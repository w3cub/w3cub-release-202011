
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Building for Production - Vite - W3cubDocs</title>
  
  <meta name="description" content="When it is time to deploy your app for production, simply run the vite build command. By default, it uses &#60;root&#62;&#47;index.html as the build &hellip;">
  <meta name="keywords" content="building, for, production, vite">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/vite/guide/build.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-c8f743fc70bb84079c3cf4b71f5f99835529659c30689b2fd6193651a680f383ef1d96896f8966c7ca8a0160ffd557685bb8ad12820ec6002d60143812238086.css">
  <script type="text/javascript" src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js"></script>
  <script src="/json/vite.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/vite/" class="_nav-link" title="" style="margin-left:0;">Vite</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _simple">
				
				
<h1 id="building-for-production" tabindex="-1">Building for Production </h1>
<p>When it is time to deploy your app for production, simply run the <code>vite build</code> command. By default, it uses <code>&lt;root&gt;/index.html</code> as the build entry point, and produces an application bundle that is suitable to be served over a static hosting service. Check out the <a href="static-deploy">Deploying a Static Site</a> for guides about popular services.</p>
<h2 id="browser-compatibility" tabindex="-1">Browser Compatibility </h2>
<p>The production bundle assumes support for modern JavaScript. By default, Vite targets browsers which support the <a href="https://caniuse.com/es6-module" target="_blank" rel="noreferrer">native ES Modules</a>, <a href="https://caniuse.com/es6-module-dynamic-import" target="_blank" rel="noreferrer">native ESM dynamic import</a>, and <a href="https://caniuse.com/mdn-javascript_operators_import_meta" target="_blank" rel="noreferrer"><code>import.meta</code></a>:</p>
<ul>
<li>Chrome &gt;=87</li>
<li>Firefox &gt;=78</li>
<li>Safari &gt;=14</li>
<li>Edge &gt;=88</li>
</ul>
<p>You can specify custom targets via the <a href="../config/build-options#build-target"><code>build.target</code> config option</a>, where the lowest target is <code>es2015</code>.</p>
<p>Note that by default, Vite only handles syntax transforms and <strong>does not cover polyfills</strong>. You can check out <a href="https://polyfill.io/" target="_blank" rel="noreferrer">Polyfill.io</a> which is a service that automatically generates polyfill bundles based on the user's browser UserAgent string.</p>
<p>Legacy browsers can be supported via <a href="https://github.com/vitejs/vite/tree/main/packages/plugin-legacy" target="_blank" rel="noreferrer">@vitejs/plugin-legacy</a>, which will automatically generate legacy chunks and corresponding ES language feature polyfills. The legacy chunks are conditionally loaded only in browsers that do not have native ESM support.</p>
<h2 id="public-base-path" tabindex="-1">Public Base Path </h2>
<ul><li>Related: <a href="assets">Asset Handling</a>
</li></ul>
<p>If you are deploying your project under a nested public path, simply specify the <a href="../config/shared-options#base"><code>base</code> config option</a> and all asset paths will be rewritten accordingly. This option can also be specified as a command line flag, e.g. <code>vite build --base=/my/public/path/</code>.</p>
<p>JS-imported asset URLs, CSS <code>url()</code> references, and asset references in your <code>.html</code> files are all automatically adjusted to respect this option during build.</p>
<p>The exception is when you need to dynamically concatenate URLs on the fly. In this case, you can use the globally injected <code>import.meta.env.BASE_URL</code> variable which will be the public base path. Note this variable is statically replaced during build so it must appear exactly as-is (i.e. <code>import.meta.env['BASE_URL']</code> won't work).</p>
<p>For advanced base path control, check out <a href="#advanced-base-options">Advanced Base Options</a>.</p>
<h2 id="customizing-the-build" tabindex="-1">Customizing the Build </h2>
<p>The build can be customized via various <a href="../config/build-options">build config options</a>. Specifically, you can directly adjust the underlying <a href="https://rollupjs.org/configuration-options/" target="_blank" rel="noreferrer">Rollup options</a> via <code>build.rollupOptions</code>:</p>
<div class="language-js vp-adaptive-theme">
<span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">// vite.config.js
export default defineConfig({
  build: {
    rollupOptions: {
      // https://rollupjs.org/configuration-options/
    },
  },
})</pre>
</div>
<p>For example, you can specify multiple Rollup outputs with plugins that are only applied during build.</p>
<h2 id="chunking-strategy" tabindex="-1">Chunking Strategy </h2>
<p>You can configure how chunks are split using <code>build.rollupOptions.output.manualChunks</code> (see <a href="https://rollupjs.org/configuration-options/#output-manualchunks" target="_blank" rel="noreferrer">Rollup docs</a>). Until Vite 2.8, the default chunking strategy divided the chunks into <code>index</code> and <code>vendor</code>. It is a good strategy for some SPAs, but it is hard to provide a general solution for every Vite target use case. From Vite 2.9, <code>manualChunks</code> is no longer modified by default. You can continue to use the Split Vendor Chunk strategy by adding the <code>splitVendorChunkPlugin</code> in your config file:</p>
<div class="language-js vp-adaptive-theme">
<span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">// vite.config.js
import { splitVendorChunkPlugin } from 'vite'
export default defineConfig({
  plugins: [splitVendorChunkPlugin()],
})</pre>
</div>
<p>This strategy is also provided as a <code>splitVendorChunk({ cache: SplitVendorChunkCache })</code> factory, in case composition with custom logic is needed. <code>cache.reset()</code> needs to be called at <code>buildStart</code> for build watch mode to work correctly in this case.</p>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>You should use <code>build.rollupOptions.output.manualChunks</code> function form when using this plugin. If the object form is used, the plugin won't have any effect.</p>
</div>
<h2 id="rebuild-on-files-changes" tabindex="-1">Rebuild on files changes </h2>
<p>You can enable rollup watcher with <code>vite build --watch</code>. Or, you can directly adjust the underlying <a href="https://rollupjs.org/configuration-options/#watch" target="_blank" rel="noreferrer"><code>WatcherOptions</code></a> via <code>build.watch</code>:</p>
<div class="language-js vp-adaptive-theme">
<span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">// vite.config.js
export default defineConfig({
  build: {
    watch: {
      // https://rollupjs.org/configuration-options/#watch
    },
  },
})</pre>
</div>
<p>With the <code>--watch</code> flag enabled, changes to the <code>vite.config.js</code>, as well as any files to be bundled, will trigger a rebuild.</p>
<h2 id="multi-page-app" tabindex="-1">Multi-Page App </h2>
<p>Suppose you have the following source code structure:</p>
<div class="language- vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">├── package.json
├── vite.config.js
├── index.html
├── main.js
└── nested
    ├── index.html
    └── nested.js</pre>
</div>
<p>During dev, simply navigate or link to <code>/nested/</code> - it works as expected, just like for a normal static file server.</p>
<p>During build, all you need to do is to specify multiple <code>.html</code> files as entry points:</p>
<div class="language-js vp-adaptive-theme">
<span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">// vite.config.js
import { resolve } from 'path'
import { defineConfig } from 'vite'

export default defineConfig({
  build: {
    rollupOptions: {
      input: {
        main: resolve(__dirname, 'index.html'),
        nested: resolve(__dirname, 'nested/index.html'),
      },
    },
  },
})</pre>
</div>
<p>If you specify a different root, remember that <code>__dirname</code> will still be the folder of your vite.config.js file when resolving the input paths. Therefore, you will need to add your <code>root</code> entry to the arguments for <code>resolve</code>.</p>
<p>Note that for HTML files, Vite ignores the name given to the entry in the <code>rollupOptions.input</code> object and instead respects the resolved id of the file when generating the HTML asset in the dist folder. This ensures a consistent structure with the way the dev server works.</p>
<h2 id="library-mode" tabindex="-1">Library Mode </h2>
<p>When you are developing a browser-oriented library, you are likely spending most of the time on a test/demo page that imports your actual library. With Vite, you can use your <code>index.html</code> for that purpose to get the smooth development experience.</p>
<p>When it is time to bundle your library for distribution, use the <a href="../config/build-options#build-lib"><code>build.lib</code> config option</a>. Make sure to also externalize any dependencies that you do not want to bundle into your library, e.g. <code>vue</code> or <code>react</code>:</p>
<div class="language-js vp-adaptive-theme">
<span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">// vite.config.js
import { resolve } from 'path'
import { defineConfig } from 'vite'

export default defineConfig({
  build: {
    lib: {
      // Could also be a dictionary or array of multiple entry points
      entry: resolve(__dirname, 'lib/main.js'),
      name: 'MyLib',
      // the proper extensions will be added
      fileName: 'my-lib',
    },
    rollupOptions: {
      // make sure to externalize deps that shouldn't be bundled
      // into your library
      external: ['vue'],
      output: {
        // Provide global variables to use in the UMD build
        // for externalized deps
        globals: {
          vue: 'Vue',
        },
      },
    },
  },
})</pre>
</div>
<p>The entry file would contain exports that can be imported by users of your package:</p>
<div class="language-js vp-adaptive-theme">
<span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">// lib/main.js
import Foo from './Foo.vue'
import Bar from './Bar.vue'
export { Foo, Bar }</pre>
</div>
<p>Running <code>vite build</code> with this config uses a Rollup preset that is oriented towards shipping libraries and produces two bundle formats: <code>es</code> and <code>umd</code> (configurable via <code>build.lib</code>):</p>
<div class="language- vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">$ vite build
building for production...
dist/my-lib.js      0.08 kB / gzip: 0.07 kB
dist/my-lib.umd.cjs 0.30 kB / gzip: 0.16 kB</pre>
</div>
<p>Recommended <code>package.json</code> for your lib:</p>
<div class="language-json vp-adaptive-theme">
<span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">{
  "name": "my-lib",
  "type": "module",
  "files": ["dist"],
  "main": "./dist/my-lib.umd.cjs",
  "module": "./dist/my-lib.js",
  "exports": {
    ".": {
      "import": "./dist/my-lib.js",
      "require": "./dist/my-lib.umd.cjs"
    }
  }
}</pre>
</div>
<p>Or, if exposing multiple entry points:</p>
<div class="language-json vp-adaptive-theme">
<span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">{
  "name": "my-lib",
  "type": "module",
  "files": ["dist"],
  "main": "./dist/my-lib.cjs",
  "module": "./dist/my-lib.js",
  "exports": {
    ".": {
      "import": "./dist/my-lib.js",
      "require": "./dist/my-lib.cjs"
    },
    "./secondary": {
      "import": "./dist/secondary.js",
      "require": "./dist/secondary.cjs"
    }
  }
}</pre>
</div>
<div class="tip custom-block">
<strong class="custom-block-title">File Extensions</strong><p>If the <code>package.json</code> does not contain <code>"type": "module"</code>, Vite will generate different file extensions for Node.js compatibility. <code>.js</code> will become <code>.mjs</code> and <code>.cjs</code> will become <code>.js</code>.</p>
</div>
<div class="tip custom-block">
<strong class="custom-block-title">Environment Variables</strong><p>In library mode, all <a href="env-and-mode"><code>import.meta.env.*</code></a> usage are statically replaced when building for production. However, <code>process.env.*</code> usage are not, so that consumers of your library can dynamically change it. If this is undesirable, you can use <code>define: { 'process.env.NODE_ENV': '"production"' }</code> for example to statically replace them, or use <a href="https://github.com/benmccann/esm-env" target="_blank" rel="noreferrer"><code>esm-env</code></a> for better compatibility with bundlers and runtimes.</p>
</div>
<div class="warning custom-block">
<strong class="custom-block-title">Advanced Usage</strong><p>Library mode includes a simple and opinionated configuration for browser-oriented and JS framework libraries. If you are building non-browser libraries, or require advanced build flows, you can use <a href="https://rollupjs.org" target="_blank" rel="noreferrer">Rollup</a> or <a href="https://esbuild.github.io" target="_blank" rel="noreferrer">esbuild</a> directly.</p>
</div>
<h2 id="advanced-base-options" tabindex="-1">Advanced Base Options </h2>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>This feature is experimental. <a href="https://github.com/vitejs/vite/discussions/13834" target="_blank" rel="noreferrer">Give Feedback</a>.</p>
</div>
<p>For advanced use cases, the deployed assets and public files may be in different paths, for example to use different cache strategies. A user may choose to deploy in three different paths:</p>
<ul>
<li>The generated entry HTML files (which may be processed during SSR)</li>
<li>The generated hashed assets (JS, CSS, and other file types like images)</li>
<li>The copied <a href="assets#the-public-directory">public files</a>
</li>
</ul>
<p>A single static <a href="#public-base-path">base</a> isn't enough in these scenarios. Vite provides experimental support for advanced base options during build, using <code>experimental.renderBuiltUrl</code>.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">experimental: {
  renderBuiltUrl(filename: string, { hostType }: { hostType: 'js' | 'css' | 'html' }) {
    if (hostType === 'js') {
      return { runtime: `window.__toCdnUrl(${JSON.stringify(filename)})` }
    } else {
      return { relative: true }
    }
  }
}</pre>
</div>
<p>If the hashed assets and public files aren't deployed together, options for each group can be defined independently using asset <code>type</code> included in the second <code>context</code> param given to the function.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">experimental: {
  renderBuiltUrl(filename: string, { hostId, hostType, type }: { hostId: string, hostType: 'js' | 'css' | 'html', type: 'public' | 'asset' }) {
    if (type === 'public') {
      return 'https://www.domain.com/' + filename
    }
    else if (path.extname(hostId) === '.js') {
      return { runtime: `window.__assetsPath(${JSON.stringify(filename)})` }
    }
    else {
      return 'https://cdn.domain.com/assets/' + filename
    }
  }
}</pre>
</div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2019–present, Yuxi (Evan) You and Vite contributors<br>Licensed under the MIT License.<br>
    <a href="https://vitejs.dev/guide/build" class="_attribution-link">https://vitejs.dev/guide/build</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
