
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>ActionView&#58;&#58;Helpers&#58;&#58;FormOptionsHelper - Ruby on Rails 6.0 - W3cubDocs</title>
  
  <meta name="description" content=" Provides a number of methods for turning different kinds of containers into a set of option tags. ">
  <meta name="keywords" content="module, actionview, helpers, formoptionshelper, ruby, on, rails, rails~6.0">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/rails~6.0/actionview/helpers/formoptionshelper.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/rails~6.0.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/rails~6.0/" class="_nav-link" title="" style="margin-left:0;">Ruby on Rails 6.0</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _rdoc">
				
				
<h1 id="module-ActionView::Helpers::FormOptionsHelper" class="module"> module ActionView::Helpers::FormOptionsHelper </h1>
<dl class="meta">
<dt>Included modules:</dt>
<dd class="meta-includes"><a class="include" href="texthelper">ActionView::Helpers::TextHelper</a></dd>
</dl> <section class="description"> <p>Provides a number of methods for turning different kinds of containers into a set of option tags.</p> <p>The <code>collection_select</code>, <code>select</code> and <code>time_zone_select</code> methods take an <code>options</code> parameter, a hash:</p> <ul>
<li> <p><code>:include_blank</code> - set to true or a prompt string if the first option element of the select element is a blank. Useful if there is not a default value required for the select element.</p> <pre class="ruby" data-language="ruby">select("post", "category", Post::CATEGORIES, { include_blank: true })
</pre> <p>could become:</p> <pre>&lt;select name="post[category]" id="post_category"&gt;
  &lt;option value=""&gt;&lt;/option&gt;
  &lt;option value="joke"&gt;joke&lt;/option&gt;
  &lt;option value="poem"&gt;poem&lt;/option&gt;
&lt;/select&gt;</pre> <p>Another common case is a select tag for a <code>belongs_to</code>-associated object.</p> <p>Example with <code>@post.person_id =&gt; 2</code>:</p> <pre class="ruby" data-language="ruby">select("post", "person_id", Person.all.collect { |p| [ p.name, p.id ] }, { include_blank: 'None' })
</pre> <p>could become:</p> <pre>&lt;select name="post[person_id]" id="post_person_id"&gt;
  &lt;option value=""&gt;None&lt;/option&gt;
  &lt;option value="1"&gt;David&lt;/option&gt;
  &lt;option value="2" selected="selected"&gt;Eileen&lt;/option&gt;
  &lt;option value="3"&gt;Rafael&lt;/option&gt;
&lt;/select&gt;</pre> </li>
<li> <p><code>:prompt</code> - set to true or a prompt string. When the select element doesn't have a value yet, this prepends an option with a generic prompt – “Please select” – or the given prompt string.</p> <pre class="ruby" data-language="ruby">select("post", "person_id", Person.all.collect { |p| [ p.name, p.id ] }, { prompt: 'Select Person' })
</pre> <p>could become:</p> <pre>&lt;select name="post[person_id]" id="post_person_id"&gt;
  &lt;option value=""&gt;Select Person&lt;/option&gt;
  &lt;option value="1"&gt;David&lt;/option&gt;
  &lt;option value="2"&gt;Eileen&lt;/option&gt;
  &lt;option value="3"&gt;Rafael&lt;/option&gt;
&lt;/select&gt;</pre> </li>
<li> <p><code>:index</code> - like the other form helpers, <code>select</code> can accept an <code>:index</code> option to manually set the ID used in the resulting output. Unlike other helpers, <code>select</code> expects this option to be in the <code>html_options</code> parameter.</p> <pre class="ruby" data-language="ruby">select("album[]", "genre", %w[rap rock country], {}, { index: nil })
</pre> <p>becomes:</p> <pre>&lt;select name="album[][genre]" id="album__genre"&gt;
  &lt;option value="rap"&gt;rap&lt;/option&gt;
  &lt;option value="rock"&gt;rock&lt;/option&gt;
  &lt;option value="country"&gt;country&lt;/option&gt;
&lt;/select&gt;</pre> </li>
<li> <p><code>:disabled</code> - can be a single value or an array of values that will be disabled options in the final output.</p> <pre class="ruby" data-language="ruby">select("post", "category", Post::CATEGORIES, { disabled: 'restricted' })
</pre> <p>could become:</p> <pre>&lt;select name="post[category]" id="post_category"&gt;
  &lt;option value=""&gt;&lt;/option&gt;
  &lt;option value="joke"&gt;joke&lt;/option&gt;
  &lt;option value="poem"&gt;poem&lt;/option&gt;
  &lt;option disabled="disabled" value="restricted"&gt;restricted&lt;/option&gt;
&lt;/select&gt;</pre> <p>When used with the <code>collection_select</code> helper, <code>:disabled</code> can also be a Proc that identifies those options that should be disabled.</p> <pre class="ruby" data-language="ruby">collection_select(:post, :category_id, Category.all, :id, :name, { disabled: -&gt; (category) { category.archived? } })
</pre> <p>If the categories “2008 stuff” and “Christmas” return true when the method <code>archived?</code> is called, this would return:</p> <pre>&lt;select name="post[category_id]" id="post_category_id"&gt;
  &lt;option value="1" disabled="disabled"&gt;2008 stuff&lt;/option&gt;
  &lt;option value="2" disabled="disabled"&gt;Christmas&lt;/option&gt;
  &lt;option value="3"&gt;Jokes&lt;/option&gt;
  &lt;option value="4"&gt;Poems&lt;/option&gt;
&lt;/select&gt;</pre> </li>
</ul> </section> <section id="5Buntitled-5D" class="documentation-section"> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-collection_check_boxes"> <span class="method-name">collection_check_boxes</span><span class="method-args">(object, method, collection, value_method, text_method, options = {}, html_options = {}, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="collection_check_boxes-source"> <pre class="ruby" data-language="ruby"># File actionview/lib/action_view/helpers/form_options_helper.rb, line 757
def collection_check_boxes(object, method, collection, value_method, text_method, options = {}, html_options = {}, &amp;block)
  Tags::CollectionCheckBoxes.new(object, method, self, collection, value_method, text_method, options, html_options).render(&amp;block)
end</pre> </div> <p>Returns check box tags for the collection of existing return values of <code>method</code> for <code>object</code>'s class. The value returned from calling <code>method</code> on the instance <code>object</code> will be selected. If calling <code>method</code> returns <code>nil</code>, no selection is made.</p> <p>The <code>:value_method</code> and <code>:text_method</code> parameters are methods to be called on each member of <code>collection</code>. The return values are used as the <code>value</code> attribute and contents of each check box tag, respectively. They can also be any object that responds to <code>call</code>, such as a <code>proc</code>, that will be called for each member of the <code>collection</code> to retrieve the value/text.</p> <p>Example object structure for use with this method:</p> <pre class="ruby" data-language="ruby">class Post &lt; ActiveRecord::Base
  has_and_belongs_to_many :authors
end
class Author &lt; ActiveRecord::Base
  has_and_belongs_to_many :posts
  def name_with_initial
    "#{first_name.first}. #{last_name}"
  end
end
</pre> <p>Sample usage (selecting the associated Author for an instance of Post, <code>@post</code>):</p> <pre class="ruby" data-language="ruby">collection_check_boxes(:post, :author_ids, Author.all, :id, :name_with_initial)
</pre> <p>If <code>@post.author_ids</code> is already <code>[1]</code>, this would return:</p> <pre>&lt;input id="post_author_ids_1" name="post[author_ids][]" type="checkbox" value="1" checked="checked" /&gt;
&lt;label for="post_author_ids_1"&gt;D. Heinemeier Hansson&lt;/label&gt;
&lt;input id="post_author_ids_2" name="post[author_ids][]" type="checkbox" value="2" /&gt;
&lt;label for="post_author_ids_2"&gt;D. Thomas&lt;/label&gt;
&lt;input id="post_author_ids_3" name="post[author_ids][]" type="checkbox" value="3" /&gt;
&lt;label for="post_author_ids_3"&gt;M. Clark&lt;/label&gt;
&lt;input name="post[author_ids][]" type="hidden" value="" /&gt;</pre> <p>It is also possible to customize the way the elements will be shown by giving a block to the method:</p> <pre class="ruby" data-language="ruby">collection_check_boxes(:post, :author_ids, Author.all, :id, :name_with_initial) do |b|
  b.label { b.check_box }
end
</pre> <p>The argument passed to the block is a special kind of builder for this collection, which has the ability to generate the label and check box for the current item in the collection, with proper text and value. Using it, you can change the label and check box display order or even use the label as wrapper, as in the example above.</p> <p>The builder methods <code>label</code> and <code>check_box</code> also accept extra HTML options:</p> <pre class="ruby" data-language="ruby">collection_check_boxes(:post, :author_ids, Author.all, :id, :name_with_initial) do |b|
  b.label(class: "check_box") { b.check_box(class: "check_box") }
end
</pre> <p>There are also three special methods available: <code>object</code>, <code>text</code> and <code>value</code>, which are the current item being rendered, its text and value methods, respectively. You can use them like this:</p> <pre class="ruby" data-language="ruby">collection_check_boxes(:post, :author_ids, Author.all, :id, :name_with_initial) do |b|
   b.label(:"data-value" =&gt; b.value) { b.check_box + b.text }
end
</pre> <h4 id="method-i-collection_check_boxes-label-Gotcha">Gotcha</h4> <p>When no selection is made for a collection of checkboxes most web browsers will not send any value.</p> <p>For example, if we have a <code>User</code> model with <code>category_ids</code> field and we have the following code in our update action:</p> <pre class="ruby" data-language="ruby">@user.update(params[:user])
</pre> <p>If no <code>category_ids</code> are selected then we can safely assume this field will not be updated.</p> <p>This is possible thanks to a hidden field generated by the helper method for every collection of checkboxes. This hidden field is given the same field name as the checkboxes with a blank value.</p> <p>In the rare case you don't want this hidden field, you can pass the <code>include_hidden: false</code> option to the helper method.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-collection_radio_buttons"> <span class="method-name">collection_radio_buttons</span><span class="method-args">(object, method, collection, value_method, text_method, options = {}, html_options = {}, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="collection_radio_buttons-source"> <pre class="ruby" data-language="ruby"># File actionview/lib/action_view/helpers/form_options_helper.rb, line 673
def collection_radio_buttons(object, method, collection, value_method, text_method, options = {}, html_options = {}, &amp;block)
  Tags::CollectionRadioButtons.new(object, method, self, collection, value_method, text_method, options, html_options).render(&amp;block)
end</pre> </div> <p>Returns radio button tags for the collection of existing return values of <code>method</code> for <code>object</code>'s class. The value returned from calling <code>method</code> on the instance <code>object</code> will be selected. If calling <code>method</code> returns <code>nil</code>, no selection is made.</p> <p>The <code>:value_method</code> and <code>:text_method</code> parameters are methods to be called on each member of <code>collection</code>. The return values are used as the <code>value</code> attribute and contents of each radio button tag, respectively. They can also be any object that responds to <code>call</code>, such as a <code>proc</code>, that will be called for each member of the <code>collection</code> to retrieve the value/text.</p> <p>Example object structure for use with this method:</p> <pre class="ruby" data-language="ruby">class Post &lt; ActiveRecord::Base
  belongs_to :author
end
class Author &lt; ActiveRecord::Base
  has_many :posts
  def name_with_initial
    "#{first_name.first}. #{last_name}"
  end
end
</pre> <p>Sample usage (selecting the associated Author for an instance of Post, <code>@post</code>):</p> <pre class="ruby" data-language="ruby">collection_radio_buttons(:post, :author_id, Author.all, :id, :name_with_initial)
</pre> <p>If <code>@post.author_id</code> is already <code>1</code>, this would return:</p> <pre>&lt;input id="post_author_id_1" name="post[author_id]" type="radio" value="1" checked="checked" /&gt;
&lt;label for="post_author_id_1"&gt;D. Heinemeier Hansson&lt;/label&gt;
&lt;input id="post_author_id_2" name="post[author_id]" type="radio" value="2" /&gt;
&lt;label for="post_author_id_2"&gt;D. Thomas&lt;/label&gt;
&lt;input id="post_author_id_3" name="post[author_id]" type="radio" value="3" /&gt;
&lt;label for="post_author_id_3"&gt;M. Clark&lt;/label&gt;</pre> <p>It is also possible to customize the way the elements will be shown by giving a block to the method:</p> <pre class="ruby" data-language="ruby">collection_radio_buttons(:post, :author_id, Author.all, :id, :name_with_initial) do |b|
  b.label { b.radio_button }
end
</pre> <p>The argument passed to the block is a special kind of builder for this collection, which has the ability to generate the label and radio button for the current item in the collection, with proper text and value. Using it, you can change the label and radio button display order or even use the label as wrapper, as in the example above.</p> <p>The builder methods <code>label</code> and <code>radio_button</code> also accept extra HTML options:</p> <pre class="ruby" data-language="ruby">collection_radio_buttons(:post, :author_id, Author.all, :id, :name_with_initial) do |b|
  b.label(class: "radio_button") { b.radio_button(class: "radio_button") }
end
</pre> <p>There are also three special methods available: <code>object</code>, <code>text</code> and <code>value</code>, which are the current item being rendered, its text and value methods, respectively. You can use them like this:</p> <pre class="ruby" data-language="ruby">collection_radio_buttons(:post, :author_id, Author.all, :id, :name_with_initial) do |b|
   b.label(:"data-value" =&gt; b.value) { b.radio_button + b.text }
end
</pre> <h4 id="method-i-collection_radio_buttons-label-Gotcha">Gotcha</h4> <p>The HTML specification says when nothing is selected on a collection of radio buttons web browsers do not send any value to server. Unfortunately this introduces a gotcha: if a <code>User</code> model has a <code>category_id</code> field and in the form no category is selected, no <code>category_id</code> parameter is sent. So, any strong parameters idiom like:</p> <pre>params.require(:user).permit(...)</pre> <p>will raise an error since no <code>{user: ...}</code> will be present.</p> <p>To prevent this the helper generates an auxiliary hidden field before every collection of radio buttons. The hidden field has the same name as collection radio button and blank value.</p> <p>In case if you don't want the helper to generate this hidden field you can specify <code>include_hidden: false</code> option.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-collection_select"> <span class="method-name">collection_select</span><span class="method-args">(object, method, collection, value_method, text_method, options = {}, html_options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="collection_select-source"> <pre class="ruby" data-language="ruby"># File actionview/lib/action_view/helpers/form_options_helper.rb, line 203
def collection_select(object, method, collection, value_method, text_method, options = {}, html_options = {})
  Tags::CollectionSelect.new(object, method, self, collection, value_method, text_method, options, html_options).render
end</pre> </div> <p>Returns <code>&lt;select&gt;</code> and <code>&lt;option&gt;</code> tags for the collection of existing return values of <code>method</code> for <code>object</code>'s class. The value returned from calling <code>method</code> on the instance <code>object</code> will be selected. If calling <code>method</code> returns <code>nil</code>, no selection is made without including <code>:prompt</code> or <code>:include_blank</code> in the <code>options</code> hash.</p> <p>The <code>:value_method</code> and <code>:text_method</code> parameters are methods to be called on each member of <code>collection</code>. The return values are used as the <code>value</code> attribute and contents of each <code>&lt;option&gt;</code> tag, respectively. They can also be any object that responds to <code>call</code>, such as a <code>proc</code>, that will be called for each member of the <code>collection</code> to retrieve the value/text.</p> <p>Example object structure for use with this method:</p> <pre class="ruby" data-language="ruby">class Post &lt; ActiveRecord::Base
  belongs_to :author
end

class Author &lt; ActiveRecord::Base
  has_many :posts
  def name_with_initial
    "#{first_name.first}. #{last_name}"
  end
end
</pre> <p>Sample usage (selecting the associated Author for an instance of Post, <code>@post</code>):</p> <pre class="ruby" data-language="ruby">collection_select(:post, :author_id, Author.all, :id, :name_with_initial, prompt: true)
</pre> <p>If <code>@post.author_id</code> is already <code>1</code>, this would return:</p> <pre>&lt;select name="post[author_id]" id="post_author_id"&gt;
  &lt;option value=""&gt;Please select&lt;/option&gt;
  &lt;option value="1" selected="selected"&gt;D. Heinemeier Hansson&lt;/option&gt;
  &lt;option value="2"&gt;D. Thomas&lt;/option&gt;
  &lt;option value="3"&gt;M. Clark&lt;/option&gt;
&lt;/select&gt;</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-grouped_collection_select"> <span class="method-name">grouped_collection_select</span><span class="method-args">(object, method, collection, group_method, group_label_method, option_key_method, option_value_method, options = {}, html_options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="grouped_collection_select-source"> <pre class="ruby" data-language="ruby"># File actionview/lib/action_view/helpers/form_options_helper.rb, line 263
def grouped_collection_select(object, method, collection, group_method, group_label_method, option_key_method, option_value_method, options = {}, html_options = {})
  Tags::GroupedCollectionSelect.new(object, method, self, collection, group_method, group_label_method, option_key_method, option_value_method, options, html_options).render
end</pre> </div> <p>Returns <code>&lt;select&gt;</code>, <code>&lt;optgroup&gt;</code> and <code>&lt;option&gt;</code> tags for the collection of existing return values of <code>method</code> for <code>object</code>'s class. The value returned from calling <code>method</code> on the instance <code>object</code> will be selected. If calling <code>method</code> returns <code>nil</code>, no selection is made without including <code>:prompt</code> or <code>:include_blank</code> in the <code>options</code> hash.</p> <p>Parameters:</p> <ul>
<li> <p><code>object</code> - The instance of the class to be used for the select tag</p> </li>
<li> <p><code>method</code> - The attribute of <code>object</code> corresponding to the select tag</p> </li>
<li> <p><code>collection</code> - An array of objects representing the <code>&lt;optgroup&gt;</code> tags.</p> </li>
<li> <p><code>group_method</code> - The name of a method which, when called on a member of <code>collection</code>, returns an array of child objects representing the <code>&lt;option&gt;</code> tags. It can also be any object that responds to <code>call</code>, such as a <code>proc</code>, that will be called for each member of the <code>collection</code> to retrieve the value.</p> </li>
<li> <p><code>group_label_method</code> - The name of a method which, when called on a member of <code>collection</code>, returns a string to be used as the <code>label</code> attribute for its <code>&lt;optgroup&gt;</code> tag. It can also be any object that responds to <code>call</code>, such as a <code>proc</code>, that will be called for each member of the <code>collection</code> to retrieve the label.</p> </li>
<li> <p><code>option_key_method</code> - The name of a method which, when called on a child object of a member of <code>collection</code>, returns a value to be used as the <code>value</code> attribute for its <code>&lt;option&gt;</code> tag.</p> </li>
<li> <p><code>option_value_method</code> - The name of a method which, when called on a child object of a member of <code>collection</code>, returns a value to be used as the contents of its <code>&lt;option&gt;</code> tag.</p> </li>
</ul> <p>Example object structure for use with this method:</p> <pre class="ruby" data-language="ruby">class Continent &lt; ActiveRecord::Base
  has_many :countries
  # attribs: id, name
end

class Country &lt; ActiveRecord::Base
  belongs_to :continent
  # attribs: id, name, continent_id
end

class City &lt; ActiveRecord::Base
  belongs_to :country
  # attribs: id, name, country_id
end
</pre> <p>Sample usage:</p> <pre class="ruby" data-language="ruby">grouped_collection_select(:city, :country_id, @continents, :countries, :name, :id, :name)
</pre> <p>Possible output:</p> <pre>&lt;select name="city[country_id]" id="city_country_id"&gt;
  &lt;optgroup label="Africa"&gt;
    &lt;option value="1"&gt;South Africa&lt;/option&gt;
    &lt;option value="3"&gt;Somalia&lt;/option&gt;
  &lt;/optgroup&gt;
  &lt;optgroup label="Europe"&gt;
    &lt;option value="7" selected="selected"&gt;Denmark&lt;/option&gt;
    &lt;option value="2"&gt;Ireland&lt;/option&gt;
  &lt;/optgroup&gt;
&lt;/select&gt;</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-grouped_options_for_select"> <span class="method-name">grouped_options_for_select</span><span class="method-args">(grouped_options, selected_key = nil, options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="grouped_options_for_select-source"> <pre class="ruby" data-language="ruby"># File actionview/lib/action_view/helpers/form_options_helper.rb, line 531
def grouped_options_for_select(grouped_options, selected_key = nil, options = {})
  prompt  = options[:prompt]
  divider = options[:divider]

  body = "".html_safe

  if prompt
    body.safe_concat content_tag("option", prompt_text(prompt), value: "")
  end

  grouped_options.each do |container|
    html_attributes = option_html_attributes(container)

    if divider
      label = divider
    else
      label, container = container
    end

    html_attributes = { label: label }.merge!(html_attributes)
    body.safe_concat content_tag("optgroup", options_for_select(container, selected_key), html_attributes)
  end

  body
end</pre> </div> <p>Returns a string of <code>&lt;option&gt;</code> tags, like <code>options_for_select</code>, but wraps them with <code>&lt;optgroup&gt;</code> tags:</p> <pre class="ruby" data-language="ruby">grouped_options = [
 ['North America',
   [['United States','US'],'Canada']],
 ['Europe',
   ['Denmark','Germany','France']]
]
grouped_options_for_select(grouped_options)

grouped_options = {
  'North America' =&gt; [['United States','US'], 'Canada'],
  'Europe' =&gt; ['Denmark','Germany','France']
}
grouped_options_for_select(grouped_options)
</pre> <p>Possible output:</p> <pre>&lt;optgroup label="North America"&gt;
  &lt;option value="US"&gt;United States&lt;/option&gt;
  &lt;option value="Canada"&gt;Canada&lt;/option&gt;
&lt;/optgroup&gt;
&lt;optgroup label="Europe"&gt;
  &lt;option value="Denmark"&gt;Denmark&lt;/option&gt;
  &lt;option value="Germany"&gt;Germany&lt;/option&gt;
  &lt;option value="France"&gt;France&lt;/option&gt;
&lt;/optgroup&gt;</pre> <p>Parameters:</p> <ul>
<li> <p><code>grouped_options</code> - Accepts a nested array or hash of strings. The first value serves as the <code>&lt;optgroup&gt;</code> label while the second value must be an array of options. The second value can be a nested array of text-value pairs. See <code>options_for_select</code> for more info.</p> <pre>Ex. ["North America",[["United States","US"],["Canada","CA"]]]</pre> </li>
<li> <p><code>selected_key</code> - A value equal to the <code>value</code> attribute for one of the <code>&lt;option&gt;</code> tags, which will have the <code>selected</code> attribute set. Note: It is possible for this value to match multiple options as you might have the same option in multiple groups. Each will then get <code>selected="selected"</code>.</p> </li>
</ul> <p>Options:</p> <ul>
<li> <p><code>:prompt</code> - set to true or a prompt string. When the select element doesn't have a value yet, this prepends an option with a generic prompt - “Please select” - or the given prompt string.</p> </li>
<li> <p><code>:divider</code> - the divider for the options groups.</p> <pre class="ruby" data-language="ruby">grouped_options = [
  [['United States','US'], 'Canada'],
  ['Denmark','Germany','France']
]
grouped_options_for_select(grouped_options, nil, divider: '---------')
</pre> <p>Possible output:</p> <pre>&lt;optgroup label="---------"&gt;
  &lt;option value="US"&gt;United States&lt;/option&gt;
  &lt;option value="Canada"&gt;Canada&lt;/option&gt;
&lt;/optgroup&gt;
&lt;optgroup label="---------"&gt;
  &lt;option value="Denmark"&gt;Denmark&lt;/option&gt;
  &lt;option value="Germany"&gt;Germany&lt;/option&gt;
  &lt;option value="France"&gt;France&lt;/option&gt;
&lt;/optgroup&gt;</pre> </li>
</ul> <p><strong>Note:</strong> Only the <code>&lt;optgroup&gt;</code> and <code>&lt;option&gt;</code> tags are returned, so you still have to wrap the output in an appropriate <code>&lt;select&gt;</code> tag.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-option_groups_from_collection_for_select"> <span class="method-name">option_groups_from_collection_for_select</span><span class="method-args">(collection, group_method, group_label_method, option_key_method, option_value_method, selected_key = nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="option_groups_from_collection_for_select-source"> <pre class="ruby" data-language="ruby"># File actionview/lib/action_view/helpers/form_options_helper.rb, line 461
def option_groups_from_collection_for_select(collection, group_method, group_label_method, option_key_method, option_value_method, selected_key = nil)
  collection.map do |group|
    option_tags = options_from_collection_for_select(
      value_for_collection(group, group_method), option_key_method, option_value_method, selected_key)

    content_tag("optgroup", option_tags, label: value_for_collection(group, group_label_method))
  end.join.html_safe
end</pre> </div> <p>Returns a string of <code>&lt;option&gt;</code> tags, like <code>options_from_collection_for_select</code>, but groups them by <code>&lt;optgroup&gt;</code> tags based on the object relationships of the arguments.</p> <p>Parameters:</p> <ul>
<li> <p><code>collection</code> - An array of objects representing the <code>&lt;optgroup&gt;</code> tags.</p> </li>
<li> <p><code>group_method</code> - The name of a method which, when called on a member of <code>collection</code>, returns an array of child objects representing the <code>&lt;option&gt;</code> tags.</p> </li>
<li> <p><code>group_label_method</code> - The name of a method which, when called on a member of <code>collection</code>, returns a string to be used as the <code>label</code> attribute for its <code>&lt;optgroup&gt;</code> tag.</p> </li>
<li> <p><code>option_key_method</code> - The name of a method which, when called on a child object of a member of <code>collection</code>, returns a value to be used as the <code>value</code> attribute for its <code>&lt;option&gt;</code> tag.</p> </li>
<li> <p><code>option_value_method</code> - The name of a method which, when called on a child object of a member of <code>collection</code>, returns a value to be used as the contents of its <code>&lt;option&gt;</code> tag.</p> </li>
<li> <p><code>selected_key</code> - A value equal to the <code>value</code> attribute for one of the <code>&lt;option&gt;</code> tags, which will have the <code>selected</code> attribute set. Corresponds to the return value of one of the calls to <code>option_key_method</code>. If <code>nil</code>, no selection is made. Can also be a hash if disabled values are to be specified.</p> </li>
</ul> <p>Example object structure for use with this method:</p> <pre class="ruby" data-language="ruby">class Continent &lt; ActiveRecord::Base
  has_many :countries
  # attribs: id, name
end

class Country &lt; ActiveRecord::Base
  belongs_to :continent
  # attribs: id, name, continent_id
end
</pre> <p>Sample usage:</p> <pre class="ruby" data-language="ruby">option_groups_from_collection_for_select(@continents, :countries, :name, :id, :name, 3)
</pre> <p>Possible output:</p> <pre>&lt;optgroup label="Africa"&gt;
  &lt;option value="1"&gt;Egypt&lt;/option&gt;
  &lt;option value="4"&gt;Rwanda&lt;/option&gt;
  ...
&lt;/optgroup&gt;
&lt;optgroup label="Asia"&gt;
  &lt;option value="3" selected="selected"&gt;China&lt;/option&gt;
  &lt;option value="12"&gt;India&lt;/option&gt;
  &lt;option value="5"&gt;Japan&lt;/option&gt;
  ...
&lt;/optgroup&gt;</pre> <p><strong>Note:</strong> Only the <code>&lt;optgroup&gt;</code> and <code>&lt;option&gt;</code> tags are returned, so you still have to wrap the output in an appropriate <code>&lt;select&gt;</code> tag.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-options_for_select"> <span class="method-name">options_for_select</span><span class="method-args">(container, selected = nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="options_for_select-source"> <pre class="ruby" data-language="ruby"># File actionview/lib/action_view/helpers/form_options_helper.rb, line 357
def options_for_select(container, selected = nil)
  return container if String === container

  selected, disabled = extract_selected_and_disabled(selected).map do |r|
    Array(r).map(&amp;:to_s)
  end

  container.map do |element|
    html_attributes = option_html_attributes(element)
    text, value = option_text_and_value(element).map(&amp;:to_s)

    html_attributes[:selected] ||= option_value_selected?(value, selected)
    html_attributes[:disabled] ||= disabled &amp;&amp; option_value_selected?(value, disabled)
    html_attributes[:value] = value

    tag_builder.content_tag_string(:option, text, html_attributes)
  end.join("\n").html_safe
end</pre> </div> <p>Accepts a container (hash, array, enumerable, your type) and returns a string of option tags. Given a container where the elements respond to first and last (such as a two-element array), the “lasts” serve as option values and the “firsts” as option text. Hashes are turned into this form automatically, so the keys become “firsts” and values become lasts. If <code>selected</code> is specified, the matching “last” or element will get the selected option-tag. <code>selected</code> may also be an array of values to be selected when using a multiple select.</p> <pre class="ruby" data-language="ruby">options_for_select([["Dollar", "$"], ["Kroner", "DKK"]])
# =&gt; &lt;option value="$"&gt;Dollar&lt;/option&gt;
# =&gt; &lt;option value="DKK"&gt;Kroner&lt;/option&gt;

options_for_select([ "VISA", "MasterCard" ], "MasterCard")
# =&gt; &lt;option value="VISA"&gt;VISA&lt;/option&gt;
# =&gt; &lt;option selected="selected" value="MasterCard"&gt;MasterCard&lt;/option&gt;

options_for_select({ "Basic" =&gt; "$20", "Plus" =&gt; "$40" }, "$40")
# =&gt; &lt;option value="$20"&gt;Basic&lt;/option&gt;
# =&gt; &lt;option value="$40" selected="selected"&gt;Plus&lt;/option&gt;

options_for_select([ "VISA", "MasterCard", "Discover" ], ["VISA", "Discover"])
# =&gt; &lt;option selected="selected" value="VISA"&gt;VISA&lt;/option&gt;
# =&gt; &lt;option value="MasterCard"&gt;MasterCard&lt;/option&gt;
# =&gt; &lt;option selected="selected" value="Discover"&gt;Discover&lt;/option&gt;
</pre> <p>You can optionally provide HTML attributes as the last element of the array.</p> <pre class="ruby" data-language="ruby">options_for_select([ "Denmark", ["USA", { class: 'bold' }], "Sweden" ], ["USA", "Sweden"])
# =&gt; &lt;option value="Denmark"&gt;Denmark&lt;/option&gt;
# =&gt; &lt;option value="USA" class="bold" selected="selected"&gt;USA&lt;/option&gt;
# =&gt; &lt;option value="Sweden" selected="selected"&gt;Sweden&lt;/option&gt;

options_for_select([["Dollar", "$", { class: "bold" }], ["Kroner", "DKK", { onclick: "alert('HI');" }]])
# =&gt; &lt;option value="$" class="bold"&gt;Dollar&lt;/option&gt;
# =&gt; &lt;option value="DKK" onclick="alert('HI');"&gt;Kroner&lt;/option&gt;
</pre> <p>If you wish to specify disabled option tags, set <code>selected</code> to be a hash, with <code>:disabled</code> being either a value or array of values to be disabled. In this case, you can use <code>:selected</code> to specify selected option tags.</p> <pre class="ruby" data-language="ruby">options_for_select(["Free", "Basic", "Advanced", "Super Platinum"], disabled: "Super Platinum")
# =&gt; &lt;option value="Free"&gt;Free&lt;/option&gt;
# =&gt; &lt;option value="Basic"&gt;Basic&lt;/option&gt;
# =&gt; &lt;option value="Advanced"&gt;Advanced&lt;/option&gt;
# =&gt; &lt;option value="Super Platinum" disabled="disabled"&gt;Super Platinum&lt;/option&gt;

options_for_select(["Free", "Basic", "Advanced", "Super Platinum"], disabled: ["Advanced", "Super Platinum"])
# =&gt; &lt;option value="Free"&gt;Free&lt;/option&gt;
# =&gt; &lt;option value="Basic"&gt;Basic&lt;/option&gt;
# =&gt; &lt;option value="Advanced" disabled="disabled"&gt;Advanced&lt;/option&gt;
# =&gt; &lt;option value="Super Platinum" disabled="disabled"&gt;Super Platinum&lt;/option&gt;

options_for_select(["Free", "Basic", "Advanced", "Super Platinum"], selected: "Free", disabled: "Super Platinum")
# =&gt; &lt;option value="Free" selected="selected"&gt;Free&lt;/option&gt;
# =&gt; &lt;option value="Basic"&gt;Basic&lt;/option&gt;
# =&gt; &lt;option value="Advanced"&gt;Advanced&lt;/option&gt;
# =&gt; &lt;option value="Super Platinum" disabled="disabled"&gt;Super Platinum&lt;/option&gt;
</pre> <p>NOTE: Only the option tags are returned, you have to wrap this call in a regular HTML select tag.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-options_from_collection_for_select"> <span class="method-name">options_from_collection_for_select</span><span class="method-args">(collection, value_method, text_method, selected = nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="options_from_collection_for_select-source"> <pre class="ruby" data-language="ruby"># File actionview/lib/action_view/helpers/form_options_helper.rb, line 400
def options_from_collection_for_select(collection, value_method, text_method, selected = nil)
  options = collection.map do |element|
    [value_for_collection(element, text_method), value_for_collection(element, value_method), option_html_attributes(element)]
  end
  selected, disabled = extract_selected_and_disabled(selected)
  select_deselect = {
    selected: extract_values_from_collection(collection, value_method, selected),
    disabled: extract_values_from_collection(collection, value_method, disabled)
  }

  options_for_select(options, select_deselect)
end</pre> </div> <p>Returns a string of option tags that have been compiled by iterating over the <code>collection</code> and assigning the result of a call to the <code>value_method</code> as the option value and the <code>text_method</code> as the option text.</p> <pre class="ruby" data-language="ruby">options_from_collection_for_select(@people, 'id', 'name')
# =&gt; &lt;option value="#{person.id}"&gt;#{person.name}&lt;/option&gt;
</pre> <p>This is more often than not used inside a select_tag like this example:</p> <pre class="ruby" data-language="ruby">select_tag 'person', options_from_collection_for_select(@people, 'id', 'name')
</pre> <p>If <code>selected</code> is specified as a value or array of values, the element(s) returning a match on <code>value_method</code> will be selected option tag(s).</p> <p>If <code>selected</code> is specified as a Proc, those members of the collection that return true for the anonymous function are the selected values.</p> <p><code>selected</code> can also be a hash, specifying both <code>:selected</code> and/or <code>:disabled</code> values as required.</p> <p>Be sure to specify the same class as the <code>value_method</code> when specifying selected or disabled options. Failure to do this will produce undesired results. Example:</p> <pre class="ruby" data-language="ruby">options_from_collection_for_select(@people, 'id', 'name', '1')
</pre> <p>Will not select a person with the id of 1 because 1 (an <a href="../../integer">Integer</a>) is not the same as '1' (a string)</p> <pre class="ruby" data-language="ruby">options_from_collection_for_select(@people, 'id', 'name', 1)
</pre> <p>should produce the desired results.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-select"> <span class="method-name">select</span><span class="method-args">(object, method, choices = nil, options = {}, html_options = {}, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="select-source"> <pre class="ruby" data-language="ruby"># File actionview/lib/action_view/helpers/form_options_helper.rb, line 164
def select(object, method, choices = nil, options = {}, html_options = {}, &amp;block)
  Tags::Select.new(object, method, self, choices, options, html_options, &amp;block).render
end</pre> </div> <p>Create a select tag and a series of contained option tags for the provided object and method. The option currently held by the object will be selected, provided that the object is available.</p> <p>There are two possible formats for the <code>choices</code> parameter, corresponding to other helpers' output:</p> <ul>
<li> <p>A flat collection (see <code>options_for_select</code>).</p> </li>
<li> <p>A nested collection (see <code>grouped_options_for_select</code>).</p> </li>
</ul> <p>For example:</p> <pre class="ruby" data-language="ruby">select("post", "person_id", Person.all.collect { |p| [ p.name, p.id ] }, { include_blank: true })
</pre> <p>would become:</p> <pre>&lt;select name="post[person_id]" id="post_person_id"&gt;
  &lt;option value=""&gt;&lt;/option&gt;
  &lt;option value="1" selected="selected"&gt;David&lt;/option&gt;
  &lt;option value="2"&gt;Eileen&lt;/option&gt;
  &lt;option value="3"&gt;Rafael&lt;/option&gt;
&lt;/select&gt;</pre> <p>assuming the associated person has ID 1.</p> <p>This can be used to provide a default set of options in the standard way: before rendering the create form, a new model instance is assigned the default options and bound to @model_name. Usually this model is not saved to the database. Instead, a second model object is created when the create request is received. This allows the user to submit a form page more than once with the expected results of creating multiple records. In addition, this allows a single partial to be used to generate form inputs for both edit and create forms.</p> <p>By default, <code>post.person_id</code> is the selected option. Specify <code>selected: value</code> to use a different selection or <code>selected: nil</code> to leave all options unselected. Similarly, you can specify values to be disabled in the option tags by specifying the <code>:disabled</code> option. This can either be a single value or an array of values to be disabled.</p> <p>A block can be passed to <code>select</code> to customize how the options tags will be rendered. This is useful when the options tag has complex attributes.</p> <pre class="ruby" data-language="ruby">select(report, "campaign_ids") do
  available_campaigns.each do |c|
    content_tag(:option, c.name, value: c.id, data: { tags: c.tags.to_json })
  end
end
</pre> <h4 id="method-i-select-label-Gotcha">Gotcha</h4> <p>The HTML specification says when <code>multiple</code> parameter passed to select and all options got deselected web browsers do not send any value to server. Unfortunately this introduces a gotcha: if an <code>User</code> model has many <code>roles</code> and have <code>role_ids</code> accessor, and in the form that edits roles of the user the user deselects all roles from <code>role_ids</code> multiple select box, no <code>role_ids</code> parameter is sent. So, any mass-assignment idiom like</p> <pre class="ruby" data-language="ruby">@user.update(params[:user])
</pre> <p>wouldn't update roles.</p> <p>To prevent this the helper generates an auxiliary hidden field before every multiple select. The hidden field has the same name as multiple select and blank value.</p> <p><strong>Note:</strong> The client either sends only the hidden field (representing the deselected multiple select box), or both fields. This means that the resulting array always contains a blank string.</p> <p>In case if you don't want the helper to generate this hidden field you can specify <code>include_hidden: false</code> option.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-time_zone_options_for_select"> <span class="method-name">time_zone_options_for_select</span><span class="method-args">(selected = nil, priority_zones = nil, model = ::ActiveSupport::TimeZone)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="time_zone_options_for_select-source"> <pre class="ruby" data-language="ruby"># File actionview/lib/action_view/helpers/form_options_helper.rb, line 576
def time_zone_options_for_select(selected = nil, priority_zones = nil, model = ::ActiveSupport::TimeZone)
  zone_options = "".html_safe

  zones = model.all
  convert_zones = lambda { |list| list.map { |z| [ z.to_s, z.name ] } }

  if priority_zones
    if priority_zones.is_a?(Regexp)
      priority_zones = zones.select { |z| z =~ priority_zones }
    end

    zone_options.safe_concat options_for_select(convert_zones[priority_zones], selected)
    zone_options.safe_concat content_tag("option", "-------------", value: "", disabled: true)
    zone_options.safe_concat "\n"

    zones = zones - priority_zones
  end

  zone_options.safe_concat options_for_select(convert_zones[zones], selected)
end</pre> </div> <p>Returns a string of option tags for pretty much any time zone in the world. Supply an <a href="../../activesupport/timezone">ActiveSupport::TimeZone</a> name as <code>selected</code> to have it marked as the selected option tag. You can also supply an array of <a href="../../activesupport/timezone">ActiveSupport::TimeZone</a> objects as <code>priority_zones</code>, so that they will be listed above the rest of the (long) list. (You can use <a href="../../activesupport/timezone#method-c-us_zones">ActiveSupport::TimeZone.us_zones</a> as a convenience for obtaining a list of the US time zones, or a Regexp to select the zones of your choice)</p> <p>The <code>selected</code> parameter must be either <code>nil</code>, or a string that names an <a href="../../activesupport/timezone">ActiveSupport::TimeZone</a>.</p> <p>By default, <code>model</code> is the <a href="../../activesupport/timezone">ActiveSupport::TimeZone</a> constant (which can be obtained in Active Record as a value object). The <code>model</code> parameter must respond to <code>all</code> and return an array of objects that represent time zones; each object must respond to <code>name</code>. If a Regexp is given it will attempt to match the zones using the &lt;code&gt;=~&lt;code&gt; operator.</p> <p>NOTE: Only the option tags are returned, you have to wrap this call in a regular HTML select tag.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-time_zone_select"> <span class="method-name">time_zone_select</span><span class="method-args">(object, method, priority_zones = nil, options = {}, html_options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="time_zone_select-source"> <pre class="ruby" data-language="ruby"># File actionview/lib/action_view/helpers/form_options_helper.rb, line 297
def time_zone_select(object, method, priority_zones = nil, options = {}, html_options = {})
  Tags::TimeZoneSelect.new(object, method, self, priority_zones, options, html_options).render
end</pre> </div> <p>Returns select and option tags for the given object and method, using <a href="formoptionshelper#method-i-time_zone_options_for_select">time_zone_options_for_select</a> to generate the list of option tags.</p> <p>In addition to the <code>:include_blank</code> option documented above, this method also supports a <code>:model</code> option, which defaults to <a href="../../activesupport/timezone">ActiveSupport::TimeZone</a>. This may be used by users to specify a different time zone model object. (See <code>time_zone_options_for_select</code> for more information.)</p> <p>You can also supply an array of <a href="../../activesupport/timezone">ActiveSupport::TimeZone</a> objects as <code>priority_zones</code> so that they will be listed above the rest of the (long) list. You can use <a href="../../activesupport/timezone#method-c-us_zones">ActiveSupport::TimeZone.us_zones</a> for a list of US time zones, <a href="../../activesupport/timezone#method-c-country_zones">ActiveSupport::TimeZone.country_zones</a> for another country's time zones, or a Regexp to select the zones of your choice.</p> <p>Finally, this method supports a <code>:default</code> option, which selects a default <a href="../../activesupport/timezone">ActiveSupport::TimeZone</a> if the object's time zone is <code>nil</code>.</p> <pre class="ruby" data-language="ruby">time_zone_select("user", "time_zone", nil, include_blank: true)

time_zone_select("user", "time_zone", nil, default: "Pacific Time (US &amp; Canada)")

time_zone_select("user", 'time_zone', ActiveSupport::TimeZone.us_zones, default: "Pacific Time (US &amp; Canada)")

time_zone_select("user", 'time_zone', [ ActiveSupport::TimeZone['Alaska'], ActiveSupport::TimeZone['Hawaii'] ])

time_zone_select("user", 'time_zone', /Australia/)

time_zone_select("user", "time_zone", ActiveSupport::TimeZone.all.sort, model: ActiveSupport::TimeZone)
</pre>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    © 2004–2019 David Heinemeier Hansson<br>Licensed under the MIT License.<br>
    
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
