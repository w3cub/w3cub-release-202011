
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Struct - Ruby 2.7 - W3cubDocs</title>
  
  <meta name="description" content=" A Struct is a convenient way to bundle a number of attributes together, using accessor methods, without having to write an explicit class. ">
  <meta name="keywords" content="class, struct, ruby, ruby~2.7">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/ruby~2.7/struct.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/ruby~2.7.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/ruby~2.7/" class="_nav-link" title="" style="margin-left:0;">Ruby 2.7</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _rdoc">
				
				
<h1 id="class-Struct" class="class"> class Struct </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="object">Object</a></dd>
<dt>Included modules:</dt>
<dd class="meta-includes"><a class="include" href="enumerable">Enumerable</a></dd>
</dl> <section class="description"> <p>A <a href="struct"><code>Struct</code></a> is a convenient way to bundle a number of attributes together, using accessor methods, without having to write an explicit class.</p> <p>The <a href="struct"><code>Struct</code></a> class generates new subclasses that hold a set of members and their values. For each member a reader and writer method is created similar to <a href="module#method-i-attr_accessor"><code>Module#attr_accessor</code></a>.</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address) do
  def greeting
    "Hello #{name}!"
  end
end

dave = Customer.new("Dave", "123 Main")
dave.name     #=&gt; "Dave"
dave.greeting #=&gt; "Hello Dave!"
</pre> <p>See <a href="struct#method-c-new"><code>Struct::new</code></a> for further examples of creating struct subclasses and instances.</p> <p>In the method descriptions that follow, a “member” parameter refers to a struct member which is either a quoted string (<code>"name"</code>) or a <a href="symbol"><code>Symbol</code></a> (<code>:name</code>).</p> </section> <section id="5Buntitled-5D" class="documentation-section"> <section class="constants-list"> <header> <h3>Constants</h3> </header> <dl> <dt id="Group">Group </dt>
<dd>
<p><a href="struct#Group"><code>Group</code></a></p> <p><a href="struct#Group"><code>Group</code></a> is a <a href="struct"><code>Struct</code></a> that is only available when compiled with <code>HAVE_GETGRENT</code>.</p> <p>The struct contains the following members:</p> <dl class="rdoc-list note-list">
<dt>name </dt>
<dd> <p>contains the name of the group as a <a href="string"><code>String</code></a>.</p> </dd>
<dt>passwd </dt>
<dd> <p>contains the encrypted password as a <a href="string"><code>String</code></a>. An 'x' is returned if password access to the group is not available; an empty string is returned if no password is needed to obtain membership of the group.</p> <p>Must be compiled with <code>HAVE_STRUCT_GROUP_GR_PASSWD</code>.</p> </dd>
<dt>gid </dt>
<dd> <p>contains the group's numeric ID as an integer.</p> </dd>
<dt>mem </dt>
<dd> <p>is an <a href="array"><code>Array</code></a> of Strings containing the short login names of the members of the group.</p> </dd>
</dl> </dd>
<dt id="Passwd">Passwd </dt>
<dd>
<p><a href="struct#Passwd"><code>Passwd</code></a></p> <p><a href="struct#Passwd"><code>Passwd</code></a> is a <a href="struct"><code>Struct</code></a> that contains the following members:</p> <dl class="rdoc-list note-list">
<dt>name </dt>
<dd> <p>contains the short login name of the user as a <a href="string"><code>String</code></a>.</p> </dd>
<dt>passwd </dt>
<dd> <p>contains the encrypted password of the user as a <a href="string"><code>String</code></a>. an 'x' is returned if shadow passwords are in use. An '*' is returned if the user cannot log in using a password.</p> </dd>
<dt>uid </dt>
<dd> <p>contains the integer user ID (uid) of the user.</p> </dd>
<dt>gid </dt>
<dd> <p>contains the integer group ID (gid) of the user's primary group.</p> </dd>
<dt>dir </dt>
<dd> <p>contains the path to the home directory of the user as a <a href="string"><code>String</code></a>.</p> </dd>
<dt>shell </dt>
<dd> <p>contains the path to the login shell of the user as a <a href="string"><code>String</code></a>.</p> </dd>
</dl> <h3 id="label-The+following+members+below+are+optional-2C+and+must+be+compiled+with+special+flags-3A">The following members below are optional, and must be compiled with special flags:</h3> <dl class="rdoc-list note-list">
<dt>gecos </dt>
<dd> <p>contains a longer <a href="string"><code>String</code></a> description of the user, such as a full name. Some Unix systems provide structured information in the gecos field, but this is system-dependent. must be compiled with <code>HAVE_STRUCT_PASSWD_PW_GECOS</code></p> </dd>
<dt>change </dt>
<dd> <p>password change time(integer) must be compiled with <code>HAVE_STRUCT_PASSWD_PW_CHANGE</code></p> </dd>
<dt>quota </dt>
<dd> <p>quota value(integer) must be compiled with <code>HAVE_STRUCT_PASSWD_PW_QUOTA</code></p> </dd>
<dt>age </dt>
<dd> <p>password age(integer) must be compiled with <code>HAVE_STRUCT_PASSWD_PW_AGE</code></p> </dd>
<dt>class </dt>
<dd> <p>user access class(string) must be compiled with <code>HAVE_STRUCT_PASSWD_PW_CLASS</code></p> </dd>
<dt>comment </dt>
<dd> <p>comment(string) must be compiled with <code>HAVE_STRUCT_PASSWD_PW_COMMENT</code></p> </dd>
<dt>expire </dt>
<dd> <p>account expiration time(integer) must be compiled with <code>HAVE_STRUCT_PASSWD_PW_EXPIRE</code></p> </dd>
</dl> </dd>
<dt id="Tms">Tms </dt>
<dd>
<p><a href="struct#Tms"><code>Tms</code></a> for backward compatibility</p> </dd>
</dl> </section> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-c-json_create"> <span class="method-name">json_create</span><span class="method-args">(object)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="json_create-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/add/struct.rb, line 10
def self.json_create(object)
  new(*object['v'])
end</pre> </div> <p>Deserializes <a href="json"><code>JSON</code></a> string by constructing new <a href="struct"><code>Struct</code></a> object with values <code>v</code> serialized by <code>to_json</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-new"> <span class="method-callseq"> new([class_name] [, member_name]+) → StructClass </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> new([class_name] [, member_name]+, keyword_init: true) → StructClass </span> </div> <div class="method-heading"> <span class="method-callseq"> new([class_name] [, member_name]+) {|StructClass| block } → StructClass </span> </div> <div class="method-heading"> <span class="method-callseq"> new(value, ...) → object </span> </div> <div class="method-heading"> <span class="method-callseq"> StructClass[value, ...] → object </span> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="c" data-language="c">static VALUE
rb_struct_s_def(int argc, VALUE *argv, VALUE klass)
{
    VALUE name, rest, keyword_init = Qfalse;
    long i;
    VALUE st;
    st_table *tbl;

    rb_check_arity(argc, 1, UNLIMITED_ARGUMENTS);
    name = argv[0];
    if (SYMBOL_P(name)) {
        name = Qnil;
    }
    else {
        --argc;
        ++argv;
    }

    if (RB_TYPE_P(argv[argc-1], T_HASH)) {
        static ID keyword_ids[1];

        if (!keyword_ids[0]) {
            keyword_ids[0] = rb_intern("keyword_init");
        }
        rb_get_kwargs(argv[argc-1], keyword_ids, 0, 1, &amp;keyword_init);
        if (keyword_init == Qundef) {
            keyword_init = Qfalse;
        }
        --argc;
    }

    rest = rb_ident_hash_new();
    RBASIC_CLEAR_CLASS(rest);
    tbl = RHASH_TBL(rest);
    for (i=0; i&lt;argc; i++) {
        VALUE mem = rb_to_symbol(argv[i]);
        if (rb_is_attrset_sym(mem)) {
            rb_raise(rb_eArgError, "invalid struct member: %"PRIsVALUE, mem);
        }
        if (st_insert(tbl, mem, Qtrue)) {
            rb_raise(rb_eArgError, "duplicate member: %"PRIsVALUE, mem);
        }
    }
    rest = rb_hash_keys(rest);
    st_clear(tbl);
    RBASIC_CLEAR_CLASS(rest);
    OBJ_FREEZE_RAW(rest);
    if (NIL_P(name)) {
        st = anonymous_struct(klass);
    }
    else {
        st = new_struct(name, klass);
    }
    setup_struct(st, rest);
    rb_ivar_set(st, id_keyword_init, keyword_init);
    if (rb_block_given_p()) {
        rb_mod_module_eval(0, 0, st);
    }

    return st;
}</pre> </div> <p>The first two forms are used to create a new <a href="struct"><code>Struct</code></a> subclass <code>class_name</code> that can contain a value for each <code>member_name</code>. This subclass can be used to create instances of the structure like any other <a href="class"><code>Class</code></a>.</p> <p>If the <code>class_name</code> is omitted an anonymous structure class will be created. Otherwise, the name of this struct will appear as a constant in class <a href="struct"><code>Struct</code></a>, so it must be unique for all Structs in the system and must start with a capital letter. Assigning a structure class to a constant also gives the class the name of the constant.</p> <pre class="ruby" data-language="ruby"># Create a structure with a name under Struct
Struct.new("Customer", :name, :address)
#=&gt; Struct::Customer
Struct::Customer.new("Dave", "123 Main")
#=&gt; #&lt;struct Struct::Customer name="Dave", address="123 Main"&gt;

# Create a structure named by its constant
Customer = Struct.new(:name, :address)
#=&gt; Customer
Customer.new("Dave", "123 Main")
#=&gt; #&lt;struct Customer name="Dave", address="123 Main"&gt;
</pre> <p>If the optional <code>keyword_init</code> keyword argument is set to <code>true</code>, .new takes keyword arguments instead of normal arguments.</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address, keyword_init: true)
Customer.new(name: "Dave", address: "123 Main")
#=&gt; #&lt;struct Customer name="Dave", address="123 Main"&gt;
</pre> <p>If a block is given it will be evaluated in the context of <code>StructClass</code>, passing the created class as a parameter:</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address) do
  def greeting
    "Hello #{name}!"
  end
end
Customer.new("Dave", "123 Main").greeting  #=&gt; "Hello Dave!"
</pre> <p>This is the recommended way to customize a struct. Subclassing an anonymous struct creates an extra anonymous class that will never be used.</p> <p>The last two forms create a new instance of a struct subclass. The number of <code>value</code> parameters must be less than or equal to the number of attributes defined for the structure. Unset parameters default to <code>nil</code>. Passing more parameters than number of attributes will raise an <a href="argumenterror"><code>ArgumentError</code></a>.</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address)
Customer.new("Dave", "123 Main")
#=&gt; #&lt;struct Customer name="Dave", address="123 Main"&gt;
Customer["Dave"]
#=&gt; #&lt;struct Customer name="Dave", address=nil&gt;
</pre>  </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-3D-3D"> <span class="method-callseq"> struct == other → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="3D-3D-source"> <pre class="c" data-language="c">static VALUE
rb_struct_equal(VALUE s, VALUE s2)
{
    if (s == s2) return Qtrue;
    if (!RB_TYPE_P(s2, T_STRUCT)) return Qfalse;
    if (rb_obj_class(s) != rb_obj_class(s2)) return Qfalse;
    if (RSTRUCT_LEN(s) != RSTRUCT_LEN(s2)) {
        rb_bug("inconsistent struct"); /* should never happen */
    }

    return rb_exec_recursive_paired(recursive_equal, s, s2, s2);
}</pre> </div> <p>Equality—Returns <code>true</code> if <code>other</code> has the same struct subclass and has equal member values (according to Object#==).</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address, :zip)
joe   = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
joejr = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
jane  = Customer.new("Jane Doe", "456 Elm, Anytown NC", 12345)
joe == joejr   #=&gt; true
joe == jane    #=&gt; false
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-5B-5D"> <span class="method-callseq"> struct[member] → object </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> struct[index] → object </span> </div> <div class="method-description">
<div class="method-source-code" id="5B-5D-source"> <pre class="c" data-language="c">VALUE
rb_struct_aref(VALUE s, VALUE idx)
{
    int i = rb_struct_pos(s, &amp;idx);
    if (i &lt; 0) invalid_struct_pos(s, idx);
    return RSTRUCT_GET(s, i);
}</pre> </div> <p>Attribute Reference—Returns the value of the given struct <code>member</code> or the member at the given <code>index</code>. Raises <a href="nameerror"><code>NameError</code></a> if the <code>member</code> does not exist and <a href="indexerror"><code>IndexError</code></a> if the <code>index</code> is out of range.</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address, :zip)
joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)

joe["name"]   #=&gt; "Joe Smith"
joe[:name]    #=&gt; "Joe Smith"
joe[0]        #=&gt; "Joe Smith"
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-5B-5D-3D"> <span class="method-callseq"> struct[member] = obj → obj </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> struct[index] = obj → obj </span> </div> <div class="method-description">
<div class="method-source-code" id="5B-5D-3D-source"> <pre class="c" data-language="c">VALUE
rb_struct_aset(VALUE s, VALUE idx, VALUE val)
{
    int i = rb_struct_pos(s, &amp;idx);
    if (i &lt; 0) invalid_struct_pos(s, idx);
    rb_struct_modify(s);
    RSTRUCT_SET(s, i, val);
    return val;
}</pre> </div> <p>Attribute Assignment—Sets the value of the given struct <code>member</code> or the member at the given <code>index</code>. Raises <a href="nameerror"><code>NameError</code></a> if the <code>member</code> does not exist and <a href="indexerror"><code>IndexError</code></a> if the <code>index</code> is out of range.</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address, :zip)
joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)

joe["name"] = "Luke"
joe[:zip]   = "90210"

joe.name   #=&gt; "Luke"
joe.zip    #=&gt; "90210"
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-as_json"> <span class="method-name">as_json</span><span class="method-args">(*)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="as_json-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/add/struct.rb, line 16
def as_json(*)
  klass = self.class.name
  klass.to_s.empty? and raise JSON::JSONError, "Only named structs are supported!"
  {
    JSON.create_id =&gt; klass,
    'v'            =&gt; values,
  }
end</pre> </div> <p>Returns a hash, that will be turned into a <a href="json"><code>JSON</code></a> object and represent this object.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-deconstruct"> <span class="method-callseq"> to_a → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> values → array </span> </div> <div class="method-description">
<div class="method-source-code" id="deconstruct-source"> <pre class="c" data-language="c">static VALUE
rb_struct_to_a(VALUE s)
{
    return rb_ary_new4(RSTRUCT_LEN(s), RSTRUCT_CONST_PTR(s));
}</pre> </div> <p>Returns the values for this struct as an <a href="array"><code>Array</code></a>.</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address, :zip)
joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
joe.to_a[1]   #=&gt; "123 Maple, Anytown NC"
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-deconstruct_keys"> <span class="method-name">deconstruct_keys</span><span class="method-args">(p1)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="deconstruct_keys-source"> <pre class="c" data-language="c">static VALUE
rb_struct_deconstruct_keys(VALUE s, VALUE keys)
{
    VALUE h;
    long i;

    if (NIL_P(keys)) {
        return rb_struct_to_h(s);
    }
    if (UNLIKELY(!RB_TYPE_P(keys, T_ARRAY))) {
        rb_raise(rb_eTypeError,
                 "wrong argument type %"PRIsVALUE" (expected Array or nil)",
                 rb_obj_class(keys));

    }
    if (RSTRUCT_LEN(s) &lt; RARRAY_LEN(keys)) {
        return rb_hash_new_with_size(0);
    }
    h = rb_hash_new_with_size(RARRAY_LEN(keys));
    for (i=0; i&lt;RARRAY_LEN(keys); i++) {
        VALUE key = RARRAY_AREF(keys, i);
        int i = rb_struct_pos(s, &amp;key);
        if (i &lt; 0) {
            return h;
        }
        rb_hash_aset(h, key, RSTRUCT_GET(s, i));
    }
    return h;
}</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-dig"> <span class="method-callseq"> dig(key, ...) → object </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="dig-source"> <pre class="c" data-language="c">static VALUE
rb_struct_dig(int argc, VALUE *argv, VALUE self)
{
    rb_check_arity(argc, 1, UNLIMITED_ARGUMENTS);
    self = rb_struct_lookup(self, *argv);
    if (!--argc) return self;
    ++argv;
    return rb_obj_dig(argc, argv, self, Qnil);
}</pre> </div> <p>Extracts the nested value specified by the sequence of <code>key</code> objects by calling <code>dig</code> at each step, returning <code>nil</code> if any intermediate step is <code>nil</code>.</p> <pre class="ruby" data-language="ruby">Foo = Struct.new(:a)
f = Foo.new(Foo.new({b: [1, 2, 3]}))

f.dig(:a, :a, :b, 0)    # =&gt; 1
f.dig(:b, 0)            # =&gt; nil
f.dig(:a, :a, :b, :c)   # TypeError: no implicit conversion of Symbol into Integer
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-each"> <span class="method-callseq"> each {|obj| block } → struct </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> each → enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="each-source"> <pre class="c" data-language="c">static VALUE
rb_struct_each(VALUE s)
{
    long i;

    RETURN_SIZED_ENUMERATOR(s, 0, 0, struct_enum_size);
    for (i=0; i&lt;RSTRUCT_LEN(s); i++) {
        rb_yield(RSTRUCT_GET(s, i));
    }
    return s;
}</pre> </div> <p>Yields the value of each struct member in order. If no block is given an enumerator is returned.</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address, :zip)
joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
joe.each {|x| puts(x) }
</pre> <p>Produces:</p> <pre>Joe Smith
123 Maple, Anytown NC
12345</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-each_pair"> <span class="method-callseq"> each_pair {|sym, obj| block } → struct </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> each_pair → enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="each_pair-source"> <pre class="c" data-language="c">static VALUE
rb_struct_each_pair(VALUE s)
{
    VALUE members;
    long i;

    RETURN_SIZED_ENUMERATOR(s, 0, 0, struct_enum_size);
    members = rb_struct_members(s);
    if (rb_block_arity() &gt; 1) {
        for (i=0; i&lt;RSTRUCT_LEN(s); i++) {
            VALUE key = rb_ary_entry(members, i);
            VALUE value = RSTRUCT_GET(s, i);
            rb_yield_values(2, key, value);
        }
    }
    else {
        for (i=0; i&lt;RSTRUCT_LEN(s); i++) {
            VALUE key = rb_ary_entry(members, i);
            VALUE value = RSTRUCT_GET(s, i);
            rb_yield(rb_assoc_new(key, value));
        }
    }
    return s;
}</pre> </div> <p>Yields the name and value of each struct member in order. If no block is given an enumerator is returned.</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address, :zip)
joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
joe.each_pair {|name, value| puts("#{name} =&gt; #{value}") }
</pre> <p>Produces:</p> <pre>name =&gt; Joe Smith
address =&gt; 123 Maple, Anytown NC
zip =&gt; 12345</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-eql-3F"> <span class="method-callseq"> eql?(other) → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="eql-3F-source"> <pre class="c" data-language="c">static VALUE
rb_struct_eql(VALUE s, VALUE s2)
{
    if (s == s2) return Qtrue;
    if (!RB_TYPE_P(s2, T_STRUCT)) return Qfalse;
    if (rb_obj_class(s) != rb_obj_class(s2)) return Qfalse;
    if (RSTRUCT_LEN(s) != RSTRUCT_LEN(s2)) {
        rb_bug("inconsistent struct"); /* should never happen */
    }

    return rb_exec_recursive_paired(recursive_eql, s, s2, s2);
}</pre> </div> <p><a href="hash"><code>Hash</code></a> equality—<code>other</code> and <code>struct</code> refer to the same hash key if they have the same struct subclass and have equal member values (according to <a href="object#method-i-eql-3F"><code>Object#eql?</code></a>).</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-filter"> <span class="method-callseq"> filter {|obj| block } → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> filter → enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="filter-source"> <pre class="c" data-language="c">static VALUE
rb_struct_select(int argc, VALUE *argv, VALUE s)
{
    VALUE result;
    long i;

    rb_check_arity(argc, 0, 0);
    RETURN_SIZED_ENUMERATOR(s, 0, 0, struct_enum_size);
    result = rb_ary_new();
    for (i = 0; i &lt; RSTRUCT_LEN(s); i++) {
        if (RTEST(rb_yield(RSTRUCT_GET(s, i)))) {
            rb_ary_push(result, RSTRUCT_GET(s, i));
        }
    }

    return result;
}</pre> </div> <p>Yields each member value from the struct to the block and returns an <a href="array"><code>Array</code></a> containing the member values from the <code>struct</code> for which the given block returns a true value (equivalent to <a href="enumerable#method-i-select"><code>Enumerable#select</code></a>).</p> <pre class="ruby" data-language="ruby">Lots = Struct.new(:a, :b, :c, :d, :e, :f)
l = Lots.new(11, 22, 33, 44, 55, 66)
l.select {|v| v.even? }   #=&gt; [22, 44, 66]
</pre> <p><a href="struct#method-i-filter"><code>Struct#filter</code></a> is an alias for <a href="struct#method-i-select"><code>Struct#select</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-hash"> <span class="method-callseq"> hash → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="hash-source"> <pre class="c" data-language="c">static VALUE
rb_struct_hash(VALUE s)
{
    long i, len;
    st_index_t h;
    VALUE n;

    h = rb_hash_start(rb_hash(rb_obj_class(s)));
    len = RSTRUCT_LEN(s);
    for (i = 0; i &lt; len; i++) {
        n = rb_hash(RSTRUCT_GET(s, i));
        h = rb_hash_uint(h, NUM2LONG(n));
    }
    h = rb_hash_end(h);
    return ST2FIX(h);
}</pre> </div> <p>Returns a hash value based on this struct's contents.</p> <p>See also <a href="object#method-i-hash"><code>Object#hash</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-inspect"> <span class="method-callseq"> to_s → string </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> inspect → string </span> </div> <div class="method-description">
<div class="method-source-code" id="inspect-source"> <pre class="c" data-language="c">static VALUE
rb_struct_inspect(VALUE s)
{
    return rb_exec_recursive(inspect_struct, s, 0);
}</pre> </div> <p>Returns a description of this struct as a string.</p>  </div> <div class="aliases"> Also aliased as: <a href="struct#method-i-to_s">to_s</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-length"> <span class="method-callseq"> length → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="length-source"> <pre class="c" data-language="c">VALUE
rb_struct_size(VALUE s)
{
    return LONG2FIX(RSTRUCT_LEN(s));
}</pre> </div> <p>Returns the number of struct members.</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address, :zip)
joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
joe.length   #=&gt; 3
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-members"> <span class="method-callseq"> members → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="members-source"> <pre class="c" data-language="c">static VALUE
rb_struct_members_m(VALUE obj)
{
    return rb_struct_s_members_m(rb_obj_class(obj));
}</pre> </div> <p>Returns the struct members as an array of symbols:</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address, :zip)
joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
joe.members   #=&gt; [:name, :address, :zip]
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-select"> <span class="method-callseq"> select {|obj| block } → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> select → enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="select-source"> <pre class="c" data-language="c">static VALUE
rb_struct_select(int argc, VALUE *argv, VALUE s)
{
    VALUE result;
    long i;

    rb_check_arity(argc, 0, 0);
    RETURN_SIZED_ENUMERATOR(s, 0, 0, struct_enum_size);
    result = rb_ary_new();
    for (i = 0; i &lt; RSTRUCT_LEN(s); i++) {
        if (RTEST(rb_yield(RSTRUCT_GET(s, i)))) {
            rb_ary_push(result, RSTRUCT_GET(s, i));
        }
    }

    return result;
}</pre> </div> <p>Yields each member value from the struct to the block and returns an <a href="array"><code>Array</code></a> containing the member values from the <code>struct</code> for which the given block returns a true value (equivalent to <a href="enumerable#method-i-select"><code>Enumerable#select</code></a>).</p> <pre class="ruby" data-language="ruby">Lots = Struct.new(:a, :b, :c, :d, :e, :f)
l = Lots.new(11, 22, 33, 44, 55, 66)
l.select {|v| v.even? }   #=&gt; [22, 44, 66]
</pre> <p><a href="struct#method-i-filter"><code>Struct#filter</code></a> is an alias for <a href="struct#method-i-select"><code>Struct#select</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-size"> <span class="method-callseq"> size → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="size-source"> <pre class="c" data-language="c">VALUE
rb_struct_size(VALUE s)
{
    return LONG2FIX(RSTRUCT_LEN(s));
}</pre> </div> <p>Returns the number of struct members.</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address, :zip)
joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
joe.length   #=&gt; 3
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_a"> <span class="method-callseq"> to_a → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="to_a-source"> <pre class="c" data-language="c">static VALUE
rb_struct_to_a(VALUE s)
{
    return rb_ary_new4(RSTRUCT_LEN(s), RSTRUCT_CONST_PTR(s));
}</pre> </div> <p>Returns the values for this struct as an <a href="array"><code>Array</code></a>.</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address, :zip)
joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
joe.to_a[1]   #=&gt; "123 Maple, Anytown NC"
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_h"> <span class="method-callseq"> to_h → hash </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> to_h {|name, value| block } → hash </span> </div> <div class="method-description">
<div class="method-source-code" id="to_h-source"> <pre class="c" data-language="c">static VALUE
rb_struct_to_h(VALUE s)
{
    VALUE h = rb_hash_new_with_size(RSTRUCT_LEN(s));
    VALUE members = rb_struct_members(s);
    long i;
    int block_given = rb_block_given_p();

    for (i=0; i&lt;RSTRUCT_LEN(s); i++) {
        VALUE k = rb_ary_entry(members, i), v = RSTRUCT_GET(s, i);
        if (block_given)
            rb_hash_set_pair(h, rb_yield_values(2, k, v));
        else
            rb_hash_aset(h, k, v);
    }
    return h;
}</pre> </div> <p>Returns a <a href="hash"><code>Hash</code></a> containing the names and values for the struct's members.</p> <p>If a block is given, the results of the block on each pair of the receiver will be used as pairs.</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address, :zip)
joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
joe.to_h[:address]   #=&gt; "123 Maple, Anytown NC"
joe.to_h{|name, value| [name.upcase, value.to_s.upcase]}[:ADDRESS]
                     #=&gt; "123 MAPLE, ANYTOWN NC"
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_json"> <span class="method-name">to_json</span><span class="method-args">(*args)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="to_json-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/add/struct.rb, line 27
def to_json(*args)
  as_json.to_json(*args)
end</pre> </div> <p>Stores class name (<a href="struct"><code>Struct</code></a>) with <a href="struct"><code>Struct</code></a> values <code>v</code> as a <a href="json"><code>JSON</code></a> string. Only named structs are supported.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-to_s"> <span class="method-name">to_s</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="struct#method-i-inspect">inspect</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-values"> <span class="method-callseq"> values → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="values-source"> <pre class="c" data-language="c">static VALUE
rb_struct_to_a(VALUE s)
{
    return rb_ary_new4(RSTRUCT_LEN(s), RSTRUCT_CONST_PTR(s));
}</pre> </div> <p>Returns the values for this struct as an <a href="array"><code>Array</code></a>.</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address, :zip)
joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
joe.to_a[1]   #=&gt; "123 Maple, Anytown NC"
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-values_at"> <span class="method-callseq"> values_at(selector, ...) → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="values_at-source"> <pre class="c" data-language="c">static VALUE
rb_struct_values_at(int argc, VALUE *argv, VALUE s)
{
    return rb_get_values_at(s, RSTRUCT_LEN(s), argc, argv, struct_entry);
}</pre> </div> <p>Returns the struct member values for each <code>selector</code> as an <a href="array"><code>Array</code></a>. A <code>selector</code> may be either an <a href="integer"><code>Integer</code></a> offset or a <a href="range"><code>Range</code></a> of offsets (as in <a href="array#method-i-values_at"><code>Array#values_at</code></a>).</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address, :zip)
joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
joe.values_at(0, 2)   #=&gt; ["Joe Smith", 12345]
</pre>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core © 1993–2017 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library © contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
