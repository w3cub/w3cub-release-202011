
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>StringIO - Ruby 2.7 - W3cubDocs</title>
  
  <meta name="description" content=" Pseudo I&#47;O on String object, with interface corresponding to IO. ">
  <meta name="keywords" content="class, stringio, ruby, ruby~2.7">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/ruby~2.7/stringio.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/ruby~2.7.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/ruby~2.7/" class="_nav-link" title="" style="margin-left:0;">Ruby 2.7</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _rdoc">
				
				
<h1 id="class-StringIO" class="class"> class StringIO </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><span>Data</span></dd>
<dt>Included modules:</dt>
<dd class="meta-includes">
<a class="include" href="enumerable">Enumerable</a>, <a class="include" href="io/generic_readable">IO::generic_readable</a>, <a class="include" href="io/generic_writable">IO::generic_writable</a>
</dd>
</dl> <section class="description"> <p>Pseudo I/O on <a href="string"><code>String</code></a> object, with interface corresponding to <a href="io"><code>IO</code></a>.</p> <p>Commonly used to simulate <code>$stdio</code> or <code>$stderr</code></p> <h3 id="class-StringIO-label-Examples">Examples</h3> <pre class="ruby" data-language="ruby">require 'stringio'

# Writing stream emulation
io = StringIO.new
io.puts "Hello World"
io.string #=&gt; "Hello World\n"

# Reading stream emulation
io = StringIO.new "first\nsecond\nlast\n"
io.getc #=&gt; "f"
io.gets #=&gt; "irst\n"
io.read #=&gt; "second\nlast\n"
</pre> </section> <section id="5Buntitled-5D" class="documentation-section"> <section class="constants-list"> <header> <h3>Constants</h3> </header> <dl> <dt id="VERSION">VERSION </dt>

</dl> </section> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-c-new"> <span class="method-callseq"> new(string=""[, mode]) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="c" data-language="c">static VALUE
strio_initialize(int argc, VALUE *argv, VALUE self)
{
    struct StringIO *ptr = check_strio(self);

    if (!ptr) {
        DATA_PTR(self) = ptr = strio_alloc();
    }
    rb_call_super(0, 0);
    return strio_init(argc, argv, ptr, self);
}</pre> </div> <p>Creates new <a href="stringio"><code>StringIO</code></a> instance from with <em>string</em> and <em>mode</em>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-open"> <span class="method-callseq"> open(string=""[, mode]) {|strio| ...} </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="open-source"> <pre class="c" data-language="c">static VALUE
strio_s_open(int argc, VALUE *argv, VALUE klass)
{
    VALUE obj = rb_class_new_instance_kw(argc, argv, klass, RB_PASS_CALLED_KEYWORDS);
    if (!rb_block_given_p()) return obj;
    return rb_ensure(rb_yield, obj, strio_finalize, obj);
}</pre> </div> <p>Equivalent to <a href="stringio#method-c-new"><code>StringIO.new</code></a> except that when it is called with a block, it yields with the new instance and closes it, and returns the result which returned from the block.</p>  </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-binmode"> <span class="method-callseq"> binmode → stringio </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="binmode-source"> <pre class="c" data-language="c">static VALUE
strio_binmode(VALUE self)
{
    struct StringIO *ptr = StringIO(self);
    rb_encoding *enc = rb_ascii8bit_encoding();

    ptr-&gt;enc = enc;
    if (WRITABLE(self)) {
        rb_enc_associate(ptr-&gt;string, enc);
    }
    return self;
}</pre> </div> <p>Puts stream into binary mode. See <a href="io#method-i-binmode"><code>IO#binmode</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-bytes"> <span class="method-name">bytes</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="bytes-source"> <pre class="c" data-language="c">static VALUE
strio_bytes(VALUE self)
{
    rb_warn("StringIO#bytes is deprecated; use #each_byte instead");
    if (!rb_block_given_p())
        return rb_enumeratorize(self, ID2SYM(rb_intern("each_byte")), 0, 0);
    return strio_each_byte(self);
}</pre> </div> <p>This is a deprecated alias for <a href="stringio#method-i-each_byte"><code>each_byte</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-chars"> <span class="method-name">chars</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="chars-source"> <pre class="c" data-language="c">static VALUE
strio_chars(VALUE self)
{
    rb_warn("StringIO#chars is deprecated; use #each_char instead");
    if (!rb_block_given_p())
        return rb_enumeratorize(self, ID2SYM(rb_intern("each_char")), 0, 0);
    return strio_each_char(self);
}</pre> </div> <p>This is a deprecated alias for <a href="stringio#method-i-each_char"><code>each_char</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-close"> <span class="method-callseq"> close → nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="close-source"> <pre class="c" data-language="c">static VALUE
strio_close(VALUE self)
{
    StringIO(self);
    RBASIC(self)-&gt;flags &amp;= ~STRIO_READWRITE;
    return Qnil;
}</pre> </div> <p>Closes a <a href="stringio"><code>StringIO</code></a>. The stream is unavailable for any further data operations; an <code>IOError</code> is raised if such an attempt is made.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-close_read"> <span class="method-callseq"> close_read → nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="close_read-source"> <pre class="c" data-language="c">static VALUE
strio_close_read(VALUE self)
{
    struct StringIO *ptr = StringIO(self);
    if (!(ptr-&gt;flags &amp; FMODE_READABLE)) {
        rb_raise(rb_eIOError, "closing non-duplex IO for reading");
    }
    RBASIC(self)-&gt;flags &amp;= ~STRIO_READABLE;
    return Qnil;
}</pre> </div> <p>Closes the read end of a <a href="stringio"><code>StringIO</code></a>. Will raise an <code>IOError</code> if the receiver is not readable.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-close_write"> <span class="method-callseq"> close_write → nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="close_write-source"> <pre class="c" data-language="c">static VALUE
strio_close_write(VALUE self)
{
    struct StringIO *ptr = StringIO(self);
    if (!(ptr-&gt;flags &amp; FMODE_WRITABLE)) {
        rb_raise(rb_eIOError, "closing non-duplex IO for writing");
    }
    RBASIC(self)-&gt;flags &amp;= ~STRIO_WRITABLE;
    return Qnil;
}</pre> </div> <p>Closes the write end of a <a href="stringio"><code>StringIO</code></a>. Will raise an <code>IOError</code> if the receiver is not writeable.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-closed-3F"> <span class="method-callseq"> closed? → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="closed-3F-source"> <pre class="c" data-language="c">static VALUE
strio_closed(VALUE self)
{
    StringIO(self);
    if (!CLOSED(self)) return Qfalse;
    return Qtrue;
}</pre> </div> <p>Returns <code>true</code> if the stream is completely closed, <code>false</code> otherwise.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-closed_read-3F"> <span class="method-callseq"> closed_read? → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="closed_read-3F-source"> <pre class="c" data-language="c">static VALUE
strio_closed_read(VALUE self)
{
    StringIO(self);
    if (READABLE(self)) return Qfalse;
    return Qtrue;
}</pre> </div> <p>Returns <code>true</code> if the stream is not readable, <code>false</code> otherwise.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-closed_write-3F"> <span class="method-callseq"> closed_write? → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="closed_write-3F-source"> <pre class="c" data-language="c">static VALUE
strio_closed_write(VALUE self)
{
    StringIO(self);
    if (WRITABLE(self)) return Qfalse;
    return Qtrue;
}</pre> </div> <p>Returns <code>true</code> if the stream is not writable, <code>false</code> otherwise.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-codepoints"> <span class="method-name">codepoints</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="codepoints-source"> <pre class="c" data-language="c">static VALUE
strio_codepoints(VALUE self)
{
    rb_warn("StringIO#codepoints is deprecated; use #each_codepoint instead");
    if (!rb_block_given_p())
        return rb_enumeratorize(self, ID2SYM(rb_intern("each_codepoint")), 0, 0);
    return strio_each_codepoint(self);
}</pre> </div> <p>This is a deprecated alias for <a href="stringio#method-i-each_codepoint"><code>each_codepoint</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-each"> <span class="method-callseq"> each(sep=$/, chomp: false) {|line| block } → strio </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> each(limit, chomp: false) {|line| block } → strio </span> </div> <div class="method-heading"> <span class="method-callseq"> each(sep, limit, chomp: false) {|line| block } → strio </span> </div> <div class="method-heading"> <span class="method-callseq"> each(...) → anEnumerator </span> </div> <div class="method-heading"> <span class="method-callseq"> each_line(sep=$/, chomp: false) {|line| block } → strio </span> </div> <div class="method-heading"> <span class="method-callseq"> each_line(limit, chomp: false) {|line| block } → strio </span> </div> <div class="method-heading"> <span class="method-callseq"> each_line(sep, limit, chomp: false) {|line| block } → strio </span> </div> <div class="method-heading"> <span class="method-callseq"> each_line(...) → anEnumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="each-source"> <pre class="c" data-language="c">static VALUE
strio_each(int argc, VALUE *argv, VALUE self)
{
    VALUE line;
    struct getline_arg arg;

    StringIO(self);
    RETURN_ENUMERATOR(self, argc, argv);

    if (prepare_getline_args(&amp;arg, argc, argv)-&gt;limit == 0) {
        rb_raise(rb_eArgError, "invalid limit: 0 for each_line");
    }

    while (!NIL_P(line = strio_getline(&amp;arg, readable(self)))) {
        rb_yield(line);
    }
    return self;
}</pre> </div> <p>See <a href="io#method-i-each"><code>IO#each</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-each_byte"> <span class="method-callseq"> each_byte {|byte| block } → strio </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> each_byte → anEnumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="each_byte-source"> <pre class="c" data-language="c">static VALUE
strio_each_byte(VALUE self)
{
    struct StringIO *ptr = readable(self);

    RETURN_ENUMERATOR(self, 0, 0);

    while (ptr-&gt;pos &lt; RSTRING_LEN(ptr-&gt;string)) {
        char c = RSTRING_PTR(ptr-&gt;string)[ptr-&gt;pos++];
        rb_yield(CHR2FIX(c));
    }
    return self;
}</pre> </div> <p>See <a href="io#method-i-each_byte"><code>IO#each_byte</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-each_char"> <span class="method-callseq"> each_char {|char| block } → strio </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> each_char → anEnumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="each_char-source"> <pre class="c" data-language="c">static VALUE
strio_each_char(VALUE self)
{
    VALUE c;

    RETURN_ENUMERATOR(self, 0, 0);

    while (!NIL_P(c = strio_getc(self))) {
        rb_yield(c);
    }
    return self;
}</pre> </div> <p>See <a href="io#method-i-each_char"><code>IO#each_char</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-each_codepoint"> <span class="method-callseq"> each_codepoint {|c| block } → strio </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> each_codepoint → anEnumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="each_codepoint-source"> <pre class="c" data-language="c">static VALUE
strio_each_codepoint(VALUE self)
{
    struct StringIO *ptr;
    rb_encoding *enc;
    unsigned int c;
    int n;

    RETURN_ENUMERATOR(self, 0, 0);

    ptr = readable(self);
    enc = get_enc(ptr);
    for (;;) {
        if (ptr-&gt;pos &gt;= RSTRING_LEN(ptr-&gt;string)) {
            return self;
        }

        c = rb_enc_codepoint_len(RSTRING_PTR(ptr-&gt;string)+ptr-&gt;pos,
                                 RSTRING_END(ptr-&gt;string), &amp;n, enc);
        rb_yield(UINT2NUM(c));
        ptr-&gt;pos += n;
    }
    return self;
}</pre> </div> <p>See <a href="io#method-i-each_codepoint"><code>IO#each_codepoint</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-each_line"> <span class="method-callseq"> each_line(sep=$/, chomp: false) {|line| block } → strio </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> each_line(limit, chomp: false) {|line| block } → strio </span> </div> <div class="method-heading"> <span class="method-callseq"> each_line(sep, limit, chomp: false) {|line| block } → strio </span> </div> <div class="method-heading"> <span class="method-callseq"> each_line(...) → anEnumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="each_line-source"> <pre class="c" data-language="c">static VALUE
strio_each(int argc, VALUE *argv, VALUE self)
{
    VALUE line;
    struct getline_arg arg;

    StringIO(self);
    RETURN_ENUMERATOR(self, argc, argv);

    if (prepare_getline_args(&amp;arg, argc, argv)-&gt;limit == 0) {
        rb_raise(rb_eArgError, "invalid limit: 0 for each_line");
    }

    while (!NIL_P(line = strio_getline(&amp;arg, readable(self)))) {
        rb_yield(line);
    }
    return self;
}</pre> </div> <p>See <a href="io#method-i-each"><code>IO#each</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-eof"> <span class="method-callseq"> eof → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> eof? → true or false </span> </div> <div class="method-description">
<div class="method-source-code" id="eof-source"> <pre class="c" data-language="c">static VALUE
strio_eof(VALUE self)
{
    struct StringIO *ptr = readable(self);
    if (ptr-&gt;pos &lt; RSTRING_LEN(ptr-&gt;string)) return Qfalse;
    return Qtrue;
}</pre> </div> <p>Returns true if the stream is at the end of the data (underlying string). The stream must be opened for reading or an <code>IOError</code> will be raised.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-eof-3F"> <span class="method-callseq"> eof? → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="eof-3F-source"> <pre class="c" data-language="c">static VALUE
strio_eof(VALUE self)
{
    struct StringIO *ptr = readable(self);
    if (ptr-&gt;pos &lt; RSTRING_LEN(ptr-&gt;string)) return Qfalse;
    return Qtrue;
}</pre> </div> <p>Returns true if the stream is at the end of the data (underlying string). The stream must be opened for reading or an <code>IOError</code> will be raised.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-external_encoding"> <span class="method-callseq"> external_encoding → encoding </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="external_encoding-source"> <pre class="c" data-language="c">static VALUE
strio_external_encoding(VALUE self)
{
    struct StringIO *ptr = StringIO(self);
    return rb_enc_from_encoding(get_enc(ptr));
}</pre> </div> <p>Returns the <a href="encoding"><code>Encoding</code></a> object that represents the encoding of the file. If the stream is write mode and no encoding is specified, returns <code>nil</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-fcntl"> <span class="method-name">fcntl</span><span class="method-args">(*args)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="fcntl-source"> <pre class="c" data-language="c">static VALUE
strio_unimpl(int argc, VALUE *argv, VALUE self)
{
    StringIO(self);
    rb_notimplement();

    UNREACHABLE;
}</pre> </div> <p>Raises <a href="notimplementederror"><code>NotImplementedError</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-fileno"> <span class="method-name">fileno</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="fileno-source"> <pre class="c" data-language="c">static VALUE
strio_nil(VALUE self)
{
    StringIO(self);
    return Qnil;
}</pre> </div> <p>Returns <code>nil</code>. Just for compatibility to <a href="io"><code>IO</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-flush"> <span class="method-name">flush</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="flush-source"> <pre class="c" data-language="c">static VALUE
strio_self(VALUE self)
{
    StringIO(self);
    return self;
}</pre> </div> <p>Returns an object itself. Just for compatibility to <a href="io"><code>IO</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-fsync"> <span class="method-name">fsync</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="fsync-source"> <pre class="c" data-language="c">static VALUE
strio_0(VALUE self)
{
    StringIO(self);
    return INT2FIX(0);
}</pre> </div> <p>Returns 0. Just for compatibility to <a href="io"><code>IO</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-getbyte"> <span class="method-callseq"> getbyte → fixnum or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="getbyte-source"> <pre class="c" data-language="c">static VALUE
strio_getbyte(VALUE self)
{
    struct StringIO *ptr = readable(self);
    int c;
    if (ptr-&gt;pos &gt;= RSTRING_LEN(ptr-&gt;string)) {
        return Qnil;
    }
    c = RSTRING_PTR(ptr-&gt;string)[ptr-&gt;pos++];
    return CHR2FIX(c);
}</pre> </div> <p>See <a href="io#method-i-getbyte"><code>IO#getbyte</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-getc"> <span class="method-callseq"> getc → string or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="getc-source"> <pre class="c" data-language="c">static VALUE
strio_getc(VALUE self)
{
    struct StringIO *ptr = readable(self);
    rb_encoding *enc = get_enc(ptr);
    VALUE str = ptr-&gt;string;
    long pos = ptr-&gt;pos;
    int len;
    char *p;

    if (pos &gt;= RSTRING_LEN(str)) {
        return Qnil;
    }
    p = RSTRING_PTR(str)+pos;
    len = rb_enc_mbclen(p, RSTRING_END(str), enc);
    ptr-&gt;pos += len;
    return enc_subseq(str, pos, len, enc);
}</pre> </div> <p>See <a href="io#method-i-getc"><code>IO#getc</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-gets"> <span class="method-callseq"> gets(sep=$/, chomp: false) → string or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> gets(limit, chomp: false) → string or nil </span> </div> <div class="method-heading"> <span class="method-callseq"> gets(sep, limit, chomp: false) → string or nil </span> </div> <div class="method-description">
<div class="method-source-code" id="gets-source"> <pre class="c" data-language="c">static VALUE
strio_gets(int argc, VALUE *argv, VALUE self)
{
    struct getline_arg arg;
    VALUE str;

    if (prepare_getline_args(&amp;arg, argc, argv)-&gt;limit == 0) {
        struct StringIO *ptr = readable(self);
        return rb_enc_str_new(0, 0, get_enc(ptr));
    }

    str = strio_getline(&amp;arg, readable(self));
    rb_lastline_set(str);
    return str;
}</pre> </div> <p>See <a href="io#method-i-gets"><code>IO#gets</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-internal_encoding"> <span class="method-callseq"> internal_encoding → encoding </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="internal_encoding-source"> <pre class="c" data-language="c">static VALUE
strio_internal_encoding(VALUE self)
{
    return Qnil;
}</pre> </div> <p>Returns the <a href="encoding"><code>Encoding</code></a> of the internal string if conversion is specified. Otherwise returns <code>nil</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-isatty"> <span class="method-name">isatty</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="isatty-source"> <pre class="c" data-language="c">static VALUE
strio_false(VALUE self)
{
    StringIO(self);
    return Qfalse;
}</pre> </div> <p>Returns <code>false</code>. Just for compatibility to <a href="io"><code>IO</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-length"> <span class="method-callseq"> length → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="length-source"> <pre class="c" data-language="c">static VALUE
strio_size(VALUE self)
{
    VALUE string = StringIO(self)-&gt;string;
    if (NIL_P(string)) {
        rb_raise(rb_eIOError, "not opened");
    }
    return ULONG2NUM(RSTRING_LEN(string));
}</pre> </div> <p>Returns the size of the buffer string.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-lineno"> <span class="method-callseq"> lineno → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="lineno-source"> <pre class="c" data-language="c">static VALUE
strio_get_lineno(VALUE self)
{
    return LONG2NUM(StringIO(self)-&gt;lineno);
}</pre> </div> <p>Returns the current line number. The stream must be opened for reading. <code>lineno</code> counts the number of times <code>gets</code> is called, rather than the number of newlines encountered. The two values will differ if <code>gets</code> is called with a separator other than newline. See also the <code>$.</code> variable.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-lineno-3D"> <span class="method-callseq"> lineno = integer → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="lineno-3D-source"> <pre class="c" data-language="c">static VALUE
strio_set_lineno(VALUE self, VALUE lineno)
{
    StringIO(self)-&gt;lineno = NUM2LONG(lineno);
    return lineno;
}</pre> </div> <p>Manually sets the current line number to the given value. <code>$.</code> is updated only on the next read.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-lines"> <span class="method-name">lines</span><span class="method-args">(*args)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="lines-source"> <pre class="c" data-language="c">static VALUE
strio_lines(int argc, VALUE *argv, VALUE self)
{
    rb_warn("StringIO#lines is deprecated; use #each_line instead");
    if (!rb_block_given_p())
        return rb_enumeratorize(self, ID2SYM(rb_intern("each_line")), argc, argv);
    return strio_each(argc, argv, self);
}</pre> </div> <p>This is a deprecated alias for <a href="stringio#method-i-each_line"><code>each_line</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-pid"> <span class="method-name">pid</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="pid-source"> <pre class="c" data-language="c">static VALUE
strio_nil(VALUE self)
{
    StringIO(self);
    return Qnil;
}</pre> </div> <p>Returns <code>nil</code>. Just for compatibility to <a href="io"><code>IO</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-pos"> <span class="method-callseq"> pos → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> tell → integer </span> </div> <div class="method-description">
<div class="method-source-code" id="pos-source"> <pre class="c" data-language="c">static VALUE
strio_get_pos(VALUE self)
{
    return LONG2NUM(StringIO(self)-&gt;pos);
}</pre> </div> <p>Returns the current offset (in bytes).</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-pos-3D"> <span class="method-callseq"> pos = integer → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="pos-3D-source"> <pre class="c" data-language="c">static VALUE
strio_set_pos(VALUE self, VALUE pos)
{
    struct StringIO *ptr = StringIO(self);
    long p = NUM2LONG(pos);
    if (p &lt; 0) {
        error_inval(0);
    }
    ptr-&gt;pos = p;
    return pos;
}</pre> </div> <p>Seeks to the given position (in bytes).</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-putc"> <span class="method-callseq"> putc(obj) → obj </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="putc-source"> <pre class="c" data-language="c">static VALUE
strio_putc(VALUE self, VALUE ch)
{
    struct StringIO *ptr = writable(self);
    VALUE str;

    check_modifiable(ptr);
    if (RB_TYPE_P(ch, T_STRING)) {
        str = rb_str_substr(ch, 0, 1);
    }
    else {
        char c = NUM2CHR(ch);
        str = rb_str_new(&amp;c, 1);
    }
    strio_write(self, str);
    return ch;
}</pre> </div> <p>See <a href="io#method-i-putc"><code>IO#putc</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-read"> <span class="method-callseq"> read([length [, outbuf]]) → string, outbuf, or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="read-source"> <pre class="c" data-language="c">static VALUE
strio_read(int argc, VALUE *argv, VALUE self)
{
    struct StringIO *ptr = readable(self);
    VALUE str = Qnil;
    long len;
    int binary = 0;

    rb_check_arity(argc, 0, 2);
    switch (argc) {
      case 2:
        str = argv[1];
        if (!NIL_P(str)) {
            StringValue(str);
            rb_str_modify(str);
        }
        /* fall through */
      case 1:
        if (!NIL_P(argv[0])) {
            len = NUM2LONG(argv[0]);
            if (len &lt; 0) {
                rb_raise(rb_eArgError, "negative length %ld given", len);
            }
            if (len &gt; 0 &amp;&amp; ptr-&gt;pos &gt;= RSTRING_LEN(ptr-&gt;string)) {
                if (!NIL_P(str)) rb_str_resize(str, 0);
                return Qnil;
            }
            binary = 1;
            break;
        }
        /* fall through */
      case 0:
        len = RSTRING_LEN(ptr-&gt;string);
        if (len &lt;= ptr-&gt;pos) {
            rb_encoding *enc = get_enc(ptr);
            if (NIL_P(str)) {
                str = rb_str_new(0, 0);
            }
            else {
                rb_str_resize(str, 0);
            }
            rb_enc_associate(str, enc);
            return str;
        }
        else {
            len -= ptr-&gt;pos;
        }
        break;
    }
    if (NIL_P(str)) {
        rb_encoding *enc = binary ? rb_ascii8bit_encoding() : get_enc(ptr);
        str = strio_substr(ptr, ptr-&gt;pos, len, enc);
    }
    else {
        long rest = RSTRING_LEN(ptr-&gt;string) - ptr-&gt;pos;
        if (len &gt; rest) len = rest;
        rb_str_resize(str, len);
        MEMCPY(RSTRING_PTR(str), RSTRING_PTR(ptr-&gt;string) + ptr-&gt;pos, char, len);
        if (binary)
            rb_enc_associate(str, rb_ascii8bit_encoding());
        else
            rb_enc_copy(str, ptr-&gt;string);
    }
    ptr-&gt;pos += RSTRING_LEN(str);
    return str;
}</pre> </div> <p>See <a href="io#method-i-read"><code>IO#read</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-readlines"> <span class="method-callseq"> readlines(sep=$/, chomp: false) → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> readlines(limit, chomp: false) → array </span> </div> <div class="method-heading"> <span class="method-callseq"> readlines(sep, limit, chomp: false) → array </span> </div> <div class="method-description">
<div class="method-source-code" id="readlines-source"> <pre class="c" data-language="c">static VALUE
strio_readlines(int argc, VALUE *argv, VALUE self)
{
    VALUE ary, line;
    struct getline_arg arg;

    StringIO(self);
    ary = rb_ary_new();
    if (prepare_getline_args(&amp;arg, argc, argv)-&gt;limit == 0) {
        rb_raise(rb_eArgError, "invalid limit: 0 for readlines");
    }

    while (!NIL_P(line = strio_getline(&amp;arg, readable(self)))) {
        rb_ary_push(ary, line);
    }
    return ary;
}</pre> </div> <p>See <a href="io#method-i-readlines"><code>IO#readlines</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-reopen"> <span class="method-callseq"> reopen(other_StrIO) → strio </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> reopen(string, mode) → strio </span> </div> <div class="method-description">
<div class="method-source-code" id="reopen-source"> <pre class="c" data-language="c">static VALUE
strio_reopen(int argc, VALUE *argv, VALUE self)
{
    rb_io_taint_check(self);
    if (argc == 1 &amp;&amp; !RB_TYPE_P(*argv, T_STRING)) {
        return strio_copy(self, *argv);
    }
    return strio_init(argc, argv, StringIO(self), self);
}</pre> </div> <p>Reinitializes the stream with the given <em>other_StrIO</em> or <em>string</em> and <em>mode</em> (see StringIO#new).</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-rewind"> <span class="method-callseq"> rewind → 0 </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="rewind-source"> <pre class="c" data-language="c">static VALUE
strio_rewind(VALUE self)
{
    struct StringIO *ptr = StringIO(self);
    ptr-&gt;pos = 0;
    ptr-&gt;lineno = 0;
    return INT2FIX(0);
}</pre> </div> <p>Positions the stream to the beginning of input, resetting <code>lineno</code> to zero.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-seek"> <span class="method-callseq"> seek(amount, whence=SEEK_SET) → 0 </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="seek-source"> <pre class="c" data-language="c">static VALUE
strio_seek(int argc, VALUE *argv, VALUE self)
{
    VALUE whence;
    struct StringIO *ptr = StringIO(self);
    long amount, offset;

    rb_scan_args(argc, argv, "11", NULL, &amp;whence);
    amount = NUM2LONG(argv[0]);
    if (CLOSED(self)) {
        rb_raise(rb_eIOError, "closed stream");
    }
    switch (NIL_P(whence) ? 0 : NUM2LONG(whence)) {
      case 0:
        offset = 0;
        break;
      case 1:
        offset = ptr-&gt;pos;
        break;
      case 2:
        offset = RSTRING_LEN(ptr-&gt;string);
        break;
      default:
        error_inval("invalid whence");
    }
    if (amount &gt; LONG_MAX - offset || amount + offset &lt; 0) {
        error_inval(0);
    }
    ptr-&gt;pos = amount + offset;
    return INT2FIX(0);
}</pre> </div> <p>Seeks to a given offset <em>amount</em> in the stream according to the value of <em>whence</em> (see <a href="io#method-i-seek"><code>IO#seek</code></a>).</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-set_encoding"> <span class="method-callseq"> set_encoding(ext_enc, [int_enc[, opt]]) → strio </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="set_encoding-source"> <pre class="c" data-language="c">static VALUE
strio_set_encoding(int argc, VALUE *argv, VALUE self)
{
    rb_encoding* enc;
    struct StringIO *ptr = StringIO(self);
    VALUE ext_enc, int_enc, opt;

    argc = rb_scan_args(argc, argv, "11:", &amp;ext_enc, &amp;int_enc, &amp;opt);

    if (NIL_P(ext_enc)) {
        enc = rb_default_external_encoding();
    }
    else {
        enc = rb_to_encoding(ext_enc);
    }
    ptr-&gt;enc = enc;
    if (WRITABLE(self)) {
        rb_enc_associate(ptr-&gt;string, enc);
    }

    return self;
}</pre> </div> <p>Specify the encoding of the <a href="stringio"><code>StringIO</code></a> as <em>ext_enc</em>. Use the default external encoding if <em>ext_enc</em> is nil. 2nd argument <em>int_enc</em> and optional hash <em>opt</em> argument are ignored; they are for API compatibility to <a href="io"><code>IO</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-set_encoding_by_bom"> <span class="method-name">set_encoding_by_bom</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="set_encoding_by_bom-source"> <pre class="c" data-language="c">static VALUE
strio_set_encoding_by_bom(VALUE self)
{
    struct StringIO *ptr = StringIO(self);

    if (!set_encoding_by_bom(ptr)) return Qnil;
    return rb_enc_from_encoding(ptr-&gt;enc);
}</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-size"> <span class="method-callseq"> size → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="size-source"> <pre class="c" data-language="c">static VALUE
strio_size(VALUE self)
{
    VALUE string = StringIO(self)-&gt;string;
    if (NIL_P(string)) {
        rb_raise(rb_eIOError, "not opened");
    }
    return ULONG2NUM(RSTRING_LEN(string));
}</pre> </div> <p>Returns the size of the buffer string.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-string"> <span class="method-callseq"> string → string </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="string-source"> <pre class="c" data-language="c">static VALUE
strio_get_string(VALUE self)
{
    return StringIO(self)-&gt;string;
}</pre> </div> <p>Returns underlying <a href="string"><code>String</code></a> object, the subject of <a href="io"><code>IO</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-string-3D"> <span class="method-callseq"> string = string → string </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="string-3D-source"> <pre class="c" data-language="c">static VALUE
strio_set_string(VALUE self, VALUE string)
{
    struct StringIO *ptr = StringIO(self);

    rb_io_taint_check(self);
    ptr-&gt;flags &amp;= ~FMODE_READWRITE;
    StringValue(string);
    ptr-&gt;flags = OBJ_FROZEN(string) ? FMODE_READABLE : FMODE_READWRITE;
    ptr-&gt;pos = 0;
    ptr-&gt;lineno = 0;
    return ptr-&gt;string = string;
}</pre> </div> <p>Changes underlying <a href="string"><code>String</code></a> object, the subject of <a href="io"><code>IO</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-sync"> <span class="method-callseq"> sync → true </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="sync-source"> <pre class="c" data-language="c">static VALUE
strio_get_sync(VALUE self)
{
    StringIO(self);
    return Qtrue;
}</pre> </div> <p>Returns <code>true</code> always.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-sync-3D"> <span class="method-name">sync=</span><span class="method-args">(p1)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="sync-3D-source"> <pre class="c" data-language="c">static VALUE
strio_first(VALUE self, VALUE arg)
{
    StringIO(self);
    return arg;
}</pre> </div> <p>Returns the argument unchanged. Just for compatibility to <a href="io"><code>IO</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-tell"> <span class="method-callseq"> pos → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> tell → integer </span> </div> <div class="method-description">
<div class="method-source-code" id="tell-source"> <pre class="c" data-language="c">static VALUE
strio_get_pos(VALUE self)
{
    return LONG2NUM(StringIO(self)-&gt;pos);
}</pre> </div> <p>Returns the current offset (in bytes).</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-truncate"> <span class="method-callseq"> truncate(integer) → 0 </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="truncate-source"> <pre class="c" data-language="c">static VALUE
strio_truncate(VALUE self, VALUE len)
{
    VALUE string = writable(self)-&gt;string;
    long l = NUM2LONG(len);
    long plen = RSTRING_LEN(string);
    if (l &lt; 0) {
        error_inval("negative length");
    }
    rb_str_resize(string, l);
    if (plen &lt; l) {
        MEMZERO(RSTRING_PTR(string) + plen, char, l - plen);
    }
    return len;
}</pre> </div> <p>Truncates the buffer string to at most <em>integer</em> bytes. The stream must be opened for writing.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-tty-3F"> <span class="method-name">tty?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="tty-3F-source"> <pre class="c" data-language="c">static VALUE
strio_false(VALUE self)
{
    StringIO(self);
    return Qfalse;
}</pre> </div> <p>Returns <code>false</code>. Just for compatibility to <a href="io"><code>IO</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-ungetbyte"> <span class="method-callseq"> ungetbyte(fixnum) → nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="ungetbyte-source"> <pre class="c" data-language="c">static VALUE
strio_ungetbyte(VALUE self, VALUE c)
{
    struct StringIO *ptr = readable(self);

    check_modifiable(ptr);
    if (NIL_P(c)) return Qnil;
    if (RB_INTEGER_TYPE_P(c)) {
        /* rb_int_and() not visible from exts */
        VALUE v = rb_funcall(c, '&amp;', 1, INT2FIX(0xff));
        const char cc = NUM2INT(v) &amp; 0xFF;
        strio_unget_bytes(ptr, &amp;cc, 1);
    }
    else {
        long cl;
        SafeStringValue(c);
        cl = RSTRING_LEN(c);
        if (cl &gt; 0) {
            strio_unget_bytes(ptr, RSTRING_PTR(c), cl);
            RB_GC_GUARD(c);
        }
    }
    return Qnil;
}</pre> </div> <p>See <a href="io#method-i-ungetbyte"><code>IO#ungetbyte</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-ungetc"> <span class="method-callseq"> ungetc(string) → nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="ungetc-source"> <pre class="c" data-language="c">static VALUE
strio_ungetc(VALUE self, VALUE c)
{
    struct StringIO *ptr = readable(self);
    rb_encoding *enc, *enc2;

    check_modifiable(ptr);
    if (NIL_P(c)) return Qnil;
    if (RB_INTEGER_TYPE_P(c)) {
        int len, cc = NUM2INT(c);
        char buf[16];

        enc = rb_enc_get(ptr-&gt;string);
        len = rb_enc_codelen(cc, enc);
        if (len &lt;= 0) rb_enc_uint_chr(cc, enc);
        rb_enc_mbcput(cc, buf, enc);
        return strio_unget_bytes(ptr, buf, len);
    }
    else {
        SafeStringValue(c);
        enc = rb_enc_get(ptr-&gt;string);
        enc2 = rb_enc_get(c);
        if (enc != enc2 &amp;&amp; enc != rb_ascii8bit_encoding()) {
            c = rb_str_conv_enc(c, enc2, enc);
        }
        strio_unget_bytes(ptr, RSTRING_PTR(c), RSTRING_LEN(c));
        RB_GC_GUARD(c);
        return Qnil;
    }
}</pre> </div> <p>Pushes back one character (passed as a parameter) such that a subsequent buffered read will return it. There is no limitation for multiple pushbacks including pushing back behind the beginning of the buffer string.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-write"> <span class="method-callseq"> write(string, ...) → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> syswrite(string) → integer </span> </div> <div class="method-description">
<div class="method-source-code" id="write-source"> <pre class="c" data-language="c">static VALUE
strio_write_m(int argc, VALUE *argv, VALUE self)
{
    long len = 0;
    while (argc-- &gt; 0) {
        /* StringIO can't exceed long limit */
        len += strio_write(self, *argv++);
    }
    return LONG2NUM(len);
}</pre> </div> <p>Appends the given string to the underlying buffer string. The stream must be opened for writing. If the argument is not a string, it will be converted to a string using <code>to_s</code>. Returns the number of bytes written. See <a href="io#method-i-write"><code>IO#write</code></a>.</p>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core © 1993–2017 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library © contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
