
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Bundler&#58;&#58;Definition - Ruby 2.7 - W3cubDocs</title>
  
  <meta name="description" content=" Given a gemfile and lockfile creates a Bundler definition ">
  <meta name="keywords" content="class, bundler, definition, ruby, ruby~2.7">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/ruby~2.7/bundler/definition.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/ruby~2.7.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/ruby~2.7/" class="_nav-link" title="" style="margin-left:0;">Ruby 2.7</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _rdoc">
				
				
<h1 id="class-Bundler::Definition" class="class"> class Bundler::Definition </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="../object">Object</a></dd>
<dt>Included modules:</dt>
<dd class="meta-includes"><a class="include" href="gemhelpers">Bundler::GemHelpers</a></dd>
</dl>  <section id="5Buntitled-5D" class="documentation-section"> <section class="attribute-method-details"> <header> <h3>Attributes</h3> </header> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-dependencies"> <span class="method-name">dependencies</span><span class="attribute-access-type">[R]</span> </div>  </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-gemfiles"> <span class="method-name">gemfiles</span><span class="attribute-access-type">[R]</span> </div>  </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-locked_deps"> <span class="method-name">locked_deps</span><span class="attribute-access-type">[R]</span> </div>  </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-locked_gems"> <span class="method-name">locked_gems</span><span class="attribute-access-type">[R]</span> </div>  </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-lockfile"> <span class="method-name">lockfile</span><span class="attribute-access-type">[R]</span> </div>  </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-platforms"> <span class="method-name">platforms</span><span class="attribute-access-type">[R]</span> </div>  </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-requires"> <span class="method-name">requires</span><span class="attribute-access-type">[R]</span> </div>  </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-ruby_version"> <span class="method-name">ruby_version</span><span class="attribute-access-type">[R]</span> </div>  </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-sources"> <span class="method-name">sources</span><span class="attribute-access-type">[R]</span> </div>  </div> </section> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-c-build"> <span class="method-name">build</span><span class="method-args">(gemfile, lockfile, unlock)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="build-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 28
def self.build(gemfile, lockfile, unlock)
  unlock ||= {}
  gemfile = Pathname.new(gemfile).expand_path

  raise GemfileNotFound, "#{gemfile} not found" unless gemfile.file?

  Dsl.evaluate(gemfile, lockfile, unlock)
end</pre> </div> <p>Given a gemfile and lockfile creates a <a href="../bundler"><code>Bundler</code></a> definition</p> <p>@param gemfile [Pathname] Path to Gemfile @param lockfile [Pathname,nil] Path to Gemfile.lock @param unlock [Hash, Boolean, nil] Gems that have been requested</p> <pre class="ruby" data-language="ruby">to be updated or true if all gems should be updated
</pre> <p>@return [Bundler::Definition]</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-new"> <span class="method-name">new</span><span class="method-args">(lockfile, dependencies, sources, unlock, ruby_version = nil, optional_groups = [], gemfiles = [])</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 55
def initialize(lockfile, dependencies, sources, unlock, ruby_version = nil, optional_groups = [], gemfiles = [])
  if [true, false].include?(unlock)
    @unlocking_bundler = false
    @unlocking = unlock
  else
    unlock = unlock.dup
    @unlocking_bundler = unlock.delete(:bundler)
    unlock.delete_if {|_k, v| Array(v).empty? }
    @unlocking = !unlock.empty?
  end

  @dependencies    = dependencies
  @sources         = sources
  @unlock          = unlock
  @optional_groups = optional_groups
  @remote          = false
  @specs           = nil
  @ruby_version    = ruby_version
  @gemfiles        = gemfiles

  @lockfile               = lockfile
  @lockfile_contents      = String.new
  @locked_bundler_version = nil
  @locked_ruby_version    = nil
  @locked_specs_incomplete_for_platform = false

  if lockfile &amp;&amp; File.exist?(lockfile)
    @lockfile_contents = Bundler.read_file(lockfile)
    @locked_gems = LockfileParser.new(@lockfile_contents)
    @locked_platforms = @locked_gems.platforms
    @platforms = @locked_platforms.dup
    @locked_bundler_version = @locked_gems.bundler_version
    @locked_ruby_version = @locked_gems.ruby_version

    if unlock != true
      @locked_deps    = @locked_gems.dependencies
      @locked_specs   = SpecSet.new(@locked_gems.specs)
      @locked_sources = @locked_gems.sources
    else
      @unlock         = {}
      @locked_deps    = {}
      @locked_specs   = SpecSet.new([])
      @locked_sources = []
    end
  else
    @unlock         = {}
    @platforms      = []
    @locked_gems    = nil
    @locked_deps    = {}
    @locked_specs   = SpecSet.new([])
    @locked_sources = []
    @locked_platforms = []
  end

  @unlock[:gems] ||= []
  @unlock[:sources] ||= []
  @unlock[:ruby] ||= if @ruby_version &amp;&amp; locked_ruby_version_object
    @ruby_version.diff(locked_ruby_version_object)
  end
  @unlocking ||= @unlock[:ruby] ||= (!@locked_ruby_version ^ !@ruby_version)

  add_current_platform unless Bundler.frozen_bundle?

  converge_path_sources_to_gemspec_sources
  @path_changes = converge_paths
  @source_changes = converge_sources

  unless @unlock[:lock_shared_dependencies]
    eager_unlock = expand_dependencies(@unlock[:gems], true)
    @unlock[:gems] = @locked_specs.for(eager_unlock, [], false, false, false).map(&amp;:name)
  end

  @dependency_changes = converge_dependencies
  @local_changes = converge_locals

  @requires = compute_requires
end</pre> </div> <p>How does the new system work?</p> <ul>
<li> <p>Load information from Gemfile and Lockfile</p> </li>
<li> <p>Invalidate stale locked specs</p> </li>
<li> <p>All specs from stale source are stale</p> </li>
<li> <p>All specs that are reachable only through a stale dependency are stale.</p> </li>
<li> <p>If all fresh dependencies are satisfied by the locked</p> </li>
</ul> <pre>specs, then we can try to resolve locally.</pre> <p>@param lockfile [Pathname] Path to Gemfile.lock @param dependencies [Array(<a href="dependency"><code>Bundler::Dependency</code></a>)] array of dependencies from Gemfile @param sources [Bundler::SourceList] @param unlock [Hash, Boolean, nil] Gems that have been requested</p> <pre class="ruby" data-language="ruby">to be updated or true if all gems should be updated
</pre> <p>@param <a href="definition#attribute-i-ruby_version"><code>ruby_version</code></a> [Bundler::RubyVersion, nil] Requested Ruby Version @param optional_groups [Array(<a href="../string"><code>String</code></a>)] A list of optional groups</p>  </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-add_current_platform"> <span class="method-name">add_current_platform</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="add_current_platform-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 521
def add_current_platform
  current_platforms.each {|platform| add_platform(platform) }
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-add_platform"> <span class="method-name">add_platform</span><span class="method-args">(platform)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="add_platform-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 511
def add_platform(platform)
  @new_platform ||= !@platforms.include?(platform)
  @platforms |= [platform]
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-current_dependencies"> <span class="method-name">current_dependencies</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="current_dependencies-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 230
def current_dependencies
  dependencies.select(&amp;:should_include?)
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-ensure_equivalent_gemfile_and_lockfile"> <span class="method-name">ensure_equivalent_gemfile_and_lockfile</span><span class="method-args">(explicit_flag = false)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="ensure_equivalent_gemfile_and_lockfile-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 392
def ensure_equivalent_gemfile_and_lockfile(explicit_flag = false)
  msg = String.new
  msg &lt;&lt; "You are trying to install in deployment mode after changing\n" \
         "your Gemfile. Run `bundle install` elsewhere and add the\n" \
         "updated #{Bundler.default_lockfile.relative_path_from(SharedHelpers.pwd)} to version control."

  unless explicit_flag
    suggested_command = if Bundler.settings.locations("frozen")[:global]
      "bundle config unset frozen"
    elsif Bundler.settings.locations("deployment").keys.&amp;([:global, :local]).any?
      "bundle config unset deployment"
    else
      "bundle install --no-deployment"
    end
    msg &lt;&lt; "\n\nIf this is a development machine, remove the #{Bundler.default_gemfile} " \
           "freeze \nby running `#{suggested_command}`."
  end

  added =   []
  deleted = []
  changed = []

  new_platforms = @platforms - @locked_platforms
  deleted_platforms = @locked_platforms - @platforms
  added.concat new_platforms.map {|p| "* platform: #{p}" }
  deleted.concat deleted_platforms.map {|p| "* platform: #{p}" }

  gemfile_sources = sources.lock_sources

  new_sources = gemfile_sources - @locked_sources
  deleted_sources = @locked_sources - gemfile_sources

  new_deps = @dependencies - @locked_deps.values
  deleted_deps = @locked_deps.values - @dependencies

  # Check if it is possible that the source is only changed thing
  if (new_deps.empty? &amp;&amp; deleted_deps.empty?) &amp;&amp; (!new_sources.empty? &amp;&amp; !deleted_sources.empty?)
    new_sources.reject! {|source| (source.path? &amp;&amp; source.path.exist?) || equivalent_rubygems_remotes?(source) }
    deleted_sources.reject! {|source| (source.path? &amp;&amp; source.path.exist?) || equivalent_rubygems_remotes?(source) }
  end

  if @locked_sources != gemfile_sources
    if new_sources.any?
      added.concat new_sources.map {|source| "* source: #{source}" }
    end

    if deleted_sources.any?
      deleted.concat deleted_sources.map {|source| "* source: #{source}" }
    end
  end

  added.concat new_deps.map {|d| "* #{pretty_dep(d)}" } if new_deps.any?
  if deleted_deps.any?
    deleted.concat deleted_deps.map {|d| "* #{pretty_dep(d)}" }
  end

  both_sources = Hash.new {|h, k| h[k] = [] }
  @dependencies.each {|d| both_sources[d.name][0] = d }
  @locked_deps.each  {|name, d| both_sources[name][1] = d.source }

  both_sources.each do |name, (dep, lock_source)|
    next unless (dep.nil? &amp;&amp; !lock_source.nil?) || (!dep.nil? &amp;&amp; !lock_source.nil? &amp;&amp; !lock_source.can_lock?(dep))
    gemfile_source_name = (dep &amp;&amp; dep.source) || "no specified source"
    lockfile_source_name = lock_source || "no specified source"
    changed &lt;&lt; "* #{name} from `#{gemfile_source_name}` to `#{lockfile_source_name}`"
  end

  reason = change_reason
  msg &lt;&lt; "\n\n#{reason.split(", ").map(&amp;:capitalize).join("\n")}" unless reason.strip.empty?
  msg &lt;&lt; "\n\nYou have added to the Gemfile:\n" &lt;&lt; added.join("\n") if added.any?
  msg &lt;&lt; "\n\nYou have deleted from the Gemfile:\n" &lt;&lt; deleted.join("\n") if deleted.any?
  msg &lt;&lt; "\n\nYou have changed in the Gemfile:\n" &lt;&lt; changed.join("\n") if changed.any?
  msg &lt;&lt; "\n"

  raise ProductionError, msg if added.any? || deleted.any? || changed.any? || !nothing_changed?
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-find_indexed_specs"> <span class="method-name">find_indexed_specs</span><span class="method-args">(current_spec)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="find_indexed_specs-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 529
def find_indexed_specs(current_spec)
  index[current_spec.name].select {|spec| spec.match_platform(current_spec.platform) }.sort_by(&amp;:version)
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-find_resolved_spec"> <span class="method-name">find_resolved_spec</span><span class="method-args">(current_spec)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="find_resolved_spec-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 525
def find_resolved_spec(current_spec)
  specs.find_by_name_and_platform(current_spec.name, current_spec.platform)
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-gem_version_promoter"> <span class="method-name">gem_version_promoter</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="gem_version_promoter-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 133
def gem_version_promoter
  @gem_version_promoter ||= begin
    locked_specs =
      if unlocking? &amp;&amp; @locked_specs.empty? &amp;&amp; !@lockfile_contents.empty?
        # Definition uses an empty set of locked_specs to indicate all gems
        # are unlocked, but GemVersionPromoter needs the locked_specs
        # for conservative comparison.
        Bundler::SpecSet.new(@locked_gems.specs)
      else
        @locked_specs
      end
    GemVersionPromoter.new(locked_specs, @unlock[:gems])
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-groups"> <span class="method-name">groups</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="groups-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 323
def groups
  dependencies.map(&amp;:groups).flatten.uniq
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-has_local_dependencies-3F"> <span class="method-name">has_local_dependencies?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="has_local_dependencies-3F-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 315
def has_local_dependencies?
  !sources.path_sources.empty? || !sources.git_sources.empty?
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-has_rubygems_remotes-3F"> <span class="method-name">has_rubygems_remotes?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="has_rubygems_remotes-3F-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 311
def has_rubygems_remotes?
  sources.rubygems_sources.any? {|s| s.remotes.any? }
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-index"> <span class="method-name">index</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="index-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 267
def index
  @index ||= Index.build do |idx|
    dependency_names = @dependencies.map(&amp;:name)

    sources.all_sources.each do |source|
      source.dependency_names = dependency_names - pinned_spec_names(source)
      idx.add_source source.specs
      dependency_names.concat(source.unmet_deps).uniq!
    end

    double_check_for_index(idx, dependency_names)
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-lock"> <span class="method-name">lock</span><span class="method-args">(file, preserve_unknown_sections = false)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="lock-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 327
def lock(file, preserve_unknown_sections = false)
  contents = to_lock

  # Convert to \r\n if the existing lock has them
  # i.e., Windows with `git config core.autocrlf=true`
  contents.gsub!(/\n/, "\r\n") if @lockfile_contents.match("\r\n")

  if @locked_bundler_version
    locked_major = @locked_bundler_version.segments.first
    current_major = Gem::Version.create(Bundler::VERSION).segments.first

    if updating_major = locked_major &lt; current_major
      Bundler.ui.warn "Warning: the lockfile is being updated to Bundler #{current_major}, " \
                      "after which you will be unable to return to Bundler #{@locked_bundler_version.segments.first}."
    end
  end

  preserve_unknown_sections ||= !updating_major &amp;&amp; (Bundler.frozen_bundle? || !(unlocking? || @unlocking_bundler))

  return if file &amp;&amp; File.exist?(file) &amp;&amp; lockfiles_equal?(@lockfile_contents, contents, preserve_unknown_sections)

  if Bundler.frozen_bundle?
    Bundler.ui.error "Cannot write a changed lockfile while frozen."
    return
  end

  SharedHelpers.filesystem_access(file) do |p|
    File.open(p, "wb") {|f| f.puts(contents) }
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-locked_bundler_version"> <span class="method-name">locked_bundler_version</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="locked_bundler_version-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 358
def locked_bundler_version
  if @locked_bundler_version &amp;&amp; @locked_bundler_version &lt; Gem::Version.new(Bundler::VERSION)
    new_version = Bundler::VERSION
  end

  new_version || @locked_bundler_version || Bundler::VERSION
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-locked_ruby_version"> <span class="method-name">locked_ruby_version</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="locked_ruby_version-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 366
def locked_ruby_version
  return unless ruby_version
  if @unlock[:ruby] || !@locked_ruby_version
    Bundler::RubyVersion.system
  else
    @locked_ruby_version
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-locked_ruby_version_object"> <span class="method-name">locked_ruby_version_object</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="locked_ruby_version_object-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 375
def locked_ruby_version_object
  return unless @locked_ruby_version
  @locked_ruby_version_object ||= begin
    unless version = RubyVersion.from_string(@locked_ruby_version)
      raise LockfileError, "The Ruby version #{@locked_ruby_version} from " \
        "#{@lockfile} could not be parsed. " \
        "Try running bundle update --ruby to resolve this."
    end
    version
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-missing_specs"> <span class="method-name">missing_specs</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="missing_specs-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 201
def missing_specs
  missing = []
  resolve.materialize(requested_dependencies, missing)
  missing
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-missing_specs-3F"> <span class="method-name">missing_specs?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="missing_specs-3F-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 207
def missing_specs?
  missing = missing_specs
  return false if missing.empty?
  Bundler.ui.debug "The definition is missing #{missing.map(&amp;:full_name)}"
  true
rescue BundlerError =&gt; e
  @index = nil
  @resolve = nil
  @specs = nil
  @gem_version_promoter = nil

  Bundler.ui.debug "The definition is missing dependencies, failed to resolve &amp; materialize locally (#{e})"
  true
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-new_platform-3F"> <span class="method-name">new_platform?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="new_platform-3F-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 197
def new_platform?
  @new_platform
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-new_specs"> <span class="method-name">new_specs</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="new_specs-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 189
def new_specs
  specs - @locked_specs
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-nothing_changed-3F"> <span class="method-name">nothing_changed?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="nothing_changed-3F-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 536
def nothing_changed?
  !@source_changes &amp;&amp; !@dependency_changes &amp;&amp; !@new_platform &amp;&amp; !@path_changes &amp;&amp; !@local_changes &amp;&amp; !@locked_specs_incomplete_for_platform
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-remove_platform"> <span class="method-name">remove_platform</span><span class="method-args">(platform)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="remove_platform-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 516
def remove_platform(platform)
  return if @platforms.delete(Gem::Platform.new(platform))
  raise InvalidOption, "Unable to remove the platform `#{platform}` since the only platforms are #{@platforms.join ", "}"
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-removed_specs"> <span class="method-name">removed_specs</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="removed_specs-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 193
def removed_specs
  @locked_specs - specs
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-requested_specs"> <span class="method-name">requested_specs</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="requested_specs-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 222
def requested_specs
  @requested_specs ||= begin
    groups = requested_groups
    groups.map!(&amp;:to_sym)
    specs_for(groups)
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-resolve"> <span class="method-name">resolve</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="resolve-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 245
def resolve
  @resolve ||= begin
    last_resolve = converge_locked_specs
    resolve =
      if Bundler.frozen_bundle?
        Bundler.ui.debug "Frozen, using resolution from the lockfile"
        last_resolve
      elsif !unlocking? &amp;&amp; nothing_changed?
        Bundler.ui.debug("Found no changes, using resolution from the lockfile")
        last_resolve
      else
        # Run a resolve against the locally available gems
        Bundler.ui.debug("Found changes from the lockfile, re-resolving dependencies because #{change_reason}")
        last_resolve.merge Resolver.resolve(expanded_dependencies, index, source_requirements, last_resolve, gem_version_promoter, additional_base_requirements_for_resolve, platforms)
      end

    # filter out gems that _can_ be installed on multiple platforms, but don't need
    # to be
    resolve.for(expand_dependencies(dependencies, true), [], false, false, false)
  end
end</pre> </div> <p>Resolve all the dependencies specified in Gemfile. It ensures that dependencies that have been already resolved via locked file and are fresh are reused when resolving dependencies</p> <p>@return [SpecSet] resolved dependencies</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-resolve_remotely-21"> <span class="method-name">resolve_remotely!</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="resolve_remotely-21-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 154
def resolve_remotely!
  raise "Specs already loaded" if @specs
  @remote = true
  sources.remote!
  specs
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-resolve_with_cache-21"> <span class="method-name">resolve_with_cache!</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="resolve_with_cache-21-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 148
def resolve_with_cache!
  raise "Specs already loaded" if @specs
  sources.cached!
  specs
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-spec_git_paths"> <span class="method-name">spec_git_paths</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="spec_git_paths-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 319
def spec_git_paths
  sources.git_sources.map {|s| File.realpath(s.path) if File.exist?(s.path) }.compact
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-specs"> <span class="method-name">specs</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="specs-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 167
def specs
  @specs ||= begin
    begin
      specs = resolve.materialize(requested_dependencies)
    rescue GemNotFound =&gt; e # Handle yanked gem
      gem_name, gem_version = extract_gem_info(e)
      locked_gem = @locked_specs[gem_name].last
      raise if locked_gem.nil? || locked_gem.version.to_s != gem_version || !@remote
      raise GemNotFound, "Your bundle is locked to #{locked_gem}, but that version could not " \
                         "be found in any of the sources listed in your Gemfile. If you haven't changed sources, " \
                         "that means the author of #{locked_gem} has removed it. You'll need to update your bundle " \
                         "to a version other than #{locked_gem} that hasn't been removed in order to install."
    end
    unless specs["bundler"].any?
      bundler = sources.metadata_source.specs.search(Gem::Dependency.new("bundler", VERSION)).last
      specs["bundler"] = bundler
    end

    specs
  end
end</pre> </div> <p>For given dependency list returns a <a href="specset"><code>SpecSet</code></a> with Gemspec of all the required dependencies.</p> <pre>1. The method first resolves the dependencies specified in Gemfile
2. After that it tries and fetches gemspec of resolved dependencies</pre> <p>@return [Bundler::SpecSet]</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-specs_for"> <span class="method-name">specs_for</span><span class="method-args">(groups)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="specs_for-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 234
def specs_for(groups)
  deps = dependencies.select {|d| (d.groups &amp; groups).any? }
  deps.delete_if {|d| !d.should_include? }
  specs.for(expand_dependencies(deps))
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_lock"> <span class="method-name">to_lock</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="to_lock-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 387
def to_lock
  require_relative "lockfile_generator"
  LockfileGenerator.generate(self)
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-unlocking-3F"> <span class="method-name">unlocking?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="unlocking-3F-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 540
def unlocking?
  @unlocking
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-validate_platforms-21"> <span class="method-name">validate_platforms!</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="validate_platforms-21-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 499
def validate_platforms!
  return if @platforms.any? do |bundle_platform|
    Bundler.rubygems.platforms.any? do |local_platform|
      MatchPlatform.platforms_match?(bundle_platform, local_platform)
    end
  end

  raise ProductionError, "Your bundle only supports platforms #{@platforms.map(&amp;:to_s)} " \
    "but your local platforms are #{Bundler.rubygems.platforms.map(&amp;:to_s)}, and " \
    "there's no compatible match between those two lists."
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-validate_ruby-21"> <span class="method-name">validate_ruby!</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="validate_ruby-21-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 474
def validate_ruby!
  return unless ruby_version

  if diff = ruby_version.diff(Bundler::RubyVersion.system)
    problem, expected, actual = diff

    msg = case problem
          when :engine
            "Your Ruby engine is #{actual}, but your Gemfile specified #{expected}"
          when :version
            "Your Ruby version is #{actual}, but your Gemfile specified #{expected}"
          when :engine_version
            "Your #{Bundler::RubyVersion.system.engine} version is #{actual}, but your Gemfile specified #{ruby_version.engine} #{expected}"
          when :patchlevel
            if !expected.is_a?(String)
              "The Ruby patchlevel in your Gemfile must be a string"
            else
              "Your Ruby patchlevel is #{actual}, but your Gemfile specified #{expected}"
            end
    end

    raise RubyVersionMismatch, msg
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-validate_runtime-21"> <span class="method-name">validate_runtime!</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="validate_runtime-21-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 469
def validate_runtime!
  validate_ruby!
  validate_platforms!
end</pre> </div>  </div> </div> </section> <section id="private-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Private Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-additional_base_requirements_for_resolve"> <span class="method-name">additional_base_requirements_for_resolve</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="additional_base_requirements_for_resolve-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 982
def additional_base_requirements_for_resolve
  return [] unless @locked_gems &amp;&amp; Bundler.feature_flag.only_update_to_newer_versions?
  dependencies_by_name = dependencies.inject({}) {|memo, dep| memo.update(dep.name =&gt; dep) }
  @locked_gems.specs.reduce({}) do |requirements, locked_spec|
    name = locked_spec.name
    dependency = dependencies_by_name[name]
    next requirements if @locked_gems.dependencies[name] != dependency
    next requirements if dependency &amp;&amp; dependency.source.is_a?(Source::Path)
    dep = Gem::Dependency.new(name, "&gt;= #{locked_spec.version}")
    requirements[name] = DepProxy.new(dep, locked_spec.platform)
    requirements
  end.values
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-change_reason"> <span class="method-name">change_reason</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="change_reason-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 554
def change_reason
  if unlocking?
    unlock_reason = @unlock.reject {|_k, v| Array(v).empty? }.map do |k, v|
      if v == true
        k.to_s
      else
        v = Array(v)
        "#{k}: (#{v.join(", ")})"
      end
    end.join(", ")
    return "bundler is unlocking #{unlock_reason}"
  end
  [
    [@source_changes, "the list of sources changed"],
    [@dependency_changes, "the dependencies in your gemfile changed"],
    [@new_platform, "you added a new platform to your gemfile"],
    [@path_changes, "the gemspecs for path gems changed"],
    [@local_changes, "the gemspecs for git local gems changed"],
    [@locked_specs_incomplete_for_platform, "the lockfile does not have all gems needed for the current platform"],
  ].select(&amp;:first).map(&amp;:last).join(", ")
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-compute_requires"> <span class="method-name">compute_requires</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="compute_requires-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 971
def compute_requires
  dependencies.reduce({}) do |requires, dep|
    next requires unless dep.should_include?
    requires[dep.name] = Array(dep.autorequire || dep.name).map do |file|
      # Allow `require: true` as an alias for `require: &lt;name&gt;`
      file == true ? dep.name : file
    end
    requires
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-concat_ruby_version_requirements"> <span class="method-name">concat_ruby_version_requirements</span><span class="method-args">(ruby_version, ruby_versions = [])</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="concat_ruby_version_requirements-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 871
def concat_ruby_version_requirements(ruby_version, ruby_versions = [])
  return ruby_versions unless ruby_version
  if ruby_version.patchlevel
    ruby_versions &lt;&lt; ruby_version.to_gem_version_with_patchlevel
  else
    ruby_versions.concat(ruby_version.versions.map do |version|
      requirement = Gem::Requirement.new(version)
      if requirement.exact?
        "~&gt; #{version}.0"
      else
        requirement
      end
    end)
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-converge_dependencies"> <span class="method-name">converge_dependencies</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="converge_dependencies-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 697
def converge_dependencies
  frozen = Bundler.frozen_bundle?
  (@dependencies + @locked_deps.values).each do |dep|
    locked_source = @locked_deps[dep.name]
    # This is to make sure that if bundler is installing in deployment mode and
    # after locked_source and sources don't match, we still use locked_source.
    if frozen &amp;&amp; !locked_source.nil? &amp;&amp;
        locked_source.respond_to?(:source) &amp;&amp; locked_source.source.instance_of?(Source::Path) &amp;&amp; locked_source.source.path.exist?
      dep.source = locked_source.source
    elsif dep.source
      dep.source = sources.get(dep.source)
    end
    if dep.source.is_a?(Source::Gemspec)
      dep.platforms.concat(@platforms.map {|p| Dependency::REVERSE_PLATFORM_MAP[p] }.flatten(1)).uniq!
    end
  end

  changes = false
  # We want to know if all match, but don't want to check all entries
  # This means we need to return false if any dependency doesn't match
  # the lock or doesn't exist in the lock.
  @dependencies.each do |dependency|
    unless locked_dep = @locked_deps[dependency.name]
      changes = true
      next
    end

    # Gem::Dependency#== matches Gem::Dependency#type. As the lockfile
    # doesn't carry a notion of the dependency type, if you use
    # add_development_dependency in a gemspec that's loaded with the gemspec
    # directive, the lockfile dependencies and resolved dependencies end up
    # with a mismatch on #type. Work around that by setting the type on the
    # dep from the lockfile.
    locked_dep.instance_variable_set(:@type, dependency.type)

    # We already know the name matches from the hash lookup
    # so we only need to check the requirement now
    changes ||= dependency.requirement != locked_dep.requirement
  end

  changes
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-converge_locals"> <span class="method-name">converge_locals</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="converge_locals-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 609
def converge_locals
  locals = []

  Bundler.settings.local_overrides.map do |k, v|
    spec   = @dependencies.find {|s| s.name == k }
    source = spec &amp;&amp; spec.source
    if source &amp;&amp; source.respond_to?(:local_override!)
      source.unlock! if @unlock[:gems].include?(spec.name)
      locals &lt;&lt; [source, source.local_override!(v)]
    end
  end

  sources_with_changes = locals.select do |source, changed|
    changed || specs_changed?(source)
  end.map(&amp;:first)
  !sources_with_changes.each {|source| @unlock[:sources] &lt;&lt; source.name }.empty?
end</pre> </div> <p>Get all locals and override their matching sources. Return true if any of the locals changed (for example, they point to a new revision) or depend on new specs.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-converge_locked_specs"> <span class="method-name">converge_locked_specs</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="converge_locked_specs-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 743
def converge_locked_specs
  deps = []

  # Build a list of dependencies that are the same in the Gemfile
  # and Gemfile.lock. If the Gemfile modified a dependency, but
  # the gem in the Gemfile.lock still satisfies it, this is fine
  # too.
  @dependencies.each do |dep|
    locked_dep = @locked_deps[dep.name]

    # If the locked_dep doesn't match the dependency we're looking for then we ignore the locked_dep
    locked_dep = nil unless locked_dep == dep

    if in_locked_deps?(dep, locked_dep) || satisfies_locked_spec?(dep)
      deps &lt;&lt; dep
    elsif dep.source.is_a?(Source::Path) &amp;&amp; dep.current_platform? &amp;&amp; (!locked_dep || dep.source != locked_dep.source)
      @locked_specs.each do |s|
        @unlock[:gems] &lt;&lt; s.name if s.source == dep.source
      end

      dep.source.unlock! if dep.source.respond_to?(:unlock!)
      dep.source.specs.each {|s| @unlock[:gems] &lt;&lt; s.name }
    end
  end

  unlock_source_unlocks_spec = Bundler.feature_flag.unlock_source_unlocks_spec?

  converged = []
  @locked_specs.each do |s|
    # Replace the locked dependency's source with the equivalent source from the Gemfile
    dep = @dependencies.find {|d| s.satisfies?(d) }
    s.source = (dep &amp;&amp; dep.source) || sources.get(s.source)

    # Don't add a spec to the list if its source is expired. For example,
    # if you change a Git gem to RubyGems.
    next if s.source.nil?
    next if @unlock[:sources].include?(s.source.name)

    # XXX This is a backwards-compatibility fix to preserve the ability to
    # unlock a single gem by passing its name via `--source`. See issue #3759
    # TODO: delete in Bundler 2
    next if unlock_source_unlocks_spec &amp;&amp; @unlock[:sources].include?(s.name)

    # If the spec is from a path source and it doesn't exist anymore
    # then we unlock it.

    # Path sources have special logic
    if s.source.instance_of?(Source::Path) || s.source.instance_of?(Source::Gemspec)
      new_specs = begin
        s.source.specs
      rescue PathError, GitError
        # if we won't need the source (according to the lockfile),
        # don't error if the path/git source isn't available
        next if @locked_specs.
                for(requested_dependencies, [], false, true, false).
                none? {|locked_spec| locked_spec.source == s.source }

        raise
      end

      new_spec = new_specs[s].first

      # If the spec is no longer in the path source, unlock it. This
      # commonly happens if the version changed in the gemspec
      next unless new_spec

      new_runtime_deps = new_spec.dependencies.select {|d| d.type != :development }
      old_runtime_deps = s.dependencies.select {|d| d.type != :development }
      # If the dependencies of the path source have changed and locked spec can't satisfy new dependencies, unlock it
      next unless new_runtime_deps.sort == old_runtime_deps.sort || new_runtime_deps.all? {|d| satisfies_locked_spec?(d) }

      s.dependencies.replace(new_spec.dependencies)
    end

    converged &lt;&lt; s
  end

  resolve = SpecSet.new(converged)
  @locked_specs_incomplete_for_platform = !resolve.for(expand_dependencies(deps), @unlock[:gems], true, true)
  resolve = resolve.for(expand_dependencies(deps, true), @unlock[:gems], false, false, false)
  diff    = nil

  # Now, we unlock any sources that do not have anymore gems pinned to it
  sources.all_sources.each do |source|
    next unless source.respond_to?(:unlock!)

    unless resolve.any? {|s| s.source == source }
      diff ||= @locked_specs.to_a - resolve.to_a
      source.unlock! if diff.any? {|s| s.source == source }
    end
  end

  resolve
end</pre> </div> <p>Remove elements from the locked specs that are expired. This will most commonly happen if the Gemfile has changed since the lockfile was last generated</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-converge_path_source_to_gemspec_source"> <span class="method-name">converge_path_source_to_gemspec_source</span><span class="method-args">(source)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="converge_path_source_to_gemspec_source-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 633
def converge_path_source_to_gemspec_source(source)
  return source unless source.instance_of?(Source::Path)
  gemspec_source = sources.path_sources.find {|s| s.is_a?(Source::Gemspec) &amp;&amp; s.as_path_source == source }
  gemspec_source || source
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-converge_path_sources_to_gemspec_sources"> <span class="method-name">converge_path_sources_to_gemspec_sources</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="converge_path_sources_to_gemspec_sources-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 639
def converge_path_sources_to_gemspec_sources
  @locked_sources.map! do |source|
    converge_path_source_to_gemspec_source(source)
  end
  @locked_specs.each do |spec|
    spec.source &amp;&amp;= converge_path_source_to_gemspec_source(spec.source)
  end
  @locked_deps.each do |_, dep|
    dep.source &amp;&amp;= converge_path_source_to_gemspec_source(dep.source)
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-converge_paths"> <span class="method-name">converge_paths</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="converge_paths-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 627
def converge_paths
  sources.path_sources.any? do |source|
    specs_changed?(source)
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-converge_rubygems_sources"> <span class="method-name">converge_rubygems_sources</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="converge_rubygems_sources-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 651
def converge_rubygems_sources
  return false if Bundler.feature_flag.disable_multisource?

  changes = false

  # Get the RubyGems sources from the Gemfile.lock
  locked_gem_sources = @locked_sources.select {|s| s.is_a?(Source::Rubygems) }
  # Get the RubyGems remotes from the Gemfile
  actual_remotes = sources.rubygems_remotes

  # If there is a RubyGems source in both
  if !locked_gem_sources.empty? &amp;&amp; !actual_remotes.empty?
    locked_gem_sources.each do |locked_gem|
      # Merge the remotes from the Gemfile into the Gemfile.lock
      changes |= locked_gem.replace_remotes(actual_remotes, Bundler.settings[:allow_deployment_source_credential_changes])
    end
  end

  changes
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-converge_sources"> <span class="method-name">converge_sources</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="converge_sources-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 672
def converge_sources
  changes = false

  changes |= converge_rubygems_sources

  # Replace the sources from the Gemfile with the sources from the Gemfile.lock,
  # if they exist in the Gemfile.lock and are `==`. If you can't find an equivalent
  # source in the Gemfile.lock, use the one from the Gemfile.
  changes |= sources.replace_sources!(@locked_sources)

  sources.all_sources.each do |source|
    # If the source is unlockable and the current command allows an unlock of
    # the source (for example, you are doing a `bundle update &lt;foo&gt;` of a git-pinned
    # gem), unlock it. For git sources, this means to unlock the revision, which
    # will cause the `ref` used to be the most recent for the branch (or master) if
    # an explicit `ref` is not used.
    if source.respond_to?(:unlock!) &amp;&amp; @unlock[:sources].include?(source.name)
      source.unlock!
      changes = true
    end
  end

  changes
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-current_platforms"> <span class="method-name">current_platforms</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="current_platforms-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 546
def current_platforms
  current_platform = Bundler.local_platform
  [].tap do |platforms|
    platforms &lt;&lt; current_platform if Bundler.feature_flag.specific_platform?
    platforms &lt;&lt; generic(current_platform)
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-dependencies_for_source_changed-3F"> <span class="method-name">dependencies_for_source_changed?</span><span class="method-args">(source, locked_source = source)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="dependencies_for_source_changed-3F-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 588
def dependencies_for_source_changed?(source, locked_source = source)
  deps_for_source = @dependencies.select {|s| s.source == source }
  locked_deps_for_source = @locked_deps.values.select {|dep| dep.source == locked_source }

  Set.new(deps_for_source) != Set.new(locked_deps_for_source)
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-double_check_for_index"> <span class="method-name">double_check_for_index</span><span class="method-args">(idx, dependency_names)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="double_check_for_index-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 286
def double_check_for_index(idx, dependency_names)
  pinned_names = pinned_spec_names
  loop do
    idxcount = idx.size

    names = :names # do this so we only have to traverse to get dependency_names from the index once
    unmet_dependency_names = lambda do
      return names unless names == :names
      new_names = sources.all_sources.map(&amp;:dependency_names_to_double_check)
      return names = nil if new_names.compact!
      names = new_names.flatten(1).concat(dependency_names)
      names.uniq!
      names -= pinned_names
      names
    end

    sources.all_sources.each do |source|
      source.double_check_for(unmet_dependency_names)
    end

    break if idxcount == idx.size
  end
end</pre> </div> <p>Suppose the gem Foo depends on the gem Bar. Foo exists in <a href="source"><code>Source</code></a> A. Bar has some versions that exist in both sources A and B. At this point, the API request will have found all the versions of Bar in source A, but will not have found any versions of Bar from source B, which is a problem if the requested version of Foo specifically depends on a version of Bar that is only found in source B. This ensures that for each spec we found, we add all possible versions from all sources to the index.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-equivalent_rubygems_remotes-3F"> <span class="method-name">equivalent_rubygems_remotes?</span><span class="method-args">(source)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="equivalent_rubygems_remotes-3F-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 996
def equivalent_rubygems_remotes?(source)
  return false unless source.is_a?(Source::Rubygems)

  Bundler.settings[:allow_deployment_source_credential_changes] &amp;&amp; source.equivalent_remotes?(sources.rubygems_remotes)
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-expand_dependencies"> <span class="method-name">expand_dependencies</span><span class="method-args">(dependencies, remote = false)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="expand_dependencies-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 887
def expand_dependencies(dependencies, remote = false)
  sorted_platforms = Resolver.sort_platforms(@platforms)
  deps = []
  dependencies.each do |dep|
    dep = Dependency.new(dep, "&gt;= 0") unless dep.respond_to?(:name)
    next if !remote &amp;&amp; !dep.current_platform?
    platforms = dep.gem_platforms(sorted_platforms)
    if platforms.empty? &amp;&amp; !Bundler.settings[:disable_platform_warnings]
      mapped_platforms = dep.expanded_platforms
      Bundler.ui.warn \
        "The dependency #{dep} will be unused by any of the platforms Bundler is installing for. " \
        "Bundler is installing for #{@platforms.join ", "} but the dependency " \
        "is only for #{mapped_platforms.join ", "}. " \
        "To add those platforms to the bundle, " \
        "run `bundle lock --add-platform #{mapped_platforms.join " "}`."
    end
    platforms.each do |p|
      deps &lt;&lt; DepProxy.new(dep, p) if remote || p == generic_local_platform
    end
  end
  deps
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-expanded_dependencies"> <span class="method-name">expanded_dependencies</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="expanded_dependencies-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 851
def expanded_dependencies
  @expanded_dependencies ||= begin
    expand_dependencies(dependencies + metadata_dependencies, @remote)
  end
end</pre> </div> <p>This list of dependencies is only used in <a href="definition#method-i-resolve"><code>resolve</code></a>, so it's OK to add the metadata dependencies here</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-extract_gem_info"> <span class="method-name">extract_gem_info</span><span class="method-args">(error)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="extract_gem_info-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 965
def extract_gem_info(error)
  # This method will extract the error message like "Could not find foo-1.2.3 in any of the sources"
  # to an array. The first element will be the gem name (e.g. foo), the second will be the version number.
  error.message.scan(/Could not find (\w+)-(\d+(?:\.\d+)+)/).flatten
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-in_locked_deps-3F"> <span class="method-name">in_locked_deps?</span><span class="method-args">(dep, locked_dep)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="in_locked_deps-3F-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 838
def in_locked_deps?(dep, locked_dep)
  # Because the lockfile can't link a dep to a specific remote, we need to
  # treat sources as equivalent anytime the locked dep has all the remotes
  # that the Gemfile dep does.
  locked_dep &amp;&amp; locked_dep.source &amp;&amp; dep.source &amp;&amp; locked_dep.source.include?(dep.source)
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-lockfiles_equal-3F"> <span class="method-name">lockfiles_equal?</span><span class="method-args">(current, proposed, preserve_unknown_sections)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="lockfiles_equal-3F-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 952
def lockfiles_equal?(current, proposed, preserve_unknown_sections)
  if preserve_unknown_sections
    sections_to_ignore = LockfileParser.sections_to_ignore(@locked_bundler_version)
    sections_to_ignore += LockfileParser.unknown_sections_in_lockfile(current)
    sections_to_ignore += LockfileParser::ENVIRONMENT_VERSION_SECTIONS
    pattern = /#{Regexp.union(sections_to_ignore)}\n(\s{2,}.*\n)+/
    whitespace_cleanup = /\n{2,}/
    current = current.gsub(pattern, "\n").gsub(whitespace_cleanup, "\n\n").strip
    proposed = proposed.gsub(pattern, "\n").gsub(whitespace_cleanup, "\n\n").strip
  end
  current == proposed
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-metadata_dependencies"> <span class="method-name">metadata_dependencies</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="metadata_dependencies-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 857
def metadata_dependencies
  @metadata_dependencies ||= begin
    ruby_versions = concat_ruby_version_requirements(@ruby_version)
    if ruby_versions.empty? || !@ruby_version.exact?
      concat_ruby_version_requirements(RubyVersion.system)
      concat_ruby_version_requirements(locked_ruby_version_object) unless @unlock[:ruby]
    end
    [
      Dependency.new("Ruby\0", ruby_versions),
      Dependency.new("RubyGems\0", Gem::VERSION),
    ]
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-pinned_spec_names"> <span class="method-name">pinned_spec_names</span><span class="method-args">(skip = nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="pinned_spec_names-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 937
def pinned_spec_names(skip = nil)
  pinned_names = []
  default = Bundler.feature_flag.disable_multisource? &amp;&amp; sources.default_source
  @dependencies.each do |dep|
    next unless dep_source = dep.source || default
    next if dep_source == skip
    pinned_names &lt;&lt; dep.name
  end
  pinned_names
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-pretty_dep"> <span class="method-name">pretty_dep</span><span class="method-args">(dep, source = false)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="pretty_dep-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 576
def pretty_dep(dep, source = false)
  SharedHelpers.pretty_dependency(dep, source)
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-requested_dependencies"> <span class="method-name">requested_dependencies</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="requested_dependencies-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 910
def requested_dependencies
  groups = requested_groups
  groups.map!(&amp;:to_sym)
  dependencies.reject {|d| !d.should_include? || (d.groups &amp; groups).empty? }
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-requested_groups"> <span class="method-name">requested_groups</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="requested_groups-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 948
def requested_groups
  groups - Bundler.settings[:without] - @optional_groups + Bundler.settings[:with]
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-satisfies_locked_spec-3F"> <span class="method-name">satisfies_locked_spec?</span><span class="method-args">(dep)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="satisfies_locked_spec-3F-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 845
def satisfies_locked_spec?(dep)
  @locked_specs[dep].any? {|s| s.satisfies?(dep) &amp;&amp; (!dep.source || s.source.include?(dep.source)) }
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-source_requirements"> <span class="method-name">source_requirements</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="source_requirements-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 916
def source_requirements
  # Load all specs from remote sources
  index

  # Record the specs available in each gem's source, so that those
  # specs will be available later when the resolver knows where to
  # look for that gemspec (or its dependencies)
  default = sources.default_source
  source_requirements = { :default =&gt; default }
  default = nil unless Bundler.feature_flag.disable_multisource?
  dependencies.each do |dep|
    next unless source = dep.source || default
    source_requirements[dep.name] = source
  end
  metadata_dependencies.each do |dep|
    source_requirements[dep.name] = sources.metadata_source
  end
  source_requirements["bundler"] = sources.metadata_source # needs to come last to override
  source_requirements
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-specs_changed-3F"> <span class="method-name">specs_changed?</span><span class="method-args">(source)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="specs_changed-3F-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 582
def specs_changed?(source)
  locked = @locked_sources.find {|s| s == source }

  !locked || dependencies_for_source_changed?(source, locked) || specs_for_source_changed?(source)
end</pre> </div> <p>Check if the specs of the given source changed according to the locked source.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-specs_for_source_changed-3F"> <span class="method-name">specs_for_source_changed?</span><span class="method-args">(source)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="specs_for_source_changed-3F-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/definition.rb, line 595
def specs_for_source_changed?(source)
  locked_index = Index.new
  locked_index.use(@locked_specs.select {|s| source.can_lock?(s) })

  # order here matters, since Index#== is checking source.specs.include?(locked_index)
  locked_index != source.specs
rescue PathError, GitError =&gt; e
  Bundler.ui.debug "Assuming that #{source} has not changed since fetching its specs errored (#{e})"
  false
end</pre> </div>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core  19932017 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library  contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
