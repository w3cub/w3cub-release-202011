
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>BasicSocket - Ruby 2.7 - W3cubDocs</title>
  
  <meta name="description" content=" BasicSocket is the super class for all the Socket classes. ">
  <meta name="keywords" content="class, basicsocket, ruby, ruby~2.7">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/ruby~2.7/basicsocket.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/ruby~2.7.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/ruby~2.7/" class="_nav-link" title="" style="margin-left:0;">Ruby 2.7</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _rdoc">
				
				
<h1 id="class-BasicSocket" class="class"> class BasicSocket </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="io">IO</a></dd>
</dl> <section class="description"> <p><a href="basicsocket"><code>BasicSocket</code></a> is the super class for all the <a href="socket"><code>Socket</code></a> classes.</p> </section> <section id="5Buntitled-5D" class="documentation-section"> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-c-do_not_reverse_lookup"> <span class="method-callseq"> do_not_reverse_lookup → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="do_not_reverse_lookup-source"> <pre class="c" data-language="c">static VALUE
bsock_do_not_rev_lookup(VALUE _)
{
    return rsock_do_not_reverse_lookup?Qtrue:Qfalse;
}</pre> </div> <p>Gets the global <a href="basicsocket#method-c-do_not_reverse_lookup"><code>do_not_reverse_lookup</code></a> flag.</p> <pre class="ruby" data-language="ruby">BasicSocket.do_not_reverse_lookup  #=&gt; false
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-do_not_reverse_lookup-3D"> <span class="method-callseq"> do_not_reverse_lookup = bool </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="do_not_reverse_lookup-3D-source"> <pre class="c" data-language="c">static VALUE
bsock_do_not_rev_lookup_set(VALUE self, VALUE val)
{
    rsock_do_not_reverse_lookup = RTEST(val);
    return val;
}</pre> </div> <p>Sets the global <a href="basicsocket#method-c-do_not_reverse_lookup"><code>do_not_reverse_lookup</code></a> flag.</p> <p>The flag is used for initial value of <a href="basicsocket#method-c-do_not_reverse_lookup"><code>do_not_reverse_lookup</code></a> for each socket.</p> <pre class="ruby" data-language="ruby">s1 = TCPSocket.new("localhost", 80)
p s1.do_not_reverse_lookup                 #=&gt; true
BasicSocket.do_not_reverse_lookup = false
s2 = TCPSocket.new("localhost", 80)
p s2.do_not_reverse_lookup                 #=&gt; false
p s1.do_not_reverse_lookup                 #=&gt; true
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-for_fd"> <span class="method-callseq"> for_fd(fd) → basicsocket </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="for_fd-source"> <pre class="c" data-language="c">static VALUE
bsock_s_for_fd(VALUE klass, VALUE fd)
{
    rb_io_t *fptr;
    VALUE sock = rsock_init_sock(rb_obj_alloc(klass), NUM2INT(fd));

    GetOpenFile(sock, fptr);

    return sock;
}</pre> </div> <p>Returns a socket object which contains the file descriptor, <em>fd</em>.</p> <pre class="ruby" data-language="ruby"># If invoked by inetd, STDIN/STDOUT/STDERR is a socket.
STDIN_SOCK = Socket.for_fd(STDIN.fileno)
p STDIN_SOCK.remote_address
</pre>  </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-close_read"> <span class="method-callseq"> close_read → nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="close_read-source"> <pre class="c" data-language="c">static VALUE
bsock_close_read(VALUE sock)
{
    rb_io_t *fptr;

    GetOpenFile(sock, fptr);
    shutdown(fptr-&gt;fd, 0);
    if (!(fptr-&gt;mode &amp; FMODE_WRITABLE)) {
        return rb_io_close(sock);
    }
    fptr-&gt;mode &amp;= ~FMODE_READABLE;

    return Qnil;
}</pre> </div> <p>Disallows further read using shutdown system call.</p> <pre class="ruby" data-language="ruby">s1, s2 = UNIXSocket.pair
s1.close_read
s2.puts #=&gt; Broken pipe (Errno::EPIPE)
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-close_write"> <span class="method-callseq"> close_write → nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="close_write-source"> <pre class="c" data-language="c">static VALUE
bsock_close_write(VALUE sock)
{
    rb_io_t *fptr;

    GetOpenFile(sock, fptr);
    if (!(fptr-&gt;mode &amp; FMODE_READABLE)) {
        return rb_io_close(sock);
    }
    shutdown(fptr-&gt;fd, 1);
    fptr-&gt;mode &amp;= ~FMODE_WRITABLE;

    return Qnil;
}</pre> </div> <p>Disallows further write using shutdown system call.</p> <pre class="ruby" data-language="ruby">UNIXSocket.pair {|s1, s2|
  s1.print "ping"
  s1.close_write
  p s2.read        #=&gt; "ping"
  s2.print "pong"
  s2.close
  p s1.read        #=&gt; "pong"
}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-connect_address"> <span class="method-name">connect_address</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="connect_address-source"> <pre class="ruby" data-language="ruby"># File ext/socket/lib/socket.rb, line 251
def connect_address
  addr = local_address
  afamily = addr.afamily
  if afamily == Socket::AF_INET
    raise SocketError, "unbound IPv4 socket" if addr.ip_port == 0
    if addr.ip_address == "0.0.0.0"
      addr = Addrinfo.new(["AF_INET", addr.ip_port, nil, "127.0.0.1"], addr.pfamily, addr.socktype, addr.protocol)
    end
  elsif defined?(Socket::AF_INET6) &amp;&amp; afamily == Socket::AF_INET6
    raise SocketError, "unbound IPv6 socket" if addr.ip_port == 0
    if addr.ip_address == "::"
      addr = Addrinfo.new(["AF_INET6", addr.ip_port, nil, "::1"], addr.pfamily, addr.socktype, addr.protocol)
    elsif addr.ip_address == "0.0.0.0" # MacOS X 10.4 returns "a.b.c.d" for IPv4-mapped IPv6 address.
      addr = Addrinfo.new(["AF_INET6", addr.ip_port, nil, "::1"], addr.pfamily, addr.socktype, addr.protocol)
    elsif addr.ip_address == "::ffff:0.0.0.0" # MacOS X 10.6 returns "::ffff:a.b.c.d" for IPv4-mapped IPv6 address.
      addr = Addrinfo.new(["AF_INET6", addr.ip_port, nil, "::1"], addr.pfamily, addr.socktype, addr.protocol)
    end
  elsif defined?(Socket::AF_UNIX) &amp;&amp; afamily == Socket::AF_UNIX
    raise SocketError, "unbound Unix socket" if addr.unix_path == ""
  end
  addr
end</pre> </div> <p>Returns an address of the socket suitable for connect in the local machine.</p> <p>This method returns <em>self</em>.local_address, except following condition.</p> <ul>
<li> <p>IPv4 unspecified address (0.0.0.0) is replaced by IPv4 loopback address (127.0.0.1).</p> </li>
<li> <p>IPv6 unspecified address (::) is replaced by IPv6 loopback address (::1).</p> </li>
</ul> <p>If the local address is not suitable for connect, <a href="socketerror"><code>SocketError</code></a> is raised. IPv4 and IPv6 address which port is 0 is not suitable for connect. Unix domain socket which has no path is not suitable for connect.</p> <pre class="ruby" data-language="ruby">Addrinfo.tcp("0.0.0.0", 0).listen {|serv|
  p serv.connect_address #=&gt; #&lt;Addrinfo: 127.0.0.1:53660 TCP&gt;
  serv.connect_address.connect {|c|
    s, _ = serv.accept
    p [c, s] #=&gt; [#&lt;Socket:fd 4&gt;, #&lt;Socket:fd 6&gt;]
  }
}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-do_not_reverse_lookup"> <span class="method-callseq"> do_not_reverse_lookup → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="do_not_reverse_lookup-source"> <pre class="c" data-language="c">static VALUE
bsock_do_not_reverse_lookup(VALUE sock)
{
    rb_io_t *fptr;

    GetOpenFile(sock, fptr);
    return (fptr-&gt;mode &amp; FMODE_NOREVLOOKUP) ? Qtrue : Qfalse;
}</pre> </div> <p>Gets the <a href="basicsocket#method-c-do_not_reverse_lookup"><code>do_not_reverse_lookup</code></a> flag of <em>basicsocket</em>.</p> <pre class="ruby" data-language="ruby">require 'socket'

BasicSocket.do_not_reverse_lookup = false
TCPSocket.open("www.ruby-lang.org", 80) {|sock|
  p sock.do_not_reverse_lookup      #=&gt; false
}
BasicSocket.do_not_reverse_lookup = true
TCPSocket.open("www.ruby-lang.org", 80) {|sock|
  p sock.do_not_reverse_lookup      #=&gt; true
}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-do_not_reverse_lookup-3D"> <span class="method-callseq"> do_not_reverse_lookup = bool </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="do_not_reverse_lookup-3D-source"> <pre class="c" data-language="c">static VALUE
bsock_do_not_reverse_lookup_set(VALUE sock, VALUE state)
{
    rb_io_t *fptr;

    GetOpenFile(sock, fptr);
    if (RTEST(state)) {
        fptr-&gt;mode |= FMODE_NOREVLOOKUP;
    }
    else {
        fptr-&gt;mode &amp;= ~FMODE_NOREVLOOKUP;
    }
    return sock;
}</pre> </div> <p>Sets the <a href="basicsocket#method-c-do_not_reverse_lookup"><code>do_not_reverse_lookup</code></a> flag of <em>basicsocket</em>.</p> <pre class="ruby" data-language="ruby">TCPSocket.open("www.ruby-lang.org", 80) {|sock|
  p sock.do_not_reverse_lookup       #=&gt; true
  p sock.peeraddr                    #=&gt; ["AF_INET", 80, "221.186.184.68", "221.186.184.68"]
  sock.do_not_reverse_lookup = false
  p sock.peeraddr                    #=&gt; ["AF_INET", 80, "carbon.ruby-lang.org", "54.163.249.195"]
}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-getpeereid"> <span class="method-callseq"> getpeereid → [euid, egid] </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="getpeereid-source"> <pre class="c" data-language="c">static VALUE
bsock_getpeereid(VALUE self)
{
#if defined(HAVE_GETPEEREID)
    rb_io_t *fptr;
    uid_t euid;
    gid_t egid;
    GetOpenFile(self, fptr);
    if (getpeereid(fptr-&gt;fd, &amp;euid, &amp;egid) == -1)
        rb_sys_fail("getpeereid(3)");
    return rb_assoc_new(UIDT2NUM(euid), GIDT2NUM(egid));
#elif defined(SO_PEERCRED) /* GNU/Linux */
    rb_io_t *fptr;
    struct ucred cred;
    socklen_t len = sizeof(cred);
    GetOpenFile(self, fptr);
    if (getsockopt(fptr-&gt;fd, SOL_SOCKET, SO_PEERCRED, &amp;cred, &amp;len) == -1)
        rb_sys_fail("getsockopt(SO_PEERCRED)");
    return rb_assoc_new(UIDT2NUM(cred.uid), GIDT2NUM(cred.gid));
#elif defined(HAVE_GETPEERUCRED) /* Solaris */
    rb_io_t *fptr;
    ucred_t *uc = NULL;
    VALUE ret;
    GetOpenFile(self, fptr);
    if (getpeerucred(fptr-&gt;fd, &amp;uc) == -1)
        rb_sys_fail("getpeerucred(3C)");
    ret = rb_assoc_new(UIDT2NUM(ucred_geteuid(uc)), GIDT2NUM(ucred_getegid(uc)));
    ucred_free(uc);
    return ret;
#endif
}</pre> </div> <p>Returns the user and group on the peer of the UNIX socket. The result is a two element array which contains the effective uid and the effective gid.</p> <pre class="ruby" data-language="ruby">Socket.unix_server_loop("/tmp/sock") {|s|
  begin
    euid, egid = s.getpeereid

    # Check the connected client is myself or not.
    next if euid != Process.uid

    # do something about my resource.

  ensure
    s.close
  end
}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-getpeername"> <span class="method-callseq"> getpeername → sockaddr </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="getpeername-source"> <pre class="c" data-language="c">static VALUE
bsock_getpeername(VALUE sock)
{
    union_sockaddr buf;
    socklen_t len = (socklen_t)sizeof buf;
    socklen_t len0 = len;
    rb_io_t *fptr;

    GetOpenFile(sock, fptr);
    if (getpeername(fptr-&gt;fd, &amp;buf.addr, &amp;len) &lt; 0)
        rb_sys_fail("getpeername(2)");
    if (len0 &lt; len) len = len0;
    return rb_str_new((char*)&amp;buf, len);
}</pre> </div> <p>Returns the remote address of the socket as a sockaddr string.</p> <pre class="ruby" data-language="ruby">TCPServer.open("127.0.0.1", 1440) {|serv|
  c = TCPSocket.new("127.0.0.1", 1440)
  s = serv.accept
  p s.getpeername #=&gt; "\x02\x00\x82u\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00"
}
</pre> <p>If <a href="addrinfo"><code>Addrinfo</code></a> object is preferred over the binary string, use <a href="basicsocket#method-i-remote_address"><code>BasicSocket#remote_address</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-getsockname"> <span class="method-callseq"> getsockname → sockaddr </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="getsockname-source"> <pre class="c" data-language="c">static VALUE
bsock_getsockname(VALUE sock)
{
    union_sockaddr buf;
    socklen_t len = (socklen_t)sizeof buf;
    socklen_t len0 = len;
    rb_io_t *fptr;

    GetOpenFile(sock, fptr);
    if (getsockname(fptr-&gt;fd, &amp;buf.addr, &amp;len) &lt; 0)
        rb_sys_fail("getsockname(2)");
    if (len0 &lt; len) len = len0;
    return rb_str_new((char*)&amp;buf, len);
}</pre> </div> <p>Returns the local address of the socket as a sockaddr string.</p> <pre class="ruby" data-language="ruby">TCPServer.open("127.0.0.1", 15120) {|serv|
  p serv.getsockname #=&gt; "\x02\x00;\x10\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00"
}
</pre> <p>If <a href="addrinfo"><code>Addrinfo</code></a> object is preferred over the binary string, use <a href="basicsocket#method-i-local_address"><code>BasicSocket#local_address</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-getsockopt"> <span class="method-callseq"> getsockopt(level, optname) → socketoption </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="getsockopt-source"> <pre class="c" data-language="c">static VALUE
bsock_getsockopt(VALUE sock, VALUE lev, VALUE optname)
{
    int level, option;
    socklen_t len;
    char *buf;
    rb_io_t *fptr;
    int family;

    GetOpenFile(sock, fptr);
    family = rsock_getfamily(fptr);
    level = rsock_level_arg(family, lev);
    option = rsock_optname_arg(family, level, optname);
    len = 256;
#ifdef _AIX
    switch (option) {
      case SO_DEBUG:
      case SO_REUSEADDR:
      case SO_KEEPALIVE:
      case SO_DONTROUTE:
      case SO_BROADCAST:
      case SO_OOBINLINE:
        /* AIX doesn't set len for boolean options */
        len = sizeof(int);
    }
#endif
    buf = ALLOCA_N(char,len);

    rb_io_check_closed(fptr);

    if (getsockopt(fptr-&gt;fd, level, option, buf, &amp;len) &lt; 0)
        rsock_sys_fail_path("getsockopt(2)", fptr-&gt;pathv);

    return rsock_sockopt_new(family, level, option, rb_str_new(buf, len));
}</pre> </div> <p>Gets a socket option. These are protocol and system specific, see your local system documentation for details. The option is returned as a <a href="socket/option"><code>Socket::Option</code></a> object.</p> <h3 id="method-i-getsockopt-label-Parameters">Parameters</h3> <ul>
<li> <p><code>level</code> is an integer, usually one of the SOL_ constants such as Socket::SOL_SOCKET, or a protocol level. A string or symbol of the name, possibly without prefix, is also accepted.</p> </li>
<li> <p><code>optname</code> is an integer, usually one of the SO_ constants, such as Socket::SO_REUSEADDR. A string or symbol of the name, possibly without prefix, is also accepted.</p> </li>
</ul> <h3 id="method-i-getsockopt-label-Examples">Examples</h3> <p>Some socket options are integers with boolean values, in this case <a href="basicsocket#method-i-getsockopt"><code>getsockopt</code></a> could be called like this:</p> <pre class="ruby" data-language="ruby">reuseaddr = sock.getsockopt(:SOCKET, :REUSEADDR).bool

optval = sock.getsockopt(Socket::SOL_SOCKET,Socket::SO_REUSEADDR)
optval = optval.unpack "i"
reuseaddr = optval[0] == 0 ? false : true
</pre> <p>Some socket options are integers with numeric values, in this case <a href="basicsocket#method-i-getsockopt"><code>getsockopt</code></a> could be called like this:</p> <pre class="ruby" data-language="ruby">ipttl = sock.getsockopt(:IP, :TTL).int

optval = sock.getsockopt(Socket::IPPROTO_IP, Socket::IP_TTL)
ipttl = optval.unpack("i")[0]
</pre> <p>Option values may be structs. Decoding them can be complex as it involves examining your system headers to determine the correct definition. An example is a +struct linger+, which may be defined in your system headers as:</p> <pre class="ruby" data-language="ruby">struct linger {
  int l_onoff;
  int l_linger;
};
</pre> <p>In this case <a href="basicsocket#method-i-getsockopt"><code>getsockopt</code></a> could be called like this:</p> <pre class="ruby" data-language="ruby"># Socket::Option knows linger structure.
onoff, linger = sock.getsockopt(:SOCKET, :LINGER).linger

optval =  sock.getsockopt(Socket::SOL_SOCKET, Socket::SO_LINGER)
onoff, linger = optval.unpack "ii"
onoff = onoff == 0 ? false : true
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-local_address"> <span class="method-callseq"> local_address → addrinfo </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="local_address-source"> <pre class="c" data-language="c">static VALUE
bsock_local_address(VALUE sock)
{
    union_sockaddr buf;
    socklen_t len = (socklen_t)sizeof buf;
    socklen_t len0 = len;
    rb_io_t *fptr;

    GetOpenFile(sock, fptr);
    if (getsockname(fptr-&gt;fd, &amp;buf.addr, &amp;len) &lt; 0)
        rb_sys_fail("getsockname(2)");
    if (len0 &lt; len) len = len0;
    return rsock_fd_socket_addrinfo(fptr-&gt;fd, &amp;buf.addr, len);
}</pre> </div> <p>Returns an <a href="addrinfo"><code>Addrinfo</code></a> object for local address obtained by getsockname.</p> <p>Note that addrinfo.protocol is filled by 0.</p> <pre class="ruby" data-language="ruby">TCPSocket.open("www.ruby-lang.org", 80) {|s|
  p s.local_address #=&gt; #&lt;Addrinfo: 192.168.0.129:36873 TCP&gt;
}

TCPServer.open("127.0.0.1", 1512) {|serv|
  p serv.local_address #=&gt; #&lt;Addrinfo: 127.0.0.1:1512 TCP&gt;
}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-recv"> <span class="method-callseq"> recv(maxlen[, flags[, outbuf]]) → mesg </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="recv-source"> <pre class="c" data-language="c">static VALUE
bsock_recv(int argc, VALUE *argv, VALUE sock)
{
    return rsock_s_recvfrom(sock, argc, argv, RECV_RECV);
}</pre> </div> <p>Receives a message.</p> <p><em>maxlen</em> is the maximum number of bytes to receive.</p> <p><em>flags</em> should be a bitwise OR of Socket::MSG_* constants.</p> <p><em>outbuf</em> will contain only the received data after the method call even if it is not empty at the beginning.</p> <pre class="ruby" data-language="ruby">UNIXSocket.pair {|s1, s2|
  s1.puts "Hello World"
  p s2.recv(4)                     #=&gt; "Hell"
  p s2.recv(4, Socket::MSG_PEEK)   #=&gt; "o Wo"
  p s2.recv(4)                     #=&gt; "o Wo"
  p s2.recv(10)                    #=&gt; "rld\n"
}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-recv_nonblock"> <span class="method-callseq"> recv_nonblock(maxlen [, flags [, buf [, options ]]]) → mesg </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="recv_nonblock-source"> <pre class="ruby" data-language="ruby"># File ext/socket/lib/socket.rb, line 371
def recv_nonblock(len, flag = 0, str = nil, exception: true)
  __recv_nonblock(len, flag, str, exception)
end</pre> </div> <p>Receives up to <em>maxlen</em> bytes from <code>socket</code> using recvfrom(2) after O_NONBLOCK is set for the underlying file descriptor. <em>flags</em> is zero or more of the <code>MSG_</code> options. The result, <em>mesg</em>, is the data received.</p> <p>When recvfrom(2) returns 0, <a href="basicsocket#method-i-recv_nonblock"><code>Socket#recv_nonblock</code></a> returns an empty string as data. The meaning depends on the socket: EOF on TCP, empty packet on UDP, etc.</p> <h3 id="method-i-recv_nonblock-label-Parameters">Parameters</h3> <ul>
<li> <p><code>maxlen</code> - the number of bytes to receive from the socket</p> </li>
<li> <p><code>flags</code> - zero or more of the <code>MSG_</code> options</p> </li>
<li> <p><code>buf</code> - destination <a href="string"><code>String</code></a> buffer</p> </li>
<li> <p><code>options</code> - keyword hash, supporting `exception: false`</p> </li>
</ul> <h3 id="method-i-recv_nonblock-label-Example">Example</h3> <pre class="ruby" data-language="ruby">serv = TCPServer.new("127.0.0.1", 0)
af, port, host, addr = serv.addr
c = TCPSocket.new(addr, port)
s = serv.accept
c.send "aaa", 0
begin # emulate blocking recv.
  p s.recv_nonblock(10) #=&gt; "aaa"
rescue IO::WaitReadable
  IO.select([s])
  retry
end
</pre> <p>Refer to <a href="socket#method-i-recvfrom"><code>Socket#recvfrom</code></a> for the exceptions that may be thrown if the call to <em>recv_nonblock</em> fails.</p> <p><a href="basicsocket#method-i-recv_nonblock"><code>BasicSocket#recv_nonblock</code></a> may raise any error corresponding to recvfrom(2) failure, including Errno::EWOULDBLOCK.</p> <p>If the exception is Errno::EWOULDBLOCK or Errno::EAGAIN, it is extended by <a href="io/waitreadable"><code>IO::WaitReadable</code></a>. So <a href="io/waitreadable"><code>IO::WaitReadable</code></a> can be used to rescue the exceptions for retrying recv_nonblock.</p> <p>By specifying a keyword argument <em>exception</em> to <code>false</code>, you can indicate that <a href="basicsocket#method-i-recv_nonblock"><code>recv_nonblock</code></a> should not raise an <a href="io/waitreadable"><code>IO::WaitReadable</code></a> exception, but return the symbol <code>:wait_readable</code> instead.</p> <h3 id="method-i-recv_nonblock-label-See">See</h3> <ul><li> <p><a href="socket#method-i-recvfrom"><code>Socket#recvfrom</code></a></p> </li></ul>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-recvmsg"> <span class="method-callseq"> recvmsg(maxmesglen=nil, flags=0, maxcontrollen=nil, opts={}) → [mesg, sender_addrinfo, rflags, *controls] </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="recvmsg-source"> <pre class="ruby" data-language="ruby"># File ext/socket/lib/socket.rb, line 426
def recvmsg(dlen = nil, flags = 0, clen = nil, scm_rights: false)
  __recvmsg(dlen, flags, clen, scm_rights)
end</pre> </div> <p>recvmsg receives a message using recvmsg(2) system call in blocking manner.</p> <p><em>maxmesglen</em> is the maximum length of mesg to receive.</p> <p><em>flags</em> is bitwise OR of MSG_* constants such as Socket::MSG_PEEK.</p> <p><em>maxcontrollen</em> is the maximum length of controls (ancillary data) to receive.</p> <p><em>opts</em> is option hash. Currently :scm_rights=&gt;bool is the only option.</p> <p>:scm_rights option specifies that application expects SCM_RIGHTS control message. If the value is nil or false, application don't expects SCM_RIGHTS control message. In this case, recvmsg closes the passed file descriptors immediately. This is the default behavior.</p> <p>If :scm_rights value is neither nil nor false, application expects SCM_RIGHTS control message. In this case, recvmsg creates <a href="io"><code>IO</code></a> objects for each file descriptors for <a href="socket/ancillarydata#method-i-unix_rights"><code>Socket::AncillaryData#unix_rights</code></a> method.</p> <p>The return value is 4-elements array.</p> <p><em>mesg</em> is a string of the received message.</p> <p><em>sender_addrinfo</em> is a sender socket address for connection-less socket. It is an <a href="addrinfo"><code>Addrinfo</code></a> object. For connection-oriented socket such as TCP, sender_addrinfo is platform dependent.</p> <p><em>rflags</em> is a flags on the received message which is bitwise OR of MSG_* constants such as Socket::MSG_TRUNC. It will be nil if the system uses 4.3BSD style old recvmsg system call.</p> <p><em>controls</em> is ancillary data which is an array of <a href="socket/ancillarydata"><code>Socket::AncillaryData</code></a> objects such as:</p> <pre class="ruby" data-language="ruby">#&lt;Socket::AncillaryData: AF_UNIX SOCKET RIGHTS 7&gt;
</pre> <p><em>maxmesglen</em> and <em>maxcontrollen</em> can be nil. In that case, the buffer will be grown until the message is not truncated. Internally, MSG_PEEK is used. Buffer full and MSG_CTRUNC are checked for truncation.</p> <p>recvmsg can be used to implement recv_io as follows:</p> <pre class="ruby" data-language="ruby">mesg, sender_sockaddr, rflags, *controls = sock.recvmsg(:scm_rights=&gt;true)
controls.each {|ancdata|
  if ancdata.cmsg_is?(:SOCKET, :RIGHTS)
    return ancdata.unix_rights[0]
  end
}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-recvmsg_nonblock"> <span class="method-callseq"> recvmsg_nonblock(maxdatalen=nil, flags=0, maxcontrollen=nil, opts={}) → [data, sender_addrinfo, rflags, *controls] </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="recvmsg_nonblock-source"> <pre class="ruby" data-language="ruby"># File ext/socket/lib/socket.rb, line 442
def recvmsg_nonblock(dlen = nil, flags = 0, clen = nil,
                     scm_rights: false, exception: true)
  __recvmsg_nonblock(dlen, flags, clen, scm_rights, exception)
end</pre> </div> <p>recvmsg receives a message using recvmsg(2) system call in non-blocking manner.</p> <p>It is similar to <a href="basicsocket#method-i-recvmsg"><code>BasicSocket#recvmsg</code></a> but non-blocking flag is set before the system call and it doesn't retry the system call.</p> <p>By specifying a keyword argument <em>exception</em> to <code>false</code>, you can indicate that <a href="basicsocket#method-i-recvmsg_nonblock"><code>recvmsg_nonblock</code></a> should not raise an <a href="io/waitreadable"><code>IO::WaitReadable</code></a> exception, but return the symbol <code>:wait_readable</code> instead.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-remote_address"> <span class="method-callseq"> remote_address → addrinfo </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="remote_address-source"> <pre class="c" data-language="c">static VALUE
bsock_remote_address(VALUE sock)
{
    union_sockaddr buf;
    socklen_t len = (socklen_t)sizeof buf;
    socklen_t len0 = len;
    rb_io_t *fptr;

    GetOpenFile(sock, fptr);
    if (getpeername(fptr-&gt;fd, &amp;buf.addr, &amp;len) &lt; 0)
        rb_sys_fail("getpeername(2)");
    if (len0 &lt; len) len = len0;
    return rsock_fd_socket_addrinfo(fptr-&gt;fd, &amp;buf.addr, len);
}</pre> </div> <p>Returns an <a href="addrinfo"><code>Addrinfo</code></a> object for remote address obtained by getpeername.</p> <p>Note that addrinfo.protocol is filled by 0.</p> <pre class="ruby" data-language="ruby">TCPSocket.open("www.ruby-lang.org", 80) {|s|
  p s.remote_address #=&gt; #&lt;Addrinfo: 221.186.184.68:80 TCP&gt;
}

TCPServer.open("127.0.0.1", 1728) {|serv|
  c = TCPSocket.new("127.0.0.1", 1728)
  s = serv.accept
  p s.remote_address #=&gt; #&lt;Addrinfo: 127.0.0.1:36504 TCP&gt;
}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-send"> <span class="method-callseq"> send(mesg, flags [, dest_sockaddr]) → numbytes_sent </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="send-source"> <pre class="c" data-language="c">VALUE
rsock_bsock_send(int argc, VALUE *argv, VALUE sock)
{
    struct rsock_send_arg arg;
    VALUE flags, to;
    rb_io_t *fptr;
    ssize_t n;
    rb_blocking_function_t *func;
    const char *funcname;

    rb_scan_args(argc, argv, "21", &amp;arg.mesg, &amp;flags, &amp;to);

    StringValue(arg.mesg);
    if (!NIL_P(to)) {
        SockAddrStringValue(to);
        to = rb_str_new4(to);
        arg.to = (struct sockaddr *)RSTRING_PTR(to);
        arg.tolen = RSTRING_SOCKLEN(to);
        func = rsock_sendto_blocking;
        funcname = "sendto(2)";
    }
    else {
        func = rsock_send_blocking;
        funcname = "send(2)";
    }
    GetOpenFile(sock, fptr);
    arg.fd = fptr-&gt;fd;
    arg.flags = NUM2INT(flags);
    while (rsock_maybe_fd_writable(arg.fd),
           (n = (ssize_t)BLOCKING_REGION_FD(func, &amp;arg)) &lt; 0) {
        if (rb_io_wait_writable(arg.fd)) {
            continue;
        }
        rb_sys_fail(funcname);
    }
    return SSIZET2NUM(n);
}</pre> </div> <p>send <em>mesg</em> via <em>basicsocket</em>.</p> <p><em>mesg</em> should be a string.</p> <p><em>flags</em> should be a bitwise OR of Socket::MSG_* constants.</p> <p><em>dest_sockaddr</em> should be a packed sockaddr string or an addrinfo.</p> <pre class="ruby" data-language="ruby">TCPSocket.open("localhost", 80) {|s|
  s.send "GET / HTTP/1.0\r\n\r\n", 0
  p s.read
}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-sendmsg"> <span class="method-callseq"> sendmsg(mesg, flags=0, dest_sockaddr=nil, *controls) → numbytes_sent </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="sendmsg-source"> <pre class="ruby" data-language="ruby"># File ext/socket/lib/socket.rb, line 303
def sendmsg(mesg, flags = 0, dest_sockaddr = nil, *controls)
  __sendmsg(mesg, flags, dest_sockaddr, controls)
end</pre> </div> <p>sendmsg sends a message using sendmsg(2) system call in blocking manner.</p> <p><em>mesg</em> is a string to send.</p> <p><em>flags</em> is bitwise OR of MSG_* constants such as Socket::MSG_OOB.</p> <p><em>dest_sockaddr</em> is a destination socket address for connection-less socket. It should be a sockaddr such as a result of <a href="socket#method-c-sockaddr_in"><code>Socket.sockaddr_in</code></a>. An <a href="addrinfo"><code>Addrinfo</code></a> object can be used too.</p> <p><em>controls</em> is a list of ancillary data. The element of <em>controls</em> should be <a href="socket/ancillarydata"><code>Socket::AncillaryData</code></a> or 3-elements array. The 3-element array should contains cmsg_level, cmsg_type and data.</p> <p>The return value, <em>numbytes_sent</em> is an integer which is the number of bytes sent.</p> <p>sendmsg can be used to implement send_io as follows:</p> <pre class="ruby" data-language="ruby"># use Socket::AncillaryData.
ancdata = Socket::AncillaryData.int(:UNIX, :SOCKET, :RIGHTS, io.fileno)
sock.sendmsg("a", 0, nil, ancdata)

# use 3-element array.
ancdata = [:SOCKET, :RIGHTS, [io.fileno].pack("i!")]
sock.sendmsg("\0", 0, nil, ancdata)
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-sendmsg_nonblock"> <span class="method-callseq"> sendmsg_nonblock(mesg, flags=0, dest_sockaddr=nil, *controls, opts={}) → numbytes_sent </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="sendmsg_nonblock-source"> <pre class="ruby" data-language="ruby"># File ext/socket/lib/socket.rb, line 319
def sendmsg_nonblock(mesg, flags = 0, dest_sockaddr = nil, *controls,
                     exception: true)
  __sendmsg_nonblock(mesg, flags, dest_sockaddr, controls, exception)
end</pre> </div> <p><a href="basicsocket#method-i-sendmsg_nonblock"><code>sendmsg_nonblock</code></a> sends a message using sendmsg(2) system call in non-blocking manner.</p> <p>It is similar to <a href="basicsocket#method-i-sendmsg"><code>BasicSocket#sendmsg</code></a> but the non-blocking flag is set before the system call and it doesn't retry the system call.</p> <p>By specifying a keyword argument <em>exception</em> to <code>false</code>, you can indicate that <a href="basicsocket#method-i-sendmsg_nonblock"><code>sendmsg_nonblock</code></a> should not raise an <a href="io/waitwritable"><code>IO::WaitWritable</code></a> exception, but return the symbol <code>:wait_writable</code> instead.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-setsockopt"> <span class="method-callseq"> setsockopt(level, optname, optval) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> setsockopt(socketoption) </span> </div> <div class="method-description">
<div class="method-source-code" id="setsockopt-source"> <pre class="c" data-language="c">static VALUE
bsock_setsockopt(int argc, VALUE *argv, VALUE sock)
{
    VALUE lev, optname, val;
    int family, level, option;
    rb_io_t *fptr;
    int i;
    char *v;
    int vlen;

    if (argc == 1) {
        lev = rb_funcall(argv[0], rb_intern("level"), 0);
        optname = rb_funcall(argv[0], rb_intern("optname"), 0);
        val = rb_funcall(argv[0], rb_intern("data"), 0);
    }
    else {
        rb_scan_args(argc, argv, "30", &amp;lev, &amp;optname, &amp;val);
    }

    GetOpenFile(sock, fptr);
    family = rsock_getfamily(fptr);
    level = rsock_level_arg(family, lev);
    option = rsock_optname_arg(family, level, optname);

    switch (TYPE(val)) {
      case T_FIXNUM:
        i = FIX2INT(val);
        goto numval;
      case T_FALSE:
        i = 0;
        goto numval;
      case T_TRUE:
        i = 1;
      numval:
        v = (char*)&amp;i; vlen = (int)sizeof(i);
        break;
      default:
        StringValue(val);
        v = RSTRING_PTR(val);
        vlen = RSTRING_SOCKLEN(val);
        break;
    }

    rb_io_check_closed(fptr);
    if (setsockopt(fptr-&gt;fd, level, option, v, vlen) &lt; 0)
        rsock_sys_fail_path("setsockopt(2)", fptr-&gt;pathv);

    return INT2FIX(0);
}</pre> </div> <p>Sets a socket option. These are protocol and system specific, see your local system documentation for details.</p> <h3 id="method-i-setsockopt-label-Parameters">Parameters</h3> <ul>
<li> <p><code>level</code> is an integer, usually one of the SOL_ constants such as Socket::SOL_SOCKET, or a protocol level. A string or symbol of the name, possibly without prefix, is also accepted.</p> </li>
<li> <p><code>optname</code> is an integer, usually one of the SO_ constants, such as Socket::SO_REUSEADDR. A string or symbol of the name, possibly without prefix, is also accepted.</p> </li>
<li> <p><code>optval</code> is the value of the option, it is passed to the underlying setsockopt() as a pointer to a certain number of bytes. How this is done depends on the type:</p> <ul>
<li> <p>Integer: value is assigned to an int, and a pointer to the int is passed, with length of sizeof(int).</p> </li>
<li> <p>true or false: 1 or 0 (respectively) is assigned to an int, and the int is passed as for an <a href="integer"><code>Integer</code></a>. Note that <code>false</code> must be passed, not <code>nil</code>.</p> </li>
<li> <p>String: the string's data and length is passed to the socket.</p> </li>
</ul> </li>
<li> <p><code>socketoption</code> is an instance of <a href="socket/option"><code>Socket::Option</code></a></p> </li>
</ul> <h3 id="method-i-setsockopt-label-Examples">Examples</h3> <p>Some socket options are integers with boolean values, in this case <a href="basicsocket#method-i-setsockopt"><code>setsockopt</code></a> could be called like this:</p> <pre class="ruby" data-language="ruby">sock.setsockopt(:SOCKET, :REUSEADDR, true)
sock.setsockopt(Socket::SOL_SOCKET,Socket::SO_REUSEADDR, true)
sock.setsockopt(Socket::Option.bool(:INET, :SOCKET, :REUSEADDR, true))
</pre> <p>Some socket options are integers with numeric values, in this case <a href="basicsocket#method-i-setsockopt"><code>setsockopt</code></a> could be called like this:</p> <pre class="ruby" data-language="ruby">sock.setsockopt(:IP, :TTL, 255)
sock.setsockopt(Socket::IPPROTO_IP, Socket::IP_TTL, 255)
sock.setsockopt(Socket::Option.int(:INET, :IP, :TTL, 255))
</pre> <p>Option values may be structs. Passing them can be complex as it involves examining your system headers to determine the correct definition. An example is an <code>ip_mreq</code>, which may be defined in your system headers as:</p> <pre class="ruby" data-language="ruby">struct ip_mreq {
  struct  in_addr imr_multiaddr;
  struct  in_addr imr_interface;
};
</pre> <p>In this case <a href="basicsocket#method-i-setsockopt"><code>setsockopt</code></a> could be called like this:</p> <pre class="ruby" data-language="ruby">optval = IPAddr.new("224.0.0.251").hton +
         IPAddr.new(Socket::INADDR_ANY, Socket::AF_INET).hton
sock.setsockopt(Socket::IPPROTO_IP, Socket::IP_ADD_MEMBERSHIP, optval)
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-shutdown"> <span class="method-callseq"> shutdown([how]) → 0 </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="shutdown-source"> <pre class="c" data-language="c">static VALUE
bsock_shutdown(int argc, VALUE *argv, VALUE sock)
{
    VALUE howto;
    int how;
    rb_io_t *fptr;

    rb_scan_args(argc, argv, "01", &amp;howto);
    if (howto == Qnil)
        how = SHUT_RDWR;
    else {
        how = rsock_shutdown_how_arg(howto);
        if (how != SHUT_WR &amp;&amp; how != SHUT_RD &amp;&amp; how != SHUT_RDWR) {
            rb_raise(rb_eArgError, "`how' should be either :SHUT_RD, :SHUT_WR, :SHUT_RDWR");
        }
    }
    GetOpenFile(sock, fptr);
    if (shutdown(fptr-&gt;fd, how) == -1)
        rb_sys_fail("shutdown(2)");

    return INT2FIX(0);
}</pre> </div> <p>Calls shutdown(2) system call.</p> <p>s.shutdown(Socket::SHUT_RD) disallows further read.</p> <p>s.shutdown(Socket::SHUT_WR) disallows further write.</p> <p>s.shutdown(Socket::SHUT_RDWR) disallows further read and write.</p> <p><em>how</em> can be symbol or string:</p> <ul>
<li> <p>:RD, :SHUT_RD, “RD” and “SHUT_RD” are accepted as Socket::SHUT_RD.</p> </li>
<li> <p>:WR, :SHUT_WR, “WR” and “SHUT_WR” are accepted as Socket::SHUT_WR.</p> </li>
<li> <p>:RDWR, :SHUT_RDWR, “RDWR” and “SHUT_RDWR” are accepted as Socket::SHUT_RDWR.</p> <p><a href="unixsocket#method-c-pair"><code>UNIXSocket.pair</code></a> {|s1, s2|</p> <pre class="ruby" data-language="ruby">s1.puts "ping"
s1.shutdown(:WR)
p s2.read          #=&gt; "ping\n"
s2.puts "pong"
s2.close
p s1.read          #=&gt; "pong\n"
</pre> <p>}</p> </li>
</ul>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core © 1993–2017 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library © contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
