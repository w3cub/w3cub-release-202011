
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Ast - Python 2.7 - W3cubDocs</title>
  
  <meta name="description" content=" New in version 2.5&#58; The low-level _ast module containing only the node classes. ">
  <meta name="keywords" content="ast, —, abstract, syntax, trees, python, python~2.7">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/python~2.7/library/ast.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/python~2.7.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/python~2.7/" class="_nav-link" title="" style="margin-left:0;">Python 2.7</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _python">
				
				
<h1 id="ast-abstract-syntax-trees"> ast — Abstract Syntax Trees</h1> <div class="versionadded" id="module-ast"> <p><span class="versionmodified added">New in version 2.5: </span>The low-level <code>_ast</code> module containing only the node classes.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.6: </span>The high-level <code>ast</code> module containing all helpers.</p> </div> <p><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/2.7/Lib/ast.py">Lib/ast.py</a></p>  <p>The <a class="reference internal" href="#module-ast" title="ast: Abstract Syntax Tree classes and manipulation."><code>ast</code></a> module helps Python applications to process trees of the Python abstract syntax grammar. The abstract syntax itself might change with each Python release; this module helps to find out programmatically what the current grammar looks like.</p> <p>An abstract syntax tree can be generated by passing <code>ast.PyCF_ONLY_AST</code> as a flag to the <a class="reference internal" href="functions#compile" title="compile"><code>compile()</code></a> built-in function, or using the <a class="reference internal" href="#ast.parse" title="ast.parse"><code>parse()</code></a> helper provided in this module. The result will be a tree of objects whose classes all inherit from <a class="reference internal" href="#ast.AST" title="ast.AST"><code>ast.AST</code></a>. An abstract syntax tree can be compiled into a Python code object using the built-in <a class="reference internal" href="functions#compile" title="compile"><code>compile()</code></a> function.</p>  <h2 id="node-classes">1. Node classes</h2> <dl class="class"> <dt id="ast.AST">
<code>class ast.AST</code> </dt> <dd>
<p>This is the base of all AST node classes. The actual node classes are derived from the <code>Parser/Python.asdl</code> file, which is reproduced <a class="reference internal" href="#abstract-grammar"><span class="std std-ref">below</span></a>. They are defined in the <code>_ast</code> C module and re-exported in <a class="reference internal" href="#module-ast" title="ast: Abstract Syntax Tree classes and manipulation."><code>ast</code></a>.</p> <p>There is one class defined for each left-hand side symbol in the abstract grammar (for example, <code>ast.stmt</code> or <code>ast.expr</code>). In addition, there is one class defined for each constructor on the right-hand side; these classes inherit from the classes for the left-hand side trees. For example, <code>ast.BinOp</code> inherits from <code>ast.expr</code>. For production rules with alternatives (aka “sums”), the left-hand side class is abstract: only instances of specific constructor nodes are ever created.</p> <dl class="attribute"> <dt id="ast.AST._fields">
<code>_fields</code> </dt> <dd>
<p>Each concrete class has an attribute <a class="reference internal" href="#ast.AST._fields" title="ast.AST._fields"><code>_fields</code></a> which gives the names of all child nodes.</p> <p>Each instance of a concrete class has one attribute for each child node, of the type as defined in the grammar. For example, <code>ast.BinOp</code> instances have an attribute <code>left</code> of type <code>ast.expr</code>.</p> <p>If these attributes are marked as optional in the grammar (using a question mark), the value might be <code>None</code>. If the attributes can have zero-or-more values (marked with an asterisk), the values are represented as Python lists. All possible attributes must be present and have valid values when compiling an AST with <a class="reference internal" href="functions#compile" title="compile"><code>compile()</code></a>.</p> </dd>
</dl> <dl class="attribute"> <dt id="ast.AST.lineno">
<code>lineno</code> </dt> <dt id="ast.AST.col_offset">
<code>col_offset</code> </dt> <dd>
<p>Instances of <code>ast.expr</code> and <code>ast.stmt</code> subclasses have <a class="reference internal" href="#ast.AST.lineno" title="ast.AST.lineno"><code>lineno</code></a> and <a class="reference internal" href="#ast.AST.col_offset" title="ast.AST.col_offset"><code>col_offset</code></a> attributes. The <a class="reference internal" href="#ast.AST.lineno" title="ast.AST.lineno"><code>lineno</code></a> is the line number of source text (1-indexed so the first line is line 1) and the <a class="reference internal" href="#ast.AST.col_offset" title="ast.AST.col_offset"><code>col_offset</code></a> is the UTF-8 byte offset of the first token that generated the node. The UTF-8 offset is recorded because the parser uses UTF-8 internally.</p> </dd>
</dl> <p>The constructor of a class <code>ast.T</code> parses its arguments as follows:</p> <ul class="simple"> <li>If there are positional arguments, there must be as many as there are items in <code>T._fields</code>; they will be assigned as attributes of these names.</li> <li>If there are keyword arguments, they will set the attributes of the same names to the given values.</li> </ul> <p>For example, to create and populate an <code>ast.UnaryOp</code> node, you could use</p> <pre data-language="python">node = ast.UnaryOp()
node.op = ast.USub()
node.operand = ast.Num()
node.operand.n = 5
node.operand.lineno = 0
node.operand.col_offset = 0
node.lineno = 0
node.col_offset = 0
</pre> <p>or the more compact</p> <pre data-language="python">node = ast.UnaryOp(ast.USub(), ast.Num(5, lineno=0, col_offset=0),
                   lineno=0, col_offset=0)
</pre> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.6: </span>The constructor as explained above was added. In Python 2.5 nodes had to be created by calling the class constructor without arguments and setting the attributes afterwards.</p> </div> </dd>
</dl>   <h2 id="id1">2. Abstract Grammar</h2> <p id="abstract-grammar">The module defines a string constant <code>__version__</code> which is the decimal Subversion revision number of the file shown below.</p> <p>The abstract grammar is currently defined as follows:</p> <pre data-language="none">-- ASDL's five builtin types are identifier, int, string, object, bool

module Python version "$Revision$"
{
	mod = Module(stmt* body)
	    | Interactive(stmt* body)
	    | Expression(expr body)

	    -- not really an actual node but useful in Jython's typesystem.
	    | Suite(stmt* body)

	stmt = FunctionDef(identifier name, arguments args, 
                            stmt* body, expr* decorator_list)
	      | ClassDef(identifier name, expr* bases, stmt* body, expr* decorator_list)
	      | Return(expr? value)

	      | Delete(expr* targets)
	      | Assign(expr* targets, expr value)
	      | AugAssign(expr target, operator op, expr value)

	      -- not sure if bool is allowed, can always use int
 	      | Print(expr? dest, expr* values, bool nl)

	      -- use 'orelse' because else is a keyword in target languages
	      | For(expr target, expr iter, stmt* body, stmt* orelse)
	      | While(expr test, stmt* body, stmt* orelse)
	      | If(expr test, stmt* body, stmt* orelse)
	      | With(expr context_expr, expr? optional_vars, stmt* body)

	      -- 'type' is a bad name
	      | Raise(expr? type, expr? inst, expr? tback)
	      | TryExcept(stmt* body, excepthandler* handlers, stmt* orelse)
	      | TryFinally(stmt* body, stmt* finalbody)
	      | Assert(expr test, expr? msg)

	      | Import(alias* names)
	      | ImportFrom(identifier? module, alias* names, int? level)

	      -- Doesn't capture requirement that locals must be
	      -- defined if globals is
	      -- still supports use as a function!
	      | Exec(expr body, expr? globals, expr? locals)

	      | Global(identifier* names)
	      | Expr(expr value)
	      | Pass | Break | Continue

	      -- XXX Jython will be different
	      -- col_offset is the byte offset in the utf8 string the parser uses
	      attributes (int lineno, int col_offset)

	      -- BoolOp() can use left &amp; right?
	expr = BoolOp(boolop op, expr* values)
	     | BinOp(expr left, operator op, expr right)
	     | UnaryOp(unaryop op, expr operand)
	     | Lambda(arguments args, expr body)
	     | IfExp(expr test, expr body, expr orelse)
	     | Dict(expr* keys, expr* values)
	     | Set(expr* elts)
	     | ListComp(expr elt, comprehension* generators)
	     | SetComp(expr elt, comprehension* generators)
	     | DictComp(expr key, expr value, comprehension* generators)
	     | GeneratorExp(expr elt, comprehension* generators)
	     -- the grammar constrains where yield expressions can occur
	     | Yield(expr? value)
	     -- need sequences for compare to distinguish between
	     -- x &lt; 4 &lt; 3 and (x &lt; 4) &lt; 3
	     | Compare(expr left, cmpop* ops, expr* comparators)
	     | Call(expr func, expr* args, keyword* keywords,
			 expr? starargs, expr? kwargs)
	     | Repr(expr value)
	     | Num(object n) -- a number as a PyObject.
	     | Str(string s) -- need to specify raw, unicode, etc?
	     -- other literals? bools?

	     -- the following expression can appear in assignment context
	     | Attribute(expr value, identifier attr, expr_context ctx)
	     | Subscript(expr value, slice slice, expr_context ctx)
	     | Name(identifier id, expr_context ctx)
	     | List(expr* elts, expr_context ctx) 
	     | Tuple(expr* elts, expr_context ctx)

	      -- col_offset is the byte offset in the utf8 string the parser uses
	      attributes (int lineno, int col_offset)

	expr_context = Load | Store | Del | AugLoad | AugStore | Param

	slice = Ellipsis | Slice(expr? lower, expr? upper, expr? step) 
	      | ExtSlice(slice* dims) 
	      | Index(expr value) 

	boolop = And | Or 

	operator = Add | Sub | Mult | Div | Mod | Pow | LShift 
                 | RShift | BitOr | BitXor | BitAnd | FloorDiv

	unaryop = Invert | Not | UAdd | USub

	cmpop = Eq | NotEq | Lt | LtE | Gt | GtE | Is | IsNot | In | NotIn

	comprehension = (expr target, expr iter, expr* ifs)

	-- not sure what to call the first argument for raise and except
	excepthandler = ExceptHandler(expr? type, expr? name, stmt* body)
	                attributes (int lineno, int col_offset)

	arguments = (expr* args, identifier? vararg, 
		     identifier? kwarg, expr* defaults)

        -- keyword arguments supplied to call
        keyword = (identifier arg, expr value)

        -- import name with optional 'as' alias.
        alias = (identifier name, identifier? asname)
}
</pre>   <h2 id="ast-helpers">3. ast Helpers</h2> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.6.</span></p> </div> <p>Apart from the node classes, <a class="reference internal" href="#module-ast" title="ast: Abstract Syntax Tree classes and manipulation."><code>ast</code></a> module defines these utility functions and classes for traversing abstract syntax trees:</p> <dl class="function"> <dt id="ast.parse">
<code>ast.parse(source, filename='&lt;unknown&gt;', mode='exec')</code> </dt> <dd>
<p>Parse the source into an AST node. Equivalent to <code>compile(source,
filename, mode, ast.PyCF_ONLY_AST)</code>.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>It is possible to crash the Python interpreter with a sufficiently large/complex string due to stack depth limitations in Python’s AST compiler.</p> </div> </dd>
</dl> <dl class="function"> <dt id="ast.literal_eval">
<code>ast.literal_eval(node_or_string)</code> </dt> <dd>
<p>Safely evaluate an expression node or a Unicode or <em>Latin-1</em> encoded string containing a Python literal or container display. The string or node provided may only consist of the following Python literal structures: strings, numbers, tuples, lists, dicts, booleans, and <code>None</code>.</p> <p>This can be used for safely evaluating strings containing Python values from untrusted sources without the need to parse the values oneself. It is not capable of evaluating arbitrarily complex expressions, for example involving operators or indexing.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>It is possible to crash the Python interpreter with a sufficiently large/complex string due to stack depth limitations in Python’s AST compiler.</p> </div> </dd>
</dl> <dl class="function"> <dt id="ast.get_docstring">
<code>ast.get_docstring(node, clean=True)</code> </dt> <dd>
<p>Return the docstring of the given <em>node</em> (which must be a <code>FunctionDef</code>, <code>ClassDef</code> or <code>Module</code> node), or <code>None</code> if it has no docstring. If <em>clean</em> is true, clean up the docstring’s indentation with <a class="reference internal" href="inspect#inspect.cleandoc" title="inspect.cleandoc"><code>inspect.cleandoc()</code></a>.</p> </dd>
</dl> <dl class="function"> <dt id="ast.fix_missing_locations">
<code>ast.fix_missing_locations(node)</code> </dt> <dd>
<p>When you compile a node tree with <a class="reference internal" href="functions#compile" title="compile"><code>compile()</code></a>, the compiler expects <code>lineno</code> and <code>col_offset</code> attributes for every node that supports them. This is rather tedious to fill in for generated nodes, so this helper adds these attributes recursively where not already set, by setting them to the values of the parent node. It works recursively starting at <em>node</em>.</p> </dd>
</dl> <dl class="function"> <dt id="ast.increment_lineno">
<code>ast.increment_lineno(node, n=1)</code> </dt> <dd>
<p>Increment the line number of each node in the tree starting at <em>node</em> by <em>n</em>. This is useful to “move code” to a different location in a file.</p> </dd>
</dl> <dl class="function"> <dt id="ast.copy_location">
<code>ast.copy_location(new_node, old_node)</code> </dt> <dd>
<p>Copy source location (<code>lineno</code> and <code>col_offset</code>) from <em>old_node</em> to <em>new_node</em> if possible, and return <em>new_node</em>.</p> </dd>
</dl> <dl class="function"> <dt id="ast.iter_fields">
<code>ast.iter_fields(node)</code> </dt> <dd>
<p>Yield a tuple of <code>(fieldname, value)</code> for each field in <code>node._fields</code> that is present on <em>node</em>.</p> </dd>
</dl> <dl class="function"> <dt id="ast.iter_child_nodes">
<code>ast.iter_child_nodes(node)</code> </dt> <dd>
<p>Yield all direct child nodes of <em>node</em>, that is, all fields that are nodes and all items of fields that are lists of nodes.</p> </dd>
</dl> <dl class="function"> <dt id="ast.walk">
<code>ast.walk(node)</code> </dt> <dd>
<p>Recursively yield all descendant nodes in the tree starting at <em>node</em> (including <em>node</em> itself), in no specified order. This is useful if you only want to modify nodes in place and don’t care about the context.</p> </dd>
</dl> <dl class="class"> <dt id="ast.NodeVisitor">
<code>class ast.NodeVisitor</code> </dt> <dd>
<p>A node visitor base class that walks the abstract syntax tree and calls a visitor function for every node found. This function may return a value which is forwarded by the <a class="reference internal" href="#ast.NodeVisitor.visit" title="ast.NodeVisitor.visit"><code>visit()</code></a> method.</p> <p>This class is meant to be subclassed, with the subclass adding visitor methods.</p> <dl class="method"> <dt id="ast.NodeVisitor.visit">
<code>visit(node)</code> </dt> <dd>
<p>Visit a node. The default implementation calls the method called <code>self.visit_<em>classname</em></code> where <em>classname</em> is the name of the node class, or <a class="reference internal" href="#ast.NodeVisitor.generic_visit" title="ast.NodeVisitor.generic_visit"><code>generic_visit()</code></a> if that method doesn’t exist.</p> </dd>
</dl> <dl class="method"> <dt id="ast.NodeVisitor.generic_visit">
<code>generic_visit(node)</code> </dt> <dd>
<p>This visitor calls <a class="reference internal" href="#ast.NodeVisitor.visit" title="ast.NodeVisitor.visit"><code>visit()</code></a> on all children of the node.</p> <p>Note that child nodes of nodes that have a custom visitor method won’t be visited unless the visitor calls <a class="reference internal" href="#ast.NodeVisitor.generic_visit" title="ast.NodeVisitor.generic_visit"><code>generic_visit()</code></a> or visits them itself.</p> </dd>
</dl> <p>Don’t use the <a class="reference internal" href="#ast.NodeVisitor" title="ast.NodeVisitor"><code>NodeVisitor</code></a> if you want to apply changes to nodes during traversal. For this a special visitor exists (<a class="reference internal" href="#ast.NodeTransformer" title="ast.NodeTransformer"><code>NodeTransformer</code></a>) that allows modifications.</p> </dd>
</dl> <dl class="class"> <dt id="ast.NodeTransformer">
<code>class ast.NodeTransformer</code> </dt> <dd>
<p>A <a class="reference internal" href="#ast.NodeVisitor" title="ast.NodeVisitor"><code>NodeVisitor</code></a> subclass that walks the abstract syntax tree and allows modification of nodes.</p> <p>The <a class="reference internal" href="#ast.NodeTransformer" title="ast.NodeTransformer"><code>NodeTransformer</code></a> will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is <code>None</code>, the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place.</p> <p>Here is an example transformer that rewrites all occurrences of name lookups (<code>foo</code>) to <code>data['foo']</code>:</p> <pre data-language="python">class RewriteName(NodeTransformer):

    def visit_Name(self, node):
        return copy_location(Subscript(
            value=Name(id='data', ctx=Load()),
            slice=Index(value=Str(s=node.id)),
            ctx=node.ctx
        ), node)
</pre> <p>Keep in mind that if the node you’re operating on has child nodes you must either transform the child nodes yourself or call the <code>generic_visit()</code> method for the node first.</p> <p>For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node.</p> <p>Usually you use the transformer like this:</p> <pre data-language="python">node = YourTransformer().visit(node)
</pre> </dd>
</dl> <dl class="function"> <dt id="ast.dump">
<code>ast.dump(node, annotate_fields=True, include_attributes=False)</code> </dt> <dd>
<p>Return a formatted dump of the tree in <em>node</em>. This is mainly useful for debugging purposes. The returned string will show the names and the values for fields. This makes the code impossible to evaluate, so if evaluation is wanted <em>annotate_fields</em> must be set to <code>False</code>. Attributes such as line numbers and column offsets are not dumped by default. If this is wanted, <em>include_attributes</em> can be set to <code>True</code>.</p> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2001–2020 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/2.7/library/ast.html" class="_attribution-link">https://docs.python.org/2.7/library/ast.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
