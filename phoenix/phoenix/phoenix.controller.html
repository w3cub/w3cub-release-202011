
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Phoenix.Controller - Phoenix - W3cubDocs</title>
  
  <meta name="description" content=" Controllers are used to group common functionality in the same (pluggable) module. ">
  <meta name="keywords" content="phoenix, controller, summary, functions">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/phoenix/phoenix/phoenix.controller.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/phoenix.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/phoenix/" class="_nav-link" title="" style="margin-left:0;">Phoenix</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _elixir">
				
				
<h1> Phoenix.Controller   </h1> <section id="moduledoc"> <p>Controllers are used to group common functionality in the same (pluggable) module.</p>
<p>For example, the route:</p>
<pre data-language="elixir">get "/users/:id", MyAppWeb.UserController, :show</pre>
<p>will invoke the <code class="inline">show/2</code> action in the <code class="inline">MyAppWeb.UserController</code>:</p>
<pre data-language="elixir">defmodule MyAppWeb.UserController do
  use MyAppWeb, :controller

  def show(conn, %{"id" =&gt; id}) do
    user = Repo.get(User, id)
    render(conn, "show.html", user: user)
  end
end</pre>
<p>An action is a regular function that receives the connection and the request parameters as arguments. The connection is a <a href="../plug/plug.conn"><code class="inline">Plug.Conn</code></a> struct, as specified by the Plug library.</p>
<h2 id="module-options" class="section-heading">  Options </h2> <p>When used, the controller supports the following options:</p>
<ul>
<li><p><code class="inline">:namespace</code> - sets the namespace to properly inflect the layout view. By default it uses the base alias in your controller name</p></li>
<li><p><code class="inline">:log</code> - the level to log. When false, disables controller logging</p></li>
<li><p><code class="inline">:put_default_views</code> - controls whether the default view and layout should be set or not</p></li>
</ul>
<h2 id="module-connection" class="section-heading">  Connection </h2> <p>A controller by default provides many convenience functions for manipulating the connection, rendering templates, and more.</p>
<p>Those functions are imported from two modules:</p>
<ul>
<li><p><a href="../plug/plug.conn"><code class="inline">Plug.Conn</code></a> - a collection of low-level functions to work with the connection</p></li>
<li><p><a href="#content"><code class="inline">Phoenix.Controller</code></a> - functions provided by Phoenix to support rendering, and other Phoenix specific behaviour</p></li>
</ul>
<p>If you want to have functions that manipulate the connection without fully implementing the controller, you can import both modules directly instead of <code class="inline">use Phoenix.Controller</code>.</p>
<h2 id="module-plug-pipeline" class="section-heading">  Plug pipeline </h2> <p>As with routers, controllers also have their own plug pipeline. However, different from routers, controllers have a single pipeline:</p>
<pre data-language="elixir">defmodule MyAppWeb.UserController do
  use MyAppWeb, :controller

  plug :authenticate, usernames: ["jose", "eric", "sonny"]

  def show(conn, params) do
    # authenticated users only
  end

  defp authenticate(conn, options) do
    if get_session(conn, :username) in options[:usernames] do
      conn
    else
      conn |&gt; redirect(to: "/") |&gt; halt()
    end
  end
end</pre>
<p>The <code class="inline">:authenticate</code> plug will be invoked before the action. If the plug calls <a href="../plug/plug.conn#halt/1"><code class="inline">Plug.Conn.halt/1</code></a> (which is by default imported into controllers), it will halt the pipeline and won't invoke the action.</p>
<h3 id="module-guards" class="section-heading">  Guards </h3> <p><code class="inline">plug/2</code> in controllers supports guards, allowing a developer to configure a plug to only run in some particular action:</p>
<pre data-language="elixir">plug :authenticate, [usernames: ["jose", "eric", "sonny"]] when action in [:show, :edit]
plug :authenticate, [usernames: ["admin"]] when not action in [:index]</pre>
<p>The first plug will run only when action is show or edit. The second plug will always run, except for the index action.</p>
<p>Those guards work like regular Elixir guards and the only variables accessible in the guard are <code class="inline">conn</code>, the <code class="inline">action</code> as an atom and the <code class="inline">controller</code> as an alias.</p>
<h2 id="module-controllers-are-plugs" class="section-heading">  Controllers are plugs </h2> <p>Like routers, controllers are plugs, but they are wired to dispatch to a particular function which is called an action.</p>
<p>For example, the route:</p>
<pre data-language="elixir">get "/users/:id", UserController, :show</pre>
<p>will invoke <code class="inline">UserController</code> as a plug:</p>
<pre data-language="elixir">UserController.call(conn, :show)</pre>
<p>which will trigger the plug pipeline and which will eventually invoke the inner action plug that dispatches to the <code class="inline">show/2</code> function in the <code class="inline">UserController</code>.</p>
<p>As controllers are plugs, they implement both <code class="inline">init/1</code> and <code class="inline">call/2</code>, and it also provides a function named <code class="inline">action/2</code> which is responsible for dispatching the appropriate action after the plug stack (and is also overridable).</p>
<h3 id="module-overriding-action-2-for-custom-arguments" class="section-heading">  Overriding <code class="inline">action/2</code> for custom arguments </h3> <p>Phoenix injects an <code class="inline">action/2</code> plug in your controller which calls the function matched from the router. By default, it passes the conn and params. In some cases, overriding the <code class="inline">action/2</code> plug in your controller is a useful way to inject arguments into your actions that you would otherwise need to repeatedly fetch off the connection. For example, imagine if you stored a <code class="inline">conn.assigns.current_user</code> in the connection and wanted quick access to the user for every action in your controller:</p>
<pre data-language="elixir">def action(conn, _) do
  args = [conn, conn.params, conn.assigns.current_user]
  apply(__MODULE__, action_name(conn), args)
end

def index(conn, _params, user) do
  videos = Repo.all(user_videos(user))
  # ...
end

def delete(conn, %{"id" =&gt; id}, user) do
  video = Repo.get!(user_videos(user), id)
  # ...
end</pre>
<h2 id="module-rendering-and-layouts" class="section-heading">  Rendering and layouts </h2> <p>One of the main features provided by controllers is the ability to perform content negotiation and render templates based on information sent by the client. Read <a href="#render/3"><code class="inline">render/3</code></a> to learn more.</p>
<p>It is also important not to confuse <a href="#render/3"><code class="inline">Phoenix.Controller.render/3</code></a> with <a href="phoenix.view#render/3"><code class="inline">Phoenix.View.render/3</code></a>. The former expects a connection and relies on content negotiation while the latter is connection-agnostic and typically invoked from your views.</p> </section> <section id="summary" class="details-list"> <h1 class="section-heading">  Summary </h1> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#accepts/2">accepts(conn, accepted)</a> </dt> <dd class="summary-synopsis"><p>Performs content negotiation based on the available formats.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#action_fallback/1">action_fallback(plug)</a> </dt> <dd class="summary-synopsis"><p>Registers the plug to call as a fallback to the controller action.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#action_name/1">action_name(conn)</a> </dt> <dd class="summary-synopsis"><p>Returns the action name as an atom, raises if unavailable.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#allow_jsonp/2">allow_jsonp(conn, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>A plug that may convert a JSON response into a JSONP one.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#clear_flash/1">clear_flash(conn)</a> </dt> <dd class="summary-synopsis"><p>Clears all flash messages.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#controller_module/1">controller_module(conn)</a> </dt> <dd class="summary-synopsis"><p>Returns the controller module as an atom, raises if unavailable.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#current_path/1">current_path(conn)</a> </dt> <dd class="summary-synopsis"><p>Returns the current request path with its default query parameters</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#current_path/2">current_path(conn, params)</a> </dt> <dd class="summary-synopsis"><p>Returns the current path with the given query parameters.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#current_url/1">current_url(conn)</a> </dt> <dd class="summary-synopsis"><p>Returns the current request url with its default query parameters</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#current_url/2">current_url(conn, params)</a> </dt> <dd class="summary-synopsis"><p>Returns the current request URL with query params.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#delete_csrf_token/0">delete_csrf_token()</a> </dt> <dd class="summary-synopsis"><p>Deletes the CSRF token from the process dictionary.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#endpoint_module/1">endpoint_module(conn)</a> </dt> <dd class="summary-synopsis"><p>Returns the endpoint module as an atom, raises if unavailable.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#fetch_flash/2">fetch_flash(conn, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Fetches the flash storage.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#get_csrf_token/0">get_csrf_token()</a> </dt> <dd class="summary-synopsis"><p>Gets or generates a CSRF token.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#get_flash/1">get_flash(conn)</a> </dt> <dd class="summary-synopsis"><p>Returns a map of previously set flash messages or an empty map.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#get_flash/2">get_flash(conn, key)</a> </dt> <dd class="summary-synopsis"><p>Returns a message from flash by <code class="inline">key</code> (or <code class="inline">nil</code> if no message is available for <code class="inline">key</code>).</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#get_format/1">get_format(conn)</a> </dt> <dd class="summary-synopsis"><p>Returns the request format, such as "json", "html".</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#html/2">html(conn, data)</a> </dt> <dd class="summary-synopsis"><p>Sends html response.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#json/2">json(conn, data)</a> </dt> <dd class="summary-synopsis"><p>Sends JSON response.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#layout/1">layout(conn)</a> </dt> <dd class="summary-synopsis"><p>Retrieves the current layout.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#layout_formats/1">layout_formats(conn)</a> </dt> <dd class="summary-synopsis"><p>Retrieves current layout formats.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#merge_flash/2">merge_flash(conn, enumerable)</a> </dt> <dd class="summary-synopsis"><p>Merges a map into the flash.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#protect_from_forgery/2">protect_from_forgery(conn, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Enables CSRF protection.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_flash/3">put_flash(conn, key, message)</a> </dt> <dd class="summary-synopsis"><p>Persists a value in flash.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_format/2">put_format(conn, format)</a> </dt> <dd class="summary-synopsis"><p>Puts the format in the connection.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_layout/2">put_layout(conn, layout)</a> </dt> <dd class="summary-synopsis"><p>Stores the layout for rendering.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_layout_formats/2">put_layout_formats(conn, formats)</a> </dt> <dd class="summary-synopsis"><p>Sets which formats have a layout when rendering.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_new_layout/2">put_new_layout(conn, layout)</a> </dt> <dd class="summary-synopsis"><p>Stores the layout for rendering if one was not stored yet.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_new_view/2">put_new_view(conn, module)</a> </dt> <dd class="summary-synopsis"><p>Stores the view for rendering if one was not stored yet.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_root_layout/2">put_root_layout(conn, layout)</a> </dt> <dd class="summary-synopsis"><p>Stores the root layout for rendering.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_router_url/2">put_router_url(conn, uri)</a> </dt> <dd class="summary-synopsis"><p>Puts the url string or <code class="inline">%URI{}</code> to be used for route generation.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_secure_browser_headers/2">put_secure_browser_headers(conn, headers \\ %{})</a> </dt> <dd class="summary-synopsis"><p>Put headers that improve browser security.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_static_url/2">put_static_url(conn, uri)</a> </dt> <dd class="summary-synopsis"><p>Puts the URL or <code class="inline">%URI{}</code> to be used for the static url generation.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_view/2">put_view(conn, module)</a> </dt> <dd class="summary-synopsis"><p>Stores the view for rendering.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#redirect/2">redirect(conn, opts)</a> </dt> <dd class="summary-synopsis"><p>Sends redirect response to the given url.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render/2">render(conn, template_or_assigns \\ [])</a> </dt> <dd class="summary-synopsis"><p>Render the given template or the default template specified by the current action with the given assigns.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render/3">render(conn, template, assigns)</a> </dt> <dd class="summary-synopsis"><p>Renders the given <code class="inline">template</code> and <code class="inline">assigns</code> based on the <code class="inline">conn</code> information.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#root_layout/1">root_layout(conn)</a> </dt> <dd class="summary-synopsis"><p>Retrieves the current root layout.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#router_module/1">router_module(conn)</a> </dt> <dd class="summary-synopsis"><p>Returns the router module as an atom, raises if unavailable.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#scrub_params/2">scrub_params(conn, required_key)</a> </dt> <dd class="summary-synopsis"><p>Scrubs the parameters from the request.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#send_download/3">send_download(conn, kind, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Sends the given file or binary as a download.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#status_message_from_template/1">status_message_from_template(template)</a> </dt> <dd class="summary-synopsis"><p>Generates a status message from the template name.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#text/2">text(conn, data)</a> </dt> <dd class="summary-synopsis"><p>Sends text response.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#view_module/1">view_module(conn)</a> </dt> <dd class="summary-synopsis"><p>Retrieves the current view.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#view_template/1">view_template(conn)</a> </dt> <dd class="summary-synopsis"><p>Returns the template name rendered in the view as a string (or nil if no template was rendered).</p></dd> </div> </dl> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  Functions </h1> <div class="functions-list"> <section class="detail"> <h3 class="detail-header" id="accepts/2">accepts(conn, accepted)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">accepts(Plug.Conn.t(), [binary()]) :: Plug.Conn.t() | no_return()</pre> </div> <p>Performs content negotiation based on the available formats.</p>
<p>It receives a connection, a list of formats that the server is capable of rendering and then proceeds to perform content negotiation based on the request information. If the client accepts any of the given formats, the request proceeds.</p>
<p>If the request contains a "_format" parameter, it is considered to be the format desired by the client. If no "_format" parameter is available, this function will parse the "accept" header and find a matching format accordingly.</p>
<p>This function is useful when you may want to serve different content-types (such as JSON and HTML) from the same routes. However, if you always have distinct routes, you can also disable content negotiation and simply hardcode your format of choice in your route pipelines:</p>
<pre data-language="elixir">plug :put_format, "html"</pre>
<p>It is important to notice that browsers have historically sent bad accept headers. For this reason, this function will default to "html" format whenever:</p>
<ul>
<li><p>the accepted list of arguments contains the "html" format</p></li>
<li><p>the accept header specified more than one media type preceded or followed by the wildcard media type "<code class="inline">*/*</code>"</p></li>
</ul>
<p>This function raises <a href="phoenix.notacceptableerror"><code class="inline">Phoenix.NotAcceptableError</code></a>, which is rendered with status 406, whenever the server cannot serve a response in any of the formats expected by the client.</p>
<h4 id="accepts/2-examples" class="section-heading">  Examples </h4> <p><a href="#accepts/2"><code class="inline">accepts/2</code></a> can be invoked as a function:</p>
<pre data-language="elixir">iex&gt; accepts(conn, ["html", "json"])</pre>
<p>or used as a plug:</p>
<pre data-language="elixir">plug :accepts, ["html", "json"]
plug :accepts, ~w(html json)</pre>
<h4 id="accepts/2-custom-media-types" class="section-heading">  Custom media types </h4> <p>It is possible to add custom media types to your Phoenix application. The first step is to teach Plug about those new media types in your <code class="inline">config/config.exs</code> file:</p>
<pre data-language="elixir">config :mime, :types, %{
  "application/vnd.api+json" =&gt; ["json-api"]
}</pre>
<p>The key is the media type, the value is a list of formats the media type can be identified with. For example, by using "json-api", you will be able to use templates with extension "index.json-api" or to force a particular format in a given URL by sending "?_format=json-api".</p>
<p>After this change, you must recompile plug:</p>
<pre data-language="elixir">$ mix deps.clean mime --build
$ mix deps.get</pre>
<p>And now you can use it in accepts too:</p>
<pre data-language="elixir">plug :accepts, ["html", "json-api"]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="action_fallback/1">action_fallback(plug)</h3> <section class="docstring"> <p>Registers the plug to call as a fallback to the controller action.</p>
<p>A fallback plug is useful to translate common domain data structures into a valid <code class="inline">%Plug.Conn{}</code> response. If the controller action fails to return a <code class="inline">%Plug.Conn{}</code>, the provided plug will be called and receive the controller's <code class="inline">%Plug.Conn{}</code> as it was before the action was invoked along with the value returned from the controller action.</p>
<h4 id="action_fallback/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">defmodule MyController do
  use Phoenix.Controller

  action_fallback MyFallbackController

  def show(conn, %{"id" =&gt; id}, current_user) do
    with {:ok, post} &lt;- Blog.fetch_post(id),
         :ok &lt;- Authorizer.authorize(current_user, :view, post) do

      render(conn, "show.json", post: post)
    end
  end
end</pre>
<p>In the above example, <code class="inline">with</code> is used to match only a successful post fetch, followed by valid authorization for the current user. In the event either of those fail to match, <code class="inline">with</code> will not invoke the render block and instead return the unmatched value. In this case, imagine <code class="inline">Blog.fetch_post/2</code> returned <code class="inline">{:error, :not_found}</code> or <code class="inline">Authorizer.authorize/3</code> returned <code class="inline">{:error, :unauthorized}</code>. For cases where these data structures serve as return values across multiple boundaries in our domain, a single fallback module can be used to translate the value into a valid response. For example, you could write the following fallback controller to handle the above values:</p>
<pre data-language="elixir">defmodule MyFallbackController do
  use Phoenix.Controller

  def call(conn, {:error, :not_found}) do
    conn
    |&gt; put_status(:not_found)
    |&gt; put_view(MyErrorView)
    |&gt; render(:"404")
  end

  def call(conn, {:error, :unauthorized}) do
    conn
    |&gt; put_status(403)
    |&gt; put_view(MyErrorView)
    |&gt; render(:"403")
  end
end</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="action_name/1">action_name(conn)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">action_name(Plug.Conn.t()) :: atom()</pre> </div> <p>Returns the action name as an atom, raises if unavailable.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="allow_jsonp/2">allow_jsonp(conn, opts \\ [])</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">allow_jsonp(Plug.Conn.t(), Keyword.t()) :: Plug.Conn.t()</pre> </div> <p>A plug that may convert a JSON response into a JSONP one.</p>
<p>In case a JSON response is returned, it will be converted to a JSONP as long as the callback field is present in the query string. The callback field itself defaults to "callback", but may be configured with the callback option.</p>
<p>In case there is no callback or the response is not encoded in JSON format, it is a no-op.</p>
<p>Only alphanumeric characters and underscore are allowed in the callback name. Otherwise an exception is raised.</p>
<h4 id="allow_jsonp/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"># Will convert JSON to JSONP if callback=someFunction is given
plug :allow_jsonp

# Will convert JSON to JSONP if cb=someFunction is given
plug :allow_jsonp, callback: "cb"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="clear_flash/1">clear_flash(conn)</h3> <section class="docstring"> <p>Clears all flash messages.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="controller_module/1">controller_module(conn)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">controller_module(Plug.Conn.t()) :: atom()</pre> </div> <p>Returns the controller module as an atom, raises if unavailable.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="current_path/1">current_path(conn)</h3> <section class="docstring"> <p>Returns the current request path with its default query parameters:</p>
<pre data-language="elixir">iex&gt; current_path(conn)
"/users/123?existing=param"</pre>
<p>See <a href="#current_path/2"><code class="inline">current_path/2</code></a> to override the default parameters.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="current_path/2">current_path(conn, params)</h3> <section class="docstring"> <p>Returns the current path with the given query parameters.</p>
<p>You may also retrieve only the request path by passing an empty map of params.</p>
<h4 id="current_path/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; current_path(conn)
"/users/123?existing=param"

iex&gt; current_path(conn, %{new: "param"})
"/users/123?new=param"

iex&gt; current_path(conn, %{filter: %{status: ["draft", "published"})
"/users/123?filter[status][]=draft&amp;filter[status][]=published"

iex&gt; current_path(conn, %{})
"/users/123"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="current_url/1">current_url(conn)</h3> <section class="docstring"> <p>Returns the current request url with its default query parameters:</p>
<pre data-language="elixir">iex&gt; current_url(conn)
"https://www.example.com/users/123?existing=param"</pre>
<p>See <a href="#current_url/2"><code class="inline">current_url/2</code></a> to override the default parameters.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="current_url/2">current_url(conn, params)</h3> <section class="docstring"> <p>Returns the current request URL with query params.</p>
<p>The path will be retrieved from the currently requested path via <a href="#current_path/1"><code class="inline">current_path/1</code></a>. The scheme, host and others will be received from the URL configuration in your Phoenix endpoint. The reason we don't use the host and scheme information in the request is because most applications are behind proxies and the host and scheme may not actually reflect the host and scheme accessed by the client. If you want to access the url precisely as requested by the client, see <a href="../plug/plug.conn#request_url/1"><code class="inline">Plug.Conn.request_url/1</code></a>.</p>
<h4 id="current_url/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; current_url(conn)
"https://www.example.com/users/123?existing=param"

iex&gt; current_url(conn, %{new: "param"})
"https://www.example.com/users/123?new=param"

iex&gt; current_url(conn, %{})
"https://www.example.com/users/123"</pre>
<h4 id="current_url/2-custom-url-generation" class="section-heading">  Custom URL Generation </h4> <p>In some cases, you'll need to generate a request's URL, but using a different scheme, different host, etc. This can be accomplished in two ways.</p>
<p>If you want to do so in a case-by-case basis, you can define a custom function that gets the endpoint URI configuration and changes it accordingly. For example, to get the current URL always in HTTPS format:</p>
<pre data-language="elixir">def current_secure_url(conn, params \\ %{}) do
  cur_uri  = MyAppWeb.Endpoint.struct_url()
  cur_path = Phoenix.Controller.current_path(conn, params)

  MyAppWeb.Router.Helpers.url(%URI{cur_uri | scheme: "https"}) &lt;&gt; cur_path
end</pre>
<p>However, if you want all generated URLs to always have a certain schema, host, etc, you may use <a href="#put_router_url/2"><code class="inline">put_router_url/2</code></a>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="delete_csrf_token/0">delete_csrf_token()</h3> <section class="docstring"> <p>Deletes the CSRF token from the process dictionary.</p>
<p><em>Note</em>: The token is deleted only after a response has been sent.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="endpoint_module/1">endpoint_module(conn)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">endpoint_module(Plug.Conn.t()) :: atom()</pre> </div> <p>Returns the endpoint module as an atom, raises if unavailable.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="fetch_flash/2">fetch_flash(conn, opts \\ [])</h3> <section class="docstring"> <p>Fetches the flash storage.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="get_csrf_token/0">get_csrf_token()</h3> <section class="docstring"> <p>Gets or generates a CSRF token.</p>
<p>If a token exists, it is returned, otherwise it is generated and stored in the process dictionary.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="get_flash/1">get_flash(conn)</h3> <section class="docstring"> <p>Returns a map of previously set flash messages or an empty map.</p>
<h4 id="get_flash/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; get_flash(conn)
%{}

iex&gt; conn = put_flash(conn, :info, "Welcome Back!")
iex&gt; get_flash(conn)
%{"info" =&gt; "Welcome Back!"}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="get_flash/2">get_flash(conn, key)</h3> <section class="docstring"> <p>Returns a message from flash by <code class="inline">key</code> (or <code class="inline">nil</code> if no message is available for <code class="inline">key</code>).</p>
<h4 id="get_flash/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; conn = put_flash(conn, :info, "Welcome Back!")
iex&gt; get_flash(conn, :info)
"Welcome Back!"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="get_format/1">get_format(conn)</h3> <section class="docstring"> <p>Returns the request format, such as "json", "html".</p>
<p>This format is used when rendering a template as an atom. For example, <code class="inline">render(conn, :foo)</code> will render <code class="inline">"foo.FORMAT"</code> where the format is the one set here. The default format is typically set from the negotiation done in <a href="#accepts/2"><code class="inline">accepts/2</code></a>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="html/2">html(conn, data)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">html(Plug.Conn.t(), iodata()) :: Plug.Conn.t()</pre> </div> <p>Sends html response.</p>
<h4 id="html/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; html(conn, "&lt;html&gt;&lt;head&gt;...")</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="json/2">json(conn, data)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">json(Plug.Conn.t(), term()) :: Plug.Conn.t()</pre> </div> <p>Sends JSON response.</p>
<p>It uses the configured <code class="inline">:json_library</code> under the <code class="inline">:phoenix</code> application for <code class="inline">:json</code> to pick up the encoder module.</p>
<h4 id="json/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; json(conn, %{id: 123})</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="layout/1">layout(conn)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">layout(Plug.Conn.t()) :: {atom(), String.t() | atom()} | false</pre> </div> <p>Retrieves the current layout.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="layout_formats/1">layout_formats(conn)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">layout_formats(Plug.Conn.t()) :: [String.t()]</pre> </div> <p>Retrieves current layout formats.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="merge_flash/2">merge_flash(conn, enumerable)</h3> <section class="docstring"> <p>Merges a map into the flash.</p>
<p>Returns the updated connection.</p>
<h4 id="merge_flash/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; conn = merge_flash(conn, info: "Welcome Back!")
iex&gt; get_flash(conn, :info)
"Welcome Back!"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="protect_from_forgery/2">protect_from_forgery(conn, opts \\ [])</h3> <section class="docstring"> <p>Enables CSRF protection.</p>
<p>Currently used as a wrapper function for <a href="../plug/plug.csrfprotection"><code class="inline">Plug.CSRFProtection</code></a> and mainly serves as a function plug in <code class="inline">YourApp.Router</code>.</p>
<p>Check <a href="#get_csrf_token/0"><code class="inline">get_csrf_token/0</code></a> and <a href="#delete_csrf_token/0"><code class="inline">delete_csrf_token/0</code></a> for retrieving and deleting CSRF tokens.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="put_flash/3">put_flash(conn, key, message)</h3> <section class="docstring"> <p>Persists a value in flash.</p>
<p>Returns the updated connection.</p>
<h4 id="put_flash/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; conn = put_flash(conn, :info, "Welcome Back!")
iex&gt; get_flash(conn, :info)
"Welcome Back!"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="put_format/2">put_format(conn, format)</h3> <section class="docstring"> <p>Puts the format in the connection.</p>
<p>This format is used when rendering a template as an atom. For example, <code class="inline">render(conn, :foo)</code> will render <code class="inline">"foo.FORMAT"</code> where the format is the one set here. The default format is typically set from the negotiation done in <a href="#accepts/2"><code class="inline">accepts/2</code></a>.</p>
<p>See <a href="#get_format/1"><code class="inline">get_format/1</code></a> for retrieval.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="put_layout/2">put_layout(conn, layout)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">put_layout(
  Plug.Conn.t(),
  {atom(), binary() | atom()} | atom() | binary() | false
) :: Plug.Conn.t()</pre> </div> <p>Stores the layout for rendering.</p>
<p>The layout must be a tuple, specifying the layout view and the layout name, or false. In case a previous layout is set, <code class="inline">put_layout</code> also accepts the layout name to be given as a string or as an atom. If a string, it must contain the format. Passing an atom means the layout format will be found at rendering time, similar to the template in <a href="#render/3"><code class="inline">render/3</code></a>. It can also be set to <code class="inline">false</code>. In this case, no layout would be used.</p>
<h4 id="put_layout/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; layout(conn)
false

iex&gt; conn = put_layout conn, {AppView, "application.html"}
iex&gt; layout(conn)
{AppView, "application.html"}

iex&gt; conn = put_layout conn, "print.html"
iex&gt; layout(conn)
{AppView, "print.html"}

iex&gt; conn = put_layout conn, :print
iex&gt; layout(conn)
{AppView, :print}</pre>
<p>Raises <a href="../plug/plug.conn.alreadysenterror"><code class="inline">Plug.Conn.AlreadySentError</code></a> if <code class="inline">conn</code> is already sent.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="put_layout_formats/2">put_layout_formats(conn, formats)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">put_layout_formats(Plug.Conn.t(), [String.t()]) :: Plug.Conn.t()</pre> </div> <p>Sets which formats have a layout when rendering.</p>
<h4 id="put_layout_formats/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; layout_formats(conn)
["html"]

iex&gt; put_layout_formats(conn, ["html", "mobile"])
iex&gt; layout_formats(conn)
["html", "mobile"]</pre>
<p>Raises <a href="../plug/plug.conn.alreadysenterror"><code class="inline">Plug.Conn.AlreadySentError</code></a> if <code class="inline">conn</code> is already sent.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="put_new_layout/2">put_new_layout(conn, layout)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">put_new_layout(Plug.Conn.t(), {atom(), binary() | atom()} | false) ::
  Plug.Conn.t()</pre> </div> <p>Stores the layout for rendering if one was not stored yet.</p>
<p>Raises <a href="../plug/plug.conn.alreadysenterror"><code class="inline">Plug.Conn.AlreadySentError</code></a> if <code class="inline">conn</code> is already sent.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="put_new_view/2">put_new_view(conn, module)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">put_new_view(Plug.Conn.t(), atom()) :: Plug.Conn.t()</pre> </div> <p>Stores the view for rendering if one was not stored yet.</p>
<p>Raises <a href="../plug/plug.conn.alreadysenterror"><code class="inline">Plug.Conn.AlreadySentError</code></a> if <code class="inline">conn</code> is already sent.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="put_root_layout/2">put_root_layout(conn, layout)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">put_root_layout(
  Plug.Conn.t(),
  {atom(), binary() | atom()} | atom() | binary() | false
) :: Plug.Conn.t()</pre> </div> <p>Stores the root layout for rendering.</p>
<p>Like <a href="#put_layout/2"><code class="inline">put_layout/2</code></a>, the layout must be a tuple, specifying the layout view and the layout name, or false.</p>
<p>In case a previous layout is set, <code class="inline">put_root_layout</code> also accepts the layout name to be given as a string or as an atom. If a string, it must contain the format. Passing an atom means the layout format will be found at rendering time, similar to the template in <a href="#render/3"><code class="inline">render/3</code></a>. It can also be set to <code class="inline">false</code>. In this case, no layout would be used.</p>
<h4 id="put_root_layout/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; root_layout(conn)
false

iex&gt; conn = put_root_layout conn, {AppView, "root.html"}
iex&gt; root_layout(conn)
{AppView, "root.html"}

iex&gt; conn = put_root_layout conn, "bare.html"
iex&gt; root_layout(conn)
{AppView, "bare.html"}

iex&gt; conn = put_root_layout conn, :bare
iex&gt; root_layout(conn)
{AppView, :bare}</pre>
<p>Raises <a href="../plug/plug.conn.alreadysenterror"><code class="inline">Plug.Conn.AlreadySentError</code></a> if <code class="inline">conn</code> is already sent.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="put_router_url/2">put_router_url(conn, uri)</h3> <section class="docstring"> <p>Puts the url string or <code class="inline">%URI{}</code> to be used for route generation.</p>
<p>This function overrides the default URL generation pulled from the <code class="inline">%Plug.Conn{}</code>'s endpoint configuration.</p>
<h4 id="put_router_url/2-examples" class="section-heading">  Examples </h4> <p>Imagine your application is configured to run on "example.com" but after the user signs in, you want all links to use "some_user.example.com". You can do so by setting the proper router url configuration:</p>
<pre data-language="elixir">def put_router_url_by_user(conn) do
  put_router_url(conn, get_user_from_conn(conn).account_name &lt;&gt; ".example.com")
end</pre>
<p>Now when you call <code class="inline">Routes.some_route_url(conn, ...)</code>, it will use the router url set above. Keep in mind that, if you want to generate routes to the <em>current</em> domain, it is preferred to use <code class="inline">Routes.some_route_path</code> helpers, as those are always relative.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="put_secure_browser_headers/2">put_secure_browser_headers(conn, headers \\ %{})</h3> <section class="docstring"> <p>Put headers that improve browser security.</p>
<p>It sets the following headers:</p>
<ul>
<li>
<code class="inline">x-frame-options</code> - set to SAMEORIGIN to avoid clickjacking through iframes unless in the same origin</li>
<li>
<code class="inline">x-content-type-options</code> - set to nosniff. This requires script and style tags to be sent with proper content type</li>
<li>
<code class="inline">x-xss-protection</code> - set to "1; mode=block" to improve XSS protection on both Chrome and IE</li>
<li>
<code class="inline">x-download-options</code> - set to noopen to instruct the browser not to open a download directly in the browser, to avoid HTML files rendering inline and accessing the security context of the application (like critical domain cookies)</li>
<li>
<code class="inline">x-permitted-cross-domain-policies</code> - set to none to restrict Adobe Flash Playerâ€™s access to data</li>
<li>
<code class="inline">cross-origin-window-policy</code> - set to deny to avoid window control attacks</li>
</ul>
<p>A custom headers map may also be given to be merged with defaults. It is recommended for custom header keys to be in lowercase, to avoid sending duplicate keys in a request. Additionally, responses with mixed-case headers served over HTTP/2 are not considered valid by common clients, resulting in dropped responses.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="put_static_url/2">put_static_url(conn, uri)</h3> <section class="docstring"> <p>Puts the URL or <code class="inline">%URI{}</code> to be used for the static url generation.</p>
<p>Using this function on a <code class="inline">%Plug.Conn{}</code> struct tells <code class="inline">static_url/2</code> to use the given information for URL generation instead of the the <code class="inline">%Plug.Conn{}</code>'s endpoint configuration (much like <a href="#put_router_url/2"><code class="inline">put_router_url/2</code></a> but for static URLs).</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="put_view/2">put_view(conn, module)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">put_view(Plug.Conn.t(), atom()) :: Plug.Conn.t()</pre> </div> <p>Stores the view for rendering.</p>
<p>Raises <a href="../plug/plug.conn.alreadysenterror"><code class="inline">Plug.Conn.AlreadySentError</code></a> if <code class="inline">conn</code> is already sent.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="redirect/2">redirect(conn, opts)</h3> <section class="docstring"> <p>Sends redirect response to the given url.</p>
<p>For security, <code class="inline">:to</code> only accepts paths. Use the <code class="inline">:external</code> option to redirect to any URL.</p>
<p>The response will be sent with the status code defined within the connection, via <a href="../plug/plug.conn#put_status/2"><code class="inline">Plug.Conn.put_status/2</code></a>. If no status code is set, a 302 response is sent.</p>
<h4 id="redirect/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; redirect(conn, to: "/login")

iex&gt; redirect(conn, external: "http://elixir-lang.org")</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="render/2">render(conn, template_or_assigns \\ [])</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">render(Plug.Conn.t(), Keyword.t() | map() | binary() | atom()) :: Plug.Conn.t()</pre> </div> <p>Render the given template or the default template specified by the current action with the given assigns.</p>
<p>See <a href="#render/3"><code class="inline">render/3</code></a> for more information.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="render/3">render(conn, template, assigns)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">render(
  Plug.Conn.t(),
  binary() | atom(),
  Keyword.t() | map() | binary() | atom()
) :: Plug.Conn.t()</pre> </div> <p>Renders the given <code class="inline">template</code> and <code class="inline">assigns</code> based on the <code class="inline">conn</code> information.</p>
<p>Once the template is rendered, the template format is set as the response content type (for example, an HTML template will set "text/html" as response content type) and the data is sent to the client with default status of 200.</p>
<h4 id="render/3-arguments" class="section-heading">  Arguments </h4> <ul>
<li><p><code class="inline">conn</code> - the <a href="../plug/plug.conn"><code class="inline">Plug.Conn</code></a> struct</p></li>
<li><p><code class="inline">template</code> - which may be an atom or a string. If an atom, like <code class="inline">:index</code>, it will render a template with the same format as the one returned by <a href="#get_format/1"><code class="inline">get_format/1</code></a>. For example, for an HTML request, it will render the "index.html" template. If the template is a string, it must contain the extension too, like "index.json"</p></li>
<li><p><code class="inline">assigns</code> - a dictionary with the assigns to be used in the view. Those assigns are merged and have higher precedence than the connection assigns (<code class="inline">conn.assigns</code>)</p></li>
</ul>
<h4 id="render/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">defmodule MyAppWeb.UserController do
  use Phoenix.Controller

  def show(conn, _params) do
    render(conn, "show.html", message: "Hello")
  end
end</pre>
<p>The example above renders a template "show.html" from the <code class="inline">MyAppWeb.UserView</code> and sets the response content type to "text/html".</p>
<p>In many cases, you may want the template format to be set dynamically based on the request. To do so, you can pass the template name as an atom (without the extension):</p>
<pre data-language="elixir">def show(conn, _params) do
  render(conn, :show, message: "Hello")
end</pre>
<p>In order for the example above to work, we need to do content negotiation with the accepts plug before rendering. You can do so by adding the following to your pipeline (in the router):</p>
<pre data-language="elixir">plug :accepts, ["html"]</pre>
<h4 id="render/3-views" class="section-heading">  Views </h4> <p>By default, Controllers render templates in a view with a similar name to the controller. For example, <code class="inline">MyAppWeb.UserController</code> will render templates inside the <code class="inline">MyAppWeb.UserView</code>. This information can be changed any time by using the <a href="#put_view/2"><code class="inline">put_view/2</code></a> function:</p>
<pre data-language="elixir">def show(conn, _params) do
  conn
  |&gt; put_view(MyAppWeb.SpecialView)
  |&gt; render(:show, message: "Hello")
end</pre>
<p><a href="#put_view/2"><code class="inline">put_view/2</code></a> can also be used as a plug:</p>
<pre data-language="elixir">defmodule MyAppWeb.UserController do
  use Phoenix.Controller

  plug :put_view, MyAppWeb.SpecialView

  def show(conn, _params) do
    render(conn, :show, message: "Hello")
  end
end</pre>
<h4 id="render/3-layouts" class="section-heading">  Layouts </h4> <p>Templates are often rendered inside layouts. By default, Phoenix will render layouts for html requests. For example:</p>
<pre data-language="elixir">defmodule MyAppWeb.UserController do
  use Phoenix.Controller

  def show(conn, _params) do
    render(conn, "show.html", message: "Hello")
  end
end</pre>
<p>will render the "show.html" template inside an "app.html" template specified in <code class="inline">MyAppWeb.LayoutView</code>. <a href="#put_layout/2"><code class="inline">put_layout/2</code></a> can be used to change the layout, similar to how <a href="#put_view/2"><code class="inline">put_view/2</code></a> can be used to change the view.</p>
<p><a href="#layout_formats/1"><code class="inline">layout_formats/1</code></a> and <a href="#put_layout_formats/2"><code class="inline">put_layout_formats/2</code></a> can be used to configure which formats support/require layout rendering (defaults to "html" only).</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="root_layout/1">root_layout(conn)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">root_layout(Plug.Conn.t()) :: {atom(), String.t() | atom()} | false</pre> </div> <p>Retrieves the current root layout.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="router_module/1">router_module(conn)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">router_module(Plug.Conn.t()) :: atom()</pre> </div> <p>Returns the router module as an atom, raises if unavailable.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="scrub_params/2">scrub_params(conn, required_key)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">scrub_params(Plug.Conn.t(), String.t()) :: Plug.Conn.t()</pre> </div> <p>Scrubs the parameters from the request.</p>
<p>This process is two-fold:</p>
<ul>
<li>Checks to see if the <code class="inline">required_key</code> is present</li>
<li>Changes empty parameters of <code class="inline">required_key</code> (recursively) to nils</li>
</ul>
<p>This function is useful for removing empty strings sent via HTML forms. If you are providing an API, there is likely no need to invoke <a href="#scrub_params/2"><code class="inline">scrub_params/2</code></a>.</p>
<p>If the <code class="inline">required_key</code> is not present, it will raise <a href="phoenix.missingparamerror"><code class="inline">Phoenix.MissingParamError</code></a>.</p>
<h4 id="scrub_params/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; scrub_params(conn, "user")</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="send_download/3">send_download(conn, kind, opts \\ [])</h3> <section class="docstring"> <p>Sends the given file or binary as a download.</p>
<p>The second argument must be <code class="inline">{:binary, contents}</code>, where <code class="inline">contents</code> will be sent as download, or<code class="inline">{:file, path}</code>, where <code class="inline">path</code> is the filesystem location of the file to be sent. Be careful to not interpolate the path from external parameters, as it could allow traversal of the filesystem.</p>
<p>The download is achieved by setting "content-disposition" to attachment. The "content-type" will also be set based on the extension of the given filename but can be customized via the <code class="inline">:content_type</code> and <code class="inline">:charset</code> options.</p>
<h4 id="send_download/3-options" class="section-heading">  Options </h4> <ul>
<li>
<code class="inline">:filename</code> - the filename to be presented to the user as download</li>
<li>
<code class="inline">:content_type</code> - the content type of the file or binary sent as download. It is automatically inferred from the filename extension</li>
<li>
<code class="inline">:disposition</code> - specifies dispositon type (<code class="inline">:attachment</code> or <code class="inline">:inline</code>). If <code class="inline">:attachment</code> was used, user will be prompted to save the file. If <code class="inline">:inline</code> was used, the browser will attempt to open the file. Defaults to <code class="inline">:attachment</code>.</li>
<li>
<code class="inline">:charset</code> - the charset of the file, such as "utf-8". Defaults to none</li>
<li>
<code class="inline">:offset</code> - the bytes to offset when reading. Defaults to <code class="inline">0</code>
</li>
<li>
<code class="inline">:length</code> - the total bytes to read. Defaults to <code class="inline">:all</code>
</li>
<li>
<code class="inline">:encode</code> - encodes the filename using <a href="https://hexdocs.pm/elixir/URI.html#encode_www_form/1"><code class="inline">URI.encode_www_form/1</code></a>. Defaults to <code class="inline">true</code>. When <code class="inline">false</code>, disables encoding. If you disable encoding, you need to guarantee there are no special characters in the filename, such as quotes, newlines, etc. Otherwise you can expose your application to security attacks</li>
</ul>
<h4 id="send_download/3-examples" class="section-heading">  Examples </h4> <p>To send a file that is stored inside your application priv directory:</p>
<pre data-language="elixir">path = Application.app_dir(:my_app, "priv/prospectus.pdf")
send_download(conn, {:file, path})</pre>
<p>When using <code class="inline">{:file, path}</code>, the filename is inferred from the given path but may also be set explicitly.</p>
<p>To allow the user to download contents that are in memory as a binary or string:</p>
<pre data-language="elixir">send_download(conn, {:binary, "world"}, filename: "hello.txt")</pre>
<p>See <a href="../plug/plug.conn#send_file/3"><code class="inline">Plug.Conn.send_file/3</code></a> and <a href="../plug/plug.conn#send_resp/3"><code class="inline">Plug.Conn.send_resp/3</code></a> if you would like to access the low-level functions used to send files and responses via Plug.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="status_message_from_template/1">status_message_from_template(template)</h3> <section class="docstring"> <p>Generates a status message from the template name.</p>
<h4 id="status_message_from_template/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; status_message_from_template("404.html")
"Not Found"
iex&gt; status_message_from_template("whatever.html")
"Internal Server Error"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="text/2">text(conn, data)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">text(Plug.Conn.t(), String.Chars.t()) :: Plug.Conn.t()</pre> </div> <p>Sends text response.</p>
<h4 id="text/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; text(conn, "hello")

iex&gt; text(conn, :implements_to_string)</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="view_module/1">view_module(conn)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">view_module(Plug.Conn.t()) :: atom()</pre> </div> <p>Retrieves the current view.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="view_template/1">view_template(conn)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">view_template(Plug.Conn.t()) :: binary() | nil</pre> </div> <p>Returns the template name rendered in the view as a string (or nil if no template was rendered).</p> </section> </section> </div> </section><div class="_attribution">
  <p class="_attribution-p">
    Â© 2014 Chris McCord<br>Licensed under the MIT License.<br>
    <a href="https://hexdocs.pm/phoenix/Phoenix.Controller.html" class="_attribution-link">https://hexdocs.pm/phoenix/Phoenix.Controller.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
