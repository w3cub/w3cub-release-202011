
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Phoenix.LiveViewTest - Phoenix - W3cubDocs</title>
  
  <meta name="description" content=" Conveniences for testing Phoenix LiveViews. ">
  <meta name="keywords" content="phoenix, liveviewtest, summary, functions">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/phoenix/phoenix_live_view/phoenix.liveviewtest.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/phoenix.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/phoenix/" class="_nav-link" title="" style="margin-left:0;">Phoenix</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _elixir">
				
				
<h1>  Phoenix.LiveViewTest  </h1> <section id="moduledoc"> <p>Conveniences for testing Phoenix LiveViews.</p>
<p>In LiveView tests, we interact with views via process communication in substitution of a browser. Like a browser, our test process receives messages about the rendered updates from the view which can be asserted against to test the life-cycle and behavior of LiveViews and their children.</p>
<h2 id="module-liveview-testing" class="section-heading">  LiveView Testing </h2> <p>The life-cycle of a LiveView as outlined in the <a href="phoenix.liveview"><code class="inline">Phoenix.LiveView</code></a> docs details how a view starts as a stateless HTML render in a disconnected socket state. Once the browser receives the HTML, it connects to the server and a new LiveView process is started, remounted in a connected socket state, and the view continues statefully. The LiveView test functions support testing both disconnected and connected mounts separately, for example:</p>
<pre data-language="elixir">import Plug.Conn
import Phoenix.ConnTest
import Phoenix.LiveViewTest
@endpoint MyEndpoint

test "disconnected and connected mount", %{conn: conn} do
  conn = get(conn, "/my-path")
  assert html_response(conn, 200) =~ "&lt;h1&gt;My Disconnected View&lt;/h1&gt;"

  {:ok, view, html} = live(conn)
end

test "redirected mount", %{conn: conn} do
  assert {:error, {:redirect, %{to: "/somewhere"}}} = live(conn, "my-path")
end</pre>
<p>Here, we start by using the familiar <a href="../phoenix/phoenix.conntest"><code class="inline">Phoenix.ConnTest</code></a> function, <code class="inline">get/2</code> to test the regular HTTP GET request which invokes mount with a disconnected socket. Next, <a href="#live/1"><code class="inline">live/1</code></a> is called with our sent connection to mount the view in a connected state, which starts our stateful LiveView process.</p>
<p>In general, it's often more convenient to test the mounting of a view in a single step, provided you don't need the result of the stateless HTTP render. This is done with a single call to <a href="#live/2"><code class="inline">live/2</code></a>, which performs the <code class="inline">get</code> step for us:</p>
<pre data-language="elixir">test "connected mount", %{conn: conn} do
  {:ok, _view, html} = live(conn, "/my-path")
  assert html =~ "&lt;h1&gt;My Connected View&lt;/h1&gt;"
end</pre>
<h2 id="module-testing-events" class="section-heading">  Testing Events </h2> <p>The browser can send a variety of events to a LiveView via <code class="inline">phx-</code> bindings, which are sent to the <code class="inline">handle_event/3</code> callback. To test events sent by the browser and assert on the rendered side effect of the event, use the <code class="inline">render_*</code> functions:</p>
<ul>
<li><p><a href="#render_click/1"><code class="inline">render_click/1</code></a> - sends a phx-click event and value, returning the rendered result of the <code class="inline">handle_event/3</code> callback.</p></li>
<li><p><a href="#render_focus/2"><code class="inline">render_focus/2</code></a> - sends a phx-focus event and value, returning the rendered result of the <code class="inline">handle_event/3</code> callback.</p></li>
<li><p><a href="#render_blur/1"><code class="inline">render_blur/1</code></a> - sends a phx-blur event and value, returning the rendered result of the <code class="inline">handle_event/3</code> callback.</p></li>
<li><p><a href="#render_submit/1"><code class="inline">render_submit/1</code></a> - sends a form phx-submit event and value, returning the rendered result of the <code class="inline">handle_event/3</code> callback.</p></li>
<li><p><a href="#render_change/1"><code class="inline">render_change/1</code></a> - sends a form phx-change event and value, returning the rendered result of the <code class="inline">handle_event/3</code> callback.</p></li>
<li><p><a href="#render_keydown/1"><code class="inline">render_keydown/1</code></a> - sends a form phx-keydown event and value, returning the rendered result of the <code class="inline">handle_event/3</code> callback.</p></li>
<li><p><a href="#render_keyup/1"><code class="inline">render_keyup/1</code></a> - sends a form phx-keyup event and value, returning the rendered result of the <code class="inline">handle_event/3</code> callback.</p></li>
<li><p><a href="#render_hook/3"><code class="inline">render_hook/3</code></a> - sends a hook event and value, returning the rendered result of the <code class="inline">handle_event/3</code> callback.</p></li>
</ul>
<p>For example:</p>
<pre data-language="elixir">{:ok, view, _html} = live(conn, "/thermo")

assert render_click(view, :inc) =~ "The temperature is: 31℉"

assert render_click(view, :set_temp, 35) =~ "The temperature is: 35℉"

assert render_submit(view, :save, %{deg: 30}) =~ "The temperature is: 30℉"

assert render_change(view, :validate, %{deg: -30}) =~ "invalid temperature"

assert render_keydown(view, :key, :ArrowUp) =~ "The temperature is: 31℉"

assert render_keydown(view, :key, :ArrowDown) =~ "The temperature is: 30℉"</pre>
<h2 id="module-testing-regular-messages" class="section-heading">  Testing regular messages </h2> <p>LiveViews are <a href="https://hexdocs.pm/elixir/GenServer.html"><code class="inline">GenServer</code></a>'s under the hood, and can send and receive messages just like any other server. To test the side effects of sending or receiving messages, simply message the view and use the <code class="inline">render</code> function to test the result:</p>
<pre data-language="elixir">send(view.pid, {:set_temp, 50})
assert render(view) =~ "The temperature is: 50℉"</pre>
<h2 id="module-testing-components" class="section-heading">  Testing components </h2> <p>There are two main mechanisms for testing components. To test stateless components or just a regular rendering of a component, one can use <a href="#render_component/2"><code class="inline">render_component/2</code></a>:</p>
<pre data-language="elixir">assert render_component(MyComponent, id: 123, user: %User{}) =~
         "some markup in component"</pre>
<p>If you want to test how components are mounted by a LiveView and interact with DOM events, you can use the regular <a href="#live/2"><code class="inline">live/2</code></a> macro to build the LiveView with the component and then scope events by passing the view and a <strong>DOM selector</strong> in a list:</p>
<pre data-language="elixir">{:ok, view, html} = live(conn, "/users")
html = view |&gt; element("#user-13 a", "Delete") |&gt; render_click()
refute html =~ "user-13"
refute view |&gt; element("#user-13") |&gt; has_element?()</pre>
<p>In the example above, LiveView will lookup for an element with ID=user-13 and retrieve its <code class="inline">phx-target</code>. If <code class="inline">phx-target</code> points to a component, that will be the component used, otherwise it will fallback to the view.</p> </section> <section id="summary" class="details-list"> <h1 class="section-heading">  Summary </h1> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#assert_patch/3">assert_patch(view, to, timeout \\ 100)</a> </dt> <dd class="summary-synopsis"><p>Asserts a live patch will happen within <code class="inline">timeout</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#assert_patched/2">assert_patched(view, to)</a> </dt> <dd class="summary-synopsis"><p>Asserts a live patch was performed.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#assert_push_event/4">assert_push_event(view, event, payload, timeout \\ 100)</a> </dt> <dd class="summary-synopsis"><p>Asserts an event will be pushed within <code class="inline">timeout</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#assert_redirect/3">assert_redirect(view, to, timeout \\ 100)</a> </dt> <dd class="summary-synopsis"><p>Asserts a redirect will happen within <code class="inline">timeout</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#assert_redirected/2">assert_redirected(view, to)</a> </dt> <dd class="summary-synopsis"><p>Asserts a redirect was performed.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#assert_reply/3">assert_reply(view, payload, timeout \\ 100)</a> </dt> <dd class="summary-synopsis"><p>Asserts a hook reply was returned from a <code class="inline">handle_event</code> callback.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#element/3">element(view, selector, text_filter \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Returns an element to scope a function to.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#find_live_child/2">find_live_child(parent, child_id)</a> </dt> <dd class="summary-synopsis"><p>Gets the nested LiveView child by <code class="inline">child_id</code> from the <code class="inline">parent</code> LiveView.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#follow_redirect/3">follow_redirect(reason, conn, to \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Follows the redirect from a <code class="inline">render_*</code> action.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#form/3">form(view, selector, form_data \\ %{})</a> </dt> <dd class="summary-synopsis"><p>Returns a form element to scope a function to.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#has_element?/1">has_element?(element)</a> </dt> <dd class="summary-synopsis"><p>Checks if the given element exists on the page.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#has_element?/3">has_element?(view, selector, text_filter \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Checks if the given <code class="inline">selector</code> with <code class="inline">text_filter</code> is on <code class="inline">view</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#live/2">live(conn, path \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Spawns a connected LiveView process.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#live_children/1">live_children(parent)</a> </dt> <dd class="summary-synopsis"><p>Returns the current list of LiveView children for the <code class="inline">parent</code> LiveView.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#live_isolated/3">live_isolated(conn, live_view, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Spawns a connected LiveView process mounted in isolation as the sole rendered element.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#page_title/1">page_title(view)</a> </dt> <dd class="summary-synopsis"><p>Returns the most recent title that was updated via a <code class="inline">page_title</code> assign.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_connect_info/2">put_connect_info(conn, params)</a> </dt> <dd class="summary-synopsis"><p>Puts connect info to be used on LiveView connections.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_connect_params/2">put_connect_params(conn, params)</a> </dt> <dd class="summary-synopsis"><p>Puts connect params to be used on LiveView connections.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render/1">render(view)</a> </dt> <dd class="summary-synopsis"><p>Returns the HTML string of the rendered view or element.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_blur/2">render_blur(element, value \\ %{})</a> </dt> <dd class="summary-synopsis"><p>Sends a blur event given by <code class="inline">element</code> and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_blur/3">render_blur(view, event, value)</a> </dt> <dd class="summary-synopsis"><p>Sends a blur event to the view and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_change/2">render_change(element, value \\ %{})</a> </dt> <dd class="summary-synopsis"><p>Sends a form change event given by <code class="inline">element</code> and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_change/3">render_change(view, event, value)</a> </dt> <dd class="summary-synopsis"><p>Sends a form change event to the view and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_click/2">render_click(element, value \\ %{})</a> </dt> <dd class="summary-synopsis"><p>Sends a click event given by <code class="inline">element</code> and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_click/3">render_click(view, event, value)</a> </dt> <dd class="summary-synopsis"><p>Sends a click <code class="inline">event</code> to the <code class="inline">view</code> with <code class="inline">value</code> and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_component/3">render_component(component, assigns, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Mounts, updates and renders a component.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_focus/2">render_focus(element, value \\ %{})</a> </dt> <dd class="summary-synopsis"><p>Sends a focus event given by <code class="inline">element</code> and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_focus/3">render_focus(view, event, value)</a> </dt> <dd class="summary-synopsis"><p>Sends a focus event to the view and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_hook/3">render_hook(view_or_element, event, value \\ %{})</a> </dt> <dd class="summary-synopsis"><p>Sends a hook event to the view or an element and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_keydown/2">render_keydown(element, value \\ %{})</a> </dt> <dd class="summary-synopsis"><p>Sends a keydown event given by <code class="inline">element</code> and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_keydown/3">render_keydown(view, event, value)</a> </dt> <dd class="summary-synopsis"><p>Sends a keydown event to the view and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_keyup/2">render_keyup(element, value \\ %{})</a> </dt> <dd class="summary-synopsis"><p>Sends a keyup event given by <code class="inline">element</code> and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_keyup/3">render_keyup(view, event, value)</a> </dt> <dd class="summary-synopsis"><p>Sends a keyup event to the view and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_patch/2">render_patch(view, path)</a> </dt> <dd class="summary-synopsis"><p>Simulates a <code class="inline">live_patch</code> to the given <code class="inline">path</code> and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_submit/2">render_submit(element, value \\ %{})</a> </dt> <dd class="summary-synopsis"><p>Sends a form submit event given by <code class="inline">element</code> and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_submit/3">render_submit(view, event, value)</a> </dt> <dd class="summary-synopsis"><p>Sends a form submit event to the view and returns the rendered result.</p></dd> </div> </dl> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  Functions </h1> <div class="functions-list"> <section class="detail">  <h3 class="detail-header" id="assert_patch/3">assert_patch(view, to, timeout \\ 100)</h3> <section class="docstring"> <p>Asserts a live patch will happen within <code class="inline">timeout</code>.</p>
<p>It always returns <code class="inline">:ok</code>. To assert on the flash message, you can assert on the result of the rendered LiveView.</p>
<h4 id="assert_patch/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">render_click(view, :event_that_triggers_patch)
assert_patch view, "/path"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="assert_patched/2">assert_patched(view, to)</h3> <section class="docstring"> <p>Asserts a live patch was performed.</p>
<p>It always returns <code class="inline">:ok</code>. To assert on the flash message, you can assert on the result of the rendered LiveView.</p>
<h4 id="assert_patched/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">render_click(view, :event_that_triggers_redirect)
assert_patched view, "/path"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="assert_push_event/4">assert_push_event(view, event, payload, timeout \\ 100)</h3> <section class="docstring"> <p>Asserts an event will be pushed within <code class="inline">timeout</code>.</p>
<h4 id="assert_push_event/4-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">assert_push_event view, "scores", %{points: 100, user: "josé"}</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="assert_redirect/3">assert_redirect(view, to, timeout \\ 100)</h3> <section class="docstring"> <p>Asserts a redirect will happen within <code class="inline">timeout</code>.</p>
<p>It returns the flash messages from said redirect, if any. Note the flash will contain string keys.</p>
<h4 id="assert_redirect/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">render_click(view, :event_that_triggers_redirect)
flash = assert_redirect view, "/path"
assert flash["info"] == "Welcome"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="assert_redirected/2">assert_redirected(view, to)</h3> <section class="docstring"> <p>Asserts a redirect was performed.</p>
<p>It returns the flash messages from said redirect, if any. Note the flash will contain string keys.</p>
<h4 id="assert_redirected/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">render_click(view, :event_that_triggers_redirect)
flash = assert_redirected view, "/path"
assert flash["info"] == "Welcome"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="assert_reply/3">assert_reply(view, payload, timeout \\ 100)</h3> <section class="docstring"> <p>Asserts a hook reply was returned from a <code class="inline">handle_event</code> callback.</p>
<h4 id="assert_reply/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">assert_reply view, %{result: "ok", transaction_id: _}</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="element/3">element(view, selector, text_filter \\ nil)</h3> <section class="docstring"> <p>Returns an element to scope a function to.</p>
<p>It expects the current LiveView, a query selector, and a text filter.</p>
<p>An optional text filter may be given to filter the results by the query selector. If the text filter is a string or a regex, it will match any element that contains the string or matches the regex. After the text filter is applied, only one element must remain, otherwise an error is raised.</p>
<p>If no text filter is given, then the query selector itself must return a single element.</p>
<pre data-language="elixir">assert view
      |&gt; element("#term a:first-child()", "Increment")
      |&gt; render() =~ "Increment&lt;/a&gt;"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="find_live_child/2">find_live_child(parent, child_id)</h3> <section class="docstring"> <p>Gets the nested LiveView child by <code class="inline">child_id</code> from the <code class="inline">parent</code> LiveView.</p>
<h4 id="find_live_child/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, _html} = live(conn, "/thermo")
assert clock_view = find_live_child(view, "clock")
assert render_click(clock_view, :snooze) =~ "snoozing"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="follow_redirect/3">follow_redirect(reason, conn, to \\ nil)</h3> <section class="docstring"> <p>Follows the redirect from a <code class="inline">render_*</code> action.</p>
<p>Imagine you have a LiveView that redirects on a <code class="inline">render_click</code> event. You can make it sure it immediately redirects after the <code class="inline">render_click</code> action by calling <a href="#follow_redirect/3"><code class="inline">follow_redirect/3</code></a>:</p>
<pre data-language="elixir">live_view
|&gt; render_click("redirect")
|&gt; follow_redirect(conn)</pre>
<p><a href="#follow_redirect/3"><code class="inline">follow_redirect/3</code></a> expects a connection as second argument. This is the connection that will be used to perform the underlying request.</p>
<p>If the LiveView redirects with a live redirect, this macro returns <code class="inline">{:ok, live_view, disconnected_html}</code> with the content of the new LiveView, the same as the <code class="inline">live/3</code> macro. If the LiveView redirects with a regular redirect, this macro returns <code class="inline">{:ok, conn}</code> with the rendered redirected page. In any other case, this macro raises.</p>
<p>Finally, note that you can optionally assert on the path you are being redirected to by passing a third argument:</p>
<pre data-language="elixir">live_view
|&gt; render_click("redirect")
|&gt; follow_redirect(conn, "/redirected/page")</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="form/3">form(view, selector, form_data \\ %{})</h3> <section class="docstring"> <p>Returns a form element to scope a function to.</p>
<p>It expects the current LiveView, a query selector, and the form data. The query selector must return a single element.</p>
<p>The form data will be validated directly against the form markup and make sure the data you are changing/submitting actually exists, failing otherwise.</p>
<h4 id="form/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">assert view
      |&gt; form("#term", user: %{name: "hello"})
      |&gt; render_submit() =~ "Name updated"</pre>
<p>This function is meant to mimic what the user can actually do, so you cannot set hidden input values. However, hidden values can be given when calling <a href="#render_submit/2"><code class="inline">render_submit/2</code></a> or <a href="#render_change/2"><code class="inline">render_change/2</code></a>, see their docs for examples.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="has_element?/1">has_element?(element)</h3> <section class="docstring"> <p>Checks if the given element exists on the page.</p>
<h4 id="has_element?/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">assert view |&gt; element("#some-element") |&gt; has_element?()</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="has_element?/3">has_element?(view, selector, text_filter \\ nil)</h3> <section class="docstring"> <p>Checks if the given <code class="inline">selector</code> with <code class="inline">text_filter</code> is on <code class="inline">view</code>.</p>
<p>See <a href="#element/3"><code class="inline">element/3</code></a> for more information.</p>
<h4 id="has_element?/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">assert has_element?(view, "#some-element")</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="live/2">live(conn, path \\ nil)</h3> <section class="docstring"> <p>Spawns a connected LiveView process.</p>
<p>If a <code class="inline">path</code> is given, then a regular <code class="inline">get(conn, path)</code> is done and the page is upgraded to a <code class="inline">LiveView</code>. If no path is given, it assumes a previously rendered <code class="inline">%Plug.Conn{}</code> is given, which will be converted to a <code class="inline">LiveView</code> immediately.</p>
<h4 id="live/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/path")
assert view.module = MyLive
assert html =~ "the count is 3"

assert {:error, {:redirect, %{to: "/somewhere"}}} = live(conn, "/path")</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="live_children/1">live_children(parent)</h3> <section class="docstring"> <p>Returns the current list of LiveView children for the <code class="inline">parent</code> LiveView.</p>
<p>Children are returned in the order they appear in the rendered HTML.</p>
<h4 id="live_children/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, _html} = live(conn, "/thermo")
assert [clock_view] = live_children(view)
assert render_click(clock_view, :snooze) =~ "snoozing"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="live_isolated/3">live_isolated(conn, live_view, opts \\ [])</h3> <section class="docstring"> <p>Spawns a connected LiveView process mounted in isolation as the sole rendered element.</p>
<p>Useful for testing LiveViews that are not directly routable, such as those built as small components to be re-used in multiple parents. Testing routable LiveViews is still recommended whenever possible since features such as live navigation require routable LiveViews.</p>
<h4 id="live_isolated/3-options" class="section-heading">  Options </h4> <ul>
<li>
<code class="inline">:connect_params</code> - the map of params available in connected mount. See <a href="phoenix.liveview#get_connect_params/1"><code class="inline">Phoenix.LiveView.get_connect_params/1</code></a> for more information.</li>
<li>
<code class="inline">:session</code> - the session to be given to the LiveView</li>
</ul>
<p>All other options are forwarded to the LiveView for rendering. Refer to <a href="phoenix.liveview.helpers#live_render/3"><code class="inline">Phoenix.LiveView.Helpers.live_render/3</code></a> for a list of supported render options.</p>
<h4 id="live_isolated/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} =
  live_isolated(conn, AppWeb.ClockLive, session: %{"tz" =&gt; "EST"})</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="page_title/1">page_title(view)</h3> <section class="docstring"> <p>Returns the most recent title that was updated via a <code class="inline">page_title</code> assign.</p>
<h4 id="page_title/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">render_click(view, :event_that_triggers_page_title_update)
assert page_title(view) =~ "my title"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="put_connect_info/2">put_connect_info(conn, params)</h3> <section class="docstring"> <p>Puts connect info to be used on LiveView connections.</p>
<p>See <a href="phoenix.liveview#get_connect_info/1"><code class="inline">Phoenix.LiveView.get_connect_info/1</code></a>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="put_connect_params/2">put_connect_params(conn, params)</h3> <section class="docstring"> <p>Puts connect params to be used on LiveView connections.</p>
<p>See <a href="phoenix.liveview#get_connect_params/1"><code class="inline">Phoenix.LiveView.get_connect_params/1</code></a>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="render/1">render(view)</h3> <section class="docstring"> <p>Returns the HTML string of the rendered view or element.</p>
<p>If a view is provided, the entire LiveView is rendered. If an element is provided, only that element is rendered.</p>
<h4 id="render/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, _html} = live(conn, "/thermo")
assert render(view) =~ ~s|&lt;button id="alarm"&gt;Snooze&lt;/div&gt;|

assert view
       |&gt; element("#alarm")
       |&gt; render() == "Snooze"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="render_blur/2">render_blur(element, value \\ %{})</h3> <section class="docstring"> <p>Sends a blur event given by <code class="inline">element</code> and returns the rendered result.</p>
<p>The <code class="inline">element</code> is created with <a href="#element/3"><code class="inline">element/3</code></a> and must point to a single element on the page with a <code class="inline">phx-blur</code> attribute in it. The event name given set on <code class="inline">phx-blur</code> is then sent to the appropriate LiveView (or component if <code class="inline">phx-target</code> is set accordingly). All <code class="inline">phx-value-*</code> entries in the element are sent as values. Extra values can be given with the <code class="inline">value</code> argument.</p>
<p>It returns the contents of the whole LiveView or an <code class="inline">{:error, redirect}</code> tuple.</p>
<h4 id="render_blur/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/thermo")

assert view
       |&gt; element("#inactive")
       |&gt; render_blur() =~ "Tap to wake"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="render_blur/3">render_blur(view, event, value)</h3> <section class="docstring"> <p>Sends a blur event to the view and returns the rendered result.</p>
<p>It returns the contents of the whole LiveView or an <code class="inline">{:error, redirect}</code> tuple.</p>
<h4 id="render_blur/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/thermo")
assert html =~ "The temp is: 30℉"
assert render_blur(view, :inactive) =~ "Tap to wake"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="render_change/2">render_change(element, value \\ %{})</h3> <section class="docstring"> <p>Sends a form change event given by <code class="inline">element</code> and returns the rendered result.</p>
<p>The <code class="inline">element</code> is created with <a href="#element/3"><code class="inline">element/3</code></a> and must point to a single element on the page with a <code class="inline">phx-change</code> attribute in it. The event name given set on <code class="inline">phx-change</code> is then sent to the appropriate LiveView (or component if <code class="inline">phx-target</code> is set accordingly). All <code class="inline">phx-value-*</code> entries in the element are sent as values.</p>
<p>If you need to pass any extra values or metadata, such as the "_target" parameter, you can do so by giving a map under the <code class="inline">value</code> argument.</p>
<p>It returns the contents of the whole LiveView or an <code class="inline">{:error, redirect}</code> tuple.</p>
<h4 id="render_change/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/thermo")

assert view
       |&gt; element("form")
       |&gt; render_change(%{deg: 123}) =~ "123 exceeds limits"

# Passing metadata
{:ok, view, html} = live(conn, "/thermo")

assert view
       |&gt; element("form")
       |&gt; render_change(%{_target: ["deg"], deg: 123}) =~ "123 exceeds limits"</pre>
<p>As with <a href="#render_submit/2"><code class="inline">render_submit/2</code></a>, hidden input field values can be provided like so:</p>
<pre data-language="elixir">refute view
      |&gt; form("#term", user: %{name: "hello"})
      |&gt; render_change(%{user: %{"hidden_field" =&gt; "example"}}) =~ "can't be blank"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="render_change/3">render_change(view, event, value)</h3> <section class="docstring"> <p>Sends a form change event to the view and returns the rendered result.</p>
<p>It returns the contents of the whole LiveView or an <code class="inline">{:error, redirect}</code> tuple.</p>
<h4 id="render_change/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/thermo")
assert html =~ "The temp is: 30℉"
assert render_change(view, :validate, %{deg: 123}) =~ "123 exceeds limits"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="render_click/2">render_click(element, value \\ %{})</h3> <section class="docstring"> <p>Sends a click event given by <code class="inline">element</code> and returns the rendered result.</p>
<p>The <code class="inline">element</code> is created with <a href="#element/3"><code class="inline">element/3</code></a> and must point to a single element on the page with a <code class="inline">phx-click</code> attribute in it. The event name given set on <code class="inline">phx-click</code> is then sent to the appropriate LiveView (or component if <code class="inline">phx-target</code> is set accordingly). All <code class="inline">phx-value-*</code> entries in the element are sent as values. Extra values can be given with the <code class="inline">value</code> argument.</p>
<p>If the element is does not have a <code class="inline">phx-click</code> attribute but it is a link (the <code class="inline">&lt;a&gt;</code> tag), the link will be followed accordingly:</p>
<ul>
<li>if the link is a <code class="inline">live_patch</code>, the current view will be patched</li>
<li>if the link is a <code class="inline">live_redirect</code>, this function will return <code class="inline">{:error, {:live_redirect, %{to: url}}}</code>, which can be followed with <a href="#follow_redirect/2"><code class="inline">follow_redirect/2</code></a>
</li>
<li>if the link is a regular link, this function will return <code class="inline">{:error, {:redirect, %{to: url}}}</code>, which can be followed with <a href="#follow_redirect/2"><code class="inline">follow_redirect/2</code></a>
</li>
</ul>
<p>It returns the contents of the whole LiveView or an <code class="inline">{:error, redirect}</code> tuple.</p>
<h4 id="render_click/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/thermo")

assert view
       |&gt; element("buttons", "Increment")
       |&gt; render_click() =~ "The temperature is: 30℉"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="render_click/3">render_click(view, event, value)</h3> <section class="docstring"> <p>Sends a click <code class="inline">event</code> to the <code class="inline">view</code> with <code class="inline">value</code> and returns the rendered result.</p>
<p>It returns the contents of the whole LiveView or an <code class="inline">{:error, redirect}</code> tuple.</p>
<h4 id="render_click/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/thermo")
assert html =~ "The temperature is: 30℉"
assert render_click(view, :inc) =~ "The temperature is: 31℉"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="render_component/3">render_component(component, assigns, opts \\ [])</h3> <section class="docstring"> <p>Mounts, updates and renders a component.</p>
<p>If the component uses the <code class="inline">@myself</code> assigns, then an <code class="inline">id</code> must be given to it is marked as stateful.</p>
<h4 id="render_component/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">assert render_component(MyComponent, id: 123, user: %User{}) =~
         "some markup in component"

assert render_component(MyComponent, %{id: 123, user: %User{}}, router: SomeRouter) =~
         "some markup in component"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="render_focus/2">render_focus(element, value \\ %{})</h3> <section class="docstring"> <p>Sends a focus event given by <code class="inline">element</code> and returns the rendered result.</p>
<p>The <code class="inline">element</code> is created with <a href="#element/3"><code class="inline">element/3</code></a> and must point to a single element on the page with a <code class="inline">phx-focus</code> attribute in it. The event name given set on <code class="inline">phx-focus</code> is then sent to the appropriate LiveView (or component if <code class="inline">phx-target</code> is set accordingly). All <code class="inline">phx-value-*</code> entries in the element are sent as values. Extra values can be given with the <code class="inline">value</code> argument.</p>
<p>It returns the contents of the whole LiveView or an <code class="inline">{:error, redirect}</code> tuple.</p>
<h4 id="render_focus/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/thermo")

assert view
       |&gt; element("#inactive")
       |&gt; render_focus() =~ "Tap to wake"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="render_focus/3">render_focus(view, event, value)</h3> <section class="docstring"> <p>Sends a focus event to the view and returns the rendered result.</p>
<p>It returns the contents of the whole LiveView or an <code class="inline">{:error, redirect}</code> tuple.</p>
<h4 id="render_focus/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/thermo")
assert html =~ "The temp is: 30℉"
assert render_focus(view, :inactive) =~ "Tap to wake"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="render_hook/3">render_hook(view_or_element, event, value \\ %{})</h3> <section class="docstring"> <p>Sends a hook event to the view or an element and returns the rendered result.</p>
<p>It returns the contents of the whole LiveView or an <code class="inline">{:error, redirect}</code> tuple.</p>
<h4 id="render_hook/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/thermo")
assert html =~ "The temp is: 30℉"
assert render_hook(view, :refresh, %{deg: 32}) =~ "The temp is: 32℉"</pre>
<p>If you are pushing events from a hook to a component, then you must pass an <code class="inline">element</code>, created with <a href="#element/3"><code class="inline">element/3</code></a>, as first argument and it must point to a single element on the page with a <code class="inline">phx-target</code> attribute in it:</p>
<pre data-language="elixir">{:ok, view, _html} = live(conn, "/thermo")
assert view
       |&gt; element("#thermo-component")
       |&gt; render_hook(:refresh, %{deg: 32}) =~ "The temp is: 32℉"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="render_keydown/2">render_keydown(element, value \\ %{})</h3> <section class="docstring"> <p>Sends a keydown event given by <code class="inline">element</code> and returns the rendered result.</p>
<p>The <code class="inline">element</code> is created with <a href="#element/3"><code class="inline">element/3</code></a> and must point to a single element on the page with a <code class="inline">phx-keydown</code> or <code class="inline">phx-window-keydown</code> attribute in it. The event name given set on <code class="inline">phx-keydown</code> is then sent to the appropriate LiveView (or component if <code class="inline">phx-target</code> is set accordingly). All <code class="inline">phx-value-*</code> entries in the element are sent as values. Extra values can be given with the <code class="inline">value</code> argument.</p>
<p>It returns the contents of the whole LiveView or an <code class="inline">{:error, redirect}</code> tuple.</p>
<h4 id="render_keydown/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/thermo")
assert html =~ "The temp is: 30℉"
assert view |&gt; element("#inc") |&gt; render_keydown() =~ "The temp is: 31℉"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="render_keydown/3">render_keydown(view, event, value)</h3> <section class="docstring"> <p>Sends a keydown event to the view and returns the rendered result.</p>
<p>It returns the contents of the whole LiveView or an <code class="inline">{:error, redirect}</code> tuple.</p>
<h4 id="render_keydown/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/thermo")
assert html =~ "The temp is: 30℉"
assert render_keydown(view, :inc) =~ "The temp is: 31℉"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="render_keyup/2">render_keyup(element, value \\ %{})</h3> <section class="docstring"> <p>Sends a keyup event given by <code class="inline">element</code> and returns the rendered result.</p>
<p>The <code class="inline">element</code> is created with <a href="#element/3"><code class="inline">element/3</code></a> and must point to a single element on the page with a <code class="inline">phx-keyup</code> or <code class="inline">phx-window-keyup</code> attribute in it. The event name given set on <code class="inline">phx-keyup</code> is then sent to the appropriate LiveView (or component if <code class="inline">phx-target</code> is set accordingly). All <code class="inline">phx-value-*</code> entries in the element are sent as values. Extra values can be given with the <code class="inline">value</code> argument.</p>
<p>It returns the contents of the whole LiveView or an <code class="inline">{:error, redirect}</code> tuple.</p>
<h4 id="render_keyup/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/thermo")
assert html =~ "The temp is: 30℉"
assert view |&gt; element("#inc") |&gt; render_keyup() =~ "The temp is: 31℉"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="render_keyup/3">render_keyup(view, event, value)</h3> <section class="docstring"> <p>Sends a keyup event to the view and returns the rendered result.</p>
<p>It returns the contents of the whole LiveView or an <code class="inline">{:error, redirect}</code> tuple.</p>
<h4 id="render_keyup/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/thermo")
assert html =~ "The temp is: 30℉"
assert render_keyup(view, :inc) =~ "The temp is: 31℉"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="render_patch/2">render_patch(view, path)</h3> <section class="docstring"> <p>Simulates a <code class="inline">live_patch</code> to the given <code class="inline">path</code> and returns the rendered result.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="render_submit/2">render_submit(element, value \\ %{})</h3> <section class="docstring"> <p>Sends a form submit event given by <code class="inline">element</code> and returns the rendered result.</p>
<p>The <code class="inline">element</code> is created with <a href="#element/3"><code class="inline">element/3</code></a> and must point to a single element on the page with a <code class="inline">phx-submit</code> attribute in it. The event name given set on <code class="inline">phx-submit</code> is then sent to the appropriate LiveView (or component if <code class="inline">phx-target</code> is set accordingly). All <code class="inline">phx-value-*</code> entries in the element are sent as values. Extra values, including hidden input fields, can be given with the <code class="inline">value</code> argument.</p>
<p>It returns the contents of the whole LiveView or an <code class="inline">{:error, redirect}</code> tuple.</p>
<h4 id="render_submit/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/thermo")

assert view
       |&gt; element("form")
       |&gt; render_submit(%{deg: 123}) =~ "123 exceeds limits"</pre>
<p>To submit a form along with some with hidden input values:</p>
<pre data-language="elixir">assert view
      |&gt; form("#term", user: %{name: "hello"})
      |&gt; render_submit(%{user: %{"hidden_field" =&gt; "example"}}) =~ "Name updated"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="render_submit/3">render_submit(view, event, value)</h3> <section class="docstring"> <p>Sends a form submit event to the view and returns the rendered result.</p>
<p>It returns the contents of the whole LiveView or an <code class="inline">{:error, redirect}</code> tuple.</p>
<h4 id="render_submit/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/thermo")
assert html =~ "The temp is: 30℉"
assert render_submit(view, :refresh, %{deg: 32}) =~ "The temp is: 32℉"</pre> </section> </section> </div> </section><div class="_attribution">
  <p class="_attribution-p">
    © 2018 Chris McCord<br>Licensed under the MIT License.<br>
    <a href="https://hexdocs.pm/phoenix_live_view/Phoenix.LiveViewTest.html" class="_attribution-link">https://hexdocs.pm/phoenix_live_view/Phoenix.LiveViewTest.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
