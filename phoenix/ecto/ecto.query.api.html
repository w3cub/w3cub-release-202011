
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Ecto.Query.API - Phoenix - W3cubDocs</title>
  
  <meta name="description" content=" Lists all functions allowed in the query API. ">
  <meta name="keywords" content="ecto, query, api, summary, functions, phoenix">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/phoenix/ecto/ecto.query.api.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/phoenix.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/phoenix/" class="_nav-link" title="" style="margin-left:0;">Phoenix</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _elixir">
				
				
<h1> Ecto.Query.API   </h1> <section id="moduledoc"> <p>Lists all functions allowed in the query API.</p>
<ul>
<li>Comparison operators: <code class="inline">==</code>, <code class="inline">!=</code>, <code class="inline">&lt;=</code>, <code class="inline">&gt;=</code>, <code class="inline">&lt;</code>, <code class="inline">&gt;</code>
</li>
<li>Arithmetic operators: <code class="inline">+</code>, <code class="inline">-</code>, <code class="inline">*</code>, <code class="inline">/</code>
</li>
<li>Boolean operators: <code class="inline">and</code>, <code class="inline">or</code>, <code class="inline">not</code>
</li>
<li>Inclusion operator: <a href="#in/2"><code class="inline">in/2</code></a>
</li>
<li>Subquery operators: <code class="inline">any</code>, <code class="inline">all</code> and <code class="inline">exists</code>
</li>
<li>Search functions: <a href="#like/2"><code class="inline">like/2</code></a> and <a href="#ilike/2"><code class="inline">ilike/2</code></a>
</li>
<li>Null check functions: <a href="#is_nil/1"><code class="inline">is_nil/1</code></a>
</li>
<li>Aggregates: <a href="#count/0"><code class="inline">count/0</code></a>, <a href="#count/1"><code class="inline">count/1</code></a>, <a href="#avg/1"><code class="inline">avg/1</code></a>, <a href="#sum/1"><code class="inline">sum/1</code></a>, <a href="#min/1"><code class="inline">min/1</code></a>, <a href="#max/1"><code class="inline">max/1</code></a>
</li>
<li>Date/time intervals: <a href="#datetime_add/3"><code class="inline">datetime_add/3</code></a>, <a href="#date_add/3"><code class="inline">date_add/3</code></a>, <a href="#from_now/2"><code class="inline">from_now/2</code></a>, <a href="#ago/2"><code class="inline">ago/2</code></a>
</li>
<li>Inside select: <a href="#struct/2"><code class="inline">struct/2</code></a>, <a href="#map/2"><code class="inline">map/2</code></a>, <a href="#merge/2"><code class="inline">merge/2</code></a> and literals (map, tuples, lists, etc)</li>
<li>General: <a href="#fragment/1"><code class="inline">fragment/1</code></a>, <a href="#field/2"><code class="inline">field/2</code></a>, <a href="#type/2"><code class="inline">type/2</code></a>, <a href="#as/1"><code class="inline">as/1</code></a>, <a href="#parent_as/1"><code class="inline">parent_as/1</code></a>
</li>
</ul>
<p>Note the functions in this module exist for documentation purposes and one should never need to invoke them directly. Furthermore, it is possible to define your own macros and use them in Ecto queries (see docs for <a href="#fragment/1"><code class="inline">fragment/1</code></a>).</p>
<h2 id="module-intervals" class="section-heading">  Intervals </h2> <p>Ecto supports following values for <code class="inline">interval</code> option: <code class="inline">"year"</code>, <code class="inline">"month"</code>, <code class="inline">"week"</code>, <code class="inline">"day"</code>, <code class="inline">"hour"</code>, <code class="inline">"minute"</code>, <code class="inline">"second"</code>, <code class="inline">"millisecond"</code>, and <code class="inline">"microsecond"</code>.</p>
<p><a href="https://hexdocs.pm/elixir/Date.html"><code class="inline">Date</code></a>/<a href="https://hexdocs.pm/elixir/Time.html"><code class="inline">Time</code></a> functions like <a href="#datetime_add/3"><code class="inline">datetime_add/3</code></a>, <a href="#date_add/3"><code class="inline">date_add/3</code></a>, <a href="#from_now/2"><code class="inline">from_now/2</code></a>, <a href="#ago/2"><code class="inline">ago/2</code></a> take <code class="inline">interval</code> as an argument.</p>
<h2 id="module-window-api" class="section-heading">  Window API </h2> <p>Ecto also supports many of the windows functions found in SQL databases. See <a href="ecto.query.windowapi"><code class="inline">Ecto.Query.WindowAPI</code></a> for more information.</p>
<h2 id="module-about-the-arithmetic-operators" class="section-heading">  About the arithmetic operators </h2> <p>The Ecto implementation of these operators provide only a thin layer above the adapters. So if your adapter allows you to use them in a certain way (like adding a date and an interval in PostgreSQL), it should work just fine in Ecto queries.</p> </section> <section id="summary" class="details-list"> <h1 class="section-heading">  Summary </h1> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#!=/2">left != right</a> </dt> <dd class="summary-synopsis"><p>Binary <code class="inline">!=</code> operation.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#*/2">left * right</a> </dt> <dd class="summary-synopsis"><p>Binary <code class="inline">*</code> operation.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#+/2">left + right</a> </dt> <dd class="summary-synopsis"><p>Binary <code class="inline">+</code> operation.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#-/2">left - right</a> </dt> <dd class="summary-synopsis"><p>Binary <code class="inline">-</code> operation.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#//2">left / right</a> </dt> <dd class="summary-synopsis"><p>Binary <code class="inline">/</code> operation.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#%3C/2">left &lt; right</a> </dt> <dd class="summary-synopsis"><p>Binary <code class="inline">&lt;</code> operation.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#%3C=/2">left &lt;= right</a> </dt> <dd class="summary-synopsis"><p>Binary <code class="inline">&lt;=</code> operation.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#==/2">left == right</a> </dt> <dd class="summary-synopsis"><p>Binary <code class="inline">==</code> operation.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#%3E/2">left &gt; right</a> </dt> <dd class="summary-synopsis"><p>Binary <code class="inline">&gt;</code> operation.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#%3E=/2">left &gt;= right</a> </dt> <dd class="summary-synopsis"><p>Binary <code class="inline">&gt;=</code> operation.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#ago/2">ago(count, interval)</a> </dt> <dd class="summary-synopsis"><p>Subtracts the given interval from the current time in UTC.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#all/1">all(subquery)</a> </dt> <dd class="summary-synopsis"><p>Evaluates whether all values returned from the provided subquery match in a comparison operation.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#and/2">left and right</a> </dt> <dd class="summary-synopsis"><p>Binary <code class="inline">and</code> operation.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#any/1">any(subquery)</a> </dt> <dd class="summary-synopsis"><p>Tests whether one or more values returned from the provided subquery match in a comparison operation.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#as/1">as(binding)</a> </dt> <dd class="summary-synopsis"><p>Refer to a named atom binding.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#avg/1">avg(value)</a> </dt> <dd class="summary-synopsis"><p>Calculates the average for the given entry.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#coalesce/2">coalesce(value, expr)</a> </dt> <dd class="summary-synopsis"><p>Takes whichever value is not null, or null if they both are.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#count/0">count()</a> </dt> <dd class="summary-synopsis"><p>Counts the entries in the table.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#count/1">count(value)</a> </dt> <dd class="summary-synopsis"><p>Counts the given entry.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#count/2">count(value, atom)</a> </dt> <dd class="summary-synopsis"><p>Counts the distinct values in given entry.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#date_add/3">date_add(date, count, interval)</a> </dt> <dd class="summary-synopsis"><p>Adds a given interval to a date.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#datetime_add/3">datetime_add(datetime, count, interval)</a> </dt> <dd class="summary-synopsis"><p>Adds a given interval to a datetime.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#exists/1">exists(subquery)</a> </dt> <dd class="summary-synopsis"><p>Evaluates to true if the provided subquery returns 1 or more rows.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#field/2">field(source, field)</a> </dt> <dd class="summary-synopsis"><p>Allows a field to be dynamically accessed.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#filter/2">filter(value, filter)</a> </dt> <dd class="summary-synopsis"><p>Applies the given expression as a FILTER clause against an aggregate. This is currently only supported by Postgres.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#fragment/1">fragment(fragments)</a> </dt> <dd class="summary-synopsis"><p>Send fragments directly to the database.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#from_now/2">from_now(count, interval)</a> </dt> <dd class="summary-synopsis"><p>Adds the given interval to the current time in UTC.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#ilike/2">ilike(string, search)</a> </dt> <dd class="summary-synopsis"><p>Searches for <code class="inline">search</code> in <code class="inline">string</code> in a case insensitive fashion.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#in/2">left in right</a> </dt> <dd class="summary-synopsis"><p>Checks if the left-value is included in the right one.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#is_nil/1">is_nil(value)</a> </dt> <dd class="summary-synopsis"><p>Checks if the given value is nil.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#json_extract_path/2">json_extract_path(json_field, path)</a> </dt> <dd class="summary-synopsis"><p>Returns value from the <code class="inline">json_field</code> pointed to by <code class="inline">path</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#like/2">like(string, search)</a> </dt> <dd class="summary-synopsis"><p>Searches for <code class="inline">search</code> in <code class="inline">string</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#map/2">map(source, fields)</a> </dt> <dd class="summary-synopsis"><p>Used in <code class="inline">select</code> to specify which fields should be returned as a map.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#max/1">max(value)</a> </dt> <dd class="summary-synopsis"><p>Calculates the maximum for the given entry.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#merge/2">merge(left_map, right_map)</a> </dt> <dd class="summary-synopsis"><p>Merges the map on the right over the map on the left.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#min/1">min(value)</a> </dt> <dd class="summary-synopsis"><p>Calculates the minimum for the given entry.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#not/1">not(value)</a> </dt> <dd class="summary-synopsis"><p>Unary <code class="inline">not</code> operation.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#or/2">left or right</a> </dt> <dd class="summary-synopsis"><p>Binary <code class="inline">or</code> operation.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#parent_as/1">parent_as(binding)</a> </dt> <dd class="summary-synopsis"><p>Refer to a named atom binding in the parent query.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#struct/2">struct(source, fields)</a> </dt> <dd class="summary-synopsis"><p>Used in <code class="inline">select</code> to specify which struct fields should be returned.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#sum/1">sum(value)</a> </dt> <dd class="summary-synopsis"><p>Calculates the sum for the given entry.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#type/2">type(interpolated_value, type)</a> </dt> <dd class="summary-synopsis"><p>Casts the given value to the given type at the database level.</p></dd> </div> </dl> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  Functions </h1> <div class="functions-list"> <section class="detail"> <h3 class="detail-header" id="!=/2">left != right</h3> <section class="docstring"> <p>Binary <code class="inline">!=</code> operation.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="*/2">left * right</h3> <section class="docstring"> <p>Binary <code class="inline">*</code> operation.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="+/2">left + right</h3> <section class="docstring"> <p>Binary <code class="inline">+</code> operation.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="-/2">left - right</h3> <section class="docstring"> <p>Binary <code class="inline">-</code> operation.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="//2">left / right</h3> <section class="docstring"> <p>Binary <code class="inline">/</code> operation.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="%3C/2">left &lt; right</h3> <section class="docstring"> <p>Binary <code class="inline">&lt;</code> operation.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="%3C=/2">left &lt;= right</h3> <section class="docstring"> <p>Binary <code class="inline">&lt;=</code> operation.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="==/2">left == right</h3> <section class="docstring"> <p>Binary <code class="inline">==</code> operation.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="%3E/2">left &gt; right</h3> <section class="docstring"> <p>Binary <code class="inline">&gt;</code> operation.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="%3E=/2">left &gt;= right</h3> <section class="docstring"> <p>Binary <code class="inline">&gt;=</code> operation.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="ago/2">ago(count, interval)</h3> <section class="docstring"> <p>Subtracts the given interval from the current time in UTC.</p>
<p>The current time in UTC is retrieved from Elixir and not from the database.</p>
<p>See <a href="#module-intervals">Intervals</a> for supported <code class="inline">interval</code> values.</p>
<h4 id="ago/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">from p in Post, where: p.published_at &gt; ago(3, "month")</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="all/1">all(subquery)</h3> <section class="docstring"> <p>Evaluates whether all values returned from the provided subquery match in a comparison operation.</p>
<pre data-language="elixir">from p in Post, where: p.visits &gt;= all(
  from(p in Post, select: avg(p.visits), group_by: [p.category_id])
)</pre>
<p>For a post to match in the above example it must be visited at least as much as the average post in all categories.</p>
<pre data-language="elixir">from p in Post, where: p.visits = all(
  from(p in Post, select: max(p.visits))
)</pre>
<p>The above example matches all the posts which are tied for being the most visited.</p>
<p>Both <code class="inline">any</code> and <code class="inline">all</code> must be given a subquery as an argument, and theyu must be used on the right hand side of a comparison. Both can be used with every comparison operator: <code class="inline">==</code>, <code class="inline">!=</code>, <code class="inline">&gt;</code>, <code class="inline">&gt;=</code>, <code class="inline">&lt;</code>, <code class="inline">&lt;=</code>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="and/2">left and right</h3> <section class="docstring"> <p>Binary <code class="inline">and</code> operation.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="any/1">any(subquery)</h3> <section class="docstring"> <p>Tests whether one or more values returned from the provided subquery match in a comparison operation.</p>
<pre data-language="elixir">from p in Product, where: p.id = any(
  from(li in LineItem, select: [li.product_id], where: li.created_at &gt; ^since and li.qty &gt;= 10)
)</pre>
<p>A product matches in the above example if a line item was created since the provided date where the customer purchased at least 10 units.</p>
<p>Both <code class="inline">any</code> and <code class="inline">all</code> must be given a subquery as an argument, and theyu must be used on the right hand side of a comparison. Both can be used with every comparison operator: <code class="inline">==</code>, <code class="inline">!=</code>, <code class="inline">&gt;</code>, <code class="inline">&gt;=</code>, <code class="inline">&lt;</code>, <code class="inline">&lt;=</code>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="as/1">as(binding)</h3> <section class="docstring"> <p>Refer to a named atom binding.</p>
<p>See the "Named binding" section in <a href="ecto.query"><code class="inline">Ecto.Query</code></a> for more information.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="avg/1">avg(value)</h3> <section class="docstring"> <p>Calculates the average for the given entry.</p>
<pre data-language="elixir">from p in Payment, select: avg(p.value)</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="coalesce/2">coalesce(value, expr)</h3> <section class="docstring"> <p>Takes whichever value is not null, or null if they both are.</p>
<p>In SQL, COALESCE takes any number of arguments, but in ecto it only takes two, so it must be chained to achieve the same effect.</p>
<pre data-language="elixir">from p in Payment, select: p.value |&gt; coalesce(p.backup_value) |&gt; coalesce(0)</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="count/0">count()</h3> <section class="docstring"> <p>Counts the entries in the table.</p>
<pre data-language="elixir">from p in Post, select: count()</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="count/1">count(value)</h3> <section class="docstring"> <p>Counts the given entry.</p>
<pre data-language="elixir">from p in Post, select: count(p.id)</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="count/2">count(value, atom)</h3> <section class="docstring"> <p>Counts the distinct values in given entry.</p>
<pre data-language="elixir">from p in Post, select: count(p.id, :distinct)</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="date_add/3">date_add(date, count, interval)</h3> <section class="docstring"> <p>Adds a given interval to a date.</p>
<p>See <a href="#datetime_add/3"><code class="inline">datetime_add/3</code></a> for more information.</p>
<p>See <a href="#module-intervals">Intervals</a> for supported <code class="inline">interval</code> values.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="datetime_add/3">datetime_add(datetime, count, interval)</h3> <section class="docstring"> <p>Adds a given interval to a datetime.</p>
<p>The first argument is a <code class="inline">datetime</code>, the second one is the count for the interval, which may be either positive or negative and the interval value:</p>
<pre data-language="elixir"># Get all items published since the last month
from p in Post, where: p.published_at &gt;
                       datetime_add(^NaiveDateTime.utc_now(), -1, "month")</pre>
<p>In the example above, we used <a href="#datetime_add/3"><code class="inline">datetime_add/3</code></a> to subtract one month from the current datetime and compared it with the <code class="inline">p.published_at</code>. If you want to perform operations on date, <a href="#date_add/3"><code class="inline">date_add/3</code></a> could be used.</p>
<p>See <a href="#module-intervals">Intervals</a> for supported <code class="inline">interval</code> values.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="exists/1">exists(subquery)</h3> <section class="docstring"> <p>Evaluates to true if the provided subquery returns 1 or more rows.</p>
<pre data-language="elixir">from p in Post, as: :post, where: exists(from(c in Comment, where: parent_as(:post).id == c.post_id and c.replies_count &gt; 5, select: 1))</pre>
<p>This is best used in conjunction with <code class="inline">parent_as</code> to correlate the subquery with the parent query to test some condition on related rows in a different table. In the above example the query returns posts which have at least one comment that has more than 5 replies.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="field/2">field(source, field)</h3> <section class="docstring"> <p>Allows a field to be dynamically accessed.</p>
<pre data-language="elixir">def at_least_four(doors_or_tires) do
  from c in Car,
    where: field(c, ^doors_or_tires) &gt;= 4
end</pre>
<p>In the example above, both <code class="inline">at_least_four(:doors)</code> and <code class="inline">at_least_four(:tires)</code> would be valid calls as the field is dynamically generated.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="filter/2">filter(value, filter)</h3> <section class="docstring"> <p>Applies the given expression as a FILTER clause against an aggregate. This is currently only supported by Postgres.</p>
<pre data-language="elixir">from p in Payment, select: filter(avg(p.value), p.value &gt; 0 and p.value &lt; 100)

from p in Payment, select: avg(p.value) |&gt; filter(p.value &lt; 0)</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="fragment/1">fragment(fragments)</h3> <section class="docstring"> <p>Send fragments directly to the database.</p>
<p>It is not possible to represent all possible database queries using Ecto's query syntax. When such is required, it is possible to use fragments to send any expression to the database:</p>
<pre data-language="elixir">def unpublished_by_title(title) do
  from p in Post,
    where: is_nil(p.published_at) and
           fragment("lower(?)", p.title) == ^title
end</pre>
<p>Every occurence of the <code class="inline">?</code> character will be interpreted as a place for additional argument. If the literal character <code class="inline">?</code> is required, it can be escaped with <code class="inline">\\?</code> (one escape for strings, another for fragment).</p>
<p>In the example above, we are using the lower procedure in the database to downcase the title column.</p>
<p>It is very important to keep in mind that Ecto is unable to do any type casting described above when fragments are used. You can however use the <a href="#type/2"><code class="inline">type/2</code></a> function to give Ecto some hints:</p>
<pre data-language="elixir">fragment("lower(?)", p.title) == type(^title, :string)</pre>
<p>Or even say the right side is of the same type as <code class="inline">p.title</code>:</p>
<pre data-language="elixir">fragment("lower(?)", p.title) == type(^title, p.title)</pre>
<h4 id="fragment/1-keyword-fragments" class="section-heading">  Keyword fragments </h4> <p>In order to support databases that do not have string-based queries, like MongoDB, fragments also allow keywords to be given:</p>
<pre data-language="elixir">from p in Post,
    where: fragment(title: ["$eq": ^some_value])</pre>
<h4 id="fragment/1-defining-custom-functions-using-macros-and-fragment" class="section-heading">  Defining custom functions using macros and fragment </h4> <p>You can add a custom Ecto query function using macros. For example to expose SQL's coalesce function you can define this macro:</p>
<pre data-language="elixir">defmodule CustomFunctions do
  defmacro coalesce(left, right) do
    quote do
      fragment("coalesce(?, ?)", unquote(left), unquote(right))
    end
  end
end</pre>
<p>To have coalesce/2 available, just import the module that defines it.</p>
<pre data-language="elixir">import CustomFunctions</pre>
<p>The only downside is that it will show up as a fragment when inspecting the Elixir query. Other than that, it should be equivalent to a built-in Ecto query function.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="from_now/2">from_now(count, interval)</h3> <section class="docstring"> <p>Adds the given interval to the current time in UTC.</p>
<p>The current time in UTC is retrieved from Elixir and not from the database.</p>
<p>See <a href="#module-intervals">Intervals</a> for supported <code class="inline">interval</code> values.</p>
<h4 id="from_now/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">from a in Account, where: a.expires_at &lt; from_now(3, "month")</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="ilike/2">ilike(string, search)</h3> <section class="docstring"> <p>Searches for <code class="inline">search</code> in <code class="inline">string</code> in a case insensitive fashion.</p>
<pre data-language="elixir">from p in Post, where: ilike(p.body, "Chapter%")</pre>
<p>Translates to the underlying SQL ILIKE query. This operation is only available on PostgreSQL.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="in/2">left in right</h3> <section class="docstring"> <p>Checks if the left-value is included in the right one.</p>
<pre data-language="elixir">from p in Post, where: p.id in [1, 2, 3]</pre>
<p>The right side may either be a list, a literal list or even a column in the database with array type:</p>
<pre data-language="elixir">from p in Post, where: "elixir" in p.tags</pre>
<p>Additionally, the right side may also be a subquery:</p>
<pre data-language="elixir">from c in Comment, where: c.post_id in subquery(
  from(p in Post, where: p.created_at &gt; ^since)
)</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="is_nil/1">is_nil(value)</h3> <section class="docstring"> <p>Checks if the given value is nil.</p>
<pre data-language="elixir">from p in Post, where: is_nil(p.published_at)</pre>
<p>To check if a given value is not nil use:</p>
<pre data-language="elixir">from p in Post, where: not is_nil(p.published_at)</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="json_extract_path/2">json_extract_path(json_field, path)</h3> <section class="docstring"> <p>Returns value from the <code class="inline">json_field</code> pointed to by <code class="inline">path</code>.</p>
<pre data-language="elixir">from(post in Post, select: json_extract_path(post.meta, ["author", "name"]))</pre>
<p>The query can be also rewritten as:</p>
<pre data-language="elixir">from(post in Post, select: post.meta["author"]["name"])</pre>
<p>Path elements can be integers to access values in JSON arrays:</p>
<pre data-language="elixir">from(post in Post, select: post.meta["tags"][0]["name"])</pre>
<p>Any element of the path can be dynamic:</p>
<pre data-language="elixir">field = "name"
from(post in Post, select: post.meta["author"][^field])</pre>
<h4 id="json_extract_path/2-warning" class="section-heading">  Warning </h4> <p>The underlying data in the JSON column is returned without any additional decoding. This means "null" JSON values are not the same as SQL's "null". For example, the <code class="inline">Repo.all</code> operation below returns an empty list because <code class="inline">p.meta["author"]</code> returns JSON's null and therefore <code class="inline">is_nil</code> does not succeed:</p>
<pre data-language="elixir">Repo.insert!(%Post{meta: %{author: nil}})
Repo.all(from(post in Post, where: is_nil(p.meta["author"])))</pre>
<p>Similarly, other types, such as datetimes, are returned as strings. This means conditions like <code class="inline">post.meta["published_at"] &gt; from_now(-1, "day")</code> may return incorrect results or fail as the underlying database tries to compare incompatible types. You can, however, use <a href="#type/2"><code class="inline">type/2</code></a> to force the types on the database level.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="like/2">like(string, search)</h3> <section class="docstring"> <p>Searches for <code class="inline">search</code> in <code class="inline">string</code>.</p>
<pre data-language="elixir">from p in Post, where: like(p.body, "Chapter%")</pre>
<p>Translates to the underlying SQL LIKE query, therefore its behaviour is dependent on the database. In particular, PostgreSQL will do a case-sensitive operation, while the majority of other databases will be case-insensitive. For performing a case-insensitive <code class="inline">like</code> in PostgreSQL, see <a href="#ilike/2"><code class="inline">ilike/2</code></a>.</p>
<p>You should be very careful when allowing user sent data to be used as part of LIKE query, since they allow to perform <a href="https://githubengineering.com/like-injection/">LIKE-injections</a>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="map/2">map(source, fields)</h3> <section class="docstring"> <p>Used in <code class="inline">select</code> to specify which fields should be returned as a map.</p>
<p>For example, if you don't need all fields to be returned or neither need a struct, you can use <a href="#map/2"><code class="inline">map/2</code></a> to achieve both:</p>
<pre data-language="elixir">from p in Post,
  select: map(p, [:title, :body])</pre>
<p><a href="#map/2"><code class="inline">map/2</code></a> can also be used to dynamically select fields:</p>
<pre data-language="elixir">fields = [:title, :body]
from p in Post, select: map(p, ^fields)</pre>
<p>If the same source is selected multiple times with a <code class="inline">map</code>, the fields are merged in order to avoid fetching multiple copies from the database. In other words, the expression below:</p>
<pre data-language="elixir">from(city in City, preload: :country,
     select: {map(city, [:country_id]), map(city, [:name])}</pre>
<p>is expanded to:</p>
<pre data-language="elixir">from(city in City, preload: :country,
     select: {map(city, [:country_id, :name]), map(city, [:country_id, :name])}</pre>
<p>For preloads, the selected fields may be specified from the parent:</p>
<pre data-language="elixir">from(city in City, preload: :country,
     select: map(city, [:country_id, :name, country: [:id, :population]]))</pre>
<p> It's also possible to select a struct from one source but only a subset of fields from one of its associations:</p>
<pre data-language="elixir">from(city in City, preload: :country,
     select: %{city | country: map(country: [:id, :population]))</pre>
<p><strong>IMPORTANT</strong>: When filtering fields for associations, you MUST include the foreign keys used in the relationship, otherwise Ecto will be unable to find associated records.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="max/1">max(value)</h3> <section class="docstring"> <p>Calculates the maximum for the given entry.</p>
<pre data-language="elixir">from p in Payment, select: max(p.value)</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="merge/2">merge(left_map, right_map)</h3> <section class="docstring"> <p>Merges the map on the right over the map on the left.</p>
<p>If the map on the left side is a struct, Ecto will check all of the field on the right previously exist on the left before merging.</p>
<pre data-language="elixir">from(city in City, select: merge(city, %{virtual_field: "some_value"}))</pre>
<p>This function is primarily used by <a href="ecto.query#select_merge/3"><code class="inline">Ecto.Query.select_merge/3</code></a> to merge different select clauses.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="min/1">min(value)</h3> <section class="docstring"> <p>Calculates the minimum for the given entry.</p>
<pre data-language="elixir">from p in Payment, select: min(p.value)</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="not/1">not(value)</h3> <section class="docstring"> <p>Unary <code class="inline">not</code> operation.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="or/2">left or right</h3> <section class="docstring"> <p>Binary <code class="inline">or</code> operation.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="parent_as/1">parent_as(binding)</h3> <section class="docstring"> <p>Refer to a named atom binding in the parent query.</p>
<p>This is available only inside subqueries.</p>
<p>See the "Named binding" section in <a href="ecto.query"><code class="inline">Ecto.Query</code></a> for more information.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="struct/2">struct(source, fields)</h3> <section class="docstring"> <p>Used in <code class="inline">select</code> to specify which struct fields should be returned.</p>
<p>For example, if you don't need all fields to be returned as part of a struct, you can filter it to include only certain fields by using <a href="#struct/2"><code class="inline">struct/2</code></a>:</p>
<pre data-language="elixir">from p in Post,
  select: struct(p, [:title, :body])</pre>
<p><a href="#struct/2"><code class="inline">struct/2</code></a> can also be used to dynamically select fields:</p>
<pre data-language="elixir">fields = [:title, :body]
from p in Post, select: struct(p, ^fields)</pre>
<p>As a convenience, <code class="inline">select</code> allows developers to take fields without an explicit call to <a href="#struct/2"><code class="inline">struct/2</code></a>:</p>
<pre data-language="elixir">from p in Post, select: [:title, :body]</pre>
<p>Or even dynamically:</p>
<pre data-language="elixir">fields = [:title, :body]
from p in Post, select: ^fields</pre>
<p>For preloads, the selected fields may be specified from the parent:</p>
<pre data-language="elixir">from(city in City, preload: :country,
     select: struct(city, [:country_id, :name, country: [:id, :population]]))</pre>
<p>If the same source is selected multiple times with a <code class="inline">struct</code>, the fields are merged in order to avoid fetching multiple copies from the database. In other words, the expression below:</p>
<pre data-language="elixir">from(city in City, preload: :country,
     select: {struct(city, [:country_id]), struct(city, [:name])}</pre>
<p>is expanded to:</p>
<pre data-language="elixir">from(city in City, preload: :country,
     select: {struct(city, [:country_id, :name]), struct(city, [:country_id, :name])}</pre>
<p><strong>IMPORTANT</strong>: When filtering fields for associations, you MUST include the foreign keys used in the relationship, otherwise Ecto will be unable to find associated records.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="sum/1">sum(value)</h3> <section class="docstring"> <p>Calculates the sum for the given entry.</p>
<pre data-language="elixir">from p in Payment, select: sum(p.value)</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="type/2">type(interpolated_value, type)</h3> <section class="docstring"> <p>Casts the given value to the given type at the database level.</p>
<p>Most of the times, Ecto is able to proper cast interpolated values due to its type checking mechanism. In some situations though, you may want to tell Ecto that a parameter has some particular type:</p>
<pre data-language="elixir">type(^title, :string)</pre>
<p>It is also possible to say the type must match the same of a column:</p>
<pre data-language="elixir">type(^title, p.title)</pre>
<p>Ecto will ensure <code class="inline">^title</code> is cast to the given type and enforce such type at the database level. If the value is returned in a <code class="inline">select</code>, Ecto will also enforce the proper type throughout.</p>
<p>When performing arithmetic operations, <a href="#type/2"><code class="inline">type/2</code></a> can be used to cast all the parameters in the operation to the same type:</p>
<pre data-language="elixir">from p in Post,
  select: type(p.visits + ^a_float + ^a_integer, :decimal)</pre>
<p>Inside <code class="inline">select</code>, <a href="#type/2"><code class="inline">type/2</code></a> can also be used to cast fragments:</p>
<pre data-language="elixir">type(fragment("NOW"), :naive_datetime)</pre>
<p>Or to type fields from schemaless queries:</p>
<pre data-language="elixir">from p in "posts", select: type(p.cost, :decimal)</pre>
<p>Or to type aggregation results:</p>
<pre data-language="elixir">from p in Post, select: type(avg(p.cost), :integer)
from p in Post, select: type(filter(avg(p.cost), p.cost &gt; 0), :integer)</pre> </section> </section> </div> </section><div class="_attribution">
  <p class="_attribution-p">
    © 2013 Plataformatec<br>© 2020 Dashbit<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/ecto/Ecto.Query.API.html" class="_attribution-link">https://hexdocs.pm/ecto/Ecto.Query.API.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
