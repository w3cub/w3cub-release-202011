
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Ecto.Schema - Phoenix - W3cubDocs</title>
  
  <meta name="description" content=" Defines a schema. ">
  <meta name="keywords" content="ecto, schema, summary, types, functions, phoenix">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/phoenix/ecto/ecto.schema.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/phoenix.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/phoenix/" class="_nav-link" title="" style="margin-left:0;">Phoenix</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _elixir">
				
				
<h1> Ecto.Schema   </h1> <section id="moduledoc"> <p>Defines a schema.</p>
<p>An Ecto schema is used to map any data source into an Elixir struct. The definition of the schema is possible through two main APIs: <a href="#schema/2"><code class="inline">schema/2</code></a> and <a href="#embedded_schema/1"><code class="inline">embedded_schema/1</code></a>.</p>
<p><a href="#schema/2"><code class="inline">schema/2</code></a> is typically used to map data from a persisted source, usually a database table, into Elixir structs and vice-versa. For this reason, the first argument of <a href="#schema/2"><code class="inline">schema/2</code></a> is the source (table) name. Structs defined with <a href="#schema/2"><code class="inline">schema/2</code></a> also contain a <code class="inline">__meta__</code> field with metadata holding the status of the struct, for example, if it has been built, loaded or deleted.</p>
<p>On the other hand, <a href="#embedded_schema/1"><code class="inline">embedded_schema/1</code></a> is used for defining schemas that are embedded in other schemas or only exist in-memory. For example, you can use such schemas to receive data from a command line interface and validate it, without ever persisting it elsewhere. Such structs do not contain a <code class="inline">__meta__</code> field, as they are never persisted.</p>
<p>Besides working as data mappers, <a href="#embedded_schema/1"><code class="inline">embedded_schema/1</code></a> and <a href="#schema/2"><code class="inline">schema/2</code></a> can also be used together to decouple how the data is represented in your applications from the database. Let's see some examples.</p>
<h2 id="module-example" class="section-heading">  Example </h2> <pre data-language="elixir">defmodule User do
  use Ecto.Schema

  schema "users" do
    field :name, :string
    field :age, :integer, default: 0
    field :password, :string, redact: true
    has_many :posts, Post
  end
end</pre>
<p>By default, a schema will automatically generate a primary key which is named <code class="inline">id</code> and of type <code class="inline">:integer</code>. The <code class="inline">field</code> macro defines a field in the schema with given name and type. <code class="inline">has_many</code> associates many posts with the user schema. Schemas are regular structs and can be created and manipulated directly using Elixir's struct API:</p>
<pre data-language="elixir">iex&gt; user = %User{name: "jane"}
iex&gt; %{user | age: 30}</pre>
<p>However, most commonly, structs are cast, validated and manipulated with the <a href="ecto.changeset"><code class="inline">Ecto.Changeset</code></a> module.</p>
<p>Note that the name of the database table does not need to correlate to your module name. For example, if you are working with a legacy database, you can reference the table name when you define your schema:</p>
<pre data-language="elixir">defmodule User do
  use Ecto.Schema

  schema "legacy_users" do
    # ... fields ...
  end
end</pre>
<p>Embedded schemas are defined similarly to source-based schemas. For example, you can use an embedded schema to represent your UI, mapping and validating its inputs, and then you convert such embedded schema to other schemas that are persisted to the database:</p>
<pre data-language="elixir">defmodule SignUp do
  use Ecto.Schema

  embedded_schema do
    field :name, :string
    field :age, :integer
    field :email, :string
    field :accepts_conditions, :boolean
  end
end

defmodule Profile do
  use Ecto.Schema

  schema "profiles" do
    field :name
    field :age
    belongs_to :account, Account
  end
end

defmodule Account do
  use Ecto.Schema

  schema "accounts" do
    field :email
  end
end</pre>
<p>The <code class="inline">SignUp</code> schema can be cast and validated with the help of the <a href="ecto.changeset"><code class="inline">Ecto.Changeset</code></a> module, and afterwards, you can copy its data to the <code class="inline">Profile</code> and <code class="inline">Account</code> structs that will be persisted to the database with the help of <a href="ecto.repo"><code class="inline">Ecto.Repo</code></a>.</p>
<h2 id="module-redacting-fields" class="section-heading">  Redacting fields </h2> <p>A field marked with <code class="inline">redact: true</code> will display a value of <code class="inline">**redacted**</code> when inspected in changes inside a <a href="ecto.changeset"><code class="inline">Ecto.Changeset</code></a> and be excluded from inspect on the schema unless the schema module is tagged with the option <code class="inline">@ecto_derive_inspect_for_redacted_fields false</code>.</p>
<h2 id="module-schema-attributes" class="section-heading">  Schema attributes </h2> <p>Supported attributes for configuring the defined schema. They must be set after the <code class="inline">use Ecto.Schema</code> call and before the <a href="#schema/2"><code class="inline">schema/2</code></a> definition.</p>
<p>These attributes are:</p>
<ul>
<li><p><code class="inline">@primary_key</code> - configures the schema primary key. It expects a tuple <code class="inline">{field_name, type, options}</code> with the primary key field name, type (typically <code class="inline">:id</code> or <code class="inline">:binary_id</code>, but can be any type) and options. It also accepts <code class="inline">false</code> to disable the generation of a primary key field. Defaults to <code class="inline">{:id, :id, autogenerate: true}</code>.</p></li>
<li><p><code class="inline">@schema_prefix</code> - configures the schema prefix. Defaults to <code class="inline">nil</code>, which generates structs and queries without prefix. When set, the prefix will be used by every built struct and on queries whenever the schema is used in a <code class="inline">from</code> or a <code class="inline">join</code>. In PostgreSQL, the prefix is called "SCHEMA" (typically set via Postgres' <code class="inline">search_path</code>). In MySQL the prefix points to databases.</p></li>
<li><p><code class="inline">@foreign_key_type</code> - configures the default foreign key type used by <code class="inline">belongs_to</code> associations. It must be set in the same module that defines the <code class="inline">belongs_to</code>. Defaults to <code class="inline">:id</code>;</p></li>
<li><p><code class="inline">@timestamps_opts</code> - configures the default timestamps type used by <code class="inline">timestamps</code>. Defaults to <code class="inline">[type: :naive_datetime]</code>;</p></li>
<li><p><code class="inline">@derive</code> - the same as <code class="inline">@derive</code> available in <a href="https://hexdocs.pm/elixir/Kernel.html#defstruct/1"><code class="inline">Kernel.defstruct/1</code></a> as the schema defines a struct behind the scenes;</p></li>
<li><p><code class="inline">@field_source_mapper</code> - a function that receives the current field name and returns the mapping of this field name in the underlying source. In other words, it is a mechanism to automatically generate the <code class="inline">:source</code> option for the <code class="inline">field</code> macro. It defaults to <code class="inline">fn x -&gt; x end</code>, where no field transformation is done;</p></li>
</ul>
<p>The advantage of configuring the schema via those attributes is that they can be set with a macro to configure application wide defaults.</p>
<p>For example, if your database does not support autoincrementing primary keys and requires something like UUID or a RecordID, you can configure and use <code class="inline">:binary_id</code> as your primary key type as follows:</p>
<pre data-language="elixir"># Define a module to be used as base
defmodule MyApp.Schema do
  defmacro __using__(_) do
    quote do
      use Ecto.Schema
      @primary_key {:id, :binary_id, autogenerate: true}
      @foreign_key_type :binary_id
    end
  end
end

# Now use MyApp.Schema to define new schemas
defmodule MyApp.Comment do
  use MyApp.Schema

  schema "comments" do
    belongs_to :post, MyApp.Post
  end
end</pre>
<p>Any schemas using <code class="inline">MyApp.Schema</code> will get the <code class="inline">:id</code> field with type <code class="inline">:binary_id</code> as the primary key. We explain what the <code class="inline">:binary_id</code> type entails in the next section.</p>
<p>The <code class="inline">belongs_to</code> association on <code class="inline">MyApp.Comment</code> will also define a <code class="inline">:post_id</code> field with <code class="inline">:binary_id</code> type that references the <code class="inline">:id</code> field of the <code class="inline">MyApp.Post</code> schema.</p>
<h2 id="module-primary-keys" class="section-heading">  Primary keys </h2> <p>Ecto supports two ID types, called <code class="inline">:id</code> and <code class="inline">:binary_id</code>, which are often used as the type for primary keys and associations.</p>
<p>The <code class="inline">:id</code> type is used when the primary key is an integer while the <code class="inline">:binary_id</code> is used for primary keys in particular binary formats, which may be <a href="ecto.uuid"><code class="inline">Ecto.UUID</code></a> for databases like PostgreSQL and MySQL, or some specific ObjectID or RecordID often imposed by NoSQL databases.</p>
<p>In both cases, both types have their semantics specified by the underlying adapter/database. If you use the <code class="inline">:id</code> type with <code class="inline">:autogenerate</code>, it means the database will be responsible for auto-generation of the id. This is often the case for primary keys in relational databases which are auto-incremented.</p>
<p>There are two ways to define primary keys in Ecto: using the <code class="inline">@primary_key</code> module attribute and using <code class="inline">primary_key: true</code> as option for <a href="#field/3"><code class="inline">field/3</code></a> in your schema definition. They are not mutually exclusive and can be used together.</p>
<p>Using <code class="inline">@primary_key</code> should be prefered for single field primary keys and sharing primary key definitions between multiple schemas using macros. Setting <code class="inline">@primary_key</code> also automatically configures the reference types for <code class="inline">has_one</code> and <code class="inline">has_many</code> associations.</p>
<p>Ecto also supports composite primary keys, which is where you need to use <code class="inline">primary_key: true</code> for the fields in your schema. This usually goes along with setting <code class="inline">@primary_key false</code> to disable generation of additional primary key fields.</p>
<p>Besides <code class="inline">:id</code> and <code class="inline">:binary_id</code>, which are often used by primary and foreign keys, Ecto provides a huge variety of types to be used by any field.</p>
<h2 id="module-types-and-casting" class="section-heading">  Types and casting </h2> <p>When defining the schema, types need to be given. Types are split into two categories, primitive types and custom types.</p>
<h3 id="module-primitive-types" class="section-heading">  Primitive types </h3> <p>The primitive types are:</p>
<table>
<thead><tr>
<th style="text-align: left;">Ecto type</th>
<th style="text-align: left;">Elixir type</th>
<th style="text-align: left;">Literal syntax in query</th>
</tr></thead>
<tbody>
<tr>
<td style="text-align: left;"><code class="inline">:id</code></td>
<td style="text-align: left;"><code class="inline">integer</code></td>
<td style="text-align: left;">1, 2, 3</td>
</tr>
<tr>
<td style="text-align: left;"><code class="inline">:binary_id</code></td>
<td style="text-align: left;"><code class="inline">binary</code></td>
<td style="text-align: left;"><code class="inline">&lt;&lt;int, int, int, ...&gt;&gt;</code></td>
</tr>
<tr>
<td style="text-align: left;"><code class="inline">:integer</code></td>
<td style="text-align: left;"><code class="inline">integer</code></td>
<td style="text-align: left;">1, 2, 3</td>
</tr>
<tr>
<td style="text-align: left;"><code class="inline">:float</code></td>
<td style="text-align: left;"><code class="inline">float</code></td>
<td style="text-align: left;">1.0, 2.0, 3.0</td>
</tr>
<tr>
<td style="text-align: left;"><code class="inline">:boolean</code></td>
<td style="text-align: left;"><code class="inline">boolean</code></td>
<td style="text-align: left;">true, false</td>
</tr>
<tr>
<td style="text-align: left;"><code class="inline">:string</code></td>
<td style="text-align: left;">UTF-8 encoded <code class="inline">string</code>
</td>
<td style="text-align: left;">"hello"</td>
</tr>
<tr>
<td style="text-align: left;"><code class="inline">:binary</code></td>
<td style="text-align: left;"><code class="inline">binary</code></td>
<td style="text-align: left;"><code class="inline">&lt;&lt;int, int, int, ...&gt;&gt;</code></td>
</tr>
<tr>
<td style="text-align: left;"><code class="inline">{:array, inner_type}</code></td>
<td style="text-align: left;"><code class="inline">list</code></td>
<td style="text-align: left;"><code class="inline">[value, value, value, ...]</code></td>
</tr>
<tr>
<td style="text-align: left;"><code class="inline">:map</code></td>
<td style="text-align: left;"><code class="inline">map</code></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><code class="inline">{:map, inner_type}</code></td>
<td style="text-align: left;"><code class="inline">map</code></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><code class="inline">:decimal</code></td>
<td style="text-align: left;"><a href="https://github.com/ericmj/decimal"><code class="inline">Decimal</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><code class="inline">:date</code></td>
<td style="text-align: left;"><a href="https://hexdocs.pm/elixir/Date.html"><code class="inline">Date</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><code class="inline">:time</code></td>
<td style="text-align: left;"><a href="https://hexdocs.pm/elixir/Time.html"><code class="inline">Time</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><code class="inline">:time_usec</code></td>
<td style="text-align: left;"><a href="https://hexdocs.pm/elixir/Time.html"><code class="inline">Time</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><code class="inline">:naive_datetime</code></td>
<td style="text-align: left;"><a href="https://hexdocs.pm/elixir/NaiveDateTime.html"><code class="inline">NaiveDateTime</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><code class="inline">:naive_datetime_usec</code></td>
<td style="text-align: left;"><a href="https://hexdocs.pm/elixir/NaiveDateTime.html"><code class="inline">NaiveDateTime</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><code class="inline">:utc_datetime</code></td>
<td style="text-align: left;"><a href="https://hexdocs.pm/elixir/DateTime.html"><code class="inline">DateTime</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><code class="inline">:utc_datetime_usec</code></td>
<td style="text-align: left;"><a href="https://hexdocs.pm/elixir/DateTime.html"><code class="inline">DateTime</code></a></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<p><strong>Notes:</strong></p>
<ul>
<li><p>For the <code class="inline">{:array, inner_type}</code> and <code class="inline">{:map, inner_type}</code> type, replace <code class="inline">inner_type</code> with one of the valid types, such as <code class="inline">:string</code>.</p></li>
<li><p>For the <code class="inline">:decimal</code> type, <code class="inline">+Infinity</code>, <code class="inline">-Infinity</code>, and <code class="inline">NaN</code> values are not supported, even though the <a href="https://hexdocs.pm/decimal/1.6.0/Decimal.html"><code class="inline">Decimal</code></a> library handles them. To support them, you can create a custom type.</p></li>
<li><p>For calendar types with and without microseconds, the precision is enforced when persisting to the DB. For example, casting <code class="inline">~T[09:00:00]</code> as <code class="inline">:time_usec</code> will succeed and result in <code class="inline">~T[09:00:00.000000]</code>, but persisting a type without microseconds as <code class="inline">:time_usec</code> will fail. Similarly, casting <code class="inline">~T[09:00:00.000000]</code> as <code class="inline">:time</code> will succeed, but persisting will not. This is the same behaviour as seen in other types, where casting has to be done explicitly and is never performed implicitly when loading from or dumping to the database.</p></li>
</ul>
<h3 id="module-custom-types" class="section-heading">  Custom types </h3> <p>Besides providing primitive types, Ecto allows custom types to be implemented by developers, allowing Ecto behaviour to be extended.</p>
<p>A custom type is a module that implements one of the <a href="ecto.type"><code class="inline">Ecto.Type</code></a> or <a href="ecto.parameterizedtype"><code class="inline">Ecto.ParameterizedType</code></a> behaviours. By default, Ecto provides the following custom types:</p>
<table>
<thead><tr>
<th style="text-align: left;">Custom type</th>
<th style="text-align: left;">Database type</th>
<th style="text-align: left;">Elixir type</th>
</tr></thead>
<tbody>
<tr>
<td style="text-align: left;"><a href="ecto.uuid"><code class="inline">Ecto.UUID</code></a></td>
<td style="text-align: left;">
<code class="inline">:uuid</code> (as a binary)</td>
<td style="text-align: left;">
<code class="inline">string()</code> (as a UUID)</td>
</tr>
<tr>
<td style="text-align: left;"><a href="ecto.enum"><code class="inline">Ecto.Enum</code></a></td>
<td style="text-align: left;"><code class="inline">:string</code></td>
<td style="text-align: left;"><code class="inline">atom()</code></td>
</tr>
</tbody>
</table>
<p>Finally, schemas can also have virtual fields by passing the <code class="inline">virtual: true</code> option. These fields are not persisted to the database and can optionally not be type checked by declaring type <code class="inline">:any</code>.</p>
<h3 id="module-the-datetime-types" class="section-heading">  The datetime types </h3> <p>Four different datetime primitive types are available:</p>
<ul>
<li><p><code class="inline">naive_datetime</code> - has a precision of seconds and casts values to Elixir's <a href="https://hexdocs.pm/elixir/NaiveDateTime.html"><code class="inline">NaiveDateTime</code></a> struct which has no timezone information.</p></li>
<li><p><code class="inline">naive_datetime_usec</code> - has a default precision of microseconds and also casts values to <a href="https://hexdocs.pm/elixir/NaiveDateTime.html"><code class="inline">NaiveDateTime</code></a> with no timezone information.</p></li>
<li><p><code class="inline">utc_datetime</code> - has a precision of seconds and casts values to Elixir's <a href="https://hexdocs.pm/elixir/DateTime.html"><code class="inline">DateTime</code></a> struct and expects the time zone to be set to UTC.</p></li>
<li><p><code class="inline">utc_datetime_usec</code> has a default precision of microseconds and also casts values to <a href="https://hexdocs.pm/elixir/DateTime.html"><code class="inline">DateTime</code></a> expecting the time zone be set to UTC.</p></li>
</ul>
<p>All of those types are represented by the same timestamp/datetime in the underlying data storage, the difference are in their precision and how the data is loaded into Elixir.</p>
<p>Having different precisions allows developers to choose a type that will be compatible with the database and your project's precision requirements. For example, some older versions of MySQL do not support microseconds in datetime fields.</p>
<p>When choosing what datetime type to work with, keep in mind that Elixir functions like <a href="https://hexdocs.pm/elixir/NaiveDateTime.html#utc_now/0"><code class="inline">NaiveDateTime.utc_now/0</code></a> have a default precision of 6. Casting a value with a precision greater than 0 to a non-<code class="inline">usec</code> type will truncate all microseconds and set the precision to 0.</p>
<h3 id="module-the-map-type" class="section-heading">  The map type </h3> <p>The map type allows developers to store an Elixir map directly in the database:</p>
<pre data-language="elixir"># In your migration
create table(:users) do
  add :data, :map
end

# In your schema
field :data, :map

# Now in your code
user = Repo.insert! %User{data: %{"foo" =&gt; "bar"}}</pre>
<p>Keep in mind that we advise the map keys to be strings or integers instead of atoms. Atoms may be accepted depending on how maps are serialized but the database will always convert atom keys to strings due to security reasons.</p>
<p>In order to support maps, different databases may employ different techniques. For example, PostgreSQL will store those values in jsonb fields, allowing you to just query parts of it. MSSQL, on the other hand, does not yet provide a JSON type, so the value will be stored in a text field.</p>
<p>For maps to work in such databases, Ecto will need a JSON library. By default Ecto will use <a href="http://github.com/michalmuskala/jason">Jason</a> which needs to be added to your deps in <code class="inline">mix.exs</code>:</p>
<pre data-language="elixir">{:jason, "~&gt; 1.0"}</pre>
<p>You can however configure the adapter to use another library. For example, if using Postgres:</p>
<pre data-language="elixir">config :postgrex, :json_library, YourLibraryOfChoice</pre>
<p>Or if using MySQL:</p>
<pre data-language="elixir">config :mariaex, :json_library, YourLibraryOfChoice</pre>
<p>If changing the JSON library, remember to recompile the adapter afterwards by cleaning the current build:</p>
<pre data-language="elixir">mix deps.clean --build postgrex</pre>
<h3 id="module-casting" class="section-heading">  Casting </h3> <p>When directly manipulating the struct, it is the responsibility of the developer to ensure the field values have the proper type. For example, you can create a user struct with an invalid value for <code class="inline">age</code>:</p>
<pre data-language="elixir">iex&gt; user = %User{age: "0"}
iex&gt; user.age
"0"</pre>
<p>However, if you attempt to persist the struct above, an error will be raised since Ecto validates the types when sending them to the adapter/database.</p>
<p>Therefore, when working with and manipulating external data, it is recommended to use <a href="ecto.changeset"><code class="inline">Ecto.Changeset</code></a>'s that are able to filter and properly cast external data:</p>
<pre data-language="elixir">changeset = Ecto.Changeset.cast(%User{}, %{"age" =&gt; "0"}, [:age])
user = Repo.insert!(changeset)</pre>
<p><strong>You can use Ecto schemas and changesets to cast and validate any kind of data, regardless if the data will be persisted to an Ecto repository or not</strong>.</p>
<h2 id="module-reflection" class="section-heading">  Reflection </h2> <p>Any schema module will generate the <code class="inline">__schema__</code> function that can be used for runtime introspection of the schema:</p>
<ul>
<li><p><code class="inline">__schema__(:source)</code> - Returns the source as given to <a href="#schema/2"><code class="inline">schema/2</code></a>;</p></li>
<li><p><code class="inline">__schema__(:prefix)</code> - Returns optional prefix for source provided by <code class="inline">@schema_prefix</code> schema attribute;</p></li>
<li><p><code class="inline">__schema__(:primary_key)</code> - Returns a list of primary key fields (empty if there is none);</p></li>
<li><p><code class="inline">__schema__(:fields)</code> - Returns a list of all non-virtual field names;</p></li>
<li><p><code class="inline">__schema__(:field_source, field)</code> - Returns the alias of the given field;</p></li>
<li><p><code class="inline">__schema__(:type, field)</code> - Returns the type of the given non-virtual field;</p></li>
<li><p><code class="inline">__schema__(:associations)</code> - Returns a list of all association field names;</p></li>
<li><p><code class="inline">__schema__(:association, assoc)</code> - Returns the association reflection of the given assoc;</p></li>
<li><p><code class="inline">__schema__(:embeds)</code> - Returns a list of all embedded field names;</p></li>
<li><p><code class="inline">__schema__(:embed, embed)</code> - Returns the embedding reflection of the given embed;</p></li>
<li><p><code class="inline">__schema__(:read_after_writes)</code> - Non-virtual fields that must be read back from the database after every write (insert or update);</p></li>
<li><p><code class="inline">__schema__(:autogenerate_id)</code> - Primary key that is auto generated on insert;</p></li>
<li><p><code class="inline">__schema__(:redact_fields)</code> - Returns a list of redacted field names;</p></li>
</ul>
<p>Furthermore, both <code class="inline">__struct__</code> and <code class="inline">__changeset__</code> functions are defined so structs and changeset functionalities are available.</p>
<h2 id="module-working-with-typespecs" class="section-heading">  Working with typespecs </h2> <p>Generating typespecs for schemas is out of the scope of <a href="#content"><code class="inline">Ecto.Schema</code></a>.</p>
<p>In order to be able to use types such as <code class="inline">User.t()</code>, <code class="inline">t/0</code> has to be defined manually:</p>
<pre data-language="elixir">defmodule User do
  use Ecto.Schema

  @type t :: %__MODULE__{
    name: String.t(),
    age: non_neg_integer()
  }

  # ... schema ...
end</pre>
<p>Defining the type of each field is not mandatory, but it is preferable.</p> </section> <section id="summary" class="details-list"> <h1 class="section-heading">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#t:belongs_to/1">belongs_to(t)</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:embedded_schema/0">embedded_schema()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:has_many/1">has_many(t)</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:has_one/1">has_one(t)</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:many_to_many/1">many_to_many(t)</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:prefix/0">prefix()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:schema/0">schema()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:source/0">source()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:t/0">t()</a> </dt> </div> </dl> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#belongs_to/3">belongs_to(name, queryable, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Indicates a one-to-one or many-to-one association with another schema.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#embedded_schema/1">embedded_schema(list)</a> </dt> <dd class="summary-synopsis"><p>Defines an embedded schema with the given field definitions.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#embeds_many/3">embeds_many(name, schema, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Indicates an embedding of many schemas.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#embeds_many/4">embeds_many(name, schema, opts, list)</a> </dt> <dd class="summary-synopsis"><p>Indicates an embedding of many schemas.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#embeds_one/3">embeds_one(name, schema, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Indicates an embedding of a schema.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#embeds_one/4">embeds_one(name, schema, opts, list)</a> </dt> <dd class="summary-synopsis"><p>Indicates an embedding of a schema.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#field/3">field(name, type \\ :string, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Defines a field on the schema with given name and type.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#has_many/3">has_many(name, queryable, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Indicates a one-to-many association with another schema.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#has_one/3">has_one(name, queryable, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Indicates a one-to-one association with another schema.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#many_to_many/3">many_to_many(name, queryable, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Indicates a many-to-many association with another schema.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#schema/2">schema(source, list)</a> </dt> <dd class="summary-synopsis"><p>Defines a schema struct with a source name and field definitions.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#timestamps/1">timestamps(opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Generates <code class="inline">:inserted_at</code> and <code class="inline">:updated_at</code> timestamp fields.</p></dd> </div> </dl> </section> <section id="types" class="details-list"> <h1 class="section-heading">  Types </h1> <div class="types-list"> <section class="detail"> <h3 class="detail-header" id="t:belongs_to/1">belongs_to(t)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">belongs_to(t) :: t | Ecto.Association.NotLoaded.t()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:embedded_schema/0">embedded_schema()</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">embedded_schema() :: %{optional(atom()) =&gt; any(), :__struct__ =&gt; atom()}</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:has_many/1">has_many(t)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">has_many(t) :: [t] | Ecto.Association.NotLoaded.t()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:has_one/1">has_one(t)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">has_one(t) :: t | Ecto.Association.NotLoaded.t()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:many_to_many/1">many_to_many(t)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">many_to_many(t) :: [t] | Ecto.Association.NotLoaded.t()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:prefix/0">prefix()</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">prefix() :: String.t() | nil</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:schema/0">schema()</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">schema() :: %{
  optional(atom()) =&gt; any(),
  :__struct__ =&gt; atom(),
  :__meta__ =&gt; Ecto.Schema.Metadata.t()
}</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:source/0">source()</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">source() :: String.t()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:t/0">t()</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">t() :: schema() | embedded_schema()</pre> </div> </section> </section> </div> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  Functions </h1> <div class="functions-list"> <section class="detail">  <h3 class="detail-header" id="belongs_to/3">belongs_to(name, queryable, opts \\ [])</h3> <section class="docstring"> <p>Indicates a one-to-one or many-to-one association with another schema.</p>
<p>The current schema belongs to zero or one records of the other schema. The other schema often has a <code class="inline">has_one</code> or a <code class="inline">has_many</code> field with the reverse association.</p>
<p>You should use <code class="inline">belongs_to</code> in the table that contains the foreign key. Imagine a company &lt;-&gt; employee relationship. If the employee contains the <code class="inline">company_id</code> in the underlying database table, we say the employee belongs to company.</p>
<p>In fact, when you invoke this macro, a field with the name of foreign key is automatically defined in the schema for you.</p>
<h4 id="belongs_to/3-options" class="section-heading">  Options </h4> <ul>
<li><p><code class="inline">:foreign_key</code> - Sets the foreign key field name, defaults to the name of the association suffixed by <code class="inline">_id</code>. For example, <code class="inline">belongs_to :company</code> will define foreign key of <code class="inline">:company_id</code>. The associated <code class="inline">has_one</code> or <code class="inline">has_many</code> field in the other schema should also have its <code class="inline">:foreign_key</code> option set with the same value.</p></li>
<li><p><code class="inline">:references</code> - Sets the key on the other schema to be used for the association, defaults to: <code class="inline">:id</code></p></li>
<li><p><code class="inline">:define_field</code> - When false, does not automatically define a <code class="inline">:foreign_key</code> field, implying the user is defining the field manually elsewhere</p></li>
<li><p><code class="inline">:type</code> - Sets the type of automatically defined <code class="inline">:foreign_key</code>. Defaults to: <code class="inline">:integer</code> and can be set per schema via <code class="inline">@foreign_key_type</code></p></li>
<li><p><code class="inline">:on_replace</code> - The action taken on associations when the record is replaced when casting or manipulating parent changeset. May be <code class="inline">:raise</code> (default), <code class="inline">:mark_as_invalid</code>, <code class="inline">:nilify</code>, <code class="inline">:update</code>, or <code class="inline">:delete</code>. See <a href="ecto.changeset"><code class="inline">Ecto.Changeset</code></a>'s section on related data for more info.</p></li>
<li><p><code class="inline">:defaults</code> - Default values to use when building the association. It may be a keyword list of options that override the association schema or a <code class="inline">{module, function, args}</code> that receive the struct and the owner as arguments. For example, if you set <code class="inline">Post.has_many :comments, defaults: [public: true]</code>, then when using <code class="inline">Ecto.build_assoc(post, :comments)</code> that comment will have <code class="inline">comment.public == true</code>. Alternatively, you can set it to <code class="inline">Post.has_many :comments, defaults: {__MODULE__, :update_comment, []}</code> and <code class="inline">Post.update_comment(comment, post)</code> will be invoked.</p></li>
<li><p><code class="inline">:primary_key</code> - If the underlying belongs_to field is a primary key</p></li>
<li><p><code class="inline">:source</code> - Defines the name that is to be used in database for this field</p></li>
<li><p><code class="inline">:where</code> - A filter for the association. See "Filtering associations" in <a href="#has_many/3"><code class="inline">has_many/3</code></a>.</p></li>
</ul>
<h4 id="belongs_to/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">defmodule Comment do
  use Ecto.Schema

  schema "comments" do
    belongs_to :post, Post
  end
end

# The post can come preloaded on the comment record
[comment] = Repo.all(from(c in Comment, where: c.id == 42, preload: :post))
comment.post #=&gt; %Post{...}</pre>
<p>If you need custom options on the underlying field, you can define the field explicitly and then pass <code class="inline">define_field: false</code> to <code class="inline">belongs_to</code>:</p>
<pre data-language="elixir">defmodule Comment do
  use Ecto.Schema

  schema "comments" do
    field :post_id, :integer, ... # custom options
    belongs_to :post, Post, define_field: false
  end
end</pre>
<h4 id="belongs_to/3-polymorphic-associations" class="section-heading">  Polymorphic associations </h4> <p>One common use case for belongs to associations is to handle polymorphism. For example, imagine you have defined a Comment schema and you wish to use it for commenting on both tasks and posts.</p>
<p>Some abstractions would force you to define some sort of polymorphic association with two fields in your database:</p>
<pre data-language="elixir">* commentable_type
* commentable_id</pre>
<p>The problem with this approach is that it breaks references in the database. You can't use foreign keys and it is very inefficient, both in terms of query time and storage.</p>
<p>In Ecto, we have three ways to solve this issue. The simplest is to define multiple fields in the Comment schema, one for each association:</p>
<pre data-language="elixir">* task_id
* post_id</pre>
<p>Unless you have dozens of columns, this is simpler for the developer, more DB friendly and more efficient in all aspects.</p>
<p>Alternatively, because Ecto does not tie a schema to a given table, we can use separate tables for each association. Let's start over and define a new Comment schema:</p>
<pre data-language="elixir">defmodule Comment do
  use Ecto.Schema

  schema "abstract table: comments" do
    # This will be used by associations on each "concrete" table
    field :assoc_id, :integer
  end
end</pre>
<p>Notice we have changed the table name to "abstract table: comments". You can choose whatever name you want, the point here is that this particular table will never exist.</p>
<p>Now in your Post and Task schemas:</p>
<pre data-language="elixir">defmodule Post do
  use Ecto.Schema

  schema "posts" do
    has_many :comments, {"posts_comments", Comment}, foreign_key: :assoc_id
  end
end

defmodule Task do
  use Ecto.Schema

  schema "tasks" do
    has_many :comments, {"tasks_comments", Comment}, foreign_key: :assoc_id
  end
end</pre>
<p>Now each association uses its own specific table, "posts_comments" and "tasks_comments", which must be created on migrations. The advantage of this approach is that we never store unrelated data together, also ensuring we keep database references fast and correct.</p>
<p>When using this technique, the only limitation is that you cannot build comments directly. For example, the command below</p>
<pre data-language="elixir">Repo.insert!(%Comment{})</pre>
<p>will attempt to use the abstract table. Instead, one should use</p>
<pre data-language="elixir">Repo.insert!(build_assoc(post, :comments))</pre>
<p>leveraging the <a href="ecto#build_assoc/3"><code class="inline">Ecto.build_assoc/3</code></a> function. You can also use <a href="ecto#assoc/2"><code class="inline">Ecto.assoc/2</code></a> or pass a tuple in the query syntax to easily retrieve associated comments to a given post or task:</p>
<pre data-language="elixir"># Fetch all comments associated with the given task
Repo.all(Ecto.assoc(task, :comments))</pre>
<p>Or all comments in a given table:</p>
<pre data-language="elixir">Repo.all from(c in {"posts_comments", Comment}), ...)</pre>
<p>The third and final option is to use <a href="#many_to_many/3"><code class="inline">many_to_many/3</code></a> to define the relationships between the resources. In this case, the comments table won't have the foreign key, instead there is an intermediary table responsible for associating the entries:</p>
<pre data-language="elixir">defmodule Comment do
  use Ecto.Schema
  schema "comments" do
    # ...
  end
end</pre>
<p>In your posts and tasks:</p>
<pre data-language="elixir">defmodule Post do
  use Ecto.Schema

  schema "posts" do
    many_to_many :comments, Comment, join_through: "posts_comments"
  end
end

defmodule Task do
  use Ecto.Schema

  schema "tasks" do
    many_to_many :comments, Comment, join_through: "tasks_comments"
  end
end</pre>
<p>See <a href="#many_to_many/3"><code class="inline">many_to_many/3</code></a> for more information on this particular approach.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="embedded_schema/1">embedded_schema(list)</h3> <section class="docstring"> <p>Defines an embedded schema with the given field definitions.</p>
<p>An embedded schema is either embedded into another schema or kept exclusively in memory. For this reason, an embedded schema does not require a source name and it does not include a metadata field.</p>
<p>Embedded schemas by default set the primary key type to <code class="inline">:binary_id</code> but such can be configured with the <code class="inline">@primary_key</code> attribute.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="embeds_many/3">embeds_many(name, schema, opts \\ [])</h3> <section class="docstring"> <p>Indicates an embedding of many schemas.</p>
<p>The current schema has zero or more records of the other schema embedded inside of it. Embeds have all the things regular schemas have.</p>
<p>It is recommended to declare your <a href="#embeds_many/3"><code class="inline">embeds_many/3</code></a> field with type <code class="inline">:map</code> in your migrations, instead of using <code class="inline">{:array, :map}</code>. Ecto can work with both maps and arrays as the container for embeds (and in most databases map are represented as JSON which allows Ecto to choose what works best).</p>
<p>The embedded may or may not have a primary key. Ecto uses the primary keys to detect if an embed is being updated or not. If a primary is not present and you still want the list of embeds to be updated, <code class="inline">:on_replace</code> must be set to <code class="inline">:delete</code>, forcing all current embeds to be deleted and replaced by new ones whenever a new list of embeds is set.</p>
<p>For encoding and decoding of embeds, please read the docs for <a href="#embeds_one/3"><code class="inline">embeds_one/3</code></a>.</p>
<h4 id="embeds_many/3-options" class="section-heading">  Options </h4> <ul>
<li><p><code class="inline">:on_replace</code> - The action taken on associations when the embed is replaced when casting or manipulating parent changeset. May be <code class="inline">:raise</code> (default), <code class="inline">:mark_as_invalid</code>, or <code class="inline">:delete</code>. See <a href="ecto.changeset"><code class="inline">Ecto.Changeset</code></a>'s section on related data for more info.</p></li>
<li><p><code class="inline">:source</code> - Defines the name that is to be used in database for this field. This is useful when attaching to an existing database. The value should be an atom.</p></li>
</ul>
<h4 id="embeds_many/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">defmodule Order do
  use Ecto.Schema

  schema "orders" do
    embeds_many :items, Item
  end
end

defmodule Item do
  use Ecto.Schema

  embedded_schema do
    field :title
  end
end

# The items are loaded with the order
order = Repo.get!(Order, 42)
order.items #=&gt; [%Item{...}, ...]</pre>
<p>Adding and removal of embeds can only be done via the <a href="ecto.changeset"><code class="inline">Ecto.Changeset</code></a> API so Ecto can properly track the embed life-cycle:</p>
<pre data-language="elixir"># Order has no items
order = Repo.get!(Order, 42)
order.items
# =&gt; []

items  = [%Item{title: "Soap"}]

# Generate a changeset
changeset = Ecto.Changeset.change(order)

# Put a one or more new items
changeset = Ecto.Changeset.put_embed(changeset, :items, items)

# Update the order and fetch items
items = Repo.update!(changeset).items

# Items are generated with a unique identification
items
# =&gt; [%Item{id: "20a97d94-f79b-4e63-a875-85deed7719b7", title: "Soap"}]</pre>
<p>Updating of embeds must be done using a changeset for each changed embed.</p>
<pre data-language="elixir"># Order has an existing items
order = Repo.get!(Order, 42)
order.items
# =&gt; [%Item{id: "20a97d94-f79b-4e63-a875-85deed7719b7", title: "Soap"}]

# Generate a changeset
changeset = Ecto.Changeset.change(order)

# Put the updated item as a changeset
current_item = List.first(order.items)
item_changeset = Ecto.Changeset.change(current_item, title: "Mujju's Soap")
order_changeset = Ecto.Changeset.put_embed(changeset, :items, [item_changeset])

# Update the order and fetch items
items = Repo.update!(order_changeset).items

# Item has the updated title
items
# =&gt; [%Item{id: "20a97d94-f79b-4e63-a875-85deed7719b7", title: "Mujju's Soap"}]</pre>
<h4 id="embeds_many/3-inline-embedded-schema" class="section-heading">  Inline embedded schema </h4> <p>The schema module can be defined inline in the parent schema in simple cases:</p>
<pre data-language="elixir">defmodule Parent do
  use Ecto.Schema

  schema "parents" do
    field :name, :string

    embeds_many :children, Child do
      field :name, :string
      field :age,  :integer
    end
  end
end</pre>
<p>Primary keys are automatically set up for embedded schemas as well, defaulting to <code class="inline">{:id, :binary_id, autogenerate: true}</code>. You can customize it by passing a <code class="inline">:primary_key</code> option with the same arguments as <code class="inline">@primary_key</code> (see the <a href="ecto.schema#module-schema-attributes">Schema attributes</a> section for more info).</p>
<p>Defining embedded schema in such a way will define a <code class="inline">Parent.Child</code> module with the appropriate struct. In order to properly cast the embedded schema. When casting the inline-defined embedded schemas you need to use the <code class="inline">:with</code> option of <code class="inline">cast_embed/3</code> to provide the proper function to do the casting. For example:</p>
<pre data-language="elixir">def changeset(schema, params) do
  schema
  |&gt; cast(params, [:name])
  |&gt; cast_embed(:children, with: &amp;child_changeset/2)
end

defp child_changeset(schema, params) do
  schema
  |&gt; cast(params, [:name, :age])
end</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="embeds_many/4">embeds_many(name, schema, opts, list)</h3> <section class="docstring"> <p>Indicates an embedding of many schemas.</p>
<p>For options and examples see documentation of <a href="#embeds_many/3"><code class="inline">embeds_many/3</code></a>.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="embeds_one/3">embeds_one(name, schema, opts \\ [])</h3> <section class="docstring"> <p>Indicates an embedding of a schema.</p>
<p>The current schema has zero or one records of the other schema embedded inside of it. It uses a field similar to the <code class="inline">:map</code> type for storage, but allows embeds to have all the things regular schema can.</p>
<p>You must declare your <a href="#embeds_one/3"><code class="inline">embeds_one/3</code></a> field with type <code class="inline">:map</code> at the database level.</p>
<p>The embedded may or may not have a primary key. Ecto uses the primary keys to detect if an embed is being updated or not. If a primary key is not present, <code class="inline">:on_replace</code> should be set to either <code class="inline">:update</code> or <code class="inline">:delete</code> if there is a desire to either update or delete the current embed when a new one is set.</p>
<h4 id="embeds_one/3-options" class="section-heading">  Options </h4> <ul>
<li><p><code class="inline">:on_replace</code> - The action taken on associations when the embed is replaced when casting or manipulating parent changeset. May be <code class="inline">:raise</code> (default), <code class="inline">:mark_as_invalid</code>, <code class="inline">:update</code>, or <code class="inline">:delete</code>. See <a href="ecto.changeset"><code class="inline">Ecto.Changeset</code></a>'s section on related data for more info.</p></li>
<li><p><code class="inline">:source</code> - Defines the name that is to be used in database for this field. This is useful when attaching to an existing database. The value should be an atom.</p></li>
</ul>
<h4 id="embeds_one/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">defmodule Order do
  use Ecto.Schema

  schema "orders" do
    embeds_one :item, Item
  end
end

defmodule Item do
  use Ecto.Schema

  embedded_schema do
    field :title
  end
end

# The item is loaded with the order
order = Repo.get!(Order, 42)
order.item #=&gt; %Item{...}</pre>
<p>Adding and removal of embeds can only be done via the <a href="ecto.changeset"><code class="inline">Ecto.Changeset</code></a> API so Ecto can properly track the embed life-cycle:</p>
<pre data-language="elixir">order = Repo.get!(Order, 42)
item  = %Item{title: "Soap"}

# Generate a changeset
changeset = Ecto.Changeset.change(order)

# Put a new embed to the changeset
changeset = Ecto.Changeset.put_embed(changeset, :item, item)

# Update the order, and fetch the item
item = Repo.update!(changeset).item

# Item is generated with a unique identification
item
# =&gt; %Item{id: "20a97d94-f79b-4e63-a875-85deed7719b7", title: "Soap"}</pre>
<h4 id="embeds_one/3-inline-embedded-schema" class="section-heading">  Inline embedded schema </h4> <p>The schema module can be defined inline in the parent schema in simple cases:</p>
<pre data-language="elixir">defmodule Parent do
  use Ecto.Schema

  schema "parents" do
    field :name, :string

    embeds_one :child, Child do
      field :name, :string
      field :age,  :integer
    end
  end
end</pre>
<p>Options should be passed before the <code class="inline">do</code> block like this:</p>
<pre data-language="elixir">embeds_one :child, Child, on_replace: :delete do
  field :name, :string
  field :age,  :integer
end</pre>
<p>Primary keys are automatically set up for embedded schemas as well, defaulting to <code class="inline">{:id, :binary_id, autogenerate: true}</code>. You can customize it by passing a <code class="inline">:primary_key</code> option with the same arguments as <code class="inline">@primary_key</code> (see the <a href="ecto.schema#module-schema-attributes">Schema attributes</a> section for more info).</p>
<p>Defining embedded schema in such a way will define a <code class="inline">Parent.Child</code> module with the appropriate struct. In order to properly cast the embedded schema. When casting the inline-defined embedded schemas you need to use the <code class="inline">:with</code> option of <a href="ecto.changeset#cast_embed/3"><code class="inline">Ecto.Changeset.cast_embed/3</code></a> to provide the proper function to do the casting. For example:</p>
<pre data-language="elixir">def changeset(schema, params) do
  schema
  |&gt; cast(params, [:name])
  |&gt; cast_embed(:child, with: &amp;child_changeset/2)
end

defp child_changeset(schema, params) do
  schema
  |&gt; cast(params, [:name, :age])
end</pre>
<h4 id="embeds_one/3-encoding-and-decoding" class="section-heading">  Encoding and decoding </h4> <p>Because many databases do not support direct encoding and decoding of embeds, it is often emulated by Ecto by using specific encoding and decoding rules.</p>
<p>For example, PostgreSQL will store embeds on top of JSONB columns, which means types in embedded schemas won't go through the usual dump-&gt;DB-&gt;load cycle but rather encode-&gt;DB-&gt;decode-&gt;cast. This means that, when using embedded schemas with databases like PG or MySQL, make sure all of your types can be JSON encoded/decoded correctly. Ecto provides this guarantee for all built-in types.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="embeds_one/4">embeds_one(name, schema, opts, list)</h3> <section class="docstring"> <p>Indicates an embedding of a schema.</p>
<p>For options and examples see documentation of <a href="#embeds_one/3"><code class="inline">embeds_one/3</code></a>.</p> </section> </section> <section class="detail">   <h3 class="detail-header" id="field/3">field(name, type \\ :string, opts \\ [])</h3> <section class="docstring"> <p>Defines a field on the schema with given name and type.</p>
<p>The field name will be used as is to read and write to the database by all of the built-in adapters unless overridden with the <code class="inline">:source</code> option.</p>
<h4 id="field/3-options" class="section-heading">  Options </h4> <ul>
<li><p><code class="inline">:default</code> - Sets the default value on the schema and the struct. The default value is calculated at compilation time, so don't use expressions like <code class="inline">DateTime.utc_now</code> or <code class="inline">Ecto.UUID.generate</code> as they would then be the same for all records.</p></li>
<li><p><code class="inline">:source</code> - Defines the name that is to be used in database for this field. This is useful when attaching to an existing database. The value should be an atom.</p></li>
<li><p><code class="inline">:autogenerate</code> - a <code class="inline">{module, function, args}</code> tuple for a function to call to generate the field value before insertion if value is not set. A shorthand value of <code class="inline">true</code> is equivalent to <code class="inline">{type, :autogenerate, []}</code>.</p></li>
<li>
<p><code class="inline">:read_after_writes</code> - When true, the field is always read back from the database after insert and updates.</p>
<p>For relational databases, this means the RETURNING option of those statements is used. For this reason, MySQL does not support this option and will raise an error if a schema is inserted/updated with read after writes fields.</p>
</li>
<li><p><code class="inline">:virtual</code> - When true, the field is not persisted to the database. Notice virtual fields do not support <code class="inline">:autogenerate</code> nor <code class="inline">:read_after_writes</code>.</p></li>
<li><p><code class="inline">:primary_key</code> - When true, the field is used as part of the composite primary key.</p></li>
<li><p><code class="inline">:load_in_query</code> - When false, the field will not be loaded when selecting the whole struct in a query, such as <code class="inline">from p in Post, select: p</code>. Defaults to <code class="inline">true</code>.</p></li>
<li><p><code class="inline">:redact</code> - When true, it will display a value of <code class="inline">**redacted**</code> when inspected in changes inside a <a href="ecto.changeset"><code class="inline">Ecto.Changeset</code></a> and be excluded from inspect on the schema. Defaults to <code class="inline">false</code>.</p></li>
</ul> </section> </section> <section class="detail">  <h3 class="detail-header" id="has_many/3">has_many(name, queryable, opts \\ [])</h3> <section class="docstring"> <p>Indicates a one-to-many association with another schema.</p>
<p>The current schema has zero or more records of the other schema. The other schema often has a <code class="inline">belongs_to</code> field with the reverse association.</p>
<h4 id="has_many/3-options" class="section-heading">  Options </h4> <ul>
<li><p><code class="inline">:foreign_key</code> - Sets the foreign key, this should map to a field on the other schema, defaults to the underscored name of the current schema suffixed by <code class="inline">_id</code></p></li>
<li><p><code class="inline">:references</code> - Sets the key on the current schema to be used for the association, defaults to the primary key on the schema</p></li>
<li><p><code class="inline">:through</code> - Allow this association to be defined in terms of existing associations. Read the section on <code class="inline">:through</code> associations for more info</p></li>
<li><p><code class="inline">:on_delete</code> - The action taken on associations when parent record is deleted. May be <code class="inline">:nothing</code> (default), <code class="inline">:nilify_all</code> and <code class="inline">:delete_all</code>. Using this option is DISCOURAGED for most relational databases. Instead, in your migration, set <code class="inline">references(:parent_id, on_delete: :delete_all)</code>. Opposite to the migration option, this option cannot guarantee integrity and it is only triggered for <a href="ecto.repo#c:delete/2"><code class="inline">Ecto.Repo.delete/2</code></a> (and not on <a href="ecto.repo#c:delete_all/2"><code class="inline">Ecto.Repo.delete_all/2</code></a>) and it never cascades. If posts has many comments, which has many tags, and you delete a post, only comments will be deleted. If your database does not support references, cascading can be manually implemented by using <a href="ecto.multi"><code class="inline">Ecto.Multi</code></a> or <a href="ecto.changeset#prepare_changes/2"><code class="inline">Ecto.Changeset.prepare_changes/2</code></a>.</p></li>
<li><p><code class="inline">:on_replace</code> - The action taken on associations when the record is replaced when casting or manipulating parent changeset. May be <code class="inline">:raise</code> (default), <code class="inline">:mark_as_invalid</code>, <code class="inline">:nilify</code>, or <code class="inline">:delete</code>. See <a href="ecto.changeset"><code class="inline">Ecto.Changeset</code></a>'s section about ":on_replace" for more info.</p></li>
<li><p><code class="inline">:defaults</code> - Default values to use when building the association. It may be a keyword list of options that override the association schema or a <code class="inline">{module, function, args}</code> that receive the struct and the owner as arguments. For example, if you set <code class="inline">Post.has_many :comments, defaults: [public: true]</code>, then when using <code class="inline">Ecto.build_assoc(post, :comments)</code> that comment will have <code class="inline">comment.public == true</code>. Alternatively, you can set it to <code class="inline">Post.has_many :comments, defaults: {__MODULE__, :update_comment, []}</code> and <code class="inline">Post.update_comment(comment, post)</code> will be invoked.</p></li>
<li><p><code class="inline">:where</code> - A filter for the association. See "Filtering associations" below. It does not apply to <code class="inline">:through</code> associations.</p></li>
</ul>
<h4 id="has_many/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">defmodule Post do
  use Ecto.Schema
  schema "posts" do
    has_many :comments, Comment
  end
end

# Get all comments for a given post
post = Repo.get(Post, 42)
comments = Repo.all assoc(post, :comments)

# The comments can come preloaded on the post struct
[post] = Repo.all(from(p in Post, where: p.id == 42, preload: :comments))
post.comments #=&gt; [%Comment{...}, ...]</pre>
<p><code class="inline">has_many</code> can be used to define hierarchical relationships within a single schema, for example threaded comments.</p>
<pre data-language="elixir">defmodule Comment do
  use Ecto.Schema
  schema "comments" do
    field :content, :string
    field :parent_id, :integer
    belongs_to :parent, Comment, foreign_key: :parent_id, references: :id, define_field: false
    has_many :children, Comment, foreign_key: :parent_id, references: :id
  end
end</pre>
<h4 id="has_many/3-filtering-associations" class="section-heading">  Filtering associations </h4> <p>It is possible to specify a <code class="inline">:where</code> option that will filter the records returned by the association. Querying, joining or preloading the association will use the given conditions as shown next:</p>
<pre data-language="elixir">defmodule Post do
  use Ecto.Schema

  schema "posts" do
    has_many :public_comments, Comment,
      where: [public: true]
  end
end</pre>
<p>The <code class="inline">:where</code> option expects a keyword list where the key is an atom representing the field and the value is either:</p>
<ul>
<li>
<code class="inline">nil</code> - which specifies the field must be nil</li>
<li>
<code class="inline">{:not, nil}</code> - which specifies the field must not be nil</li>
<li>
<code class="inline">{:in, list}</code> - which specifies the field must be one of the values in a list</li>
<li>
<code class="inline">{:fragment, expr}</code> - which specifies a fragment string as the filter (see <a href="ecto.query.api#fragment/1"><code class="inline">Ecto.Query.API.fragment/1</code></a>) with the field's value given to it as the only argument</li>
<li>or any other value which the field is compared directly against</li>
</ul>
<p>Note the values above are distinctly different from the values you would pass to <code class="inline">where</code> when building a query. For example, if you attempt to build a query such as</p>
<pre data-language="elixir">from Post, where: [id: nil]</pre>
<p>it will emit an error. This is because queries can be built dynamically, and therefore passing <code class="inline">nil</code> can lead to security errors. However, the <code class="inline">:where</code> values for an association are given at compile-time, which is less dynamic and cannot leverage the full power of Ecto queries, which explains why they have different APIs.</p>
<p><strong>Important!</strong> Please use this feature only when strictly necessary, otherwise it is very easy to end-up with large schemas with dozens of different associations polluting your schema and affecting your application performance. For instance, if you are using associations only for different querying purposes, then it is preferable to build and compose queries, rather than defining multiple associations:</p>
<pre data-language="elixir">posts
|&gt; Ecto.assoc(:comments)
|&gt; Comment.deleted()</pre>
<p>Or when preloading:</p>
<pre data-language="elixir">from posts, preload: [comments: ^Comment.deleted()]</pre>
<h4 id="has_many/3-has_many-has_one-through" class="section-heading">  has_many/has_one :through </h4> <p>Ecto also supports defining associations in terms of other associations via the <code class="inline">:through</code> option. Let's see an example:</p>
<pre data-language="elixir">defmodule Post do
  use Ecto.Schema

  schema "posts" do
    has_many :comments, Comment
    has_one :permalink, Permalink

    # In the has_many :through example below, the `:comments`
    # in the list [:comments, :author] refers to the
    # `has_many :comments` in the Post own schema and the
    # `:author` refers to the `belongs_to :author` of the
    # Comment's schema (the module below).
    # (see the description below for more details)
    has_many :comments_authors, through: [:comments, :author]

    # Specify the association with custom source
    has_many :tags, {"posts_tags", Tag}
  end
end

defmodule Comment do
  use Ecto.Schema

  schema "comments" do
    belongs_to :author, Author
    belongs_to :post, Post
    has_one :post_permalink, through: [:post, :permalink]
  end
end</pre>
<p>In the example above, we have defined a <code class="inline">has_many :through</code> association named <code class="inline">:comments_authors</code>. A <code class="inline">:through</code> association always expects a list and the first element of the list must be a previously defined association in the current module. For example, <code class="inline">:comments_authors</code> first points to <code class="inline">:comments</code> in the same module (Post), which then points to <code class="inline">:author</code> in the next schema, <code class="inline">Comment</code>.</p>
<p>This <code class="inline">:through</code> association will return all authors for all comments that belongs to that post:</p>
<pre data-language="elixir"># Get all comments authors for a given post
post = Repo.get(Post, 42)
authors = Repo.all assoc(post, :comments_authors)</pre>
<p><code class="inline">:through</code> associations can also be preloaded. In such cases, not only the <code class="inline">:through</code> association is preloaded but all intermediate steps are preloaded too:</p>
<pre data-language="elixir">[post] = Repo.all(from(p in Post, where: p.id == 42, preload: :comments_authors))
post.comments_authors #=&gt; [%Author{...}, ...]

# The comments for each post will be preloaded too
post.comments #=&gt; [%Comment{...}, ...]

# And the author for each comment too
hd(post.comments).author #=&gt; %Author{...}</pre>
<p>When the <code class="inline">:through</code> association is expected to return one or zero items, <code class="inline">has_one :through</code> should be used instead, as in the example at the beginning of this section:</p>
<pre data-language="elixir"># How we defined the association above
has_one :post_permalink, through: [:post, :permalink]

# Get a preloaded comment
[comment] = Repo.all(Comment) |&gt; Repo.preload(:post_permalink)
comment.post_permalink #=&gt; %Permalink{...}</pre>
<p>Note <code class="inline">:through</code> associations are read-only. For example, you cannot use <a href="ecto.changeset#cast_assoc/3"><code class="inline">Ecto.Changeset.cast_assoc/3</code></a> to modify through associations.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="has_one/3">has_one(name, queryable, opts \\ [])</h3> <section class="docstring"> <p>Indicates a one-to-one association with another schema.</p>
<p>The current schema has zero or one records of the other schema. The other schema often has a <code class="inline">belongs_to</code> field with the reverse association.</p>
<h4 id="has_one/3-options" class="section-heading">  Options </h4> <ul>
<li><p><code class="inline">:foreign_key</code> - Sets the foreign key, this should map to a field on the other schema, defaults to the underscored name of the current module suffixed by <code class="inline">_id</code></p></li>
<li><p><code class="inline">:references</code> - Sets the key on the current schema to be used for the association, defaults to the primary key on the schema</p></li>
<li><p><code class="inline">:through</code> - If this association must be defined in terms of existing associations. Read the section in <a href="#has_many/3"><code class="inline">has_many/3</code></a> for more information</p></li>
<li><p><code class="inline">:on_delete</code> - The action taken on associations when parent record is deleted. May be <code class="inline">:nothing</code> (default), <code class="inline">:nilify_all</code> and <code class="inline">:delete_all</code>. Using this option is DISCOURAGED for most relational databases. Instead, in your migration, set <code class="inline">references(:parent_id, on_delete: :delete_all)</code>. Opposite to the migration option, this option cannot guarantee integrity and it is only triggered for <a href="ecto.repo#c:delete/2"><code class="inline">Ecto.Repo.delete/2</code></a> (and not on <a href="ecto.repo#c:delete_all/2"><code class="inline">Ecto.Repo.delete_all/2</code></a>) and it never cascades. If posts has many comments, which has many tags, and you delete a post, only comments will be deleted. If your database does not support references, cascading can be manually implemented by using <a href="ecto.multi"><code class="inline">Ecto.Multi</code></a> or <a href="ecto.changeset#prepare_changes/2"><code class="inline">Ecto.Changeset.prepare_changes/2</code></a></p></li>
<li><p><code class="inline">:on_replace</code> - The action taken on associations when the record is replaced when casting or manipulating parent changeset. May be <code class="inline">:raise</code> (default), <code class="inline">:mark_as_invalid</code>, <code class="inline">:nilify</code>, <code class="inline">:update</code>, or <code class="inline">:delete</code>. See <a href="ecto.changeset"><code class="inline">Ecto.Changeset</code></a>'s section on related data for more info.</p></li>
<li><p><code class="inline">:defaults</code> - Default values to use when building the association. It may be a keyword list of options that override the association schema or a <code class="inline">{module, function, args}</code> that receive the struct and the owner as arguments. For example, if you set <code class="inline">Post.has_many :comments, defaults: [public: true]</code>, then when using <code class="inline">Ecto.build_assoc(post, :comments)</code> that comment will have <code class="inline">comment.public == true</code>. Alternatively, you can set it to <code class="inline">Post.has_many :comments, defaults: {__MODULE__, :update_comment, []}</code> and <code class="inline">Post.update_comment(comment, post)</code> will be invoked.</p></li>
<li><p><code class="inline">:where</code> - A filter for the association. See "Filtering associations" in <a href="#has_many/3"><code class="inline">has_many/3</code></a>. It does not apply to <code class="inline">:through</code> associations.</p></li>
</ul>
<h4 id="has_one/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">defmodule Post do
  use Ecto.Schema

  schema "posts" do
    has_one :permalink, Permalink

    # Specify the association with custom source
    has_one :category, {"posts_categories", Category}
  end
end

# The permalink can come preloaded on the post struct
[post] = Repo.all(from(p in Post, where: p.id == 42, preload: :permalink))
post.permalink #=&gt; %Permalink{...}</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="many_to_many/3">many_to_many(name, queryable, opts \\ [])</h3> <section class="docstring"> <p>Indicates a many-to-many association with another schema.</p>
<p>The association happens through a join schema or source, containing foreign keys to the associated schemas. For example, the association below:</p>
<pre data-language="elixir"># from MyApp.Post
many_to_many :tags, MyApp.Tag, join_through: "posts_tags"</pre>
<p>is backed by relational databases through a join table as follows:</p>
<pre data-language="elixir">[Post] &lt;-&gt; [posts_tags] &lt;-&gt; [Tag]
  id   &lt;--   post_id
              tag_id    --&gt;  id</pre>
<p>More information on the migration for creating such a schema is shown below.</p>
<h4 id="many_to_many/3-options" class="section-heading">  Options </h4> <ul>
<li><p><code class="inline">:join_through</code> - Specifies the source of the associated data. It may be a string, like "posts_tags", representing the underlying storage table or an atom, like <code class="inline">MyApp.PostTag</code>, representing a schema. This option is required.</p></li>
<li><p><code class="inline">:join_keys</code> - Specifies how the schemas are associated. It expects a keyword list with two entries, the first being how the join table should reach the current schema and the second how the join table should reach the associated schema. In the example above, it defaults to: <code class="inline">[post_id: :id, tag_id: :id]</code>. The keys are inflected from the schema names.</p></li>
<li><p><code class="inline">:on_delete</code> - The action taken on associations when the parent record is deleted. May be <code class="inline">:nothing</code> (default) or <code class="inline">:delete_all</code>. Using this option is DISCOURAGED for most relational databases. Instead, in your migration, set <code class="inline">references(:parent_id, on_delete: :delete_all)</code>. Opposite to the migration option, this option cannot guarantee integrity and it is only triggered for <a href="ecto.repo#c:delete/2"><code class="inline">Ecto.Repo.delete/2</code></a> (and not on <a href="ecto.repo#c:delete_all/2"><code class="inline">Ecto.Repo.delete_all/2</code></a>). This option can only remove data from the join source, never the associated records, and it never cascades.</p></li>
<li><p><code class="inline">:on_replace</code> - The action taken on associations when the record is replaced when casting or manipulating parent changeset. May be <code class="inline">:raise</code> (default), <code class="inline">:mark_as_invalid</code>, or <code class="inline">:delete</code>. <code class="inline">:delete</code> will only remove data from the join source, never the associated records. See <a href="ecto.changeset"><code class="inline">Ecto.Changeset</code></a>'s section on related data for more info.</p></li>
<li><p><code class="inline">:defaults</code> - Default values to use when building the association. It may be a keyword list of options that override the association schema or a <code class="inline">{module, function, args}</code> that receive the struct and the owner as arguments. For example, if you set <code class="inline">Post.has_many :comments, defaults: [public: true]</code>, then when using <code class="inline">Ecto.build_assoc(post, :comments)</code> that comment will have <code class="inline">comment.public == true</code>. Alternatively, you can set it to <code class="inline">Post.has_many :comments, defaults: {__MODULE__, :update_comment, []}</code> and <code class="inline">Post.update_comment(comment, post)</code> will be invoked.</p></li>
<li><p><code class="inline">:join_defaults</code> - The same as <code class="inline">:defaults</code> but it applies to the join schema instead. This option will raise if it is given and the <code class="inline">:join_through</code> value is not a schema.</p></li>
<li><p><code class="inline">:unique</code> - When true, checks if the associated entries are unique whenever the association is cast or changed via the parent record. For instance, it would verify that a given tag cannot be attached to the same post more than once. This exists mostly as a quick check for user feedback, as it does not guarantee uniqueness at the database level. Therefore, you should also set a unique index in the database join table, such as: <code class="inline">create unique_index(:posts_tags, [:post_id, :tag_id])</code></p></li>
<li><p><code class="inline">:where</code> - A filter for the association. See "Filtering associations" in <a href="#has_many/3"><code class="inline">has_many/3</code></a></p></li>
<li><p><code class="inline">:join_where</code> - A filter for the join table. See "Filtering associations" in <a href="#has_many/3"><code class="inline">has_many/3</code></a></p></li>
</ul>
<h4 id="many_to_many/3-removing-data" class="section-heading">  Removing data </h4> <p>If you attempt to remove associated <code class="inline">many_to_many</code> data, <strong>Ecto will always remove data from the join schema and never from the target associations</strong> be it by setting <code class="inline">:on_replace</code> to <code class="inline">:delete</code>, <code class="inline">:on_delete</code> to <code class="inline">:delete_all</code> or by using changeset functions such as <a href="ecto.changeset#put_assoc/3"><code class="inline">Ecto.Changeset.put_assoc/3</code></a>. For example, if a <code class="inline">Post</code> has a many to many relationship with <code class="inline">Tag</code>, setting <code class="inline">:on_delete</code> to <code class="inline">:delete_all</code> will only delete entries from the "posts_tags" table in case <code class="inline">Post</code> is deleted.</p>
<h4 id="many_to_many/3-migration" class="section-heading">  Migration </h4> <p>How your migration should be structured depends on the value you pass in <code class="inline">:join_through</code>. If <code class="inline">:join_through</code> is simply a string, representing a table, you may define a table without primary keys and you must not include any further columns, as those values won't be set by Ecto:</p>
<pre data-language="elixir">create table(:posts_tags, primary_key: false) do
  add :post_id, references(:posts)
  add :tag_id, references(:tags)
end</pre>
<p>However, if your <code class="inline">:join_through</code> is a schema, like <code class="inline">MyApp.PostTag</code>, your join table may be structured as any other table in your codebase, including timestamps:</p>
<pre data-language="elixir">create table(:posts_tags) do
  add :post_id, references(:posts)
  add :tag_id, references(:tags)
  timestamps()
end</pre>
<p>Because <code class="inline">:join_through</code> contains a schema, in such cases, autogenerated values and primary keys will be automatically handled by Ecto.</p>
<h4 id="many_to_many/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">defmodule Post do
  use Ecto.Schema
  schema "posts" do
    many_to_many :tags, Tag, join_through: "posts_tags"
  end
end

# Let's create a post and a tag
post = Repo.insert!(%Post{})
tag = Repo.insert!(%Tag{name: "introduction"})

# We can associate at any time post and tags together using changesets
post
|&gt; Repo.preload(:tags) # Load existing data
|&gt; Ecto.Changeset.change() # Build the changeset
|&gt; Ecto.Changeset.put_assoc(:tags, [tag]) # Set the association
|&gt; Repo.update!

# In a later moment, we may get all tags for a given post
post = Repo.get(Post, 42)
tags = Repo.all(assoc(post, :tags))

# The tags may also be preloaded on the post struct for reading
[post] = Repo.all(from(p in Post, where: p.id == 42, preload: :tags))
post.tags #=&gt; [%Tag{...}, ...]</pre>
<h4 id="many_to_many/3-join-schema-example" class="section-heading">  Join Schema Example </h4> <p>You may prefer to use a join schema to handle many_to_many associations. The decoupled nature of Ecto allows us to create a "join" struct which <code class="inline">belongs_to</code> both sides of the many to many association.</p>
<p>In our example, a <code class="inline">User</code> has and belongs to many <code class="inline">Organization</code>s:</p>
<pre data-language="elixir">defmodule MyApp.Repo.Migrations.CreateUserOrganization do
  use Ecto.Migration

  def change do
    create table(:users_organizations) do
      add :user_id, references(:users)
      add :organization_id, references(:organizations)

      timestamps()
    end
  end
end

defmodule UserOrganization do
  use Ecto.Schema

  @primary_key false
  schema "users_organizations" do
    belongs_to :user, User
    belongs_to :organization, Organization
    timestamps() # Added bonus, a join schema will also allow you to set timestamps
  end

  def changeset(struct, params \\ %{}) do
    struct
    |&gt; Ecto.Changeset.cast(params, [:user_id, :organization_id])
    |&gt; Ecto.Changeset.validate_required([:user_id, :organization_id])
    # Maybe do some counter caching here!
  end
end

defmodule User do
  use Ecto.Schema

  schema "users" do
    many_to_many :organizations, Organization, join_through: UserOrganization
  end
end

defmodule Organization do
  use Ecto.Schema

  schema "organizations" do
    many_to_many :users, User, join_through: UserOrganization
  end
end

# Then to create the association, pass in the ID's of an existing
# User and Organization to UserOrganization.changeset
changeset = UserOrganization.changeset(%UserOrganization{}, %{user_id: id, organization_id: id})

case Repo.insert(changeset) do
  {:ok, assoc} -&gt; # Assoc was created!
  {:error, changeset} -&gt; # Handle the error
end</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="schema/2">schema(source, list)</h3> <section class="docstring"> <p>Defines a schema struct with a source name and field definitions.</p>
<p>An additional field called <code class="inline">__meta__</code> is added to the struct for storing internal Ecto state. This field always has a <a href="ecto.schema.metadata"><code class="inline">Ecto.Schema.Metadata</code></a> struct as value and can be manipulated with the <a href="ecto#put_meta/2"><code class="inline">Ecto.put_meta/2</code></a> function.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="timestamps/1">timestamps(opts \\ [])</h3> <section class="docstring"> <p>Generates <code class="inline">:inserted_at</code> and <code class="inline">:updated_at</code> timestamp fields.</p>
<p>The fields generated by this macro will automatically be set to the current time when inserting and updating values in a repository.</p>
<h4 id="timestamps/1-options" class="section-heading">  Options </h4> <ul>
<li>
<code class="inline">:inserted_at</code> - the Ecto schema name of the field for insertion times or <code class="inline">false</code>
</li>
<li>
<code class="inline">:updated_at</code> - the Ecto schema name of the field for update times or <code class="inline">false</code>
</li>
<li>
<code class="inline">:inserted_at_source</code> - the name of the database column for insertion times or <code class="inline">false</code>
</li>
<li>
<code class="inline">:updated_at_source</code> - the name of the database column for update times or <code class="inline">false</code>
</li>
<li>
<code class="inline">:type</code> - the timestamps type, defaults to <code class="inline">:naive_datetime</code>.</li>
<li>
<code class="inline">:autogenerate</code> - a module-function-args tuple used for generating both <code class="inline">inserted_at</code> and <code class="inline">updated_at</code> timestamps</li>
</ul>
<p>All options can be pre-configured by setting <code class="inline">@timestamps_opts</code>.</p> </section> </section> </div> </section><div class="_attribution">
  <p class="_attribution-p">
     2013 Plataformatec<br> 2020 Dashbit<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/ecto/Ecto.Schema.html" class="_attribution-link">https://hexdocs.pm/ecto/Ecto.Schema.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
