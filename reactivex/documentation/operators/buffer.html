
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Buffer - ReactiveX - W3cubDocs</title>
  
  <meta name="description" content="The Buffer operator transforms an Observable that emits items into an Observable that emits buffered collections of those items. There are a number &hellip;">
  <meta name="keywords" content="buffer, reactivex">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/reactivex/documentation/operators/buffer.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/reactivex.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/reactivex/" class="_nav-link" title="" style="margin-left:0;">ReactiveX</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _reactivex">
				
				
<h1>Buffer</h1> <blockquote>periodically gather items emitted by an Observable into bundles and emit these bundles rather than emitting the items one at a time</blockquote> <figure> <img src="http://reactivex.io/documentation/operators/images/Buffer.png" style="width:100%;" alt="Buffer"> <figcaption><p> The <span class="operator">Buffer</span> operator transforms an Observable that emits items into an Observable that emits buffered collections of those items. There are a number of variants in the various language-specific implementations of <span class="operator">Buffer</span> that differ in how they choose which items go in which buffers. </p>
<p> Note that if the source Observable issues an <code>onError</code> notification, <span class="operator">Buffer</span> will pass on this notification immediately without first emitting the buffer it is in the process of assembling, even if that buffer contains items that were emitted by the source Observable before it issued the error notification. </p></figcaption> </figure> <p> The <a href="window"><span class="operator">Window</span></a> operator is similar to <span class="operator">Buffer</span> but collects items into separate Observables rather than into data structures before reemitting them. </p> <h4>See Also</h4> <ul> <li><a href="window"><span class="operator">Window</span></a></li> <li><a href="http://www.introtorx.com/Content/v1.0.10621.0/13_TimeShiftedSequences.html#Buffer"><cite>Introduction to Rx</cite>: Buffer</a></li> <li><a href="http://www.introtorx.com/Content/v1.0.10621.0/17_SequencesOfCoincidence.html#BufferRevisted"><cite>Introduction to Rx</cite>: Buffer revisited</a></li> <li><a href="http://rxwiki.wikidot.com/101samples#toc26"><cite>101 Rx Samples</cite>: Buffer — Simple</a></li> </ul> <h2>Language-Specific Information</h2> <div id="accordion" role="tablist" aria-multiselectable="true"> <div> <div role="tab" id="headingRxCpp"> <h3 class="panel-title">  RxCpp <code>buffer pairwise</code>  </h3> </div> <div id="collapseRxCpp" role="tabpanel" aria-labelledby="headingRxCpp"> <div> <p> RxCpp implements two variants of <span class="operator">Buffer</span>: </p> <h4><code>buffer(count)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/buffer3.png" style="width:100%;" alt="buffer(count)"> <figcaption> <p><code>buffer(count)</code> emits non-overlapping buffers in the form of <code>vector</code>s, each of which contains at most <code>count</code> items from the source Observable (the final emitted <code>vector</code> may have fewer than <code>count</code> items).</p> </figcaption> </figure> <h4><code>buffer(count, skip)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/buffer4.png" style="width:100%;" alt="buffer(count,skip)"> <figcaption> <p><code>buffer(count, skip)</code> creates a new buffer starting with the first emitted item from the source Observable, and every <code>skip</code> items thereafter, and fills each buffer with <code>count</code> items: the initial item and <code>count-1</code> subsequent ones. It emits these buffers as <code>vector</code>s. Depending on the values of <code>count</code> and <code>skip</code> these buffers may overlap (multiple buffers may contain the same item), or they may have gaps (where items emitted by the source Observable are not represented in any buffer).</p> </figcaption> </figure> </div> </div> </div> <div> <div role="tab" id="headingRxGroovy"> <h3 class="panel-title">  RxGroovy <code>buffer</code>  </h3> </div> <div id="collapseRxGroovy" role="tabpanel" aria-labelledby="headingRxGroovy"> <div> <p> In RxGroovy there are several variants of <span class="operator">Buffer</span>: </p> <h4><code>buffer(count)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/buffer3.png" style="width:100%;" alt="buffer(count)"> <figcaption> <p><code>buffer(count)</code> emits non-overlapping buffers in the form of <code>List</code>s, each of which contains at most <code>count</code> items from the source Observable (the final emitted <code>List</code> may have fewer than <code>count</code> items).</p> <ul> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(int)"><code>buffer(int)</code></a>
</li> </ul></figcaption> </figure> <h4><code>buffer(count, skip)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/buffer4.png" style="width:100%;" alt="buffer(count,skip)"> <figcaption> <p><code>buffer(count, skip)</code> creates a new buffer starting with the first emitted item from the source Observable, and every <code>skip</code> items thereafter, and fills each buffer with <code>count</code> items: the initial item and <code>count-1</code> subsequent ones. It emits these buffers as <code>List</code>s. Depending on the values of <code>count</code> and <code>skip</code> these buffers may overlap (multiple buffers may contain the same item), or they may have gaps (where items emitted by the source Observable are not represented in any buffer).</p> <ul> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(int,%20int)"><code>buffer(int,int)</code></a>
</li> </ul></figcaption> </figure> <h4><code>buffer(bufferClosingSelector)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/buffer1.png" style="width:100%;" alt="buffer(bufferClosingSelector)"> <figcaption> <p>When it subscribes to the source Observable, <code>buffer(bufferClosingSelector)</code> begins to collect its emissions into a <code>List</code>, and it also calls <code>bufferClosingSelector</code> to generate a second Observable. When this second Observable emits an <code>TClosing</code> object, <code>buffer</code> emits the current <code>List</code> and repeats this process: beginning a new <code>List</code> and calling <code>bufferClosingSelector</code> to create a new Observable to monitor. It will do this until the source Observable terminates.</p> <ul> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.functions.Func0)"><code>buffer(Func0)</code></a>
</li> </ul></figcaption> </figure> <h4>
<code>buffer(boundary</code>[<code>, initialCapacity</code>]<code>)</code>
</h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/buffer8.png" style="width:100%;" alt="buffer(boundary)"> <figcaption> <p><code>buffer(boundary)</code> monitors an Observable, <code>boundary</code>. Each time that Observable emits an item, it creates a new <code>List</code> to begin collecting items emitted by the source Observable and emits the previous <code>List</code>.</p> <ul> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.Observable)"><code>buffer(Observable)</code></a>
</li> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.Observable,%20int)"><code>buffer(Observable,int)</code></a>
</li> </ul></figcaption> </figure> <h4><code>buffer(bufferOpenings, bufferClosingSelector)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/buffer2.png" style="width:100%;" alt="buffer(bufferOpenings,bufferClosingSelector)"> <figcaption> <p><code>buffer(bufferOpenings, bufferClosingSelector)</code> monitors an Observable, <code>bufferOpenings</code>, that emits <code>BufferOpening</code> objects. Each time it observes such an emitted item, it creates a new <code>List</code> to begin collecting items emitted by the source Observable and it passes the <code>bufferOpenings</code> Observable into the <code>closingSelector</code> function. That function returns an Observable. <code>buffer</code> monitors that Observable and when it detects an emitted item from it, it closes the <code>List</code> and emits it as its own emission.</p> <ul> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.Observable,%20rx.functions.Func1)"><code>buffer(Observable,Func1)</code></a>
</li> </ul></figcaption> </figure> <h4>
<code>buffer(timespan, unit</code>[<code>, scheduler</code>]<code>)</code>
</h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/buffer5.png" style="width:100%;" alt="buffer(timespan,unit)"> <figcaption> <p><code>buffer(timespan, unit)</code> emits a new <code>List</code> of items periodically, every <code>timespan</code> amount of time, containing all items emitted by the source Observable since the previous bundle emission or, in the case of the first bundle, since the subscription to the source Observable. There is also a version of this variant of the operator that takes a <a href="../scheduler"><code>Scheduler</code></a> as a parameter and uses it to govern the timespan; by default this variant uses the <code>computation</code> Scheduler.</p> <ul> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit)"><code>buffer(long,TimeUnit)</code></a>
</li> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)"><code>buffer(long,TimeUnit,Scheduler)</code></a>
</li> </ul></figcaption> </figure> <h4>
<code>buffer(timespan, unit, count</code>[<code>, scheduler</code>]<code>)</code>
</h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/buffer6.png" style="width:100%;" alt="buffer(timespan,unit,count)"> <figcaption> <p><code>buffer(timespan, unit, count)</code> emits a new <code>List</code> of items for every <code>count</code> items emitted by the source Observable, or, if <code>timespan</code> has elapsed since its last bundle emission, it emits a bundle of however many items the source Observable has emitted in that span, even if this is fewer than <code>count</code>. There is also a version of this variant of the operator that takes a <a href="../scheduler"><code>Scheduler</code></a> as a parameter and uses it to govern the timespan; by default this variant uses the <code>computation</code> scheduler.</p> <ul> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit,%20int)"><code>buffer(long,TimeUnit,int)</code></a>
</li> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit,%20int,%20rx.Scheduler)"><code>buffer(long,TimeUnit,int,Scheduler)</code></a>
</li> </ul></figcaption> </figure> <h4>
<code>buffer(timespan, timeshift, unit</code>[<code>, scheduler</code>]<code>)</code>
</h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/buffer7.png" style="width:100%;" alt="buffer(timespan,timeshift,unit)"> <figcaption> <p><code>buffer(timespan, timeshift, unit)</code> creates a new <code>List</code> of items every <code>timeshift</code> period of time, and fills this bundle with every item emitted by the source Observable from that time until <code>timespan</code> time has passed since the bundle’s creation, before emitting this <code>List</code> as its own emission. If <code>timespan</code> is longer than <code>timeshift</code>, the emitted bundles will represent time periods that overlap and so they may contain duplicate items. There is also a version of this variant of the operator that takes a <a href="../scheduler"><code>Scheduler</code></a> as a parameter and uses it to govern the timespan; by default this variant uses the <code>computation</code> scheduler.</p> <ul> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20long,%20java.util.concurrent.TimeUnit)"><code>buffer(long,long,TimeUnit)</code></a>
</li> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)"><code>buffer(long,long,TimeUnit,Scheduler)</code></a>
</li> </ul></figcaption> </figure> <p> You can use the <span class="operator">Buffer</span> operator to implement backpressure (that is, to cope with an Observable that may produce items too quickly for its observer to consume). </p> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/bp.buffer2.png" style="width:100%;" alt="Buffer as a backpressure strategy"> <figcaption><p> Buffer can reduce a sequence of many items to a sequence of fewer buffers-of-items, making them more manageable. You could, for example, close and emit a buffer of items from a bursty Observable periodically, at a regular interval of time. </p> <h4>Sample Code</h4> <pre data-language="groovy">Observable&lt;List&lt;Integer&gt;&gt; burstyBuffered = bursty.buffer(500, TimeUnit.MILLISECONDS);</pre> </figcaption> </figure> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/bp.buffer1.png" style="width:100%;" alt="Buffer as a backpressure strategy"> <figcaption><p> Or you could get fancy, and collect items in buffers during the bursty periods and emit them at the end of each burst, by using the <a href="debounce"><span class="operator">Debounce</span></a> operator to emit a buffer closing indicator to the buffer operator. </p> <h4>Sample Code</h4> <pre data-language="groovy">// we have to multicast the original bursty Observable so we can use it
// both as our source and as the source for our buffer closing selector:
Observable&lt;Integer&gt; burstyMulticast = bursty.publish().refCount();
// burstyDebounced will be our buffer closing selector:
Observable&lt;Integer&gt; burstyDebounced = burstyMulticast.debounce(10, TimeUnit.MILLISECONDS);
// and this, finally, is the Observable of buffers we're interested in:
Observable&lt;List&lt;Integer&gt;&gt; burstyBuffered = burstyMulticast.buffer(burstyDebounced);</pre> </figcaption> </figure> </div> </div> </div> <div> <div role="tab" id="headingRxJava 1․x"> <h3 class="panel-title">  RxJava 1․x <code>buffer</code>  </h3> </div> <div id="collapseRxJava 1․x" role="tabpanel" aria-labelledby="headingRxJava 1․x"> <div> <p> In RxJava there are several variants of <span class="operator">Buffer</span>: </p> <h4><code>buffer(count)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/buffer3.png" style="width:100%;" alt="buffer(count)"> <figcaption> <p><code>buffer(count)</code> emits non-overlapping buffers in the form of <code>List</code>s, each of which contains at most <code>count</code> items from the source Observable (the final emitted <code>List</code> may have fewer than <code>count</code> items).</p> <ul> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(int)"><code>buffer(int)</code></a>
</li> </ul></figcaption> </figure> <h4><code>buffer(count, skip)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/buffer4.png" style="width:100%;" alt="buffer(count,skip)"> <figcaption> <p><code>buffer(count, skip)</code> creates a new buffer starting with the first emitted item from the source Observable, and every <code>skip</code> items thereafter, and fills each buffer with <code>count</code> items: the initial item and <code>count-1</code> subsequent ones. It emits these buffers as <code>List</code>s. Depending on the values of <code>count</code> and <code>skip</code> these buffers may overlap (multiple buffers may contain the same item), or they may have gaps (where items emitted by the source Observable are not represented in any buffer).</p> <ul> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(int,%20int)"><code>buffer(int,int)</code></a>
</li> </ul></figcaption> </figure> <h4><code>buffer(bufferClosingSelector)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/buffer1.png" style="width:100%;" alt="buffer(bufferClosingSelector)"> <figcaption> <p>When it subscribes to the source Observable, <code>buffer(bufferClosingSelector)</code> begins to collect its emissions into a <code>List</code>, and it also calls <code>bufferClosingSelector</code> to generate a second Observable. When this second Observable emits an <code>TClosing</code> object, <code>buffer</code> emits the current <code>List</code> and repeats this process: beginning a new <code>List</code> and calling <code>bufferClosingSelector</code> to create a new Observable to monitor. It will do this until the source Observable terminates.</p> <ul> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.functions.Func0)"><code>buffer(Func0)</code></a>
</li> </ul></figcaption> </figure> <h4><code>buffer(boundary)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/buffer8.png" style="width:100%;" alt="buffer(boundary)"> <figcaption> <p><code>buffer(boundary)</code> monitors an Observable, <code>boundary</code>. Each time that Observable emits an item, it creates a new <code>List</code> to begin collecting items emitted by the source Observable and emits the previous <code>List</code>.</p> <ul> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.Observable)"><code>buffer(Observable)</code></a>
</li> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.Observable,%20int)"><code>buffer(Observable,int)</code></a>
</li> </ul></figcaption> </figure> <h4><code>buffer(bufferOpenings, bufferClosingSelector)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/buffer2.png" style="width:100%;" alt="buffer(bufferOpenings,bufferClosingSelector)"> <figcaption> <p><code>buffer(bufferOpenings, bufferClosingSelector)</code> monitors an Observable, <code>bufferOpenings</code>, that emits <code>BufferOpening</code> objects. Each time it observes such an emitted item, it creates a new <code>List</code> to begin collecting items emitted by the source Observable and it passes the <code>bufferOpenings</code> Observable into the <code>closingSelector</code> function. That function returns an Observable. <code>buffer</code> monitors that Observable and when it detects an emitted item from it, it closes the <code>List</code> and emits it as its own emission.</p> <ul> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.Observable,%20rx.functions.Func1)"><code>buffer(Observable,Func1)</code></a>
</li> </ul></figcaption> </figure> <h4>
<code>buffer(timespan, unit</code>[<code>, scheduler</code>]<code>)</code>
</h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/buffer5.png" style="width:100%;" alt="buffer(timespan,unit)"> <figcaption> <p><code>buffer(timespan, unit)</code> emits a new <code>List</code> of items periodically, every <code>timespan</code> amount of time, containing all items emitted by the source Observable since the previous bundle emission or, in the case of the first bundle, since the subscription to the source Observable. There is also a version of this variant of the operator that takes a <a href="../scheduler"><code>Scheduler</code></a> as a parameter and uses it to govern the timespan; by default this variant uses the <code>computation</code> scheduler.</p> <ul> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit)"><code>buffer(long,TimeUnit)</code></a>
</li> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)"><code>buffer(long,TimeUnit,Scheduler)</code></a>
</li> </ul></figcaption> </figure> <h4>
<code>buffer(timespan, unit, count</code>[<code>, scheduler</code>]<code>)</code>
</h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/buffer6.png" style="width:100%;" alt="buffer(timespan,unit,count)"> <figcaption> <p><code>buffer(timespan, unit, count)</code> emits a new <code>List</code> of items for every <code>count</code> items emitted by the source Observable, or, if <code>timespan</code> has elapsed since its last bundle emission, it emits a bundle of however many items the source Observable has emitted in that span, even if this is fewer than <code>count</code>. There is also a version of this variant of the operator that takes a <a href="../scheduler"><code>Scheduler</code></a> as a parameter and uses it to govern the timespan; by default this variant uses the <code>computation</code> scheduler.</p> <ul> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit,%20int)"><code>buffer(long,TimeUnit,int)</code></a>
</li> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit,%20int,%20rx.Scheduler)"><code>buffer(long,TimeUnit,int,Scheduler)</code></a>
</li> </ul></figcaption> </figure> <h4>
<code>buffer(timespan, timeshift, unit</code>[<code>, scheduler</code>]<code>)</code>
</h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/buffer7.png" style="width:100%;" alt="buffer(timespan,timeshift,unit)"> <figcaption> <p><code>buffer(timespan, timeshift, unit)</code> creates a new <code>List</code> of items every <code>timeshift</code> period of time, and fills this bundle with every item emitted by the source Observable from that time until <code>timespan</code> time has passed since the bundle’s creation, before emitting this <code>List</code> as its own emission. If <code>timespan</code> is longer than <code>timeshift</code>, the emitted bundles will represent time periods that overlap and so they may contain duplicate items. There is also a version of this variant of the operator that takes a <a href="../scheduler"><code>Scheduler</code></a> as a parameter and uses it to govern the timespan; by default this variant uses the <code>computation</code> scheduler.</p> <ul> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20long,%20java.util.concurrent.TimeUnit)"><code>buffer(long,long,TimeUnit)</code></a>
</li> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)"><code>buffer(long,long,TimeUnit,Scheduler)</code></a>
</li> </ul></figcaption> </figure> <p> You can use the <span class="operator">Buffer</span> operator to implement backpressure (that is, to cope with an Observable that may produce items too quickly for its observer to consume). </p> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/bp.buffer2.png" style="width:100%;" alt="Buffer as a backpressure strategy"> <figcaption><p> Buffer can reduce a sequence of many items to a sequence of fewer buffers-of-items, making them more manageable. You could, for example, close and emit a buffer of items from a bursty Observable periodically, at a regular interval of time. </p> <h4>Sample Code</h4> <pre data-language="java">Observable&lt;List&lt;Integer&gt;&gt; burstyBuffered = bursty.buffer(500, TimeUnit.MILLISECONDS);</pre> </figcaption> </figure> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/bp.buffer1.png" style="width:100%;" alt="Buffer as a backpressure strategy"> <figcaption><p> Or you could get fancy, and collect items in buffers during the bursty periods and emit them at the end of each burst, by using the <a href="debounce"><span class="operator">Debounce</span></a> operator to emit a buffer closing indicator to the buffer operator. </p> <h4>Sample Code</h4> <pre data-language="java">// we have to multicast the original bursty Observable so we can use it
// both as our source and as the source for our buffer closing selector:
Observable&lt;Integer&gt; burstyMulticast = bursty.publish().refCount();
// burstyDebounced will be our buffer closing selector:
Observable&lt;Integer&gt; burstyDebounced = burstyMulticast.debounce(10, TimeUnit.MILLISECONDS);
// and this, finally, is the Observable of buffers we're interested in:
Observable&lt;List&lt;Integer&gt;&gt; burstyBuffered = burstyMulticast.buffer(burstyDebounced);</pre> </figcaption> </figure> <h4>See Also</h4> <ul> <li><a href="http://blog.kaush.co/2015/01/05/debouncedbuffer-with-rxjava/"><cite>DebouncedBuffer With RxJava</cite> by Gopal Kaushik</a></li> <li><a href="https://gist.github.com/benjchristensen/e4524a308456f3c21c0b#file-debouncebufferpublish-java"><cite>DebounceBuffer: Use publish(), debounce() and buffer() together to capture bursts of events.</cite> by Ben Christensen</a></li> </ul> </div> </div> </div>  <div> <div role="tab" id="headingRxJS"> <h3 class="panel-title">  RxJS <code>buffer bufferWithCount bufferWithTime bufferWithTimeOrCount</code>  </h3> </div> <div id="collapseRxJS" role="tabpanel" aria-labelledby="headingRxJS"> <div> <p> RxJS has four <span class="operator">Buffer</span> operators — <code>buffer</code>, <code>bufferWithCount</code>, <code>bufferWithTime</code>, and <code>bufferWithTimeOrCount</code> — each of which has variants that have different ways of governing which source Observable items are emitted as part of which buffers. </p> <h4><code>buffer(bufferBoundaries)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/buffer8.png" style="width:100%;" alt="buffer(bufferBoundaries)"> <figcaption> <p><code>buffer(bufferBoundaries)</code> monitors an Observable, <code>bufferBoundaries</code>. Each time that Observable emits an item, it creates a new collection to begin collecting items emitted by the source Observable and emits the previous collection.</p> </figcaption> </figure> <h4><code>buffer(bufferClosingSelector)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/buffer1.png" style="width:100%;" alt="buffer(bufferClosingSelector)"> <figcaption> <p>When it subscribes to the source Observable, <code>buffer(bufferClosingSelector)</code> begins to collect its emissions into a collection, and it also calls <code>bufferClosingSelector</code> to generate a second Observable. When this second Observable emits an item, <code>buffer</code> emits the current collection and repeats this process: beginning a new collection and calling <code>bufferClosingSelector</code> to create a new Observable to monitor. It will do this until the source Observable terminates.</p> </figcaption> </figure> <h4><code>buffer(bufferOpenings,bufferClosingSelector)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/buffer2.png" style="width:100%;" alt="buffer(bufferOpenings,bufferClosingSelector)"> <figcaption> <p><code>buffer(bufferOpenings, bufferClosingSelector)</code> monitors an Observable, <code>bufferOpenings</code>, that emits <code>BufferOpening</code> objects. Each time it observes such an emitted item, it creates a new collection to begin collecting items emitted by the source Observable and it passes the <code>bufferOpenings</code> Observable into the <code>bufferClosingSelector</code> function. That function returns an Observable. <code>buffer</code> monitors that Observable and when it detects an emitted item from it, it emits the current collection and begins a new one.</p> </figcaption> </figure> <p> <code>buffer</code> is found in each of the following distributions: </p> <ul> <li><code>rx.all.js</code></li> <li><code>rx.all.compat.js</code></li> <li><code>rx.coincidence.js</code></li> </ul> <p> <code>buffer</code> requires one of the following distributions: </p> <ul> <li><code>rx.js</code></li> <li><code>rx.compat.js</code></li> <li><code>rx.lite.js</code></li> <li><code>rx.lite.compat.js</code></li> </ul> <h4><code>bufferWithCount(count)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/bufferWithCount3.png" style="width:100%;" alt="bufferWithCount(count)"> <figcaption> <p><code>bufferWithCount(count)</code> emits non-overlapping buffers, each of which contains at most <code>count</code> items from the source Observable (the final emitted buffer may contain fewer than <code>count</code> items).</p> </figcaption> </figure> <h4><code>bufferWithCount(count, skip)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/bufferWithCount4.png" style="width:100%;" alt="bufferWithCount(count,skip)"> <figcaption> <p><code>bufferWithCount(count, skip)</code> creates a new buffer starting with the first emitted item from the source Observable, and a new one for every <code>skip</code> items thereafter, and fills each buffer with <code>count</code> items: the initial item and <code>count-1</code> subsequent ones, emitting each buffer when it is complete. Depending on the values of <code>count</code> and <code>skip</code> these buffers may overlap (multiple buffers may contain the same item), or they may have gaps (where items emitted by the source Observable are not represented in any buffer).</p> </figcaption> </figure> <p> <code>bufferWithCount</code> is found in each of the following distributions: </p> <ul> <li><code>rx.js</code></li> <li><code>rx.compat.js</code></li> <li><code>rx.all.js</code></li> <li><code>rx.all.compat.js</code></li> <li><code>rx.lite.extras.js</code></li> </ul> <h4><code>bufferWithTime(timeSpan)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/bufferWithTime5.png" style="width:100%;" alt="bufferWithTime(timeSpan)"> <figcaption> <p><code>bufferWithTime(timeSpan)</code> emits a new collection of items periodically, every <code>timeSpan</code> milliseconds, containing all items emitted by the source Observable since the previous bundle emission or, in the case of the first bundle, since the subscription to the source Observable. There is also a version of this variant of the operator that takes a <a href="../scheduler"><code>Scheduler</code></a> as a parameter and uses it to govern the timespan; by default this variant uses the <code>timeout</code> scheduler.</p> </figcaption> </figure> <h4><code>bufferWithTime(timeSpan, timeShift)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/bufferWithTime7.png" style="width:100%;" alt="bufferWithTime(timeSpan,timeShift)"> <figcaption> <p><code>bufferWithTime(timeSpan, timeShift)</code> creates a new collection of items every <code>timeShift</code> milliseconds, and fills this bundle with every item emitted by the source Observable from that time until <code>timeSpan</code> milliseconds has passed since the collection’s creation, before emitting this collection as its own emission. If <code>timeSpan</code> is longer than <code>timeShift</code>, the emitted bundles will represent time periods that overlap and so they may contain duplicate items. There is also a version of this variant of the operator that takes a <a href="../scheduler"><code>Scheduler</code></a> as a parameter and uses it to govern the timespan; by default this variant uses the <code>timeout</code> scheduler.</p> </figcaption> </figure> <h4><code>bufferWithTimeOrCount(timeSpan, count)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/bufferWithTimeOrCount6.png" style="width:100%;" alt="bufferWithTimeOrCount(timeSpan,count)"> <figcaption> <p><code>bufferWithTimeOrCount(timeSpan, count)</code> emits a new collection of items for every <code>count</code> items emitted by the source Observable, or, if <code>timeSpan</code> milliseconds have elapsed since its last collection emission, it emits a collection of however many items the source Observable has emitted in that span, even if this is fewer than <code>count</code>. There is also a version of this variant of the operator that takes a <a href="../scheduler"><code>Scheduler</code></a> as a parameter and uses it to govern the timespan; by default this variant uses the <code>timeout</code> scheduler.</p> </figcaption> </figure> <p> <code>bufferWithTime</code> and <code>bufferWithTimeOrCount</code> are found in each of the following distributions: </p> <ul> <li><code>rx.all.js</code></li> <li><code>rx.all.compat.js</code></li> <li><code>rx.time.js</code></li> </ul> <p> <code>bufferWithTime</code> and <code>bufferWithTimeOrCount</code> require one of the following distributions: </p> <ul> <li>
<code>rx.time.js</code> requires <code>rx.js</code> or <code>rx.compat.js</code>
</li> <li>otherwise: <code>rx.lite.js</code> or <code>rx.lite.compat.js</code>
</li> </ul> </div> </div> </div> <div> <div role="tab" id="headingRxKotlin"> <h3 class="panel-title">  RxKotlin <code>buffer</code>  </h3> </div> <div id="collapseRxKotlin" role="tabpanel" aria-labelledby="headingRxKotlin"> <div> <p> In RxKotlin there are several variants of <span class="operator">Buffer</span>: </p> <h4><code>buffer(count)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/buffer3.png" style="width:100%;" alt="buffer(count)"> <figcaption> <p><code>buffer(count)</code> emits non-overlapping buffers in the form of <code>List</code>s, each of which contains at most <code>count</code> items from the source Observable (the final emitted <code>List</code> may have fewer than <code>count</code> items).</p> </figcaption> </figure> <h4><code>buffer(count, skip)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/buffer4.png" style="width:100%;" alt="buffer(count,skip)"> <figcaption> <p><code>buffer(count, skip)</code> creates a new buffer starting with the first emitted item from the source Observable, and every <code>skip</code> items thereafter, and fills each buffer with <code>count</code> items: the initial item and <code>count-1</code> subsequent ones. It emits these buffers as <code>List</code>s. Depending on the values of <code>count</code> and <code>skip</code> these buffers may overlap (multiple buffers may contain the same item), or they may have gaps (where items emitted by the source Observable are not represented in any buffer).</p> </figcaption> </figure> <h4><code>buffer(bufferClosingSelector)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/buffer1.png" style="width:100%;" alt="buffer(bufferClosingSelector)"> <figcaption> <p>When it subscribes to the source Observable, <code>buffer(bufferClosingSelector)</code> begins to collect its emissions into a <code>List</code>, and it also calls <code>bufferClosingSelector</code> to generate a second Observable. When this second Observable emits an <code>TClosing</code> object, <code>buffer</code> emits the current <code>List</code> and repeats this process: beginning a new <code>List</code> and calling <code>bufferClosingSelector</code> to create a new Observable to monitor. It will do this until the source Observable terminates.</p> </figcaption> </figure> <h4><code>buffer(boundary)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/buffer8.png" style="width:100%;" alt="buffer(boundary)"> <figcaption> <p><code>buffer(boundary)</code> monitors an Observable, <code>boundary</code>. Each time that Observable emits an item, it creates a new <code>List</code> to begin collecting items emitted by the source Observable and emits the previous <code>List</code>.</p> </figcaption> </figure> <h4><code>buffer(bufferOpenings, bufferClosingSelector)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/buffer2.png" style="width:100%;" alt="buffer(bufferOpenings,bufferClosingSelector)"> <figcaption> <p><code>buffer(bufferOpenings, bufferClosingSelector)</code> monitors an Observable, <code>bufferOpenings</code>, that emits <code>BufferOpening</code> objects. Each time it observes such an emitted item, it creates a new <code>List</code> to begin collecting items emitted by the source Observable and it passes the <code>bufferOpenings</code> Observable into the <code>closingSelector</code> function. That function returns an Observable. <code>buffer</code> monitors that Observable and when it detects an emitted item from it, it closes the <code>List</code> and emits it as its own emission.</p> </figcaption> </figure> <h4>
<code>buffer(timespan, unit</code>[<code>, scheduler</code>]<code>)</code>
</h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/buffer5.png" style="width:100%;" alt="buffer(timespan,unit)"> <figcaption> <p><code>buffer(timespan, unit)</code> emits a new <code>List</code> of items periodically, every <code>timespan</code> amount of time, containing all items emitted by the source Observable since the previous bundle emission or, in the case of the first bundle, since the subscription to the source Observable. There is also a version of this variant of the operator that takes a <a href="../scheduler"><code>Scheduler</code></a> as a parameter and uses it to govern the timespan; by default this variant uses the <code>computation</code> scheduler.</p> </figcaption> </figure> <h4>
<code>buffer(timespan, unit, count</code>[<code>, scheduler</code>]<code>)</code>
</h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/buffer6.png" style="width:100%;" alt="buffer(timespan,unit,count)"> <figcaption> <p><code>buffer(timespan, unit, count)</code> emits a new <code>List</code> of items for every <code>count</code> items emitted by the source Observable, or, if <code>timespan</code> has elapsed since its last bundle emission, it emits a bundle of however many items the source Observable has emitted in that span, even if this is fewer than <code>count</code>. There is also a version of this variant of the operator that takes a <a href="../scheduler"><code>Scheduler</code></a> as a parameter and uses it to govern the timespan; by default this variant uses the <code>computation</code> scheduler.</p> </figcaption> </figure> <h4>
<code>buffer(timespan, timeshift, unit</code>[<code>, scheduler</code>]<code>)</code>
</h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/buffer7.png" style="width:100%;" alt="buffer(timespan,timeshift,unit)"> <figcaption> <p><code>buffer(timespan, timeshift, unit)</code> creates a new <code>List</code> of items every <code>timeshift</code> period of time, and fills this bundle with every item emitted by the source Observable from that time until <code>timespan</code> time has passed since the bundle’s creation, before emitting this <code>List</code> as its own emission. If <code>timespan</code> is longer than <code>timeshift</code>, the emitted bundles will represent time periods that overlap and so they may contain duplicate items. There is also a version of this variant of the operator that takes a <a href="../scheduler"><code>Scheduler</code></a> as a parameter and uses it to govern the timespan; by default this variant uses the <code>computation</code> scheduler.</p> </figcaption> </figure> </div> </div> </div> <div> <div role="tab" id="headingRxNET"> <h3 class="panel-title">  RxNET <code>Buffer</code>  </h3> </div> <div id="collapseRxNET" role="tabpanel" aria-labelledby="headingRxNET"> <div> <p> In Rx.NET there are several variants of <span class="operator">Buffer</span>. For each variety you can either pass in the source Observable as the first parameter, or you can call it as an instance method of the source Observable (in which case you can omit that parameter): </p> <h4><code>Buffer(count)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/Buffer3.net.png" style="width:100%;" alt="Buffer(count)"> <figcaption> <p><code>Buffer(count)</code> emits non-overlapping buffers in the form of <code>IList</code>s, each of which contains at most <code>count</code> items from the source Observable (the final emitted <code>IList</code> may have fewer than <code>count</code> items).</p> </figcaption> </figure> <h4><code>Buffer(count, skip)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/Buffer4.net.png" style="width:100%;" alt="Buffer(count,skip)"> <figcaption> <p><code>Buffer(count, skip)</code> creates a new buffer starting with the first emitted item from the source Observable, and every <code>skip</code> items thereafter, and fills each buffer with <code>count</code> items: the initial item and <code>count-1</code> subsequent ones. It emits these buffers as <code>IList</code>s. Depending on the values of <code>count</code> and <code>skip</code> these buffers may overlap (multiple buffers may contain the same item), or they may have gaps (where items emitted by the source Observable are not represented in any buffer).</p> </figcaption> </figure> <h4><code>Buffer(bufferClosingSelector)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/Buffer1.net.png" style="width:100%;" alt="Buffer(bufferClosingSelector)"> <figcaption> <p>When it subscribes to the source Observable, <code>Buffer(bufferClosingSelector)</code> begins to collect its emissions into an <code>IList</code>, and it also calls <code>bufferClosingSelector</code> to generate a second Observable. When this second Observable emits an <code>TBufferClosing</code> object, <code>Buffer</code> emits the current <code>IList</code> and repeats this process: beginning a new <code>IList</code> and calling <code>bufferClosingSelector</code> to create a new Observable to monitor. It will do this until the source Observable terminates.</p> </figcaption> </figure> <h4><code>Buffer(bufferOpenings,bufferClosingSelector)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/Buffer2.net.png" style="width:100%;" alt="Buffer(bufferOpenings,bufferClosingSelector)"> <figcaption> <p><code>Buffer(bufferOpenings, bufferClosingSelector)</code> monitors an Observable, <code>BufferOpenings</code>, that emits <code>TBufferOpening</code> objects. Each time it observes such an emitted item, it creates a new <code>IList</code> to begin collecting items emitted by the source Observable and it passes the <code>TBufferOpening</code> object into the <code>bufferClosingSelector</code> function. That function returns an Observable. <code>Buffer</code> monitors that Observable and when it detects an emitted item from it, it closes the <code>IList</code> and emits it as its own emission.</p> </figcaption> </figure> <h4><code>Buffer(timeSpan)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/Buffer5.net.png" style="width:100%;" alt="Buffer(timeSpan)"> <figcaption> <p><code>Buffer(timeSpan)</code> emits a new <code>IList</code> of items periodically, every <code>timeSpan</code> amount of time, containing all items emitted by the source Observable since the previous bundle emission or, in the case of the first list, since the subscription to the source Observable. There is also a version of this variant of the operator that takes an <a href="../scheduler"><code>IScheduler</code></a> as a parameter and uses it to govern the timespan.</p> </figcaption> </figure> <h4><code>Buffer(timeSpan, count)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/Buffer6.net.png" style="width:100%;" alt="Buffer(timeSpan,count)"> <figcaption> <p><code>Buffer(timeSpan, count)</code> emits a new <code>IList</code> of items for every <code>count</code> items emitted by the source Observable, or, if <code>timeSpan</code> has elapsed since its last list emission, it emits a list of however many items the source Observable has emitted in that span, even if this is fewer than <code>count</code>. There is also a version of this variant of the operator that takes an <a href="../scheduler"><code>IScheduler</code></a> as a parameter and uses it to govern the timespan.</p> </figcaption> </figure> <h4><code>Buffer(timeSpan, timeShift)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/Buffer7.net.png" style="width:100%;" alt="Buffer(timeSpan,timeShift)"> <figcaption> <p><code>Buffer(timeSpan, timeShift)</code> creates a new <code>IList</code> of items every <code>timeShift</code> period of time, and fills this list with every item emitted by the source Observable from that time until <code>timeSpan</code> time has passed since the list’s creation, before emitting this <code>IList</code> as its own emission. If <code>timeSpan</code> is longer than <code>timeShift</code>, the emitted lists will represent time periods that overlap and so they may contain duplicate items. There is also a version of this variant of the operator that takes an <a href="../scheduler"><code>IScheduler</code></a> as a parameter and uses it to govern the timespan.</p> </figcaption> </figure> </div> </div> </div> <div> <div role="tab" id="headingRxPHP"> <h3 class="panel-title">  RxPHP <code>bufferWithCount</code>  </h3> </div> <div id="collapseRxPHP" role="tabpanel" aria-labelledby="headingRxPHP"> <div> <figure class="variant"> <figcaption> <p> RxPHP implements this operator as <code>bufferWithCount</code>. </p> <p> Projects each element of an observable sequence into zero or more buffers which are produced based on element count information. </p> <h4>Sample Code</h4> <pre data-language="php">//from https://github.com/ReactiveX/RxPHP/blob/master/demo/bufferWithCount/bufferWithCount.php

$source = Rx\Observable::range(1, 6)
    -&gt;bufferWithCount(2)
    -&gt;subscribe($stdoutObserver);</pre> <div> <pre data-language="javascript">Next value: [1,2]
Next value: [3,4]
Next value: [5,6]
Complete!</pre> </div> <pre data-language="php">//from https://github.com/ReactiveX/RxPHP/blob/master/demo/bufferWithCount/bufferWithCountAndSkip.php

$source = Rx\Observable::range(1, 6)
    -&gt;bufferWithCount(2, 1)
    -&gt;subscribe($stdoutObserver);</pre> <div> <pre data-language="javascript">Next value: [1,2]
Next value: [2,3]
Next value: [3,4]
Next value: [4,5]
Next value: [5,6]
Next value: [6]
Complete!</pre> </div> </figcaption> </figure> </div> </div> </div> <div> <div role="tab" id="headingRxPY"> <h3 class="panel-title">  RxPY <code>buffer buffer_with_count buffer_with_time buffer_with_time_or_count pairwise</code>  </h3> </div> <div id="collapseRxPY" role="tabpanel" aria-labelledby="headingRxPY"> <div> <p> RxPY has several <span class="operator">Buffer</span> variants: <code>buffer</code>, <code>buffer_with_count</code>, <code>buffer_with_time</code>, and <code>buffer_with_time_or_count</code>. For each of these variants there are optional parameters that change the behavior of the operator. As always in RxPY, when an operator may take more than one optional parameter, be sure to name the parameter in the parameter list when you call the operator so as to avoid ambiguity. </p> <h4><code>buffer(buffer_openings)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/buffer8.py.png" style="width:100%;" alt="buffer(buffer_openings)"> <figcaption> <p><code>buffer(buffer_openings=boundaryObservable)</code> monitors an Observable, <code>buffer_openings</code>. Each time that Observable emits an item, it creates a new array to begin collecting items emitted by the source Observable and emits the previous array.</p> </figcaption> </figure> <h4><code>buffer(closing_selector)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/buffer1.py.png" style="width:100%;" alt="buffer(closing_selector)"> <figcaption> <p><code>buffer(closing_selector=closingSelector)</code> begins collecting items emitted by the source Observable immediately upon subscription, and also calls the <code>closing_selector</code> function to generate a second Observable. It monitors this new Observable and, when it completes or emits an item, it emits the current array, begins a new array to collect items from the source Observable, and calls <code>closing_selector</code> again to generate a new Observable to monitor in order to determine when to emit the new array. It repeats this process until the source Observable terminates, whereupon it emits the final array.</p> </figcaption> </figure> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/buffer2.py.png" style="width:100%;" alt="buffer(closing_selector,buffer_closing_selector)"> <figcaption> <p><code>buffer(closing_selector=openingSelector, buffer_closing_selector=closingSelector)</code> begins by calling <code>closing_selector</code> to get an Observable. It monitors this Observable, and, whenever it emits an item, <code>buffer</code> creates a new array, begins to collect items subsequently emitted by the source Observable into this array, and calls <code>buffer_closing_selector</code> to get a new Observable to govern the closing of that array. When this new Observable emits an item or terminates, <code>buffer</code> closes and emits the array that the Observable governs.</p> </figcaption> </figure> <h4><code>buffer_with_count(count)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/buffer_with_count3.py.png" style="width:100%;" alt="buffer_with_count(count)"> <figcaption> <p><code>buffer_with_count(count)</code> emits non-overlapping buffers in the form of arrays, each of which contains at most <code>count</code> items from the source Observable (the final emitted array may have fewer than <code>count</code> items).</p> </figcaption> </figure> <h4><code>buffer_with_count(count, skip)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/buffer_with_count4.py.png" style="width:100%;" alt="buffer_with_count(count,skip)"> <figcaption> <p><code>buffer_with_count(count, skip=skip)</code> creates a new buffer starting with the first emitted item from the source Observable, and every <code>skip</code> items thereafter, and fills each buffer with <code>count</code> items: the initial item and <code>count-1</code> subsequent ones. It emits these buffers as arrays. Depending on the values of <code>count</code> and <code>skip</code> these buffers may overlap (multiple buffers may contain the same item), or they may have gaps (where items emitted by the source Observable are not represented in any buffer).</p> </figcaption> </figure> <h4><code>buffer_with_time(timespan)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/buffer_with_time5.py.png" style="width:100%;" alt="buffer_with_time(timespan)"> <figcaption> <p><code>buffer_with_time(timespan)</code> emits a new array of items periodically, every <code>timespan</code> milliseconds, containing all items emitted by the source Observable since the previous bundle emission or, in the case of the first bundle, since the subscription to the source Observable. There is also a version of this variant of the operator that takes a <code>scheduler</code> parameter and uses it to govern the timespan; by default this variant uses the <code>timeout</code> scheduler.</p> </figcaption> </figure> <h4><code>buffer_with_time(timespan, timeshift)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/buffer_with_time7.py.png" style="width:100%;" alt="buffer_with_time(timespan,timeshift)"> <figcaption> <p><code>buffer(timespan, timeshift=timeshift)</code> creates a new array of items every <code>timeshift</code> milliseconds, and fills this array with every item emitted by the source Observable from that time until <code>timespan</code> milliseconds have passed since the array’s creation, before emitting this array as its own emission. If <code>timespan</code> is longer than <code>timeshift</code>, the emitted arrays will represent time periods that overlap and so they may contain duplicate items. There is also a version of this variant of the operator that takes a <code>scheduler</code> parameter and uses it to govern the timespan; by default this variant uses the <code>timeout</code> scheduler.</p> </figcaption> </figure> <h4><code>buffer_with_time_or_count(timespan, count)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/buffer_with_time_or_count6.py.png" style="width:100%;" alt="buffer_with_time_or_count(timespan,count)"> <figcaption> <p><code>buffer_with_time_or_count(timespan, count)</code> emits a new array of items for every <code>count</code> items emitted by the source Observable, or, if <code>timespan</code> milliseconds have elapsed since its last bundle emission, it emits an array of however many items the source Observable has emitted in that span, even if this is fewer than <code>count</code>. There is also a version of this variant of the operator that takes a <code>scheduler</code> parameter and uses it to govern the timespan; by default this variant uses the <code>timeout</code> scheduler.</p> </figcaption> </figure> </div> </div> </div> <div> <div role="tab" id="headingRxrb"> <h3 class="panel-title">  Rxrb <code>buffer_with_count buffer_with_time</code>  </h3> </div> <div id="collapseRxrb" role="tabpanel" aria-labelledby="headingRxrb"> <div> <p> Rx.rb has three variants of the <span class="operator">Buffer</span> operator: </p> <h4><code>buffer_with_count(count)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/buffer_with_count3.py.png" style="width:100%;" alt="buffer_with_count(count)"> <figcaption> <p><code>buffer_with_count(count)</code> emits non-overlapping buffers in the form of arrays, each of which contains at most <code>count</code> items from the source Observable (the final emitted array may have fewer than <code>count</code> items).</p> </figcaption> </figure> <h4><code>buffer_with_count(count,skip)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/buffer_with_count4.rb.png" style="width:100%;" alt="buffer_with_count(count,skip)"> <figcaption> <p><code>buffer_with_count(count, skip=skip)</code> creates a new buffer starting with the first emitted item from the source Observable, and every <code>skip</code> items thereafter, and fills each buffer with <code>count</code> items: the initial item and <code>count-1</code> subsequent ones. It emits these buffers as arrays. Depending on the values of <code>count</code> and <code>skip</code> these buffers may overlap (multiple buffers may contain the same item), or they may have gaps (where items emitted by the source Observable are not represented in any buffer).</p> </figcaption> </figure> <h4><code>buffer_with_time(timespan)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/buffer_with_time5.py.png" style="width:100%;" alt="buffer_with_time(timespan)"> <figcaption> <p><code>buffer_with_time(timespan)</code> emits a new array of items periodically, every <code>timespan</code> milliseconds, containing all items emitted by the source Observable since the previous bundle emission or, in the case of the first bundle, since the subscription to the source Observable.</p> </figcaption> </figure> </div> </div> </div> <div> <div role="tab" id="headingRxScala"> <h3 class="panel-title">  RxScala <code>slidingBuffer tumblingBuffer</code>  </h3> </div> <div id="collapseRxScala" role="tabpanel" aria-labelledby="headingRxScala"> <div> <p> RxScala has two varieties of <span class="operator">Buffer</span> — <code>slidingBuffer</code> and <code>tumblingBuffer</code> — each of which has variants with different ways of assembling the buffers they emit: </p> <h4><code>slidingBuffer(count, skip)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/slidingBuffer4.png" style="width:100%;" alt="slidingBuffer(count,skip)"> <figcaption> <p><code>slidingBuffer(count, skip)</code> creates a new buffer starting with the first emitted item from the source Observable, and every <code>skip</code> items thereafter, and fills each buffer with <code>count</code> items: the initial item and <code>count-1</code> subsequent ones. It emits these buffers as <code>Seq</code>s. Depending on the values of <code>count</code> and <code>skip</code> these buffers may overlap (multiple buffers may contain the same item), or they may have gaps (where items emitted by the source Observable are not represented in any buffer).</p> </figcaption> </figure> <h4><code>slidingBuffer(timespan, timeshift)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/slidingBuffer7.png" style="width:100%;" alt="slidingBuffer(timespan,timeshift)"> <figcaption> <p><code>slidingBuffer(timespan, timeshift)</code> creates a new <code>Seq</code> of items every <code>timeshift</code> (a <code>Duration</code>), and fills this buffer with every item emitted by the source Observable from that time until <code>timespan</code> (also a <code>Duration</code>) has passed since the buffer’s creation, before emitting this <code>Seq</code> as its own emission. If <code>timespan</code> is longer than <code>timeshift</code>, the emitted arrays will represent time periods that overlap and so they may contain duplicate items. There is also a version of this variant of the operator that takes a <a href="../scheduler"><code>Scheduler</code></a> as a parameter and uses it to govern the timespan.</p> </figcaption> </figure> <h4><code>slidingBuffer(openings, closings)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/slidingBuffer2.png" style="width:100%;" alt="slidingBuffer(openings,closings)"> <figcaption> <p><code>slidingBuffer(openings,closings)</code> monitors the <code>openings</code> Observable, and, whenever it emits an <code>Opening</code> item, <code>slidingBuffer</code> creates a new <code>Seq</code>, begins to collect items subsequently emitted by the source Observable into this buffer, and calls <code>closings</code> to get a new Observable to govern the closing of that buffer. When this new Observable emits an item or terminates, <code>slidingBuffer</code> closes and emits the <code>Seq</code>that the Observable governs.</p> </figcaption> </figure> <h4><code>tumblingBuffer(count)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/tumblingBuffer3.png" style="width:100%;" alt="tumblingBuffer(count)"> <figcaption> <p><code>tumblingBuffer(count)</code> emits non-overlapping buffers in the form of <code>Seq</code>s, each of which contains at most <code>count</code> items from the source Observable (the final emitted buffer may have fewer than <code>count</code> items).</p> </figcaption> </figure> <h4><code>tumblingBuffer(boundary)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/tumblingBuffer8.png" style="width:100%;" alt="tumblingBuffer(boundary)"> <figcaption> <p><code>tumblingBuffer(boundary)</code> monitors an Observable, <code>boundary</code>. Each time that Observable emits an item, it creates a new <code>Seq</code> to begin collecting items emitted by the source Observable and emits the previous <code>Seq</code>. This variant of the operator has an optional second parameter, <code>initialCapacity</code> with which you can indicate the expected size of these buffers so as to make memory allocation more efficient.</p> </figcaption> </figure> <h4><code>tumblingBuffer(timespan)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/tumblingBuffer5.png" style="width:100%;" alt="tumblingBuffer(timespan)"> <figcaption> <p><code>tumblingBuffer(timespan)</code> emits a new <code>Seq</code> of items periodically, every <code>timespan</code> (a <code>Duration</code>), containing all items emitted by the source Observable since the previous bundle emission or, in the case of the first bundle, since the subscription to the source Observable. This variant of the operator has an optional second parameter, <code>scheduler</code>, with which you can set the <a href="../scheduler"><code>Scheduler</code></a> that you want to govern the timespan calculation.</p> </figcaption> </figure> <h4><code>tumblingBuffer(timespan, count)</code></h4> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/tumblingBuffer6.png" style="width:100%;" alt="tumblingBuffer(timespan,count)"> <figcaption> <p><code>tumblingBuffer(timespan, count)</code> emits a new <code>Seq</code> of items for every <code>count</code> items emitted by the source Observable, or, if <code>timespan</code> (a <code>Duration</code>) has elapsed since its last bundle emission, it emits a <code>Seq</code> containing however many items the source Observable emitted in that span, even if this is fewer than <code>count</code>. This variant of the operator has an optional third parameter, <code>scheduler</code>, with which you can set the <a href="../scheduler"><code>Scheduler</code></a> that you want to govern the timespan calculation.</p> </figcaption> </figure> </div> </div> </div>  </div>
<div class="_attribution">
  <p class="_attribution-p">
    © ReactiveX contributors<br>Licensed under the Apache License 2.0.<br>
    <a href="http://reactivex.io/documentation/operators/buffer.html" class="_attribution-link">http://reactivex.io/documentation/operators/buffer.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
