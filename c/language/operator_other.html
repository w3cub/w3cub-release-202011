
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Other Operators - C - W3cubDocs</title>
  
  <meta name="description" content=" A collection of operators that do not fit into any of the other major categories. ">
  <meta name="keywords" content="other, operators, c">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/c/language/operator_other.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/c.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/c/" class="_nav-link" title="" style="margin-left:0;">C</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _c">
				
				
<h1 id="firstHeading" class="firstHeading">Other operators</h1>            <p>A collection of operators that do not fit into any of the other major categories.</p>
<table class="wikitable"> <tr style="text-align:center"> <th> Operator </th> <th> Operator name </th> <th> Example </th> <th> Description </th>
</tr> <tr style="text-align:center"> <td> <code>(...)</code> </td> <td> <a href="operator_other#Function_call">function call</a> </td> <td> <code>f(...)</code> </td> <td> call the function <b>f</b>(), with zero or more arguments </td>
</tr> <tr style="text-align:center"> <td> <code>,</code> </td> <td> <a href="operator_other#Comma_operator">comma operator</a> </td> <td> <code>a, b</code> </td> <td> evaluate expression <b>a</b>, disregard its return value and complete any side-effects, then evaluate expression <b>b</b>, returning the type and the result of this evaluation </td>
</tr> <tr style="text-align:center"> <td> <code>(type)</code> </td> <td> <a href="cast" title="c/language/cast">type cast</a> </td> <td> <code>(type)a</code> </td> <td> cast the type of <b>a</b> to <b>type</b> </td>
</tr> <tr style="text-align:center"> <td> <code>? :</code> </td> <td> <a href="operator_other#Conditional_operator">conditional operator</a> </td> <td> <code>a ? b : c</code> </td> <td> if <b>a</b> is logically true (does not evaluate to zero) then evaluate expression <b>b</b>, otherwise evaluate expression <b>c</b> </td>
</tr> <tr style="text-align:center"> <td> <code>sizeof</code> </td> <td> <a href="sizeof" title="c/language/sizeof">sizeof operator</a> </td> <td> <code>sizeof a</code> </td> <td> the size in bytes of <b>a</b> </td>
</tr> <tr style="text-align:center"> <td> <code>_Alignof</code> <span class="t-mark-rev t-since-c11">(since C11)</span> </td> <td> <a href="alignof" title="c/language/ Alignof">_Alignof operator</a> </td> <td> <code>_Alignof(type)</code> </td> <td> the alignment required of <b>type</b> </td>
</tr>
</table> <h3 id="Function_call">Function call</h3> <p>The function call expression has the form.</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td class="t-sdsc-nopad"> <span class="t-spar">expression</span> <code>(</code> <span class="t-spar">argument-list</span><span class="t-mark">(optional)</span> <code>)</code> </td> <td class="t-sdsc-nopad"> </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <p>where.</p>
<table class="t-par-begin"> <tr class="t-par"> <td> <span class="t-spar">expression</span> </td> <td> - </td> <td> any expression of pointer-to-function type (after <a href="conversion#Lvalue_conversions" title="c/language/conversion">lvalue conversions</a>) </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">argument-list</span> </td> <td> - </td> <td> comma-separated list of expressions (which cannot be comma operators) of any complete object type. May be omitted when calling functions that take no arguments. </td>
</tr>
</table> <p>The behavior of the function call expression depends on whether the prototype of the function being called is <a href="scope" title="c/language/scope">in scope</a> at the point of call.</p>
<h4 id="Call_to_a_function_with_a_prototype">Call to a function with a prototype</h4> <div class="t-li1">
<span class="t-li">1)</span> The number of parameters must equal the number of arguments (unless the ellipsis parameter is used).</div> <div class="t-li1">
<span class="t-li">2)</span> The type of each parameter must be a type such that <a href="conversion" title="c/language/conversion">implicit conversion as if by assignment</a> exists that converts the unqualified type of the corresponding argument to the type of the parameter.</div> <table class="t-rev-begin"> <tr class="t-rev t-since-c99">
<td>  Additionally, for every parameter of <a href="array" title="c/language/array">array type</a> that uses the keyword <code>static</code> between <code>[</code> and <code>]</code>, the argument expression must designate a pointer to the element of an array with at least that many elements as specified in the size expression of the parameter. </td> <td><span class="t-mark-rev t-since-c99">(since C99)</span></td>
</tr> </table> <div class="t-li1">
<span class="t-li">3)</span> The arguments are evaluated <a href="eval_order" title="c/language/eval order">in unspecified order and without sequencing</a>.</div> <div class="t-li1">
<span class="t-li">4)</span> <span class="t-rev-inl t-until-c11"><span><a href="operator_assignment" title="c/language/operator assignment">Assignment</a></span> <span><span class="t-mark-rev t-until-c11">(until C11)</span></span></span><span class="t-rev-inl t-since-c11"><span><a href="initialization" title="c/language/initialization">Initialization</a></span> <span><span class="t-mark-rev t-since-c11">(since C11)</span></span></span> is performed to copy the value of each argument to the corresponding function parameter (note; the function can modify its parameters, and those changes do not affect the arguments; C function calls are only call-by-value). <ul><li> if there is a <a href="variadic" title="c/language/variadic">trailing ellipsis</a> parameter, <a href="conversion#Default_argument_promotions" title="c/language/conversion">Default argument promotions</a> are performed on the remaining arguments, which are made available to <code>va_list</code>.</li></ul>
</div> <div class="t-li1">
<span class="t-li">5)</span> Function is executed, and the value it returns becomes the value of the function call expression (if the function returns void, the function call expression is a void expression) <div class="c source-c"><pre data-language="c">void f(char* p, int x) {}
int main(void)
{
    f("abc", 3.14); // array to pointer and float to int conversions
}</pre></div>
</div> <h4 id="Call_to_a_function_without_a_prototype">Call to a function without a prototype</h4> <div class="t-li1">
<span class="t-li">1)</span> The arguments are evaluated <a href="eval_order" title="c/language/eval order">in unspecified order and without sequencing</a>.</div> <div class="t-li1">
<span class="t-li">2)</span> <a href="conversion#Default_argument_promotions" title="c/language/conversion">Default argument promotions</a> are performed on every argument expression.</div> <div class="t-li1">
<span class="t-li">3)</span> <span class="t-rev-inl t-until-c11"><span><a href="operator_assignment" title="c/language/operator assignment">Assignment</a></span> <span><span class="t-mark-rev t-until-c11">(until C11)</span></span></span><span class="t-rev-inl t-since-c11"><span><a href="initialization" title="c/language/initialization">Initialization</a></span> <span><span class="t-mark-rev t-since-c11">(since C11)</span></span></span> is performed to copy the value of each argument to the corresponding function parameter.</div> <div class="t-li1">
<span class="t-li">4)</span> Function is executed, and the value it returns becomes the value of the function call expression (if the function returns void, the function call expression is a void expression) <div class="c source-c"><pre data-language="c">void f(); // no prototype
int main(void)
{
    f(1, 1.0f); // UB unless f is defined to take an int and a double
}
void f(int a, double c) {}</pre></div>
</div> <p>The behavior of a function call to a function without a prototype is undefined if.</p>
<ul>
<li> the number of arguments does not match the number of parameters. </li>
<li> the promoted types of the arguments are not <a href="compatible_type#Compatible_types" title="c/language/type">compatible</a> with the promoted types of the parameters except that </li>
<ul>
<li> signed and unsigned versions of the same integer type are considered compatible if the value of the argument is representable by both types. </li>
<li> pointers to void and pointers to (possibly cvr-qualified) character types are considered compatible </li>
</ul>
</ul>  <h4 id="Notes">Notes</h4> <p>The evaluations of <span class="t-spar">expression</span> that designates the function to be called and all arguments are <a href="eval_order" title="c/language/eval order">unsequenced</a> with respect to each other (but there is a sequence point before the body of the function begins executing).</p>
<div class="c source-c"><pre data-language="c">(*pf[f1()]) (f2(), f3() + f4()); // f1, f2, f3, f4 may be called in any order</pre></div> <p>Although function call is only defined for pointers to functions, it works with function designators due to the <a href="conversion#Function_to_pointer_conversion" title="c/language/conversion">function-to-pointer implicit conversion</a>.</p>
<div class="c source-c"><pre data-language="c">int f(void) { return 1; }
int (*pf)(void) = f;
int main(void)
{
    f();    // convert f to pointer, then call
    (&amp;f)(); // create a pointer to function, then call
 
    pf();    // call the function
    (*pf)(); // obtain the function designator, convert to pointer, then calls
 
    (****f)(); // convert to pointer, obtain the function, repeat 4x, then call
    (****pf)(); // also OK
}</pre></div> <p>Functions that ignore unused arguments, such as <code><a href="../io/fprintf" title="c/io/fprintf">printf</a></code>, must be called with a prototype in scope (the prototype of such functions necessarily uses the <a href="variadic" title="c/language/variadic">trailing ellipsis</a> parameter) to avoid invoking undefined behavior.</p>
<p>A post-C11 defect report DR 427 changes the semantics of preparing function parameters when calling a function with a prototype from assignment to initialization from their corresponding arguments, in order to allow parameters of const-qualified type (which are <i>de-facto</i> allowed). The permitted implicit conversions remain implicit conversions as if by assignment since that's what <a href="initialization" title="c/language/initialization">initialization</a> also uses.</p>
<table class="t-rev-begin"> <tr class="t-rev t-until-c99">
<td> <p>A function call expression where <span class="t-spar">expression</span> consists entirely of an identifier and that identifier is undeclared acts as though the identifier is declared as.</p>
<div class="c source-c"><pre data-language="c">extern int identifier(); // returns int and has no prototype</pre></div> <p>So the following complete program is valid C89:</p>
<div class="c source-c"><pre data-language="c">main() {
    int n = atoi("123"); // implicitly declares atoi as int atoi()
}</pre></div> </td> <td><span class="t-mark">(until C99)</span></td>
</tr> </table> <h3 id="Comma_operator">Comma operator</h3> <p>The comma operator expression has the form.</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td class="t-sdsc-nopad"> <span class="t-spar">lhs</span> <code>,</code> <span class="t-spar">rhs</span> </td> <td class="t-sdsc-nopad"> </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <p>where.</p>
<table class="t-par-begin"> <tr class="t-par"> <td> <span class="t-spar">lhs</span> </td> <td> - </td> <td> any expression </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">rhs</span> </td> <td> - </td> <td> any expression other than another comma operator (in other words, comma operator's <a href="operator_precedence" title="c/language/operator precedence">associativity</a> is left-to-right) </td>
</tr>
</table> <p>First, the left operand, <span class="t-spar">lhs</span>, is evaluated and its result value is discarded.</p>
<p>Then, a <a href="eval_order" title="c/language/eval order">sequence point</a> takes place, so that all side effects of <span class="t-spar">lhs</span> are complete.</p>
<p>Then, the right operand, <span class="t-spar">rhs</span>, is evaluated and its result is returned by the comma operator as a <a href="value_category" title="c/language/value category">non-lvalue</a>.</p>
<h3 id="Notes_2">Notes</h3> <p>The type of the <span class="t-spar">lhs</span> may be <code>void</code> (that is, it may be a call to a function that returns <code>void</code>, or it can be an expression <a href="cast" title="c/language/cast">cast</a> to <code>void</code>).</p>
<p>The comma operator may be lvalue in C++, but never in C.</p>
<p>The comma operator may return a struct (the only other expressions that return structs are compound literals, function calls, assignments, and the conditional operator).</p>
<p>In the following contexts, the comma operator cannot appear at the top level of an expression because the comma has a different meaning:</p>
<ul>
<li> argument list in a function call </li>
<li> initializer expression or <a href="initialization" title="c/language/initialization">initializer list</a> </li>
<li> <a href="generic" title="c/language/generic">generic selection</a> </li>
</ul> <p>If the comma operator has to be used in such context, it must be parenthesized:</p>
<div class="c source-c"><pre data-language="c">// int n = 2,3; // error, comma assumed to begin the next declarator
// int a[2] = {1,2,3}; // error: more initializers than elements
int n = (2,3), a[2] = {(1,2),3}; // OK
 
f(a, (t=3, t+2), c); // OK, first, stores 3 in t, then calls f with three arguments</pre></div> <p>Top-level comma operator is also disallowed in array bounds.</p>
<div class="c source-c"><pre data-language="c">// int a[2,3]; // error
int a[(2,3)]; // OK, VLA array of size 3 (VLA because (2,3) is not a constant expression)</pre></div> <p>Comma operator is not allowed in <a href="constant_expression" title="c/language/constant expression">constant expressions</a>, regardless of whether it's on the top level or not.</p>
<div class="c source-c"><pre data-language="c">// static int n = (1,2); // Error: constant expression cannot call the comma operator</pre></div> <h3 id="Cast_operator">Cast operator</h3> <p>See <a href="cast" title="c/language/cast">cast operator</a>.</p>
<h3 id="Conditional_operator">Conditional operator</h3> <p>The conditional operator expression has the form.</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td class="t-sdsc-nopad"> <span class="t-spar">condition</span> <code>?</code> <span class="t-spar">expression-true</span> <code>:</code> <span class="t-spar">expression-false</span> </td> <td class="t-sdsc-nopad"> </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <p>where.</p>
<table class="t-par-begin"> <tr class="t-par"> <td> <span class="t-spar">condition</span> </td> <td> - </td> <td> an expression of scalar type </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">expression-true</span> </td> <td> - </td> <td> the expression that will be evaluated if condition compares unequal to zero </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">expression-false</span> </td> <td> - </td> <td> the expression that will be evaluated if condition compares equal to zero </td>
</tr>
</table> <p>Only the following expressions are allowed as <span class="t-spar">expression-true</span> and <span class="t-spar">expression-false</span>.</p>
<ul>
<li> two expressions of any <a href="arithmetic_types" title="c/language/arithmetic types">arithmetic type</a> </li>
<li> two expressions of the same <a href="struct" title="c/language/struct">struct</a> or <a href="union" title="c/language/union">union</a> type </li>
<li> two expressions of void type </li>
<li> two expressions of pointer type, pointing to types that are <a href="compatible_type#Compatible_types" title="c/language/type">compatible</a>, ignoring cvr-qualifiers </li>
<li> one expression is a pointer and the other is the null pointer constant (such as <code><a href="../types/null" title="c/types/NULL">NULL</a></code>) </li>
<li> one expression is a pointer to object and the other is a pointer to void (possibly qualified) </li>
</ul> <div class="t-li1">
<span class="t-li">1)</span> First, evaluates <span class="t-spar">condition</span>. There is a <a href="eval_order" title="c/language/eval order">sequence point</a> after this evaluation.</div> <div class="t-li1">
<span class="t-li">2)</span> If the result of <span class="t-spar">condition</span> compares unequal to zero, executes <span class="t-spar">expression-true</span>, otherwise executes <span class="t-spar">expression-false</span>
</div> <div class="t-li1">
<span class="t-li">3)</span> Performs a <a href="conversion" title="c/language/conversion">conversion</a> from the result of the evaluation to the <i>common type</i>, defined as follows:</div> <div class="t-li2">
<span class="t-li">1)</span> if the expressions have arithmetic type, the common type is the type after <a href="conversion#Usual_arithmetic_conversions" title="c/language/conversion">usual arithmetic conversions</a>
</div> <div class="t-li2">
<span class="t-li">2)</span> if the expressions have struct/union type, the common type is that struct/union type</div> <div class="t-li2">
<span class="t-li">3)</span> if the expressions are both void, the entire conditional operator expression is a void expression</div> <div class="t-li2">
<span class="t-li">4)</span> if one is a pointer and the other is a null pointer constant, the type is the type of that pointer</div> <div class="t-li2">
<span class="t-li">5)</span> if both are pointers, the result is the pointer to the type that combines cvr-qualifiers of both pointed-to types (that is, if one is <code>const int*</code> and the other is <code>volatile int*</code>, the result is <code>const volatile int*</code>), and if the types were different, the pointed-to type is the <a href="types#Composite_type" title="c/language/types" class="mw-redirect">composite type</a>.</div> <div class="t-li2">
<span class="t-li">6)</span> if one is a pointer to void, the result is a pointer to void with combined cvr-qualifiers</div> <div class="c source-c"><pre data-language="c">#define ICE(x) (sizeof(*(1 ? ((void*)((x) * 0l)) : (int*)1)))
 
// if x is an Integer Constant Expression then macro expands to
 
 sizeof( 1 ? NULL : (int *) 1)  // (void *)((x)*0l)) -&gt; NULL
 
// according to point (4) this further converts into
 
 sizeof(int)
 
// if x is not an Integer Constant Expression then macro expands to
// according to point (6)
 
 (sizeof(*(void *)(x))           // Error due incomplete type</pre></div> <h4 id="Notes_3">Notes</h4> <p>The conditional operator is never an <a href="value_category" title="c/language/value category">lvalue expression</a>, although it may return objects of struct/union type. The only other expressions that may return stucts are <a href="operator_assignment" title="c/language/operator assignment">assignment</a>, <a href="operator_other#Comma_operator">comma</a>, <a href="operator_other#Function_call">function call</a>, and <a href="compound_literal" title="c/language/compound literal">compound literal</a>.</p>
<p>Note that in C++, it may be an lvalue expression.</p>
<p>See <a href="operator_precedence" title="c/language/operator precedence">operator precedence</a> for the details on the relative precedence of this operator and assignment.</p>
<p>Conditional operator has right-to-left associativity, which allows chaining.</p>
<div class="c source-c"><pre data-language="c">struct vehicle v = arg == 'B' ? bus      :
                   arg == 'A' ? airplane :
                   arg == 'T' ? train    :
                   arg == 'C' ? car      :
                   arg == 'H' ? horse    :
                                feet;</pre></div> <h3 id="sizeof_operator">sizeof operator</h3> <p>See <a href="sizeof" title="c/language/sizeof">sizeof operator</a>.</p>
<h3 id="Alignof_operator">_Alignof operator</h3> <p>See <a href="alignof" title="c/language/ Alignof">_Alignof operator</a>.</p>
<h3 id="References">References</h3>  <ul>
<li> C11 standard (ISO/IEC 9899:2011): </li>
<ul>
<li> 6.5.2.2 Function calls (p: 81-82) </li>
<li> 6.5.3.4 The sizeof and _Alignof operators (p: 90-91) </li>
<li> 6.5.4 Cast operators (p: 91) </li>
<li> 6.5.15 Conditional operator (p: 100) </li>
<li> 6.5.17 Comma operator (p: 105) </li>
</ul>
<li> C99 standard (ISO/IEC 9899:1999): </li>
<ul>
<li> 6.5.2.2 Function calls (p: 71-72) </li>
<li> 6.5.3.4 The sizeof operator (p: 80-81) </li>
<li> 6.5.4 Cast operators (p: 81) </li>
<li> 6.5.15 Conditional operator (p: 90-91) </li>
<li> 6.5.17 Comma operator (p: 94) </li>
</ul>
<li> C89/C90 standard (ISO/IEC 9899:1990): </li>
<ul>
<li> 3.3.2.2 Function calls </li>
<li> 3.3.3.4 The sizeof operator </li>
<li> 3.3.4 Cast operators </li>
<li> 3.3.15 Conditional operator </li>
<li> 3.3.17 Comma operator </li>
</ul>
</ul>                     <h3 id="See_also">See also</h3> <ul><li> <a href="operator_precedence" title="c/language/operator precedence">Operator precedence</a> </li></ul> <table class="wikitable"> <tr style="text-align:center"> <th colspan="7"> Common operators </th>
</tr> <tr style="text-align:center"> <td> <a href="operator_assignment" title="c/language/operator assignment"> assignment</a> </td> <td> <a href="operator_incdec" title="c/language/operator incdec"> increment<br>decrement</a> </td> <td> <a href="operator_arithmetic" title="c/language/operator arithmetic"> arithmetic</a> </td> <td> <a href="operator_logical" title="c/language/operator logical"> logical</a> </td> <td> <a href="operator_comparison" title="c/language/operator comparison"> comparison</a> </td> <td> <a href="operator_member_access" title="c/language/operator member access"> member<br>access</a> </td> <td> <strong class="selflink"> other</strong> </td>
</tr> <tr style="text-align:center"> <td> <p><code>a = b a += b a -= b a *= b a /= b a %= b a &amp;= b a |= b a ^= b a &lt;&lt;= b a &gt;&gt;= b</code>.</p>
</td> <td> <p><code>++a --a a++ a--</code></p>
</td> <td> <p><code>+a -a a + b a - b a * b a / b a % b ~a a &amp; b a | b a ^ b a &lt;&lt; b a &gt;&gt; b</code>.</p>
</td> <td> <p><code>!a a &amp;&amp; b a || b</code>.</p>
</td> <td> <p><code>a == b a != b a &lt; b a &gt; b a &lt;= b a &gt;= b</code>.</p>
</td> <td> <p><code>a[b] *a &amp;a a-&gt;b a.b</code>.</p>
</td> <td> <p><code>a(...) a, b (type) a ? : sizeof _Alignof</code> <span class="t-mark-rev t-since-c11">(since C11)</span>.</p>
</td>
</tr> </table>            <div class="_attribution">
  <p class="_attribution-p">
    Â© cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/c/language/operator_other" class="_attribution-link">http://en.cppreference.com/w/c/language/operator_other</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
