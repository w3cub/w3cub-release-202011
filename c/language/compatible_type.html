
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Type - C - W3cubDocs</title>
  
  <meta name="description" content=" (See also arithmetic types for the details on most built-in types and the list of type-related utilities that are provided by the C library). ">
  <meta name="keywords" content="type, c">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/c/language/compatible_type.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-1810d67ab7e57be09d8247710d2feb6954566959eb82322d1fee3a0c9156f56974b78ebaa9928774f00767342bbe58b0799d91fcc336b92b319170b196f9b64b.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/c.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/c/" class="_nav-link" title="" style="margin-left:0;">C</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _cppref">
				
				
<h1 id="firstHeading" class="firstHeading">Type</h1>            <p><small>(See also <a href="arithmetic_types" title="c/language/arithmetic types">arithmetic types</a> for the details on most built-in types and <a href="../types" title="c/types"> the list of type-related utilities</a> that are provided by the C library)</small>.</p>
<p><a href="object" title="c/language/object">Objects</a>, <a href="functions" title="c/language/functions">functions</a>, and <a href="expressions" title="c/language/expressions">expressions</a> have a property called <i>type</i>, which determines the interpretation of the binary value stored in an object or evaluated by the expression.</p>
<h3 id="Type_classification"> Type classification</h3> <p>The C type system consists of the following types:</p>
<ul>
<li>the type <code>void</code> </li>
<li>basic types </li>
<li>the type <code>char</code> </li>
<li>signed integer types </li>
<ul><li>standard: <code>signed char</code>, <code>short</code>, <code>int</code>, <code>long</code><span class="t-rev-inl t-since-c99"><span>, <code>long long</code></span> <span><span class="t-mark-rev t-since-c99">(since C99)</span></span></span> </li></ul>
</ul>    <table class="t-rev-begin"> <tr class="t-rev t-since-c99">
<td> <ul><li>extended: implementation defined, e.g. <code>__int128</code> </li></ul>  </td> <td><span class="t-mark-rev t-since-c99">(since C99)</span></td>
</tr> </table> <ul>
<li>unsigned integer types </li>
<ul><li>standard: <span class="t-rev-inl t-since-c99"><span><code>_Bool</code>,</span> <span><span class="t-mark-rev t-since-c99">(since C99)</span></span></span> <code>unsigned char</code>, <code>unsigned short</code>, <code>unsigned int</code>, <code>unsigned long</code><span class="t-rev-inl t-since-c99"><span>, <code>unsigned long long</code></span> <span><span class="t-mark-rev t-since-c99">(since C99)</span></span></span> </li></ul>
</ul>   <table class="t-rev-begin"> <tr class="t-rev t-since-c99">
<td> <ul><li>extended: implementation-defined, e.g. <code>__uint128</code> </li></ul>  </td> <td><span class="t-mark-rev t-since-c99">(since C99)</span></td>
</tr> </table> <ul>
<li>floating-point types </li>
<ul><li>real floating-point types: <code>float</code>, <code>double</code>, <code>long double</code> </li></ul>
</ul>   <table class="t-rev-begin"> <tr class="t-rev t-since-c23">
<td> <ul><li>decimal real floating-point types: <code>_Decimal32</code>, <code>_Decimal64</code>, <code>_Decimal128</code> </li></ul>  </td> <td><span class="t-mark-rev t-since-c23">(since C23)</span></td>
</tr> <tr class="t-rev t-since-c99">
<td> <ul>
<li>complex types: <code>float _Complex</code>, <code>double _Complex</code>, <code>long double _Complex</code> </li>
<li>imaginary types: <code>float _Imaginary</code>, <code>double _Imaginary</code>, <code>long double _Imaginary</code> </li>
</ul>  </td> <td><span class="t-mark-rev t-since-c99">(since C99)</span></td>
</tr> </table> <ul>
<li> <a href="enum" title="c/language/enum">enumerated types</a> </li>
<li> derived types </li>
<ul>
<li> <a href="array" title="c/language/array">array types</a> </li>
<li> <a href="struct" title="c/language/struct">structure types</a> </li>
<li> <a href="union" title="c/language/union">union types</a> </li>
<li> <a href="functions" title="c/language/functions">function types</a> </li>
<li> <a href="pointer" title="c/language/pointer">pointer types</a> </li>
</ul>
</ul>   <table class="t-rev-begin"> <tr class="t-rev t-since-c11">
<td> <ul><li> <a href="atomic" title="c/language/atomic">atomic types</a> </li></ul> </td> <td><span class="t-mark-rev t-since-c11">(since C11)</span></td>
</tr> </table> <p>For every type listed above several qualified versions of its type may exist, corresponding to the combinations of one, two, or all three of the <a href="const" title="c/language/const"><code>const</code></a>, <a href="volatile" title="c/language/volatile"><code>volatile</code></a>, and <a href="restrict" title="c/language/restrict"><code>restrict</code></a> qualifiers (where allowed by the qualifier's semantics).</p>
<h4 id="Type_groups"> Type groups</h4> <ul>
<li> <i>object types</i>: all types that aren't function types </li>
<li> <i>character types</i>: <code>char</code>, <code>signed char</code>, <code>unsigned char</code> </li>
<li> <i>integer types</i>: <code>char</code>, signed integer types, unsigned integer types, enumerated types </li>
<li> <i>real types</i>: integer types and real floating types </li>
<li> <a href="arithmetic_types" title="c/language/arithmetic types">arithmetic types</a>: integer types and floating types </li>
<li> <i>scalar types</i>: arithmetic types, pointer types<span class="t-rev-inl t-since-c23"><span>, and <code><a href="../types/nullptr_t" title="c/types/nullptr t">nullptr_t</a></code></span> <span><span class="t-mark-rev t-since-c23">(since C23)</span></span></span> </li>
<li> <i>aggregate types</i>: array types and structure types </li>
<li> <i>derived declarator types</i>: array types, function types, and pointer types </li>
</ul> <h3 id="Compatible_types"> Compatible types</h3> <p>In a C program, the declarations referring to the same object or function in <i>different translation units</i> do not have to use the same type. They only have to use sufficiently similar types, formally known as <i>compatible types</i>. Same applies to function calls and lvalue accesses; argument types must be <i>compatible</i> with parameter types and lvalue expression type must be <i>compatible</i> with the object type that is accessed.</p>
<p>The types <code>T</code> and <code>U</code> are compatible, if.</p>
<ul>
<li> they are the same type (same name or aliases introduced by a <a href="typedef" title="c/language/typedef">typedef</a>) </li>
<li> they are identically cvr-qualified versions of compatible unqualified types </li>
<li> they are pointer types and are pointing to compatible types </li>
<li> they are array types, and </li>
<ul>
<li> their element types are compatible, and </li>
<li> if both have constant size, that size is the same. Note: arrays of unknown bound are compatible with any array of compatible element type. <span class="t-rev-inl t-since-c99"><span>VLA is compatible with any array of compatible element type.</span> <span><span class="t-mark-rev t-since-c99">(since C99)</span></span></span> </li>
</ul>
<li> they are both structure/union/enumeration types, and </li>
<li>
<span class="t-mark-rev t-since-c99">(C99)</span>if one is declared with a tag, the other must also be declared with the same tag. </li>
<li> if both are completed types, their members must correspond exactly in number, be declared with compatible types, and have matching names. </li>
<li> additionally, if they are enumerations, corresponding members must also have the same values. </li>
<li> additionally, if they are structures or unions, </li>
<ul>
<li> Corresponding members must be declared in the same order (structures only) </li>
<li> Corresponding bit fields must have the same widths. </li>
</ul>
<li> one is an enumerated type and the other is that enumeration's underlying type </li>
<li> they are function types, and </li>
<ul>
<li> their return types are compatible </li>
<li> they both use parameter lists, the number of parameters (including the use of the ellipsis) is the same, and the corresponding parameter, after applying array-to-pointer and function-to-pointer type adjustments and after stripping top-level qualifiers, have compatible types </li>
<li> one is an old-style (parameter-less) definition, the other has a parameter list, the parameter list does not use an ellipsis and each parameter is compatible (after function parameter type adjustment) with the corresponding old-style parameter after default argument promotions </li>
<li> one is an old-style (parameter-less) declaration, the other has a parameter list, the parameter list does not use an ellipsis, and all parameters (after function parameter type adjustment) are unaffected by default argument promotions </li>
</ul>
</ul>        <p>The type <code>char</code> is not compatible with <code>signed char</code> and not compatible with <code>unsigned char</code>.</p>
<p>If two declarations refer to the same object or function and do not use compatible types, the behavior of the program is undefined.</p>
<div class="c source-c"><pre data-language="c">// Translation Unit 1
struct S {int a;};
extern struct S *x;  // compatible with TU2's x, but not with TU3's x
// Translation Unit 2
struct S;
extern struct S *x; // compatible with both x's
// Translation Unit 3
struct S {float a;};
extern struct S *x; // compatible with TU2's x, but not with TU1's x
 
// the behavior is undefined</pre></div> <div class="c source-c"><pre data-language="c">// Translation Unit 1
#include &lt;stdio.h&gt;
struct s {int i;}; // compatible with TU3's s, but not TU2's
extern struct s x = {0}; // compatible with TU3's x
extern void f(void); // compatible with TU2's f
int main()
{
   f();
   return x.i;
}
// Translation Unit 2
struct s {float f;}; // compatible with TU4's s, but not TU1's s
extern struct s y = {3.14}; // compatible with TU4's y
void f() // compatible with TU1's f
{
   return;
}
// Translation Unit 3
struct s {int i;}; // compatible with TU1's s, but not TU2's s
extern struct s x; // compatible with TU1's x
// Translation Unit 4
struct s {float f;}; // compatible with TU2's s, but not TU1's s
extern struct s y; // compatible with TU2's y
 
// the behavior is well-defined: only multiple declarations
// of objects and functions must have compatible types, not the types themselves</pre></div> <p>Note: C++ has no concept of compatible types. A C program that declares two types that are compatible but not identical in different translation units is not a valid C++ program.</p>
<h3 id="Composite_types"> Composite types</h3> <p>A composite type can be constructed from two types that are compatible; it is a type that is compatible with both of the two types and satisfies the following conditions:</p>
<ul>
<li>If both types are array types, the following rules are applied: </li>
<ul><li>If one type is an array of known constant size, the composite type is an array of that size. </li></ul>
</ul>  <table class="t-rev-begin"> <tr class="t-rev t-since-c99">
<td> <ul>
<li>Otherwise, if one type is a VLA whose size is specified by an expression that is not evaluated, the behavior is undefined. </li>
<li>Otherwise, if one type is a VLA whose size is specified, the composite type is a VLA of that size. </li>
<li>Otherwise, if one type is a VLA of unspecified size, the composite type is a VLA of unspecified size. </li>
</ul> </td> <td><span class="t-mark-rev t-since-c99">(since C99)</span></td>
</tr> </table> <ul>
<li>Otherwise, both types are arrays of unknown size and the composite type is an array of unknown size. </li>
<li>If only one type is a function type with a parameter type list (a function prototype), the composite type is a function prototype with the parameter type list. </li>
<li>If both types are function types with parameter type lists, the type of each parameter in the composite parameter type list is the composite type of the corresponding parameters. </li>
</ul> The element type of the composite type is the composite type of the two element types.    <p>These rules apply recursively to the types from which the two types are derived.</p>
<div class="c source-c"><pre data-language="c">// Given the following two file scope declarations:
int f(int (*)(), double (*)[3]);
int f(int (*)(char *), double (*)[]);
// The resulting composite type for the function is:
int f(int (*)(char *), double (*)[3]);</pre></div> <p>For an identifier with internal or external <a href="storage_duration" title="c/language/storage duration">linkage</a> declared in a scope in which a prior declaration of that identifier is visible, if the prior declaration specifies internal or external linkage, the type of the identifier at the later declaration becomes the composite type.</p>
<h3 id="Incomplete_types"> Incomplete types</h3> <p>An incomplete type is an object type that lacks sufficient information to determine the size of the objects of that type. An incomplete type may be completed at some point in the translation unit.</p>
<p>The following types are incomplete:</p>
<ul>
<li> the type <code>void</code>. This type cannot be completed. </li>
<li> array type of unknown size. It can be completed by a later declaration that specifies the size. </li>
</ul> <div class="c source-c"><pre data-language="c">extern char a[]; // the type of a is incomplete (this typically appears in a header)
char a[10];      // the type of a is now complete (this typically appears in a source file)</pre></div> <ul><li> structure or union type of unknown content. It can be completed by a declaration of the same structure or union that defines its content later in the same scope. </li></ul> <div class="c source-c"><pre data-language="c">struct node {
  struct node *next; // struct node is incomplete at this point
}; // struct node is complete at this point</pre></div> <h3 id="Type_names"> Type names</h3> <p>A type may have to be named in context other than the <a href="declarations" title="c/language/declarations">declaration</a>. In these situations, <i>type name</i> is used, which is, grammatically, exactly the same as a list of <i>type-specifiers</i> and <i>type-qualifiers</i>, followed by the <i>declarator</i> (see <a href="declarations" title="c/language/declarations">declarations</a>) as would be used to declare a single object or function of this type, except that the identifier is omitted:</p>
<div class="c source-c"><pre data-language="c">int n; // declaration of an int
sizeof(int); // use of type name
 
int *a[3]; // declaration of an array of 3 pointers to int
sizeof(int *[3]); // use of type name
 
int (*p)[3]; // declaration of a pointer to array of 3 int
sizeof(int (*)[3]); // use of type name
 
int (*a)[*] // declaration of pointer to VLA (in a function parameter)
sizeof(int (*)[*]) // use of type name (in a function parameter)
 
int *f(void); // declaration of function
sizeof(int *(void)); // use of type name
 
int (*p)(void); // declaration of pointer to function
sizeof(int (*)(void)); // use of type name
 
int (*const a[])(unsigned int, ...) = {0}; // array of pointers to functions
sizeof(int (*const [])(unsigned int, ...)); // use of type name</pre></div> <p>Except the redundant parentheses around the identifier are meaningful in a type-name and represent "function with no parameter specification":</p>
<div class="c source-c"><pre data-language="c">int (n); // declares n of type int
sizeof(int ()); // uses type "function returning int"</pre></div> <p>Type names are used in the following situations:</p>
<ul>
<li> <a href="cast" title="c/language/cast">cast</a> </li>
<li> <a href="sizeof" title="c/language/sizeof">sizeof</a> </li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-since-c99">
<td> <ul><li> <a href="compound_literal" title="c/language/compound literal">compound literal</a> </li></ul> </td> <td><span class="t-mark-rev t-since-c99">(since C99)</span></td>
</tr> <tr class="t-rev t-since-c11">
<td> <ul>
<li> <a href="generic" title="c/language/generic">generic selection</a> </li>
<li> <a href="_alignof" title="c/language/ Alignof">_Alignof</a> </li>
<li> <a href="_alignas" title="c/language/ Alignas">_Alignas</a> </li>
<li> <a href="atomic" title="c/language/atomic">_Atomic</a> (when used as a type specifier) </li>
</ul> </td> <td><span class="t-mark-rev t-since-c11">(since C11)</span></td>
</tr> </table> <p><br> A type name may introduce a new type:</p>
<div class="c source-c"><pre data-language="c">void* p = (void*)(struct X {int i;} *)0;
// type name "struct X {int i;}*" used in the cast expression
// introduces the new type "struct X"
struct X x = {1}; // struct X is now in scope</pre></div> <h3 id="References"> References</h3>  <ul>
<li> C17 standard (ISO/IEC 9899:2018): </li>
<ul>
<li> 6.2.5 Types (p: 31-33) </li>
<li> 6.2.6 Representations of types (p: 31-35) </li>
<li> 6.2.7 Compatible type and composite type (p: 35-36) </li>
</ul>
<li> C11 standard (ISO/IEC 9899:2011): </li>
<ul>
<li> 6.2.5 Types (p: 39-43) </li>
<li> 6.2.6 Representations of types (p: 44-46) </li>
<li> 6.2.7 Compatible type and composite type (p: 47-48) </li>
</ul>
<li> C99 standard (ISO/IEC 9899:1999): </li>
<ul>
<li> 6.2.5 Types (p: 33-37) </li>
<li> 6.2.6 Representations of types (p: 37-40) </li>
<li> 6.2.7 Compatible type and composite type (p: 40-41) </li>
</ul>
<li> C89/C90 standard (ISO/IEC 9899:1990): </li>
<ul>
<li> 3.1.2.5 Types </li>
<li> 3.1.2.6 Compatible type and composite type </li>
</ul>
</ul>                      <h3 id="See_also"> See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td colspan="2"> <span><a href="https://en.cppreference.com/w/cpp/language/type" title="cpp/language/type">C++ documentation</a></span> for <span class=""><span>Type</span></span> </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    Â© cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/c/language/compatible_type" class="_attribution-link">https://en.cppreference.com/w/c/language/compatible_type</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
