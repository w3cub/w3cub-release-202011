
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Implicit Conversions - C - W3cubDocs</title>
  
  <meta name="description" content=" When an expression is used in the context where a value of a different type is expected, conversion may occur&#58; ">
  <meta name="keywords" content="implicit, conversions, c">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/c/language/conversion.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/c.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/c/" class="_nav-link" title="" style="margin-left:0;">C</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _c">
				
				
<h1 id="firstHeading" class="firstHeading">Implicit conversions</h1>            <p>When an expression is used in the context where a value of a different type is expected, <i>conversion</i> may occur:</p>
<div class="c source-c"><pre data-language="c">int n = 1L; // expression 1L has type long, int is expected
n = 2.1; // expression 2.1 has type double, int is expected
char *p = malloc(10); // expression malloc(10) has type void*, char* is expected</pre></div> <p>Conversions take place in the following situations:</p>
<h3 id="Conversion_as_if_by_assignment">Conversion as if by assignment</h3> <ul>
<li> In the <a href="operator_assignment" title="c/language/operator assignment">assignment</a> operator, the value of the right-hand operand is converted to the unqualified type of the left-hand operand. </li>
<li> In <a href="scalar_initialization" title="c/language/scalar initialization">scalar initialization</a>, the value of the initializer expression is converted to the unqualified type of the object being initialized </li>
<li> In a <a href="operator_other" title="c/language/operator other">function-call expression</a>, to a function that has a prototype, the value of each argument expression is converted to the type of the unqualified declared types of the corresponding parameter </li>
<li> In a <a href="return" title="c/language/return">return statement</a>, the value of the operand of <code>return</code> is converted to an object having the return type of the function </li>
</ul> <p>Note that actual assignment, in addition to the conversion, also removes extra range and precision from floating-point types and prohibits overlaps; those characteristics do not apply to conversion as if by assignment.</p>
<h3 id="Default_argument_promotions">Default argument promotions</h3> <p>In a <a href="operator_other#Function_call" title="c/language/operator other">function call expression</a> when the call is made to.</p>
<div class="t-li1">
<span class="t-li">1)</span> a <a href="function_declaration" title="c/language/function declaration">function without a prototype</a>
</div> <div class="t-li1">
<span class="t-li">2)</span> a <a href="variadic" title="c/language/variadic">variadic function</a>, where the argument expression is one of the trailing arguments that are matched against the ellipsis parameter</div> <p>Each argument of integer type undergoes <i>integer promotion</i> (see below), and each argument of type <code>float</code> is implicitly converted to the type <code>double</code>.</p>
<div class="c source-c"><pre data-language="c">int add_nums(int count, ...);
int sum = add_nums(2, 'c', true); // add_nums is called with three ints: (2, 99, 1)</pre></div> <p>Note that <code><span class="kw4">float</span> <a href="../numeric/complex/complex"><span class="kw743">complex</span></a></code> and <code><span class="kw4">float</span> <a href="../numeric/complex/imaginary"><span class="kw745">imaginary</span></a></code> are not promoted to <code><span class="kw4">double</span> <a href="../numeric/complex/complex"><span class="kw743">complex</span></a></code> and <code><span class="kw4">double</span> <a href="../numeric/complex/imaginary"><span class="kw745">imaginary</span></a></code> in this context.</p>
<h3 id="Usual_arithmetic_conversions">Usual arithmetic conversions</h3> <p>The arguments of the following arithmetic operators undergo implicit conversions for the purpose of obtaining the <i>common real type</i>, which is the type in which the calculation is performed:</p>
<ul>
<li> <a href="operator_arithmetic" title="c/language/operator arithmetic">binary arithmetic</a> *, /, %, +, - </li>
<li> <a href="operator_comparison" title="c/language/operator comparison">relational operators</a> &lt;, &gt;, &lt;=, &gt;=, ==, != </li>
<li> <a href="operator_arithmetic" title="c/language/operator arithmetic">binary bitwise arithmetic</a> &amp;, ^, |, </li>
<li> the <a href="operator_other" title="c/language/operator other">conditional operator</a> ?: </li>
</ul> <div class="t-li1">
<span class="t-li">1)</span> If one operand is <code>long double</code>, <code><span class="kw4">long</span> <span class="kw4">double</span> <a href="../numeric/complex/complex"><span class="kw743">complex</span></a></code>, or <code><span class="kw4">long</span> <span class="kw4">double</span> <a href="../numeric/complex/imaginary"><span class="kw745">imaginary</span></a></code>, the other operand is implicitly converted as follows: <ul>
<li>integer or real floating type to <code>long double</code> </li>
<li>complex type to <code><span class="kw4">long</span> <span class="kw4">double</span> <a href="../numeric/complex/complex"><span class="kw743">complex</span></a></code> </li>
<li>imaginary type to <code><span class="kw4">long</span> <span class="kw4">double</span> <a href="../numeric/complex/imaginary"><span class="kw745">imaginary</span></a></code>
</li>
</ul>
</div> <div class="t-li1">
<span class="t-li">2)</span> Otherwise, if one operand is <code>double</code>, <code><span class="kw4">double</span> <a href="../numeric/complex/complex"><span class="kw743">complex</span></a></code>, or <code><span class="kw4">double</span> <a href="../numeric/complex/imaginary"><span class="kw745">imaginary</span></a></code>, the other operand is implicitly converted as follows: <ul>
<li>integer or real floating type to <code>double</code> </li>
<li>complex type to <code><span class="kw4">double</span> <a href="../numeric/complex/complex"><span class="kw743">complex</span></a></code> </li>
<li>imaginary type to <code><span class="kw4">double</span> <a href="../numeric/complex/imaginary"><span class="kw745">imaginary</span></a></code>
</li>
</ul>
</div> <div class="t-li1">
<span class="t-li">3)</span> Otherwise, if one operand is <code>float</code>, <code><span class="kw4">float</span> <a href="../numeric/complex/complex"><span class="kw743">complex</span></a></code>, or <code><span class="kw4">float</span> <a href="../numeric/complex/imaginary"><span class="kw745">imaginary</span></a></code>, the other operand is implicitly converted as follows: <ul>
<li>integer type to <code>float</code> (the only real type possible is float, which remains as-is) </li>
<li>complex type remains <code><span class="kw4">float</span> <a href="../numeric/complex/complex"><span class="kw743">complex</span></a></code> </li>
<li>imaginary type remains <code><span class="kw4">float</span> <a href="../numeric/complex/imaginary"><span class="kw745">imaginary</span></a></code>
</li>
</ul>
</div> <div class="t-li1">
<span class="t-li">4)</span> Otherwise, both operands are integers. In that case, First of all, both operands undergo <i>integer promotions</i> (see below). Then <ul>
<li> If the types after promotion are the same, that type is the common type </li>
<li> Otherwise, if both operands after promotion have the same signedness (both signed or both unsigned), the operand with the lesser <i>conversion rank</i> (see below) is implicitly converted to the type of the operand with the greater <i>conversion rank</i> </li>
<li> Otherwise, the signedness is different: If the operand with the unsigned type has <i>conversion rank</i> greater or equal than the rank of the type of the signed operand, then the operand with the signed type is implicitly converted to the unsigned type </li>
<li> Otherwise, the signedness is different and the signed operand's rank is greater than unsigned operand's rank. In this case, if the signed type can represent all values of the unsigned type, then the operand with the unsigned type is implicitly converted to the type of the signed operand. </li>
<li> Otherwise, both operands undergo implicit conversion to the unsigned type counterpart of the signed operand's type. </li>
</ul>  <div class="c source-c"><pre data-language="c">1.f + 20000001; // int is converted to float, giving 20000000.00
                // addition and then rounding to float gives 20000000.00
(char)'a' + 1L; // First, char is promoted back to int.
                // this is signed + signed case, different rank
                // int is converted to long, the result is 98 signed long
2u - 10; // signed / unsigned, same rank
         // 10 is converted to unsigned, unsigned math is modulo UINT_MAX+1
         // for 32 bit ints, result is 4294967288 of type unsigned int (aka UINT_MAX-7)
0UL - 1LL; // signed/unsigned diff rank, rank of signed is greater.
           // If sizeof(long) == sizeof(long long), signed cannot represent all unsigned
           // this is the last case: both operands are converted to unsigned long long
           // the result is 18446744073709551615 (ULLONG_MAX) of type unsigned long long</pre></div>
</div> <p>The result type is determined as follows:</p>
<ul>
<li> if both operands are complex, the result type is complex </li>
<li> if both operands are imaginary, the result type is imaginary </li>
<li> if both operands are real, the result type is real </li>
<li> if the two floating-point operands have different type domains (complex vs. real, complex vs imaginary, or imaginary vs. real), the result type is complex </li>
</ul> <div class="c source-c"><pre data-language="c">double complex z = 1 + 2*I;
double f = 3.0;
z + f; // z remains as-is, f is converted to double, the result is double complex</pre></div> <p>As always, the result of a floating-point operator may have greater range and precision than is indicated by its type (see <code><a href="../types/limits/flt_eval_method" title="c/types/limits/FLT EVAL METHOD">FLT_EVAL_METHOD</a></code>).</p>
<p>Note: real and imaginary operands are not implicitly converted to complex because doing so would require extra computation, while producing undesirable results in certain cases involving infinities, NaNs and signed zeros. For example, if reals were converted to complex, 2.0×(3.0+i∞) would evaluate as (2.0+i0.0)×(3.0+i∞) ⇒ (2.0×3.0–0.0×∞) + i(2.0×∞+0.0×3.0) ⇒ NaN+i∞ rather than the correct 6.0+i∞. If imaginaries were converted to complex, i2.0×(∞+i3.0) would evaluate as (0.0+i2.0) × (∞+i3.0) ⇒ (0.0×∞ – 2.0×3.0) + i(0.0×3.0 + 2.0×∞) ⇒ NaN + i∞ instead of –6.0 + i∞.</p>
<p>Note: regardless of usual arithmetic conversions, the calculation may always be performed in a narrower type than specifier by these rules under the <a href="https://en.cppreference.com/mwiki/index.php?title=c/language/as_if&amp;action=edit&amp;redlink=1" class="new" title="c/language/as if (page does not exist)">as-if rule</a>.</p>
<h3 id="Value_transformations">Value transformations</h3> <h4 id="Lvalue_conversion">Lvalue conversion</h4> <p>Any <a href="value_category" title="c/language/value category">lvalue expression</a> of any non-array type, when used in any context other than.</p>
<ul>
<li> as the operand of the <a href="operator_member_access" title="c/language/operator member access">address-of operator</a> (if allowed) </li>
<li> as the operand of the pre/post <a href="operator_incdec" title="c/language/operator incdec">increment and decrement operators</a>. </li>
<li> as the left-hand operand of the <a href="operator_member_access" title="c/language/operator member access">member access</a> (dot) operator. </li>
<li> as the left-hand operand of the <a href="operator_assignment" title="c/language/operator assignment">assignment and compound assignment</a> operators. </li>
<li> as the operand of <a href="sizeof" title="c/language/sizeof">sizeof</a> </li>
</ul> <p>undergoes <i>lvalue conversion</i>: the type remains the same, but loses <a href="const" title="c/language/const">const</a>/<a href="volatile" title="c/language/volatile">volatile</a>/<a href="restrict" title="c/language/restrict">restrict</a>-qualifiers and <a href="atomic" title="c/language/atomic">atomic</a> properties, if any. The value remains the same, but loses its lvalue properties (the address may no longer be taken).</p>
<p>If the lvalue has incomplete type, the behavior is undefined.</p>
<p>If the lvalue designates an object of automatic storage duration whose address was never taken and if that object was uninitialized (not declared with an initializer and no assignment to it has been performed prior to use), the behavior is undefined.</p>
<p>This conversion models the memory load of the value of the object from its location.</p>
<div class="c source-c"><pre data-language="c">volatile int n = 1;
int x = n;            // lvalue conversion on n reads the value of n
volatile int* p = &amp;n; // no lvalue conversion: does not read the value of n</pre></div> <h4 id="Array_to_pointer_conversion">Array to pointer conversion</h4> <p>Any <a href="value_category" title="c/language/value category">lvalue expression</a> of <a href="array" title="c/language/array">array type</a>, when used in any context other than.</p>
<ul>
<li> as the operand of the <a href="operator_member_access" title="c/language/operator member access">address-of operator</a> </li>
<li> as the operand of <a href="sizeof" title="c/language/sizeof">sizeof</a> </li>
<li> as the string literal used for <a href="array_initialization" title="c/language/array initialization">array initialization</a> </li>
</ul> <p>undergoes a conversion to the non-lvalue pointer to its first element.</p>
<p>If the array was declared <a href="storage_duration" title="c/language/storage duration">register</a>, the behavior is undefined.</p>
<div class="c source-c"><pre data-language="c">int a[3], b[3][4];
int* p = a;      // conversion to &amp;a[0]
int (*q)[4] = b; // conversion to &amp;b[0]</pre></div> <h4 id="Function_to_pointer_conversion">Function to pointer conversion</h4> <p>Any function designator expression, when used in any context other than.</p>
<ul>
<li> as the operand of the <a href="operator_member_access" title="c/language/operator member access">address-of operator</a> </li>
<li> as the operand of <a href="sizeof" title="c/language/sizeof">sizeof</a> </li>
</ul> <p>undergoes a conversion to the non-lvalue pointer to the function designated by the expression.</p>
<div class="c source-c"><pre data-language="c">int f(int);
int (*p)(int) = f; // conversion to &amp;f
(***p)(1); // repeated dereference to f and conversion back to &amp;f</pre></div> <h3 id="Implicit_conversion_semantics">Implicit conversion semantics</h3> <p>Implicit conversion, whether <i>as if by assignment</i> or a <i>usual arithmetic conversion</i>, consists of two stages:</p>
<div class="t-li1">
<span class="t-li">1)</span> value transformation (if applicable)</div> <div class="t-li1">
<span class="t-li">2)</span> one of the conversions listed below (if it can produce the target type)</div> <h4 id="Compatible_types">Compatible types</h4> <p>Conversion of a value of any type to any <a href="types#Compatible_types" title="c/language/types" class="mw-redirect">compatible type</a> is always a no-op and does not change the representation.</p>
<div class="c source-c"><pre data-language="c">uint8_t (*a)[10];         // if uint8_t is a typedef to unsigned char
unsigned char (*b)[] = a; // then these pointer types are compatible</pre></div> <h4 id="Integer_promotions">Integer promotions</h4> <p>Integer promotion is the implicit conversion of a value of any integer type with <i>rank</i> less or equal to <i>rank</i> of int or of a <a href="bit_field" title="c/language/bit field">bit field</a> of type _Bool, int, signed int, unsigned int, to the value of type <code>int</code> or <code>unsigned int</code>.</p>
<p>If <code>int</code> can represent the entire range of values of the original type (or the range of values of the original bit field), the value is converted to type <code>int</code>. Otherwise the value is converted to <code>unsigned int</code>.</p>
<p>Integer promotions preserve the value, including the sign:</p>
<div class="c source-c"><pre data-language="c">int main(void) {
   void f(); // old-style function declaration
   char x = 'a'; // integer conversion from int to char
   f(x); // integer promotion from char back to int
}
void f(x) int x; {} // the function expects int</pre></div> <p><i>rank</i> above is a property of every <a href="compatible_type" title="c/language/type">integer type</a> and is defined as follows:</p>
<div class="t-li1">
<span class="t-li">1)</span> the ranks of all signed integer types are different and increase with their precision: rank of signed char &lt; rank of short &lt; rank of int &lt; rank of long int &lt; rank of long long int</div> <div class="t-li1">
<span class="t-li">2)</span> the ranks of all signed integer types equal the ranks of the corresponding unsigned integer types</div> <div class="t-li1">
<span class="t-li">3)</span> the rank of any standard integer type is greater than the rank of any extended integer type of the same size (that is, rank of __int64 &lt; rank of long long int, but rank of long long &lt; rank of __int128 due to the rule <span class="t-v">(1)</span>)</div> <div class="t-li1">
<span class="t-li">4)</span> rank of char equals rank of signed char and rank of unsigned char</div> <div class="t-li1">
<span class="t-li">5)</span> the rank of _Bool is less than the rank of any other standard integer type</div> <div class="t-li1">
<span class="t-li">6)</span> the rank of any enumerated type equals the rank of its compatible integer type</div> <div class="t-li1">
<span class="t-li">7)</span> ranking is transitive: if rank of T1 &lt; rank of T2 and rank of T2 &lt; rank of T3 then rank of T1 &lt; rank of T3</div> <div class="t-li1">
<span class="t-li">8)</span> any aspects of relative ranking of extended integer types not covered above are implementation defined</div> <p>Note: integer promotions are applied only.</p>
<ul>
<li> as part of <i>usual arithmetic conversions</i> (see above) </li>
<li> as part of <i>default argument promotions</i> (see above) </li>
<li> to the operand of the unary arithmetic operators + and - </li>
<li> to the operand of the unary bitwise operator ~ </li>
<li> to both operands of the shift operators &lt;&lt; and &gt;&gt; </li>
</ul> <h4 id="Boolean_conversion">Boolean conversion</h4> <p>A value of any scalar type can be implicitly converted to _Bool. The values that compare equal to zero are converted to <code>​0​</code>, all other values are converted to <code>1</code>.</p>
<div class="c source-c"><pre data-language="c">bool b1 = 0.5;              // b1 == 1 (0.5 converted to int would be zero)
bool b2 = 2.0*_Imaginary_I; // b2 == 1 (but converted to int would be zero)
bool b3 = 0.0 + 3.0*I;      // b3 == 1 (but converted to int would be zero)
bool b4 = 0.0/0.0;          // b4 == 1 (NaN does not compare equal to zero)</pre></div> <h4 id="Integer_conversions">Integer conversions</h4> <p>A value of any integer type can be implicitly converted to any other integer type. Except where covered by promotions and boolean conversions above, the rules are:</p>
<ul>
<li> if the target type can represent the value, the value is unchanged </li>
<li> otherwise, if the target type is unsigned, the value 2<span class="t-su">b<br></span>, where b is the number of bits in the target type, is repeatedly subtracted or added to the source value until the result fits in the target type. In other words, unsigned integers implement modulo arithmetic. </li>
<li> otherwise, if the target type is signed, the behavior is implementation-defined (which may include raising a signal) </li>
</ul> <div class="c source-c"><pre data-language="c">char x = 'a'; // int -&gt; char, result unchanged
unsigned char n = -123456; // target is unsigned, result is 192 (that is, -123456+483*256)
signed char m = 123456;    // target is signed, result is implementation-defined
assert(sizeof(int) &gt; -1);  // assert fails:
                           // operator &gt; requests conversion of -1 to size_t,
                           // target is unsigned, result is SIZE_MAX</pre></div> <h4 id="Real_floating-integer_conversions">Real floating-integer conversions</h4> <p>A finite value of any real floating type can be implicitly converted to any integer type. Except where covered by boolean conversion above, the rules are:</p>
<ul>
<li> The fractional part is discarded (truncated towards zero). </li>
<ul>
<li> If the resulting value can be represented by the target type, that value is used </li>
<li> otherwise, the behavior is undefined </li>
</ul>
</ul>  <div class="c source-c"><pre data-language="c">int n = 3.14; // n == 3
int x = 1e10; // undefined behavior for 32-bit int</pre></div> <p>A value of any integer type can be implicitly converted to any real floating type.</p>
<ul>
<li> if the value can be represented exactly by the target type, it is unchanged </li>
<li> if the value can be represented, but cannot be represented exactly, the result is the nearest higher or the nearest lower value (in other words, rounding direction is implementation-defined), although if IEEE arithmetic is supported, rounding is to nearest. It is unspecified whether <code><a href="../numeric/fenv/fe_exceptions" title="c/numeric/fenv/FE exceptions">FE_INEXACT</a></code> is raised in this case. </li>
<li> if the value cannot be represented, the behavior is undefined, although if IEEE arithmetic is supported, <code><a href="../numeric/fenv/fe_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a></code> is raised and the result value is unspecified. </li>
</ul> <p>The result of this conversion may have greater range and precision than its target type indicates (see <code><a href="../types/limits/flt_eval_method" title="c/types/limits/FLT EVAL METHOD">FLT_EVAL_METHOD</a></code>.</p>
<p>If control over <code><a href="../numeric/fenv/fe_exceptions" title="c/numeric/fenv/FE exceptions">FE_INEXACT</a></code> is needed in floating-to-integer conversions, <code><a href="../numeric/math/rint" title="c/numeric/math/rint">rint</a></code> and <code><a href="../numeric/math/nearbyint" title="c/numeric/math/nearbyint">nearbyint</a></code> may be used.</p>
<div class="c source-c"><pre data-language="c">double d = 10; // d = 10.00
float f = 20000001; // f = 20000000.00 (FE_INEXACT)
float x = 1+(long long)FLT_MAX; // undefined behavior</pre></div> <h4 id="Real_floating_point_conversions">Real floating point conversions</h4> <p>A value of any real floating type can be implicitly converted to any other real floating type.</p>
<ul>
<li> If the value can be represented by the target type exactly, it is unchanged </li>
<li> if the value can be represented, but cannot be represented exactly, the result is the nearest higher or the nearest lower value (in other words, rounding direction is implementation-defined), although if IEEE arithmetic is supported, rounding is to nearest </li>
<li> if the value cannot be represented, the behavior is undefined  </li>
</ul> <p>The result of this conversion may have greater range and precision than its target type indicates (see <code><a href="../types/limits/flt_eval_method" title="c/types/limits/FLT EVAL METHOD">FLT_EVAL_METHOD</a></code>.</p>
<div class="c source-c"><pre data-language="c">double d = 0.1; // d = 0.1000000000000000055511151231257827021181583404541015625
float f = d;    // f = 0.100000001490116119384765625
float x = 2*(double)FLT_MAX; // undefined</pre></div> <h4 id="Complex_type_conversions">Complex type conversions</h4> <p>A value of any complex type can be implicitly converted to any other complex type. The real part and the imaginary part individually follow the conversion rules for the real floating types.</p>
<div class="c source-c"><pre data-language="c">double complex d = 0.1 + 0.1*I;
float complex f = d; // f is (0.100000001490116119384765625, 0.100000001490116119384765625)</pre></div> <h4 id="Imaginary_type_conversions">Imaginary type conversions</h4> <p>A value of any imaginary type can be implicitly converted to any other imaginary type. The imaginary part follows the conversion rules for the real floating types.</p>
<div class="c source-c"><pre data-language="c">double imaginary d = 0.1*_Imaginary_I;
float imaginary f = d; // f is 0.100000001490116119384765625*I</pre></div> <h4 id="Real-complex_conversions">Real-complex conversions</h4> <p>A value of any real floating type can be implicitly converted to any complex type.</p>
<ul>
<li> The real part of the result is determined by the conversion rules for the real floating types </li>
<li> The imaginary part of the result is positive zero (or unsigned zero on non-IEEE systems) </li>
</ul> <p>A value of any complex type can be implicitly converted to any real floating type.</p>
<ul>
<li> The real part is converted following the rules for the real floating types </li>
<li> The imaginary part is discarded </li>
</ul> <p>Note: in complex-to-real conversion, a NaN in the imaginary part will not propagate to the real result.</p>
<div class="c source-c"><pre data-language="c">double complex z = 0.5 + 3*I;
float f = z;  // the imaginary part is discarded, f is set to 0.5
z = f;        // sets z to 0.5 + 0*I</pre></div> <h4 id="Real-imaginary_conversions">Real-imaginary conversions</h4> <p>A value of any imaginary type can be implicitly converted to any real type (integer or floating-point). The result is always a positive (or unsigned) zero, except when the target type is _Bool, in which case boolean conversion rules apply.</p>
<p>A value of any real type can be implicitly converted to any imaginary type. The result is always a positive imaginary zero.</p>
<div class="c source-c"><pre data-language="c">double imaginary z = 3*I;
bool b = z;  // Boolean conversion: sets b to true 
float f = z; // Real-imaginary conversion: sets f to 0.0 
z = 3.14;    // Imaginary-real conversion: sets z to 0*_Imaginary_I</pre></div> <h4 id="Complex-imaginary_conversions">Complex-imaginary conversions</h4> <p>A value of any imaginary type can be implicitly converted to any complex type.</p>
<ul>
<li> The real part of the result is the positive zero </li>
<li> The imaginary part of the result follows the conversion rules for the corresponding real types </li>
</ul> <p>A value of any complex type can be implicitly converted to any imaginary type.</p>
<ul>
<li> The real part is discarded </li>
<li> The imaginary part of the result follows the conversion rules for the corresponding real types </li>
</ul> <div class="c source-c"><pre data-language="c">double imaginary z = I * (3*I); // the complex result -3.0+0i loses real part
                                // sets z to 0*_Imaginary_I</pre></div> <h4 id="Pointer_conversions">Pointer conversions</h4> <p>A pointer to <code>void</code> can be implicitly converted to and from any pointer to object type with the following semantics:</p>
<ul>
<li> If a pointer to object is converted to a pointer to void and back, its value compares equal to the original pointer. </li>
<li> No other guarantees are offered </li>
</ul> <div class="c source-c"><pre data-language="c">int* p = malloc(10 * sizeof(int)); // malloc returns void*</pre></div> <p>A pointer to an unqualified type may be implicitly converted to the pointer to qualified version of that type (in other words, <a href="const" title="c/language/const">const</a>, <a href="volatile" title="c/language/volatile">volatile</a>, and <a href="restrict" title="c/language/restrict">restrict</a> qualifiers can be added. The original pointer and the result compare equal.</p>
<div class="c source-c"><pre data-language="c">int n;
const int* p = &amp;n; // &amp;n has type int*</pre></div> <p>Any integer <a href="constant_expression" title="c/language/constant expression">constant expression</a> with value <code>​0​</code> as well as integer pointer expression with value zero cast to the type <code>void*</code> can be implicitly converted to any pointer type (both pointer to object and pointer to function). The result is the null pointer value of its type, guaranteed to compare unequal to any non-null pointer value of that type. This integer or void* expression is known as <i>null pointer constant</i> and the standard library provides one definition of this constant as the macro <code><a href="../types/null" title="c/types/NULL">NULL</a></code> .</p>
<div class="c source-c"><pre data-language="c">int* p = 0;
double* q = NULL;</pre></div> <h3 id="Notes">Notes</h3> <p>Although signed integer overflow in any arithmetic operator is undefined behavior, overflowing a signed integer type in an integer conversion is merely unspecified behavior.</p>
<p>On the other hand, although unsigned integer overflow in any arithmetic operator (and in integer conversion) is a well-defined operation and follows the rules of modulo arithmetic, overflowing an unsigned integer in a floating-to-integer conversion is undefined behavior: the values of real floating type that can be converted to unsigned integer are the values from the open interval (-1; Unnn_MAX+1).</p>
<div class="c source-c"><pre data-language="c">unsigned int n = -1.0; // undefined behavior</pre></div> <p>Conversions between pointers and integers (except from pointer to _Bool and from integer constant expression with the value zero to pointer), between pointers to objects (except where either to or from is a pointer to void) and conversions between pointers to functions (except when the functions have compatible types) are never implicit and require a <a href="cast" title="c/language/cast">cast operator</a>.</p>
<p>There are no conversions (implicit or explicit) between pointers to functions and pointers to objects (including void*) or integers.</p>
<h3 id="References">References</h3>  <ul>
<li> C11 standard (ISO/IEC 9899:2011): </li>
<ul><li> 6.3 Conversions (p: 50-56) </li></ul>
<li> C99 standard (ISO/IEC 9899:1999): </li>
<ul><li> 6.3 Conversions (p: 42-48) </li></ul>
<li> C89/C90 standard (ISO/IEC 9899:1990): </li>
<ul><li> 3.2 Conversions </li></ul>
</ul>         <h3 id="See_also">See also</h3>            <div class="_attribution">
  <p class="_attribution-p">
    © cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/c/language/conversion" class="_attribution-link">http://en.cppreference.com/w/c/language/conversion</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
