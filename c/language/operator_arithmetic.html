
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Arithmetic Operators - C - W3cubDocs</title>
  
  <meta name="description" content=" Arithmetic operators apply standard mathematical operations to their operands. ">
  <meta name="keywords" content="arithmetic, operators, c">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/c/language/operator_arithmetic.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/c.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/c/" class="_nav-link" title="" style="margin-left:0;">C</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _c">
				
				
<h1 id="firstHeading" class="firstHeading">Arithmetic operators</h1>            <p>Arithmetic operators apply standard mathematical operations to their operands.</p>
<table class="wikitable"> <tr style="text-align:center"> <th> Operator </th> <th> Operator name </th> <th> Example </th> <th> Result </th>
</tr> <tr style="text-align:center"> <td> <code>+</code> </td> <td> unary plus </td> <td> <code>+a</code> </td> <td> the value of <b>a</b> after promotions </td>
</tr> <tr style="text-align:center"> <td> <code>-</code> </td> <td> unary minus </td> <td> <code>-a</code> </td> <td> the negative of <b>a</b> </td>
</tr> <tr style="text-align:center"> <td> <code>+</code> </td> <td> addition </td> <td> <code>a + b</code> </td> <td> the addition of <b>a</b> and <b>b</b> </td>
</tr> <tr style="text-align:center"> <td> <code>-</code> </td> <td> subtraction </td> <td> <code>a - b</code> </td> <td> the subtraction of <b>b</b> from <b>a</b> </td>
</tr> <tr style="text-align:center"> <td> <code>*</code> </td> <td> product </td> <td> <code>a * b</code> </td> <td> the product of <b>a</b> and <b>b</b> </td>
</tr> <tr style="text-align:center"> <td> <code>/</code> </td> <td> division </td> <td> <code>a / b</code> </td> <td> the division of <b>a</b> by <b>b</b> </td>
</tr> <tr style="text-align:center"> <td> <code>%</code> </td> <td> modulo </td> <td> <code>a % b</code> </td> <td> the remainder of <b>a</b> divided by <b>b</b> </td>
</tr> <tr style="text-align:center"> <td> <code>~</code> </td> <td> bitwise NOT </td> <td> <code>~a</code> </td> <td> the bitwise NOT of <b>a</b> </td>
</tr> <tr style="text-align:center"> <td> <code>&amp;</code> </td> <td> bitwise AND </td> <td> <code>a &amp; b</code> </td> <td> the bitwise AND of <b>a</b> and <b>b</b> </td>
</tr> <tr style="text-align:center"> <td> <code>|</code> </td> <td> bitwise OR </td> <td> <code>a | b</code> </td> <td> the bitwise OR of <b>a</b> and <b>b</b> </td>
</tr> <tr style="text-align:center"> <td> <code>^</code> </td> <td> bitwise XOR </td> <td> <code>a ^ b</code> </td> <td> the bitwise XOR of <b>a</b> and <b>b</b> </td>
</tr> <tr style="text-align:center"> <td> <code>&lt;&lt;</code> </td> <td> bitwise left shift </td> <td> <code>a &lt;&lt; b</code> </td> <td> <b>a</b> left shifted by <b>b</b> </td>
</tr> <tr style="text-align:center"> <td> <code>&gt;&gt;</code> </td> <td> bitwise right shift </td> <td> <code>a &gt;&gt; b</code> </td> <td> <b>a</b> right shifted by <b>b</b> </td>
</tr>
</table> <h3 id="Overflows">Overflows</h3> <p>Unsigned integer arithmetic is always performed modulo 2<span class="t-su">n<br></span> where n is the number of bits in that particular integer. E.g. for <code>unsigned int</code>, adding one to <code><a href="../types/limits" title="c/types/limits">UINT_MAX</a></code> gives <code>​0​</code>, and subtracting one from <code>​0​</code> gives <code><a href="../types/limits" title="c/types/limits">UINT_MAX</a></code>.</p>
<p>When signed integer arithmetic operation overflows (the result does not fit in the result type), the behavior is undefined: it may wrap around according to the rules of the representation (typically 2's complement), it may trap on some platforms or due to compiler options (e.g. <code>-ftrapv</code> in GCC and Clang), or may be completely <a rel="nofollow" class="external text" href="http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html">optimized out by the compiler</a>.</p>
<h4 id="Floating-point_environment">Floating-point environment</h4> <p>If <a href="../preprocessor/impl" title="c/preprocessor/impl"><code> #pragma STDC FENV_ACCESS</code></a> is set to <code>ON</code>, all floating-point arithmetic operators obey the current floating-point <a href="../numeric/fenv/fe_round" title="c/numeric/fenv/FE round">rounding direction</a> and report floating-point arithmetic errors as specified in <a href="../numeric/math/math_errhandling" title="c/numeric/math/math errhandling"><code>math_errhandling</code></a> unless part of a <a href="initialization" title="c/language/initialization">static initializer</a> (in which case floating-point exceptions are not raised and the rounding mode is to nearest).</p>
<h4 id="Floating-point_contraction">Floating-point contraction</h4> <p>Unless <a href="../preprocessor/impl" title="c/preprocessor/impl"><code> #pragma STDC FP_CONTRACT</code></a> is set to <code>OFF</code>, all floating-point arithmetic may be performed as if the intermediate results have infinite range and precision, that is optimizations that omit rounding errors and floating-point exceptions that would be observed if the expression was evaluated exactly as written. For example, allows the implementation of <code>(x*y) + z</code> with a single fused multiply-add CPU instruction or optimization of <code>a = x*x*x*x;</code> as <code>tmp = x*x; a = tmp*tmp</code>.</p>
<p>Unrelated to contracting, intermediate results of floating-point arithmetic may have range and precision that is different from the one indicated by its type, see <code><a href="../types/limits/flt_eval_method" title="c/types/limits/FLT EVAL METHOD">FLT_EVAL_METHOD</a></code>.</p>
<h3 id="Unary_arithmetic">Unary arithmetic</h3> <p>The unary arithmetic operator expressions have the form.</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <code>+</code> <span class="t-spar">expression</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>-</code> <span class="t-spar">expression</span> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <div class="t-li1">
<span class="t-li">1)</span> unary plus (promotion)</div> <div class="t-li1">
<span class="t-li">2)</span> unary minus (negation) <p>where.</p>
<table class="t-par-begin"> <tr class="t-par"> <td> <span class="t-spar">expression</span> </td> <td> - </td> <td> expression of any <a href="arithmetic_types" title="c/language/arithmetic types">arithmetic type</a> </td>
</tr>
</table>
</div> <p>Both unary plus and unary minus first apply <a href="conversion" title="c/language/conversion">integral promotions</a> to their operand, and then.</p>
<ul>
<li> unary plus returns the value after promotion </li>
<li> unary minus returns the negative of the value after promotion (except that the negative of a NaN is another NaN) </li>
</ul> <p>The type of the expression is the type after promotion, and the <a href="value_category" title="c/language/value category">value category</a> is non-lvalue.</p>
<h4 id="Notes">Notes</h4> <p>The unary minus invokes undefined behavior due to signed integer overflow when applied to <code><a href="../types/limits" title="c/types/limits">INT_MIN</a></code>, <code><a href="../types/limits" title="c/types/limits">LONG_MIN</a></code>, or <code><a href="../types/limits" title="c/types/limits">LLONG_MIN</a></code>, on typical (2's complement) platforms.</p>
<p>In C++, unary operator + can also be used with other built-in types such as arrays and functions, not so in C.</p>
<div class="t-example"> <div class="c source-c"><pre data-language="c">#include &lt;stdio.h&gt;
#include &lt;complex.h&gt;
int main(void)
{
    char c = 'a';
    printf("sizeof char: %zu sizeof int: %zu\n", sizeof c, sizeof +c);
 
    printf("-1, where 1 is signed: %d\n", -1);
    printf("-1, where 1 is unsigned: %u\n", -1u);
 
    double complex z = 1 + 2*I;
    printf("-(1+2i) = %.1f%+.1f\n", creal(-z), cimag(-z));
}</pre></div> <p>Possible output:</p>
<div class="text source-text"><pre data-language="c">sizeof char: 1 sizeof int: 4
-1, where 1 is signed: -1
-1, where 1 is unsigned: 4294967295
-(1+2i) = -1.0-2.0</pre></div> </div> <h3 id="Additive_operators">Additive operators</h3> <p>The binary additive arithmetic operator expressions have the form.</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">lhs</span> <code>+</code> <span class="t-spar">rhs</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">lhs</span> <code>-</code> <span class="t-spar">rhs</span> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <div class="t-li1">
<span class="t-li">1)</span> addition: <span class="t-spar">lhs</span> and <span class="t-spar">rhs</span> must be one of the following <ul>
<li> both have <a href="arithmetic_types" title="c/language/arithmetic types">arithmetic types</a>, including complex and imaginary </li>
<li> one is a pointer to complete object type, the other has integer type</li>
</ul>
</div> <div class="t-li1">
<span class="t-li">2)</span> subtraction: <span class="t-spar">lhs</span> and <span class="t-spar">rhs</span> must be one of the following <ul>
<li> both have <a href="arithmetic_types" title="c/language/arithmetic types">arithmetic types</a>, including complex and imaginary </li>
<li> <span class="t-spar">lhs</span> has pointer to complete object type, <span class="t-spar">rhs</span> has integer type </li>
<li> both are pointers to complete objects of <a href="compatible_type#Comparible_types" title="c/language/type">compatible</a> types, ignoring qualifiers</li>
</ul>
</div> <h4 id="Arithmetic_addition_and_subtraction">Arithmetic addition and subtraction</h4> <p>If both operands have <a href="arithmetic_types" title="c/language/arithmetic types">arithmetic types</a>, then.</p>
<ul>
<li> first, <a href="conversion#Usual_arithmetic_conversions" title="c/language/conversion">usual arithmetic conversions</a> are performed </li>
<li> then, the values of the operands after conversions are added or subtracted following the usual rules of mathematics (for subtraction, <span class="t-spar">rhs</span> is subtracted from <span class="t-spar">lhs</span>), except that </li>
<ul>
<li> if one operand is NaN, the result is NaN </li>
<li> infinity minus infinity is NaN and <code><a href="../numeric/fenv/fe_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a></code> is raised </li>
<li> infinity plus the negative infinity is NaN and <code><a href="../numeric/fenv/fe_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a></code> is raised </li>
</ul>
</ul>  <p>Complex and imaginary addition and subtraction are defined as follows (note the result type is imaginary if both operands are imaginary and complex if one operand is real and the other imaginary, as specified by the usual arithmetic conversions):</p>
<table class="wikitable"> <tr> <th> + or - </th> <th> u </th> <th> iv </th> <th> u + iv </th>
</tr> <tr> <th> x </th> <td> x ± u </td> <td> x ± iv </td> <td> (x ± u) ± iv </td>
</tr> <tr> <th> iy </th> <td> ±u + iy </td> <td> i(y ± v) </td> <td> ±u + i(y ± v) </td>
</tr> <tr> <th> x + iy </th> <td> (x ± u) + iy </td> <td> x + i(y ± v) </td> <td> (x ± u) + i(y ± v) </td>
</tr>
</table> <div class="t-example"> <div class="c source-c"><pre data-language="c">// work in progress
// note: take part of the c/language/conversion example</pre></div> </div> <h4 id="Pointer_arithmetic">Pointer arithmetic</h4> <ul>
<li> If the pointer <code>P</code> points at an element of an array with index <code>I</code>, then </li>
<ul>
<li> <code>P+N</code> and <code>N+P</code> are pointers that point at an element of the same array with index <code>I+N</code> </li>
<li> <code>P-N</code> is a pointer that points at an element of the same array with index {tt|I-N}} </li>
</ul>
</ul>  <p>The behavior is defined only if both the original pointer and the result pointer are pointing at elements of the same array or one past the end of that array. Note that executing p-1 when p points at the first element of an array is undefined behavior and may fail on some platforms.</p>
<ul>
<li> If the pointer <code>P1</code> points at an element of an array with index <code>I</code> (or one past the end) and <code>P2</code> points at an element of the same array with index <code>J</code> (or one past the end), then </li>
<ul><li> <code>P1-P2</code> has the value equal to <code>J-I</code> and the type <code><a href="../types/ptrdiff_t" title="c/types/ptrdiff t">ptrdiff_t</a></code> (which is a signed integer type, typically half as large as the size of the largest object that can be declared) </li></ul>
</ul>  <p>The behavior is defined only if the result fits in <code><a href="../types/ptrdiff_t" title="c/types/ptrdiff t">ptrdiff_t</a></code>.</p>
<p>For the purpose of pointer arithmetic, a pointer to an object that is not an element of any array is treated as a pointer to the first element of an array of size 1.</p>
<div class="t-example"> <div class="c source-c"><pre data-language="c">// work in progress
int n = 4, m = 3;
int a[n][m];     // VLA of 4 VLAs of 3 ints each
int (*p)[m] = a; // p == &amp;a[0] 
p = p + 1;       // p == &amp;a[1] (pointer arithmetic works with VLAs just the same)
(*p)[2] = 99;    // changes a[1][2]</pre></div> </div> <h3 id="Multiplicative_operators">Multiplicative operators</h3> <p>The binary multiplicative arithmetic operator expressions have the form.</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">lhs</span> <code>*</code> <span class="t-spar">rhs</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">lhs</span> <code>/</code> <span class="t-spar">rhs</span> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">lhs</span> <code>%</code> <span class="t-spar">rhs</span> </td> <td> (3) </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <div class="t-li1">
<span class="t-li">1)</span> multiplication. <span class="t-spar">lhs</span> and <span class="t-spar">rhs</span> must have <a href="arithmetic_types" title="c/language/arithmetic types">arithmetic types</a>
</div> <div class="t-li1">
<span class="t-li">2)</span> division. <span class="t-spar">lhs</span> and <span class="t-spar">rhs</span> must have <a href="arithmetic_types" title="c/language/arithmetic types">arithmetic types</a>
</div> <div class="t-li1">
<span class="t-li">3)</span> remainder. <span class="t-spar">lhs</span> and <span class="t-spar">rhs</span> must have <a href="arithmetic_types" title="c/language/arithmetic types">integer types</a>
</div> <ul><li> first, <a href="conversion#Usual_arithmetic_conversions" title="c/language/conversion">usual arithmetic conversions</a> are performed. Then... </li></ul> <h4 id="Multiplication">Multiplication</h4> <p>The binary operator * performs multiplication of its operands (after usual arithmetic conversions) following the usual arithmetic definitions, except that.</p>
<ul>
<li> if one operand is a NaN, the result is a NaN </li>
<li> multiplication if infinity by zero gives NaN and <code><a href="../numeric/fenv/fe_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a></code> is raised </li>
<li> multiplication of infinity by a nonzero gives infinity (even for complex arguments) </li>
</ul> <p>Because in C, any <a href="arithmetic_types" title="c/language/arithmetic types">complex value</a> with at least one infinite part as an infinity even if its other part is a NaN, the usual arithmetic rules do not apply to complex-complex multiplication. Other combinations of floating operands follow the following table:</p>
<table class="wikitable"> <tr> <th> * </th> <th> u </th> <th> iv </th> <th> u + iv </th>
</tr> <tr> <th> x </th> <td> xu </td> <td> i(xv) </td> <td> (xu) + i(xv) </td>
</tr> <tr> <th> iy </th> <td> i(yu) </td> <td> −yv </td> <td> (−yv) + i(yu) </td>
</tr> <tr> <th> x + iy </th> <td> (xu) + i(yu) </td> <td> (−yv) + i(xv) </td> <td> <i>special rules</i> </td>
</tr>
</table> <p>Besides infinity handling, complex multiplication is not allowed to overflow intermediate results, except when <a href="../preprocessor/impl" title="c/preprocessor/impl"><code> #pragma STDC CX_LIMITED_RANGE</code></a> is set to <code>ON</code>, in which case the value may be calculated as if by (x+iy)×(u+iv) = (xu-yv)+i(yu+xv), as the programmer assumes the responsibility of limiting the range of the operands and dealing with the infinities.</p>
<p>Despite disallowing undue overflow, complex multiplication may raise spurious floating-point exceptions (otherwise it is prohibitively difficult to implement non-overflowing versions).</p>
<div class="t-example"> <div class="c source-c"><pre data-language="c">#include&lt;stdio.h&gt;
#include &lt;stdio.h&gt;
#include &lt;complex.h&gt;
#include &lt;math.h&gt;
int main(void)
{
 
 
// TODO simpler cases, take some from C++
 
 
   double complex z = (1 + 0*I) * (INFINITY + I*INFINITY);
// textbook formula would give
// (1+i0)(∞+i∞) ⇒ (1×∞ – 0×∞) + i(0×∞+1×∞) ⇒ NaN + I*NaN
// but C gives a complex infinity
   printf("%f + i*%f\n", creal(z), cimag(z));
 
// textbook formula would give
// cexp(∞+iNaN) ⇒ exp(∞)×(cis(NaN)) ⇒ NaN + I*NaN
// but C gives  ±∞+i*nan
   double complex y = cexp(INFINITY + I*NAN);
   printf("%f + i*%f\n", creal(y), cimag(y));
 
}</pre></div> <p>Possible output:</p>
<div class="text source-text"><pre data-language="c">inf + i*inf 
inf + i*nan</pre></div> </div> <h4 id="Division">Division</h4> <p>The binary operator / divides the first operand by the second (after usual arithmetic conversions) following the usual arithmetics definitions, except that.</p>
<ul>
<li> when the type after usual arithmetic conversions is an integer type, the result is the algebraic quotient (not a fraction), <span class="t-rev-inl t-until-c99"><span>rounded in implementation-defined direction</span> <span><span class="t-mark">(until C99)</span></span></span><span class="t-rev-inl t-since-c99"><span>truncated towards zero</span> <span><span class="t-mark-rev t-since-c99">(since C99)</span></span></span> </li>
<li> if one operand is a NaN, the result is a NaN </li>
<li> if the first operand is a complex infinity and the second operand is finite, then the </li>
</ul> <p>result of the / operator is a complex infinity.</p>
<ul><li> if the first operand is finite and the second operand is a complex infinity, then the </li></ul> <p>result of the / operator is a zero.</p>
<p>Because in C, any <a href="arithmetic_types" title="c/language/arithmetic types">complex value</a> with at least one infinite part as an infinity even if its other part is a NaN, the usual arithmetic rules do not apply to complex-complex division. Other combinations of floating operands follow the following table:</p>
<table class="wikitable"> <tr> <th> / </th> <th> u </th> <th> iv </th>
</tr> <tr> <th> x </th> <td> x/u </td> <td> i(−x/v) </td>
</tr> <tr> <th> iy </th> <td> i(y/u) </td> <td> y/v </td>
</tr> <tr> <th> x + iy </th> <td> (x/u) + i(y/u) </td> <td> (y/v) + i(−x/v) </td>
</tr>
</table> <p>Besides infinity handling, complex division is not allowed to overflow intermediate results, except when <a href="../preprocessor/impl" title="c/preprocessor/impl"><code> #pragma STDC CX_LIMITED_RANGE</code></a> is set to <code>ON</code>, in which case the value may be calculated as if by (x+iy)/(u+iv) = [(xu+yv)+i(yu-xv)]/(u<span class="t-su">2<br></span>+v<span class="t-su">2<br></span>), as the programmer assumes the responsibility of limiting the range of the operands and dealing with the infinities.</p>
<p>Despite disallowing undue overflow, complex division may raise spurious floating-point exceptions (otherwise it is prohibitively difficult to implement non-overflowing versions).</p>
<p>If the second operand is zero, the behavior is undefined, except that if the IEEE floating-point arithmetic is supported, and the floating-point division is taking place, then.</p>
<ul>
<li> Dividing a non-zero number by ±0.0 gives the correctly-signed infinity and <code><a href="../numeric/fenv/fe_exceptions" title="c/numeric/fenv/FE exceptions">FE_DIVBYZERO</a></code> is raised </li>
<li> Dividing 0.0 by 0.0 gives NaN and <code><a href="../numeric/fenv/fe_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a></code> is raised </li>
</ul> <h4 id="Remainder">Remainder</h4> <p>The binary operator % yields the remainder of the division of the first operand by the second (after usual arithmetic conversions).</p>
<p>The sign of the remainder is defined in such a way that if the quotient <code>a/b</code> is representable in the result type, then <code>(a/b)*b + a%b == a</code>.</p>
<p>If the second operand is zero, the behavior is undefined.</p>
<p>If the quotient <code>a/b</code> is not representable in the result type, the behavior of both <code>a/b</code> and <code>a%b</code> is undefined (that means <code>INT_MIN%-1</code> is undefined on 2's complement systems).</p>
<p>Note: the remainder operator does not work on floating-point types, the library function <code><a href="../numeric/math/fmod" title="c/numeric/math/fmod">fmod</a></code> provides that functionality.</p>
<h3 id="Bitwise_logic">Bitwise logic</h3> <p>The bitwise arithmetic operator expressions have the form.</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <code>~</code> <span class="t-spar">rhs</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">lhs</span> <code>&amp;</code> <span class="t-spar">rhs</span> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">lhs</span> <code>|</code> <span class="t-spar">rhs</span> </td> <td> (3) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">lhs</span> <code>^</code> <span class="t-spar">rhs</span> </td> <td> (4) </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <div class="t-li1">
<span class="t-li">1)</span> bitwise NOT</div> <div class="t-li1">
<span class="t-li">2)</span> bitwise AND</div> <div class="t-li1">
<span class="t-li">3)</span> bitwise OR</div> <div class="t-li1">
<span class="t-li">4)</span> bitwise XOR <p>where.</p>
<table class="t-par-begin"> <tr class="t-par"> <td> <span class="t-spar">lhs</span>, <span class="t-spar">rhs</span> </td> <td> - </td> <td> expressions of integer type </td>
</tr>
</table>
</div> <p>First, operators &amp;, ^, and | perform <a href="conversion#Usual_arithmetic_conversions" title="c/language/conversion">usual arithmetic conversions</a> on both operands and the operator ~ performs <a href="conversion#Integer_promotions" title="c/language/conversion">integer promotions</a> on its only operand.</p>
<p>Then, the corresponding binary logic operators are applied bitwise; that is, each bit of the result is set or cleared according to the logic operation (NOT, AND, OR, or XOR), applied to the corresponding bits of the operands.</p>
<p>Note: bitwise operators are commonly used to manipulate bit sets and bit masks.</p>
<p>Note: for unsigned types (after promotion), the expression ~E is equivalent to the maximum value representable by the result type minus the original value of E.</p>
<div class="t-example"> <div class="c source-c"><pre data-language="c">#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
int main(void)
{
    uint16_t mask = 0x00f0;
    uint32_t a = 0x12345678;
    printf("Value: %#x mask: %#x\n"
           "Setting bits:   %#x\n"
           "Clearing bits:  %#x\n"
           "Selecting bits: %#x\n",
           a,mask,(a|mask),(a&amp;~mask),(a&amp;mask));
}</pre></div> <p>Possible output:</p>
<div class="text source-text"><pre data-language="c">Value: 0x12345678 mask: 0xf0
Setting bits:   0x123456f8
Clearing bits:  0x12345608
Selecting bits: 0x70</pre></div> </div> <h3 id="Shift_operators">Shift operators</h3> <p>The bitwise shift operator expressions have the form.</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">lhs</span> <code>&lt;&lt;</code> <span class="t-spar">rhs</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">lhs</span> <code>&gt;&gt;</code> <span class="t-spar">rhs</span> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <div class="t-li1">
<span class="t-li">1)</span> left shift of <span class="t-spar">lhs</span> by <span class="t-spar">rhs</span> bits</div> <div class="t-li1">
<span class="t-li">2)</span> right shift of <span class="t-spar">lhs</span> by <span class="t-spar">rhs</span> bits <p>where.</p>
<table class="t-par-begin"> <tr class="t-par"> <td> <span class="t-spar">lhs</span>, <span class="t-spar">rhs</span> </td> <td> - </td> <td> expressions of integer type </td>
</tr>
</table>
</div> <p>First, <a href="conversion" title="c/language/conversion">integer promotions</a> are performed, individually, on each operand (Note: this is unlike other binary arithmetic operators, which all perform usual arithmetic conversions). The type of the result is the type of <span class="t-spar">lhs</span> after promotion.</p>
<p>For unsigned <span class="t-spar">lhs</span>, the value of <code>LHS &lt;&lt; RHS</code> is the value of LHS * 2<span class="t-su">RHS<br></span>, reduced modulo maximum value of the return type plus 1 (that is, bitwise left shift is performed and the bits that get shifted out of the destination type are discarded). For signed <span class="t-spar">lhs</span> with nonnegative values, the value of <code>LHS &lt;&lt; RHS</code> is LHS * 2<span class="t-su">RHS<br></span> if it is representable in the promoted type of <span class="t-spar">lhs</span>, otherwise the behavior is undefined.</p>
<p>For unsigned <span class="t-spar">lhs</span> and for signed <span class="t-spar">lhs</span> with nonnegative values, the value of <code>LHS &gt;&gt; RHS</code> is the integer part of LHS / 2<span class="t-su">RHS<br></span>. For negative <code>LHS</code>, the value of <code>LHS &gt;&gt; RHS</code> is implementation-defined where in most implementations, this performs arithmetic right shift (so that the result remains negative). Thus in most implementations, right shifting a signed <code>LHS</code> fills the new higher-order bits with the original sign bit (i.e. with 0 if it was non-negative and 1 if it was negative).</p>
<p>In any case, the behavior is undefined if <span class="t-spar">rhs</span> is negative or is greater or equal the number of bits in the promoted <span class="t-spar">lhs</span>.</p>
<div class="t-example"> <div class="c source-c"><pre data-language="c">#include &lt;stdio.h&gt;
enum {ONE=1, TWO=2};
int main(void)
{
    char c = 0x10;
    unsigned long long ulong_num = 0x123;
    printf("0x123 &lt;&lt; 1  = %#llx\n"
           "0x123 &lt;&lt; 63 = %#llx\n"   // overflow truncates high bits for unsigned numbers
           "0x10  &lt;&lt; 10 = %#x\n",    // char is promoted to int
           ulong_num &lt;&lt; 1, ulong_num &lt;&lt; 63, c &lt;&lt; 10);
    long long long_num = -1000;
    printf("-1000 &gt;&gt; 1 = %lld\n", long_num &gt;&gt; ONE);  // implementation defined
}</pre></div> <p>Possible output:</p>
<div class="text source-text"><pre data-language="c">0x123 &lt;&lt; 1  = 0x246
0x123 &lt;&lt; 63 = 0x8000000000000000
0x10  &lt;&lt; 10 = 0x4000
-1000 &gt;&gt; 1 = -500</pre></div> </div> <h3 id="References">References</h3>  <ul>
<li> C11 standard (ISO/IEC 9899:2011): </li>
<ul>
<li> 6.5.3.3 Unary arithmetic operators (p: 89) </li>
<li> 6.5.5 Multiplicative operators (p: 92) </li>
<li> 6.5.6 Additive operators (p: 92-94) </li>
<li> 6.5.7 Bitwise shift operators (p: 94-95) </li>
<li> 6.5.10 Bitwise AND operator (p: 97) </li>
<li> 6.5.11 Bitwise exclusive OR operator (p: 98) </li>
<li> 6.5.12 Bitwise inclusive OR operator (p: 98) </li>
</ul>
<li> C99 standard (ISO/IEC 9899:1999): </li>
<ul>
<li> 6.5.3.3 Unary arithmetic operators (p: 79) </li>
<li> 6.5.5 Multiplicative operators (p: 82) </li>
<li> 6.5.6 Additive operators (p: 82-84) </li>
<li> 6.5.7 Bitwise shift operators (p: 84-85) </li>
<li> 6.5.10 Bitwise AND operator (p: 87) </li>
<li> 6.5.11 Bitwise exclusive OR operator (p: 88) </li>
<li> 6.5.12 Bitwise inclusive OR operator (p: 88) </li>
</ul>
<li> C89/C90 standard (ISO/IEC 9899:1990): </li>
<ul>
<li> 3.3.3.3 Unary arithmetic operators </li>
<li> 3.3.5 Multiplicative operators </li>
<li> 3.3.6 Additive operators </li>
<li> 3.3.7 Bitwise shift operators </li>
<li> 3.3.10 Bitwise AND operator </li>
<li> 3.3.11 Bitwise exclusive OR operator </li>
<li> 3.3.12 Bitwise inclusive OR operator </li>
</ul>
</ul>                           <h3 id="See_also">See also</h3> <p><a href="operator_precedence" title="c/language/operator precedence">Operator precedence</a>.</p>
<table class="wikitable"> <tr style="text-align:center"> <th colspan="7"> Common operators </th>
</tr> <tr style="text-align:center"> <td> <a href="operator_assignment" title="c/language/operator assignment"> assignment</a> </td> <td> <a href="operator_incdec" title="c/language/operator incdec"> increment<br>decrement</a> </td> <td> <strong class="selflink"> arithmetic</strong> </td> <td> <a href="operator_logical" title="c/language/operator logical"> logical</a> </td> <td> <a href="operator_comparison" title="c/language/operator comparison"> comparison</a> </td> <td> <a href="operator_member_access" title="c/language/operator member access"> member<br>access</a> </td> <td> <a href="operator_other" title="c/language/operator other"> other</a> </td>
</tr> <tr style="text-align:center"> <td> <p><code>a = b a += b a -= b a *= b a /= b a %= b a &amp;= b a |= b a ^= b a &lt;&lt;= b a &gt;&gt;= b</code>.</p>
</td> <td> <p><code>++a --a a++ a--</code></p>
</td> <td> <p><code>+a -a a + b a - b a * b a / b a % b ~a a &amp; b a | b a ^ b a &lt;&lt; b a &gt;&gt; b</code>.</p>
</td> <td> <p><code>!a a &amp;&amp; b a || b</code>.</p>
</td> <td> <p><code>a == b a != b a &lt; b a &gt; b a &lt;= b a &gt;= b</code>.</p>
</td> <td> <p><code>a[b] *a &amp;a a-&gt;b a.b</code>.</p>
</td> <td> <p><code>a(...) a, b (type) a ? : sizeof _Alignof</code> <span class="t-mark-rev t-since-c11">(since C11)</span>.</p>
</td>
</tr> </table>            <div class="_attribution">
  <p class="_attribution-p">
    © cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/c/language/operator_arithmetic" class="_attribution-link">http://en.cppreference.com/w/c/language/operator_arithmetic</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
