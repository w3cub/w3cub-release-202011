
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Encoding&#47;xml - Go - W3cubDocs</title>
  
  <meta name="description" content=" Package xml implements a simple XML 1.0 parser that understands XML name spaces. ">
  <meta name="keywords" content="package, xml, encoding, go">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/go/encoding/xml/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/go.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/go/" class="_nav-link" title="" style="margin-left:0;">Go</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _go">
				
				
<h1> Package xml  </h1>    <ul id="short-nav">
<li><code>import "encoding/xml"</code></li>
<li><a href="#pkg-overview" class="overviewLink">Overview</a></li>
<li><a href="#pkg-index" class="indexLink">Index</a></li>
<li><a href="#pkg-examples" class="examplesLink">Examples</a></li>
</ul>     <h2 id="pkg-overview">Overview </h2> <p> Package xml implements a simple XML 1.0 parser that understands XML name spaces. </p>    <h4 id="example__customMarshalXML"> <span class="text">Example (CustomMarshalXML)</span>
</h4> <pre class="play" data-language="go">package main

import (
	"encoding/xml"
	"fmt"
	"log"
	"strings"
)

type Animal int

const (
	Unknown Animal = iota
	Gopher
	Zebra
)

func (a *Animal) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var s string
	if err := d.DecodeElement(&amp;s, &amp;start); err != nil {
		return err
	}
	switch strings.ToLower(s) {
	default:
		*a = Unknown
	case "gopher":
		*a = Gopher
	case "zebra":
		*a = Zebra
	}

	return nil
}

func (a Animal) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	var s string
	switch a {
	default:
		s = "unknown"
	case Gopher:
		s = "gopher"
	case Zebra:
		s = "zebra"
	}
	return e.EncodeElement(s, start)
}

func main() {
	blob := `
	&lt;animals&gt;
		&lt;animal&gt;gopher&lt;/animal&gt;
		&lt;animal&gt;armadillo&lt;/animal&gt;
		&lt;animal&gt;zebra&lt;/animal&gt;
		&lt;animal&gt;unknown&lt;/animal&gt;
		&lt;animal&gt;gopher&lt;/animal&gt;
		&lt;animal&gt;bee&lt;/animal&gt;
		&lt;animal&gt;gopher&lt;/animal&gt;
		&lt;animal&gt;zebra&lt;/animal&gt;
	&lt;/animals&gt;`
	var zoo struct {
		Animals []Animal `xml:"animal"`
	}
	if err := xml.Unmarshal([]byte(blob), &amp;zoo); err != nil {
		log.Fatal(err)
	}

	census := make(map[Animal]int)
	for _, animal := range zoo.Animals {
		census[animal] += 1
	}

	fmt.Printf("Zoo Census:\n* Gophers: %d\n* Zebras:  %d\n* Unknown: %d\n",
		census[Gopher], census[Zebra], census[Unknown])

}
</pre>      <h4 id="example__textMarshalXML"> <span class="text">Example (TextMarshalXML)</span>
</h4> <pre class="play" data-language="go">package main

import (
	"encoding/xml"
	"fmt"
	"log"
	"strings"
)

type Size int

const (
	Unrecognized Size = iota
	Small
	Large
)

func (s *Size) UnmarshalText(text []byte) error {
	switch strings.ToLower(string(text)) {
	default:
		*s = Unrecognized
	case "small":
		*s = Small
	case "large":
		*s = Large
	}
	return nil
}

func (s Size) MarshalText() ([]byte, error) {
	var name string
	switch s {
	default:
		name = "unrecognized"
	case Small:
		name = "small"
	case Large:
		name = "large"
	}
	return []byte(name), nil
}

func main() {
	blob := `
	&lt;sizes&gt;
		&lt;size&gt;small&lt;/size&gt;
		&lt;size&gt;regular&lt;/size&gt;
		&lt;size&gt;large&lt;/size&gt;
		&lt;size&gt;unrecognized&lt;/size&gt;
		&lt;size&gt;small&lt;/size&gt;
		&lt;size&gt;normal&lt;/size&gt;
		&lt;size&gt;small&lt;/size&gt;
		&lt;size&gt;large&lt;/size&gt;
	&lt;/sizes&gt;`
	var inventory struct {
		Sizes []Size `xml:"size"`
	}
	if err := xml.Unmarshal([]byte(blob), &amp;inventory); err != nil {
		log.Fatal(err)
	}

	counts := make(map[Size]int)
	for _, size := range inventory.Sizes {
		counts[size] += 1
	}

	fmt.Printf("Inventory Counts:\n* Small:        %d\n* Large:        %d\n* Unrecognized: %d\n",
		counts[Small], counts[Large], counts[Unrecognized])

}
</pre>        <h2 id="pkg-index">Index </h2>  <ul id="manual-nav">
<li><a href="#pkg-constants">Constants</a></li>
<li><a href="#pkg-variables">Variables</a></li>
<li><a href="#Escape">func Escape(w io.Writer, s []byte)</a></li>
<li><a href="#EscapeText">func EscapeText(w io.Writer, s []byte) error</a></li>
<li><a href="#Marshal">func Marshal(v interface{}) ([]byte, error)</a></li>
<li><a href="#MarshalIndent">func MarshalIndent(v interface{}, prefix, indent string) ([]byte, error)</a></li>
<li><a href="#Unmarshal">func Unmarshal(data []byte, v interface{}) error</a></li>
<li><a href="#Attr">type Attr</a></li>
<li><a href="#CharData">type CharData</a></li>
<li> <a href="#CharData.Copy">func (c CharData) Copy() CharData</a>
</li>
<li><a href="#Comment">type Comment</a></li>
<li> <a href="#Comment.Copy">func (c Comment) Copy() Comment</a>
</li>
<li><a href="#Decoder">type Decoder</a></li>
<li> <a href="#NewDecoder">func NewDecoder(r io.Reader) *Decoder</a>
</li>
<li> <a href="#NewTokenDecoder">func NewTokenDecoder(t TokenReader) *Decoder</a>
</li>
<li> <a href="#Decoder.Decode">func (d *Decoder) Decode(v interface{}) error</a>
</li>
<li> <a href="#Decoder.DecodeElement">func (d *Decoder) DecodeElement(v interface{}, start *StartElement) error</a>
</li>
<li> <a href="#Decoder.InputOffset">func (d *Decoder) InputOffset() int64</a>
</li>
<li> <a href="#Decoder.RawToken">func (d *Decoder) RawToken() (Token, error)</a>
</li>
<li> <a href="#Decoder.Skip">func (d *Decoder) Skip() error</a>
</li>
<li> <a href="#Decoder.Token">func (d *Decoder) Token() (Token, error)</a>
</li>
<li><a href="#Directive">type Directive</a></li>
<li> <a href="#Directive.Copy">func (d Directive) Copy() Directive</a>
</li>
<li><a href="#Encoder">type Encoder</a></li>
<li> <a href="#NewEncoder">func NewEncoder(w io.Writer) *Encoder</a>
</li>
<li> <a href="#Encoder.Encode">func (enc *Encoder) Encode(v interface{}) error</a>
</li>
<li> <a href="#Encoder.EncodeElement">func (enc *Encoder) EncodeElement(v interface{}, start StartElement) error</a>
</li>
<li> <a href="#Encoder.EncodeToken">func (enc *Encoder) EncodeToken(t Token) error</a>
</li>
<li> <a href="#Encoder.Flush">func (enc *Encoder) Flush() error</a>
</li>
<li> <a href="#Encoder.Indent">func (enc *Encoder) Indent(prefix, indent string)</a>
</li>
<li><a href="#EndElement">type EndElement</a></li>
<li><a href="#Marshaler">type Marshaler</a></li>
<li><a href="#MarshalerAttr">type MarshalerAttr</a></li>
<li><a href="#Name">type Name</a></li>
<li><a href="#ProcInst">type ProcInst</a></li>
<li> <a href="#ProcInst.Copy">func (p ProcInst) Copy() ProcInst</a>
</li>
<li><a href="#StartElement">type StartElement</a></li>
<li> <a href="#StartElement.Copy">func (e StartElement) Copy() StartElement</a>
</li>
<li> <a href="#StartElement.End">func (e StartElement) End() EndElement</a>
</li>
<li><a href="#SyntaxError">type SyntaxError</a></li>
<li> <a href="#SyntaxError.Error">func (e *SyntaxError) Error() string</a>
</li>
<li><a href="#TagPathError">type TagPathError</a></li>
<li> <a href="#TagPathError.Error">func (e *TagPathError) Error() string</a>
</li>
<li><a href="#Token">type Token</a></li>
<li> <a href="#CopyToken">func CopyToken(t Token) Token</a>
</li>
<li><a href="#TokenReader">type TokenReader</a></li>
<li><a href="#UnmarshalError">type UnmarshalError</a></li>
<li> <a href="#UnmarshalError.Error">func (e UnmarshalError) Error() string</a>
</li>
<li><a href="#Unmarshaler">type Unmarshaler</a></li>
<li><a href="#UnmarshalerAttr">type UnmarshalerAttr</a></li>
<li><a href="#UnsupportedTypeError">type UnsupportedTypeError</a></li>
<li> <a href="#UnsupportedTypeError.Error">func (e *UnsupportedTypeError) Error() string</a>
</li>
<li><a href="#pkg-note-BUG">Bugs</a></li>
</ul> <div id="pkg-examples"> <h3>Examples</h3>  <dl> <dd><a class="exampleLink" href="#example_Encoder">Encoder</a></dd> <dd><a class="exampleLink" href="#example_MarshalIndent">MarshalIndent</a></dd> <dd><a class="exampleLink" href="#example_Unmarshal">Unmarshal</a></dd> <dd><a class="exampleLink" href="#example__customMarshalXML">Package (CustomMarshalXML)</a></dd> <dd><a class="exampleLink" href="#example__textMarshalXML">Package (TextMarshalXML)</a></dd> </dl> </div> <h3>Package files</h3> <p>  <a href="https://golang.org/src/encoding/xml/marshal.go">marshal.go</a> <a href="https://golang.org/src/encoding/xml/read.go">read.go</a> <a href="https://golang.org/src/encoding/xml/typeinfo.go">typeinfo.go</a> <a href="https://golang.org/src/encoding/xml/xml.go">xml.go</a>  </p>   <h2 id="pkg-constants">Constants</h2> <pre data-language="go">const (
    // Header is a generic XML header suitable for use with the output of Marshal.
    // This is not automatically added to any output of this package,
    // it is provided as a convenience.
    Header = `&lt;?xml version="1.0" encoding="UTF-8"?&gt;` + "\n"
)</pre> <h2 id="pkg-variables">Variables</h2> <p> HTMLAutoClose is the set of HTML elements that should be considered to close automatically. </p> <p> See the Decoder.Strict and Decoder.Entity fields' documentation. </p> <pre data-language="go">var HTMLAutoClose []string = htmlAutoClose</pre> <p> HTMLEntity is an entity map containing translations for the standard HTML entity characters. </p> <p> See the Decoder.Strict and Decoder.Entity fields' documentation. </p> <pre data-language="go">var HTMLEntity map[string]string = htmlEntity</pre> <h2 id="Escape">func Escape<a href="https://golang.org/src/encoding/xml/xml.go?s=46171:46205#L1978" class="source">Source</a>  </h2> <pre data-language="go">func Escape(w io.Writer, s []byte)</pre> <p> Escape is like EscapeText but omits the error return value. It is provided for backwards compatibility with Go 1.0. Code targeting Go 1.1 or later should use EscapeText. </p> <h2 id="EscapeText">func EscapeText<a href="https://golang.org/src/encoding/xml/xml.go?s=44289:44333#L1884" class="source">Source</a>  <span title="Added in Go 1.1">1.1</span> </h2> <pre data-language="go">func EscapeText(w io.Writer, s []byte) error</pre> <p> EscapeText writes to w the properly escaped XML equivalent of the plain text data s. </p> <h2 id="Marshal">func Marshal<a href="https://golang.org/src/encoding/xml/marshal.go?s=3363:3406#L69" class="source">Source</a>  </h2> <pre data-language="go">func Marshal(v interface{}) ([]byte, error)</pre> <p> Marshal returns the XML encoding of v. </p> <p> Marshal handles an array or slice by marshaling each of the elements. Marshal handles a pointer by marshaling the value it points at or, if the pointer is nil, by writing nothing. Marshal handles an interface value by marshaling the value it contains or, if the interface value is nil, by writing nothing. Marshal handles all other data by writing one or more XML elements containing the data. </p> <p> The name for the XML elements is taken from, in order of preference: </p> <pre data-language="go">- the tag on the XMLName field, if the data is a struct
- the value of the XMLName field of type Name
- the tag of the struct field used to obtain the data
- the name of the struct field used to obtain the data
- the name of the marshaled type
</pre> <p> The XML element for a struct contains marshaled elements for each of the exported fields of the struct, with these exceptions: </p> <pre data-language="go">- the XMLName field, described above, is omitted.
- a field with tag "-" is omitted.
- a field with tag "name,attr" becomes an attribute with
  the given name in the XML element.
- a field with tag ",attr" becomes an attribute with the
  field name in the XML element.
- a field with tag ",chardata" is written as character data,
  not as an XML element.
- a field with tag ",cdata" is written as character data
  wrapped in one or more &lt;![CDATA[ ... ]]&gt; tags, not as an XML element.
- a field with tag ",innerxml" is written verbatim, not subject
  to the usual marshaling procedure.
- a field with tag ",comment" is written as an XML comment, not
  subject to the usual marshaling procedure. It must not contain
  the "--" string within it.
- a field with a tag including the "omitempty" option is omitted
  if the field value is empty. The empty values are false, 0, any
  nil pointer or interface value, and any array, slice, map, or
  string of length zero.
- an anonymous struct field is handled as if the fields of its
  value were part of the outer struct.
- a field implementing Marshaler is written by calling its MarshalXML
  method.
- a field implementing encoding.TextMarshaler is written by encoding the
  result of its MarshalText method as text.
</pre> <p> If a field uses a tag "a&gt;b&gt;c", then the element c will be nested inside parent elements a and b. Fields that appear next to each other that name the same parent will be enclosed in one XML element. </p> <p> If the XML name for a struct field is defined by both the field tag and the struct's XMLName field, the names must match. </p> <p> See MarshalIndent for an example. </p> <p> Marshal will return an error if asked to marshal a channel, function, or map. </p> <h2 id="MarshalIndent">func MarshalIndent<a href="https://golang.org/src/encoding/xml/marshal.go?s=5222:5294#L115" class="source">Source</a>  </h2> <pre data-language="go">func MarshalIndent(v interface{}, prefix, indent string) ([]byte, error)</pre> <p> MarshalIndent works like Marshal, but each XML element begins on a new indented line that starts with prefix and is followed by one or more copies of indent according to the nesting depth. </p>    <h4 id="example_MarshalIndent"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"encoding/xml"
	"fmt"
	"os"
)

func main() {
	type Address struct {
		City, State string
	}
	type Person struct {
		XMLName   xml.Name `xml:"person"`
		Id        int      `xml:"id,attr"`
		FirstName string   `xml:"name&gt;first"`
		LastName  string   `xml:"name&gt;last"`
		Age       int      `xml:"age"`
		Height    float32  `xml:"height,omitempty"`
		Married   bool
		Address
		Comment string `xml:",comment"`
	}

	v := &amp;Person{Id: 13, FirstName: "John", LastName: "Doe", Age: 42}
	v.Comment = " Need more details. "
	v.Address = Address{"Hanga Roa", "Easter Island"}

	output, err := xml.MarshalIndent(v, "  ", "    ")
	if err != nil {
		fmt.Printf("error: %v\n", err)
	}

	os.Stdout.Write(output)
}
</pre>   <h2 id="Unmarshal">func Unmarshal<a href="https://golang.org/src/encoding/xml/read.go?s=5770:5818#L122" class="source">Source</a>  </h2> <pre data-language="go">func Unmarshal(data []byte, v interface{}) error</pre> <p> Unmarshal parses the XML-encoded data and stores the result in the value pointed to by v, which must be an arbitrary struct, slice, or string. Well-formed data that does not fit into v is discarded. </p> <p> Because Unmarshal uses the reflect package, it can only assign to exported (upper case) fields. Unmarshal uses a case-sensitive comparison to match XML element names to tag values and struct field names. </p> <p> Unmarshal maps an XML element to a struct using the following rules. In the rules, the tag of a field refers to the value associated with the key 'xml' in the struct field's tag (see the example above). </p> <pre data-language="go">* If the struct has a field of type []byte or string with tag
   ",innerxml", Unmarshal accumulates the raw XML nested inside the
   element in that field. The rest of the rules still apply.

* If the struct has a field named XMLName of type Name,
   Unmarshal records the element name in that field.

* If the XMLName field has an associated tag of the form
   "name" or "namespace-URL name", the XML element must have
   the given name (and, optionally, name space) or else Unmarshal
   returns an error.

* If the XML element has an attribute whose name matches a
   struct field name with an associated tag containing ",attr" or
   the explicit name in a struct field tag of the form "name,attr",
   Unmarshal records the attribute value in that field.

* If the XML element has an attribute not handled by the previous
   rule and the struct has a field with an associated tag containing
   ",any,attr", Unmarshal records the attribute value in the first
   such field.

* If the XML element contains character data, that data is
   accumulated in the first struct field that has tag ",chardata".
   The struct field may have type []byte or string.
   If there is no such field, the character data is discarded.

* If the XML element contains comments, they are accumulated in
   the first struct field that has tag ",comment".  The struct
   field may have type []byte or string. If there is no such
   field, the comments are discarded.

* If the XML element contains a sub-element whose name matches
   the prefix of a tag formatted as "a" or "a&gt;b&gt;c", unmarshal
   will descend into the XML structure looking for elements with the
   given names, and will map the innermost elements to that struct
   field. A tag starting with "&gt;" is equivalent to one starting
   with the field name followed by "&gt;".

* If the XML element contains a sub-element whose name matches
   a struct field's XMLName tag and the struct field has no
   explicit name tag as per the previous rule, unmarshal maps
   the sub-element to that struct field.

* If the XML element contains a sub-element whose name matches a
   field without any mode flags (",attr", ",chardata", etc), Unmarshal
   maps the sub-element to that struct field.

* If the XML element contains a sub-element that hasn't matched any
   of the above rules and the struct has a field with tag ",any",
   unmarshal maps the sub-element to that struct field.

* An anonymous struct field is handled as if the fields of its
   value were part of the outer struct.

* A struct field with tag "-" is never unmarshaled into.
</pre> <p> If Unmarshal encounters a field type that implements the Unmarshaler interface, Unmarshal calls its UnmarshalXML method to produce the value from the XML element. Otherwise, if the value implements encoding.TextUnmarshaler, Unmarshal calls that value's UnmarshalText method. </p> <p> Unmarshal maps an XML element to a string or []byte by saving the concatenation of that element's character data in the string or []byte. The saved []byte is never nil. </p> <p> Unmarshal maps an attribute value to a string or []byte by saving the value in the string or slice. </p> <p> Unmarshal maps an attribute value to an Attr by saving the attribute, including its name, in the Attr. </p> <p> Unmarshal maps an XML element or attribute value to a slice by extending the length of the slice and mapping the element or attribute to the newly created value. </p> <p> Unmarshal maps an XML element or attribute value to a bool by setting it to the boolean value represented by the string. Whitespace is trimmed and ignored. </p> <p> Unmarshal maps an XML element or attribute value to an integer or floating-point field by setting the field to the result of interpreting the string value in decimal. There is no check for overflow. Whitespace is trimmed and ignored. </p> <p> Unmarshal maps an XML element to a Name by recording the element name. </p> <p> Unmarshal maps an XML element to a pointer by setting the pointer to a freshly allocated value and then mapping the element to that value. </p> <p> A missing element or empty attribute value will be unmarshaled as a zero value. If the field is a slice, a zero value will be appended to the field. Otherwise, the field will be set to its zero value. </p>    <h4 id="example_Unmarshal"> <span class="text">Example</span>
</h4> <p>This example demonstrates unmarshaling an XML excerpt into a value with some preset fields. Note that the Phone field isn't modified and that the XML &lt;Company&gt; element is ignored. Also, the Groups field is assigned considering the element path provided in its tag. </p> <pre class="play" data-language="go">package main

import (
	"encoding/xml"
	"fmt"
)

func main() {
	type Email struct {
		Where string `xml:"where,attr"`
		Addr  string
	}
	type Address struct {
		City, State string
	}
	type Result struct {
		XMLName xml.Name `xml:"Person"`
		Name    string   `xml:"FullName"`
		Phone   string
		Email   []Email
		Groups  []string `xml:"Group&gt;Value"`
		Address
	}
	v := Result{Name: "none", Phone: "none"}

	data := `
		&lt;Person&gt;
			&lt;FullName&gt;Grace R. Emlin&lt;/FullName&gt;
			&lt;Company&gt;Example Inc.&lt;/Company&gt;
			&lt;Email where="home"&gt;
				&lt;Addr&gt;gre@example.com&lt;/Addr&gt;
			&lt;/Email&gt;
			&lt;Email where='work'&gt;
				&lt;Addr&gt;gre@work.com&lt;/Addr&gt;
			&lt;/Email&gt;
			&lt;Group&gt;
				&lt;Value&gt;Friends&lt;/Value&gt;
				&lt;Value&gt;Squash&lt;/Value&gt;
			&lt;/Group&gt;
			&lt;City&gt;Hanga Roa&lt;/City&gt;
			&lt;State&gt;Easter Island&lt;/State&gt;
		&lt;/Person&gt;
	`
	err := xml.Unmarshal([]byte(data), &amp;v)
	if err != nil {
		fmt.Printf("error: %v", err)
		return
	}
	fmt.Printf("XMLName: %#v\n", v.XMLName)
	fmt.Printf("Name: %q\n", v.Name)
	fmt.Printf("Phone: %q\n", v.Phone)
	fmt.Printf("Email: %v\n", v.Email)
	fmt.Printf("Groups: %v\n", v.Groups)
	fmt.Printf("Address: %v\n", v.Address)
}
</pre>   <h2 id="Attr">type Attr<a href="https://golang.org/src/encoding/xml/xml.go?s=1131:1177#L38" class="source">Source</a>  </h2> <p> An Attr represents an attribute in an XML element (Name=Value). </p> <pre data-language="go">type Attr struct {
    Name  Name
    Value string
}
</pre> <h2 id="CharData">type CharData<a href="https://golang.org/src/encoding/xml/xml.go?s=1966:1986#L74" class="source">Source</a>  </h2> <p> A CharData represents XML character data (raw text), in which XML escape sequences have been replaced by the characters they represent. </p> <pre data-language="go">type CharData []byte</pre> <h3 id="CharData.Copy">func (CharData) Copy<a href="https://golang.org/src/encoding/xml/xml.go?s=2116:2149#L83" class="source">Source</a>  </h3> <pre data-language="go">func (c CharData) Copy() CharData</pre> <p> Copy creates a new copy of CharData. </p> <h2 id="Comment">type Comment<a href="https://golang.org/src/encoding/xml/xml.go?s=2313:2332#L87" class="source">Source</a>  </h2> <p> A Comment represents an XML comment of the form &lt;!--comment--&gt;. The bytes do not include the &lt;!-- and --&gt; comment markers. </p> <pre data-language="go">type Comment []byte</pre> <h3 id="Comment.Copy">func (Comment) Copy<a href="https://golang.org/src/encoding/xml/xml.go?s=2373:2404#L90" class="source">Source</a>  </h3> <pre data-language="go">func (c Comment) Copy() Comment</pre> <p> Copy creates a new copy of Comment. </p> <h2 id="Decoder">type Decoder<a href="https://golang.org/src/encoding/xml/xml.go?s=4169:6498#L147" class="source">Source</a>  </h2> <p> A Decoder represents an XML parser reading a particular input stream. The parser assumes that its input is encoded in UTF-8. </p> <pre data-language="go">type Decoder struct {
    // Strict defaults to true, enforcing the requirements
    // of the XML specification.
    // If set to false, the parser allows input containing common
    // mistakes:
    //	* If an element is missing an end tag, the parser invents
    //	  end tags as necessary to keep the return values from Token
    //	  properly balanced.
    //	* In attribute values and character data, unknown or malformed
    //	  character entities (sequences beginning with &amp;) are left alone.
    //
    // Setting:
    //
    //	d.Strict = false
    //	d.AutoClose = xml.HTMLAutoClose
    //	d.Entity = xml.HTMLEntity
    //
    // creates a parser that can handle typical HTML.
    //
    // Strict mode does not enforce the requirements of the XML name spaces TR.
    // In particular it does not reject name space tags using undefined prefixes.
    // Such tags are recorded with the unknown prefix as the name space URL.
    Strict bool

    // When Strict == false, AutoClose indicates a set of elements to
    // consider closed immediately after they are opened, regardless
    // of whether an end element is present.
    AutoClose []string

    // Entity can be used to map non-standard entity names to string replacements.
    // The parser behaves as if these standard mappings are present in the map,
    // regardless of the actual map content:
    //
    //	"lt": "&lt;",
    //	"gt": "&gt;",
    //	"amp": "&amp;",
    //	"apos": "'",
    //	"quot": `"`,
    Entity map[string]string

    // CharsetReader, if non-nil, defines a function to generate
    // charset-conversion readers, converting from the provided
    // non-UTF-8 charset into UTF-8. If CharsetReader is nil or
    // returns an error, parsing stops with an error. One of the
    // CharsetReader's result values must be non-nil.
    CharsetReader func(charset string, input io.Reader) (io.Reader, error)

    // DefaultSpace sets the default name space used for unadorned tags,
    // as if the entire XML stream were wrapped in an element containing
    // the attribute xmlns="DefaultSpace".
    DefaultSpace string // Go 1.1
    // contains filtered or unexported fields
}
</pre> <h3 id="NewDecoder">func NewDecoder<a href="https://golang.org/src/encoding/xml/xml.go?s=6638:6675#L219" class="source">Source</a>  </h3> <pre data-language="go">func NewDecoder(r io.Reader) *Decoder</pre> <p> NewDecoder creates a new XML parser reading from r. If r does not implement io.ByteReader, NewDecoder will do its own buffering. </p> <h3 id="NewTokenDecoder">func NewTokenDecoder<a href="https://golang.org/src/encoding/xml/xml.go?s=6895:6939#L231" class="source">Source</a>  <span title="Added in Go 1.10">1.10</span> </h3> <pre data-language="go">func NewTokenDecoder(t TokenReader) *Decoder</pre> <p> NewTokenDecoder creates a new XML parser using an underlying token stream. </p> <h3 id="Decoder.Decode">func (*Decoder) Decode<a href="https://golang.org/src/encoding/xml/read.go?s=5973:6018#L128" class="source">Source</a>  </h3> <pre data-language="go">func (d *Decoder) Decode(v interface{}) error</pre> <p> Decode works like Unmarshal, except it reads the decoder stream to find the start element. </p> <h3 id="Decoder.DecodeElement">func (*Decoder) DecodeElement<a href="https://golang.org/src/encoding/xml/read.go?s=6293:6366#L136" class="source">Source</a>  </h3> <pre data-language="go">func (d *Decoder) DecodeElement(v interface{}, start *StartElement) error</pre> <p> DecodeElement works like Unmarshal except that it takes a pointer to the start XML element to decode into v. It is useful when a client reads some raw XML tokens itself but also wants to defer to Unmarshal for some elements. </p> <h3 id="Decoder.InputOffset">func (*Decoder) InputOffset<a href="https://golang.org/src/encoding/xml/xml.go?s=22421:22458#L917" class="source">Source</a>  <span title="Added in Go 1.4">1.4</span> </h3> <pre data-language="go">func (d *Decoder) InputOffset() int64</pre> <p> InputOffset returns the input stream byte offset of the current decoder position. The offset gives the location of the end of the most recently returned token and the beginning of the next token. </p> <h3 id="Decoder.RawToken">func (*Decoder) RawToken<a href="https://golang.org/src/encoding/xml/xml.go?s=14581:14624#L534" class="source">Source</a>  </h3> <pre data-language="go">func (d *Decoder) RawToken() (Token, error)</pre> <p> RawToken is like Token but does not verify that start and end elements match and does not translate name space prefixes to their corresponding URLs. </p> <h3 id="Decoder.Skip">func (*Decoder) Skip<a href="https://golang.org/src/encoding/xml/read.go?s=22143:22173#L730" class="source">Source</a>  </h3> <pre data-language="go">func (d *Decoder) Skip() error</pre> <p> Skip reads tokens until it has consumed the end element matching the most recent start element already consumed. It recurs if it encounters a start element, so it can be used to skip nested structures. It returns nil if it finds an end element matching the start element; otherwise it returns an error describing the problem. </p> <h3 id="Decoder.Token">func (*Decoder) Token<a href="https://golang.org/src/encoding/xml/xml.go?s=8197:8237#L269" class="source">Source</a>  </h3> <pre data-language="go">func (d *Decoder) Token() (Token, error)</pre> <p> Token returns the next XML token in the input stream. At the end of the input stream, Token returns nil, io.EOF. </p> <p> Slices of bytes in the returned token data refer to the parser's internal buffer and remain valid only until the next call to Token. To acquire a copy of the bytes, call CopyToken or the token's Copy method. </p> <p> Token expands self-closing elements such as &lt;br/&gt; into separate start and end elements returned by successive calls. </p> <p> Token guarantees that the StartElement and EndElement tokens it returns are properly nested and matched: if Token encounters an unexpected end element or EOF before all expected end elements, it will return an error. </p> <p> Token implements XML name spaces as described by <a href="https://www.w3.org/TR/REC-xml-names/">https://www.w3.org/TR/REC-xml-names/</a>. Each of the Name structures contained in the Token has the Space set to the URL identifying its name space when known. If Token encounters an unrecognized name space prefix, it uses the prefix as the Space rather than report an error. </p> <h2 id="Directive">type Directive<a href="https://golang.org/src/encoding/xml/xml.go?s=2807:2828#L106" class="source">Source</a>  </h2> <p> A Directive represents an XML directive of the form &lt;!text&gt;. The bytes do not include the &lt;! and &gt; markers. </p> <pre data-language="go">type Directive []byte</pre> <h3 id="Directive.Copy">func (Directive) Copy<a href="https://golang.org/src/encoding/xml/xml.go?s=2871:2906#L109" class="source">Source</a>  </h3> <pre data-language="go">func (d Directive) Copy() Directive</pre> <p> Copy creates a new copy of Directive. </p> <h2 id="Encoder">type Encoder<a href="https://golang.org/src/encoding/xml/marshal.go?s=5505:5539#L126" class="source">Source</a>  </h2> <p> An Encoder writes XML data to an output stream. </p> <pre data-language="go">type Encoder struct {
    // contains filtered or unexported fields
}
</pre>    <h4 id="example_Encoder"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"encoding/xml"
	"fmt"
	"os"
)

func main() {
	type Address struct {
		City, State string
	}
	type Person struct {
		XMLName   xml.Name `xml:"person"`
		Id        int      `xml:"id,attr"`
		FirstName string   `xml:"name&gt;first"`
		LastName  string   `xml:"name&gt;last"`
		Age       int      `xml:"age"`
		Height    float32  `xml:"height,omitempty"`
		Married   bool
		Address
		Comment string `xml:",comment"`
	}

	v := &amp;Person{Id: 13, FirstName: "John", LastName: "Doe", Age: 42}
	v.Comment = " Need more details. "
	v.Address = Address{"Hanga Roa", "Easter Island"}

	enc := xml.NewEncoder(os.Stdout)
	enc.Indent("  ", "    ")
	if err := enc.Encode(v); err != nil {
		fmt.Printf("error: %v\n", err)
	}

}
</pre>   <h3 id="NewEncoder">func NewEncoder<a href="https://golang.org/src/encoding/xml/marshal.go?s=5595:5632#L131" class="source">Source</a>  </h3> <pre data-language="go">func NewEncoder(w io.Writer) *Encoder</pre> <p> NewEncoder returns a new encoder that writes to w. </p> <h3 id="Encoder.Encode">func (*Encoder) Encode<a href="https://golang.org/src/encoding/xml/marshal.go?s=6217:6264#L151" class="source">Source</a>  </h3> <pre data-language="go">func (enc *Encoder) Encode(v interface{}) error</pre> <p> Encode writes the XML encoding of v to the stream. </p> <p> See the documentation for Marshal for details about the conversion of Go values to XML. </p> <p> Encode calls Flush before returning. </p> <h3 id="Encoder.EncodeElement">func (*Encoder) EncodeElement<a href="https://golang.org/src/encoding/xml/marshal.go?s=6643:6717#L166" class="source">Source</a>  <span title="Added in Go 1.2">1.2</span> </h3> <pre data-language="go">func (enc *Encoder) EncodeElement(v interface{}, start StartElement) error</pre> <p> EncodeElement writes the XML encoding of v to the stream, using start as the outermost tag in the encoding. </p> <p> See the documentation for Marshal for details about the conversion of Go values to XML. </p> <p> EncodeElement calls Flush before returning. </p> <h3 id="Encoder.EncodeToken">func (*Encoder) EncodeToken<a href="https://golang.org/src/encoding/xml/marshal.go?s=7625:7671#L192" class="source">Source</a>  <span title="Added in Go 1.2">1.2</span> </h3> <pre data-language="go">func (enc *Encoder) EncodeToken(t Token) error</pre> <p> EncodeToken writes the given XML token to the stream. It returns an error if StartElement and EndElement tokens are not properly matched. </p> <p> EncodeToken does not call Flush, because usually it is part of a larger operation such as Encode or EncodeElement (or a custom Marshaler's MarshalXML invoked during those), and those will call Flush when finished. Callers that create an Encoder and then invoke EncodeToken directly, without using Encode or EncodeElement, need to call Flush when finished to ensure that the XML is written to the underlying writer. </p> <p> EncodeToken allows writing a ProcInst with Target set to "xml" only as the first token in the stream. </p> <h3 id="Encoder.Flush">func (*Encoder) Flush<a href="https://golang.org/src/encoding/xml/marshal.go?s=10177:10210#L289" class="source">Source</a>  <span title="Added in Go 1.2">1.2</span> </h3> <pre data-language="go">func (enc *Encoder) Flush() error</pre> <p> Flush flushes any buffered XML to the underlying writer. See the EncodeToken documentation for details about when it is necessary. </p> <h3 id="Encoder.Indent">func (*Encoder) Indent<a href="https://golang.org/src/encoding/xml/marshal.go?s=5922:5971#L140" class="source">Source</a>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (enc *Encoder) Indent(prefix, indent string)</pre> <p> Indent sets the encoder to generate XML in which each element begins on a new indented line that starts with prefix and is followed by one or more copies of indent according to the nesting depth. </p> <h2 id="EndElement">type EndElement<a href="https://golang.org/src/encoding/xml/xml.go?s=1782:1819#L67" class="source">Source</a>  </h2> <p> An EndElement represents an XML end element. </p> <pre data-language="go">type EndElement struct {
    Name Name
}
</pre> <h2 id="Marshaler">type Marshaler<a href="https://golang.org/src/encoding/xml/marshal.go?s=4324:4402#L93" class="source">Source</a>  <span title="Added in Go 1.2">1.2</span> </h2> <p> Marshaler is the interface implemented by objects that can marshal themselves into valid XML elements. </p> <p> MarshalXML encodes the receiver as zero or more XML elements. By convention, arrays or slices are typically encoded as a sequence of elements, one per entry. Using start as the element tag is not required, but doing so will enable Unmarshal to match the XML elements to the correct struct field. One common implementation strategy is to construct a separate value with a layout corresponding to the desired XML and then to encode it using e.EncodeElement. Another common strategy is to use repeated calls to e.EncodeToken to generate the XML output one token at a time. The sequence of encoded tokens must make up zero or more valid XML elements. </p> <pre data-language="go">type Marshaler interface {
    MarshalXML(e *Encoder, start StartElement) error
}</pre> <h2 id="MarshalerAttr">type MarshalerAttr<a href="https://golang.org/src/encoding/xml/marshal.go?s=4949:5022#L108" class="source">Source</a>  <span title="Added in Go 1.2">1.2</span> </h2> <p> MarshalerAttr is the interface implemented by objects that can marshal themselves into valid XML attributes. </p> <p> MarshalXMLAttr returns an XML attribute with the encoded value of the receiver. Using name as the attribute name is not required, but doing so will enable Unmarshal to match the attribute to the correct struct field. If MarshalXMLAttr returns the zero attribute Attr{}, no attribute will be generated in the output. MarshalXMLAttr is used only for struct fields with the "attr" option in the field tag. </p> <pre data-language="go">type MarshalerAttr interface {
    MarshalXMLAttr(name Name) (Attr, error)
}</pre> <h2 id="Name">type Name<a href="https://golang.org/src/encoding/xml/xml.go?s=1021:1062#L33" class="source">Source</a>  </h2> <p> A Name represents an XML name (Local) annotated with a name space identifier (Space). In tokens returned by Decoder.Token, the Space identifier is given as a canonical URL, not the short prefix used in the document being parsed. </p> <pre data-language="go">type Name struct {
    Space, Local string
}
</pre> <h2 id="ProcInst">type ProcInst<a href="https://golang.org/src/encoding/xml/xml.go?s=2521:2575#L93" class="source">Source</a>  </h2> <p> A ProcInst represents an XML processing instruction of the form &lt;?target inst?&gt; </p> <pre data-language="go">type ProcInst struct {
    Target string
    Inst   []byte
}
</pre> <h3 id="ProcInst.Copy">func (ProcInst) Copy<a href="https://golang.org/src/encoding/xml/xml.go?s=2617:2650#L99" class="source">Source</a>  </h3> <pre data-language="go">func (p ProcInst) Copy() ProcInst</pre> <p> Copy creates a new copy of ProcInst. </p> <h2 id="StartElement">type StartElement<a href="https://golang.org/src/encoding/xml/xml.go?s=1385:1437#L48" class="source">Source</a>  </h2> <p> A StartElement represents an XML start element. </p> <pre data-language="go">type StartElement struct {
    Name Name
    Attr []Attr
}
</pre> <h3 id="StartElement.Copy">func (StartElement) Copy<a href="https://golang.org/src/encoding/xml/xml.go?s=1483:1524#L54" class="source">Source</a>  </h3> <pre data-language="go">func (e StartElement) Copy() StartElement</pre> <p> Copy creates a new copy of StartElement. </p> <h3 id="StartElement.End">func (StartElement) End<a href="https://golang.org/src/encoding/xml/xml.go?s=1663:1701#L62" class="source">Source</a>  <span title="Added in Go 1.2">1.2</span> </h3> <pre data-language="go">func (e StartElement) End() EndElement</pre> <p> End returns the corresponding XML end element. </p> <h2 id="SyntaxError">type SyntaxError<a href="https://golang.org/src/encoding/xml/xml.go?s=609:659#L19" class="source">Source</a>  </h2> <p> A SyntaxError represents a syntax error in the XML input stream. </p> <pre data-language="go">type SyntaxError struct {
    Msg  string
    Line int
}
</pre> <h3 id="SyntaxError.Error">func (*SyntaxError) Error<a href="https://golang.org/src/encoding/xml/xml.go?s=661:697#L24" class="source">Source</a>  </h3> <pre data-language="go">func (e *SyntaxError) Error() string</pre> <h2 id="TagPathError">type TagPathError<a href="https://golang.org/src/encoding/xml/typeinfo.go?s=8771:8868#L327" class="source">Source</a>  </h2> <p> A TagPathError represents an error in the unmarshaling process caused by the use of field tags with conflicting paths. </p> <pre data-language="go">type TagPathError struct {
    Struct       reflect.Type
    Field1, Tag1 string
    Field2, Tag2 string
}
</pre> <h3 id="TagPathError.Error">func (*TagPathError) Error<a href="https://golang.org/src/encoding/xml/typeinfo.go?s=8870:8907#L333" class="source">Source</a>  </h3> <pre data-language="go">func (e *TagPathError) Error() string</pre> <h2 id="Token">type Token<a href="https://golang.org/src/encoding/xml/xml.go?s=1310:1332#L45" class="source">Source</a>  </h2> <p> A Token is an interface holding one of the token types: StartElement, EndElement, CharData, Comment, ProcInst, or Directive. </p> <pre data-language="go">type Token interface{}</pre> <h3 id="CopyToken">func CopyToken<a href="https://golang.org/src/encoding/xml/xml.go?s=2982:3011#L112" class="source">Source</a>  </h3> <pre data-language="go">func CopyToken(t Token) Token</pre> <p> CopyToken returns a copy of a Token. </p> <h2 id="TokenReader">type TokenReader<a href="https://golang.org/src/encoding/xml/xml.go?s=3982:4036#L141" class="source">Source</a>  <span title="Added in Go 1.10">1.10</span> </h2> <p> A TokenReader is anything that can decode a stream of XML tokens, including a Decoder. </p> <p> When Token encounters an error or end-of-file condition after successfully reading a token, it returns the token. It may return the (non-nil) error from the same call or return the error (and a nil token) from a subsequent call. An instance of this general case is that a TokenReader returning a non-nil token at the end of the token stream may return either io.EOF or a nil error. The next Read should return nil, io.EOF. </p> <p> Implementations of Token are discouraged from returning a nil token with a nil error. Callers should treat a return of nil, nil as indicating that nothing happened; in particular it does not indicate EOF. </p> <pre data-language="go">type TokenReader interface {
    Token() (Token, error)
}</pre> <h2 id="UnmarshalError">type UnmarshalError<a href="https://golang.org/src/encoding/xml/read.go?s=6598:6624#L145" class="source">Source</a>  </h2> <p> An UnmarshalError represents an error in the unmarshaling process. </p> <pre data-language="go">type UnmarshalError string</pre> <h3 id="UnmarshalError.Error">func (UnmarshalError) Error<a href="https://golang.org/src/encoding/xml/read.go?s=6626:6664#L147" class="source">Source</a>  </h3> <pre data-language="go">func (e UnmarshalError) Error() string</pre> <h2 id="Unmarshaler">type Unmarshaler<a href="https://golang.org/src/encoding/xml/read.go?s=7383:7465#L164" class="source">Source</a>  <span title="Added in Go 1.2">1.2</span> </h2> <p> Unmarshaler is the interface implemented by objects that can unmarshal an XML element description of themselves. </p> <p> UnmarshalXML decodes a single XML element beginning with the given start element. If it returns an error, the outer call to Unmarshal stops and returns that error. UnmarshalXML must consume exactly one XML element. One common implementation strategy is to unmarshal into a separate value with a layout matching the expected XML using d.DecodeElement, and then to copy the data from that value into the receiver. Another common strategy is to use d.Token to process the XML object one token at a time. UnmarshalXML may not use d.RawToken. </p> <pre data-language="go">type Unmarshaler interface {
    UnmarshalXML(d *Decoder, start StartElement) error
}</pre> <h2 id="UnmarshalerAttr">type UnmarshalerAttr<a href="https://golang.org/src/encoding/xml/read.go?s=7830:7899#L176" class="source">Source</a>  <span title="Added in Go 1.2">1.2</span> </h2> <p> UnmarshalerAttr is the interface implemented by objects that can unmarshal an XML attribute description of themselves. </p> <p> UnmarshalXMLAttr decodes a single XML attribute. If it returns an error, the outer call to Unmarshal stops and returns that error. UnmarshalXMLAttr is used only for struct fields with the "attr" option in the field tag. </p> <pre data-language="go">type UnmarshalerAttr interface {
    UnmarshalXMLAttr(attr Attr) error
}</pre> <h2 id="UnsupportedTypeError">type UnsupportedTypeError<a href="https://golang.org/src/encoding/xml/marshal.go?s=29115:29170#L1021" class="source">Source</a>  </h2> <p> UnsupportedTypeError is returned when Marshal encounters a type that cannot be converted into XML. </p> <pre data-language="go">type UnsupportedTypeError struct {
    Type reflect.Type
}
</pre> <h3 id="UnsupportedTypeError.Error">func (*UnsupportedTypeError) Error<a href="https://golang.org/src/encoding/xml/marshal.go?s=29172:29217#L1025" class="source">Source</a>  </h3> <pre data-language="go">func (e *UnsupportedTypeError) Error() string</pre> <h2 id="pkg-note-BUG">Bugs</h2> <ul> <li>
<a href="https://golang.org/src/encoding/xml/read.go?s=256:578#L7" style="float: left;">☞</a> <p> Mapping between XML elements and data structures is inherently flawed: an XML element is an order-dependent collection of anonymous values, while a data structure is an order-independent collection of named values. See package json for a textual representation more suitable to data structures. </p> </li> </ul>
<div class="_attribution">
  <p class="_attribution-p">
    © Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>
    <a href="https://golang.org/pkg/encoding/xml/" class="_attribution-link">https://golang.org/pkg/encoding/xml/</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
