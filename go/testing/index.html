
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Testing - Go - W3cubDocs</title>
  
  <meta name="description" content="Package testing provides support for automated testing of Go packages. It is intended to be used in concert with the &#34;go test&#34; command, &hellip;">
  <meta name="keywords" content="package, testing, go">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/go/testing/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/go.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/go/" class="_nav-link" title="" style="margin-left:0;">Go</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _go">
				
				
<h1> Package testing  </h1>    <ul id="short-nav">
<li><code>import "testing"</code></li>
<li><a href="#pkg-overview" class="overviewLink">Overview</a></li>
<li><a href="#pkg-index" class="indexLink">Index</a></li>
<li><a href="#pkg-examples" class="examplesLink">Examples</a></li>
<li><a href="#pkg-subdirectories">Subdirectories</a></li>
</ul>     <h2 id="pkg-overview">Overview </h2> <p> Package testing provides support for automated testing of Go packages. It is intended to be used in concert with the "go test" command, which automates execution of any function of the form </p> <pre data-language="go">func TestXxx(*testing.T)
</pre> <p> where Xxx does not start with a lowercase letter. The function name serves to identify the test routine. </p> <p> Within these functions, use the Error, Fail or related methods to signal failure. </p> <p> To write a new test suite, create a file whose name ends _test.go that contains the TestXxx functions as described here. Put the file in the same package as the one being tested. The file will be excluded from regular package builds but will be included when the "go test" command is run. For more detail, run "go help test" and "go help testflag". </p> <p> A simple test function looks like this: </p> <pre data-language="go">func TestAbs(t *testing.T) {
    got := Abs(-1)
    if got != 1 {
        t.Errorf("Abs(-1) = %d; want 1", got)
    }
}
</pre> <h3 id="hdr-Benchmarks">Benchmarks</h3> <p> Functions of the form </p> <pre data-language="go">func BenchmarkXxx(*testing.B)
</pre> <p> are considered benchmarks, and are executed by the "go test" command when its -bench flag is provided. Benchmarks are run sequentially. </p> <p> For a description of the testing flags, see <a href="https://golang.org/cmd/go/#hdr-Testing_flags">https://golang.org/cmd/go/#hdr-Testing_flags</a> </p> <p> A sample benchmark function looks like this: </p> <pre data-language="go">func BenchmarkRandInt(b *testing.B) {
    for i := 0; i &lt; b.N; i++ {
        rand.Int()
    }
}
</pre> <p> The benchmark function must run the target code b.N times. During benchmark execution, b.N is adjusted until the benchmark function lasts long enough to be timed reliably. The output </p> <pre data-language="go">BenchmarkRandInt-8   	68453040	        17.8 ns/op
</pre> <p> means that the loop ran 68453040 times at a speed of 17.8 ns per loop. </p> <p> If a benchmark needs some expensive setup before running, the timer may be reset: </p> <pre data-language="go">func BenchmarkBigLen(b *testing.B) {
    big := NewBig()
    b.ResetTimer()
    for i := 0; i &lt; b.N; i++ {
        big.Len()
    }
}
</pre> <p> If a benchmark needs to test performance in a parallel setting, it may use the RunParallel helper function; such benchmarks are intended to be used with the go test -cpu flag: </p> <pre data-language="go">func BenchmarkTemplateParallel(b *testing.B) {
    templ := template.Must(template.New("test").Parse("Hello, {{.}}!"))
    b.RunParallel(func(pb *testing.PB) {
        var buf bytes.Buffer
        for pb.Next() {
            buf.Reset()
            templ.Execute(&amp;buf, "World")
        }
    })
}
</pre> <h3 id="hdr-Examples">Examples</h3> <p> The package also runs and verifies example code. Example functions may include a concluding line comment that begins with "Output:" and is compared with the standard output of the function when the tests are run. (The comparison ignores leading and trailing space.) These are examples of an example: </p> <pre data-language="go">func ExampleHello() {
    fmt.Println("hello")
    // Output: hello
}

func ExampleSalutations() {
    fmt.Println("hello, and")
    fmt.Println("goodbye")
    // Output:
    // hello, and
    // goodbye
}
</pre> <p> The comment prefix "Unordered output:" is like "Output:", but matches any line order: </p> <pre data-language="go">func ExamplePerm() {
    for _, value := range Perm(5) {
        fmt.Println(value)
    }
    // Unordered output: 4
    // 2
    // 1
    // 3
    // 0
}
</pre> <p> Example functions without output comments are compiled but not executed. </p> <p> The naming convention to declare examples for the package, a function F, a type T and method M on type T are: </p> <pre data-language="go">func Example() { ... }
func ExampleF() { ... }
func ExampleT() { ... }
func ExampleT_M() { ... }
</pre> <p> Multiple example functions for a package/type/function/method may be provided by appending a distinct suffix to the name. The suffix must start with a lower-case letter. </p> <pre data-language="go">func Example_suffix() { ... }
func ExampleF_suffix() { ... }
func ExampleT_suffix() { ... }
func ExampleT_M_suffix() { ... }
</pre> <p> The entire test file is presented as the example when it contains a single example function, at least one other function, type, variable, or constant declaration, and no test or benchmark functions. </p> <h3 id="hdr-Skipping">Skipping</h3> <p> Tests or benchmarks may be skipped at run time with a call to the Skip method of *T or *B: </p> <pre data-language="go">func TestTimeConsuming(t *testing.T) {
    if testing.Short() {
        t.Skip("skipping test in short mode.")
    }
    ...
}
</pre> <h3 id="hdr-Subtests_and_Sub_benchmarks">Subtests and Sub-benchmarks</h3> <p> The Run methods of T and B allow defining subtests and sub-benchmarks, without having to define separate functions for each. This enables uses like table-driven benchmarks and creating hierarchical tests. It also provides a way to share common setup and tear-down code: </p> <pre data-language="go">func TestFoo(t *testing.T) {
    // &lt;setup code&gt;
    t.Run("A=1", func(t *testing.T) { ... })
    t.Run("A=2", func(t *testing.T) { ... })
    t.Run("B=1", func(t *testing.T) { ... })
    // &lt;tear-down code&gt;
}
</pre> <p> Each subtest and sub-benchmark has a unique name: the combination of the name of the top-level test and the sequence of names passed to Run, separated by slashes, with an optional trailing sequence number for disambiguation. </p> <p> The argument to the -run and -bench command-line flags is an unanchored regular expression that matches the test's name. For tests with multiple slash-separated elements, such as subtests, the argument is itself slash-separated, with expressions matching each name element in turn. Because it is unanchored, an empty expression matches any string. For example, using "matching" to mean "whose name contains": </p> <pre data-language="go">go test -run ''      # Run all tests.
go test -run Foo     # Run top-level tests matching "Foo", such as "TestFooBar".
go test -run Foo/A=  # For top-level tests matching "Foo", run subtests matching "A=".
go test -run /A=1    # For all top-level tests, run subtests matching "A=1".
</pre> <p> Subtests can also be used to control parallelism. A parent test will only complete once all of its subtests complete. In this example, all tests are run in parallel with each other, and only with each other, regardless of other top-level tests that may be defined: </p> <pre data-language="go">func TestGroupedParallel(t *testing.T) {
    for _, tc := range tests {
        tc := tc // capture range variable
        t.Run(tc.Name, func(t *testing.T) {
            t.Parallel()
            ...
        })
    }
}
</pre> <p> The race detector kills the program if it exceeds 8192 concurrent goroutines, so use care when running parallel tests with the -race flag set. </p> <p> Run does not return until parallel subtests have completed, providing a way to clean up after a group of parallel tests: </p> <pre data-language="go">func TestTeardownParallel(t *testing.T) {
    // This Run will not return until the parallel tests finish.
    t.Run("group", func(t *testing.T) {
        t.Run("Test1", parallelTest1)
        t.Run("Test2", parallelTest2)
        t.Run("Test3", parallelTest3)
    })
    // &lt;tear-down code&gt;
}
</pre> <h3 id="hdr-Main">Main</h3> <p> It is sometimes necessary for a test program to do extra setup or teardown before or after testing. It is also sometimes necessary for a test to control which code runs on the main thread. To support these and other cases, if a test file contains a function: </p> <pre data-language="go">func TestMain(m *testing.M)
</pre> <p> then the generated test will call TestMain(m) instead of running the tests directly. TestMain runs in the main goroutine and can do whatever setup and teardown is necessary around a call to m.Run. m.Run will return an exit code that may be passed to os.Exit. If TestMain returns, the test wrapper will pass the result of m.Run to os.Exit itself. </p> <p> When TestMain is called, flag.Parse has not been run. If TestMain depends on command-line flags, including those of the testing package, it should call flag.Parse explicitly. Command line flags are always parsed by the time test or benchmark functions run. </p> <p> A simple implementation of TestMain is: </p> <pre data-language="go">func TestMain(m *testing.M) {
	// call flag.Parse() here if TestMain uses flags
	os.Exit(m.Run())
}
</pre>      <h2 id="pkg-index">Index </h2>  <ul id="manual-nav">
<li><a href="#AllocsPerRun">func AllocsPerRun(runs int, f func()) (avg float64)</a></li>
<li><a href="#CoverMode">func CoverMode() string</a></li>
<li><a href="#Coverage">func Coverage() float64</a></li>
<li><a href="#Init">func Init()</a></li>
<li><a href="#Main">func Main(matchString func(pat, str string) (bool, error), tests []InternalTest, benchmarks []InternalBenchmark, examples []InternalExample)</a></li>
<li><a href="#RegisterCover">func RegisterCover(c Cover)</a></li>
<li><a href="#RunBenchmarks">func RunBenchmarks(matchString func(pat, str string) (bool, error), benchmarks []InternalBenchmark)</a></li>
<li><a href="#RunExamples">func RunExamples(matchString func(pat, str string) (bool, error), examples []InternalExample) (ok bool)</a></li>
<li><a href="#RunTests">func RunTests(matchString func(pat, str string) (bool, error), tests []InternalTest) (ok bool)</a></li>
<li><a href="#Short">func Short() bool</a></li>
<li><a href="#Verbose">func Verbose() bool</a></li>
<li><a href="#B">type B</a></li>
<li> <a href="#B.Cleanup">func (c *B) Cleanup(f func())</a>
</li>
<li> <a href="#B.Error">func (c *B) Error(args ...interface{})</a>
</li>
<li> <a href="#B.Errorf">func (c *B) Errorf(format string, args ...interface{})</a>
</li>
<li> <a href="#B.Fail">func (c *B) Fail()</a>
</li>
<li> <a href="#B.FailNow">func (c *B) FailNow()</a>
</li>
<li> <a href="#B.Failed">func (c *B) Failed() bool</a>
</li>
<li> <a href="#B.Fatal">func (c *B) Fatal(args ...interface{})</a>
</li>
<li> <a href="#B.Fatalf">func (c *B) Fatalf(format string, args ...interface{})</a>
</li>
<li> <a href="#B.Helper">func (c *B) Helper()</a>
</li>
<li> <a href="#B.Log">func (c *B) Log(args ...interface{})</a>
</li>
<li> <a href="#B.Logf">func (c *B) Logf(format string, args ...interface{})</a>
</li>
<li> <a href="#B.Name">func (c *B) Name() string</a>
</li>
<li> <a href="#B.ReportAllocs">func (b *B) ReportAllocs()</a>
</li>
<li> <a href="#B.ReportMetric">func (b *B) ReportMetric(n float64, unit string)</a>
</li>
<li> <a href="#B.ResetTimer">func (b *B) ResetTimer()</a>
</li>
<li> <a href="#B.Run">func (b *B) Run(name string, f func(b *B)) bool</a>
</li>
<li> <a href="#B.RunParallel">func (b *B) RunParallel(body func(*PB))</a>
</li>
<li> <a href="#B.SetBytes">func (b *B) SetBytes(n int64)</a>
</li>
<li> <a href="#B.SetParallelism">func (b *B) SetParallelism(p int)</a>
</li>
<li> <a href="#B.Skip">func (c *B) Skip(args ...interface{})</a>
</li>
<li> <a href="#B.SkipNow">func (c *B) SkipNow()</a>
</li>
<li> <a href="#B.Skipf">func (c *B) Skipf(format string, args ...interface{})</a>
</li>
<li> <a href="#B.Skipped">func (c *B) Skipped() bool</a>
</li>
<li> <a href="#B.StartTimer">func (b *B) StartTimer()</a>
</li>
<li> <a href="#B.StopTimer">func (b *B) StopTimer()</a>
</li>
<li> <a href="#B.TempDir">func (c *B) TempDir() string</a>
</li>
<li><a href="#BenchmarkResult">type BenchmarkResult</a></li>
<li> <a href="#Benchmark">func Benchmark(f func(b *B)) BenchmarkResult</a>
</li>
<li> <a href="#BenchmarkResult.AllocedBytesPerOp">func (r BenchmarkResult) AllocedBytesPerOp() int64</a>
</li>
<li> <a href="#BenchmarkResult.AllocsPerOp">func (r BenchmarkResult) AllocsPerOp() int64</a>
</li>
<li> <a href="#BenchmarkResult.MemString">func (r BenchmarkResult) MemString() string</a>
</li>
<li> <a href="#BenchmarkResult.NsPerOp">func (r BenchmarkResult) NsPerOp() int64</a>
</li>
<li> <a href="#BenchmarkResult.String">func (r BenchmarkResult) String() string</a>
</li>
<li><a href="#Cover">type Cover</a></li>
<li><a href="#CoverBlock">type CoverBlock</a></li>
<li><a href="#InternalBenchmark">type InternalBenchmark</a></li>
<li><a href="#InternalExample">type InternalExample</a></li>
<li><a href="#InternalTest">type InternalTest</a></li>
<li><a href="#M">type M</a></li>
<li> <a href="#MainStart">func MainStart(deps testDeps, tests []InternalTest, benchmarks []InternalBenchmark, examples []InternalExample) *M</a>
</li>
<li> <a href="#M.Run">func (m *M) Run() (code int)</a>
</li>
<li><a href="#PB">type PB</a></li>
<li> <a href="#PB.Next">func (pb *PB) Next() bool</a>
</li>
<li><a href="#T">type T</a></li>
<li> <a href="#T.Cleanup">func (c *T) Cleanup(f func())</a>
</li>
<li> <a href="#T.Deadline">func (t *T) Deadline() (deadline time.Time, ok bool)</a>
</li>
<li> <a href="#T.Error">func (c *T) Error(args ...interface{})</a>
</li>
<li> <a href="#T.Errorf">func (c *T) Errorf(format string, args ...interface{})</a>
</li>
<li> <a href="#T.Fail">func (c *T) Fail()</a>
</li>
<li> <a href="#T.FailNow">func (c *T) FailNow()</a>
</li>
<li> <a href="#T.Failed">func (c *T) Failed() bool</a>
</li>
<li> <a href="#T.Fatal">func (c *T) Fatal(args ...interface{})</a>
</li>
<li> <a href="#T.Fatalf">func (c *T) Fatalf(format string, args ...interface{})</a>
</li>
<li> <a href="#T.Helper">func (c *T) Helper()</a>
</li>
<li> <a href="#T.Log">func (c *T) Log(args ...interface{})</a>
</li>
<li> <a href="#T.Logf">func (c *T) Logf(format string, args ...interface{})</a>
</li>
<li> <a href="#T.Name">func (c *T) Name() string</a>
</li>
<li> <a href="#T.Parallel">func (t *T) Parallel()</a>
</li>
<li> <a href="#T.Run">func (t *T) Run(name string, f func(t *T)) bool</a>
</li>
<li> <a href="#T.Skip">func (c *T) Skip(args ...interface{})</a>
</li>
<li> <a href="#T.SkipNow">func (c *T) SkipNow()</a>
</li>
<li> <a href="#T.Skipf">func (c *T) Skipf(format string, args ...interface{})</a>
</li>
<li> <a href="#T.Skipped">func (c *T) Skipped() bool</a>
</li>
<li> <a href="#T.TempDir">func (c *T) TempDir() string</a>
</li>
<li><a href="#TB">type TB</a></li>
</ul> <div id="pkg-examples"> <h3>Examples</h3>  <dl> <dd><a class="exampleLink" href="#example_B_ReportMetric">B.ReportMetric</a></dd> <dd><a class="exampleLink" href="#example_B_RunParallel">B.RunParallel</a></dd> </dl> </div> <h3>Package files</h3> <p>  <a href="https://golang.org/src/testing/allocs.go">allocs.go</a> <a href="https://golang.org/src/testing/benchmark.go">benchmark.go</a> <a href="https://golang.org/src/testing/cover.go">cover.go</a> <a href="https://golang.org/src/testing/example.go">example.go</a> <a href="https://golang.org/src/testing/match.go">match.go</a> <a href="https://golang.org/src/testing/run_example.go">run_example.go</a> <a href="https://golang.org/src/testing/testing.go">testing.go</a>  </p>   <h2 id="AllocsPerRun">func AllocsPerRun<a href="https://golang.org/src/testing/allocs.go?s=669:720#L10" class="source">Source</a>  <span title="Added in Go 1.1">1.1</span> </h2> <pre data-language="go">func AllocsPerRun(runs int, f func()) (avg float64)</pre> <p> AllocsPerRun returns the average number of allocations during calls to f. Although the return value has type float64, it will always be an integral value. </p> <p> To compute the number of allocations, the function will first be run once as a warm-up. The average number of allocations over the specified number of runs will then be measured and returned. </p> <p> AllocsPerRun sets GOMAXPROCS to 1 during its measurement and will restore it before returning. </p> <h2 id="CoverMode">func CoverMode<a href="https://golang.org/src/testing/testing.go?s=16728:16751#L426" class="source">Source</a>  <span title="Added in Go 1.8">1.8</span> </h2> <pre data-language="go">func CoverMode() string</pre> <p> CoverMode reports what the test coverage mode is set to. The values are "set", "count", or "atomic". The return value will be empty if test coverage is not enabled. </p> <h2 id="Coverage">func Coverage<a href="https://golang.org/src/testing/cover.go?s=1633:1656#L38" class="source">Source</a>  <span title="Added in Go 1.4">1.4</span> </h2> <pre data-language="go">func Coverage() float64</pre> <p> Coverage reports the current code coverage as a fraction in the range [0, 1]. If coverage is not enabled, Coverage returns 0. </p> <p> When running a large set of sequential test cases, checking Coverage after each one can be useful for identifying which test cases exercise new code paths. It is not a replacement for the reports generated by 'go test -cover' and 'go tool cover'. </p> <h2 id="Init">func Init<a href="https://golang.org/src/testing/testing.go?s=9320:9331#L254" class="source">Source</a>  <span title="Added in Go 1.13">1.13</span> </h2> <pre data-language="go">func Init()</pre> <p> Init registers testing flags. These flags are automatically registered by the "go test" command before running test functions, so Init is only needed when calling functions such as Benchmark without using "go test". </p> <p> Init has no effect if it was already called. </p> <h2 id="Main">func Main<a href="https://golang.org/src/testing/testing.go?s=41868:42008#L1251" class="source">Source</a>  </h2> <pre data-language="go">func Main(matchString func(pat, str string) (bool, error), tests []InternalTest, benchmarks []InternalBenchmark, examples []InternalExample)</pre> <p> Main is an internal function, part of the implementation of the "go test" command. It was exported because it is cross-package and predates "internal" packages. It is no longer used by "go test" but preserved, as much as possible, for other systems that simulate "go test" using Main, but Main sometimes cannot be updated as new functionality is added to the testing package. Systems simulating "go test" should be updated to use MainStart. </p> <h2 id="RegisterCover">func RegisterCover<a href="https://golang.org/src/testing/cover.go?s=2096:2123#L57" class="source">Source</a>  <span title="Added in Go 1.2">1.2</span> </h2> <pre data-language="go">func RegisterCover(c Cover)</pre> <p> RegisterCover records the coverage data accumulators for the tests. NOTE: This function is internal to the testing infrastructure and may change. It is not covered (yet) by the Go 1 compatibility guidelines. </p> <h2 id="RunBenchmarks">func RunBenchmarks<a href="https://golang.org/src/testing/benchmark.go?s=13764:13863#L484" class="source">Source</a>  </h2> <pre data-language="go">func RunBenchmarks(matchString func(pat, str string) (bool, error), benchmarks []InternalBenchmark)</pre> <p> RunBenchmarks is an internal function but exported because it is cross-package; it is part of the implementation of the "go test" command. </p> <h2 id="RunExamples">func RunExamples<a href="https://golang.org/src/testing/example.go?s=475:578#L14" class="source">Source</a>  </h2> <pre data-language="go">func RunExamples(matchString func(pat, str string) (bool, error), examples []InternalExample) (ok bool)</pre> <p> RunExamples is an internal function but exported because it is cross-package; it is part of the implementation of the "go test" command. </p> <h2 id="RunTests">func RunTests<a href="https://golang.org/src/testing/testing.go?s=45927:46021#L1394" class="source">Source</a>  </h2> <pre data-language="go">func RunTests(matchString func(pat, str string) (bool, error), tests []InternalTest) (ok bool)</pre> <p> RunTests is an internal function but exported because it is cross-package; it is part of the implementation of the "go test" command. </p> <h2 id="Short">func Short<a href="https://golang.org/src/testing/testing.go?s=16299:16316#L411" class="source">Source</a>  </h2> <pre data-language="go">func Short() bool</pre> <p> Short reports whether the -test.short flag is set. </p> <h2 id="Verbose">func Verbose<a href="https://golang.org/src/testing/testing.go?s=16828:16847#L431" class="source">Source</a>  <span title="Added in Go 1.1">1.1</span> </h2> <pre data-language="go">func Verbose() bool</pre> <p> Verbose reports whether the -test.v flag is set. </p> <h2 id="B">type B<a href="https://golang.org/src/testing/benchmark.go?s=2453:3341#L82" class="source">Source</a>  </h2> <p> B is a type passed to Benchmark functions to manage benchmark timing and to specify the number of iterations to run. </p> <p> A benchmark ends when its Benchmark function returns or calls any of the methods FailNow, Fatal, Fatalf, SkipNow, Skip, or Skipf. Those methods must be called only from the goroutine running the Benchmark function. The other reporting methods, such as the variations of Log and Error, may be called simultaneously from multiple goroutines. </p> <p> Like in tests, benchmark logs are accumulated during execution and dumped to standard output when done. Unlike in tests, benchmark logs are always printed, so as not to hide output whose existence may be affecting benchmark results. </p> <pre data-language="go">type B struct {
    N int
    // contains filtered or unexported fields
}
</pre> <h3 id="B.Cleanup">func (*B) Cleanup<a href="https://golang.org/src/testing/testing.go?s=29828:29862#L853" class="source">Source</a>  <span title="Added in Go 1.14">1.14</span> </h3> <pre data-language="go">func (c *B) Cleanup(f func())</pre> <p> Cleanup registers a function to be called when the test and all its subtests complete. Cleanup functions will be called in last added, first called order. </p> <h3 id="B.Error">func (*B) Error<a href="https://golang.org/src/testing/testing.go?s=27660:27703#L776" class="source">Source</a>  </h3> <pre data-language="go">func (c *B) Error(args ...interface{})</pre> <p> Error is equivalent to Log followed by Fail. </p> <h3 id="B.Errorf">func (*B) Errorf<a href="https://golang.org/src/testing/testing.go?s=27799:27858#L782" class="source">Source</a>  </h3> <pre data-language="go">func (c *B) Errorf(format string, args ...interface{})</pre> <p> Errorf is equivalent to Logf followed by Fail. </p> <h3 id="B.Fail">func (*B) Fail<a href="https://golang.org/src/testing/testing.go?s=23815:23838#L670" class="source">Source</a>  </h3> <pre data-language="go">func (c *B) Fail()</pre> <p> Fail marks the function as having failed but continues execution. </p> <h3 id="B.FailNow">func (*B) FailNow<a href="https://golang.org/src/testing/testing.go?s=24706:24732#L699" class="source">Source</a>  </h3> <pre data-language="go">func (c *B) FailNow()</pre> <p> FailNow marks the function as having failed and stops its execution by calling runtime.Goexit (which then runs all deferred calls in the current goroutine). Execution will continue at the next test or benchmark. FailNow must be called from the goroutine running the test or benchmark function, not from other goroutines created during the test. Calling FailNow does not stop those other goroutines. </p> <h3 id="B.Failed">func (*B) Failed<a href="https://golang.org/src/testing/testing.go?s=24148:24178#L684" class="source">Source</a>  </h3> <pre data-language="go">func (c *B) Failed() bool</pre> <p> Failed reports whether the function has failed. </p> <h3 id="B.Fatal">func (*B) Fatal<a href="https://golang.org/src/testing/testing.go?s=27962:28005#L788" class="source">Source</a>  </h3> <pre data-language="go">func (c *B) Fatal(args ...interface{})</pre> <p> Fatal is equivalent to Log followed by FailNow. </p> <h3 id="B.Fatalf">func (*B) Fatalf<a href="https://golang.org/src/testing/testing.go?s=28107:28166#L794" class="source">Source</a>  </h3> <pre data-language="go">func (c *B) Fatalf(format string, args ...interface{})</pre> <p> Fatalf is equivalent to Logf followed by FailNow. </p> <h3 id="B.Helper">func (*B) Helper<a href="https://golang.org/src/testing/testing.go?s=29494:29519#L841" class="source">Source</a>  <span title="Added in Go 1.9">1.9</span> </h3> <pre data-language="go">func (c *B) Helper()</pre> <p> Helper marks the calling function as a test helper function. When printing file and line information, that function will be skipped. Helper may be called simultaneously from multiple goroutines. </p> <h3 id="B.Log">func (*B) Log<a href="https://golang.org/src/testing/testing.go?s=27069:27110#L766" class="source">Source</a>  </h3> <pre data-language="go">func (c *B) Log(args ...interface{})</pre> <p> Log formats its arguments using default formatting, analogous to Println, and records the text in the error log. For tests, the text will be printed only if the test fails or the -test.v flag is set. For benchmarks, the text is always printed to avoid having performance depend on the value of the -test.v flag. </p> <h3 id="B.Logf">func (*B) Logf<a href="https://golang.org/src/testing/testing.go?s=27513:27570#L773" class="source">Source</a>  </h3> <pre data-language="go">func (c *B) Logf(format string, args ...interface{})</pre> <p> Logf formats its arguments according to the format, analogous to Printf, and records the text in the error log. A final newline is added if not provided. For tests, the text will be printed only if the test fails or the -test.v flag is set. For benchmarks, the text is always printed to avoid having performance depend on the value of the -test.v flag. </p> <h3 id="B.Name">func (*B) Name<a href="https://golang.org/src/testing/testing.go?s=23571:23601#L656" class="source">Source</a>  <span title="Added in Go 1.8">1.8</span> </h3> <pre data-language="go">func (c *B) Name() string</pre> <p> Name returns the name of the running test or benchmark. </p> <h3 id="B.ReportAllocs">func (*B) ReportAllocs<a href="https://golang.org/src/testing/benchmark.go?s=5099:5125#L164" class="source">Source</a>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (b *B) ReportAllocs()</pre> <p> ReportAllocs enables malloc statistics for this benchmark. It is equivalent to setting -test.benchmem, but it only affects the benchmark function that calls ReportAllocs. </p> <h3 id="B.ReportMetric">func (*B) ReportMetric<a href="https://golang.org/src/testing/benchmark.go?s=9641:9689#L326" class="source">Source</a>  <span title="Added in Go 1.13">1.13</span> </h3> <pre data-language="go">func (b *B) ReportMetric(n float64, unit string)</pre> <p> ReportMetric adds "n unit" to the reported benchmark results. If the metric is per-iteration, the caller should divide by b.N, and by convention units should end in "/op". ReportMetric overrides any previously reported value for the same unit. ReportMetric panics if unit is the empty string or if unit contains any whitespace. If unit is a unit normally reported by the benchmark framework itself (such as "allocs/op"), ReportMetric will override that metric. Setting "ns/op" to 0 will suppress that built-in metric. </p>    <h4 id="example_B_ReportMetric"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"sort"
	"testing"
)

func main() {
	// This reports a custom benchmark metric relevant to a
	// specific algorithm (in this case, sorting).
	testing.Benchmark(func(b *testing.B) {
		var compares int64
		for i := 0; i &lt; b.N; i++ {
			s := []int{5, 4, 3, 2, 1}
			sort.Slice(s, func(i, j int) bool {
				compares++
				return s[i] &lt; s[j]
			})
		}
		// This metric is per-operation, so divide by b.N and
		// report it as a "/op" unit.
		b.ReportMetric(float64(compares)/float64(b.N), "compares/op")
	})
}
</pre>   <h3 id="B.ResetTimer">func (*B) ResetTimer<a href="https://golang.org/src/testing/benchmark.go?s=4272:4296#L136" class="source">Source</a>  </h3> <pre data-language="go">func (b *B) ResetTimer()</pre> <p> ResetTimer zeroes the elapsed benchmark time and memory allocation counters and deletes user-reported metrics. It does not affect whether the timer is running. </p> <h3 id="B.Run">func (*B) Run<a href="https://golang.org/src/testing/benchmark.go?s=17060:17107#L596" class="source">Source</a>  <span title="Added in Go 1.7">1.7</span> </h3> <pre data-language="go">func (b *B) Run(name string, f func(b *B)) bool</pre> <p> Run benchmarks f as a subbenchmark with the given name. It reports whether there were any failures. </p> <p> A subbenchmark is like any other benchmark. A benchmark that calls Run at least once will not be measured itself and will be called once with N=1. </p> <h3 id="B.RunParallel">func (*B) RunParallel<a href="https://golang.org/src/testing/benchmark.go?s=20925:20964#L726" class="source">Source</a>  <span title="Added in Go 1.3">1.3</span> </h3> <pre data-language="go">func (b *B) RunParallel(body func(*PB))</pre> <p> RunParallel runs a benchmark in parallel. It creates multiple goroutines and distributes b.N iterations among them. The number of goroutines defaults to GOMAXPROCS. To increase parallelism for non-CPU-bound benchmarks, call SetParallelism before RunParallel. RunParallel is usually used with the go test -cpu flag. </p> <p> The body function will be run in each goroutine. It should set up any goroutine-local state and then iterate until pb.Next returns false. It should not use the StartTimer, StopTimer, or ResetTimer functions, because they have global effect. It should also not call Run. </p>    <h4 id="example_B_RunParallel"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"testing"
	"text/template"
)

func main() {
	// Parallel benchmark for text/template.Template.Execute on a single object.
	testing.Benchmark(func(b *testing.B) {
		templ := template.Must(template.New("test").Parse("Hello, {{.}}!"))
		// RunParallel will create GOMAXPROCS goroutines
		// and distribute work among them.
		b.RunParallel(func(pb *testing.PB) {
			// Each goroutine has its own bytes.Buffer.
			var buf bytes.Buffer
			for pb.Next() {
				// The loop body is executed b.N times total across all goroutines.
				buf.Reset()
				templ.Execute(&amp;buf, "World")
			}
		})
	})
}
</pre>   <h3 id="B.SetBytes">func (*B) SetBytes<a href="https://golang.org/src/testing/benchmark.go?s=4872:4901#L159" class="source">Source</a>  </h3> <pre data-language="go">func (b *B) SetBytes(n int64)</pre> <p> SetBytes records the number of bytes processed in a single operation. If this is called, the benchmark will report ns/op and MB/s. </p> <h3 id="B.SetParallelism">func (*B) SetParallelism<a href="https://golang.org/src/testing/benchmark.go?s=22132:22165#L770" class="source">Source</a>  <span title="Added in Go 1.3">1.3</span> </h3> <pre data-language="go">func (b *B) SetParallelism(p int)</pre> <p> SetParallelism sets the number of goroutines used by RunParallel to p*GOMAXPROCS. There is usually no need to call SetParallelism for CPU-bound benchmarks. If p is less than 1, this call will have no effect. </p> <h3 id="B.Skip">func (*B) Skip<a href="https://golang.org/src/testing/testing.go?s=28272:28314#L800" class="source">Source</a>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (c *B) Skip(args ...interface{})</pre> <p> Skip is equivalent to Log followed by SkipNow. </p> <h3 id="B.SkipNow">func (*B) SkipNow<a href="https://golang.org/src/testing/testing.go?s=28990:29016#L819" class="source">Source</a>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (c *B) SkipNow()</pre> <p> SkipNow marks the test as having been skipped and stops its execution by calling runtime.Goexit. If a test fails (see Error, Errorf, Fail) and is then skipped, it is still considered to have failed. Execution will continue at the next test or benchmark. See also FailNow. SkipNow must be called from the goroutine running the test, not from other goroutines created during the test. Calling SkipNow does not stop those other goroutines. </p> <h3 id="B.Skipf">func (*B) Skipf<a href="https://golang.org/src/testing/testing.go?s=28415:28473#L806" class="source">Source</a>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (c *B) Skipf(format string, args ...interface{})</pre> <p> Skipf is equivalent to Logf followed by SkipNow. </p> <h3 id="B.Skipped">func (*B) Skipped<a href="https://golang.org/src/testing/testing.go?s=29199:29230#L832" class="source">Source</a>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (c *B) Skipped() bool</pre> <p> Skipped reports whether the test was skipped. </p> <h3 id="B.StartTimer">func (*B) StartTimer<a href="https://golang.org/src/testing/benchmark.go?s=3518:3542#L110" class="source">Source</a>  </h3> <pre data-language="go">func (b *B) StartTimer()</pre> <p> StartTimer starts timing a test. This function is called automatically before a benchmark starts, but it can also be used to resume timing after a call to StopTimer. </p> <h3 id="B.StopTimer">func (*B) StopTimer<a href="https://golang.org/src/testing/benchmark.go?s=3864:3887#L123" class="source">Source</a>  </h3> <pre data-language="go">func (b *B) StopTimer()</pre> <p> StopTimer stops timing a test. This can be used to pause the timer while performing complex initialization that you don't want to measure. </p> <h3 id="B.TempDir">func (*B) TempDir<a href="https://golang.org/src/testing/testing.go?s=30725:30758#L888" class="source">Source</a>  <span title="Added in Go 1.15">1.15</span> </h3> <pre data-language="go">func (c *B) TempDir() string</pre> <p> TempDir returns a temporary directory for the test to use. The directory is automatically removed by Cleanup when the test and all its subtests complete. Each subsequent call to t.TempDir returns a unique directory; if the directory creation fails, TempDir terminates the test by calling Fatal. </p> <h2 id="BenchmarkResult">type BenchmarkResult<a href="https://golang.org/src/testing/benchmark.go?s=9941:10361#L337" class="source">Source</a>  </h2> <p> BenchmarkResult contains the results of a benchmark run. </p> <pre data-language="go">type BenchmarkResult struct {
    N         int           // The number of iterations.
    T         time.Duration // The total time taken.
    Bytes     int64         // Bytes processed in one iteration.
    MemAllocs uint64        // The total number of memory allocations; added in Go 1.1
    MemBytes  uint64        // The total number of bytes allocated; added in Go 1.1

    // Extra records additional metrics reported by ReportMetric.
    Extra map[string]float64 // Go 1.13
}
</pre> <h3 id="Benchmark">func Benchmark<a href="https://golang.org/src/testing/benchmark.go?s=22623:22667#L784" class="source">Source</a>  </h3> <pre data-language="go">func Benchmark(f func(b *B)) BenchmarkResult</pre> <p> Benchmark benchmarks a single function. It is useful for creating custom benchmarks that do not use the "go test" command. </p> <p> If f depends on testing flags, then Init must be used to register those flags before calling Benchmark and before calling flag.Parse. </p> <p> If f calls Run, the result will be an estimate of running all its subbenchmarks that don't call Run in sequence in a single benchmark. </p> <h3 id="BenchmarkResult.AllocedBytesPerOp">func (BenchmarkResult) AllocedBytesPerOp<a href="https://golang.org/src/testing/benchmark.go?s=11195:11245#L384" class="source">Source</a>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (r BenchmarkResult) AllocedBytesPerOp() int64</pre> <p> AllocedBytesPerOp returns the "B/op" metric, which is calculated as r.MemBytes / r.N. </p> <h3 id="BenchmarkResult.AllocsPerOp">func (BenchmarkResult) AllocsPerOp<a href="https://golang.org/src/testing/benchmark.go?s=10923:10967#L372" class="source">Source</a>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (r BenchmarkResult) AllocsPerOp() int64</pre> <p> AllocsPerOp returns the "allocs/op" metric, which is calculated as r.MemAllocs / r.N. </p> <h3 id="BenchmarkResult.MemString">func (BenchmarkResult) MemString<a href="https://golang.org/src/testing/benchmark.go?s=13150:13193#L462" class="source">Source</a>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (r BenchmarkResult) MemString() string</pre> <p> MemString returns r.AllocedBytesPerOp and r.AllocsPerOp in the same format as 'go test'. </p> <h3 id="BenchmarkResult.NsPerOp">func (BenchmarkResult) NsPerOp<a href="https://golang.org/src/testing/benchmark.go?s=10402:10442#L349" class="source">Source</a>  </h3> <pre data-language="go">func (r BenchmarkResult) NsPerOp() int64</pre> <p> NsPerOp returns the "ns/op" metric. </p> <h3 id="BenchmarkResult.String">func (BenchmarkResult) String<a href="https://golang.org/src/testing/benchmark.go?s=11720:11760#L401" class="source">Source</a>  </h3> <pre data-language="go">func (r BenchmarkResult) String() string</pre> <p> String returns a summary of the benchmark results. It follows the benchmark result line format from <a href="https://golang.org/design/14313-benchmark-format">https://golang.org/design/14313-benchmark-format</a>, not including the benchmark name. Extra metrics override built-in metrics of the same name. String does not include allocs/op or B/op, since those are reported by MemString. </p> <h2 id="Cover">type Cover<a href="https://golang.org/src/testing/cover.go?s=1090:1237#L24" class="source">Source</a>  <span title="Added in Go 1.2">1.2</span> </h2> <p> Cover records information about test coverage checking. NOTE: This struct is internal to the testing infrastructure and may change. It is not covered (yet) by the Go 1 compatibility guidelines. </p> <pre data-language="go">type Cover struct {
    Mode            string
    Counters        map[string][]uint32
    Blocks          map[string][]CoverBlock
    CoveredPackages string
}
</pre> <h2 id="CoverBlock">type CoverBlock<a href="https://golang.org/src/testing/cover.go?s=596:868#L11" class="source">Source</a>  <span title="Added in Go 1.2">1.2</span> </h2> <p> CoverBlock records the coverage data for a single basic block. The fields are 1-indexed, as in an editor: The opening line of the file is number 1, for example. Columns are measured in bytes. NOTE: This struct is internal to the testing infrastructure and may change. It is not covered (yet) by the Go 1 compatibility guidelines. </p> <pre data-language="go">type CoverBlock struct {
    Line0 uint32 // Line number for block start.
    Col0  uint16 // Column number for block start.
    Line1 uint32 // Line number for block end.
    Col1  uint16 // Column number for block end.
    Stmts uint16 // Number of statements included in this block.
}
</pre> <h2 id="InternalBenchmark">type InternalBenchmark<a href="https://golang.org/src/testing/benchmark.go?s=1659:1722#L64" class="source">Source</a>  </h2> <p> InternalBenchmark is an internal type but exported because it is cross-package; it is part of the implementation of the "go test" command. </p> <pre data-language="go">type InternalBenchmark struct {
    Name string
    F    func(b *B)
}
</pre> <h2 id="InternalExample">type InternalExample<a href="https://golang.org/src/testing/example.go?s=229:330#L5" class="source">Source</a>  </h2> <pre data-language="go">type InternalExample struct {
    Name      string
    F         func()
    Output    string
    Unordered bool // Go 1.7
}
</pre> <h2 id="InternalTest">type InternalTest<a href="https://golang.org/src/testing/testing.go?s=34325:34381#L1008" class="source">Source</a>  </h2> <p> InternalTest is an internal type but exported because it is cross-package; it is part of the implementation of the "go test" command. </p> <pre data-language="go">type InternalTest struct {
    Name string
    F    func(*T)
}
</pre> <h2 id="M">type M<a href="https://golang.org/src/testing/testing.go?s=42169:42478#L1256" class="source">Source</a>  <span title="Added in Go 1.4">1.4</span> </h2> <p> M is a type passed to a TestMain function to run the actual tests. </p> <pre data-language="go">type M struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="MainStart">func MainStart<a href="https://golang.org/src/testing/testing.go?s=43149:43263#L1289" class="source">Source</a>  <span title="Added in Go 1.8">1.8</span> </h3> <pre data-language="go">func MainStart(deps testDeps, tests []InternalTest, benchmarks []InternalBenchmark, examples []InternalExample) *M</pre> <p> MainStart is meant for use by tests generated by 'go test'. It is not meant to be called directly and is not subject to the Go 1 compatibility document. It may change signature from release to release. </p> <h3 id="M.Run">func (*M) Run<a href="https://golang.org/src/testing/testing.go?s=43450:43478#L1300" class="source">Source</a>  <span title="Added in Go 1.4">1.4</span> </h3> <pre data-language="go">func (m *M) Run() (code int)</pre> <p> Run runs the tests. It returns an exit code to pass to os.Exit. </p> <h2 id="PB">type PB<a href="https://golang.org/src/testing/benchmark.go?s=19699:19981#L693" class="source">Source</a>  <span title="Added in Go 1.3">1.3</span> </h2> <p> A PB is used by RunParallel for running parallel benchmarks. </p> <pre data-language="go">type PB struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="PB.Next">func (*PB) Next<a href="https://golang.org/src/testing/benchmark.go?s=20045:20070#L701" class="source">Source</a>  <span title="Added in Go 1.3">1.3</span> </h3> <pre data-language="go">func (pb *PB) Next() bool</pre> <p> Next reports whether there are more iterations to execute. </p> <h2 id="T">type T<a href="https://golang.org/src/testing/testing.go?s=23377:23479#L647" class="source">Source</a>  </h2> <p> T is a type passed to Test functions to manage test state and support formatted test logs. </p> <p> A test ends when its Test function returns or calls any of the methods FailNow, Fatal, Fatalf, SkipNow, Skip, or Skipf. Those methods, as well as the Parallel method, must be called only from the goroutine running the Test function. </p> <p> The other reporting methods, such as the variations of Log and Error, may be called simultaneously from multiple goroutines. </p> <pre data-language="go">type T struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="T.Cleanup">func (*T) Cleanup<a href="https://golang.org/src/testing/testing.go?s=29828:29862#L853" class="source">Source</a>  <span title="Added in Go 1.14">1.14</span> </h3> <pre data-language="go">func (c *T) Cleanup(f func())</pre> <p> Cleanup registers a function to be called when the test and all its subtests complete. Cleanup functions will be called in last added, first called order. </p> <h3 id="T.Deadline">func (*T) Deadline<a href="https://golang.org/src/testing/testing.go?s=39202:39254#L1171" class="source">Source</a>  <span title="Added in Go 1.15">1.15</span> </h3> <pre data-language="go">func (t *T) Deadline() (deadline time.Time, ok bool)</pre> <p> Deadline reports the time at which the test binary will have exceeded the timeout specified by the -timeout flag. </p> <p> The ok result is false if the -timeout flag indicates “no timeout” (0). </p> <h3 id="T.Error">func (*T) Error<a href="https://golang.org/src/testing/testing.go?s=27660:27703#L776" class="source">Source</a>  </h3> <pre data-language="go">func (c *T) Error(args ...interface{})</pre> <p> Error is equivalent to Log followed by Fail. </p> <h3 id="T.Errorf">func (*T) Errorf<a href="https://golang.org/src/testing/testing.go?s=27799:27858#L782" class="source">Source</a>  </h3> <pre data-language="go">func (c *T) Errorf(format string, args ...interface{})</pre> <p> Errorf is equivalent to Logf followed by Fail. </p> <h3 id="T.Fail">func (*T) Fail<a href="https://golang.org/src/testing/testing.go?s=23815:23838#L670" class="source">Source</a>  </h3> <pre data-language="go">func (c *T) Fail()</pre> <p> Fail marks the function as having failed but continues execution. </p> <h3 id="T.FailNow">func (*T) FailNow<a href="https://golang.org/src/testing/testing.go?s=24706:24732#L699" class="source">Source</a>  </h3> <pre data-language="go">func (c *T) FailNow()</pre> <p> FailNow marks the function as having failed and stops its execution by calling runtime.Goexit (which then runs all deferred calls in the current goroutine). Execution will continue at the next test or benchmark. FailNow must be called from the goroutine running the test or benchmark function, not from other goroutines created during the test. Calling FailNow does not stop those other goroutines. </p> <h3 id="T.Failed">func (*T) Failed<a href="https://golang.org/src/testing/testing.go?s=24148:24178#L684" class="source">Source</a>  </h3> <pre data-language="go">func (c *T) Failed() bool</pre> <p> Failed reports whether the function has failed. </p> <h3 id="T.Fatal">func (*T) Fatal<a href="https://golang.org/src/testing/testing.go?s=27962:28005#L788" class="source">Source</a>  </h3> <pre data-language="go">func (c *T) Fatal(args ...interface{})</pre> <p> Fatal is equivalent to Log followed by FailNow. </p> <h3 id="T.Fatalf">func (*T) Fatalf<a href="https://golang.org/src/testing/testing.go?s=28107:28166#L794" class="source">Source</a>  </h3> <pre data-language="go">func (c *T) Fatalf(format string, args ...interface{})</pre> <p> Fatalf is equivalent to Logf followed by FailNow. </p> <h3 id="T.Helper">func (*T) Helper<a href="https://golang.org/src/testing/testing.go?s=29494:29519#L841" class="source">Source</a>  <span title="Added in Go 1.9">1.9</span> </h3> <pre data-language="go">func (c *T) Helper()</pre> <p> Helper marks the calling function as a test helper function. When printing file and line information, that function will be skipped. Helper may be called simultaneously from multiple goroutines. </p> <h3 id="T.Log">func (*T) Log<a href="https://golang.org/src/testing/testing.go?s=27069:27110#L766" class="source">Source</a>  </h3> <pre data-language="go">func (c *T) Log(args ...interface{})</pre> <p> Log formats its arguments using default formatting, analogous to Println, and records the text in the error log. For tests, the text will be printed only if the test fails or the -test.v flag is set. For benchmarks, the text is always printed to avoid having performance depend on the value of the -test.v flag. </p> <h3 id="T.Logf">func (*T) Logf<a href="https://golang.org/src/testing/testing.go?s=27513:27570#L773" class="source">Source</a>  </h3> <pre data-language="go">func (c *T) Logf(format string, args ...interface{})</pre> <p> Logf formats its arguments according to the format, analogous to Printf, and records the text in the error log. A final newline is added if not provided. For tests, the text will be printed only if the test fails or the -test.v flag is set. For benchmarks, the text is always printed to avoid having performance depend on the value of the -test.v flag. </p> <h3 id="T.Name">func (*T) Name<a href="https://golang.org/src/testing/testing.go?s=23571:23601#L656" class="source">Source</a>  <span title="Added in Go 1.8">1.8</span> </h3> <pre data-language="go">func (c *T) Name() string</pre> <p> Name returns the name of the running test or benchmark. </p> <h3 id="T.Parallel">func (*T) Parallel<a href="https://golang.org/src/testing/testing.go?s=32974:32996#L969" class="source">Source</a>  </h3> <pre data-language="go">func (t *T) Parallel()</pre> <p> Parallel signals that this test is to be run in parallel with (and only with) other parallel tests. When a test is run multiple times due to use of -test.count or -test.cpu, multiple instances of a single test never run in parallel with each other. </p> <h3 id="T.Run">func (*T) Run<a href="https://golang.org/src/testing/testing.go?s=37631:37678#L1125" class="source">Source</a>  <span title="Added in Go 1.7">1.7</span> </h3> <pre data-language="go">func (t *T) Run(name string, f func(t *T)) bool</pre> <p> Run runs f as a subtest of t called name. It runs f in a separate goroutine and blocks until f returns or calls t.Parallel to become a parallel test. Run reports whether f succeeded (or at least did not fail before calling t.Parallel). </p> <p> Run may be called simultaneously from multiple goroutines, but all such calls must return before the outer test function for t returns. </p> <h3 id="T.Skip">func (*T) Skip<a href="https://golang.org/src/testing/testing.go?s=28272:28314#L800" class="source">Source</a>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (c *T) Skip(args ...interface{})</pre> <p> Skip is equivalent to Log followed by SkipNow. </p> <h3 id="T.SkipNow">func (*T) SkipNow<a href="https://golang.org/src/testing/testing.go?s=28990:29016#L819" class="source">Source</a>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (c *T) SkipNow()</pre> <p> SkipNow marks the test as having been skipped and stops its execution by calling runtime.Goexit. If a test fails (see Error, Errorf, Fail) and is then skipped, it is still considered to have failed. Execution will continue at the next test or benchmark. See also FailNow. SkipNow must be called from the goroutine running the test, not from other goroutines created during the test. Calling SkipNow does not stop those other goroutines. </p> <h3 id="T.Skipf">func (*T) Skipf<a href="https://golang.org/src/testing/testing.go?s=28415:28473#L806" class="source">Source</a>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (c *T) Skipf(format string, args ...interface{})</pre> <p> Skipf is equivalent to Logf followed by SkipNow. </p> <h3 id="T.Skipped">func (*T) Skipped<a href="https://golang.org/src/testing/testing.go?s=29199:29230#L832" class="source">Source</a>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (c *T) Skipped() bool</pre> <p> Skipped reports whether the test was skipped. </p> <h3 id="T.TempDir">func (*T) TempDir<a href="https://golang.org/src/testing/testing.go?s=30725:30758#L888" class="source">Source</a>  <span title="Added in Go 1.15">1.15</span> </h3> <pre data-language="go">func (c *T) TempDir() string</pre> <p> TempDir returns a temporary directory for the test to use. The directory is automatically removed by Cleanup when the test and all its subtests complete. Each subsequent call to t.TempDir returns a unique directory; if the directory creation fails, TempDir terminates the test by calling Fatal. </p> <h2 id="TB">type TB<a href="https://golang.org/src/testing/testing.go?s=22280:22856#L610" class="source">Source</a>  <span title="Added in Go 1.9">1.9</span> </h2> <p> TB is the interface common to T and B. </p> <pre data-language="go">type TB interface {
    Cleanup(func())
    Error(args ...interface{})
    Errorf(format string, args ...interface{})
    Fail()
    FailNow()
    Failed() bool
    Fatal(args ...interface{})
    Fatalf(format string, args ...interface{})
    Helper()
    Log(args ...interface{})
    Logf(format string, args ...interface{})
    Name() string
    Skip(args ...interface{})
    SkipNow()
    Skipf(format string, args ...interface{})
    Skipped() bool
    TempDir() string
    // contains filtered or unexported methods
}</pre> <h2 id="pkg-subdirectories">Subdirectories</h2> <div class="pkg-dir"> <table> <tr> <th class="pkg-name">Name</th> <th class="pkg-synopsis">Synopsis</th> </tr> <tr> <td colspan="2"><a href="../index">..</a></td> </tr> <tr> <td class="pkg-name"> <a href="iotest/index">iotest</a> </td> <td class="pkg-synopsis"> Package iotest implements Readers and Writers useful mainly for testing. </td> </tr> <tr> <td class="pkg-name"> <a href="quick/index">quick</a> </td> <td class="pkg-synopsis"> Package quick implements utility functions to help with black box testing. </td> </tr> </table> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>
    <a href="https://golang.org/pkg/testing/" class="_attribution-link">https://golang.org/pkg/testing/</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
