
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Go&#47;types - Go - W3cubDocs</title>
  
  <meta name="description" content="Package types declares the data types and implements the algorithms for type-checking of Go packages. Use Config.Check to invoke the type checker &hellip;">
  <meta name="keywords" content="package, types, go">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/go/go/types/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/go.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/go/" class="_nav-link" title="" style="margin-left:0;">Go</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _go">
				
				
<h1> Package types  </h1>    <ul id="short-nav">
<li><code>import "go/types"</code></li>
<li><a href="#pkg-overview" class="overviewLink">Overview</a></li>
<li><a href="#pkg-index" class="indexLink">Index</a></li>
<li><a href="#pkg-examples" class="examplesLink">Examples</a></li>
</ul>     <h2 id="pkg-overview">Overview </h2> <p> Package types declares the data types and implements the algorithms for type-checking of Go packages. Use Config.Check to invoke the type checker for a package. Alternatively, create a new type checker with NewChecker and invoke it incrementally by calling Checker.Files. </p> <p> Type-checking consists of several interdependent phases: </p> <p> Name resolution maps each identifier (ast.Ident) in the program to the language object (Object) it denotes. Use Info.{Defs,Uses,Implicits} for the results of name resolution. </p> <p> Constant folding computes the exact constant value (constant.Value) for every expression (ast.Expr) that is a compile-time constant. Use Info.Types[expr].Value for the results of constant folding. </p> <p> Type inference computes the type (Type) of every expression (ast.Expr) and checks for compliance with the language specification. Use Info.Types[expr].Type for the results of type inference. </p> <p> For a tutorial, see <a href="https://golang.org/s/types-tutorial">https://golang.org/s/types-tutorial</a>. </p>      <h2 id="pkg-index">Index </h2>  <ul id="manual-nav">
<li><a href="#pkg-variables">Variables</a></li>
<li><a href="#AssertableTo">func AssertableTo(V *Interface, T Type) bool</a></li>
<li><a href="#AssignableTo">func AssignableTo(V, T Type) bool</a></li>
<li><a href="#CheckExpr">func CheckExpr(fset *token.FileSet, pkg *Package, pos token.Pos, expr ast.Expr, info *Info) (err error)</a></li>
<li><a href="#Comparable">func Comparable(T Type) bool</a></li>
<li><a href="#ConvertibleTo">func ConvertibleTo(V, T Type) bool</a></li>
<li><a href="#DefPredeclaredTestFuncs">func DefPredeclaredTestFuncs()</a></li>
<li><a href="#ExprString">func ExprString(x ast.Expr) string</a></li>
<li><a href="#Id">func Id(pkg *Package, name string) string</a></li>
<li><a href="#Identical">func Identical(x, y Type) bool</a></li>
<li><a href="#IdenticalIgnoreTags">func IdenticalIgnoreTags(x, y Type) bool</a></li>
<li><a href="#Implements">func Implements(V Type, T *Interface) bool</a></li>
<li><a href="#IsInterface">func IsInterface(typ Type) bool</a></li>
<li><a href="#ObjectString">func ObjectString(obj Object, qf Qualifier) string</a></li>
<li><a href="#SelectionString">func SelectionString(s *Selection, qf Qualifier) string</a></li>
<li><a href="#TypeString">func TypeString(typ Type, qf Qualifier) string</a></li>
<li><a href="#WriteExpr">func WriteExpr(buf *bytes.Buffer, x ast.Expr)</a></li>
<li><a href="#WriteSignature">func WriteSignature(buf *bytes.Buffer, sig *Signature, qf Qualifier)</a></li>
<li><a href="#WriteType">func WriteType(buf *bytes.Buffer, typ Type, qf Qualifier)</a></li>
<li><a href="#Array">type Array</a></li>
<li> <a href="#NewArray">func NewArray(elem Type, len int64) *Array</a>
</li>
<li> <a href="#Array.Elem">func (a *Array) Elem() Type</a>
</li>
<li> <a href="#Array.Len">func (a *Array) Len() int64</a>
</li>
<li> <a href="#Array.String">func (a *Array) String() string</a>
</li>
<li> <a href="#Array.Underlying">func (a *Array) Underlying() Type</a>
</li>
<li><a href="#Basic">type Basic</a></li>
<li> <a href="#Basic.Info">func (b *Basic) Info() BasicInfo</a>
</li>
<li> <a href="#Basic.Kind">func (b *Basic) Kind() BasicKind</a>
</li>
<li> <a href="#Basic.Name">func (b *Basic) Name() string</a>
</li>
<li> <a href="#Basic.String">func (b *Basic) String() string</a>
</li>
<li> <a href="#Basic.Underlying">func (b *Basic) Underlying() Type</a>
</li>
<li><a href="#BasicInfo">type BasicInfo</a></li>
<li><a href="#BasicKind">type BasicKind</a></li>
<li><a href="#Builtin">type Builtin</a></li>
<li> <a href="#Builtin.Exported">func (obj *Builtin) Exported() bool</a>
</li>
<li> <a href="#Builtin.Id">func (obj *Builtin) Id() string</a>
</li>
<li> <a href="#Builtin.Name">func (obj *Builtin) Name() string</a>
</li>
<li> <a href="#Builtin.Parent">func (obj *Builtin) Parent() *Scope</a>
</li>
<li> <a href="#Builtin.Pkg">func (obj *Builtin) Pkg() *Package</a>
</li>
<li> <a href="#Builtin.Pos">func (obj *Builtin) Pos() token.Pos</a>
</li>
<li> <a href="#Builtin.String">func (obj *Builtin) String() string</a>
</li>
<li> <a href="#Builtin.Type">func (obj *Builtin) Type() Type</a>
</li>
<li><a href="#Chan">type Chan</a></li>
<li> <a href="#NewChan">func NewChan(dir ChanDir, elem Type) *Chan</a>
</li>
<li> <a href="#Chan.Dir">func (c *Chan) Dir() ChanDir</a>
</li>
<li> <a href="#Chan.Elem">func (c *Chan) Elem() Type</a>
</li>
<li> <a href="#Chan.String">func (c *Chan) String() string</a>
</li>
<li> <a href="#Chan.Underlying">func (c *Chan) Underlying() Type</a>
</li>
<li><a href="#ChanDir">type ChanDir</a></li>
<li><a href="#Checker">type Checker</a></li>
<li> <a href="#NewChecker">func NewChecker(conf *Config, fset *token.FileSet, pkg *Package, info *Info) *Checker</a>
</li>
<li> <a href="#Checker.Files">func (check *Checker) Files(files []*ast.File) error</a>
</li>
<li><a href="#Config">type Config</a></li>
<li> <a href="#Config.Check">func (conf *Config) Check(path string, fset *token.FileSet, files []*ast.File, info *Info) (*Package, error)</a>
</li>
<li><a href="#Const">type Const</a></li>
<li> <a href="#NewConst">func NewConst(pos token.Pos, pkg *Package, name string, typ Type, val constant.Value) *Const</a>
</li>
<li> <a href="#Const.Exported">func (obj *Const) Exported() bool</a>
</li>
<li> <a href="#Const.Id">func (obj *Const) Id() string</a>
</li>
<li> <a href="#Const.Name">func (obj *Const) Name() string</a>
</li>
<li> <a href="#Const.Parent">func (obj *Const) Parent() *Scope</a>
</li>
<li> <a href="#Const.Pkg">func (obj *Const) Pkg() *Package</a>
</li>
<li> <a href="#Const.Pos">func (obj *Const) Pos() token.Pos</a>
</li>
<li> <a href="#Const.String">func (obj *Const) String() string</a>
</li>
<li> <a href="#Const.Type">func (obj *Const) Type() Type</a>
</li>
<li> <a href="#Const.Val">func (obj *Const) Val() constant.Value</a>
</li>
<li><a href="#Error">type Error</a></li>
<li> <a href="#Error.Error">func (err Error) Error() string</a>
</li>
<li><a href="#Func">type Func</a></li>
<li> <a href="#MissingMethod">func MissingMethod(V Type, T *Interface, static bool) (method *Func, wrongType bool)</a>
</li>
<li> <a href="#NewFunc">func NewFunc(pos token.Pos, pkg *Package, name string, sig *Signature) *Func</a>
</li>
<li> <a href="#Func.Exported">func (obj *Func) Exported() bool</a>
</li>
<li> <a href="#Func.FullName">func (obj *Func) FullName() string</a>
</li>
<li> <a href="#Func.Id">func (obj *Func) Id() string</a>
</li>
<li> <a href="#Func.Name">func (obj *Func) Name() string</a>
</li>
<li> <a href="#Func.Parent">func (obj *Func) Parent() *Scope</a>
</li>
<li> <a href="#Func.Pkg">func (obj *Func) Pkg() *Package</a>
</li>
<li> <a href="#Func.Pos">func (obj *Func) Pos() token.Pos</a>
</li>
<li> <a href="#Func.Scope">func (obj *Func) Scope() *Scope</a>
</li>
<li> <a href="#Func.String">func (obj *Func) String() string</a>
</li>
<li> <a href="#Func.Type">func (obj *Func) Type() Type</a>
</li>
<li><a href="#ImportMode">type ImportMode</a></li>
<li><a href="#Importer">type Importer</a></li>
<li><a href="#ImporterFrom">type ImporterFrom</a></li>
<li><a href="#Info">type Info</a></li>
<li> <a href="#Info.ObjectOf">func (info *Info) ObjectOf(id *ast.Ident) Object</a>
</li>
<li> <a href="#Info.TypeOf">func (info *Info) TypeOf(e ast.Expr) Type</a>
</li>
<li><a href="#Initializer">type Initializer</a></li>
<li> <a href="#Initializer.String">func (init *Initializer) String() string</a>
</li>
<li><a href="#Interface">type Interface</a></li>
<li> <a href="#NewInterface">func NewInterface(methods []*Func, embeddeds []*Named) *Interface</a>
</li>
<li> <a href="#NewInterfaceType">func NewInterfaceType(methods []*Func, embeddeds []Type) *Interface</a>
</li>
<li> <a href="#Interface.Complete">func (t *Interface) Complete() *Interface</a>
</li>
<li> <a href="#Interface.Embedded">func (t *Interface) Embedded(i int) *Named</a>
</li>
<li> <a href="#Interface.EmbeddedType">func (t *Interface) EmbeddedType(i int) Type</a>
</li>
<li> <a href="#Interface.Empty">func (t *Interface) Empty() bool</a>
</li>
<li> <a href="#Interface.ExplicitMethod">func (t *Interface) ExplicitMethod(i int) *Func</a>
</li>
<li> <a href="#Interface.Method">func (t *Interface) Method(i int) *Func</a>
</li>
<li> <a href="#Interface.NumEmbeddeds">func (t *Interface) NumEmbeddeds() int</a>
</li>
<li> <a href="#Interface.NumExplicitMethods">func (t *Interface) NumExplicitMethods() int</a>
</li>
<li> <a href="#Interface.NumMethods">func (t *Interface) NumMethods() int</a>
</li>
<li> <a href="#Interface.String">func (t *Interface) String() string</a>
</li>
<li> <a href="#Interface.Underlying">func (t *Interface) Underlying() Type</a>
</li>
<li><a href="#Label">type Label</a></li>
<li> <a href="#NewLabel">func NewLabel(pos token.Pos, pkg *Package, name string) *Label</a>
</li>
<li> <a href="#Label.Exported">func (obj *Label) Exported() bool</a>
</li>
<li> <a href="#Label.Id">func (obj *Label) Id() string</a>
</li>
<li> <a href="#Label.Name">func (obj *Label) Name() string</a>
</li>
<li> <a href="#Label.Parent">func (obj *Label) Parent() *Scope</a>
</li>
<li> <a href="#Label.Pkg">func (obj *Label) Pkg() *Package</a>
</li>
<li> <a href="#Label.Pos">func (obj *Label) Pos() token.Pos</a>
</li>
<li> <a href="#Label.String">func (obj *Label) String() string</a>
</li>
<li> <a href="#Label.Type">func (obj *Label) Type() Type</a>
</li>
<li><a href="#Map">type Map</a></li>
<li> <a href="#NewMap">func NewMap(key, elem Type) *Map</a>
</li>
<li> <a href="#Map.Elem">func (m *Map) Elem() Type</a>
</li>
<li> <a href="#Map.Key">func (m *Map) Key() Type</a>
</li>
<li> <a href="#Map.String">func (m *Map) String() string</a>
</li>
<li> <a href="#Map.Underlying">func (m *Map) Underlying() Type</a>
</li>
<li><a href="#MethodSet">type MethodSet</a></li>
<li> <a href="#NewMethodSet">func NewMethodSet(T Type) *MethodSet</a>
</li>
<li> <a href="#MethodSet.At">func (s *MethodSet) At(i int) *Selection</a>
</li>
<li> <a href="#MethodSet.Len">func (s *MethodSet) Len() int</a>
</li>
<li> <a href="#MethodSet.Lookup">func (s *MethodSet) Lookup(pkg *Package, name string) *Selection</a>
</li>
<li> <a href="#MethodSet.String">func (s *MethodSet) String() string</a>
</li>
<li><a href="#Named">type Named</a></li>
<li> <a href="#NewNamed">func NewNamed(obj *TypeName, underlying Type, methods []*Func) *Named</a>
</li>
<li> <a href="#Named.AddMethod">func (t *Named) AddMethod(m *Func)</a>
</li>
<li> <a href="#Named.Method">func (t *Named) Method(i int) *Func</a>
</li>
<li> <a href="#Named.NumMethods">func (t *Named) NumMethods() int</a>
</li>
<li> <a href="#Named.Obj">func (t *Named) Obj() *TypeName</a>
</li>
<li> <a href="#Named.SetUnderlying">func (t *Named) SetUnderlying(underlying Type)</a>
</li>
<li> <a href="#Named.String">func (t *Named) String() string</a>
</li>
<li> <a href="#Named.Underlying">func (t *Named) Underlying() Type</a>
</li>
<li><a href="#Nil">type Nil</a></li>
<li> <a href="#Nil.Exported">func (obj *Nil) Exported() bool</a>
</li>
<li> <a href="#Nil.Id">func (obj *Nil) Id() string</a>
</li>
<li> <a href="#Nil.Name">func (obj *Nil) Name() string</a>
</li>
<li> <a href="#Nil.Parent">func (obj *Nil) Parent() *Scope</a>
</li>
<li> <a href="#Nil.Pkg">func (obj *Nil) Pkg() *Package</a>
</li>
<li> <a href="#Nil.Pos">func (obj *Nil) Pos() token.Pos</a>
</li>
<li> <a href="#Nil.String">func (obj *Nil) String() string</a>
</li>
<li> <a href="#Nil.Type">func (obj *Nil) Type() Type</a>
</li>
<li><a href="#Object">type Object</a></li>
<li> <a href="#LookupFieldOrMethod">func LookupFieldOrMethod(T Type, addressable bool, pkg *Package, name string) (obj Object, index []int, indirect bool)</a>
</li>
<li><a href="#Package">type Package</a></li>
<li> <a href="#NewPackage">func NewPackage(path, name string) *Package</a>
</li>
<li> <a href="#Package.Complete">func (pkg *Package) Complete() bool</a>
</li>
<li> <a href="#Package.Imports">func (pkg *Package) Imports() []*Package</a>
</li>
<li> <a href="#Package.MarkComplete">func (pkg *Package) MarkComplete()</a>
</li>
<li> <a href="#Package.Name">func (pkg *Package) Name() string</a>
</li>
<li> <a href="#Package.Path">func (pkg *Package) Path() string</a>
</li>
<li> <a href="#Package.Scope">func (pkg *Package) Scope() *Scope</a>
</li>
<li> <a href="#Package.SetImports">func (pkg *Package) SetImports(list []*Package)</a>
</li>
<li> <a href="#Package.SetName">func (pkg *Package) SetName(name string)</a>
</li>
<li> <a href="#Package.String">func (pkg *Package) String() string</a>
</li>
<li><a href="#PkgName">type PkgName</a></li>
<li> <a href="#NewPkgName">func NewPkgName(pos token.Pos, pkg *Package, name string, imported *Package) *PkgName</a>
</li>
<li> <a href="#PkgName.Exported">func (obj *PkgName) Exported() bool</a>
</li>
<li> <a href="#PkgName.Id">func (obj *PkgName) Id() string</a>
</li>
<li> <a href="#PkgName.Imported">func (obj *PkgName) Imported() *Package</a>
</li>
<li> <a href="#PkgName.Name">func (obj *PkgName) Name() string</a>
</li>
<li> <a href="#PkgName.Parent">func (obj *PkgName) Parent() *Scope</a>
</li>
<li> <a href="#PkgName.Pkg">func (obj *PkgName) Pkg() *Package</a>
</li>
<li> <a href="#PkgName.Pos">func (obj *PkgName) Pos() token.Pos</a>
</li>
<li> <a href="#PkgName.String">func (obj *PkgName) String() string</a>
</li>
<li> <a href="#PkgName.Type">func (obj *PkgName) Type() Type</a>
</li>
<li><a href="#Pointer">type Pointer</a></li>
<li> <a href="#NewPointer">func NewPointer(elem Type) *Pointer</a>
</li>
<li> <a href="#Pointer.Elem">func (p *Pointer) Elem() Type</a>
</li>
<li> <a href="#Pointer.String">func (p *Pointer) String() string</a>
</li>
<li> <a href="#Pointer.Underlying">func (p *Pointer) Underlying() Type</a>
</li>
<li><a href="#Qualifier">type Qualifier</a></li>
<li> <a href="#RelativeTo">func RelativeTo(pkg *Package) Qualifier</a>
</li>
<li><a href="#Scope">type Scope</a></li>
<li> <a href="#NewScope">func NewScope(parent *Scope, pos, end token.Pos, comment string) *Scope</a>
</li>
<li> <a href="#Scope.Child">func (s *Scope) Child(i int) *Scope</a>
</li>
<li> <a href="#Scope.Contains">func (s *Scope) Contains(pos token.Pos) bool</a>
</li>
<li> <a href="#Scope.End">func (s *Scope) End() token.Pos</a>
</li>
<li> <a href="#Scope.Innermost">func (s *Scope) Innermost(pos token.Pos) *Scope</a>
</li>
<li> <a href="#Scope.Insert">func (s *Scope) Insert(obj Object) Object</a>
</li>
<li> <a href="#Scope.Len">func (s *Scope) Len() int</a>
</li>
<li> <a href="#Scope.Lookup">func (s *Scope) Lookup(name string) Object</a>
</li>
<li> <a href="#Scope.LookupParent">func (s *Scope) LookupParent(name string, pos token.Pos) (*Scope, Object)</a>
</li>
<li> <a href="#Scope.Names">func (s *Scope) Names() []string</a>
</li>
<li> <a href="#Scope.NumChildren">func (s *Scope) NumChildren() int</a>
</li>
<li> <a href="#Scope.Parent">func (s *Scope) Parent() *Scope</a>
</li>
<li> <a href="#Scope.Pos">func (s *Scope) Pos() token.Pos</a>
</li>
<li> <a href="#Scope.String">func (s *Scope) String() string</a>
</li>
<li> <a href="#Scope.WriteTo">func (s *Scope) WriteTo(w io.Writer, n int, recurse bool)</a>
</li>
<li><a href="#Selection">type Selection</a></li>
<li> <a href="#Selection.Index">func (s *Selection) Index() []int</a>
</li>
<li> <a href="#Selection.Indirect">func (s *Selection) Indirect() bool</a>
</li>
<li> <a href="#Selection.Kind">func (s *Selection) Kind() SelectionKind</a>
</li>
<li> <a href="#Selection.Obj">func (s *Selection) Obj() Object</a>
</li>
<li> <a href="#Selection.Recv">func (s *Selection) Recv() Type</a>
</li>
<li> <a href="#Selection.String">func (s *Selection) String() string</a>
</li>
<li> <a href="#Selection.Type">func (s *Selection) Type() Type</a>
</li>
<li><a href="#SelectionKind">type SelectionKind</a></li>
<li><a href="#Signature">type Signature</a></li>
<li> <a href="#NewSignature">func NewSignature(recv *Var, params, results *Tuple, variadic bool) *Signature</a>
</li>
<li> <a href="#Signature.Params">func (s *Signature) Params() *Tuple</a>
</li>
<li> <a href="#Signature.Recv">func (s *Signature) Recv() *Var</a>
</li>
<li> <a href="#Signature.Results">func (s *Signature) Results() *Tuple</a>
</li>
<li> <a href="#Signature.String">func (s *Signature) String() string</a>
</li>
<li> <a href="#Signature.Underlying">func (s *Signature) Underlying() Type</a>
</li>
<li> <a href="#Signature.Variadic">func (s *Signature) Variadic() bool</a>
</li>
<li><a href="#Sizes">type Sizes</a></li>
<li> <a href="#SizesFor">func SizesFor(compiler, arch string) Sizes</a>
</li>
<li><a href="#Slice">type Slice</a></li>
<li> <a href="#NewSlice">func NewSlice(elem Type) *Slice</a>
</li>
<li> <a href="#Slice.Elem">func (s *Slice) Elem() Type</a>
</li>
<li> <a href="#Slice.String">func (s *Slice) String() string</a>
</li>
<li> <a href="#Slice.Underlying">func (s *Slice) Underlying() Type</a>
</li>
<li><a href="#StdSizes">type StdSizes</a></li>
<li> <a href="#StdSizes.Alignof">func (s *StdSizes) Alignof(T Type) int64</a>
</li>
<li> <a href="#StdSizes.Offsetsof">func (s *StdSizes) Offsetsof(fields []*Var) []int64</a>
</li>
<li> <a href="#StdSizes.Sizeof">func (s *StdSizes) Sizeof(T Type) int64</a>
</li>
<li><a href="#Struct">type Struct</a></li>
<li> <a href="#NewStruct">func NewStruct(fields []*Var, tags []string) *Struct</a>
</li>
<li> <a href="#Struct.Field">func (s *Struct) Field(i int) *Var</a>
</li>
<li> <a href="#Struct.NumFields">func (s *Struct) NumFields() int</a>
</li>
<li> <a href="#Struct.String">func (s *Struct) String() string</a>
</li>
<li> <a href="#Struct.Tag">func (s *Struct) Tag(i int) string</a>
</li>
<li> <a href="#Struct.Underlying">func (s *Struct) Underlying() Type</a>
</li>
<li><a href="#Tuple">type Tuple</a></li>
<li> <a href="#NewTuple">func NewTuple(x ...*Var) *Tuple</a>
</li>
<li> <a href="#Tuple.At">func (t *Tuple) At(i int) *Var</a>
</li>
<li> <a href="#Tuple.Len">func (t *Tuple) Len() int</a>
</li>
<li> <a href="#Tuple.String">func (t *Tuple) String() string</a>
</li>
<li> <a href="#Tuple.Underlying">func (t *Tuple) Underlying() Type</a>
</li>
<li><a href="#Type">type Type</a></li>
<li> <a href="#Default">func Default(typ Type) Type</a>
</li>
<li><a href="#TypeAndValue">type TypeAndValue</a></li>
<li> <a href="#Eval">func Eval(fset *token.FileSet, pkg *Package, pos token.Pos, expr string) (_ TypeAndValue, err error)</a>
</li>
<li> <a href="#TypeAndValue.Addressable">func (tv TypeAndValue) Addressable() bool</a>
</li>
<li> <a href="#TypeAndValue.Assignable">func (tv TypeAndValue) Assignable() bool</a>
</li>
<li> <a href="#TypeAndValue.HasOk">func (tv TypeAndValue) HasOk() bool</a>
</li>
<li> <a href="#TypeAndValue.IsBuiltin">func (tv TypeAndValue) IsBuiltin() bool</a>
</li>
<li> <a href="#TypeAndValue.IsNil">func (tv TypeAndValue) IsNil() bool</a>
</li>
<li> <a href="#TypeAndValue.IsType">func (tv TypeAndValue) IsType() bool</a>
</li>
<li> <a href="#TypeAndValue.IsValue">func (tv TypeAndValue) IsValue() bool</a>
</li>
<li> <a href="#TypeAndValue.IsVoid">func (tv TypeAndValue) IsVoid() bool</a>
</li>
<li><a href="#TypeName">type TypeName</a></li>
<li> <a href="#NewTypeName">func NewTypeName(pos token.Pos, pkg *Package, name string, typ Type) *TypeName</a>
</li>
<li> <a href="#TypeName.Exported">func (obj *TypeName) Exported() bool</a>
</li>
<li> <a href="#TypeName.Id">func (obj *TypeName) Id() string</a>
</li>
<li> <a href="#TypeName.IsAlias">func (obj *TypeName) IsAlias() bool</a>
</li>
<li> <a href="#TypeName.Name">func (obj *TypeName) Name() string</a>
</li>
<li> <a href="#TypeName.Parent">func (obj *TypeName) Parent() *Scope</a>
</li>
<li> <a href="#TypeName.Pkg">func (obj *TypeName) Pkg() *Package</a>
</li>
<li> <a href="#TypeName.Pos">func (obj *TypeName) Pos() token.Pos</a>
</li>
<li> <a href="#TypeName.String">func (obj *TypeName) String() string</a>
</li>
<li> <a href="#TypeName.Type">func (obj *TypeName) Type() Type</a>
</li>
<li><a href="#Var">type Var</a></li>
<li> <a href="#NewField">func NewField(pos token.Pos, pkg *Package, name string, typ Type, embedded bool) *Var</a>
</li>
<li> <a href="#NewParam">func NewParam(pos token.Pos, pkg *Package, name string, typ Type) *Var</a>
</li>
<li> <a href="#NewVar">func NewVar(pos token.Pos, pkg *Package, name string, typ Type) *Var</a>
</li>
<li> <a href="#Var.Anonymous">func (obj *Var) Anonymous() bool</a>
</li>
<li> <a href="#Var.Embedded">func (obj *Var) Embedded() bool</a>
</li>
<li> <a href="#Var.Exported">func (obj *Var) Exported() bool</a>
</li>
<li> <a href="#Var.Id">func (obj *Var) Id() string</a>
</li>
<li> <a href="#Var.IsField">func (obj *Var) IsField() bool</a>
</li>
<li> <a href="#Var.Name">func (obj *Var) Name() string</a>
</li>
<li> <a href="#Var.Parent">func (obj *Var) Parent() *Scope</a>
</li>
<li> <a href="#Var.Pkg">func (obj *Var) Pkg() *Package</a>
</li>
<li> <a href="#Var.Pos">func (obj *Var) Pos() token.Pos</a>
</li>
<li> <a href="#Var.String">func (obj *Var) String() string</a>
</li>
<li> <a href="#Var.Type">func (obj *Var) Type() Type</a>
</li>
</ul> <div id="pkg-examples"> <h3>Examples</h3>  <dl> <dd><a class="exampleLink" href="#example_Info">Info</a></dd> <dd><a class="exampleLink" href="#example_MethodSet">MethodSet</a></dd> <dd><a class="exampleLink" href="#example_Scope">Scope</a></dd> </dl> </div> <h3>Package files</h3> <p>  <a href="https://golang.org/src/go/types/api.go">api.go</a> <a href="https://golang.org/src/go/types/assignments.go">assignments.go</a> <a href="https://golang.org/src/go/types/builtins.go">builtins.go</a> <a href="https://golang.org/src/go/types/call.go">call.go</a> <a href="https://golang.org/src/go/types/check.go">check.go</a> <a href="https://golang.org/src/go/types/conversions.go">conversions.go</a> <a href="https://golang.org/src/go/types/decl.go">decl.go</a> <a href="https://golang.org/src/go/types/errors.go">errors.go</a> <a href="https://golang.org/src/go/types/eval.go">eval.go</a> <a href="https://golang.org/src/go/types/expr.go">expr.go</a> <a href="https://golang.org/src/go/types/exprstring.go">exprstring.go</a> <a href="https://golang.org/src/go/types/gccgosizes.go">gccgosizes.go</a> <a href="https://golang.org/src/go/types/initorder.go">initorder.go</a> <a href="https://golang.org/src/go/types/labels.go">labels.go</a> <a href="https://golang.org/src/go/types/lookup.go">lookup.go</a> <a href="https://golang.org/src/go/types/methodset.go">methodset.go</a> <a href="https://golang.org/src/go/types/object.go">object.go</a> <a href="https://golang.org/src/go/types/objset.go">objset.go</a> <a href="https://golang.org/src/go/types/operand.go">operand.go</a> <a href="https://golang.org/src/go/types/package.go">package.go</a> <a href="https://golang.org/src/go/types/predicates.go">predicates.go</a> <a href="https://golang.org/src/go/types/resolver.go">resolver.go</a> <a href="https://golang.org/src/go/types/return.go">return.go</a> <a href="https://golang.org/src/go/types/scope.go">scope.go</a> <a href="https://golang.org/src/go/types/selection.go">selection.go</a> <a href="https://golang.org/src/go/types/sizes.go">sizes.go</a> <a href="https://golang.org/src/go/types/stmt.go">stmt.go</a> <a href="https://golang.org/src/go/types/type.go">type.go</a> <a href="https://golang.org/src/go/types/typestring.go">typestring.go</a> <a href="https://golang.org/src/go/types/typexpr.go">typexpr.go</a> <a href="https://golang.org/src/go/types/universe.go">universe.go</a>  </p>   <h2 id="pkg-variables">Variables</h2> <p> Typ contains the predeclared *Basic types indexed by their corresponding BasicKind. </p> <p> The *Basic type for Typ[Byte] will have the name "uint8". Use Universe.Lookup("byte").Type() to obtain the specific alias basic type named "byte" (and analogous for "rune"). </p> <pre data-language="go">var Typ = []*Basic{
    Invalid: {Invalid, 0, "invalid type"},

    Bool:          {Bool, IsBoolean, "bool"},
    Int:           {Int, IsInteger, "int"},
    Int8:          {Int8, IsInteger, "int8"},
    Int16:         {Int16, IsInteger, "int16"},
    Int32:         {Int32, IsInteger, "int32"},
    Int64:         {Int64, IsInteger, "int64"},
    Uint:          {Uint, IsInteger | IsUnsigned, "uint"},
    Uint8:         {Uint8, IsInteger | IsUnsigned, "uint8"},
    Uint16:        {Uint16, IsInteger | IsUnsigned, "uint16"},
    Uint32:        {Uint32, IsInteger | IsUnsigned, "uint32"},
    Uint64:        {Uint64, IsInteger | IsUnsigned, "uint64"},
    Uintptr:       {Uintptr, IsInteger | IsUnsigned, "uintptr"},
    Float32:       {Float32, IsFloat, "float32"},
    Float64:       {Float64, IsFloat, "float64"},
    Complex64:     {Complex64, IsComplex, "complex64"},
    Complex128:    {Complex128, IsComplex, "complex128"},
    String:        {String, IsString, "string"},
    UnsafePointer: {UnsafePointer, 0, "Pointer"},

    UntypedBool:    {UntypedBool, IsBoolean | IsUntyped, "untyped bool"},
    UntypedInt:     {UntypedInt, IsInteger | IsUntyped, "untyped int"},
    UntypedRune:    {UntypedRune, IsInteger | IsUntyped, "untyped rune"},
    UntypedFloat:   {UntypedFloat, IsFloat | IsUntyped, "untyped float"},
    UntypedComplex: {UntypedComplex, IsComplex | IsUntyped, "untyped complex"},
    UntypedString:  {UntypedString, IsString | IsUntyped, "untyped string"},
    UntypedNil:     {UntypedNil, IsUntyped, "untyped nil"},
}</pre> <h2 id="AssertableTo">func AssertableTo<a href="https://golang.org/src/go/types/api.go?s=13219:13263#L355" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <pre data-language="go">func AssertableTo(V *Interface, T Type) bool</pre> <p> AssertableTo reports whether a value of type V can be asserted to have type T. </p> <h2 id="AssignableTo">func AssignableTo<a href="https://golang.org/src/go/types/api.go?s=13419:13452#L361" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <pre data-language="go">func AssignableTo(V, T Type) bool</pre> <p> AssignableTo reports whether a value of type V is assignable to a variable of type T. </p> <h2 id="CheckExpr">func CheckExpr<a href="https://golang.org/src/go/types/eval.go?s=1880:1983#L46" class="source">Source</a>  <span title="Added in Go 1.13">1.13</span> </h2> <pre data-language="go">func CheckExpr(fset *token.FileSet, pkg *Package, pos token.Pos, expr ast.Expr, info *Info) (err error)</pre> <p> CheckExpr type checks the expression expr as if it had appeared at position pos of package pkg. Type information about the expression is recorded in info. </p> <p> If pkg == nil, the Universe scope is used and the provided position pos is ignored. If pkg != nil, and pos is invalid, the package scope is used. Otherwise, pos must belong to the package. </p> <p> An error is returned if pos is not within the package or if the node cannot be type-checked. </p> <p> Note: Eval and CheckExpr should not be used instead of running Check to compute types and values, but in addition to Check, as these functions ignore the context in which an expression is used (e.g., an assignment). Thus, top-level untyped constants will return an untyped type rather then the respective context-specific type. </p> <h2 id="Comparable">func Comparable<a href="https://golang.org/src/go/types/predicates.go?s=1744:1772#L71" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <pre data-language="go">func Comparable(T Type) bool</pre> <p> Comparable reports whether values of type T are comparable. </p> <h2 id="ConvertibleTo">func ConvertibleTo<a href="https://golang.org/src/go/types/api.go?s=13656:13690#L367" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <pre data-language="go">func ConvertibleTo(V, T Type) bool</pre> <p> ConvertibleTo reports whether a value of type V is convertible to a value of type T. </p> <h2 id="DefPredeclaredTestFuncs">func DefPredeclaredTestFuncs<a href="https://golang.org/src/go/types/universe.go?s=5276:5306#L173" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <pre data-language="go">func DefPredeclaredTestFuncs()</pre> <p> DefPredeclaredTestFuncs defines the assert and trace built-ins. These built-ins are intended for debugging and testing of this package only. </p> <h2 id="ExprString">func ExprString<a href="https://golang.org/src/go/types/exprstring.go?s=439:473#L7" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <pre data-language="go">func ExprString(x ast.Expr) string</pre> <p> ExprString returns the (possibly shortened) string representation for x. Shortened representations are suitable for user interfaces but may not necessarily follow Go syntax. </p> <h2 id="Id">func Id<a href="https://golang.org/src/go/types/object.go?s=2004:2045#L50" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <pre data-language="go">func Id(pkg *Package, name string) string</pre> <p> Id returns name if it is exported, otherwise it returns the name qualified with the package path. </p> <h2 id="Identical">func Identical<a href="https://golang.org/src/go/types/api.go?s=14066:14096#L380" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <pre data-language="go">func Identical(x, y Type) bool</pre> <p> Identical reports whether x and y are identical types. Receivers of Signature types are ignored. </p> <h2 id="IdenticalIgnoreTags">func IdenticalIgnoreTags<a href="https://golang.org/src/go/types/api.go?s=14275:14315#L386" class="source">Source</a>  <span title="Added in Go 1.8">1.8</span> </h2> <pre data-language="go">func IdenticalIgnoreTags(x, y Type) bool</pre> <p> IdenticalIgnoreTags reports whether x and y are identical types if tags are ignored. Receivers of Signature types are ignored. </p> <h2 id="Implements">func Implements<a href="https://golang.org/src/go/types/api.go?s=13863:13905#L373" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <pre data-language="go">func Implements(V Type, T *Interface) bool</pre> <p> Implements reports whether type V implements interface T. </p> <h2 id="IsInterface">func IsInterface<a href="https://golang.org/src/go/types/predicates.go?s=1593:1624#L65" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <pre data-language="go">func IsInterface(typ Type) bool</pre> <p> IsInterface reports whether typ is an interface type. </p> <h2 id="ObjectString">func ObjectString<a href="https://golang.org/src/go/types/object.go?s=13740:13790#L440" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <pre data-language="go">func ObjectString(obj Object, qf Qualifier) string</pre> <p> ObjectString returns the string form of obj. The Qualifier controls the printing of package-level objects, and may be nil. </p> <h2 id="SelectionString">func SelectionString<a href="https://golang.org/src/go/types/selection.go?s=3562:3617#L109" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <pre data-language="go">func SelectionString(s *Selection, qf Qualifier) string</pre> <p> SelectionString returns the string form of s. The Qualifier controls the printing of package-level objects, and may be nil. </p> <p> Examples: </p> <pre data-language="go">"field (T) f int"
"method (T) f(X) Y"
"method expr (T) f(X) Y"
</pre> <h2 id="TypeString">func TypeString<a href="https://golang.org/src/go/types/typestring.go?s=2151:2197#L55" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <pre data-language="go">func TypeString(typ Type, qf Qualifier) string</pre> <p> TypeString returns the string representation of typ. The Qualifier controls the printing of package-level objects, and may be nil. </p> <h2 id="WriteExpr">func WriteExpr<a href="https://golang.org/src/go/types/exprstring.go?s=730:775#L16" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <pre data-language="go">func WriteExpr(buf *bytes.Buffer, x ast.Expr)</pre> <p> WriteExpr writes the (possibly shortened) string representation for x to buf. Shortened representations are suitable for user interfaces but may not necessarily follow Go syntax. </p> <h2 id="WriteSignature">func WriteSignature<a href="https://golang.org/src/go/types/typestring.go?s=7408:7476#L275" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <pre data-language="go">func WriteSignature(buf *bytes.Buffer, sig *Signature, qf Qualifier)</pre> <p> WriteSignature writes the representation of the signature sig to buf, without a leading "func" keyword. The Qualifier controls the printing of package-level objects, and may be nil. </p> <h2 id="WriteType">func WriteType<a href="https://golang.org/src/go/types/typestring.go?s=2417:2474#L64" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <pre data-language="go">func WriteType(buf *bytes.Buffer, typ Type, qf Qualifier)</pre> <p> WriteType writes the string representation of typ to buf. The Qualifier controls the printing of package-level objects, and may be nil. </p> <h2 id="Array">type Array<a href="https://golang.org/src/go/types/type.go?s=1709:1753#L84" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <p> An Array represents an array type. </p> <pre data-language="go">type Array struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="NewArray">func NewArray<a href="https://golang.org/src/go/types/type.go?s=1881:1923#L91" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func NewArray(elem Type, len int64) *Array</pre> <p> NewArray returns a new array type for the given element type and length. A negative length indicates an unknown length. </p> <h3 id="Array.Elem">func (*Array) Elem<a href="https://golang.org/src/go/types/type.go?s=2129:2156#L98" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (a *Array) Elem() Type</pre> <p> Elem returns element type of array a. </p> <h3 id="Array.Len">func (*Array) Len<a href="https://golang.org/src/go/types/type.go?s=2042:2069#L95" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (a *Array) Len() int64</pre> <p> Len returns the length of array a. A negative result indicates an unknown length. </p> <h3 id="Array.String">func (*Array) String<a href="https://golang.org/src/go/types/type.go?s=16554:16585#L504" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (a *Array) String() string</pre> <h3 id="Array.Underlying">func (*Array) Underlying<a href="https://golang.org/src/go/types/type.go?s=15966:15999#L492" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (a *Array) Underlying() Type</pre> <h2 id="Basic">type Basic<a href="https://golang.org/src/go/types/type.go?s=1304:1370#L68" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <p> A Basic represents a basic type. </p> <pre data-language="go">type Basic struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="Basic.Info">func (*Basic) Info<a href="https://golang.org/src/go/types/type.go?s=1528:1560#L78" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (b *Basic) Info() BasicInfo</pre> <p> Info returns information about properties of basic type b. </p> <h3 id="Basic.Kind">func (*Basic) Kind<a href="https://golang.org/src/go/types/type.go?s=1414:1446#L75" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (b *Basic) Kind() BasicKind</pre> <p> Kind returns the kind of basic type b. </p> <h3 id="Basic.Name">func (*Basic) Name<a href="https://golang.org/src/go/types/type.go?s=1622:1651#L81" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (b *Basic) Name() string</pre> <p> Name returns the name of basic type b. </p> <h3 id="Basic.String">func (*Basic) String<a href="https://golang.org/src/go/types/type.go?s=16488:16519#L503" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (b *Basic) String() string</pre> <h3 id="Basic.Underlying">func (*Basic) Underlying<a href="https://golang.org/src/go/types/type.go?s=15915:15948#L491" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (b *Basic) Underlying() Type</pre> <h2 id="BasicInfo">type BasicInfo<a href="https://golang.org/src/go/types/type.go?s=968:986#L50" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <p> BasicInfo is a set of flags describing properties of a basic type. </p> <pre data-language="go">type BasicInfo int</pre> <p> Properties of basic types. </p> <pre data-language="go">const (
    IsBoolean BasicInfo = 1 &lt;&lt; iota
    IsInteger
    IsUnsigned
    IsFloat
    IsComplex
    IsString
    IsUntyped

    IsOrdered   = IsInteger | IsFloat | IsString
    IsNumeric   = IsInteger | IsFloat | IsComplex
    IsConstType = IsBoolean | IsNumeric | IsString
)</pre> <h2 id="BasicKind">type BasicKind<a href="https://golang.org/src/go/types/type.go?s=485:503#L10" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <p> BasicKind describes the kind of basic type. </p> <pre data-language="go">type BasicKind int</pre> <pre data-language="go">const (
    Invalid BasicKind = iota // type is invalid

    // predeclared types
    Bool
    Int
    Int8
    Int16
    Int32
    Int64
    Uint
    Uint8
    Uint16
    Uint32
    Uint64
    Uintptr
    Float32
    Float64
    Complex64
    Complex128
    String
    UnsafePointer

    // types for untyped values
    UntypedBool
    UntypedInt
    UntypedRune
    UntypedFloat
    UntypedComplex
    UntypedString
    UntypedNil

    // aliases
    Byte = Uint8
    Rune = Int32
)</pre> <h2 id="Builtin">type Builtin<a href="https://golang.org/src/go/types/object.go?s=11624:11669#L327" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <p> A Builtin represents a built-in function. Builtins don't have a valid type. </p> <pre data-language="go">type Builtin struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="Builtin.Exported">func (*Builtin) Exported<a href="https://golang.org/src/go/types/object.go?s=4259:4293#L131" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Builtin) Exported() bool</pre> <p> Exported reports whether the object is exported (starts with a capital letter). It doesn't take into account whether the object is in a local (function) scope or not. </p> <h3 id="Builtin.Id">func (*Builtin) Id<a href="https://golang.org/src/go/types/object.go?s=4383:4413#L134" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Builtin) Id() string</pre> <p> Id is a wrapper for Id(obj.Pkg(), obj.Name()). </p> <h3 id="Builtin.Name">func (*Builtin) Name<a href="https://golang.org/src/go/types/object.go?s=3943:3975#L123" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Builtin) Name() string</pre> <p> Name returns the object's (package-local, unqualified) name. </p> <h3 id="Builtin.Parent">func (*Builtin) Parent<a href="https://golang.org/src/go/types/object.go?s=3521:3555#L113" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Builtin) Parent() *Scope</pre> <p> Parent returns the scope in which the object is declared. The result is nil for methods and struct fields. </p> <h3 id="Builtin.Pkg">func (*Builtin) Pkg<a href="https://golang.org/src/go/types/object.go?s=3825:3858#L120" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Builtin) Pkg() *Package</pre> <p> Pkg returns the package to which the object belongs. The result is nil for labels and objects in the Universe scope. </p> <h3 id="Builtin.Pos">func (*Builtin) Pos<a href="https://golang.org/src/go/types/object.go?s=3647:3681#L116" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Builtin) Pos() token.Pos</pre> <p> Pos returns the declaration position of the object's identifier. </p> <h3 id="Builtin.String">func (*Builtin) String<a href="https://golang.org/src/go/types/object.go?s=14293:14328#L452" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Builtin) String() string</pre> <h3 id="Builtin.Type">func (*Builtin) Type<a href="https://golang.org/src/go/types/object.go?s=4032:4062#L126" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Builtin) Type() Type</pre> <p> Type returns the object's type. </p> <h2 id="Chan">type Chan<a href="https://golang.org/src/go/types/type.go?s=13300:13345#L413" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <p> A Chan represents a channel type. </p> <pre data-language="go">type Chan struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="NewChan">func NewChan<a href="https://golang.org/src/go/types/type.go?s=13621:13663#L429" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func NewChan(dir ChanDir, elem Type) *Chan</pre> <p> NewChan returns a new channel type for the given direction and element type. </p> <h3 id="Chan.Dir">func (*Chan) Dir<a href="https://golang.org/src/go/types/type.go?s=13737:13765#L434" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (c *Chan) Dir() ChanDir</pre> <p> Dir returns the direction of channel c. </p> <h3 id="Chan.Elem">func (*Chan) Elem<a href="https://golang.org/src/go/types/type.go?s=13831:13857#L437" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (c *Chan) Elem() Type</pre> <p> Elem returns the element type of channel c. </p> <h3 id="Chan.String">func (*Chan) String<a href="https://golang.org/src/go/types/type.go?s=17082:17112#L512" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (c *Chan) String() string</pre> <h3 id="Chan.Underlying">func (*Chan) Underlying<a href="https://golang.org/src/go/types/type.go?s=16374:16406#L500" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (c *Chan) Underlying() Type</pre> <h2 id="ChanDir">type ChanDir<a href="https://golang.org/src/go/types/type.go?s=13397:13413#L419" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <p> A ChanDir value indicates a channel direction. </p> <pre data-language="go">type ChanDir int</pre> <p> The direction of a channel is indicated by one of these constants. </p> <pre data-language="go">const (
    SendRecv ChanDir = iota
    SendOnly
    RecvOnly
)</pre> <h2 id="Checker">type Checker<a href="https://golang.org/src/go/types/check.go?s=2969:4726#L63" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <p> A Checker maintains the state of the type checker. It must be created with NewChecker. </p> <pre data-language="go">type Checker struct {
    *Info
    // contains filtered or unexported fields
}
</pre> <h3 id="NewChecker">func NewChecker<a href="https://golang.org/src/go/types/check.go?s=6951:7036#L166" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func NewChecker(conf *Config, fset *token.FileSet, pkg *Package, info *Info) *Checker</pre> <p> NewChecker returns a new Checker instance for a given package. Package files may be added incrementally via checker.Files. </p> <h3 id="Checker.Files">func (*Checker) Files<a href="https://golang.org/src/go/types/check.go?s=8646:8698#L239" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (check *Checker) Files(files []*ast.File) error</pre> <p> Files checks the provided files as part of the checker's package. </p> <h2 id="Config">type Config<a href="https://golang.org/src/go/types/api.go?s=3684:5518#L84" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <p> A Config specifies the configuration for type checking. The zero value for Config is a ready-to-use default configuration. </p> <pre data-language="go">type Config struct {
    // If IgnoreFuncBodies is set, function bodies are not
    // type-checked.
    IgnoreFuncBodies bool

    // If FakeImportC is set, `import "C"` (for packages requiring Cgo)
    // declares an empty "C" package and errors are omitted for qualified
    // identifiers referring to package C (which won't find an object).
    // This feature is intended for the standard library cmd/api tool.
    //
    // Caution: Effects may be unpredictable due to follow-on errors.
    //          Do not use casually!
    FakeImportC bool

    // If Error != nil, it is called with each error found
    // during type checking; err has dynamic type Error.
    // Secondary errors (for instance, to enumerate all types
    // involved in an invalid recursive type declaration) have
    // error strings that start with a '\t' character.
    // If Error == nil, type-checking stops with the first
    // error found.
    Error func(err error)

    // An importer is used to import packages referred to from
    // import declarations.
    // If the installed importer implements ImporterFrom, the type
    // checker calls ImportFrom instead of Import.
    // The type checker reports an error if an importer is needed
    // but none was installed.
    Importer Importer

    // If Sizes != nil, it provides the sizing functions for package unsafe.
    // Otherwise SizesFor("gc", "amd64") is used instead.
    Sizes Sizes

    // If DisableUnusedImportCheck is set, packages are not checked
    // for unused imports.
    DisableUnusedImportCheck bool
    // contains filtered or unexported fields
}
</pre> <h3 id="Config.Check">func (*Config) Check<a href="https://golang.org/src/go/types/api.go?s=12934:13042#L349" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (conf *Config) Check(path string, fset *token.FileSet, files []*ast.File, info *Info) (*Package, error)</pre> <p> Check type-checks a package and returns the resulting package object and the first error if any. Additionally, if info != nil, Check populates each of the non-nil maps in the Info struct. </p> <p> The package is marked as complete if no errors occurred, otherwise it is incomplete. See Config.Error for controlling behavior in the presence of errors. </p> <p> The package is specified by a list of *ast.Files and corresponding file set, and the package path the package is identified with. The clean path must not be empty or dot ("."). </p> <h2 id="Const">type Const<a href="https://golang.org/src/go/types/object.go?s=6399:6448#L187" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <p> A Const represents a declared constant. </p> <pre data-language="go">type Const struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="NewConst">func NewConst<a href="https://golang.org/src/go/types/object.go?s=6571:6663#L194" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func NewConst(pos token.Pos, pkg *Package, name string, typ Type, val constant.Value) *Const</pre> <p> NewConst returns a new constant with value val. The remaining arguments set the attributes found with all Objects. </p> <h3 id="Const.Exported">func (*Const) Exported<a href="https://golang.org/src/go/types/object.go?s=4259:4293#L131" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Const) Exported() bool</pre> <p> Exported reports whether the object is exported (starts with a capital letter). It doesn't take into account whether the object is in a local (function) scope or not. </p> <h3 id="Const.Id">func (*Const) Id<a href="https://golang.org/src/go/types/object.go?s=4383:4413#L134" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Const) Id() string</pre> <p> Id is a wrapper for Id(obj.Pkg(), obj.Name()). </p> <h3 id="Const.Name">func (*Const) Name<a href="https://golang.org/src/go/types/object.go?s=3943:3975#L123" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Const) Name() string</pre> <p> Name returns the object's (package-local, unqualified) name. </p> <h3 id="Const.Parent">func (*Const) Parent<a href="https://golang.org/src/go/types/object.go?s=3521:3555#L113" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Const) Parent() *Scope</pre> <p> Parent returns the scope in which the object is declared. The result is nil for methods and struct fields. </p> <h3 id="Const.Pkg">func (*Const) Pkg<a href="https://golang.org/src/go/types/object.go?s=3825:3858#L120" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Const) Pkg() *Package</pre> <p> Pkg returns the package to which the object belongs. The result is nil for labels and objects in the Universe scope. </p> <h3 id="Const.Pos">func (*Const) Pos<a href="https://golang.org/src/go/types/object.go?s=3647:3681#L116" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Const) Pos() token.Pos</pre> <p> Pos returns the declaration position of the object's identifier. </p> <h3 id="Const.String">func (*Const) String<a href="https://golang.org/src/go/types/object.go?s=13938:13971#L447" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Const) String() string</pre> <h3 id="Const.Type">func (*Const) Type<a href="https://golang.org/src/go/types/object.go?s=4032:4062#L126" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Const) Type() Type</pre> <p> Type returns the object's type. </p> <h3 id="Const.Val">func (*Const) Val<a href="https://golang.org/src/go/types/object.go?s=6791:6829#L199" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Const) Val() constant.Value</pre> <p> Val returns the constant's value. </p> <h2 id="Error">type Error<a href="https://golang.org/src/go/types/api.go?s=1516:1721#L31" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <p> An Error describes a type-checking error; it implements the error interface. A "soft" error is an error that still permits a valid interpretation of a package (such as "unused variable"); "hard" errors may lead to unpredictable behavior if ignored. </p> <pre data-language="go">type Error struct {
    Fset *token.FileSet // file set for interpretation of Pos
    Pos  token.Pos      // error position
    Msg  string         // error message
    Soft bool           // if set, error is "soft"
}
</pre> <h3 id="Error.Error">func (Error) Error<a href="https://golang.org/src/go/types/api.go?s=1811:1842#L40" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (err Error) Error() string</pre> <p> Error returns an error string formatted as follows: filename:line:column: message </p> <h2 id="Func">type Func<a href="https://golang.org/src/go/types/object.go?s=10327:10425#L284" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <p> A Func represents a declared function, concrete method, or abstract (interface) method. Its Type() is always a *Signature. An abstract method may belong to many interfaces due to embedding. </p> <pre data-language="go">type Func struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="MissingMethod">func MissingMethod<a href="https://golang.org/src/go/types/lookup.go?s=9788:9872#L255" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func MissingMethod(V Type, T *Interface, static bool) (method *Func, wrongType bool)</pre> <p> MissingMethod returns (nil, false) if V implements T, otherwise it returns a missing method required by T and whether it is missing or just has the wrong type. </p> <p> For non-interface types V, or if static is set, V implements T if all methods of T are present in V. Otherwise (V is an interface and static is not set), MissingMethod only checks that methods of T which are also present in V have matching types (e.g., for a type assertion x.(T) where x is of interface type V). </p> <h3 id="NewFunc">func NewFunc<a href="https://golang.org/src/go/types/object.go?s=10524:10600#L291" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func NewFunc(pos token.Pos, pkg *Package, name string, sig *Signature) *Func</pre> <p> NewFunc returns a new function with the given signature, representing the function's type. </p> <h3 id="Func.Exported">func (*Func) Exported<a href="https://golang.org/src/go/types/object.go?s=4259:4293#L131" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Func) Exported() bool</pre> <p> Exported reports whether the object is exported (starts with a capital letter). It doesn't take into account whether the object is in a local (function) scope or not. </p> <h3 id="Func.FullName">func (*Func) FullName<a href="https://golang.org/src/go/types/object.go?s=10865:10899#L302" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Func) FullName() string</pre> <p> FullName returns the package- or receiver-type-qualified name of function or method obj. </p> <h3 id="Func.Id">func (*Func) Id<a href="https://golang.org/src/go/types/object.go?s=4383:4413#L134" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Func) Id() string</pre> <p> Id is a wrapper for Id(obj.Pkg(), obj.Name()). </p> <h3 id="Func.Name">func (*Func) Name<a href="https://golang.org/src/go/types/object.go?s=3943:3975#L123" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Func) Name() string</pre> <p> Name returns the object's (package-local, unqualified) name. </p> <h3 id="Func.Parent">func (*Func) Parent<a href="https://golang.org/src/go/types/object.go?s=3521:3555#L113" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Func) Parent() *Scope</pre> <p> Parent returns the scope in which the object is declared. The result is nil for methods and struct fields. </p> <h3 id="Func.Pkg">func (*Func) Pkg<a href="https://golang.org/src/go/types/object.go?s=3825:3858#L120" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Func) Pkg() *Package</pre> <p> Pkg returns the package to which the object belongs. The result is nil for labels and objects in the Universe scope. </p> <h3 id="Func.Pos">func (*Func) Pos<a href="https://golang.org/src/go/types/object.go?s=3647:3681#L116" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Func) Pos() token.Pos</pre> <p> Pos returns the declaration position of the object's identifier. </p> <h3 id="Func.Scope">func (*Func) Scope<a href="https://golang.org/src/go/types/object.go?s=11036:11067#L309" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Func) Scope() *Scope</pre> <p> Scope returns the scope of the function's body block. </p> <h3 id="Func.String">func (*Func) String<a href="https://golang.org/src/go/types/object.go?s=14151:14183#L450" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Func) String() string</pre> <h3 id="Func.Type">func (*Func) Type<a href="https://golang.org/src/go/types/object.go?s=4032:4062#L126" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Func) Type() Type</pre> <p> Type returns the object's type. </p> <h2 id="ImportMode">type ImportMode<a href="https://golang.org/src/go/types/api.go?s=2467:2486#L57" class="source">Source</a>  <span title="Added in Go 1.6">1.6</span> </h2> <p> ImportMode is reserved for future use. </p> <pre data-language="go">type ImportMode int</pre> <h2 id="Importer">type Importer<a href="https://golang.org/src/go/types/api.go?s=2165:2423#L49" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <p> An Importer resolves import paths to Packages. </p> <p> CAUTION: This interface does not support the import of locally vendored packages. See <a href="https://golang.org/s/go15vendor">https://golang.org/s/go15vendor</a>. If possible, external implementations should implement ImporterFrom. </p> <pre data-language="go">type Importer interface {
    // Import returns the imported package for the given import path.
    // The semantics is like for ImporterFrom.ImportFrom except that
    // dir and mode are ignored (since they are not present).
    Import(path string) (*Package, error)
}</pre> <h2 id="ImporterFrom">type ImporterFrom<a href="https://golang.org/src/go/types/api.go?s=2665:3553#L62" class="source">Source</a>  <span title="Added in Go 1.6">1.6</span> </h2> <p> An ImporterFrom resolves import paths to packages; it supports vendoring per <a href="https://golang.org/s/go15vendor">https://golang.org/s/go15vendor</a>. Use go/importer to obtain an ImporterFrom implementation. </p> <pre data-language="go">type ImporterFrom interface {
    // Importer is present for backward-compatibility. Calling
    // Import(path) is the same as calling ImportFrom(path, "", 0);
    // i.e., locally vendored packages may not be found.
    // The types package does not call Import if an ImporterFrom
    // is present.
    Importer

    // ImportFrom returns the imported package for the given import
    // path when imported by a package file located in dir.
    // If the import failed, besides returning an error, ImportFrom
    // is encouraged to cache and return a package anyway, if one
    // was created. This will reduce package inconsistencies and
    // follow-on type checker errors due to the missing package.
    // The mode value must be 0; it is reserved for future use.
    // Two calls to ImportFrom with the same path and dir must
    // return the same package.
    ImportFrom(path, dir string, mode ImportMode) (*Package, error)
}</pre> <h2 id="Info">type Info<a href="https://golang.org/src/go/types/api.go?s=5808:9347#L141" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <p> Info holds result type information for a type-checked package. Only the information for which a map is provided is collected. If the package has type errors, the collected information may be incomplete. </p> <pre data-language="go">type Info struct {
    // Types maps expressions to their types, and for constant
    // expressions, also their values. Invalid expressions are
    // omitted.
    //
    // For (possibly parenthesized) identifiers denoting built-in
    // functions, the recorded signatures are call-site specific:
    // if the call result is not a constant, the recorded type is
    // an argument-specific signature. Otherwise, the recorded type
    // is invalid.
    //
    // The Types map does not record the type of every identifier,
    // only those that appear where an arbitrary expression is
    // permitted. For instance, the identifier f in a selector
    // expression x.f is found only in the Selections map, the
    // identifier z in a variable declaration 'var z int' is found
    // only in the Defs map, and identifiers denoting packages in
    // qualified identifiers are collected in the Uses map.
    Types map[ast.Expr]TypeAndValue

    // Defs maps identifiers to the objects they define (including
    // package names, dots "." of dot-imports, and blank "_" identifiers).
    // For identifiers that do not denote objects (e.g., the package name
    // in package clauses, or symbolic variables t in t := x.(type) of
    // type switch headers), the corresponding objects are nil.
    //
    // For an embedded field, Defs returns the field *Var it defines.
    //
    // Invariant: Defs[id] == nil || Defs[id].Pos() == id.Pos()
    Defs map[*ast.Ident]Object

    // Uses maps identifiers to the objects they denote.
    //
    // For an embedded field, Uses returns the *TypeName it denotes.
    //
    // Invariant: Uses[id].Pos() != id.Pos()
    Uses map[*ast.Ident]Object

    // Implicits maps nodes to their implicitly declared objects, if any.
    // The following node and object types may appear:
    //
    //     node               declared object
    //
    //     *ast.ImportSpec    *PkgName for imports without renames
    //     *ast.CaseClause    type-specific *Var for each type switch case clause (incl. default)
    //     *ast.Field         anonymous parameter *Var (incl. unnamed results)
    //
    Implicits map[ast.Node]Object

    // Selections maps selector expressions (excluding qualified identifiers)
    // to their corresponding selections.
    Selections map[*ast.SelectorExpr]*Selection

    // Scopes maps ast.Nodes to the scopes they define. Package scopes are not
    // associated with a specific node but with all files belonging to a package.
    // Thus, the package scope can be found in the type-checked Package object.
    // Scopes nest, with the Universe scope being the outermost scope, enclosing
    // the package scope, which contains (one or more) files scopes, which enclose
    // function scopes which in turn enclose statement and function literal scopes.
    // Note that even though package-level functions are declared in the package
    // scope, the function scopes are embedded in the file scope of the file
    // containing the function declaration.
    //
    // The following node types may appear in Scopes:
    //
    //     *ast.File
    //     *ast.FuncType
    //     *ast.BlockStmt
    //     *ast.IfStmt
    //     *ast.SwitchStmt
    //     *ast.TypeSwitchStmt
    //     *ast.CaseClause
    //     *ast.CommClause
    //     *ast.ForStmt
    //     *ast.RangeStmt
    //
    Scopes map[ast.Node]*Scope

    // InitOrder is the list of package-level initializers in the order in which
    // they must be executed. Initializers referring to variables related by an
    // initialization dependency appear in topological order, the others appear
    // in source order. Variables without an initialization expression do not
    // appear in this list.
    InitOrder []*Initializer
}
</pre>    <h4 id="example_Info"> <span class="text">Example</span>
</h4> <p>ExampleInfo prints various facts recorded by the type checker in a types.Info struct: definitions of and references to each named object, and the type, value, and mode of every expression in the package. </p> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"go/types"
	"log"
	"sort"
	"strings"
)

func main() {
	// Parse a single source file.
	const input = `
package fib

type S string

var a, b, c = len(b), S(c), "hello"

func fib(x int) int {
	if x &lt; 2 {
		return x
	}
	return fib(x-1) - fib(x-2)
}`
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, "fib.go", input, 0)
	if err != nil {
		log.Fatal(err)
	}

	// Type-check the package.
	// We create an empty map for each kind of input
	// we're interested in, and Check populates them.
	info := types.Info{
		Types: make(map[ast.Expr]types.TypeAndValue),
		Defs:  make(map[*ast.Ident]types.Object),
		Uses:  make(map[*ast.Ident]types.Object),
	}
	var conf types.Config
	pkg, err := conf.Check("fib", fset, []*ast.File{f}, &amp;info)
	if err != nil {
		log.Fatal(err)
	}

	// Print package-level variables in initialization order.
	fmt.Printf("InitOrder: %v\n\n", info.InitOrder)

	// For each named object, print the line and
	// column of its definition and each of its uses.
	fmt.Println("Defs and Uses of each named object:")
	usesByObj := make(map[types.Object][]string)
	for id, obj := range info.Uses {
		posn := fset.Position(id.Pos())
		lineCol := fmt.Sprintf("%d:%d", posn.Line, posn.Column)
		usesByObj[obj] = append(usesByObj[obj], lineCol)
	}
	var items []string
	for obj, uses := range usesByObj {
		sort.Strings(uses)
		item := fmt.Sprintf("%s:\n  defined at %s\n  used at %s",
			types.ObjectString(obj, types.RelativeTo(pkg)),
			fset.Position(obj.Pos()),
			strings.Join(uses, ", "))
		items = append(items, item)
	}
	sort.Strings(items) // sort by line:col, in effect
	fmt.Println(strings.Join(items, "\n"))
	fmt.Println()

	fmt.Println("Types and Values of each expression:")
	items = nil
	for expr, tv := range info.Types {
		var buf bytes.Buffer
		posn := fset.Position(expr.Pos())
		tvstr := tv.Type.String()
		if tv.Value != nil {
			tvstr += " = " + tv.Value.String()
		}
		// line:col | expr | mode : type = value
		fmt.Fprintf(&amp;buf, "%2d:%2d | %-19s | %-7s : %s",
			posn.Line, posn.Column, exprString(fset, expr),
			mode(tv), tvstr)
		items = append(items, buf.String())
	}
	sort.Strings(items)
	fmt.Println(strings.Join(items, "\n"))

}

func mode(tv types.TypeAndValue) string {
	switch {
	case tv.IsVoid():
		return "void"
	case tv.IsType():
		return "type"
	case tv.IsBuiltin():
		return "builtin"
	case tv.IsNil():
		return "nil"
	case tv.Assignable():
		if tv.Addressable() {
			return "var"
		}
		return "mapindex"
	case tv.IsValue():
		return "value"
	default:
		return "unknown"
	}
}

func exprString(fset *token.FileSet, expr ast.Expr) string {
	var buf bytes.Buffer
	format.Node(&amp;buf, fset, expr)
	return buf.String()
}
</pre>   <h3 id="Info.ObjectOf">func (*Info) ObjectOf<a href="https://golang.org/src/go/types/api.go?s=9972:10020#L250" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (info *Info) ObjectOf(id *ast.Ident) Object</pre> <p> ObjectOf returns the object denoted by the specified id, or nil if not found. </p> <p> If id is an embedded struct field, ObjectOf returns the field (*Var) it defines, not the type (*TypeName) it uses. </p> <p> Precondition: the Uses and Defs maps are populated. </p> <h3 id="Info.TypeOf">func (*Info) TypeOf<a href="https://golang.org/src/go/types/api.go?s=9479:9520#L230" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (info *Info) TypeOf(e ast.Expr) Type</pre> <p> TypeOf returns the type of expression e, or nil if not found. Precondition: the Types, Uses and Defs maps are populated. </p> <h2 id="Initializer">type Initializer<a href="https://golang.org/src/go/types/api.go?s=12063:12133#L320" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <p> An Initializer describes a package-level variable, or a list of variables in case of a multi-valued initialization expression, and the corresponding initialization expression. </p> <pre data-language="go">type Initializer struct {
    Lhs []*Var // var Lhs = Rhs
    Rhs ast.Expr
}
</pre> <h3 id="Initializer.String">func (*Initializer) String<a href="https://golang.org/src/go/types/api.go?s=12135:12175#L325" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (init *Initializer) String() string</pre> <h2 id="Interface">type Interface<a href="https://golang.org/src/go/types/type.go?s=6899:7177#L234" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <p> An Interface represents an interface type. </p> <pre data-language="go">type Interface struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="NewInterface">func NewInterface<a href="https://golang.org/src/go/types/type.go?s=8052:8117#L256" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func NewInterface(methods []*Func, embeddeds []*Named) *Interface</pre> <p> NewInterface returns a new (incomplete) interface for the given methods and embedded types. Each embedded type must have an underlying type of interface type. NewInterface takes ownership of the provided methods and may modify their types by setting missing receivers. To compute the method set of the interface, Complete must be called. </p> <p> Deprecated: Use NewInterfaceType instead which allows any (even non-defined) interface types to be embedded. This is necessary for interfaces that embed alias type names referring to non-defined (literal) interface types. </p> <h3 id="NewInterfaceType">func NewInterfaceType<a href="https://golang.org/src/go/types/type.go?s=8763:8830#L270" class="source">Source</a>  <span title="Added in Go 1.11">1.11</span> </h3> <pre data-language="go">func NewInterfaceType(methods []*Func, embeddeds []Type) *Interface</pre> <p> NewInterfaceType returns a new (incomplete) interface for the given methods and embedded types. Each embedded type must have an underlying type of interface type (this property is not verified for defined types, which may be in the process of being set up and which don't have a valid underlying type yet). NewInterfaceType takes ownership of the provided methods and may modify their types by setting missing receivers. To compute the method set of the interface, Complete must be called. </p> <h3 id="Interface.Complete">func (*Interface) Complete<a href="https://golang.org/src/go/types/type.go?s=11824:11865#L345" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (t *Interface) Complete() *Interface</pre> <p> Complete computes the interface's method set. It must be called by users of NewInterfaceType and NewInterface after the interface's embedded types are fully defined and before using the interface type in any way other than to form other types. The interface must not contain duplicate methods or a panic occurs. Complete returns the receiver. </p> <h3 id="Interface.Embedded">func (*Interface) Embedded<a href="https://golang.org/src/go/types/type.go?s=10447:10489#L316" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (t *Interface) Embedded(i int) *Named</pre> <p> Embedded returns the i'th embedded defined (*Named) type of interface t for 0 &lt;= i &lt; t.NumEmbeddeds(). The result is nil if the i'th embedded type is not a defined type. </p> <p> Deprecated: Use EmbeddedType which is not restricted to defined (*Named) types. </p> <h3 id="Interface.EmbeddedType">func (*Interface) EmbeddedType<a href="https://golang.org/src/go/types/type.go?s=10638:10682#L319" class="source">Source</a>  <span title="Added in Go 1.11">1.11</span> </h3> <pre data-language="go">func (t *Interface) EmbeddedType(i int) Type</pre> <p> EmbeddedType returns the i'th embedded type of interface t for 0 &lt;= i &lt; t.NumEmbeddeds(). </p> <h3 id="Interface.Empty">func (*Interface) Empty<a href="https://golang.org/src/go/types/type.go?s=11374:11406#L338" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (t *Interface) Empty() bool</pre> <p> Empty reports whether t is the empty interface. The interface must have been completed. </p> <h3 id="Interface.ExplicitMethod">func (*Interface) ExplicitMethod<a href="https://golang.org/src/go/types/type.go?s=9975:10022#L307" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (t *Interface) ExplicitMethod(i int) *Func</pre> <p> ExplicitMethod returns the i'th explicitly declared method of interface t for 0 &lt;= i &lt; t.NumExplicitMethods(). The methods are ordered by their unique Id. </p> <h3 id="Interface.Method">func (*Interface) Method<a href="https://golang.org/src/go/types/type.go?s=11188:11227#L334" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (t *Interface) Method(i int) *Func</pre> <p> Method returns the i'th method of interface t for 0 &lt;= i &lt; t.NumMethods(). The methods are ordered by their unique Id. The interface must have been completed. </p> <h3 id="Interface.NumEmbeddeds">func (*Interface) NumEmbeddeds<a href="https://golang.org/src/go/types/type.go?s=10117:10155#L310" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (t *Interface) NumEmbeddeds() int</pre> <p> NumEmbeddeds returns the number of embedded types in interface t. </p> <h3 id="Interface.NumExplicitMethods">func (*Interface) NumExplicitMethods<a href="https://golang.org/src/go/types/type.go?s=9742:9786#L303" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (t *Interface) NumExplicitMethods() int</pre> <p> NumExplicitMethods returns the number of explicitly declared methods of interface t. </p> <h3 id="Interface.NumMethods">func (*Interface) NumMethods<a href="https://golang.org/src/go/types/type.go?s=10819:10855#L323" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (t *Interface) NumMethods() int</pre> <p> NumMethods returns the total number of methods of interface t. The interface must have been completed. </p> <h3 id="Interface.String">func (*Interface) String<a href="https://golang.org/src/go/types/type.go?s=16950:16985#L510" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (t *Interface) String() string</pre> <h3 id="Interface.Underlying">func (*Interface) Underlying<a href="https://golang.org/src/go/types/type.go?s=16272:16309#L498" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (t *Interface) Underlying() Type</pre> <h2 id="Label">type Label<a href="https://golang.org/src/go/types/object.go?s=11274:11343#L315" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <p> A Label represents a declared label. Labels don't have a type. </p> <pre data-language="go">type Label struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="NewLabel">func NewLabel<a href="https://golang.org/src/go/types/object.go?s=11378:11440#L321" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func NewLabel(pos token.Pos, pkg *Package, name string) *Label</pre> <p> NewLabel returns a new label. </p> <h3 id="Label.Exported">func (*Label) Exported<a href="https://golang.org/src/go/types/object.go?s=4259:4293#L131" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Label) Exported() bool</pre> <p> Exported reports whether the object is exported (starts with a capital letter). It doesn't take into account whether the object is in a local (function) scope or not. </p> <h3 id="Label.Id">func (*Label) Id<a href="https://golang.org/src/go/types/object.go?s=4383:4413#L134" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Label) Id() string</pre> <p> Id is a wrapper for Id(obj.Pkg(), obj.Name()). </p> <h3 id="Label.Name">func (*Label) Name<a href="https://golang.org/src/go/types/object.go?s=3943:3975#L123" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Label) Name() string</pre> <p> Name returns the object's (package-local, unqualified) name. </p> <h3 id="Label.Parent">func (*Label) Parent<a href="https://golang.org/src/go/types/object.go?s=3521:3555#L113" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Label) Parent() *Scope</pre> <p> Parent returns the scope in which the object is declared. The result is nil for methods and struct fields. </p> <h3 id="Label.Pkg">func (*Label) Pkg<a href="https://golang.org/src/go/types/object.go?s=3825:3858#L120" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Label) Pkg() *Package</pre> <p> Pkg returns the package to which the object belongs. The result is nil for labels and objects in the Universe scope. </p> <h3 id="Label.Pos">func (*Label) Pos<a href="https://golang.org/src/go/types/object.go?s=3647:3681#L116" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Label) Pos() token.Pos</pre> <p> Pos returns the declaration position of the object's identifier. </p> <h3 id="Label.String">func (*Label) String<a href="https://golang.org/src/go/types/object.go?s=14222:14255#L451" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Label) String() string</pre> <h3 id="Label.Type">func (*Label) Type<a href="https://golang.org/src/go/types/object.go?s=4032:4062#L126" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Label) Type() Type</pre> <p> Type returns the object's type. </p> <h2 id="Map">type Map<a href="https://golang.org/src/go/types/type.go?s=12930:12965#L397" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <p> A Map represents a map type. </p> <pre data-language="go">type Map struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="NewMap">func NewMap<a href="https://golang.org/src/go/types/type.go?s=13032:13064#L402" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func NewMap(key, elem Type) *Map</pre> <p> NewMap returns a new map for the given key and element types. </p> <h3 id="Map.Elem">func (*Map) Elem<a href="https://golang.org/src/go/types/type.go?s=13218:13243#L410" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (m *Map) Elem() Type</pre> <p> Elem returns the element type of map m. </p> <h3 id="Map.Key">func (*Map) Key<a href="https://golang.org/src/go/types/type.go?s=13132:13156#L407" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (m *Map) Key() Type</pre> <p> Key returns the key type of map m. </p> <h3 id="Map.String">func (*Map) String<a href="https://golang.org/src/go/types/type.go?s=17016:17045#L511" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (m *Map) String() string</pre> <h3 id="Map.Underlying">func (*Map) Underlying<a href="https://golang.org/src/go/types/type.go?s=16323:16354#L499" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (m *Map) Underlying() Type</pre> <h2 id="MethodSet">type MethodSet<a href="https://golang.org/src/go/types/methodset.go?s=485:529#L8" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <p> A MethodSet is an ordered set of concrete or abstract (interface) methods; a method is a MethodVal selection, and they are ordered by ascending m.Obj().Id(). The zero value for a MethodSet is a ready-to-use empty method set. </p> <pre data-language="go">type MethodSet struct {
    // contains filtered or unexported fields
}
</pre>    <h4 id="example_MethodSet"> <span class="text">Example</span>
</h4> <p>ExampleMethodSet prints the method sets of various types. </p> <pre class="play" data-language="go">package main

import (
	"fmt"
	"go/ast"
	"go/importer"
	"go/parser"
	"go/token"
	"go/types"
	"log"
)

func main() {
	// Parse a single source file.
	const input = `
package temperature
import "fmt"
type Celsius float64
func (c Celsius) String() string  { return fmt.Sprintf("%gC", c) }
func (c *Celsius) SetF(f float64) { *c = Celsius(f - 32 / 9 * 5) }

type S struct { I; m int }
type I interface { m() byte }
`
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, "celsius.go", input, 0)
	if err != nil {
		log.Fatal(err)
	}

	// Type-check a package consisting of this file.
	// Type information for the imported packages
	// comes from $GOROOT/pkg/$GOOS_$GOOARCH/fmt.a.
	conf := types.Config{Importer: importer.Default()}
	pkg, err := conf.Check("temperature", fset, []*ast.File{f}, nil)
	if err != nil {
		log.Fatal(err)
	}

	// Print the method sets of Celsius and *Celsius.
	celsius := pkg.Scope().Lookup("Celsius").Type()
	for _, t := range []types.Type{celsius, types.NewPointer(celsius)} {
		fmt.Printf("Method set of %s:\n", t)
		mset := types.NewMethodSet(t)
		for i := 0; i &lt; mset.Len(); i++ {
			fmt.Println(mset.At(i))
		}
		fmt.Println()
	}

	// Print the method set of S.
	styp := pkg.Scope().Lookup("S").Type()
	fmt.Printf("Method set of %s:\n", styp)
	fmt.Println(types.NewMethodSet(styp))

}
</pre>   <h3 id="NewMethodSet">func NewMethodSet<a href="https://golang.org/src/go/types/methodset.go?s=1809:1845#L62" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func NewMethodSet(T Type) *MethodSet</pre> <p> NewMethodSet returns the method set for the given type T. It always returns a non-nil method set, even if it is empty. </p> <h3 id="MethodSet.At">func (*MethodSet) At<a href="https://golang.org/src/go/types/methodset.go?s=943:983#L30" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (s *MethodSet) At(i int) *Selection</pre> <p> At returns the i'th method in s for 0 &lt;= i &lt; s.Len(). </p> <h3 id="MethodSet.Len">func (*MethodSet) Len<a href="https://golang.org/src/go/types/methodset.go?s=832:861#L27" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (s *MethodSet) Len() int</pre> <p> Len returns the number of methods in s. </p> <h3 id="MethodSet.Lookup">func (*MethodSet) Lookup<a href="https://golang.org/src/go/types/methodset.go?s=1088:1152#L33" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (s *MethodSet) Lookup(pkg *Package, name string) *Selection</pre> <p> Lookup returns the method with matching package and name, or nil if not found. </p> <h3 id="MethodSet.String">func (*MethodSet) String<a href="https://golang.org/src/go/types/methodset.go?s=531:566#L12" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (s *MethodSet) String() string</pre> <h2 id="Named">type Named<a href="https://golang.org/src/go/types/type.go?s=13913:14362#L440" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <p> A Named represents a named type. </p> <pre data-language="go">type Named struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="NewNamed">func NewNamed<a href="https://golang.org/src/go/types/type.go?s=14611:14680#L451" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func NewNamed(obj *TypeName, underlying Type, methods []*Func) *Named</pre> <p> NewNamed returns a new named type for the given type name, underlying type, and associated methods. If the given type name obj doesn't have a type yet, its type is set to the returned named type. The underlying type must not be a *Named. </p> <h3 id="Named.AddMethod">func (*Named) AddMethod<a href="https://golang.org/src/go/types/type.go?s=15739:15773#L483" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (t *Named) AddMethod(m *Func)</pre> <p> AddMethod adds method m unless it is already in the method list. </p> <h3 id="Named.Method">func (*Named) Method<a href="https://golang.org/src/go/types/type.go?s=15252:15287#L469" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (t *Named) Method(i int) *Func</pre> <p> Method returns the i'th method of named type t for 0 &lt;= i &lt; t.NumMethods(). </p> <h3 id="Named.NumMethods">func (*Named) NumMethods<a href="https://golang.org/src/go/types/type.go?s=15113:15145#L466" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (t *Named) NumMethods() int</pre> <p> NumMethods returns the number of explicit methods whose receiver is named type t. </p> <h3 id="Named.Obj">func (*Named) Obj<a href="https://golang.org/src/go/types/type.go?s=14978:15009#L463" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (t *Named) Obj() *TypeName</pre> <p> Obj returns the type name for the named type t. </p> <h3 id="Named.SetUnderlying">func (*Named) SetUnderlying<a href="https://golang.org/src/go/types/type.go?s=15380:15426#L472" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (t *Named) SetUnderlying(underlying Type)</pre> <p> SetUnderlying sets the underlying type and marks t as complete. </p> <h3 id="Named.String">func (*Named) String<a href="https://golang.org/src/go/types/type.go?s=17148:17179#L513" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (t *Named) String() string</pre> <h3 id="Named.Underlying">func (*Named) Underlying<a href="https://golang.org/src/go/types/type.go?s=16425:16458#L501" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (t *Named) Underlying() Type</pre> <h2 id="Nil">type Nil<a href="https://golang.org/src/go/types/object.go?s=11856:11883#L337" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <p> Nil represents the predeclared value nil. </p> <pre data-language="go">type Nil struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="Nil.Exported">func (*Nil) Exported<a href="https://golang.org/src/go/types/object.go?s=4259:4293#L131" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Nil) Exported() bool</pre> <p> Exported reports whether the object is exported (starts with a capital letter). It doesn't take into account whether the object is in a local (function) scope or not. </p> <h3 id="Nil.Id">func (*Nil) Id<a href="https://golang.org/src/go/types/object.go?s=4383:4413#L134" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Nil) Id() string</pre> <p> Id is a wrapper for Id(obj.Pkg(), obj.Name()). </p> <h3 id="Nil.Name">func (*Nil) Name<a href="https://golang.org/src/go/types/object.go?s=3943:3975#L123" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Nil) Name() string</pre> <p> Name returns the object's (package-local, unqualified) name. </p> <h3 id="Nil.Parent">func (*Nil) Parent<a href="https://golang.org/src/go/types/object.go?s=3521:3555#L113" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Nil) Parent() *Scope</pre> <p> Parent returns the scope in which the object is declared. The result is nil for methods and struct fields. </p> <h3 id="Nil.Pkg">func (*Nil) Pkg<a href="https://golang.org/src/go/types/object.go?s=3825:3858#L120" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Nil) Pkg() *Package</pre> <p> Pkg returns the package to which the object belongs. The result is nil for labels and objects in the Universe scope. </p> <h3 id="Nil.Pos">func (*Nil) Pos<a href="https://golang.org/src/go/types/object.go?s=3647:3681#L116" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Nil) Pos() token.Pos</pre> <p> Pos returns the declaration position of the object's identifier. </p> <h3 id="Nil.String">func (*Nil) String<a href="https://golang.org/src/go/types/object.go?s=14364:14395#L453" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Nil) String() string</pre> <h3 id="Nil.Type">func (*Nil) Type<a href="https://golang.org/src/go/types/object.go?s=4032:4062#L126" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Nil) Type() Type</pre> <p> Type returns the object's type. </p> <h2 id="Object">type Object<a href="https://golang.org/src/go/types/object.go?s=411:1898#L8" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <p> An Object describes a named language entity such as a package, constant, type, variable, function (incl. methods), or label. All objects implement the Object interface. </p> <pre data-language="go">type Object interface {
    Parent() *Scope // scope in which this object is declared; nil for methods and struct fields
    Pos() token.Pos // position of object identifier in declaration
    Pkg() *Package  // package to which this object belongs; nil for labels and objects in the Universe scope
    Name() string   // package local object name
    Type() Type     // object type
    Exported() bool // reports whether the name starts with a capital letter
    Id() string     // object name if exported, qualified name if not exported (see func Id)

    // String returns a human-readable string of the object.
    String() string
    // contains filtered or unexported methods
}</pre> <h3 id="LookupFieldOrMethod">func LookupFieldOrMethod<a href="https://golang.org/src/go/types/lookup.go?s=1549:1667#L25" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func LookupFieldOrMethod(T Type, addressable bool, pkg *Package, name string) (obj Object, index []int, indirect bool)</pre> <p> LookupFieldOrMethod looks up a field or method with given package and name in T and returns the corresponding *Var or *Func, an index sequence, and a bool indicating if there were any pointer indirections on the path to the field or method. If addressable is set, T is the type of an addressable variable (only matters for method lookups). </p> <p> The last index entry is the field or method index in the (possibly embedded) type where the entry was found, either: </p> <pre data-language="go">1) the list of declared methods of a named type; or
2) the list of all methods (method set) of an interface type; or
3) the list of fields of a struct type.
</pre> <p> The earlier index entries are the indices of the embedded struct fields traversed to get to the found entry, starting at depth 0. </p> <p> If no entry is found, a nil object is returned. In this case, the returned index and indirect values have the following meaning: </p> <pre data-language="go">	- If index != nil, the index sequence points to an ambiguous entry
	(the same name appeared more than once at the same embedding level).

	- If indirect is set, a method with a pointer receiver type was found
     but there was no pointer on the path from the actual receiver type to
	the method's formal receiver base type, nor was the receiver addressable.
</pre> <h2 id="Package">type Package<a href="https://golang.org/src/go/types/package.go?s=243:555#L3" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <p> A Package describes a Go package. </p> <pre data-language="go">type Package struct {
    // contains filtered or unexported fields
}
</pre> <p> The Unsafe package is the package returned by an importer for the import path "unsafe". </p> <pre data-language="go">var Unsafe *Package</pre> <h3 id="NewPackage">func NewPackage<a href="https://golang.org/src/go/types/package.go?s=695:738#L15" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func NewPackage(path, name string) *Package</pre> <p> NewPackage returns a new Package for the given package path and name. The package is not complete and contains no explicit imports. </p> <h3 id="Package.Complete">func (*Package) Complete<a href="https://golang.org/src/go/types/package.go?s=1479:1514#L36" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (pkg *Package) Complete() bool</pre> <p> A package is complete if its scope contains (at least) all exported objects; otherwise it is incomplete. </p> <h3 id="Package.Imports">func (*Package) Imports<a href="https://golang.org/src/go/types/package.go?s=1961:2001#L47" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (pkg *Package) Imports() []*Package</pre> <p> Imports returns the list of packages directly imported by pkg; the list is in source order. </p> <p> If pkg was loaded from export data, Imports includes packages that provide package-level objects referenced by pkg. This may be more or less than the set of packages directly imported by pkg's source code. </p> <h3 id="Package.MarkComplete">func (*Package) MarkComplete<a href="https://golang.org/src/go/types/package.go?s=1585:1619#L39" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (pkg *Package) MarkComplete()</pre> <p> MarkComplete marks a package as complete. </p> <h3 id="Package.Name">func (*Package) Name<a href="https://golang.org/src/go/types/package.go?s=1010:1043#L24" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (pkg *Package) Name() string</pre> <p> Name returns the package name. </p> <h3 id="Package.Path">func (*Package) Path<a href="https://golang.org/src/go/types/package.go?s=921:954#L21" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (pkg *Package) Path() string</pre> <p> Path returns the package path. </p> <h3 id="Package.Scope">func (*Package) Scope<a href="https://golang.org/src/go/types/package.go?s=1311:1345#L32" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (pkg *Package) Scope() *Scope</pre> <p> Scope returns the (complete or incomplete) package scope holding the objects declared at package level (TypeNames, Consts, Vars, and Funcs). </p> <h3 id="Package.SetImports">func (*Package) SetImports<a href="https://golang.org/src/go/types/package.go?s=2171:2218#L51" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (pkg *Package) SetImports(list []*Package)</pre> <p> SetImports sets the list of explicitly imported packages to list. It is the caller's responsibility to make sure list elements are unique. </p> <h3 id="Package.SetName">func (*Package) SetName<a href="https://golang.org/src/go/types/package.go?s=1099:1139#L27" class="source">Source</a>  <span title="Added in Go 1.6">1.6</span> </h3> <pre data-language="go">func (pkg *Package) SetName(name string)</pre> <p> SetName sets the package name. </p> <h3 id="Package.String">func (*Package) String<a href="https://golang.org/src/go/types/package.go?s=2243:2278#L53" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (pkg *Package) String() string</pre> <h2 id="PkgName">type PkgName<a href="https://golang.org/src/go/types/object.go?s=5720:5816#L170" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <p> A PkgName represents an imported Go package. PkgNames don't have a type. </p> <pre data-language="go">type PkgName struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="NewPkgName">func NewPkgName<a href="https://golang.org/src/go/types/object.go?s=5965:6050#L178" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func NewPkgName(pos token.Pos, pkg *Package, name string, imported *Package) *PkgName</pre> <p> NewPkgName returns a new PkgName object representing an imported package. The remaining arguments set the attributes found with all Objects. </p> <h3 id="PkgName.Exported">func (*PkgName) Exported<a href="https://golang.org/src/go/types/object.go?s=4259:4293#L131" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *PkgName) Exported() bool</pre> <p> Exported reports whether the object is exported (starts with a capital letter). It doesn't take into account whether the object is in a local (function) scope or not. </p> <h3 id="PkgName.Id">func (*PkgName) Id<a href="https://golang.org/src/go/types/object.go?s=4383:4413#L134" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *PkgName) Id() string</pre> <p> Id is a wrapper for Id(obj.Pkg(), obj.Name()). </p> <h3 id="PkgName.Imported">func (*PkgName) Imported<a href="https://golang.org/src/go/types/object.go?s=6291:6330#L184" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *PkgName) Imported() *Package</pre> <p> Imported returns the package that was imported. It is distinct from Pkg(), which is the package containing the import statement. </p> <h3 id="PkgName.Name">func (*PkgName) Name<a href="https://golang.org/src/go/types/object.go?s=3943:3975#L123" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *PkgName) Name() string</pre> <p> Name returns the object's (package-local, unqualified) name. </p> <h3 id="PkgName.Parent">func (*PkgName) Parent<a href="https://golang.org/src/go/types/object.go?s=3521:3555#L113" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *PkgName) Parent() *Scope</pre> <p> Parent returns the scope in which the object is declared. The result is nil for methods and struct fields. </p> <h3 id="PkgName.Pkg">func (*PkgName) Pkg<a href="https://golang.org/src/go/types/object.go?s=3825:3858#L120" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *PkgName) Pkg() *Package</pre> <p> Pkg returns the package to which the object belongs. The result is nil for labels and objects in the Universe scope. </p> <h3 id="PkgName.Pos">func (*PkgName) Pos<a href="https://golang.org/src/go/types/object.go?s=3647:3681#L116" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *PkgName) Pos() token.Pos</pre> <p> Pos returns the declaration position of the object's identifier. </p> <h3 id="PkgName.String">func (*PkgName) String<a href="https://golang.org/src/go/types/object.go?s=13867:13902#L446" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *PkgName) String() string</pre> <h3 id="PkgName.Type">func (*PkgName) Type<a href="https://golang.org/src/go/types/object.go?s=4032:4062#L126" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *PkgName) Type() Type</pre> <p> Type returns the object's type. </p> <h2 id="Pointer">type Pointer<a href="https://golang.org/src/go/types/type.go?s=3671:3721#L149" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <p> A Pointer represents a pointer type. </p> <pre data-language="go">type Pointer struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="NewPointer">func NewPointer<a href="https://golang.org/src/go/types/type.go?s=3799:3834#L154" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func NewPointer(elem Type) *Pointer</pre> <p> NewPointer returns a new pointer type for the given element (base) type. </p> <h3 id="Pointer.Elem">func (*Pointer) Elem<a href="https://golang.org/src/go/types/type.go?s=3926:3955#L157" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (p *Pointer) Elem() Type</pre> <p> Elem returns the element type for the given pointer p. </p> <h3 id="Pointer.String">func (*Pointer) String<a href="https://golang.org/src/go/types/type.go?s=16752:16785#L507" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (p *Pointer) String() string</pre> <h3 id="Pointer.Underlying">func (*Pointer) Underlying<a href="https://golang.org/src/go/types/type.go?s=16119:16154#L495" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (p *Pointer) Underlying() Type</pre> <h2 id="Qualifier">type Qualifier<a href="https://golang.org/src/go/types/typestring.go?s=781:817#L15" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <p> A Qualifier controls how named package-level objects are printed in calls to TypeString, ObjectString, and SelectionString. </p> <p> These three formatting routines call the Qualifier for each package-level object O, and if the Qualifier returns a non-empty string p, the object is printed in the form p.O. If it returns an empty string, only the object name O is printed. </p> <p> Using a nil Qualifier is equivalent to using (*Package).Path: the object is qualified by the import path, e.g., "encoding/json.Marshal". </p> <pre data-language="go">type Qualifier func(*Package) string</pre> <h3 id="RelativeTo">func RelativeTo<a href="https://golang.org/src/go/types/typestring.go?s=917:956#L19" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func RelativeTo(pkg *Package) Qualifier</pre> <p> RelativeTo returns a Qualifier that fully qualifies members of all packages other than pkg. </p> <h2 id="Scope">type Scope<a href="https://golang.org/src/go/types/scope.go?s=493:791#L12" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <p> A Scope maintains a set of objects and links to its containing (parent) and contained (children) scopes. Objects may be inserted and looked up by name. The zero value for Scope is a ready-to-use empty scope. </p> <pre data-language="go">type Scope struct {
    // contains filtered or unexported fields
}
</pre> <p> The Universe scope contains all predeclared objects of Go. It is the outermost scope of any chain of nested scopes. </p> <pre data-language="go">var Universe *Scope</pre>    <h4 id="example_Scope"> <span class="text">Example</span>
</h4> <p>ExampleScope prints the tree of Scopes of a package created from a set of parsed files. </p> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/importer"
	"go/parser"
	"go/token"
	"go/types"
	"log"
	"regexp"
)

func main() {
	// Parse the source files for a package.
	fset := token.NewFileSet()
	var files []*ast.File
	for _, file := range []struct{ name, input string }{
		{"main.go", `
package main
import "fmt"
func main() {
	freezing := FToC(-18)
	fmt.Println(freezing, Boiling) }
`},
		{"celsius.go", `
package main
import "fmt"
type Celsius float64
func (c Celsius) String() string { return fmt.Sprintf("%gC", c) }
func FToC(f float64) Celsius { return Celsius(f - 32 / 9 * 5) }
const Boiling Celsius = 100
func Unused() { {}; {{ var x int; _ = x }} } // make sure empty block scopes get printed
`},
	} {
		f, err := parser.ParseFile(fset, file.name, file.input, 0)
		if err != nil {
			log.Fatal(err)
		}
		files = append(files, f)
	}

	// Type-check a package consisting of these files.
	// Type information for the imported "fmt" package
	// comes from $GOROOT/pkg/$GOOS_$GOOARCH/fmt.a.
	conf := types.Config{Importer: importer.Default()}
	pkg, err := conf.Check("temperature", fset, files, nil)
	if err != nil {
		log.Fatal(err)
	}

	// Print the tree of scopes.
	// For determinism, we redact addresses.
	var buf bytes.Buffer
	pkg.Scope().WriteTo(&amp;buf, 0, true)
	rx := regexp.MustCompile(` 0x[a-fA-F0-9]*`)
	fmt.Println(rx.ReplaceAllString(buf.String(), ""))

}
</pre>   <h3 id="NewScope">func NewScope<a href="https://golang.org/src/go/types/scope.go?s=915:986#L23" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func NewScope(parent *Scope, pos, end token.Pos, comment string) *Scope</pre> <p> NewScope returns a new, empty scope contained in the given parent scope, if any. The comment is for debugging only. </p> <h3 id="Scope.Child">func (*Scope) Child<a href="https://golang.org/src/go/types/scope.go?s=1820:1855#L54" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (s *Scope) Child(i int) *Scope</pre> <p> Child returns the i'th child scope for 0 &lt;= i &lt; NumChildren(). </p> <h3 id="Scope.Contains">func (*Scope) Contains<a href="https://golang.org/src/go/types/scope.go?s=3978:4022#L111" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (s *Scope) Contains(pos token.Pos) bool</pre> <p> Contains reports whether pos is within the scope's extent. The result is guaranteed to be valid only if the type-checked AST has complete position information. </p> <h3 id="Scope.End">func (*Scope) End<a href="https://golang.org/src/go/types/scope.go?s=3759:3790#L106" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (s *Scope) End() token.Pos</pre> <h3 id="Scope.Innermost">func (*Scope) Innermost<a href="https://golang.org/src/go/types/scope.go?s=4340:4387#L120" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (s *Scope) Innermost(pos token.Pos) *Scope</pre> <p> Innermost returns the innermost (child) scope containing pos. If pos is not within any scope, the result is nil. The result is also nil for the Universe scope. The result is guaranteed to be valid only if the type-checked AST has complete position information. </p> <h3 id="Scope.Insert">func (*Scope) Insert<a href="https://golang.org/src/go/types/scope.go?s=3211:3252#L86" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (s *Scope) Insert(obj Object) Object</pre> <p> Insert attempts to insert an object obj into scope s. If s already contains an alternative object alt with the same name, Insert leaves s unchanged and returns alt. Otherwise it inserts obj, sets the object's parent scope if not already set, and returns nil. </p> <h3 id="Scope.Len">func (*Scope) Len<a href="https://golang.org/src/go/types/scope.go?s=1348:1373#L36" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (s *Scope) Len() int</pre> <p> Len returns the number of scope elements. </p> <h3 id="Scope.Lookup">func (*Scope) Lookup<a href="https://golang.org/src/go/types/scope.go?s=2000:2042#L58" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (s *Scope) Lookup(name string) Object</pre> <p> Lookup returns the object in scope s with the given name if such an object exists; otherwise the result is nil. </p> <h3 id="Scope.LookupParent">func (*Scope) LookupParent<a href="https://golang.org/src/go/types/scope.go?s=2700:2773#L72" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (s *Scope) LookupParent(name string, pos token.Pos) (*Scope, Object)</pre> <p> LookupParent follows the parent chain of scopes starting with s until it finds a scope where Lookup(name) returns a non-nil object, and then returns that scope and object. If a valid position pos is provided, only objects that were declared at or before pos are considered. If no such scope and object exists, the result is (nil, nil). </p> <p> Note that obj.Parent() may be different from the returned scope if the object was inserted into the scope and already had a parent at that time (see Insert). This can only happen for dot-imported objects whose scope is the scope of the package that exported them. </p> <h3 id="Scope.Names">func (*Scope) Names<a href="https://golang.org/src/go/types/scope.go?s=1459:1491#L39" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (s *Scope) Names() []string</pre> <p> Names returns the scope's element names in sorted order. </p> <h3 id="Scope.NumChildren">func (*Scope) NumChildren<a href="https://golang.org/src/go/types/scope.go?s=1692:1725#L51" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (s *Scope) NumChildren() int</pre> <p> NumChildren returns the number of scopes nested in s. </p> <h3 id="Scope.Parent">func (*Scope) Parent<a href="https://golang.org/src/go/types/scope.go?s=1250:1281#L33" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (s *Scope) Parent() *Scope</pre> <p> Parent returns the scope's containing (parent) scope. </p> <h3 id="Scope.Pos">func (*Scope) Pos<a href="https://golang.org/src/go/types/scope.go?s=3710:3741#L105" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (s *Scope) Pos() token.Pos</pre> <p> Pos and End describe the scope's source code extent [pos, end). The results are guaranteed to be valid only if the type-checked AST has complete position information. The extent is undefined for Universe and package scopes. </p> <h3 id="Scope.String">func (*Scope) String<a href="https://golang.org/src/go/types/scope.go?s=5509:5540#L168" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (s *Scope) String() string</pre> <p> String returns a string representation of the scope, for debugging. </p> <h3 id="Scope.WriteTo">func (*Scope) WriteTo<a href="https://golang.org/src/go/types/scope.go?s=5041:5098#L147" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (s *Scope) WriteTo(w io.Writer, n int, recurse bool)</pre> <p> WriteTo writes a string representation of the scope to w, with the scope elements sorted by name. The level of indentation is controlled by n &gt;= 0, with n == 0 for no indentation. If recurse is set, it also writes nested (children) scopes. </p> <h2 id="Selection">type Selection<a href="https://golang.org/src/go/types/selection.go?s=1061:1294#L30" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <p> A Selection describes a selector expression x.f. For the declarations: </p> <pre data-language="go">type T struct{ x int; E }
type E struct{}
func (e E) m() {}
var p *T
</pre> <p> the following relations exist: </p> <pre data-language="go">Selector    Kind          Recv    Obj    Type       Index     Indirect

p.x         FieldVal      T       x      int        {0}       true
p.m         MethodVal     *T      m      func()     {1, 0}    true
T.m         MethodExpr    T       m      func(T)    {1, 0}    false
</pre> <pre data-language="go">type Selection struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="Selection.Index">func (*Selection) Index<a href="https://golang.org/src/go/types/selection.go?s=3058:3091#L92" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (s *Selection) Index() []int</pre> <p> Index describes the path from x to f in x.f. The last index entry is the field or method index of the type declaring f; either: </p> <pre data-language="go">1) the list of declared methods of a named type; or
2) the list of methods of an interface type; or
3) the list of fields of a struct type.
</pre> <p> The earlier index entries are the indices of the embedded fields implicitly traversed to get from (the type of) x to f, starting at embedding depth 0. </p> <h3 id="Selection.Indirect">func (*Selection) Indirect<a href="https://golang.org/src/go/types/selection.go?s=3207:3242#L96" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (s *Selection) Indirect() bool</pre> <p> Indirect reports whether any pointer indirection was required to get from x to f in x.f. </p> <h3 id="Selection.Kind">func (*Selection) Kind<a href="https://golang.org/src/go/types/selection.go?s=1332:1372#L39" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (s *Selection) Kind() SelectionKind</pre> <p> Kind returns the selection kind. </p> <h3 id="Selection.Obj">func (*Selection) Obj<a href="https://golang.org/src/go/types/selection.go?s=1588:1620#L46" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (s *Selection) Obj() Object</pre> <p> Obj returns the object denoted by x.f; a *Var for a field selection, and a *Func in all other cases. </p> <h3 id="Selection.Recv">func (*Selection) Recv<a href="https://golang.org/src/go/types/selection.go?s=1430:1461#L42" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (s *Selection) Recv() Type</pre> <p> Recv returns the type of x in x.f. </p> <h3 id="Selection.String">func (*Selection) String<a href="https://golang.org/src/go/types/selection.go?s=3266:3301#L98" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (s *Selection) String() string</pre> <h3 id="Selection.Type">func (*Selection) Type<a href="https://golang.org/src/go/types/selection.go?s=1754:1785#L50" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (s *Selection) Type() Type</pre> <p> Type returns the type of x.f, which may be different from the type of f. See Selection for more information. </p> <h2 id="SelectionKind">type SelectionKind<a href="https://golang.org/src/go/types/selection.go?s=343:365#L6" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <p> SelectionKind describes the kind of a selector expression x.f (excluding qualified identifiers). </p> <pre data-language="go">type SelectionKind int</pre> <pre data-language="go">const (
    FieldVal   SelectionKind = iota // x.f is a struct field selector
    MethodVal                       // x.f is a method selector
    MethodExpr                      // x.f is a method expression
)</pre> <h2 id="Signature">type Signature<a href="https://golang.org/src/go/types/type.go?s=4745:5428#L187" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <p> A Signature represents a (non-builtin) function or method type. The receiver is ignored when comparing signatures for identity. </p> <pre data-language="go">type Signature struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="NewSignature">func NewSignature<a href="https://golang.org/src/go/types/type.go?s=5697:5775#L203" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func NewSignature(recv *Var, params, results *Tuple, variadic bool) *Signature</pre> <p> NewSignature returns a new function type for the given receiver, parameters, and results, either of which may be nil. If variadic is set, the function is variadic, it must have at least one parameter, and the last parameter must be of unnamed slice type. </p> <h3 id="Signature.Params">func (*Signature) Params<a href="https://golang.org/src/go/types/type.go?s=6566:6601#L225" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (s *Signature) Params() *Tuple</pre> <p> Params returns the parameters of signature s, or nil. </p> <h3 id="Signature.Recv">func (*Signature) Recv<a href="https://golang.org/src/go/types/type.go?s=6458:6489#L222" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (s *Signature) Recv() *Var</pre> <p> Recv returns the receiver of signature s (if a method), or nil if a function. It is ignored when comparing signatures for identity. </p> <p> For an abstract method, Recv returns the enclosing interface either as a *Named or an *Interface. Due to embedding, an interface may contain methods whose receiver type is a different interface. </p> <h3 id="Signature.Results">func (*Signature) Results<a href="https://golang.org/src/go/types/type.go?s=6678:6714#L228" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (s *Signature) Results() *Tuple</pre> <p> Results returns the results of signature s, or nil. </p> <h3 id="Signature.String">func (*Signature) String<a href="https://golang.org/src/go/types/type.go?s=16884:16919#L509" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (s *Signature) String() string</pre> <h3 id="Signature.Underlying">func (*Signature) Underlying<a href="https://golang.org/src/go/types/type.go?s=16221:16258#L497" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (s *Signature) Underlying() Type</pre> <h3 id="Signature.Variadic">func (*Signature) Variadic<a href="https://golang.org/src/go/types/type.go?s=6794:6829#L231" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (s *Signature) Variadic() bool</pre> <p> Variadic reports whether the signature s is variadic. </p> <h2 id="Sizes">type Sizes<a href="https://golang.org/src/go/types/sizes.go?s=265:769#L1" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <p> Sizes defines the sizing functions for package unsafe. </p> <pre data-language="go">type Sizes interface {
    // Alignof returns the alignment of a variable of type T.
    // Alignof must implement the alignment guarantees required by the spec.
    Alignof(T Type) int64

    // Offsetsof returns the offsets of the given struct fields, in bytes.
    // Offsetsof must implement the offset guarantees required by the spec.
    Offsetsof(fields []*Var) []int64

    // Sizeof returns the size of a variable of type T.
    // Sizeof must implement the size guarantees required by the spec.
    Sizeof(T Type) int64
}</pre> <h3 id="SizesFor">func SizesFor<a href="https://golang.org/src/go/types/sizes.go?s=4997:5039#L174" class="source">Source</a>  <span title="Added in Go 1.9">1.9</span> </h3> <pre data-language="go">func SizesFor(compiler, arch string) Sizes</pre> <p> SizesFor returns the Sizes used by a compiler for an architecture. The result is nil if a compiler/architecture pair is not known. </p> <p> Supported architectures for compiler "gc": "386", "arm", "arm64", "amd64", "amd64p32", "mips", "mipsle", "mips64", "mips64le", "ppc64", "ppc64le", "riscv64", "s390x", "sparc64", "wasm". </p> <h2 id="Slice">type Slice<a href="https://golang.org/src/go/types/type.go?s=2212:2244#L101" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <p> A Slice represents a slice type. </p> <pre data-language="go">type Slice struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="NewSlice">func NewSlice<a href="https://golang.org/src/go/types/type.go?s=2311:2342#L106" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func NewSlice(elem Type) *Slice</pre> <p> NewSlice returns a new slice type for the given element type. </p> <h3 id="Slice.Elem">func (*Slice) Elem<a href="https://golang.org/src/go/types/type.go?s=2413:2440#L109" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (s *Slice) Elem() Type</pre> <p> Elem returns the element type of slice s. </p> <h3 id="Slice.String">func (*Slice) String<a href="https://golang.org/src/go/types/type.go?s=16620:16651#L505" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (s *Slice) String() string</pre> <h3 id="Slice.Underlying">func (*Slice) Underlying<a href="https://golang.org/src/go/types/type.go?s=16017:16050#L493" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (s *Slice) Underlying() Type</pre> <h2 id="StdSizes">type StdSizes<a href="https://golang.org/src/go/types/sizes.go?s=1657:1804#L33" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <p> StdSizes is a convenience type for creating commonly used Sizes. It makes the following simplifying assumptions: </p> <pre data-language="go">	- The size of explicitly sized basic types (int16, etc.) is the
	  specified size.
	- The size of strings and interfaces is 2*WordSize.
	- The size of slices is 3*WordSize.
	- The size of an array of n elements corresponds to the size of
	  a struct of n consecutive fields of the array's element type.
     - The size of a struct is the offset of the last field plus that
	  field's size. As with all element types, if the struct is used
	  in an array its size must first be aligned to a multiple of the
	  struct's alignment.
	- All other types have size WordSize.
	- Arrays and structs are aligned per spec definition; all other
	  types are naturally aligned with a maximum alignment MaxAlign.
</pre> <p> *StdSizes implements Sizes. </p> <pre data-language="go">type StdSizes struct {
    WordSize int64 // word size in bytes - must be &gt;= 4 (32bits)
    MaxAlign int64 // maximum alignment in bytes - must be &gt;= 1
}
</pre> <h3 id="StdSizes.Alignof">func (*StdSizes) Alignof<a href="https://golang.org/src/go/types/sizes.go?s=1806:1846#L38" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (s *StdSizes) Alignof(T Type) int64</pre> <h3 id="StdSizes.Offsetsof">func (*StdSizes) Offsetsof<a href="https://golang.org/src/go/types/sizes.go?s=3001:3052#L82" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (s *StdSizes) Offsetsof(fields []*Var) []int64</pre> <h3 id="StdSizes.Sizeof">func (*StdSizes) Sizeof<a href="https://golang.org/src/go/types/sizes.go?s=3479:3518#L110" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (s *StdSizes) Sizeof(T Type) int64</pre> <h2 id="Struct">type Struct<a href="https://golang.org/src/go/types/type.go?s=2498:2592#L112" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <p> A Struct represents a struct type. </p> <pre data-language="go">type Struct struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="NewStruct">func NewStruct<a href="https://golang.org/src/go/types/type.go?s=2892:2944#L121" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func NewStruct(fields []*Var, tags []string) *Struct</pre> <p> NewStruct returns a new struct with the given fields and corresponding field tags. If a field with index i has a tag, tags[i] must be that tag, but len(tags) may be only as long as required to hold the tag with the largest index i. Consequently, if no field has a tag, tags may be nil. </p> <h3 id="Struct.Field">func (*Struct) Field<a href="https://golang.org/src/go/types/type.go?s=3417:3451#L138" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (s *Struct) Field(i int) *Var</pre> <p> Field returns the i'th field for 0 &lt;= i &lt; NumFields(). </p> <h3 id="Struct.NumFields">func (*Struct) NumFields<a href="https://golang.org/src/go/types/type.go?s=3300:3332#L135" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (s *Struct) NumFields() int</pre> <p> NumFields returns the number of fields in the struct (including blank and embedded fields). </p> <h3 id="Struct.String">func (*Struct) String<a href="https://golang.org/src/go/types/type.go?s=16686:16718#L506" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (s *Struct) String() string</pre> <h3 id="Struct.Tag">func (*Struct) Tag<a href="https://golang.org/src/go/types/type.go?s=3536:3570#L141" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (s *Struct) Tag(i int) string</pre> <p> Tag returns the i'th field tag for 0 &lt;= i &lt; NumFields(). </p> <h3 id="Struct.Underlying">func (*Struct) Underlying<a href="https://golang.org/src/go/types/type.go?s=16068:16102#L494" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (s *Struct) Underlying() Type</pre> <h2 id="Tuple">type Tuple<a href="https://golang.org/src/go/types/type.go?s=4205:4239#L162" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <p> A Tuple represents an ordered list of variables; a nil *Tuple is a valid (empty) tuple. Tuples are used as components of signatures and to represent the type of multiple assignments; they are not first class types of Go. </p> <pre data-language="go">type Tuple struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="NewTuple">func NewTuple<a href="https://golang.org/src/go/types/type.go?s=4298:4329#L167" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func NewTuple(x ...*Var) *Tuple</pre> <p> NewTuple returns a new tuple for the given variables. </p> <h3 id="Tuple.At">func (*Tuple) At<a href="https://golang.org/src/go/types/type.go?s=4558:4588#L183" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (t *Tuple) At(i int) *Var</pre> <p> At returns the i'th variable of tuple t. </p> <h3 id="Tuple.Len">func (*Tuple) Len<a href="https://golang.org/src/go/types/type.go?s=4434:4459#L175" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (t *Tuple) Len() int</pre> <p> Len returns the number variables of tuple t. </p> <h3 id="Tuple.String">func (*Tuple) String<a href="https://golang.org/src/go/types/type.go?s=16818:16849#L508" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (t *Tuple) String() string</pre> <h3 id="Tuple.Underlying">func (*Tuple) Underlying<a href="https://golang.org/src/go/types/type.go?s=16170:16203#L496" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (t *Tuple) Underlying() Type</pre> <h2 id="Type">type Type<a href="https://golang.org/src/go/types/type.go?s=268:436#L1" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <p> A Type represents a type of Go. All types implement the Type interface. </p> <pre data-language="go">type Type interface {
    // Underlying returns the underlying type of a type.
    Underlying() Type

    // String returns a string representation of a type.
    String() string
}</pre> <h3 id="Default">func Default<a href="https://golang.org/src/go/types/predicates.go?s=8852:8879#L300" class="source">Source</a>  <span title="Added in Go 1.8">1.8</span> </h3> <pre data-language="go">func Default(typ Type) Type</pre> <p> Default returns the default "typed" type for an "untyped" type; it returns the incoming type for all other types. The default type for untyped nil is untyped nil. </p> <h2 id="TypeAndValue">type TypeAndValue<a href="https://golang.org/src/go/types/api.go?s=10198:10279#L259" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <p> TypeAndValue reports the type and value (for constants) of the corresponding expression. </p> <pre data-language="go">type TypeAndValue struct {
    Type  Type
    Value constant.Value
    // contains filtered or unexported fields
}
</pre> <h3 id="Eval">func Eval<a href="https://golang.org/src/go/types/eval.go?s=689:789#L14" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func Eval(fset *token.FileSet, pkg *Package, pos token.Pos, expr string) (_ TypeAndValue, err error)</pre> <p> Eval returns the type and, if constant, the value for the expression expr, evaluated at position pos of package pkg, which must have been derived from type-checking an AST with complete position information relative to the provided file set. </p> <p> The meaning of the parameters fset, pkg, and pos is the same as in CheckExpr. An error is returned if expr cannot be parsed successfully, or the resulting expr AST cannot be type-checked. </p> <h3 id="TypeAndValue.Addressable">func (TypeAndValue) Addressable<a href="https://golang.org/src/go/types/api.go?s=11392:11433#L301" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (tv TypeAndValue) Addressable() bool</pre> <p> Addressable reports whether the corresponding expression is addressable (<a href="https://golang.org/ref/spec#Address_operators">https://golang.org/ref/spec#Address_operators</a>). </p> <h3 id="TypeAndValue.Assignable">func (TypeAndValue) Assignable<a href="https://golang.org/src/go/types/api.go?s=11584:11624#L307" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (tv TypeAndValue) Assignable() bool</pre> <p> Assignable reports whether the corresponding expression is assignable to (provided a value of the right type). </p> <h3 id="TypeAndValue.HasOk">func (TypeAndValue) HasOk<a href="https://golang.org/src/go/types/api.go?s=11787:11822#L313" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (tv TypeAndValue) HasOk() bool</pre> <p> HasOk reports whether the corresponding expression may be used on the rhs of a comma-ok assignment. </p> <h3 id="TypeAndValue.IsBuiltin">func (TypeAndValue) IsBuiltin<a href="https://golang.org/src/go/types/api.go?s=10701:10740#L278" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (tv TypeAndValue) IsBuiltin() bool</pre> <p> IsBuiltin reports whether the corresponding expression denotes a (possibly parenthesized) built-in function. </p> <h3 id="TypeAndValue.IsNil">func (TypeAndValue) IsNil<a href="https://golang.org/src/go/types/api.go?s=11169:11204#L295" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (tv TypeAndValue) IsNil() bool</pre> <p> IsNil reports whether the corresponding expression denotes the predeclared value nil. </p> <h3 id="TypeAndValue.IsType">func (TypeAndValue) IsType<a href="https://golang.org/src/go/types/api.go?s=10517:10553#L272" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (tv TypeAndValue) IsType() bool</pre> <p> IsType reports whether the corresponding expression specifies a type. </p> <h3 id="TypeAndValue.IsValue">func (TypeAndValue) IsValue<a href="https://golang.org/src/go/types/api.go?s=10922:10959#L285" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (tv TypeAndValue) IsValue() bool</pre> <p> IsValue reports whether the corresponding expression is a value. Builtins are not considered values. Constant values have a non- nil Value. </p> <h3 id="TypeAndValue.IsVoid">func (TypeAndValue) IsVoid<a href="https://golang.org/src/go/types/api.go?s=10375:10411#L267" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (tv TypeAndValue) IsVoid() bool</pre> <p> IsVoid reports whether the corresponding expression is a function call without results. </p> <h2 id="TypeName">type TypeName<a href="https://golang.org/src/go/types/object.go?s=7012:7044#L204" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <p> A TypeName represents a name for a (defined or alias) type. </p> <pre data-language="go">type TypeName struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="NewTypeName">func NewTypeName<a href="https://golang.org/src/go/types/object.go?s=7402:7480#L215" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func NewTypeName(pos token.Pos, pkg *Package, name string, typ Type) *TypeName</pre> <p> NewTypeName returns a new type name denoting the given typ. The remaining arguments set the attributes found with all Objects. </p> <p> The typ argument may be a defined (Named) type or an alias type. It may also be nil such that the returned TypeName can be used as argument for NewNamed, which will set the TypeName's type as a side- effect. </p> <h3 id="TypeName.Exported">func (*TypeName) Exported<a href="https://golang.org/src/go/types/object.go?s=4259:4293#L131" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *TypeName) Exported() bool</pre> <p> Exported reports whether the object is exported (starts with a capital letter). It doesn't take into account whether the object is in a local (function) scope or not. </p> <h3 id="TypeName.Id">func (*TypeName) Id<a href="https://golang.org/src/go/types/object.go?s=4383:4413#L134" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *TypeName) Id() string</pre> <p> Id is a wrapper for Id(obj.Pkg(), obj.Name()). </p> <h3 id="TypeName.IsAlias">func (*TypeName) IsAlias<a href="https://golang.org/src/go/types/object.go?s=7629:7664#L220" class="source">Source</a>  <span title="Added in Go 1.9">1.9</span> </h3> <pre data-language="go">func (obj *TypeName) IsAlias() bool</pre> <p> IsAlias reports whether obj is an alias name for a type. </p> <h3 id="TypeName.Name">func (*TypeName) Name<a href="https://golang.org/src/go/types/object.go?s=3943:3975#L123" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *TypeName) Name() string</pre> <p> Name returns the object's (package-local, unqualified) name. </p> <h3 id="TypeName.Parent">func (*TypeName) Parent<a href="https://golang.org/src/go/types/object.go?s=3521:3555#L113" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *TypeName) Parent() *Scope</pre> <p> Parent returns the scope in which the object is declared. The result is nil for methods and struct fields. </p> <h3 id="TypeName.Pkg">func (*TypeName) Pkg<a href="https://golang.org/src/go/types/object.go?s=3825:3858#L120" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *TypeName) Pkg() *Package</pre> <p> Pkg returns the package to which the object belongs. The result is nil for labels and objects in the Universe scope. </p> <h3 id="TypeName.Pos">func (*TypeName) Pos<a href="https://golang.org/src/go/types/object.go?s=3647:3681#L116" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *TypeName) Pos() token.Pos</pre> <p> Pos returns the declaration position of the object's identifier. </p> <h3 id="TypeName.String">func (*TypeName) String<a href="https://golang.org/src/go/types/object.go?s=14009:14045#L448" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *TypeName) String() string</pre> <h3 id="TypeName.Type">func (*TypeName) Type<a href="https://golang.org/src/go/types/object.go?s=4032:4062#L126" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *TypeName) Type() Type</pre> <p> Type returns the object's type. </p> <h2 id="Var">type Var<a href="https://golang.org/src/go/types/object.go?s=8496:8702#L244" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <p> A Variable represents a declared variable (including function parameters and results, and struct fields). </p> <pre data-language="go">type Var struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="NewField">func NewField<a href="https://golang.org/src/go/types/object.go?s=9401:9486#L265" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func NewField(pos token.Pos, pkg *Package, name string, typ Type, embedded bool) *Var</pre> <p> NewField returns a new variable representing a struct field. For embedded fields, the name is the unqualified type name / under which the field is accessible. </p> <h3 id="NewParam">func NewParam<a href="https://golang.org/src/go/types/object.go?s=9028:9098#L258" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func NewParam(pos token.Pos, pkg *Package, name string, typ Type) *Var</pre> <p> NewParam returns a new variable representing a function parameter. </p> <h3 id="NewVar">func NewVar<a href="https://golang.org/src/go/types/object.go?s=8798:8866#L253" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func NewVar(pos token.Pos, pkg *Package, name string, typ Type) *Var</pre> <p> NewVar returns a new variable. The arguments set the attributes found with all Objects. </p> <h3 id="Var.Anonymous">func (*Var) Anonymous<a href="https://golang.org/src/go/types/object.go?s=9739:9771#L271" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Var) Anonymous() bool</pre> <p> Anonymous reports whether the variable is an embedded field. Same as Embedded; only present for backward-compatibility. </p> <h3 id="Var.Embedded">func (*Var) Embedded<a href="https://golang.org/src/go/types/object.go?s=9860:9891#L274" class="source">Source</a>  <span title="Added in Go 1.11">1.11</span> </h3> <pre data-language="go">func (obj *Var) Embedded() bool</pre> <p> Embedded reports whether the variable is an embedded field. </p> <h3 id="Var.Exported">func (*Var) Exported<a href="https://golang.org/src/go/types/object.go?s=4259:4293#L131" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Var) Exported() bool</pre> <p> Exported reports whether the object is exported (starts with a capital letter). It doesn't take into account whether the object is in a local (function) scope or not. </p> <h3 id="Var.Id">func (*Var) Id<a href="https://golang.org/src/go/types/object.go?s=4383:4413#L134" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Var) Id() string</pre> <p> Id is a wrapper for Id(obj.Pkg(), obj.Name()). </p> <h3 id="Var.IsField">func (*Var) IsField<a href="https://golang.org/src/go/types/object.go?s=9976:10006#L277" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Var) IsField() bool</pre> <p> IsField reports whether the variable is a struct field. </p> <h3 id="Var.Name">func (*Var) Name<a href="https://golang.org/src/go/types/object.go?s=3943:3975#L123" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Var) Name() string</pre> <p> Name returns the object's (package-local, unqualified) name. </p> <h3 id="Var.Parent">func (*Var) Parent<a href="https://golang.org/src/go/types/object.go?s=3521:3555#L113" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Var) Parent() *Scope</pre> <p> Parent returns the scope in which the object is declared. The result is nil for methods and struct fields. </p> <h3 id="Var.Pkg">func (*Var) Pkg<a href="https://golang.org/src/go/types/object.go?s=3825:3858#L120" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Var) Pkg() *Package</pre> <p> Pkg returns the package to which the object belongs. The result is nil for labels and objects in the Universe scope. </p> <h3 id="Var.Pos">func (*Var) Pos<a href="https://golang.org/src/go/types/object.go?s=3647:3681#L116" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Var) Pos() token.Pos</pre> <p> Pos returns the declaration position of the object's identifier. </p> <h3 id="Var.String">func (*Var) String<a href="https://golang.org/src/go/types/object.go?s=14080:14111#L449" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Var) String() string</pre> <h3 id="Var.Type">func (*Var) Type<a href="https://golang.org/src/go/types/object.go?s=4032:4062#L126" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (obj *Var) Type() Type</pre> <p> Type returns the object's type. </p>
<div class="_attribution">
  <p class="_attribution-p">
     Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>
    <a href="https://golang.org/pkg/go/types/" class="_attribution-link">https://golang.org/pkg/go/types/</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
