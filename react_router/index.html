
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>React Router Documentation - W3cubDocs</title>
  
  <meta name="description" content=" React Router documentation ">
  <meta name="keywords" content="api, reference, react, router, documentation, react_router">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/react_router/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-60a6449bb52e9968d95c133a29f066ffcb8dbe4f077d4022e51c991ce30bf256c8e19c508207a4193c414ffd0414826564317669b0f27f9f85c1cb21b84e097e.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/react_router.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/react_router/" class="_nav-link" title="" style="margin-left:0;">React Router</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _simple">
				
				
<h1 id="api-reference">
API Reference</h1>
<p>React Router is a collection of <a href="https://reactjs.org/docs/components-and-props.html">React components</a>, <a href="https://reactjs.org/docs/hooks-intro.html">hooks</a> and utilities that make it easy to build multi-page applications with <a href="https://reactjs.org">React</a>. This reference contains the function signatures and return types of the various interfaces in React Router.</p>
<h2 id="overview">
Overview</h2>
<h3 id="packages">
Packages</h3>
<p>React Router is published to npm in three different packages:</p>
<ul> <li>
<a href="https://npm.im/react-router"><code>react-router</code></a> contains most of the core functionality of React Router including the route matching algorithm and most of the core components and hooks</li> <li>
<a href="https://npm.im/react-router-dom"><code>react-router-dom</code></a> includes everything from <code>react-router</code> and adds a few DOM-specific APIs, including <a href="#browserrouter"><code>&lt;BrowserRouter&gt;</code></a>, <a href="#hashrouter"><code>&lt;HashRouter&gt;</code></a>, and <a href="#link"><code>&lt;Link&gt;</code></a>
</li> <li>
<a href="https://npm.im/react-router-native"><code>react-router-native</code></a> includes everything from <code>react-router</code> and adds a few APIs that are specific to React Native, including <a href="#nativerouter"><code>&lt;NativeRouter&gt;</code></a> and <a href="#link-react-native">a native version of <code>&lt;Link&gt;</code></a>
</li> </ul>
<p>Both <code>react-router-dom</code> and <code>react-router-native</code> automatically include <code>react-router</code> as a dependency when you install them, and both packages re-export everything from <code>react-router</code>. <strong>When you <code>import</code> stuff, you should always import from either <code>react-router-dom</code> or <code>react-router-native</code> and never directly from <code>react-router</code></strong>. Otherwise you may accidentally import mismatched versions of the library in your app.</p>
<p>If you <a href="https://reactrouterdotcom.fly.dev/docs/en/v6/getting-started/installation">installed</a> React Router as a global (using a <code>&lt;script&gt;</code> tag), you can find the library on the <code>window.ReactRouterDOM</code> object. If you installed it from npm, you can <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import"><code>import</code></a> the pieces you need. The examples in this reference all use <code>import</code> syntax.</p>
<h3 id="setup">
Setup</h3>
<p>To get React Router working in your app, you need to render a router element at or near the root of your element tree. We provide several different routers depending on where your app is running.</p>
<ul> <li>
<a href="#browserrouter"><code>&lt;BrowserRouter&gt;</code></a> or <a href="#hashrouter"><code>&lt;HashRouter&gt;</code></a> should be used when running in a web browser (which one you pick depends on the style of URL you prefer or need)</li> <li>
<a href="#staticrouter"><code>&lt;StaticRouter&gt;</code></a> should be used when server-rendering a website</li> <li>
<a href="#nativerouter"><code>&lt;NativeRouter&gt;</code></a> should be used in <a href="https://reactnative.dev/">React Native</a> apps</li> <li>
<a href="#memoryrouter"><code>&lt;MemoryRouter&gt;</code></a> is useful in testing scenarios and as a reference implementation for the other routers</li> </ul>
<p>These routers provide the context that React Router needs to operate in a particular environment. Each one renders <a href="#router">a <code>&lt;Router&gt;</code></a> internally, which you may also do if you need more fine-grained control for some reason. But it is highly likely that one of the built-in routers is what you need.</p>
<h3 id="routing">
Routing</h3>
<p>Routing is the process of deciding which React elements will be rendered on a given page of your app, and how they will be nested. React Router provides two interfaces for declaring your routes.</p>
<ul> <li>
<a href="#routes-and-route"><code>&lt;Routes&gt;</code> and <code>&lt;Route&gt;</code></a> if you're using JSX</li> <li>
<a href="#useroutes"><code>useRoutes</code></a> if you'd prefer a JavaScript object-based config</li> </ul>
<p>A few low-level pieces that we use internally are also exposed as public API, in case you need to build your own higher-level interfaces for some reason.</p>
<ul> <li>
<a href="#matchpath"><code>matchPath</code></a> - matches a path pattern against a URL pathname</li> <li>
<a href="#matchroutes"><code>matchRoutes</code></a> - matches a set of routes against a <a href="#location">location</a>
</li> <li>
<a href="#createroutesfromchildren"><code>createRoutesFromChildren</code></a> - creates a route config from a set of React elements (i.e. <a href="#routes-and-route"><code>&lt;Route&gt;</code></a> elements)</li> </ul>
<h3 id="navigation">
Navigation</h3>
<p>React Router's navigation interfaces let you change the currently rendered page by modifying the current <a href="#location">location</a>. There are two main interfaces for navigating between pages in your app, depending on what you need.</p>
<ul> <li>
<a href="#link"><code>&lt;Link&gt;</code></a> and <a href="#navlink"><code>&lt;NavLink&gt;</code></a> render an accessible <code>&lt;a&gt;</code> element, or a <code>TouchableHighlight</code> on React Native. This lets the user initiate navigation by clicking or tapping an element on the page.</li> <li>
<a href="#usenavigate"><code>useNavigate</code></a> and <a href="#navigate"><code>&lt;Navigate&gt;</code></a> let you programmatically navigate, usually in an event handler or in response to some change in state</li> </ul>
<p>There are a few low-level APIs that we use internally that may also prove useful when building your own navigation interfaces.</p>
<ul> <li>
<a href="#useresolvedpath"><code>useResolvedPath</code></a> - resolves a relative path against the current <a href="#location">location</a>
</li> <li>
<a href="#usehref"><code>useHref</code></a> - resolves a relative path suitable for use as a <code>&lt;a href&gt;</code>
</li> <li>
<a href="#uselocation"><code>useLocation</code></a> and <a href="#usenavigationtype"><code>useNavigationType</code></a> - these describe the current <a href="#location">location</a> and how we got there</li> <li>
<a href="#uselinkclickhandler"><code>useLinkClickHandler</code></a> - returns an event handler to for navigation when building a custom <code>&lt;Link&gt;</code> in <code>react-router-dom</code>
</li> <li>
<a href="#uselinkpresshandler"><code>useLinkPressHandler</code></a> - returns an event handler to for navigation when building a custom <code>&lt;Link&gt;</code> in <code>react-router-native</code>
</li> <li>
<a href="#resolvepath"><code>resolvePath</code></a> - resolves a relative path against a given URL pathname</li> </ul>
<h3 id="search-parameters">
Search Parameters</h3>
<p>Access to the URL <a href="https://developer.mozilla.org/en-US/docs/Web/API/URL/searchParams">search parameters</a> is provided via <a href="#usesearchparams">the <code>useSearchParams</code> hook</a>.</p>
<hr>
<h2 id="reference">
Reference</h2>
<h3 id="browserrouter">
<code>&lt;BrowserRouter&gt;</code>
</h3>
<details> <summary>Type declaration</summary><div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">declare function BrowserRouter(
  props: BrowserRouterProps
): React.ReactElement;

interface BrowserRouterProps {
  basename?: string;
  children?: React.ReactNode;
  window?: Window;
}
</pre></div></details><p><code>&lt;BrowserRouter&gt;</code> is the recommended interface for running React Router in a web browser. A <code>&lt;BrowserRouter&gt;</code> stores the current location in the browser's address bar using clean URLs and navigates using the browser's built-in history stack.</p>
<p><code>&lt;BrowserRouter window&gt;</code> defaults to using the current <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/defaultView">document's <code>defaultView</code></a>, but it may also be used to track changes to another window's URL, in an <code>&lt;iframe&gt;</code>, for example.</p>
<div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">import * as React from "react";
import * as ReactDOM from "react-dom";
import { BrowserRouter } from "react-router-dom";

ReactDOM.render(
  &lt;BrowserRouter&gt;
    {/* The rest of your app goes here */}
  &lt;/BrowserRouter&gt;,
  root
);
</pre></div>
<h3 id="hashrouter">
<code>&lt;HashRouter&gt;</code>
</h3>
<details> <summary>Type declaration</summary><div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">declare function HashRouter(
  props: HashRouterProps
): React.ReactElement;

interface HashRouterProps {
  basename?: string;
  children?: React.ReactNode;
  window?: Window;
}
</pre></div></details><p><code>&lt;HashRouter&gt;</code> is for use in web browsers when the URL should not (or cannot) be sent to the server for some reason. This may happen in some shared hosting scenarios where you do not have full control over the server. In these situations, <code>&lt;HashRouter&gt;</code> makes it possible to store the current location in the <code>hash</code> portion of the current URL, so it is never sent to the server.</p>
<p><code>&lt;HashRouter window&gt;</code> defaults to using the current <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/defaultView">document's <code>defaultView</code></a>, but it may also be used to track changes to another window's URL, in an <code>&lt;iframe&gt;</code>, for example.</p>
<div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">import * as React from "react";
import * as ReactDOM from "react-dom";
import { HashRouter } from "react-router-dom";

ReactDOM.render(
  &lt;HashRouter&gt;
    {/* The rest of your app goes here */}
  &lt;/HashRouter&gt;,
  root
);
</pre></div>
<p><docs-warning>We strongly recommend you do not use <code>HashRouter</code> unless you absolutely have to.</docs-warning></p>
<h3 id="nativerouter">
<code>&lt;NativeRouter&gt;</code>
</h3>
<details> <summary>Type declaration</summary><div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">declare function NativeRouter(
  props: NativeRouterProps
): React.ReactElement;

interface NativeRouterProps extends MemoryRouterProps {}
</pre></div></details><p><code>&lt;NativeRouter&gt;</code> is the recommended interface for running React Router in a <a href="https://reactnative.dev">React Native</a> app.</p>
<ul> <li>
<code>&lt;NativeRouter initialEntries&gt;</code> defaults to <code>["/"]</code> (a single entry at the root <code>/</code> URL)</li> <li>
<code>&lt;NativeRouter initialIndex&gt;</code> defaults to the last index of <code>initialEntries</code>
</li> </ul>
<div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">import * as React from "react";
import { NativeRouter } from "react-router-native";

function App() {
  return (
    &lt;NativeRouter&gt;
      {/* The rest of your app goes here */}
    &lt;/NativeRouter&gt;
  );
}
</pre></div>
<h3 id="memoryrouter">
<code>&lt;MemoryRouter&gt;</code>
</h3>
<details> <summary>Type declaration</summary><div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">declare function MemoryRouter(
  props: MemoryRouterProps
): React.ReactElement;

interface MemoryRouterProps {
  basename?: string;
  children?: React.ReactNode;
  initialEntries?: InitialEntry[];
  initialIndex?: number;
}
</pre></div></details><p>A <code>&lt;MemoryRouter&gt;</code> stores its locations internally in an array. Unlike <code>&lt;BrowserHistory&gt;</code> and <code>&lt;HashHistory&gt;</code>, it isn't tied to an external source, like the history stack in a browser. This makes it ideal for scenarios where you need complete control over the history stack, like testing.</p>
<ul> <li>
<code>&lt;MemoryRouter initialEntries&gt;</code> defaults to <code>["/"]</code> (a single entry at the root <code>/</code> URL)</li> <li>
<code>&lt;MemoryRouter initialIndex&gt;</code> defaults to the last index of <code>initialEntries</code>
</li> </ul>
<blockquote> <p><strong>Tip:</strong></p> <p>Most of React Router's tests are written using a <code>&lt;MemoryRouter&gt;</code> as the source of truth, so you can see some great examples of using it by just <a href="https://github.com/remix-run/react-router/tree/main/packages/react-router/__tests__">browsing through our tests</a>.</p> </blockquote>
<div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">import * as React from "react";
import { create } from "react-test-renderer";
import {
  MemoryRouter,
  Routes,
  Route
} from "react-router-dom";

describe("My app", () =&gt; {
  it("renders correctly", () =&gt; {
    let renderer = create(
      &lt;MemoryRouter initialEntries={["/users/mjackson"]}&gt;
        &lt;Routes&gt;
          &lt;Route path="users" element={&lt;Users /&gt;}&gt;
            &lt;Route path=":id" element={&lt;UserProfile /&gt;} /&gt;
          &lt;/Route&gt;
        &lt;/Routes&gt;
      &lt;/MemoryRouter&gt;
    );

    expect(renderer.toJSON()).toMatchSnapshot();
  });
});
</pre></div>
<h3 id="link">
<code>&lt;Link&gt;</code>
</h3>
<blockquote> <p><strong>Note:</strong></p> <p>This is the web version of <code>&lt;Link&gt;</code>. For the React Native version, <a href="#link-react-native">go here</a>.</p> </blockquote>
<details> <summary>Type declaration</summary><div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">declare function Link(props: LinkProps): React.ReactElement;

interface LinkProps
  extends Omit&lt;
    React.AnchorHTMLAttributes&lt;HTMLAnchorElement&gt;,
    "href"
  &gt; {
  replace?: boolean;
  state?: any;
  to: To;
  reloadDocument?: boolean;
}

type To = Partial&lt;Location&gt; | string;
</pre></div></details><p>A <code>&lt;Link&gt;</code> is an element that lets the user navigate to another page by clicking or tapping on it. In <code>react-router-dom</code>, a <code>&lt;Link&gt;</code> renders an accessible <code>&lt;a&gt;</code> element with a real <code>href</code> that points to the resource it's linking to. This means that things like right-clicking a <code>&lt;Link&gt;</code> work as you'd expect. You can use <code>&lt;Link reloadDocument&gt;</code> to skip client side routing and let the browser handle the transition normally (as if it were an <code>&lt;a href&gt;</code>).</p>
<div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">import * as React from "react";
import { Link } from "react-router-dom";

function UsersIndexPage({ users }) {
  return (
    &lt;div&gt;
      &lt;h1&gt;Users&lt;/h1&gt;
      &lt;ul&gt;
        {users.map(user =&gt; (
          &lt;li key={user.id}&gt;
            &lt;Link to={user.id}&gt;{user.name}&lt;/Link&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}
</pre></div>
<p>A relative <code>&lt;Link to&gt;</code> value (that does not begin with <code>/</code>) resolves relative to the parent route, which means that it builds upon the URL path that was matched by the route that rendered that <code>&lt;Link&gt;</code>. It may contain <code>..</code> to link to routes further up the hierarchy. In these cases, <code>..</code> works exactly like the command-line <code>cd</code> function; each <code>..</code> removes one segment of the parent path.</p>
<blockquote> <p><strong>Note:</strong></p> <p><code>&lt;Link to&gt;</code> with a <code>..</code> behaves differently from a normal <code>&lt;a href&gt;</code> when the current URL ends with <code>/</code>. <code>&lt;Link to&gt;</code> ignores the trailing slash, and removes one URL segment for each <code>..</code>. But an <code>&lt;a href&gt;</code> value handles <code>..</code> differently when the current URL ends with <code>/</code> vs when it does not.</p> </blockquote>
<h3 id="link-react-native">
<code>&lt;Link&gt;</code> (React Native)</h3>
<blockquote> <p><strong>Note:</strong></p> <p>This is the React Native version of <code>&lt;Link&gt;</code>. For the web version, <a href="#link">go here</a>.</p> </blockquote>
<details> <summary>Type declaration</summary><div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">declare function Link(props: LinkProps): React.ReactElement;

interface LinkProps extends TouchableHighlightProps {
  children?: React.ReactNode;
  onPress?(event: GestureResponderEvent): void;
  replace?: boolean;
  state?: State;
  to: To;
}
</pre></div></details><p>A <code>&lt;Link&gt;</code> is an element that lets the user navigate to another view by tapping it, similar to how <code>&lt;a&gt;</code> elements work in a web app. In <code>react-router-native</code>, a <code>&lt;Link&gt;</code> renders a <code>TouchableHighlight</code>. To override default styling and behaviour, please refer to the <a href="https://reactnative.dev/docs/touchablehighlight#props">Props reference for <code>TouchableHighlight</code></a>.</p>
<div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">import * as React from "react";
import { View, Text } from "react-native";
import { Link } from "react-router-native";

function Home() {
  return (
    &lt;View&gt;
      &lt;Text&gt;Welcome!&lt;/Text&gt;
      &lt;Link to="/profile"&gt;Visit your profile&lt;/Link&gt;
    &lt;/View&gt;
  );
}
</pre></div>
<h3 id="navlink">
<code>&lt;NavLink&gt;</code>
</h3>
<details> <summary>Type declaration</summary><div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">declare function NavLink(
  props: NavLinkProps
): React.ReactElement;

interface NavLinkProps
  extends Omit&lt;
    LinkProps,
    "className" | "style" | "children"
  &gt; {
  caseSensitive?: boolean;
  children?:
    | React.ReactNode
    | ((props: { isActive: boolean }) =&gt; React.ReactNode);
  className?:
    | string
    | ((props: {
        isActive: boolean;
      }) =&gt; string | undefined);
  end?: boolean;
  style?:
    | React.CSSProperties
    | ((props: {
        isActive: boolean;
      }) =&gt; React.CSSProperties);
}
</pre></div></details><p>A <code>&lt;NavLink&gt;</code> is a special kind of <a href="#link"><code>&lt;Link&gt;</code></a> that knows whether or not it is "active". This is useful when building a navigation menu such as a breadcrumb or a set of tabs where you'd like to show which of them is currently selected. It also provides useful context for assistive technology like screen readers.</p>
<p>By default, an <code>active</code> class is added to a <code>&lt;NavLink&gt;</code> component when it is active. This provides the same simple styling mechanism for most users who are upgrading from v5. One difference as of <code>v6.0.0-beta.3</code> is that <code>activeClassName</code> and <code>activeStyle</code> have been removed from <code>NavLinkProps</code>. Instead, you can pass a function to either <code>style</code> or <code>className</code> that will allow you to customize the inline styling or the class string based on the component's active state. you can also pass a function as children to customize the content of the <code>&lt;NavLink&gt;</code> component based on their active state, specially useful to change styles on internal elements.</p>
<div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">import * as React from "react";
import { NavLink } from "react-router-dom";

function NavList() {
  // This styling will be applied to a &lt;NavLink&gt; when the
  // route that it links to is currently selected.
  let activeStyle = {
    textDecoration: "underline"
  };

  let activeClassName = "underline"

  return (
    &lt;nav&gt;
      &lt;ul&gt;
        &lt;li&gt;
          &lt;NavLink
            to="messages"
            style={({ isActive }) =&gt;
              isActive ? activeStyle : undefined
            }
          &gt;
            Messages
          &lt;/NavLink&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;NavLink
            to="tasks"
            className={({ isActive }) =&gt;
              isActive ? activeClassName : undefined
            }
          &gt;
            Tasks
          &lt;/NavLink&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;NavLink
            to="tasks"
          &gt;
            {({ isActive }) =&gt; (
              &lt;span className={isActive ? activeClassName : undefined}&gt;
                Tasks
              &lt;/span&gt;
            ))}
          &lt;/NavLink&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/nav&gt;
  );
}
</pre></div>
<p>If you prefer the v5 API, you can create your own <code>&lt;NavLink /&gt;</code> as a wrapper component:</p>
<div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">import * as React from "react";
import { NavLink as BaseNavLink } from "react-router-dom";

const NavLink = React.forwardRef(
  ({ activeClassName, activeStyle, ...props }, ref) =&gt; {
    return (
      &lt;BaseNavLink
        ref={ref}
        {...props}
        className={({ isActive }) =&gt;
          [
            props.className,
            isActive ? activeClassName : null
          ]
            .filter(Boolean)
            .join(" ")
        }
        style={({ isActive }) =&gt; ({
          ...props.style,
          ...(isActive ? activeStyle : null)
        })}
      /&gt;
    );
  }
);
</pre></div>
<p>If the <code>end</code> prop is used, it will ensure this component isn't matched as "active" when its descendant paths are matched. For example, to render a link that is only active at the website root and not any other URLs, you can use:</p>
<div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">&lt;NavLink to="/" end&gt;
  Home
&lt;/NavLink&gt;
</pre></div>
<h3 id="navigate">
<code>&lt;Navigate&gt;</code>
</h3>
<details> <summary>Type declaration</summary><div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">declare function Navigate(props: NavigateProps): null;

interface NavigateProps {
  to: To;
  replace?: boolean;
  state?: State;
}
</pre></div></details><p>A <code>&lt;Navigate&gt;</code> element changes the current location when it is rendered. It's a component wrapper around <a href="#usenavigate"><code>useNavigate</code></a>, and accepts all the same arguments as props.</p>
<blockquote> <p><strong>Note:</strong></p> <p>Having a component-based version of the <code>useNavigate</code> hook makes it easier to use this feature in a <a href="https://reactjs.org/docs/react-component.html"><code>React.Component</code></a> subclass where hooks are not able to be used.</p> </blockquote>
<div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">import * as React from "react";
import { Navigate } from "react-router-dom";

class LoginForm extends React.Component {
  state = { user: null, error: null };

  async handleSubmit(event) {
    event.preventDefault();
    try {
      let user = await login(event.target);
      this.setState({ user });
    } catch (error) {
      this.setState({ error });
    }
  }

  render() {
    let { user, error } = this.state;
    return (
      &lt;div&gt;
        {error &amp;&amp; &lt;p&gt;{error.message}&lt;/p&gt;}
        {user &amp;&amp; (
          &lt;Navigate to="/dashboard" replace={true} /&gt;
        )}
        &lt;form onSubmit={event =&gt; this.handleSubmit(event)}&gt;
          &lt;input type="text" name="username" /&gt;
          &lt;input type="password" name="password" /&gt;
        &lt;/form&gt;
      &lt;/div&gt;
    );
  }
}
</pre></div>
<h3 id="outlet">
<code>&lt;Outlet&gt;</code>
</h3>
<details> <summary>Type declaration</summary><div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">interface OutletProps {
  context?: unknown;
}
declare function Outlet(
  props: OutletProps
): React.ReactElement | null;
</pre></div></details><p>An <code>&lt;Outlet&gt;</code> should be used in parent route elements to render their child route elements. This allows nested UI to show up when child routes are rendered. If the parent route matched exactly, it will render a child index route or nothing if there is no index route.</p>
<div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">function Dashboard() {
  return (
    &lt;div&gt;
      &lt;h1&gt;Dashboard&lt;/h1&gt;

      {/* This element will render either &lt;DashboardMessages&gt; when the URL is
          "/messages", &lt;DashboardTasks&gt; at "/tasks", or null if it is "/"
      */}
      &lt;Outlet /&gt;
    &lt;/div&gt;
  );
}

function App() {
  return (
    &lt;Routes&gt;
      &lt;Route path="/" element={&lt;Dashboard /&gt;}&gt;
        &lt;Route
          path="messages"
          element={&lt;DashboardMessages /&gt;}
        /&gt;
        &lt;Route path="tasks" element={&lt;DashboardTasks /&gt;} /&gt;
      &lt;/Route&gt;
    &lt;/Routes&gt;
  );
}
</pre></div>
<h3 id="useoutletcontext">
<code>useOutletContext</code>
</h3>
<details> <summary>Type declaration</summary><div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">declare function useOutletContext&lt;
  Context = unknown
&gt;(): Context;
</pre></div></details><p>Often parent routes manage state or other values you want shared with child routes. You can create your own <a href="https://reactjs.org/docs/context.html">context provider</a> if you like, but this is such a common situation that it's built-into <code>&lt;Outlet /&gt;</code>:</p>
<div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">function Parent() {
  const [count, setCount] = React.useState(0);
  return &lt;Outlet context={[count, setCount]} /&gt;;
}
</pre></div>
<div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">function Child() {
  const [count, setCount] = useOutletContext();
  const increment = () =&gt; setCount(c =&gt; c + 1);
  return &lt;button onClick={increment}&gt;{count}&lt;/button&gt;;
}
</pre></div>
<p>If you're using TypeScript, we recommend the parent component provide a custom hook for accessing the context value. This makes it easier for consumers to get nice typings, control consumers, and know who's consuming the context value. Here's a more realistic example:</p>
<div><pre data-filename="src/routes/dashboard.tsx" data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">import * as React from "react";
import type { User } from "./types";

type ContextType = { user: User | null };

export default function Dashboard() {
  const [user, setUser] = React.useState&lt;User | null&gt;(null);

  return (
    &lt;div&gt;
      &lt;h1&gt;Dashboard&lt;/h1&gt;
      &lt;Outlet context={user} /&gt;
    &lt;/div&gt;
  );
}

export function useUser() {
  return useOutletContext&lt;ContextType&gt;();
}
</pre></div>
<div><pre data-filename="src/routes/dashboard/messages.tsx" data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">import { useUser } from "../dashboard";

export default function DashboardMessages() {
  const user = useUser();
  return (
    &lt;div&gt;
      &lt;h2&gt;Messages&lt;/h2&gt;
      &lt;p&gt;Hello, {user.name}!&lt;/p&gt;
    &lt;/div&gt;
  );
}
</pre></div>
<h3 id="router">
<code>&lt;Router&gt;</code>
</h3>
<details> <summary>Type declaration</summary><div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">declare function Router(
  props: RouterProps
): React.ReactElement | null;

interface RouterProps {
  basename?: string;
  children?: React.ReactNode;
  location: Partial&lt;Location&gt; | string;
  navigationType?: NavigationType;
  navigator: Navigator;
  static?: boolean;
}
</pre></div></details><p><code>&lt;Router&gt;</code> is the low-level interface that is shared by all router components (<a href="#browserrouter"><code>&lt;BrowserRouter&gt;</code></a>, <a href="#hashrouter"><code>&lt;HashRouter&gt;</code></a>, <a href="#staticrouter"><code>&lt;StaticRouter&gt;</code></a>, <a href="#nativerouter"><code>&lt;NativeRouter&gt;</code></a>, and <a href="#memoryrouter"><code>&lt;MemoryRouter&gt;</code></a>). In terms of React, <code>&lt;Router&gt;</code> is a <a href="https://reactjs.org/docs/context.html#contextprovider">context provider</a> that supplies routing information to the rest of the app.</p>
<p>You probably never need to render a <code>&lt;Router&gt;</code> manually. Instead, you should use one of the higher-level routers depending on your environment. You only ever need one router in a given app.</p>
<p>The <code>&lt;Router basename&gt;</code> prop may be used to make all routes and links in your app relative to a "base" portion of the URL pathname that they all share. This is useful when rendering only a portion of a larger app with React Router or when your app has multiple entry points. Basenames are not case-sensitive.</p>

<h3 id="routes-and-route">
<code>&lt;Routes&gt;</code> and <code>&lt;Route&gt;</code>
</h3>
<details> <summary>Type declaration</summary><div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">declare function Routes(
  props: RoutesProps
): React.ReactElement | null;

interface RoutesProps {
  children?: React.ReactNode;
  location?: Partial&lt;Location&gt; | string;
}

declare function Route(
  props: RouteProps
): React.ReactElement | null;

interface RouteProps {
  caseSensitive?: boolean;
  children?: React.ReactNode;
  element?: React.ReactElement | null;
  index?: boolean;
  path?: string;
}
</pre></div></details><p><code>&lt;Routes&gt;</code> and <code>&lt;Route&gt;</code> are the primary ways to render something in React Router based on the current <a href="#location"><code>location</code></a>. You can think about a <code>&lt;Route&gt;</code> kind of like an <code>if</code> statement; if its <code>path</code> matches the current URL, it renders its <code>element</code>! The <code>&lt;Route caseSensitive&gt;</code> prop determines if the matching should be done in a case-sensitive manner (defaults to <code>false</code>).</p>
<p>Whenever the location changes, <code>&lt;Routes&gt;</code> looks through all its <code>children</code> <code>&lt;Route&gt;</code> elements to find the best match and renders that branch of the UI. <code>&lt;Route&gt;</code> elements may be nested to indicate nested UI, which also correspond to nested URL paths. Parent routes render their child routes by rendering an <a href="#outlet"><code>&lt;Outlet&gt;</code></a>.</p>
<div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">&lt;Routes&gt;
  &lt;Route path="/" element={&lt;Dashboard /&gt;}&gt;
    &lt;Route
      path="messages"
      element={&lt;DashboardMessages /&gt;}
    /&gt;
    &lt;Route path="tasks" element={&lt;DashboardTasks /&gt;} /&gt;
  &lt;/Route&gt;
  &lt;Route path="about" element={&lt;AboutPage /&gt;} /&gt;
&lt;/Routes&gt;
</pre></div>
<blockquote> <p><strong>Note:</strong></p> <p>If you'd prefer to define your routes as regular JavaScript objects instead of using JSX, <a href="#useroutes">try <code>useRoutes</code> instead</a>.</p> </blockquote>
<p>The default <code>&lt;Route element&gt;</code> is an <a href="#outlet"><code>&lt;Outlet&gt;</code></a>. This means the route will still render its children even without an explicit <code>element</code> prop, so you can nest route paths without nesting UI around the child route elements.</p>
<p>For example, in the following config the parent route renders an <code>&lt;Outlet&gt;</code> by default, so the child route will render without any surrounding UI. But the child route's path is <code>/users/:id</code> because it still builds on its parent.</p>
<div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">&lt;Route path="users"&gt;
  &lt;Route path=":id" element={&lt;UserProfile /&gt;} /&gt;
&lt;/Route&gt;
</pre></div>
<h3 id="staticrouter">
<code>&lt;StaticRouter&gt;</code>
</h3>
<details> <summary>Type declaration</summary><div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">declare function StaticRouter(
  props: StaticRouterProps
): React.ReactElement;

interface StaticRouterProps {
  basename?: string;
  children?: React.ReactNode;
  location?: Path | LocationPieces;
}
</pre></div></details><p><code>&lt;StaticRouter&gt;</code> is used to render a React Router web app in <a href="https://nodejs.org">node</a>. Provide the current location via the <code>location</code> prop.</p>
<ul> <li>
<code>&lt;StaticRouter location&gt;</code> defaults to <code>"/"</code>
</li> </ul>
<div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">import * as React from "react";
import * as ReactDOMServer from "react-dom/server";
import { StaticRouter } from "react-router-dom/server";
import http from "http";

function requestHandler(req, res) {
  let html = ReactDOMServer.renderToString(
    &lt;StaticRouter location={req.url}&gt;
      {/* The rest of your app goes here */}
    &lt;/StaticRouter&gt;
  );

  res.write(html);
  res.end();
}

http.createServer(requestHandler).listen(3000);
</pre></div>
<h3 id="createroutesfromchildren">
<code>createRoutesFromChildren</code>
</h3>
<details> <summary>Type declaration</summary><div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">declare function createRoutesFromChildren(
  children: React.ReactNode
): RouteObject[];

interface RouteObject {
  caseSensitive?: boolean;
  children?: RouteObject[];
  element?: React.ReactNode;
  index?: boolean;
  path?: string;
}
</pre></div></details><p><code>createRoutesFromChildren</code> is a helper that creates route objects from <code>&lt;Route&gt;</code> elements. It is used internally in a <a href="#routes-and-route"><code>&lt;Routes&gt;</code> element</a> to generate a route config from its <a href="#routes-and-route"><code>&lt;Route&gt;</code></a> children.</p>
<h3 id="generatepath">
<code>generatePath</code>
</h3>
<details> <summary>Type declaration</summary><div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">declare function generatePath(
  path: string,
  params?: Params
): string;
</pre></div></details><p><code>generatePath</code> interpolates a set of params into a route path string with <code>:id</code> and <code>*</code> placeholders. This can be useful when you want to eliminate placeholders from a route path so it matches statically instead of using a dynamic parameter.</p>
<div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">generatePath("/users/:id", { id: 42 }); // "/users/42"
generatePath("/files/:type/*", {
  type: "img",
  "*": "cat.jpg"
}); // "/files/img/cat.jpg"
</pre></div>
<h3 id="location">
<code>Location</code>
</h3>
<p>The term "location" in React Router refers to <a href="https://github.com/remix-run/history/blob/main/docs/api-reference.md#location">the <code>Location</code> interface</a> from the <a href="https://github.com/remix-run/history">history</a> library.</p>
<blockquote> <p><strong>Note:</strong></p> <p>The <code>history</code> package is React Router's only dependency and many of the core types in React Router come directly from that library including <code>Location</code>, <code>To</code>, <code>Path</code>, <code>State</code>, and others. You can read more about the history library in <a href="https://github.com/remix-run/history/tree/main/docs">its documentation</a>.</p> </blockquote>
<h3 id="matchroutes">
<code>matchRoutes</code>
</h3>
<details> <summary>Type declaration</summary><div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">declare function matchRoutes(
  routes: RouteObject[],
  location: Partial&lt;Location&gt; | string,
  basename?: string
): RouteMatch[] | null;

interface RouteMatch&lt;ParamKey extends string = string&gt; {
  params: Params&lt;ParamKey&gt;;
  pathname: string;
  route: RouteObject;
}
</pre></div></details><p><code>matchRoutes</code> runs the route matching algorithm for a set of routes against a given <a href="#location"><code>location</code></a> to see which routes (if any) match. If it finds a match, an array of <code>RouteMatch</code> objects is returned, one for each route that matched.</p>
<p>This is the heart of React Router's matching algorithm. It is used internally by <a href="#useroutes"><code>useRoutes</code></a> and the <a href="#routes-and-route"><code>&lt;Routes&gt;</code> component</a> to determine which routes match the current location. It can also be useful in some situations where you want to manually match a set of routes.</p>
<h3 id="rendermatches">
<code>renderMatches</code>
</h3>
<details> <summary>Type declaration</summary><div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">declare function renderMatches(
  matches: RouteMatch[] | null
): React.ReactElement | null;
</pre></div></details><p><code>renderMatches</code> renders the result of <code>matchRoutes()</code> into a React element.</p>
<h3 id="matchpath">
<code>matchPath</code>
</h3>
<details> <summary>Type declaration</summary><div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">declare function matchPath&lt;
  ParamKey extends string = string
&gt;(
  pattern: PathPattern | string,
  pathname: string
): PathMatch&lt;ParamKey&gt; | null;

interface PathMatch&lt;ParamKey extends string = string&gt; {
  params: Params&lt;ParamKey&gt;;
  pathname: string;
  pattern: PathPattern;
}

interface PathPattern {
  path: string;
  caseSensitive?: boolean;
  end?: boolean;
}
</pre></div></details><p><code>matchPath</code> matches a route path pattern against a URL pathname and returns information about the match. This is useful whenever you need to manually run the router's matching algorithm to determine if a route path matches or not. It returns <code>null</code> if the pattern does not match the given pathname.</p>
<p>The <a href="#usematch"><code>useMatch</code> hook</a> uses this function internally to match a route path relative to the current location.</p>
<h3 id="resolvepath">
<code>resolvePath</code>
</h3>
<details> <summary>Type declaration</summary><div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">declare function resolvePath(
  to: To,
  fromPathname?: string
): Path;

type To = Partial&lt;Location&gt; | string;

interface Path {
  pathname: string;
  search: string;
  hash: string;
}
</pre></div></details><p><code>resolvePath</code> resolves a given <code>To</code> value into an actual <code>Path</code> object with an absolute <code>pathname</code>. This is useful whenever you need to know the exact path for a relative <code>To</code> value. For example, the <code>&lt;Link&gt;</code> component uses this function to know the actual URL it points to.</p>
<p>The <a href="#useresolvedpath"><code>useResolvedPath</code> hook</a> uses <code>resolvePath</code> internally to resolve the pathname. If <code>to</code> contains a pathname, it is resolved against the current route pathname. Otherwise, it is resolved against the current URL (<code>location.pathname</code>).</p>
<h3 id="usehref">
<code>useHref</code>
</h3>
<details> <summary>Type declaration</summary><div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">declare function useHref(to: To): string;
</pre></div></details><p>The <code>useHref</code> hook returns a URL that may be used to link to the given <code>to</code> location, even outside of React Router.</p>
<blockquote> <p><strong>Tip:</strong></p> <p>You may be interested in taking a look at the source for the <code>&lt;Link&gt;</code> component in <code>react-router-dom</code> to see how it uses <code>useHref</code> internally to determine its own <code>href</code> value.</p> </blockquote>
<h3 id="uselinkclickhandler">
<code>useLinkClickHandler</code>
</h3>
<details> <summary>Type declaration</summary><div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">declare function useLinkClickHandler&lt;
  E extends Element = HTMLAnchorElement,
  S extends State = State
&gt;(
  to: To,
  options?: {
    target?: React.HTMLAttributeAnchorTarget;
    replace?: boolean;
    state?: S;
  }
): (event: React.MouseEvent&lt;E, MouseEvent&gt;) =&gt; void;
</pre></div></details><p>The <code>useLinkClickHandler</code> hook returns a click event handler to for navigation when building a custom <code>&lt;Link&gt;</code> in <code>react-router-dom</code>.</p>
<div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">import {
  useHref,
  useLinkClickHandler
} from "react-router-dom";

const StyledLink = styled("a", { color: "fuchsia" });

const Link = React.forwardRef(
  (
    {
      onClick,
      replace = false,
      state,
      target,
      to,
      ...rest
    },
    ref
  ) =&gt; {
    let href = useHref(to);
    let handleClick = useLinkClickHandler(to, {
      replace,
      state,
      target
    });

    return (
      &lt;StyledLink
        {...rest}
        href={href}
        onClick={event =&gt; {
          onClick?.(event);
          if (!event.defaultPrevented) {
            handleClick(event);
          }
        }}
        ref={ref}
        target={target}
      /&gt;
    );
  }
);
</pre></div>
<h3 id="uselinkpresshandler">
<code>useLinkPressHandler</code>
</h3>
<details> <summary>Type declaration</summary><div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">declare function useLinkPressHandler&lt;
  S extends State = State
&gt;(
  to: To,
  options?: {
    replace?: boolean;
    state?: S;
  }
): (event: GestureResponderEvent) =&gt; void;
</pre></div></details><p>The <code>react-router-native</code> counterpart to <code>useLinkClickHandler</code>, <code>useLinkPressHandler</code> returns a press event handler for custom <code>&lt;Link&gt;</code> navigation.</p>
<div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">import { TouchableHighlight } from "react-native";
import { useLinkPressHandler } from "react-router-native";

function Link({
  onPress,
  replace = false,
  state,
  to,
  ...rest
}) {
  let handlePress = useLinkPressHandler(to, {
    replace,
    state
  });

  return (
    &lt;TouchableHighlight
      {...rest}
      onPress={event =&gt; {
        onPress?.(event);
        if (!event.defaultPrevented) {
          handlePress(event);
        }
      }}
    /&gt;
  );
}
</pre></div>
<h3 id="useinroutercontext">
<code>useInRouterContext</code>
</h3>
<details> <summary>Type declaration</summary><div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">declare function useInRouterContext(): boolean;
</pre></div></details><p>The <code>useInRouterContext</code> hooks returns <code>true</code> if the component is being rendered in the context of a <code>&lt;Router&gt;</code>, <code>false</code> otherwise. This can be useful for some 3rd-party extensions that need to know if they are being rendered in the context of a React Router app.</p>
<h3 id="uselocation">
<code>useLocation</code>
</h3>
<details> <summary>Type declaration</summary><div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">declare function useLocation(): Location;

interface Location&lt;S extends State = object | null&gt;
  extends Path {
  state: S;
  key: Key;
}
</pre></div></details><p>This hook returns the current <a href="#location"><code>location</code></a> object. This can be useful if you'd like to perform some side effect whenever the current location changes.</p>
<div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">import * as React from 'react';
import { useLocation } from 'react-router-dom';

function App() {
  let location = useLocation();

  React.useEffect(() =&gt; {
    ga('send', 'pageview');
  }, [location]);

  return (
    // ...
  );
}
</pre></div>
<h3 id="usenavigationtype">
<code>useNavigationType</code>
</h3>
<details> <summary>Type declaration</summary><div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">declare function useNavigationType(): NavigationType;

type NavigationType = "POP" | "PUSH" | "REPLACE";
</pre></div></details><p>This hook returns the current type of navigation or how the user came to the current page; either via a pop, push, or replace action on the history stack.</p>
<h3 id="usematch">
<code>useMatch</code>
</h3>
<details> <summary>Type declaration</summary><div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">declare function useMatch&lt;ParamKey extends string = string&gt;(
  pattern: PathPattern | string
): PathMatch&lt;ParamKey&gt; | null;
</pre></div></details><p>Returns match data about a route at the given path relative to the current location.</p>
<p>See <a href="#matchpath"><code>matchPath</code></a> for more information.</p>
<h3 id="usenavigate">
<code>useNavigate</code>
</h3>
<details> <summary>Type declaration</summary><div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">declare function useNavigate(): NavigateFunction;

interface NavigateFunction {
  (
    to: To,
    options?: { replace?: boolean; state?: any }
  ): void;
  (delta: number): void;
}
</pre></div></details><p>The <code>useNavigate</code> hook returns a function that lets you navigate programmatically, for example after a form is submitted.</p>
<div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">import { useNavigate } from "react-router-dom";

function SignupForm() {
  let navigate = useNavigate();

  async function handleSubmit(event) {
    event.preventDefault();
    await submitForm(event.target);
    navigate("../success", { replace: true });
  }

  return &lt;form onSubmit={handleSubmit}&gt;{/* ... */}&lt;/form&gt;;
}
</pre></div>
<p>The <code>navigate</code> function has two signatures:</p>
<ul> <li>Either pass a <code>To</code> value (same type as <code>&lt;Link to&gt;</code>) with an optional second <code>{ replace, state }</code> arg or</li> <li>Pass the delta you want to go in the history stack. For example, <code>navigate(-1)</code> is equivalent to hitting the back button.</li> </ul>
<h3 id="useoutlet">
<code>useOutlet</code>
</h3>
<details> <summary>Type declaration</summary><div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">declare function useOutlet(): React.ReactElement | null;
</pre></div></details><p>Returns the element for the child route at this level of the route hierarchy. This hook is used internally by <a href="#outlet"><code>&lt;Outlet&gt;</code></a> to render child routes.</p>
<h3 id="useparams">
<code>useParams</code>
</h3>
<details> <summary>Type declaration</summary><div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">declare function useParams&lt;
  K extends string = string
&gt;(): Readonly&lt;Params&lt;K&gt;&gt;;
</pre></div></details><p>The <code>useParams</code> hook returns an object of key/value pairs of the dynamic params from the current URL that were matched by the <code>&lt;Route path&gt;</code>. Child routes inherit all params from their parent routes.</p>
<div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">import * as React from 'react';
import { Routes, Route, useParams } from 'react-router-dom';

function ProfilePage() {
  // Get the userId param from the URL.
  let { userId } = useParams();
  // ...
}

function App() {
  return (
    &lt;Routes&gt;
      &lt;Route path="users"&gt;
        &lt;Route path=":userId" element={&lt;ProfilePage /&gt;} /&gt;
        &lt;Route path="me" element={...} /&gt;
      &lt;/Route&gt;
    &lt;/Routes&gt;
  );
}
</pre></div>
<h3 id="useresolvedpath">
<code>useResolvedPath</code>
</h3>
<details> <summary>Type declaration</summary><div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">declare function useResolvedPath(to: To): Path;
</pre></div></details><p>This hook resolves the <code>pathname</code> of the location in the given <code>to</code> value against the pathname of the current location.</p>
<p>This is useful when building links from relative values. For example, check out the source to <a href="#navlink"><code>&lt;NavLink&gt;</code></a> which calls <code>useResolvedPath</code> internally to resolve the full pathname of the page being linked to.</p>
<p>See <a href="#resolvepath"><code>resolvePath</code></a> for more information.</p>
<h3 id="useroutes">
<code>useRoutes</code>
</h3>
<details> <summary>Type declaration</summary><div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">declare function useRoutes(
  routes: RouteObject[],
  location?: Partial&lt;Location&gt; | string;
): React.ReactElement | null;
</pre></div></details><p>The <code>useRoutes</code> hook is the functional equivalent of <a href="#routes"><code>&lt;Routes&gt;</code></a>, but it uses JavaScript objects instead of <code>&lt;Route&gt;</code> elements to define your routes. These objects have the same properties as normal <a href="#routes-and-route"><code>&lt;Route&gt;</code> elements</a>, but they don't require JSX.</p>
<p>The return value of <code>useRoutes</code> is either a valid React element you can use to render the route tree, or <code>null</code> if nothing matched.</p>
<div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">import * as React from "react";
import { useRoutes } from "react-router-dom";

function App() {
  let element = useRoutes([
    {
      path: "/",
      element: &lt;Dashboard /&gt;,
      children: [
        {
          path: "messages",
          element: &lt;DashboardMessages /&gt;
        },
        { path: "tasks", element: &lt;DashboardTasks /&gt; }
      ]
    },
    { path: "team", element: &lt;AboutPage /&gt; }
  ]);

  return element;
}
</pre></div>
<h3 id="usesearchparams">
<code>useSearchParams</code>
</h3>
<blockquote> <p><strong>Note:</strong></p> <p>This is the web version of <code>useSearchParams</code>. For the React Native version, <a href="#usesearchparams-react-native">go here</a>.</p> </blockquote>
<details> <summary>Type declaration</summary><div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">declare function useSearchParams(
  defaultInit?: URLSearchParamsInit
): [URLSearchParams, URLSearchParamsSetter];

type ParamKeyValuePair = [string, string];

type URLSearchParamsInit =
  | string
  | ParamKeyValuePair[]
  | Record&lt;string, string | string[]&gt;
  | URLSearchParams;

interface URLSearchParamsSetter {
  (
    nextInit: URLSearchParamsInit,
    navigateOptions?: { replace?: boolean; state?: State }
  ): void;
}
</pre></div></details><p>The <code>useSearchParams</code> hook is used to read and modify the query string in the URL for the current location. Like React's own <a href="https://reactjs.org/docs/hooks-reference.html#usestate"><code>useState</code> hook</a>, <code>useSearchParams</code> returns an array of two values: the current location's <a href="https://developer.mozilla.org/en-US/docs/Web/API/URL/searchParams">search params</a> and a function that may be used to update them.</p>
<div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">import * as React from "react";
import { useSearchParams } from "react-router-dom";

function App() {
  let [searchParams, setSearchParams] = useSearchParams();

  function handleSubmit(event) {
    event.preventDefault();
    // The serialize function here would be responsible for
    // creating an object of { key: value } pairs from the
    // fields in the form that make up the query.
    let params = serializeFormQuery(event.target);
    setSearchParams(params);
  }

  return (
    &lt;div&gt;
      &lt;form onSubmit={handleSubmit}&gt;{/* ... */}&lt;/form&gt;
    &lt;/div&gt;
  );
}
</pre></div>
<blockquote> <p><strong>Note:</strong></p> <p>The <code>setSearchParams</code> function works like <a href="#usenavigate"><code>navigate</code></a>, but only for the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Location/search">search portion</a> of the URL. Also note that the second arg to <code>setSearchParams</code> is the same type as the second arg to <code>navigate</code>.</p> </blockquote>
<h3 id="usesearchparams-react-native">
<code>useSearchParams</code> (React Native)</h3>
<blockquote> <p><strong>Note:</strong></p> <p>This is the React Native version of <code>useSearchParams</code>. For the web version, <a href="#usesearchparams">go here</a>.</p> </blockquote>
<details> <summary>Type declaration</summary><div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">declare function useSearchParams(
  defaultInit?: URLSearchParamsInit
): [URLSearchParams, URLSearchParamsSetter];

type ParamKeyValuePair = [string, string];

type URLSearchParamsInit =
  | string
  | ParamKeyValuePair[]
  | Record&lt;string, string | string[]&gt;
  | URLSearchParams;

interface URLSearchParamsSetter {
  (
    nextInit: URLSearchParamsInit,
    navigateOptions?: { replace?: boolean; state?: State }
  ): void;
}
</pre></div></details><p>The <code>useSearchParams</code> hook is used to read and modify the query string in the URL for the current location. Like React's own <a href="https://reactjs.org/docs/hooks-reference.html#usestate"><code>useState</code> hook</a>, <code>useSearchParams</code> returns an array of two values: the current location's <a href="https://developer.mozilla.org/en-US/docs/Web/API/URL/searchParams">search params</a> and a function that may be used to update them.</p>
<div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">import * as React from "react";
import { View, SearchForm, TextInput } from "react-native";
import { useSearchParams } from "react-router-native";

function App() {
  let [searchParams, setSearchParams] = useSearchParams();
  let [query, setQuery] = React.useState(
    searchParams.get("query")
  );

  function handleSubmit() {
    setSearchParams({ query });
  }

  return (
    &lt;View&gt;
      &lt;SearchForm onSubmit={handleSubmit}&gt;
        &lt;TextInput value={query} onChangeText={setQuery} /&gt;
      &lt;/SearchForm&gt;
    &lt;/View&gt;
  );
}
</pre></div>
<h3 id="createsearchparams">
<code>createSearchParams</code>
</h3>
<details> <summary>Type declaration</summary><div><pre data-line-numbers="true" data-lang="tsx" style="color: var(--base05);background-color: var(--base00)" data-language="javascript">declare function createSearchParams(
  init?: URLSearchParamsInit
): URLSearchParams;
</pre></div></details><p><code>createSearchParams</code> is a thin wrapper around <a href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams/URLSearchParams"><code>new URLSearchParams(init)</code></a> that adds support for using objects with array values. This is the same function that <code>useSearchParams</code> uses internally for creating <code>URLSearchParams</code> objects from <code>URLSearchParamsInit</code> values.</p>
<div class="_attribution">
  <p class="_attribution-p">
     React Training 2015-2019<br> Remix Software 2020-2021<br>Licensed under the MIT License (MIT).<br>
    <a href="https://reactrouterdotcom.fly.dev/docs/en/v6/api" class="_attribution-link">https://reactrouterdotcom.fly.dev/docs/en/v6/api</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
