
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Graphics2D - OpenJDK 11 - W3cubDocs</title>
  
  <meta name="description" content="This Graphics2D class extends the Graphics class to provide more sophisticated control over geometry, coordinate transformations, color management, &hellip;">
  <meta name="keywords" content="class, graphics, d, openjdk, openjdk~11">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/openjdk~11/java.desktop/java/awt/graphics2d.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/openjdk~11.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/openjdk~11/" class="_nav-link" title="" style="margin-left:0;">OpenJDK 11</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _openjdk">
				
				
<main role="main">    <h1>Class Graphics2D</h1>   <ul class="inheritance"> <li><a href="../../../java.base/java/lang/object">java.lang.Object</a></li> <li> <ul class="inheritance"> <li><a href="graphics">java.awt.Graphics</a></li> <li> <ul class="inheritance"> <li>java.awt.Graphics2D</li> </ul> </li> </ul> </li> </ul>    <pre data-language="java">public abstract class Graphics2D
extends Graphics</pre> <div>
<p>This <code>Graphics2D</code> class extends the <a href="graphics"><code>Graphics</code></a> class to provide more sophisticated control over geometry, coordinate transformations, color management, and text layout. This is the fundamental class for rendering 2-dimensional shapes, text and images on the Java(tm) platform. </p>
<h2>Coordinate Spaces</h2> All coordinates passed to a <code>Graphics2D</code> object are specified in a device-independent coordinate system called User Space, which is used by applications. The <code>Graphics2D</code> object contains an <a href="geom/affinetransform"><code>AffineTransform</code></a> object as part of its rendering state that defines how to convert coordinates from user space to device-dependent coordinates in Device Space. 
<p> Coordinates in device space usually refer to individual device pixels and are aligned on the infinitely thin gaps between these pixels. Some <code>Graphics2D</code> objects can be used to capture rendering operations for storage into a graphics metafile for playback on a concrete device of unknown physical resolution at a later time. Since the resolution might not be known when the rendering operations are captured, the <code>Graphics2D Transform</code> is set up to transform user coordinates to a virtual device space that approximates the expected resolution of the target device. Further transformations might need to be applied at playback time if the estimate is incorrect. </p>
<p> Some of the operations performed by the rendering attribute objects occur in the device space, but all <code>Graphics2D</code> methods take user space coordinates. </p>
<p> Every <code>Graphics2D</code> object is associated with a target that defines where rendering takes place. A <a href="graphicsconfiguration"><code>GraphicsConfiguration</code></a> object defines the characteristics of the rendering target, such as pixel format and resolution. The same rendering target is used throughout the life of a <code>Graphics2D</code> object. </p>
<p> When creating a <code>Graphics2D</code> object, the <code>GraphicsConfiguration</code> specifies the <a id="deftransform">default transform</a> for the target of the <code>Graphics2D</code> (a <a href="component"><code>Component</code></a> or <a href="image"><code>Image</code></a>). This default transform maps the user space coordinate system to screen and printer device coordinates such that the origin maps to the upper left hand corner of the target region of the device with increasing X coordinates extending to the right and increasing Y coordinates extending downward. The scaling of the default transform is set to identity for those devices that are close to 72 dpi, such as screen devices. The scaling of the default transform is set to approximately 72 user space coordinates per square inch for high resolution devices, such as printers. For image buffers, the default transform is the <code>Identity</code> transform. </p>
<h2>Rendering Process</h2> The Rendering Process can be broken down into four phases that are controlled by the <code>Graphics2D</code> rendering attributes. The renderer can optimize many of these steps, either by caching the results for future calls, by collapsing multiple virtual steps into a single operation, or by recognizing various attributes as common simple cases that can be eliminated by modifying other parts of the operation. <p> The steps in the rendering process are: </p>
<ol> <li> Determine what to render. </li>
<li> Constrain the rendering operation to the current <code>Clip</code>. The <code>Clip</code> is specified by a <a href="shape"><code>Shape</code></a> in user space and is controlled by the program using the various clip manipulation methods of <code>Graphics</code> and <code>Graphics2D</code>. This <i>user clip</i> is transformed into device space by the current <code>Transform</code> and combined with the <i>device clip</i>, which is defined by the visibility of windows and device extents. The combination of the user clip and device clip defines the <i>composite clip</i>, which determines the final clipping region. The user clip is not modified by the rendering system to reflect the resulting composite clip. </li>
<li> Determine what colors to render. </li>
<li> Apply the colors to the destination drawing surface using the current <a href="composite"><code>Composite</code></a> attribute in the <code>Graphics2D</code> context. </li>
</ol> <br> The three types of rendering operations, along with details of each of their particular rendering processes are: <ol> <li> <b><a id="rendershape"><code>Shape</code> operations</a></b> <ol> <li> If the operation is a <code>draw(Shape)</code> operation, then the <a href="stroke#createStrokedShape(java.awt.Shape)"><code>createStrokedShape</code></a> method on the current <a href="stroke"><code>Stroke</code></a> attribute in the <code>Graphics2D</code> context is used to construct a new <code>Shape</code> object that contains the outline of the specified <code>Shape</code>. </li>
<li> The <code>Shape</code> is transformed from user space to device space using the current <code>Transform</code> in the <code>Graphics2D</code> context. </li>
<li> The outline of the <code>Shape</code> is extracted using the <a href="shape#getPathIterator(java.awt.geom.AffineTransform)"><code>getPathIterator</code></a> method of <code>Shape</code>, which returns a <a href="geom/pathiterator"><code>PathIterator</code></a> object that iterates along the boundary of the <code>Shape</code>. </li>
<li> If the <code>Graphics2D</code> object cannot handle the curved segments that the <code>PathIterator</code> object returns then it can call the alternate <a href="shape#getPathIterator(java.awt.geom.AffineTransform,double)"><code>getPathIterator</code></a> method of <code>Shape</code>, which flattens the <code>Shape</code>. </li>
<li> The current <a href="paint"><code>Paint</code></a> in the <code>Graphics2D</code> context is queried for a <a href="paintcontext"><code>PaintContext</code></a>, which specifies the colors to render in device space. </li>
</ol> </li>
<li> <b><a id="rendertext">Text operations</a></b> <ol> <li> The following steps are used to determine the set of glyphs required to render the indicated <code>String</code>: <ol> <li> If the argument is a <code>String</code>, then the current <code>Font</code> in the <code>Graphics2D</code> context is asked to convert the Unicode characters in the <code>String</code> into a set of glyphs for presentation with whatever basic layout and shaping algorithms the font implements. </li>
<li> If the argument is an <a href="../../../java.base/java/text/attributedcharacteriterator"><code>AttributedCharacterIterator</code></a>, the iterator is asked to convert itself to a <a href="font/textlayout"><code>TextLayout</code></a> using its embedded font attributes. The <code>TextLayout</code> implements more sophisticated glyph layout algorithms that perform Unicode bi-directional layout adjustments automatically for multiple fonts of differing writing directions. </li>
<li> If the argument is a <a href="font/glyphvector"><code>GlyphVector</code></a>, then the <code>GlyphVector</code> object already contains the appropriate font-specific glyph codes with explicit coordinates for the position of each glyph. </li>
</ol> </li>
<li> The current <code>Font</code> is queried to obtain outlines for the indicated glyphs. These outlines are treated as shapes in user space relative to the position of each glyph that was determined in step 1. </li>
<li> The character outlines are filled as indicated above under <a href="#rendershape"><code>Shape</code> operations</a>. </li>
<li> The current <code>Paint</code> is queried for a <code>PaintContext</code>, which specifies the colors to render in device space. </li>
</ol> </li>
<li> <b><a id="renderingimage"><code>Image</code> Operations</a></b> <ol> <li> The region of interest is defined by the bounding box of the source <code>Image</code>. This bounding box is specified in Image Space, which is the <code>Image</code> object's local coordinate system. </li>
<li> If an <code>AffineTransform</code> is passed to <a href="#drawImage(java.awt.Image,java.awt.geom.AffineTransform,java.awt.image.ImageObserver)"><code>drawImage(Image, AffineTransform, ImageObserver)</code></a>, the <code>AffineTransform</code> is used to transform the bounding box from image space to user space. If no <code>AffineTransform</code> is supplied, the bounding box is treated as if it is already in user space. </li>
<li> The bounding box of the source <code>Image</code> is transformed from user space into device space using the current <code>Transform</code>. Note that the result of transforming the bounding box does not necessarily result in a rectangular region in device space. </li>
<li> The <code>Image</code> object determines what colors to render, sampled according to the source to destination coordinate mapping specified by the current <code>Transform</code> and the optional image transform. </li>
</ol> </li>
</ol> <h2>Default Rendering Attributes</h2> The default values for the <code>Graphics2D</code> rendering attributes are: <dl> <dt>
<i><code>Paint</code></i> </dt>
<dd>The color of the <code>Component</code>. </dd>
<dt>
<i><code>Font</code></i> </dt>
<dd>The <code>Font</code> of the <code>Component</code>. </dd>
<dt>
<i><code>Stroke</code></i> </dt>
<dd>A square pen with a linewidth of 1, no dashing, miter segment joins and square end caps. </dd>
<dt>
<i><code>Transform</code></i> </dt>
<dd>The <a href="graphicsconfiguration#getDefaultTransform()"><code>getDefaultTransform</code></a> for the <code>GraphicsConfiguration</code> of the <code>Component</code>. </dd>
<dt>
<i><code>Composite</code></i> </dt>
<dd>The <a href="alphacomposite#SRC_OVER"><code>AlphaComposite.SRC_OVER</code></a> rule. </dd>
<dt>
<i><code>Clip</code></i> </dt>
<dd>No rendering <code>Clip</code>, the output is clipped to the <code>Component</code>. </dd>
</dl> <h2>Rendering Compatibility Issues</h2> The JDK(tm) 1.1 rendering model is based on a pixelization model that specifies that coordinates are infinitely thin, lying between the pixels. Drawing operations are performed using a one-pixel wide pen that fills the pixel below and to the right of the anchor point on the path. The JDK 1.1 rendering model is consistent with the capabilities of most of the existing class of platform renderers that need to resolve integer coordinates to a discrete pen that must fall completely on a specified number of pixels. <p> The Java 2D(tm) (Java(tm) 2 platform) API supports antialiasing renderers. A pen with a width of one pixel does not need to fall completely on pixel N as opposed to pixel N+1. The pen can fall partially on both pixels. It is not necessary to choose a bias direction for a wide pen since the blending that occurs along the pen traversal edges makes the sub-pixel position of the pen visible to the user. On the other hand, when antialiasing is turned off by setting the <a href="renderinghints#KEY_ANTIALIASING"><code>KEY_ANTIALIASING</code></a> hint key to the <a href="renderinghints#VALUE_ANTIALIAS_OFF"><code>VALUE_ANTIALIAS_OFF</code></a> hint value, the renderer might need to apply a bias to determine which pixel to modify when the pen is straddling a pixel boundary, such as when it is drawn along an integer coordinate in device space. While the capabilities of an antialiasing renderer make it no longer necessary for the rendering model to specify a bias for the pen, it is desirable for the antialiasing and non-antialiasing renderers to perform similarly for the common cases of drawing one-pixel wide horizontal and vertical lines on the screen. To ensure that turning on antialiasing by setting the <a href="renderinghints#KEY_ANTIALIASING"><code>KEY_ANTIALIASING</code></a> hint key to <a href="renderinghints#VALUE_ANTIALIAS_ON"><code>VALUE_ANTIALIAS_ON</code></a> does not cause such lines to suddenly become twice as wide and half as opaque, it is desirable to have the model specify a path for such lines so that they completely cover a particular set of pixels to help increase their crispness. </p>
<p> Java 2D API maintains compatibility with JDK 1.1 rendering behavior, such that legacy operations and existing renderer behavior is unchanged under Java 2D API. Legacy methods that map onto general <code>draw</code> and <code>fill</code> methods are defined, which clearly indicates how <code>Graphics2D</code> extends <code>Graphics</code> based on settings of <code>Stroke</code> and <code>Transform</code> attributes and rendering hints. The definition performs identically under default attribute settings. For example, the default <code>Stroke</code> is a <code>BasicStroke</code> with a width of 1 and no dashing and the default Transform for screen drawing is an Identity transform. </p>
<p> The following two rules provide predictable rendering behavior whether aliasing or antialiasing is being used. </p>
<ul> <li> Device coordinates are defined to be between device pixels which avoids any inconsistent results between aliased and antialiased rendering. If coordinates were defined to be at a pixel's center, some of the pixels covered by a shape, such as a rectangle, would only be half covered. With aliased rendering, the half covered pixels would either be rendered inside the shape or outside the shape. With anti-aliased rendering, the pixels on the entire edge of the shape would be half covered. On the other hand, since coordinates are defined to be between pixels, a shape like a rectangle would have no half covered pixels, whether or not it is rendered using antialiasing. </li>
<li> Lines and paths stroked using the <code>BasicStroke</code> object may be "normalized" to provide consistent rendering of the outlines when positioned at various points on the drawable and whether drawn with aliased or antialiased rendering. This normalization process is controlled by the <a href="renderinghints#KEY_STROKE_CONTROL"><code>KEY_STROKE_CONTROL</code></a> hint. The exact normalization algorithm is not specified, but the goals of this normalization are to ensure that lines are rendered with consistent visual appearance regardless of how they fall on the pixel grid and to promote more solid horizontal and vertical lines in antialiased mode so that they resemble their non-antialiased counterparts more closely. A typical normalization step might promote antialiased line endpoints to pixel centers to reduce the amount of blending or adjust the subpixel positioning of non-antialiased lines so that the floating point line widths round to even or odd pixel counts with equal likelihood. This process can move endpoints by up to half a pixel (usually towards positive infinity along both axes) to promote these consistent results. </li>
</ul> <p> The following definitions of general legacy methods perform identically to previously specified behavior under default attribute settings: </p>
<ul> <li> For <code>fill</code> operations, including <code>fillRect</code>, <code>fillRoundRect</code>, <code>fillOval</code>, <code>fillArc</code>, <code>fillPolygon</code>, and <code>clearRect</code>, <a href="#fill(java.awt.Shape)"><code>fill</code></a> can now be called with the desired <code>Shape</code>. For example, when filling a rectangle: <pre data-language="java">fill(new Rectangle(x, y, w, h));</pre> is called. </li>
<li> Similarly, for draw operations, including <code>drawLine</code>, <code>drawRect</code>, <code>drawRoundRect</code>, <code>drawOval</code>, <code>drawArc</code>, <code>drawPolyline</code>, and <code>drawPolygon</code>, <a href="#draw(java.awt.Shape)"><code>draw</code></a> can now be called with the desired <code>Shape</code>. For example, when drawing a rectangle: <pre data-language="java">draw(new Rectangle(x, y, w, h));</pre> is called. </li>
<li> The <code>draw3DRect</code> and <code>fill3DRect</code> methods were implemented in terms of the <code>drawLine</code> and <code>fillRect</code> methods in the <code>Graphics</code> class which would predicate their behavior upon the current <code>Stroke</code> and <code>Paint</code> objects in a <code>Graphics2D</code> context. This class overrides those implementations with versions that use the current <code>Color</code> exclusively, overriding the current <code>Paint</code> and which uses <code>fillRect</code> to describe the exact same behavior as the preexisting methods regardless of the setting of the current <code>Stroke</code>. </li>
</ul> The <code>Graphics</code> class defines only the <code>setColor</code> method to control the color to be painted. Since the Java 2D API extends the <code>Color</code> object to implement the new <code>Paint</code> interface, the existing <code>setColor</code> method is now a convenience method for setting the current <code>Paint</code> attribute to a <code>Color</code> object. <code>setColor(c)</code> is equivalent to <code>setPaint(c)</code>. <p> The <code>Graphics</code> class defines two methods for controlling how colors are applied to the destination. </p>
<ol> <li> The <code>setPaintMode</code> method is implemented as a convenience method to set the default <code>Composite</code>, equivalent to <code>setComposite(new AlphaComposite.SrcOver)</code>. </li>
<li> The <code>setXORMode(Color xorcolor)</code> method is implemented as a convenience method to set a special <code>Composite</code> object that ignores the <code>Alpha</code> components of source colors and sets the destination color to the value: <pre data-language="java">dstpixel = (PixelOf(srccolor) ^ PixelOf(xorcolor) ^ dstpixel);</pre> </li>
</ol>
</div> <dl> <dt>See Also:</dt> <dd><a href="renderinghints"><code>RenderingHints</code></a></dd> </dl>      <section role="region">  <h2>Constructor Summary</h2> <table> <caption>Constructors </caption> <tr> <th scope="col">Modifier</th> <th scope="col">Constructor</th> <th scope="col">Description</th> </tr> <tr> <td><code>protected </code></td> <th scope="row"><code><a href="#%3Cinit%3E()">Graphics2D</a>()</code></th> <td> <p>Constructs a new <code>Graphics2D</code> object.</p> </td> </tr> </table>  </section>  <section role="region">  <h2>Method Summary</h2> <table> <caption>All Methods <a href="javascript:show(2);">Instance Methods</a> <a href="javascript:show(4);">Abstract Methods</a> <a href="javascript:show(8);">Concrete Methods</a> </caption> <tr> <th scope="col">Modifier and Type</th> <th scope="col">Method</th> <th scope="col">Description</th> </tr> <tr id="i0"> <td><code>abstract void</code></td> <th scope="row"><code><a href="#addRenderingHints(java.util.Map)">addRenderingHints</a>​(<a href="../../../java.base/java/util/map">Map</a>&lt;?,​?&gt; hints)</code></th> <td> <p>Sets the values of an arbitrary number of preferences for the rendering algorithms.</p> </td> </tr> <tr id="i1"> <td><code>abstract void</code></td> <th scope="row"><code><a href="#clip(java.awt.Shape)">clip</a>​(<a href="shape">Shape</a> s)</code></th> <td> <p>Intersects the current <code>Clip</code> with the interior of the specified <code>Shape</code> and sets the <code>Clip</code> to the resulting intersection.</p> </td> </tr> <tr id="i2"> <td><code>abstract void</code></td> <th scope="row"><code><a href="#draw(java.awt.Shape)">draw</a>​(<a href="shape">Shape</a> s)</code></th> <td> <p>Strokes the outline of a <code>Shape</code> using the settings of the current <code>Graphics2D</code> context.</p> </td> </tr> <tr id="i3"> <td><code>void</code></td> <th scope="row"><code><a href="#draw3DRect(int,int,int,int,boolean)">draw3DRect</a>​(int x,
          int y,
          int width,
          int height,
          boolean raised)</code></th> <td> <p>Draws a 3-D highlighted outline of the specified rectangle.</p> </td> </tr> <tr id="i4"> <td><code>abstract void</code></td> <th scope="row"><code><a href="#drawGlyphVector(java.awt.font.GlyphVector,float,float)">drawGlyphVector</a>​(<a href="font/glyphvector">GlyphVector</a> g,
               float x,
               float y)</code></th> <td> <p>Renders the text of the specified <a href="font/glyphvector"><code>GlyphVector</code></a> using the <code>Graphics2D</code> context's rendering attributes.</p> </td> </tr> <tr id="i5"> <td><code>abstract void</code></td> <th scope="row"><code><a href="#drawImage(java.awt.image.BufferedImage,java.awt.image.BufferedImageOp,int,int)">drawImage</a>​(<a href="image/bufferedimage">BufferedImage</a> img,
         <a href="image/bufferedimageop">BufferedImageOp</a> op,
         int x,
         int y)</code></th> <td> <p>Renders a <code>BufferedImage</code> that is filtered with a <a href="image/bufferedimageop"><code>BufferedImageOp</code></a>.</p> </td> </tr> <tr id="i6"> <td><code>abstract boolean</code></td> <th scope="row"><code><a href="#drawImage(java.awt.Image,java.awt.geom.AffineTransform,java.awt.image.ImageObserver)">drawImage</a>​(<a href="image">Image</a> img,
         <a href="geom/affinetransform">AffineTransform</a> xform,
         <a href="image/imageobserver">ImageObserver</a> obs)</code></th> <td> <p>Renders an image, applying a transform from image space into user space before drawing.</p> </td> </tr> <tr id="i7"> <td><code>abstract void</code></td> <th scope="row"><code><a href="#drawRenderableImage(java.awt.image.renderable.RenderableImage,java.awt.geom.AffineTransform)">drawRenderableImage</a>​(<a href="image/renderable/renderableimage">RenderableImage</a> img,
                   <a href="geom/affinetransform">AffineTransform</a> xform)</code></th> <td> <p>Renders a <a href="image/renderable/renderableimage"><code>RenderableImage</code></a>, applying a transform from image space into user space before drawing.</p> </td> </tr> <tr id="i8"> <td><code>abstract void</code></td> <th scope="row"><code><a href="#drawRenderedImage(java.awt.image.RenderedImage,java.awt.geom.AffineTransform)">drawRenderedImage</a>​(<a href="image/renderedimage">RenderedImage</a> img,
                 <a href="geom/affinetransform">AffineTransform</a> xform)</code></th> <td> <p>Renders a <a href="image/renderedimage"><code>RenderedImage</code></a>, applying a transform from image space into user space before drawing.</p> </td> </tr> <tr id="i9"> <td><code>abstract void</code></td> <th scope="row"><code><a href="#drawString(java.lang.String,float,float)">drawString</a>​(<a href="../../../java.base/java/lang/string">String</a> str,
          float x,
          float y)</code></th> <td> <p>Renders the text specified by the specified <code>String</code>, using the current text attribute state in the <code>Graphics2D</code> context.</p> </td> </tr> <tr id="i10"> <td><code>abstract void</code></td> <th scope="row"><code><a href="#drawString(java.lang.String,int,int)">drawString</a>​(<a href="../../../java.base/java/lang/string">String</a> str,
          int x,
          int y)</code></th> <td> <p>Renders the text of the specified <code>String</code>, using the current text attribute state in the <code>Graphics2D</code> context.</p> </td> </tr> <tr id="i11"> <td><code>abstract void</code></td> <th scope="row"><code><a href="#drawString(java.text.AttributedCharacterIterator,float,float)">drawString</a>​(<a href="../../../java.base/java/text/attributedcharacteriterator">AttributedCharacterIterator</a> iterator,
          float x,
          float y)</code></th> <td> <p>Renders the text of the specified iterator applying its attributes in accordance with the specification of the <a href="font/textattribute"><code>TextAttribute</code></a> class.</p> </td> </tr> <tr id="i12"> <td><code>abstract void</code></td> <th scope="row"><code><a href="#drawString(java.text.AttributedCharacterIterator,int,int)">drawString</a>​(<a href="../../../java.base/java/text/attributedcharacteriterator">AttributedCharacterIterator</a> iterator,
          int x,
          int y)</code></th> <td> <p>Renders the text of the specified iterator applying its attributes in accordance with the specification of the <a href="font/textattribute"><code>TextAttribute</code></a> class.</p> </td> </tr> <tr id="i13"> <td><code>abstract void</code></td> <th scope="row"><code><a href="#fill(java.awt.Shape)">fill</a>​(<a href="shape">Shape</a> s)</code></th> <td> <p>Fills the interior of a <code>Shape</code> using the settings of the <code>Graphics2D</code> context.</p> </td> </tr> <tr id="i14"> <td><code>void</code></td> <th scope="row"><code><a href="#fill3DRect(int,int,int,int,boolean)">fill3DRect</a>​(int x,
          int y,
          int width,
          int height,
          boolean raised)</code></th> <td> <p>Paints a 3-D highlighted rectangle filled with the current color.</p> </td> </tr> <tr id="i15"> <td><code>abstract <a href="color">Color</a></code></td> <th scope="row"><code><a href="#getBackground()">getBackground</a>()</code></th> <td> <p>Returns the background color used for clearing a region.</p> </td> </tr> <tr id="i16"> <td><code>abstract <a href="composite">Composite</a></code></td> <th scope="row"><code><a href="#getComposite()">getComposite</a>()</code></th> <td> <p>Returns the current <code>Composite</code> in the <code>Graphics2D</code> context.</p> </td> </tr> <tr id="i17"> <td><code>abstract <a href="graphicsconfiguration">GraphicsConfiguration</a></code></td> <th scope="row"><code><a href="#getDeviceConfiguration()">getDeviceConfiguration</a>()</code></th> <td> <p>Returns the device configuration associated with this <code>Graphics2D</code>.</p> </td> </tr> <tr id="i18"> <td><code>abstract <a href="font/fontrendercontext">FontRenderContext</a></code></td> <th scope="row"><code><a href="#getFontRenderContext()">getFontRenderContext</a>()</code></th> <td> <p>Get the rendering context of the <code>Font</code> within this <code>Graphics2D</code> context.</p> </td> </tr> <tr id="i19"> <td><code>abstract <a href="paint">Paint</a></code></td> <th scope="row"><code><a href="#getPaint()">getPaint</a>()</code></th> <td> <p>Returns the current <code>Paint</code> of the <code>Graphics2D</code> context.</p> </td> </tr> <tr id="i20"> <td><code>abstract <a href="../../../java.base/java/lang/object">Object</a></code></td> <th scope="row"><code><a href="#getRenderingHint(java.awt.RenderingHints.Key)">getRenderingHint</a>​(<a href="renderinghints.key">RenderingHints.Key</a> hintKey)</code></th> <td> <p>Returns the value of a single preference for the rendering algorithms.</p> </td> </tr> <tr id="i21"> <td><code>abstract <a href="renderinghints">RenderingHints</a></code></td> <th scope="row"><code><a href="#getRenderingHints()">getRenderingHints</a>()</code></th> <td> <p>Gets the preferences for the rendering algorithms.</p> </td> </tr> <tr id="i22"> <td><code>abstract <a href="stroke">Stroke</a></code></td> <th scope="row"><code><a href="#getStroke()">getStroke</a>()</code></th> <td> <p>Returns the current <code>Stroke</code> in the <code>Graphics2D</code> context.</p> </td> </tr> <tr id="i23"> <td><code>abstract <a href="geom/affinetransform">AffineTransform</a></code></td> <th scope="row"><code><a href="#getTransform()">getTransform</a>()</code></th> <td> <p>Returns a copy of the current <code>Transform</code> in the <code>Graphics2D</code> context.</p> </td> </tr> <tr id="i24"> <td><code>abstract boolean</code></td> <th scope="row"><code><a href="#hit(java.awt.Rectangle,java.awt.Shape,boolean)">hit</a>​(<a href="rectangle">Rectangle</a> rect,
   <a href="shape">Shape</a> s,
   boolean onStroke)</code></th> <td> <p>Checks whether or not the specified <code>Shape</code> intersects the specified <a href="rectangle"><code>Rectangle</code></a>, which is in device space.</p> </td> </tr> <tr id="i25"> <td><code>abstract void</code></td> <th scope="row"><code><a href="#rotate(double)">rotate</a>​(double theta)</code></th> <td> <p>Concatenates the current <code>Graphics2D</code> <code>Transform</code> with a rotation transform.</p> </td> </tr> <tr id="i26"> <td><code>abstract void</code></td> <th scope="row"><code><a href="#rotate(double,double,double)">rotate</a>​(double theta,
      double x,
      double y)</code></th> <td> <p>Concatenates the current <code>Graphics2D</code> <code>Transform</code> with a translated rotation transform.</p> </td> </tr> <tr id="i27"> <td><code>abstract void</code></td> <th scope="row"><code><a href="#scale(double,double)">scale</a>​(double sx,
     double sy)</code></th> <td> <p>Concatenates the current <code>Graphics2D</code> <code>Transform</code> with a scaling transformation Subsequent rendering is resized according to the specified scaling factors relative to the previous scaling.</p> </td> </tr> <tr id="i28"> <td><code>abstract void</code></td> <th scope="row"><code><a href="#setBackground(java.awt.Color)">setBackground</a>​(<a href="color">Color</a> color)</code></th> <td> <p>Sets the background color for the <code>Graphics2D</code> context.</p> </td> </tr> <tr id="i29"> <td><code>abstract void</code></td> <th scope="row"><code><a href="#setComposite(java.awt.Composite)">setComposite</a>​(<a href="composite">Composite</a> comp)</code></th> <td> <p>Sets the <code>Composite</code> for the <code>Graphics2D</code> context.</p> </td> </tr> <tr id="i30"> <td><code>abstract void</code></td> <th scope="row"><code><a href="#setPaint(java.awt.Paint)">setPaint</a>​(<a href="paint">Paint</a> paint)</code></th> <td> <p>Sets the <code>Paint</code> attribute for the <code>Graphics2D</code> context.</p> </td> </tr> <tr id="i31"> <td><code>abstract void</code></td> <th scope="row"><code><a href="#setRenderingHint(java.awt.RenderingHints.Key,java.lang.Object)">setRenderingHint</a>​(<a href="renderinghints.key">RenderingHints.Key</a> hintKey,
                <a href="../../../java.base/java/lang/object">Object</a> hintValue)</code></th> <td> <p>Sets the value of a single preference for the rendering algorithms.</p> </td> </tr> <tr id="i32"> <td><code>abstract void</code></td> <th scope="row"><code><a href="#setRenderingHints(java.util.Map)">setRenderingHints</a>​(<a href="../../../java.base/java/util/map">Map</a>&lt;?,​?&gt; hints)</code></th> <td> <p>Replaces the values of all preferences for the rendering algorithms with the specified <code>hints</code>.</p> </td> </tr> <tr id="i33"> <td><code>abstract void</code></td> <th scope="row"><code><a href="#setStroke(java.awt.Stroke)">setStroke</a>​(<a href="stroke">Stroke</a> s)</code></th> <td> <p>Sets the <code>Stroke</code> for the <code>Graphics2D</code> context.</p> </td> </tr> <tr id="i34"> <td><code>abstract void</code></td> <th scope="row"><code><a href="#setTransform(java.awt.geom.AffineTransform)">setTransform</a>​(<a href="geom/affinetransform">AffineTransform</a> Tx)</code></th> <td> <p>Overwrites the Transform in the <code>Graphics2D</code> context.</p> </td> </tr> <tr id="i35"> <td><code>abstract void</code></td> <th scope="row"><code><a href="#shear(double,double)">shear</a>​(double shx,
     double shy)</code></th> <td> <p>Concatenates the current <code>Graphics2D</code> <code>Transform</code> with a shearing transform.</p> </td> </tr> <tr id="i36"> <td><code>abstract void</code></td> <th scope="row"><code><a href="#transform(java.awt.geom.AffineTransform)">transform</a>​(<a href="geom/affinetransform">AffineTransform</a> Tx)</code></th> <td> <p>Composes an <code>AffineTransform</code> object with the <code>Transform</code> in this <code>Graphics2D</code> according to the rule last-specified-first-applied.</p> </td> </tr> <tr id="i37"> <td><code>abstract void</code></td> <th scope="row"><code><a href="#translate(double,double)">translate</a>​(double tx,
         double ty)</code></th> <td> <p>Concatenates the current <code>Graphics2D Transform</code> with a translation transform.</p> </td> </tr> <tr id="i38"> <td><code>abstract void</code></td> <th scope="row"><code><a href="#translate(int,int)">translate</a>​(int x,
         int y)</code></th> <td> <p>Translates the origin of the <code>Graphics2D</code> context to the point (<i>x</i>, <i>y</i>) in the current coordinate system.</p> </td> </tr> </table>  <h2>Methods declared in class java.awt.<a href="graphics">Graphics</a>
</h2> <code><a href="graphics#clearRect(int,int,int,int)">clearRect</a>, <a href="graphics#clipRect(int,int,int,int)">clipRect</a>, <a href="graphics#copyArea(int,int,int,int,int,int)">copyArea</a>, <a href="graphics#create()">create</a>, <a href="graphics#create(int,int,int,int)">create</a>, <a href="graphics#dispose()">dispose</a>, <a href="graphics#drawArc(int,int,int,int,int,int)">drawArc</a>, <a href="graphics#drawBytes(byte%5B%5D,int,int,int,int)">drawBytes</a>, <a href="graphics#drawChars(char%5B%5D,int,int,int,int)">drawChars</a>, <a href="graphics#drawImage(java.awt.Image,int,int,int,int,int,int,int,int,java.awt.Color,java.awt.image.ImageObserver)">drawImage</a>, <a href="graphics#drawImage(java.awt.Image,int,int,int,int,int,int,int,int,java.awt.image.ImageObserver)">drawImage</a>, <a href="graphics#drawImage(java.awt.Image,int,int,int,int,java.awt.Color,java.awt.image.ImageObserver)">drawImage</a>, <a href="graphics#drawImage(java.awt.Image,int,int,int,int,java.awt.image.ImageObserver)">drawImage</a>, <a href="graphics#drawImage(java.awt.Image,int,int,java.awt.Color,java.awt.image.ImageObserver)">drawImage</a>, <a href="graphics#drawImage(java.awt.Image,int,int,java.awt.image.ImageObserver)">drawImage</a>, <a href="graphics#drawLine(int,int,int,int)">drawLine</a>, <a href="graphics#drawOval(int,int,int,int)">drawOval</a>, <a href="graphics#drawPolygon(int%5B%5D,int%5B%5D,int)">drawPolygon</a>, <a href="graphics#drawPolygon(java.awt.Polygon)">drawPolygon</a>, <a href="graphics#drawPolyline(int%5B%5D,int%5B%5D,int)">drawPolyline</a>, <a href="graphics#drawRect(int,int,int,int)">drawRect</a>, <a href="graphics#drawRoundRect(int,int,int,int,int,int)">drawRoundRect</a>, <a href="graphics#fillArc(int,int,int,int,int,int)">fillArc</a>, <a href="graphics#fillOval(int,int,int,int)">fillOval</a>, <a href="graphics#fillPolygon(int%5B%5D,int%5B%5D,int)">fillPolygon</a>, <a href="graphics#fillPolygon(java.awt.Polygon)">fillPolygon</a>, <a href="graphics#fillRect(int,int,int,int)">fillRect</a>, <a href="graphics#fillRoundRect(int,int,int,int,int,int)">fillRoundRect</a>, <a href="graphics#finalize()">finalize</a>, <a href="graphics#getClip()">getClip</a>, <a href="graphics#getClipBounds()">getClipBounds</a>, <a href="graphics#getClipBounds(java.awt.Rectangle)">getClipBounds</a>, <a href="graphics#getClipRect()">getClipRect</a>, <a href="graphics#getColor()">getColor</a>, <a href="graphics#getFont()">getFont</a>, <a href="graphics#getFontMetrics()">getFontMetrics</a>, <a href="graphics#getFontMetrics(java.awt.Font)">getFontMetrics</a>, <a href="graphics#hitClip(int,int,int,int)">hitClip</a>, <a href="graphics#setClip(int,int,int,int)">setClip</a>, <a href="graphics#setClip(java.awt.Shape)">setClip</a>, <a href="graphics#setColor(java.awt.Color)">setColor</a>, <a href="graphics#setFont(java.awt.Font)">setFont</a>, <a href="graphics#setPaintMode()">setPaintMode</a>, <a href="graphics#setXORMode(java.awt.Color)">setXORMode</a>, <a href="graphics#toString()">toString</a></code>  <h2>Methods declared in class java.lang.<a href="../../../java.base/java/lang/object">Object</a>
</h2> <code><a href="../../../java.base/java/lang/object#clone()">clone</a>, <a href="../../../java.base/java/lang/object#equals(java.lang.Object)">equals</a>, <a href="../../../java.base/java/lang/object#getClass()">getClass</a>, <a href="../../../java.base/java/lang/object#hashCode()">hashCode</a>, <a href="../../../java.base/java/lang/object#notify()">notify</a>, <a href="../../../java.base/java/lang/object#notifyAll()">notifyAll</a>, <a href="../../../java.base/java/lang/object#wait()">wait</a>, <a href="../../../java.base/java/lang/object#wait(long)">wait</a>, <a href="../../../java.base/java/lang/object#wait(long,int)">wait</a></code>  </section>   <div>   <section role="region">  <h2>Constructor Detail</h2>   <h3>Graphics2D</h3> <pre data-language="java">protected Graphics2D()</pre> <p>Constructs a new <code>Graphics2D</code> object. Since <code>Graphics2D</code> is an abstract class, and since it must be customized by subclasses for different output devices, <code>Graphics2D</code> objects cannot be created directly. Instead, <code>Graphics2D</code> objects must be obtained from another <code>Graphics2D</code> object, created by a <code>Component</code>, or obtained from images such as <a href="image/bufferedimage"><code>BufferedImage</code></a> objects.</p> <dl> <dt>See Also:</dt> <dd>
<a href="component#getGraphics()"><code>Component.getGraphics()</code></a>, <a href="graphics#create()"><code>Graphics.create()</code></a>
</dd> </dl>   </section>  <section role="region">  <h2>Method Detail</h2>   <h3>draw3DRect</h3> <pre data-language="java">public void draw3DRect​(int x,
                       int y,
                       int width,
                       int height,
                       boolean raised)</pre> <div>
<p>Draws a 3-D highlighted outline of the specified rectangle. The edges of the rectangle are highlighted so that they appear to be beveled and lit from the upper left corner. </p>
<p> The colors used for the highlighting effect are determined based on the current color. The resulting rectangle covers an area that is <code>width + 1</code> pixels wide by <code>height + 1</code> pixels tall. This method uses the current <code>Color</code> exclusively and ignores the current <code>Paint</code>.</p>
</div> <dl> <dt>Overrides:</dt> <dd>
<code><a href="graphics#draw3DRect(int,int,int,int,boolean)">draw3DRect</a></code> in class <code><a href="graphics">Graphics</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>x</code> - the x coordinate of the rectangle to be drawn.</dd> <dd>
<code>y</code> - the y coordinate of the rectangle to be drawn.</dd> <dd>
<code>width</code> - the width of the rectangle to be drawn.</dd> <dd>
<code>height</code> - the height of the rectangle to be drawn.</dd> <dd>
<code>raised</code> - a boolean that determines whether the rectangle appears to be raised above the surface or sunk into the surface.</dd> <dt>See Also:</dt> <dd><a href="graphics#fill3DRect(int,int,int,int,boolean)"><code>Graphics.fill3DRect(int, int, int, int, boolean)</code></a></dd> </dl>    <h3>fill3DRect</h3> <pre data-language="java">public void fill3DRect​(int x,
                       int y,
                       int width,
                       int height,
                       boolean raised)</pre> <p>Paints a 3-D highlighted rectangle filled with the current color. The edges of the rectangle are highlighted so that it appears as if the edges were beveled and lit from the upper left corner. The colors used for the highlighting effect and for filling are determined from the current <code>Color</code>. This method uses the current <code>Color</code> exclusively and ignores the current <code>Paint</code>.</p> <dl> <dt>Overrides:</dt> <dd>
<code><a href="graphics#fill3DRect(int,int,int,int,boolean)">fill3DRect</a></code> in class <code><a href="graphics">Graphics</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>x</code> - the x coordinate of the rectangle to be filled.</dd> <dd>
<code>y</code> - the y coordinate of the rectangle to be filled.</dd> <dd>
<code>width</code> - the width of the rectangle to be filled.</dd> <dd>
<code>height</code> - the height of the rectangle to be filled.</dd> <dd>
<code>raised</code> - a boolean value that determines whether the rectangle appears to be raised above the surface or etched into the surface.</dd> <dt>See Also:</dt> <dd><a href="graphics#draw3DRect(int,int,int,int,boolean)"><code>Graphics.draw3DRect(int, int, int, int, boolean)</code></a></dd> </dl>    <h3>draw</h3> <pre data-language="java">public abstract void draw​(Shape s)</pre> <p>Strokes the outline of a <code>Shape</code> using the settings of the current <code>Graphics2D</code> context. The rendering attributes applied include the <code>Clip</code>, <code>Transform</code>, <code>Paint</code>, <code>Composite</code> and <code>Stroke</code> attributes.</p> <dl> <dt>Parameters:</dt> <dd>
<code>s</code> - the <code>Shape</code> to be rendered</dd> <dt>See Also:</dt> <dd>
<a href="#setStroke(java.awt.Stroke)"><code>setStroke(java.awt.Stroke)</code></a>, <a href="#setPaint(java.awt.Paint)"><code>setPaint(java.awt.Paint)</code></a>, <a href="graphics#setColor(java.awt.Color)"><code>Graphics.setColor(java.awt.Color)</code></a>, <a href="#transform(java.awt.geom.AffineTransform)"><code>transform(java.awt.geom.AffineTransform)</code></a>, <a href="#setTransform(java.awt.geom.AffineTransform)"><code>setTransform(java.awt.geom.AffineTransform)</code></a>, <a href="#clip(java.awt.Shape)"><code>clip(java.awt.Shape)</code></a>, <a href="graphics#setClip(int,int,int,int)"><code>Graphics.setClip(int, int, int, int)</code></a>, <a href="#setComposite(java.awt.Composite)"><code>setComposite(java.awt.Composite)</code></a>
</dd> </dl>    <h3>drawImage</h3> <pre data-language="java">public abstract boolean drawImage​(Image img,
                                  AffineTransform xform,
                                  ImageObserver obs)</pre> <p>Renders an image, applying a transform from image space into user space before drawing. The transformation from user space into device space is done with the current <code>Transform</code> in the <code>Graphics2D</code>. The specified transformation is applied to the image before the transform attribute in the <code>Graphics2D</code> context is applied. The rendering attributes applied include the <code>Clip</code>, <code>Transform</code>, and <code>Composite</code> attributes. Note that no rendering is done if the specified transform is noninvertible.</p> <dl> <dt>Parameters:</dt> <dd>
<code>img</code> - the specified image to be rendered. This method does nothing if <code>img</code> is null.</dd> <dd>
<code>xform</code> - the transformation from image space into user space</dd> <dd>
<code>obs</code> - the <a href="image/imageobserver"><code>ImageObserver</code></a> to be notified as more of the <code>Image</code> is converted</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the <code>Image</code> is fully loaded and completely rendered, or if it's null; <code>false</code> if the <code>Image</code> is still being loaded.</dd> <dt>See Also:</dt> <dd>
<a href="#transform(java.awt.geom.AffineTransform)"><code>transform(java.awt.geom.AffineTransform)</code></a>, <a href="#setTransform(java.awt.geom.AffineTransform)"><code>setTransform(java.awt.geom.AffineTransform)</code></a>, <a href="#setComposite(java.awt.Composite)"><code>setComposite(java.awt.Composite)</code></a>, <a href="#clip(java.awt.Shape)"><code>clip(java.awt.Shape)</code></a>, <a href="graphics#setClip(int,int,int,int)"><code>Graphics.setClip(int, int, int, int)</code></a>
</dd> </dl>    <h3>drawImage</h3> <pre data-language="java">public abstract void drawImage​(BufferedImage img,
                               BufferedImageOp op,
                               int x,
                               int y)</pre> <p>Renders a <code>BufferedImage</code> that is filtered with a <a href="image/bufferedimageop"><code>BufferedImageOp</code></a>. The rendering attributes applied include the <code>Clip</code>, <code>Transform</code> and <code>Composite</code> attributes. This is equivalent to: </p>
<pre data-language="java">img1 = op.filter(img, null);
 drawImage(img1, new AffineTransform(1f,0f,0f,1f,x,y), null);</pre> <dl> <dt>Parameters:</dt> <dd>
<code>op</code> - the filter to be applied to the image before rendering</dd> <dd>
<code>img</code> - the specified <code>BufferedImage</code> to be rendered. This method does nothing if <code>img</code> is null.</dd> <dd>
<code>x</code> - the x coordinate of the location in user space where the upper left corner of the image is rendered</dd> <dd>
<code>y</code> - the y coordinate of the location in user space where the upper left corner of the image is rendered</dd> <dt>See Also:</dt> <dd>
<a href="#transform(java.awt.geom.AffineTransform)"><code>transform(java.awt.geom.AffineTransform)</code></a>, <a href="#setTransform(java.awt.geom.AffineTransform)"><code>setTransform(java.awt.geom.AffineTransform)</code></a>, <a href="#setComposite(java.awt.Composite)"><code>setComposite(java.awt.Composite)</code></a>, <a href="#clip(java.awt.Shape)"><code>clip(java.awt.Shape)</code></a>, <a href="graphics#setClip(int,int,int,int)"><code>Graphics.setClip(int, int, int, int)</code></a>
</dd> </dl>    <h3>drawRenderedImage</h3> <pre data-language="java">public abstract void drawRenderedImage​(RenderedImage img,
                                       AffineTransform xform)</pre> <p>Renders a <a href="image/renderedimage"><code>RenderedImage</code></a>, applying a transform from image space into user space before drawing. The transformation from user space into device space is done with the current <code>Transform</code> in the <code>Graphics2D</code>. The specified transformation is applied to the image before the transform attribute in the <code>Graphics2D</code> context is applied. The rendering attributes applied include the <code>Clip</code>, <code>Transform</code>, and <code>Composite</code> attributes. Note that no rendering is done if the specified transform is noninvertible.</p> <dl> <dt>Parameters:</dt> <dd>
<code>img</code> - the image to be rendered. This method does nothing if <code>img</code> is null.</dd> <dd>
<code>xform</code> - the transformation from image space into user space</dd> <dt>See Also:</dt> <dd>
<a href="#transform(java.awt.geom.AffineTransform)"><code>transform(java.awt.geom.AffineTransform)</code></a>, <a href="#setTransform(java.awt.geom.AffineTransform)"><code>setTransform(java.awt.geom.AffineTransform)</code></a>, <a href="#setComposite(java.awt.Composite)"><code>setComposite(java.awt.Composite)</code></a>, <a href="#clip(java.awt.Shape)"><code>clip(java.awt.Shape)</code></a>, <a href="graphics#setClip(int,int,int,int)"><code>Graphics.setClip(int, int, int, int)</code></a>
</dd> </dl>    <h3>drawRenderableImage</h3> <pre data-language="java">public abstract void drawRenderableImage​(RenderableImage img,
                                         AffineTransform xform)</pre> <div>
<p>Renders a <a href="image/renderable/renderableimage"><code>RenderableImage</code></a>, applying a transform from image space into user space before drawing. The transformation from user space into device space is done with the current <code>Transform</code> in the <code>Graphics2D</code>. The specified transformation is applied to the image before the transform attribute in the <code>Graphics2D</code> context is applied. The rendering attributes applied include the <code>Clip</code>, <code>Transform</code>, and <code>Composite</code> attributes. Note that no rendering is done if the specified transform is noninvertible. </p>
<p> Rendering hints set on the <code>Graphics2D</code> object might be used in rendering the <code>RenderableImage</code>. If explicit control is required over specific hints recognized by a specific <code>RenderableImage</code>, or if knowledge of which hints are used is required, then a <code>RenderedImage</code> should be obtained directly from the <code>RenderableImage</code> and rendered using <a href="#drawRenderedImage(java.awt.image.RenderedImage,java.awt.geom.AffineTransform)"><code>drawRenderedImage</code></a>.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>img</code> - the image to be rendered. This method does nothing if <code>img</code> is null.</dd> <dd>
<code>xform</code> - the transformation from image space into user space</dd> <dt>See Also:</dt> <dd>
<a href="#transform(java.awt.geom.AffineTransform)"><code>transform(java.awt.geom.AffineTransform)</code></a>, <a href="#setTransform(java.awt.geom.AffineTransform)"><code>setTransform(java.awt.geom.AffineTransform)</code></a>, <a href="#setComposite(java.awt.Composite)"><code>setComposite(java.awt.Composite)</code></a>, <a href="#clip(java.awt.Shape)"><code>clip(java.awt.Shape)</code></a>, <a href="graphics#setClip(int,int,int,int)"><code>Graphics.setClip(int, int, int, int)</code></a>, <a href="#drawRenderedImage(java.awt.image.RenderedImage,java.awt.geom.AffineTransform)"><code>drawRenderedImage(java.awt.image.RenderedImage, java.awt.geom.AffineTransform)</code></a>
</dd> </dl>    <h3>drawString</h3> <pre data-language="java">public abstract void drawString​(String str,
                                int x,
                                int y)</pre> <p>Renders the text of the specified <code>String</code>, using the current text attribute state in the <code>Graphics2D</code> context. The baseline of the first character is at position (<i>x</i>, <i>y</i>) in the User Space. The rendering attributes applied include the <code>Clip</code>, <code>Transform</code>, <code>Paint</code>, <code>Font</code> and <code>Composite</code> attributes. For characters in script systems such as Hebrew and Arabic, the glyphs can be rendered from right to left, in which case the coordinate supplied is the location of the leftmost character on the baseline.</p> <dl> <dt>Specified by:</dt> <dd>
<code><a href="graphics#drawString(java.lang.String,int,int)">drawString</a></code> in class <code><a href="graphics">Graphics</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>str</code> - the string to be rendered</dd> <dd>
<code>x</code> - the x coordinate of the location where the <code>String</code> should be rendered</dd> <dd>
<code>y</code> - the y coordinate of the location where the <code>String</code> should be rendered</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../java.base/java/lang/nullpointerexception">NullPointerException</a></code> - if <code>str</code> is <code>null</code>
</dd> <dt>Since:</dt> <dd>1.0</dd> <dt>See Also:</dt> <dd>
<a href="graphics#drawBytes(byte%5B%5D,int,int,int,int)"><code>Graphics.drawBytes(byte[], int, int, int, int)</code></a>, <a href="graphics#drawChars(char%5B%5D,int,int,int,int)"><code>Graphics.drawChars(char[], int, int, int, int)</code></a>
</dd> </dl>    <h3>drawString</h3> <pre data-language="java">public abstract void drawString​(String str,
                                float x,
                                float y)</pre> <p>Renders the text specified by the specified <code>String</code>, using the current text attribute state in the <code>Graphics2D</code> context. The baseline of the first character is at position (<i>x</i>, <i>y</i>) in the User Space. The rendering attributes applied include the <code>Clip</code>, <code>Transform</code>, <code>Paint</code>, <code>Font</code> and <code>Composite</code> attributes. For characters in script systems such as Hebrew and Arabic, the glyphs can be rendered from right to left, in which case the coordinate supplied is the location of the leftmost character on the baseline.</p> <dl> <dt>Parameters:</dt> <dd>
<code>str</code> - the <code>String</code> to be rendered</dd> <dd>
<code>x</code> - the x coordinate of the location where the <code>String</code> should be rendered</dd> <dd>
<code>y</code> - the y coordinate of the location where the <code>String</code> should be rendered</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../java.base/java/lang/nullpointerexception">NullPointerException</a></code> - if <code>str</code> is <code>null</code>
</dd> <dt>See Also:</dt> <dd>
<a href="#setPaint(java.awt.Paint)"><code>setPaint(java.awt.Paint)</code></a>, <a href="graphics#setColor(java.awt.Color)"><code>Graphics.setColor(java.awt.Color)</code></a>, <a href="graphics#setFont(java.awt.Font)"><code>Graphics.setFont(java.awt.Font)</code></a>, <a href="#setTransform(java.awt.geom.AffineTransform)"><code>setTransform(java.awt.geom.AffineTransform)</code></a>, <a href="#setComposite(java.awt.Composite)"><code>setComposite(java.awt.Composite)</code></a>, <a href="graphics#setClip(int,int,int,int)"><code>Graphics.setClip(int, int, int, int)</code></a>
</dd> </dl>    <h3>drawString</h3> <pre data-language="java">public abstract void drawString​(AttributedCharacterIterator iterator,
                                int x,
                                int y)</pre> <div>
<p>Renders the text of the specified iterator applying its attributes in accordance with the specification of the <a href="font/textattribute"><code>TextAttribute</code></a> class. </p>
<p> The baseline of the first character is at position (<i>x</i>, <i>y</i>) in User Space. For characters in script systems such as Hebrew and Arabic, the glyphs can be rendered from right to left, in which case the coordinate supplied is the location of the leftmost character on the baseline.</p>
</div> <dl> <dt>Specified by:</dt> <dd>
<code><a href="graphics#drawString(java.text.AttributedCharacterIterator,int,int)">drawString</a></code> in class <code><a href="graphics">Graphics</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>iterator</code> - the iterator whose text is to be rendered</dd> <dd>
<code>x</code> - the x coordinate where the iterator's text is to be rendered</dd> <dd>
<code>y</code> - the y coordinate where the iterator's text is to be rendered</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../java.base/java/lang/nullpointerexception">NullPointerException</a></code> - if <code>iterator</code> is <code>null</code>
</dd> <dt>See Also:</dt> <dd>
<a href="#setPaint(java.awt.Paint)"><code>setPaint(java.awt.Paint)</code></a>, <a href="graphics#setColor(java.awt.Color)"><code>Graphics.setColor(java.awt.Color)</code></a>, <a href="#setTransform(java.awt.geom.AffineTransform)"><code>setTransform(java.awt.geom.AffineTransform)</code></a>, <a href="#setComposite(java.awt.Composite)"><code>setComposite(java.awt.Composite)</code></a>, <a href="graphics#setClip(int,int,int,int)"><code>Graphics.setClip(int, int, int, int)</code></a>
</dd> </dl>    <h3>drawString</h3> <pre data-language="java">public abstract void drawString​(AttributedCharacterIterator iterator,
                                float x,
                                float y)</pre> <div>
<p>Renders the text of the specified iterator applying its attributes in accordance with the specification of the <a href="font/textattribute"><code>TextAttribute</code></a> class. </p>
<p> The baseline of the first character is at position (<i>x</i>, <i>y</i>) in User Space. For characters in script systems such as Hebrew and Arabic, the glyphs can be rendered from right to left, in which case the coordinate supplied is the location of the leftmost character on the baseline.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>iterator</code> - the iterator whose text is to be rendered</dd> <dd>
<code>x</code> - the x coordinate where the iterator's text is to be rendered</dd> <dd>
<code>y</code> - the y coordinate where the iterator's text is to be rendered</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../java.base/java/lang/nullpointerexception">NullPointerException</a></code> - if <code>iterator</code> is <code>null</code>
</dd> <dt>See Also:</dt> <dd>
<a href="#setPaint(java.awt.Paint)"><code>setPaint(java.awt.Paint)</code></a>, <a href="graphics#setColor(java.awt.Color)"><code>Graphics.setColor(java.awt.Color)</code></a>, <a href="#setTransform(java.awt.geom.AffineTransform)"><code>setTransform(java.awt.geom.AffineTransform)</code></a>, <a href="#setComposite(java.awt.Composite)"><code>setComposite(java.awt.Composite)</code></a>, <a href="graphics#setClip(int,int,int,int)"><code>Graphics.setClip(int, int, int, int)</code></a>
</dd> </dl>    <h3>drawGlyphVector</h3> <pre data-language="java">public abstract void drawGlyphVector​(GlyphVector g,
                                     float x,
                                     float y)</pre> <p>Renders the text of the specified <a href="font/glyphvector"><code>GlyphVector</code></a> using the <code>Graphics2D</code> context's rendering attributes. The rendering attributes applied include the <code>Clip</code>, <code>Transform</code>, <code>Paint</code>, and <code>Composite</code> attributes. The <code>GlyphVector</code> specifies individual glyphs from a <a href="font"><code>Font</code></a>. The <code>GlyphVector</code> can also contain the glyph positions. This is the fastest way to render a set of characters to the screen.</p> <dl> <dt>Parameters:</dt> <dd>
<code>g</code> - the <code>GlyphVector</code> to be rendered</dd> <dd>
<code>x</code> - the x position in User Space where the glyphs should be rendered</dd> <dd>
<code>y</code> - the y position in User Space where the glyphs should be rendered</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../java.base/java/lang/nullpointerexception">NullPointerException</a></code> - if <code>g</code> is <code>null</code>.</dd> <dt>See Also:</dt> <dd>
<a href="font#createGlyphVector(java.awt.font.FontRenderContext,java.lang.String)"><code>Font.createGlyphVector(java.awt.font.FontRenderContext, java.lang.String)</code></a>, <a href="font/glyphvector"><code>GlyphVector</code></a>, <a href="#setPaint(java.awt.Paint)"><code>setPaint(java.awt.Paint)</code></a>, <a href="graphics#setColor(java.awt.Color)"><code>Graphics.setColor(java.awt.Color)</code></a>, <a href="#setTransform(java.awt.geom.AffineTransform)"><code>setTransform(java.awt.geom.AffineTransform)</code></a>, <a href="#setComposite(java.awt.Composite)"><code>setComposite(java.awt.Composite)</code></a>, <a href="graphics#setClip(int,int,int,int)"><code>Graphics.setClip(int, int, int, int)</code></a>
</dd> </dl>    <h3>fill</h3> <pre data-language="java">public abstract void fill​(Shape s)</pre> <p>Fills the interior of a <code>Shape</code> using the settings of the <code>Graphics2D</code> context. The rendering attributes applied include the <code>Clip</code>, <code>Transform</code>, <code>Paint</code>, and <code>Composite</code>.</p> <dl> <dt>Parameters:</dt> <dd>
<code>s</code> - the <code>Shape</code> to be filled</dd> <dt>See Also:</dt> <dd>
<a href="#setPaint(java.awt.Paint)"><code>setPaint(java.awt.Paint)</code></a>, <a href="graphics#setColor(java.awt.Color)"><code>Graphics.setColor(java.awt.Color)</code></a>, <a href="#transform(java.awt.geom.AffineTransform)"><code>transform(java.awt.geom.AffineTransform)</code></a>, <a href="#setTransform(java.awt.geom.AffineTransform)"><code>setTransform(java.awt.geom.AffineTransform)</code></a>, <a href="#setComposite(java.awt.Composite)"><code>setComposite(java.awt.Composite)</code></a>, <a href="#clip(java.awt.Shape)"><code>clip(java.awt.Shape)</code></a>, <a href="graphics#setClip(int,int,int,int)"><code>Graphics.setClip(int, int, int, int)</code></a>
</dd> </dl>    <h3>hit</h3> <pre data-language="java">public abstract boolean hit​(Rectangle rect,
                            Shape s,
                            boolean onStroke)</pre> <p>Checks whether or not the specified <code>Shape</code> intersects the specified <a href="rectangle"><code>Rectangle</code></a>, which is in device space. If <code>onStroke</code> is false, this method checks whether or not the interior of the specified <code>Shape</code> intersects the specified <code>Rectangle</code>. If <code>onStroke</code> is <code>true</code>, this method checks whether or not the <code>Stroke</code> of the specified <code>Shape</code> outline intersects the specified <code>Rectangle</code>. The rendering attributes taken into account include the <code>Clip</code>, <code>Transform</code>, and <code>Stroke</code> attributes.</p> <dl> <dt>Parameters:</dt> <dd>
<code>rect</code> - the area in device space to check for a hit</dd> <dd>
<code>s</code> - the <code>Shape</code> to check for a hit</dd> <dd>
<code>onStroke</code> - flag used to choose between testing the stroked or the filled shape. If the flag is <code>true</code>, the <code>Stroke</code> outline is tested. If the flag is <code>false</code>, the filled <code>Shape</code> is tested.</dd> <dt>Returns:</dt> <dd>
<code>true</code> if there is a hit; <code>false</code> otherwise.</dd> <dt>See Also:</dt> <dd>
<a href="#setStroke(java.awt.Stroke)"><code>setStroke(java.awt.Stroke)</code></a>, <a href="#fill(java.awt.Shape)"><code>fill(java.awt.Shape)</code></a>, <a href="#draw(java.awt.Shape)"><code>draw(java.awt.Shape)</code></a>, <a href="#transform(java.awt.geom.AffineTransform)"><code>transform(java.awt.geom.AffineTransform)</code></a>, <a href="#setTransform(java.awt.geom.AffineTransform)"><code>setTransform(java.awt.geom.AffineTransform)</code></a>, <a href="#clip(java.awt.Shape)"><code>clip(java.awt.Shape)</code></a>, <a href="graphics#setClip(int,int,int,int)"><code>Graphics.setClip(int, int, int, int)</code></a>
</dd> </dl>    <h3>getDeviceConfiguration</h3> <pre data-language="java">public abstract GraphicsConfiguration getDeviceConfiguration()</pre> <p>Returns the device configuration associated with this <code>Graphics2D</code>.</p> <dl> <dt>Returns:</dt> <dd>the device configuration of this <code>Graphics2D</code>.</dd> </dl>    <h3>setComposite</h3> <pre data-language="java">public abstract void setComposite​(Composite comp)</pre> <div>
<p>Sets the <code>Composite</code> for the <code>Graphics2D</code> context. The <code>Composite</code> is used in all drawing methods such as <code>drawImage</code>, <code>drawString</code>, <code>draw</code>, and <code>fill</code>. It specifies how new pixels are to be combined with the existing pixels on the graphics device during the rendering process. </p>
<p>If this <code>Graphics2D</code> context is drawing to a <code>Component</code> on the display screen and the <code>Composite</code> is a custom object rather than an instance of the <code>AlphaComposite</code> class, and if there is a security manager, its <code>checkPermission</code> method is called with an <code>AWTPermission("readDisplayPixels")</code> permission.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>comp</code> - the <code>Composite</code> object to be used for rendering</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../java.base/java/lang/securityexception">SecurityException</a></code> - if a custom <code>Composite</code> object is being used to render to the screen and a security manager is set and its <code>checkPermission</code> method does not allow the operation.</dd> <dt>See Also:</dt> <dd>
<a href="graphics#setXORMode(java.awt.Color)"><code>Graphics.setXORMode(java.awt.Color)</code></a>, <a href="graphics#setPaintMode()"><code>Graphics.setPaintMode()</code></a>, <a href="#getComposite()"><code>getComposite()</code></a>, <a href="alphacomposite"><code>AlphaComposite</code></a>, <a href="../../../java.base/java/lang/securitymanager#checkPermission(java.security.Permission)"><code>SecurityManager.checkPermission(java.security.Permission)</code></a>, <a href="awtpermission"><code>AWTPermission</code></a>
</dd> </dl>    <h3>setPaint</h3> <pre data-language="java">public abstract void setPaint​(Paint paint)</pre> <p>Sets the <code>Paint</code> attribute for the <code>Graphics2D</code> context. Calling this method with a <code>null Paint</code> object does not have any effect on the current <code>Paint</code> attribute of this <code>Graphics2D</code>.</p> <dl> <dt>Parameters:</dt> <dd>
<code>paint</code> - the <code>Paint</code> object to be used to generate color during the rendering process, or <code>null</code>
</dd> <dt>See Also:</dt> <dd>
<a href="graphics#setColor(java.awt.Color)"><code>Graphics.setColor(java.awt.Color)</code></a>, <a href="#getPaint()"><code>getPaint()</code></a>, <a href="gradientpaint"><code>GradientPaint</code></a>, <a href="texturepaint"><code>TexturePaint</code></a>
</dd> </dl>    <h3>setStroke</h3> <pre data-language="java">public abstract void setStroke​(Stroke s)</pre> <p>Sets the <code>Stroke</code> for the <code>Graphics2D</code> context.</p> <dl> <dt>Parameters:</dt> <dd>
<code>s</code> - the <code>Stroke</code> object to be used to stroke a <code>Shape</code> during the rendering process</dd> <dt>See Also:</dt> <dd>
<a href="basicstroke"><code>BasicStroke</code></a>, <a href="#getStroke()"><code>getStroke()</code></a>
</dd> </dl>    <h3>setRenderingHint</h3> <pre data-language="java">public abstract void setRenderingHint​(RenderingHints.Key hintKey,
                                      Object hintValue)</pre> <p>Sets the value of a single preference for the rendering algorithms. Hint categories include controls for rendering quality and overall time/quality trade-off in the rendering process. Refer to the <code>RenderingHints</code> class for definitions of some common keys and values.</p> <dl> <dt>Parameters:</dt> <dd>
<code>hintKey</code> - the key of the hint to be set.</dd> <dd>
<code>hintValue</code> - the value indicating preferences for the specified hint category.</dd> <dt>See Also:</dt> <dd>
<a href="#getRenderingHint(java.awt.RenderingHints.Key)"><code>getRenderingHint(RenderingHints.Key)</code></a>, <a href="renderinghints"><code>RenderingHints</code></a>
</dd> </dl>    <h3>getRenderingHint</h3> <pre data-language="java">public abstract Object getRenderingHint​(RenderingHints.Key hintKey)</pre> <p>Returns the value of a single preference for the rendering algorithms. Hint categories include controls for rendering quality and overall time/quality trade-off in the rendering process. Refer to the <code>RenderingHints</code> class for definitions of some common keys and values.</p> <dl> <dt>Parameters:</dt> <dd>
<code>hintKey</code> - the key corresponding to the hint to get.</dd> <dt>Returns:</dt> <dd>an object representing the value for the specified hint key. Some of the keys and their associated values are defined in the <code>RenderingHints</code> class.</dd> <dt>See Also:</dt> <dd>
<a href="renderinghints"><code>RenderingHints</code></a>, <a href="#setRenderingHint(java.awt.RenderingHints.Key,java.lang.Object)"><code>setRenderingHint(RenderingHints.Key, Object)</code></a>
</dd> </dl>    <h3>setRenderingHints</h3> <pre data-language="java">public abstract void setRenderingHints​(Map&lt;?,​?&gt; hints)</pre> <p>Replaces the values of all preferences for the rendering algorithms with the specified <code>hints</code>. The existing values for all rendering hints are discarded and the new set of known hints and values are initialized from the specified <a href="../../../java.base/java/util/map"><code>Map</code></a> object. Hint categories include controls for rendering quality and overall time/quality trade-off in the rendering process. Refer to the <code>RenderingHints</code> class for definitions of some common keys and values.</p> <dl> <dt>Parameters:</dt> <dd>
<code>hints</code> - the rendering hints to be set</dd> <dt>See Also:</dt> <dd>
<a href="#getRenderingHints()"><code>getRenderingHints()</code></a>, <a href="renderinghints"><code>RenderingHints</code></a>
</dd> </dl>    <h3>addRenderingHints</h3> <pre data-language="java">public abstract void addRenderingHints​(Map&lt;?,​?&gt; hints)</pre> <p>Sets the values of an arbitrary number of preferences for the rendering algorithms. Only values for the rendering hints that are present in the specified <code>Map</code> object are modified. All other preferences not present in the specified object are left unmodified. Hint categories include controls for rendering quality and overall time/quality trade-off in the rendering process. Refer to the <code>RenderingHints</code> class for definitions of some common keys and values.</p> <dl> <dt>Parameters:</dt> <dd>
<code>hints</code> - the rendering hints to be set</dd> <dt>See Also:</dt> <dd><a href="renderinghints"><code>RenderingHints</code></a></dd> </dl>    <h3>getRenderingHints</h3> <pre data-language="java">public abstract RenderingHints getRenderingHints()</pre> <p>Gets the preferences for the rendering algorithms. Hint categories include controls for rendering quality and overall time/quality trade-off in the rendering process. Returns all of the hint key/value pairs that were ever specified in one operation. Refer to the <code>RenderingHints</code> class for definitions of some common keys and values.</p> <dl> <dt>Returns:</dt> <dd>a reference to an instance of <code>RenderingHints</code> that contains the current preferences.</dd> <dt>See Also:</dt> <dd>
<a href="renderinghints"><code>RenderingHints</code></a>, <a href="#setRenderingHints(java.util.Map)"><code>setRenderingHints(Map)</code></a>
</dd> </dl>    <h3>translate</h3> <pre data-language="java">public abstract void translate​(int x,
                               int y)</pre> <p>Translates the origin of the <code>Graphics2D</code> context to the point (<i>x</i>, <i>y</i>) in the current coordinate system. Modifies the <code>Graphics2D</code> context so that its new origin corresponds to the point (<i>x</i>, <i>y</i>) in the <code>Graphics2D</code> context's former coordinate system. All coordinates used in subsequent rendering operations on this graphics context are relative to this new origin.</p> <dl> <dt>Specified by:</dt> <dd>
<code><a href="graphics#translate(int,int)">translate</a></code> in class <code><a href="graphics">Graphics</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>x</code> - the specified x coordinate</dd> <dd>
<code>y</code> - the specified y coordinate</dd> <dt>Since:</dt> <dd>1.0</dd> </dl>    <h3>translate</h3> <pre data-language="java">public abstract void translate​(double tx,
                               double ty)</pre> <p>Concatenates the current <code>Graphics2D Transform</code> with a translation transform. Subsequent rendering is translated by the specified distance relative to the previous position. This is equivalent to calling transform(T), where T is an <code>AffineTransform</code> represented by the following matrix: </p>
<pre data-language="java">[   1    0    tx  ]
          [   0    1    ty  ]
          [   0    0    1   ]</pre> <dl> <dt>Parameters:</dt> <dd>
<code>tx</code> - the distance to translate along the x-axis</dd> <dd>
<code>ty</code> - the distance to translate along the y-axis</dd> </dl>    <h3>rotate</h3> <pre data-language="java">public abstract void rotate​(double theta)</pre> <p>Concatenates the current <code>Graphics2D</code> <code>Transform</code> with a rotation transform. Subsequent rendering is rotated by the specified radians relative to the previous origin. This is equivalent to calling <code>transform(R)</code>, where R is an <code>AffineTransform</code> represented by the following matrix: </p>
<pre data-language="java">[   cos(theta)    -sin(theta)    0   ]
          [   sin(theta)     cos(theta)    0   ]
          [       0              0         1   ]</pre> Rotating with a positive angle theta rotates points on the positive x axis toward the positive y axis. <dl> <dt>Parameters:</dt> <dd>
<code>theta</code> - the angle of rotation in radians</dd> </dl>    <h3>rotate</h3> <pre data-language="java">public abstract void rotate​(double theta,
                            double x,
                            double y)</pre> <p>Concatenates the current <code>Graphics2D</code> <code>Transform</code> with a translated rotation transform. Subsequent rendering is transformed by a transform which is constructed by translating to the specified location, rotating by the specified radians, and translating back by the same amount as the original translation. This is equivalent to the following sequence of calls: </p>
<pre data-language="java">translate(x, y);
          rotate(theta);
          translate(-x, -y);</pre> Rotating with a positive angle theta rotates points on the positive x axis toward the positive y axis. <dl> <dt>Parameters:</dt> <dd>
<code>theta</code> - the angle of rotation in radians</dd> <dd>
<code>x</code> - the x coordinate of the origin of the rotation</dd> <dd>
<code>y</code> - the y coordinate of the origin of the rotation</dd> </dl>    <h3>scale</h3> <pre data-language="java">public abstract void scale​(double sx,
                           double sy)</pre> <p>Concatenates the current <code>Graphics2D</code> <code>Transform</code> with a scaling transformation Subsequent rendering is resized according to the specified scaling factors relative to the previous scaling. This is equivalent to calling <code>transform(S)</code>, where S is an <code>AffineTransform</code> represented by the following matrix: </p>
<pre data-language="java">[   sx   0    0   ]
          [   0    sy   0   ]
          [   0    0    1   ]</pre> <dl> <dt>Parameters:</dt> <dd>
<code>sx</code> - the amount by which X coordinates in subsequent rendering operations are multiplied relative to previous rendering operations.</dd> <dd>
<code>sy</code> - the amount by which Y coordinates in subsequent rendering operations are multiplied relative to previous rendering operations.</dd> </dl>    <h3>shear</h3> <pre data-language="java">public abstract void shear​(double shx,
                           double shy)</pre> <p>Concatenates the current <code>Graphics2D</code> <code>Transform</code> with a shearing transform. Subsequent renderings are sheared by the specified multiplier relative to the previous position. This is equivalent to calling <code>transform(SH)</code>, where SH is an <code>AffineTransform</code> represented by the following matrix: </p>
<pre data-language="java">[   1   shx   0   ]
          [  shy   1    0   ]
          [   0    0    1   ]</pre> <dl> <dt>Parameters:</dt> <dd>
<code>shx</code> - the multiplier by which coordinates are shifted in the positive X axis direction as a function of their Y coordinate</dd> <dd>
<code>shy</code> - the multiplier by which coordinates are shifted in the positive Y axis direction as a function of their X coordinate</dd> </dl>    <h3>transform</h3> <pre data-language="java">public abstract void transform​(AffineTransform Tx)</pre> <p>Composes an <code>AffineTransform</code> object with the <code>Transform</code> in this <code>Graphics2D</code> according to the rule last-specified-first-applied. If the current <code>Transform</code> is Cx, the result of composition with Tx is a new <code>Transform</code> Cx'. Cx' becomes the current <code>Transform</code> for this <code>Graphics2D</code>. Transforming a point p by the updated <code>Transform</code> Cx' is equivalent to first transforming p by Tx and then transforming the result by the original <code>Transform</code> Cx. In other words, Cx'(p) = Cx(Tx(p)). A copy of the Tx is made, if necessary, so further modifications to Tx do not affect rendering.</p> <dl> <dt>Parameters:</dt> <dd>
<code>Tx</code> - the <code>AffineTransform</code> object to be composed with the current <code>Transform</code>
</dd> <dt>See Also:</dt> <dd>
<a href="#setTransform(java.awt.geom.AffineTransform)"><code>setTransform(java.awt.geom.AffineTransform)</code></a>, <a href="geom/affinetransform"><code>AffineTransform</code></a>
</dd> </dl>    <h3>setTransform</h3> <pre data-language="java">public abstract void setTransform​(AffineTransform Tx)</pre> <div>
<p>Overwrites the Transform in the <code>Graphics2D</code> context. WARNING: This method should <b>never</b> be used to apply a new coordinate transform on top of an existing transform because the <code>Graphics2D</code> might already have a transform that is needed for other purposes, such as rendering Swing components or applying a scaling transformation to adjust for the resolution of a printer. </p>
<p>To add a coordinate transform, use the <code>transform</code>, <code>rotate</code>, <code>scale</code>, or <code>shear</code> methods. The <code>setTransform</code> method is intended only for restoring the original <code>Graphics2D</code> transform after rendering, as shown in this example: </p>
<pre data-language="java">// Get the current transform
 AffineTransform saveAT = g2.getTransform();
 // Perform transformation
 g2d.transform(...);
 // Render
 g2d.draw(...);
 // Restore original transform
 g2d.setTransform(saveAT);</pre>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>Tx</code> - the <code>AffineTransform</code> that was retrieved from the <code>getTransform</code> method</dd> <dt>See Also:</dt> <dd>
<a href="#transform(java.awt.geom.AffineTransform)"><code>transform(java.awt.geom.AffineTransform)</code></a>, <a href="#getTransform()"><code>getTransform()</code></a>, <a href="geom/affinetransform"><code>AffineTransform</code></a>
</dd> </dl>    <h3>getTransform</h3> <pre data-language="java">public abstract AffineTransform getTransform()</pre> <p>Returns a copy of the current <code>Transform</code> in the <code>Graphics2D</code> context.</p> <dl> <dt>Returns:</dt> <dd>the current <code>AffineTransform</code> in the <code>Graphics2D</code> context.</dd> <dt>See Also:</dt> <dd>
<a href="#transform(java.awt.geom.AffineTransform)"><code>transform(java.awt.geom.AffineTransform)</code></a>, <a href="#setTransform(java.awt.geom.AffineTransform)"><code>setTransform(java.awt.geom.AffineTransform)</code></a>
</dd> </dl>    <h3>getPaint</h3> <pre data-language="java">public abstract Paint getPaint()</pre> <p>Returns the current <code>Paint</code> of the <code>Graphics2D</code> context.</p> <dl> <dt>Returns:</dt> <dd>the current <code>Graphics2D Paint</code>, which defines a color or pattern.</dd> <dt>See Also:</dt> <dd>
<a href="#setPaint(java.awt.Paint)"><code>setPaint(java.awt.Paint)</code></a>, <a href="graphics#setColor(java.awt.Color)"><code>Graphics.setColor(java.awt.Color)</code></a>
</dd> </dl>    <h3>getComposite</h3> <pre data-language="java">public abstract Composite getComposite()</pre> <p>Returns the current <code>Composite</code> in the <code>Graphics2D</code> context.</p> <dl> <dt>Returns:</dt> <dd>the current <code>Graphics2D Composite</code>, which defines a compositing style.</dd> <dt>See Also:</dt> <dd><a href="#setComposite(java.awt.Composite)"><code>setComposite(java.awt.Composite)</code></a></dd> </dl>    <h3>setBackground</h3> <pre data-language="java">public abstract void setBackground​(Color color)</pre> <p>Sets the background color for the <code>Graphics2D</code> context. The background color is used for clearing a region. When a <code>Graphics2D</code> is constructed for a <code>Component</code>, the background color is inherited from the <code>Component</code>. Setting the background color in the <code>Graphics2D</code> context only affects the subsequent <code>clearRect</code> calls and not the background color of the <code>Component</code>. To change the background of the <code>Component</code>, use appropriate methods of the <code>Component</code>.</p> <dl> <dt>Parameters:</dt> <dd>
<code>color</code> - the background color that is used in subsequent calls to <code>clearRect</code>
</dd> <dt>See Also:</dt> <dd>
<a href="#getBackground()"><code>getBackground()</code></a>, <a href="graphics#clearRect(int,int,int,int)"><code>Graphics.clearRect(int, int, int, int)</code></a>
</dd> </dl>    <h3>getBackground</h3> <pre data-language="java">public abstract Color getBackground()</pre> <p>Returns the background color used for clearing a region.</p> <dl> <dt>Returns:</dt> <dd>the current <code>Graphics2D Color</code>, which defines the background color.</dd> <dt>See Also:</dt> <dd><a href="#setBackground(java.awt.Color)"><code>setBackground(java.awt.Color)</code></a></dd> </dl>    <h3>getStroke</h3> <pre data-language="java">public abstract Stroke getStroke()</pre> <p>Returns the current <code>Stroke</code> in the <code>Graphics2D</code> context.</p> <dl> <dt>Returns:</dt> <dd>the current <code>Graphics2D Stroke</code>, which defines the line style.</dd> <dt>See Also:</dt> <dd><a href="#setStroke(java.awt.Stroke)"><code>setStroke(java.awt.Stroke)</code></a></dd> </dl>    <h3>clip</h3> <pre data-language="java">public abstract void clip​(Shape s)</pre> <p>Intersects the current <code>Clip</code> with the interior of the specified <code>Shape</code> and sets the <code>Clip</code> to the resulting intersection. The specified <code>Shape</code> is transformed with the current <code>Graphics2D</code> <code>Transform</code> before being intersected with the current <code>Clip</code>. This method is used to make the current <code>Clip</code> smaller. To make the <code>Clip</code> larger, use <code>setClip</code>. The <i>user clip</i> modified by this method is independent of the clipping associated with device bounds and visibility. If no clip has previously been set, or if the clip has been cleared using <a href="graphics#setClip(java.awt.Shape)"><code>setClip</code></a> with a <code>null</code> argument, the specified <code>Shape</code> becomes the new user clip.</p> <dl> <dt>Parameters:</dt> <dd>
<code>s</code> - the <code>Shape</code> to be intersected with the current <code>Clip</code>. If <code>s</code> is <code>null</code>, this method clears the current <code>Clip</code>.</dd> </dl>    <h3>getFontRenderContext</h3> <pre data-language="java">public abstract FontRenderContext getFontRenderContext()</pre> <p>Get the rendering context of the <code>Font</code> within this <code>Graphics2D</code> context. The <a href="font/fontrendercontext"><code>FontRenderContext</code></a> encapsulates application hints such as anti-aliasing and fractional metrics, as well as target device specific information such as dots-per-inch. This information should be provided by the application when using objects that perform typographical formatting, such as <code>Font</code> and <code>TextLayout</code>. This information should also be provided by applications that perform their own layout and need accurate measurements of various characteristics of glyphs such as advance and line height when various rendering hints have been applied to the text rendering.</p> <dl> <dt>Returns:</dt> <dd>a reference to an instance of FontRenderContext.</dd> <dt>Since:</dt> <dd>1.2</dd> <dt>See Also:</dt> <dd>
<a href="font/fontrendercontext"><code>FontRenderContext</code></a>, <a href="font#createGlyphVector(java.awt.font.FontRenderContext,java.lang.String)"><code>Font.createGlyphVector(java.awt.font.FontRenderContext, java.lang.String)</code></a>, <a href="font/textlayout"><code>TextLayout</code></a>
</dd> </dl>   </section>  </div>  </main>  <div class="_attribution">
  <p class="_attribution-p">
    © 1993, 2020, Oracle and/or its affiliates. All rights reserved.<br>Documentation extracted from Debian's OpenJDK Development Kit package.<br>Licensed under the GNU General Public License, version 2, with the Classpath Exception.<br>Various third party code in OpenJDK is licensed under different licenses (see Debian package).<br>Java and OpenJDK are trademarks or registered trademarks of Oracle and/or its affiliates.<br>
    <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/java/awt/Graphics2D.html" class="_attribution-link">https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/java/awt/Graphics2D.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
