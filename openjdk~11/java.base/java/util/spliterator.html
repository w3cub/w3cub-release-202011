
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Spliterator - OpenJDK 11 - W3cubDocs</title>
  
  <meta name="description" content="An object for traversing and partitioning elements of a source. The source of elements covered by a Spliterator could be, for example, an array, a &hellip;">
  <meta name="keywords" content="interface, spliterator, t, openjdk, openjdk~11">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/openjdk~11/java.base/java/util/spliterator.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/openjdk~11.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/openjdk~11/" class="_nav-link" title="" style="margin-left:0;">OpenJDK 11</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _openjdk">
				
				
<main role="main">    <h1>Interface Spliterator&lt;T&gt;</h1>     <dl> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of elements returned by this Spliterator</dd> </dl> <dl> <dt>All Known Subinterfaces:</dt> <dd>
<code><a href="spliterator.ofdouble">Spliterator.OfDouble</a></code>, <code><a href="spliterator.ofint">Spliterator.OfInt</a></code>, <code><a href="spliterator.oflong">Spliterator.OfLong</a></code>, <code><a href="spliterator.ofprimitive">Spliterator.OfPrimitive</a>&lt;T,​T_CONS,​T_SPLITR&gt;</code>
</dd> </dl> <dl> <dt>All Known Implementing Classes:</dt> <dd>
<code><a href="spliterators.abstractdoublespliterator">Spliterators.AbstractDoubleSpliterator</a></code>, <code><a href="spliterators.abstractintspliterator">Spliterators.AbstractIntSpliterator</a></code>, <code><a href="spliterators.abstractlongspliterator">Spliterators.AbstractLongSpliterator</a></code>, <code><a href="spliterators.abstractspliterator">Spliterators.AbstractSpliterator</a></code>
</dd> </dl>  <pre data-language="java">public interface Spliterator&lt;T&gt;</pre> <div>
<p>An object for traversing and partitioning elements of a source. The source of elements covered by a Spliterator could be, for example, an array, a <a href="collection"><code>Collection</code></a>, an IO channel, or a generator function. </p>
<p>A Spliterator may traverse elements individually (<a href="#tryAdvance(java.util.function.Consumer)"><code>tryAdvance()</code></a>) or sequentially in bulk (<a href="#forEachRemaining(java.util.function.Consumer)"><code>forEachRemaining()</code></a>). </p>
<p>A Spliterator may also partition off some of its elements (using <a href="#trySplit()"><code>trySplit()</code></a>) as another Spliterator, to be used in possibly-parallel operations. Operations using a Spliterator that cannot split, or does so in a highly imbalanced or inefficient manner, are unlikely to benefit from parallelism. Traversal and splitting exhaust elements; each Spliterator is useful for only a single bulk computation. </p>
<p>A Spliterator also reports a set of <a href="#characteristics()"><code>characteristics()</code></a> of its structure, source, and elements from among <a href="#ORDERED"><code>ORDERED</code></a>, <a href="#DISTINCT"><code>DISTINCT</code></a>, <a href="#SORTED"><code>SORTED</code></a>, <a href="#SIZED"><code>SIZED</code></a>, <a href="#NONNULL"><code>NONNULL</code></a>, <a href="#IMMUTABLE"><code>IMMUTABLE</code></a>, <a href="#CONCURRENT"><code>CONCURRENT</code></a>, and <a href="#SUBSIZED"><code>SUBSIZED</code></a>. These may be employed by Spliterator clients to control, specialize or simplify computation. For example, a Spliterator for a <a href="collection"><code>Collection</code></a> would report <code>SIZED</code>, a Spliterator for a <a href="set"><code>Set</code></a> would report <code>DISTINCT</code>, and a Spliterator for a <a href="sortedset"><code>SortedSet</code></a> would also report <code>SORTED</code>. Characteristics are reported as a simple unioned bit set. Some characteristics additionally constrain method behavior; for example if <code>ORDERED</code>, traversal methods must conform to their documented ordering. New characteristics may be defined in the future, so implementors should not assign meanings to unlisted values. </p>
<p><a id="binding">A Spliterator that does not report <code>IMMUTABLE</code> or <code>CONCURRENT</code> is expected to have a documented policy concerning: when the spliterator <em>binds</em> to the element source; and detection of structural interference of the element source detected after binding.</a> A <em>late-binding</em> Spliterator binds to the source of elements at the point of first traversal, first split, or first query for estimated size, rather than at the time the Spliterator is created. A Spliterator that is not <em>late-binding</em> binds to the source of elements at the point of construction or first invocation of any method. Modifications made to the source prior to binding are reflected when the Spliterator is traversed. After binding a Spliterator should, on a best-effort basis, throw <a href="concurrentmodificationexception"><code>ConcurrentModificationException</code></a> if structural interference is detected. Spliterators that do this are called <em>fail-fast</em>. The bulk traversal method (<a href="#forEachRemaining(java.util.function.Consumer)"><code>forEachRemaining()</code></a>) of a Spliterator may optimize traversal and check for structural interference after all elements have been traversed, rather than checking per-element and failing immediately. </p>
<p>Spliterators can provide an estimate of the number of remaining elements via the <a href="#estimateSize()"><code>estimateSize()</code></a> method. Ideally, as reflected in characteristic <a href="#SIZED"><code>SIZED</code></a>, this value corresponds exactly to the number of elements that would be encountered in a successful traversal. However, even when not exactly known, an estimated value may still be useful to operations being performed on the source, such as helping to determine whether it is preferable to split further or traverse the remaining elements sequentially. </p>
<p>Despite their obvious utility in parallel algorithms, spliterators are not expected to be thread-safe; instead, implementations of parallel algorithms using spliterators should ensure that the spliterator is only used by one thread at a time. This is generally easy to attain via <em>serial thread-confinement</em>, which often is a natural consequence of typical parallel algorithms that work by recursive decomposition. A thread calling <a href="#trySplit()"><code>trySplit()</code></a> may hand over the returned Spliterator to another thread, which in turn may traverse or further split that Spliterator. The behaviour of splitting and traversal is undefined if two or more threads operate concurrently on the same spliterator. If the original thread hands a spliterator off to another thread for processing, it is best if that handoff occurs before any elements are consumed with <a href="#tryAdvance(java.util.function.Consumer)"><code>tryAdvance()</code></a>, as certain guarantees (such as the accuracy of <a href="#estimateSize()"><code>estimateSize()</code></a> for <code>SIZED</code> spliterators) are only valid before traversal has begun. </p>
<p>Primitive subtype specializations of <code>Spliterator</code> are provided for <a href="spliterator.ofint"><code>int</code></a>, <a href="spliterator.oflong"><code>long</code></a>, and <a href="spliterator.ofdouble"><code>double</code></a> values. The subtype default implementations of <a href="#tryAdvance(java.util.function.Consumer)"><code>tryAdvance(java.util.function.Consumer)</code></a> and <a href="#forEachRemaining(java.util.function.Consumer)"><code>forEachRemaining(java.util.function.Consumer)</code></a> box primitive values to instances of their corresponding wrapper class. Such boxing may undermine any performance advantages gained by using the primitive specializations. To avoid boxing, the corresponding primitive-based methods should be used. For example, <a href="spliterator.ofprimitive#tryAdvance(T_CONS)"><code>Spliterator.OfPrimitive.tryAdvance(java.util.function.IntConsumer)</code></a> and <a href="spliterator.ofprimitive#forEachRemaining(T_CONS)"><code>Spliterator.OfPrimitive.forEachRemaining(java.util.function.IntConsumer)</code></a> should be used in preference to <a href="spliterator.ofint#tryAdvance(java.util.function.Consumer)"><code>Spliterator.OfInt.tryAdvance(java.util.function.Consumer)</code></a> and <a href="spliterator.ofint#forEachRemaining(java.util.function.Consumer)"><code>Spliterator.OfInt.forEachRemaining(java.util.function.Consumer)</code></a>. Traversal of primitive values using boxing-based methods <a href="#tryAdvance(java.util.function.Consumer)"><code>tryAdvance()</code></a> and <a href="#forEachRemaining(java.util.function.Consumer)"><code>forEachRemaining()</code></a> does not affect the order in which the values, transformed to boxed values, are encountered.</p>
</div> <dl> <dt>API Note:</dt> <dd>
<p>Spliterators, like <code>Iterator</code>s, are for traversing the elements of a source. The <code>Spliterator</code> API was designed to support efficient parallel traversal in addition to sequential traversal, by supporting decomposition as well as single-element iteration. In addition, the protocol for accessing elements via a Spliterator is designed to impose smaller per-element overhead than <code>Iterator</code>, and to avoid the inherent race involved in having separate methods for <code>hasNext()</code> and <code>next()</code>. </p>
<p>For mutable sources, arbitrary and non-deterministic behavior may occur if the source is structurally interfered with (elements added, replaced, or removed) between the time that the Spliterator binds to its data source and the end of traversal. For example, such interference will produce arbitrary, non-deterministic results when using the <code>java.util.stream</code> framework. </p>
<p>Structural interference of a source can be managed in the following ways (in approximate order of decreasing desirability): </p>
<ul> <li>The source cannot be structurally interfered with. <br>For example, an instance of <a href="concurrent/copyonwritearraylist"><code>CopyOnWriteArrayList</code></a> is an immutable source. A Spliterator created from the source reports a characteristic of <code>IMMUTABLE</code>.</li> <li>The source manages concurrent modifications. <br>For example, a key set of a <a href="concurrent/concurrenthashmap"><code>ConcurrentHashMap</code></a> is a concurrent source. A Spliterator created from the source reports a characteristic of <code>CONCURRENT</code>.</li> <li>The mutable source provides a late-binding and fail-fast Spliterator. <br>Late binding narrows the window during which interference can affect the calculation; fail-fast detects, on a best-effort basis, that structural interference has occurred after traversal has commenced and throws <a href="concurrentmodificationexception"><code>ConcurrentModificationException</code></a>. For example, <a href="arraylist"><code>ArrayList</code></a>, and many other non-concurrent <code>Collection</code> classes in the JDK, provide a late-binding, fail-fast spliterator.</li> <li>The mutable source provides a non-late-binding but fail-fast Spliterator. <br>The source increases the likelihood of throwing <code>ConcurrentModificationException</code> since the window of potential interference is larger.</li> <li>The mutable source provides a late-binding and non-fail-fast Spliterator. <br>The source risks arbitrary, non-deterministic behavior after traversal has commenced since interference is not detected. </li> <li>The mutable source provides a non-late-binding and non-fail-fast Spliterator. <br>The source increases the risk of arbitrary, non-deterministic behavior since non-detected interference may occur after construction. </li> </ul> <p><b>Example.</b> Here is a class (not a very useful one, except for illustration) that maintains an array in which the actual data are held in even locations, and unrelated tag data are held in odd locations. Its Spliterator ignores the tags. </p>
<pre data-language="java">class TaggedArray&lt;T&gt; {
   private final Object[] elements; // immutable after construction
   TaggedArray(T[] data, Object[] tags) {
     int size = data.length;
     if (tags.length != size) throw new IllegalArgumentException();
     this.elements = new Object[2 * size];
     for (int i = 0, j = 0; i &lt; size; ++i) {
       elements[j++] = data[i];
       elements[j++] = tags[i];
     }
   }

   public Spliterator&lt;T&gt; spliterator() {
     return new TaggedArraySpliterator&lt;&gt;(elements, 0, elements.length);
   }

   static class TaggedArraySpliterator&lt;T&gt; implements Spliterator&lt;T&gt; {
     private final Object[] array;
     private int origin; // current index, advanced on split or traversal
     private final int fence; // one past the greatest index

     TaggedArraySpliterator(Object[] array, int origin, int fence) {
       this.array = array; this.origin = origin; this.fence = fence;
     }

     public void forEachRemaining(Consumer&lt;? super T&gt; action) {
       for (; origin &lt; fence; origin += 2)
         action.accept((T) array[origin]);
     }

     public boolean tryAdvance(Consumer&lt;? super T&gt; action) {
       if (origin &lt; fence) {
         action.accept((T) array[origin]);
         origin += 2;
         return true;
       }
       else // cannot advance
         return false;
     }

     public Spliterator&lt;T&gt; trySplit() {
       int lo = origin; // divide range in half
       int mid = ((lo + fence) &gt;&gt;&gt; 1) &amp; ~1; // force midpoint to be even
       if (lo &lt; mid) { // split out left half
         origin = mid; // reset this Spliterator's origin
         return new TaggedArraySpliterator&lt;&gt;(array, lo, mid);
       }
       else       // too small to split
         return null;
     }

     public long estimateSize() {
       return (long)((fence - origin) / 2);
     }

     public int characteristics() {
       return ORDERED | SIZED | IMMUTABLE | SUBSIZED;
     }
   }
 }</pre> <p>As an example how a parallel computation framework, such as the <code>java.util.stream</code> package, would use Spliterator in a parallel computation, here is one way to implement an associated parallel forEach, that illustrates the primary usage idiom of splitting off subtasks until the estimated amount of work is small enough to perform sequentially. Here we assume that the order of processing across subtasks doesn't matter; different (forked) tasks may further split and process elements concurrently in undetermined order. This example uses a <a href="concurrent/countedcompleter"><code>CountedCompleter</code></a>; similar usages apply to other parallel task constructions. </p>
<pre data-language="java">static &lt;T&gt; void parEach(TaggedArray&lt;T&gt; a, Consumer&lt;T&gt; action) {
   Spliterator&lt;T&gt; s = a.spliterator();
   long targetBatchSize = s.estimateSize() / (ForkJoinPool.getCommonPoolParallelism() * 8);
   new ParEach(null, s, action, targetBatchSize).invoke();
 }

 static class ParEach&lt;T&gt; extends CountedCompleter&lt;Void&gt; {
   final Spliterator&lt;T&gt; spliterator;
   final Consumer&lt;T&gt; action;
   final long targetBatchSize;

   ParEach(ParEach&lt;T&gt; parent, Spliterator&lt;T&gt; spliterator,
           Consumer&lt;T&gt; action, long targetBatchSize) {
     super(parent);
     this.spliterator = spliterator; this.action = action;
     this.targetBatchSize = targetBatchSize;
   }

   public void compute() {
     Spliterator&lt;T&gt; sub;
     while (spliterator.estimateSize() &gt; targetBatchSize &amp;&amp;
            (sub = spliterator.trySplit()) != null) {
       addToPendingCount(1);
       new ParEach&lt;&gt;(this, sub, action, targetBatchSize).fork();
     }
     spliterator.forEachRemaining(action);
     propagateCompletion();
   }
 }</pre>
</dd> <dt>Implementation Note:</dt> <dd>If the boolean system property <code>org.openjdk.java.util.stream.tripwire</code> is set to <code>true</code> then diagnostic warnings are reported if boxing of primitive values occur when operating on primitive subtype specializations.</dd> <dt>Since:</dt> <dd>1.8</dd> <dt>See Also:</dt> <dd><a href="collection"><code>Collection</code></a></dd> </dl>      <section role="region">  <h2>Nested Class Summary</h2> <table> <caption>Nested Classes </caption> <tr> <th scope="col">Modifier and Type</th> <th scope="col">Interface</th> <th scope="col">Description</th> </tr> <tr> <td><code>static interface </code></td> <th scope="row"><code><a href="spliterator.ofdouble">Spliterator.OfDouble</a></code></th> <td> <p>A Spliterator specialized for <code>double</code> values.</p> </td> </tr> <tr> <td><code>static interface </code></td> <th scope="row"><code><a href="spliterator.ofint">Spliterator.OfInt</a></code></th> <td> <p>A Spliterator specialized for <code>int</code> values.</p> </td> </tr> <tr> <td><code>static interface </code></td> <th scope="row"><code><a href="spliterator.oflong">Spliterator.OfLong</a></code></th> <td> <p>A Spliterator specialized for <code>long</code> values.</p> </td> </tr> <tr> <td><code>static interface </code></td> <th scope="row"><code><a href="spliterator.ofprimitive">Spliterator.OfPrimitive</a>&lt;<a href="spliterator.ofprimitive">T</a>,​<a href="spliterator.ofprimitive">T_CONS</a>,​<a href="spliterator.ofprimitive">T_SPLITR</a> extends <a href="spliterator.ofprimitive">Spliterator.OfPrimitive</a>&lt;<a href="spliterator.ofprimitive">T</a>,​<a href="spliterator.ofprimitive">T_CONS</a>,​<a href="spliterator.ofprimitive">T_SPLITR</a>&gt;&gt;</code></th> <td> <p>A Spliterator specialized for primitive values.</p> </td> </tr> </table>  </section>  <section role="region">  <h2>Field Summary</h2> <table> <caption>Fields </caption> <tr> <th scope="col">Modifier and Type</th> <th scope="col">Field</th> <th scope="col">Description</th> </tr> <tr> <td><code>static int</code></td> <th scope="row"><code><a href="#CONCURRENT">CONCURRENT</a></code></th> <td> <p>Characteristic value signifying that the element source may be safely concurrently modified (allowing additions, replacements, and/or removals) by multiple threads without external synchronization.</p> </td> </tr> <tr> <td><code>static int</code></td> <th scope="row"><code><a href="#DISTINCT">DISTINCT</a></code></th> <td> <p>Characteristic value signifying that, for each pair of encountered elements <code>x, y</code>, <code>!x.equals(y)</code>.</p> </td> </tr> <tr> <td><code>static int</code></td> <th scope="row"><code><a href="#IMMUTABLE">IMMUTABLE</a></code></th> <td> <p>Characteristic value signifying that the element source cannot be structurally modified; that is, elements cannot be added, replaced, or removed, so such changes cannot occur during traversal.</p> </td> </tr> <tr> <td><code>static int</code></td> <th scope="row"><code><a href="#NONNULL">NONNULL</a></code></th> <td> <p>Characteristic value signifying that the source guarantees that encountered elements will not be <code>null</code>.</p> </td> </tr> <tr> <td><code>static int</code></td> <th scope="row"><code><a href="#ORDERED">ORDERED</a></code></th> <td> <p>Characteristic value signifying that an encounter order is defined for elements.</p> </td> </tr> <tr> <td><code>static int</code></td> <th scope="row"><code><a href="#SIZED">SIZED</a></code></th> <td> <p>Characteristic value signifying that the value returned from <code>estimateSize()</code> prior to traversal or splitting represents a finite size that, in the absence of structural source modification, represents an exact count of the number of elements that would be encountered by a complete traversal.</p> </td> </tr> <tr> <td><code>static int</code></td> <th scope="row"><code><a href="#SORTED">SORTED</a></code></th> <td> <p>Characteristic value signifying that encounter order follows a defined sort order.</p> </td> </tr> <tr> <td><code>static int</code></td> <th scope="row"><code><a href="#SUBSIZED">SUBSIZED</a></code></th> <td> <p>Characteristic value signifying that all Spliterators resulting from <code>trySplit()</code> will be both <a href="#SIZED"><code>SIZED</code></a> and <a href="#SUBSIZED"><code>SUBSIZED</code></a>.</p> </td> </tr> </table>  </section>  <section role="region">  <h2>Method Summary</h2> <table> <caption>All Methods <a href="javascript:show(2);">Instance Methods</a> <a href="javascript:show(4);">Abstract Methods</a> <a href="javascript:show(16);">Default Methods</a> </caption> <tr> <th scope="col">Modifier and Type</th> <th scope="col">Method</th> <th scope="col">Description</th> </tr> <tr id="i0"> <td><code>int</code></td> <th scope="row"><code><a href="#characteristics()">characteristics</a>()</code></th> <td> <p>Returns a set of characteristics of this Spliterator and its elements.</p> </td> </tr> <tr id="i1"> <td><code>long</code></td> <th scope="row"><code><a href="#estimateSize()">estimateSize</a>()</code></th> <td> <p>Returns an estimate of the number of elements that would be encountered by a <a href="#forEachRemaining(java.util.function.Consumer)"><code>forEachRemaining(java.util.function.Consumer&lt;? super T&gt;)</code></a> traversal, or returns <a href="../lang/long#MAX_VALUE"><code>Long.MAX_VALUE</code></a> if infinite, unknown, or too expensive to compute.</p> </td> </tr> <tr id="i2"> <td><code>default void</code></td> <th scope="row"><code><a href="#forEachRemaining(java.util.function.Consumer)">forEachRemaining</a>​(<a href="function/consumer">Consumer</a>&lt;? super <a href="spliterator">T</a>&gt; action)</code></th> <td> <p>Performs the given action for each remaining element, sequentially in the current thread, until all elements have been processed or the action throws an exception.</p> </td> </tr> <tr id="i3"> <td><code>default <a href="comparator">Comparator</a>&lt;? super <a href="spliterator">T</a>&gt;</code></td> <th scope="row"><code><a href="#getComparator()">getComparator</a>()</code></th> <td> <p>If this Spliterator's source is <a href="#SORTED"><code>SORTED</code></a> by a <a href="comparator"><code>Comparator</code></a>, returns that <code>Comparator</code>.</p> </td> </tr> <tr id="i4"> <td><code>default long</code></td> <th scope="row"><code><a href="#getExactSizeIfKnown()">getExactSizeIfKnown</a>()</code></th> <td> <p>Convenience method that returns <a href="#estimateSize()"><code>estimateSize()</code></a> if this Spliterator is <a href="#SIZED"><code>SIZED</code></a>, else <code>-1</code>.</p> </td> </tr> <tr id="i5"> <td><code>default boolean</code></td> <th scope="row"><code><a href="#hasCharacteristics(int)">hasCharacteristics</a>​(int characteristics)</code></th> <td> <p>Returns <code>true</code> if this Spliterator's <a href="#characteristics()"><code>characteristics()</code></a> contain all of the given characteristics.</p> </td> </tr> <tr id="i6"> <td><code>boolean</code></td> <th scope="row"><code><a href="#tryAdvance(java.util.function.Consumer)">tryAdvance</a>​(<a href="function/consumer">Consumer</a>&lt;? super <a href="spliterator">T</a>&gt; action)</code></th> <td> <p>If a remaining element exists, performs the given action on it, returning <code>true</code>; else returns <code>false</code>.</p> </td> </tr> <tr id="i7"> <td><code><a href="spliterator">Spliterator</a>&lt;<a href="spliterator">T</a>&gt;</code></td> <th scope="row"><code><a href="#trySplit()">trySplit</a>()</code></th> <td> <p>If this spliterator can be partitioned, returns a Spliterator covering elements, that will, upon return from this method, not be covered by this Spliterator.</p> </td> </tr> </table>  </section>   <div>   <section role="region">  <h2>Field Detail</h2>   <h3>ORDERED</h3> <pre data-language="java">static final int ORDERED</pre> <div>
<p>Characteristic value signifying that an encounter order is defined for elements. If so, this Spliterator guarantees that method <a href="#trySplit()"><code>trySplit()</code></a> splits a strict prefix of elements, that method <a href="#tryAdvance(java.util.function.Consumer)"><code>tryAdvance(java.util.function.Consumer&lt;? super T&gt;)</code></a> steps by one element in prefix order, and that <a href="#forEachRemaining(java.util.function.Consumer)"><code>forEachRemaining(java.util.function.Consumer&lt;? super T&gt;)</code></a> performs actions in encounter order. </p>
<p>A <a href="collection"><code>Collection</code></a> has an encounter order if the corresponding <a href="collection#iterator()"><code>Collection.iterator()</code></a> documents an order. If so, the encounter order is the same as the documented order. Otherwise, a collection does not have an encounter order.</p>
</div> <dl> <dt>API Note:</dt> <dd>Encounter order is guaranteed to be ascending index order for any <a href="list"><code>List</code></a>. But no order is guaranteed for hash-based collections such as <a href="hashset"><code>HashSet</code></a>. Clients of a Spliterator that reports <code>ORDERED</code> are expected to preserve ordering constraints in non-commutative parallel computations.</dd> <dt>See Also:</dt> <dd><a href="https://docs.oracle.com/en/java/javase/11/docs/api/constant-values.html#java.util.Spliterator.ORDERED">Constant Field Values</a></dd> </dl>    <h3>DISTINCT</h3> <pre data-language="java">static final int DISTINCT</pre> <p>Characteristic value signifying that, for each pair of encountered elements <code>x, y</code>, <code>!x.equals(y)</code>. This applies for example, to a Spliterator based on a <a href="set"><code>Set</code></a>.</p> <dl> <dt>See Also:</dt> <dd><a href="https://docs.oracle.com/en/java/javase/11/docs/api/constant-values.html#java.util.Spliterator.DISTINCT">Constant Field Values</a></dd> </dl>    <h3>SORTED</h3> <pre data-language="java">static final int SORTED</pre> <div>
<p>Characteristic value signifying that encounter order follows a defined sort order. If so, method <a href="#getComparator()"><code>getComparator()</code></a> returns the associated Comparator, or <code>null</code> if all elements are <a href="../lang/comparable"><code>Comparable</code></a> and are sorted by their natural ordering. </p>
<p>A Spliterator that reports <code>SORTED</code> must also report <code>ORDERED</code>.</p>
</div> <dl> <dt>API Note:</dt> <dd>The spliterators for <code>Collection</code> classes in the JDK that implement <a href="navigableset"><code>NavigableSet</code></a> or <a href="sortedset"><code>SortedSet</code></a> report <code>SORTED</code>.</dd> <dt>See Also:</dt> <dd><a href="https://docs.oracle.com/en/java/javase/11/docs/api/constant-values.html#java.util.Spliterator.SORTED">Constant Field Values</a></dd> </dl>    <h3>SIZED</h3> <pre data-language="java">static final int SIZED</pre> <p>Characteristic value signifying that the value returned from <code>estimateSize()</code> prior to traversal or splitting represents a finite size that, in the absence of structural source modification, represents an exact count of the number of elements that would be encountered by a complete traversal.</p> <dl> <dt>API Note:</dt> <dd>Most Spliterators for Collections, that cover all elements of a <code>Collection</code> report this characteristic. Sub-spliterators, such as those for <a href="hashset"><code>HashSet</code></a>, that cover a sub-set of elements and approximate their reported size do not.</dd> <dt>See Also:</dt> <dd><a href="https://docs.oracle.com/en/java/javase/11/docs/api/constant-values.html#java.util.Spliterator.SIZED">Constant Field Values</a></dd> </dl>    <h3>NONNULL</h3> <pre data-language="java">static final int NONNULL</pre> <p>Characteristic value signifying that the source guarantees that encountered elements will not be <code>null</code>. (This applies, for example, to most concurrent collections, queues, and maps.)</p> <dl> <dt>See Also:</dt> <dd><a href="https://docs.oracle.com/en/java/javase/11/docs/api/constant-values.html#java.util.Spliterator.NONNULL">Constant Field Values</a></dd> </dl>    <h3>IMMUTABLE</h3> <pre data-language="java">static final int IMMUTABLE</pre> <p>Characteristic value signifying that the element source cannot be structurally modified; that is, elements cannot be added, replaced, or removed, so such changes cannot occur during traversal. A Spliterator that does not report <code>IMMUTABLE</code> or <code>CONCURRENT</code> is expected to have a documented policy (for example throwing <a href="concurrentmodificationexception"><code>ConcurrentModificationException</code></a>) concerning structural interference detected during traversal.</p> <dl> <dt>See Also:</dt> <dd><a href="https://docs.oracle.com/en/java/javase/11/docs/api/constant-values.html#java.util.Spliterator.IMMUTABLE">Constant Field Values</a></dd> </dl>    <h3>CONCURRENT</h3> <pre data-language="java">static final int CONCURRENT</pre> <div>
<p>Characteristic value signifying that the element source may be safely concurrently modified (allowing additions, replacements, and/or removals) by multiple threads without external synchronization. If so, the Spliterator is expected to have a documented policy concerning the impact of modifications during traversal. </p>
<p>A top-level Spliterator should not report both <code>CONCURRENT</code> and <code>SIZED</code>, since the finite size, if known, may change if the source is concurrently modified during traversal. Such a Spliterator is inconsistent and no guarantees can be made about any computation using that Spliterator. Sub-spliterators may report <code>SIZED</code> if the sub-split size is known and additions or removals to the source are not reflected when traversing. </p>
<p>A top-level Spliterator should not report both <code>CONCURRENT</code> and <code>IMMUTABLE</code>, since they are mutually exclusive. Such a Spliterator is inconsistent and no guarantees can be made about any computation using that Spliterator. Sub-spliterators may report <code>IMMUTABLE</code> if additions or removals to the source are not reflected when traversing.</p>
</div> <dl> <dt>API Note:</dt> <dd>Most concurrent collections maintain a consistency policy guaranteeing accuracy with respect to elements present at the point of Spliterator construction, but possibly not reflecting subsequent additions or removals.</dd> <dt>See Also:</dt> <dd><a href="https://docs.oracle.com/en/java/javase/11/docs/api/constant-values.html#java.util.Spliterator.CONCURRENT">Constant Field Values</a></dd> </dl>    <h3>SUBSIZED</h3> <pre data-language="java">static final int SUBSIZED</pre> <div>
<p>Characteristic value signifying that all Spliterators resulting from <code>trySplit()</code> will be both <a href="#SIZED"><code>SIZED</code></a> and <a href="#SUBSIZED"><code>SUBSIZED</code></a>. (This means that all child Spliterators, whether direct or indirect, will be <code>SIZED</code>.) </p>
<p>A Spliterator that does not report <code>SIZED</code> as required by <code>SUBSIZED</code> is inconsistent and no guarantees can be made about any computation using that Spliterator.</p>
</div> <dl> <dt>API Note:</dt> <dd>Some spliterators, such as the top-level spliterator for an approximately balanced binary tree, will report <code>SIZED</code> but not <code>SUBSIZED</code>, since it is common to know the size of the entire tree but not the exact sizes of subtrees.</dd> <dt>See Also:</dt> <dd><a href="https://docs.oracle.com/en/java/javase/11/docs/api/constant-values.html#java.util.Spliterator.SUBSIZED">Constant Field Values</a></dd> </dl>   </section>  <section role="region">  <h2>Method Detail</h2>   <h3>tryAdvance</h3> <pre data-language="java">boolean tryAdvance​(Consumer&lt;? super T&gt; action)</pre> <p>If a remaining element exists, performs the given action on it, returning <code>true</code>; else returns <code>false</code>. If this Spliterator is <a href="#ORDERED"><code>ORDERED</code></a> the action is performed on the next element in encounter order. Exceptions thrown by the action are relayed to the caller.</p> <dl> <dt>Parameters:</dt> <dd>
<code>action</code> - The action</dd> <dt>Returns:</dt> <dd>
<code>false</code> if no remaining elements existed upon entry to this method, else <code>true</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if the specified action is null</dd> </dl>    <h3>forEachRemaining</h3> <pre data-language="java">default void forEachRemaining​(Consumer&lt;? super T&gt; action)</pre> <p>Performs the given action for each remaining element, sequentially in the current thread, until all elements have been processed or the action throws an exception. If this Spliterator is <a href="#ORDERED"><code>ORDERED</code></a>, actions are performed in encounter order. Exceptions thrown by the action are relayed to the caller.</p> <dl> <dt>Implementation Requirements:</dt> <dd>The default implementation repeatedly invokes <a href="#tryAdvance(java.util.function.Consumer)"><code>tryAdvance(java.util.function.Consumer&lt;? super T&gt;)</code></a> until it returns <code>false</code>. It should be overridden whenever possible.</dd> <dt>Parameters:</dt> <dd>
<code>action</code> - The action</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if the specified action is null</dd> </dl>    <h3>trySplit</h3> <pre data-language="java">Spliterator&lt;T&gt; trySplit()</pre> <div>
<p>If this spliterator can be partitioned, returns a Spliterator covering elements, that will, upon return from this method, not be covered by this Spliterator. </p>
<p>If this Spliterator is <a href="#ORDERED"><code>ORDERED</code></a>, the returned Spliterator must cover a strict prefix of the elements. </p>
<p>Unless this Spliterator covers an infinite number of elements, repeated calls to <code>trySplit()</code> must eventually return <code>null</code>. Upon non-null return: </p>
<ul> <li>the value reported for <code>estimateSize()</code> before splitting, must, after splitting, be greater than or equal to <code>estimateSize()</code> for this and the returned Spliterator; and</li> <li>if this Spliterator is <code>SUBSIZED</code>, then <code>estimateSize()</code> for this spliterator before splitting must be equal to the sum of <code>estimateSize()</code> for this and the returned Spliterator after splitting.</li> </ul> <p>This method may return <code>null</code> for any reason, including emptiness, inability to split after traversal has commenced, data structure constraints, and efficiency considerations.</p>
</div> <dl> <dt>API Note:</dt> <dd>An ideal <code>trySplit</code> method efficiently (without traversal) divides its elements exactly in half, allowing balanced parallel computation. Many departures from this ideal remain highly effective; for example, only approximately splitting an approximately balanced tree, or for a tree in which leaf nodes may contain either one or two elements, failing to further split these nodes. However, large deviations in balance and/or overly inefficient <code>
 trySplit</code> mechanics typically result in poor parallel performance.</dd> <dt>Returns:</dt> <dd>a <code>Spliterator</code> covering some portion of the elements, or <code>null</code> if this spliterator cannot be split</dd> </dl>    <h3>estimateSize</h3> <pre data-language="java">long estimateSize()</pre> <div>
<p>Returns an estimate of the number of elements that would be encountered by a <a href="#forEachRemaining(java.util.function.Consumer)"><code>forEachRemaining(java.util.function.Consumer&lt;? super T&gt;)</code></a> traversal, or returns <a href="../lang/long#MAX_VALUE"><code>Long.MAX_VALUE</code></a> if infinite, unknown, or too expensive to compute. </p>
<p>If this Spliterator is <a href="#SIZED"><code>SIZED</code></a> and has not yet been partially traversed or split, or this Spliterator is <a href="#SUBSIZED"><code>SUBSIZED</code></a> and has not yet been partially traversed, this estimate must be an accurate count of elements that would be encountered by a complete traversal. Otherwise, this estimate may be arbitrarily inaccurate, but must decrease as specified across invocations of <a href="#trySplit()"><code>trySplit()</code></a>.</p>
</div> <dl> <dt>API Note:</dt> <dd>Even an inexact estimate is often useful and inexpensive to compute. For example, a sub-spliterator of an approximately balanced binary tree may return a value that estimates the number of elements to be half of that of its parent; if the root Spliterator does not maintain an accurate count, it could estimate size to be the power of two corresponding to its maximum depth.</dd> <dt>Returns:</dt> <dd>the estimated size, or <code>Long.MAX_VALUE</code> if infinite, unknown, or too expensive to compute.</dd> </dl>    <h3>getExactSizeIfKnown</h3> <pre data-language="java">default long getExactSizeIfKnown()</pre> <p>Convenience method that returns <a href="#estimateSize()"><code>estimateSize()</code></a> if this Spliterator is <a href="#SIZED"><code>SIZED</code></a>, else <code>-1</code>.</p> <dl> <dt>Implementation Requirements:</dt> <dd>The default implementation returns the result of <code>estimateSize()</code> if the Spliterator reports a characteristic of <code>SIZED</code>, and <code>-1</code> otherwise.</dd> <dt>Returns:</dt> <dd>the exact size, if known, else <code>-1</code>.</dd> </dl>    <h3>characteristics</h3> <pre data-language="java">int characteristics()</pre> <div>
<p>Returns a set of characteristics of this Spliterator and its elements. The result is represented as ORed values from <a href="#ORDERED"><code>ORDERED</code></a>, <a href="#DISTINCT"><code>DISTINCT</code></a>, <a href="#SORTED"><code>SORTED</code></a>, <a href="#SIZED"><code>SIZED</code></a>, <a href="#NONNULL"><code>NONNULL</code></a>, <a href="#IMMUTABLE"><code>IMMUTABLE</code></a>, <a href="#CONCURRENT"><code>CONCURRENT</code></a>, <a href="#SUBSIZED"><code>SUBSIZED</code></a>. Repeated calls to <code>characteristics()</code> on a given spliterator, prior to or in-between calls to <code>trySplit</code>, should always return the same result. </p>
<p>If a Spliterator reports an inconsistent set of characteristics (either those returned from a single invocation or across multiple invocations), no guarantees can be made about any computation using this Spliterator.</p>
</div> <dl> <dt>API Note:</dt> <dd>The characteristics of a given spliterator before splitting may differ from the characteristics after splitting. For specific examples see the characteristic values <a href="#SIZED"><code>SIZED</code></a>, <a href="#SUBSIZED"><code>SUBSIZED</code></a> and <a href="#CONCURRENT"><code>CONCURRENT</code></a>.</dd> <dt>Returns:</dt> <dd>a representation of characteristics</dd> </dl>    <h3>hasCharacteristics</h3> <pre data-language="java">default boolean hasCharacteristics​(int characteristics)</pre> <p>Returns <code>true</code> if this Spliterator's <a href="#characteristics()"><code>characteristics()</code></a> contain all of the given characteristics.</p> <dl> <dt>Implementation Requirements:</dt> <dd>The default implementation returns true if the corresponding bits of the given characteristics are set.</dd> <dt>Parameters:</dt> <dd>
<code>characteristics</code> - the characteristics to check for</dd> <dt>Returns:</dt> <dd>
<code>true</code> if all the specified characteristics are present, else <code>false</code>
</dd> </dl>    <h3>getComparator</h3> <pre data-language="java">default Comparator&lt;? super T&gt; getComparator()</pre> <p>If this Spliterator's source is <a href="#SORTED"><code>SORTED</code></a> by a <a href="comparator"><code>Comparator</code></a>, returns that <code>Comparator</code>. If the source is <code>SORTED</code> in <a href="../lang/comparable">natural order</a>, returns <code>null</code>. Otherwise, if the source is not <code>SORTED</code>, throws <a href="../lang/illegalstateexception"><code>IllegalStateException</code></a>.</p> <dl> <dt>Implementation Requirements:</dt> <dd>The default implementation always throws <a href="../lang/illegalstateexception"><code>IllegalStateException</code></a>.</dd> <dt>Returns:</dt> <dd>a Comparator, or <code>null</code> if the elements are sorted in the natural order.</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalstateexception">IllegalStateException</a></code> - if the spliterator does not report a characteristic of <code>SORTED</code>.</dd> </dl>   </section>  </div>  </main>  <div class="_attribution">
  <p class="_attribution-p">
    © 1993, 2020, Oracle and/or its affiliates. All rights reserved.<br>Documentation extracted from Debian's OpenJDK Development Kit package.<br>Licensed under the GNU General Public License, version 2, with the Classpath Exception.<br>Various third party code in OpenJDK is licensed under different licenses (see Debian package).<br>Java and OpenJDK are trademarks or registered trademarks of Oracle and/or its affiliates.<br>
    <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Spliterator.html" class="_attribution-link">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Spliterator.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
