
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>VarHandle - OpenJDK 11 - W3cubDocs</title>
  
  <meta name="description" content="A VarHandle is a dynamically strongly typed reference to a variable, or to a parametrically-defined family of variables, including static fields, &hellip;">
  <meta name="keywords" content="class, varhandlecompiling, invocation, access, mode, methodsinvocation, checkingvarhandle, creationinteroperation, between, varhandles, and, core, reflection, apiinteroperation, java, generics, varhandle, openjdk, openjdk~11">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/openjdk~11/java.base/java/lang/invoke/varhandle.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/openjdk~11.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/openjdk~11/" class="_nav-link" title="" style="margin-left:0;">OpenJDK 11</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _openjdk">
				
				
<main role="main">    <h1>Class VarHandle</h1>   <ul class="inheritance"> <li><a href="../object">java.lang.Object</a></li> <li> <ul class="inheritance"> <li>java.lang.invoke.VarHandle</li> </ul> </li> </ul>    <pre data-language="java">public abstract class VarHandle
extends Object</pre> <div>
<p>A VarHandle is a dynamically strongly typed reference to a variable, or to a parametrically-defined family of variables, including static fields, non-static fields, array elements, or components of an off-heap data structure. Access to such variables is supported under various <em>access modes</em>, including plain read/write access, volatile read/write access, and compare-and-set. </p>
<p>VarHandles are immutable and have no visible state. VarHandles cannot be subclassed by the user. </p>
<p>A VarHandle has: </p>
<ul> <li>a <a href="#varType()"><code>variable type</code></a> T, the type of every variable referenced by this VarHandle; and </li>
<li>a list of <a href="#coordinateTypes()"><code>coordinate types</code></a> <code>CT1, CT2, ..., CTn</code>, the types of <em>coordinate expressions</em> that jointly locate a variable referenced by this VarHandle. </li>
</ul> Variable and coordinate types may be primitive or reference, and are represented by <code>Class</code> objects. The list of coordinate types may be empty. <p>Factory methods that produce or <a href="methodhandles.lookup"><code>lookup</code></a> VarHandle instances document the supported variable type and the list of coordinate types. </p>
<p>Each access mode is associated with one <em>access mode method</em>, a <a href="methodhandle#sigpoly">signature polymorphic</a> method named for the access mode. When an access mode method is invoked on a VarHandle instance, the initial arguments to the invocation are coordinate expressions that indicate in precisely which object the variable is to be accessed. Trailing arguments to the invocation represent values of importance to the access mode. For example, the various compare-and-set or compare-and-exchange access modes require two trailing arguments for the variable's expected value and new value. </p>
<p>The arity and types of arguments to the invocation of an access mode method are not checked statically. Instead, each access mode method specifies an <a href="#accessModeType(java.lang.invoke.VarHandle.AccessMode)"><code>access mode type</code></a>, represented as an instance of <a href="methodtype"><code>MethodType</code></a>, that serves as a kind of method signature against which the arguments are checked dynamically. An access mode type gives formal parameter types in terms of the coordinate types of a VarHandle instance and the types for values of importance to the access mode. An access mode type also gives a return type, often in terms of the variable type of a VarHandle instance. When an access mode method is invoked on a VarHandle instance, the symbolic type descriptor at the call site, the run time types of arguments to the invocation, and the run time type of the return value, must <a href="#invoke">match</a> the types given in the access mode type. A runtime exception will be thrown if the match fails. For example, the access mode method <a href="#compareAndSet(java.lang.Object...)"><code>compareAndSet(java.lang.Object...)</code></a> specifies that if its receiver is a VarHandle instance with coordinate types <code>CT1, ..., CTn</code> and variable type <code>T</code>, then its access mode type is <code>(CT1 c1, ..., CTn cn, T expectedValue, T newValue)boolean</code>. Suppose that a VarHandle instance can access array elements, and that its coordinate types are <code>String[]</code> and <code>int</code> while its variable type is <code>String</code>. The access mode type for <code>compareAndSet</code> on this VarHandle instance would be <code>(String[] c1, int c2, String expectedValue, String newValue)boolean</code>. Such a VarHandle instance may be produced by the <a href="methodhandles#arrayElementVarHandle(java.lang.Class)"><code>array factory method</code></a> and access array elements as follows: </p>
<pre data-language="java">String[] sa = ...
 VarHandle avh = MethodHandles.arrayElementVarHandle(String[].class);
 boolean r = avh.compareAndSet(sa, 10, "expected", "new");</pre> <p>Access modes control atomicity and consistency properties. <em>Plain</em> read (<code>get</code>) and write (<code>set</code>) accesses are guaranteed to be bitwise atomic only for references and for primitive values of at most 32 bits, and impose no observable ordering constraints with respect to threads other than the executing thread. <em>Opaque</em> operations are bitwise atomic and coherently ordered with respect to accesses to the same variable. In addition to obeying Opaque properties, <em>Acquire</em> mode reads and their subsequent accesses are ordered after matching <em>Release</em> mode writes and their previous accesses. In addition to obeying Acquire and Release properties, all <em>Volatile</em> operations are totally ordered with respect to each other. </p>
<p>Access modes are grouped into the following categories: </p>
<ul> <li>read access modes that get the value of a variable under specified memory ordering effects. The set of corresponding access mode methods belonging to this group consists of the methods <a href="#get(java.lang.Object...)"><code>get</code></a>, <a href="#getVolatile(java.lang.Object...)"><code>getVolatile</code></a>, <a href="#getAcquire(java.lang.Object...)"><code>getAcquire</code></a>, <a href="#getOpaque(java.lang.Object...)"><code>getOpaque</code></a>. </li>
<li>write access modes that set the value of a variable under specified memory ordering effects. The set of corresponding access mode methods belonging to this group consists of the methods <a href="#set(java.lang.Object...)"><code>set</code></a>, <a href="#setVolatile(java.lang.Object...)"><code>setVolatile</code></a>, <a href="#setRelease(java.lang.Object...)"><code>setRelease</code></a>, <a href="#setOpaque(java.lang.Object...)"><code>setOpaque</code></a>. </li>
<li>atomic update access modes that, for example, atomically compare and set the value of a variable under specified memory ordering effects. The set of corresponding access mode methods belonging to this group consists of the methods <a href="#compareAndSet(java.lang.Object...)"><code>compareAndSet</code></a>, <a href="#weakCompareAndSetPlain(java.lang.Object...)"><code>weakCompareAndSetPlain</code></a>, <a href="#weakCompareAndSet(java.lang.Object...)"><code>weakCompareAndSet</code></a>, <a href="#weakCompareAndSetAcquire(java.lang.Object...)"><code>weakCompareAndSetAcquire</code></a>, <a href="#weakCompareAndSetRelease(java.lang.Object...)"><code>weakCompareAndSetRelease</code></a>, <a href="#compareAndExchangeAcquire(java.lang.Object...)"><code>compareAndExchangeAcquire</code></a>, <a href="#compareAndExchange(java.lang.Object...)"><code>compareAndExchange</code></a>, <a href="#compareAndExchangeRelease(java.lang.Object...)"><code>compareAndExchangeRelease</code></a>, <a href="#getAndSet(java.lang.Object...)"><code>getAndSet</code></a>, <a href="#getAndSetAcquire(java.lang.Object...)"><code>getAndSetAcquire</code></a>, <a href="#getAndSetRelease(java.lang.Object...)"><code>getAndSetRelease</code></a>. </li>
<li>numeric atomic update access modes that, for example, atomically get and set with addition the value of a variable under specified memory ordering effects. The set of corresponding access mode methods belonging to this group consists of the methods <a href="#getAndAdd(java.lang.Object...)"><code>getAndAdd</code></a>, <a href="#getAndAddAcquire(java.lang.Object...)"><code>getAndAddAcquire</code></a>, <a href="#getAndAddRelease(java.lang.Object...)"><code>getAndAddRelease</code></a>, </li>
<li>bitwise atomic update access modes that, for example, atomically get and bitwise OR the value of a variable under specified memory ordering effects. The set of corresponding access mode methods belonging to this group consists of the methods <a href="#getAndBitwiseOr(java.lang.Object...)"><code>getAndBitwiseOr</code></a>, <a href="#getAndBitwiseOrAcquire(java.lang.Object...)"><code>getAndBitwiseOrAcquire</code></a>, <a href="#getAndBitwiseOrRelease(java.lang.Object...)"><code>getAndBitwiseOrRelease</code></a>, <a href="#getAndBitwiseAnd(java.lang.Object...)"><code>getAndBitwiseAnd</code></a>, <a href="#getAndBitwiseAndAcquire(java.lang.Object...)"><code>getAndBitwiseAndAcquire</code></a>, <a href="#getAndBitwiseAndRelease(java.lang.Object...)"><code>getAndBitwiseAndRelease</code></a>, <a href="#getAndBitwiseXor(java.lang.Object...)"><code>getAndBitwiseXor</code></a>, <a href="#getAndBitwiseXorAcquire(java.lang.Object...)"><code>getAndBitwiseXorAcquire</code></a>, <a href="#getAndBitwiseXorRelease(java.lang.Object...)"><code>getAndBitwiseXorRelease</code></a>. </li>
</ul> <p>Factory methods that produce or <a href="methodhandles.lookup"><code>lookup</code></a> VarHandle instances document the set of access modes that are supported, which may also include documenting restrictions based on the variable type and whether a variable is read-only. If an access mode is not supported then the corresponding access mode method will on invocation throw an <code>UnsupportedOperationException</code>. Factory methods should document any additional undeclared exceptions that may be thrown by access mode methods. The <a href="#get(java.lang.Object...)"><code>get</code></a> access mode is supported for all VarHandle instances and the corresponding method never throws <code>UnsupportedOperationException</code>. If a VarHandle references a read-only variable (for example a <code>final</code> field) then write, atomic update, numeric atomic update, and bitwise atomic update access modes are not supported and corresponding methods throw <code>UnsupportedOperationException</code>. Read/write access modes (if supported), with the exception of <code>get</code> and <code>set</code>, provide atomic access for reference types and all primitive types. Unless stated otherwise in the documentation of a factory method, the access modes <code>get</code> and <code>set</code> (if supported) provide atomic access for reference types and all primitives types, with the exception of <code>long</code> and <code>double</code> on 32-bit platforms. </p>
<p>Access modes will override any memory ordering effects specified at the declaration site of a variable. For example, a VarHandle accessing a field using the <code>get</code> access mode will access the field as specified <em>by its access mode</em> even if that field is declared <code>volatile</code>. When mixed access is performed extreme care should be taken since the Java Memory Model may permit surprising results. </p>
<p>In addition to supporting access to variables under various access modes, a set of static methods, referred to as memory fence methods, is also provided for fine-grained control of memory ordering. The Java Language Specification permits other threads to observe operations as if they were executed in orders different than are apparent in program source code, subject to constraints arising, for example, from the use of locks, <code>volatile</code> fields or VarHandles. The static methods, <a href="#fullFence()"><code>fullFence</code></a>, <a href="#acquireFence()"><code>acquireFence</code></a>, <a href="#releaseFence()"><code>releaseFence</code></a>, <a href="#loadLoadFence()"><code>loadLoadFence</code></a> and <a href="#storeStoreFence()"><code>storeStoreFence</code></a>, can also be used to impose constraints. Their specifications, as is the case for certain access modes, are phrased in terms of the lack of "reorderings" -- observable ordering effects that might otherwise occur if the fence was not present. More precise phrasing of the specification of access mode methods and memory fence methods may accompany future updates of the Java Language Specification. </p>
<h1>Compiling invocation of access mode methods</h1> A Java method call expression naming an access mode method can invoke a VarHandle from Java source code. From the viewpoint of source code, these methods can take any arguments and their polymorphic result (if expressed) can be cast to any return type. Formally this is accomplished by giving the access mode methods variable arity <code>Object</code> arguments and <code>Object</code> return types (if the return type is polymorphic), but they have an additional quality called <em>signature polymorphism</em> which connects this freedom of invocation directly to the JVM execution stack. <p> As is usual with virtual methods, source-level calls to access mode methods compile to an <code>invokevirtual</code> instruction. More unusually, the compiler must record the actual argument types, and may not perform method invocation conversions on the arguments. Instead, it must generate instructions to push them on the stack according to their own unconverted types. The VarHandle object itself will be pushed on the stack before the arguments. The compiler then generates an <code>invokevirtual</code> instruction that invokes the access mode method with a symbolic type descriptor which describes the argument and return types. </p>
<p> To issue a complete symbolic type descriptor, the compiler must also determine the return type (if polymorphic). This is based on a cast on the method invocation expression, if there is one, or else <code>Object</code> if the invocation is an expression, or else <code>void</code> if the invocation is a statement. The cast may be to a primitive type (but not <code>void</code>). </p>
<p> As a corner case, an uncasted <code>null</code> argument is given a symbolic type descriptor of <code>java.lang.Void</code>. The ambiguity with the type <code>Void</code> is harmless, since there are no references of type <code>Void</code> except the null reference. </p>
<h1><a id="invoke">Performing invocation of access mode methods</a></h1> The first time an <code>invokevirtual</code> instruction is executed it is linked by symbolically resolving the names in the instruction and verifying that the method call is statically legal. This also holds for calls to access mode methods. In this case, the symbolic type descriptor emitted by the compiler is checked for correct syntax, and names it contains are resolved. Thus, an <code>invokevirtual</code> instruction which invokes an access mode method will always link, as long as the symbolic type descriptor is syntactically well-formed and the types exist. <p> When the <code>invokevirtual</code> is executed after linking, the receiving VarHandle's access mode type is first checked by the JVM to ensure that it matches the symbolic type descriptor. If the type match fails, it means that the access mode method which the caller is invoking is not present on the individual VarHandle being invoked. </p>
<p> Invocation of an access mode method behaves as if an invocation of <a href="methodhandle#invoke(java.lang.Object...)"><code>MethodHandle.invoke(java.lang.Object...)</code></a>, where the receiving method handle accepts the VarHandle instance as the leading argument. More specifically, the following, where <code>{access-mode}</code> corresponds to the access mode method name: </p>
<pre data-language="java">VarHandle vh = ..
 R r = (R) vh.{access-mode}(p1, p2, ..., pN);</pre> behaves as if: <pre data-language="java">VarHandle vh = ..
 VarHandle.AccessMode am = VarHandle.AccessMode.valueFromMethodName("{access-mode}");
 MethodHandle mh = MethodHandles.varHandleExactInvoker(
                       am,
                       vh.accessModeType(am));

 R r = (R) mh.invoke(vh, p1, p2, ..., pN)</pre> (modulo access mode methods do not declare throwing of <code>Throwable</code>). This is equivalent to: <pre data-language="java">MethodHandle mh = MethodHandles.lookup().findVirtual(
                       VarHandle.class,
                       "{access-mode}",
                       MethodType.methodType(R, p1, p2, ..., pN));

 R r = (R) mh.invokeExact(vh, p1, p2, ..., pN)</pre> where the desired method type is the symbolic type descriptor and a <a href="methodhandle#invokeExact(java.lang.Object...)"><code>MethodHandle.invokeExact(java.lang.Object...)</code></a> is performed, since before invocation of the target, the handle will apply reference casts as necessary and box, unbox, or widen primitive values, as if by <a href="methodhandle#asType(java.lang.invoke.MethodType)"><code>asType</code></a> (see also <a href="methodhandles#varHandleInvoker(java.lang.invoke.VarHandle.AccessMode,java.lang.invoke.MethodType)"><code>MethodHandles.varHandleInvoker(java.lang.invoke.VarHandle.AccessMode, java.lang.invoke.MethodType)</code></a>). More concisely, such behaviour is equivalent to: <pre data-language="java">VarHandle vh = ..
 VarHandle.AccessMode am = VarHandle.AccessMode.valueFromMethodName("{access-mode}");
 MethodHandle mh = vh.toMethodHandle(am);

 R r = (R) mh.invoke(p1, p2, ..., pN)</pre> Where, in this case, the method handle is bound to the VarHandle instance. <h1>Invocation checking</h1> In typical programs, VarHandle access mode type matching will usually succeed. But if a match fails, the JVM will throw a <a href="wrongmethodtypeexception"><code>WrongMethodTypeException</code></a>. <p> Thus, an access mode type mismatch which might show up as a linkage error in a statically typed program can show up as a dynamic <code>WrongMethodTypeException</code> in a program which uses VarHandles. </p>
<p> Because access mode types contain "live" <code>Class</code> objects, method type matching takes into account both type names and class loaders. Thus, even if a VarHandle <code>VH</code> is created in one class loader <code>L1</code> and used in another <code>L2</code>, VarHandle access mode method calls are type-safe, because the caller's symbolic type descriptor, as resolved in <code>L2</code>, is matched against the original callee method's symbolic type descriptor, as resolved in <code>L1</code>. The resolution in <code>L1</code> happens when <code>VH</code> is created and its access mode types are assigned, while the resolution in <code>L2</code> happens when the <code>invokevirtual</code> instruction is linked. </p>
<p> Apart from type descriptor checks, a VarHandles's capability to access it's variables is unrestricted. If a VarHandle is formed on a non-public variable by a class that has access to that variable, the resulting VarHandle can be used in any place by any caller who receives a reference to it. </p>
<p> Unlike with the Core Reflection API, where access is checked every time a reflective method is invoked, VarHandle access checking is performed <a href="methodhandles.lookup#access">when the VarHandle is created</a>. Thus, VarHandles to non-public variables, or to variables in non-public classes, should generally be kept secret. They should not be passed to untrusted code unless their use from the untrusted code would be harmless. </p>
<h1>VarHandle creation</h1> Java code can create a VarHandle that directly accesses any field that is accessible to that code. This is done via a reflective, capability-based API called <a href="methodhandles.lookup"><code>MethodHandles.Lookup</code></a>. For example, a VarHandle for a non-static field can be obtained from <a href="methodhandles.lookup#findVarHandle(java.lang.Class,java.lang.String,java.lang.Class)"><code>Lookup.findVarHandle</code></a>. There is also a conversion method from Core Reflection API objects, <a href="methodhandles.lookup#unreflectVarHandle(java.lang.reflect.Field)"><code>Lookup.unreflectVarHandle</code></a>. <p> Access to protected field members is restricted to receivers only of the accessing class, or one of its subclasses, and the accessing class must in turn be a subclass (or package sibling) of the protected member's defining class. If a VarHandle refers to a protected non-static field of a declaring class outside the current package, the receiver argument will be narrowed to the type of the accessing class. </p>
<h1>Interoperation between VarHandles and the Core Reflection API</h1> Using factory methods in the <a href="methodhandles.lookup"><code>Lookup</code></a> API, any field represented by a Core Reflection API object can be converted to a behaviorally equivalent VarHandle. For example, a reflective <a href="../reflect/field"><code>Field</code></a> can be converted to a VarHandle using <a href="methodhandles.lookup#unreflectVarHandle(java.lang.reflect.Field)"><code>Lookup.unreflectVarHandle</code></a>. The resulting VarHandles generally provide more direct and efficient access to the underlying fields. <p> As a special case, when the Core Reflection API is used to view the signature polymorphic access mode methods in this class, they appear as ordinary non-polymorphic methods. Their reflective appearance, as viewed by <a href="../class#getDeclaredMethod(java.lang.String,java.lang.Class...)"><code>Class.getDeclaredMethod</code></a>, is unaffected by their special status in this API. For example, <a href="../reflect/executable#getModifiers()"><code>Method.getModifiers</code></a> will report exactly those modifier bits required for any similarly declared method, including in this case <code>native</code> and <code>varargs</code> bits. </p>
<p> As with any reflected method, these methods (when reflected) may be invoked directly via <a href="../reflect/method#invoke(java.lang.Object,java.lang.Object...)"><code>java.lang.reflect.Method.invoke</code></a>, via JNI, or indirectly via <a href="methodhandles.lookup#unreflect(java.lang.reflect.Method)"><code>Lookup.unreflect</code></a>. However, such reflective calls do not result in access mode method invocations. Such a call, if passed the required argument (a single one, of type <code>Object[]</code>), will ignore the argument and will throw an <code>UnsupportedOperationException</code>. </p>
<p> Since <code>invokevirtual</code> instructions can natively invoke VarHandle access mode methods under any symbolic type descriptor, this reflective view conflicts with the normal presentation of these methods via bytecodes. Thus, these native methods, when reflectively viewed by <code>Class.getDeclaredMethod</code>, may be regarded as placeholders only. </p>
<p> In order to obtain an invoker method for a particular access mode type, use <a href="methodhandles#varHandleExactInvoker(java.lang.invoke.VarHandle.AccessMode,java.lang.invoke.MethodType)"><code>MethodHandles.varHandleExactInvoker(java.lang.invoke.VarHandle.AccessMode, java.lang.invoke.MethodType)</code></a> or <a href="methodhandles#varHandleInvoker(java.lang.invoke.VarHandle.AccessMode,java.lang.invoke.MethodType)"><code>MethodHandles.varHandleInvoker(java.lang.invoke.VarHandle.AccessMode, java.lang.invoke.MethodType)</code></a>. The <a href="methodhandles.lookup#findVirtual(java.lang.Class,java.lang.String,java.lang.invoke.MethodType)"><code>Lookup.findVirtual</code></a> API is also able to return a method handle to call an access mode method for any specified access mode type and is equivalent in behaviour to <a href="methodhandles#varHandleInvoker(java.lang.invoke.VarHandle.AccessMode,java.lang.invoke.MethodType)"><code>MethodHandles.varHandleInvoker(java.lang.invoke.VarHandle.AccessMode, java.lang.invoke.MethodType)</code></a>. </p>
<h1>Interoperation between VarHandles and Java generics</h1> A VarHandle can be obtained for a variable, such as a field, which is declared with Java generic types. As with the Core Reflection API, the VarHandle's variable type will be constructed from the erasure of the source-level type. When a VarHandle access mode method is invoked, the types of its arguments or the return value cast type may be generic types or type instances. If this occurs, the compiler will replace those types by their erasures when it constructs the symbolic type descriptor for the <code>invokevirtual</code> instruction.</div> <dl> <dt>Since:</dt> <dd>9</dd> <dt>See Also:</dt> <dd>
<a href="methodhandle"><code>MethodHandle</code></a>, <a href="methodhandles"><code>MethodHandles</code></a>, <a href="methodtype"><code>MethodType</code></a>
</dd> </dl>      <section role="region">  <h2>Nested Class Summary</h2> <table> <caption>Nested Classes </caption> <tr> <th scope="col">Modifier and Type</th> <th scope="col">Class</th> <th scope="col">Description</th> </tr> <tr> <td><code>static class </code></td> <th scope="row"><code><a href="varhandle.accessmode">VarHandle.AccessMode</a></code></th> <td> <p>The set of access modes that specify how a variable, referenced by a VarHandle, is accessed.</p> </td> </tr> </table>  </section>  <section role="region">  <h2>Method Summary</h2> <table> <caption>All Methods <a href="javascript:show(1);">Static Methods</a> <a href="javascript:show(2);">Instance Methods</a> <a href="javascript:show(8);">Concrete Methods</a> </caption> <tr> <th scope="col">Modifier and Type</th> <th scope="col">Method</th> <th scope="col">Description</th> </tr> <tr id="i0"> <td><code><a href="methodtype">MethodType</a></code></td> <th scope="row"><code><a href="#accessModeType(java.lang.invoke.VarHandle.AccessMode)">accessModeType</a>​(<a href="varhandle.accessmode">VarHandle.AccessMode</a> accessMode)</code></th> <td> <p>Obtains the access mode type for this VarHandle and a given access mode.</p> </td> </tr> <tr id="i1"> <td><code>static void</code></td> <th scope="row"><code><a href="#acquireFence()">acquireFence</a>()</code></th> <td> <p>Ensures that loads before the fence will not be reordered with loads and stores after the fence.</p> </td> </tr> <tr id="i2"> <td><code><a href="../object">Object</a></code></td> <th scope="row"><code><a href="#compareAndExchange(java.lang.Object...)">compareAndExchange</a>​(<a href="../object">Object</a>... args)</code></th> <td> <p>Atomically sets the value of a variable to the <code>newValue</code> with the memory semantics of <a href="#setVolatile(java.lang.Object...)"><code>setVolatile(java.lang.Object...)</code></a> if the variable's current value, referred to as the <em>witness value</em>, <code>==</code> the <code>expectedValue</code>, as accessed with the memory semantics of <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(java.lang.Object...)</code></a>.</p> </td> </tr> <tr id="i3"> <td><code><a href="../object">Object</a></code></td> <th scope="row"><code><a href="#compareAndExchangeAcquire(java.lang.Object...)">compareAndExchangeAcquire</a>​(<a href="../object">Object</a>... args)</code></th> <td> <p>Atomically sets the value of a variable to the <code>newValue</code> with the memory semantics of <a href="#set(java.lang.Object...)"><code>set(java.lang.Object...)</code></a> if the variable's current value, referred to as the <em>witness value</em>, <code>==</code> the <code>expectedValue</code>, as accessed with the memory semantics of <a href="#getAcquire(java.lang.Object...)"><code>getAcquire(java.lang.Object...)</code></a>.</p> </td> </tr> <tr id="i4"> <td><code><a href="../object">Object</a></code></td> <th scope="row"><code><a href="#compareAndExchangeRelease(java.lang.Object...)">compareAndExchangeRelease</a>​(<a href="../object">Object</a>... args)</code></th> <td> <p>Atomically sets the value of a variable to the <code>newValue</code> with the memory semantics of <a href="#setRelease(java.lang.Object...)"><code>setRelease(java.lang.Object...)</code></a> if the variable's current value, referred to as the <em>witness value</em>, <code>==</code> the <code>expectedValue</code>, as accessed with the memory semantics of <a href="#get(java.lang.Object...)"><code>get(java.lang.Object...)</code></a>.</p> </td> </tr> <tr id="i5"> <td><code>boolean</code></td> <th scope="row"><code><a href="#compareAndSet(java.lang.Object...)">compareAndSet</a>​(<a href="../object">Object</a>... args)</code></th> <td> <p>Atomically sets the value of a variable to the <code>newValue</code> with the memory semantics of <a href="#setVolatile(java.lang.Object...)"><code>setVolatile(java.lang.Object...)</code></a> if the variable's current value, referred to as the <em>witness value</em>, <code>==</code> the <code>expectedValue</code>, as accessed with the memory semantics of <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(java.lang.Object...)</code></a>.</p> </td> </tr> <tr id="i6"> <td><code><a href="../../util/list">List</a>&lt;<a href="../class">Class</a>&lt;?&gt;&gt;</code></td> <th scope="row"><code><a href="#coordinateTypes()">coordinateTypes</a>()</code></th> <td> <p>Returns the coordinate types for this VarHandle.</p> </td> </tr> <tr id="i7"> <td><code>static void</code></td> <th scope="row"><code><a href="#fullFence()">fullFence</a>()</code></th> <td> <p>Ensures that loads and stores before the fence will not be reordered with loads and stores after the fence.</p> </td> </tr> <tr id="i8"> <td><code><a href="../object">Object</a></code></td> <th scope="row"><code><a href="#get(java.lang.Object...)">get</a>​(<a href="../object">Object</a>... args)</code></th> <td> <p>Returns the value of a variable, with memory semantics of reading as if the variable was declared non-<code>volatile</code>.</p> </td> </tr> <tr id="i9"> <td><code><a href="../object">Object</a></code></td> <th scope="row"><code><a href="#getAcquire(java.lang.Object...)">getAcquire</a>​(<a href="../object">Object</a>... args)</code></th> <td> <p>Returns the value of a variable, and ensures that subsequent loads and stores are not reordered before this access.</p> </td> </tr> <tr id="i10"> <td><code><a href="../object">Object</a></code></td> <th scope="row"><code><a href="#getAndAdd(java.lang.Object...)">getAndAdd</a>​(<a href="../object">Object</a>... args)</code></th> <td> <p>Atomically adds the <code>value</code> to the current value of a variable with the memory semantics of <a href="#setVolatile(java.lang.Object...)"><code>setVolatile(java.lang.Object...)</code></a>, and returns the variable's previous value, as accessed with the memory semantics of <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(java.lang.Object...)</code></a>.</p> </td> </tr> <tr id="i11"> <td><code><a href="../object">Object</a></code></td> <th scope="row"><code><a href="#getAndAddAcquire(java.lang.Object...)">getAndAddAcquire</a>​(<a href="../object">Object</a>... args)</code></th> <td> <p>Atomically adds the <code>value</code> to the current value of a variable with the memory semantics of <a href="#set(java.lang.Object...)"><code>set(java.lang.Object...)</code></a>, and returns the variable's previous value, as accessed with the memory semantics of <a href="#getAcquire(java.lang.Object...)"><code>getAcquire(java.lang.Object...)</code></a>.</p> </td> </tr> <tr id="i12"> <td><code><a href="../object">Object</a></code></td> <th scope="row"><code><a href="#getAndAddRelease(java.lang.Object...)">getAndAddRelease</a>​(<a href="../object">Object</a>... args)</code></th> <td> <p>Atomically adds the <code>value</code> to the current value of a variable with the memory semantics of <a href="#setRelease(java.lang.Object...)"><code>setRelease(java.lang.Object...)</code></a>, and returns the variable's previous value, as accessed with the memory semantics of <a href="#get(java.lang.Object...)"><code>get(java.lang.Object...)</code></a>.</p> </td> </tr> <tr id="i13"> <td><code><a href="../object">Object</a></code></td> <th scope="row"><code><a href="#getAndBitwiseAnd(java.lang.Object...)">getAndBitwiseAnd</a>​(<a href="../object">Object</a>... args)</code></th> <td> <p>Atomically sets the value of a variable to the result of bitwise AND between the variable's current value and the <code>mask</code> with the memory semantics of <a href="#setVolatile(java.lang.Object...)"><code>setVolatile(java.lang.Object...)</code></a> and returns the variable's previous value, as accessed with the memory semantics of <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(java.lang.Object...)</code></a>.</p> </td> </tr> <tr id="i14"> <td><code><a href="../object">Object</a></code></td> <th scope="row"><code><a href="#getAndBitwiseAndAcquire(java.lang.Object...)">getAndBitwiseAndAcquire</a>​(<a href="../object">Object</a>... args)</code></th> <td> <p>Atomically sets the value of a variable to the result of bitwise AND between the variable's current value and the <code>mask</code> with the memory semantics of <a href="#set(java.lang.Object...)"><code>set(java.lang.Object...)</code></a> and returns the variable's previous value, as accessed with the memory semantics of <a href="#getAcquire(java.lang.Object...)"><code>getAcquire(java.lang.Object...)</code></a>.</p> </td> </tr> <tr id="i15"> <td><code><a href="../object">Object</a></code></td> <th scope="row"><code><a href="#getAndBitwiseAndRelease(java.lang.Object...)">getAndBitwiseAndRelease</a>​(<a href="../object">Object</a>... args)</code></th> <td> <p>Atomically sets the value of a variable to the result of bitwise AND between the variable's current value and the <code>mask</code> with the memory semantics of <a href="#setRelease(java.lang.Object...)"><code>setRelease(java.lang.Object...)</code></a> and returns the variable's previous value, as accessed with the memory semantics of <a href="#get(java.lang.Object...)"><code>get(java.lang.Object...)</code></a>.</p> </td> </tr> <tr id="i16"> <td><code><a href="../object">Object</a></code></td> <th scope="row"><code><a href="#getAndBitwiseOr(java.lang.Object...)">getAndBitwiseOr</a>​(<a href="../object">Object</a>... args)</code></th> <td> <p>Atomically sets the value of a variable to the result of bitwise OR between the variable's current value and the <code>mask</code> with the memory semantics of <a href="#setVolatile(java.lang.Object...)"><code>setVolatile(java.lang.Object...)</code></a> and returns the variable's previous value, as accessed with the memory semantics of <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(java.lang.Object...)</code></a>.</p> </td> </tr> <tr id="i17"> <td><code><a href="../object">Object</a></code></td> <th scope="row"><code><a href="#getAndBitwiseOrAcquire(java.lang.Object...)">getAndBitwiseOrAcquire</a>​(<a href="../object">Object</a>... args)</code></th> <td> <p>Atomically sets the value of a variable to the result of bitwise OR between the variable's current value and the <code>mask</code> with the memory semantics of <a href="#set(java.lang.Object...)"><code>set(java.lang.Object...)</code></a> and returns the variable's previous value, as accessed with the memory semantics of <a href="#getAcquire(java.lang.Object...)"><code>getAcquire(java.lang.Object...)</code></a>.</p> </td> </tr> <tr id="i18"> <td><code><a href="../object">Object</a></code></td> <th scope="row"><code><a href="#getAndBitwiseOrRelease(java.lang.Object...)">getAndBitwiseOrRelease</a>​(<a href="../object">Object</a>... args)</code></th> <td> <p>Atomically sets the value of a variable to the result of bitwise OR between the variable's current value and the <code>mask</code> with the memory semantics of <a href="#setRelease(java.lang.Object...)"><code>setRelease(java.lang.Object...)</code></a> and returns the variable's previous value, as accessed with the memory semantics of <a href="#get(java.lang.Object...)"><code>get(java.lang.Object...)</code></a>.</p> </td> </tr> <tr id="i19"> <td><code><a href="../object">Object</a></code></td> <th scope="row"><code><a href="#getAndBitwiseXor(java.lang.Object...)">getAndBitwiseXor</a>​(<a href="../object">Object</a>... args)</code></th> <td> <p>Atomically sets the value of a variable to the result of bitwise XOR between the variable's current value and the <code>mask</code> with the memory semantics of <a href="#setVolatile(java.lang.Object...)"><code>setVolatile(java.lang.Object...)</code></a> and returns the variable's previous value, as accessed with the memory semantics of <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(java.lang.Object...)</code></a>.</p> </td> </tr> <tr id="i20"> <td><code><a href="../object">Object</a></code></td> <th scope="row"><code><a href="#getAndBitwiseXorAcquire(java.lang.Object...)">getAndBitwiseXorAcquire</a>​(<a href="../object">Object</a>... args)</code></th> <td> <p>Atomically sets the value of a variable to the result of bitwise XOR between the variable's current value and the <code>mask</code> with the memory semantics of <a href="#set(java.lang.Object...)"><code>set(java.lang.Object...)</code></a> and returns the variable's previous value, as accessed with the memory semantics of <a href="#getAcquire(java.lang.Object...)"><code>getAcquire(java.lang.Object...)</code></a>.</p> </td> </tr> <tr id="i21"> <td><code><a href="../object">Object</a></code></td> <th scope="row"><code><a href="#getAndBitwiseXorRelease(java.lang.Object...)">getAndBitwiseXorRelease</a>​(<a href="../object">Object</a>... args)</code></th> <td> <p>Atomically sets the value of a variable to the result of bitwise XOR between the variable's current value and the <code>mask</code> with the memory semantics of <a href="#setRelease(java.lang.Object...)"><code>setRelease(java.lang.Object...)</code></a> and returns the variable's previous value, as accessed with the memory semantics of <a href="#get(java.lang.Object...)"><code>get(java.lang.Object...)</code></a>.</p> </td> </tr> <tr id="i22"> <td><code><a href="../object">Object</a></code></td> <th scope="row"><code><a href="#getAndSet(java.lang.Object...)">getAndSet</a>​(<a href="../object">Object</a>... args)</code></th> <td> <p>Atomically sets the value of a variable to the <code>newValue</code> with the memory semantics of <a href="#setVolatile(java.lang.Object...)"><code>setVolatile(java.lang.Object...)</code></a> and returns the variable's previous value, as accessed with the memory semantics of <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(java.lang.Object...)</code></a>.</p> </td> </tr> <tr id="i23"> <td><code><a href="../object">Object</a></code></td> <th scope="row"><code><a href="#getAndSetAcquire(java.lang.Object...)">getAndSetAcquire</a>​(<a href="../object">Object</a>... args)</code></th> <td> <p>Atomically sets the value of a variable to the <code>newValue</code> with the memory semantics of <a href="#set(java.lang.Object...)"><code>set(java.lang.Object...)</code></a> and returns the variable's previous value, as accessed with the memory semantics of <a href="#getAcquire(java.lang.Object...)"><code>getAcquire(java.lang.Object...)</code></a>.</p> </td> </tr> <tr id="i24"> <td><code><a href="../object">Object</a></code></td> <th scope="row"><code><a href="#getAndSetRelease(java.lang.Object...)">getAndSetRelease</a>​(<a href="../object">Object</a>... args)</code></th> <td> <p>Atomically sets the value of a variable to the <code>newValue</code> with the memory semantics of <a href="#setRelease(java.lang.Object...)"><code>setRelease(java.lang.Object...)</code></a> and returns the variable's previous value, as accessed with the memory semantics of <a href="#get(java.lang.Object...)"><code>get(java.lang.Object...)</code></a>.</p> </td> </tr> <tr id="i25"> <td><code><a href="../object">Object</a></code></td> <th scope="row"><code><a href="#getOpaque(java.lang.Object...)">getOpaque</a>​(<a href="../object">Object</a>... args)</code></th> <td> <p>Returns the value of a variable, accessed in program order, but with no assurance of memory ordering effects with respect to other threads.</p> </td> </tr> <tr id="i26"> <td><code><a href="../object">Object</a></code></td> <th scope="row"><code><a href="#getVolatile(java.lang.Object...)">getVolatile</a>​(<a href="../object">Object</a>... args)</code></th> <td> <p>Returns the value of a variable, with memory semantics of reading as if the variable was declared <code>volatile</code>.</p> </td> </tr> <tr id="i27"> <td><code>boolean</code></td> <th scope="row"><code><a href="#isAccessModeSupported(java.lang.invoke.VarHandle.AccessMode)">isAccessModeSupported</a>​(<a href="varhandle.accessmode">VarHandle.AccessMode</a> accessMode)</code></th> <td> <p>Returns <code>true</code> if the given access mode is supported, otherwise <code>false</code>.</p> </td> </tr> <tr id="i28"> <td><code>static void</code></td> <th scope="row"><code><a href="#loadLoadFence()">loadLoadFence</a>()</code></th> <td> <p>Ensures that loads before the fence will not be reordered with loads after the fence.</p> </td> </tr> <tr id="i29"> <td><code>static void</code></td> <th scope="row"><code><a href="#releaseFence()">releaseFence</a>()</code></th> <td> <p>Ensures that loads and stores before the fence will not be reordered with stores after the fence.</p> </td> </tr> <tr id="i30"> <td><code>void</code></td> <th scope="row"><code><a href="#set(java.lang.Object...)">set</a>​(<a href="../object">Object</a>... args)</code></th> <td> <p>Sets the value of a variable to the <code>newValue</code>, with memory semantics of setting as if the variable was declared non-<code>volatile</code> and non-<code>final</code>.</p> </td> </tr> <tr id="i31"> <td><code>void</code></td> <th scope="row"><code><a href="#setOpaque(java.lang.Object...)">setOpaque</a>​(<a href="../object">Object</a>... args)</code></th> <td> <p>Sets the value of a variable to the <code>newValue</code>, in program order, but with no assurance of memory ordering effects with respect to other threads.</p> </td> </tr> <tr id="i32"> <td><code>void</code></td> <th scope="row"><code><a href="#setRelease(java.lang.Object...)">setRelease</a>​(<a href="../object">Object</a>... args)</code></th> <td> <p>Sets the value of a variable to the <code>newValue</code>, and ensures that prior loads and stores are not reordered after this access.</p> </td> </tr> <tr id="i33"> <td><code>void</code></td> <th scope="row"><code><a href="#setVolatile(java.lang.Object...)">setVolatile</a>​(<a href="../object">Object</a>... args)</code></th> <td> <p>Sets the value of a variable to the <code>newValue</code>, with memory semantics of setting as if the variable was declared <code>volatile</code>.</p> </td> </tr> <tr id="i34"> <td><code>static void</code></td> <th scope="row"><code><a href="#storeStoreFence()">storeStoreFence</a>()</code></th> <td> <p>Ensures that stores before the fence will not be reordered with stores after the fence.</p> </td> </tr> <tr id="i35"> <td><code><a href="methodhandle">MethodHandle</a></code></td> <th scope="row"><code><a href="#toMethodHandle(java.lang.invoke.VarHandle.AccessMode)">toMethodHandle</a>​(<a href="varhandle.accessmode">VarHandle.AccessMode</a> accessMode)</code></th> <td> <p>Obtains a method handle bound to this VarHandle and the given access mode.</p> </td> </tr> <tr id="i36"> <td><code><a href="../class">Class</a>&lt;?&gt;</code></td> <th scope="row"><code><a href="#varType()">varType</a>()</code></th> <td> <p>Returns the variable type of variables referenced by this VarHandle.</p> </td> </tr> <tr id="i37"> <td><code>boolean</code></td> <th scope="row"><code><a href="#weakCompareAndSet(java.lang.Object...)">weakCompareAndSet</a>​(<a href="../object">Object</a>... args)</code></th> <td> <p>Possibly atomically sets the value of a variable to the <code>newValue</code> with the memory semantics of <a href="#setVolatile(java.lang.Object...)"><code>setVolatile(java.lang.Object...)</code></a> if the variable's current value, referred to as the <em>witness value</em>, <code>==</code> the <code>expectedValue</code>, as accessed with the memory semantics of <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(java.lang.Object...)</code></a>.</p> </td> </tr> <tr id="i38"> <td><code>boolean</code></td> <th scope="row"><code><a href="#weakCompareAndSetAcquire(java.lang.Object...)">weakCompareAndSetAcquire</a>​(<a href="../object">Object</a>... args)</code></th> <td> <p>Possibly atomically sets the value of a variable to the <code>newValue</code> with the semantics of <a href="#set(java.lang.Object...)"><code>set(java.lang.Object...)</code></a> if the variable's current value, referred to as the <em>witness value</em>, <code>==</code> the <code>expectedValue</code>, as accessed with the memory semantics of <a href="#getAcquire(java.lang.Object...)"><code>getAcquire(java.lang.Object...)</code></a>.</p> </td> </tr> <tr id="i39"> <td><code>boolean</code></td> <th scope="row"><code><a href="#weakCompareAndSetPlain(java.lang.Object...)">weakCompareAndSetPlain</a>​(<a href="../object">Object</a>... args)</code></th> <td> <p>Possibly atomically sets the value of a variable to the <code>newValue</code> with the semantics of <a href="#set(java.lang.Object...)"><code>set(java.lang.Object...)</code></a> if the variable's current value, referred to as the <em>witness value</em>, <code>==</code> the <code>expectedValue</code>, as accessed with the memory semantics of <a href="#get(java.lang.Object...)"><code>get(java.lang.Object...)</code></a>.</p> </td> </tr> <tr id="i40"> <td><code>boolean</code></td> <th scope="row"><code><a href="#weakCompareAndSetRelease(java.lang.Object...)">weakCompareAndSetRelease</a>​(<a href="../object">Object</a>... args)</code></th> <td> <p>Possibly atomically sets the value of a variable to the <code>newValue</code> with the semantics of <a href="#setRelease(java.lang.Object...)"><code>setRelease(java.lang.Object...)</code></a> if the variable's current value, referred to as the <em>witness value</em>, <code>==</code> the <code>expectedValue</code>, as accessed with the memory semantics of <a href="#get(java.lang.Object...)"><code>get(java.lang.Object...)</code></a>.</p> </td> </tr> </table>  <h2>Methods declared in class java.lang.<a href="../object">Object</a>
</h2> <code><a href="../object#clone()">clone</a>, <a href="../object#equals(java.lang.Object)">equals</a>, <a href="../object#finalize()">finalize</a>, <a href="../object#getClass()">getClass</a>, <a href="../object#hashCode()">hashCode</a>, <a href="../object#notify()">notify</a>, <a href="../object#notifyAll()">notifyAll</a>, <a href="../object#toString()">toString</a>, <a href="../object#wait()">wait</a>, <a href="../object#wait(long)">wait</a>, <a href="../object#wait(long,int)">wait</a></code>  </section>   <div>   <section role="region">  <h2>Method Detail</h2>   <h3>get</h3> <pre data-language="java">public final Object get​(Object... args)</pre> <div>
<p>Returns the value of a variable, with memory semantics of reading as if the variable was declared non-<code>volatile</code>. Commonly referred to as plain read access. </p>
<p>The method signature is of the form <code>(CT1 ct1, ..., CTn ctn)T</code>. </p>
<p>The symbolic type descriptor at the call site of <code>get</code> must match the access mode type that is the result of calling <code>accessModeType(VarHandle.AccessMode.GET)</code> on this VarHandle. </p>
<p>This access mode is supported by all VarHandle instances and never throws <code>UnsupportedOperationException</code>.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>args</code> - the signature-polymorphic parameter list of the form <code>(CT1 ct1, ..., CTn)</code> , statically represented using varargs.</dd> <dt>Returns:</dt> <dd>the signature-polymorphic result that is the value of the variable , statically represented using <code>Object</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="wrongmethodtypeexception">WrongMethodTypeException</a></code> - if the access mode type does not match the caller's symbolic type descriptor.</dd> <dd>
<code><a href="../classcastexception">ClassCastException</a></code> - if the access mode type matches the caller's symbolic type descriptor, but a reference cast fails.</dd> </dl>    <h3>set</h3> <pre data-language="java">public final void set​(Object... args)</pre> <div>
<p>Sets the value of a variable to the <code>newValue</code>, with memory semantics of setting as if the variable was declared non-<code>volatile</code> and non-<code>final</code>. Commonly referred to as plain write access. </p>
<p>The method signature is of the form <code>(CT1 ct1, ..., CTn ctn, T newValue)void</code> </p>
<p>The symbolic type descriptor at the call site of <code>set</code> must match the access mode type that is the result of calling <code>accessModeType(VarHandle.AccessMode.SET)</code> on this VarHandle.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>args</code> - the signature-polymorphic parameter list of the form <code>(CT1 ct1, ..., CTn ctn, T newValue)</code> , statically represented using varargs.</dd> <dt>Throws:</dt> <dd>
<code><a href="../unsupportedoperationexception">UnsupportedOperationException</a></code> - if the access mode is unsupported for this VarHandle.</dd> <dd>
<code><a href="wrongmethodtypeexception">WrongMethodTypeException</a></code> - if the access mode type does not match the caller's symbolic type descriptor.</dd> <dd>
<code><a href="../classcastexception">ClassCastException</a></code> - if the access mode type matches the caller's symbolic type descriptor, but a reference cast fails.</dd> </dl>    <h3>getVolatile</h3> <pre data-language="java">public final Object getVolatile​(Object... args)</pre> <div>
<p>Returns the value of a variable, with memory semantics of reading as if the variable was declared <code>volatile</code>. </p>
<p>The method signature is of the form <code>(CT1 ct1, ..., CTn ctn)T</code>. </p>
<p>The symbolic type descriptor at the call site of <code>getVolatile</code> must match the access mode type that is the result of calling <code>accessModeType(VarHandle.AccessMode.GET_VOLATILE)</code> on this VarHandle.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>args</code> - the signature-polymorphic parameter list of the form <code>(CT1 ct1, ..., CTn ctn)</code> , statically represented using varargs.</dd> <dt>Returns:</dt> <dd>the signature-polymorphic result that is the value of the variable , statically represented using <code>Object</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../unsupportedoperationexception">UnsupportedOperationException</a></code> - if the access mode is unsupported for this VarHandle.</dd> <dd>
<code><a href="wrongmethodtypeexception">WrongMethodTypeException</a></code> - if the access mode type does not match the caller's symbolic type descriptor.</dd> <dd>
<code><a href="../classcastexception">ClassCastException</a></code> - if the access mode type matches the caller's symbolic type descriptor, but a reference cast fails.</dd> </dl>    <h3>setVolatile</h3> <pre data-language="java">public final void setVolatile​(Object... args)</pre> <div>
<p>Sets the value of a variable to the <code>newValue</code>, with memory semantics of setting as if the variable was declared <code>volatile</code>. </p>
<p>The method signature is of the form <code>(CT1 ct1, ..., CTn ctn, T newValue)void</code>. </p>
<p>The symbolic type descriptor at the call site of <code>setVolatile</code> must match the access mode type that is the result of calling <code>accessModeType(VarHandle.AccessMode.SET_VOLATILE)</code> on this VarHandle.</p>
</div> <dl> <dt>API Note:</dt> <dd>Ignoring the many semantic differences from C and C++, this method has memory ordering effects compatible with <code>memory_order_seq_cst</code>.</dd> <dt>Parameters:</dt> <dd>
<code>args</code> - the signature-polymorphic parameter list of the form <code>(CT1 ct1, ..., CTn ctn, T newValue)</code> , statically represented using varargs.</dd> <dt>Throws:</dt> <dd>
<code><a href="../unsupportedoperationexception">UnsupportedOperationException</a></code> - if the access mode is unsupported for this VarHandle.</dd> <dd>
<code><a href="wrongmethodtypeexception">WrongMethodTypeException</a></code> - if the access mode type does not match the caller's symbolic type descriptor.</dd> <dd>
<code><a href="../classcastexception">ClassCastException</a></code> - if the access mode type matches the caller's symbolic type descriptor, but a reference cast fails.</dd> </dl>    <h3>getOpaque</h3> <pre data-language="java">public final Object getOpaque​(Object... args)</pre> <div>
<p>Returns the value of a variable, accessed in program order, but with no assurance of memory ordering effects with respect to other threads. </p>
<p>The method signature is of the form <code>(CT1 ct1, ..., CTn ctn)T</code>. </p>
<p>The symbolic type descriptor at the call site of <code>getOpaque</code> must match the access mode type that is the result of calling <code>accessModeType(VarHandle.AccessMode.GET_OPAQUE)</code> on this VarHandle.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>args</code> - the signature-polymorphic parameter list of the form <code>(CT1 ct1, ..., CTn ctn)</code> , statically represented using varargs.</dd> <dt>Returns:</dt> <dd>the signature-polymorphic result that is the value of the variable , statically represented using <code>Object</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../unsupportedoperationexception">UnsupportedOperationException</a></code> - if the access mode is unsupported for this VarHandle.</dd> <dd>
<code><a href="wrongmethodtypeexception">WrongMethodTypeException</a></code> - if the access mode type does not match the caller's symbolic type descriptor.</dd> <dd>
<code><a href="../classcastexception">ClassCastException</a></code> - if the access mode type matches the caller's symbolic type descriptor, but a reference cast fails.</dd> </dl>    <h3>setOpaque</h3> <pre data-language="java">public final void setOpaque​(Object... args)</pre> <div>
<p>Sets the value of a variable to the <code>newValue</code>, in program order, but with no assurance of memory ordering effects with respect to other threads. </p>
<p>The method signature is of the form <code>(CT1 ct1, ..., CTn ctn, T newValue)void</code>. </p>
<p>The symbolic type descriptor at the call site of <code>setOpaque</code> must match the access mode type that is the result of calling <code>accessModeType(VarHandle.AccessMode.SET_OPAQUE)</code> on this VarHandle.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>args</code> - the signature-polymorphic parameter list of the form <code>(CT1 ct1, ..., CTn ctn, T newValue)</code> , statically represented using varargs.</dd> <dt>Throws:</dt> <dd>
<code><a href="../unsupportedoperationexception">UnsupportedOperationException</a></code> - if the access mode is unsupported for this VarHandle.</dd> <dd>
<code><a href="wrongmethodtypeexception">WrongMethodTypeException</a></code> - if the access mode type does not match the caller's symbolic type descriptor.</dd> <dd>
<code><a href="../classcastexception">ClassCastException</a></code> - if the access mode type matches the caller's symbolic type descriptor, but a reference cast fails.</dd> </dl>    <h3>getAcquire</h3> <pre data-language="java">public final Object getAcquire​(Object... args)</pre> <div>
<p>Returns the value of a variable, and ensures that subsequent loads and stores are not reordered before this access. </p>
<p>The method signature is of the form <code>(CT1 ct1, ..., CTn ctn)T</code>. </p>
<p>The symbolic type descriptor at the call site of <code>getAcquire</code> must match the access mode type that is the result of calling <code>accessModeType(VarHandle.AccessMode.GET_ACQUIRE)</code> on this VarHandle.</p>
</div> <dl> <dt>API Note:</dt> <dd>Ignoring the many semantic differences from C and C++, this method has memory ordering effects compatible with <code>memory_order_acquire</code> ordering.</dd> <dt>Parameters:</dt> <dd>
<code>args</code> - the signature-polymorphic parameter list of the form <code>(CT1 ct1, ..., CTn ctn)</code> , statically represented using varargs.</dd> <dt>Returns:</dt> <dd>the signature-polymorphic result that is the value of the variable , statically represented using <code>Object</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../unsupportedoperationexception">UnsupportedOperationException</a></code> - if the access mode is unsupported for this VarHandle.</dd> <dd>
<code><a href="wrongmethodtypeexception">WrongMethodTypeException</a></code> - if the access mode type does not match the caller's symbolic type descriptor.</dd> <dd>
<code><a href="../classcastexception">ClassCastException</a></code> - if the access mode type matches the caller's symbolic type descriptor, but a reference cast fails.</dd> </dl>    <h3>setRelease</h3> <pre data-language="java">public final void setRelease​(Object... args)</pre> <div>
<p>Sets the value of a variable to the <code>newValue</code>, and ensures that prior loads and stores are not reordered after this access. </p>
<p>The method signature is of the form <code>(CT1 ct1, ..., CTn ctn, T newValue)void</code>. </p>
<p>The symbolic type descriptor at the call site of <code>setRelease</code> must match the access mode type that is the result of calling <code>accessModeType(VarHandle.AccessMode.SET_RELEASE)</code> on this VarHandle.</p>
</div> <dl> <dt>API Note:</dt> <dd>Ignoring the many semantic differences from C and C++, this method has memory ordering effects compatible with <code>memory_order_release</code> ordering.</dd> <dt>Parameters:</dt> <dd>
<code>args</code> - the signature-polymorphic parameter list of the form <code>(CT1 ct1, ..., CTn ctn, T newValue)</code> , statically represented using varargs.</dd> <dt>Throws:</dt> <dd>
<code><a href="../unsupportedoperationexception">UnsupportedOperationException</a></code> - if the access mode is unsupported for this VarHandle.</dd> <dd>
<code><a href="wrongmethodtypeexception">WrongMethodTypeException</a></code> - if the access mode type does not match the caller's symbolic type descriptor.</dd> <dd>
<code><a href="../classcastexception">ClassCastException</a></code> - if the access mode type matches the caller's symbolic type descriptor, but a reference cast fails.</dd> </dl>    <h3>compareAndSet</h3> <pre data-language="java">public final boolean compareAndSet​(Object... args)</pre> <div>
<p>Atomically sets the value of a variable to the <code>newValue</code> with the memory semantics of <a href="#setVolatile(java.lang.Object...)"><code>setVolatile(java.lang.Object...)</code></a> if the variable's current value, referred to as the <em>witness value</em>, <code>==</code> the <code>expectedValue</code>, as accessed with the memory semantics of <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(java.lang.Object...)</code></a>. </p>
<p>The method signature is of the form <code>(CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)boolean</code>. </p>
<p>The symbolic type descriptor at the call site of <code>
 compareAndSet</code> must match the access mode type that is the result of calling <code>accessModeType(VarHandle.AccessMode.COMPARE_AND_SET)</code> on this VarHandle.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>args</code> - the signature-polymorphic parameter list of the form <code>(CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)</code> , statically represented using varargs.</dd> <dt>Returns:</dt> <dd>
<code>true</code> if successful, otherwise <code>false</code> if the witness value was not the same as the <code>expectedValue</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../unsupportedoperationexception">UnsupportedOperationException</a></code> - if the access mode is unsupported for this VarHandle.</dd> <dd>
<code><a href="wrongmethodtypeexception">WrongMethodTypeException</a></code> - if the access mode type does not match the caller's symbolic type descriptor.</dd> <dd>
<code><a href="../classcastexception">ClassCastException</a></code> - if the access mode type matches the caller's symbolic type descriptor, but a reference cast fails.</dd> <dt>See Also:</dt> <dd>
<a href="#setVolatile(java.lang.Object...)"><code>setVolatile(Object...)</code></a>, <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(Object...)</code></a>
</dd> </dl>    <h3>compareAndExchange</h3> <pre data-language="java">public final Object compareAndExchange​(Object... args)</pre> <div>
<p>Atomically sets the value of a variable to the <code>newValue</code> with the memory semantics of <a href="#setVolatile(java.lang.Object...)"><code>setVolatile(java.lang.Object...)</code></a> if the variable's current value, referred to as the <em>witness value</em>, <code>==</code> the <code>expectedValue</code>, as accessed with the memory semantics of <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(java.lang.Object...)</code></a>. </p>
<p>The method signature is of the form <code>(CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)T</code>. </p>
<p>The symbolic type descriptor at the call site of <code>
 compareAndExchange</code> must match the access mode type that is the result of calling <code>accessModeType(VarHandle.AccessMode.COMPARE_AND_EXCHANGE)</code> on this VarHandle.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>args</code> - the signature-polymorphic parameter list of the form <code>(CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)</code> , statically represented using varargs.</dd> <dt>Returns:</dt> <dd>the signature-polymorphic result that is the witness value, which will be the same as the <code>expectedValue</code> if successful , statically represented using <code>Object</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../unsupportedoperationexception">UnsupportedOperationException</a></code> - if the access mode is unsupported for this VarHandle.</dd> <dd>
<code><a href="wrongmethodtypeexception">WrongMethodTypeException</a></code> - if the access mode type is not compatible with the caller's symbolic type descriptor.</dd> <dd>
<code><a href="../classcastexception">ClassCastException</a></code> - if the access mode type is compatible with the caller's symbolic type descriptor, but a reference cast fails.</dd> <dt>See Also:</dt> <dd>
<a href="#setVolatile(java.lang.Object...)"><code>setVolatile(Object...)</code></a>, <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(Object...)</code></a>
</dd> </dl>    <h3>compareAndExchangeAcquire</h3> <pre data-language="java">public final Object compareAndExchangeAcquire​(Object... args)</pre> <div>
<p>Atomically sets the value of a variable to the <code>newValue</code> with the memory semantics of <a href="#set(java.lang.Object...)"><code>set(java.lang.Object...)</code></a> if the variable's current value, referred to as the <em>witness value</em>, <code>==</code> the <code>expectedValue</code>, as accessed with the memory semantics of <a href="#getAcquire(java.lang.Object...)"><code>getAcquire(java.lang.Object...)</code></a>. </p>
<p>The method signature is of the form <code>(CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)T</code>. </p>
<p>The symbolic type descriptor at the call site of <code>
 compareAndExchangeAcquire</code> must match the access mode type that is the result of calling <code>accessModeType(VarHandle.AccessMode.COMPARE_AND_EXCHANGE_ACQUIRE)</code> on this VarHandle.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>args</code> - the signature-polymorphic parameter list of the form <code>(CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)</code> , statically represented using varargs.</dd> <dt>Returns:</dt> <dd>the signature-polymorphic result that is the witness value, which will be the same as the <code>expectedValue</code> if successful , statically represented using <code>Object</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../unsupportedoperationexception">UnsupportedOperationException</a></code> - if the access mode is unsupported for this VarHandle.</dd> <dd>
<code><a href="wrongmethodtypeexception">WrongMethodTypeException</a></code> - if the access mode type does not match the caller's symbolic type descriptor.</dd> <dd>
<code><a href="../classcastexception">ClassCastException</a></code> - if the access mode type matches the caller's symbolic type descriptor, but a reference cast fails.</dd> <dt>See Also:</dt> <dd>
<a href="#set(java.lang.Object...)"><code>set(Object...)</code></a>, <a href="#getAcquire(java.lang.Object...)"><code>getAcquire(Object...)</code></a>
</dd> </dl>    <h3>compareAndExchangeRelease</h3> <pre data-language="java">public final Object compareAndExchangeRelease​(Object... args)</pre> <div>
<p>Atomically sets the value of a variable to the <code>newValue</code> with the memory semantics of <a href="#setRelease(java.lang.Object...)"><code>setRelease(java.lang.Object...)</code></a> if the variable's current value, referred to as the <em>witness value</em>, <code>==</code> the <code>expectedValue</code>, as accessed with the memory semantics of <a href="#get(java.lang.Object...)"><code>get(java.lang.Object...)</code></a>. </p>
<p>The method signature is of the form <code>(CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)T</code>. </p>
<p>The symbolic type descriptor at the call site of <code>
 compareAndExchangeRelease</code> must match the access mode type that is the result of calling <code>accessModeType(VarHandle.AccessMode.COMPARE_AND_EXCHANGE_RELEASE)</code> on this VarHandle.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>args</code> - the signature-polymorphic parameter list of the form <code>(CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)</code> , statically represented using varargs.</dd> <dt>Returns:</dt> <dd>the signature-polymorphic result that is the witness value, which will be the same as the <code>expectedValue</code> if successful , statically represented using <code>Object</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../unsupportedoperationexception">UnsupportedOperationException</a></code> - if the access mode is unsupported for this VarHandle.</dd> <dd>
<code><a href="wrongmethodtypeexception">WrongMethodTypeException</a></code> - if the access mode type does not match the caller's symbolic type descriptor.</dd> <dd>
<code><a href="../classcastexception">ClassCastException</a></code> - if the access mode type matches the caller's symbolic type descriptor, but a reference cast fails.</dd> <dt>See Also:</dt> <dd>
<a href="#setRelease(java.lang.Object...)"><code>setRelease(Object...)</code></a>, <a href="#get(java.lang.Object...)"><code>get(Object...)</code></a>
</dd> </dl>    <h3>weakCompareAndSetPlain</h3> <pre data-language="java">public final boolean weakCompareAndSetPlain​(Object... args)</pre> <div>
<p>Possibly atomically sets the value of a variable to the <code>newValue</code> with the semantics of <a href="#set(java.lang.Object...)"><code>set(java.lang.Object...)</code></a> if the variable's current value, referred to as the <em>witness value</em>, <code>==</code> the <code>expectedValue</code>, as accessed with the memory semantics of <a href="#get(java.lang.Object...)"><code>get(java.lang.Object...)</code></a>. </p>
<p>This operation may fail spuriously (typically, due to memory contention) even if the witness value does match the expected value. </p>
<p>The method signature is of the form <code>(CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)boolean</code>. </p>
<p>The symbolic type descriptor at the call site of <code>
 weakCompareAndSetPlain</code> must match the access mode type that is the result of calling <code>accessModeType(VarHandle.AccessMode.WEAK_COMPARE_AND_SET_PLAIN)</code> on this VarHandle.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>args</code> - the signature-polymorphic parameter list of the form <code>(CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)</code> , statically represented using varargs.</dd> <dt>Returns:</dt> <dd>
<code>true</code> if successful, otherwise <code>false</code> if the witness value was not the same as the <code>expectedValue</code> or if this operation spuriously failed.</dd> <dt>Throws:</dt> <dd>
<code><a href="../unsupportedoperationexception">UnsupportedOperationException</a></code> - if the access mode is unsupported for this VarHandle.</dd> <dd>
<code><a href="wrongmethodtypeexception">WrongMethodTypeException</a></code> - if the access mode type does not match the caller's symbolic type descriptor.</dd> <dd>
<code><a href="../classcastexception">ClassCastException</a></code> - if the access mode type matches the caller's symbolic type descriptor, but a reference cast fails.</dd> <dt>See Also:</dt> <dd>
<a href="#set(java.lang.Object...)"><code>set(Object...)</code></a>, <a href="#get(java.lang.Object...)"><code>get(Object...)</code></a>
</dd> </dl>    <h3>weakCompareAndSet</h3> <pre data-language="java">public final boolean weakCompareAndSet​(Object... args)</pre> <div>
<p>Possibly atomically sets the value of a variable to the <code>newValue</code> with the memory semantics of <a href="#setVolatile(java.lang.Object...)"><code>setVolatile(java.lang.Object...)</code></a> if the variable's current value, referred to as the <em>witness value</em>, <code>==</code> the <code>expectedValue</code>, as accessed with the memory semantics of <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(java.lang.Object...)</code></a>. </p>
<p>This operation may fail spuriously (typically, due to memory contention) even if the witness value does match the expected value. </p>
<p>The method signature is of the form <code>(CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)boolean</code>. </p>
<p>The symbolic type descriptor at the call site of <code>
 weakCompareAndSet</code> must match the access mode type that is the result of calling <code>accessModeType(VarHandle.AccessMode.WEAK_COMPARE_AND_SET)</code> on this VarHandle.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>args</code> - the signature-polymorphic parameter list of the form <code>(CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)</code> , statically represented using varargs.</dd> <dt>Returns:</dt> <dd>
<code>true</code> if successful, otherwise <code>false</code> if the witness value was not the same as the <code>expectedValue</code> or if this operation spuriously failed.</dd> <dt>Throws:</dt> <dd>
<code><a href="../unsupportedoperationexception">UnsupportedOperationException</a></code> - if the access mode is unsupported for this VarHandle.</dd> <dd>
<code><a href="wrongmethodtypeexception">WrongMethodTypeException</a></code> - if the access mode type does not match the caller's symbolic type descriptor.</dd> <dd>
<code><a href="../classcastexception">ClassCastException</a></code> - if the access mode type matches the caller's symbolic type descriptor, but a reference cast fails.</dd> <dt>See Also:</dt> <dd>
<a href="#setVolatile(java.lang.Object...)"><code>setVolatile(Object...)</code></a>, <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(Object...)</code></a>
</dd> </dl>    <h3>weakCompareAndSetAcquire</h3> <pre data-language="java">public final boolean weakCompareAndSetAcquire​(Object... args)</pre> <div>
<p>Possibly atomically sets the value of a variable to the <code>newValue</code> with the semantics of <a href="#set(java.lang.Object...)"><code>set(java.lang.Object...)</code></a> if the variable's current value, referred to as the <em>witness value</em>, <code>==</code> the <code>expectedValue</code>, as accessed with the memory semantics of <a href="#getAcquire(java.lang.Object...)"><code>getAcquire(java.lang.Object...)</code></a>. </p>
<p>This operation may fail spuriously (typically, due to memory contention) even if the witness value does match the expected value. </p>
<p>The method signature is of the form <code>(CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)boolean</code>. </p>
<p>The symbolic type descriptor at the call site of <code>
 weakCompareAndSetAcquire</code> must match the access mode type that is the result of calling <code>accessModeType(VarHandle.AccessMode.WEAK_COMPARE_AND_SET_ACQUIRE)</code> on this VarHandle.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>args</code> - the signature-polymorphic parameter list of the form <code>(CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)</code> , statically represented using varargs.</dd> <dt>Returns:</dt> <dd>
<code>true</code> if successful, otherwise <code>false</code> if the witness value was not the same as the <code>expectedValue</code> or if this operation spuriously failed.</dd> <dt>Throws:</dt> <dd>
<code><a href="../unsupportedoperationexception">UnsupportedOperationException</a></code> - if the access mode is unsupported for this VarHandle.</dd> <dd>
<code><a href="wrongmethodtypeexception">WrongMethodTypeException</a></code> - if the access mode type does not match the caller's symbolic type descriptor.</dd> <dd>
<code><a href="../classcastexception">ClassCastException</a></code> - if the access mode type matches the caller's symbolic type descriptor, but a reference cast fails.</dd> <dt>See Also:</dt> <dd>
<a href="#set(java.lang.Object...)"><code>set(Object...)</code></a>, <a href="#getAcquire(java.lang.Object...)"><code>getAcquire(Object...)</code></a>
</dd> </dl>    <h3>weakCompareAndSetRelease</h3> <pre data-language="java">public final boolean weakCompareAndSetRelease​(Object... args)</pre> <div>
<p>Possibly atomically sets the value of a variable to the <code>newValue</code> with the semantics of <a href="#setRelease(java.lang.Object...)"><code>setRelease(java.lang.Object...)</code></a> if the variable's current value, referred to as the <em>witness value</em>, <code>==</code> the <code>expectedValue</code>, as accessed with the memory semantics of <a href="#get(java.lang.Object...)"><code>get(java.lang.Object...)</code></a>. </p>
<p>This operation may fail spuriously (typically, due to memory contention) even if the witness value does match the expected value. </p>
<p>The method signature is of the form <code>(CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)boolean</code>. </p>
<p>The symbolic type descriptor at the call site of <code>
 weakCompareAndSetRelease</code> must match the access mode type that is the result of calling <code>accessModeType(VarHandle.AccessMode.WEAK_COMPARE_AND_SET_RELEASE)</code> on this VarHandle.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>args</code> - the signature-polymorphic parameter list of the form <code>(CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)</code> , statically represented using varargs.</dd> <dt>Returns:</dt> <dd>
<code>true</code> if successful, otherwise <code>false</code> if the witness value was not the same as the <code>expectedValue</code> or if this operation spuriously failed.</dd> <dt>Throws:</dt> <dd>
<code><a href="../unsupportedoperationexception">UnsupportedOperationException</a></code> - if the access mode is unsupported for this VarHandle.</dd> <dd>
<code><a href="wrongmethodtypeexception">WrongMethodTypeException</a></code> - if the access mode type does not match the caller's symbolic type descriptor.</dd> <dd>
<code><a href="../classcastexception">ClassCastException</a></code> - if the access mode type matches the caller's symbolic type descriptor, but a reference cast fails.</dd> <dt>See Also:</dt> <dd>
<a href="#setRelease(java.lang.Object...)"><code>setRelease(Object...)</code></a>, <a href="#get(java.lang.Object...)"><code>get(Object...)</code></a>
</dd> </dl>    <h3>getAndSet</h3> <pre data-language="java">public final Object getAndSet​(Object... args)</pre> <div>
<p>Atomically sets the value of a variable to the <code>newValue</code> with the memory semantics of <a href="#setVolatile(java.lang.Object...)"><code>setVolatile(java.lang.Object...)</code></a> and returns the variable's previous value, as accessed with the memory semantics of <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(java.lang.Object...)</code></a>. </p>
<p>The method signature is of the form <code>(CT1 ct1, ..., CTn ctn, T newValue)T</code>. </p>
<p>The symbolic type descriptor at the call site of <code>getAndSet</code> must match the access mode type that is the result of calling <code>accessModeType(VarHandle.AccessMode.GET_AND_SET)</code> on this VarHandle.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>args</code> - the signature-polymorphic parameter list of the form <code>(CT1 ct1, ..., CTn ctn, T newValue)</code> , statically represented using varargs.</dd> <dt>Returns:</dt> <dd>the signature-polymorphic result that is the previous value of the variable , statically represented using <code>Object</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../unsupportedoperationexception">UnsupportedOperationException</a></code> - if the access mode is unsupported for this VarHandle.</dd> <dd>
<code><a href="wrongmethodtypeexception">WrongMethodTypeException</a></code> - if the access mode type does not match the caller's symbolic type descriptor.</dd> <dd>
<code><a href="../classcastexception">ClassCastException</a></code> - if the access mode type matches the caller's symbolic type descriptor, but a reference cast fails.</dd> <dt>See Also:</dt> <dd>
<a href="#setVolatile(java.lang.Object...)"><code>setVolatile(Object...)</code></a>, <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(Object...)</code></a>
</dd> </dl>    <h3>getAndSetAcquire</h3> <pre data-language="java">public final Object getAndSetAcquire​(Object... args)</pre> <div>
<p>Atomically sets the value of a variable to the <code>newValue</code> with the memory semantics of <a href="#set(java.lang.Object...)"><code>set(java.lang.Object...)</code></a> and returns the variable's previous value, as accessed with the memory semantics of <a href="#getAcquire(java.lang.Object...)"><code>getAcquire(java.lang.Object...)</code></a>. </p>
<p>The method signature is of the form <code>(CT1 ct1, ..., CTn ctn, T newValue)T</code>. </p>
<p>The symbolic type descriptor at the call site of <code>getAndSetAcquire</code> must match the access mode type that is the result of calling <code>accessModeType(VarHandle.AccessMode.GET_AND_SET_ACQUIRE)</code> on this VarHandle.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>args</code> - the signature-polymorphic parameter list of the form <code>(CT1 ct1, ..., CTn ctn, T newValue)</code> , statically represented using varargs.</dd> <dt>Returns:</dt> <dd>the signature-polymorphic result that is the previous value of the variable , statically represented using <code>Object</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../unsupportedoperationexception">UnsupportedOperationException</a></code> - if the access mode is unsupported for this VarHandle.</dd> <dd>
<code><a href="wrongmethodtypeexception">WrongMethodTypeException</a></code> - if the access mode type does not match the caller's symbolic type descriptor.</dd> <dd>
<code><a href="../classcastexception">ClassCastException</a></code> - if the access mode type matches the caller's symbolic type descriptor, but a reference cast fails.</dd> <dt>See Also:</dt> <dd>
<a href="#setVolatile(java.lang.Object...)"><code>setVolatile(Object...)</code></a>, <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(Object...)</code></a>
</dd> </dl>    <h3>getAndSetRelease</h3> <pre data-language="java">public final Object getAndSetRelease​(Object... args)</pre> <div>
<p>Atomically sets the value of a variable to the <code>newValue</code> with the memory semantics of <a href="#setRelease(java.lang.Object...)"><code>setRelease(java.lang.Object...)</code></a> and returns the variable's previous value, as accessed with the memory semantics of <a href="#get(java.lang.Object...)"><code>get(java.lang.Object...)</code></a>. </p>
<p>The method signature is of the form <code>(CT1 ct1, ..., CTn ctn, T newValue)T</code>. </p>
<p>The symbolic type descriptor at the call site of <code>getAndSetRelease</code> must match the access mode type that is the result of calling <code>accessModeType(VarHandle.AccessMode.GET_AND_SET_RELEASE)</code> on this VarHandle.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>args</code> - the signature-polymorphic parameter list of the form <code>(CT1 ct1, ..., CTn ctn, T newValue)</code> , statically represented using varargs.</dd> <dt>Returns:</dt> <dd>the signature-polymorphic result that is the previous value of the variable , statically represented using <code>Object</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../unsupportedoperationexception">UnsupportedOperationException</a></code> - if the access mode is unsupported for this VarHandle.</dd> <dd>
<code><a href="wrongmethodtypeexception">WrongMethodTypeException</a></code> - if the access mode type does not match the caller's symbolic type descriptor.</dd> <dd>
<code><a href="../classcastexception">ClassCastException</a></code> - if the access mode type matches the caller's symbolic type descriptor, but a reference cast fails.</dd> <dt>See Also:</dt> <dd>
<a href="#setVolatile(java.lang.Object...)"><code>setVolatile(Object...)</code></a>, <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(Object...)</code></a>
</dd> </dl>    <h3>getAndAdd</h3> <pre data-language="java">public final Object getAndAdd​(Object... args)</pre> <div>
<p>Atomically adds the <code>value</code> to the current value of a variable with the memory semantics of <a href="#setVolatile(java.lang.Object...)"><code>setVolatile(java.lang.Object...)</code></a>, and returns the variable's previous value, as accessed with the memory semantics of <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(java.lang.Object...)</code></a>. </p>
<p>The method signature is of the form <code>(CT1 ct1, ..., CTn ctn, T value)T</code>. </p>
<p>The symbolic type descriptor at the call site of <code>getAndAdd</code> must match the access mode type that is the result of calling <code>accessModeType(VarHandle.AccessMode.GET_AND_ADD)</code> on this VarHandle.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>args</code> - the signature-polymorphic parameter list of the form <code>(CT1 ct1, ..., CTn ctn, T value)</code> , statically represented using varargs.</dd> <dt>Returns:</dt> <dd>the signature-polymorphic result that is the previous value of the variable , statically represented using <code>Object</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../unsupportedoperationexception">UnsupportedOperationException</a></code> - if the access mode is unsupported for this VarHandle.</dd> <dd>
<code><a href="wrongmethodtypeexception">WrongMethodTypeException</a></code> - if the access mode type does not match the caller's symbolic type descriptor.</dd> <dd>
<code><a href="../classcastexception">ClassCastException</a></code> - if the access mode type matches the caller's symbolic type descriptor, but a reference cast fails.</dd> <dt>See Also:</dt> <dd>
<a href="#setVolatile(java.lang.Object...)"><code>setVolatile(Object...)</code></a>, <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(Object...)</code></a>
</dd> </dl>    <h3>getAndAddAcquire</h3> <pre data-language="java">public final Object getAndAddAcquire​(Object... args)</pre> <div>
<p>Atomically adds the <code>value</code> to the current value of a variable with the memory semantics of <a href="#set(java.lang.Object...)"><code>set(java.lang.Object...)</code></a>, and returns the variable's previous value, as accessed with the memory semantics of <a href="#getAcquire(java.lang.Object...)"><code>getAcquire(java.lang.Object...)</code></a>. </p>
<p>The method signature is of the form <code>(CT1 ct1, ..., CTn ctn, T value)T</code>. </p>
<p>The symbolic type descriptor at the call site of <code>getAndAddAcquire</code> must match the access mode type that is the result of calling <code>accessModeType(VarHandle.AccessMode.GET_AND_ADD_ACQUIRE)</code> on this VarHandle.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>args</code> - the signature-polymorphic parameter list of the form <code>(CT1 ct1, ..., CTn ctn, T value)</code> , statically represented using varargs.</dd> <dt>Returns:</dt> <dd>the signature-polymorphic result that is the previous value of the variable , statically represented using <code>Object</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../unsupportedoperationexception">UnsupportedOperationException</a></code> - if the access mode is unsupported for this VarHandle.</dd> <dd>
<code><a href="wrongmethodtypeexception">WrongMethodTypeException</a></code> - if the access mode type does not match the caller's symbolic type descriptor.</dd> <dd>
<code><a href="../classcastexception">ClassCastException</a></code> - if the access mode type matches the caller's symbolic type descriptor, but a reference cast fails.</dd> <dt>See Also:</dt> <dd>
<a href="#setVolatile(java.lang.Object...)"><code>setVolatile(Object...)</code></a>, <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(Object...)</code></a>
</dd> </dl>    <h3>getAndAddRelease</h3> <pre data-language="java">public final Object getAndAddRelease​(Object... args)</pre> <div>
<p>Atomically adds the <code>value</code> to the current value of a variable with the memory semantics of <a href="#setRelease(java.lang.Object...)"><code>setRelease(java.lang.Object...)</code></a>, and returns the variable's previous value, as accessed with the memory semantics of <a href="#get(java.lang.Object...)"><code>get(java.lang.Object...)</code></a>. </p>
<p>The method signature is of the form <code>(CT1 ct1, ..., CTn ctn, T value)T</code>. </p>
<p>The symbolic type descriptor at the call site of <code>getAndAddRelease</code> must match the access mode type that is the result of calling <code>accessModeType(VarHandle.AccessMode.GET_AND_ADD_RELEASE)</code> on this VarHandle.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>args</code> - the signature-polymorphic parameter list of the form <code>(CT1 ct1, ..., CTn ctn, T value)</code> , statically represented using varargs.</dd> <dt>Returns:</dt> <dd>the signature-polymorphic result that is the previous value of the variable , statically represented using <code>Object</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../unsupportedoperationexception">UnsupportedOperationException</a></code> - if the access mode is unsupported for this VarHandle.</dd> <dd>
<code><a href="wrongmethodtypeexception">WrongMethodTypeException</a></code> - if the access mode type does not match the caller's symbolic type descriptor.</dd> <dd>
<code><a href="../classcastexception">ClassCastException</a></code> - if the access mode type matches the caller's symbolic type descriptor, but a reference cast fails.</dd> <dt>See Also:</dt> <dd>
<a href="#setVolatile(java.lang.Object...)"><code>setVolatile(Object...)</code></a>, <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(Object...)</code></a>
</dd> </dl>    <h3>getAndBitwiseOr</h3> <pre data-language="java">public final Object getAndBitwiseOr​(Object... args)</pre> <div>
<p>Atomically sets the value of a variable to the result of bitwise OR between the variable's current value and the <code>mask</code> with the memory semantics of <a href="#setVolatile(java.lang.Object...)"><code>setVolatile(java.lang.Object...)</code></a> and returns the variable's previous value, as accessed with the memory semantics of <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(java.lang.Object...)</code></a>. </p>
<p>If the variable type is the non-integral <code>boolean</code> type then a logical OR is performed instead of a bitwise OR. </p>
<p>The method signature is of the form <code>(CT1 ct1, ..., CTn ctn, T mask)T</code>. </p>
<p>The symbolic type descriptor at the call site of <code>getAndBitwiseOr</code> must match the access mode type that is the result of calling <code>accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_OR)</code> on this VarHandle.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>args</code> - the signature-polymorphic parameter list of the form <code>(CT1 ct1, ..., CTn ctn, T mask)</code> , statically represented using varargs.</dd> <dt>Returns:</dt> <dd>the signature-polymorphic result that is the previous value of the variable , statically represented using <code>Object</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../unsupportedoperationexception">UnsupportedOperationException</a></code> - if the access mode is unsupported for this VarHandle.</dd> <dd>
<code><a href="wrongmethodtypeexception">WrongMethodTypeException</a></code> - if the access mode type does not match the caller's symbolic type descriptor.</dd> <dd>
<code><a href="../classcastexception">ClassCastException</a></code> - if the access mode type matches the caller's symbolic type descriptor, but a reference cast fails.</dd> <dt>See Also:</dt> <dd>
<a href="#setVolatile(java.lang.Object...)"><code>setVolatile(Object...)</code></a>, <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(Object...)</code></a>
</dd> </dl>    <h3>getAndBitwiseOrAcquire</h3> <pre data-language="java">public final Object getAndBitwiseOrAcquire​(Object... args)</pre> <div>
<p>Atomically sets the value of a variable to the result of bitwise OR between the variable's current value and the <code>mask</code> with the memory semantics of <a href="#set(java.lang.Object...)"><code>set(java.lang.Object...)</code></a> and returns the variable's previous value, as accessed with the memory semantics of <a href="#getAcquire(java.lang.Object...)"><code>getAcquire(java.lang.Object...)</code></a>. </p>
<p>If the variable type is the non-integral <code>boolean</code> type then a logical OR is performed instead of a bitwise OR. </p>
<p>The method signature is of the form <code>(CT1 ct1, ..., CTn ctn, T mask)T</code>. </p>
<p>The symbolic type descriptor at the call site of <code>getAndBitwiseOrAcquire</code> must match the access mode type that is the result of calling <code>accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_OR_ACQUIRE)</code> on this VarHandle.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>args</code> - the signature-polymorphic parameter list of the form <code>(CT1 ct1, ..., CTn ctn, T mask)</code> , statically represented using varargs.</dd> <dt>Returns:</dt> <dd>the signature-polymorphic result that is the previous value of the variable , statically represented using <code>Object</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../unsupportedoperationexception">UnsupportedOperationException</a></code> - if the access mode is unsupported for this VarHandle.</dd> <dd>
<code><a href="wrongmethodtypeexception">WrongMethodTypeException</a></code> - if the access mode type does not match the caller's symbolic type descriptor.</dd> <dd>
<code><a href="../classcastexception">ClassCastException</a></code> - if the access mode type matches the caller's symbolic type descriptor, but a reference cast fails.</dd> <dt>See Also:</dt> <dd>
<a href="#set(java.lang.Object...)"><code>set(Object...)</code></a>, <a href="#getAcquire(java.lang.Object...)"><code>getAcquire(Object...)</code></a>
</dd> </dl>    <h3>getAndBitwiseOrRelease</h3> <pre data-language="java">public final Object getAndBitwiseOrRelease​(Object... args)</pre> <div>
<p>Atomically sets the value of a variable to the result of bitwise OR between the variable's current value and the <code>mask</code> with the memory semantics of <a href="#setRelease(java.lang.Object...)"><code>setRelease(java.lang.Object...)</code></a> and returns the variable's previous value, as accessed with the memory semantics of <a href="#get(java.lang.Object...)"><code>get(java.lang.Object...)</code></a>. </p>
<p>If the variable type is the non-integral <code>boolean</code> type then a logical OR is performed instead of a bitwise OR. </p>
<p>The method signature is of the form <code>(CT1 ct1, ..., CTn ctn, T mask)T</code>. </p>
<p>The symbolic type descriptor at the call site of <code>getAndBitwiseOrRelease</code> must match the access mode type that is the result of calling <code>accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_OR_RELEASE)</code> on this VarHandle.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>args</code> - the signature-polymorphic parameter list of the form <code>(CT1 ct1, ..., CTn ctn, T mask)</code> , statically represented using varargs.</dd> <dt>Returns:</dt> <dd>the signature-polymorphic result that is the previous value of the variable , statically represented using <code>Object</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../unsupportedoperationexception">UnsupportedOperationException</a></code> - if the access mode is unsupported for this VarHandle.</dd> <dd>
<code><a href="wrongmethodtypeexception">WrongMethodTypeException</a></code> - if the access mode type does not match the caller's symbolic type descriptor.</dd> <dd>
<code><a href="../classcastexception">ClassCastException</a></code> - if the access mode type matches the caller's symbolic type descriptor, but a reference cast fails.</dd> <dt>See Also:</dt> <dd>
<a href="#setRelease(java.lang.Object...)"><code>setRelease(Object...)</code></a>, <a href="#get(java.lang.Object...)"><code>get(Object...)</code></a>
</dd> </dl>    <h3>getAndBitwiseAnd</h3> <pre data-language="java">public final Object getAndBitwiseAnd​(Object... args)</pre> <div>
<p>Atomically sets the value of a variable to the result of bitwise AND between the variable's current value and the <code>mask</code> with the memory semantics of <a href="#setVolatile(java.lang.Object...)"><code>setVolatile(java.lang.Object...)</code></a> and returns the variable's previous value, as accessed with the memory semantics of <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(java.lang.Object...)</code></a>. </p>
<p>If the variable type is the non-integral <code>boolean</code> type then a logical AND is performed instead of a bitwise AND. </p>
<p>The method signature is of the form <code>(CT1 ct1, ..., CTn ctn, T mask)T</code>. </p>
<p>The symbolic type descriptor at the call site of <code>getAndBitwiseAnd</code> must match the access mode type that is the result of calling <code>accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_AND)</code> on this VarHandle.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>args</code> - the signature-polymorphic parameter list of the form <code>(CT1 ct1, ..., CTn ctn, T mask)</code> , statically represented using varargs.</dd> <dt>Returns:</dt> <dd>the signature-polymorphic result that is the previous value of the variable , statically represented using <code>Object</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../unsupportedoperationexception">UnsupportedOperationException</a></code> - if the access mode is unsupported for this VarHandle.</dd> <dd>
<code><a href="wrongmethodtypeexception">WrongMethodTypeException</a></code> - if the access mode type does not match the caller's symbolic type descriptor.</dd> <dd>
<code><a href="../classcastexception">ClassCastException</a></code> - if the access mode type matches the caller's symbolic type descriptor, but a reference cast fails.</dd> <dt>See Also:</dt> <dd>
<a href="#setVolatile(java.lang.Object...)"><code>setVolatile(Object...)</code></a>, <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(Object...)</code></a>
</dd> </dl>    <h3>getAndBitwiseAndAcquire</h3> <pre data-language="java">public final Object getAndBitwiseAndAcquire​(Object... args)</pre> <div>
<p>Atomically sets the value of a variable to the result of bitwise AND between the variable's current value and the <code>mask</code> with the memory semantics of <a href="#set(java.lang.Object...)"><code>set(java.lang.Object...)</code></a> and returns the variable's previous value, as accessed with the memory semantics of <a href="#getAcquire(java.lang.Object...)"><code>getAcquire(java.lang.Object...)</code></a>. </p>
<p>If the variable type is the non-integral <code>boolean</code> type then a logical AND is performed instead of a bitwise AND. </p>
<p>The method signature is of the form <code>(CT1 ct1, ..., CTn ctn, T mask)T</code>. </p>
<p>The symbolic type descriptor at the call site of <code>getAndBitwiseAndAcquire</code> must match the access mode type that is the result of calling <code>accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_AND_ACQUIRE)</code> on this VarHandle.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>args</code> - the signature-polymorphic parameter list of the form <code>(CT1 ct1, ..., CTn ctn, T mask)</code> , statically represented using varargs.</dd> <dt>Returns:</dt> <dd>the signature-polymorphic result that is the previous value of the variable , statically represented using <code>Object</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../unsupportedoperationexception">UnsupportedOperationException</a></code> - if the access mode is unsupported for this VarHandle.</dd> <dd>
<code><a href="wrongmethodtypeexception">WrongMethodTypeException</a></code> - if the access mode type does not match the caller's symbolic type descriptor.</dd> <dd>
<code><a href="../classcastexception">ClassCastException</a></code> - if the access mode type matches the caller's symbolic type descriptor, but a reference cast fails.</dd> <dt>See Also:</dt> <dd>
<a href="#set(java.lang.Object...)"><code>set(Object...)</code></a>, <a href="#getAcquire(java.lang.Object...)"><code>getAcquire(Object...)</code></a>
</dd> </dl>    <h3>getAndBitwiseAndRelease</h3> <pre data-language="java">public final Object getAndBitwiseAndRelease​(Object... args)</pre> <div>
<p>Atomically sets the value of a variable to the result of bitwise AND between the variable's current value and the <code>mask</code> with the memory semantics of <a href="#setRelease(java.lang.Object...)"><code>setRelease(java.lang.Object...)</code></a> and returns the variable's previous value, as accessed with the memory semantics of <a href="#get(java.lang.Object...)"><code>get(java.lang.Object...)</code></a>. </p>
<p>If the variable type is the non-integral <code>boolean</code> type then a logical AND is performed instead of a bitwise AND. </p>
<p>The method signature is of the form <code>(CT1 ct1, ..., CTn ctn, T mask)T</code>. </p>
<p>The symbolic type descriptor at the call site of <code>getAndBitwiseAndRelease</code> must match the access mode type that is the result of calling <code>accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_AND_RELEASE)</code> on this VarHandle.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>args</code> - the signature-polymorphic parameter list of the form <code>(CT1 ct1, ..., CTn ctn, T mask)</code> , statically represented using varargs.</dd> <dt>Returns:</dt> <dd>the signature-polymorphic result that is the previous value of the variable , statically represented using <code>Object</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../unsupportedoperationexception">UnsupportedOperationException</a></code> - if the access mode is unsupported for this VarHandle.</dd> <dd>
<code><a href="wrongmethodtypeexception">WrongMethodTypeException</a></code> - if the access mode type does not match the caller's symbolic type descriptor.</dd> <dd>
<code><a href="../classcastexception">ClassCastException</a></code> - if the access mode type matches the caller's symbolic type descriptor, but a reference cast fails.</dd> <dt>See Also:</dt> <dd>
<a href="#setRelease(java.lang.Object...)"><code>setRelease(Object...)</code></a>, <a href="#get(java.lang.Object...)"><code>get(Object...)</code></a>
</dd> </dl>    <h3>getAndBitwiseXor</h3> <pre data-language="java">public final Object getAndBitwiseXor​(Object... args)</pre> <div>
<p>Atomically sets the value of a variable to the result of bitwise XOR between the variable's current value and the <code>mask</code> with the memory semantics of <a href="#setVolatile(java.lang.Object...)"><code>setVolatile(java.lang.Object...)</code></a> and returns the variable's previous value, as accessed with the memory semantics of <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(java.lang.Object...)</code></a>. </p>
<p>If the variable type is the non-integral <code>boolean</code> type then a logical XOR is performed instead of a bitwise XOR. </p>
<p>The method signature is of the form <code>(CT1 ct1, ..., CTn ctn, T mask)T</code>. </p>
<p>The symbolic type descriptor at the call site of <code>getAndBitwiseXor</code> must match the access mode type that is the result of calling <code>accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_XOR)</code> on this VarHandle.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>args</code> - the signature-polymorphic parameter list of the form <code>(CT1 ct1, ..., CTn ctn, T mask)</code> , statically represented using varargs.</dd> <dt>Returns:</dt> <dd>the signature-polymorphic result that is the previous value of the variable , statically represented using <code>Object</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../unsupportedoperationexception">UnsupportedOperationException</a></code> - if the access mode is unsupported for this VarHandle.</dd> <dd>
<code><a href="wrongmethodtypeexception">WrongMethodTypeException</a></code> - if the access mode type does not match the caller's symbolic type descriptor.</dd> <dd>
<code><a href="../classcastexception">ClassCastException</a></code> - if the access mode type matches the caller's symbolic type descriptor, but a reference cast fails.</dd> <dt>See Also:</dt> <dd>
<a href="#setVolatile(java.lang.Object...)"><code>setVolatile(Object...)</code></a>, <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(Object...)</code></a>
</dd> </dl>    <h3>getAndBitwiseXorAcquire</h3> <pre data-language="java">public final Object getAndBitwiseXorAcquire​(Object... args)</pre> <div>
<p>Atomically sets the value of a variable to the result of bitwise XOR between the variable's current value and the <code>mask</code> with the memory semantics of <a href="#set(java.lang.Object...)"><code>set(java.lang.Object...)</code></a> and returns the variable's previous value, as accessed with the memory semantics of <a href="#getAcquire(java.lang.Object...)"><code>getAcquire(java.lang.Object...)</code></a>. </p>
<p>If the variable type is the non-integral <code>boolean</code> type then a logical XOR is performed instead of a bitwise XOR. </p>
<p>The method signature is of the form <code>(CT1 ct1, ..., CTn ctn, T mask)T</code>. </p>
<p>The symbolic type descriptor at the call site of <code>getAndBitwiseXorAcquire</code> must match the access mode type that is the result of calling <code>accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_XOR_ACQUIRE)</code> on this VarHandle.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>args</code> - the signature-polymorphic parameter list of the form <code>(CT1 ct1, ..., CTn ctn, T mask)</code> , statically represented using varargs.</dd> <dt>Returns:</dt> <dd>the signature-polymorphic result that is the previous value of the variable , statically represented using <code>Object</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../unsupportedoperationexception">UnsupportedOperationException</a></code> - if the access mode is unsupported for this VarHandle.</dd> <dd>
<code><a href="wrongmethodtypeexception">WrongMethodTypeException</a></code> - if the access mode type does not match the caller's symbolic type descriptor.</dd> <dd>
<code><a href="../classcastexception">ClassCastException</a></code> - if the access mode type matches the caller's symbolic type descriptor, but a reference cast fails.</dd> <dt>See Also:</dt> <dd>
<a href="#set(java.lang.Object...)"><code>set(Object...)</code></a>, <a href="#getAcquire(java.lang.Object...)"><code>getAcquire(Object...)</code></a>
</dd> </dl>    <h3>getAndBitwiseXorRelease</h3> <pre data-language="java">public final Object getAndBitwiseXorRelease​(Object... args)</pre> <div>
<p>Atomically sets the value of a variable to the result of bitwise XOR between the variable's current value and the <code>mask</code> with the memory semantics of <a href="#setRelease(java.lang.Object...)"><code>setRelease(java.lang.Object...)</code></a> and returns the variable's previous value, as accessed with the memory semantics of <a href="#get(java.lang.Object...)"><code>get(java.lang.Object...)</code></a>. </p>
<p>If the variable type is the non-integral <code>boolean</code> type then a logical XOR is performed instead of a bitwise XOR. </p>
<p>The method signature is of the form <code>(CT1 ct1, ..., CTn ctn, T mask)T</code>. </p>
<p>The symbolic type descriptor at the call site of <code>getAndBitwiseXorRelease</code> must match the access mode type that is the result of calling <code>accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_XOR_RELEASE)</code> on this VarHandle.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>args</code> - the signature-polymorphic parameter list of the form <code>(CT1 ct1, ..., CTn ctn, T mask)</code> , statically represented using varargs.</dd> <dt>Returns:</dt> <dd>the signature-polymorphic result that is the previous value of the variable , statically represented using <code>Object</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../unsupportedoperationexception">UnsupportedOperationException</a></code> - if the access mode is unsupported for this VarHandle.</dd> <dd>
<code><a href="wrongmethodtypeexception">WrongMethodTypeException</a></code> - if the access mode type does not match the caller's symbolic type descriptor.</dd> <dd>
<code><a href="../classcastexception">ClassCastException</a></code> - if the access mode type matches the caller's symbolic type descriptor, but a reference cast fails.</dd> <dt>See Also:</dt> <dd>
<a href="#setRelease(java.lang.Object...)"><code>setRelease(Object...)</code></a>, <a href="#get(java.lang.Object...)"><code>get(Object...)</code></a>
</dd> </dl>    <h3>varType</h3> <pre data-language="java">public final Class&lt;?&gt; varType()</pre> <p>Returns the variable type of variables referenced by this VarHandle.</p> <dl> <dt>Returns:</dt> <dd>the variable type of variables referenced by this VarHandle</dd> </dl>    <h3>coordinateTypes</h3> <pre data-language="java">public final List&lt;Class&lt;?&gt;&gt; coordinateTypes()</pre> <p>Returns the coordinate types for this VarHandle.</p> <dl> <dt>Returns:</dt> <dd>the coordinate types for this VarHandle. The returned list is unmodifiable</dd> </dl>    <h3>accessModeType</h3> <pre data-language="java">public final MethodType accessModeType​(VarHandle.AccessMode accessMode)</pre> <div>
<p>Obtains the access mode type for this VarHandle and a given access mode. </p>
<p>The access mode type's parameter types will consist of a prefix that is the coordinate types of this VarHandle followed by further types as defined by the access mode method. The access mode type's return type is defined by the return type of the access mode method.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>accessMode</code> - the access mode, corresponding to the signature-polymorphic method of the same name</dd> <dt>Returns:</dt> <dd>the access mode type for the given access mode</dd> </dl>    <h3>isAccessModeSupported</h3> <pre data-language="java">public final boolean isAccessModeSupported​(VarHandle.AccessMode accessMode)</pre> <div>
<p>Returns <code>true</code> if the given access mode is supported, otherwise <code>false</code>. </p>
<p>The return of a <code>false</code> value for a given access mode indicates that an <code>UnsupportedOperationException</code> is thrown on invocation of the corresponding access mode method.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>accessMode</code> - the access mode, corresponding to the signature-polymorphic method of the same name</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the given access mode is supported, otherwise <code>false</code>.</dd> </dl>    <h3>toMethodHandle</h3> <pre data-language="java">public final MethodHandle toMethodHandle​(VarHandle.AccessMode accessMode)</pre> <p>Obtains a method handle bound to this VarHandle and the given access mode.</p> <dl> <dt>API Note:</dt> <dd>This method, for a VarHandle <code>vh</code> and access mode <code>{access-mode}</code>, returns a method handle that is equivalent to method handle <code>bmh</code> in the following code (though it may be more efficient): <pre data-language="java">MethodHandle mh = MethodHandles.varHandleExactInvoker(
                       vh.accessModeType(VarHandle.AccessMode.{access-mode}));

 MethodHandle bmh = mh.bindTo(vh);</pre>
</dd> <dt>Parameters:</dt> <dd>
<code>accessMode</code> - the access mode, corresponding to the signature-polymorphic method of the same name</dd> <dt>Returns:</dt> <dd>a method handle bound to this VarHandle and the given access mode</dd> </dl>    <h3>fullFence</h3> <pre data-language="java">public static void fullFence()</pre> <p>Ensures that loads and stores before the fence will not be reordered with loads and stores after the fence.</p> <dl> <dt>API Note:</dt> <dd>Ignoring the many semantic differences from C and C++, this method has memory ordering effects compatible with <code>atomic_thread_fence(memory_order_seq_cst)</code>
</dd> </dl>    <h3>acquireFence</h3> <pre data-language="java">public static void acquireFence()</pre> <p>Ensures that loads before the fence will not be reordered with loads and stores after the fence.</p> <dl> <dt>API Note:</dt> <dd>Ignoring the many semantic differences from C and C++, this method has memory ordering effects compatible with <code>atomic_thread_fence(memory_order_acquire)</code>
</dd> </dl>    <h3>releaseFence</h3> <pre data-language="java">public static void releaseFence()</pre> <p>Ensures that loads and stores before the fence will not be reordered with stores after the fence.</p> <dl> <dt>API Note:</dt> <dd>Ignoring the many semantic differences from C and C++, this method has memory ordering effects compatible with <code>atomic_thread_fence(memory_order_release)</code>
</dd> </dl>    <h3>loadLoadFence</h3> <pre data-language="java">public static void loadLoadFence()</pre> <p>Ensures that loads before the fence will not be reordered with loads after the fence.</p>    <h3>storeStoreFence</h3> <pre data-language="java">public static void storeStoreFence()</pre> <p>Ensures that stores before the fence will not be reordered with stores after the fence.</p>   </section>  </div>  </main>  <div class="_attribution">
  <p class="_attribution-p">
    © 1993, 2020, Oracle and/or its affiliates. All rights reserved.<br>Documentation extracted from Debian's OpenJDK Development Kit package.<br>Licensed under the GNU General Public License, version 2, with the Classpath Exception.<br>Various third party code in OpenJDK is licensed under different licenses (see Debian package).<br>Java and OpenJDK are trademarks or registered trademarks of Oracle and/or its affiliates.<br>
    <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/invoke/VarHandle.html" class="_attribution-link">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/invoke/VarHandle.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
