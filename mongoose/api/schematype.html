
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Schematype - Mongoose - W3cubDocs</title>
  
  <meta name="description" content=" SchemaType constructor. Do not instantiate SchemaType directly. Mongoose converts your schema paths into SchemaTypes automatically. ">
  <meta name="keywords" content="schematype, mongoose">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/mongoose/api/schematype.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/mongoose.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/mongoose/" class="_nav-link" title="" style="margin-left:0;">Mongoose</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _simple">
				
				
<h1>Schematype</h1>

<div class="api-content">
<h3 id="schematype_SchemaType">SchemaType()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">path <span class="method-type">«String»</span> </li>
<li class="param">[options] <span class="method-type">«SchemaTypeOptions»</span> See <a href="schematypeoptions">SchemaTypeOptions docs</a> </li>
<li class="param">[instance] <span class="method-type">«String»</span> </li>
</ul>
<div>
<p>SchemaType constructor. Do <strong>not</strong> instantiate <code>SchemaType</code> directly. Mongoose converts your schema paths into SchemaTypes automatically.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> schema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span> });
schema.path(<span class="hljs-string">'name'</span>) <span class="hljs-keyword">instanceof</span> SchemaType; <span class="hljs-comment">// true</span></pre> </div>
<h3 id="schematype_SchemaType-cast">SchemaType.cast()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">caster <span class="method-type">«Function|false»</span> Function that casts arbitrary values to this type, or throws an error if casting failed </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Function»</span> </li></ul>
<div>
<p>Get/set the function used to cast arbitrary values to this type.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-comment">// Disallow `null` for numbers, and don't try to cast any values to</span>
<span class="hljs-comment">// numbers, so even strings like '123' will cause a CastError.</span>
mongoose.Number.cast(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) </span>{
  assert.ok(v === <span class="hljs-literal">undefined</span> || <span class="hljs-keyword">typeof</span> v === <span class="hljs-string">'number'</span>);
  <span class="hljs-keyword">return</span> v;
});</pre> </div>
<h3 id="schematype_SchemaType-checkRequired">SchemaType.checkRequired()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">fn <span class="method-type">«Function»</span> </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Function»</span> </li></ul>
<div>
<p>Override the function the required validator uses to check whether a value passes the <code>required</code> check. Override this on the individual SchemaType.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-comment">// Use this to allow empty strings to pass the `required` validator</span>
mongoose.Schema.Types.String.checkRequired(v =&gt; <span class="hljs-keyword">typeof</span> v === <span class="hljs-string">'string'</span>);</pre> </div>
<h3 id="schematype_SchemaType-get">SchemaType.get()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">getter <span class="method-type">«Function»</span> </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«this»</span> </li></ul>
<div>
<p>Attaches a getter for all instances of this schema type.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-comment">// Make all numbers round down</span>
mongoose.Number.get(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.floor(v); });</pre> </div>
<h3 id="schematype_SchemaType-default">SchemaType.prototype.default()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">val <span class="method-type">«Function|any»</span> the default value </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«defaultValue»</span> </li></ul>
<div>
<p>Sets a default value for this SchemaType.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ n: { type: <span class="hljs-built_in">Number</span>, <span class="hljs-keyword">default</span>: <span class="hljs-number">10</span> })
<span class="hljs-keyword">var</span> M = db.model(<span class="hljs-string">'M'</span>, schema)
<span class="hljs-keyword">var</span> m = <span class="hljs-keyword">new</span> M;
<span class="hljs-built_in">console</span>.log(m.n) <span class="hljs-comment">// 10</span></pre> <p>Defaults can be either <code>functions</code> which return the value to use as the default or the literal value itself. Either way, the value will be cast based on its schema type before being set during document creation.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-comment">// values are cast:</span>
<span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ aNumber: { type: <span class="hljs-built_in">Number</span>, <span class="hljs-keyword">default</span>: <span class="hljs-number">4.815162342</span> }})
<span class="hljs-keyword">var</span> M = db.model(<span class="hljs-string">'M'</span>, schema)
<span class="hljs-keyword">var</span> m = <span class="hljs-keyword">new</span> M;
<span class="hljs-built_in">console</span>.log(m.aNumber) <span class="hljs-comment">// 4.815162342</span>

<span class="hljs-comment">// default unique objects for Mixed types:</span>
<span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ mixed: Schema.Types.Mixed });
schema.path(<span class="hljs-string">'mixed'</span>).default(<span class="hljs-function"><span class="hljs-keyword">function</span> () </span>{
  <span class="hljs-keyword">return</span> {};
});

<span class="hljs-comment">// if we don't use a function to return object literals for Mixed defaults,</span>
<span class="hljs-comment">// each document will receive a reference to the same object literal creating</span>
<span class="hljs-comment">// a "shared" object instance:</span>
<span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ mixed: Schema.Types.Mixed });
schema.path(<span class="hljs-string">'mixed'</span>).default({});
<span class="hljs-keyword">var</span> M = db.model(<span class="hljs-string">'M'</span>, schema);
<span class="hljs-keyword">var</span> m1 = <span class="hljs-keyword">new</span> M;
m1.mixed.added = <span class="hljs-number">1</span>;
<span class="hljs-built_in">console</span>.log(m1.mixed); <span class="hljs-comment">// { added: 1 }</span>
<span class="hljs-keyword">var</span> m2 = <span class="hljs-keyword">new</span> M;
<span class="hljs-built_in">console</span>.log(m2.mixed); <span class="hljs-comment">// { added: 1 }</span></pre> </div>
<h3 id="schematype_SchemaType-get">SchemaType.prototype.get()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">fn <span class="method-type">«Function»</span> </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«SchemaType»</span> this </li></ul>
<div>
<p>Adds a getter to this schematype.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dob</span> (<span class="hljs-params">val</span>) </span>{
  <span class="hljs-keyword">if</span> (!val) <span class="hljs-keyword">return</span> val;
  <span class="hljs-keyword">return</span> (val.getMonth() + <span class="hljs-number">1</span>) + <span class="hljs-string">"/"</span> + val.getDate() + <span class="hljs-string">"/"</span> + val.getFullYear();
}

<span class="hljs-comment">// defining within the schema</span>
<span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> Schema({ born: { type: <span class="hljs-built_in">Date</span>, get: dob })

<span class="hljs-comment">// or by retreiving its SchemaType</span>
<span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> Schema({ born: <span class="hljs-built_in">Date</span> })
s.path(<span class="hljs-string">'born'</span>).get(dob)</pre> <p>Getters allow you to transform the representation of the data as it travels from the raw mongodb document to the value that you see.</p> <p>Suppose you are storing credit card numbers and you want to hide everything except the last 4 digits to the mongoose user. You can do so by defining a getter in the following way:</p> <pre data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">obfuscate</span> (<span class="hljs-params">cc</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">'****-****-****-'</span> + cc.slice(cc.length<span class="hljs-number">-4</span>, cc.length);
}

<span class="hljs-keyword">var</span> AccountSchema = <span class="hljs-keyword">new</span> Schema({
  creditCardNumber: { type: <span class="hljs-built_in">String</span>, get: obfuscate }
});

<span class="hljs-keyword">var</span> Account = db.model(<span class="hljs-string">'Account'</span>, AccountSchema);

Account.findById(id, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, found</span>) </span>{
  <span class="hljs-built_in">console</span>.log(found.creditCardNumber); <span class="hljs-comment">// '****-****-****-1234'</span>
});</pre> <p>Getters are also passed a second argument, the schematype on which the getter was defined. This allows for tailored behavior based on options passed in the schema.</p> <pre data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inspector</span> (<span class="hljs-params">val, schematype</span>) </span>{
  <span class="hljs-keyword">if</span> (schematype.options.required) {
    <span class="hljs-keyword">return</span> schematype.path + <span class="hljs-string">' is required'</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> schematype.path + <span class="hljs-string">' is not'</span>;
  }
}

<span class="hljs-keyword">var</span> VirusSchema = <span class="hljs-keyword">new</span> Schema({
  name: { type: <span class="hljs-built_in">String</span>, required: <span class="hljs-literal">true</span>, get: inspector },
  taxonomy: { type: <span class="hljs-built_in">String</span>, get: inspector }
})

<span class="hljs-keyword">var</span> Virus = db.model(<span class="hljs-string">'Virus'</span>, VirusSchema);

Virus.findById(id, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, virus</span>) </span>{
  <span class="hljs-built_in">console</span>.log(virus.name);     <span class="hljs-comment">// name is required</span>
  <span class="hljs-built_in">console</span>.log(virus.taxonomy); <span class="hljs-comment">// taxonomy is not</span>
})</pre> </div>
<h3 id="schematype_SchemaType-immutable">SchemaType.prototype.immutable()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">bool <span class="method-type">«Boolean»</span> </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«SchemaType»</span> this </li></ul>
<div>
<p>Defines this path as immutable. Mongoose prevents you from changing immutable paths unless the parent document has <a href="https://mongoosejs.com/docs/api.html#document_Document-isNew"><code>isNew: true</code></a>.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> schema = <span class="hljs-keyword">new</span> Schema({
  name: { type: <span class="hljs-built_in">String</span>, immutable: <span class="hljs-literal">true</span> },
  age: <span class="hljs-built_in">Number</span>
});
<span class="hljs-keyword">const</span> Model = mongoose.model(<span class="hljs-string">'Test'</span>, schema);

<span class="hljs-keyword">await</span> Model.create({ name: <span class="hljs-string">'test'</span> });
<span class="hljs-keyword">const</span> doc = <span class="hljs-keyword">await</span> Model.findOne();

doc.isNew; <span class="hljs-comment">// false</span>
doc.name = <span class="hljs-string">'new name'</span>;
doc.name; <span class="hljs-comment">// 'test', because `name` is immutable</span></pre> <p>Mongoose also prevents changing immutable properties using <code>updateOne()</code> and <code>updateMany()</code> based on <a href="../guide#strict">strict mode</a>.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-comment">// Mongoose will strip out the `name` update, because `name` is immutable</span>
Model.updateOne({}, { $set: { name: <span class="hljs-string">'test2'</span> }, $inc: { age: <span class="hljs-number">1</span> } });

<span class="hljs-comment">// If `strict` is set to 'throw', Mongoose will throw an error if you</span>
<span class="hljs-comment">// update `name`</span>
<span class="hljs-keyword">const</span> err = <span class="hljs-keyword">await</span> Model.updateOne({}, { name: <span class="hljs-string">'test2'</span> }, { strict: <span class="hljs-string">'throw'</span> }).
  then(() =&gt; <span class="hljs-literal">null</span>, err =&amp;gt; err);
err.name; <span class="hljs-comment">// StrictModeError</span>

<span class="hljs-comment">// If `strict` is `false`, Mongoose allows updating `name` even though</span>
<span class="hljs-comment">// the property is immutable.</span>
Model.updateOne({}, { name: <span class="hljs-string">'test2'</span> }, { strict: <span class="hljs-literal">false</span> });</pre> </div>
<h3 id="schematype_SchemaType-index">SchemaType.prototype.index()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">options <span class="method-type">«Object|Boolean|String»</span> </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«SchemaType»</span> this </li></ul>
<div>
<p>Declares the index options for this schematype.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> Schema({ name: { type: <span class="hljs-built_in">String</span>, index: <span class="hljs-literal">true</span> })
<span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> Schema({ loc: { type: [<span class="hljs-built_in">Number</span>], index: <span class="hljs-string">'hashed'</span> })
<span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> Schema({ loc: { type: [<span class="hljs-built_in">Number</span>], index: <span class="hljs-string">'2d'</span>, sparse: <span class="hljs-literal">true</span> })
<span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> Schema({ loc: { type: [<span class="hljs-built_in">Number</span>], index: { type: <span class="hljs-string">'2dsphere'</span>, sparse: <span class="hljs-literal">true</span> }})
<span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> Schema({ date: { type: <span class="hljs-built_in">Date</span>, index: { unique: <span class="hljs-literal">true</span>, expires: <span class="hljs-string">'1d'</span> }})
s.path(<span class="hljs-string">'my.path'</span>).index(<span class="hljs-literal">true</span>);
s.path(<span class="hljs-string">'my.date'</span>).index({ expires: <span class="hljs-number">60</span> });
s.path(<span class="hljs-string">'my.path'</span>).index({ unique: <span class="hljs-literal">true</span>, sparse: <span class="hljs-literal">true</span> });</pre> <h4>NOTE:</h4> <p><em>Indexes are created <a href="https://docs.mongodb.com/manual/core/index-creation/#index-creation-background">in the background</a> by default. If <code>background</code> is set to <code>false</code>, MongoDB will not execute any read/write operations you send until the index build. Specify <code>background: false</code> to override Mongoose's default.</em></p> </div>
<h3 id="schematype_SchemaType-ref">SchemaType.prototype.ref()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">ref <span class="method-type">«String|Model|Function»</span> either a model name, a <a href="../models">Model</a>, or a function that returns a model name or model. </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«SchemaType»</span> this </li></ul>
<div>
<p>Set the model that this path refers to. This is the option that <a href="../populate">populate</a> looks at to determine the foreign collection it should query.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> userSchema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span> });
<span class="hljs-keyword">const</span> User = mongoose.model(<span class="hljs-string">'User'</span>, userSchema);

<span class="hljs-keyword">const</span> postSchema = <span class="hljs-keyword">new</span> Schema({ user: mongoose.ObjectId });
postSchema.path(<span class="hljs-string">'user'</span>).ref(<span class="hljs-string">'User'</span>); <span class="hljs-comment">// By model name</span>
postSchema.path(<span class="hljs-string">'user'</span>).ref(User); <span class="hljs-comment">// Can pass the model as well</span>

<span class="hljs-comment">// Or you can just declare the `ref` inline in your schema</span>
<span class="hljs-keyword">const</span> postSchema2 = <span class="hljs-keyword">new</span> Schema({
  user: { type: mongoose.ObjectId, ref: User }
});</pre> </div>
<h3 id="schematype_SchemaType-required">SchemaType.prototype.required()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">required <span class="method-type">«Boolean|Function|Object»</span> enable/disable the validator, or function that returns required boolean, or options object </li>
<ul style="margin-top: 0.5em"><li>[options.isRequired] <span class="method-type">«Boolean|Function»</span> enable/disable the validator, or function that returns required boolean </li></ul>
<ul style="margin-top: 0.5em"><li>[options.ErrorConstructor] <span class="method-type">«Function»</span> custom error constructor. The constructor receives 1 parameter, an object containing the validator properties. </li></ul>
<li class="param">[message] <span class="method-type">«String»</span> optional custom error message </li>
</ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«SchemaType»</span> this </li></ul>
<div>
<p>Adds a required validator to this SchemaType. The validator gets added to the front of this SchemaType's validators array using <code>unshift()</code>.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> Schema({ born: { type: <span class="hljs-built_in">Date</span>, required: <span class="hljs-literal">true</span> })

<span class="hljs-comment">// or with custom error message</span>

<span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> Schema({ born: { type: <span class="hljs-built_in">Date</span>, required: <span class="hljs-string">'{PATH} is required!'</span> })

<span class="hljs-comment">// or with a function</span>

<span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> Schema({
  userId: ObjectId,
  username: {
    type: <span class="hljs-built_in">String</span>,
    required: <span class="hljs-function"><span class="hljs-keyword">function</span>() </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.userId != <span class="hljs-literal">null</span>; }
  }
})

<span class="hljs-comment">// or with a function and a custom message</span>
<span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> Schema({
  userId: ObjectId,
  username: {
    type: <span class="hljs-built_in">String</span>,
    required: [
      <span class="hljs-function"><span class="hljs-keyword">function</span>() </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.userId != <span class="hljs-literal">null</span>; },
      <span class="hljs-string">'username is required if id is specified'</span>
    ]
  }
})

<span class="hljs-comment">// or through the path API</span>

s.path(<span class="hljs-string">'name'</span>).required(<span class="hljs-literal">true</span>);

<span class="hljs-comment">// with custom error messaging</span>

s.path(<span class="hljs-string">'name'</span>).required(<span class="hljs-literal">true</span>, <span class="hljs-string">'grrr :( '</span>);

<span class="hljs-comment">// or make a path conditionally required based on a function</span>
<span class="hljs-keyword">var</span> isOver18 = <span class="hljs-function"><span class="hljs-keyword">function</span>() </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.age &gt;= <span class="hljs-number">18</span>; };
s.path(<span class="hljs-string">'voterRegistrationId'</span>).required(isOver18);</pre> <p>The required validator uses the SchemaType's <code>checkRequired</code> function to determine whether a given value satisfies the required validator. By default, a value satisfies the required validator if <code>val != null</code> (that is, if the value is not null nor undefined). However, most built-in mongoose schema types override the default <code>checkRequired</code> function:</p> </div>
<h3 id="schematype_SchemaType-select">SchemaType.prototype.select()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">val <span class="method-type">«Boolean»</span> </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«SchemaType»</span> this </li></ul>
<div>
<p>Sets default <code>select()</code> behavior for this path.</p> <p>Set to <code>true</code> if this path should always be included in the results, <code>false</code> if it should be excluded by default. This setting can be overridden at the query level.</p> <h4>Example:</h4> <pre data-language="javascript">T = db.model(<span class="hljs-string">'T'</span>, <span class="hljs-keyword">new</span> Schema({ x: { type: <span class="hljs-built_in">String</span>, select: <span class="hljs-literal">true</span> }}));
T.find(..); <span class="hljs-comment">// field x will always be selected ..</span>
<span class="hljs-comment">// .. unless overridden;</span>
T.find().select(<span class="hljs-string">'-x'</span>).exec(callback);</pre> </div>
<h3 id="schematype_SchemaType-set">SchemaType.prototype.set()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">fn <span class="method-type">«Function»</span> </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«SchemaType»</span> this </li></ul>
<div>
<p>Adds a setter to this schematype.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">capitalize</span> (<span class="hljs-params">val</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> val !== <span class="hljs-string">'string'</span>) val = <span class="hljs-string">''</span>;
  <span class="hljs-keyword">return</span> val.charAt(<span class="hljs-number">0</span>).toUpperCase() + val.substring(<span class="hljs-number">1</span>);
}

<span class="hljs-comment">// defining within the schema</span>
<span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> Schema({ name: { type: <span class="hljs-built_in">String</span>, set: capitalize }});

<span class="hljs-comment">// or with the SchemaType</span>
<span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span> })
s.path(<span class="hljs-string">'name'</span>).set(capitalize);</pre> <p>Setters allow you to transform the data before it gets to the raw mongodb document or query.</p> <p>Suppose you are implementing user registration for a website. Users provide an email and password, which gets saved to mongodb. The email is a string that you will want to normalize to lower case, in order to avoid one email having more than one account -- e.g., otherwise, <a href="mailto:avenue@q.com">avenue@q.com</a> can be registered for 2 accounts via <a href="mailto:avenue@q.com">avenue@q.com</a> and <a href="mailto:AvEnUe@Q.CoM">AvEnUe@Q.CoM</a>.</p> <p>You can set up email lower case normalization easily via a Mongoose setter.</p> <pre data-language="javascript">function toLower(v) {
  return v.toLowerCase();
}

var UserSchema = new Schema({
  email: { type: String, set: toLower }
});

var User = db.model('User', UserSchema);

var user = new User({email: '<a href="mailto:AVENUE@Q.COM">AVENUE@Q.COM</a>'});
console.log(user.email); // '<a href="mailto:avenue@q.com">avenue@q.com</a>'

// or
var user = new User();
user.email = '<a href="mailto:Avenue@Q.com">Avenue@Q.com</a>';
console.log(user.email); // '<a href="mailto:avenue@q.com">avenue@q.com</a>'
User.updateOne({ _id: _id }, { $set: { email: '<a href="mailto:AVENUE@Q.COM">AVENUE@Q.COM</a>' } }); // update to '<a href="mailto:avenue@q.com">avenue@q.com</a>'
</pre> <p>As you can see above, setters allow you to transform the data before it stored in MongoDB, or before executing a query.</p> <p><em>NOTE: we could have also just used the built-in <code>lowercase: true</code> SchemaType option instead of defining our own function.</em></p> <pre data-language="javascript"><span class="hljs-keyword">new</span> Schema({ email: { type: <span class="hljs-built_in">String</span>, lowercase: <span class="hljs-literal">true</span> }})</pre> <p>Setters are also passed a second argument, the schematype on which the setter was defined. This allows for tailored behavior based on options passed in the schema.</p> <pre data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inspector</span> (<span class="hljs-params">val, schematype</span>) </span>{
  <span class="hljs-keyword">if</span> (schematype.options.required) {
    <span class="hljs-keyword">return</span> schematype.path + <span class="hljs-string">' is required'</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> val;
  }
}

<span class="hljs-keyword">var</span> VirusSchema = <span class="hljs-keyword">new</span> Schema({
  name: { type: <span class="hljs-built_in">String</span>, required: <span class="hljs-literal">true</span>, set: inspector },
  taxonomy: { type: <span class="hljs-built_in">String</span>, set: inspector }
})

<span class="hljs-keyword">var</span> Virus = db.model(<span class="hljs-string">'Virus'</span>, VirusSchema);
<span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> Virus({ name: <span class="hljs-string">'Parvoviridae'</span>, taxonomy: <span class="hljs-string">'Parvovirinae'</span> });

<span class="hljs-built_in">console</span>.log(v.name);     <span class="hljs-comment">// name is required</span>
<span class="hljs-built_in">console</span>.log(v.taxonomy); <span class="hljs-comment">// Parvovirinae</span></pre> <p>You can also use setters to modify other properties on the document. If you're setting a property <code>name</code> on a document, the setter will run with <code>this</code> as the document. Be careful, in mongoose 5 setters will also run when querying by <code>name</code> with <code>this</code> as the query.</p> <div class="highlight"><pre lang="javascript" data-language="javascript">const nameSchema = new Schema({ name: String, keywords: [String] });
nameSchema.path('name').set(function(v) {
  // Need to check if `this` is a document, because in mongoose 5
  // setters will also run on queries, in which case `this` will be a
  // mongoose query object.
  if (this instanceof Document &amp;&amp; v != null) {
    this.keywords = v.split(' ');
  }
  return v;
});
</pre></div> </div>
<h3 id="schematype_SchemaType-sparse">SchemaType.prototype.sparse()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">bool <span class="method-type">«Boolean»</span> </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«SchemaType»</span> this </li></ul>
<div>
<p>Declares a sparse index.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> Schema({ name: { type: <span class="hljs-built_in">String</span>, sparse: <span class="hljs-literal">true</span> } });
s.path(<span class="hljs-string">'name'</span>).index({ sparse: <span class="hljs-literal">true</span> });</pre> </div>
<h3 id="schematype_SchemaType-text">SchemaType.prototype.text()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">bool <span class="method-type">«Boolean»</span> </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«SchemaType»</span> this </li></ul>
<div>
<p>Declares a full text index.</p> <h3>Example:</h3> <pre data-language="javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> Schema({name : {type: <span class="hljs-built_in">String</span>, text : <span class="hljs-literal">true</span> })
 s.path(<span class="hljs-string">'name'</span>).index({text : <span class="hljs-literal">true</span>});</pre> </div>
<h3 id="schematype_SchemaType-unique">SchemaType.prototype.unique()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">bool <span class="method-type">«Boolean»</span> </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«SchemaType»</span> this </li></ul>
<div>
<p>Declares an unique index.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> Schema({ name: { type: <span class="hljs-built_in">String</span>, unique: <span class="hljs-literal">true</span> }});
s.path(<span class="hljs-string">'name'</span>).index({ unique: <span class="hljs-literal">true</span> });</pre> <p><em>NOTE: violating the constraint returns an <code>E11000</code> error from MongoDB when saving, not a Mongoose validation error.</em></p> </div>
<h3 id="schematype_SchemaType-validate">SchemaType.prototype.validate()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">obj <span class="method-type">«RegExp|Function|Object»</span> validator function, or hash describing options </li>
<ul style="margin-top: 0.5em"><li>[obj.validator] <span class="method-type">«Function»</span> validator function. If the validator function returns <code>undefined</code> or a truthy value, validation succeeds. If it returns <a href="https://masteringjs.io/tutorials/fundamentals/falsy">falsy</a> (except <code>undefined</code>) or throws an error, validation fails. </li></ul>
<ul style="margin-top: 0.5em"><li>[obj.message] <span class="method-type">«String|Function»</span> optional error message. If function, should return the error message as a string </li></ul>
<ul style="margin-top: 0.5em"><li>[obj.propsParameter=false] <span class="method-type">«Boolean»</span> If true, Mongoose will pass the validator properties object (with the <code>validator</code> function, <code>message</code>, etc.) as the 2nd arg to the validator function. This is disabled by default because many validators <a href="https://github.com/chriso/validator.js#validators">rely on positional args</a>, so turning this on may cause unpredictable behavior in external validators. </li></ul>
<li class="param">[errorMsg] <span class="method-type">«String|Function»</span> optional error message. If function, should return the error message as a string </li>
<li class="param">[type] <span class="method-type">«String»</span> optional validator type </li>
</ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«SchemaType»</span> this </li></ul>
<div>
<p>Adds validator(s) for this document path.</p> <p>Validators always receive the value to validate as their first argument and must return <code>Boolean</code>. Returning <code>false</code> or throwing an error means validation failed.</p> <p>The error message argument is optional. If not passed, the <a href="#error_messages_MongooseError-messages">default generic error message template</a> will be used.</p> <h4>Examples:</h4> <pre data-language="javascript"><span class="hljs-comment">// make sure every value is equal to "something"</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">validator</span> (<span class="hljs-params">val</span>) </span>{
  <span class="hljs-keyword">return</span> val == <span class="hljs-string">'something'</span>;
}
<span class="hljs-keyword">new</span> Schema({ name: { type: <span class="hljs-built_in">String</span>, validate: validator }});

<span class="hljs-comment">// with a custom error message</span>

<span class="hljs-keyword">var</span> custom = [validator, <span class="hljs-string">'Uh oh, {PATH} does not equal "something".'</span>]
<span class="hljs-keyword">new</span> Schema({ name: { type: <span class="hljs-built_in">String</span>, validate: custom }});

<span class="hljs-comment">// adding many validators at a time</span>

<span class="hljs-keyword">var</span> many = [
    { validator: validator, msg: <span class="hljs-string">'uh oh'</span> }
  , { validator: anotherValidator, msg: <span class="hljs-string">'failed'</span> }
]
<span class="hljs-keyword">new</span> Schema({ name: { type: <span class="hljs-built_in">String</span>, validate: many }});

<span class="hljs-comment">// or utilizing SchemaType methods directly:</span>

<span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-string">'string'</span> });
schema.path(<span class="hljs-string">'name'</span>).validate(validator, <span class="hljs-string">'validation of `{PATH}` failed with value `{VALUE}`'</span>);</pre> <h4>Error message templates:</h4> <p>From the examples above, you may have noticed that error messages support basic templating. There are a few other template keywords besides <code>{PATH}</code> and <code>{VALUE}</code> too. To find out more, details are available <a href="#error_messages_MongooseError.messages">here</a>.</p> <p>If Mongoose's built-in error message templating isn't enough, Mongoose supports setting the <code>message</code> property to a function.</p> <pre data-language="javascript">schema.path(<span class="hljs-string">'name'</span>).validate({
  validator: <span class="hljs-function"><span class="hljs-keyword">function</span>() </span>{ <span class="hljs-keyword">return</span> v.length &gt; <span class="hljs-number">5</span>; },
  <span class="hljs-comment">// `errors['name']` will be "name must have length 5, got 'foo'"</span>
  message: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">props</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${props.path}</span> must have length 5, got '<span class="hljs-subst">${props.value}</span>'`</span>;
  }
});</pre> <p>To bypass Mongoose's error messages and just copy the error message that the validator throws, do this:</p> <pre data-language="javascript">schema.path(<span class="hljs-string">'name'</span>).validate({
  validator: <span class="hljs-function"><span class="hljs-keyword">function</span>() </span>{ <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Oops!'</span>); },
  <span class="hljs-comment">// `errors['name']` will be "Oops!"</span>
  message: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">props</span>) </span>{ <span class="hljs-keyword">return</span> props.reason.message; }
});</pre> <h4>Asynchronous validation:</h4> <p>Mongoose supports validators that return a promise. A validator that returns a promise is called an <em>async validator</em>. Async validators run in parallel, and <code>validate()</code> will wait until all async validators have settled.</p> <pre data-language="javascript">schema.path(<span class="hljs-string">'name'</span>).validate({
  validator: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{
      resolve(<span class="hljs-literal">false</span>); <span class="hljs-comment">// validation failed</span>
    });
  }
});</pre> <p>You might use asynchronous validators to retreive other documents from the database to validate against or to meet other I/O bound validation needs.</p> <p>Validation occurs <code>pre('save')</code> or whenever you manually execute <a href="#document_Document-validate">document#validate</a>.</p> <p>If validation fails during <code>pre('save')</code> and no callback was passed to receive the error, an <code>error</code> event will be emitted on your Models associated db <a href="#connection_Connection">connection</a>, passing the validation error object along.</p> <pre data-language="javascript"><span class="hljs-keyword">var</span> conn = mongoose.createConnection(..);
conn.on(<span class="hljs-string">'error'</span>, handleError);

<span class="hljs-keyword">var</span> Product = conn.model(<span class="hljs-string">'Product'</span>, yourSchema);
<span class="hljs-keyword">var</span> dvd = <span class="hljs-keyword">new</span> Product(..);
dvd.save(); <span class="hljs-comment">// emits error on the `conn` above</span></pre> <p>If you want to handle these errors at the Model level, add an <code>error</code> listener to your Model as shown below.</p> <pre data-language="javascript"><span class="hljs-comment">// registering an error listener on the Model lets us handle errors more locally</span>
Product.on(<span class="hljs-string">'error'</span>, handleError);</pre> </div>
</div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2010 LearnBoost<br>Licensed under the MIT License.<br>
    <a href="https://mongoosejs.com/docs/api/schematype.html" class="_attribution-link">https://mongoosejs.com/docs/api/schematype.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
