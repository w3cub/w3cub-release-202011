
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Writing Drivers - RethinkDB Ruby - W3cubDocs</title>
  
  <meta name="description" content="RethinkDB client drivers are responsible for serializing queries, sending them to the server using the ReQL wire protocol, and receiving responses &hellip;">
  <meta name="keywords" content="writing, rethinkdb, drivers, ruby, rethinkdb~ruby">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/rethinkdb~ruby/docs/writing-drivers/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/rethinkdb~ruby.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/rethinkdb~ruby/" class="_nav-link" title="" style="margin-left:0;">RethinkDB Ruby</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _rethinkdb">
				
				
<h1 class="title">Writing RethinkDB drivers</h1> <div class="toc">  <ul id="markdown-toc"> <li><a href="#initial-steps" id="markdown-toc-initial-steps">Initial steps</a></li> <li><a href="#open-a-connection" id="markdown-toc-open-a-connection">Open a connection</a></li> <li><a href="#perform-a-handshake" id="markdown-toc-perform-a-handshake">Perform a handshake</a></li> <li><a href="#serializing-queries" id="markdown-toc-serializing-queries">Serializing queries</a></li> <li><a href="#send-the-message" id="markdown-toc-send-the-message">Send the message</a></li> <li><a href="#receive-responses" id="markdown-toc-receive-responses">Receive responses</a></li> <li><a href="#notes-on-connections" id="markdown-toc-notes-on-connections">Notes on connections</a></li> <li><a href="#get-help" id="markdown-toc-get-help">Get help</a></li> </ul> </div> <p>RethinkDB client drivers are responsible for serializing queries, sending them to the server using the ReQL wire protocol, and receiving responses from the server and returning them to the calling application. This process takes the following steps:</p> <ul> <li>Open a connection</li> <li>Perform a handshake</li> <li>Serialize the query</li> <li>Send the message</li> <li>Receive responses</li> </ul> <blockquote class="infobox ">
<p>For updates on protocol and behavior changes in new versions of RethinkDB and general assistance with writing drivers, join the <a href="https://groups.google.com/forum/?fromgroups#!forum/rethinkdb-dev">RethinkDB-Dev Google Group</a>.</p> </blockquote> <h2 id="initial-steps">Initial steps</h2> <p>ReQL types and commands are defined in the <a href="https://github.com/rethinkdb/rethinkdb/blob/next/src/rdb_protocol/ql2.proto">ql2.proto</a> file.</p> <p>For a JavaScript version of the file, run <code class="highlighter-rouge">make js-driver</code> in the <code class="highlighter-rouge">rethinkdb</code> repo, and retrieve the JSON version of the file in <code class="highlighter-rouge">build/packages/js/proto-def.js</code>. Alternatively you may grab the equivalent file from <a href="https://github.com/neumino/rethinkdbdash/blob/master/lib/protodef.js">rethinkdbdash</a>.</p> <p>The <code class="highlighter-rouge">ql2.proto</code> file is well-commented, showing arguments and output for each command.</p> <h2 id="open-a-connection">Open a connection</h2> <p>Open a TCP connection to the server on the driver port. The default port is <code class="highlighter-rouge">28015</code>.</p> <h2 id="perform-a-handshake">Perform a handshake</h2> <p>With version <code class="highlighter-rouge">V1_0</code> of the protocol, the handshake protocol has changed from previous versions.</p> <h3 id="version-v10">Version V1_0</h3> <ol> <li> <p>The client sends the “magic number” (<code class="highlighter-rouge">0x34c2bdc3</code>) for the protocol version, as a 32-bit little-endian integer (4 bytes).</p> <pre data-language=""> SEND c3 bd c2 34
</pre>  </li> <li> <p>On <strong>success,</strong> the server sends a null-terminated JSON response, indicating success, minimum and maximum protocol versions, and the server version.</p> <pre data-language=""> {
     "success": true,
     "min_protocol_version": 0,
     "max_protocol_version": 0,
     "server_version": "2.3.0"
 }
</pre>  <p>On <strong>failure,</strong> the server sends a null-terminated error string (<em>not</em> JSON).</p> <pre data-language=""> ERROR: Received an unsupported protocol version. This port is for RethinkDB queries. Does your client driver version not match the server?
</pre>  </li> <li> <p>The client sends the protocol version, authentication method, and authentication as a null-terminated JSON response. RethinkDB currently supports only one authentication method, <code class="highlighter-rouge">SCRAM-SHA-256</code>, as specified in <a href="https://tools.ietf.org/html/rfc7677">IETF RFC 7677</a> and <a href="https://tools.ietf.org/html/rfc5802">RFC 5802</a>. The RFC is followed with the exception of error handling (RethinkDB uses its own higher level error reporting rather than the <code class="highlighter-rouge">e=</code> field). RethinkDB does not support channel binding and clients should not request this. The value of <code class="highlighter-rouge">"authentication"</code> is the “client-first-message” specified in RFC 5802 (the channel binding flag, optional SASL authorization identity, username (<code class="highlighter-rouge">n=</code>), and random nonce (<code class="highlighter-rouge">r=</code>).</p> <pre data-language=""> {
     "protocol_version": 0,
     "authentication_method": "SCRAM-SHA-256",
     "authentication": "n,,n=user,r=rOprNGfwEbeRWgbNEkqO"
 }
</pre>  </li> <li> <p>The server sends a null-terminated JSON response with a <code class="highlighter-rouge">"success"</code> value of either <code class="highlighter-rouge">true</code> or <code class="highlighter-rouge">false</code>. On <code class="highlighter-rouge">true</code>, then <code class="highlighter-rouge">"authentication"</code> will contain the “server-first-message” containing the iteration count (<code class="highlighter-rouge">i=</code>), salt (<code class="highlighter-rouge">s=</code>) and a concatenation of the client nonce with its own nonce.</p> <pre data-language=""> {
     "success": true,
     "authentication": "r=rOprNGfwEbeRWgbNEkqO%hvYDpWUa2RaTCAfuxFIlj)hNlF$k0,
       s=W22ZaJ0SNY7soEsUEjb6gQ==,i=4096"
 }
</pre>  <p>On <code class="highlighter-rouge">false</code>, the server will send an error and error code.</p> <pre data-language=""> {
     "success": false,
     "error": "You mucked up.",
     "error_code": 12
 }
</pre>  <p>A <code class="highlighter-rouge">ReqlAuthError</code> should be thrown if the error code is between 10 and 20 (inclusive).</p> </li> <li> <p>The client sends the null-terminated JSON “client-final-message” with the same nonce and the ClientProof computed as specified by the RFC.</p> <pre data-language=""> {
     "authentication": "c=biws,r=rOprNGfwEbeRWgbNEkqO%hvYDpWUa2RaTCAfuxFIlj)hNlF$k0,
       p=dHzbZapWIk4jUhN+Ute9ytag9zjfMHgsqmmiz7AndVQ="
 }
</pre>  </li> <li> <p>The server sends a null-terminated JSON response with a <code class="highlighter-rouge">"success"</code> value of either <code class="highlighter-rouge">true</code> or <code class="highlighter-rouge">false</code>. On <code class="highlighter-rouge">true</code>, then <code class="highlighter-rouge">"authentication"</code> will contain the “server-final-message” with the ServerSignature value. The client should compute a ServerSignature as specified in the RFC and verify the values are identical.</p> <pre data-language=""> {
     "success": true,
     "authentication": "v=6rriTRBi23WpRR/wtup+mMhUZUn/dB5nLTJRsjl95G4="
 }
</pre>  <p>On <code class="highlighter-rouge">false</code>, the server will send an error and error code as above.</p> </li> </ol> <p><strong>Note:</strong> It is possible to optimize the handshake by sending message #3 immediately after #1 without waiting for the server response, and read messages #2 and #4 afterward, handling them as appropriate.</p> <h3 id="versions-v03-and-v04">Versions V0_3 and V0_4</h3> <p><em><strong>Note:</strong> these versions do not support RethinkDB users and permissions, and may be deprecated in a future release. When communicating with RethinkDB 2.3 or later, the authentication key will be compared to the admin user account password.</em></p> <ol> <li>Send the protocol version, as a 32-bit little-endian integer (4 bytes). <em>Note:</em> All instructions below assume a protocol of <code class="highlighter-rouge">V0_3</code> or higher. The current protocol as of RethinkDB 2.0 is <code class="highlighter-rouge">V0_4</code>.</li> <li>Send the length of the authorization key, as a 32-bit little-endian integer (4 bytes). Send <code class="highlighter-rouge">0</code> if there is no authorization key.</li> <li>Send the authorization key as an ASCII string. <em>If there is no authorization key, skip this step.</em>
</li> <li>Send the protocol type, as a 32-bit little-endian integer (4 bytes). Protocol types are defined in the <code class="highlighter-rouge">Protocol</code> enum in <code class="highlighter-rouge">ql2.proto</code>. New drivers should use JSON, <code class="highlighter-rouge">0x7e6970c7</code>.</li> </ol> <p>The server will respond with a <code class="highlighter-rouge">null</code>-terminated ASCII string describing the result of the handshake. If the string is <code class="highlighter-rouge">"SUCCESS"</code>, the client may proceed to stage 2 and begin sending queries. Any other string indicates an error. The server will close the connection, and the driver should report this error to the user.</p> <h3 id="example-1-no-auth-key">Example 1: No auth key</h3> <table> <thead> <tr> <th>Step</th> <th>Direction</th> <th>Element</th> <th>Bytes</th> </tr> </thead> <tbody> <tr> <td>1</td> <td>SEND</td> <td><code class="highlighter-rouge">V0_4</code></td> <td><code class="highlighter-rouge">20 2d 0c 40</code></td> </tr> <tr> <td>2</td> <td>SEND</td> <td>key size</td> <td><code class="highlighter-rouge">00 00 00 00</code></td> </tr> <tr> <td>3</td> <td>SEND</td> <td>auth key</td> <td> </td> </tr> <tr> <td>4</td> <td>SEND</td> <td>JSON</td> <td><code class="highlighter-rouge">c7 70 69 7e</code></td> </tr> <tr> <td>5</td> <td>RECV</td> <td>success</td> <td><code class="highlighter-rouge">53 55 43 43 45 53 53</code></td> </tr> </tbody> </table> <h3 id="example-2-auth-key">Example 2: Auth key</h3> <table> <thead> <tr> <th>Step</th> <th>Direction</th> <th>Element</th> <th>Bytes</th> </tr> </thead> <tbody> <tr> <td>1</td> <td>SEND</td> <td><code class="highlighter-rouge">V0_4</code></td> <td><code class="highlighter-rouge">20 2d 0c 40</code></td> </tr> <tr> <td>2</td> <td>SEND</td> <td>key size</td> <td><code class="highlighter-rouge">07 00 00 00</code></td> </tr> <tr> <td>3</td> <td>SEND</td> <td>auth key</td> <td><code class="highlighter-rouge">68 75 6e 74 65 72 32</code></td> </tr> <tr> <td>4</td> <td>SEND</td> <td>JSON</td> <td><code class="highlighter-rouge">c7 70 69 7e</code></td> </tr> <tr> <td>5</td> <td>RECV</td> <td>success</td> <td><code class="highlighter-rouge">53 55 43 43 45 53 53</code></td> </tr> </tbody> </table> <h2 id="serializing-queries">Serializing queries</h2> <p>Your driver should assign each query a unique 8-byte token per connection. (The official RethinkDB drivers implement this as an unsigned 8-byte little-endian counter per connection.) The server will send responses to queries using this token as an identifier so the response can be matched to its query. The token can also be used to request more data for the query if all the results were not returned in the first response.</p> <h3 id="a-simple-example">A simple example</h3> <p>The next section will explain how to build complex queries. For now, we will just send the string <code class="highlighter-rouge">"foo"</code> (<code class="highlighter-rouge">r.expr("foo")</code>) to the server.</p> <p>Sending a query to the server takes the following steps:</p> <ul> <li>Serialize the query as UTF8-encoded JSON</li> <li>Send the following data to the server: <ul> <li>The 8-byte unique query token</li> <li>The size of the JSON-serialized, UTF8-encoded query, as a 4-byte little-endian integer</li> <li>The wrapped query message (QueryType, serialized query and options)</li> </ul> </li> </ul> <p>The wrapped query message sent to the server is an array of three elements:</p> <pre data-language="">[ QueryType, query, options ]
</pre>  <p>The next section will go into more detail, but in our example the <code class="highlighter-rouge">QueryType</code> is <code class="highlighter-rouge">1</code> (or <code class="highlighter-rouge">START</code>, as we’ll see later), the <code class="highlighter-rouge">query</code> is simply the string <code class="highlighter-rouge">"foo"</code> and there are no options.</p> <pre data-language="">[ 1, "foo", {} ]
</pre>  <p>So, the data we send to the server is as follows:</p> <table> <thead> <tr> <th>Step</th> <th>Element</th> <th>Transmitted bytes</th> </tr> </thead> <tbody> <tr> <td>1</td> <td>query token</td> <td><code class="highlighter-rouge">00 00 00 00 00 00 00 01</code></td> </tr> <tr> <td>2</td> <td>length</td> <td><code class="highlighter-rouge">0c 00 00 00</code></td> </tr> <tr> <td>3</td> <td>query</td> <td><code class="highlighter-rouge">[1,"foo",{}]</code></td> </tr> </tbody> </table> <p>Once the query is sent, you can read the response object back from the server. The response object takes the following form:</p> <ul> <li>The 8-byte unique query token</li> <li>The length of the response, as a 4-byte little-endian integer</li> <li>The JSON-encoded response</li> </ul> <table> <thead> <tr> <th>Step</th> <th>Element</th> <th>Bytes on wire</th> </tr> </thead> <tbody> <tr> <td>1</td> <td>query token</td> <td><code class="highlighter-rouge">00 00 00 00 00 00 00 01</code></td> </tr> <tr> <td>2</td> <td>length</td> <td><code class="highlighter-rouge">13 00 00 00</code></td> </tr> <tr> <td>3</td> <td>response</td> <td><code class="highlighter-rouge"><span class="p">{</span><span class="s2">"t"</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="s2">"r"</span><span class="p">:[</span><span class="s2">"foo"</span><span class="p">]}</span></code></td> </tr> </tbody> </table> <p>When you parse the response string as JSON, you get the object:</p> <pre data-language="">{
    t: 1,         // protodef.Response.ResponseType.SUCCESS_ATOM
    r: ["foo"]    // the response is the string 'foo"
}
</pre>  <p>Where <code class="highlighter-rouge">t:1</code> means that the response is a value, and <code class="highlighter-rouge">r: ["foo"]</code> the string <code class="highlighter-rouge">"foo"</code>.</p> <h3 id="queries-in-detail">Queries in detail</h3> <p>ReQL is a <a href="http://en.wikipedia.org/wiki/Domain-specific_language">domain specific language</a> expressed in the host language. The three official drivers follow a very similar syntax; you should stick to that model as closely as your chosen language allows. Typically you are free to use either a prefix or infix notation, or mix the two.</p> <p>Internally, queries are represented as trees. A query of:</p> <pre data-language="">r.db("blog").table("users").filter({name: "Michel"})
</pre>  <p>is represented by this tree:</p> <p><img alt="Query tree illustration" src="https://rethinkdb.com/assets/images/docs/query_tree.png"></p> <h4 id="reql-commands">ReQL commands</h4> <p>ReQL commands are represented as a list of two or three elements.</p> <pre data-language="">[&lt;command&gt;, [&lt;arguments&gt;], {&lt;options&gt;}]
</pre>  <ul> <li>
<code class="highlighter-rouge">&lt;command&gt;</code> is the integer representing the command, from <code class="highlighter-rouge">ql2.proto</code>
</li> <li>
<code class="highlighter-rouge">&lt;arguments&gt;</code> is a list of all arguments. Each argument is itself a query (a command list, or data).</li> <li>
<code class="highlighter-rouge">&lt;options&gt;</code> are the command’s optional arguments. This element may be left out if the command has no optional arguments given.</li> </ul> <p>Thus, this is how our previous query is represented:</p> <pre data-language="">r.db("blog").table("users").filter({name: "Michel"});

FILTER = 39     // from ql2.proto
TABLE = 15
DB = 14

r.db("blog") =&gt;
    [14, ["blog"]]

r.db("blog").table("users") =&gt;
    [15, [[14, ["blog"]], "users"]]

r.db("blog").table("users").filter({name: "Michel"}) =&gt;
    [39, [[15, [[14, ["blog"]], "users"]], {"name": "Michel"}]]
</pre>  <h4 id="implementation-considerations">Implementation considerations</h4> <p>If you want to use a prefix notation, you just need to implement all the commands on a module. If you want to use an infix notation, you should implement all the functions on a class “term” and some prefix commands on the module.</p> <p>You can only check arity of the methods to a certain extent. If an <code class="highlighter-rouge">ARGS</code> term is one of the argument, only the server can effectively verify that enough arguments are provided (or not too many). The arity errors reported by the server suppose a prefix notation. Things may change if the solution in <a href="https://github.com/rethinkdb/rethinkdb/issues/2463#issuecomment-44584491">#2463</a> is implemented.</p> <h4 id="reql-data">ReQL data</h4> <p>A <em>datum</em> (the singular of data) is any value that can be represented in JSON: booleans, numbers, strings, objects, arrays and <code class="highlighter-rouge">null</code>. They are sent to the server in JSON form.</p> <p>Arrays, however, are a special case: since ReQL commands (as described above) are sent as arrays, you must send data arrays as arguments to the <code class="highlighter-rouge">MAKE_ARRAY</code> command. So the array</p> <pre data-language="">[10, 20, 30]
</pre>  <p>Would be sent to the server as</p> <pre data-language="">// MAKE_ARRAY = 2 (from ql2.proto)

[2, [10, 20, 30]]
</pre>  <h4 id="reql-pseudo-types">ReQL pseudo types</h4> <p>Some native ReQL data types have no direct JSON representations. These are implemented as <em>pseudo types,</em> JSON objects with the special key <code class="highlighter-rouge">$reql_type$</code>. The three official ReQL drivers convert date and binary types to pseudo types.</p> <p><strong>Date pseudo type</strong></p> <pre data-language="">{
    $reql_type: "TIME",
    epoch_time: &lt;timestamp&gt;,
    timezone: &lt;string&gt;
}
</pre>  <p>The <code class="highlighter-rouge">epoch_time</code> field is a Unix timestamp, the number of seconds since January 1st, 1970, with millisecond precision. The <code class="highlighter-rouge">timezone</code> field is a string in the format <code class="highlighter-rouge">[+-]HH:MM</code>, indicating the offset from UTC. UTC is <code class="highlighter-rouge">+00:00</code>; PST is <code class="highlighter-rouge">-08:00</code>; and so on.</p> <p><strong>Binary pseudo type</strong></p> <pre data-language="">{
    $reql_type$: "BINARY",
    data: &lt;string&gt;
}
</pre>  <p>The <code class="highlighter-rouge">data</code> field is a Base64-encoded string of the binary object.</p> <h4 id="anonymous-functions">Anonymous functions</h4> <p>A <a href="http://www.rethinkdb.com/blog/lambda-functions/" title="All about lambda functions in RethinkDB queries">good article</a> by <a href="https://github.com/wmrowan">Bill Rowan</a> explains anonymous functions (or lambda functions) in the drivers. The article covers why anonymous functions are useful and how they work. Here, we’ll just focus on how to serialize anonymous functions.</p> <p>When the driver finds an anonymous function, it returns a query object like this one:</p> <pre data-language="">// FUNC = 69, MAKE_ARRAY = 2 (from ql2.proto)

[69, [[2, [p1, p2, ...]], function body]]
</pre>  <p>The parameters are represented as values <code class="highlighter-rouge">&lt;p1&gt;</code>, <code class="highlighter-rouge">&lt;p2&gt;</code>, etc.; the values are arbitrary, but must be unique per query to avoid collisions. Within the function body the values are referred to with the query term <code class="highlighter-rouge">VAR</code>, defined as <code class="highlighter-rouge">10</code> in <code class="highlighter-rouge">ql2.proto</code>. So the value of parameter <code class="highlighter-rouge">1</code> is retrieved with <code class="highlighter-rouge">[10, [1]]</code>.</p> <p>Take the function:</p> <pre data-language="">function(x, y, z) {
    return r.add(x, y, z)
}
</pre>  <p>The function would be serialized as:</p> <pre data-language="">[FUNC, 
 [[MAKE_ARRAY, [1, 2, 3]],
   [ADD,
    [[VAR, [1]],
     [VAR, [2]],
     [VAR, [3]]]]]]

// FUNC = 69, MAKE_ARRAY = 2, ADD = 24, VAR = 10 (from ql2.proto)

[69, [[2, [1, 2, 3]], [24, [[10, [1]], [10, [2]], [10, [3]]]]]]
</pre>  <h4 id="implementation-details">Implementation details</h4> <p>Serializing functions depends heavily on your driver’s language. The JavaScript driver does it this way:</p> <ul> <li>Look at how many arguments the function takes (<code class="highlighter-rouge">num_args</code>)</li> <li>Create that many <code class="highlighter-rouge">VAR</code> terms</li> <li>Call the function with those terms</li> <li>Serialize the result as the function body</li> </ul> <p>If your driver uses infix notation, you must make sure that the <code class="highlighter-rouge">VAR</code> term implements all the ReQL methods.</p> <h4 id="serializing-implicitvar-rrow">Serializing IMPLICIT_VAR (r.row)</h4> <p>The <code class="highlighter-rouge">IMPLICIT_VAR</code> term is equivalent to the <a href="https://rethinkdb.com/api/python/row">row</a> command in the official JavaScript and Python drivers. It’s useful for languages where anonymous functions are too verbose.</p> <p>If you support <code class="highlighter-rouge">IMPLICIT_VAR</code> in your driver, then every time you parse the argument of a function you should check if the method can take a function. If it can, you should look for an <code class="highlighter-rouge">IMPLICIT_VAR</code> term (i.e., <code class="highlighter-rouge">row</code>). If you find one, wrap the argument in a function that takes one parameter:</p> <pre data-language="">[69, [[2, [1]], argument]]
</pre>  <p>If you do not find one, treat the argument normally.</p> <p>In the case of nested functions, the <code class="highlighter-rouge">IMPLICIT_VAR</code> term is ambiguous, and should not be used. Your driver should either throw an error or let the server return an error.</p> <h4 id="serializing-binary">Serializing BINARY</h4> <p>Binary objects created with <code class="highlighter-rouge">r.binary</code> can be serialized in two different ways.</p> <p>If the argument is a ReQL term (not including a datum), serialize it using the standard term:</p> <pre data-language="">[BINARY, argument]
</pre>  <p>If the language’s native binary format is used, use the pseudotype serialization described above.</p> <pre data-language="">{
    $reql_type$: "BINARY",
    data: &lt;base64 string&gt;
}
</pre>  <h4 id="serializing-funcall-rdo">Serializing FUNCALL (r.do)</h4> <p>The <code class="highlighter-rouge">r.do()</code> command is serialized with the <code class="highlighter-rouge">FUNCALL</code> term.</p> <pre data-language="">[FUNCALL, [function], arguments]
</pre>  <p>Take the <code class="highlighter-rouge">do</code> command:</p> <pre data-language="">r.do(10, 20, function (x, y) {
  return r.add(x, y);
})
</pre>  <p>This would be serialized as:</p> <pre data-language="">[FUNCALL,
  [FUNC,
    [[MAKE_ARRAY, [1, 2]],
      [ADD,
        [[VAR, [1]],
         [VAR, [2]]]]]],
  10,
  20]

// FUNCALL = 64, FUNC = 69, MAKE_ARRAY = 2, ADD = 24, VAR = 10

[64, [69, [[2, [1, 2]], [24, [[10, [1]], [10, [2]]]]]], 10, 20]
</pre>  <p>Note that while <code class="highlighter-rouge">r.do()</code> takes the function as its <em>last</em> argument, <code class="highlighter-rouge">FUNCALL</code> serializes the function as its <em>first</em> argument.</p> <h2 id="send-the-message">Send the message</h2> <p>Because you can keep chaining commands (or calling them in prefix notation), you need a command to signify the end of the chain and send the query to the server. This command is <code class="highlighter-rouge">run</code> in the official drivers.</p> <h3 id="wrapping-queries">Wrapping queries</h3> <p>Once the <a href="https://rethinkdb.com/api/python/run">run</a> command is processed, the serialized query needs to be wrapped in the message sent to the server. The complete message takes the form:</p> <pre data-language="">[ QueryType, query, options ]
</pre>  <p>The query types are defined in <code class="highlighter-rouge">ql2.proto</code>. When a query is first sent to the server, it will be sent with a <code class="highlighter-rouge">QueryType</code> of <code class="highlighter-rouge">START</code> (<code class="highlighter-rouge">1</code>). The options (sometimes referred to as “global optargs”) are options passed to the <code class="highlighter-rouge">run</code> command itself; see the <a href="https://rethinkdb.com/api/python/run">run documentation</a> for a complete list. (Commands sent to the server are snake_case, not camelCase.)</p> <p>The full list of <code class="highlighter-rouge">QueryType</code> values is as follows:</p> <ul> <li>
<code class="highlighter-rouge">1</code> <code class="highlighter-rouge">START</code>: Start a new query.</li> <li>
<code class="highlighter-rouge">2</code> <code class="highlighter-rouge">CONTINUE</code>: Continue a query that returned <code class="highlighter-rouge">SUCCESS_PARTIAL</code> (see <a href="#receive-responses">Receive responses</a>).</li> <li>
<code class="highlighter-rouge">3</code> <code class="highlighter-rouge">STOP</code>: Stop a query that is still executing.</li> <li>
<code class="highlighter-rouge">4</code> <code class="highlighter-rouge">NOREPLY_WAIT</code>: Wait for noreply operations to finish. The server will return a <code class="highlighter-rouge">WAIT_COMPLETE</code> response.</li> <li>
<code class="highlighter-rouge">5</code> <code class="highlighter-rouge">SERVER_INFO</code>: Ask for server information. The server will return a <code class="highlighter-rouge">SERVER_INFO</code> response.</li> </ul> <p><code class="highlighter-rouge">CONTINUE</code> and <code class="highlighter-rouge">STOP</code> should be sent on the same connection with the same token generated for that query’s <code class="highlighter-rouge">START</code> message.</p> <h3 id="sending-queries">Sending queries</h3> <p>To recap, sending a query to the server takes the following steps:</p> <ul> <li>Serialize the query as UTF8-encoded JSON</li> <li>Send the following data to the server: <ul> <li>The 8-byte unique query token</li> <li>The size of the JSON-serialized, UTF8-encoded wrapped query, as a 4-byte little-endian integer</li> <li>The wrapped query message (QueryType, serialized query and options)</li> </ul> </li> </ul> <p>The token is a unique integer per connection. Keeping a counter per connection is a simple way to implement it.</p> <p>So, our initial example query of:</p> <pre data-language="">r.db("blog").table("users").filter({name: "Michel"})
</pre>  <p>is sent as follows on the wire:</p> <table> <thead> <tr> <th>Step</th> <th>Semantic command</th> <th>Transmitted</th> </tr> </thead> <tbody> <tr> <td>1</td> <td>query token</td> <td><code class="highlighter-rouge">00 00 00 00 00 00 00 01</code></td> </tr> <tr> <td>2</td> <td>length</td> <td><code class="highlighter-rouge">3C 00 00 00</code></td> </tr> <tr> <td>3</td> <td>query</td> <td><code class="highlighter-rouge">[1,[39,[[15,[[14,["blog"]],"users"]],{"name":"Michel"}]],{}]</code></td> </tr> </tbody> </table> <h3 id="wrapping-the-db-query-option">Wrapping the DB query option</h3> <p>If the <code class="highlighter-rouge">db</code> option is passed to the <code class="highlighter-rouge">run</code> command, its value must be a <code class="highlighter-rouge">DB</code> term. The query:</p> <pre data-language="">r.table("users").run({db: "blog"});
</pre>  <p>should be sent as as if the argument to <code class="highlighter-rouge">db</code> was <code class="highlighter-rouge">r.db("blog")</code>:</p> <pre data-language="">[1,[15,["users"]],{"db":[14,["blog"]]}]
</pre>  <h2 id="receive-responses">Receive responses</h2> <p>Responses from the server take the following form:</p> <ul> <li>The 8-byte unique query token the response corresponds to</li> <li>The size of the JSON-encoded response, as a 4-byte little-endian integer</li> <li>The JSON-encoded <code class="highlighter-rouge">Response</code> object</li> </ul> <p>The <code class="highlighter-rouge">Response</code> object will have the following fields:</p> <ul> <li>
<code class="highlighter-rouge">t</code>: the <code class="highlighter-rouge">ResponseType</code>, as defined in <code class="highlighter-rouge">ql2.proto</code>
</li> <li>
<code class="highlighter-rouge">r</code>: data from the result, as a JSON array</li> <li>
<code class="highlighter-rouge">b</code>: a backtrace if <code class="highlighter-rouge">t</code> is an error type; this field will not be present otherwise</li> <li>
<code class="highlighter-rouge">p</code>: a profile if the global optarg <code class="highlighter-rouge">profile: true</code> was specified; this field will not be present otherwise</li> <li>
<code class="highlighter-rouge">n</code>: an optional array of <code class="highlighter-rouge">ResponseNote</code> values, as defined in <code class="highlighter-rouge">ql2.proto</code>
</li> </ul> <h3 id="response-types">Response types</h3> <p>These will be numeric values, corresponding to the types in <code class="highlighter-rouge">ql2.proto</code>.</p> <ul> <li>
<code class="highlighter-rouge">1</code> <code class="highlighter-rouge">SUCCESS_ATOM</code>: The whole query has been returned and the result is in the first (and only) element of <code class="highlighter-rouge">r</code>.</li> <li>
<code class="highlighter-rouge">2</code> <code class="highlighter-rouge">SUCCESS_SEQUENCE</code>: Either the whole query has been returned in <code class="highlighter-rouge">r</code>, or the last section of a multi-response query has been returned.</li> <li>
<code class="highlighter-rouge">3</code> <code class="highlighter-rouge">SUCCESS_PARTIAL</code>: The query has returned a stream, which may or may not be complete. To retrieve more results for the query, send a <code class="highlighter-rouge">CONTINUE</code> message (see below).</li> <li>
<code class="highlighter-rouge">4</code> <code class="highlighter-rouge">WAIT_COMPLETE</code>: This <code class="highlighter-rouge">ResponseType</code> indicates all queries run in <code class="highlighter-rouge">noreply</code> mode have finished executing. <code class="highlighter-rouge">r</code> will be empty.</li> <li>
<code class="highlighter-rouge">5</code> <code class="highlighter-rouge">SERVER_INFO</code>: The response to a <code class="highlighter-rouge">SERVER_INFO</code> request. The data will be in the first (and only) element of <code class="highlighter-rouge">r</code>.</li> <li>
<code class="highlighter-rouge">16</code> <code class="highlighter-rouge">CLIENT_ERROR</code>: The server failed to run the query due to a bad client request. The error message will be in the first element of <code class="highlighter-rouge">r</code>.</li> <li>
<code class="highlighter-rouge">17</code> <code class="highlighter-rouge">COMPILE_ERROR</code>: The server failed to run the query due to an ReQL compilation error. The error message will be in the first element of <code class="highlighter-rouge">r</code>.</li> <li>
<code class="highlighter-rouge">18</code> <code class="highlighter-rouge">RUNTIME_ERROR</code>: The query compiled correctly, but failed at runtime. The error message will be in the first element of <code class="highlighter-rouge">r</code>.</li> </ul> <h3 id="response-notes">Response notes</h3> <p>The <code class="highlighter-rouge">n</code> field, if present, will be an array of one or more <code class="highlighter-rouge">ResponseNote</code> values, giving further information about the kind of the stream being returned. These will be numeric values, corresponding to the notes in <code class="highlighter-rouge">ql2.proto</code>.</p> <p>All of the response notes involve changefeeds; read <a href="../changefeeds/ruby/index">Changefeeds in RethinkDB</a> for more detailed information.</p> <ul> <li>
<code class="highlighter-rouge">1</code> <code class="highlighter-rouge">SEQUENCE_FEED</code>: The stream is a changefeed.</li> <li>
<code class="highlighter-rouge">2</code> <code class="highlighter-rouge">ATOM_FEED</code>: The stream is a <em>point</em> changefeed, i.e., returning changes from a single document.</li> <li>
<code class="highlighter-rouge">3</code> <code class="highlighter-rouge">ORDER_BY_LIMIT_FEED</code>: The stream is a changefeed generated with an <code class="highlighter-rouge">order_by().limit()</code> query.</li> <li>
<code class="highlighter-rouge">4</code> <code class="highlighter-rouge">UNIONED_FEED</code>: The stream is a union of multiple changefeed types that cannot be collapsed to a single type, e.g., <code class="highlighter-rouge">r.table('test').changes().union(r.table('test').get(0).changes())</code>.</li> <li>
<code class="highlighter-rouge">5</code> <code class="highlighter-rouge">INCLUDES_STATES</code>: The stream is a changefeed that includes states notes, e.g., `{state: ‘initializing’}.</li> </ul> <h3 id="multipart-responses">Multipart responses</h3> <p>Streams and feeds are lazily-computed sequences, and return a <code class="highlighter-rouge">ResponseType</code> of <code class="highlighter-rouge">SUCCESS_PARTIAL</code> (<code class="highlighter-rouge">3</code>), with currently available data in the <code class="highlighter-rouge">r</code> array. When the driver receives a feed or stream, it should return a cursor (or an object with a cursor-like interface). <em>N.B.:</em> <code class="highlighter-rouge">SUCCESS_SEQUENCE</code> and <code class="highlighter-rouge">SUCCESS_PARTIAL</code> responses should be both be represented as cursors. Depending on the size of the query results and the time it takes to return them, you may receive either one <code class="highlighter-rouge">SUCCESS_SEQUENCE</code> result, or one or more <code class="highlighter-rouge">SUCCESS_PARTIAL</code> results followed by a final <code class="highlighter-rouge">SUCCESS_SEQUENCE</code> result.</p> <p>To retrieve more data for the cursor, the driver should send a query with a <code class="highlighter-rouge">QueryType</code> of <code class="highlighter-rouge">CONTINUE</code> <em>on the same connection with the same token.</em> As with other queries, this must be sent with the query token, the size of the query, and the query itself, simply <code class="highlighter-rouge">[2]</code>.</p> <table> <thead> <tr> <th>Step</th> <th>Element</th> <th>Transmitted bytes</th> </tr> </thead> <tbody> <tr> <td>1</td> <td>token</td> <td><code class="highlighter-rouge">00 00 00 00 00 00 00 01</code></td> </tr> <tr> <td>2</td> <td>length</td> <td><code class="highlighter-rouge">03 00 00 00</code></td> </tr> <tr> <td>3</td> <td>query</td> <td><code class="highlighter-rouge">[2]</code></td> </tr> </tbody> </table> <p>You will receive another response of either type <code class="highlighter-rouge">SUCCESS_PARTIAL</code>, indicating there is still more data available, or <code class="highlighter-rouge">SUCCESS_SEQUENCE</code> if you have reached the end of the stream. (This will never be returned for a feed.) Note that these <code class="highlighter-rouge">ResponseType</code>s can be returned without data (an empty array as the <code class="highlighter-rouge">r</code> value). A driver can send <code class="highlighter-rouge">CONTINUE</code> to fetch the next batch of a sequence as soon as the response is received.</p> <p>To close a cursor and stop receiving data from the stream or feed, send a query with a <code class="highlighter-rouge">QueryType</code> of <code class="highlighter-rouge">STOP</code> on the same connection with the same token.</p> <h2 id="notes-on-connections">Notes on connections</h2> <p>Starting with RethinkDB 2.0 (<code class="highlighter-rouge">V0_4</code>), the server will process multiple queries in parallel rather than sequentially, and there is no guarantee that a read following a write on the same connection will “see” the results of the write as long as it’s successful. (Previous versions of the server would process multiple queries on the same connection sequentially.)</p> <p>You should not release a connection in the pool as soon as you receive a response. Only release the connection when you receive a response of a type other than <code class="highlighter-rouge">SUCCESS_PARTIAL</code>.</p> <h2 id="get-help">Get help</h2> <p>You can ask questions and get notes on changes introduced in new versions of RethinkDB on the <a href="https://groups.google.com/forum/?fromgroups#!forum/rethinkdb-dev">RethinkDB-Dev Google Group</a>. You can also visit the <a href="irc://irc.freenode.org/rethinkdb">RethinkDB IRC Channel</a>, where core developers and other driver developers frequently hang out. Also, you can ask questions on <a href="http://stackoverflow.com/">Stack Overflow</a> using the tag “<a href="http://stackoverflow.com/questions/tagged/rethinkdb">rethinkdb</a>.”</p>
<div class="_attribution">
  <p class="_attribution-p">
    © RethinkDB contributors<br>Licensed under the Creative Commons Attribution-ShareAlike 3.0 Unported License.<br>
    <a href="https://rethinkdb.com/docs/writing-drivers/" class="_attribution-link">https://rethinkdb.com/docs/writing-drivers/</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
