
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>How to Build Your Inventory - Ansible 2.10 - W3cubDocs</title>
  
  <meta name="description" content="Ansible works against multiple managed nodes or “hosts” in your infrastructure at the same time, using a list or group of lists known as inventory. &hellip;">
  <meta name="keywords" content="how, build, your, inventory, ansible, ansible~2.10">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/ansible~2.10/user_guide/intro_inventory.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/ansible~2.10.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/ansible~2.10/" class="_nav-link" title="" style="margin-left:0;">Ansible 2.10</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _sphinx">
				
				
<h1 id="intro-inventory">How to build your inventory</h1> <p id="how-to-build-your-inventory">Ansible works against multiple managed nodes or “hosts” in your infrastructure at the same time, using a list or group of lists known as inventory. Once your inventory is defined, you use <a class="reference internal" href="intro_patterns#intro-patterns"><span class="std std-ref">patterns</span></a> to select the hosts or groups you want Ansible to run against.</p> <p>The default location for inventory is a file called <code>/etc/ansible/hosts</code>. You can specify a different inventory file at the command line using the <code>-i &lt;path&gt;</code> option. You can also use multiple inventory files at the same time, and/or pull inventory from dynamic or cloud sources or different formats (YAML, ini, and so on), as described in <a class="reference internal" href="intro_dynamic_inventory#intro-dynamic-inventory"><span class="std std-ref">Working with dynamic inventory</span></a>. Introduced in version 2.4, Ansible has <a class="reference internal" href="../plugins/inventory#inventory-plugins"><span class="std std-ref">Inventory Plugins</span></a> to make this flexible and customizable.</p>  <ul class="simple"> <li>
<p><a class="reference internal" href="#inventory-basics-formats-hosts-and-groups" id="id5">Inventory basics: formats, hosts, and groups</a></p> <ul> <li><a class="reference internal" href="#default-groups" id="id6">Default groups</a></li> <li><a class="reference internal" href="#hosts-in-multiple-groups" id="id7">Hosts in multiple groups</a></li> <li><a class="reference internal" href="#adding-ranges-of-hosts" id="id8">Adding ranges of hosts</a></li> </ul> </li> <li><a class="reference internal" href="#adding-variables-to-inventory" id="id9">Adding variables to inventory</a></li> <li>
<p><a class="reference internal" href="#assigning-a-variable-to-one-machine-host-variables" id="id10">Assigning a variable to one machine: host variables</a></p> <ul> <li><a class="reference internal" href="#inventory-aliases" id="id11">Inventory aliases</a></li> </ul> </li> <li>
<p><a class="reference internal" href="#assigning-a-variable-to-many-machines-group-variables" id="id12">Assigning a variable to many machines: group variables</a></p> <ul> <li><a class="reference internal" href="#inheriting-variable-values-group-variables-for-groups-of-groups" id="id13">Inheriting variable values: group variables for groups of groups</a></li> </ul> </li> <li><a class="reference internal" href="#organizing-host-and-group-variables" id="id14">Organizing host and group variables</a></li> <li><a class="reference internal" href="#how-variables-are-merged" id="id15">How variables are merged</a></li> <li><a class="reference internal" href="#using-multiple-inventory-sources" id="id16">Using multiple inventory sources</a></li> <li>
<p><a class="reference internal" href="#connecting-to-hosts-behavioral-inventory-parameters" id="id17">Connecting to hosts: behavioral inventory parameters</a></p> <ul> <li><a class="reference internal" href="#non-ssh-connection-types" id="id18">Non-SSH connection types</a></li> </ul> </li> <li>
<p><a class="reference internal" href="#inventory-setup-examples" id="id19">Inventory setup examples</a></p> <ul> <li><a class="reference internal" href="#example-one-inventory-per-environment" id="id20">Example: One inventory per environment</a></li> <li><a class="reference internal" href="#example-group-by-function" id="id21">Example: Group by function</a></li> <li><a class="reference internal" href="#example-group-by-location" id="id22">Example: Group by location</a></li> </ul> </li> </ul>   <h2 id="inventoryformat">Inventory basics: formats, hosts, and groups</h2> <p id="inventory-basics-formats-hosts-and-groups">The inventory file can be in one of many formats, depending on the inventory plugins you have. The most common formats are INI and YAML. A basic INI <code>/etc/ansible/hosts</code> might look like this:</p> <pre data-language="text">mail.example.com

[webservers]
foo.example.com
bar.example.com

[dbservers]
one.example.com
two.example.com
three.example.com
</pre> <p>The headings in brackets are group names, which are used in classifying hosts and deciding what hosts you are controlling at what times and for what purpose. Group names should follow the same guidelines as <a class="reference internal" href="playbooks_variables#valid-variable-names"><span class="std std-ref">Creating valid variable names</span></a>.</p> <p>Here’s that same basic inventory file in YAML format:</p> <pre data-language="yaml">all:
  hosts:
    mail.example.com:
  children:
    webservers:
      hosts:
        foo.example.com:
        bar.example.com:
    dbservers:
      hosts:
        one.example.com:
        two.example.com:
        three.example.com:
</pre>  <h3 id="id1">Default groups</h3> <p id="default-groups">There are two default groups: <code>all</code> and <code>ungrouped</code>. The <code>all</code> group contains every host. The <code>ungrouped</code> group contains all hosts that don’t have another group aside from <code>all</code>. Every host will always belong to at least 2 groups (<code>all</code> and <code>ungrouped</code> or <code>all</code> and some other group). Though <code>all</code> and <code>ungrouped</code> are always present, they can be implicit and not appear in group listings like <code>group_names</code>.</p>   <h3 id="host-multiple-groups">Hosts in multiple groups</h3> <p id="hosts-in-multiple-groups">You can (and probably will) put each host in more than one group. For example a production webserver in a datacenter in Atlanta might be included in groups called [prod] and [atlanta] and [webservers]. You can create groups that track:</p> <ul class="simple"> <li>What - An application, stack or microservice (for example, database servers, web servers, and so on).</li> <li>Where - A datacenter or region, to talk to local DNS, storage, and so on (for example, east, west).</li> <li>When - The development stage, to avoid testing on production resources (for example, prod, test).</li> </ul> <p>Extending the previous YAML inventory to include what, when, and where would look like:</p> <pre data-language="yaml">all:
  hosts:
    mail.example.com:
  children:
    webservers:
      hosts:
        foo.example.com:
        bar.example.com:
    dbservers:
      hosts:
        one.example.com:
        two.example.com:
        three.example.com:
    east:
      hosts:
        foo.example.com:
        one.example.com:
        two.example.com:
    west:
      hosts:
        bar.example.com:
        three.example.com:
    prod:
      hosts:
        foo.example.com:
        one.example.com:
        two.example.com:
    test:
      hosts:
        bar.example.com:
        three.example.com:
</pre> <p>You can see that <code>one.example.com</code> exists in the <code>dbservers</code>, <code>east</code>, and <code>prod</code> groups.</p> <p>You can also use nested groups to simplify <code>prod</code> and <code>test</code> in this inventory, for the same result:</p> <pre data-language="yaml">all:
  hosts:
    mail.example.com:
  children:
    webservers:
      hosts:
        foo.example.com:
        bar.example.com:
    dbservers:
      hosts:
        one.example.com:
        two.example.com:
        three.example.com:
    east:
      hosts:
        foo.example.com:
        one.example.com:
        two.example.com:
    west:
      hosts:
        bar.example.com:
        three.example.com:
    prod:
      children:
        east:
    test:
      children:
        west:
</pre> <p>You can find more examples on how to organize your inventories and group your hosts in <a class="reference internal" href="#inventory-setup-examples"><span class="std std-ref">Inventory setup examples</span></a>.</p>   <h3 id="adding-ranges-of-hosts">Adding ranges of hosts</h3> <p>If you have a lot of hosts with a similar pattern, you can add them as a range rather than listing each hostname separately:</p> <p>In INI:</p> <pre data-language="text">[webservers]
www[01:50].example.com
</pre> <p>In YAML:</p> <pre data-language="yaml">...
  webservers:
    hosts:
      www[01:50].example.com:
</pre> <p>You can specify a stride (increments between sequence numbers) when defining a numeric range of hosts:</p> <p>In INI:</p> <pre data-language="text">[webservers]
www[01:50:2].example.com
</pre> <p>In YAML:</p> <pre data-language="yaml">...
  webservers:
    hosts:
      www[01:50:2].example.com:
</pre> <p>For numeric patterns, leading zeros can be included or removed, as desired. Ranges are inclusive. You can also define alphabetic ranges:</p> <pre data-language="text">[databases]
db-[a:f].example.com
</pre>    <h2 id="variables-in-inventory">Adding variables to inventory</h2> <p id="adding-variables-to-inventory">You can store variable values that relate to a specific host or group in inventory. To start with, you may add variables directly to the hosts and groups in your main inventory file. As you add more and more managed nodes to your Ansible inventory, however, you will likely want to store variables in separate host and group variable files. See <a class="reference internal" href="playbooks_variables#define-variables-in-inventory"><span class="std std-ref">Defining variables in inventory</span></a> for details.</p>   <h2 id="host-variables">Assigning a variable to one machine: host variables</h2> <p id="assigning-a-variable-to-one-machine-host-variables">You can easily assign a variable to a single host, then use it later in playbooks. In INI:</p> <pre data-language="text">[atlanta]
host1 http_port=80 maxRequestsPerChild=808
host2 http_port=303 maxRequestsPerChild=909
</pre> <p>In YAML:</p> <pre data-language="yaml">atlanta:
  host1:
    http_port: 80
    maxRequestsPerChild: 808
  host2:
    http_port: 303
    maxRequestsPerChild: 909
</pre> <p>Unique values like non-standard SSH ports work well as host variables. You can add them to your Ansible inventory by adding the port number after the hostname with a colon:</p> <pre data-language="text">badwolf.example.com:5309
</pre> <p>Connection variables also work well as host variables:</p> <pre data-language="text">[targets]

localhost              ansible_connection=local
other1.example.com     ansible_connection=ssh        ansible_user=myuser
other2.example.com     ansible_connection=ssh        ansible_user=myotheruser
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If you list non-standard SSH ports in your SSH config file, the <code>openssh</code> connection will find and use them, but the <code>paramiko</code> connection will not.</p> </div>  <h3 id="id2">Inventory aliases</h3> <p id="inventory-aliases">You can also define aliases in your inventory:</p> <p>In INI:</p> <pre data-language="text">jumper ansible_port=5555 ansible_host=192.0.2.50
</pre> <p>In YAML:</p> <pre data-language="yaml">...
  hosts:
    jumper:
      ansible_port: 5555
      ansible_host: 192.0.2.50
</pre> <p>In the above example, running Ansible against the host alias “jumper” will connect to 192.0.2.50 on port 5555. See <a class="reference internal" href="#behavioral-parameters"><span class="std std-ref">behavioral inventory parameters</span></a> to further customize the connection to hosts.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Values passed in the INI format using the <code>key=value</code> syntax are interpreted differently depending on where they are declared:</p> <ul class="simple"> <li>When declared inline with the host, INI values are interpreted as Python literal structures (strings, numbers, tuples, lists, dicts, booleans, None). Host lines accept multiple <code>key=value</code> parameters per line. Therefore they need a way to indicate that a space is part of a value rather than a separator.</li> <li>When declared in a <code>:vars</code> section, INI values are interpreted as strings. For example <code>var=FALSE</code> would create a string equal to ‘FALSE’. Unlike host lines, <code>:vars</code> sections accept only a single entry per line, so everything after the <code>=</code> must be the value for the entry.</li> <li>If a variable value set in an INI inventory must be a certain type (for example, a string or a boolean value), always specify the type with a filter in your task. Do not rely on types set in INI inventories when consuming variables.</li> <li>Consider using YAML format for inventory sources to avoid confusion on the actual type of a variable. The YAML inventory plugin processes variable values consistently and correctly.</li> </ul> </div> <p>Generally speaking, this is not the best way to define variables that describe your system policy. Setting variables in the main inventory file is only a shorthand. See <a class="reference internal" href="#splitting-out-vars"><span class="std std-ref">Organizing host and group variables</span></a> for guidelines on storing variable values in individual files in the ‘host_vars’ directory.</p>    <h2 id="group-variables">Assigning a variable to many machines: group variables</h2> <p id="assigning-a-variable-to-many-machines-group-variables">If all hosts in a group share a variable value, you can apply that variable to an entire group at once. In INI:</p> <pre data-language="text">[atlanta]
host1
host2

[atlanta:vars]
ntp_server=ntp.atlanta.example.com
proxy=proxy.atlanta.example.com
</pre> <p>In YAML:</p> <pre data-language="yaml">atlanta:
  hosts:
    host1:
    host2:
  vars:
    ntp_server: ntp.atlanta.example.com
    proxy: proxy.atlanta.example.com
</pre> <p>Group variables are a convenient way to apply variables to multiple hosts at once. Before executing, however, Ansible always flattens variables, including inventory variables, to the host level. If a host is a member of multiple groups, Ansible reads variable values from all of those groups. If you assign different values to the same variable in different groups, Ansible chooses which value to use based on internal <a class="reference internal" href="#how-we-merge"><span class="std std-ref">rules for merging</span></a>.</p>  <h3 id="subgroups">Inheriting variable values: group variables for groups of groups</h3> <p id="inheriting-variable-values-group-variables-for-groups-of-groups">You can make groups of groups using the <code>:children</code> suffix in INI or the <code>children:</code> entry in YAML. You can apply variables to these groups of groups using <code>:vars</code> or <code>vars:</code>:</p> <p>In INI:</p> <pre data-language="text">[atlanta]
host1
host2

[raleigh]
host2
host3

[southeast:children]
atlanta
raleigh

[southeast:vars]
some_server=foo.southeast.example.com
halon_system_timeout=30
self_destruct_countdown=60
escape_pods=2

[usa:children]
southeast
northeast
southwest
northwest
</pre> <p>In YAML:</p> <pre data-language="yaml">all:
  children:
    usa:
      children:
        southeast:
          children:
            atlanta:
              hosts:
                host1:
                host2:
            raleigh:
              hosts:
                host2:
                host3:
          vars:
            some_server: foo.southeast.example.com
            halon_system_timeout: 30
            self_destruct_countdown: 60
            escape_pods: 2
        northeast:
        northwest:
        southwest:
</pre> <p>If you need to store lists or hash data, or prefer to keep host and group specific variables separate from the inventory file, see <a class="reference internal" href="#splitting-out-vars"><span class="std std-ref">Organizing host and group variables</span></a>.</p> <p>Child groups have a couple of properties to note:</p>  <ul class="simple"> <li>Any host that is member of a child group is automatically a member of the parent group.</li> <li>A child group’s variables will have higher precedence (override) a parent group’s variables.</li> <li>Groups can have multiple parents and children, but not circular relationships.</li> <li>Hosts can also be in multiple groups, but there will only be <strong>one</strong> instance of a host, merging the data from the multiple groups.</li> </ul>     <h2 id="splitting-out-vars">Organizing host and group variables</h2> <p id="organizing-host-and-group-variables">Although you can store variables in the main inventory file, storing separate host and group variables files may help you organize your variable values more easily. Host and group variable files must use YAML syntax. Valid file extensions include ‘.yml’, ‘.yaml’, ‘.json’, or no file extension. See <a class="reference internal" href="../reference_appendices/yamlsyntax#yaml-syntax"><span class="std std-ref">YAML Syntax</span></a> if you are new to YAML.</p> <p>Ansible loads host and group variable files by searching paths relative to the inventory file or the playbook file. If your inventory file at <code>/etc/ansible/hosts</code> contains a host named ‘foosball’ that belongs to two groups, ‘raleigh’ and ‘webservers’, that host will use variables in YAML files at the following locations:</p> <pre data-language="bash">/etc/ansible/group_vars/raleigh # can optionally end in '.yml', '.yaml', or '.json'
/etc/ansible/group_vars/webservers
/etc/ansible/host_vars/foosball
</pre> <p>For example, if you group hosts in your inventory by datacenter, and each datacenter uses its own NTP server and database server, you can create a file called <code>/etc/ansible/group_vars/raleigh</code> to store the variables for the <code>raleigh</code> group:</p> <pre data-language="yaml">---
ntp_server: acme.example.org
database_server: storage.example.org
</pre> <p>You can also create <em>directories</em> named after your groups or hosts. Ansible will read all the files in these directories in lexicographical order. An example with the ‘raleigh’ group:</p> <pre data-language="bash">/etc/ansible/group_vars/raleigh/db_settings
/etc/ansible/group_vars/raleigh/cluster_settings
</pre> <p>All hosts in the ‘raleigh’ group will have the variables defined in these files available to them. This can be very useful to keep your variables organized when a single file gets too big, or when you want to use <a class="reference internal" href="vault#playbooks-vault"><span class="std std-ref">Ansible Vault</span></a> on some group variables.</p> <p>You can also add <code>group_vars/</code> and <code>host_vars/</code> directories to your playbook directory. The <code>ansible-playbook</code> command looks for these directories in the current working directory by default. Other Ansible commands (for example, <code>ansible</code>, <code>ansible-console</code>, and so on) will only look for <code>group_vars/</code> and <code>host_vars/</code> in the inventory directory. If you want other commands to load group and host variables from a playbook directory, you must provide the <code>--playbook-dir</code> option on the command line. If you load inventory files from both the playbook directory and the inventory directory, variables in the playbook directory will override variables set in the inventory directory.</p> <p>Keeping your inventory file and variables in a git repo (or other version control) is an excellent way to track changes to your inventory and host variables.</p>   <h2 id="how-we-merge">How variables are merged</h2> <p id="how-variables-are-merged">By default variables are merged/flattened to the specific host before a play is run. This keeps Ansible focused on the Host and Task, so groups don’t really survive outside of inventory and host matching. By default, Ansible overwrites variables including the ones defined for a group and/or host (see <a class="reference internal" href="../reference_appendices/config#default-hash-behaviour"><span class="std std-ref">DEFAULT_HASH_BEHAVIOUR</span></a>). The order/precedence is (from lowest to highest):</p> <ul class="simple"> <li>all group (because it is the ‘parent’ of all other groups)</li> <li>parent group</li> <li>child group</li> <li>host</li> </ul> <p>By default Ansible merges groups at the same parent/child level in ASCII order, and the last group loaded overwrites the previous groups. For example, an a_group will be merged with b_group and b_group vars that match will overwrite the ones in a_group.</p> <p>You can change this behavior by setting the group variable <code>ansible_group_priority</code> to change the merge order for groups of the same level (after the parent/child order is resolved). The larger the number, the later it will be merged, giving it higher priority. This variable defaults to <code>1</code> if not set. For example:</p> <pre data-language="yaml">a_group:
    testvar: a
    ansible_group_priority: 10
b_group:
    testvar: b
</pre> <p>In this example, if both groups have the same priority, the result would normally have been <code>testvar == b</code>, but since we are giving the <code>a_group</code> a higher priority the result will be <code>testvar == a</code>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p><code>ansible_group_priority</code> can only be set in the inventory source and not in group_vars/, as the variable is used in the loading of group_vars.</p> </div>   <h2 id="id3">Using multiple inventory sources</h2> <p id="using-multiple-inventory-sources">You can target multiple inventory sources (directories, dynamic inventory scripts or files supported by inventory plugins) at the same time by giving multiple inventory parameters from the command line or by configuring <a class="reference internal" href="../reference_appendices/config#envvar-ANSIBLE_INVENTORY" id="index-0"><code>ANSIBLE_INVENTORY</code></a>. This can be useful when you want to target normally separate environments, like staging and production, at the same time for a specific action.</p> <p>Target two sources from the command line like this:</p> <pre data-language="bash">ansible-playbook get_logs.yml -i staging -i production
</pre> <p>Keep in mind that if there are variable conflicts in the inventories, they are resolved according to the rules described in <a class="reference internal" href="#how-we-merge"><span class="std std-ref">How variables are merged</span></a> and <a class="reference internal" href="playbooks_variables#ansible-variable-precedence"><span class="std std-ref">Variable precedence: Where should I put a variable?</span></a>. The merging order is controlled by the order of the inventory source parameters. If <code>[all:vars]</code> in staging inventory defines <code>myvar = 1</code>, but production inventory defines <code>myvar = 2</code>, the playbook will be run with <code>myvar = 2</code>. The result would be reversed if the playbook was run with <code>-i production -i staging</code>.</p> <p><strong>Aggregating inventory sources with a directory</strong></p> <p>You can also create an inventory by combining multiple inventory sources and source types under a directory. This can be useful for combining static and dynamic hosts and managing them as one inventory. The following inventory combines an inventory plugin source, a dynamic inventory script, and a file with static hosts:</p> <pre data-language="text">inventory/
  openstack.yml          # configure inventory plugin to get hosts from Openstack cloud
  dynamic-inventory.py   # add additional hosts with dynamic inventory script
  static-inventory       # add static hosts and groups
  group_vars/
    all.yml              # assign variables to all hosts
</pre> <p>You can target this inventory directory simply like this:</p> <pre data-language="bash">ansible-playbook example.yml -i inventory
</pre> <p>It can be useful to control the merging order of the inventory sources if there’s variable conflicts or group of groups dependencies to the other inventory sources. The inventories are merged in ASCII order according to the filenames so the result can be controlled by adding prefixes to the files:</p> <pre data-language="text">inventory/
  01-openstack.yml          # configure inventory plugin to get hosts from Openstack cloud
  02-dynamic-inventory.py   # add additional hosts with dynamic inventory script
  03-static-inventory       # add static hosts
  group_vars/
    all.yml                 # assign variables to all hosts
</pre> <p>If <code>01-openstack.yml</code> defines <code>myvar = 1</code> for the group <code>all</code>, <code>02-dynamic-inventory.py</code> defines <code>myvar = 2</code>, and <code>03-static-inventory</code> defines <code>myvar = 3</code>, the playbook will be run with <code>myvar = 3</code>.</p> <p>For more details on inventory plugins and dynamic inventory scripts see <a class="reference internal" href="../plugins/inventory#inventory-plugins"><span class="std std-ref">Inventory Plugins</span></a> and <a class="reference internal" href="intro_dynamic_inventory#intro-dynamic-inventory"><span class="std std-ref">Working with dynamic inventory</span></a>.</p>   <h2 id="behavioral-parameters">Connecting to hosts: behavioral inventory parameters</h2> <p id="connecting-to-hosts-behavioral-inventory-parameters">As described above, setting the following variables control how Ansible interacts with remote hosts.</p> <p>Host connection:</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Ansible does not expose a channel to allow communication between the user and the ssh process to accept a password manually to decrypt an ssh key when using the ssh connection plugin (which is the default). The use of <code>ssh-agent</code> is highly recommended.</p> </div> <dl class="simple"> <dt>ansible_connection</dt>
<dd>
<p>Connection type to the host. This can be the name of any of ansible’s connection plugins. SSH protocol types are <code>smart</code>, <code>ssh</code> or <code>paramiko</code>. The default is smart. Non-SSH based types are described in the next section.</p> </dd> </dl> <p>General for all connections:</p> <dl class="simple"> <dt>ansible_host</dt>
<dd>
<p>The name of the host to connect to, if different from the alias you wish to give to it.</p> </dd> <dt>ansible_port</dt>
<dd>
<p>The connection port number, if not the default (22 for ssh)</p> </dd> <dt>ansible_user</dt>
<dd>
<p>The user name to use when connecting to the host</p> </dd> <dt>ansible_password</dt>
<dd>
<p>The password to use to authenticate to the host (never store this variable in plain text; always use a vault. See <a class="reference internal" href="playbooks_best_practices#tip-for-variables-and-vaults"><span class="std std-ref">Keep vaulted variables safely visible</span></a>)</p> </dd> </dl> <p>Specific to the SSH connection:</p> <dl class="simple"> <dt>ansible_ssh_private_key_file</dt>
<dd>
<p>Private key file used by ssh. Useful if using multiple keys and you don’t want to use SSH agent.</p> </dd> <dt>ansible_ssh_common_args</dt>
<dd>
<p>This setting is always appended to the default command line for <strong class="command">sftp</strong>, <strong class="command">scp</strong>, and <strong class="command">ssh</strong>. Useful to configure a <code>ProxyCommand</code> for a certain host (or group).</p> </dd> <dt>ansible_sftp_extra_args</dt>
<dd>
<p>This setting is always appended to the default <strong class="command">sftp</strong> command line.</p> </dd> <dt>ansible_scp_extra_args</dt>
<dd>
<p>This setting is always appended to the default <strong class="command">scp</strong> command line.</p> </dd> <dt>ansible_ssh_extra_args</dt>
<dd>
<p>This setting is always appended to the default <strong class="command">ssh</strong> command line.</p> </dd> <dt>ansible_ssh_pipelining</dt>
<dd>
<p>Determines whether or not to use SSH pipelining. This can override the <code>pipelining</code> setting in <code>ansible.cfg</code>.</p> </dd> <dt>ansible_ssh_executable (added in version 2.2)</dt>
<dd>
<p>This setting overrides the default behavior to use the system <strong class="command">ssh</strong>. This can override the <code>ssh_executable</code> setting in <code>ansible.cfg</code>.</p> </dd> </dl> <p>Privilege escalation (see <a class="reference internal" href="become#become"><span class="std std-ref">Ansible Privilege Escalation</span></a> for further details):</p> <dl class="simple"> <dt>ansible_become</dt>
<dd>
<p>Equivalent to <code>ansible_sudo</code> or <code>ansible_su</code>, allows to force privilege escalation</p> </dd> <dt>ansible_become_method</dt>
<dd>
<p>Allows to set privilege escalation method</p> </dd> <dt>ansible_become_user</dt>
<dd>
<p>Equivalent to <code>ansible_sudo_user</code> or <code>ansible_su_user</code>, allows to set the user you become through privilege escalation</p> </dd> <dt>ansible_become_password</dt>
<dd>
<p>Equivalent to <code>ansible_sudo_password</code> or <code>ansible_su_password</code>, allows you to set the privilege escalation password (never store this variable in plain text; always use a vault. See <a class="reference internal" href="playbooks_best_practices#tip-for-variables-and-vaults"><span class="std std-ref">Keep vaulted variables safely visible</span></a>)</p> </dd> <dt>ansible_become_exe</dt>
<dd>
<p>Equivalent to <code>ansible_sudo_exe</code> or <code>ansible_su_exe</code>, allows you to set the executable for the escalation method selected</p> </dd> <dt>ansible_become_flags</dt>
<dd>
<p>Equivalent to <code>ansible_sudo_flags</code> or <code>ansible_su_flags</code>, allows you to set the flags passed to the selected escalation method. This can be also set globally in <code>ansible.cfg</code> in the <code>sudo_flags</code> option</p> </dd> </dl> <p>Remote host environment parameters:</p> <dl class="simple" id="ansible-shell-type"> <dt>ansible_shell_type</dt>
<dd>
<p>The shell type of the target system. You should not use this setting unless you have set the <a class="reference internal" href="#ansible-shell-executable"><span class="std std-ref">ansible_shell_executable</span></a> to a non-Bourne (sh) compatible shell. By default commands are formatted using <code>sh</code>-style syntax. Setting this to <code>csh</code> or <code>fish</code> will cause commands executed on target systems to follow those shell’s syntax instead.</p> </dd> </dl> <dl class="simple" id="ansible-python-interpreter"> <dt>ansible_python_interpreter</dt>
<dd>
<p>The target host python path. This is useful for systems with more than one Python or not located at <strong class="command">/usr/bin/python</strong> such as *BSD, or where <strong class="command">/usr/bin/python</strong> is not a 2.X series Python. We do not use the <strong class="command">/usr/bin/env</strong> mechanism as that requires the remote user’s path to be set right and also assumes the <strong class="program">python</strong> executable is named python, where the executable might be named something like <strong class="program">python2.6</strong>.</p> </dd> <dt>ansible_*_interpreter</dt>
<dd>
<p>Works for anything such as ruby or perl and works just like <a class="reference internal" href="#ansible-python-interpreter"><span class="std std-ref">ansible_python_interpreter</span></a>. This replaces shebang of modules which will run on that host.</p> </dd> </dl> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.1.</span></p> </div> <dl class="simple" id="ansible-shell-executable"> <dt>ansible_shell_executable</dt>
<dd>
<p>This sets the shell the ansible controller will use on the target machine, overrides <code>executable</code> in <code>ansible.cfg</code> which defaults to <strong class="command">/bin/sh</strong>. You should really only change it if is not possible to use <strong class="command">/bin/sh</strong> (in other words, if <strong class="command">/bin/sh</strong> is not installed on the target machine or cannot be run from sudo.).</p> </dd> </dl> <p>Examples from an Ansible-INI host file:</p> <pre data-language="text">some_host         ansible_port=2222     ansible_user=manager
aws_host          ansible_ssh_private_key_file=/home/example/.ssh/aws.pem
freebsd_host      ansible_python_interpreter=/usr/local/bin/python
ruby_module_host  ansible_ruby_interpreter=/usr/bin/ruby.1.9.3
</pre>  <h3 id="non-ssh-connection-types">Non-SSH connection types</h3> <p>As stated in the previous section, Ansible executes playbooks over SSH but it is not limited to this connection type. With the host specific parameter <code>ansible_connection=&lt;connector&gt;</code>, the connection type can be changed. The following non-SSH based connectors are available:</p> <p><strong>local</strong></p> <p>This connector can be used to deploy the playbook to the control machine itself.</p> <p><strong>docker</strong></p> <p>This connector deploys the playbook directly into Docker containers using the local Docker client. The following parameters are processed by this connector:</p> <dl class="simple"> <dt>ansible_host</dt>
<dd>
<p>The name of the Docker container to connect to.</p> </dd> <dt>ansible_user</dt>
<dd>
<p>The user name to operate within the container. The user must exist inside the container.</p> </dd> <dt>ansible_become</dt>
<dd>
<p>If set to <code>true</code> the <code>become_user</code> will be used to operate within the container.</p> </dd> <dt>ansible_docker_extra_args</dt>
<dd>
<p>Could be a string with any additional arguments understood by Docker, which are not command specific. This parameter is mainly used to configure a remote Docker daemon to use.</p> </dd> </dl> <p>Here is an example of how to instantly deploy to created containers:</p> <pre data-language="yaml">- name: Create a jenkins container
  community.general.docker_container:
    docker_host: myserver.net:4243
    name: my_jenkins
    image: jenkins

- name: Add the container to inventory
  ansible.builtin.add_host:
    name: my_jenkins
    ansible_connection: docker
    ansible_docker_extra_args: "--tlsverify --tlscacert=/path/to/ca.pem --tlscert=/path/to/client-cert.pem --tlskey=/path/to/client-key.pem -H=tcp://myserver.net:4243"
    ansible_user: jenkins
  changed_when: false

- name: Create a directory for ssh keys
  delegate_to: my_jenkins
  ansible.builtin.file:
    path: "/var/jenkins_home/.ssh/jupiter"
    state: directory
</pre> <p>For a full list with available plugins and examples, see <a class="reference internal" href="../plugins/connection#connection-plugin-list"><span class="std std-ref">Plugin List</span></a>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If you’re reading the docs from the beginning, this may be the first example you’ve seen of an Ansible playbook. This is not an inventory file. Playbooks will be covered in great detail later in the docs.</p> </div>    <h2 id="id4">Inventory setup examples</h2> <p id="inventory-setup-examples">See also <a class="reference internal" href="sample_setup#sample-setup"><span class="std std-ref">Sample Ansible setup</span></a>, which shows inventory along with playbooks and other Ansible artifacts.</p>  <h3 id="inventory-setup-per-environment">Example: One inventory per environment</h3> <p id="example-one-inventory-per-environment">If you need to manage multiple environments it’s sometimes prudent to have only hosts of a single environment defined per inventory. This way, it is harder to, for instance, accidentally change the state of nodes inside the “test” environment when you actually wanted to update some “staging” servers.</p> <p>For the example mentioned above you could have an <code>inventory_test</code> file:</p> <pre data-language="ini">[dbservers]
db01.test.example.com
db02.test.example.com

[appservers]
app01.test.example.com
app02.test.example.com
app03.test.example.com
</pre> <p>That file only includes hosts that are part of the “test” environment. Define the “staging” machines in another file called <code>inventory_staging</code>:</p> <pre data-language="ini">[dbservers]
db01.staging.example.com
db02.staging.example.com

[appservers]
app01.staging.example.com
app02.staging.example.com
app03.staging.example.com
</pre> <p>To apply a playbook called <code>site.yml</code> to all the app servers in the test environment, use the following command:</p> <pre data-language="YAML">ansible-playbook -i inventory_test site.yml -l appservers
</pre>   <h3 id="inventory-setup-per-function">Example: Group by function</h3> <p id="example-group-by-function">In the previous section you already saw an example for using groups in order to cluster hosts that have the same function. This allows you, for instance, to define firewall rules inside a playbook or role without affecting database servers:</p> <pre data-language="yaml">- hosts: dbservers
  tasks:
  - name: Allow access from 10.0.0.1
    ansible.builtin.iptables:
      chain: INPUT
      jump: ACCEPT
      source: 10.0.0.1
</pre>   <h3 id="inventory-setup-per-location">Example: Group by location</h3> <p id="example-group-by-location">Other tasks might be focused on where a certain host is located. Let’s say that <code>db01.test.example.com</code> and <code>app01.test.example.com</code> are located in DC1 while <code>db02.test.example.com</code> is in DC2:</p> <pre data-language="ini">[dc1]
db01.test.example.com
app01.test.example.com

[dc2]
db02.test.example.com
</pre> <p>In practice, you might even end up mixing all these setups as you might need to, on one day, update all nodes in a specific data center while, on another day, update all the application servers no matter their location.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="../plugins/inventory#inventory-plugins"><span class="std std-ref">Inventory Plugins</span></a></dt>
<dd>
<p>Pulling inventory from dynamic or static sources</p> </dd> <dt><a class="reference internal" href="intro_dynamic_inventory#intro-dynamic-inventory"><span class="std std-ref">Working with dynamic inventory</span></a></dt>
<dd>
<p>Pulling inventory from dynamic sources, such as cloud providers</p> </dd> <dt><a class="reference internal" href="intro_adhoc#intro-adhoc"><span class="std std-ref">Introduction to ad-hoc commands</span></a></dt>
<dd>
<p>Examples of basic commands</p> </dd> <dt><a class="reference internal" href="playbooks#working-with-playbooks"><span class="std std-ref">Working with playbooks</span></a></dt>
<dd>
<p>Learning Ansible’s configuration, deployment, and orchestration language.</p> </dd> <dt><a class="reference external" href="https://groups.google.com/group/ansible-project">Mailing List</a></dt>
<dd>
<p>Questions? Help? Ideas? Stop by the list on Google Groups</p> </dd> <dt><a class="reference external" href="http://irc.freenode.net">irc.freenode.net</a></dt>
<dd>
<p>#ansible IRC chat channel</p> </dd> </dl> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012–2018 Michael DeHaan<br>© 2018–2019 Red Hat, Inc.<br>Licensed under the GNU General Public License version 3.<br>
    <a href="https://docs.ansible.com/ansible/2.10/user_guide/intro_inventory.html" class="_attribution-link">https://docs.ansible.com/ansible/2.10/user_guide/intro_inventory.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
