
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>std&#58;&#58;collections&#58;&#58;BinaryHeap - Rust - W3cubDocs</title>
  
  <meta name="description" content=" A priority queue implemented with a binary heap. ">
  <meta name="keywords" content="struct, std, collections, binaryheap, rust">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/rust/std/collections/struct.binaryheap.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/rust.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/rust/" class="_nav-link" title="" style="margin-left:0;">Rust</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _rust">
				
				
<h1 class="fqn">Struct std::collections::BinaryHeap</h1>
<pre class="rust struct" data-language="rust">pub struct BinaryHeap&lt;T&gt; { /* fields omitted */ }</pre>
<p>A priority queue implemented with a binary heap.</p> <p>This will be a max-heap.</p> <p>It is a logic error for an item to be modified in such a way that the item's ordering relative to any other item, as determined by the <code>Ord</code> trait, changes while it is in the heap. This is normally only possible through <code>Cell</code>, <code>RefCell</code>, global state, I/O, or unsafe code.</p> <h2 id="examples" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;

// Type inference lets us omit an explicit type signature (which
// would be `BinaryHeap&lt;i32&gt;` in this example).
let mut heap = BinaryHeap::new();

// We can use peek to look at the next item in the heap. In this case,
// there's no items in there yet so we get None.
assert_eq!(heap.peek(), None);

// Let's add some scores...
heap.push(1);
heap.push(5);
heap.push(2);

// Now peek shows the most important item in the heap.
assert_eq!(heap.peek(), Some(&amp;5));

// We can check the length of a heap.
assert_eq!(heap.len(), 3);

// We can iterate over the items in the heap, although they are returned in
// a random order.
for x in &amp;heap {
    println!("{}", x);
}

// If we instead pop these scores, they should come back in order.
assert_eq!(heap.pop(), Some(5));
assert_eq!(heap.pop(), Some(2));
assert_eq!(heap.pop(), Some(1));
assert_eq!(heap.pop(), None);

// We can clear the heap of any remaining items.
heap.clear();

// The heap should now be empty.
assert!(heap.is_empty())</pre></div> <h3 id="min-heap" class="section-header">Min-heap</h3> <p>Either <code>std::cmp::Reverse</code> or a custom <code>Ord</code> implementation can be used to make <code>BinaryHeap</code> a min-heap. This makes <code>heap.pop()</code> return the smallest value instead of the greatest one.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
use std::cmp::Reverse;

let mut heap = BinaryHeap::new();

// Wrap values in `Reverse`
heap.push(Reverse(1));
heap.push(Reverse(5));
heap.push(Reverse(2));

// If we pop these scores now, they should come back in the reverse order.
assert_eq!(heap.pop(), Some(Reverse(1)));
assert_eq!(heap.pop(), Some(Reverse(2)));
assert_eq!(heap.pop(), Some(Reverse(5)));
assert_eq!(heap.pop(), None);</pre></div> <h2 id="time-complexity" class="section-header">Time complexity</h2>
<table>
<thead><tr>
<th><a href="#method.push">push</a></th>
<th><a href="#method.pop">pop</a></th>
<th>
<a href="#method.peek">peek</a>/<a href="#method.peek_mut">peek_mut</a>
</th>
</tr></thead>
<tbody> <tr>
<td>O(1)~</td>
<td>
<em>O</em>(log(<em>n</em>))</td>
<td>
<em>O</em>(1)</td>
</tr> </tbody>
</table> <p>The value for <code>push</code> is an expected cost; the method documentation gives a more detailed analysis.</p> <h2 id="implementations" class="small-section-header">Implementations</h2>
<h3 id="impl" class="impl">
<code class="in-band">impl&lt;T&gt; <a class="struct" href="struct.binaryheap" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where fmt-newline">where<br>Â Â Â Â T: <a class="trait" href="../cmp/trait.ord" title="trait std::cmp::Ord">Ord</a>,Â </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#338-696" title="goto source code">[src]</a>
</h3>
<h4 id="method.new" class="method">
<code>pub fn <a href="#method.new" class="fnname">new</a>() -&gt; <a class="struct" href="struct.binaryheap" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#351-353" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Creates an empty <code>BinaryHeap</code> as a max-heap.</p> <h2 id="examples-1" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let mut heap = BinaryHeap::new();
heap.push(4);</pre></div> </div>
<h4 id="method.with_capacity" class="method">
<code>pub fn <a href="#method.with_capacity" class="fnname">with_capacity</a>(capacity: <a class="primitive" href="../primitive.usize">usize</a>) -&gt; <a class="struct" href="struct.binaryheap" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#370-372" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Creates an empty <code>BinaryHeap</code> with a specific capacity. This preallocates enough memory for <code>capacity</code> elements, so that the <code>BinaryHeap</code> does not have to be reallocated until it contains at least that many values.</p> <h2 id="examples-2" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let mut heap = BinaryHeap::with_capacity(10);
heap.push(4);</pre></div> </div>
<h4 id="method.peek_mut" class="method">
<code>pub fn <a href="#method.peek_mut" class="fnname">peek_mut</a>(&amp;mut self) -&gt; <a class="enum" href="../option/enum.option" title="enum std::option::Option">Option</a>&lt;<a class="struct" href="binary_heap/struct.peekmut" title="struct std::collections::binary_heap::PeekMut">PeekMut</a>&lt;'_, T&gt;&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#403-405" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.12.0">1.12.0</span>
</h4>
<div class="docblock">
<p>Returns a mutable reference to the greatest item in the binary heap, or <code>None</code> if it is empty.</p> <p>Note: If the <code>PeekMut</code> value is leaked, the heap may be in an inconsistent state.</p> <h2 id="examples-3" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let mut heap = BinaryHeap::new();
assert!(heap.peek_mut().is_none());

heap.push(1);
heap.push(5);
heap.push(2);
{
    let mut val = heap.peek_mut().unwrap();
    *val = 0;
}
assert_eq!(heap.peek(), Some(&amp;2));</pre></div> <h2 id="time-complexity-1" class="section-header">Time complexity</h2> <p>Cost is <em>O</em>(1) in the worst case.</p> </div>
<h4 id="method.pop" class="method">
<code>pub fn <a href="#method.pop" class="fnname">pop</a>(&amp;mut self) -&gt; <a class="enum" href="../option/enum.option" title="enum std::option::Option">Option</a>&lt;T&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#427-435" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Removes the greatest item from the binary heap and returns it, or <code>None</code> if it is empty.</p> <h2 id="examples-4" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let mut heap = BinaryHeap::from(vec![1, 3]);

assert_eq!(heap.pop(), Some(3));
assert_eq!(heap.pop(), Some(1));
assert_eq!(heap.pop(), None);</pre></div> <h2 id="time-complexity-2" class="section-header">Time complexity</h2> <p>The worst case cost of <code>pop</code> on a heap containing <em>n</em> elements is <em>O</em>(log(<em>n</em>)).</p> </div>
<h4 id="method.push" class="method">
<code>pub fn <a href="#method.push" class="fnname">push</a>(&amp;mut self, item: T)</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#470-474" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Pushes an item onto the binary heap.</p> <h2 id="examples-5" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let mut heap = BinaryHeap::new();
heap.push(3);
heap.push(5);
heap.push(1);

assert_eq!(heap.len(), 3);
assert_eq!(heap.peek(), Some(&amp;5));</pre></div> <h2 id="time-complexity-3" class="section-header">Time complexity</h2> <p>The expected cost of <code>push</code>, averaged over every possible ordering of the elements being pushed, and over a sufficiently large number of pushes, is <em>O</em>(1). This is the most meaningful cost metric when pushing elements that are <em>not</em> already in any sorted pattern.</p> <p>The time complexity degrades if elements are pushed in predominantly ascending order. In the worst case, elements are pushed in ascending sorted order and the amortized cost per push is <em>O</em>(log(<em>n</em>)) against a heap containing <em>n</em> elements.</p> <p>The worst case cost of a <em>single</em> call to <code>push</code> is <em>O</em>(<em>n</em>). The worst case occurs when capacity is exhausted and needs a resize. The resize cost has been amortized in the previous figures.</p> </div>
<h4 id="method.into_sorted_vec" class="method">
<code>pub fn <a href="#method.into_sorted_vec" class="fnname">into_sorted_vec</a>(self) -&gt; <a class="struct" href="../vec/struct.vec" title="struct std::vec::Vec">Vec</a>&lt;T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Vec&lt;u8&gt;</h3>
<pre class="content">impl Write for Vec&lt;u8&gt;
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#494-502" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span>
</h4>
<div class="docblock">
<p>Consumes the <code>BinaryHeap</code> and returns a vector in sorted (ascending) order.</p> <h2 id="examples-6" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;

let mut heap = BinaryHeap::from(vec![1, 2, 4, 5, 7]);
heap.push(6);
heap.push(3);

let vec = heap.into_sorted_vec();
assert_eq!(vec, [1, 2, 3, 4, 5, 6, 7]);</pre></div> </div>
<h4 id="method.append" class="method">
<code>pub fn <a href="#method.append" class="fnname">append</a>(&amp;mut self, other: &amp;mut <a class="struct" href="struct.binaryheap" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt;)</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#609-639" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.11.0">1.11.0</span>
</h4>
<div class="docblock">
<p>Moves all the elements of <code>other</code> into <code>self</code>, leaving <code>other</code> empty.</p> <h2 id="examples-7" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;

let v = vec![-10, 1, 2, 3, 3];
let mut a = BinaryHeap::from(v);

let v = vec![-20, 5, 43];
let mut b = BinaryHeap::from(v);

a.append(&amp;mut b);

assert_eq!(a.into_sorted_vec(), [-20, -10, 1, 2, 3, 3, 5, 43]);
assert!(b.is_empty());</pre></div> </div>
<h4 id="method.drain_sorted" class="method">
<code>pub fn <a href="#method.drain_sorted" class="fnname">drain_sorted</a>(&amp;mut self) -&gt; <a class="struct" href="binary_heap/struct.drainsorted" title="struct std::collections::binary_heap::DrainSorted">DrainSorted</a>&lt;'_, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for DrainSorted&lt;'_, T&gt;</h3>
<pre class="content">impl&lt;'_, T&gt; Iterator for DrainSorted&lt;'_, T&gt; where
Â Â Â Â T: Ord,Â 
    type Item = T;
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#665-667" title="goto source code">[src]</a>
</h4>
<div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (binary_heap_drain_sorted #59278)</span></div>
<div class="docblock">
<p>Returns an iterator which retrieves elements in heap order. The retrieved elements are removed from the original heap. The remaining elements will be removed on drop in heap order.</p> <p>Note:</p> <ul> <li>
<code>.drain_sorted()</code> is <em>O</em>(<em>n</em> * log(<em>n</em>)); much slower than <code>.drain()</code>. You should use the latter for most cases.</li> </ul> <h2 id="examples-8" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(binary_heap_drain_sorted)]
use std::collections::BinaryHeap;

let mut heap = BinaryHeap::from(vec![1, 2, 3, 4, 5]);
assert_eq!(heap.len(), 5);

drop(heap.drain_sorted()); // removes all elements in heap order
assert_eq!(heap.len(), 0);</pre></div> </div>
<h4 id="method.retain" class="method">
<code>pub fn <a href="#method.retain" class="fnname">retain</a>&lt;F&gt;(&amp;mut self, f: F) <span class="where fmt-newline">where<br>Â Â Â Â F: <a class="trait" href="../ops/trait.fnmut" title="trait std::ops::FnMut">FnMut</a>(<a class="primitive" href="../primitive.reference">&amp;</a>T) -&gt; <a class="primitive" href="../primitive.bool">bool</a>,Â </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#689-695" title="goto source code">[src]</a>
</h4>
<div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (binary_heap_retain #71503)</span></div>
<div class="docblock">
<p>Retains only the elements specified by the predicate.</p> <p>In other words, remove all elements <code>e</code> such that <code>f(&amp;e)</code> returns <code>false</code>. The elements are visited in unsorted (and unspecified) order.</p> <h2 id="examples-9" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(binary_heap_retain)]
use std::collections::BinaryHeap;

let mut heap = BinaryHeap::from(vec![-10, -5, 1, 2, 4, 13]);

heap.retain(|x| x % 2 == 0); // only keep even numbers

assert_eq!(heap.into_sorted_vec(), [-10, 2, 4])</pre></div> </div>
<h3 id="impl-1" class="impl">
<code class="in-band">impl&lt;T&gt; <a class="struct" href="struct.binaryheap" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#698-986" title="goto source code">[src]</a>
</h3>
<h4 id="method.iter" class="method">
<code>pub fn <a href="#method.iter" class="fnname">iter</a>(&amp;self) -&gt; <a class="struct" href="binary_heap/struct.iter" title="struct std::collections::binary_heap::Iter">Iter</a>&lt;'_, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Iter&lt;'a, T&gt;</h3>
<pre class="content">impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt;
    type Item = &amp;'a T;
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#716-718" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns an iterator visiting all values in the underlying vector, in arbitrary order.</p> <h2 id="examples-10" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let heap = BinaryHeap::from(vec![1, 2, 3, 4]);

// Print 1, 2, 3, 4 in arbitrary order
for x in heap.iter() {
    println!("{}", x);
}</pre></div> </div>
<h4 id="method.into_iter_sorted" class="method">
<code>pub fn <a href="#method.into_iter_sorted" class="fnname">into_iter_sorted</a>(self) -&gt; <a class="struct" href="binary_heap/struct.intoitersorted" title="struct std::collections::binary_heap::IntoIterSorted">IntoIterSorted</a>&lt;T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for IntoIterSorted&lt;T&gt;</h3>
<pre class="content">impl&lt;T&gt; Iterator for IntoIterSorted&lt;T&gt; where
Â Â Â Â T: Ord,Â 
    type Item = T;
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#735-737" title="goto source code">[src]</a>
</h4>
<div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (binary_heap_into_iter_sorted #59278)</span></div>
<div class="docblock">
<p>Returns an iterator which retrieves elements in heap order. This method consumes the original heap.</p> <h2 id="examples-11" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(binary_heap_into_iter_sorted)]
use std::collections::BinaryHeap;
let heap = BinaryHeap::from(vec![1, 2, 3, 4, 5]);

assert_eq!(heap.into_iter_sorted().take(2).collect::&lt;Vec&lt;_&gt;&gt;(), vec![5, 4]);</pre></div> </div>
<h4 id="method.peek" class="method">
<code>pub fn <a href="#method.peek" class="fnname">peek</a>(&amp;self) -&gt; <a class="enum" href="../option/enum.option" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="../primitive.reference">&amp;</a>T&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#761-763" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns the greatest item in the binary heap, or <code>None</code> if it is empty.</p> <h2 id="examples-12" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let mut heap = BinaryHeap::new();
assert_eq!(heap.peek(), None);

heap.push(1);
heap.push(5);
heap.push(2);
assert_eq!(heap.peek(), Some(&amp;5));
</pre></div> <h2 id="time-complexity-4" class="section-header">Time complexity</h2> <p>Cost is <em>O</em>(1) in the worst case.</p> </div>
<h4 id="method.capacity" class="method">
<code>pub fn <a href="#method.capacity" class="fnname">capacity</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.usize">usize</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#778-780" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns the number of elements the binary heap can hold without reallocating.</p> <h2 id="examples-13" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let mut heap = BinaryHeap::with_capacity(100);
assert!(heap.capacity() &gt;= 100);
heap.push(4);</pre></div> </div>
<h4 id="method.reserve_exact" class="method">
<code>pub fn <a href="#method.reserve_exact" class="fnname">reserve_exact</a>(&amp;mut self, additional: <a class="primitive" href="../primitive.usize">usize</a>)</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#807-809" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Reserves the minimum capacity for exactly <code>additional</code> more elements to be inserted in the given <code>BinaryHeap</code>. Does nothing if the capacity is already sufficient.</p> <p>Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer <a href="#method.reserve"><code>reserve</code></a> if future insertions are expected.</p> <h2 id="panics" class="section-header">Panics</h2> <p>Panics if the new capacity overflows <code>usize</code>.</p> <h2 id="examples-14" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let mut heap = BinaryHeap::new();
heap.reserve_exact(100);
assert!(heap.capacity() &gt;= 100);
heap.push(4);</pre></div> </div>
<h4 id="method.reserve" class="method">
<code>pub fn <a href="#method.reserve" class="fnname">reserve</a>(&amp;mut self, additional: <a class="primitive" href="../primitive.usize">usize</a>)</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#830-832" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Reserves capacity for at least <code>additional</code> more elements to be inserted in the <code>BinaryHeap</code>. The collection may reserve more space to avoid frequent reallocations.</p> <h2 id="panics-1" class="section-header">Panics</h2> <p>Panics if the new capacity overflows <code>usize</code>.</p> <h2 id="examples-15" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let mut heap = BinaryHeap::new();
heap.reserve(100);
assert!(heap.capacity() &gt;= 100);
heap.push(4);</pre></div> </div>
<h4 id="method.shrink_to_fit" class="method">
<code>pub fn <a href="#method.shrink_to_fit" class="fnname">shrink_to_fit</a>(&amp;mut self)</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#849-851" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Discards as much additional capacity as possible.</p> <h2 id="examples-16" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let mut heap: BinaryHeap&lt;i32&gt; = BinaryHeap::with_capacity(100);

assert!(heap.capacity() &gt;= 100);
heap.shrink_to_fit();
assert!(heap.capacity() == 0);</pre></div> </div>
<h4 id="method.shrink_to" class="method">
<code>pub fn <a href="#method.shrink_to" class="fnname">shrink_to</a>(&amp;mut self, min_capacity: <a class="primitive" href="../primitive.usize">usize</a>)</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#874-876" title="goto source code">[src]</a>
</h4>
<div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (shrink_to #56431)new API </span></div>
<div class="docblock">
<p>Discards capacity with a lower bound.</p> <p>The capacity will remain at least as large as both the length and the supplied value.</p> <p>Panics if the current capacity is smaller than the supplied minimum capacity.</p> <h2 id="examples-17" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(shrink_to)]
use std::collections::BinaryHeap;
let mut heap: BinaryHeap&lt;i32&gt; = BinaryHeap::with_capacity(100);

assert!(heap.capacity() &gt;= 100);
heap.shrink_to(10);
assert!(heap.capacity() &gt;= 10);</pre></div> </div>
<h4 id="method.into_vec" class="method">
<code>pub fn <a href="#method.into_vec" class="fnname">into_vec</a>(self) -&gt; <a class="struct" href="../vec/struct.vec" title="struct std::vec::Vec">Vec</a>&lt;T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Vec&lt;u8&gt;</h3>
<pre class="content">impl Write for Vec&lt;u8&gt;
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#896-898" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span>
</h4>
<div class="docblock">
<p>Consumes the <code>BinaryHeap</code> and returns the underlying vector in arbitrary order.</p> <h2 id="examples-18" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let heap = BinaryHeap::from(vec![1, 2, 3, 4, 5, 6, 7]);
let vec = heap.into_vec();

// Will print in some order
for x in vec {
    println!("{}", x);
}</pre></div> </div>
<h4 id="method.len" class="method">
<code>pub fn <a href="#method.len" class="fnname">len</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.usize">usize</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#913-915" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns the length of the binary heap.</p> <h2 id="examples-19" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let heap = BinaryHeap::from(vec![1, 3]);

assert_eq!(heap.len(), 2);</pre></div> </div>
<h4 id="method.is_empty" class="method">
<code>pub fn <a href="#method.is_empty" class="fnname">is_empty</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#936-938" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Checks if the binary heap is empty.</p> <h2 id="examples-20" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let mut heap = BinaryHeap::new();

assert!(heap.is_empty());

heap.push(3);
heap.push(5);
heap.push(1);

assert!(!heap.is_empty());</pre></div> </div>
<h4 id="method.drain" class="method">
<code>pub fn <a href="#method.drain" class="fnname">drain</a>(&amp;mut self) -&gt; <a class="struct" href="binary_heap/struct.drain" title="struct std::collections::binary_heap::Drain">Drain</a>&lt;'_, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Drain&lt;'_, T&gt;</h3>
<pre class="content">impl&lt;'_, T&gt; Iterator for Drain&lt;'_, T&gt;
    type Item = T;
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#962-964" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span>
</h4>
<div class="docblock">
<p>Clears the binary heap, returning an iterator over the removed elements.</p> <p>The elements are removed in arbitrary order.</p> <h2 id="examples-21" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let mut heap = BinaryHeap::from(vec![1, 3]);

assert!(!heap.is_empty());

for x in heap.drain() {
    println!("{}", x);
}

assert!(heap.is_empty());</pre></div> </div>
<h4 id="method.clear" class="method">
<code>pub fn <a href="#method.clear" class="fnname">clear</a>(&amp;mut self)</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#983-985" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Drops all items from the binary heap.</p> <h2 id="examples-22" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let mut heap = BinaryHeap::from(vec![1, 3]);

assert!(!heap.is_empty());

heap.clear();

assert!(heap.is_empty());</pre></div> </div>
<h2 id="trait-implementations" class="small-section-header">Trait Implementations</h2>
<div id="trait-implementations-list">
<h3 id="impl-Clone" class="impl">
<code class="in-band">impl&lt;T&gt; <a class="trait" href="../clone/trait.clone" title="trait std::clone::Clone">Clone</a> for <a class="struct" href="struct.binaryheap" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where fmt-newline">where<br>Â Â Â Â T: <a class="trait" href="../clone/trait.clone" title="trait std::clone::Clone">Clone</a>,Â </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#312-320" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.clone" class="method hidden">
<code>fn <a href="../clone/trait.clone#tymethod.clone" class="fnname">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.binaryheap" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#313-315" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Returns a copy of the value. <a href="../clone/trait.clone#tymethod.clone">Read more</a></p> </div>
<h4 id="method.clone_from" class="method hidden">
<code>fn <a href="../clone/trait.clone#method.clone_from" class="fnname">clone_from</a>(&amp;mut self, source: &amp;<a class="struct" href="struct.binaryheap" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt;)</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#317-319" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs copy-assignment from <code>source</code>. <a href="../clone/trait.clone#method.clone_from">Read more</a></p> </div>
</div>
<h3 id="impl-Debug" class="impl">
<code class="in-band">impl&lt;T&gt; <a class="trait" href="../fmt/trait.debug" title="trait std::fmt::Debug">Debug</a> for <a class="struct" href="struct.binaryheap" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where fmt-newline">where<br>Â Â Â Â T: <a class="trait" href="../fmt/trait.debug" title="trait std::fmt::Debug">Debug</a>,Â </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#332-336" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span>
</h3>
<div class="impl-items">
<h4 id="method.fmt" class="method hidden">
<code>fn <a href="../fmt/trait.debug#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="../fmt/struct.formatter" title="struct std::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="../result/enum.result" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="../primitive.unit">()</a>, <a class="struct" href="../fmt/struct.error" title="struct std::fmt::Error">Error</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#333-335" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Formats the value using the given formatter. <a href="../fmt/trait.debug#tymethod.fmt">Read more</a></p> </div>
</div>
<h3 id="impl-Default" class="impl">
<code class="in-band">impl&lt;T&gt; <a class="trait" href="../default/trait.default" title="trait std::default::Default">Default</a> for <a class="struct" href="struct.binaryheap" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where fmt-newline">where<br>Â Â Â Â T: <a class="trait" href="../cmp/trait.ord" title="trait std::cmp::Ord">Ord</a>,Â </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#323-329" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.default" class="method">
<code>fn <a href="../default/trait.default#tymethod.default" class="fnname">default</a>() -&gt; <a class="struct" href="struct.binaryheap" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#326-328" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Creates an empty <code>BinaryHeap&lt;T&gt;</code>.</p> </div>
</div>
<h3 id="impl-Extend%3C%26%27a%20T%3E" class="impl">
<code class="in-band">impl&lt;'a, T&gt; <a class="trait" href="../iter/trait.extend" title="trait std::iter::Extend">Extend</a>&lt;<a class="primitive" href="../primitive.reference">&amp;'a </a>T&gt; for <a class="struct" href="struct.binaryheap" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where fmt-newline">where<br>Â Â Â Â T: 'a + <a class="trait" href="../cmp/trait.ord" title="trait std::cmp::Ord">Ord</a> + <a class="trait" href="../marker/trait.copy" title="trait std::marker::Copy">Copy</a>,Â </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#1417-1431" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span>
</h3>
<div class="impl-items">
<h4 id="method.extend-1" class="method hidden">
<code>fn <a href="../iter/trait.extend#tymethod.extend" class="fnname">extend</a>&lt;I&gt;(&amp;mut self, iter: I) <span class="where fmt-newline">where<br>Â Â Â Â I: <a class="trait" href="../iter/trait.intoiterator" title="trait std::iter::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="../primitive.reference">&amp;'a </a>T&gt;,Â </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#1418-1420" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Extends a collection with the contents of an iterator. <a href="../iter/trait.extend#tymethod.extend">Read more</a></p> </div>
<h4 id="method.extend_one-1" class="method hidden">
<code>fn <a href="../iter/trait.extend#method.extend_one" class="fnname">extend_one</a>(&amp;mut self, <a class="primitive" href="../primitive.reference">&amp;'a </a>T)</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#1423-1425" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (extend_one #72631)</span></div>
<div class="docblock hidden">
<p>Extends a collection with exactly one element.</p> </div>
<h4 id="method.extend_reserve-1" class="method hidden">
<code>fn <a href="../iter/trait.extend#method.extend_reserve" class="fnname">extend_reserve</a>(&amp;mut self, additional: <a class="primitive" href="../primitive.usize">usize</a>)</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#1428-1430" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (extend_one #72631)</span></div>
<div class="docblock hidden">
<p>Reserves capacity in a collection for the given number of additional elements. <a href="../iter/trait.extend#method.extend_reserve">Read more</a></p> </div>
</div>
<h3 id="impl-Extend%3CT%3E" class="impl">
<code class="in-band">impl&lt;T&gt; <a class="trait" href="../iter/trait.extend" title="trait std::iter::Extend">Extend</a>&lt;T&gt; for <a class="struct" href="struct.binaryheap" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where fmt-newline">where<br>Â Â Â Â T: <a class="trait" href="../cmp/trait.ord" title="trait std::cmp::Ord">Ord</a>,Â </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#1376-1391" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.extend" class="method hidden">
<code>fn <a href="../iter/trait.extend#tymethod.extend" class="fnname">extend</a>&lt;I&gt;(&amp;mut self, iter: I) <span class="where fmt-newline">where<br>Â Â Â Â I: <a class="trait" href="../iter/trait.intoiterator" title="trait std::iter::IntoIterator">IntoIterator</a>&lt;Item = T&gt;,Â </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#1378-1380" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Extends a collection with the contents of an iterator. <a href="../iter/trait.extend#tymethod.extend">Read more</a></p> </div>
<h4 id="method.extend_one" class="method hidden">
<code>fn <a href="../iter/trait.extend#method.extend_one" class="fnname">extend_one</a>(&amp;mut self, item: T)</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#1383-1385" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (extend_one #72631)</span></div>
<div class="docblock hidden">
<p>Extends a collection with exactly one element.</p> </div>
<h4 id="method.extend_reserve" class="method hidden">
<code>fn <a href="../iter/trait.extend#method.extend_reserve" class="fnname">extend_reserve</a>(&amp;mut self, additional: <a class="primitive" href="../primitive.usize">usize</a>)</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#1388-1390" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (extend_one #72631)</span></div>
<div class="docblock hidden">
<p>Reserves capacity in a collection for the given number of additional elements. <a href="../iter/trait.extend#method.extend_reserve">Read more</a></p> </div>
</div>
<h3 id="impl-From%3CBinaryHeap%3CT%3E%3E" class="impl">
<code class="in-band">impl&lt;T&gt; <a class="trait" href="../convert/trait.from" title="trait std::convert::From">From</a>&lt;<a class="struct" href="struct.binaryheap" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt;&gt; for <a class="struct" href="../vec/struct.vec" title="struct std::vec::Vec">Vec</a>&lt;T&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#1324-1328" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span>
</h3>
<div class="impl-items">
<h4 id="method.from-1" class="method hidden">
<code>fn <a href="../convert/trait.from#tymethod.from" class="fnname">from</a>(heap: <a class="struct" href="struct.binaryheap" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt;) -&gt; <a class="struct" href="../vec/struct.vec" title="struct std::vec::Vec">Vec</a>&lt;T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Vec&lt;u8&gt;</h3>
<pre class="content">impl Write for Vec&lt;u8&gt;
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#1325-1327" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs the conversion.</p> </div>
</div>
<h3 id="impl-From%3CVec%3CT%3E%3E" class="impl">
<code class="in-band">impl&lt;T&gt; <a class="trait" href="../convert/trait.from" title="trait std::convert::From">From</a>&lt;<a class="struct" href="../vec/struct.vec" title="struct std::vec::Vec">Vec</a>&lt;T&gt;&gt; for <a class="struct" href="struct.binaryheap" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where fmt-newline">where<br>Â Â Â Â T: <a class="trait" href="../cmp/trait.ord" title="trait std::cmp::Ord">Ord</a>,Â </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#1312-1321" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span>
</h3>
<div class="impl-items">
<h4 id="method.from" class="method">
<code>fn <a href="../convert/trait.from#tymethod.from" class="fnname">from</a>(vec: <a class="struct" href="../vec/struct.vec" title="struct std::vec::Vec">Vec</a>&lt;T&gt;) -&gt; <a class="struct" href="struct.binaryheap" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#1316-1320" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Converts a <code>Vec&lt;T&gt;</code> into a <code>BinaryHeap&lt;T&gt;</code>.</p> <p>This conversion happens in-place, and has <em>O</em>(<em>n</em>) time complexity.</p> </div>
</div>
<h3 id="impl-FromIterator%3CT%3E" class="impl">
<code class="in-band">impl&lt;T&gt; <a class="trait" href="../iter/trait.fromiterator" title="trait std::iter::FromIterator">FromIterator</a>&lt;T&gt; for <a class="struct" href="struct.binaryheap" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where fmt-newline">where<br>Â Â Â Â T: <a class="trait" href="../cmp/trait.ord" title="trait std::cmp::Ord">Ord</a>,Â </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#1331-1335" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.from_iter" class="method hidden">
<code>fn <a href="../iter/trait.fromiterator#tymethod.from_iter" class="fnname">from_iter</a>&lt;I&gt;(iter: I) -&gt; <a class="struct" href="struct.binaryheap" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where fmt-newline">where<br>Â Â Â Â I: <a class="trait" href="../iter/trait.intoiterator" title="trait std::iter::IntoIterator">IntoIterator</a>&lt;Item = T&gt;,Â </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#1332-1334" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Creates a value from an iterator. <a href="../iter/trait.fromiterator#tymethod.from_iter">Read more</a></p> </div>
</div>
<h3 id="impl-IntoIterator" class="impl">
<code class="in-band">impl&lt;'a, T&gt; <a class="trait" href="../iter/trait.intoiterator" title="trait std::iter::IntoIterator">IntoIterator</a> for &amp;'a <a class="struct" href="struct.binaryheap" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#1366-1373" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="associatedtype.Item" class="type"><code>type <a href="../iter/trait.intoiterator#associatedtype.Item" class="type">Item</a> = <a class="primitive" href="../primitive.reference">&amp;'a </a>T</code></h4>
<div class="docblock">
<p>The type of the elements being iterated over.</p> </div>
<h4 id="associatedtype.IntoIter" class="type"><code>type <a href="../iter/trait.intoiterator#associatedtype.IntoIter" class="type">IntoIter</a> = <a class="struct" href="binary_heap/struct.iter" title="struct std::collections::binary_heap::Iter">Iter</a>&lt;'a, T&gt;</code></h4>
<div class="docblock">
<p>Which kind of iterator are we turning this into?</p> </div>
<h4 id="method.into_iter" class="method hidden">
<code>fn <a href="../iter/trait.intoiterator#tymethod.into_iter" class="fnname">into_iter</a>(self) -&gt; <a class="struct" href="binary_heap/struct.iter" title="struct std::collections::binary_heap::Iter">Iter</a>&lt;'a, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Iter&lt;'a, T&gt;</h3>
<pre class="content">impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt;
    type Item = &amp;'a T;
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#1370-1372" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Creates an iterator from a value. <a href="../iter/trait.intoiterator#tymethod.into_iter">Read more</a></p> </div>
</div>
<h3 id="impl-IntoIterator-1" class="impl">
<code class="in-band">impl&lt;T&gt; <a class="trait" href="../iter/trait.intoiterator" title="trait std::iter::IntoIterator">IntoIterator</a> for <a class="struct" href="struct.binaryheap" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#1338-1363" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="associatedtype.Item-1" class="type"><code>type <a href="../iter/trait.intoiterator#associatedtype.Item" class="type">Item</a> = T</code></h4>
<div class="docblock">
<p>The type of the elements being iterated over.</p> </div>
<h4 id="associatedtype.IntoIter-1" class="type"><code>type <a href="../iter/trait.intoiterator#associatedtype.IntoIter" class="type">IntoIter</a> = <a class="struct" href="binary_heap/struct.intoiter" title="struct std::collections::binary_heap::IntoIter">IntoIter</a>&lt;T&gt;</code></h4>
<div class="docblock">
<p>Which kind of iterator are we turning this into?</p> </div>
<h4 id="method.into_iter-1" class="method">
<code>fn <a href="../iter/trait.intoiterator#tymethod.into_iter" class="fnname">into_iter</a>(self) -&gt; <a class="struct" href="binary_heap/struct.intoiter" title="struct std::collections::binary_heap::IntoIter">IntoIter</a>&lt;T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for IntoIter&lt;T&gt;</h3>
<pre class="content">impl&lt;T&gt; Iterator for IntoIter&lt;T&gt;
    type Item = T;
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#1360-1362" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Creates a consuming iterator, that is, one that moves each value out of the binary heap in arbitrary order. The binary heap cannot be used after calling this.</p> <h2 id="examples-23" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let heap = BinaryHeap::from(vec![1, 2, 3, 4]);

// Print 1, 2, 3, 4 in arbitrary order
for x in heap.into_iter() {
    // x has type i32, not &amp;i32
    println!("{}", x);
}</pre></div> </div>
</div>
</div>
<h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations</h2>
<div id="synthetic-implementations-list">
<h3 id="impl-RefUnwindSafe" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="../panic/trait.refunwindsafe" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.binaryheap" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where fmt-newline">where<br>Â Â Â Â T: <a class="trait" href="../panic/trait.refunwindsafe" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a>,Â </span></code></h3>

<h3 id="impl-Send" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="../marker/trait.send" title="trait std::marker::Send">Send</a> for <a class="struct" href="struct.binaryheap" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where fmt-newline">where<br>Â Â Â Â T: <a class="trait" href="../marker/trait.send" title="trait std::marker::Send">Send</a>,Â </span></code></h3>

<h3 id="impl-Sync" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="../marker/trait.sync" title="trait std::marker::Sync">Sync</a> for <a class="struct" href="struct.binaryheap" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where fmt-newline">where<br>Â Â Â Â T: <a class="trait" href="../marker/trait.sync" title="trait std::marker::Sync">Sync</a>,Â </span></code></h3>

<h3 id="impl-Unpin" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="../marker/trait.unpin" title="trait std::marker::Unpin">Unpin</a> for <a class="struct" href="struct.binaryheap" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where fmt-newline">where<br>Â Â Â Â T: <a class="trait" href="../marker/trait.unpin" title="trait std::marker::Unpin">Unpin</a>,Â </span></code></h3>

<h3 id="impl-UnwindSafe" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="../panic/trait.unwindsafe" title="trait std::panic::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.binaryheap" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where fmt-newline">where<br>Â Â Â Â T: <a class="trait" href="../panic/trait.unwindsafe" title="trait std::panic::UnwindSafe">UnwindSafe</a>,Â </span></code></h3>

</div>
<h2 id="blanket-implementations" class="small-section-header">Blanket Implementations</h2>
<div id="blanket-implementations-list">
<h3 id="impl-Any" class="impl">
<code class="in-band">impl&lt;T&gt; <a class="trait" href="../any/trait.any" title="trait std::any::Any">Any</a> for T <span class="where fmt-newline">where<br>Â Â Â Â T: 'static + ?<a class="trait" href="../marker/trait.sized" title="trait std::marker::Sized">Sized</a>,Â </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/any.rs.html#108-112" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.type_id" class="method hidden">
<code>fn <a href="../any/trait.any#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="../any/struct.typeid" title="struct std::any::TypeId">TypeId</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/any.rs.html#109-111" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Gets the <code>TypeId</code> of <code>self</code>. <a href="../any/trait.any#tymethod.type_id">Read more</a></p> </div>
</div>
<h3 id="impl-Borrow%3CT%3E" class="impl">
<code class="in-band">impl&lt;T&gt; <a class="trait" href="../borrow/trait.borrow" title="trait std::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>Â Â Â Â T: ?<a class="trait" href="../marker/trait.sized" title="trait std::marker::Sized">Sized</a>,Â </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/borrow.rs.html#210-214" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.borrow" class="method hidden">
<code>fn <a href="../borrow/trait.borrow#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.reference">&amp;</a>T<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for &amp;'_ mut F</h3>
<pre class="content">impl&lt;'_, F&gt; Future for &amp;'_ mut F where
Â Â Â Â F: Unpin + Future + ?Sized,Â 
    type Output = &lt;F as Future&gt;::Output;
impl&lt;'_, I&gt; Iterator for &amp;'_ mut I where
Â Â Â Â I: Iterator + ?Sized,Â 
    type Item = &lt;I as Iterator&gt;::Item;
impl&lt;R:Â Read + ?Sized, '_&gt; Read for &amp;'_ mut R
impl&lt;W:Â Write + ?Sized, '_&gt; Write for &amp;'_ mut W
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/borrow.rs.html#211-213" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Immutably borrows from an owned value. <a href="../borrow/trait.borrow#tymethod.borrow">Read more</a></p> </div>
</div>
<h3 id="impl-BorrowMut%3CT%3E" class="impl">
<code class="in-band">impl&lt;T&gt; <a class="trait" href="../borrow/trait.borrowmut" title="trait std::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>Â Â Â Â T: ?<a class="trait" href="../marker/trait.sized" title="trait std::marker::Sized">Sized</a>,Â </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/borrow.rs.html#217-221" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.borrow_mut" class="method hidden">
<code>fn <a href="../borrow/trait.borrowmut#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="../primitive.reference">&amp;mut </a>T<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for &amp;'_ mut F</h3>
<pre class="content">impl&lt;'_, F&gt; Future for &amp;'_ mut F where
Â Â Â Â F: Unpin + Future + ?Sized,Â 
    type Output = &lt;F as Future&gt;::Output;
impl&lt;'_, I&gt; Iterator for &amp;'_ mut I where
Â Â Â Â I: Iterator + ?Sized,Â 
    type Item = &lt;I as Iterator&gt;::Item;
impl&lt;R:Â Read + ?Sized, '_&gt; Read for &amp;'_ mut R
impl&lt;W:Â Write + ?Sized, '_&gt; Write for &amp;'_ mut W
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/borrow.rs.html#218-220" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Mutably borrows from an owned value. <a href="../borrow/trait.borrowmut#tymethod.borrow_mut">Read more</a></p> </div>
</div>
<h3 id="impl-From%3CT%3E" class="impl">
<code class="in-band">impl&lt;T&gt; <a class="trait" href="../convert/trait.from" title="trait std::convert::From">From</a>&lt;T&gt; for T</code><a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#570-574" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.from-2" class="method hidden">
<code>fn <a href="../convert/trait.from#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</code><a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#571-573" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs the conversion.</p> </div>
</div>
<h3 id="impl-Into%3CU%3E" class="impl">
<code class="in-band">impl&lt;T, U&gt; <a class="trait" href="../convert/trait.into" title="trait std::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>Â Â Â Â U: <a class="trait" href="../convert/trait.from" title="trait std::convert::From">From</a>&lt;T&gt;,Â </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#559-566" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.into" class="method hidden">
<code>fn <a href="../convert/trait.into#tymethod.into" class="fnname">into</a>(self) -&gt; U</code><a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#563-565" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs the conversion.</p> </div>
</div>
<h3 id="impl-IntoIterator-2" class="impl">
<code class="in-band">impl&lt;I&gt; <a class="trait" href="../iter/trait.intoiterator" title="trait std::iter::IntoIterator">IntoIterator</a> for I <span class="where fmt-newline">where<br>Â Â Â Â I: <a class="trait" href="../iter/trait.iterator" title="trait std::iter::Iterator">Iterator</a>,Â </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/iter/traits/collect.rs.html#244-251" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="associatedtype.Item-2" class="type"><code>type <a href="../iter/trait.intoiterator#associatedtype.Item" class="type">Item</a> = &lt;I as <a class="trait" href="../iter/trait.iterator" title="trait std::iter::Iterator">Iterator</a>&gt;::<a class="type" href="../iter/trait.iterator#associatedtype.Item" title="type std::iter::Iterator::Item">Item</a></code></h4>
<div class="docblock">
<p>The type of the elements being iterated over.</p> </div>
<h4 id="associatedtype.IntoIter-2" class="type"><code>type <a href="../iter/trait.intoiterator#associatedtype.IntoIter" class="type">IntoIter</a> = I</code></h4>
<div class="docblock">
<p>Which kind of iterator are we turning this into?</p> </div>
<h4 id="method.into_iter-2" class="method hidden">
<code>fn <a href="../iter/trait.intoiterator#tymethod.into_iter" class="fnname">into_iter</a>(self) -&gt; I</code><a class="srclink" href="https://doc.rust-lang.org/src/core/iter/traits/collect.rs.html#248-250" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Creates an iterator from a value. <a href="../iter/trait.intoiterator#tymethod.into_iter">Read more</a></p> </div>
</div>
<h3 id="impl-ToOwned" class="impl">
<code class="in-band">impl&lt;T&gt; <a class="trait" href="../borrow/trait.toowned" title="trait std::borrow::ToOwned">ToOwned</a> for T <span class="where fmt-newline">where<br>Â Â Â Â T: <a class="trait" href="../clone/trait.clone" title="trait std::clone::Clone">Clone</a>,Â </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#80-92" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="associatedtype.Owned" class="type"><code>type <a href="../borrow/trait.toowned#associatedtype.Owned" class="type">Owned</a> = T</code></h4>
<div class="docblock">
<p>The resulting type after obtaining ownership.</p> </div>
<h4 id="method.to_owned" class="method hidden">
<code>fn <a href="../borrow/trait.toowned#tymethod.to_owned" class="fnname">to_owned</a>(&amp;self) -&gt; T</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#85-87" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Creates owned data from borrowed data, usually by cloning. <a href="../borrow/trait.toowned#tymethod.to_owned">Read more</a></p> </div>
<h4 id="method.clone_into" class="method hidden">
<code>fn <a href="../borrow/trait.toowned#method.clone_into" class="fnname">clone_into</a>(&amp;self, target: <a class="primitive" href="../primitive.reference">&amp;mut </a>T)</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#89-91" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (toowned_clone_into #41263)recently added </span></div>
<div class="docblock hidden">
<p>Uses borrowed data to replace owned data, usually by cloning. <a href="../borrow/trait.toowned#method.clone_into">Read more</a></p> </div>
</div>
<h3 id="impl-TryFrom%3CU%3E" class="impl">
<code class="in-band">impl&lt;T, U&gt; <a class="trait" href="../convert/trait.tryfrom" title="trait std::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>Â Â Â Â U: <a class="trait" href="../convert/trait.into" title="trait std::convert::Into">Into</a>&lt;T&gt;,Â </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#607-616" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="associatedtype.Error" class="type"><code>type <a href="../convert/trait.tryfrom#associatedtype.Error" class="type">Error</a> = <a class="enum" href="../convert/enum.infallible" title="enum std::convert::Infallible">Infallible</a></code></h4>
<div class="docblock">
<p>The type returned in the event of a conversion error.</p> </div>
<h4 id="method.try_from" class="method hidden">
<code>fn <a href="../convert/trait.tryfrom#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="../result/enum.result" title="enum std::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="../convert/trait.tryfrom" title="trait std::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="../convert/trait.tryfrom#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#613-615" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs the conversion.</p> </div>
</div>
<h3 id="impl-TryInto%3CU%3E" class="impl">
<code class="in-band">impl&lt;T, U&gt; <a class="trait" href="../convert/trait.tryinto" title="trait std::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>Â Â Â Â U: <a class="trait" href="../convert/trait.tryfrom" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;,Â </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#593-602" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="associatedtype.Error-1" class="type"><code>type <a href="../convert/trait.tryinto#associatedtype.Error" class="type">Error</a> = &lt;U as <a class="trait" href="../convert/trait.tryfrom" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="../convert/trait.tryfrom#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a></code></h4>
<div class="docblock">
<p>The type returned in the event of a conversion error.</p> </div>
<h4 id="method.try_into" class="method hidden">
<code>fn <a href="../convert/trait.tryinto#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="../result/enum.result" title="enum std::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="../convert/trait.tryfrom" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="../convert/trait.tryfrom#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#599-601" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs the conversion.</p> </div>
</div>
</div>
<div class="_attribution">
  <p class="_attribution-p">
    Â© 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html" class="_attribution-link">https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
