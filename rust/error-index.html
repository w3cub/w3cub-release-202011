
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Compiler Errors - Rust - W3cubDocs</title>
  
  <meta name="description" content="This error suggests that the expression arm corresponding to the noted pattern will never be reached as for all possible values of the expression &hellip;">
  <meta name="keywords" content="rust, compiler, error, index, errors">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/rust/error-">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/rust.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/rust/" class="_nav-link" title="" style="margin-left:0;">Rust</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _rust">
				
				
<h1>Rust Compiler Error Index</h1> <h3 id="E0001" class="section-header">E0001</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>This error suggests that the expression arm corresponding to the noted pattern will never be reached as for all possible values of the expression being matched, one of the preceding patterns will match.</p> <p>This means that perhaps some of the preceding patterns are too general, this one is too specific or the ordering is incorrect.</p> <p>For example, the following <code>match</code> block has too many arms:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
match Some(0) {
    Some(bar) =&gt; {/* ... */}
    x =&gt; {/* ... */} // This handles the `None` case
    _ =&gt; {/* ... */} // All possible cases have already been handled
}</pre></div> <p><code>match</code> blocks have their patterns matched in order, so, for example, putting a wildcard arm above a more specific arm will make the latter arm irrelevant.</p> <p>Ensure the ordering of the match arm is correct and remove any superfluous arms.</p>  <h3 id="E0002" class="section-header">E0002</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-1" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>This error indicates that an empty match expression is invalid because the type it is matching on is non-empty (there exist values of this type). In safe code it is impossible to create an instance of an empty type, so empty match expressions are almost never desired. This error is typically fixed by adding one or more cases to the match expression.</p> <p>An example of an empty type is <code>enum Empty { }</code>. So, the following will work:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
enum Empty {}

fn foo(x: Empty) {
    match x {
        // empty
    }
}</pre></div> <p>However, this won't:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn foo(x: Option&lt;String&gt;) {
    match x {
        // empty
    }
}</pre></div>  <h3 id="E0004" class="section-header">E0004</h3> <p>This error indicates that the compiler cannot guarantee a matching pattern for one or more possible inputs to a match expression. Guaranteed matches are required in order to assign values to match expressions, or alternatively, determine the flow of execution.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
enum Terminator {
    HastaLaVistaBaby,
    TalkToMyHand,
}

let x = Terminator::HastaLaVistaBaby;

match x { // error: non-exhaustive patterns: `HastaLaVistaBaby` not covered
    Terminator::TalkToMyHand =&gt; {}
}</pre></div> <p>If you encounter this error you must alter your patterns so that every possible value of the input type is matched. For types with a small number of variants (like enums) you should probably cover all cases explicitly. Alternatively, the underscore <code>_</code> wildcard pattern can be added after all other patterns to match "anything else". Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
enum Terminator {
    HastaLaVistaBaby,
    TalkToMyHand,
}

let x = Terminator::HastaLaVistaBaby;

match x {
    Terminator::TalkToMyHand =&gt; {}
    Terminator::HastaLaVistaBaby =&gt; {}
}

// or:

match x {
    Terminator::TalkToMyHand =&gt; {}
    _ =&gt; {}
}</pre></div>  <h3 id="E0005" class="section-header">E0005</h3> <p>Patterns used to bind names must be irrefutable, that is, they must guarantee that a name will be extracted in all cases.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let x = Some(1);
let Some(y) = x;
// error: refutable pattern in local binding: `None` not covered</pre></div> <p>If you encounter this error you probably need to use a <code>match</code> or <code>if let</code> to deal with the possibility of failure. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x = Some(1);

match x {
    Some(y) =&gt; {
        // do something
    },
    None =&gt; {}
}

// or:

if let Some(y) = x {
    // do something
}</pre></div>  <h3 id="E0007" class="section-header">E0007</h3> <p>This error indicates that the bindings in a match arm would require a value to be moved into more than one location, thus violating unique ownership. Code like the following is invalid as it requires the entire <code>Option&lt;String&gt;</code> to be moved into a variable called <code>op_string</code> while simultaneously requiring the inner <code>String</code> to be moved into a variable called <code>s</code>.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let x = Some("s".to_string());

match x {
    op_string @ Some(s) =&gt; {}, // error: cannot bind by-move with sub-bindings
    None =&gt; {},
}</pre></div> <p>See also the error E0303.</p>  <h3 id="E0009" class="section-header">E0009</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-2" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>In a pattern, all values that don't implement the <code>Copy</code> trait have to be bound the same way. The goal here is to avoid binding simultaneously by-move and by-ref.</p> <p>This limitation may be removed in a future version of Rust.</p> <p>Erroneous code example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(move_ref_pattern)]

struct X { x: (), }

let x = Some((X { x: () }, X { x: () }));
match x {
    Some((y, ref z)) =&gt; {}, // error: cannot bind by-move and by-ref in the
                            //        same pattern
    None =&gt; panic!()
}</pre></div> <p>You have two solutions:</p> <p>Solution #1: Bind the pattern's values the same way.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct X { x: (), }

let x = Some((X { x: () }, X { x: () }));
match x {
    Some((ref y, ref z)) =&gt; {},
    // or Some((y, z)) =&gt; {}
    None =&gt; panic!()
}</pre></div> <p>Solution #2: Implement the <code>Copy</code> trait for the <code>X</code> structure.</p> <p>However, please keep in mind that the first solution should be preferred.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[derive(Clone, Copy)]
struct X { x: (), }

let x = Some((X { x: () }, X { x: () }));
match x {
    Some((y, ref z)) =&gt; {},
    None =&gt; panic!()
}</pre></div>  <h3 id="E0010" class="section-header">E0010</h3> <p>The value of statics and constants must be known at compile time, and they live for the entire lifetime of a program. Creating a boxed value allocates memory on the heap at runtime, and therefore cannot be done at compile time.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(box_syntax)]

const CON : Box&lt;i32&gt; = box 0;</pre></div>  <h3 id="E0013" class="section-header">E0013</h3> <p>Static and const variables can refer to other const variables. But a const variable cannot refer to a static variable.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
static X: i32 = 42;
const Y: i32 = X;</pre></div> <p>In this example, <code>Y</code> cannot refer to <code>X</code> here. To fix this, the value can be extracted as a const and then used:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
const A: i32 = 42;
static X: i32 = A;
const Y: i32 = A;</pre></div>  <h3 id="E0014" class="section-header">E0014</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-3" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>Constants can only be initialized by a constant value or, in a future version of Rust, a call to a const function. This error indicates the use of a path (like a::b, or x) denoting something other than one of these allowed items.</p> <p>Erroneous code example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
const FOO: i32 = { let x = 0; x }; // 'x' isn't a constant nor a function!</pre></div> <p>To avoid it, you have to replace the non-constant value:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
const FOO: i32 = { const X : i32 = 0; X };
// or even:
const FOO2: i32 = { 0 }; // but brackets are useless here</pre></div>  <h3 id="E0015" class="section-header">E0015</h3> <p>A constant item was initialized with something that is not a constant expression.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn create_some() -&gt; Option&lt;u8&gt; {
    Some(1)
}

const FOO: Option&lt;u8&gt; = create_some(); // error!</pre></div> <p>The only functions that can be called in static or constant expressions are <code>const</code> functions, and struct/enum constructors.</p> <p>To fix this error, you can declare <code>create_some</code> as a constant function:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
const fn create_some() -&gt; Option&lt;u8&gt; { // declared as a const function
    Some(1)
}

const FOO: Option&lt;u8&gt; = create_some(); // ok!

// These are also working:
struct Bar {
    x: u8,
}

const OTHER_FOO: Option&lt;u8&gt; = Some(1);
const BAR: Bar = Bar {x: 1};</pre></div>  <h3 id="E0019" class="section-header">E0019</h3> <p>A function call isn't allowed in the const's initialization expression because the expression's value must be known at compile-time.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(box_syntax)]

fn main() {
    struct MyOwned;

    static STATIC11: Box&lt;MyOwned&gt; = box MyOwned; // error!
}</pre></div> <p>Remember: you can't use a function call inside a const's initialization expression! However, you can totally use it anywhere else:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
enum Test {
    V1
}

impl Test {
    fn func(&amp;self) -&gt; i32 {
        12
    }
}

fn main() {
    const FOO: Test = Test::V1;

    FOO.func(); // here is good
    let x = FOO.func(); // or even here!
}</pre></div>  <h3 id="E0023" class="section-header">E0023</h3> <p>A pattern attempted to extract an incorrect number of fields from a variant.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
enum Fruit {
    Apple(String, String),
    Pear(u32),
}

let x = Fruit::Apple(String::new(), String::new());

match x {
    Fruit::Apple(a) =&gt; {}, // error!
    _ =&gt; {}
}</pre></div> <p>A pattern used to match against an enum variant must provide a sub-pattern for each field of the enum variant.</p> <p>Here the <code>Apple</code> variant has two fields, and should be matched against like so:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
enum Fruit {
    Apple(String, String),
    Pear(u32),
}

let x = Fruit::Apple(String::new(), String::new());

// Correct.
match x {
    Fruit::Apple(a, b) =&gt; {},
    _ =&gt; {}
}</pre></div> <p>Matching with the wrong number of fields has no sensible interpretation:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
enum Fruit {
    Apple(String, String),
    Pear(u32),
}

let x = Fruit::Apple(String::new(), String::new());

// Incorrect.
match x {
    Fruit::Apple(a) =&gt; {},
    Fruit::Apple(a, b, c) =&gt; {},
}</pre></div> <p>Check how many fields the enum was declared with and ensure that your pattern uses the same number.</p>  <h3 id="E0025" class="section-header">E0025</h3> <p>Each field of a struct can only be bound once in a pattern.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo {
    a: u8,
    b: u8,
}

fn main(){
    let x = Foo { a:1, b:2 };

    let Foo { a: x, a: y } = x;
    // error: field `a` bound multiple times in the pattern
}</pre></div> <p>Each occurrence of a field name binds the value of that field, so to fix this error you will have to remove or alter the duplicate uses of the field name. Perhaps you misspelled another field name? Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo {
    a: u8,
    b: u8,
}

fn main(){
    let x = Foo { a:1, b:2 };

    let Foo { a: x, b: y } = x; // ok!
}</pre></div>  <h3 id="E0026" class="section-header">E0026</h3> <p>A struct pattern attempted to extract a non-existent field from a struct.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Thing {
    x: u32,
    y: u32,
}

let thing = Thing { x: 0, y: 0 };

match thing {
    Thing { x, z } =&gt; {} // error: `Thing::z` field doesn't exist
}</pre></div> <p>If you are using shorthand field patterns but want to refer to the struct field by a different name, you should rename it explicitly. Struct fields are identified by the name used before the colon <code>:</code> so struct patterns should resemble the declaration of the struct type being matched.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Thing {
    x: u32,
    y: u32,
}

let thing = Thing { x: 0, y: 0 };

match thing {
    Thing { x, y: z } =&gt; {} // we renamed `y` to `z`
}</pre></div>  <h3 id="E0027" class="section-header">E0027</h3> <p>A pattern for a struct fails to specify a sub-pattern for every one of the struct's fields.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Dog {
    name: String,
    age: u32,
}

let d = Dog { name: "Rusty".to_string(), age: 8 };

// This is incorrect.
match d {
    Dog { age: x } =&gt; {}
}</pre></div> <p>To fix this error, ensure that each field from the struct's definition is mentioned in the pattern, or use <code>..</code> to ignore unwanted fields. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Dog {
    name: String,
    age: u32,
}

let d = Dog { name: "Rusty".to_string(), age: 8 };

match d {
    Dog { name: ref n, age: x } =&gt; {}
}

// This is also correct (ignore unused fields).
match d {
    Dog { age: x, .. } =&gt; {}
}</pre></div>  <h3 id="E0029" class="section-header">E0029</h3> <p>Something other than numbers and characters has been used for a range.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let string = "salutations !";

// The ordering relation for strings cannot be evaluated at compile time,
// so this doesn't work:
match string {
    "hello" ..= "world" =&gt; {}
    _ =&gt; {}
}

// This is a more general version, using a guard:
match string {
    s if s &gt;= "hello" &amp;&amp; s &lt;= "world" =&gt; {}
    _ =&gt; {}
}</pre></div> <p>In a match expression, only numbers and characters can be matched against a range. This is because the compiler checks that the range is non-empty at compile-time, and is unable to evaluate arbitrary comparison functions. If you want to capture values of an orderable type between two end-points, you can use a guard.</p>  <h3 id="E0030" class="section-header">E0030</h3> <p>When matching against a range, the compiler verifies that the range is non-empty. Range patterns include both end-points, so this is equivalent to requiring the start of the range to be less than or equal to the end of the range.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
match 5u32 {
    // This range is ok, albeit pointless.
    1 ..= 1 =&gt; {}
    // This range is empty, and the compiler can tell.
    1000 ..= 5 =&gt; {}
}</pre></div>  <h3 id="E0033" class="section-header">E0033</h3> <p>A trait type has been dereferenced.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let trait_obj: &amp;SomeTrait = &amp;"some_value";

// This tries to implicitly dereference to create an unsized local variable.
let &amp;invalid = trait_obj;

// You can call methods without binding to the value being pointed at.
trait_obj.method_one();
trait_obj.method_two();</pre></div> <p>A pointer to a trait type cannot be implicitly dereferenced by a pattern. Every trait defines a type, but because the size of trait implementers isn't fixed, this type has no compile-time size. Therefore, all accesses to trait types must be through pointers. If you encounter this error you should try to avoid dereferencing the pointer.</p> <p>You can read more about trait objects in the <a href="reference/types#trait-objects">Trait Objects</a> section of the Reference.</p>  <h3 id="E0034" class="section-header">E0034</h3> <p>The compiler doesn't know what method to call because more than one method has the same prototype.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Test;

trait Trait1 {
    fn foo();
}

trait Trait2 {
    fn foo();
}

impl Trait1 for Test { fn foo() {} }
impl Trait2 for Test { fn foo() {} }

fn main() {
    Test::foo() // error, which foo() to call?
}</pre></div> <p>To avoid this error, you have to keep only one of them and remove the others. So let's take our example and fix it:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Test;

trait Trait1 {
    fn foo();
}

impl Trait1 for Test { fn foo() {} }

fn main() {
    Test::foo() // and now that's good!
}</pre></div> <p>However, a better solution would be using fully explicit naming of type and trait:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Test;

trait Trait1 {
    fn foo();
}

trait Trait2 {
    fn foo();
}

impl Trait1 for Test { fn foo() {} }
impl Trait2 for Test { fn foo() {} }

fn main() {
    &lt;Test as Trait1&gt;::foo()
}</pre></div> <p>One last example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait F {
    fn m(&amp;self);
}

trait G {
    fn m(&amp;self);
}

struct X;

impl F for X { fn m(&amp;self) { println!("I am F"); } }
impl G for X { fn m(&amp;self) { println!("I am G"); } }

fn main() {
    let f = X;

    F::m(&amp;f); // it displays "I am F"
    G::m(&amp;f); // it displays "I am G"
}</pre></div>  <h3 id="E0038" class="section-header">E0038</h3> <p>Trait objects like <code>Box&lt;Trait&gt;</code> can only be constructed when certain requirements are satisfied by the trait in question.</p> <p>Trait objects are a form of dynamic dispatch and use a dynamically sized type for the inner type. So, for a given trait <code>Trait</code>, when <code>Trait</code> is treated as a type, as in <code>Box&lt;Trait&gt;</code>, the inner type is 'unsized'. In such cases the boxed pointer is a 'fat pointer' that contains an extra pointer to a table of methods (among other things) for dynamic dispatch. This design mandates some restrictions on the types of traits that are allowed to be used in trait objects, which are collectively termed as 'object safety' rules.</p> <p>Attempting to create a trait object for a non object-safe trait will trigger this error.</p> <p>There are various rules:</p> <h3 id="the-trait-cannot-require-self-sized" class="section-header">The trait cannot require <code>Self: Sized</code>
</h3> <p>When <code>Trait</code> is treated as a type, the type does not implement the special <code>Sized</code> trait, because the type does not have a known size at compile time and can only be accessed behind a pointer. Thus, if we have a trait like the following:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Foo where Self: Sized {

}</pre></div> <p>We cannot create an object of type <code>Box&lt;Foo&gt;</code> or <code>&amp;Foo</code> since in this case <code>Self</code> would not be <code>Sized</code>.</p> <p>Generally, <code>Self: Sized</code> is used to indicate that the trait should not be used as a trait object. If the trait comes from your own crate, consider removing this restriction.</p> <h3 id="method-references-the-self-type-in-its-parameters-or-return-type" class="section-header">Method references the <code>Self</code> type in its parameters or return type</h3> <p>This happens when a trait has a method like the following:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Trait {
    fn foo(&amp;self) -&gt; Self;
}

impl Trait for String {
    fn foo(&amp;self) -&gt; Self {
        "hi".to_owned()
    }
}

impl Trait for u8 {
    fn foo(&amp;self) -&gt; Self {
        1
    }
}</pre></div> <p>(Note that <code>&amp;self</code> and <code>&amp;mut self</code> are okay, it's additional <code>Self</code> types which cause this problem.)</p> <p>In such a case, the compiler cannot predict the return type of <code>foo()</code> in a situation like the following:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Trait {
    fn foo(&amp;self) -&gt; Self;
}

fn call_foo(x: Box&lt;Trait&gt;) {
    let y = x.foo(); // What type is y?
    // ...
}</pre></div> <p>If only some methods aren't object-safe, you can add a <code>where Self: Sized</code> bound on them to mark them as explicitly unavailable to trait objects. The functionality will still be available to all other implementers, including <code>Box&lt;Trait&gt;</code> which is itself sized (assuming you <code>impl Trait for Box&lt;Trait&gt;</code>).</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Trait {
    fn foo(&amp;self) -&gt; Self where Self: Sized;
    // more functions
}</pre></div> <p>Now, <code>foo()</code> can no longer be called on a trait object, but you will now be allowed to make a trait object, and that will be able to call any object-safe methods. With such a bound, one can still call <code>foo()</code> on types implementing that trait that aren't behind trait objects.</p> <h3 id="method-has-generic-type-parameters" class="section-header">Method has generic type parameters</h3> <p>As mentioned before, trait objects contain pointers to method tables. So, if we have:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Trait {
    fn foo(&amp;self);
}

impl Trait for String {
    fn foo(&amp;self) {
        // implementation 1
    }
}

impl Trait for u8 {
    fn foo(&amp;self) {
        // implementation 2
    }
}
// ...</pre></div> <p>At compile time each implementation of <code>Trait</code> will produce a table containing the various methods (and other items) related to the implementation.</p> <p>This works fine, but when the method gains generic parameters, we can have a problem.</p> <p>Usually, generic parameters get <em>monomorphized</em>. For example, if I have</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo&lt;T&gt;(x: T) {
    // ...
}</pre></div> <p>The machine code for <code>foo::&lt;u8&gt;()</code>, <code>foo::&lt;bool&gt;()</code>, <code>foo::&lt;String&gt;()</code>, or any other type substitution is different. Hence the compiler generates the implementation on-demand. If you call <code>foo()</code> with a <code>bool</code> parameter, the compiler will only generate code for <code>foo::&lt;bool&gt;()</code>. When we have additional type parameters, the number of monomorphized implementations the compiler generates does not grow drastically, since the compiler will only generate an implementation if the function is called with unparametrized substitutions (i.e., substitutions where none of the substituted types are themselves parameterized).</p> <p>However, with trait objects we have to make a table containing <em>every</em> object that implements the trait. Now, if it has type parameters, we need to add implementations for every type that implements the trait, and there could theoretically be an infinite number of types.</p> <p>For example, with:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Trait {
    fn foo&lt;T&gt;(&amp;self, on: T);
    // more methods
}

impl Trait for String {
    fn foo&lt;T&gt;(&amp;self, on: T) {
        // implementation 1
    }
}

impl Trait for u8 {
    fn foo&lt;T&gt;(&amp;self, on: T) {
        // implementation 2
    }
}

// 8 more implementations</pre></div> <p>Now, if we have the following code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn call_foo(thing: Box&lt;Trait&gt;) {
    thing.foo(true); // this could be any one of the 8 types above
    thing.foo(1);
    thing.foo("hello");
}</pre></div> <p>We don't just need to create a table of all implementations of all methods of <code>Trait</code>, we need to create such a table, for each different type fed to <code>foo()</code>. In this case this turns out to be (10 types implementing <code>Trait</code>)*(3 types being fed to <code>foo()</code>) = 30 implementations!</p> <p>With real world traits these numbers can grow drastically.</p> <p>To fix this, it is suggested to use a <code>where Self: Sized</code> bound similar to the fix for the sub-error above if you do not intend to call the method with type parameters:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Trait {
    fn foo&lt;T&gt;(&amp;self, on: T) where Self: Sized;
    // more methods
}</pre></div> <p>If this is not an option, consider replacing the type parameter with another trait object (e.g., if <code>T: OtherTrait</code>, use <code>on: Box&lt;OtherTrait&gt;</code>). If the number of types you intend to feed to this method is limited, consider manually listing out the methods of different types.</p> <h3 id="method-has-no-receiver" class="section-header">Method has no receiver</h3> <p>Methods that do not take a <code>self</code> parameter can't be called since there won't be a way to get a pointer to the method table for them.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    fn foo() -&gt; u8;
}</pre></div> <p>This could be called as <code>&lt;Foo as Foo&gt;::foo()</code>, which would not be able to pick an implementation.</p> <p>Adding a <code>Self: Sized</code> bound to these methods will generally make this compile.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    fn foo() -&gt; u8 where Self: Sized;
}</pre></div> <h3 id="the-trait-cannot-contain-associated-constants" class="section-header">The trait cannot contain associated constants</h3> <p>Just like static functions, associated constants aren't stored on the method table. If the trait or any subtrait contain an associated constant, they cannot be made into an object.</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Foo {
    const X: i32;
}

impl Foo {}</pre></div> <p>A simple workaround is to use a helper method instead:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    fn x(&amp;self) -&gt; i32;
}</pre></div> <h3 id="the-trait-cannot-use-self-as-a-type-parameter-in-the-supertrait-listing" class="section-header">The trait cannot use <code>Self</code> as a type parameter in the supertrait listing</h3> <p>This is similar to the second sub-error, but subtler. It happens in situations like the following:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Super&lt;A: ?Sized&gt; {}

trait Trait: Super&lt;Self&gt; {
}

struct Foo;

impl Super&lt;Foo&gt; for Foo{}

impl Trait for Foo {}

fn main() {
    let x: Box&lt;dyn Trait&gt;;
}</pre></div> <p>Here, the supertrait might have methods as follows:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Super&lt;A: ?Sized&gt; {
    fn get_a(&amp;self) -&gt; &amp;A; // note that this is object safe!
}</pre></div> <p>If the trait <code>Trait</code> was deriving from something like <code>Super&lt;String&gt;</code> or <code>Super&lt;T&gt;</code> (where <code>Foo</code> itself is <code>Foo&lt;T&gt;</code>), this is okay, because given a type <code>get_a()</code> will definitely return an object of that type.</p> <p>However, if it derives from <code>Super&lt;Self&gt;</code>, even though <code>Super</code> is object safe, the method <code>get_a()</code> would return an object of unknown type when called on the function. <code>Self</code> type parameters let us make object safe traits no longer safe, so they are forbidden when specifying supertraits.</p> <p>There's no easy fix for this, generally code will need to be refactored so that you no longer need to derive from <code>Super&lt;Self&gt;</code>.</p>  <h3 id="E0040" class="section-header">E0040</h3> <p>It is not allowed to manually call destructors in Rust.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo {
    x: i32,
}

impl Drop for Foo {
    fn drop(&amp;mut self) {
        println!("kaboom");
    }
}

fn main() {
    let mut x = Foo { x: -7 };
    x.drop(); // error: explicit use of destructor method
}</pre></div> <p>It is unnecessary to do this since <code>drop</code> is called automatically whenever a value goes out of scope. However, if you really need to drop a value by hand, you can use the <code>std::mem::drop</code> function:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo {
    x: i32,
}
impl Drop for Foo {
    fn drop(&amp;mut self) {
        println!("kaboom");
    }
}
fn main() {
    let mut x = Foo { x: -7 };
    drop(x); // ok!
}</pre></div>  <h3 id="E0044" class="section-header">E0044</h3> <p>You cannot use type or const parameters on foreign items.</p> <p>Example of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
extern { fn some_func&lt;T&gt;(x: T); }</pre></div> <p>To fix this, replace the generic parameter with the specializations that you need:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
extern { fn some_func_i32(x: i32); }
extern { fn some_func_i64(x: i64); }</pre></div>  <h3 id="E0045" class="section-header">E0045</h3> <p>Variadic parameters have been used on a non-C ABI function.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(unboxed_closures)]

extern "rust-call" {
    fn foo(x: u8, ...); // error!
}</pre></div> <p>Rust only supports variadic parameters for interoperability with C code in its FFI. As such, variadic parameters can only be used with functions which are using the C ABI. To fix such code, put them in an extern "C" block:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
extern "C" {
    fn foo (x: u8, ...);
}</pre></div>  <h3 id="E0046" class="section-header">E0046</h3> <p>Items are missing in a trait implementation.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Foo {
    fn foo();
}

struct Bar;

impl Foo for Bar {}
// error: not all trait items implemented, missing: `foo`</pre></div> <p>When trying to make some type implement a trait <code>Foo</code>, you must, at minimum, provide implementations for all of <code>Foo</code>'s required methods (meaning the methods that do not have default implementations), as well as any required trait items like associated types or constants. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    fn foo();
}

struct Bar;

impl Foo for Bar {
    fn foo() {} // ok!
}</pre></div>  <h3 id="E0049" class="section-header">E0049</h3> <p>An attempted implementation of a trait method has the wrong number of type or const parameters.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Foo {
    fn foo&lt;T: Default&gt;(x: T) -&gt; Self;
}

struct Bar;

// error: method `foo` has 0 type parameters but its trait declaration has 1
// type parameter
impl Foo for Bar {
    fn foo(x: bool) -&gt; Self { Bar }
}</pre></div> <p>For example, the <code>Foo</code> trait has a method <code>foo</code> with a type parameter <code>T</code>, but the implementation of <code>foo</code> for the type <code>Bar</code> is missing this parameter. To fix this error, they must have the same type parameters:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    fn foo&lt;T: Default&gt;(x: T) -&gt; Self;
}

struct Bar;

impl Foo for Bar {
    fn foo&lt;T: Default&gt;(x: T) -&gt; Self { // ok!
        Bar
    }
}</pre></div>  <h3 id="E0050" class="section-header">E0050</h3> <p>An attempted implementation of a trait method has the wrong number of function parameters.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Foo {
    fn foo(&amp;self, x: u8) -&gt; bool;
}

struct Bar;

// error: method `foo` has 1 parameter but the declaration in trait `Foo::foo`
// has 2
impl Foo for Bar {
    fn foo(&amp;self) -&gt; bool { true }
}</pre></div> <p>For example, the <code>Foo</code> trait has a method <code>foo</code> with two function parameters (<code>&amp;self</code> and <code>u8</code>), but the implementation of <code>foo</code> for the type <code>Bar</code> omits the <code>u8</code> parameter. To fix this error, they must have the same parameters:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    fn foo(&amp;self, x: u8) -&gt; bool;
}

struct Bar;

impl Foo for Bar {
    fn foo(&amp;self, x: u8) -&gt; bool { // ok!
        true
    }
}</pre></div>  <h3 id="E0053" class="section-header">E0053</h3> <p>The parameters of any trait method must match between a trait implementation and the trait definition.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Foo {
    fn foo(x: u16);
    fn bar(&amp;self);
}

struct Bar;

impl Foo for Bar {
    // error, expected u16, found i16
    fn foo(x: i16) { }

    // error, types differ in mutability
    fn bar(&amp;mut self) { }
}</pre></div>  <h3 id="E0054" class="section-header">E0054</h3> <p>It is not allowed to cast to a bool.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let x = 5;

// Not allowed, won't compile
let x_is_nonzero = x as bool;</pre></div> <p>If you are trying to cast a numeric type to a bool, you can compare it with zero instead:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x = 5;

// Ok
let x_is_nonzero = x != 0;</pre></div>  <h3 id="E0055" class="section-header">E0055</h3> <p>During a method call, a value is automatically dereferenced as many times as needed to make the value's type match the method's receiver. The catch is that the compiler will only attempt to dereference a number of times up to the recursion limit (which can be set via the <code>recursion_limit</code> attribute).</p> <p>For a somewhat artificial example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![recursion_limit="4"]

struct Foo;

impl Foo {
    fn foo(&amp;self) {}
}

fn main() {
    let foo = Foo;
    let ref_foo = &amp;&amp;&amp;&amp;&amp;Foo;

    // error, reached the recursion limit while auto-dereferencing `&amp;&amp;&amp;&amp;&amp;Foo`
    ref_foo.foo();
}</pre></div> <p>One fix may be to increase the recursion limit. Note that it is possible to create an infinite recursion of dereferencing, in which case the only fix is to somehow break the recursion.</p>  <h3 id="E0057" class="section-header">E0057</h3> <p>An invalid number of arguments was given when calling a closure.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let f = |x| x * 3;
let a = f();        // invalid, too few parameters
let b = f(4);       // this works!
let c = f(2, 3);    // invalid, too many parameters</pre></div> <p>When invoking closures or other implementations of the function traits <code>Fn</code>, <code>FnMut</code> or <code>FnOnce</code> using call notation, the number of parameters passed to the function must match its definition.</p> <p>A generic function must be treated similarly:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo&lt;F: Fn()&gt;(f: F) {
    f(); // this is valid, but f(3) would not work
}</pre></div>  <h3 id="E0059" class="section-header">E0059</h3> <p>The built-in function traits are generic over a tuple of the function arguments. If one uses angle-bracket notation (<code>Fn&lt;(T,), Output=U&gt;</code>) instead of parentheses (<code>Fn(T) -&gt; U</code>) to denote the function trait, the type parameter should be a tuple. Otherwise function call notation cannot be used and the trait will not be implemented by closures.</p> <p>The most likely source of this error is using angle-bracket notation without wrapping the function argument type into a tuple, for example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(unboxed_closures)]

fn foo&lt;F: Fn&lt;i32&gt;&gt;(f: F) -&gt; F::Output { f(3) }</pre></div> <p>It can be fixed by adjusting the trait bound like this:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(unboxed_closures)]

fn foo&lt;F: Fn&lt;(i32,)&gt;&gt;(f: F) -&gt; F::Output { f(3) }</pre></div> <p>Note that <code>(T,)</code> always denotes the type of a 1-tuple containing an element of type <code>T</code>. The comma is necessary for syntactic disambiguation.</p>  <h3 id="E0060" class="section-header">E0060</h3> <p>External C functions are allowed to be variadic. However, a variadic function takes a minimum number of arguments. For example, consider C's variadic <code>printf</code> function:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
use std::os::raw::{c_char, c_int};

extern "C" {
    fn printf(_: *const c_char, ...) -&gt; c_int;
}

unsafe { printf(); } // error!</pre></div> <p>Using this declaration, it must be called with at least one argument, so simply calling <code>printf()</code> is invalid. But the following uses are allowed:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
unsafe {
    use std::ffi::CString;

    let fmt = CString::new("test\n").unwrap();
    printf(fmt.as_ptr());

    let fmt = CString::new("number = %d\n").unwrap();
    printf(fmt.as_ptr(), 3);

    let fmt = CString::new("%d, %d\n").unwrap();
    printf(fmt.as_ptr(), 10, 5);
}</pre></div>  <h3 id="E0061" class="section-header">E0061</h3> <p>An invalid number of arguments was passed when calling a function.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn f(u: i32) {}

f(); // error!</pre></div> <p>The number of arguments passed to a function must match the number of arguments specified in the function signature.</p> <p>For example, a function like:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn f(a: u16, b: &amp;str) {}</pre></div> <p>Must always be called with exactly two arguments, e.g., <code>f(2, "test")</code>.</p> <p>Note that Rust does not have a notion of optional function arguments or variadic functions (except for its C-FFI).</p>  <h3 id="E0062" class="section-header">E0062</h3> <p>A struct's or struct-like enum variant's field was specified more than once.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo {
    x: i32,
}

fn main() {
    let x = Foo {
                x: 0,
                x: 0, // error: field `x` specified more than once
            };
}</pre></div> <p>This error indicates that during an attempt to build a struct or struct-like enum variant, one of the fields was specified more than once. Each field should be specified exactly one time. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo {
    x: i32,
}

fn main() {
    let x = Foo { x: 0 }; // ok!
}</pre></div>  <h3 id="E0063" class="section-header">E0063</h3> <p>A struct's or struct-like enum variant's field was not provided.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo {
    x: i32,
    y: i32,
}

fn main() {
    let x = Foo { x: 0 }; // error: missing field: `y`
}</pre></div> <p>Each field should be specified exactly once. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo {
    x: i32,
    y: i32,
}

fn main() {
    let x = Foo { x: 0, y: 0 }; // ok!
}</pre></div>  <h3 id="E0067" class="section-header">E0067</h3> <p>An invalid left-hand side expression was used on an assignment operation.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
12 += 1; // error!</pre></div> <p>You need to have a place expression to be able to assign it something. For example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut x: i8 = 12;
x += 1; // ok!</pre></div>  <h3 id="E0069" class="section-header">E0069</h3> <p>The compiler found a function whose body contains a <code>return;</code> statement but whose return type is not <code>()</code>.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
// error
fn foo() -&gt; u8 {
    return;
}</pre></div> <p>Since <code>return;</code> is just like <code>return ();</code>, there is a mismatch between the function's return type and the value being returned.</p>  <h3 id="E0070" class="section-header">E0070</h3> <p>An assignment operator was used on a non-place expression.</p> <p>Erroneous code examples:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct SomeStruct {
    x: i32,
    y: i32,
}

const SOME_CONST: i32 = 12;

fn some_other_func() {}

fn some_function() {
    SOME_CONST = 14; // error: a constant value cannot be changed!
    1 = 3; // error: 1 isn't a valid place!
    some_other_func() = 4; // error: we cannot assign value to a function!
    SomeStruct::x = 12; // error: SomeStruct a structure name but it is used
                        //        like a variable!
}</pre></div> <p>The left-hand side of an assignment operator must be a place expression. A place expression represents a memory location and can be a variable (with optional namespacing), a dereference, an indexing expression or a field reference.</p> <p>More details can be found in the <a href="reference/expressions#places-rvalues-and-temporaries">Expressions</a> section of the Reference.</p> <p>And now let's give working examples:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct SomeStruct {
    x: i32,
    y: i32,
}
let mut s = SomeStruct { x: 0, y: 0 };

s.x = 3; // that's good !

// ...

fn some_func(x: &amp;mut i32) {
    *x = 12; // that's good !
}</pre></div>  <h3 id="E0071" class="section-header">E0071</h3> <p>A structure-literal syntax was used to create an item that is not a structure or enum variant.</p> <p>Example of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
type U32 = u32;
let t = U32 { value: 4 }; // error: expected struct, variant or union type,
                          // found builtin type `u32`</pre></div> <p>To fix this, ensure that the name was correctly spelled, and that the correct form of initializer was used.</p> <p>For example, the code above can be fixed to:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
enum Foo {
    FirstValue(i32)
}

fn main() {
    let u = Foo::FirstValue(0i32);

    let t = 4;
}</pre></div>  <h3 id="E0072" class="section-header">E0072</h3> <p>A recursive type has infinite size because it doesn't have an indirection.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct ListNode {
    head: u8,
    tail: Option&lt;ListNode&gt;, // error: no indirection here so impossible to
                            //        compute the type's size
}</pre></div> <p>When defining a recursive struct or enum, any use of the type being defined from inside the definition must occur behind a pointer (like <code>Box</code>, <code>&amp;</code> or <code>Rc</code>). This is because structs and enums must have a well-defined size, and without the pointer, the size of the type would need to be unbounded.</p> <p>In the example, the type cannot have a well-defined size, because it needs to be arbitrarily large (since we would be able to nest <code>ListNode</code>s to any depth). Specifically,</p> <pre>size of `ListNode` = 1 byte for `head`
                   + 1 byte for the discriminant of the `Option`
                   + size of `ListNode`
</pre> <p>One way to fix this is by wrapping <code>ListNode</code> in a <code>Box</code>, like so:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct ListNode {
    head: u8,
    tail: Option&lt;Box&lt;ListNode&gt;&gt;,
}</pre></div> <p>This works because <code>Box</code> is a pointer, so its size is well-known.</p>  <h3 id="E0073" class="section-header">E0073</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-4" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>You cannot define a struct (or enum) <code>Foo</code> that requires an instance of <code>Foo</code> in order to make a new <code>Foo</code> value. This is because there would be no way a first instance of <code>Foo</code> could be made to initialize another instance!</p> <p>Here's an example of a struct that has this problem:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo { x: Box&lt;Foo&gt; } // error</pre></div> <p>One fix is to use <code>Option</code>, like so:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo { x: Option&lt;Box&lt;Foo&gt;&gt; }</pre></div> <p>Now it's possible to create at least one instance of <code>Foo</code>: <code>Foo { x: None }</code>.</p>  <h3 id="E0074" class="section-header">E0074</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-5" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>When using the <code>#[simd]</code> attribute on a tuple struct, the components of the tuple struct must all be of a concrete, nongeneric type so the compiler can reason about how to use SIMD with them. This error will occur if the types are generic.</p> <p>This will cause an error:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(repr_simd)]

#[repr(simd)]
struct Bad&lt;T&gt;(T, T, T);</pre></div> <p>This will not:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(repr_simd)]

#[repr(simd)]
struct Good(u32, u32, u32);</pre></div>  <h3 id="E0075" class="section-header">E0075</h3> <p>A <code>#[simd]</code> attribute was applied to an empty tuple struct.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(repr_simd)]

#[repr(simd)]
struct Bad; // error!</pre></div> <p>The <code>#[simd]</code> attribute can only be applied to non empty tuple structs, because it doesn't make sense to try to use SIMD operations when there are no values to operate on.</p> <p>Fixed example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(repr_simd)]

#[repr(simd)]
struct Good(u32); // ok!</pre></div>  <h3 id="E0076" class="section-header">E0076</h3> <p>All types in a tuple struct aren't the same when using the <code>#[simd]</code> attribute.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(repr_simd)]

#[repr(simd)]
struct Bad(u16, u32, u32); // error!</pre></div> <p>When using the <code>#[simd]</code> attribute to automatically use SIMD operations in tuple struct, the types in the struct must all be of the same type, or the compiler will trigger this error.</p> <p>Fixed example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(repr_simd)]

#[repr(simd)]
struct Good(u32, u32, u32); // ok!</pre></div>  <h3 id="E0077" class="section-header">E0077</h3> <p>A tuple struct's element isn't a machine type when using the <code>#[simd]</code> attribute.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(repr_simd)]

#[repr(simd)]
struct Bad(String); // error!</pre></div> <p>When using the <code>#[simd]</code> attribute on a tuple struct, the elements in the tuple must be machine types so SIMD operations can be applied to them.</p> <p>Fixed example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(repr_simd)]

#[repr(simd)]
struct Good(u32, u32, u32); // ok!</pre></div>  <h3 id="E0080" class="section-header">E0080</h3> <p>A constant value failed to get evaluated.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
enum Enum {
    X = (1 &lt;&lt; 500),
    Y = (1 / 0),
}</pre></div> <p>This error indicates that the compiler was unable to sensibly evaluate a constant expression that had to be evaluated. Attempting to divide by 0 or causing an integer overflow are two ways to induce this error.</p> <p>Ensure that the expressions given can be evaluated as the desired integer type.</p> <p>See the <a href="reference/items/enumerations#custom-discriminant-values-for-field-less-enumerations">Custom Discriminants</a> section of the Reference for more information about setting custom integer types on fieldless enums using the <a href="reference/type-layout#reprc-enums"><code>repr</code> attribute</a>.</p>  <h3 id="E0081" class="section-header">E0081</h3> <p>A discriminant value is present more than once.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
enum Enum {
    P = 3,
    X = 3, // error!
    Y = 5,
}</pre></div> <p>Enum discriminants are used to differentiate enum variants stored in memory. This error indicates that the same value was used for two or more variants, making it impossible to distinguish them.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
enum Enum {
    P,
    X = 3, // ok!
    Y = 5,
}</pre></div> <p>Note that variants without a manually specified discriminant are numbered from top to bottom starting from 0, so clashes can occur with seemingly unrelated variants.</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
enum Bad {
    X,
    Y = 0, // error!
}</pre></div> <p>Here <code>X</code> will have already been specified the discriminant 0 by the time <code>Y</code> is encountered, so a conflict occurs.</p>  <h3 id="E0084" class="section-header">E0084</h3> <p>An unsupported representation was attempted on a zero-variant enum.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[repr(i32)]
enum NightsWatch {} // error: unsupported representation for zero-variant enum</pre></div> <p>It is impossible to define an integer type to be used to represent zero-variant enum values because there are no zero-variant enum values. There is no way to construct an instance of the following type using only safe code. So you have two solutions. Either you add variants in your enum:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[repr(i32)]
enum NightsWatch {
    JonSnow,
    Commander,
}</pre></div> <p>or you remove the integer representation of your enum:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
enum NightsWatch {}</pre></div>  <h3 id="E0087" class="section-header">E0087</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-6" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>Too many type arguments were supplied for a function. For example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn foo&lt;T&gt;() {}

fn main() {
    foo::&lt;f64, bool&gt;(); // error: wrong number of type arguments:
                        //        expected 1, found 2
}</pre></div> <p>The number of supplied arguments must exactly match the number of defined type parameters.</p>  <h3 id="E0088" class="section-header">E0088</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-7" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>You gave too many lifetime arguments. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn f() {}

fn main() {
    f::&lt;'static&gt;() // error: wrong number of lifetime arguments:
                   //        expected 0, found 1
}</pre></div> <p>Please check you give the right number of lifetime arguments. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn f() {}

fn main() {
    f() // ok!
}</pre></div> <p>It's also important to note that the Rust compiler can generally determine the lifetime by itself. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo {
    value: String
}

impl Foo {
    // it can be written like this
    fn get_value&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a str { &amp;self.value }
    // but the compiler works fine with this too:
    fn without_lifetime(&amp;self) -&gt; &amp;str { &amp;self.value }
}

fn main() {
    let f = Foo { value: "hello".to_owned() };

    println!("{}", f.get_value());
    println!("{}", f.without_lifetime());
}</pre></div>  <h3 id="E0089" class="section-header">E0089</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-8" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>Too few type arguments were supplied for a function. For example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn foo&lt;T, U&gt;() {}

fn main() {
    foo::&lt;f64&gt;(); // error: wrong number of type arguments: expected 2, found 1
}</pre></div> <p>Note that if a function takes multiple type arguments but you want the compiler to infer some of them, you can use type placeholders:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn foo&lt;T, U&gt;(x: T) {}

fn main() {
    let x: bool = true;
    foo::&lt;f64&gt;(x);    // error: wrong number of type arguments:
                      //        expected 2, found 1
    foo::&lt;_, f64&gt;(x); // same as `foo::&lt;bool, f64&gt;(x)`
}</pre></div>  <h3 id="E0090" class="section-header">E0090</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-9" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>You gave too few lifetime arguments. Example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn foo&lt;'a: 'b, 'b: 'a&gt;() {}

fn main() {
    foo::&lt;'static&gt;(); // error: wrong number of lifetime arguments:
                      //        expected 2, found 1
}</pre></div> <p>Please check you give the right number of lifetime arguments. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo&lt;'a: 'b, 'b: 'a&gt;() {}

fn main() {
    foo::&lt;'static, 'static&gt;();
}</pre></div>  <h3 id="E0091" class="section-header">E0091</h3> <p>An unnecessary type or const parameter was given in a type alias.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
type Foo&lt;T&gt; = u32; // error: type parameter `T` is unused
// or:
type Foo&lt;A,B&gt; = Box&lt;A&gt;; // error: type parameter `B` is unused</pre></div> <p>Please check you didn't write too many parameters. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
type Foo = u32; // ok!
type Foo2&lt;A&gt; = Box&lt;A&gt;; // ok!</pre></div>  <h3 id="E0092" class="section-header">E0092</h3> <p>An undefined atomic operation function was declared.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(intrinsics)]

extern "rust-intrinsic" {
    fn atomic_foo(); // error: unrecognized atomic operation
                     //        function
}</pre></div> <p>Please check you didn't make a mistake in the function's name. All intrinsic functions are defined in <code>librustc_codegen_llvm/intrinsic.rs</code> and in <code>libcore/intrinsics.rs</code> in the Rust source code. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(intrinsics)]

extern "rust-intrinsic" {
    fn atomic_fence(); // ok!
}</pre></div>  <h3 id="E0093" class="section-header">E0093</h3> <p>An unknown intrinsic function was declared.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(intrinsics)]

extern "rust-intrinsic" {
    fn foo(); // error: unrecognized intrinsic function: `foo`
}

fn main() {
    unsafe {
        foo();
    }
}</pre></div> <p>Please check you didn't make a mistake in the function's name. All intrinsic functions are defined in <code>librustc_codegen_llvm/intrinsic.rs</code> and in <code>libcore/intrinsics.rs</code> in the Rust source code. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(intrinsics)]

extern "rust-intrinsic" {
    fn atomic_fence(); // ok!
}

fn main() {
    unsafe {
        atomic_fence();
    }
}</pre></div>  <h3 id="E0094" class="section-header">E0094</h3> <p>An invalid number of type parameters was given to an intrinsic function.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(intrinsics)]

extern "rust-intrinsic" {
    fn size_of&lt;T, U&gt;() -&gt; usize; // error: intrinsic has wrong number
                                 //        of type parameters
}</pre></div> <p>Please check that you provided the right number of type parameters and verify with the function declaration in the Rust source code. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(intrinsics)]

extern "rust-intrinsic" {
    fn size_of&lt;T&gt;() -&gt; usize; // ok!
}</pre></div>  <h3 id="E0106" class="section-header">E0106</h3> <p>This error indicates that a lifetime is missing from a type. If it is an error inside a function signature, the problem may be with failing to adhere to the lifetime elision rules (see below).</p> <p>Erroneous code examples:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo1 { x: &amp;bool }
              // ^ expected lifetime parameter
struct Foo2&lt;'a&gt; { x: &amp;'a bool } // correct

struct Bar1 { x: Foo2 }
              // ^^^^ expected lifetime parameter
struct Bar2&lt;'a&gt; { x: Foo2&lt;'a&gt; } // correct

enum Baz1 { A(u8), B(&amp;bool), }
                  // ^ expected lifetime parameter
enum Baz2&lt;'a&gt; { A(u8), B(&amp;'a bool), } // correct

type MyStr1 = &amp;str;
           // ^ expected lifetime parameter
type MyStr2&lt;'a&gt; = &amp;'a str; // correct</pre></div> <p>Lifetime elision is a special, limited kind of inference for lifetimes in function signatures which allows you to leave out lifetimes in certain cases. For more background on lifetime elision see <a href="book/ch10-03-lifetime-syntax#lifetime-elision">the book</a>.</p> <p>The lifetime elision rules require that any function signature with an elided output lifetime must either have:</p> <ul> <li>exactly one input lifetime</li> <li>or, multiple input lifetimes, but the function must also be a method with a <code>&amp;self</code> or <code>&amp;mut self</code> receiver</li> </ul> <p>In the first case, the output lifetime is inferred to be the same as the unique input lifetime. In the second case, the lifetime is instead inferred to be the same as the lifetime on <code>&amp;self</code> or <code>&amp;mut self</code>.</p> <p>Here are some examples of elision errors:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
// error, no input lifetimes
fn foo() -&gt; &amp;str { }

// error, `x` and `y` have distinct lifetimes inferred
fn bar(x: &amp;str, y: &amp;str) -&gt; &amp;str { }

// error, `y`'s lifetime is inferred to be distinct from `x`'s
fn baz&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;str { }</pre></div>  <h3 id="E0107" class="section-header">E0107</h3> <p>An incorrect number of generic arguments were provided.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo&lt;T&gt; { x: T }

struct Bar { x: Foo }             // error: wrong number of type arguments:
                                  //        expected 1, found 0
struct Baz&lt;S, T&gt; { x: Foo&lt;S, T&gt; } // error: wrong number of type arguments:
                                  //        expected 1, found 2

fn foo&lt;T, U&gt;(x: T, y: U) {}
fn f() {}

fn main() {
    let x: bool = true;
    foo::&lt;bool&gt;(x);                 // error: wrong number of type arguments:
                                    //        expected 2, found 1
    foo::&lt;bool, i32, i32&gt;(x, 2, 4); // error: wrong number of type arguments:
                                    //        expected 2, found 3
    f::&lt;'static&gt;();                 // error: wrong number of lifetime arguments
                                    //        expected 0, found 1
}</pre></div> <p>When using/declaring an item with generic arguments, you must provide the exact same number:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo&lt;T&gt; { x: T }

struct Bar&lt;T&gt; { x: Foo&lt;T&gt; }               // ok!
struct Baz&lt;S, T&gt; { x: Foo&lt;S&gt;, y: Foo&lt;T&gt; } // ok!

fn foo&lt;T, U&gt;(x: T, y: U) {}
fn f() {}

fn main() {
    let x: bool = true;
    foo::&lt;bool, u32&gt;(x, 12);              // ok!
    f();                                  // ok!
}</pre></div>  <h3 id="E0109" class="section-header">E0109</h3> <p>You tried to provide a generic argument to a type which doesn't need it.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
type X = u32&lt;i32&gt;; // error: type arguments are not allowed for this type
type Y = bool&lt;'static&gt;; // error: lifetime parameters are not allowed on
                        //        this type</pre></div> <p>Check that you used the correct argument and that the definition is correct.</p> <p>Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
type X = u32; // ok!
type Y = bool; // ok!</pre></div> <p>Note that generic arguments for enum variant constructors go after the variant, not after the enum. For example, you would write <code>Option::None::&lt;u32&gt;</code>, rather than <code>Option::&lt;u32&gt;::None</code>.</p>  <h3 id="E0110" class="section-header">E0110</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-10" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>You tried to provide a lifetime to a type which doesn't need it. See <code>E0109</code> for more details.</p>  <h3 id="E0116" class="section-header">E0116</h3> <p>An inherent implementation was defined for a type outside the current crate.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
impl Vec&lt;u8&gt; { } // error</pre></div> <p>You can only define an inherent implementation for a type in the same crate where the type was defined. For example, an <code>impl</code> block as above is not allowed since <code>Vec</code> is defined in the standard library.</p> <p>To fix this problem, you can do either of these things:</p> <ul> <li>define a trait that has the desired associated functions/types/constants and implement the trait for the type in question</li> <li>define a new type wrapping the type and define an implementation on the new type</li> </ul> <p>Note that using the <code>type</code> keyword does not work here because <code>type</code> only introduces a type alias:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
type Bytes = Vec&lt;u8&gt;;

impl Bytes { } // error, same as above</pre></div>  <h3 id="E0117" class="section-header">E0117</h3> <p>Only traits defined in the current crate can be implemented for arbitrary types.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
impl Drop for u32 {}</pre></div> <p>This error indicates a violation of one of Rust's orphan rules for trait implementations. The rule prohibits any implementation of a foreign trait (a trait defined in another crate) where</p> <ul> <li>the type that is implementing the trait is foreign</li> <li>all of the parameters being passed to the trait (if there are any) are also foreign.</li> </ul> <p>To avoid this kind of error, ensure that at least one local type is referenced by the <code>impl</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
pub struct Foo; // you define your type in your crate

impl Drop for Foo { // and you can implement the trait on it!
    // code of trait implementation here
}

impl From&lt;Foo&gt; for i32 { // or you use a type from your crate as
                         // a type parameter
    fn from(i: Foo) -&gt; i32 {
        0
    }
}</pre></div> <p>Alternatively, define a trait locally and implement that instead:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Bar {
    fn get(&amp;self) -&gt; usize;
}

impl Bar for u32 {
    fn get(&amp;self) -&gt; usize { 0 }
}</pre></div> <p>For information on the design of the orphan rules, see <a href="https://github.com/rust-lang/rfcs/blob/master/text/1023-rebalancing-coherence.md">RFC 1023</a>.</p>  <h3 id="E0118" class="section-header">E0118</h3> <p>An inherent implementation was defined for something which isn't a struct nor an enum.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
impl (u8, u8) { // error: no base type found for inherent implementation
    fn get_state(&amp;self) -&gt; String {
        // ...
    }
}</pre></div> <p>To fix this error, please implement a trait on the type or wrap it in a struct. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
// we create a trait here
trait LiveLongAndProsper {
    fn get_state(&amp;self) -&gt; String;
}

// and now you can implement it on (u8, u8)
impl LiveLongAndProsper for (u8, u8) {
    fn get_state(&amp;self) -&gt; String {
        "He's dead, Jim!".to_owned()
    }
}</pre></div> <p>Alternatively, you can create a newtype. A newtype is a wrapping tuple-struct. For example, <code>NewType</code> is a newtype over <code>Foo</code> in <code>struct NewType(Foo)</code>. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct TypeWrapper((u8, u8));

impl TypeWrapper {
    fn get_state(&amp;self) -&gt; String {
        "Fascinating!".to_owned()
    }
}</pre></div>  <h3 id="E0119" class="section-header">E0119</h3> <p>There are conflicting trait implementations for the same type.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait MyTrait {
    fn get(&amp;self) -&gt; usize;
}

impl&lt;T&gt; MyTrait for T {
    fn get(&amp;self) -&gt; usize { 0 }
}

struct Foo {
    value: usize
}

impl MyTrait for Foo { // error: conflicting implementations of trait
                       //        `MyTrait` for type `Foo`
    fn get(&amp;self) -&gt; usize { self.value }
}</pre></div> <p>When looking for the implementation for the trait, the compiler finds both the <code>impl&lt;T&gt; MyTrait for T</code> where T is all types and the <code>impl MyTrait for Foo</code>. Since a trait cannot be implemented multiple times, this is an error. So, when you write:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait MyTrait {
    fn get(&amp;self) -&gt; usize;
}

impl&lt;T&gt; MyTrait for T {
    fn get(&amp;self) -&gt; usize { 0 }
}</pre></div> <p>This makes the trait implemented on all types in the scope. So if you try to implement it on another one after that, the implementations will conflict. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait MyTrait {
    fn get(&amp;self) -&gt; usize;
}

impl&lt;T&gt; MyTrait for T {
    fn get(&amp;self) -&gt; usize { 0 }
}

struct Foo;

fn main() {
    let f = Foo;

    f.get(); // the trait is implemented so we can use it
}</pre></div>  <h3 id="E0120" class="section-header">E0120</h3> <p>Drop was implemented on a trait, which is not allowed: only structs and enums can implement Drop.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait MyTrait {}

impl Drop for MyTrait {
    fn drop(&amp;mut self) {}
}</pre></div> <p>A workaround for this problem is to wrap the trait up in a struct, and implement Drop on that:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait MyTrait {}
struct MyWrapper&lt;T: MyTrait&gt; { foo: T }

impl &lt;T: MyTrait&gt; Drop for MyWrapper&lt;T&gt; {
    fn drop(&amp;mut self) {}
}
</pre></div> <p>Alternatively, wrapping trait objects requires something:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait MyTrait {}

//or Box&lt;MyTrait&gt;, if you wanted an owned trait object
struct MyWrapper&lt;'a&gt; { foo: &amp;'a MyTrait }

impl &lt;'a&gt; Drop for MyWrapper&lt;'a&gt; {
    fn drop(&amp;mut self) {}
}</pre></div>  <h3 id="E0121" class="section-header">E0121</h3> <p>The type placeholder <code>_</code> was used within a type on an item's signature.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn foo() -&gt; _ { 5 } // error

static BAR: _ = "test"; // error</pre></div> <p>In those cases, you need to provide the type explicitly:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo() -&gt; i32 { 5 } // ok!

static BAR: &amp;str = "test"; // ok!</pre></div> <p>The type placeholder <code>_</code> can be used outside item's signature as follows:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x = "a4a".split('4')
    .collect::&lt;Vec&lt;_&gt;&gt;(); // No need to precise the Vec's generic type.</pre></div>  <h3 id="E0124" class="section-header">E0124</h3> <p>A struct was declared with two fields having the same name.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo {
    field1: i32,
    field1: i32, // error: field is already declared
}</pre></div> <p>Please verify that the field names have been correctly spelled. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo {
    field1: i32,
    field2: i32, // ok!
}</pre></div>  <h3 id="E0128" class="section-header">E0128</h3> <p>A type parameter with default value is using forward declared identifier.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo&lt;T = U, U = ()&gt; {
    field1: T,
    field2: U,
}
// error: type parameters with a default cannot use forward declared
//        identifiers</pre></div> <p>Type parameter defaults can only use parameters that occur before them. Since type parameters are evaluated in-order, this issue could be fixed by doing:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo&lt;U = (), T = U&gt; {
    field1: T,
    field2: U,
}</pre></div> <p>Please also verify that this wasn't because of a name-clash and rename the type parameter if so.</p>  <h3 id="E0130" class="section-header">E0130</h3> <p>A pattern was declared as an argument in a foreign function declaration.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
extern {
    fn foo((a, b): (u32, u32)); // error: patterns aren't allowed in foreign
                                //        function declarations
}</pre></div> <p>To fix this error, replace the pattern argument with a regular one. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct SomeStruct {
    a: u32,
    b: u32,
}

extern {
    fn foo(s: SomeStruct); // ok!
}</pre></div> <p>Or:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
extern {
    fn foo(a: (u32, u32)); // ok!
}</pre></div>  <h3 id="E0131" class="section-header">E0131</h3> <p>The <code>main</code> function was defined with generic parameters.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn main&lt;T&gt;() { // error: main function is not allowed to have generic parameters
}</pre></div> <p>It is not possible to define the <code>main</code> function with generic parameters. It must not take any arguments.</p>  <h3 id="E0132" class="section-header">E0132</h3> <p>A function with the <code>start</code> attribute was declared with type parameters.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(start)]

#[start]
fn f&lt;T&gt;() {}</pre></div> <p>It is not possible to declare type parameters on a function that has the <code>start</code> attribute. Such a function must have the following type signature (for more information, view <a href="https://doc.rust-lang.org/unstable-book/language-features/lang-items.html#writing-an-executable-without-stdlib">the unstable book</a>):</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn(isize, *const *const u8) -&gt; isize;</pre></div> <p>Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(start)]

#[start]
fn my_start(argc: isize, argv: *const *const u8) -&gt; isize {
    0
}</pre></div>  <h3 id="E0133" class="section-header">E0133</h3> <p>Unsafe code was used outside of an unsafe function or block.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
unsafe fn f() { return; } // This is the unsafe code

fn main() {
    f(); // error: call to unsafe function requires unsafe function or block
}</pre></div> <p>Using unsafe functionality is potentially dangerous and disallowed by safety checks. Examples:</p> <ul> <li>Dereferencing raw pointers</li> <li>Calling functions via FFI</li> <li>Calling functions marked unsafe</li> </ul> <p>These safety checks can be relaxed for a section of the code by wrapping the unsafe instructions with an <code>unsafe</code> block. For instance:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
unsafe fn f() { return; }

fn main() {
    unsafe { f(); } // ok!
}</pre></div> <p>See the <a href="book/ch19-01-unsafe-rust">unsafe section</a> of the Book for more details.</p>  <h3 id="E0136" class="section-header">E0136</h3> <p>More than one <code>main</code> function was found.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn main() {
    // ...
}

// ...

fn main() { // error!
    // ...
}</pre></div> <p>A binary can only have one entry point, and by default that entry point is the <code>main()</code> function. If there are multiple instances of this function, please rename one of them.</p>  <h3 id="E0137" class="section-header">E0137</h3> <p>More than one function was declared with the <code>#[main]</code> attribute.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(main)]

#[main]
fn foo() {}

#[main]
fn f() {} // error: multiple functions with a `#[main]` attribute</pre></div> <p>This error indicates that the compiler found multiple functions with the <code>#[main]</code> attribute. This is an error because there must be a unique entry point into a Rust program. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(main)]

#[main]
fn f() {} // ok!</pre></div>  <h3 id="E0138" class="section-header">E0138</h3> <p>More than one function was declared with the <code>#[start]</code> attribute.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(start)]

#[start]
fn foo(argc: isize, argv: *const *const u8) -&gt; isize {}

#[start]
fn f(argc: isize, argv: *const *const u8) -&gt; isize {}
// error: multiple 'start' functions</pre></div> <p>This error indicates that the compiler found multiple functions with the <code>#[start]</code> attribute. This is an error because there must be a unique entry point into a Rust program. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(start)]

#[start]
fn foo(argc: isize, argv: *const *const u8) -&gt; isize { 0 } // ok!</pre></div>  <h3 id="E0139" class="section-header">E0139</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-11" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>There are various restrictions on transmuting between types in Rust; for example types being transmuted must have the same size. To apply all these restrictions, the compiler must know the exact types that may be transmuted. When type parameters are involved, this cannot always be done.</p> <p>So, for example, the following is not allowed:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::mem::transmute;

struct Foo&lt;T&gt;(Vec&lt;T&gt;);

fn foo&lt;T&gt;(x: Vec&lt;T&gt;) {
    // we are transmuting between Vec&lt;T&gt; and Foo&lt;F&gt; here
    let y: Foo&lt;T&gt; = unsafe { transmute(x) };
    // do something with y
}</pre></div> <p>In this specific case there's a good chance that the transmute is harmless (but this is not guaranteed by Rust). However, when alignment and enum optimizations come into the picture, it's quite likely that the sizes may or may not match with different type parameter substitutions. It's not possible to check this for <em>all</em> possible types, so <code>transmute()</code> simply only accepts types without any unsubstituted type parameters.</p> <p>If you need this, there's a good chance you're doing something wrong. Keep in mind that Rust doesn't guarantee much about the layout of different structs (even two structs with identical declarations may have different layouts). If there is a solution that avoids the transmute entirely, try it instead.</p> <p>If it's possible, hand-monomorphize the code by writing the function for each possible type substitution. It's possible to use traits to do this cleanly, for example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::mem::transmute;

struct Foo&lt;T&gt;(Vec&lt;T&gt;);

trait MyTransmutableType: Sized {
    fn transmute(_: Vec&lt;Self&gt;) -&gt; Foo&lt;Self&gt;;
}

impl MyTransmutableType for u8 {
    fn transmute(x: Vec&lt;u8&gt;) -&gt; Foo&lt;u8&gt; {
        unsafe { transmute(x) }
    }
}

impl MyTransmutableType for String {
    fn transmute(x: Vec&lt;String&gt;) -&gt; Foo&lt;String&gt; {
        unsafe { transmute(x) }
    }
}

// ... more impls for the types you intend to transmute

fn foo&lt;T: MyTransmutableType&gt;(x: Vec&lt;T&gt;) {
    let y: Foo&lt;T&gt; = &lt;T as MyTransmutableType&gt;::transmute(x);
    // do something with y
}</pre></div> <p>Each impl will be checked for a size match in the transmute as usual, and since there are no unbound type parameters involved, this should compile unless there is a size mismatch in one of the impls.</p> <p>It is also possible to manually transmute:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
unsafe {
    ptr::read(&amp;v as *const _ as *const SomeType) // `v` transmuted to `SomeType`
}</pre></div> <p>Note that this does not move <code>v</code> (unlike <code>transmute</code>), and may need a call to <code>mem::forget(v)</code> in case you want to avoid destructors being called.</p>  <h3 id="E0152" class="section-header">E0152</h3> <p>A lang item was redefined.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(lang_items)]

#[lang = "owned_box"]
struct Foo; // error: duplicate lang item found: `owned_box`</pre></div> <p>Lang items are already implemented in the standard library. Unless you are writing a free-standing application (e.g., a kernel), you do not need to provide them yourself.</p> <p>You can build a free-standing crate by adding <code>#![no_std]</code> to the crate attributes:</p> <div class="information">ⓘThis example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">
#![no_std]</pre></div> <p>See also the <a href="https://doc.rust-lang.org/unstable-book/language-features/lang-items.html#writing-an-executable-without-stdlib">unstable book</a>.</p>  <h3 id="E0154" class="section-header">E0154</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-12" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>Imports (<code>use</code> statements) are not allowed after non-item statements, such as variable declarations and expression statements.</p> <p>Here is an example that demonstrates the error:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn f() {
    // Variable declaration before import
    let x = 0;
    use std::io::Read;
    // ...
}</pre></div> <p>The solution is to declare the imports at the top of the block, function, or file.</p> <p>Here is the previous example again, with the correct order:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn f() {
    use std::io::Read;
    let x = 0;
    // ...
}</pre></div> <p>See the <a href="reference/statements#declaration-statements">Declaration Statements</a> section of the reference for more information about what constitutes an item declaration and what does not.</p>  <h3 id="E0158" class="section-header">E0158</h3> <p>An associated const has been referenced in a pattern.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
enum EFoo { A, B, C, D }

trait Foo {
    const X: EFoo;
}

fn test&lt;A: Foo&gt;(arg: EFoo) {
    match arg {
        A::X =&gt; { // error!
            println!("A::X");
        }
    }
}</pre></div> <p><code>const</code> and <code>static</code> mean different things. A <code>const</code> is a compile-time constant, an alias for a literal value. This property means you can match it directly within a pattern.</p> <p>The <code>static</code> keyword, on the other hand, guarantees a fixed location in memory. This does not always mean that the value is constant. For example, a global mutex can be declared <code>static</code> as well.</p> <p>If you want to match against a <code>static</code>, consider using a guard instead:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
static FORTY_TWO: i32 = 42;

match Some(42) {
    Some(x) if x == FORTY_TWO =&gt; {}
    _ =&gt; {}
}</pre></div>  <h3 id="E0161" class="section-header">E0161</h3> <p>A value was moved whose size was not known at compile time.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(box_syntax)]

fn main() {
    let array: &amp;[isize] = &amp;[1, 2, 3];
    let _x: Box&lt;[isize]&gt; = box *array;
    // error: cannot move a value of type [isize]: the size of [isize] cannot
    //        be statically determined
}</pre></div> <p>In Rust, you can only move a value when its size is known at compile time.</p> <p>To work around this restriction, consider "hiding" the value behind a reference: either <code>&amp;x</code> or <code>&amp;mut x</code>. Since a reference has a fixed size, this lets you move it around as usual. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(box_syntax)]

fn main() {
    let array: &amp;[isize] = &amp;[1, 2, 3];
    let _x: Box&lt;&amp;[isize]&gt; = box array; // ok!
}</pre></div>  <h3 id="E0162" class="section-header">E0162</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-13" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>An if-let pattern attempts to match the pattern, and enters the body if the match was successful. If the match is irrefutable (when it cannot fail to match), use a regular <code>let</code>-binding instead. For instance:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Irrefutable(i32);
let irr = Irrefutable(0);

// This fails to compile because the match is irrefutable.
if let Irrefutable(x) = irr {
    // This body will always be executed.
    // ...
}</pre></div> <p>Try this instead:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Irrefutable(i32);
let irr = Irrefutable(0);

let Irrefutable(x) = irr;
println!("{}", x);</pre></div>  <h3 id="E0164" class="section-header">E0164</h3> <p>Something which is neither a tuple struct nor a tuple variant was used as a pattern.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
enum A {
    B,
    C,
}

impl A {
    fn new() {}
}

fn bar(foo: A) {
    match foo {
        A::new() =&gt; (), // error!
        _ =&gt; {}
    }
}</pre></div> <p>This error means that an attempt was made to match something which is neither a tuple struct nor a tuple variant. Only these two elements are allowed as a pattern:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
enum A {
    B,
    C,
}

impl A {
    fn new() {}
}

fn bar(foo: A) {
    match foo {
        A::B =&gt; (), // ok!
        _ =&gt; {}
    }
}</pre></div>  <h3 id="E0165" class="section-header">E0165</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-14" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>A while-let pattern attempts to match the pattern, and enters the body if the match was successful. If the match is irrefutable (when it cannot fail to match), use a regular <code>let</code>-binding inside a <code>loop</code> instead. For instance:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Irrefutable(i32);
let irr = Irrefutable(0);

// This fails to compile because the match is irrefutable.
while let Irrefutable(x) = irr {
    // ...
}</pre></div> <p>Try this instead:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Irrefutable(i32);
let irr = Irrefutable(0);

loop {
    let Irrefutable(x) = irr;
    // ...
}</pre></div>  <h3 id="E0170" class="section-header">E0170</h3> <p>A pattern binding is using the same name as one of the variants of a type.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
enum Method {
    GET,
    POST,
}

fn is_empty(s: Method) -&gt; bool {
    match s {
        GET =&gt; true,
        _ =&gt; false
    }
}

fn main() {}</pre></div> <p>Enum variants are qualified by default. For example, given this type:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
enum Method {
    GET,
    POST,
}</pre></div> <p>You would match it using:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
enum Method {
    GET,
    POST,
}

let m = Method::GET;

match m {
    Method::GET =&gt; {},
    Method::POST =&gt; {},
}</pre></div> <p>If you don't qualify the names, the code will bind new variables named "GET" and "POST" instead. This behavior is likely not what you want, so <code>rustc</code> warns when that happens.</p> <p>Qualified names are good practice, and most code works well with them. But if you prefer them unqualified, you can import the variants into scope:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use Method::*;
enum Method { GET, POST }</pre></div> <p>If you want others to be able to import variants from your module directly, use <code>pub use</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
pub use Method::*;
pub enum Method { GET, POST }</pre></div>  <h3 id="E0178" class="section-header">E0178</h3> <p>The <code>+</code> type operator was used in an ambiguous context.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Foo {}

struct Bar&lt;'a&gt; {
    x: &amp;'a Foo + 'a,     // error!
    y: &amp;'a mut Foo + 'a, // error!
    z: fn() -&gt; Foo + 'a, // error!
}</pre></div> <p>In types, the <code>+</code> type operator has low precedence, so it is often necessary to use parentheses:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Foo {}

struct Bar&lt;'a&gt; {
    x: &amp;'a (Foo + 'a),     // ok!
    y: &amp;'a mut (Foo + 'a), // ok!
    z: fn() -&gt; (Foo + 'a), // ok!
}</pre></div> <p>More details can be found in <a href="https://github.com/rust-lang/rfcs/pull/438">RFC 438</a>.</p>   <h3 id="E0184" class="section-header">E0184</h3> <p>The <code>Copy</code> trait was implemented on a type with a <code>Drop</code> implementation.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[derive(Copy)]
struct Foo; // error!

impl Drop for Foo {
    fn drop(&amp;mut self) {
    }
}</pre></div> <p>Explicitly implementing both <code>Drop</code> and <code>Copy</code> trait on a type is currently disallowed. This feature can make some sense in theory, but the current implementation is incorrect and can lead to memory unsafety (see <a href="https://github.com/rust-lang/rust/issues/20126">issue #20126</a>), so it has been disabled for now.</p>  <h3 id="E0185" class="section-header">E0185</h3> <p>An associated function for a trait was defined to be static, but an implementation of the trait declared the same function to be a method (i.e., to take a <code>self</code> parameter).</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Foo {
    fn foo();
}

struct Bar;

impl Foo for Bar {
    // error, method `foo` has a `&amp;self` declaration in the impl, but not in
    // the trait
    fn foo(&amp;self) {}
}</pre></div> <p>When a type implements a trait's associated function, it has to use the same signature. So in this case, since <code>Foo::foo</code> does not take any argument and does not return anything, its implementation on <code>Bar</code> should be the same:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    fn foo();
}

struct Bar;

impl Foo for Bar {
    fn foo() {} // ok!
}</pre></div>  <h3 id="E0186" class="section-header">E0186</h3> <p>An associated function for a trait was defined to be a method (i.e., to take a <code>self</code> parameter), but an implementation of the trait declared the same function to be static.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Foo {
    fn foo(&amp;self);
}

struct Bar;

impl Foo for Bar {
    // error, method `foo` has a `&amp;self` declaration in the trait, but not in
    // the impl
    fn foo() {}
}</pre></div> <p>When a type implements a trait's associated function, it has to use the same signature. So in this case, since <code>Foo::foo</code> takes <code>self</code> as argument and does not return anything, its implementation on <code>Bar</code> should be the same:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    fn foo(&amp;self);
}

struct Bar;

impl Foo for Bar {
    fn foo(&amp;self) {} // ok!
}</pre></div>  <h3 id="E0191" class="section-header">E0191</h3> <p>An associated type wasn't specified for a trait object.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Trait {
    type Bar;
}

type Foo = Trait; // error: the value of the associated type `Bar` (from
                  //        the trait `Trait`) must be specified</pre></div> <p>Trait objects need to have all associated types specified. Please verify that all associated types of the trait were specified and the correct trait was used. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Trait {
    type Bar;
}

type Foo = Trait&lt;Bar=i32&gt;; // ok!</pre></div>  <h3 id="E0193" class="section-header">E0193</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-15" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p><code>where</code> clauses must use generic type parameters: it does not make sense to use them otherwise. An example causing this error:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    fn bar(&amp;self);
}

#[derive(Copy,Clone)]
struct Wrapper&lt;T&gt; {
    Wrapped: T
}

impl Foo for Wrapper&lt;u32&gt; where Wrapper&lt;u32&gt;: Clone {
    fn bar(&amp;self) { }
}</pre></div> <p>This use of a <code>where</code> clause is strange - a more common usage would look something like the following:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    fn bar(&amp;self);
}

#[derive(Copy,Clone)]
struct Wrapper&lt;T&gt; {
    Wrapped: T
}
impl &lt;T&gt; Foo for Wrapper&lt;T&gt; where Wrapper&lt;T&gt;: Clone {
    fn bar(&amp;self) { }
}</pre></div> <p>Here, we're saying that the implementation exists on Wrapper only when the wrapped type <code>T</code> implements <code>Clone</code>. The <code>where</code> clause is important because some types will not implement <code>Clone</code>, and thus will not get this method.</p> <p>In our erroneous example, however, we're referencing a single concrete type. Since we know for certain that <code>Wrapper&lt;u32&gt;</code> implements <code>Clone</code>, there's no reason to also specify it in a <code>where</code> clause.</p>  <h3 id="E0195" class="section-header">E0195</h3> <p>The lifetime parameters of the method do not match the trait declaration.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Trait {
    fn bar&lt;'a,'b:'a&gt;(x: &amp;'a str, y: &amp;'b str);
}

struct Foo;

impl Trait for Foo {
    fn bar&lt;'a,'b&gt;(x: &amp;'a str, y: &amp;'b str) {
    // error: lifetime parameters or bounds on method `bar`
    // do not match the trait declaration
    }
}</pre></div> <p>The lifetime constraint <code>'b</code> for <code>bar()</code> implementation does not match the trait declaration. Ensure lifetime declarations match exactly in both trait declaration and implementation. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Trait {
    fn t&lt;'a,'b:'a&gt;(x: &amp;'a str, y: &amp;'b str);
}

struct Foo;

impl Trait for Foo {
    fn t&lt;'a,'b:'a&gt;(x: &amp;'a str, y: &amp;'b str) { // ok!
    }
}</pre></div>  <h3 id="E0197" class="section-header">E0197</h3> <p>An inherent implementation was marked unsafe.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo;

unsafe impl Foo { } // error!</pre></div> <p>Inherent implementations (one that do not implement a trait but provide methods associated with a type) are always safe because they are not implementing an unsafe trait. Removing the <code>unsafe</code> keyword from the inherent implementation will resolve this error.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo;

impl Foo { } // ok!</pre></div>  <h3 id="E0198" class="section-header">E0198</h3> <p>A negative implementation was marked as unsafe.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo;

unsafe impl !Clone for Foo { } // error!</pre></div> <p>A negative implementation is one that excludes a type from implementing a particular trait. Not being able to use a trait is always a safe operation, so negative implementations are always safe and never need to be marked as unsafe.</p> <p>This will compile:</p> <div class="information">ⓘThis example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">
#![feature(optin_builtin_traits)]

struct Foo;

auto trait Enterprise {}

impl !Enterprise for Foo { }</pre></div> <p>Please note that negative impls are only allowed for auto traits.</p>  <h3 id="E0199" class="section-header">E0199</h3> <p>A trait implementation was marked as unsafe while the trait is safe.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo;

trait Bar { }

unsafe impl Bar for Foo { } // error!</pre></div> <p>Safe traits should not have unsafe implementations, therefore marking an implementation for a safe trait unsafe will cause a compiler error. Removing the unsafe marker on the trait noted in the error will resolve this problem:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo;

trait Bar { }

impl Bar for Foo { } // ok!</pre></div>  <h3 id="E0200" class="section-header">E0200</h3> <p>An unsafe trait was implemented without an unsafe implementation.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo;

unsafe trait Bar { }

impl Bar for Foo { } // error!</pre></div> <p>Unsafe traits must have unsafe implementations. This error occurs when an implementation for an unsafe trait isn't marked as unsafe. This may be resolved by marking the unsafe implementation as unsafe.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo;

unsafe trait Bar { }

unsafe impl Bar for Foo { } // ok!</pre></div>  <h3 id="E0201" class="section-header">E0201</h3> <p>Two associated items (like methods, associated types, associated functions, etc.) were defined with the same identifier.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo(u8);

impl Foo {
    fn bar(&amp;self) -&gt; bool { self.0 &gt; 5 }
    fn bar() {} // error: duplicate associated function
}

trait Baz {
    type Quux;
    fn baz(&amp;self) -&gt; bool;
}

impl Baz for Foo {
    type Quux = u32;

    fn baz(&amp;self) -&gt; bool { true }

    // error: duplicate method
    fn baz(&amp;self) -&gt; bool { self.0 &gt; 5 }

    // error: duplicate associated type
    type Quux = u32;
}</pre></div> <p>Note, however, that items with the same name are allowed for inherent <code>impl</code> blocks that don't overlap:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo&lt;T&gt;(T);

impl Foo&lt;u8&gt; {
    fn bar(&amp;self) -&gt; bool { self.0 &gt; 5 }
}

impl Foo&lt;bool&gt; {
    fn bar(&amp;self) -&gt; bool { self.0 }
}</pre></div>  <h3 id="E0202" class="section-header">E0202</h3> <p>Inherent associated types were part of <a href="https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-items.md">RFC 195</a> but are not yet implemented. See <a href="https://github.com/rust-lang/rust/issues/8995">the tracking issue</a> for the status of this implementation.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo;

impl Foo {
    type Bar = isize; // error!
}</pre></div>  <h3 id="E0203" class="section-header">E0203</h3> <p>Having multiple relaxed default bounds is unsupported.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Bad&lt;T: ?Sized + ?Send&gt;{
    inner: T
}</pre></div> <p>Here the type <code>T</code> cannot have a relaxed bound for multiple default traits (<code>Sized</code> and <code>Send</code>). This can be fixed by only using one relaxed bound.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Good&lt;T: ?Sized&gt;{
    inner: T
}</pre></div>  <h3 id="E0204" class="section-header">E0204</h3> <p>The <code>Copy</code> trait was implemented on a type which contains a field that doesn't implement the <code>Copy</code> trait.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo {
    foo: Vec&lt;u32&gt;,
}

impl Copy for Foo { } // error!</pre></div> <p>The <code>Copy</code> trait is implemented by default only on primitive types. If your type only contains primitive types, you'll be able to implement <code>Copy</code> on it. Otherwise, it won't be possible.</p> <p>Here's another example that will fail:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[derive(Copy)] // error!
struct Foo&lt;'a&gt; {
    ty: &amp;'a mut bool,
}</pre></div> <p>This fails because <code>&amp;mut T</code> is not <code>Copy</code>, even when <code>T</code> is <code>Copy</code> (this differs from the behavior for <code>&amp;T</code>, which is always <code>Copy</code>).</p>  <h3 id="E0205" class="section-header">E0205</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-16" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>An attempt to implement the <code>Copy</code> trait for an enum failed because one of the variants does not implement <code>Copy</code>. To fix this, you must implement <code>Copy</code> for the mentioned variant. Note that this may not be possible, as in the example of</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
enum Foo {
    Bar(Vec&lt;u32&gt;),
    Baz,
}

impl Copy for Foo { }</pre></div> <p>This fails because <code>Vec&lt;T&gt;</code> does not implement <code>Copy</code> for any <code>T</code>.</p> <p>Here's another example that will fail:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[derive(Copy)]
enum Foo&lt;'a&gt; {
    Bar(&amp;'a mut bool),
    Baz,
}</pre></div> <p>This fails because <code>&amp;mut T</code> is not <code>Copy</code>, even when <code>T</code> is <code>Copy</code> (this differs from the behavior for <code>&amp;T</code>, which is always <code>Copy</code>).</p>  <h3 id="E0206" class="section-header">E0206</h3> <p>The <code>Copy</code> trait was implemented on a type which is neither a struct nor an enum.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
type Foo = [u8; 256];
impl Copy for Foo { } // error!

#[derive(Copy, Clone)]
struct Bar;

impl Copy for &amp;'static mut Bar { } // error!</pre></div> <p>You can only implement <code>Copy</code> for a struct or an enum. Both of the previous examples will fail, because neither <code>[u8; 256]</code> nor <code>&amp;'static mut Bar</code> (mutable reference to <code>Bar</code>) is a struct or enum.</p>  <h3 id="E0207" class="section-header">E0207</h3> <p>A type parameter that is specified for <code>impl</code> is not constrained.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo;

impl&lt;T: Default&gt; Foo {
    // error: the type parameter `T` is not constrained by the impl trait, self
    // type, or predicates [E0207]
    fn get(&amp;self) -&gt; T {
        &lt;T as Default&gt;::default()
    }
}</pre></div> <p>Any type parameter parameter of an <code>impl</code> must meet at least one of the following criteria:</p> <ul> <li>it appears in the <em>implementing type</em> of the impl, e.g. <code>impl&lt;T&gt; Foo&lt;T&gt;</code>
</li> <li>for a trait impl, it appears in the <em>implemented trait</em>, e.g. <code>impl&lt;T&gt; SomeTrait&lt;T&gt; for Foo</code>
</li> <li>it is bound as an associated type, e.g. <code>impl&lt;T, U&gt; SomeTrait for T where T: AnotherTrait&lt;AssocType=U&gt;</code>
</li> </ul> <h3 id="error-example-1" class="section-header">Error example 1</h3> <p>Suppose we have a struct <code>Foo</code> and we would like to define some methods for it. The previous code example has a definition which leads to a compiler error:</p> <p>The problem is that the parameter <code>T</code> does not appear in the implementing type (<code>Foo</code>) of the impl. In this case, we can fix the error by moving the type parameter from the <code>impl</code> to the method <code>get</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo;

// Move the type parameter from the impl to the method
impl Foo {
    fn get&lt;T: Default&gt;(&amp;self) -&gt; T {
        &lt;T as Default&gt;::default()
    }
}</pre></div> <h3 id="error-example-2" class="section-header">Error example 2</h3> <p>As another example, suppose we have a <code>Maker</code> trait and want to establish a type <code>FooMaker</code> that makes <code>Foo</code>s:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Maker {
    type Item;
    fn make(&amp;mut self) -&gt; Self::Item;
}

struct Foo&lt;T&gt; {
    foo: T
}

struct FooMaker;

impl&lt;T: Default&gt; Maker for FooMaker {
// error: the type parameter `T` is not constrained by the impl trait, self
// type, or predicates [E0207]
    type Item = Foo&lt;T&gt;;

    fn make(&amp;mut self) -&gt; Foo&lt;T&gt; {
        Foo { foo: &lt;T as Default&gt;::default() }
    }
}</pre></div> <p>This fails to compile because <code>T</code> does not appear in the trait or in the implementing type.</p> <p>One way to work around this is to introduce a phantom type parameter into <code>FooMaker</code>, like so:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::marker::PhantomData;

trait Maker {
    type Item;
    fn make(&amp;mut self) -&gt; Self::Item;
}

struct Foo&lt;T&gt; {
    foo: T
}

// Add a type parameter to `FooMaker`
struct FooMaker&lt;T&gt; {
    phantom: PhantomData&lt;T&gt;,
}

impl&lt;T: Default&gt; Maker for FooMaker&lt;T&gt; {
    type Item = Foo&lt;T&gt;;

    fn make(&amp;mut self) -&gt; Foo&lt;T&gt; {
        Foo {
            foo: &lt;T as Default&gt;::default(),
        }
    }
}</pre></div> <p>Another way is to do away with the associated type in <code>Maker</code> and use an input type parameter instead:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
// Use a type parameter instead of an associated type here
trait Maker&lt;Item&gt; {
    fn make(&amp;mut self) -&gt; Item;
}

struct Foo&lt;T&gt; {
    foo: T
}

struct FooMaker;

impl&lt;T: Default&gt; Maker&lt;Foo&lt;T&gt;&gt; for FooMaker {
    fn make(&amp;mut self) -&gt; Foo&lt;T&gt; {
        Foo { foo: &lt;T as Default&gt;::default() }
    }
}</pre></div> <h3 id="additional-information" class="section-header">Additional information</h3> <p>For more information, please see <a href="https://github.com/rust-lang/rfcs/blob/master/text/0447-no-unused-impl-parameters.md">RFC 447</a>.</p>   <h3 id="E0210" class="section-header">E0210</h3> <p>This error indicates a violation of one of Rust's orphan rules for trait implementations. The rule concerns the use of type parameters in an implementation of a foreign trait (a trait defined in another crate), and states that type parameters must be "covered" by a local type.</p> <p>When implementing a foreign trait for a foreign type, the trait must have one or more type parameters. A type local to your crate must appear before any use of any type parameters.</p> <p>To understand what this means, it is perhaps easier to consider a few examples.</p> <p>If <code>ForeignTrait</code> is a trait defined in some external crate <code>foo</code>, then the following trait <code>impl</code> is an error:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
extern crate foo;
use foo::ForeignTrait;

impl&lt;T&gt; ForeignTrait for T { } // error</pre></div> <p>To work around this, it can be covered with a local type, <code>MyType</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct MyType&lt;T&gt;(T);
impl&lt;T&gt; ForeignTrait for MyType&lt;T&gt; { } // Ok</pre></div> <p>Please note that a type alias is not sufficient.</p> <p>For another example of an error, suppose there's another trait defined in <code>foo</code> named <code>ForeignTrait2</code> that takes two type parameters. Then this <code>impl</code> results in the same rule violation:</p> <div class="information">ⓘThis example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">
struct MyType2;
impl&lt;T&gt; ForeignTrait2&lt;T, MyType&lt;T&gt;&gt; for MyType2 { } // error</pre></div> <p>The reason for this is that there are two appearances of type parameter <code>T</code> in the <code>impl</code> header, both as parameters for <code>ForeignTrait2</code>. The first appearance is uncovered, and so runs afoul of the orphan rule.</p> <p>Consider one more example:</p> <div class="information">ⓘThis example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">
impl&lt;T&gt; ForeignTrait2&lt;MyType&lt;T&gt;, T&gt; for MyType2 { } // Ok</pre></div> <p>This only differs from the previous <code>impl</code> in that the parameters <code>T</code> and <code>MyType&lt;T&gt;</code> for <code>ForeignTrait2</code> have been swapped. This example does <em>not</em> violate the orphan rule; it is permitted.</p> <p>To see why that last example was allowed, you need to understand the general rule. Unfortunately this rule is a bit tricky to state. Consider an <code>impl</code>:</p> <div class="information">ⓘThis example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">
impl&lt;P1, ..., Pm&gt; ForeignTrait&lt;T1, ..., Tn&gt; for T0 { ... }</pre></div> <p>where <code>P1, ..., Pm</code> are the type parameters of the <code>impl</code> and <code>T0, ..., Tn</code> are types. One of the types <code>T0, ..., Tn</code> must be a local type (this is another orphan rule, see the explanation for E0117).</p> <p>Both of the following must be true:</p> <ol> <li>At least one of the types <code>T0..=Tn</code> must be a local type. Let <code>Ti</code> be the first such type.</li> <li>No uncovered type parameters <code>P1..=Pm</code> may appear in <code>T0..Ti</code> (excluding <code>Ti</code>).</li> </ol> <p>For information on the design of the orphan rules, see <a href="https://rust-lang.github.io/rfcs/2451-re-rebalancing-coherence.html">RFC 2451</a> and <a href="https://github.com/rust-lang/rfcs/blob/master/text/1023-rebalancing-coherence.md">RFC 1023</a>.</p> <p>For information on the design of the orphan rules, see <a href="https://github.com/rust-lang/rfcs/blob/master/text/1023-rebalancing-coherence.md">RFC 1023</a>.</p>  <h3 id="E0211" class="section-header">E0211</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-17" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>You used a function or type which doesn't fit the requirements for where it was used. Erroneous code examples:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(intrinsics)]

extern "rust-intrinsic" {
    fn size_of&lt;T&gt;(); // error: intrinsic has wrong type
}

// or:

fn main() -&gt; i32 { 0 }
// error: main function expects type: `fn() {main}`: expected (), found i32

// or:

let x = 1u8;
match x {
    0u8..=3i8 =&gt; (),
    // error: mismatched types in range: expected u8, found i8
    _ =&gt; ()
}

// or:

use std::rc::Rc;
struct Foo;

impl Foo {
    fn x(self: Rc&lt;Foo&gt;) {}
    // error: mismatched self type: expected `Foo`: expected struct
    //        `Foo`, found struct `alloc::rc::Rc`
}</pre></div> <p>For the first code example, please check the function definition. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(intrinsics)]

extern "rust-intrinsic" {
    fn size_of&lt;T&gt;() -&gt; usize; // ok!
}</pre></div> <p>The second case example is a bit particular: the main function must always have this definition:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn main();</pre></div> <p>They never take parameters and never return types.</p> <p>For the third example, when you match, all patterns must have the same type as the type you're matching on. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x = 1u8;

match x {
    0u8..=3u8 =&gt; (), // ok!
    _ =&gt; ()
}</pre></div> <p>And finally, for the last example, only <code>Box&lt;Self&gt;</code>, <code>&amp;Self</code>, <code>Self</code>, or <code>&amp;mut Self</code> work as explicit self parameters. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo;

impl Foo {
    fn x(self: Box&lt;Foo&gt;) {} // ok!
}</pre></div>   <h3 id="E0214" class="section-header">E0214</h3> <p>A generic type was described using parentheses rather than angle brackets.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let v: Vec(&amp;str) = vec!["foo"];</pre></div> <p>This is not currently supported: <code>v</code> should be defined as <code>Vec&lt;&amp;str&gt;</code>. Parentheses are currently only used with generic types when defining parameters for <code>Fn</code>-family traits.</p> <p>The previous code example fixed:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let v: Vec&lt;&amp;str&gt; = vec!["foo"];</pre></div>  <h3 id="E0220" class="section-header">E0220</h3> <p>The associated type used was not defined in the trait.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait T1 {
    type Bar;
}

type Foo = T1&lt;F=i32&gt;; // error: associated type `F` not found for `T1`

// or:

trait T2 {
    type Bar;

    // error: Baz is used but not declared
    fn return_bool(&amp;self, _: &amp;Self::Bar, _: &amp;Self::Baz) -&gt; bool;
}</pre></div> <p>Make sure that you have defined the associated type in the trait body. Also, verify that you used the right trait or you didn't misspell the associated type name. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait T1 {
    type Bar;
}

type Foo = T1&lt;Bar=i32&gt;; // ok!

// or:

trait T2 {
    type Bar;
    type Baz; // we declare `Baz` in our trait.

    // and now we can use it here:
    fn return_bool(&amp;self, _: &amp;Self::Bar, _: &amp;Self::Baz) -&gt; bool;
}</pre></div>  <h3 id="E0221" class="section-header">E0221</h3> <p>An attempt was made to retrieve an associated type, but the type was ambiguous.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait T1 {}
trait T2 {}

trait Foo {
    type A: T1;
}

trait Bar : Foo {
    type A: T2;
    fn do_something() {
        let _: Self::A;
    }
}</pre></div> <p>In this example, <code>Foo</code> defines an associated type <code>A</code>. <code>Bar</code> inherits that type from <code>Foo</code>, and defines another associated type of the same name. As a result, when we attempt to use <code>Self::A</code>, it's ambiguous whether we mean the <code>A</code> defined by <code>Foo</code> or the one defined by <code>Bar</code>.</p> <p>There are two options to work around this issue. The first is simply to rename one of the types. Alternatively, one can specify the intended type using the following syntax:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait T1 {}
trait T2 {}

trait Foo {
    type A: T1;
}

trait Bar : Foo {
    type A: T2;
    fn do_something() {
        let _: &lt;Self as Bar&gt;::A;
    }
}</pre></div>  <h3 id="E0222" class="section-header">E0222</h3> <p>An attempt was made to constrain an associated type.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
pub trait Vehicle {
    type Color;
}

pub trait Box {
    type Color;
}

pub trait BoxCar : Box + Vehicle {}

fn dent_object&lt;COLOR&gt;(c: dyn BoxCar&lt;Color=COLOR&gt;) {} // Invalid constraint</pre></div> <p>In this example, <code>BoxCar</code> has two super-traits: <code>Vehicle</code> and <code>Box</code>. Both of these traits define an associated type <code>Color</code>. <code>BoxCar</code> inherits two types with that name from both super-traits. Because of this, we need to use the fully qualified path syntax to refer to the appropriate <code>Color</code> associated type, either <code>&lt;BoxCar as Vehicle&gt;::Color</code> or <code>&lt;BoxCar as Box&gt;::Color</code>, but this syntax is not allowed to be used in a function signature.</p> <p>In order to encode this kind of constraint, a <code>where</code> clause and a new type parameter are needed:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
pub trait Vehicle {
    type Color;
}

pub trait Box {
    type Color;
}

pub trait BoxCar : Box + Vehicle {}

// Introduce a new `CAR` type parameter
fn foo&lt;CAR, COLOR&gt;(
    c: CAR,
) where
    // Bind the type parameter `CAR` to the trait `BoxCar`
    CAR: BoxCar,
    // Further restrict `&lt;BoxCar as Vehicle&gt;::Color` to be the same as the
    // type parameter `COLOR`
    CAR: Vehicle&lt;Color = COLOR&gt;,
    // We can also simultaneously restrict the other trait's associated type
    CAR: Box&lt;Color = COLOR&gt;
{}</pre></div>  <h3 id="E0223" class="section-header">E0223</h3> <p>An attempt was made to retrieve an associated type, but the type was ambiguous.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait MyTrait {type X; }

fn main() {
    let foo: MyTrait::X;
}</pre></div> <p>The problem here is that we're attempting to take the type of X from MyTrait. Unfortunately, the type of X is not defined, because it's only made concrete in implementations of the trait. A working version of this code might look like:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait MyTrait {type X; }
struct MyStruct;

impl MyTrait for MyStruct {
    type X = u32;
}

fn main() {
    let foo: &lt;MyStruct as MyTrait&gt;::X;
}</pre></div> <p>This syntax specifies that we want the X type from MyTrait, as made concrete in MyStruct. The reason that we cannot simply use <code>MyStruct::X</code> is that MyStruct might implement two different traits with identically-named associated types. This syntax allows disambiguation between the two.</p>  <h3 id="E0224" class="section-header">E0224</h3> <p>A trait object was declaired with no traits.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
type Foo = dyn 'static +;</pre></div> <p>Rust does not currently support this.</p> <p>To solve ensure the the trait object has at least one trait:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
type Foo = dyn 'static + Copy;</pre></div>  <h3 id="E0225" class="section-header">E0225</h3> <p>Multiple types were used as bounds for a closure or trait object.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn main() {
    let _: Box&lt;dyn std::io::Read + std::io::Write&gt;;
}</pre></div> <p>Rust does not currently support this.</p> <p>Auto traits such as Send and Sync are an exception to this rule: It's possible to have bounds of one non-builtin trait, plus any number of auto traits. For example, the following compiles correctly:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn main() {
    let _: Box&lt;dyn std::io::Read + Send + Sync&gt;;
}</pre></div>  <h3 id="E0226" class="section-header">E0226</h3> <p>More than one explicit lifetime bound was used on a trait object.</p> <p>Example of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Foo {}

type T&lt;'a, 'b&gt; = dyn Foo + 'a + 'b; // error: Trait object `arg` has two
                                    //        lifetime bound, 'a and 'b.</pre></div> <p>Here <code>T</code> is a trait object with two explicit lifetime bounds, 'a and 'b.</p> <p>Only a single explicit lifetime bound is permitted on trait objects. To fix this error, consider removing one of the lifetime bounds:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Foo {}

type T&lt;'a&gt; = dyn Foo + 'a;</pre></div>   <h3 id="E0228" class="section-header">E0228</h3> <p>The lifetime bound for this object type cannot be deduced from context and must be specified.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Trait { }

struct TwoBounds&lt;'a, 'b, T: Sized + 'a + 'b&gt; {
    x: &amp;'a i32,
    y: &amp;'b i32,
    z: T,
}

type Foo&lt;'a, 'b&gt; = TwoBounds&lt;'a, 'b, dyn Trait&gt;;</pre></div> <p>When a trait object is used as a type argument of a generic type, Rust will try to infer its lifetime if unspecified. However, this isn't possible when the containing type has more than one lifetime bound.</p> <p>The above example can be resolved by either reducing the number of lifetime bounds to one or by making the trait object lifetime explicit, like so:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Trait { }

struct TwoBounds&lt;'a, 'b, T: Sized + 'a + 'b&gt; {
    x: &amp;'a i32,
    y: &amp;'b i32,
    z: T,
}

type Foo&lt;'a, 'b&gt; = TwoBounds&lt;'a, 'b, dyn Trait + 'b&gt;;</pre></div> <p>For more information, see <a href="https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md">RFC 599</a> and its amendment <a href="https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md">RFC 1156</a>.</p>  <h3 id="E0229" class="section-header">E0229</h3> <p>An associated type binding was done outside of the type parameter declaration and <code>where</code> clause.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
pub trait Foo {
    type A;
    fn boo(&amp;self) -&gt; &lt;Self as Foo&gt;::A;
}

struct Bar;

impl Foo for isize {
    type A = usize;
    fn boo(&amp;self) -&gt; usize { 42 }
}

fn baz&lt;I&gt;(x: &amp;&lt;I as Foo&lt;A=Bar&gt;&gt;::A) {}
// error: associated type bindings are not allowed here</pre></div> <p>To solve this error, please move the type bindings in the type parameter declaration:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn baz&lt;I: Foo&lt;A=Bar&gt;&gt;(x: &amp;&lt;I as Foo&gt;::A) {} // ok!</pre></div> <p>Or in the <code>where</code> clause:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn baz&lt;I&gt;(x: &amp;&lt;I as Foo&gt;::A) where I: Foo&lt;A=Bar&gt; {}</pre></div>  <h3 id="E0230" class="section-header">E0230</h3> <p>The <code>#[rustc_on_unimplemented]</code> attribute lets you specify a custom error message for when a particular trait isn't implemented on a type placed in a position that needs that trait. For example, when the following code is compiled:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(rustc_attrs)]

#[rustc_on_unimplemented = "error on `{Self}` with params `&lt;{A},{B}&gt;`"] // error
trait BadAnnotation&lt;A&gt; {}</pre></div> <p>There will be an error about <code>bool</code> not implementing <code>Index&lt;u8&gt;</code>, followed by a note saying "the type <code>bool</code> cannot be indexed by <code>u8</code>".</p> <p>As you can see, you can specify type parameters in curly braces for substitution with the actual types (using the regular format string syntax) in a given situation. Furthermore, <code>{Self}</code> will substitute to the type (in this case, <code>bool</code>) that we tried to use.</p> <p>This error appears when the curly braces contain an identifier which doesn't match with any of the type parameters or the string <code>Self</code>. This might happen if you misspelled a type parameter, or if you intended to use literal curly braces. If it is the latter, escape the curly braces with a second curly brace of the same type; e.g., a literal <code>{</code> is <code>{{</code>.</p>  <h3 id="E0231" class="section-header">E0231</h3> <p>The <code>#[rustc_on_unimplemented]</code> attribute lets you specify a custom error message for when a particular trait isn't implemented on a type placed in a position that needs that trait. For example, when the following code is compiled:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(rustc_attrs)]

#[rustc_on_unimplemented = "error on `{Self}` with params `&lt;{A},{}&gt;`"] // error!
trait BadAnnotation&lt;A&gt; {}</pre></div> <p>there will be an error about <code>bool</code> not implementing <code>Index&lt;u8&gt;</code>, followed by a note saying "the type <code>bool</code> cannot be indexed by <code>u8</code>".</p> <p>As you can see, you can specify type parameters in curly braces for substitution with the actual types (using the regular format string syntax) in a given situation. Furthermore, <code>{Self}</code> will substitute to the type (in this case, <code>bool</code>) that we tried to use.</p> <p>This error appears when the curly braces do not contain an identifier. Please add one of the same name as a type parameter. If you intended to use literal braces, use <code>{{</code> and <code>}}</code> to escape them.</p>  <h3 id="E0232" class="section-header">E0232</h3> <p>The <code>#[rustc_on_unimplemented]</code> attribute lets you specify a custom error message for when a particular trait isn't implemented on a type placed in a position that needs that trait. For example, when the following code is compiled:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(rustc_attrs)]

#[rustc_on_unimplemented(lorem="")] // error!
trait BadAnnotation {}</pre></div> <p>there will be an error about <code>bool</code> not implementing <code>Index&lt;u8&gt;</code>, followed by a note saying "the type <code>bool</code> cannot be indexed by <code>u8</code>".</p> <p>For this to work, some note must be specified. An empty attribute will not do anything, please remove the attribute or add some helpful note for users of the trait.</p>  <h3 id="E0243" class="section-header">E0243</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-18" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>This error indicates that not enough type parameters were found in a type or trait.</p> <p>For example, the <code>Foo</code> struct below is defined to be generic in <code>T</code>, but the type parameter is missing in the definition of <code>Bar</code>:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo&lt;T&gt; { x: T }

struct Bar { x: Foo }</pre></div>  <h3 id="E0244" class="section-header">E0244</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-19" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>This error indicates that too many type parameters were found in a type or trait.</p> <p>For example, the <code>Foo</code> struct below has no type parameters, but is supplied with two in the definition of <code>Bar</code>:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo { x: bool }

struct Bar&lt;S, T&gt; { x: Foo&lt;S, T&gt; }</pre></div>  <h3 id="E0251" class="section-header">E0251</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-20" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>Two items of the same name cannot be imported without rebinding one of the items under a new local name.</p> <p>An example of this error:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use foo::baz;
use bar::*; // error, do `use foo::baz as quux` instead on the previous line

fn main() {}

mod foo {
    pub struct baz;
}

mod bar {
    pub mod baz {}
}</pre></div>  <h3 id="E0252" class="section-header">E0252</h3> <p>Two items of the same name cannot be imported without rebinding one of the items under a new local name.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
use foo::baz;
use bar::baz; // error, do `use bar::baz as quux` instead

fn main() {}

mod foo {
    pub struct baz;
}

mod bar {
    pub mod baz {}
}</pre></div> <p>You can use aliases in order to fix this error. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use foo::baz as foo_baz;
use bar::baz; // ok!

fn main() {}

mod foo {
    pub struct baz;
}

mod bar {
    pub mod baz {}
}</pre></div> <p>Or you can reference the item with its parent:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use bar::baz;

fn main() {
    let x = foo::baz; // ok!
}

mod foo {
    pub struct baz;
}

mod bar {
    pub mod baz {}
}</pre></div>  <h3 id="E0253" class="section-header">E0253</h3> <p>Attempt was made to import an unimportable value. This can happen when trying to import a method from a trait.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
mod foo {
    pub trait MyTrait {
        fn do_something();
    }
}

use foo::MyTrait::do_something;
// error: `do_something` is not directly importable

fn main() {}</pre></div> <p>It's invalid to directly import methods belonging to a trait or concrete type.</p>  <h3 id="E0254" class="section-header">E0254</h3> <p>Attempt was made to import an item whereas an extern crate with this name has already been imported.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
extern crate core;

mod foo {
    pub trait core {
        fn do_something();
    }
}

use foo::core;  // error: an extern crate named `core` has already
                //        been imported in this module

fn main() {}</pre></div> <p>To fix this issue, you have to rename at least one of the two imports. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
extern crate core as libcore; // ok!

mod foo {
    pub trait core {
        fn do_something();
    }
}

use foo::core;

fn main() {}</pre></div>  <h3 id="E0255" class="section-header">E0255</h3> <p>You can't import a value whose name is the same as another value defined in the module.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
use bar::foo; // error: an item named `foo` is already in scope

fn foo() {}

mod bar {
     pub fn foo() {}
}

fn main() {}</pre></div> <p>You can use aliases in order to fix this error. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use bar::foo as bar_foo; // ok!

fn foo() {}

mod bar {
     pub fn foo() {}
}

fn main() {}</pre></div> <p>Or you can reference the item with its parent:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo() {}

mod bar {
     pub fn foo() {}
}

fn main() {
    bar::foo(); // we get the item by referring to its parent
}</pre></div>  <h3 id="E0256" class="section-header">E0256</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-21" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>You can't import a type or module when the name of the item being imported is the same as another type or submodule defined in the module.</p> <p>An example of this error:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
use foo::Bar; // error

type Bar = u32;

mod foo {
    pub mod Bar { }
}

fn main() {}</pre></div>  <h3 id="E0259" class="section-header">E0259</h3> <p>The name chosen for an external crate conflicts with another external crate that has been imported into the current module.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
extern crate core;
extern crate std as core;

fn main() {}</pre></div> <p>The solution is to choose a different name that doesn't conflict with any external crate imported into the current module.</p> <p>Correct example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
extern crate core;
extern crate std as other_name;

fn main() {}</pre></div>  <h3 id="E0260" class="section-header">E0260</h3> <p>The name for an item declaration conflicts with an external crate's name.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
extern crate core;

struct core;

fn main() {}</pre></div> <p>There are two possible solutions:</p> <p>Solution #1: Rename the item.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
extern crate core;

struct xyz;</pre></div> <p>Solution #2: Import the crate with a different name.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
extern crate core as xyz;

struct abc;</pre></div> <p>See the <a href="reference/statements#declaration-statements">Declaration Statements</a> section of the reference for more information about what constitutes an item declaration and what does not.</p>  <h3 id="E0261" class="section-header">E0261</h3> <p>An undeclared lifetime was used.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
// error, use of undeclared lifetime name `'a`
fn foo(x: &amp;'a str) { }

struct Foo {
    // error, use of undeclared lifetime name `'a`
    x: &amp;'a str,
}</pre></div> <p>These can be fixed by declaring lifetime parameters:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo&lt;'a&gt; {
    x: &amp;'a str,
}

fn foo&lt;'a&gt;(x: &amp;'a str) {}</pre></div> <p>Impl blocks declare lifetime parameters separately. You need to add lifetime parameters to an impl block if you're implementing a type that has a lifetime parameter of its own. For example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo&lt;'a&gt; {
    x: &amp;'a str,
}

// error,  use of undeclared lifetime name `'a`
impl Foo&lt;'a&gt; {
    fn foo&lt;'a&gt;(x: &amp;'a str) {}
}</pre></div> <p>This is fixed by declaring the impl block like this:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo&lt;'a&gt; {
    x: &amp;'a str,
}

// correct
impl&lt;'a&gt; Foo&lt;'a&gt; {
    fn foo(x: &amp;'a str) {}
}</pre></div>  <h3 id="E0262" class="section-header">E0262</h3> <p>An invalid name was used for a lifetime parameter.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
// error, invalid lifetime parameter name `'static`
fn foo&lt;'static&gt;(x: &amp;'static str) { }</pre></div> <p>Declaring certain lifetime names in parameters is disallowed. For example, because the <code>'static</code> lifetime is a special built-in lifetime name denoting the lifetime of the entire program, this is an error:</p>  <h3 id="E0263" class="section-header">E0263</h3> <p>A lifetime was declared more than once in the same scope.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn foo&lt;'a, 'b, 'a&gt;(x: &amp;'a str, y: &amp;'b str, z: &amp;'a str) { // error!
}</pre></div> <p>Two lifetimes cannot have the same name. To fix this example, change the second <code>'a</code> lifetime into something else (<code>'c</code> for example):</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo&lt;'a, 'b, 'c&gt;(x: &amp;'a str, y: &amp;'b str, z: &amp;'c str) { // ok!
}</pre></div>  <h3 id="E0264" class="section-header">E0264</h3> <p>An unknown external lang item was used.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(lang_items)]

extern "C" {
    #[lang = "cake"] // error: unknown external lang item: `cake`
    fn cake();
}</pre></div> <p>A list of available external lang items is available in <code>src/librustc_middle/middle/weak_lang_items.rs</code>. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(lang_items)]

extern "C" {
    #[lang = "panic_impl"] // ok!
    fn cake();
}</pre></div>  <h3 id="E0267" class="section-header">E0267</h3> <p>A loop keyword (<code>break</code> or <code>continue</code>) was used inside a closure but outside of any loop.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let w = || { break; }; // error: `break` inside of a closure</pre></div> <p><code>break</code> and <code>continue</code> keywords can be used as normal inside closures as long as they are also contained within a loop. To halt the execution of a closure you should instead use a return statement. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let w = || {
    for _ in 0..10 {
        break;
    }
};

w();</pre></div>  <h3 id="E0268" class="section-header">E0268</h3> <p>A loop keyword (<code>break</code> or <code>continue</code>) was used outside of a loop.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn some_func() {
    break; // error: `break` outside of a loop
}</pre></div> <p>Without a loop to break out of or continue in, no sensible action can be taken. Please verify that you are using <code>break</code> and <code>continue</code> only in loops. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn some_func() {
    for _ in 0..10 {
        break; // ok!
    }
}</pre></div>  <h3 id="E0271" class="section-header">E0271</h3> <p>A type mismatched an associated type of a trait.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Trait { type AssociatedType; }

fn foo&lt;T&gt;(t: T) where T: Trait&lt;AssociatedType=u32&gt; {
//                    ~~~~~~~~ ~~~~~~~~~~~~~~~~~~
//                        |            |
//         This says `foo` can         |
//           only be used with         |
//              some type that         |
//         implements `Trait`.         |
//                                     |
//                             This says not only must
//                             `T` be an impl of `Trait`
//                             but also that the impl
//                             must assign the type `u32`
//                             to the associated type.
    println!("in foo");
}

impl Trait for i8 { type AssociatedType = &amp;'static str; }
//~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//      |                             |
// `i8` does have                     |
// implementation                     |
// of `Trait`...                      |
//                     ... but it is an implementation
//                     that assigns `&amp;'static str` to
//                     the associated type.

foo(3_i8);
// Here, we invoke `foo` with an `i8`, which does not satisfy
// the constraint `&lt;i8 as Trait&gt;::AssociatedType=u32`, and
// therefore the type-checker complains with this error code.</pre></div> <p>The issue can be resolved by changing the associated type:</p> <ol> <li>in the <code>foo</code> implementation:</li> </ol> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Trait { type AssociatedType; }

fn foo&lt;T&gt;(t: T) where T: Trait&lt;AssociatedType = &amp;'static str&gt; {
    println!("in foo");
}

impl Trait for i8 { type AssociatedType = &amp;'static str; }

foo(3_i8);</pre></div> <ol start="2"> <li>in the <code>Trait</code> implementation for <code>i8</code>:</li> </ol> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Trait { type AssociatedType; }

fn foo&lt;T&gt;(t: T) where T: Trait&lt;AssociatedType = u32&gt; {
    println!("in foo");
}

impl Trait for i8 { type AssociatedType = u32; }

foo(3_i8);</pre></div>  <h3 id="E0275" class="section-header">E0275</h3> <p>An evaluation of a trait requirement overflowed.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Foo {}

struct Bar&lt;T&gt;(T);

impl&lt;T&gt; Foo for T where Bar&lt;T&gt;: Foo {}</pre></div> <p>This error occurs when there was a recursive trait requirement that overflowed before it could be evaluated. This often means that there is an unbounded recursion in resolving some type bounds.</p> <p>To determine if a <code>T</code> is <code>Foo</code>, we need to check if <code>Bar&lt;T&gt;</code> is <code>Foo</code>. However, to do this check, we need to determine that <code>Bar&lt;Bar&lt;T&gt;&gt;</code> is <code>Foo</code>. To determine this, we check if <code>Bar&lt;Bar&lt;Bar&lt;T&gt;&gt;&gt;</code> is <code>Foo</code>, and so on. This is clearly a recursive requirement that can't be resolved directly.</p> <p>Consider changing your trait bounds so that they're less self-referential.</p>  <h3 id="E0276" class="section-header">E0276</h3> <p>A trait implementation has stricter requirements than the trait definition.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Foo {
    fn foo&lt;T&gt;(x: T);
}

impl Foo for bool {
    fn foo&lt;T&gt;(x: T) where T: Copy {}
}</pre></div> <p>Here, all types implementing <code>Foo</code> must have a method <code>foo&lt;T&gt;(x: T)</code> which can take any type <code>T</code>. However, in the <code>impl</code> for <code>bool</code>, we have added an extra bound that <code>T</code> is <code>Copy</code>, which isn't compatible with the original trait.</p> <p>Consider removing the bound from the method or adding the bound to the original method definition in the trait.</p>  <h3 id="E0277" class="section-header">E0277</h3> <p>You tried to use a type which doesn't implement some trait in a place which expected that trait.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
// here we declare the Foo trait with a bar method
trait Foo {
    fn bar(&amp;self);
}

// we now declare a function which takes an object implementing the Foo trait
fn some_func&lt;T: Foo&gt;(foo: T) {
    foo.bar();
}

fn main() {
    // we now call the method with the i32 type, which doesn't implement
    // the Foo trait
    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied
}</pre></div> <p>In order to fix this error, verify that the type you're using does implement the trait. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    fn bar(&amp;self);
}

fn some_func&lt;T: Foo&gt;(foo: T) {
    foo.bar(); // we can now use this method since i32 implements the
               // Foo trait
}

// we implement the trait on the i32 type
impl Foo for i32 {
    fn bar(&amp;self) {}
}

fn main() {
    some_func(5i32); // ok!
}</pre></div> <p>Or in a generic context, an erroneous code example would look like:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn some_func&lt;T&gt;(foo: T) {
    println!("{:?}", foo); // error: the trait `core::fmt::Debug` is not
                           //        implemented for the type `T`
}

fn main() {
    // We now call the method with the i32 type,
    // which *does* implement the Debug trait.
    some_func(5i32);
}</pre></div> <p>Note that the error here is in the definition of the generic function: Although we only call it with a parameter that does implement <code>Debug</code>, the compiler still rejects the function: It must work with all possible input types. In order to make this example compile, we need to restrict the generic type we're accepting:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::fmt;

// Restrict the input type to types that implement Debug.
fn some_func&lt;T: fmt::Debug&gt;(foo: T) {
    println!("{:?}", foo);
}

fn main() {
    // Calling the method is still fine, as i32 implements Debug.
    some_func(5i32);

    // This would fail to compile now:
    // struct WithoutDebug;
    // some_func(WithoutDebug);
}</pre></div> <p>Rust only looks at the signature of the called function, as such it must already specify all requirements that will be used for every type parameter.</p>    <h3 id="E0281" class="section-header">E0281</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-22" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>You tried to supply a type which doesn't implement some trait in a location which expected that trait. This error typically occurs when working with <code>Fn</code>-based types. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn foo&lt;F: Fn(usize)&gt;(x: F) { }

fn main() {
    // type mismatch: ... implements the trait `core::ops::Fn&lt;(String,)&gt;`,
    // but the trait `core::ops::Fn&lt;(usize,)&gt;` is required
    // [E0281]
    foo(|y: String| { });
}</pre></div> <p>The issue in this case is that <code>foo</code> is defined as accepting a <code>Fn</code> with one argument of type <code>String</code>, but the closure we attempted to pass to it requires one arguments of type <code>usize</code>.</p>  <h3 id="E0282" class="section-header">E0282</h3> <p>The compiler could not infer a type and asked for a type annotation.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let x = "hello".chars().rev().collect();</pre></div> <p>This error indicates that type inference did not result in one unique possible type, and extra information is required. In most cases this can be provided by adding a type annotation. Sometimes you need to specify a generic type parameter manually.</p> <p>A common example is the <code>collect</code> method on <code>Iterator</code>. It has a generic type parameter with a <code>FromIterator</code> bound, which for a <code>char</code> iterator is implemented by <code>Vec</code> and <code>String</code> among others. Consider the following snippet that reverses the characters of a string:</p> <p>In the first code example, the compiler cannot infer what the type of <code>x</code> should be: <code>Vec&lt;char&gt;</code> and <code>String</code> are both suitable candidates. To specify which type to use, you can use a type annotation on <code>x</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x: Vec&lt;char&gt; = "hello".chars().rev().collect();</pre></div> <p>It is not necessary to annotate the full type. Once the ambiguity is resolved, the compiler can infer the rest:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x: Vec&lt;_&gt; = "hello".chars().rev().collect();</pre></div> <p>Another way to provide the compiler with enough information, is to specify the generic type parameter:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x = "hello".chars().rev().collect::&lt;Vec&lt;char&gt;&gt;();</pre></div> <p>Again, you need not specify the full type if the compiler can infer it:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x = "hello".chars().rev().collect::&lt;Vec&lt;_&gt;&gt;();</pre></div> <p>Apart from a method or function with a generic type parameter, this error can occur when a type parameter of a struct or trait cannot be inferred. In that case it is not always possible to use a type annotation, because all candidates have the same return type. For instance:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo&lt;T&gt; {
    num: T,
}

impl&lt;T&gt; Foo&lt;T&gt; {
    fn bar() -&gt; i32 {
        0
    }

    fn baz() {
        let number = Foo::bar();
    }
}</pre></div> <p>This will fail because the compiler does not know which instance of <code>Foo</code> to call <code>bar</code> on. Change <code>Foo::bar()</code> to <code>Foo::&lt;T&gt;::bar()</code> to resolve the error.</p>  <h3 id="E0283" class="section-header">E0283</h3> <p>An implementation cannot be chosen unambiguously because of lack of information.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Generator {
    fn create() -&gt; u32;
}

struct Impl;

impl Generator for Impl {
    fn create() -&gt; u32 { 1 }
}

struct AnotherImpl;

impl Generator for AnotherImpl {
    fn create() -&gt; u32 { 2 }
}

fn main() {
    let cont: u32 = Generator::create();
    // error, impossible to choose one of Generator trait implementation
    // Should it be Impl or AnotherImpl, maybe something else?
}</pre></div> <p>This error can be solved by adding type annotations that provide the missing information to the compiler. In this case, the solution is to use a concrete type:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Generator {
    fn create() -&gt; u32;
}

struct AnotherImpl;

impl Generator for AnotherImpl {
    fn create() -&gt; u32 { 2 }
}

fn main() {
    let gen1 = AnotherImpl::create();

    // if there are multiple methods with same name (different traits)
    let gen2 = &lt;AnotherImpl as Generator&gt;::create();
}</pre></div>  <h3 id="E0284" class="section-header">E0284</h3> <p>This error occurs when the compiler is unable to unambiguously infer the return type of a function or method which is generic on return type, such as the <code>collect</code> method for <code>Iterator</code>s.</p> <p>For example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn foo() -&gt; Result&lt;bool, ()&gt; {
    let results = [Ok(true), Ok(false), Err(())].iter().cloned();
    let v: Vec&lt;bool&gt; = results.collect()?;
    // Do things with v...
    Ok(true)
}</pre></div> <p>Here we have an iterator <code>results</code> over <code>Result&lt;bool, ()&gt;</code>. Hence, <code>results.collect()</code> can return any type implementing <code>FromIterator&lt;Result&lt;bool, ()&gt;&gt;</code>. On the other hand, the <code>?</code> operator can accept any type implementing <code>Try</code>.</p> <p>The author of this code probably wants <code>collect()</code> to return a <code>Result&lt;Vec&lt;bool&gt;, ()&gt;</code>, but the compiler can't be sure that there isn't another type <code>T</code> implementing both <code>Try</code> and <code>FromIterator&lt;Result&lt;bool, ()&gt;&gt;</code> in scope such that <code>T::Ok == Vec&lt;bool&gt;</code>. Hence, this code is ambiguous and an error is returned.</p> <p>To resolve this error, use a concrete type for the intermediate expression:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo() -&gt; Result&lt;bool, ()&gt; {
    let results = [Ok(true), Ok(false), Err(())].iter().cloned();
    let v = {
        let temp: Result&lt;Vec&lt;bool&gt;, ()&gt; = results.collect();
        temp?
    };
    // Do things with v...
    Ok(true)
}</pre></div> <p>Note that the type of <code>v</code> can now be inferred from the type of <code>temp</code>.</p>  <h3 id="E0297" class="section-header">E0297</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-23" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>Patterns used to bind names must be irrefutable. That is, they must guarantee that a name will be extracted in all cases. Instead of pattern matching the loop variable, consider using a <code>match</code> or <code>if let</code> inside the loop body. For instance:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let xs : Vec&lt;Option&lt;i32&gt;&gt; = vec![Some(1), None];

// This fails because `None` is not covered.
for Some(x) in xs {
    // ...
}</pre></div> <p>Match inside the loop instead:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let xs : Vec&lt;Option&lt;i32&gt;&gt; = vec![Some(1), None];

for item in xs {
    match item {
        Some(x) =&gt; {},
        None =&gt; {},
    }
}</pre></div> <p>Or use <code>if let</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let xs : Vec&lt;Option&lt;i32&gt;&gt; = vec![Some(1), None];

for item in xs {
    if let Some(x) = item {
        // ...
    }
}</pre></div>  <h3 id="E0301" class="section-header">E0301</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-24" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>Mutable borrows are not allowed in pattern guards, because matching cannot have side effects. Side effects could alter the matched object or the environment on which the match depends in such a way, that the match would not be exhaustive. For instance, the following would not match any arm if mutable borrows were allowed:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
match Some(()) {
    None =&gt; { },
    option if option.take().is_none() =&gt; {
        /* impossible, option is `Some` */
    },
    Some(_) =&gt; { } // When the previous match failed, the option became `None`.
}</pre></div>  <h3 id="E0302" class="section-header">E0302</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-25" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>Assignments are not allowed in pattern guards, because matching cannot have side effects. Side effects could alter the matched object or the environment on which the match depends in such a way, that the match would not be exhaustive. For instance, the following would not match any arm if assignments were allowed:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
match Some(()) {
    None =&gt; { },
    option if { option = None; false } =&gt; { },
    Some(_) =&gt; { } // When the previous match failed, the option became `None`.
}</pre></div>  <h3 id="E0303" class="section-header">E0303</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-26" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>Sub-bindings, e.g. <code>ref x @ Some(ref y)</code> are now allowed under <code>#![feature(bindings_after_at)]</code> and checked to make sure that memory safety is upheld.</p>  <p>In certain cases it is possible for sub-bindings to violate memory safety. Updates to the borrow checker in a future version of Rust may remove this restriction, but for now patterns must be rewritten without sub-bindings.</p> <p>Before:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
match Some("hi".to_string()) {
    ref op_string_ref @ Some(s) =&gt; {},
    None =&gt; {},
}</pre></div> <p>After:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
match Some("hi".to_string()) {
    Some(ref s) =&gt; {
        let op_string_ref = &amp;Some(s);
        // ...
    },
    None =&gt; {},
}</pre></div> <p>The <code>op_string_ref</code> binding has type <code>&amp;Option&lt;&amp;String&gt;</code> in both cases.</p> <p>See also <a href="https://github.com/rust-lang/rust/issues/14587">Issue 14587</a>.</p>  <h3 id="E0307" class="section-header">E0307</h3> <p>The <code>self</code> parameter in a method has an invalid "receiver type".</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo;
struct Bar;

trait Trait {
    fn foo(&amp;self);
}

impl Trait for Foo {
    fn foo(self: &amp;Bar) {}
}</pre></div> <p>Methods take a special first parameter, of which there are three variants: <code>self</code>, <code>&amp;self</code>, and <code>&amp;mut self</code>. These are syntactic sugar for <code>self: Self</code>, <code>self: &amp;Self</code>, and <code>self: &amp;mut Self</code> respectively.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Trait {
    fn foo(&amp;self);
//         ^^^^^ `self` here is a reference to the receiver object
}

impl Trait for Foo {
    fn foo(&amp;self) {}
//         ^^^^^ the receiver type is `&amp;Foo`
}</pre></div> <p>The type <code>Self</code> acts as an alias to the type of the current trait implementer, or "receiver type". Besides the already mentioned <code>Self</code>, <code>&amp;Self</code> and <code>&amp;mut Self</code> valid receiver types, the following are also valid: <code>self: Box&lt;Self&gt;</code>, <code>self: Rc&lt;Self&gt;</code>, <code>self: Arc&lt;Self&gt;</code>, and <code>self: Pin&lt;P&gt;</code> (where P is one of the previous types except <code>Self</code>). Note that <code>Self</code> can also be the underlying implementing type, like <code>Foo</code> in the following example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
impl Trait for Foo {
    fn foo(self: &amp;Foo) {}
}</pre></div> <p>This error will be emitted by the compiler when using an invalid receiver type, like in the following example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
impl Trait for Foo {
    fn foo(self: &amp;Bar) {}
}</pre></div> <p>The nightly feature <a href="https://doc.rust-lang.org/unstable-book/language-features/arbitrary-self-types.html">Arbitrary self types</a> extends the accepted set of receiver types to also include any type that can dereference to <code>Self</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(arbitrary_self_types)]

struct Foo;
struct Bar;

// Because you can dereference `Bar` into `Foo`...
impl std::ops::Deref for Bar {
    type Target = Foo;

    fn deref(&amp;self) -&gt; &amp;Foo {
        &amp;Foo
    }
}

impl Foo {
    fn foo(self: Bar) {}
//         ^^^^^^^^^ ...it can be used as the receiver type
}</pre></div>  <h3 id="E0308" class="section-header">E0308</h3> <p>Expected type did not match the received type.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let x: i32 = "I am not a number!";
//     ~~~   ~~~~~~~~~~~~~~~~~~~~
//      |             |
//      |    initializing expression;
//      |    compiler infers type `&amp;str`
//      |
//    type `i32` assigned to variable `x`</pre></div> <p>This error occurs when the compiler is unable to infer the concrete type of a variable. It can occur in several cases, the most common being a mismatch between two types: the type the author explicitly assigned, and the type the compiler inferred.</p>  <h3 id="E0309" class="section-header">E0309</h3> <p>A parameter type is missing an explicit lifetime bound and may not live long enough.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
// This won't compile because the applicable impl of
// `SomeTrait` (below) requires that `T: 'a`, but the struct does
// not have a matching where-clause.
struct Foo&lt;'a, T&gt; {
    foo: &lt;T as SomeTrait&lt;'a&gt;&gt;::Output,
}

trait SomeTrait&lt;'a&gt; {
    type Output;
}

impl&lt;'a, T&gt; SomeTrait&lt;'a&gt; for T
where
    T: 'a,
{
    type Output = u32;
}</pre></div> <p>The type definition contains some field whose type requires an outlives annotation. Outlives annotations (e.g., <code>T: 'a</code>) are used to guarantee that all the data in T is valid for at least the lifetime <code>'a</code>. This scenario most commonly arises when the type contains an associated type reference like <code>&lt;T as SomeTrait&lt;'a&gt;&gt;::Output</code>, as shown in the previous code.</p> <p>There, the where clause <code>T: 'a</code> that appears on the impl is not known to be satisfied on the struct. To make this example compile, you have to add a where-clause like <code>T: 'a</code> to the struct definition:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo&lt;'a, T&gt;
where
    T: 'a,
{
    foo: &lt;T as SomeTrait&lt;'a&gt;&gt;::Output
}

trait SomeTrait&lt;'a&gt; {
    type Output;
}

impl&lt;'a, T&gt; SomeTrait&lt;'a&gt; for T
where
    T: 'a,
{
    type Output = u32;
}</pre></div>  <h3 id="E0310" class="section-header">E0310</h3> <p>A parameter type is missing a lifetime constraint or has a lifetime that does not live long enough.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
// This won't compile because T is not constrained to the static lifetime
// the reference needs
struct Foo&lt;T&gt; {
    foo: &amp;'static T
}</pre></div> <p>Type parameters in type definitions have lifetimes associated with them that represent how long the data stored within them is guaranteed to live. This lifetime must be as long as the data needs to be alive, and missing the constraint that denotes this will cause this error.</p> <p>This will compile, because it has the constraint on the type parameter:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo&lt;T: 'static&gt; {
    foo: &amp;'static T
}</pre></div>   <h3 id="E0312" class="section-header">E0312</h3> <p>Reference's lifetime of borrowed content doesn't match the expected lifetime.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
pub fn opt_str&lt;'a&gt;(maybestr: &amp;'a Option&lt;String&gt;) -&gt; &amp;'static str {
    if maybestr.is_none() {
        "(none)"
    } else {
        let s: &amp;'a str = maybestr.as_ref().unwrap();
        s  // Invalid lifetime!
    }
}</pre></div> <p>To fix this error, either lessen the expected lifetime or find a way to not have to use this reference outside of its current scope (by running the code directly in the same block for example?):</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
// In this case, we can fix the issue by switching from "static" lifetime to 'a
pub fn opt_str&lt;'a&gt;(maybestr: &amp;'a Option&lt;String&gt;) -&gt; &amp;'a str {
    if maybestr.is_none() {
        "(none)"
    } else {
        let s: &amp;'a str = maybestr.as_ref().unwrap();
        s  // Ok!
    }
}</pre></div>      <h3 id="E0317" class="section-header">E0317</h3> <p>An <code>if</code> expression is missing an <code>else</code> block.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let x = 5;
let a = if x == 5 {
    1
};</pre></div> <p>This error occurs when an <code>if</code> expression without an <code>else</code> block is used in a context where a type other than <code>()</code> is expected. In the previous code example, the <code>let</code> expression was expecting a value but since there was no <code>else</code>, no value was returned.</p> <p>An <code>if</code> expression without an <code>else</code> block has the type <code>()</code>, so this is a type error. To resolve it, add an <code>else</code> block having the same type as the <code>if</code> block.</p> <p>So to fix the previous code example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x = 5;
let a = if x == 5 {
    1
} else {
    2
};</pre></div>   <h3 id="E0321" class="section-header">E0321</h3> <p>A cross-crate opt-out trait was implemented on something which wasn't a struct or enum type.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(optin_builtin_traits)]

struct Foo;

impl !Sync for Foo {}

unsafe impl Send for &amp;'static Foo {}
// error: cross-crate traits with a default impl, like `core::marker::Send`,
//        can only be implemented for a struct/enum type, not
//        `&amp;'static Foo`</pre></div> <p>Only structs and enums are permitted to impl Send, Sync, and other opt-out trait, and the struct or enum must be local to the current crate. So, for example, <code>unsafe impl Send for Rc&lt;Foo&gt;</code> is not allowed.</p>  <h3 id="E0322" class="section-header">E0322</h3> <p>The <code>Sized</code> trait was implemented explicitly.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo;

impl Sized for Foo {} // error!</pre></div> <p>The <code>Sized</code> trait is a special trait built-in to the compiler for types with a constant size known at compile-time. This trait is automatically implemented for types as needed by the compiler, and it is currently disallowed to explicitly implement it for a type.</p>  <h3 id="E0323" class="section-header">E0323</h3> <p>An associated const was implemented when another trait item was expected.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Foo {
    type N;
}

struct Bar;

impl Foo for Bar {
    const N : u32 = 0;
    // error: item `N` is an associated const, which doesn't match its
    //        trait `&lt;Bar as Foo&gt;`
}</pre></div> <p>Please verify that the associated const wasn't misspelled and the correct trait was implemented. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Bar;

trait Foo {
    type N;
}

impl Foo for Bar {
    type N = u32; // ok!
}</pre></div> <p>Or:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Bar;

trait Foo {
    const N : u32;
}

impl Foo for Bar {
    const N : u32 = 0; // ok!
}</pre></div>  <h3 id="E0324" class="section-header">E0324</h3> <p>A method was implemented when another trait item was expected.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Bar;

trait Foo {
    const N : u32;

    fn M();
}

impl Foo for Bar {
    fn N() {}
    // error: item `N` is an associated method, which doesn't match its
    //        trait `&lt;Bar as Foo&gt;`
}</pre></div> <p>To fix this error, please verify that the method name wasn't misspelled and verify that you are indeed implementing the correct trait items. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Bar;

trait Foo {
    const N : u32;

    fn M();
}

impl Foo for Bar {
    const N : u32 = 0;

    fn M() {} // ok!
}</pre></div>  <h3 id="E0325" class="section-header">E0325</h3> <p>An associated type was implemented when another trait item was expected.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Bar;

trait Foo {
    const N : u32;
}

impl Foo for Bar {
    type N = u32;
    // error: item `N` is an associated type, which doesn't match its
    //        trait `&lt;Bar as Foo&gt;`
}</pre></div> <p>Please verify that the associated type name wasn't misspelled and your implementation corresponds to the trait definition. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Bar;

trait Foo {
    type N;
}

impl Foo for Bar {
    type N = u32; // ok!
}</pre></div> <p>Or:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Bar;

trait Foo {
    const N : u32;
}

impl Foo for Bar {
    const N : u32 = 0; // ok!
}</pre></div>  <h3 id="E0326" class="section-header">E0326</h3> <p>An implementation of a trait doesn't match the type constraint.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Foo {
    const BAR: bool;
}

struct Bar;

impl Foo for Bar {
    const BAR: u32 = 5; // error, expected bool, found u32
}</pre></div> <p>The types of any associated constants in a trait implementation must match the types in the trait definition.</p>  <h3 id="E0328" class="section-header">E0328</h3> <p>The Unsize trait should not be implemented directly. All implementations of Unsize are provided automatically by the compiler.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(unsize)]

use std::marker::Unsize;

pub struct MyType;

impl&lt;T&gt; Unsize&lt;T&gt; for MyType {}</pre></div> <p>If you are defining your own smart pointer type and would like to enable conversion from a sized to an unsized type with the <a href="https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md">DST coercion system</a>, use <a href="std/ops/trait.coerceunsized"><code>CoerceUnsized</code></a> instead.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(coerce_unsized)]

use std::ops::CoerceUnsized;

pub struct MyType&lt;T: ?Sized&gt; {
    field_with_unsized_type: T,
}

impl&lt;T, U&gt; CoerceUnsized&lt;MyType&lt;U&gt;&gt; for MyType&lt;T&gt;
    where T: CoerceUnsized&lt;U&gt; {}</pre></div>  <h3 id="E0329" class="section-header">E0329</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-27" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>An attempt was made to access an associated constant through either a generic type parameter or <code>Self</code>. This is not supported yet. An example causing this error is shown below:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    const BAR: f64;
}

struct MyStruct;

impl Foo for MyStruct {
    const BAR: f64 = 0f64;
}

fn get_bar_bad&lt;F: Foo&gt;(t: F) -&gt; f64 {
    F::BAR
}</pre></div> <p>Currently, the value of <code>BAR</code> for a particular type can only be accessed through a concrete type, as shown below:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    const BAR: f64;
}

struct MyStruct;

impl Foo for MyStruct {
    const BAR: f64 = 0f64;
}

fn get_bar_good() -&gt; f64 {
    &lt;MyStruct as Foo&gt;::BAR
}</pre></div>  <h3 id="E0364" class="section-header">E0364</h3> <p>Private items cannot be publicly re-exported. This error indicates that you attempted to <code>pub use</code> a type or value that was not itself public.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
mod a {
    fn foo() {}

    mod a {
        pub use super::foo; // error!
    }
}</pre></div> <p>The solution to this problem is to ensure that the items that you are re-exporting are themselves marked with <code>pub</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
mod a {
    pub fn foo() {} // ok!

    mod a {
        pub use super::foo;
    }
}</pre></div> <p>See the <a href="reference/items/use-declarations">Use Declarations</a> section of the reference for more information on this topic.</p>  <h3 id="E0365" class="section-header">E0365</h3> <p>Private modules cannot be publicly re-exported. This error indicates that you attempted to <code>pub use</code> a module that was not itself public.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
mod foo {
    pub const X: u32 = 1;
}

pub use foo as foo2;

fn main() {}</pre></div> <p>The solution to this problem is to ensure that the module that you are re-exporting is itself marked with <code>pub</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
pub mod foo {
    pub const X: u32 = 1;
}

pub use foo as foo2;

fn main() {}</pre></div> <p>See the <a href="reference/items/use-declarations">Use Declarations</a> section of the reference for more information on this topic.</p>  <h3 id="E0366" class="section-header">E0366</h3> <p>An attempt was made to implement <code>Drop</code> on a concrete specialization of a generic type. An example is shown below:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo&lt;T&gt; {
    t: T
}

impl Drop for Foo&lt;u32&gt; {
    fn drop(&amp;mut self) {}
}</pre></div> <p>This code is not legal: it is not possible to specialize <code>Drop</code> to a subset of implementations of a generic type. One workaround for this is to wrap the generic type, as shown below:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo&lt;T&gt; {
    t: T
}

struct Bar {
    t: Foo&lt;u32&gt;
}

impl Drop for Bar {
    fn drop(&amp;mut self) {}
}</pre></div>  <h3 id="E0367" class="section-header">E0367</h3> <p>An attempt was made to implement <code>Drop</code> on a specialization of a generic type.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Foo {}

struct MyStruct&lt;T&gt; {
    t: T
}

impl&lt;T: Foo&gt; Drop for MyStruct&lt;T&gt; {
    fn drop(&amp;mut self) {}
}</pre></div> <p>This code is not legal: it is not possible to specialize <code>Drop</code> to a subset of implementations of a generic type. In order for this code to work, <code>MyStruct</code> must also require that <code>T</code> implements <code>Foo</code>. Alternatively, another option is to wrap the generic type in another that specializes appropriately:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Foo{}

struct MyStruct&lt;T&gt; {
    t: T
}

struct MyStructWrapper&lt;T: Foo&gt; {
    t: MyStruct&lt;T&gt;
}

impl &lt;T: Foo&gt; Drop for MyStructWrapper&lt;T&gt; {
    fn drop(&amp;mut self) {}
}</pre></div>  <h3 id="E0368" class="section-header">E0368</h3> <p>A binary assignment operator like <code>+=</code> or <code>^=</code> was applied to a type that doesn't support it.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let mut x = 12f32; // error: binary operation `&lt;&lt;` cannot be applied to
                   //        type `f32`

x &lt;&lt;= 2;</pre></div> <p>To fix this error, please check that this type implements this binary operation. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut x = 12u32; // the `u32` type does implement the `ShlAssign` trait

x &lt;&lt;= 2; // ok!</pre></div> <p>It is also possible to overload most operators for your own type by implementing the <code>[OP]Assign</code> traits from <code>std::ops</code>.</p> <p>Another problem you might be facing is this: suppose you've overloaded the <code>+</code> operator for some type <code>Foo</code> by implementing the <code>std::ops::Add</code> trait for <code>Foo</code>, but you find that using <code>+=</code> does not work, as in this example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
use std::ops::Add;

struct Foo(u32);

impl Add for Foo {
    type Output = Foo;

    fn add(self, rhs: Foo) -&gt; Foo {
        Foo(self.0 + rhs.0)
    }
}

fn main() {
    let mut x: Foo = Foo(5);
    x += Foo(7); // error, `+= cannot be applied to the type `Foo`
}</pre></div> <p>This is because <code>AddAssign</code> is not automatically implemented, so you need to manually implement it for your type.</p>  <h3 id="E0369" class="section-header">E0369</h3> <p>A binary operation was attempted on a type which doesn't support it.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let x = 12f32; // error: binary operation `&lt;&lt;` cannot be applied to
               //        type `f32`

x &lt;&lt; 2;</pre></div> <p>To fix this error, please check that this type implements this binary operation. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x = 12u32; // the `u32` type does implement it:
               // https://doc.rust-lang.org/stable/std/ops/trait.Shl.html

x &lt;&lt; 2; // ok!</pre></div> <p>It is also possible to overload most operators for your own type by implementing traits from <code>std::ops</code>.</p> <p>String concatenation appends the string on the right to the string on the left and may require reallocation. This requires ownership of the string on the left. If something should be added to a string literal, move the literal to the heap by allocating it with <code>to_owned()</code> like in <code>"Your text".to_owned()</code>.</p>  <h3 id="E0370" class="section-header">E0370</h3> <p>The maximum value of an enum was reached, so it cannot be automatically set in the next enum value.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[repr(i64)]
enum Foo {
    X = 0x7fffffffffffffff,
    Y, // error: enum discriminant overflowed on value after
       //        9223372036854775807: i64; set explicitly via
       //        Y = -9223372036854775808 if that is desired outcome
}</pre></div> <p>To fix this, please set manually the next enum value or put the enum variant with the maximum value at the end of the enum. Examples:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[repr(i64)]
enum Foo {
    X = 0x7fffffffffffffff,
    Y = 0, // ok!
}</pre></div> <p>Or:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[repr(i64)]
enum Foo {
    Y = 0, // ok!
    X = 0x7fffffffffffffff,
}</pre></div>  <h3 id="E0371" class="section-header">E0371</h3> <p>A trait was implemented on another which already automatically implemented it.</p> <p>Erroneous code examples:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Foo { fn foo(&amp;self) { } }
trait Bar: Foo { }
trait Baz: Bar { }

impl Bar for Baz { } // error, `Baz` implements `Bar` by definition
impl Foo for Baz { } // error, `Baz` implements `Bar` which implements `Foo`
impl Baz for Baz { } // error, `Baz` (trivially) implements `Baz`
impl Baz for Bar { } // Note: This is OK</pre></div> <p>When <code>Trait2</code> is a subtrait of <code>Trait1</code> (for example, when <code>Trait2</code> has a definition like <code>trait Trait2: Trait1 { ... }</code>), it is not allowed to implement <code>Trait1</code> for <code>Trait2</code>. This is because <code>Trait2</code> already implements <code>Trait1</code> by definition, so it is not useful to do this.</p>  <h3 id="E0373" class="section-header">E0373</h3> <p>A captured variable in a closure may not live long enough.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn foo() -&gt; Box&lt;Fn(u32) -&gt; u32&gt; {
    let x = 0u32;
    Box::new(|y| x + y)
}</pre></div> <p>This error occurs when an attempt is made to use data captured by a closure, when that data may no longer exist. It's most commonly seen when attempting to return a closure as shown in the previous code example.</p> <p>Notice that <code>x</code> is stack-allocated by <code>foo()</code>. By default, Rust captures closed-over data by reference. This means that once <code>foo()</code> returns, <code>x</code> no longer exists. An attempt to access <code>x</code> within the closure would thus be unsafe.</p> <p>Another situation where this might be encountered is when spawning threads:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn foo() {
    let x = 0u32;
    let y = 1u32;

    let thr = std::thread::spawn(|| {
        x + y
    });
}</pre></div> <p>Since our new thread runs in parallel, the stack frame containing <code>x</code> and <code>y</code> may well have disappeared by the time we try to use them. Even if we call <code>thr.join()</code> within foo (which blocks until <code>thr</code> has completed, ensuring the stack frame won't disappear), we will not succeed: the compiler cannot prove that this behavior is safe, and so won't let us do it.</p> <p>The solution to this problem is usually to switch to using a <code>move</code> closure. This approach moves (or copies, where possible) data into the closure, rather than taking references to it. For example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo() -&gt; Box&lt;Fn(u32) -&gt; u32&gt; {
    let x = 0u32;
    Box::new(move |y| x + y)
}</pre></div> <p>Now that the closure has its own copy of the data, there's no need to worry about safety.</p>  <h3 id="E0374" class="section-header">E0374</h3> <p><code>CoerceUnsized</code> was implemented on a struct which does not contain a field with an unsized type.</p> <p>Example of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(coerce_unsized)]
use std::ops::CoerceUnsized;

struct Foo&lt;T: ?Sized&gt; {
    a: i32,
}

// error: Struct `Foo` has no unsized fields that need `CoerceUnsized`.
impl&lt;T, U&gt; CoerceUnsized&lt;Foo&lt;U&gt;&gt; for Foo&lt;T&gt;
    where T: CoerceUnsized&lt;U&gt; {}</pre></div> <p>An <a href="book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait">unsized type</a> is any type where the compiler does not know the length or alignment of at compile time. Any struct containing an unsized type is also unsized.</p> <p><code>CoerceUnsized</code> is used to coerce one struct containing an unsized type into another struct containing a different unsized type. If the struct doesn't have any fields of unsized types then you don't need explicit coercion to get the types you want. To fix this you can either not try to implement <code>CoerceUnsized</code> or you can add a field that is unsized to the struct.</p> <p>Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(coerce_unsized)]
use std::ops::CoerceUnsized;

// We don't need to impl `CoerceUnsized` here.
struct Foo {
    a: i32,
}

// We add the unsized type field to the struct.
struct Bar&lt;T: ?Sized&gt; {
    a: i32,
    b: T,
}

// The struct has an unsized field so we can implement
// `CoerceUnsized` for it.
impl&lt;T, U&gt; CoerceUnsized&lt;Bar&lt;U&gt;&gt; for Bar&lt;T&gt;
    where T: CoerceUnsized&lt;U&gt; {}</pre></div> <p>Note that <code>CoerceUnsized</code> is mainly used by smart pointers like <code>Box</code>, <code>Rc</code> and <code>Arc</code> to be able to mark that they can coerce unsized types that they are pointing at.</p>  <h3 id="E0375" class="section-header">E0375</h3> <p><code>CoerceUnsized</code> was implemented on a struct which contains more than one field with an unsized type.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(coerce_unsized)]
use std::ops::CoerceUnsized;

struct Foo&lt;T: ?Sized, U: ?Sized&gt; {
    a: i32,
    b: T,
    c: U,
}

// error: Struct `Foo` has more than one unsized field.
impl&lt;T, U&gt; CoerceUnsized&lt;Foo&lt;U, T&gt;&gt; for Foo&lt;T, U&gt; {}</pre></div> <p>A struct with more than one field containing an unsized type cannot implement <code>CoerceUnsized</code>. This only occurs when you are trying to coerce one of the types in your struct to another type in the struct. In this case we try to impl <code>CoerceUnsized</code> from <code>T</code> to <code>U</code> which are both types that the struct takes. An <a href="book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait">unsized type</a> is any type that the compiler doesn't know the length or alignment of at compile time. Any struct containing an unsized type is also unsized.</p> <p><code>CoerceUnsized</code> only allows for coercion from a structure with a single unsized type field to another struct with a single unsized type field. In fact Rust only allows for a struct to have one unsized type in a struct and that unsized type must be the last field in the struct. So having two unsized types in a single struct is not allowed by the compiler. To fix this use only one field containing an unsized type in the struct and then use multiple structs to manage each unsized type field you need.</p> <p>Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(coerce_unsized)]
use std::ops::CoerceUnsized;

struct Foo&lt;T: ?Sized&gt; {
    a: i32,
    b: T,
}

impl &lt;T, U&gt; CoerceUnsized&lt;Foo&lt;U&gt;&gt; for Foo&lt;T&gt;
    where T: CoerceUnsized&lt;U&gt; {}

fn coerce_foo&lt;T: CoerceUnsized&lt;U&gt;, U&gt;(t: T) -&gt; Foo&lt;U&gt; {
    Foo { a: 12i32, b: t } // we use coercion to get the `Foo&lt;U&gt;` type we need
}</pre></div>  <h3 id="E0376" class="section-header">E0376</h3> <p><code>CoerceUnsized</code> was implemented on something that isn't a struct.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(coerce_unsized)]
use std::ops::CoerceUnsized;

struct Foo&lt;T: ?Sized&gt; {
    a: T,
}

// error: The type `U` is not a struct
impl&lt;T, U&gt; CoerceUnsized&lt;U&gt; for Foo&lt;T&gt; {}</pre></div> <p><code>CoerceUnsized</code> can only be implemented for a struct. Unsized types are already able to be coerced without an implementation of <code>CoerceUnsized</code> whereas a struct containing an unsized type needs to know the unsized type field it's containing is able to be coerced. An <a href="book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait">unsized type</a> is any type that the compiler doesn't know the length or alignment of at compile time. Any struct containing an unsized type is also unsized.</p> <p>The <code>CoerceUnsized</code> trait takes a struct type. Make sure the type you are providing to <code>CoerceUnsized</code> is a struct with only the last field containing an unsized type.</p> <p>Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(coerce_unsized)]
use std::ops::CoerceUnsized;

struct Foo&lt;T&gt; {
    a: T,
}

// The `Foo&lt;U&gt;` is a struct so `CoerceUnsized` can be implemented
impl&lt;T, U&gt; CoerceUnsized&lt;Foo&lt;U&gt;&gt; for Foo&lt;T&gt; where T: CoerceUnsized&lt;U&gt; {}</pre></div> <p>Note that in Rust, structs can only contain an unsized type if the field containing the unsized type is the last and only unsized type field in the struct.</p>   <h3 id="E0378" class="section-header">E0378</h3> <p>The <code>DispatchFromDyn</code> trait was implemented on something which is not a pointer or a newtype wrapper around a pointer.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(dispatch_from_dyn)]
use std::ops::DispatchFromDyn;

struct WrapperExtraField&lt;T&gt; {
    ptr: T,
    extra_stuff: i32,
}

impl&lt;T, U&gt; DispatchFromDyn&lt;WrapperExtraField&lt;U&gt;&gt; for WrapperExtraField&lt;T&gt;
where
    T: DispatchFromDyn&lt;U&gt;,
{}</pre></div> <p>The <code>DispatchFromDyn</code> trait currently can only be implemented for builtin pointer types and structs that are newtype wrappers around them — that is, the struct must have only one field (except for<code>PhantomData</code>), and that field must itself implement <code>DispatchFromDyn</code>.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(dispatch_from_dyn, unsize)]
use std::{
    marker::Unsize,
    ops::DispatchFromDyn,
};

struct Ptr&lt;T: ?Sized&gt;(*const T);

impl&lt;T: ?Sized, U: ?Sized&gt; DispatchFromDyn&lt;Ptr&lt;U&gt;&gt; for Ptr&lt;T&gt;
where
    T: Unsize&lt;U&gt;,
{}</pre></div> <p>Another example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(dispatch_from_dyn)]
use std::{
    ops::DispatchFromDyn,
    marker::PhantomData,
};

struct Wrapper&lt;T&gt; {
    ptr: T,
    _phantom: PhantomData&lt;()&gt;,
}

impl&lt;T, U&gt; DispatchFromDyn&lt;Wrapper&lt;U&gt;&gt; for Wrapper&lt;T&gt;
where
    T: DispatchFromDyn&lt;U&gt;,
{}</pre></div>  <h3 id="E0379" class="section-header">E0379</h3> <p>A trait method was declared const.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(const_fn)]

trait Foo {
    const fn bar() -&gt; u32; // error!
}</pre></div> <p>Trait methods cannot be declared <code>const</code> by design. For more information, see <a href="https://github.com/rust-lang/rfcs/pull/911">RFC 911</a>.</p>  <h3 id="E0380" class="section-header">E0380</h3> <p>An auto trait was declared with a method or an associated item.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
unsafe auto trait Trait {
    type Output; // error!
}</pre></div> <p>Auto traits cannot have methods or associated items. For more information see the <a href="https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md">opt-in builtin traits RFC</a>.</p>  <h3 id="E0381" class="section-header">E0381</h3> <p>It is not allowed to use or capture an uninitialized variable.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn main() {
    let x: i32;
    let y = x; // error, use of possibly-uninitialized variable
}</pre></div> <p>To fix this, ensure that any declared variables are initialized before being used. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn main() {
    let x: i32 = 0;
    let y = x; // ok!
}</pre></div>  <h3 id="E0382" class="section-header">E0382</h3> <p>A variable was used after its contents have been moved elsewhere.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct MyStruct { s: u32 }

fn main() {
    let mut x = MyStruct{ s: 5u32 };
    let y = x;
    x.s = 6;
    println!("{}", x.s);
}</pre></div> <p>Since <code>MyStruct</code> is a type that is not marked <code>Copy</code>, the data gets moved out of <code>x</code> when we set <code>y</code>. This is fundamental to Rust's ownership system: outside of workarounds like <code>Rc</code>, a value cannot be owned by more than one variable.</p> <p>Sometimes we don't need to move the value. Using a reference, we can let another function borrow the value without changing its ownership. In the example below, we don't actually have to move our string to <code>calculate_length</code>, we can give it a reference to it with <code>&amp;</code> instead.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&amp;s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}</pre></div> <p>A mutable reference can be created with <code>&amp;mut</code>.</p> <p>Sometimes we don't want a reference, but a duplicate. All types marked <code>Clone</code> can be duplicated by calling <code>.clone()</code>. Subsequent changes to a clone do not affect the original variable.</p> <p>Most types in the standard library are marked <code>Clone</code>. The example below demonstrates using <code>clone()</code> on a string. <code>s1</code> is first set to "many", and then copied to <code>s2</code>. Then the first character of <code>s1</code> is removed, without affecting <code>s2</code>. "any many" is printed to the console.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn main() {
    let mut s1 = String::from("many");
    let s2 = s1.clone();
    s1.remove(0);
    println!("{} {}", s1, s2);
}</pre></div> <p>If we control the definition of a type, we can implement <code>Clone</code> on it ourselves with <code>#[derive(Clone)]</code>.</p> <p>Some types have no ownership semantics at all and are trivial to duplicate. An example is <code>i32</code> and the other number types. We don't have to call <code>.clone()</code> to clone them, because they are marked <code>Copy</code> in addition to <code>Clone</code>. Implicit cloning is more convenient in this case. We can mark our own types <code>Copy</code> if all their members also are marked <code>Copy</code>.</p> <p>In the example below, we implement a <code>Point</code> type. Because it only stores two integers, we opt-out of ownership semantics with <code>Copy</code>. Then we can <code>let p2 = p1</code> without <code>p1</code> being moved.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[derive(Copy, Clone)]
struct Point { x: i32, y: i32 }

fn main() {
    let mut p1 = Point{ x: -1, y: 2 };
    let p2 = p1;
    p1.x = 1;
    println!("p1: {}, {}", p1.x, p1.y);
    println!("p2: {}, {}", p2.x, p2.y);
}</pre></div> <p>Alternatively, if we don't control the struct's definition, or mutable shared ownership is truly required, we can use <code>Rc</code> and <code>RefCell</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::cell::RefCell;
use std::rc::Rc;

struct MyStruct { s: u32 }

fn main() {
    let mut x = Rc::new(RefCell::new(MyStruct{ s: 5u32 }));
    let y = x.clone();
    x.borrow_mut().s = 6;
    println!("{}", x.borrow().s);
}</pre></div> <p>With this approach, x and y share ownership of the data via the <code>Rc</code> (reference count type). <code>RefCell</code> essentially performs runtime borrow checking: ensuring that at most one writer or multiple readers can access the data at any one time.</p> <p>If you wish to learn more about ownership in Rust, start with the <a href="book/ch04-00-understanding-ownership">Understanding Ownership</a> chapter in the Book.</p>  <h3 id="E0383" class="section-header">E0383</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-28" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>This error occurs when an attempt is made to partially reinitialize a structure that is currently uninitialized.</p> <p>For example, this can happen when a drop has taken place:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo {
    a: u32,
}
impl Drop for Foo {
    fn drop(&amp;mut self) { /* ... */ }
}

let mut x = Foo { a: 1 };
drop(x); // `x` is now uninitialized
x.a = 2; // error, partial reinitialization of uninitialized structure `t`</pre></div> <p>This error can be fixed by fully reinitializing the structure in question:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo {
    a: u32,
}
impl Drop for Foo {
    fn drop(&amp;mut self) { /* ... */ }
}

let mut x = Foo { a: 1 };
drop(x);
x = Foo { a: 2 };</pre></div>  <h3 id="E0384" class="section-header">E0384</h3> <p>An immutable variable was reassigned.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn main() {
    let x = 3;
    x = 5; // error, reassignment of immutable variable
}</pre></div> <p>By default, variables in Rust are immutable. To fix this error, add the keyword <code>mut</code> after the keyword <code>let</code> when declaring the variable. For example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn main() {
    let mut x = 3;
    x = 5;
}</pre></div>  <h3 id="E0386" class="section-header">E0386</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-29" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>This error occurs when an attempt is made to mutate the target of a mutable reference stored inside an immutable container.</p> <p>For example, this can happen when storing a <code>&amp;mut</code> inside an immutable <code>Box</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut x: i64 = 1;
let y: Box&lt;_&gt; = Box::new(&amp;mut x);
**y = 2; // error, cannot assign to data in an immutable container</pre></div> <p>This error can be fixed by making the container mutable:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut x: i64 = 1;
let mut y: Box&lt;_&gt; = Box::new(&amp;mut x);
**y = 2;</pre></div> <p>It can also be fixed by using a type with interior mutability, such as <code>Cell</code> or <code>RefCell</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::cell::Cell;

let x: i64 = 1;
let y: Box&lt;Cell&lt;_&gt;&gt; = Box::new(Cell::new(x));
y.set(2);</pre></div>  <h3 id="E0387" class="section-header">E0387</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-30" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>This error occurs when an attempt is made to mutate or mutably reference data that a closure has captured immutably.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
// Accepts a function or a closure that captures its environment immutably.
// Closures passed to foo will not be able to mutate their closed-over state.
fn foo&lt;F: Fn()&gt;(f: F) { }

// Attempts to mutate closed-over data. Error message reads:
// `cannot assign to data in a captured outer variable...`
fn mutable() {
    let mut x = 0u32;
    foo(|| x = 2);
}

// Attempts to take a mutable reference to closed-over data.  Error message
// reads: `cannot borrow data mutably in a captured outer variable...`
fn mut_addr() {
    let mut x = 0u32;
    foo(|| { let y = &amp;mut x; });
}</pre></div> <p>The problem here is that foo is defined as accepting a parameter of type <code>Fn</code>. Closures passed into foo will thus be inferred to be of type <code>Fn</code>, meaning that they capture their context immutably.</p> <p>If the definition of <code>foo</code> is under your control, the simplest solution is to capture the data mutably. This can be done by defining <code>foo</code> to take FnMut rather than Fn:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo&lt;F: FnMut()&gt;(f: F) { }</pre></div> <p>Alternatively, we can consider using the <code>Cell</code> and <code>RefCell</code> types to achieve interior mutability through a shared reference. Our example's <code>mutable</code> function could be redefined as below:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::cell::Cell;

fn foo&lt;F: Fn()&gt;(f: F) { }

fn mutable() {
    let x = Cell::new(0u32);
    foo(|| x.set(2));
}</pre></div> <p>You can read more in the API documentation for <a href="std/cell/index">Cell</a>.</p>  <h3 id="E0388" class="section-header">E0388</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-31" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <h3 id="E0389" class="section-header">E0389</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-32" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>An attempt was made to mutate data using a non-mutable reference. This commonly occurs when attempting to assign to a non-mutable reference of a mutable reference (<code>&amp;(&amp;mut T)</code>).</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct FancyNum {
    num: u8,
}

fn main() {
    let mut fancy = FancyNum{ num: 5 };
    let fancy_ref = &amp;(&amp;mut fancy);
    fancy_ref.num = 6; // error: cannot assign to data in a `&amp;` reference
    println!("{}", fancy_ref.num);
}</pre></div> <p>Here, <code>&amp;mut fancy</code> is mutable, but <code>&amp;(&amp;mut fancy)</code> is not. Creating an immutable reference to a value borrows it immutably. There can be multiple references of type <code>&amp;(&amp;mut T)</code> that point to the same value, so they must be immutable to prevent multiple mutable references to the same value.</p> <p>To fix this, either remove the outer reference:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct FancyNum {
    num: u8,
}

fn main() {
    let mut fancy = FancyNum{ num: 5 };

    let fancy_ref = &amp;mut fancy;
    // `fancy_ref` is now &amp;mut FancyNum, rather than &amp;(&amp;mut FancyNum)

    fancy_ref.num = 6; // No error!

    println!("{}", fancy_ref.num);
}</pre></div> <p>Or make the outer reference mutable:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct FancyNum {
    num: u8
}

fn main() {
    let mut fancy = FancyNum{ num: 5 };

    let fancy_ref = &amp;mut (&amp;mut fancy);
    // `fancy_ref` is now &amp;mut(&amp;mut FancyNum), rather than &amp;(&amp;mut FancyNum)

    fancy_ref.num = 6; // No error!

    println!("{}", fancy_ref.num);
}</pre></div>  <h3 id="E0390" class="section-header">E0390</h3> <p>A method was implemented on a primitive type.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo {
    x: i32
}

impl *mut Foo {}
// error: only a single inherent implementation marked with
//        `#[lang = "mut_ptr"]` is allowed for the `*mut T` primitive</pre></div> <p>This isn't allowed, but using a trait to implement a method is a good solution. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo {
    x: i32
}

trait Bar {
    fn bar();
}

impl Bar for *mut Foo {
    fn bar() {} // ok!
}</pre></div>  <h3 id="E0391" class="section-header">E0391</h3> <p>A type dependency cycle has been encountered.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait FirstTrait : SecondTrait {

}

trait SecondTrait : FirstTrait {

}</pre></div> <p>The previous example contains a circular dependency between two traits: <code>FirstTrait</code> depends on <code>SecondTrait</code> which itself depends on <code>FirstTrait</code>.</p>  <h3 id="E0392" class="section-header">E0392</h3> <p>A type or lifetime parameter has been declared but is not actually used.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
enum Foo&lt;T&gt; {
    Bar,
}</pre></div> <p>If the type parameter was included by mistake, this error can be fixed by simply removing the type parameter, as shown below:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
enum Foo {
    Bar,
}</pre></div> <p>Alternatively, if the type parameter was intentionally inserted, it must be used. A simple fix is shown below:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
enum Foo&lt;T&gt; {
    Bar(T),
}</pre></div> <p>This error may also commonly be found when working with unsafe code. For example, when using raw pointers one may wish to specify the lifetime for which the pointed-at data is valid. An initial attempt (below) causes this error:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo&lt;'a, T&gt; {
    x: *const T,
}</pre></div> <p>We want to express the constraint that Foo should not outlive <code>'a</code>, because the data pointed to by <code>T</code> is only valid for that lifetime. The problem is that there are no actual uses of <code>'a</code>. It's possible to work around this by adding a PhantomData type to the struct, using it to tell the compiler to act as if the struct contained a borrowed reference <code>&amp;'a T</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::marker::PhantomData;

struct Foo&lt;'a, T: 'a&gt; {
    x: *const T,
    phantom: PhantomData&lt;&amp;'a T&gt;
}</pre></div> <p><a href="std/marker/struct.phantomdata">PhantomData</a> can also be used to express information about unused type parameters.</p>  <h3 id="E0393" class="section-header">E0393</h3> <p>A type parameter which references <code>Self</code> in its default value was not specified.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait A&lt;T=Self&gt; {}

fn together_we_will_rule_the_galaxy(son: &amp;A) {}
// error: the type parameter `T` must be explicitly specified in an
//        object type because its default value `Self` references the
//        type `Self`</pre></div> <p>A trait object is defined over a single, fully-defined trait. With a regular default parameter, this parameter can just be substituted in. However, if the default parameter is <code>Self</code>, the trait changes for each concrete type; i.e. <code>i32</code> will be expected to implement <code>A&lt;i32&gt;</code>, <code>bool</code> will be expected to implement <code>A&lt;bool&gt;</code>, etc... These types will not share an implementation of a fully-defined trait; instead they share implementations of a trait with different parameters substituted in for each implementation. This is irreconcilable with what we need to make a trait object work, and is thus disallowed. Making the trait concrete by explicitly specifying the value of the defaulted parameter will fix this issue. Fixed example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait A&lt;T=Self&gt; {}

fn together_we_will_rule_the_galaxy(son: &amp;A&lt;i32&gt;) {} // Ok!</pre></div>  <h3 id="E0398" class="section-header">E0398</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-33" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>In Rust 1.3, the default object lifetime bounds are expected to change, as described in <a href="https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md">RFC 1156</a>. You are getting a warning because the compiler thinks it is possible that this change will cause a compilation error in your code. It is possible, though unlikely, that this is a false alarm.</p> <p>The heart of the change is that where <code>&amp;'a Box&lt;SomeTrait&gt;</code> used to default to <code>&amp;'a Box&lt;SomeTrait+'a&gt;</code>, it now defaults to <code>&amp;'a Box&lt;SomeTrait+'static&gt;</code> (here, <code>SomeTrait</code> is the name of some trait type). Note that the only types which are affected are references to boxes, like <code>&amp;Box&lt;SomeTrait&gt;</code> or <code>&amp;[Box&lt;SomeTrait&gt;]</code>. More common types like <code>&amp;SomeTrait</code> or <code>Box&lt;SomeTrait&gt;</code> are unaffected.</p> <p>To silence this warning, edit your code to use an explicit bound. Most of the time, this means that you will want to change the signature of a function that you are calling. For example, if the error is reported on a call like <code>foo(x)</code>, and <code>foo</code> is defined as follows:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo(arg: &amp;Box&lt;SomeTrait&gt;) { /* ... */ }</pre></div> <p>You might change it to:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo&lt;'a&gt;(arg: &amp;'a Box&lt;SomeTrait+'a&gt;) { /* ... */ }</pre></div> <p>This explicitly states that you expect the trait object <code>SomeTrait</code> to contain references (with a maximum lifetime of <code>'a</code>).</p>  <h3 id="E0399" class="section-header">E0399</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-34" class="section-header">Note: this error code is no longer emitted by the compiler</h4> <p>You implemented a trait, overriding one or more of its associated types but did not reimplement its default methods.</p> <p>Example of erroneous code:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(associated_type_defaults)]

pub trait Foo {
    type Assoc = u8;
    fn bar(&amp;self) {}
}

impl Foo for i32 {
    // error - the following trait items need to be reimplemented as
    //         `Assoc` was overridden: `bar`
    type Assoc = i32;
}</pre></div> <p>To fix this, add an implementation for each default method from the trait:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(associated_type_defaults)]

pub trait Foo {
    type Assoc = u8;
    fn bar(&amp;self) {}
}

impl Foo for i32 {
    type Assoc = i32;
    fn bar(&amp;self) {} // ok!
}</pre></div>  <h3 id="E0401" class="section-header">E0401</h3> <p>Inner items do not inherit type or const parameters from the functions they are embedded in.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn foo&lt;T&gt;(x: T) {
    fn bar(y: T) { // T is defined in the "outer" function
        // ..
    }
    bar(x);
}</pre></div> <p>Nor will this:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn foo&lt;T&gt;(x: T) {
    type MaybeT = Option&lt;T&gt;;
    // ...
}</pre></div> <p>Or this:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn foo&lt;T&gt;(x: T) {
    struct Foo {
        x: T,
    }
    // ...
}</pre></div> <p>Items inside functions are basically just like top-level items, except that they can only be used from the function they are in.</p> <p>There are a couple of solutions for this.</p> <p>If the item is a function, you may use a closure:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo&lt;T&gt;(x: T) {
    let bar = |y: T| { // explicit type annotation may not be necessary
        // ..
    };
    bar(x);
}</pre></div> <p>For a generic item, you can copy over the parameters:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo&lt;T&gt;(x: T) {
    fn bar&lt;T&gt;(y: T) {
        // ..
    }
    bar(x);
}</pre></div> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo&lt;T&gt;(x: T) {
    type MaybeT&lt;T&gt; = Option&lt;T&gt;;
}</pre></div> <p>Be sure to copy over any bounds as well:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo&lt;T: Copy&gt;(x: T) {
    fn bar&lt;T: Copy&gt;(y: T) {
        // ..
    }
    bar(x);
}</pre></div> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo&lt;T: Copy&gt;(x: T) {
    struct Foo&lt;T: Copy&gt; {
        x: T,
    }
}</pre></div> <p>This may require additional type hints in the function body.</p> <p>In case the item is a function inside an <code>impl</code>, defining a private helper function might be easier:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
impl&lt;T&gt; Foo&lt;T&gt; {
    pub fn foo(&amp;self, x: T) {
        self.bar(x);
    }

    fn bar(&amp;self, y: T) {
        // ..
    }
}</pre></div> <p>For default impls in traits, the private helper solution won't work, however closures or copying the parameters should still work.</p>  <h3 id="E0403" class="section-header">E0403</h3> <p>Some type parameters have the same name.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn f&lt;T, T&gt;(s: T, u: T) {} // error: the name `T` is already used for a generic
                          //        parameter in this item's generic parameters</pre></div> <p>Please verify that none of the type parameters are misspelled, and rename any clashing parameters. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn f&lt;T, Y&gt;(s: T, u: Y) {} // ok!</pre></div> <p>Type parameters in an associated item also cannot shadow parameters from the containing item:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Foo&lt;T&gt; {
    fn do_something(&amp;self) -&gt; T;
    fn do_something_else&lt;T: Clone&gt;(&amp;self, bar: T);
}</pre></div>  <h3 id="E0404" class="section-header">E0404</h3> <p>A type that is not a trait was used in a trait position, such as a bound or <code>impl</code>.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo;
struct Bar;

impl Foo for Bar {} // error: `Foo` is not a trait</pre></div> <p>Another erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo;

fn bar&lt;T: Foo&gt;(t: T) {} // error: `Foo` is not a trait</pre></div> <p>Please verify that the trait's name was not misspelled or that the right identifier was used. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    // some functions
}
struct Bar;

impl Foo for Bar { // ok!
    // functions implementation
}</pre></div> <p>or:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    // some functions
}

fn bar&lt;T: Foo&gt;(t: T) {} // ok!</pre></div>  <h3 id="E0405" class="section-header">E0405</h3> <p>The code refers to a trait that is not in scope.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo;

impl SomeTrait for Foo {} // error: trait `SomeTrait` is not in scope</pre></div> <p>Please verify that the name of the trait wasn't misspelled and ensure that it was imported. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
// solution 1:
use some_file::SomeTrait;

// solution 2:
trait SomeTrait {
    // some functions
}

struct Foo;

impl SomeTrait for Foo { // ok!
    // implements functions
}</pre></div>  <h3 id="E0407" class="section-header">E0407</h3> <p>A definition of a method not in the implemented trait was given in a trait implementation.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Foo {
    fn a();
}

struct Bar;

impl Foo for Bar {
    fn a() {}
    fn b() {} // error: method `b` is not a member of trait `Foo`
}</pre></div> <p>Please verify you didn't misspell the method name and you used the correct trait. First example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    fn a();
    fn b();
}

struct Bar;

impl Foo for Bar {
    fn a() {}
    fn b() {} // ok!
}</pre></div> <p>Second example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    fn a();
}

struct Bar;

impl Foo for Bar {
    fn a() {}
}

impl Bar {
    fn b() {}
}</pre></div>  <h3 id="E0408" class="section-header">E0408</h3> <p>An "or" pattern was used where the variable bindings are not consistently bound across patterns.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
match x {
    Some(y) | None =&gt; { /* use y */ } // error: variable `y` from pattern #1 is
                                      //        not bound in pattern #2
    _ =&gt; ()
}</pre></div> <p>Here, <code>y</code> is bound to the contents of the <code>Some</code> and can be used within the block corresponding to the match arm. However, in case <code>x</code> is <code>None</code>, we have not specified what <code>y</code> is, and the block will use a nonexistent variable.</p> <p>To fix this error, either split into multiple match arms:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x = Some(1);
match x {
    Some(y) =&gt; { /* use y */ }
    None =&gt; { /* ... */ }
}</pre></div> <p>or, bind the variable to a field of the same type in all sub-patterns of the or pattern:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x = (0, 2);
match x {
    (0, y) | (y, 0) =&gt; { /* use y */}
    _ =&gt; {}
}</pre></div> <p>In this example, if <code>x</code> matches the pattern <code>(0, _)</code>, the second field is set to <code>y</code>. If it matches <code>(_, 0)</code>, the first field is set to <code>y</code>; so in all cases <code>y</code> is set to some value.</p>  <h3 id="E0409" class="section-header">E0409</h3> <p>An "or" pattern was used where the variable bindings are not consistently bound across patterns.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let x = (0, 2);
match x {
    (0, ref y) | (y, 0) =&gt; { /* use y */} // error: variable `y` is bound with
                                          //        different mode in pattern #2
                                          //        than in pattern #1
    _ =&gt; ()
}</pre></div> <p>Here, <code>y</code> is bound by-value in one case and by-reference in the other.</p> <p>To fix this error, just use the same mode in both cases. Generally using <code>ref</code> or <code>ref mut</code> where not already used will fix this:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x = (0, 2);
match x {
    (0, ref y) | (ref y, 0) =&gt; { /* use y */}
    _ =&gt; ()
}</pre></div> <p>Alternatively, split the pattern:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x = (0, 2);
match x {
    (y, 0) =&gt; { /* use y */ }
    (0, ref y) =&gt; { /* use y */}
    _ =&gt; ()
}</pre></div>  <h3 id="E0411" class="section-header">E0411</h3> <p>The <code>Self</code> keyword was used outside an impl, trait, or type definition.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
&lt;Self&gt;::foo; // error: use of `Self` outside of an impl, trait, or type
             // definition</pre></div> <p>The <code>Self</code> keyword represents the current type, which explains why it can only be used inside an impl, trait, or type definition. It gives access to the associated items of a type:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    type Bar;
}

trait Baz : Foo {
    fn bar() -&gt; Self::Bar; // like this
}</pre></div> <p>However, be careful when two types have a common associated type:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Foo {
    type Bar;
}

trait Foo2 {
    type Bar;
}

trait Baz : Foo + Foo2 {
    fn bar() -&gt; Self::Bar;
    // error: ambiguous associated type `Bar` in bounds of `Self`
}</pre></div> <p>This problem can be solved by specifying from which trait we want to use the <code>Bar</code> type:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    type Bar;
}

trait Foo2 {
    type Bar;
}

trait Baz : Foo + Foo2 {
    fn bar() -&gt; &lt;Self as Foo&gt;::Bar; // ok!
}</pre></div>  <h3 id="E0412" class="section-header">E0412</h3> <p>A used type name is not in scope.</p> <p>Erroneous code examples:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
impl Something {} // error: type name `Something` is not in scope

// or:

trait Foo {
    fn bar(N); // error: type name `N` is not in scope
}

// or:

fn foo(x: T) {} // type name `T` is not in scope</pre></div> <p>To fix this error, please verify you didn't misspell the type name, you did declare it or imported it into the scope. Examples:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Something;

impl Something {} // ok!

// or:

trait Foo {
    type N;

    fn bar(_: Self::N); // ok!
}

// or:

fn foo&lt;T&gt;(x: T) {} // ok!</pre></div> <p>Another case that causes this error is when a type is imported into a parent module. To fix this, you can follow the suggestion and use File directly or <code>use super::File;</code> which will import the types from the parent namespace. An example that causes this error is below:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
use std::fs::File;

mod foo {
    fn some_function(f: File) {}
}</pre></div> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::fs::File;

mod foo {
    // either
    use super::File;
    // or
    // use std::fs::File;
    fn foo(f: File) {}
}</pre></div>  <h3 id="E0415" class="section-header">E0415</h3> <p>More than one function parameter have the same name.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn foo(f: i32, f: i32) {} // error: identifier `f` is bound more than
                          //        once in this parameter list</pre></div> <p>Please verify you didn't misspell parameters' name. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo(f: i32, g: i32) {} // ok!</pre></div>  <h3 id="E0416" class="section-header">E0416</h3> <p>An identifier is bound more than once in a pattern.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
match (1, 2) {
    (x, x) =&gt; {} // error: identifier `x` is bound more than once in the
                 //        same pattern
}</pre></div> <p>Please verify you didn't misspell identifiers' name. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
match (1, 2) {
    (x, y) =&gt; {} // ok!
}</pre></div> <p>Or maybe did you mean to unify? Consider using a guard:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
match (A, B, C) {
    (x, x2, see) if x == x2 =&gt; { /* A and B are equal, do one thing */ }
    (y, z, see) =&gt; { /* A and B unequal; do another thing */ }
}</pre></div>  <h3 id="E0422" class="section-header">E0422</h3> <p>An identifier that is neither defined nor a struct was used.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn main () {
    let x = Foo { x: 1, y: 2 };
}</pre></div> <p>In this case, <code>Foo</code> is undefined, so it inherently isn't anything, and definitely not a struct.</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn main () {
    let foo = 1;
    let x = foo { x: 1, y: 2 };
}</pre></div> <p>In this case, <code>foo</code> is defined, but is not a struct, so Rust can't use it as one.</p>  <h3 id="E0423" class="section-header">E0423</h3> <p>An identifier was used like a function name or a value was expected and the identifier exists but it belongs to a different namespace.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo { a: bool };

let f = Foo();
// error: expected function, tuple struct or tuple variant, found `Foo`
// `Foo` is a struct name, but this expression uses it like a function name</pre></div> <p>Please verify you didn't misspell the name of what you actually wanted to use here. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn Foo() -&gt; u32 { 0 }

let f = Foo(); // ok!</pre></div> <p>It is common to forget the trailing <code>!</code> on macro invocations, which would also yield this error:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
println("");
// error: expected function, tuple struct or tuple variant,
// found macro `println`
// did you mean `println!(...)`? (notice the trailing `!`)</pre></div> <p>Another case where this error is emitted is when a value is expected, but something else is found:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
pub mod a {
    pub const I: i32 = 1;
}

fn h1() -&gt; i32 {
    a.I
    //~^ ERROR expected value, found module `a`
    // did you mean `a::I`?
}</pre></div>  <h3 id="E0424" class="section-header">E0424</h3> <p>The <code>self</code> keyword was used inside of an associated function without a "<code>self</code> receiver" parameter.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo;

impl Foo {
    // `bar` is a method, because it has a receiver parameter.
    fn bar(&amp;self) {}

    // `foo` is not a method, because it has no receiver parameter.
    fn foo() {
        self.bar(); // error: `self` value is a keyword only available in
                    //        methods with a `self` parameter
    }
}</pre></div> <p>The <code>self</code> keyword can only be used inside methods, which are associated functions (functions defined inside of a <code>trait</code> or <code>impl</code> block) that have a <code>self</code> receiver as its first parameter, like <code>self</code>, <code>&amp;self</code>, <code>&amp;mut self</code> or <code>self: &amp;mut Pin&lt;Self&gt;</code> (this last one is an example of an <a href="https://github.com/rust-lang/rust/issues/44874">"abitrary <code>self</code> type"</a>).</p> <p>Check if the associated function's parameter list should have contained a <code>self</code> receiver for it to be a method, and add it if so. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo;

impl Foo {
    fn bar(&amp;self) {}

    fn foo(self) { // `foo` is now a method.
        self.bar(); // ok!
    }
}</pre></div>  <h3 id="E0425" class="section-header">E0425</h3> <p>An unresolved name was used.</p> <p>Erroneous code examples:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
something_that_doesnt_exist::foo;
// error: unresolved name `something_that_doesnt_exist::foo`

// or:

trait Foo {
    fn bar() {
        Self; // error: unresolved name `Self`
    }
}

// or:

let x = unknown_variable;  // error: unresolved name `unknown_variable`</pre></div> <p>Please verify that the name wasn't misspelled and ensure that the identifier being referred to is valid for the given situation. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
enum something_that_does_exist {
    Foo,
}</pre></div> <p>Or:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
mod something_that_does_exist {
    pub static foo : i32 = 0i32;
}

something_that_does_exist::foo; // ok!</pre></div> <p>Or:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let unknown_variable = 12u32;
let x = unknown_variable; // ok!</pre></div> <p>If the item is not defined in the current module, it must be imported using a <code>use</code> statement, like so:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use foo::bar;
bar();</pre></div> <p>If the item you are importing is not defined in some super-module of the current module, then it must also be declared as public (e.g., <code>pub fn</code>).</p>  <h3 id="E0426" class="section-header">E0426</h3> <p>An undeclared label was used.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
loop {
    break 'a; // error: use of undeclared label `'a`
}</pre></div> <p>Please verify you spelled or declared the label correctly. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
'a: loop {
    break 'a; // ok!
}</pre></div>  <h3 id="E0428" class="section-header">E0428</h3> <p>A type or module has been defined more than once.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Bar;
struct Bar; // error: duplicate definition of value `Bar`</pre></div> <p>Please verify you didn't misspell the type/module's name or remove/rename the duplicated one. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Bar;
struct Bar2; // ok!</pre></div>  <h3 id="E0429" class="section-header">E0429</h3> <p>The <code>self</code> keyword cannot appear alone as the last segment in a <code>use</code> declaration.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
use std::fmt::self; // error: `self` imports are only allowed within a { } list</pre></div> <p>To use a namespace itself in addition to some of its members, <code>self</code> may appear as part of a brace-enclosed list of imports:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::fmt::{self, Debug};</pre></div> <p>If you only want to import the namespace, do so directly:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::fmt;</pre></div>  <h3 id="E0430" class="section-header">E0430</h3> <p>The <code>self</code> import appears more than once in the list.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
use something::{self, self}; // error: `self` import can only appear once in
                             //        the list</pre></div> <p>Please verify you didn't misspell the import name or remove the duplicated <code>self</code> import. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use something::{self}; // ok!</pre></div>  <h3 id="E0431" class="section-header">E0431</h3> <p>An invalid <code>self</code> import was made.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
use {self}; // error: `self` import can only appear in an import list with a
            //        non-empty prefix</pre></div> <p>You cannot import the current module into itself, please remove this import or verify you didn't misspell it.</p>  <h3 id="E0432" class="section-header">E0432</h3> <p>An import was unresolved.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
use something::Foo; // error: unresolved import `something::Foo`.</pre></div> <p>In Rust 2015, paths in <code>use</code> statements are relative to the crate root. To import items relative to the current and parent modules, use the <code>self::</code> and <code>super::</code> prefixes, respectively.</p> <p>In Rust 2018, paths in <code>use</code> statements are relative to the current module unless they begin with the name of a crate or a literal <code>crate::</code>, in which case they start from the crate root. As in Rust 2015 code, the <code>self::</code> and <code>super::</code> prefixes refer to the current and parent modules respectively.</p> <p>Also verify that you didn't misspell the import name and that the import exists in the module from where you tried to import it. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use self::something::Foo; // Ok.

mod something {
    pub struct Foo;
}</pre></div> <p>If you tried to use a module from an external crate and are using Rust 2015, you may have missed the <code>extern crate</code> declaration (which is usually placed in the crate root):</p> <div class="information">ⓘThis code runs with edition 2015</div>
<div class="example-wrap"><pre class="rust rust-example-rendered edition " data-language="rust">
extern crate core; // Required to use the `core` crate in Rust 2015.

use core::any;</pre></div> <p>In Rust 2018 the <code>extern crate</code> declaration is not required and you can instead just <code>use</code> it:</p> <div class="information">ⓘThis code runs with edition 2018</div>
<div class="example-wrap"><pre class="rust rust-example-rendered edition " data-language="rust">
use core::any; // No extern crate required in Rust 2018.</pre></div>  <h3 id="E0433" class="section-header">E0433</h3> <p>An undeclared type or module was used.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let map = HashMap::new();
// error: failed to resolve: use of undeclared type or module `HashMap`</pre></div> <p>Please verify you didn't misspell the type/module's name or that you didn't forget to import it:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::HashMap; // HashMap has been imported.
let map: HashMap&lt;u32, u32&gt; = HashMap::new(); // So it can be used!</pre></div>  <h3 id="E0434" class="section-header">E0434</h3> <p>A variable used inside an inner function comes from a dynamic environment.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn foo() {
    let y = 5;
    fn bar() -&gt; u32 {
        y // error: can't capture dynamic environment in a fn item; use the
          //        || { ... } closure form instead.
    }
}</pre></div> <p>Inner functions do not have access to their containing environment. To fix this error, you can replace the function with a closure:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo() {
    let y = 5;
    let bar = || {
        y
    };
}</pre></div> <p>Or replace the captured variable with a constant or a static item:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo() {
    static mut X: u32 = 4;
    const Y: u32 = 5;
    fn bar() -&gt; u32 {
        unsafe {
            X = 3;
        }
        Y
    }
}</pre></div>  <h3 id="E0435" class="section-header">E0435</h3> <p>A non-constant value was used in a constant expression.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let foo = 42;
let a: [u8; foo]; // error: attempt to use a non-constant value in a constant</pre></div> <p>To fix this error, please replace the value with a constant. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let a: [u8; 42]; // ok!</pre></div> <p>Or:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
const FOO: usize = 42;
let a: [u8; FOO]; // ok!</pre></div>  <h3 id="E0436" class="section-header">E0436</h3> <p>The functional record update syntax was used on something other than a struct.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
enum PublicationFrequency {
    Weekly,
    SemiMonthly { days: (u8, u8), annual_special: bool },
}

fn one_up_competitor(competitor_frequency: PublicationFrequency)
                     -&gt; PublicationFrequency {
    match competitor_frequency {
        PublicationFrequency::Weekly =&gt; PublicationFrequency::SemiMonthly {
            days: (1, 15), annual_special: false
        },
        c @ PublicationFrequency::SemiMonthly{ .. } =&gt;
            PublicationFrequency::SemiMonthly {
                annual_special: true, ..c // error: functional record update
                                          //        syntax requires a struct
        }
    }
}</pre></div> <p>The functional record update syntax is only allowed for structs (struct-like enum variants don't qualify, for example). To fix the previous code, rewrite the expression without functional record update syntax:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
enum PublicationFrequency {
    Weekly,
    SemiMonthly { days: (u8, u8), annual_special: bool },
}

fn one_up_competitor(competitor_frequency: PublicationFrequency)
                     -&gt; PublicationFrequency {
    match competitor_frequency {
        PublicationFrequency::Weekly =&gt; PublicationFrequency::SemiMonthly {
            days: (1, 15), annual_special: false
        },
        PublicationFrequency::SemiMonthly{ days, .. } =&gt;
            PublicationFrequency::SemiMonthly {
                days, annual_special: true // ok!
        }
    }
}</pre></div>  <h3 id="E0437" class="section-header">E0437</h3> <p>An associated type whose name does not match any of the associated types in the trait was used when implementing the trait.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Foo {}

impl Foo for i32 {
    type Bar = bool;
}</pre></div> <p>Trait implementations can only implement associated types that are members of the trait in question.</p> <p>The solution to this problem is to remove the extraneous associated type:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Foo {}

impl Foo for i32 {}</pre></div>  <h3 id="E0438" class="section-header">E0438</h3> <p>An associated constant whose name does not match any of the associated constants in the trait was used when implementing the trait.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Foo {}

impl Foo for i32 {
    const BAR: bool = true;
}</pre></div> <p>Trait implementations can only implement associated constants that are members of the trait in question.</p> <p>The solution to this problem is to remove the extraneous associated constant:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Foo {}

impl Foo for i32 {}</pre></div>  <h3 id="E0439" class="section-header">E0439</h3> <p>The length of the platform-intrinsic function <code>simd_shuffle</code> wasn't specified.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(platform_intrinsics)]

extern "platform-intrinsic" {
    fn simd_shuffle&lt;A,B&gt;(a: A, b: A, c: [u32; 8]) -&gt; B;
    // error: invalid `simd_shuffle`, needs length: `simd_shuffle`
}</pre></div> <p>The <code>simd_shuffle</code> function needs the length of the array passed as last parameter in its name. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(platform_intrinsics)]

extern "platform-intrinsic" {
    fn simd_shuffle8&lt;A,B&gt;(a: A, b: A, c: [u32; 8]) -&gt; B;
}</pre></div>  <h3 id="E0445" class="section-header">E0445</h3> <p>A private trait was used on a public type parameter bound.</p> <p>Erroneous code examples:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![deny(private_in_public)]

trait Foo {
    fn dummy(&amp;self) { }
}

pub trait Bar : Foo {} // error: private trait in public interface
pub struct Bar2&lt;T: Foo&gt;(pub T); // same error
pub fn foo&lt;T: Foo&gt; (t: T) {} // same error

fn main() {}</pre></div> <p>To solve this error, please ensure that the trait is also public. The trait can be made inaccessible if necessary by placing it into a private inner module, but it still has to be marked with <code>pub</code>. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
pub trait Foo { // we set the Foo trait public
    fn dummy(&amp;self) { }
}

pub trait Bar : Foo {} // ok!
pub struct Bar2&lt;T: Foo&gt;(pub T); // ok!
pub fn foo&lt;T: Foo&gt; (t: T) {} // ok!

fn main() {}</pre></div>  <h3 id="E0446" class="section-header">E0446</h3> <p>A private type was used in a public type signature.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![deny(private_in_public)]
struct Bar(u32);

mod foo {
    use crate::Bar;
    pub fn bar() -&gt; Bar { // error: private type in public interface
        Bar(0)
    }
}

fn main() {}</pre></div> <p>There are two ways to solve this error. The first is to make the public type signature only public to a module that also has access to the private type. This is done by using pub(crate) or pub(in crate::my_mod::etc) Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Bar(u32);

mod foo {
    use crate::Bar;
    pub(crate) fn bar() -&gt; Bar { // only public to crate root
        Bar(0)
    }
}

fn main() {}</pre></div> <p>The other way to solve this error is to make the private type public. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
pub struct Bar(u32); // we set the Bar type public
mod foo {
    use crate::Bar;
    pub fn bar() -&gt; Bar { // ok!
        Bar(0)
    }
}

fn main() {}</pre></div>  <h3 id="E0447" class="section-header">E0447</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-35" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>The <code>pub</code> keyword was used inside a function.</p> <p>Erroneous code example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo() {
    pub struct Bar; // error: visibility has no effect inside functions
}</pre></div> <p>Since we cannot access items defined inside a function, the visibility of its items does not impact outer code. So using the <code>pub</code> keyword in this context is invalid.</p>  <h3 id="E0448" class="section-header">E0448</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-36" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>The <code>pub</code> keyword was used inside a public enum.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
pub enum Foo {
    pub Bar, // error: unnecessary `pub` visibility
}</pre></div> <p>Since the enum is already public, adding <code>pub</code> on one its elements is unnecessary. Example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
enum Foo {
    pub Bar, // not ok!
}</pre></div> <p>This is the correct syntax:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
pub enum Foo {
    Bar, // ok!
}</pre></div>  <h3 id="E0449" class="section-header">E0449</h3> <p>A visibility qualifier was used when it was unnecessary.</p> <p>Erroneous code examples:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Bar;

trait Foo {
    fn foo();
}

pub impl Bar {} // error: unnecessary visibility qualifier

pub impl Foo for Bar { // error: unnecessary visibility qualifier
    pub fn foo() {} // error: unnecessary visibility qualifier
}</pre></div> <p>To fix this error, please remove the visibility qualifier when it is not required. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Bar;

trait Foo {
    fn foo();
}

// Directly implemented methods share the visibility of the type itself,
// so `pub` is unnecessary here
impl Bar {}

// Trait methods share the visibility of the trait, so `pub` is
// unnecessary in either case
impl Foo for Bar {
    fn foo() {}
}</pre></div>  <h3 id="E0451" class="section-header">E0451</h3> <p>A struct constructor with private fields was invoked.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
mod Bar {
    pub struct Foo {
        pub a: isize,
        b: isize,
    }
}

let f = Bar::Foo{ a: 0, b: 0 }; // error: field `b` of struct `Bar::Foo`
                                //        is private</pre></div> <p>To fix this error, please ensure that all the fields of the struct are public, or implement a function for easy instantiation. Examples:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
mod Bar {
    pub struct Foo {
        pub a: isize,
        pub b: isize, // we set `b` field public
    }
}

let f = Bar::Foo{ a: 0, b: 0 }; // ok!</pre></div> <p>Or:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
mod Bar {
    pub struct Foo {
        pub a: isize,
        b: isize, // still private
    }

    impl Foo {
        pub fn new() -&gt; Foo { // we create a method to instantiate `Foo`
            Foo { a: 0, b: 0 }
        }
    }
}

let f = Bar::Foo::new(); // ok!</pre></div>  <h3 id="E0452" class="section-header">E0452</h3> <p>An invalid lint attribute has been given.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![allow(foo = "")] // error: malformed lint attribute</pre></div> <p>Lint attributes only accept a list of identifiers (where each identifier is a lint name). Ensure the attribute is of this form:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![allow(foo)] // ok!
// or:
#![allow(foo, foo2)] // ok!</pre></div>  <h3 id="E0453" class="section-header">E0453</h3> <p>A lint check attribute was overruled by a <code>forbid</code> directive set as an attribute on an enclosing scope, or on the command line with the <code>-F</code> option.</p> <p>Example of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![forbid(non_snake_case)]

#[allow(non_snake_case)]
fn main() {
    let MyNumber = 2; // error: allow(non_snake_case) overruled by outer
                      //        forbid(non_snake_case)
}</pre></div> <p>The <code>forbid</code> lint setting, like <code>deny</code>, turns the corresponding compiler warning into a hard error. Unlike <code>deny</code>, <code>forbid</code> prevents itself from being overridden by inner attributes.</p> <p>If you're sure you want to override the lint check, you can change <code>forbid</code> to <code>deny</code> (or use <code>-D</code> instead of <code>-F</code> if the <code>forbid</code> setting was given as a command-line option) to allow the inner lint check attribute:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![deny(non_snake_case)]

#[allow(non_snake_case)]
fn main() {
    let MyNumber = 2; // ok!
}</pre></div> <p>Otherwise, edit the code to pass the lint check, and remove the overruled attribute:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![forbid(non_snake_case)]

fn main() {
    let my_number = 2;
}</pre></div>  <h3 id="E0454" class="section-header">E0454</h3> <p>A link name was given with an empty name.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[link(name = "")] extern {}
// error: `#[link(name = "")]` given with empty name</pre></div> <p>The rust compiler cannot link to an external library if you don't give it its name. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[link(name = "some_lib")] extern {} // ok!</pre></div>  <h3 id="E0455" class="section-header">E0455</h3> <p>Linking with <code>kind=framework</code> is only supported when targeting macOS, as frameworks are specific to that operating system.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">
#[link(name = "FooCoreServices", kind = "framework")] extern {}
// OS used to compile is Linux for example</pre></div> <p>To solve this error you can use conditional compilation:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[cfg_attr(target="macos", link(name = "FooCoreServices", kind = "framework"))]
extern {}</pre></div> <p>Learn more in the <a href="reference/attributes#conditional-compilation">Conditional Compilation</a> section of the Reference.</p>   <h3 id="E0458" class="section-header">E0458</h3> <p>An unknown "kind" was specified for a link attribute.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[link(kind = "wonderful_unicorn")] extern {}
// error: unknown kind: `wonderful_unicorn`</pre></div> <p>Please specify a valid "kind" value, from one of the following:</p> <ul> <li>static</li> <li>dylib</li> <li>framework</li> </ul>  <h3 id="E0459" class="section-header">E0459</h3> <p>A link was used without a name parameter.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[link(kind = "dylib")] extern {}
// error: `#[link(...)]` specified without `name = "foo"`</pre></div> <p>Please add the name parameter to allow the rust compiler to find the library you want. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[link(kind = "dylib", name = "some_lib")] extern {} // ok!</pre></div>     <h3 id="E0463" class="section-header">E0463</h3> <p>A plugin/crate was declared but cannot be found.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(plugin)]
#![plugin(cookie_monster)] // error: can't find crate for `cookie_monster`
extern crate cake_is_a_lie; // error: can't find crate for `cake_is_a_lie`</pre></div> <p>You need to link your code to the relevant crate in order to be able to use it (through Cargo or the <code>-L</code> option of rustc example). Plugins are crates as well, and you link to them the same way.</p>    <h3 id="E0466" class="section-header">E0466</h3> <p>Macro import declaration was malformed.</p> <p>Erroneous code examples:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[macro_use(a_macro(another_macro))] // error: invalid import declaration
extern crate core as some_crate;

#[macro_use(i_want = "some_macros")] // error: invalid import declaration
extern crate core as another_crate;</pre></div> <p>This is a syntax error at the level of attribute declarations. The proper syntax for macro imports is the following:</p> <div class="information">ⓘThis example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">
// In some_crate:
#[macro_export]
macro_rules! get_tacos {
    ...
}

#[macro_export]
macro_rules! get_pimientos {
    ...
}

// In your crate:
#[macro_use(get_tacos, get_pimientos)] // It imports `get_tacos` and
extern crate some_crate;               // `get_pimientos` macros from some_crate</pre></div> <p>If you would like to import all exported macros, write <code>macro_use</code> with no arguments.</p>  <h3 id="E0468" class="section-header">E0468</h3> <p>A non-root module tried to import macros from another crate.</p> <p>Example of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
mod foo {
    #[macro_use(debug_assert)]  // error: must be at crate root to import
    extern crate core;          //        macros from another crate
    fn run_macro() { debug_assert!(true); }
}</pre></div> <p>Only <code>extern crate</code> imports at the crate root level are allowed to import macros.</p> <p>Either move the macro import to crate root or do without the foreign macros. This will work:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[macro_use(debug_assert)] // ok!
extern crate core;

mod foo {
    fn run_macro() { debug_assert!(true); }
}</pre></div>  <h3 id="E0469" class="section-header">E0469</h3> <p>A macro listed for import was not found.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[macro_use(drink, be_merry)] // error: imported macro not found
extern crate alloc;

fn main() {
    // ...
}</pre></div> <p>Either the listed macro is not contained in the imported crate, or it is not exported from the given crate.</p> <p>This could be caused by a typo. Did you misspell the macro's name?</p> <p>Double-check the names of the macros listed for import, and that the crate in question exports them.</p> <p>A working version would be:</p> <div class="information">ⓘThis example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">
// In some_crate crate:
#[macro_export]
macro_rules! eat {
    ...
}

#[macro_export]
macro_rules! drink {
    ...
}

// In your crate:
#[macro_use(eat, drink)]
extern crate some_crate; //ok!</pre></div>       <h3 id="E0477" class="section-header">E0477</h3> <p>The type does not fulfill the required lifetime.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
use std::sync::Mutex;

struct MyString&lt;'a&gt; {
    data: &amp;'a str,
}

fn i_want_static_closure&lt;F&gt;(a: F)
    where F: Fn() + 'static {}

fn print_string&lt;'a&gt;(s: Mutex&lt;MyString&lt;'a&gt;&gt;) {

    i_want_static_closure(move || {     // error: this closure has lifetime 'a
                                        //        rather than 'static
        println!("{}", s.lock().unwrap().data);
    });
}</pre></div> <p>In this example, the closure does not satisfy the <code>'static</code> lifetime constraint. To fix this error, you need to double check the lifetime of the type. Here, we can fix this problem by giving <code>s</code> a static lifetime:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::sync::Mutex;

struct MyString&lt;'a&gt; {
    data: &amp;'a str,
}

fn i_want_static_closure&lt;F&gt;(a: F)
    where F: Fn() + 'static {}

fn print_string(s: Mutex&lt;MyString&lt;'static&gt;&gt;) {

    i_want_static_closure(move || {     // ok!
        println!("{}", s.lock().unwrap().data);
    });
}</pre></div>  <h3 id="E0478" class="section-header">E0478</h3> <p>A lifetime bound was not satisfied.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
// Check that the explicit lifetime bound (`'SnowWhite`, in this example) must
// outlive all the superbounds from the trait (`'kiss`, in this example).

trait Wedding&lt;'t&gt;: 't { }

struct Prince&lt;'kiss, 'SnowWhite&gt; {
    child: Box&lt;Wedding&lt;'kiss&gt; + 'SnowWhite&gt;,
    // error: lifetime bound not satisfied
}</pre></div> <p>In this example, the <code>'SnowWhite</code> lifetime is supposed to outlive the <code>'kiss</code> lifetime but the declaration of the <code>Prince</code> struct doesn't enforce it. To fix this issue, you need to specify it:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Wedding&lt;'t&gt;: 't { }

struct Prince&lt;'kiss, 'SnowWhite: 'kiss&gt; { // You say here that 'SnowWhite
                                          // must live longer than 'kiss.
    child: Box&lt;Wedding&lt;'kiss&gt; + 'SnowWhite&gt;, // And now it's all good!
}</pre></div>              <h3 id="E0491" class="section-header">E0491</h3> <p>A reference has a longer lifetime than the data it references.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo&lt;'a&gt; {
    x: fn(&amp;'a i32),
}

trait Trait&lt;'a, 'b&gt; {
    type Out;
}

impl&lt;'a, 'b&gt; Trait&lt;'a, 'b&gt; for usize {
    type Out = &amp;'a Foo&lt;'b&gt;; // error!
}</pre></div> <p>Here, the problem is that the compiler cannot be sure that the <code>'b</code> lifetime will live longer than <code>'a</code>, which should be mandatory in order to be sure that <code>Trait::Out</code> will always have a reference pointing to an existing type. So in this case, we just need to tell the compiler than <code>'b</code> must outlive <code>'a</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo&lt;'a&gt; {
    x: fn(&amp;'a i32),
}

trait Trait&lt;'a, 'b&gt; {
    type Out;
}

impl&lt;'a, 'b: 'a&gt; Trait&lt;'a, 'b&gt; for usize { // we added the lifetime enforcement
    type Out = &amp;'a Foo&lt;'b&gt;; // it now works!
}</pre></div>  <h3 id="E0492" class="section-header">E0492</h3> <p>A borrow of a constant containing interior mutability was attempted.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
use std::sync::atomic::AtomicUsize;

const A: AtomicUsize = AtomicUsize::new(0);
static B: &amp;'static AtomicUsize = &amp;A;
// error: cannot borrow a constant which may contain interior mutability,
//        create a static instead</pre></div> <p>A <code>const</code> represents a constant value that should never change. If one takes a <code>&amp;</code> reference to the constant, then one is taking a pointer to some memory location containing the value. Normally this is perfectly fine: most values can't be changed via a shared <code>&amp;</code> pointer, but interior mutability would allow it. That is, a constant value could be mutated. On the other hand, a <code>static</code> is explicitly a single memory location, which can be mutated at will.</p> <p>So, in order to solve this error, either use statics which are <code>Sync</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::AtomicUsize;

static A: AtomicUsize = AtomicUsize::new(0);
static B: &amp;'static AtomicUsize = &amp;A; // ok!</pre></div> <p>You can also have this error while using a cell type:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
use std::cell::Cell;

const A: Cell&lt;usize&gt; = Cell::new(1);
const B: &amp;Cell&lt;usize&gt; = &amp;A;
// error: cannot borrow a constant which may contain interior mutability,
//        create a static instead

// or:
struct C { a: Cell&lt;usize&gt; }

const D: C = C { a: Cell::new(1) };
const E: &amp;Cell&lt;usize&gt; = &amp;D.a; // error

// or:
const F: &amp;C = &amp;D; // error</pre></div> <p>This is because cell types do operations that are not thread-safe. Due to this, they don't implement Sync and thus can't be placed in statics.</p> <p>However, if you still wish to use these types, you can achieve this by an unsafe wrapper:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::cell::Cell;
use std::marker::Sync;

struct NotThreadSafe&lt;T&gt; {
    value: Cell&lt;T&gt;,
}

unsafe impl&lt;T&gt; Sync for NotThreadSafe&lt;T&gt; {}

static A: NotThreadSafe&lt;usize&gt; = NotThreadSafe { value : Cell::new(1) };
static B: &amp;'static NotThreadSafe&lt;usize&gt; = &amp;A; // ok!</pre></div> <p>Remember this solution is unsafe! You will have to ensure that accesses to the cell are synchronized.</p>  <h3 id="E0493" class="section-header">E0493</h3> <p>A value with a custom <code>Drop</code> implementation may be dropped during const-eval.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
enum DropType {
    A,
}

impl Drop for DropType {
    fn drop(&amp;mut self) {}
}

struct Foo {
    field1: DropType,
}

static FOO: Foo = Foo { field1: (DropType::A, DropType::A).1 }; // error!</pre></div> <p>The problem here is that if the given type or one of its fields implements the <code>Drop</code> trait, this <code>Drop</code> implementation cannot be called within a const context since it may run arbitrary, non-const-checked code. To prevent this issue, ensure all values with custom a custom <code>Drop</code> implementation escape the initializer.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
enum DropType {
    A,
}

impl Drop for DropType {
    fn drop(&amp;mut self) {}
}

struct Foo {
    field1: DropType,
}

static FOO: Foo = Foo { field1: DropType::A }; // We initialize all fields
                                               // by hand.</pre></div>  <h3 id="E0495" class="section-header">E0495</h3> <p>A lifetime cannot be determined in the given situation.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn transmute_lifetime&lt;'a, 'b, T&gt;(t: &amp;'a (T,)) -&gt; &amp;'b T {
    match (&amp;t,) { // error!
        ((u,),) =&gt; u,
    }
}

let y = Box::new((42,));
let x = transmute_lifetime(&amp;y);</pre></div> <p>In this code, you have two ways to solve this issue:</p> <ol> <li>Enforce that <code>'a</code> lives at least as long as <code>'b</code>.</li> <li>Use the same lifetime requirement for both input and output values.</li> </ol> <p>So for the first solution, you can do it by replacing <code>'a</code> with <code>'a: 'b</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn transmute_lifetime&lt;'a: 'b, 'b, T&gt;(t: &amp;'a (T,)) -&gt; &amp;'b T {
    match (&amp;t,) { // ok!
        ((u,),) =&gt; u,
    }
}</pre></div> <p>In the second you can do it by simply removing <code>'b</code> so they both use <code>'a</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn transmute_lifetime&lt;'a, T&gt;(t: &amp;'a (T,)) -&gt; &amp;'a T {
    match (&amp;t,) { // ok!
        ((u,),) =&gt; u,
    }
}</pre></div>  <h3 id="E0496" class="section-header">E0496</h3> <p>A lifetime name is shadowing another lifetime name.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo&lt;'a&gt; {
    a: &amp;'a i32,
}

impl&lt;'a&gt; Foo&lt;'a&gt; {
    fn f&lt;'a&gt;(x: &amp;'a i32) { // error: lifetime name `'a` shadows a lifetime
                           //        name that is already in scope
    }
}</pre></div> <p>Please change the name of one of the lifetimes to remove this error. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo&lt;'a&gt; {
    a: &amp;'a i32,
}

impl&lt;'a&gt; Foo&lt;'a&gt; {
    fn f&lt;'b&gt;(x: &amp;'b i32) { // ok!
    }
}

fn main() {
}</pre></div>  <h3 id="E0497" class="section-header">E0497</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-37" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>A stability attribute was used outside of the standard library.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[stable] // error: stability attributes may not be used outside of the
          //        standard library
fn foo() {}</pre></div> <p>It is not possible to use stability attributes outside of the standard library. Also, for now, it is not possible to write deprecation messages either.</p>   <h3 id="E0499" class="section-header">E0499</h3> <p>A variable was borrowed as mutable more than once.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let mut i = 0;
let mut x = &amp;mut i;
let mut a = &amp;mut i;
x;
// error: cannot borrow `i` as mutable more than once at a time</pre></div> <p>Please note that in Rust, you can either have many immutable references, or one mutable reference. For more details you may want to read the <a href="book/ch04-02-references-and-borrowing">References &amp; Borrowing</a> section of the Book.</p> <p>Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut i = 0;
let mut x = &amp;mut i; // ok!

// or:
let mut i = 0;
let a = &amp;i; // ok!
let b = &amp;i; // still ok!
let c = &amp;i; // still ok!
b;
a;</pre></div>  <h3 id="E0500" class="section-header">E0500</h3> <p>A borrowed variable was used by a closure.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn you_know_nothing(jon_snow: &amp;mut i32) {
    let nights_watch = &amp;jon_snow;
    let starks = || {
        *jon_snow = 3; // error: closure requires unique access to `jon_snow`
                       //        but it is already borrowed
    };
    println!("{}", nights_watch);
}</pre></div> <p>In here, <code>jon_snow</code> is already borrowed by the <code>nights_watch</code> reference, so it cannot be borrowed by the <code>starks</code> closure at the same time. To fix this issue, you can create the closure after the borrow has ended:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn you_know_nothing(jon_snow: &amp;mut i32) {
    let nights_watch = &amp;jon_snow;
    println!("{}", nights_watch);
    let starks = || {
        *jon_snow = 3;
    };
}</pre></div> <p>Or, if the type implements the <code>Clone</code> trait, you can clone it between closures:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn you_know_nothing(jon_snow: &amp;mut i32) {
    let mut jon_copy = jon_snow.clone();
    let starks = || {
        *jon_snow = 3;
    };
    println!("{}", jon_copy);
}</pre></div>  <h3 id="E0501" class="section-header">E0501</h3> <p>A mutable variable is used but it is already captured by a closure.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn inside_closure(x: &amp;mut i32) {
    // Actions which require unique access
}

fn outside_closure(x: &amp;mut i32) {
    // Actions which require unique access
}

fn foo(a: &amp;mut i32) {
    let mut bar = || {
        inside_closure(a)
    };
    outside_closure(a); // error: cannot borrow `*a` as mutable because previous
                        //        closure requires unique access.
    bar();
}</pre></div> <p>This error indicates that a mutable variable is used while it is still captured by a closure. Because the closure has borrowed the variable, it is not available until the closure goes out of scope.</p> <p>Note that a capture will either move or borrow a variable, but in this situation, the closure is borrowing the variable. Take a look at the chapter on <a href="https://doc.rust-lang.org/stable/rust-by-example/fn/closures/capture.html">Capturing</a> in Rust By Example for more information.</p> <p>To fix this error, you can finish using the closure before using the captured variable:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn inside_closure(x: &amp;mut i32) {}
fn outside_closure(x: &amp;mut i32) {}

fn foo(a: &amp;mut i32) {
    let mut bar = || {
        inside_closure(a)
    };
    bar();
    // borrow on `a` ends.
    outside_closure(a); // ok!
}</pre></div> <p>Or you can pass the variable as a parameter to the closure:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn inside_closure(x: &amp;mut i32) {}
fn outside_closure(x: &amp;mut i32) {}

fn foo(a: &amp;mut i32) {
    let mut bar = |s: &amp;mut i32| {
        inside_closure(s)
    };
    outside_closure(a);
    bar(a);
}</pre></div> <p>It may be possible to define the closure later:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn inside_closure(x: &amp;mut i32) {}
fn outside_closure(x: &amp;mut i32) {}

fn foo(a: &amp;mut i32) {
    outside_closure(a);
    let mut bar = || {
        inside_closure(a)
    };
    bar();
}</pre></div>  <h3 id="E0502" class="section-header">E0502</h3> <p>A variable already borrowed as immutable was borrowed as mutable.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn bar(x: &amp;mut i32) {}
fn foo(a: &amp;mut i32) {
    let y = &amp;a; // a is borrowed as immutable.
    bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed
            //        as immutable
    println!("{}", y);
}</pre></div> <p>To fix this error, ensure that you don't have any other references to the variable before trying to access it mutably:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn bar(x: &amp;mut i32) {}
fn foo(a: &amp;mut i32) {
    bar(a);
    let y = &amp;a; // ok!
    println!("{}", y);
}</pre></div> <p>For more information on Rust's ownership system, take a look at the <a href="book/ch04-02-references-and-borrowing">References &amp; Borrowing</a> section of the Book.</p>  <h3 id="E0503" class="section-header">E0503</h3> <p>A value was used after it was mutably borrowed.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn main() {
    let mut value = 3;
    // Create a mutable borrow of `value`.
    let borrow = &amp;mut value;
    let _sum = value + 1; // error: cannot use `value` because
                          //        it was mutably borrowed
    println!("{}", borrow);
}</pre></div> <p>In this example, <code>value</code> is mutably borrowed by <code>borrow</code> and cannot be used to calculate <code>sum</code>. This is not possible because this would violate Rust's mutability rules.</p> <p>You can fix this error by finishing using the borrow before the next use of the value:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn main() {
    let mut value = 3;
    let borrow = &amp;mut value;
    println!("{}", borrow);
    // The block has ended and with it the borrow.
    // You can now use `value` again.
    let _sum = value + 1;
}</pre></div> <p>Or by cloning <code>value</code> before borrowing it:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn main() {
    let mut value = 3;
    // We clone `value`, creating a copy.
    let value_cloned = value.clone();
    // The mutable borrow is a reference to `value` and
    // not to `value_cloned`...
    let borrow = &amp;mut value;
    // ... which means we can still use `value_cloned`,
    let _sum = value_cloned + 1;
    // even though the borrow only ends here.
    println!("{}", borrow);
}</pre></div> <p>For more information on Rust's ownership system, take a look at the <a href="book/ch04-02-references-and-borrowing">References &amp; Borrowing</a> section of the Book.</p>  <h3 id="E0504" class="section-header">E0504</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-38" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>This error occurs when an attempt is made to move a borrowed variable into a closure.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct FancyNum {
    num: u8,
}

fn main() {
    let fancy_num = FancyNum { num: 5 };
    let fancy_ref = &amp;fancy_num;

    let x = move || {
        println!("child function: {}", fancy_num.num);
        // error: cannot move `fancy_num` into closure because it is borrowed
    };

    x();
    println!("main function: {}", fancy_ref.num);
}</pre></div> <p>Here, <code>fancy_num</code> is borrowed by <code>fancy_ref</code> and so cannot be moved into the closure <code>x</code>. There is no way to move a value into a closure while it is borrowed, as that would invalidate the borrow.</p> <p>If the closure can't outlive the value being moved, try using a reference rather than moving:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct FancyNum {
    num: u8,
}

fn main() {
    let fancy_num = FancyNum { num: 5 };
    let fancy_ref = &amp;fancy_num;

    let x = move || {
        // fancy_ref is usable here because it doesn't move `fancy_num`
        println!("child function: {}", fancy_ref.num);
    };

    x();

    println!("main function: {}", fancy_num.num);
}</pre></div> <p>If the value has to be borrowed and then moved, try limiting the lifetime of the borrow using a scoped block:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct FancyNum {
    num: u8,
}

fn main() {
    let fancy_num = FancyNum { num: 5 };

    {
        let fancy_ref = &amp;fancy_num;
        println!("main function: {}", fancy_ref.num);
        // `fancy_ref` goes out of scope here
    }

    let x = move || {
        // `fancy_num` can be moved now (no more references exist)
        println!("child function: {}", fancy_num.num);
    };

    x();
}</pre></div> <p>If the lifetime of a reference isn't enough, such as in the case of threading, consider using an <code>Arc</code> to create a reference-counted value:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::sync::Arc;
use std::thread;

struct FancyNum {
    num: u8,
}

fn main() {
    let fancy_ref1 = Arc::new(FancyNum { num: 5 });
    let fancy_ref2 = fancy_ref1.clone();

    let x = thread::spawn(move || {
        // `fancy_ref1` can be moved and has a `'static` lifetime
        println!("child thread: {}", fancy_ref1.num);
    });

    x.join().expect("child thread should finish");
    println!("main thread: {}", fancy_ref2.num);
}</pre></div>  <h3 id="E0505" class="section-header">E0505</h3> <p>A value was moved out while it was still borrowed.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Value {}

fn borrow(val: &amp;Value) {}

fn eat(val: Value) {}

fn main() {
    let x = Value{};
    let _ref_to_val: &amp;Value = &amp;x;
    eat(x);
    borrow(_ref_to_val);
}</pre></div> <p>Here, the function <code>eat</code> takes ownership of <code>x</code>. However, <code>x</code> cannot be moved because the borrow to <code>_ref_to_val</code> needs to last till the function <code>borrow</code>. To fix that you can do a few different things:</p> <ul> <li>Try to avoid moving the variable.</li> <li>Release borrow before move.</li> <li>Implement the <code>Copy</code> trait on the type.</li> </ul> <p>Examples:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Value {}

fn borrow(val: &amp;Value) {}

fn eat(val: &amp;Value) {}

fn main() {
    let x = Value{};

    let ref_to_val: &amp;Value = &amp;x;
    eat(&amp;x); // pass by reference, if it's possible
    borrow(ref_to_val);
}</pre></div> <p>Or:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Value {}

fn borrow(val: &amp;Value) {}

fn eat(val: Value) {}

fn main() {
    let x = Value{};

    let ref_to_val: &amp;Value = &amp;x;
    borrow(ref_to_val);
    // ref_to_val is no longer used.
    eat(x);
}</pre></div> <p>Or:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[derive(Clone, Copy)] // implement Copy trait
struct Value {}

fn borrow(val: &amp;Value) {}

fn eat(val: Value) {}

fn main() {
    let x = Value{};
    let ref_to_val: &amp;Value = &amp;x;
    eat(x); // it will be copied here.
    borrow(ref_to_val);
}</pre></div> <p>For more information on Rust's ownership system, take a look at the <a href="book/ch04-02-references-and-borrowing">References &amp; Borrowing</a> section of the Book.</p>  <h3 id="E0506" class="section-header">E0506</h3> <p>An attempt was made to assign to a borrowed value.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct FancyNum {
    num: u8,
}

let mut fancy_num = FancyNum { num: 5 };
let fancy_ref = &amp;fancy_num;
fancy_num = FancyNum { num: 6 };
// error: cannot assign to `fancy_num` because it is borrowed

println!("Num: {}, Ref: {}", fancy_num.num, fancy_ref.num);</pre></div> <p>Because <code>fancy_ref</code> still holds a reference to <code>fancy_num</code>, <code>fancy_num</code> can't be assigned to a new value as it would invalidate the reference.</p> <p>Alternatively, we can move out of <code>fancy_num</code> into a second <code>fancy_num</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct FancyNum {
    num: u8,
}

let mut fancy_num = FancyNum { num: 5 };
let moved_num = fancy_num;
fancy_num = FancyNum { num: 6 };

println!("Num: {}, Moved num: {}", fancy_num.num, moved_num.num);</pre></div> <p>If the value has to be borrowed, try limiting the lifetime of the borrow using a scoped block:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct FancyNum {
    num: u8,
}

let mut fancy_num = FancyNum { num: 5 };

{
    let fancy_ref = &amp;fancy_num;
    println!("Ref: {}", fancy_ref.num);
}

// Works because `fancy_ref` is no longer in scope
fancy_num = FancyNum { num: 6 };
println!("Num: {}", fancy_num.num);</pre></div> <p>Or by moving the reference into a function:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct FancyNum {
    num: u8,
}

fn print_fancy_ref(fancy_ref: &amp;FancyNum){
    println!("Ref: {}", fancy_ref.num);
}

let mut fancy_num = FancyNum { num: 5 };

print_fancy_ref(&amp;fancy_num);

// Works because function borrow has ended
fancy_num = FancyNum { num: 6 };
println!("Num: {}", fancy_num.num);</pre></div>  <h3 id="E0507" class="section-header">E0507</h3> <p>A borrowed value was moved out.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
use std::cell::RefCell;

struct TheDarkKnight;

impl TheDarkKnight {
    fn nothing_is_true(self) {}
}

fn main() {
    let x = RefCell::new(TheDarkKnight);

    x.borrow().nothing_is_true(); // error: cannot move out of borrowed content
}</pre></div> <p>Here, the <code>nothing_is_true</code> method takes the ownership of <code>self</code>. However, <code>self</code> cannot be moved because <code>.borrow()</code> only provides an <code>&amp;TheDarkKnight</code>, which is a borrow of the content owned by the <code>RefCell</code>. To fix this error, you have three choices:</p> <ul> <li>Try to avoid moving the variable.</li> <li>Somehow reclaim the ownership.</li> <li>Implement the <code>Copy</code> trait on the type.</li> </ul> <p>This can also happen when using a type implementing <code>Fn</code> or <code>FnMut</code>, as neither allows moving out of them (they usually represent closures which can be called more than once). Much of the text following applies equally well to non-<code>FnOnce</code> closure bodies.</p> <p>Examples:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::cell::RefCell;

struct TheDarkKnight;

impl TheDarkKnight {
    fn nothing_is_true(&amp;self) {} // First case, we don't take ownership
}

fn main() {
    let x = RefCell::new(TheDarkKnight);

    x.borrow().nothing_is_true(); // ok!
}</pre></div> <p>Or:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::cell::RefCell;

struct TheDarkKnight;

impl TheDarkKnight {
    fn nothing_is_true(self) {}
}

fn main() {
    let x = RefCell::new(TheDarkKnight);
    let x = x.into_inner(); // we get back ownership

    x.nothing_is_true(); // ok!
}</pre></div> <p>Or:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::cell::RefCell;

#[derive(Clone, Copy)] // we implement the Copy trait
struct TheDarkKnight;

impl TheDarkKnight {
    fn nothing_is_true(self) {}
}

fn main() {
    let x = RefCell::new(TheDarkKnight);

    x.borrow().nothing_is_true(); // ok!
}</pre></div> <p>Moving a member out of a mutably borrowed struct will also cause E0507 error:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct TheDarkKnight;

impl TheDarkKnight {
    fn nothing_is_true(self) {}
}

struct Batcave {
    knight: TheDarkKnight
}

fn main() {
    let mut cave = Batcave {
        knight: TheDarkKnight
    };
    let borrowed = &amp;mut cave;

    borrowed.knight.nothing_is_true(); // E0507
}</pre></div> <p>It is fine only if you put something back. <code>mem::replace</code> can be used for that:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::mem;

let mut cave = Batcave {
    knight: TheDarkKnight
};
let borrowed = &amp;mut cave;

mem::replace(&amp;mut borrowed.knight, TheDarkKnight).nothing_is_true(); // ok!</pre></div> <p>For more information on Rust's ownership system, take a look at the <a href="book/ch04-02-references-and-borrowing">References &amp; Borrowing</a> section of the Book.</p>  <h3 id="E0508" class="section-header">E0508</h3> <p>A value was moved out of a non-copy fixed-size array.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct NonCopy;

fn main() {
    let array = [NonCopy; 1];
    let _value = array[0]; // error: cannot move out of type `[NonCopy; 1]`,
                           //        a non-copy fixed-size array
}</pre></div> <p>The first element was moved out of the array, but this is not possible because <code>NonCopy</code> does not implement the <code>Copy</code> trait.</p> <p>Consider borrowing the element instead of moving it:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct NonCopy;

fn main() {
    let array = [NonCopy; 1];
    let _value = &amp;array[0]; // Borrowing is allowed, unlike moving.
}</pre></div> <p>Alternatively, if your type implements <code>Clone</code> and you need to own the value, consider borrowing and then cloning:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[derive(Clone)]
struct NonCopy;

fn main() {
    let array = [NonCopy; 1];
    // Now you can clone the array element.
    let _value = array[0].clone();
}</pre></div>  <h3 id="E0509" class="section-header">E0509</h3> <p>This error occurs when an attempt is made to move out of a value whose type implements the <code>Drop</code> trait.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct FancyNum {
    num: usize
}

struct DropStruct {
    fancy: FancyNum
}

impl Drop for DropStruct {
    fn drop(&amp;mut self) {
        // Destruct DropStruct, possibly using FancyNum
    }
}

fn main() {
    let drop_struct = DropStruct{fancy: FancyNum{num: 5}};
    let fancy_field = drop_struct.fancy; // Error E0509
    println!("Fancy: {}", fancy_field.num);
    // implicit call to `drop_struct.drop()` as drop_struct goes out of scope
}</pre></div> <p>Here, we tried to move a field out of a struct of type <code>DropStruct</code> which implements the <code>Drop</code> trait. However, a struct cannot be dropped if one or more of its fields have been moved.</p> <p>Structs implementing the <code>Drop</code> trait have an implicit destructor that gets called when they go out of scope. This destructor may use the fields of the struct, so moving out of the struct could make it impossible to run the destructor. Therefore, we must think of all values whose type implements the <code>Drop</code> trait as single units whose fields cannot be moved.</p> <p>This error can be fixed by creating a reference to the fields of a struct, enum, or tuple using the <code>ref</code> keyword:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct FancyNum {
    num: usize
}

struct DropStruct {
    fancy: FancyNum
}

impl Drop for DropStruct {
    fn drop(&amp;mut self) {
        // Destruct DropStruct, possibly using FancyNum
    }
}

fn main() {
    let drop_struct = DropStruct{fancy: FancyNum{num: 5}};
    let ref fancy_field = drop_struct.fancy; // No more errors!
    println!("Fancy: {}", fancy_field.num);
    // implicit call to `drop_struct.drop()` as drop_struct goes out of scope
}</pre></div> <p>Note that this technique can also be used in the arms of a match expression:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct FancyNum {
    num: usize
}

enum DropEnum {
    Fancy(FancyNum)
}

impl Drop for DropEnum {
    fn drop(&amp;mut self) {
        // Destruct DropEnum, possibly using FancyNum
    }
}

fn main() {
    // Creates and enum of type `DropEnum`, which implements `Drop`
    let drop_enum = DropEnum::Fancy(FancyNum{num: 10});
    match drop_enum {
        // Creates a reference to the inside of `DropEnum::Fancy`
        DropEnum::Fancy(ref fancy_field) =&gt; // No error!
            println!("It was fancy-- {}!", fancy_field.num),
    }
    // implicit call to `drop_enum.drop()` as drop_enum goes out of scope
}</pre></div>  <h3 id="E0510" class="section-header">E0510</h3> <p>The matched value was assigned in a match guard.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let mut x = Some(0);
match x {
    None =&gt; {}
    Some(_) if { x = None; false } =&gt; {} // error!
    Some(_) =&gt; {}
}</pre></div> <p>When matching on a variable it cannot be mutated in the match guards, as this could cause the match to be non-exhaustive.</p> <p>Here executing <code>x = None</code> would modify the value being matched and require us to go "back in time" to the <code>None</code> arm. To fix it, change the value in the match arm:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut x = Some(0);
match x {
    None =&gt; {}
    Some(_) =&gt; {
        x = None; // ok!
    }
}</pre></div>  <h3 id="E0511" class="section-header">E0511</h3> <p>Invalid monomorphization of an intrinsic function was used.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(platform_intrinsics)]

extern "platform-intrinsic" {
    fn simd_add&lt;T&gt;(a: T, b: T) -&gt; T;
}

fn main() {
    unsafe { simd_add(0, 1); }
    // error: invalid monomorphization of `simd_add` intrinsic
}</pre></div> <p>The generic type has to be a SIMD type. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(repr_simd)]
#![feature(platform_intrinsics)]

#[repr(simd)]
#[derive(Copy, Clone)]
struct i32x2(i32, i32);

extern "platform-intrinsic" {
    fn simd_add&lt;T&gt;(a: T, b: T) -&gt; T;
}

unsafe { simd_add(i32x2(0, 0), i32x2(1, 2)); } // ok!</pre></div>  <h3 id="E0512" class="section-header">E0512</h3> <p>Transmute with two differently sized types was attempted.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn takes_u8(_: u8) {}

fn main() {
    unsafe { takes_u8(::std::mem::transmute(0u16)); }
    // error: cannot transmute between types of different sizes,
    //        or dependently-sized types
}</pre></div> <p>Please use types with same size or use the expected type directly. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn takes_u8(_: u8) {}

fn main() {
    unsafe { takes_u8(::std::mem::transmute(0i8)); } // ok!
    // or:
    unsafe { takes_u8(0u8); } // ok!
}</pre></div>   <h3 id="E0515" class="section-header">E0515</h3> <p>A reference to a local variable was returned.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn get_dangling_reference() -&gt; &amp;'static i32 {
    let x = 0;
    &amp;x
}</pre></div> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
use std::slice::Iter;
fn get_dangling_iterator&lt;'a&gt;() -&gt; Iter&lt;'a, i32&gt; {
    let v = vec![1, 2, 3];
    v.iter()
}</pre></div> <p>Local variables, function parameters and temporaries are all dropped before the end of the function body. So a reference to them cannot be returned.</p> <p>Consider returning an owned value instead:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::vec::IntoIter;

fn get_integer() -&gt; i32 {
    let x = 0;
    x
}

fn get_owned_iterator() -&gt; IntoIter&lt;i32&gt; {
    let v = vec![1, 2, 3];
    v.into_iter()
}</pre></div>  <h3 id="E0516" class="section-header">E0516</h3> <p>The <code>typeof</code> keyword is currently reserved but unimplemented.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn main() {
    let x: typeof(92) = 92;
}</pre></div> <p>Try using type inference instead. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn main() {
    let x = 92;
}</pre></div>  <h3 id="E0517" class="section-header">E0517</h3> <p>A <code>#[repr(..)]</code> attribute was placed on an unsupported item.</p> <p>Examples of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[repr(C)]
type Foo = u8;

#[repr(packed)]
enum Foo {Bar, Baz}

#[repr(u8)]
struct Foo {bar: bool, baz: bool}

#[repr(C)]
impl Foo {
    // ...
}</pre></div> <ul> <li>The <code>#[repr(C)]</code> attribute can only be placed on structs and enums.</li> <li>The <code>#[repr(packed)]</code> and <code>#[repr(simd)]</code> attributes only work on structs.</li> <li>The <code>#[repr(u8)]</code>, <code>#[repr(i16)]</code>, etc attributes only work on enums.</li> </ul> <p>These attributes do not work on typedefs, since typedefs are just aliases.</p> <p>Representations like <code>#[repr(u8)]</code>, <code>#[repr(i64)]</code> are for selecting the discriminant size for enums with no data fields on any of the variants, e.g. <code>enum Color {Red, Blue, Green}</code>, effectively setting the size of the enum to the size of the provided type. Such an enum can be cast to a value of the same type as well. In short, <code>#[repr(u8)]</code> makes the enum behave like an integer with a constrained set of allowed values.</p> <p>Only field-less enums can be cast to numerical primitives, so this attribute will not apply to structs.</p> <p><code>#[repr(packed)]</code> reduces padding to make the struct size smaller. The representation of enums isn't strictly defined in Rust, and this attribute won't work on enums.</p> <p><code>#[repr(simd)]</code> will give a struct consisting of a homogeneous series of machine types (i.e., <code>u8</code>, <code>i32</code>, etc) a representation that permits vectorization via SIMD. This doesn't make much sense for enums since they don't consist of a single list of data.</p>  <h3 id="E0518" class="section-header">E0518</h3> <p>An <code>#[inline(..)]</code> attribute was incorrectly placed on something other than a function or method.</p> <p>Example of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[inline(always)]
struct Foo;

#[inline(never)]
impl Foo {
    // ...
}</pre></div> <p><code>#[inline]</code> hints the compiler whether or not to attempt to inline a method or function. By default, the compiler does a pretty good job of figuring this out itself, but if you feel the need for annotations, <code>#[inline(always)]</code> and <code>#[inline(never)]</code> can override or force the compiler's decision.</p> <p>If you wish to apply this attribute to all methods in an impl, manually annotate each method; it is not possible to annotate the entire impl with an <code>#[inline]</code> attribute.</p>   <h3 id="E0520" class="section-header">E0520</h3> <p>A non-default implementation was already made on this type so it cannot be specialized further.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(specialization)]

trait SpaceLlama {
    fn fly(&amp;self);
}

// applies to all T
impl&lt;T&gt; SpaceLlama for T {
    default fn fly(&amp;self) {}
}

// non-default impl
// applies to all `Clone` T and overrides the previous impl
impl&lt;T: Clone&gt; SpaceLlama for T {
    fn fly(&amp;self) {}
}

// since `i32` is clone, this conflicts with the previous implementation
impl SpaceLlama for i32 {
    default fn fly(&amp;self) {}
    // error: item `fly` is provided by an `impl` that specializes
    //        another, but the item in the parent `impl` is not marked
    //        `default` and so it cannot be specialized.
}</pre></div> <p>Specialization only allows you to override <code>default</code> functions in implementations.</p> <p>To fix this error, you need to mark all the parent implementations as default. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(specialization)]

trait SpaceLlama {
    fn fly(&amp;self);
}

// applies to all T
impl&lt;T&gt; SpaceLlama for T {
    default fn fly(&amp;self) {} // This is a parent implementation.
}

// applies to all `Clone` T; overrides the previous impl
impl&lt;T: Clone&gt; SpaceLlama for T {
    default fn fly(&amp;self) {} // This is a parent implementation but was
                             // previously not a default one, causing the error
}

// applies to i32, overrides the previous two impls
impl SpaceLlama for i32 {
    fn fly(&amp;self) {} // And now that's ok!
}</pre></div>   <h3 id="E0522" class="section-header">E0522</h3> <p>The lang attribute was used in an invalid context.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(lang_items)]

#[lang = "cookie"]
fn cookie() -&gt; ! { // error: definition of an unknown language item: `cookie`
    loop {}
}</pre></div> <p>The lang attribute is intended for marking special items that are built-in to Rust itself. This includes special traits (like <code>Copy</code> and <code>Sized</code>) that affect how the compiler behaves, as well as special functions that may be automatically invoked (such as the handler for out-of-bounds accesses when indexing a slice).</p>   <h3 id="E0524" class="section-header">E0524</h3> <p>A variable which requires unique access is being used in more than one closure at the same time.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn set(x: &amp;mut isize) {
    *x += 4;
}

fn dragoooon(x: &amp;mut isize) {
    let mut c1 = || set(x);
    let mut c2 = || set(x); // error!

    c2();
    c1();
}</pre></div> <p>To solve this issue, multiple solutions are available. First, is it required for this variable to be used in more than one closure at a time? If it is the case, use reference counted types such as <code>Rc</code> (or <code>Arc</code> if it runs concurrently):</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::rc::Rc;
use std::cell::RefCell;

fn set(x: &amp;mut isize) {
    *x += 4;
}

fn dragoooon(x: &amp;mut isize) {
    let x = Rc::new(RefCell::new(x));
    let y = Rc::clone(&amp;x);
    let mut c1 = || { let mut x2 = x.borrow_mut(); set(&amp;mut x2); };
    let mut c2 = || { let mut x2 = y.borrow_mut(); set(&amp;mut x2); }; // ok!

    c2();
    c1();
}</pre></div> <p>If not, just run closures one at a time:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn set(x: &amp;mut isize) {
    *x += 4;
}

fn dragoooon(x: &amp;mut isize) {
    { // This block isn't necessary since non-lexical lifetimes, it's just to
      // make it more clear.
        let mut c1 = || set(&amp;mut *x);
        c1();
    } // `c1` has been dropped here so we're free to use `x` again!
    let mut c2 = || set(&amp;mut *x);
    c2();
}</pre></div>  <h3 id="E0525" class="section-header">E0525</h3> <p>A closure was used but didn't implement the expected trait.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct X;

fn foo&lt;T&gt;(_: T) {}
fn bar&lt;T: Fn(u32)&gt;(_: T) {}

fn main() {
    let x = X;
    let closure = |_| foo(x); // error: expected a closure that implements
                              //        the `Fn` trait, but this closure only
                              //        implements `FnOnce`
    bar(closure);
}</pre></div> <p>In the example above, <code>closure</code> is an <code>FnOnce</code> closure whereas the <code>bar</code> function expected an <code>Fn</code> closure. In this case, it's simple to fix the issue, you just have to implement <code>Copy</code> and <code>Clone</code> traits on <code>struct X</code> and it'll be ok:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[derive(Clone, Copy)] // We implement `Clone` and `Copy` traits.
struct X;

fn foo&lt;T&gt;(_: T) {}
fn bar&lt;T: Fn(u32)&gt;(_: T) {}

fn main() {
    let x = X;
    let closure = |_| foo(x);
    bar(closure); // ok!
}</pre></div> <p>To better understand how these work in Rust, read the <a href="book/ch13-01-closures">Closures</a> chapter of the Book.</p>  <h3 id="E0527" class="section-header">E0527</h3> <p>The number of elements in an array or slice pattern differed from the number of elements in the array being matched.</p> <p>Example of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let r = &amp;[1, 2, 3, 4];
match r {
    &amp;[a, b] =&gt; { // error: pattern requires 2 elements but array
                 //        has 4
        println!("a={}, b={}", a, b);
    }
}</pre></div> <p>Ensure that the pattern is consistent with the size of the matched array. Additional elements can be matched with <code>..</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let r = &amp;[1, 2, 3, 4];
match r {
    &amp;[a, b, ..] =&gt; { // ok!
        println!("a={}, b={}", a, b);
    }
}</pre></div>  <h3 id="E0528" class="section-header">E0528</h3> <p>An array or slice pattern required more elements than were present in the matched array.</p> <p>Example of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let r = &amp;[1, 2];
match r {
    &amp;[a, b, c, rest @ ..] =&gt; { // error: pattern requires at least 3
                               //        elements but array has 2
        println!("a={}, b={}, c={} rest={:?}", a, b, c, rest);
    }
}</pre></div> <p>Ensure that the matched array has at least as many elements as the pattern requires. You can match an arbitrary number of remaining elements with <code>..</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let r = &amp;[1, 2, 3, 4, 5];
match r {
    &amp;[a, b, c, rest @ ..] =&gt; { // ok!
        // prints `a=1, b=2, c=3 rest=[4, 5]`
        println!("a={}, b={}, c={} rest={:?}", a, b, c, rest);
    }
}</pre></div>  <h3 id="E0529" class="section-header">E0529</h3> <p>An array or slice pattern was matched against some other type.</p> <p>Example of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let r: f32 = 1.0;
match r {
    [a, b] =&gt; { // error: expected an array or slice, found `f32`
        println!("a={}, b={}", a, b);
    }
}</pre></div> <p>Ensure that the pattern and the expression being matched on are of consistent types:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let r = [1.0, 2.0];
match r {
    [a, b] =&gt; { // ok!
        println!("a={}, b={}", a, b);
    }
}</pre></div>  <h3 id="E0530" class="section-header">E0530</h3> <p>A binding shadowed something it shouldn't.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
static TEST: i32 = 0;

let r: (i32, i32) = (0, 0);
match r {
    TEST =&gt; {} // error: match bindings cannot shadow statics
}</pre></div> <p>To fix this error, just change the binding's name in order to avoid shadowing one of the following:</p> <ul> <li>struct name</li> <li>struct/enum variant</li> <li>static</li> <li>const</li> <li>associated const</li> </ul> <p>Fixed example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
static TEST: i32 = 0;

let r: (i32, i32) = (0, 0);
match r {
    something =&gt; {} // ok!
}</pre></div>  <h3 id="E0531" class="section-header">E0531</h3> <p>An unknown tuple struct/variant has been used.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let Type(x) = Type(12); // error!
match Bar(12) {
    Bar(x) =&gt; {} // error!
    _ =&gt; {}
}</pre></div> <p>In most cases, it's either a forgotten import or a typo. However, let's look at how you can have such a type:</p> <div class="information">ⓘThis code runs with edition 2018</div>
<div class="example-wrap"><pre class="rust rust-example-rendered edition " data-language="rust">
struct Type(u32); // this is a tuple struct

enum Foo {
    Bar(u32), // this is a tuple variant
}

use Foo::*; // To use Foo's variant directly, we need to import them in
            // the scope.</pre></div> <p>Either way, it should work fine with our previous code:</p> <div class="information">ⓘThis code runs with edition 2018</div>
<div class="example-wrap"><pre class="rust rust-example-rendered edition " data-language="rust">
struct Type(u32);

enum Foo {
    Bar(u32),
}
use Foo::*;

let Type(x) = Type(12); // ok!
match Type(12) {
    Type(x) =&gt; {} // ok!
    _ =&gt; {}
}</pre></div>  <h3 id="E0532" class="section-header">E0532</h3> <p>Pattern arm did not match expected kind.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
enum State {
    Succeeded,
    Failed(String),
}

fn print_on_failure(state: &amp;State) {
    match *state {
        // error: expected unit struct, unit variant or constant, found tuple
        //        variant `State::Failed`
        State::Failed =&gt; println!("Failed"),
        _ =&gt; ()
    }
}</pre></div> <p>To fix this error, ensure the match arm kind is the same as the expression matched.</p> <p>Fixed example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
enum State {
    Succeeded,
    Failed(String),
}

fn print_on_failure(state: &amp;State) {
    match *state {
        State::Failed(ref msg) =&gt; println!("Failed with {}", msg),
        _ =&gt; ()
    }
}</pre></div>  <h3 id="E0533" class="section-header">E0533</h3> <p>An item which isn't a unit struct, a variant, nor a constant has been used as a match pattern.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Tortoise;

impl Tortoise {
    fn turtle(&amp;self) -&gt; u32 { 0 }
}

match 0u32 {
    Tortoise::turtle =&gt; {} // Error!
    _ =&gt; {}
}
if let Tortoise::turtle = 0u32 {} // Same error!</pre></div> <p>If you want to match against a value returned by a method, you need to bind the value first:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Tortoise;

impl Tortoise {
    fn turtle(&amp;self) -&gt; u32 { 0 }
}

match 0u32 {
    x if x == Tortoise.turtle() =&gt; {} // Bound into `x` then we compare it!
    _ =&gt; {}
}</pre></div>  <h3 id="E0534" class="section-header">E0534</h3> <p>The <code>inline</code> attribute was malformed.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[inline()] // error: expected one argument
pub fn something() {}

fn main() {}</pre></div> <p>The parenthesized <code>inline</code> attribute requires the parameter to be specified:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[inline(always)]
fn something() {}</pre></div> <p>or:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[inline(never)]
fn something() {}</pre></div> <p>Alternatively, a paren-less version of the attribute may be used to hint the compiler about inlining opportunity:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[inline]
fn something() {}</pre></div> <p>For more information see the <a href="reference/attributes/codegen#the-inline-attribute"><code>inline</code> attribute</a> section of the Reference.</p>  <h3 id="E0535" class="section-header">E0535</h3> <p>An unknown argument was given to the <code>inline</code> attribute.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[inline(unknown)] // error: invalid argument
pub fn something() {}

fn main() {}</pre></div> <p>The <code>inline</code> attribute only supports two arguments:</p> <ul> <li>always</li> <li>never</li> </ul> <p>All other arguments given to the <code>inline</code> attribute will return this error. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[inline(never)] // ok!
pub fn something() {}

fn main() {}</pre></div> <p>For more information see the <a href="reference/attributes/codegen#the-inline-attribute"><code>inline</code> Attribute</a> section of the Reference.</p>  <h3 id="E0536" class="section-header">E0536</h3> <p>The <code>not</code> cfg-predicate was malformed.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[cfg(not())] // error: expected 1 cfg-pattern
pub fn something() {}

pub fn main() {}</pre></div> <p>The <code>not</code> predicate expects one cfg-pattern. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[cfg(not(target_os = "linux"))] // ok!
pub fn something() {}

pub fn main() {}</pre></div> <p>For more information about the <code>cfg</code> attribute, read the section on <a href="reference/conditional-compilation">Conditional Compilation</a> in the Reference.</p>  <h3 id="E0537" class="section-header">E0537</h3> <p>An unknown predicate was used inside the <code>cfg</code> attribute.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[cfg(unknown())] // error: invalid predicate `unknown`
pub fn something() {}

pub fn main() {}</pre></div> <p>The <code>cfg</code> attribute supports only three kinds of predicates:</p> <ul> <li>any</li> <li>all</li> <li>not</li> </ul> <p>Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[cfg(not(target_os = "linux"))] // ok!
pub fn something() {}

pub fn main() {}</pre></div> <p>For more information about the <code>cfg</code> attribute, read the section on <a href="reference/conditional-compilation">Conditional Compilation</a> in the Reference.</p>  <h3 id="E0538" class="section-header">E0538</h3> <p>Attribute contains same meta item more than once.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[deprecated(
    since="1.0.0",
    note="First deprecation note.",
    note="Second deprecation note." // error: multiple same meta item
)]
fn deprecated_function() {}</pre></div> <p>Meta items are the key-value pairs inside of an attribute. Each key may only be used once in each attribute.</p> <p>To fix the problem, remove all but one of the meta items with the same key.</p> <p>Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[deprecated(
    since="1.0.0",
    note="First deprecation note."
)]
fn deprecated_function() {}</pre></div>  <h3 id="E0539" class="section-header">E0539</h3> <p>An invalid meta-item was used inside an attribute.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(staged_api)]
#![stable(since = "1.0.0", feature = "test")]

#[rustc_deprecated(reason)] // error!
#[unstable(feature = "deprecated_fn", issue = "123")]
fn deprecated() {}

#[unstable(feature = "unstable_struct", issue)] // error!
struct Unstable;

#[rustc_const_unstable(feature)] // error!
const fn unstable_fn() {}

#[stable(feature = "stable_struct", since)] // error!
struct Stable;

#[rustc_const_stable(feature)] // error!
const fn stable_fn() {}</pre></div> <p>Meta items are the key-value pairs inside of an attribute. To fix these issues you need to give required key-value pairs.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(staged_api)]
#![stable(since = "1.0.0", feature = "test")]

#[rustc_deprecated(since = "1.39.0", reason = "reason")] // ok!
#[unstable(feature = "deprecated_fn", issue = "123")]
fn deprecated() {}

#[unstable(feature = "unstable_struct", issue = "123")] // ok!
struct Unstable;

#[rustc_const_unstable(feature = "unstable_fn", issue = "124")] // ok!
const fn unstable_fn() {}

#[stable(feature = "stable_struct", since = "1.39.0")] // ok!
struct Stable;

#[rustc_const_stable(feature = "stable_fn", since = "1.39.0")] // ok!
const fn stable_fn() {}</pre></div>  <h3 id="E0541" class="section-header">E0541</h3> <p>An unknown meta item was used.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[deprecated(
    since="1.0.0",
    // error: unknown meta item
    reason="Example invalid meta item. Should be 'note'")
]
fn deprecated_function() {}</pre></div> <p>Meta items are the key-value pairs inside of an attribute. The keys provided must be one of the valid keys for the specified attribute.</p> <p>To fix the problem, either remove the unknown meta item, or rename it if you provided the wrong name.</p> <p>In the erroneous code example above, the wrong name was provided, so changing to a correct one it will fix the error. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[deprecated(
    since="1.0.0",
    note="This is a valid meta item for the deprecated attribute."
)]
fn deprecated_function() {}</pre></div>         <h3 id="E0550" class="section-header">E0550</h3> <p>More than one <code>deprecated</code> attribute has been put on an item.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[deprecated(note = "because why not?")]
#[deprecated(note = "right?")] // error!
fn the_banished() {}</pre></div> <p>The <code>deprecated</code> attribute can only be present <strong>once</strong> on an item.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[deprecated(note = "because why not, right?")]
fn the_banished() {} // ok!</pre></div>  <h3 id="E0551" class="section-header">E0551</h3> <p>An invalid meta-item was used inside an attribute.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[deprecated(note)] // error!
fn i_am_deprecated() {}</pre></div> <p>Meta items are the key-value pairs inside of an attribute. To fix this issue, you need to give a value to the <code>note</code> key. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[deprecated(note = "because")] // ok!
fn i_am_deprecated() {}</pre></div>  <h3 id="E0552" class="section-header">E0552</h3> <p>A unrecognized representation attribute was used.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[repr(D)] // error: unrecognized representation hint
struct MyStruct {
    my_field: usize
}</pre></div> <p>You can use a <code>repr</code> attribute to tell the compiler how you want a struct or enum to be laid out in memory.</p> <p>Make sure you're using one of the supported options:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[repr(C)] // ok!
struct MyStruct {
    my_field: usize
}</pre></div> <p>For more information about specifying representations, see the <a href="https://doc.rust-lang.org/nomicon/other-reprs.html">"Alternative Representations" section</a> of the Rustonomicon.</p>   <h3 id="E0554" class="section-header">E0554</h3> <p>Feature attributes are only allowed on the nightly release channel. Stable or beta compilers will not comply.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">
#![feature(non_ascii_idents)] // error: `#![feature]` may not be used on the
                              //        stable release channel</pre></div> <p>If you need the feature, make sure to use a nightly release of the compiler (but be warned that the feature may be removed or altered in the future).</p>  <h3 id="E0556" class="section-header">E0556</h3> <p>The <code>feature</code> attribute was badly formed.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(foo_bar_baz, foo(bar), foo = "baz", foo)] // error!
#![feature] // error!
#![feature = "foo"] // error!</pre></div> <p>The <code>feature</code> attribute only accept a "feature flag" and can only be used on nightly. Example:</p> <div class="information">ⓘThis example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">
#![feature(flag)]</pre></div>  <h3 id="E0557" class="section-header">E0557</h3> <p>A feature attribute named a feature that has been removed.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(managed_boxes)] // error: feature has been removed</pre></div> <p>Delete the offending feature attribute.</p>  <h3 id="E0559" class="section-header">E0559</h3> <p>An unknown field was specified into an enum's structure variant.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
enum Field {
    Fool { x: u32 },
}

let s = Field::Fool { joke: 0 };
// error: struct variant `Field::Fool` has no field named `joke`</pre></div> <p>Verify you didn't misspell the field's name or that the field exists. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
enum Field {
    Fool { joke: u32 },
}

let s = Field::Fool { joke: 0 }; // ok!</pre></div>  <h3 id="E0560" class="section-header">E0560</h3> <p>An unknown field was specified into a structure.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Simba {
    mother: u32,
}

let s = Simba { mother: 1, father: 0 };
// error: structure `Simba` has no field named `father`</pre></div> <p>Verify you didn't misspell the field's name or that the field exists. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Simba {
    mother: u32,
    father: u32,
}

let s = Simba { mother: 1, father: 0 }; // ok!</pre></div>  <h3 id="E0561" class="section-header">E0561</h3> <p>A non-ident or non-wildcard pattern has been used as a parameter of a function pointer type.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
type A1 = fn(mut param: u8); // error!
type A2 = fn(&amp;param: u32); // error!</pre></div> <p>When using an alias over a function type, you cannot e.g. denote a parameter as being mutable.</p> <p>To fix the issue, remove patterns (<code>_</code> is allowed though). Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
type A1 = fn(param: u8); // ok!
type A2 = fn(_: u32); // ok!</pre></div> <p>You can also omit the parameter name:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
type A3 = fn(i16); // ok!</pre></div>  <h3 id="E0562" class="section-header">E0562</h3> <p>Abstract return types (written <code>impl Trait</code> for some trait <code>Trait</code>) are only allowed as function and inherent impl return types.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn main() {
    let count_to_ten: impl Iterator&lt;Item=usize&gt; = 0..10;
    // error: `impl Trait` not allowed outside of function and inherent method
    //        return types
    for i in count_to_ten {
        println!("{}", i);
    }
}</pre></div> <p>Make sure <code>impl Trait</code> only appears in return-type position.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn count_to_n(n: usize) -&gt; impl Iterator&lt;Item=usize&gt; {
    0..n
}

fn main() {
    for i in count_to_n(10) {  // ok!
        println!("{}", i);
    }
}</pre></div> <p>See <a href="https://github.com/rust-lang/rfcs/blob/master/text/1522-conservative-impl-trait.md">RFC 1522</a> for more details.</p>  <h3 id="E0565" class="section-header">E0565</h3> <p>A literal was used in a built-in attribute that doesn't support literals.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[repr("C")] // error: meta item in `repr` must be an identifier
struct Repr {}

fn main() {}</pre></div> <p>Literals in attributes are new and largely unsupported in built-in attributes. Work to support literals where appropriate is ongoing. Try using an unquoted name instead:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[repr(C)] // ok!
struct Repr {}

fn main() {}</pre></div>  <h3 id="E0566" class="section-header">E0566</h3> <p>Conflicting representation hints have been used on a same item.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[repr(u32, u64)]
enum Repr { A }</pre></div> <p>In most cases (if not all), using just one representation hint is more than enough. If you want to have a representation hint depending on the current architecture, use <code>cfg_attr</code>. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[cfg_attr(linux, repr(u32))]
#[cfg_attr(not(linux), repr(u64))]
enum Repr { A }</pre></div>  <h3 id="E0567" class="section-header">E0567</h3> <p>Generics have been used on an auto trait.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(optin_builtin_traits)]

auto trait Generic&lt;T&gt; {} // error!</pre></div> <p>Since an auto trait is implemented on all existing types, the compiler would not be able to infer the types of the trait's generic parameters.</p> <p>To fix this issue, just remove the generics:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(optin_builtin_traits)]

auto trait Generic {} // ok!</pre></div>  <h3 id="E0568" class="section-header">E0568</h3> <p>A super trait has been added to an auto trait.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(optin_builtin_traits)]

auto trait Bound : Copy {} // error!

fn main() {}</pre></div> <p>Since an auto trait is implemented on all existing types, adding a super trait would filter out a lot of those types. In the current example, almost none of all the existing types could implement <code>Bound</code> because very few of them have the <code>Copy</code> trait.</p> <p>To fix this issue, just remove the super trait:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(optin_builtin_traits)]

auto trait Bound {} // ok!

fn main() {}</pre></div>  <h3 id="E0569" class="section-header">E0569</h3> <p>If an impl has a generic parameter with the <code>#[may_dangle]</code> attribute, then that impl must be declared as an <code>unsafe impl</code>.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(dropck_eyepatch)]

struct Foo&lt;X&gt;(X);
impl&lt;#[may_dangle] X&gt; Drop for Foo&lt;X&gt; {
    fn drop(&amp;mut self) { }
}</pre></div> <p>In this example, we are asserting that the destructor for <code>Foo</code> will not access any data of type <code>X</code>, and require this assertion to be true for overall safety in our program. The compiler does not currently attempt to verify this assertion; therefore we must tag this <code>impl</code> as unsafe.</p>  <h3 id="E0570" class="section-header">E0570</h3> <p>The requested ABI is unsupported by the current target.</p> <p>The rust compiler maintains for each target a list of unsupported ABIs on that target. If an ABI is present in such a list this usually means that the target / ABI combination is currently unsupported by llvm.</p> <p>If necessary, you can circumvent this check using custom target specifications.</p>  <h3 id="E0571" class="section-header">E0571</h3> <p>A <code>break</code> statement with an argument appeared in a non-<code>loop</code> loop.</p> <p>Example of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let result = while true {
    if satisfied(i) {
        break 2 * i; // error: `break` with value from a `while` loop
    }
    i += 1;
};</pre></div> <p>The <code>break</code> statement can take an argument (which will be the value of the loop expression if the <code>break</code> statement is executed) in <code>loop</code> loops, but not <code>for</code>, <code>while</code>, or <code>while let</code> loops.</p> <p>Make sure <code>break value;</code> statements only occur in <code>loop</code> loops:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let result = loop { // This is now a "loop" loop.
    if satisfied(i) {
        break 2 * i; // ok!
    }
    i += 1;
};</pre></div>  <h3 id="E0572" class="section-header">E0572</h3> <p>A return statement was found outside of a function body.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
const FOO: u32 = return 0; // error: return statement outside of function body

fn main() {}</pre></div> <p>To fix this issue, just remove the return keyword or move the expression into a function. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
const FOO: u32 = 0;

fn some_fn() -&gt; u32 {
    return FOO;
}

fn main() {
    some_fn();
}</pre></div>  <h3 id="E0573" class="section-header">E0573</h3> <p>Something other than a type has been used when one was expected.</p> <p>Erroneous code examples:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
enum Dragon {
    Born,
}

fn oblivion() -&gt; Dragon::Born { // error!
    Dragon::Born
}

const HOBBIT: u32 = 2;
impl HOBBIT {} // error!

enum Wizard {
    Gandalf,
    Saruman,
}

trait Isengard {
    fn wizard(_: Wizard::Saruman); // error!
}</pre></div> <p>In all these errors, a type was expected. For example, in the first error, if we want to return the <code>Born</code> variant from the <code>Dragon</code> enum, we must set the function to return the enum and not its variant:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
enum Dragon {
    Born,
}

fn oblivion() -&gt; Dragon { // ok!
    Dragon::Born
}</pre></div> <p>In the second error, you can't implement something on an item, only on types. We would need to create a new type if we wanted to do something similar:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Hobbit(u32); // we create a new type

const HOBBIT: Hobbit = Hobbit(2);
impl Hobbit {} // ok!</pre></div> <p>In the third case, we tried to only expect one variant of the <code>Wizard</code> enum, which is not possible. To make this work, we need to using pattern matching over the <code>Wizard</code> enum:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
enum Wizard {
    Gandalf,
    Saruman,
}

trait Isengard {
    fn wizard(w: Wizard) { // ok!
        match w {
            Wizard::Saruman =&gt; {
                // do something
            }
            _ =&gt; {} // ignore everything else
        }
    }
}</pre></div>  <h3 id="E0574" class="section-header">E0574</h3> <p>Something other than a struct, variant or union has been used when one was expected.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
mod Mordor {}

let sauron = Mordor { x: () }; // error!

enum Jak {
    Daxter { i: isize },
}

let eco = Jak::Daxter { i: 1 };
match eco {
    Jak { i } =&gt; {} // error!
}</pre></div> <p>In all these errors, a type was expected. For example, in the first error, we tried to instantiate the <code>Mordor</code> module, which is impossible. If you want to instantiate a type inside a module, you can do it as follow:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
mod Mordor {
    pub struct TheRing {
        pub x: usize,
    }
}

let sauron = Mordor::TheRing { x: 1 }; // ok!</pre></div> <p>In the second error, we tried to bind the <code>Jak</code> enum directly, which is not possible: you can only bind one of its variants. To do so:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
enum Jak {
    Daxter { i: isize },
}

let eco = Jak::Daxter { i: 1 };
match eco {
    Jak::Daxter { i } =&gt; {} // ok!
}</pre></div>  <h3 id="E0575" class="section-header">E0575</h3> <p>Something other than a type or an associated type was given.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
enum Rick { Morty }

let _: &lt;u8 as Rick&gt;::Morty; // error!

trait Age {
    type Empire;
    fn Mythology() {}
}

impl Age for u8 {
    type Empire = u16;
}

let _: &lt;u8 as Age&gt;::Mythology; // error!</pre></div> <p>In both cases, we're declaring a variable (called <code>_</code>) and we're giving it a type. However, <code>&lt;u8 as Rick&gt;::Morty</code> and <code>&lt;u8 as Age&gt;::Mythology</code> aren't types, therefore the compiler throws an error.</p> <p><code>&lt;u8 as Rick&gt;::Morty</code> is an enum variant, you cannot use a variant as a type, you have to use the enum directly:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
enum Rick { Morty }

let _: Rick; // ok!</pre></div> <p><code>&lt;u8 as Age&gt;::Mythology</code> is a trait method, which is definitely not a type. However, the <code>Age</code> trait provides an associated type <code>Empire</code> which can be used as a type:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Age {
    type Empire;
    fn Mythology() {}
}

impl Age for u8 {
    type Empire = u16;
}

let _: &lt;u8 as Age&gt;::Empire; // ok!</pre></div>  <h3 id="E0576" class="section-header">E0576</h3> <p>An associated item wasn't found in the given type.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Hello {
    type Who;

    fn hello() -&gt; &lt;Self as Hello&gt;::You; // error!
}</pre></div> <p>In this example, we tried to use the non-existent associated type <code>You</code> of the <code>Hello</code> trait. To fix this error, use an existing associated type:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Hello {
    type Who;

    fn hello() -&gt; &lt;Self as Hello&gt;::Who; // ok!
}</pre></div>  <h3 id="E0577" class="section-header">E0577</h3> <p>Something other than a module was found in visibility scope.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
pub struct Sea;

pub (in crate::Sea) struct Shark; // error!

fn main() {}</pre></div> <p><code>Sea</code> is not a module, therefore it is invalid to use it in a visibility path. To fix this error we need to ensure <code>Sea</code> is a module.</p> <p>Please note that the visibility scope can only be applied on ancestors!</p> <div class="information">ⓘThis code runs with edition 2018</div>
<div class="example-wrap"><pre class="rust rust-example-rendered edition " data-language="rust">
pub mod Sea {
    pub (in crate::Sea) struct Shark; // ok!
}

fn main() {}</pre></div>  <h3 id="E0578" class="section-header">E0578</h3> <p>A module cannot be found and therefore, the visibility cannot be determined.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
foo!();

pub (in ::Sea) struct Shark; // error!

fn main() {}</pre></div> <p>Because of the call to the <code>foo</code> macro, the compiler guesses that the missing module could be inside it and fails because the macro definition cannot be found.</p> <p>To fix this error, please be sure that the module is in scope:</p> <div class="information">ⓘThis code runs with edition 2018</div>
<div class="example-wrap"><pre class="rust rust-example-rendered edition " data-language="rust">
pub mod Sea {
    pub (in crate::Sea) struct Shark;
}

fn main() {}</pre></div>  <h3 id="E0579" class="section-header">E0579</h3> <p>A lower range wasn't less than the upper range.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(exclusive_range_pattern)]

fn main() {
    match 5u32 {
        // This range is ok, albeit pointless.
        1 .. 2 =&gt; {}
        // This range is empty, and the compiler can tell.
        5 .. 5 =&gt; {} // error!
    }
}</pre></div> <p>When matching against an exclusive range, the compiler verifies that the range is non-empty. Exclusive range patterns include the start point but not the end point, so this is equivalent to requiring the start of the range to be less than the end of the range.</p>  <h3 id="E0580" class="section-header">E0580</h3> <p>The <code>main</code> function was incorrectly declared.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn main(x: i32) { // error: main function has wrong type
    println!("{}", x);
}</pre></div> <p>The <code>main</code> function prototype should never take arguments. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn main() {
    // your code
}</pre></div> <p>If you want to get command-line arguments, use <code>std::env::args</code>. To exit with a specified exit code, use <code>std::process::exit</code>.</p>  <h3 id="E0581" class="section-header">E0581</h3> <p>In a <code>fn</code> type, a lifetime appears only in the return type and not in the arguments types.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn main() {
    // Here, `'a` appears only in the return type:
    let x: for&lt;'a&gt; fn() -&gt; &amp;'a i32;
}</pre></div> <p>The problem here is that the lifetime isn't contrained by any of the arguments, making it impossible to determine how long it's supposed to live.</p> <p>To fix this issue, either use the lifetime in the arguments, or use the <code>'static</code> lifetime. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn main() {
    // Here, `'a` appears only in the return type:
    let x: for&lt;'a&gt; fn(&amp;'a i32) -&gt; &amp;'a i32;
    let y: fn() -&gt; &amp;'static i32;
}</pre></div> <p>Note: The examples above used to be (erroneously) accepted by the compiler, but this was since corrected. See <a href="https://github.com/rust-lang/rust/issues/33685">issue #33685</a> for more details.</p>  <h3 id="E0582" class="section-header">E0582</h3> <p>A lifetime is only present in an associated-type binding, and not in the input types to the trait.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn bar&lt;F&gt;(t: F)
    // No type can satisfy this requirement, since `'a` does not
    // appear in any of the input types (here, `i32`):
    where F: for&lt;'a&gt; Fn(i32) -&gt; Option&lt;&amp;'a i32&gt;
{
}

fn main() { }</pre></div> <p>To fix this issue, either use the lifetime in the inputs, or use <code>'static</code>. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn bar&lt;F, G&gt;(t: F, u: G)
    where F: for&lt;'a&gt; Fn(&amp;'a i32) -&gt; Option&lt;&amp;'a i32&gt;,
          G: Fn(i32) -&gt; Option&lt;&amp;'static i32&gt;,
{
}

fn main() { }</pre></div> <p>Note: The examples above used to be (erroneously) accepted by the compiler, but this was since corrected. See <a href="https://github.com/rust-lang/rust/issues/33685">issue #33685</a> for more details.</p>  <h3 id="E0583" class="section-header">E0583</h3> <p>A file wasn't found for an out-of-line module.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
mod file_that_doesnt_exist; // error: file not found for module

fn main() {}</pre></div> <p>Please be sure that a file corresponding to the module exists. If you want to use a module named <code>file_that_doesnt_exist</code>, you need to have a file named <code>file_that_doesnt_exist.rs</code> or <code>file_that_doesnt_exist/mod.rs</code> in the same directory.</p>  <h3 id="E0584" class="section-header">E0584</h3> <p>A doc comment that is not attached to anything has been encountered.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Island {
    fn lost();

    /// I'm lost!
}</pre></div> <p>A little reminder: a doc comment has to be placed before the item it's supposed to document. So if you want to document the <code>Island</code> trait, you need to put a doc comment before it, not inside it. Same goes for the <code>lost</code> method: the doc comment needs to be before it:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
/// I'm THE island!
trait Island {
    /// I'm lost!
    fn lost();
}</pre></div>  <h3 id="E0585" class="section-header">E0585</h3> <p>A documentation comment that doesn't document anything was found.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn main() {
    // The following doc comment will fail:
    /// This is a useless doc comment!
}</pre></div> <p>Documentation comments need to be followed by items, including functions, types, modules, etc. Examples:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
/// I'm documenting the following struct:
struct Foo;

/// I'm documenting the following function:
fn foo() {}</pre></div>  <h3 id="E0586" class="section-header">E0586</h3> <p>An inclusive range was used with no end.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn main() {
    let tmp = vec![0, 1, 2, 3, 4, 4, 3, 3, 2, 1];
    let x = &amp;tmp[1..=]; // error: inclusive range was used with no end
}</pre></div> <p>An inclusive range needs an end in order to <em>include</em> it. If you just need a start and no end, use a non-inclusive range (with <code>..</code>):</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn main() {
    let tmp = vec![0, 1, 2, 3, 4, 4, 3, 3, 2, 1];
    let x = &amp;tmp[1..]; // ok!
}</pre></div> <p>Or put an end to your inclusive range:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn main() {
    let tmp = vec![0, 1, 2, 3, 4, 4, 3, 3, 2, 1];
    let x = &amp;tmp[1..=3]; // ok!
}</pre></div>  <h3 id="E0587" class="section-header">E0587</h3> <p>A type has both <code>packed</code> and <code>align</code> representation hints.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[repr(packed, align(8))] // error!
struct Umbrella(i32);</pre></div> <p>You cannot use <code>packed</code> and <code>align</code> hints on a same type. If you want to pack a type to a given size, you should provide a size to packed:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[repr(packed)] // ok!
struct Umbrella(i32);</pre></div>  <h3 id="E0588" class="section-header">E0588</h3> <p>A type with <code>packed</code> representation hint has a field with <code>align</code> representation hint.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[repr(align(16))]
struct Aligned(i32);

#[repr(packed)] // error!
struct Packed(Aligned);</pre></div> <p>Just like you cannot have both <code>align</code> and <code>packed</code> representation hints on a same type, a <code>packed</code> type cannot contain another type with the <code>align</code> representation hint. However, you can do the opposite:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[repr(packed)]
struct Packed(i32);

#[repr(align(16))] // ok!
struct Aligned(Packed);</pre></div>  <h3 id="E0589" class="section-header">E0589</h3> <p>The value of <code>N</code> that was specified for <code>repr(align(N))</code> was not a power of two, or was greater than 2^29.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[repr(align(15))] // error: invalid `repr(align)` attribute: not a power of two
enum Foo {
    Bar(u64),
}</pre></div>  <h3 id="E0590" class="section-header">E0590</h3> <p><code>break</code> or <code>continue</code> keywords were used in a condition of a <code>while</code> loop without a label.</p> <p>Erroneous code code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
while break {}</pre></div> <p><code>break</code> or <code>continue</code> must include a label when used in the condition of a <code>while</code> loop.</p> <p>To fix this, add a label specifying which loop is being broken out of:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
'foo: while break 'foo {}</pre></div>  <h3 id="E0591" class="section-header">E0591</h3> <p>Per <a href="https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md">RFC 401</a>, if you have a function declaration <code>foo</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
// For the purposes of this explanation, all of these
// different kinds of `fn` declarations are equivalent:
struct S;
fn foo(x: S) { /* ... */ }
extern "C" { fn foo(x: S); }
impl S { fn foo(self) { /* ... */ } }</pre></div> <p>the type of <code>foo</code> is <strong>not</strong> <code>fn(S)</code>, as one might expect. Rather, it is a unique, zero-sized marker type written here as <code>typeof(foo)</code>. However, <code>typeof(foo)</code> can be <em>coerced</em> to a function pointer <code>fn(S)</code>, so you rarely notice this:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x: fn(S) = foo; // OK, coerces</pre></div> <p>The reason that this matter is that the type <code>fn(S)</code> is not specific to any particular function: it's a function <em>pointer</em>. So calling <code>x()</code> results in a virtual call, whereas <code>foo()</code> is statically dispatched, because the type of <code>foo</code> tells us precisely what function is being called.</p> <p>As noted above, coercions mean that most code doesn't have to be concerned with this distinction. However, you can tell the difference when using <strong>transmute</strong> to convert a fn item into a fn pointer.</p> <p>This is sometimes done as part of an FFI:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
extern "C" fn foo(userdata: Box&lt;i32&gt;) {
    /* ... */
}

let f: extern "C" fn(*mut i32) = transmute(foo);
callback(f);</pre></div> <p>Here, transmute is being used to convert the types of the fn arguments. This pattern is incorrect because, because the type of <code>foo</code> is a function <strong>item</strong> (<code>typeof(foo)</code>), which is zero-sized, and the target type (<code>fn()</code>) is a function pointer, which is not zero-sized. This pattern should be rewritten. There are a few possible ways to do this:</p> <ul> <li> <p>change the original fn declaration to match the expected signature, and do the cast in the fn body (the preferred option)</p> </li> <li> <p>cast the fn item of a fn pointer before calling transmute, as shown here:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let f: extern "C" fn(*mut i32) = transmute(foo as extern "C" fn(_));
let f: extern "C" fn(*mut i32) = transmute(foo as usize); // works too</pre></div> </li> </ul> <p>The same applies to transmutes to <code>*mut fn()</code>, which were observed in practice. Note though that use of this type is generally incorrect. The intention is typically to describe a function pointer, but just <code>fn()</code> alone suffices for that. <code>*mut fn()</code> is a pointer to a fn pointer. (Since these values are typically just passed to C code, however, this rarely makes a difference in practice.)</p>  <h3 id="E0592" class="section-header">E0592</h3> <p>This error occurs when you defined methods or associated functions with same name.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo;

impl Foo {
    fn bar() {} // previous definition here
}

impl Foo {
    fn bar() {} // duplicate definition here
}</pre></div> <p>A similar error is E0201. The difference is whether there is one declaration block or not. To avoid this error, you must give each <code>fn</code> a unique name.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo;

impl Foo {
    fn bar() {}
}

impl Foo {
    fn baz() {} // define with different name
}</pre></div>  <h3 id="E0593" class="section-header">E0593</h3> <p>You tried to supply an <code>Fn</code>-based type with an incorrect number of arguments than what was expected.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn foo&lt;F: Fn()&gt;(x: F) { }

fn main() {
    // [E0593] closure takes 1 argument but 0 arguments are required
    foo(|y| { });
}</pre></div> <p>You have to provide the same number of arguments as expected by the <code>Fn</code>-based type. So to fix the previous example, we need to remove the <code>y</code> argument:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo&lt;F: Fn()&gt;(x: F) { }

fn main() {
    foo(|| { }); // ok!
}</pre></div>  <h3 id="E0594" class="section-header">E0594</h3> <p>A non-mutable value was assigned a value.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct SolarSystem {
    earth: i32,
}

let ss = SolarSystem { earth: 3 };
ss.earth = 2; // error!</pre></div> <p>To fix this error, declare <code>ss</code> as mutable by using the <code>mut</code> keyword:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct SolarSystem {
    earth: i32,
}

let mut ss = SolarSystem { earth: 3 }; // declaring `ss` as mutable
ss.earth = 2; // ok!</pre></div>  <h3 id="E0595" class="section-header">E0595</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-39" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>Closures cannot mutate immutable captured variables.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let x = 3; // error: closure cannot assign to immutable local variable `x`
let mut c = || { x += 1 };</pre></div> <p>Make the variable binding mutable:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut x = 3; // ok!
let mut c = || { x += 1 };</pre></div>  <h3 id="E0596" class="section-header">E0596</h3> <p>This error occurs because you tried to mutably borrow a non-mutable variable.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let x = 1;
let y = &amp;mut x; // error: cannot borrow mutably</pre></div> <p>In here, <code>x</code> isn't mutable, so when we try to mutably borrow it in <code>y</code>, it fails. To fix this error, you need to make <code>x</code> mutable:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut x = 1;
let y = &amp;mut x; // ok!</pre></div>  <h3 id="E0597" class="section-header">E0597</h3> <p>This error occurs because a value was dropped while it was still borrowed</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo&lt;'a&gt; {
    x: Option&lt;&amp;'a u32&gt;,
}

let mut x = Foo { x: None };
{
    let y = 0;
    x.x = Some(&amp;y); // error: `y` does not live long enough
}
println!("{:?}", x.x);</pre></div> <p>In here, <code>y</code> is dropped at the end of the inner scope, but it is borrowed by <code>x</code> until the <code>println</code>. To fix the previous example, just remove the scope so that <code>y</code> isn't dropped until after the println</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo&lt;'a&gt; {
    x: Option&lt;&amp;'a u32&gt;,
}

let mut x = Foo { x: None };

let y = 0;
x.x = Some(&amp;y);

println!("{:?}", x.x);</pre></div>  <h3 id="E0599" class="section-header">E0599</h3> <p>This error occurs when a method is used on a type which doesn't implement it:</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Mouth;

let x = Mouth;
x.chocolate(); // error: no method named `chocolate` found for type `Mouth`
               //        in the current scope</pre></div> <p>In this case, you need to implement the <code>chocolate</code> method to fix the error:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Mouth;

impl Mouth {
    fn chocolate(&amp;self) { // We implement the `chocolate` method here.
        println!("Hmmm! I love chocolate!");
    }
}

let x = Mouth;
x.chocolate(); // ok!</pre></div>  <h3 id="E0600" class="section-header">E0600</h3> <p>An unary operator was used on a type which doesn't implement it.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
enum Question {
    Yes,
    No,
}

!Question::Yes; // error: cannot apply unary operator `!` to type `Question`</pre></div> <p>In this case, <code>Question</code> would need to implement the <code>std::ops::Not</code> trait in order to be able to use <code>!</code> on it. Let's implement it:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::ops::Not;

enum Question {
    Yes,
    No,
}

// We implement the `Not` trait on the enum.
impl Not for Question {
    type Output = bool;

    fn not(self) -&gt; bool {
        match self {
            Question::Yes =&gt; false, // If the `Answer` is `Yes`, then it
                                    // returns false.
            Question::No =&gt; true, // And here we do the opposite.
        }
    }
}

assert_eq!(!Question::Yes, false);
assert_eq!(!Question::No, true);</pre></div>  <h3 id="E0601" class="section-header">E0601</h3> <p>No <code>main</code> function was found in a binary crate.</p> <p>To fix this error, add a <code>main</code> function:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn main() {
    // Your program will start here.
    println!("Hello world!");
}</pre></div> <p>If you don't know the basics of Rust, you can look at the <a href="index">Rust Book</a> to get started.</p>  <h3 id="E0602" class="section-header">E0602</h3> <p>An unknown lint was used on the command line.</p> <p>Erroneous code example:</p> <pre>rustc -D bogus rust_file.rs
</pre> <p>Maybe you just misspelled the lint name or the lint doesn't exist anymore. Either way, try to update/remove it in order to fix the error.</p>  <h3 id="E0603" class="section-header">E0603</h3> <p>A private item was used outside its scope.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
mod SomeModule {
    const PRIVATE: u32 = 0x_a_bad_1dea_u32; // This const is private, so we
                                            // can't use it outside of the
                                            // `SomeModule` module.
}

println!("const value: {}", SomeModule::PRIVATE); // error: constant `PRIVATE`
                                                  //        is private</pre></div> <p>In order to fix this error, you need to make the item public by using the <code>pub</code> keyword. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
mod SomeModule {
    pub const PRIVATE: u32 = 0x_a_bad_1dea_u32; // We set it public by using the
                                                // `pub` keyword.
}

println!("const value: {}", SomeModule::PRIVATE); // ok!</pre></div>  <h3 id="E0604" class="section-header">E0604</h3> <p>A cast to <code>char</code> was attempted on a type other than <code>u8</code>.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
0u32 as char; // error: only `u8` can be cast as `char`, not `u32`</pre></div> <p>As the error message indicates, only <code>u8</code> can be cast into <code>char</code>. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let c = 86u8 as char; // ok!
assert_eq!(c, 'V');</pre></div> <p>For more information about casts, take a look at the Type cast section in <a href="reference/expressions/operator-expr#type-cast-expressions">The Reference Book</a>.</p>  <h3 id="E0605" class="section-header">E0605</h3> <p>An invalid cast was attempted.</p> <p>Erroneous code examples:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let x = 0u8;
x as Vec&lt;u8&gt;; // error: non-primitive cast: `u8` as `std::vec::Vec&lt;u8&gt;`

// Another example

let v = core::ptr::null::&lt;u8&gt;(); // So here, `v` is a `*const u8`.
v as &amp;u8; // error: non-primitive cast: `*const u8` as `&amp;u8`</pre></div> <p>Only primitive types can be cast into each other. Examples:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x = 0u8;
x as u32; // ok!

let v = core::ptr::null::&lt;u8&gt;();
v as *const i8; // ok!</pre></div> <p>For more information about casts, take a look at the Type cast section in <a href="reference/expressions/operator-expr#type-cast-expressions">The Reference Book</a>.</p>  <h3 id="E0606" class="section-header">E0606</h3> <p>An incompatible cast was attempted.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let x = &amp;0u8; // Here, `x` is a `&amp;u8`.
let y: u32 = x as u32; // error: casting `&amp;u8` as `u32` is invalid</pre></div> <p>When casting, keep in mind that only primitive types can be cast into each other. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x = &amp;0u8;
let y: u32 = *x as u32; // We dereference it first and then cast it.</pre></div> <p>For more information about casts, take a look at the Type cast section in <a href="reference/expressions/operator-expr#type-cast-expressions">The Reference Book</a>.</p>  <h3 id="E0607" class="section-header">E0607</h3> <p>A cast between a thin and a fat pointer was attempted.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let v = core::ptr::null::&lt;u8&gt;();
v as *const [u8];</pre></div> <p>First: what are thin and fat pointers?</p> <p>Thin pointers are "simple" pointers: they are purely a reference to a memory address.</p> <p>Fat pointers are pointers referencing Dynamically Sized Types (also called DST). DST don't have a statically known size, therefore they can only exist behind some kind of pointers that contain additional information. Slices and trait objects are DSTs. In the case of slices, the additional information the fat pointer holds is their size.</p> <p>To fix this error, don't try to cast directly between thin and fat pointers.</p> <p>For more information about casts, take a look at the Type cast section in <a href="reference/expressions/operator-expr#type-cast-expressions">The Reference Book</a>.</p>  <h3 id="E0608" class="section-header">E0608</h3> <p>An attempt to use index on a type which doesn't implement the <code>std::ops::Index</code> trait was performed.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
0u8[2]; // error: cannot index into a value of type `u8`</pre></div> <p>To be able to index into a type it needs to implement the <code>std::ops::Index</code> trait. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let v: Vec&lt;u8&gt; = vec![0, 1, 2, 3];

// The `Vec` type implements the `Index` trait so you can do:
println!("{}", v[2]);</pre></div>  <h3 id="E0609" class="section-header">E0609</h3> <p>Attempted to access a non-existent field in a struct.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct StructWithFields {
    x: u32,
}

let s = StructWithFields { x: 0 };
println!("{}", s.foo); // error: no field `foo` on type `StructWithFields`</pre></div> <p>To fix this error, check that you didn't misspell the field's name or that the field actually exists. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct StructWithFields {
    x: u32,
}

let s = StructWithFields { x: 0 };
println!("{}", s.x); // ok!</pre></div>  <h3 id="E0610" class="section-header">E0610</h3> <p>Attempted to access a field on a primitive type.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let x: u32 = 0;
println!("{}", x.foo); // error: `{integer}` is a primitive type, therefore
                       //        doesn't have fields</pre></div> <p>Primitive types are the most basic types available in Rust and don't have fields. To access data via named fields, struct types are used. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
// We declare struct called `Foo` containing two fields:
struct Foo {
    x: u32,
    y: i64,
}

// We create an instance of this struct:
let variable = Foo { x: 0, y: -12 };
// And we can now access its fields:
println!("x: {}, y: {}", variable.x, variable.y);</pre></div> <p>For more information about <a href="book/ch03-02-data-types">primitives</a> and <a href="book/ch05-00-structs">structs</a>, take a look at the Book.</p>  <h3 id="E0614" class="section-header">E0614</h3> <p>Attempted to dereference a variable which cannot be dereferenced.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let y = 0u32;
*y; // error: type `u32` cannot be dereferenced</pre></div> <p>Only types implementing <code>std::ops::Deref</code> can be dereferenced (such as <code>&amp;T</code>). Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let y = 0u32;
let x = &amp;y;
// So here, `x` is a `&amp;u32`, so we can dereference it:
*x; // ok!</pre></div>  <h3 id="E0615" class="section-header">E0615</h3> <p>Attempted to access a method like a field.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo {
    x: u32,
}

impl Foo {
    fn method(&amp;self) {}
}

let f = Foo { x: 0 };
f.method; // error: attempted to take value of method `method` on type `Foo`</pre></div> <p>If you want to use a method, add <code>()</code> after it:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
f.method();</pre></div> <p>However, if you wanted to access a field of a struct check that the field name is spelled correctly. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
println!("{}", f.x);</pre></div>  <h3 id="E0616" class="section-header">E0616</h3> <p>Attempted to access a private field on a struct.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
mod some_module {
    pub struct Foo {
        x: u32, // So `x` is private in here.
    }

    impl Foo {
        pub fn new() -&gt; Foo { Foo { x: 0 } }
    }
}

let f = some_module::Foo::new();
println!("{}", f.x); // error: field `x` of struct `some_module::Foo` is private</pre></div> <p>If you want to access this field, you have two options:</p> <ol> <li>Set the field public:</li> </ol> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
mod some_module {
    pub struct Foo {
        pub x: u32, // `x` is now public.
    }

    impl Foo {
        pub fn new() -&gt; Foo { Foo { x: 0 } }
    }
}

let f = some_module::Foo::new();
println!("{}", f.x); // ok!</pre></div> <ol start="2"> <li>Add a getter function:</li> </ol> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
mod some_module {
    pub struct Foo {
        x: u32, // So `x` is still private in here.
    }

    impl Foo {
        pub fn new() -&gt; Foo { Foo { x: 0 } }

        // We create the getter function here:
        pub fn get_x(&amp;self) -&gt; &amp;u32 { &amp;self.x }
    }
}

let f = some_module::Foo::new();
println!("{}", f.get_x()); // ok!</pre></div>  <h3 id="E0617" class="section-header">E0617</h3> <p>Attempted to pass an invalid type of variable into a variadic function.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
extern {
    fn printf(c: *const i8, ...);
}

unsafe {
    printf(::std::ptr::null(), 0f32);
    // error: cannot pass an `f32` to variadic function, cast to `c_double`
}</pre></div> <p>Certain Rust types must be cast before passing them to a variadic function, because of arcane ABI rules dictated by the C standard. To fix the error, cast the value to the type specified by the error message (which you may need to import from <code>std::os::raw</code>).</p> <p>In this case, <code>c_double</code> has the same size as <code>f64</code> so we can use it directly:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
unsafe {
    printf(::std::ptr::null(), 0f64); // ok!
}</pre></div>  <h3 id="E0618" class="section-header">E0618</h3> <p>Attempted to call something which isn't a function nor a method.</p> <p>Erroneous code examples:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
enum X {
    Entry,
}

X::Entry(); // error: expected function, tuple struct or tuple variant,
            // found `X::Entry`

// Or even simpler:
let x = 0i32;
x(); // error: expected function, tuple struct or tuple variant, found `i32`</pre></div> <p>Only functions and methods can be called using <code>()</code>. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
// We declare a function:
fn i_am_a_function() {}

// And we call it:
i_am_a_function();</pre></div>  <h3 id="E0619" class="section-header">E0619</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-40" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>The type-checker needed to know the type of an expression, but that type had not yet been inferred.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let mut x = vec![];
match x.pop() {
    Some(v) =&gt; {
        // Here, the type of `v` is not (yet) known, so we
        // cannot resolve this method call:
        v.to_uppercase(); // error: the type of this value must be known in
                          //        this context
    }
    None =&gt; {}
}</pre></div> <p>Type inference typically proceeds from the top of the function to the bottom, figuring out types as it goes. In some cases -- notably method calls and overloadable operators like <code>*</code> -- the type checker may not have enough information <em>yet</em> to make progress. This can be true even if the rest of the function provides enough context (because the type-checker hasn't looked that far ahead yet). In this case, type annotations can be used to help it along.</p> <p>To fix this error, just specify the type of the variable. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut x: Vec&lt;String&gt; = vec![]; // We precise the type of the vec elements.
match x.pop() {
    Some(v) =&gt; {
        v.to_uppercase(); // Since rustc now knows the type of the vec elements,
                          // we can use `v`'s methods.
    }
    None =&gt; {}
}</pre></div>  <h3 id="E0620" class="section-header">E0620</h3> <p>A cast to an unsized type was attempted.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let x = &amp;[1_usize, 2] as [usize]; // error: cast to unsized type: `&amp;[usize; 2]`
                                  //        as `[usize]`</pre></div> <p>In Rust, some types don't have a known size at compile-time. For example, in a slice type like <code>[u32]</code>, the number of elements is not known at compile-time and hence the overall size cannot be computed. As a result, such types can only be manipulated through a reference (e.g., <code>&amp;T</code> or <code>&amp;mut T</code>) or other pointer-type (e.g., <code>Box</code> or <code>Rc</code>). Try casting to a reference instead:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x = &amp;[1_usize, 2] as &amp;[usize]; // ok!</pre></div>  <h3 id="E0621" class="section-header">E0621</h3> <p>This error code indicates a mismatch between the lifetimes appearing in the function signature (i.e., the parameter types and the return type) and the data-flow found in the function body.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn foo&lt;'a&gt;(x: &amp;'a i32, y: &amp;i32) -&gt; &amp;'a i32 { // error: explicit lifetime
                                             //        required in the type of
                                             //        `y`
    if x &gt; y { x } else { y }
}</pre></div> <p>In the code above, the function is returning data borrowed from either <code>x</code> or <code>y</code>, but the <code>'a</code> annotation indicates that it is returning data only from <code>x</code>. To fix the error, the signature and the body must be made to match. Typically, this is done by updating the function signature. So, in this case, we change the type of <code>y</code> to <code>&amp;'a i32</code>, like so:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo&lt;'a&gt;(x: &amp;'a i32, y: &amp;'a i32) -&gt; &amp;'a i32 {
    if x &gt; y { x } else { y }
}</pre></div> <p>Now the signature indicates that the function data borrowed from either <code>x</code> or <code>y</code>. Alternatively, you could change the body to not return data from <code>y</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo&lt;'a&gt;(x: &amp;'a i32, y: &amp;i32) -&gt; &amp;'a i32 {
    x
}</pre></div>  <h3 id="E0622" class="section-header">E0622</h3> <p>An intrinsic was declared without being a function.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(intrinsics)]
extern "rust-intrinsic" {
    pub static breakpoint : fn(); // error: intrinsic must be a function
}

fn main() { unsafe { breakpoint(); } }</pre></div> <p>An intrinsic is a function available for use in a given programming language whose implementation is handled specially by the compiler. In order to fix this error, just declare a function. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(intrinsics)]
extern "rust-intrinsic" {
    pub fn breakpoint(); // ok!
}

fn main() { unsafe { breakpoint(); } }</pre></div>  <h3 id="E0623" class="section-header">E0623</h3> <p>A lifetime didn't match what was expected.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo&lt;'a&gt; {
    x: &amp;'a isize,
}

fn bar&lt;'short, 'long&gt;(c: Foo&lt;'short&gt;, l: &amp;'long isize) {
    let _: Foo&lt;'long&gt; = c; // error!
}</pre></div> <p>In this example, we tried to set a value with an incompatible lifetime to another one (<code>'long</code> is unrelated to <code>'short</code>). We can solve this issue in two different ways:</p> <p>Either we make <code>'short</code> live at least as long as <code>'long</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo&lt;'a&gt; {
    x: &amp;'a isize,
}

// we set 'short to live at least as long as 'long
fn bar&lt;'short: 'long, 'long&gt;(c: Foo&lt;'short&gt;, l: &amp;'long isize) {
    let _: Foo&lt;'long&gt; = c; // ok!
}</pre></div> <p>Or we use only one lifetime:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo&lt;'a&gt; {
    x: &amp;'a isize,
}
fn bar&lt;'short&gt;(c: Foo&lt;'short&gt;, l: &amp;'short isize) {
    let _: Foo&lt;'short&gt; = c; // ok!
}</pre></div>  <h3 id="E0624" class="section-header">E0624</h3> <p>A private item was used outside of its scope.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
mod inner {
    pub struct Foo;

    impl Foo {
        fn method(&amp;self) {}
    }
}

let foo = inner::Foo;
foo.method(); // error: method `method` is private</pre></div> <p>Two possibilities are available to solve this issue:</p> <ol> <li>Only use the item in the scope it has been defined:</li> </ol> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
mod inner {
    pub struct Foo;

    impl Foo {
        fn method(&amp;self) {}
    }

    pub fn call_method(foo: &amp;Foo) { // We create a public function.
        foo.method(); // Which calls the item.
    }
}

let foo = inner::Foo;
inner::call_method(&amp;foo); // And since the function is public, we can call the
                          // method through it.</pre></div> <ol start="2"> <li>Make the item public:</li> </ol> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
mod inner {
    pub struct Foo;

    impl Foo {
        pub fn method(&amp;self) {} // It's now public.
    }
}

let foo = inner::Foo;
foo.method(); // Ok!</pre></div>   <h3 id="E0626" class="section-header">E0626</h3> <p>This error occurs because a borrow in a generator persists across a yield point.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let mut b = || {
    let a = &amp;String::new(); // &lt;-- This borrow...
    yield (); // ...is still in scope here, when the yield occurs.
    println!("{}", a);
};
Pin::new(&amp;mut b).resume(());</pre></div> <p>At present, it is not permitted to have a yield that occurs while a borrow is still in scope. To resolve this error, the borrow must either be "contained" to a smaller scope that does not overlap the yield or else eliminated in another way. So, for example, we might resolve the previous example by removing the borrow and just storing the integer by value:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut b = || {
    let a = 3;
    yield ();
    println!("{}", a);
};
Pin::new(&amp;mut b).resume(());</pre></div> <p>This is a very simple case, of course. In more complex cases, we may wish to have more than one reference to the value that was borrowed -- in those cases, something like the <code>Rc</code> or <code>Arc</code> types may be useful.</p> <p>This error also frequently arises with iteration:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let mut b = || {
  let v = vec![1,2,3];
  for &amp;x in &amp;v { // &lt;-- borrow of `v` is still in scope...
    yield x; // ...when this yield occurs.
  }
};
Pin::new(&amp;mut b).resume(());</pre></div> <p>Such cases can sometimes be resolved by iterating "by value" (or using <code>into_iter()</code>) to avoid borrowing:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut b = || {
  let v = vec![1,2,3];
  for x in v { // &lt;-- Take ownership of the values instead!
    yield x; // &lt;-- Now yield is OK.
  }
};
Pin::new(&amp;mut b).resume(());</pre></div> <p>If taking ownership is not an option, using indices can work too:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut b = || {
  let v = vec![1,2,3];
  let len = v.len(); // (*)
  for i in 0..len {
    let x = v[i]; // (*)
    yield x; // &lt;-- Now yield is OK.
  }
};
Pin::new(&amp;mut b).resume(());

// (*) -- Unfortunately, these temporaries are currently required.
// See &lt;https://github.com/rust-lang/rust/issues/43122&gt;.</pre></div>  <h3 id="E0627" class="section-header">E0627</h3> <p>A yield expression was used outside of the generator literal.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(generators, generator_trait)]

fn fake_generator() -&gt; &amp;'static str {
    yield 1;
    return "foo"
}

fn main() {
    let mut generator = fake_generator;
}</pre></div> <p>The error occurs because keyword <code>yield</code> can only be used inside the generator literal. This can be fixed by constructing the generator correctly.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(generators, generator_trait)]

fn main() {
    let mut generator = || {
        yield 1;
        return "foo"
    };
}</pre></div>  <h3 id="E0628" class="section-header">E0628</h3> <p>More than one parameter was used for a generator.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(generators, generator_trait)]

fn main() {
    let generator = |a: i32, b: i32| {
        // error: too many parameters for a generator
        // Allowed only 0 or 1 parameter
        yield a;
    };
}</pre></div> <p>At present, it is not permitted to pass more than one explicit parameter for a generator.This can be fixed by using at most 1 parameter for the generator. For example, we might resolve the previous example by passing only one parameter.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(generators, generator_trait)]

fn main() {
    let generator = |a: i32| {
        yield a;
    };
}</pre></div>    <h3 id="E0631" class="section-header">E0631</h3> <p>This error indicates a type mismatch in closure arguments.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn foo&lt;F: Fn(i32)&gt;(f: F) {
}

fn main() {
    foo(|x: &amp;str| {});
}</pre></div> <p>The error occurs because <code>foo</code> accepts a closure that takes an <code>i32</code> argument, but in <code>main</code>, it is passed a closure with a <code>&amp;str</code> argument.</p> <p>This can be resolved by changing the type annotation or removing it entirely if it can be inferred.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo&lt;F: Fn(i32)&gt;(f: F) {
}

fn main() {
    foo(|x: i32| {});
}</pre></div>   <h3 id="E0633" class="section-header">E0633</h3> <p>The <code>unwind</code> attribute was malformed.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(unwind_attributes)]

#[unwind()] // error: expected one argument
pub extern fn something() {}

fn main() {}</pre></div> <p>The <code>#[unwind]</code> attribute should be used as follows:</p> <ul> <li> <p><code>#[unwind(aborts)]</code> -- specifies that if a non-Rust ABI function should abort the process if it attempts to unwind. This is the safer and preferred option.</p> </li> <li> <p><code>#[unwind(allowed)]</code> -- specifies that a non-Rust ABI function should be allowed to unwind. This can easily result in Undefined Behavior (UB), so be careful.</p> </li> </ul> <p>NB. The default behavior here is "allowed", but this is unspecified and likely to change in the future.</p>  <h3 id="E0634" class="section-header">E0634</h3> <p>A type has conflicting <code>packed</code> representation hints.</p> <p>Erroneous code examples:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[repr(packed, packed(2))] // error!
struct Company(i32);

#[repr(packed(2))] // error!
#[repr(packed)]
struct Company(i32);</pre></div> <p>You cannot use conflicting <code>packed</code> hints on a same type. If you want to pack a type to a given size, you should provide a size to packed:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[repr(packed)] // ok!
struct Company(i32);</pre></div>  <h3 id="E0635" class="section-header">E0635</h3> <p>The <code>#![feature]</code> attribute specified an unknown feature.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(nonexistent_rust_feature)] // error: unknown feature</pre></div>  <h3 id="E0636" class="section-header">E0636</h3> <p>A <code>#![feature]</code> attribute was declared multiple times.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![allow(stable_features)]
#![feature(rust1)]
#![feature(rust1)] // error: the feature `rust1` has already been declared</pre></div>  <h3 id="E0637" class="section-header">E0637</h3> <p>An underscore <code>_</code> character has been used as the identifier for a lifetime.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn longest&lt;'_&gt;(str1: &amp;'_ str, str2: &amp;'_ str) -&gt; &amp;'_ str {
         //^^ `'_` is a reserved lifetime name
    if str1.len() &gt; str2.len() {
        str1
    } else {
        str2
    }
}</pre></div> <p><code>'_</code>, cannot be used as a lifetime identifier because it is a reserved for the anonymous lifetime. To fix this, use a lowercase letter such as 'a, or a series of lowercase letters such as <code>'foo</code>. For more information, see <a href="book/appendix-02-operators#non-operator-symbols">the book</a>. For more information on using the anonymous lifetime in rust nightly, see <a href="https://doc.rust-lang.org/nightly/edition-guide/rust-2018/ownership-and-lifetimes/the-anonymous-lifetime.html">the nightly book</a>.</p> <p>Corrected example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn longest&lt;'a&gt;(str1: &amp;'a str, str2: &amp;'a str) -&gt; &amp;'a str {
    if str1.len() &gt; str2.len() {
        str1
    } else {
        str2
    }
}</pre></div>  <h3 id="E0638" class="section-header">E0638</h3> <p>This error indicates that the struct, enum or enum variant must be matched non-exhaustively as it has been marked as <code>non_exhaustive</code>.</p> <p>When applied within a crate, downstream users of the crate will need to use the <code>_</code> pattern when matching enums and use the <code>..</code> pattern when matching structs. Downstream crates cannot match against non-exhaustive enum variants.</p> <p>For example, in the below example, since the enum is marked as <code>non_exhaustive</code>, it is required that downstream crates match non-exhaustively on it.</p> <div class="information">ⓘThis example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">
#[non_exhaustive]
pub enum Error {
    Message(String),
    Other,
}

impl Display for Error {
    fn fmt(&amp;self, formatter: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // This will not error, despite being marked as non_exhaustive, as this
        // enum is defined within the current crate, it can be matched
        // exhaustively.
        let display = match self {
            Message(s) =&gt; s,
            Other =&gt; "other or unknown error",
        };
        formatter.write_str(display)
    }
}</pre></div> <p>An example of matching non-exhaustively on the above enum is provided below:</p> <div class="information">ⓘThis example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">
use mycrate::Error;

// This will not error as the non_exhaustive Error enum has been matched with a
// wildcard.
match error {
    Message(s) =&gt; ...,
    Other =&gt; ...,
    _ =&gt; ...,
}</pre></div> <p>Similarly, for structs, match with <code>..</code> to avoid this error.</p>  <h3 id="E0639" class="section-header">E0639</h3> <p>This error indicates that the struct, enum or enum variant cannot be instantiated from outside of the defining crate as it has been marked as <code>non_exhaustive</code> and as such more fields/variants may be added in future that could cause adverse side effects for this code.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">
#[non_exhaustive]
pub struct NormalStruct {
    pub first_field: u16,
    pub second_field: u16,
}

let ns = NormalStruct { first_field: 640, second_field: 480 }; // error!</pre></div> <p>It is recommended that you look for a <code>new</code> function or equivalent in the crate's documentation.</p>   <h3 id="E0641" class="section-header">E0641</h3> <p>Attempted to cast to/from a pointer with an unknown kind.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let b = 0 as *const _; // error</pre></div> <p>Type information must be provided if a pointer type being cast from/into another type which cannot be inferred:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
// Creating a pointer from reference: type can be inferred
let a = &amp;(String::from("Hello world!")) as *const _; // ok!

let b = 0 as *const i32; // ok!

let c: *const i32 = 0 as *const _; // ok!</pre></div>  <h3 id="E0642" class="section-header">E0642</h3> <p>Trait methods currently cannot take patterns as arguments.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Foo {
    fn foo((x, y): (i32, i32)); // error: patterns aren't allowed
                                //        in trait methods
}</pre></div> <p>You can instead use a single name for the argument:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    fn foo(x_and_y: (i32, i32)); // ok!
}</pre></div>  <h3 id="E0643" class="section-header">E0643</h3> <p>This error indicates that there is a mismatch between generic parameters and impl Trait parameters in a trait declaration versus its impl.</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Foo {
    fn foo(&amp;self, _: &amp;impl Iterator);
}
impl Foo for () {
    fn foo&lt;U: Iterator&gt;(&amp;self, _: &amp;U) { } // error method `foo` has incompatible
                                          // signature for trait
}</pre></div>  <h3 id="E0644" class="section-header">E0644</h3> <p>A closure or generator was constructed that references its own type.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn fix&lt;F&gt;(f: &amp;F)
  where F: Fn(&amp;F)
{
    f(&amp;f);
}

fn main() {
    fix(&amp;|y| {
        // Here, when `x` is called, the parameter `y` is equal to `x`.
    });
}</pre></div> <p>Rust does not permit a closure to directly reference its own type, either through an argument (as in the example above) or by capturing itself through its environment. This restriction helps keep closure inference tractable.</p> <p>The easiest fix is to rewrite your closure into a top-level function, or into a method. In some cases, you may also be able to have your closure call itself by capturing a <code>&amp;Fn()</code> object or <code>fn()</code> pointer that refers to itself. That is permitting, since the closure would be invoking itself via a virtual call, and hence does not directly reference its own <em>type</em>.</p>  <h3 id="E0646" class="section-header">E0646</h3> <p>It is not possible to define <code>main</code> with a where clause.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn main() where i32: Copy { // error: main function is not allowed to have
                            // a where clause
}</pre></div>  <h3 id="E0647" class="section-header">E0647</h3> <p>The <code>start</code> function was defined with a where clause.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(start)]

#[start]
fn start(_: isize, _: *const *const u8) -&gt; isize where (): Copy {
    //^ error: start function is not allowed to have a where clause
    0
}</pre></div>  <h3 id="E0648" class="section-header">E0648</h3> <p>An <code>export_name</code> attribute contains null characters (<code>\0</code>).</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[export_name="\0foo"] // error: `export_name` may not contain null characters
pub fn bar() {}</pre></div> <p>To fix this error, remove the null characters:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[export_name="foo"] // ok!
pub fn bar() {}</pre></div>  <h3 id="E0657" class="section-header">E0657</h3> <p>A lifetime bound on a trait implementation was captured at an incorrect place.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Id&lt;T&gt; {}
trait Lt&lt;'a&gt; {}

impl&lt;'a&gt; Lt&lt;'a&gt; for () {}
impl&lt;T&gt; Id&lt;T&gt; for T {}

fn free_fn_capture_hrtb_in_impl_trait()
    -&gt; Box&lt;for&lt;'a&gt; Id&lt;impl Lt&lt;'a&gt;&gt;&gt; // error!
{
    Box::new(())
}

struct Foo;
impl Foo {
    fn impl_fn_capture_hrtb_in_impl_trait()
        -&gt; Box&lt;for&lt;'a&gt; Id&lt;impl Lt&lt;'a&gt;&gt;&gt; // error!
    {
        Box::new(())
    }
}</pre></div> <p>Here, you have used the inappropriate lifetime in the <code>impl Trait</code>, The <code>impl Trait</code> can only capture lifetimes bound at the fn or impl level.</p> <p>To fix this we have to define the lifetime at the function or impl level and use that lifetime in the <code>impl Trait</code>. For example you can define the lifetime at the function:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Id&lt;T&gt; {}
trait Lt&lt;'a&gt; {}

impl&lt;'a&gt; Lt&lt;'a&gt; for () {}
impl&lt;T&gt; Id&lt;T&gt; for T {}

fn free_fn_capture_hrtb_in_impl_trait&lt;'b&gt;()
    -&gt; Box&lt;for&lt;'a&gt; Id&lt;impl Lt&lt;'b&gt;&gt;&gt; // ok!
{
    Box::new(())
}

struct Foo;
impl Foo {
    fn impl_fn_capture_hrtb_in_impl_trait&lt;'b&gt;()
        -&gt; Box&lt;for&lt;'a&gt; Id&lt;impl Lt&lt;'b&gt;&gt;&gt; // ok!
    {
        Box::new(())
    }
}</pre></div>  <h3 id="E0658" class="section-header">E0658</h3> <p>An unstable feature was used.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[repr(u128)] // error: use of unstable library feature 'repr128'
enum Foo {
    Bar(u64),
}</pre></div> <p>If you're using a stable or a beta version of rustc, you won't be able to use any unstable features. In order to do so, please switch to a nightly version of rustc (by using rustup).</p> <p>If you're using a nightly version of rustc, just add the corresponding feature to be able to use it:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(repr128)]

#[repr(u128)] // ok!
enum Foo {
    Bar(u64),
}</pre></div>  <h3 id="E0659" class="section-header">E0659</h3> <p>An item usage is ambiguous.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
pub mod moon {
    pub fn foo() {}
}

pub mod earth {
    pub fn foo() {}
}

mod collider {
    pub use crate::moon::*;
    pub use crate::earth::*;
}

fn main() {
    crate::collider::foo(); // ERROR: `foo` is ambiguous
}</pre></div> <p>This error generally appears when two items with the same name are imported into a module. Here, the <code>foo</code> functions are imported and reexported from the <code>collider</code> module and therefore, when we're using <code>collider::foo()</code>, both functions collide.</p> <p>To solve this error, the best solution is generally to keep the path before the item when using it. Example:</p> <div class="information">ⓘThis code runs with edition 2018</div>
<div class="example-wrap"><pre class="rust rust-example-rendered edition " data-language="rust">
pub mod moon {
    pub fn foo() {}
}

pub mod earth {
    pub fn foo() {}
}

mod collider {
    pub use crate::moon;
    pub use crate::earth;
}

fn main() {
    crate::collider::moon::foo(); // ok!
    crate::collider::earth::foo(); // ok!
}</pre></div>  <h3 id="E0660" class="section-header">E0660</h3> <p>The argument to the <code>llvm_asm</code> macro is not well-formed.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
llvm_asm!("nop" "nop");</pre></div> <p>Considering that this would be a long explanation, we instead recommend you take a look at the [<code>llvm_asm</code>] chapter of the Unstable book:</p>  <h3 id="E0661" class="section-header">E0661</h3> <p>An invalid syntax was passed to the second argument of an <code>llvm_asm</code> macro line.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let a;
llvm_asm!("nop" : "r"(a));</pre></div> <p>Considering that this would be a long explanation, we instead recommend you take a look at the [<code>llvm_asm</code>] chapter of the Unstable book:</p>  <h3 id="E0662" class="section-header">E0662</h3> <p>An invalid input operand constraint was passed to the <code>llvm_asm</code> macro (third line).</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
llvm_asm!("xor %eax, %eax"
          :
          : "=test"("a")
         );</pre></div> <p>Considering that this would be a long explanation, we instead recommend you take a look at the [<code>llvm_asm</code>] chapter of the Unstable book:</p>  <h3 id="E0663" class="section-header">E0663</h3> <p>An invalid input operand constraint was passed to the <code>llvm_asm</code> macro (third line).</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
llvm_asm!("xor %eax, %eax"
          :
          : "+test"("a")
         );</pre></div> <p>Considering that this would be a long explanation, we instead recommend you take a look at the [<code>llvm_asm</code>] chapter of the Unstable book:</p>  <h3 id="E0664" class="section-header">E0664</h3> <p>A clobber was surrounded by braces in the <code>llvm_asm</code> macro.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
llvm_asm!("mov $$0x200, %eax"
          :
          :
          : "{eax}"
         );</pre></div> <p>Considering that this would be a long explanation, we instead recommend you take a look at the [<code>llvm_asm</code>] chapter of the Unstable book:</p>  <h3 id="E0665" class="section-header">E0665</h3> <p>The <code>Default</code> trait was derived on an enum.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[derive(Default)]
enum Food {
    Sweet,
    Salty,
}</pre></div> <p>The <code>Default</code> cannot be derived on an enum for the simple reason that the compiler doesn't know which value to pick by default whereas it can for a struct as long as all its fields implement the <code>Default</code> trait as well.</p> <p>If you still want to implement <code>Default</code> on your enum, you'll have to do it "by hand":</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
enum Food {
    Sweet,
    Salty,
}

impl Default for Food {
    fn default() -&gt; Food {
        Food::Sweet
    }
}</pre></div>  <h3 id="E0666" class="section-header">E0666</h3> <p><code>impl Trait</code> types cannot appear nested in the generic arguments of other <code>impl Trait</code> types.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait MyGenericTrait&lt;T&gt; {}
trait MyInnerTrait {}

fn foo(
    bar: impl MyGenericTrait&lt;impl MyInnerTrait&gt;, // error!
) {}</pre></div> <p>Type parameters for <code>impl Trait</code> types must be explicitly defined as named generic parameters:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait MyGenericTrait&lt;T&gt; {}
trait MyInnerTrait {}

fn foo&lt;T: MyInnerTrait&gt;(
    bar: impl MyGenericTrait&lt;T&gt;, // ok!
) {}</pre></div>   <h3 id="E0668" class="section-header">E0668</h3> <p>Malformed inline assembly rejected by LLVM.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(llvm_asm)]

fn main() {
    let rax: u64;
    unsafe {
        llvm_asm!("" :"={rax"(rax));
        println!("Accumulator is: {}", rax);
    }
}</pre></div> <p>LLVM checks the validity of the constraints and the assembly string passed to it. This error implies that LLVM seems something wrong with the inline assembly call.</p> <p>In particular, it can happen if you forgot the closing bracket of a register constraint (see issue #51430), like in the previous code example.</p>  <h3 id="E0669" class="section-header">E0669</h3> <p>Cannot convert inline assembly operand to a single LLVM value.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(llvm_asm)]

fn main() {
    unsafe {
        llvm_asm!("" :: "r"("")); // error!
    }
}</pre></div> <p>This error usually happens when trying to pass in a value to an input inline assembly operand that is actually a pair of values. In particular, this can happen when trying to pass in a slice, for instance a <code>&amp;str</code>. In Rust, these values are represented internally as a pair of values, the pointer and its length. When passed as an input operand, this pair of values can not be coerced into a register and thus we must fail with an error.</p>  <h3 id="E0670" class="section-header">E0670</h3> <p>Rust 2015 does not permit the use of <code>async fn</code>.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
async fn foo() {}</pre></div> <p>Switch to the Rust 2018 edition to use <code>async fn</code>.</p>  <h3 id="E0671" class="section-header">E0671</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-41" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>Const parameters cannot depend on type parameters. The following is therefore invalid:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(const_generics)]

fn const_id&lt;T, const N: T&gt;() -&gt; T { // error
    N
}</pre></div>  <h3 id="E0687" class="section-header">E0687</h3> <p>In-band lifetimes cannot be used in <code>fn</code>/<code>Fn</code> syntax.</p> <p>Erroneous code examples:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(in_band_lifetimes)]

fn foo(x: fn(&amp;'a u32)) {} // error!

fn bar(x: &amp;Fn(&amp;'a u32)) {} // error!

fn baz(x: fn(&amp;'a u32), y: &amp;'a u32) {} // error!

struct Foo&lt;'a&gt; { x: &amp;'a u32 }

impl Foo&lt;'a&gt; {
    fn bar(&amp;self, x: fn(&amp;'a u32)) {} // error!
}</pre></div> <p>Lifetimes used in <code>fn</code> or <code>Fn</code> syntax must be explicitly declared using <code>&lt;...&gt;</code> binders. For example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo&lt;'a&gt;(x: fn(&amp;'a u32)) {} // ok!

fn bar&lt;'a&gt;(x: &amp;Fn(&amp;'a u32)) {} // ok!

fn baz&lt;'a&gt;(x: fn(&amp;'a u32), y: &amp;'a u32) {} // ok!

struct Foo&lt;'a&gt; { x: &amp;'a u32 }

impl&lt;'a&gt; Foo&lt;'a&gt; {
    fn bar(&amp;self, x: fn(&amp;'a u32)) {} // ok!
}</pre></div>  <h3 id="E0688" class="section-header">E0688</h3> <p>In-band lifetimes were mixed with explicit lifetime binders.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(in_band_lifetimes)]

fn foo&lt;'a&gt;(x: &amp;'a u32, y: &amp;'b u32) {}   // error!

struct Foo&lt;'a&gt; { x: &amp;'a u32 }

impl Foo&lt;'a&gt; {
    fn bar&lt;'b&gt;(x: &amp;'a u32, y: &amp;'b u32, z: &amp;'c u32) {}   // error!
}

impl&lt;'b&gt; Foo&lt;'a&gt; {  // error!
    fn baz() {}
}</pre></div> <p>In-band lifetimes cannot be mixed with explicit lifetime binders. For example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo&lt;'a, 'b&gt;(x: &amp;'a u32, y: &amp;'b u32) {}   // ok!

struct Foo&lt;'a&gt; { x: &amp;'a u32 }

impl&lt;'a&gt; Foo&lt;'a&gt; {
    fn bar&lt;'b,'c&gt;(x: &amp;'a u32, y: &amp;'b u32, z: &amp;'c u32) {}    // ok!
}

impl&lt;'a&gt; Foo&lt;'a&gt; {  // ok!
    fn baz() {}
}</pre></div>  <h3 id="E0689" class="section-header">E0689</h3> <p>A method was called on an ambiguous numeric type.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
2.0.neg(); // error!</pre></div> <p>This error indicates that the numeric value for the method being passed exists but the type of the numeric value or binding could not be identified.</p> <p>The error happens on numeric literals and on numeric bindings without an identified concrete type:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let x = 2.0;
x.neg();  // same error as above</pre></div> <p>Because of this, you must give the numeric literal or binding a type:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::ops::Neg;

let _ = 2.0_f32.neg(); // ok!
let x: f32 = 2.0;
let _ = x.neg(); // ok!
let _ = (2.0 as f32).neg(); // ok!</pre></div>  <h3 id="E0690" class="section-header">E0690</h3> <p>A struct with the representation hint <code>repr(transparent)</code> had zero or more than one fields that were not guaranteed to be zero-sized.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[repr(transparent)]
struct LengthWithUnit&lt;U&gt; { // error: transparent struct needs exactly one
    value: f32,            //        non-zero-sized field, but has 2
    unit: U,
}</pre></div> <p>Because transparent structs are represented exactly like one of their fields at run time, said field must be uniquely determined. If there is no field, or if there are multiple fields, it is not clear how the struct should be represented. Note that fields of zero-sized types (e.g., <code>PhantomData</code>) can also exist alongside the field that contains the actual data, they do not count for this error. When generic types are involved (as in the above example), an error is reported because the type parameter could be non-zero-sized.</p> <p>To combine <code>repr(transparent)</code> with type parameters, <code>PhantomData</code> may be useful:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::marker::PhantomData;

#[repr(transparent)]
struct LengthWithUnit&lt;U&gt; {
    value: f32,
    unit: PhantomData&lt;U&gt;,
}</pre></div>  <h3 id="E0691" class="section-header">E0691</h3> <p>A struct, enum, or union with the <code>repr(transparent)</code> representation hint contains a zero-sized field that requires non-trivial alignment.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(repr_align)]

#[repr(align(32))]
struct ForceAlign32;

#[repr(transparent)]
struct Wrapper(f32, ForceAlign32); // error: zero-sized field in transparent
                                   //        struct has alignment larger than 1</pre></div> <p>A transparent struct, enum, or union is supposed to be represented exactly like the piece of data it contains. Zero-sized fields with different alignment requirements potentially conflict with this property. In the example above, <code>Wrapper</code> would have to be aligned to 32 bytes even though <code>f32</code> has a smaller alignment requirement.</p> <p>Consider removing the over-aligned zero-sized field:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[repr(transparent)]
struct Wrapper(f32);</pre></div> <p>Alternatively, <code>PhantomData&lt;T&gt;</code> has alignment 1 for all <code>T</code>, so you can use it if you need to keep the field for some reason:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(repr_align)]

use std::marker::PhantomData;

#[repr(align(32))]
struct ForceAlign32;

#[repr(transparent)]
struct Wrapper(f32, PhantomData&lt;ForceAlign32&gt;);</pre></div> <p>Note that empty arrays <code>[T; 0]</code> have the same alignment requirement as the element type <code>T</code>. Also note that the error is conservatively reported even when the alignment of the zero-sized type is less than or equal to the data field's alignment.</p>  <h3 id="E0692" class="section-header">E0692</h3> <p>A <code>repr(transparent)</code> type was also annotated with other, incompatible representation hints.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[repr(transparent, C)] // error: incompatible representation hints
struct Grams(f32);</pre></div> <p>A type annotated as <code>repr(transparent)</code> delegates all representation concerns to another type, so adding more representation hints is contradictory. Remove either the <code>transparent</code> hint or the other hints, like this:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[repr(transparent)]
struct Grams(f32);</pre></div> <p>Alternatively, move the other attributes to the contained type:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[repr(C)]
struct Foo {
    x: i32,
    // ...
}

#[repr(transparent)]
struct FooWrapper(Foo);</pre></div> <p>Note that introducing another <code>struct</code> just to have a place for the other attributes may have unintended side effects on the representation:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[repr(transparent)]
struct Grams(f32);

#[repr(C)]
struct Float(f32);

#[repr(transparent)]
struct Grams2(Float); // this is not equivalent to `Grams` above</pre></div> <p>Here, <code>Grams2</code> is a not equivalent to <code>Grams</code> -- the former transparently wraps a (non-transparent) struct containing a single float, while <code>Grams</code> is a transparent wrapper around a float. This can make a difference for the ABI.</p>  <h3 id="E0693" class="section-header">E0693</h3> <p><code>align</code> representation hint was incorrectly declared.</p> <p>Erroneous code examples:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[repr(align=8)] // error!
struct Align8(i8);

#[repr(align="8")] // error!
struct Align8(i8);</pre></div> <p>This is a syntax error at the level of attribute declarations. The proper syntax for <code>align</code> representation hint is the following:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[repr(align(8))] // ok!
struct Align8(i8);</pre></div>  <h3 id="E0695" class="section-header">E0695</h3> <p>A <code>break</code> statement without a label appeared inside a labeled block.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
loop {
    'a: {
        break;
    }
}</pre></div> <p>Make sure to always label the <code>break</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
'l: loop {
    'a: {
        break 'l;
    }
}</pre></div> <p>Or if you want to <code>break</code> the labeled block:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
loop {
    'a: {
        break 'a;
    }
    break;
}</pre></div>  <h3 id="E0696" class="section-header">E0696</h3> <p>A function is using <code>continue</code> keyword incorrectly.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn continue_simple() {
    'b: {
        continue; // error!
    }
}
fn continue_labeled() {
    'b: {
        continue 'b; // error!
    }
}
fn continue_crossing() {
    loop {
        'b: {
            continue; // error!
        }
    }
}</pre></div> <p>Here we have used the <code>continue</code> keyword incorrectly. As we have seen above that <code>continue</code> pointing to a labeled block.</p> <p>To fix this we have to use the labeled block properly. For example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn continue_simple() {
    'b: loop {
        continue ; // ok!
    }
}
fn continue_labeled() {
    'b: loop {
        continue 'b; // ok!
    }
}
fn continue_crossing() {
    loop {
        'b: loop {
            continue; // ok!
        }
    }
}</pre></div>  <h3 id="E0697" class="section-header">E0697</h3> <p>A closure has been used as <code>static</code>.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn main() {
    static || {}; // used as `static`
}</pre></div> <p>Closures cannot be used as <code>static</code>. They "save" the environment, and as such a static closure would save only a static environment which would consist only of variables with a static lifetime. Given this it would be better to use a proper function. The easiest fix is to remove the <code>static</code> keyword.</p>  <h3 id="E0698" class="section-header">E0698</h3> <p>When using generators (or async) all type variables must be bound so a generator can be constructed.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
async fn bar&lt;T&gt;() -&gt; () {}

async fn foo() {
    bar().await; // error: cannot infer type for `T`
}</pre></div> <p>In the above example <code>T</code> is unknowable by the compiler. To fix this you must bind <code>T</code> to a concrete type such as <code>String</code> so that a generator can then be constructed:</p> <div class="information">ⓘThis code runs with edition 2018</div>
<div class="example-wrap"><pre class="rust rust-example-rendered edition " data-language="rust">
async fn bar&lt;T&gt;() -&gt; () {}

async fn foo() {
    bar::&lt;String&gt;().await;
    //   ^^^^^^^^ specify type explicitly
}</pre></div>  <h3 id="E0699" class="section-header">E0699</h3> <p>A method was called on a raw pointer whose inner type wasn't completely known.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let foo = &amp;1;
let bar = foo as *const _;
if bar.is_null() {
    // ...
}</pre></div> <p>Here, the type of <code>bar</code> isn't known; it could be a pointer to anything. Instead, specify a type for the pointer (preferably something that makes sense for the thing you're pointing to):</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let foo = &amp;1;
let bar = foo as *const i32;
if bar.is_null() {
    // ...
}</pre></div> <p>Even though <code>is_null()</code> exists as a method on any raw pointer, Rust shows this error because Rust allows for <code>self</code> to have arbitrary types (behind the arbitrary_self_types feature flag).</p> <p>This means that someone can specify such a function:</p> <div class="information">ⓘThis example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">
impl Foo {
    fn is_null(self: *const Self) -&gt; bool {
        // do something else
    }
}</pre></div> <p>and now when you call <code>.is_null()</code> on a raw pointer to <code>Foo</code>, there's ambiguity.</p> <p>Given that we don't know what type the pointer is, and there's potential ambiguity for some types, we disallow calling methods on raw pointers when the type is unknown.</p>  <h3 id="E0700" class="section-header">E0700</h3> <p>The <code>impl Trait</code> return type captures lifetime parameters that do not appear within the <code>impl Trait</code> itself.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
use std::cell::Cell;

trait Trait&lt;'a&gt; { }

impl&lt;'a, 'b&gt; Trait&lt;'b&gt; for Cell&lt;&amp;'a u32&gt; { }

fn foo&lt;'x, 'y&gt;(x: Cell&lt;&amp;'x u32&gt;) -&gt; impl Trait&lt;'y&gt;
where 'x: 'y
{
    x
}</pre></div> <p>Here, the function <code>foo</code> returns a value of type <code>Cell&lt;&amp;'x u32&gt;</code>, which references the lifetime <code>'x</code>. However, the return type is declared as <code>impl Trait&lt;'y&gt;</code> -- this indicates that <code>foo</code> returns "some type that implements <code>Trait&lt;'y&gt;</code>", but it also indicates that the return type <strong>only captures data referencing the lifetime <code>'y</code></strong>. In this case, though, we are referencing data with lifetime <code>'x</code>, so this function is in error.</p> <p>To fix this, you must reference the lifetime <code>'x</code> from the return type. For example, changing the return type to <code>impl Trait&lt;'y&gt; + 'x</code> would work:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::cell::Cell;

trait Trait&lt;'a&gt; { }

impl&lt;'a,'b&gt; Trait&lt;'b&gt; for Cell&lt;&amp;'a u32&gt; { }

fn foo&lt;'x, 'y&gt;(x: Cell&lt;&amp;'x u32&gt;) -&gt; impl Trait&lt;'y&gt; + 'x
where 'x: 'y
{
    x
}</pre></div>  <h3 id="E0701" class="section-header">E0701</h3> <p>This error indicates that a <code>#[non_exhaustive]</code> attribute was incorrectly placed on something other than a struct or enum.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[non_exhaustive]
trait Foo { }</pre></div>  <h3 id="E0703" class="section-header">E0703</h3> <p>Invalid ABI (Application Binary Interface) used in the code.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
extern "invalid" fn foo() {} // error!</pre></div> <p>At present few predefined ABI's (like Rust, C, system, etc.) can be used in Rust. Verify that the ABI is predefined. For example you can replace the given ABI from 'Rust'.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
extern "Rust" fn foo() {} // ok!</pre></div>  <h3 id="E0704" class="section-header">E0704</h3> <p>An incorrect visibility restriction was specified.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
mod foo {
    pub(foo) struct Bar {
        x: i32
    }
}</pre></div> <p>To make struct <code>Bar</code> only visible in module <code>foo</code> the <code>in</code> keyword should be used:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
mod foo {
    pub(in crate::foo) struct Bar {
        x: i32
    }
}</pre></div> <p>For more information see the Rust Reference on <a href="reference/visibility-and-privacy">Visibility</a>.</p>  <h3 id="E0705" class="section-header">E0705</h3> <p>A <code>#![feature]</code> attribute was declared for a feature that is stable in the current edition, but not in all editions.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">
#![feature(rust_2018_preview)]
#![feature(test_2018_feature)] // error: the feature
                               // `test_2018_feature` is
                               // included in the Rust 2018 edition</pre></div>  <h3 id="E0706" class="section-header">E0706</h3> <p><code>async fn</code>s are not yet supported in traits in Rust.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait T {
    // Neither case is currently supported.
    async fn foo() {}
    async fn bar(&amp;self) {}
}</pre></div> <p><code>async fn</code>s return an <code>impl Future</code>, making the following two examples equivalent:</p> <div class="information">ⓘThis example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">
async fn foo() -&gt; User {
    unimplemented!()
}
// The async fn above gets desugared as follows:
fn foo(&amp;self) -&gt; impl Future&lt;Output = User&gt; + '_ {
    unimplemented!()
}</pre></div> <p>But when it comes to supporting this in traits, there are <a href="https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/">a few implementation issues</a>. One of them is returning <code>impl Trait</code> in traits is not supported, as it would require <a href="https://github.com/rust-lang/rust/issues/44265">Generic Associated Types</a> to be supported:</p> <div class="information">ⓘThis example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">
impl MyDatabase {
    async fn get_user(&amp;self) -&gt; User {
        unimplemented!()
    }
}

impl MyDatabase {
    fn get_user(&amp;self) -&gt; impl Future&lt;Output = User&gt; + '_ {
        unimplemented!()
    }
}</pre></div> <p>Until these issues are resolved, you can use the <a href="https://crates.io/crates/async-trait"><code>async-trait</code> crate</a>, allowing you to use <code>async fn</code> in traits by desugaring to "boxed futures" (<code>Pin&lt;Box&lt;dyn Future + Send + 'async&gt;&gt;</code>).</p> <p>Note that using these trait methods will result in a heap allocation per-function-call. This is not a significant cost for the vast majority of applications, but should be considered when deciding whether to use this functionality in the public API of a low-level function that is expected to be called millions of times a second.</p> <p>You might be interested in visiting the <a href="https://rust-lang.github.io/async-book/07_workarounds/06_async_in_traits.html">async book</a> for further information.</p>  <h3 id="E0708" class="section-header">E0708</h3> <p><code>async</code> non-<code>move</code> closures with parameters are currently not supported.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(async_closure)]

fn main() {
    let add_one = async |num: u8| { // error!
        num + 1
    };
}</pre></div> <p><code>async</code> with non-move is currently not supported with the current version, you can use successfully by using move:</p> <div class="information">ⓘThis code runs with edition 2018</div>
<div class="example-wrap"><pre class="rust rust-example-rendered edition " data-language="rust">
#![feature(async_closure)]

fn main() {
    let add_one = async move |num: u8| { // ok!
        num + 1
    };
}</pre></div>  <h3 id="E0710" class="section-header">E0710</h3> <p>An unknown tool name was found in a scoped lint.</p> <p>Erroneous code examples:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[allow(clipp::filter_map)] // error!`
fn main() {
    // business logic
}</pre></div> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[warn(clipp::filter_map)] // error!`
fn main() {
    // business logic
}</pre></div> <p>Please verify you didn't misspell the tool's name or that you didn't forget to import it in you project:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[allow(clippy::filter_map)] // ok!
fn main() {
    // business logic
}</pre></div> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[warn(clippy::filter_map)] // ok!
fn main() {
    // business logic
}</pre></div>   <h3 id="E0712" class="section-header">E0712</h3> <p>A borrow of a thread-local variable was made inside a function which outlived the lifetime of the function.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(thread_local)]

#[thread_local]
static FOO: u8 = 3;

fn main() {
    let a = &amp;FOO; // error: thread-local variable borrowed past end of function

    std::thread::spawn(move || {
        println!("{}", a);
    });
}</pre></div>  <h3 id="E0713" class="section-header">E0713</h3> <p>This error occurs when an attempt is made to borrow state past the end of the lifetime of a type that implements the <code>Drop</code> trait.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(nll)]

pub struct S&lt;'a&gt; { data: &amp;'a mut String }

impl&lt;'a&gt; Drop for S&lt;'a&gt; {
    fn drop(&amp;mut self) { self.data.push_str("being dropped"); }
}

fn demo&lt;'a&gt;(s: S&lt;'a&gt;) -&gt; &amp;'a mut String { let p = &amp;mut *s.data; p }</pre></div> <p>Here, <code>demo</code> tries to borrow the string data held within its argument <code>s</code> and then return that borrow. However, <code>S</code> is declared as implementing <code>Drop</code>.</p> <p>Structs implementing the <code>Drop</code> trait have an implicit destructor that gets called when they go out of scope. This destructor gets exclusive access to the fields of the struct when it runs.</p> <p>This means that when <code>s</code> reaches the end of <code>demo</code>, its destructor gets exclusive access to its <code>&amp;mut</code>-borrowed string data. allowing another borrow of that string data (<code>p</code>), to exist across the drop of <code>s</code> would be a violation of the principle that <code>&amp;mut</code>-borrows have exclusive, unaliased access to their referenced data.</p> <p>This error can be fixed by changing <code>demo</code> so that the destructor does not run while the string-data is borrowed; for example by taking <code>S</code> by reference:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
pub struct S&lt;'a&gt; { data: &amp;'a mut String }

impl&lt;'a&gt; Drop for S&lt;'a&gt; {
    fn drop(&amp;mut self) { self.data.push_str("being dropped"); }
}

fn demo&lt;'a&gt;(s: &amp;'a mut S&lt;'a&gt;) -&gt; &amp;'a mut String { let p = &amp;mut *(*s).data; p }</pre></div> <p>Note that this approach needs a reference to S with lifetime <code>'a</code>. Nothing shorter than <code>'a</code> will suffice: a shorter lifetime would imply that after <code>demo</code> finishes executing, something else (such as the destructor!) could access <code>s.data</code> after the end of that shorter lifetime, which would again violate the <code>&amp;mut</code>-borrow's exclusive access.</p>  <h3 id="E0714" class="section-header">E0714</h3> <p>A <code>#[marker]</code> trait contained an associated item.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(marker_trait_attr)]
#![feature(associated_type_defaults)]

#[marker]
trait MarkerConst {
    const N: usize; // error!
}

fn main() {}</pre></div> <p>The items of marker traits cannot be overridden, so there's no need to have them when they cannot be changed per-type anyway. If you wanted them for ergonomic reasons, consider making an extension trait instead.</p>  <h3 id="E0715" class="section-header">E0715</h3> <p>An <code>impl</code> for a <code>#[marker]</code> trait tried to override an associated item.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(marker_trait_attr)]

#[marker]
trait Marker {
    const N: usize = 0;
    fn do_something() {}
}

struct OverrideConst;
impl Marker for OverrideConst { // error!
    const N: usize = 1;
}</pre></div> <p>Because marker traits are allowed to have multiple implementations for the same type, it's not allowed to override anything in those implementations, as it would be ambiguous which override should actually be used.</p>  <h3 id="E0716" class="section-header">E0716</h3> <p>A temporary value is being dropped while a borrow is still in active use.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn foo() -&gt; i32 { 22 }
fn bar(x: &amp;i32) -&gt; &amp;i32 { x }
let p = bar(&amp;foo());
         // ------ creates a temporary
let q = *p;</pre></div> <p>Here, the expression <code>&amp;foo()</code> is borrowing the expression <code>foo()</code>. As <code>foo()</code> is a call to a function, and not the name of a variable, this creates a <strong>temporary</strong> -- that temporary stores the return value from <code>foo()</code> so that it can be borrowed. You could imagine that <code>let p = bar(&amp;foo());</code> is equivalent to this:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let p = {
  let tmp = foo(); // the temporary
  bar(&amp;tmp)
}; // &lt;-- tmp is freed as we exit this block
let q = p;</pre></div> <p>Whenever a temporary is created, it is automatically dropped (freed) according to fixed rules. Ordinarily, the temporary is dropped at the end of the enclosing statement -- in this case, after the <code>let</code>. This is illustrated in the example above by showing that <code>tmp</code> would be freed as we exit the block.</p> <p>To fix this problem, you need to create a local variable to store the value in rather than relying on a temporary. For example, you might change the original program to the following:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo() -&gt; i32 { 22 }
fn bar(x: &amp;i32) -&gt; &amp;i32 { x }
let value = foo(); // dropped at the end of the enclosing block
let p = bar(&amp;value);
let q = *p;</pre></div> <p>By introducing the explicit <code>let value</code>, we allocate storage that will last until the end of the enclosing block (when <code>value</code> goes out of scope). When we borrow <code>&amp;value</code>, we are borrowing a local variable that already exists, and hence no temporary is created.</p> <p>Temporaries are not always dropped at the end of the enclosing statement. In simple cases where the <code>&amp;</code> expression is immediately stored into a variable, the compiler will automatically extend the lifetime of the temporary until the end of the enclosing block. Therefore, an alternative way to fix the original program is to write <code>let tmp = &amp;foo()</code> and not <code>let tmp = foo()</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo() -&gt; i32 { 22 }
fn bar(x: &amp;i32) -&gt; &amp;i32 { x }
let value = &amp;foo();
let p = bar(value);
let q = *p;</pre></div> <p>Here, we are still borrowing <code>foo()</code>, but as the borrow is assigned directly into a variable, the temporary will not be dropped until the end of the enclosing block. Similar rules apply when temporaries are stored into aggregate structures like a tuple or struct:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
// Here, two temporaries are created, but
// as they are stored directly into `value`,
// they are not dropped until the end of the
// enclosing block.
fn foo() -&gt; i32 { 22 }
let value = (&amp;foo(), &amp;foo());</pre></div>   <h3 id="E0718" class="section-header">E0718</h3> <p>A <code>#[lang = ".."]</code> attribute was placed on the wrong item type.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(lang_items)]

#[lang = "owned_box"]
static X: u32 = 42;</pre></div>  <h3 id="E0719" class="section-header">E0719</h3> <p>An associated type value was specified more than once.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(associated_type_bounds)]

trait FooTrait {}
trait BarTrait {}

// error: associated type `Item` in trait `Iterator` is specified twice
struct Foo&lt;T: Iterator&lt;Item: FooTrait, Item: BarTrait&gt;&gt; { f: T }</pre></div> <p><code>Item</code> in trait <code>Iterator</code> cannot be specified multiple times for struct <code>Foo</code>. To fix this, create a new trait that is a combination of the desired traits and specify the associated type with the new trait.</p> <p>Corrected example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(associated_type_bounds)]

trait FooTrait {}
trait BarTrait {}
trait FooBarTrait: FooTrait + BarTrait {}

struct Foo&lt;T: Iterator&lt;Item: FooBarTrait&gt;&gt; { f: T } // ok!</pre></div> <p>For more information about associated types, see <a href="book/ch19-03-advanced-traits#specifying-placeholder-types-in-trait-definitions-with-associated-types">the book</a>. For more information on associated type bounds, see <a href="https://rust-lang.github.io/rfcs/2289-associated-type-bounds.html">RFC 2289</a>.</p>  <h3 id="E0720" class="section-header">E0720</h3> <p>An <code>impl Trait</code> type expands to a recursive type.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn make_recursive_type() -&gt; impl Sized {
    [make_recursive_type(), make_recursive_type()]
}</pre></div> <p>An <code>impl Trait</code> type must be expandable to a concrete type that contains no <code>impl Trait</code> types. For example the previous example tries to create an <code>impl Trait</code> type <code>T</code> that is equal to <code>[T, T]</code>.</p>   <h3 id="E0723" class="section-header">E0723</h3> <p>An unstable feature in <code>const</code> contexts was used.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait T {}

impl T for () {}

const fn foo() -&gt; impl T { // error: `impl Trait` in const fn is unstable
    ()
}</pre></div> <p>To enable this feature on a nightly version of rustc, add the <code>const_fn</code> feature flag:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(const_fn)]

trait T {}

impl T for () {}

const fn foo() -&gt; impl T {
    ()
}</pre></div>  <h3 id="E0724" class="section-header">E0724</h3> <p><code>#[ffi_returns_twice]</code> was used on something other than a foreign function declaration.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(ffi_returns_twice)]
#![crate_type = "lib"]

#[ffi_returns_twice] // error!
pub fn foo() {}</pre></div> <p><code>#[ffi_returns_twice]</code> can only be used on foreign function declarations. For example, we might correct the previous example by declaring the function inside of an <code>extern</code> block.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(ffi_returns_twice)]

extern {
   #[ffi_returns_twice] // ok!
   pub fn foo();
}</pre></div>  <h3 id="E0725" class="section-header">E0725</h3> <p>A feature attribute named a feature that was disallowed in the compiler command line flags.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">
#![feature(never_type)] // error: the feature `never_type` is not in
                        // the list of allowed features</pre></div> <p>Delete the offending feature attribute, or add it to the list of allowed features in the <code>-Z allow_features</code> flag.</p>   <h3 id="E0727" class="section-header">E0727</h3> <p>A <code>yield</code> clause was used in an <code>async</code> context.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(generators)]

fn main() {
    let generator = || {
        async {
            yield;
        }
    };
}</pre></div> <p>Here, the <code>yield</code> keyword is used in an <code>async</code> block, which is not yet supported.</p> <p>To fix this error, you have to move <code>yield</code> out of the <code>async</code> block:</p> <div class="information">ⓘThis code runs with edition 2018</div>
<div class="example-wrap"><pre class="rust rust-example-rendered edition " data-language="rust">
#![feature(generators)]

fn main() {
    let generator = || {
        yield;
    };
}</pre></div>  <h3 id="E0728" class="section-header">E0728</h3> <p><a href="std/keyword.await"><code>await</code></a> has been used outside <a href="std/keyword.async"><code>async</code></a> function or <a href="std/keyword.async"><code>async</code></a> block.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn foo() {
    wake_and_yield_once().await // `await` is used outside `async` context
}</pre></div> <p><a href="std/keyword.await"><code>await</code></a> is used to suspend the current computation until the given future is ready to produce a value. So it is legal only within an <a href="std/keyword.async"><code>async</code></a> context, like an <code>async</code> function or an <code>async</code> block.</p> <div class="information">ⓘThis code runs with edition 2018</div>
<div class="example-wrap"><pre class="rust rust-example-rendered edition " data-language="rust">
async fn foo() {
    wake_and_yield_once().await // `await` is used within `async` function
}

fn bar(x: u8) -&gt; impl Future&lt;Output = u8&gt; {
    async move {
        wake_and_yield_once().await; // `await` is used within `async` block
        x
    }
}</pre></div>  <h3 id="E0729" class="section-header">E0729</h3> <p>Support for Non-Lexical Lifetimes (NLL) has been included in the Rust compiler since 1.31, and has been enabled on the 2015 edition since 1.36. The new borrow checker for NLL uncovered some bugs in the old borrow checker, which in some cases allowed unsound code to compile, resulting in memory safety issues.</p> <h3 id="what-do-i-do" class="section-header">What do I do?</h3> <p>Change your code so the warning does no longer trigger. For backwards compatibility, this unsound code may still compile (with a warning) right now. However, at some point in the future, the compiler will no longer accept this code and will throw a hard error.</p> <h3 id="shouldnt-you-fix-the-old-borrow-checker" class="section-header">Shouldn't you fix the old borrow checker?</h3> <p>The old borrow checker has known soundness issues that are basically impossible to fix. The new NLL-based borrow checker is the fix.</p> <h3 id="can-i-turn-these-warnings-into-errors-by-denying-a-lint" class="section-header">Can I turn these warnings into errors by denying a lint?</h3> <p>No.</p> <h3 id="when-are-these-warnings-going-to-turn-into-errors" class="section-header">When are these warnings going to turn into errors?</h3> <p>No formal timeline for turning the warnings into errors has been set. See <a href="https://github.com/rust-lang/rust/issues/58781">GitHub issue 58781</a> for more information.</p> <h3 id="why-do-i-get-this-message-with-code-that-doesnt-involve-borrowing" class="section-header">Why do I get this message with code that doesn't involve borrowing?</h3> <p>There are some known bugs that trigger this message.</p>  <h3 id="E0730" class="section-header">E0730</h3> <p>An array without a fixed length was pattern-matched.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(const_generics)]

fn is_123&lt;const N: usize&gt;(x: [u32; N]) -&gt; bool {
    match x {
        [1, 2, ..] =&gt; true, // error: cannot pattern-match on an
                            //        array without a fixed length
        _ =&gt; false
    }
}</pre></div> <p>To fix this error, you have two solutions:</p> <ol> <li>Use an array with a fixed length.</li> <li>Use a slice.</li> </ol> <p>Example with an array with a fixed length:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn is_123(x: [u32; 3]) -&gt; bool { // We use an array with a fixed size
    match x {
        [1, 2, ..] =&gt; true, // ok!
        _ =&gt; false
    }
}</pre></div> <p>Example with a slice:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn is_123(x: &amp;[u32]) -&gt; bool { // We use a slice
    match x {
        [1, 2, ..] =&gt; true, // ok!
        _ =&gt; false
    }
}</pre></div>  <h3 id="E0731" class="section-header">E0731</h3> <p>An enum with the representation hint <code>repr(transparent)</code> had zero or more than one variants.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[repr(transparent)]
enum Status { // error: transparent enum needs exactly one variant, but has 2
    Errno(u32),
    Ok,
}</pre></div> <p>Because transparent enums are represented exactly like one of their variants at run time, said variant must be uniquely determined. If there is no variant, or if there are multiple variants, it is not clear how the enum should be represented.</p>  <h3 id="E0732" class="section-header">E0732</h3> <p>An <code>enum</code> with a discriminant must specify a <code>#[repr(inttype)]</code>.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(arbitrary_enum_discriminant)]

enum Enum { // error!
    Unit = 1,
    Tuple() = 2,
    Struct{} = 3,
}</pre></div> <p>A <code>#[repr(inttype)]</code> must be provided on an <code>enum</code> if it has a non-unit variant with a discriminant, or where there are both unit variants with discriminants and non-unit variants. This restriction ensures that there is a well-defined way to extract a variant's discriminant from a value; for instance:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(arbitrary_enum_discriminant)]

#[repr(u8)]
enum Enum {
    Unit = 3,
    Tuple(u16) = 2,
    Struct {
        a: u8,
        b: u16,
    } = 1,
}

fn discriminant(v : &amp;Enum) -&gt; u8 {
    unsafe { *(v as *const Enum as *const u8) }
}

fn main() {
    assert_eq!(3, discriminant(&amp;Enum::Unit));
    assert_eq!(2, discriminant(&amp;Enum::Tuple(5)));
    assert_eq!(1, discriminant(&amp;Enum::Struct{a: 7, b: 11}));
}</pre></div>  <h3 id="E0733" class="section-header">E0733</h3> <p>An <a href="std/keyword.async"><code>async</code></a> function used recursion without boxing.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
async fn foo(n: usize) {
    if n &gt; 0 {
        foo(n - 1).await;
    }
}</pre></div> <p>To perform async recursion, the <code>async fn</code> needs to be desugared such that the <code>Future</code> is explicit in the return type:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
use std::future::Future;
fn foo_desugared(n: usize) -&gt; impl Future&lt;Output = ()&gt; {
    async move {
        if n &gt; 0 {
            foo_desugared(n - 1).await;
        }
    }
}</pre></div> <p>Finally, the future is wrapped in a pinned box:</p> <div class="information">ⓘThis code runs with edition 2018</div>
<div class="example-wrap"><pre class="rust rust-example-rendered edition " data-language="rust">
use std::future::Future;
use std::pin::Pin;
fn foo_recursive(n: usize) -&gt; Pin&lt;Box&lt;dyn Future&lt;Output = ()&gt;&gt;&gt; {
    Box::pin(async move {
        if n &gt; 0 {
            foo_recursive(n - 1).await;
        }
    })
}</pre></div> <p>The <code>Box&lt;...&gt;</code> ensures that the result is of known size, and the pin is required to keep it in the same place in memory.</p>  <h3 id="E0734" class="section-header">E0734</h3> <p>A stability attribute has been used outside of the standard library.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[rustc_deprecated(since = "b", reason = "text")] // invalid
#[stable(feature = "a", since = "b")] // invalid
#[unstable(feature = "b", issue = "none")] // invalid
fn foo(){}</pre></div> <p>These attributes are meant to only be used by the standard library and are rejected in your own crates.</p>  <h3 id="E0735" class="section-header">E0735</h3> <p>Type parameter defaults cannot use <code>Self</code> on structs, enums, or unions.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo&lt;X = Box&lt;Self&gt;&gt; {
    field1: Option&lt;X&gt;,
    field2: Option&lt;X&gt;,
}
// error: type parameters cannot use `Self` in their defaults.</pre></div>  <h3 id="E0736" class="section-header">E0736</h3> <p><code>#[track_caller]</code> and <code>#[naked]</code> cannot both be applied to the same function.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[naked]
#[track_caller]
fn foo() {}</pre></div> <p>This is primarily due to ABI incompatibilities between the two attributes. See <a href="https://github.com/rust-lang/rfcs/blob/master/text/2091-inline-semantic.md">RFC 2091</a> for details on this and other limitations.</p>  <h3 id="E0737" class="section-header">E0737</h3> <p><code>#[track_caller]</code> requires functions to have the <code>"Rust"</code> ABI for implicitly receiving caller location. See <a href="https://github.com/rust-lang/rfcs/blob/master/text/2091-inline-semantic.md">RFC 2091</a> for details on this and other restrictions.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[track_caller]
extern "C" fn foo() {}</pre></div>  <h3 id="E0739" class="section-header">E0739</h3> <p><code>#[track_caller]</code> can not be applied on struct.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[track_caller]
struct Bar {
    a: u8,
}</pre></div>  <h3 id="E0740" class="section-header">E0740</h3> <p>A <code>union</code> was declared with fields with destructors.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
union Test {
    a: A, // error!
}

#[derive(Debug)]
struct A(i32);

impl Drop for A {
    fn drop(&amp;mut self) { println!("A"); }
}</pre></div> <p>A <code>union</code> cannot have fields with destructors.</p>  <h3 id="E0741" class="section-header">E0741</h3> <p>A non-structural-match type was used as the type of a const generic parameter.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(const_generics)]

struct A;

struct B&lt;const X: A&gt;; // error!</pre></div> <p>Only structural-match types (that is, types that derive <code>PartialEq</code> and <code>Eq</code>) may be used as the types of const generic parameters.</p> <p>To fix the previous code example, we derive <code>PartialEq</code> and <code>Eq</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(const_generics)]

#[derive(PartialEq, Eq)] // We derive both traits here.
struct A;

struct B&lt;const X: A&gt;; // ok!</pre></div>  <h3 id="E0742" class="section-header">E0742</h3> <p>Visibility is restricted to a module which isn't an ancestor of the current item.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
pub mod Sea {}

pub (in crate::Sea) struct Shark; // error!

fn main() {}</pre></div> <p>To fix this error, we need to move the <code>Shark</code> struct inside the <code>Sea</code> module:</p> <div class="information">ⓘThis code runs with edition 2018</div>
<div class="example-wrap"><pre class="rust rust-example-rendered edition " data-language="rust">
pub mod Sea {
    pub (in crate::Sea) struct Shark; // ok!
}

fn main() {}</pre></div> <p>Of course, you can do it as long as the module you're referring to is an ancestor:</p> <div class="information">ⓘThis code runs with edition 2018</div>
<div class="example-wrap"><pre class="rust rust-example-rendered edition " data-language="rust">
pub mod Earth {
    pub mod Sea {
        pub (in crate::Earth) struct Shark; // ok!
    }
}

fn main() {}</pre></div>  <h3 id="E0743" class="section-header">E0743</h3> <p>The C-variadic type <code>...</code> has been nested inside another type.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(c_variadic)]

fn foo2(x: u8, y: &amp;...) {} // error!</pre></div> <p>Only foreign functions can use the C-variadic type (<code>...</code>). In such functions, <code>...</code> may only occur non-nested. That is, <code>y: &amp;'a ...</code> is not allowed.</p> <p>A C-variadic type is used to give an undefined number of parameters to a given function (like <code>printf</code> in C). The equivalent in Rust would be to use macros directly (like <code>println!</code> for example).</p>  <h3 id="E0744" class="section-header">E0744</h3> <p>A control-flow expression was used inside a const context.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
const _: i32 = {
    let mut x = 0;

    for i in 0..4 { // error!
        x += i;
    }
};</pre></div> <p>At the moment, <code>if</code> and <code>match</code>, as well as the looping constructs <code>for</code>, <code>while</code>, and <code>loop</code>, are forbidden inside a <code>const</code>, <code>static</code>, or <code>const fn</code>.</p> <p>This will be allowed at some point in the future, but the implementation is not yet complete. See the tracking issue for <a href="https://github.com/rust-lang/rust/issues/49146">conditionals</a> or <a href="https://github.com/rust-lang/rust/issues/52000">loops</a> in a const context for the current status.</p>  <h3 id="E0745" class="section-header">E0745</h3> <p>The address of temporary value was taken.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn temp_address() {
    let ptr = &amp;raw const 2; // error!
}</pre></div> <p>In this example, <code>2</code> is destroyed right after the assignment, which means that <code>ptr</code> now points to an unavailable location.</p> <p>To avoid this error, first bind the temporary to a named local variable:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn temp_address() {
    let val = 2;
    let ptr = &amp;raw const val; // ok!
}</pre></div>  <h3 id="E0746" class="section-header">E0746</h3> <p>An unboxed trait object was used as a return value.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait T {
    fn bar(&amp;self);
}
struct S(usize);
impl T for S {
    fn bar(&amp;self) {}
}

// Having the trait `T` as return type is invalid because
// unboxed trait objects do not have a statically known size:
fn foo() -&gt; dyn T { // error!
    S(42)
}</pre></div> <p>Return types cannot be <code>dyn Trait</code>s as they must be <code>Sized</code>.</p> <p>To avoid the error there are a couple of options.</p> <p>If there is a single type involved, you can use <a href="book/ch10-02-traits#returning-types-that-implement-traits"><code>impl Trait</code></a>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
// The compiler will select `S(usize)` as the materialized return type of this
// function, but callers will only know that the return type implements `T`.
fn foo() -&gt; impl T { // ok!
    S(42)
}</pre></div> <p>If there are multiple types involved, the only way you care to interact with them is through the trait's interface, and having to rely on dynamic dispatch is acceptable, then you can use <a href="book/ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types">trait objects</a> with <code>Box</code>, or other container types like <code>Rc</code> or <code>Arc</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct O(&amp;'static str);
impl T for O {
    fn bar(&amp;self) {}
}

// This now returns a "trait object" and callers are only be able to access
// associated items from `T`.
fn foo(x: bool) -&gt; Box&lt;dyn T&gt; { // ok!
    if x {
        Box::new(S(42))
    } else {
        Box::new(O("val"))
    }
}</pre></div> <p>Finally, if you wish to still be able to access the original type, you can create a new <code>enum</code> with a variant for each type:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
enum E {
    S(S),
    O(O),
}

// The caller can access the original types directly, but it needs to match on
// the returned `enum E`.
fn foo(x: bool) -&gt; E {
    if x {
        E::S(S(42))
    } else {
        E::O(O("val"))
    }
}</pre></div> <p>You can even implement the <code>trait</code> on the returned <code>enum</code> so the callers <em>don't</em> have to match on the returned value to invoke the associated items:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
impl T for E {
    fn bar(&amp;self) {
        match self {
            E::S(s) =&gt; s.bar(),
            E::O(o) =&gt; o.bar(),
        }
    }
}</pre></div> <p>If you decide to use trait objects, be aware that these rely on <a href="book/ch17-02-trait-objects#trait-objects-perform-dynamic-dispatch">dynamic dispatch</a>, which has performance implications, as the compiler needs to emit code that will figure out which method to call <em>at runtime</em> instead of during compilation. Using trait objects we are trading flexibility for performance.</p>  <h3 id="E0747" class="section-header">E0747</h3> <p>Generic arguments were not provided in the same order as the corresponding generic parameters are declared.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct S&lt;'a, T&gt;(&amp;'a T);

type X = S&lt;(), 'static&gt;; // error: the type argument is provided before the
                         // lifetime argument</pre></div> <p>The argument order should be changed to match the parameter declaration order, as in the following:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct S&lt;'a, T&gt;(&amp;'a T);

type X = S&lt;'static, ()&gt;; // ok</pre></div>  <h3 id="E0748" class="section-header">E0748</h3> <p>A raw string isn't correctly terminated because the trailing <code>#</code> count doesn't match its leading <code>#</code> count.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<pre>let dolphins = r##"Dolphins!"#; // error!</pre> <p>To terminate a raw string, you have to have the same number of <code>#</code> at the end as at the beginning. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let dolphins = r#"Dolphins!"#; // One `#` at the beginning, one at the end so
                               // all good!</pre></div>  <h3 id="E0749" class="section-header">E0749</h3> <p>An item was added on a negative impl.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait MyTrait {
    type Foo;
}

impl !MyTrait for u32 {
    type Foo = i32; // error!
}</pre></div> <p>Negative impls are not allowed to have any items. Negative impls declare that a trait is <strong>not</strong> implemented (and never will be) and hence there is no need to specify the values for trait methods or other items.</p> <p>One way to fix this is to remove the items in negative impls:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait MyTrait {
    type Foo;
}

impl !MyTrait for u32 {}</pre></div>  <h3 id="E0750" class="section-header">E0750</h3> <p>A negative impl was made default impl.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait MyTrait {
    type Foo;
}

default impl !MyTrait for u32 {} // error!</pre></div> <p>Negative impls cannot be default impls. A default impl supplies default values for the items within to be used by other impls, whereas a negative impl declares that there are no other impls. Combining it does not make sense.</p>  <h3 id="E0751" class="section-header">E0751</h3> <p>There are both a positive and negative trait implementation for the same type.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait MyTrait {}
impl MyTrait for i32 { }
impl !MyTrait for i32 { } // error!</pre></div> <p>Negative implementations are a promise that the trait will never be implemented for the given types. Therefore, both cannot exists at the same time.</p>  <h3 id="E0752" class="section-header">E0752</h3> <p>The entry point of the program was marked as <code>async</code>.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
async fn main() -&gt; Result&lt;(), ()&gt; { // error!
    Ok(())
}</pre></div> <p><code>fn main()</code> or the specified start function is not allowed to be <code>async</code>. Not having a correct async runtime library setup may cause this error. To fix it, declare the entry point without <code>async</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn main() -&gt; Result&lt;(), ()&gt; { // ok!
    Ok(())
}</pre></div>  <h3 id="E0753" class="section-header">E0753</h3> <p>An inner doc comment was used in an invalid context.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn foo() {}
//! foo
// ^ error!
fn main() {}</pre></div> <p>Inner document can only be used before items. For example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
//! A working comment applied to the module!
fn foo() {
    //! Another working comment!
}
fn main() {}</pre></div> <p>In case you want to document the item following the doc comment, you might want to use outer doc comment:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
/// I am an outer doc comment
#[doc = "I am also an outer doc comment!"]
fn foo() {
    // ...
}</pre></div>  <h3 id="E0754" class="section-header">E0754</h3> <p>An non-ascii identifier was used in an invalid context.</p> <p>Erroneous code examples:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">

mod řųśť; // error!

#[no_mangle]
fn řųśť() {} // error!

fn main() {}</pre></div> <p>Non-ascii can be used as module names if it is inlined or if a <code>#[path]</code> attribute is specified. For example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">

mod řųśť { // ok!
    const IS_GREAT: bool = true;
}

fn main() {}</pre></div>     <h3 id="E0758" class="section-header">E0758</h3> <p>A multi-line (doc-)comment is unterminated.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<pre>/* I am not terminated!</pre> <p>The same goes for doc comments:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<pre>/*! I am not terminated!</pre> <p>You need to end your multi-line comment with <code>*/</code> in order to fix this error:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
/* I am terminated! */
/*! I am also terminated! */</pre></div>  <h3 id="E0759" class="section-header">E0759</h3> <p>Return type involving a trait did not require <code>'static</code> lifetime.</p> <p>Erroneous code examples:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
use std::fmt::Debug;

fn foo(x: &amp;i32) -&gt; impl Debug { // error!
    x
}

fn bar(x: &amp;i32) -&gt; Box&lt;dyn Debug&gt; { // error!
    Box::new(x)
}</pre></div> <p>Add <code>'static</code> requirement to fix them:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn foo(x: &amp;i32) -&gt; impl Debug + 'static { // ok!
    x
}

fn bar(x: &amp;i32) -&gt; Box&lt;dyn Debug + 'static&gt; { // ok!
    Box::new(x)
}</pre></div> <p>Both <a href="book/ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types"><code>dyn Trait</code></a> and <a href="book/ch10-02-traits#returning-types-that-implement-traits"><code>impl Trait</code></a> in return types have a an implicit <code>'static</code> requirement, meaning that the value implementing them that is being returned has to be either a <code>'static</code> borrow or an owned value.</p> <p>In order to change the requirement from <code>'static</code> to be a lifetime derived from its arguments, you can add an explicit bound, either to an anonymous lifetime <code>'_</code> or some appropriate named lifetime.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo(x: &amp;i32) -&gt; impl Debug + '_ {
    x
}
fn bar(x: &amp;i32) -&gt; Box&lt;dyn Debug + '_&gt; {
    Box::new(x)
}</pre></div> <p>These are equivalent to the following explicit lifetime annotations:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; impl Debug + 'a {
    x
}
fn bar&lt;'a&gt;(x: &amp;'a i32) -&gt; Box&lt;dyn Debug + 'a&gt; {
    Box::new(x)
}</pre></div>  <h3 id="E0760" class="section-header">E0760</h3> <p><code>async fn</code>/<code>impl trait</code> return type cannot contain a projection or <code>Self</code> that references lifetimes from a parent scope.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct S&lt;'a&gt;(&amp;'a i32);

impl&lt;'a&gt; S&lt;'a&gt; {
    async fn new(i: &amp;'a i32) -&gt; Self {
        S(&amp;22)
    }
}</pre></div> <p>To fix this error we need to spell out <code>Self</code> to <code>S&lt;'a&gt;</code>:</p> <div class="information">ⓘThis code runs with edition 2018</div>
<div class="example-wrap"><pre class="rust rust-example-rendered edition " data-language="rust">
struct S&lt;'a&gt;(&amp;'a i32);

impl&lt;'a&gt; S&lt;'a&gt; {
    async fn new(i: &amp;'a i32) -&gt; S&lt;'a&gt; {
        S(&amp;22)
    }
}</pre></div> <p>This will be allowed at some point in the future, but the implementation is not yet complete. See the <a href="https://github.com/rust-lang/rust/issues/61949">issue-61949</a> for this limitation.</p>  <h3 id="E0761" class="section-header">E0761</h3> <p>Multiple candidate files were found for an out-of-line module.</p> <p>Erroneous code example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
// file: ambiguous_module/mod.rs

fn foo() {}</pre></div> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
// file: ambiguous_module.rs

fn foo() {}</pre></div> <div class="information">ⓘThis example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">
mod ambiguous_module; // error: file for module `ambiguous_module`
                      // found at both ambiguous_module.rs and
                      // ambiguous_module.rs/mod.rs

fn main() {}</pre></div> <p>Please remove this ambiguity by deleting/renaming one of the candidate files.</p>  <h3 id="E0762" class="section-header">E0762</h3> <p>A character literal wasn't ended with a quote.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<pre>static C: char = '●; // error!</pre> <p>To fix this error, add the missing quote:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
static C: char = '●'; // ok!</pre></div>  <h3 id="E0763" class="section-header">E0763</h3> <p>A byte constant wasn't correctly ended.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<pre>let c = b'a; // error!</pre> <p>To fix this error, add the missing quote:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let c = b'a'; // ok!</pre></div>  <h3 id="E0764" class="section-header">E0764</h3> <p>Mutable references (<code>&amp;mut</code>) can only be used in constant functions, not statics or constants. This limitation exists to prevent the creation of constants that have a mutable reference in their final value. If you had a constant of <code>&amp;mut i32</code> type, you could modify the value through that reference, making the constant essentially mutable. While there could be a more fine-grained scheme in the future that allows mutable references if they are not "leaked" to the final value, a more conservative approach was chosen for now. <code>const fn</code> do not have this problem, as the borrow checker will prevent the <code>const fn</code> from returning new mutable references.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(const_fn)]
#![feature(const_mut_refs)]

fn main() {
    const OH_NO: &amp;'static mut usize = &amp;mut 1; // error!
}</pre></div> <p>Remember: you cannot use a function call inside a constant or static. However, you can totally use it in constant functions:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(const_fn)]
#![feature(const_mut_refs)]

const fn foo(x: usize) -&gt; usize {
    let mut y = 1;
    let z = &amp;mut y;
    *z += x;
    y
}

fn main() {
    const FOO: usize = foo(10); // ok!
}</pre></div>  <h3 id="E0765" class="section-header">E0765</h3> <p>A double quote string (<code>"</code>) was not terminated.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<pre>let s = "; // error!</pre> <p>To fix this error, add the missing double quote at the end of the string:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s = ""; // ok!</pre></div>  <h3 id="E0766" class="section-header">E0766</h3> <p>A double quote byte string (<code>b"</code>) was not terminated.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<pre>let s = b"; // error!</pre> <p>To fix this error, add the missing double quote at the end of the string:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s = b""; // ok!</pre></div>  <h3 id="E0767" class="section-header">E0767</h3> <p>An unreachable label was used.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
'a: loop {
    || {
        loop { break 'a } // error: use of unreachable label `'a`
    };
}</pre></div> <p>Ensure that the label is within scope. Labels are not reachable through functions, closures, async blocks or modules. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
'a: loop {
    break 'a; // ok!
}</pre></div>  <h3 id="E0768" class="section-header">E0768</h3> <p>A number in a non-decimal base has no digits.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let s: i32 = 0b; // error!</pre></div> <p>To fix this error, add the missing digits:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s: i32 = 0b1; // ok!</pre></div>  <h3 id="E0769" class="section-header">E0769</h3> <p>A tuple struct or tuple variant was used in a pattern as if it were a struct or struct variant.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
enum E {
    A(i32),
}
let e = E::A(42);
match e {
    E::A { number } =&gt; println!("{}", x),
}</pre></div> <p>To fix this error, you can use the tuple pattern:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
match e {
    E::A(number) =&gt; println!("{}", number),
}</pre></div> <p>Alternatively, you can also use the struct pattern by using the correct field names and binding them to new identifiers:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
match e {
    E::A { 0: number } =&gt; println!("{}", number),
}</pre></div>  <h3 id="E0770" class="section-header">E0770</h3> <p>The type of a const parameter references other generic parameters.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(const_generics)]
fn foo&lt;T, const N: T&gt;() {} // error!</pre></div> <p>To fix this error, use a concrete type for the const parameter:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(const_generics)]
fn foo&lt;T, const N: usize&gt;() {}</pre></div>  <h3 id="E0771" class="section-header">E0771</h3> <p>A non-<code>'static</code> lifetime was used in a const generic. This is currently not allowed.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(const_generics)]

fn function_with_str&lt;'a, const STRING: &amp;'a str&gt;() {} // error!</pre></div> <p>To fix this issue, the lifetime in the const generic need to be changed to <code>'static</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(const_generics)]

fn function_with_str&lt;const STRING: &amp;'static str&gt;() {} // ok!</pre></div> <p>For more information, see <a href="https://github.com/rust-lang/rust/issues/74052">GitHub issue #74052</a>.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/error-index.html" class="_attribution-link">https://doc.rust-lang.org/error-index.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
