
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>I&#47;O in Trio - Trio - W3cubDocs</title>
  
  <meta name="description" content=" Trio provides a set of abstract base classes that define a standard interface for unidirectional and bidirectional byte streams. ">
  <meta name="keywords" content="i, o, trio">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/trio/reference-io.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/trio.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/trio/" class="_nav-link" title="" style="margin-left:0;">Trio</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _simple">
				
				
<h1>I/O in Trio</h1>  <h2>The abstract Stream API</h2> <p>Trio provides a set of abstract base classes that define a standard interface for unidirectional and bidirectional byte streams.</p> <p>Why is this useful? Because it lets you write generic protocol implementations that can work over arbitrary transports, and easily create complex transport configurations. Here’s some examples:</p> <ul> <li><p><a class="reference internal" href="#trio.SocketStream" title="trio.SocketStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.SocketStream</span></code></a> wraps a raw socket (like a TCP connection over the network), and converts it to the standard stream interface.</p></li> <li><p><a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.SSLStream</span></code></a> is a “stream adapter” that can take any object that implements the <a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.Stream</span></code></a> interface, and convert it into an encrypted stream. In Trio the standard way to speak SSL over the network is to wrap an <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> around a <a class="reference internal" href="#trio.SocketStream" title="trio.SocketStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketStream</span></code></a>.</p></li> <li>
<p>If you spawn a <a class="reference internal" href="#subprocess"><span class="std std-ref">Spawning subprocesses</span></a>, you can get a <a class="reference internal" href="#trio.abc.SendStream" title="trio.abc.SendStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendStream</span></code></a> that lets you write to its stdin, and a <a class="reference internal" href="#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveStream</span></code></a> that lets you read from its stdout. If for some reason you wanted to speak SSL to a subprocess, you could use a <a class="reference internal" href="#trio.StapledStream" title="trio.StapledStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">StapledStream</span></code></a> to combine its stdin/stdout into a single bidirectional <a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a>, and then wrap that in an <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a>:</p> <pre data-language="python">ssl_context = ssl.create_default_context()
ssl_context.check_hostname = False
s = SSLStream(StapledStream(process.stdin, process.stdout), ssl_context)</pre> </li> <li>
<p>It sometimes happens that you want to connect to an HTTPS server, but you have to go through a web proxy… and the proxy also uses HTTPS. So you end up having to do <a class="reference external" href="https://daniel.haxx.se/blog/2016/11/26/https-proxy-with-curl/">SSL-on-top-of-SSL</a>. In Trio this is trivial – just wrap your first <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> in a second <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a>:</p> <pre data-language="python"># Get a raw SocketStream connection to the proxy:
s0 = await open_tcp_stream("proxy", 443)

# Set up SSL connection to proxy:
s1 = SSLStream(s0, proxy_ssl_context, server_hostname="proxy")
# Request a connection to the website
await s1.send_all(b"CONNECT website:443 / HTTP/1.0\r\n\r\n")
await check_CONNECT_response(s1)

# Set up SSL connection to the real website. Notice that s1 is
# already an SSLStream object, and here we're wrapping a second
# SSLStream object around it.
s2 = SSLStream(s1, website_ssl_context, server_hostname="website")
# Make our request
await s2.send_all(b"GET /index.html HTTP/1.0\r\n\r\n")
...</pre> </li> <li><p>The <a class="reference internal" href="reference-testing#module-trio.testing" title="trio.testing"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.testing</span></code></a> module provides a set of <a class="reference internal" href="reference-testing#testing-streams"><span class="std std-ref">flexible in-memory stream object implementations</span></a>, so if you have a protocol implementation to test then you can can start two tasks, set up a virtual “socket” connecting them, and then do things like inject random-but-repeatable delays into the connection.</p></li> </ul>  <h3>Abstract base classes</h3> <table class="colwidths-auto docutils align-default" id="id1"> <caption><span class="caption-text">Overview: abstract base classes for I/O</span></caption> <thead> <tr class="row-odd">
<th class="head"><p>Abstract base class</p></th> <th class="head"><p>Inherits from…</p></th> <th class="head"><p>Adds these abstract methods…</p></th> <th class="head"><p>And these concrete methods.</p></th> <th class="head"><p>Example implementations</p></th> </tr> </thead> <tbody> <tr class="row-even">
<td><p><a class="reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResource</span></code></a></p></td> <td></td> <td><p><a class="reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a></p></td> <td><p><code class="docutils literal notranslate"><span class="pre">__aenter__</span></code>, <code class="docutils literal notranslate"><span class="pre">__aexit__</span></code></p></td> <td><p><a class="reference internal" href="#async-file-objects"><span class="std std-ref">Asynchronous file objects</span></a></p></td> </tr> <tr class="row-odd">
<td><p><a class="reference internal" href="#trio.abc.SendStream" title="trio.abc.SendStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendStream</span></code></a></p></td> <td><p><a class="reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResource</span></code></a></p></td> <td><p><a class="reference internal" href="#trio.abc.SendStream.send_all" title="trio.abc.SendStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_all()</span></code></a>, <a class="reference internal" href="#trio.abc.SendStream.wait_send_all_might_not_block" title="trio.abc.SendStream.wait_send_all_might_not_block"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait_send_all_might_not_block()</span></code></a></p></td> <td></td> <td><p><a class="reference internal" href="reference-testing#trio.testing.MemorySendStream" title="trio.testing.MemorySendStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemorySendStream</span></code></a></p></td> </tr> <tr class="row-even">
<td><p><a class="reference internal" href="#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveStream</span></code></a></p></td> <td><p><a class="reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResource</span></code></a></p></td> <td><p><a class="reference internal" href="#trio.abc.ReceiveStream.receive_some" title="trio.abc.ReceiveStream.receive_some"><code class="xref py py-meth docutils literal notranslate"><span class="pre">receive_some()</span></code></a></p></td> <td><p><code class="docutils literal notranslate"><span class="pre">__aiter__</span></code>, <code class="docutils literal notranslate"><span class="pre">__anext__</span></code></p></td> <td><p><a class="reference internal" href="reference-testing#trio.testing.MemoryReceiveStream" title="trio.testing.MemoryReceiveStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryReceiveStream</span></code></a></p></td> </tr> <tr class="row-odd">
<td><p><a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a></p></td> <td><p><a class="reference internal" href="#trio.abc.SendStream" title="trio.abc.SendStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendStream</span></code></a>, <a class="reference internal" href="#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveStream</span></code></a></p></td> <td></td> <td></td> <td><p><a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a></p></td> </tr> <tr class="row-even">
<td><p><a class="reference internal" href="#trio.abc.HalfCloseableStream" title="trio.abc.HalfCloseableStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">HalfCloseableStream</span></code></a></p></td> <td><p><a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a></p></td> <td><p><a class="reference internal" href="#trio.abc.HalfCloseableStream.send_eof" title="trio.abc.HalfCloseableStream.send_eof"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_eof()</span></code></a></p></td> <td></td> <td><p><a class="reference internal" href="#trio.SocketStream" title="trio.SocketStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketStream</span></code></a>, <a class="reference internal" href="#trio.StapledStream" title="trio.StapledStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">StapledStream</span></code></a></p></td> </tr> <tr class="row-odd">
<td><p><a class="reference internal" href="#trio.abc.Listener" title="trio.abc.Listener"><code class="xref py py-class docutils literal notranslate"><span class="pre">Listener</span></code></a></p></td> <td><p><a class="reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResource</span></code></a></p></td> <td><p><a class="reference internal" href="#trio.abc.Listener.accept" title="trio.abc.Listener.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">accept()</span></code></a></p></td> <td></td> <td><p><a class="reference internal" href="#trio.SocketListener" title="trio.SocketListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketListener</span></code></a>, <a class="reference internal" href="#trio.SSLListener" title="trio.SSLListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLListener</span></code></a></p></td> </tr> <tr class="row-even">
<td><p><a class="reference internal" href="#trio.abc.SendChannel" title="trio.abc.SendChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendChannel</span></code></a></p></td> <td><p><a class="reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResource</span></code></a></p></td> <td><p><a class="reference internal" href="#trio.abc.SendChannel.send" title="trio.abc.SendChannel.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a></p></td> <td></td> <td><p><a class="reference internal" href="reference-core#trio.MemorySendChannel" title="trio.MemorySendChannel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MemorySendChannel</span></code></a></p></td> </tr> <tr class="row-odd">
<td><p><a class="reference internal" href="#trio.abc.ReceiveChannel" title="trio.abc.ReceiveChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveChannel</span></code></a></p></td> <td><p><a class="reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResource</span></code></a></p></td> <td><p><a class="reference internal" href="#trio.abc.ReceiveChannel.receive" title="trio.abc.ReceiveChannel.receive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">receive()</span></code></a></p></td> <td><p><code class="docutils literal notranslate"><span class="pre">__aiter__</span></code>, <code class="docutils literal notranslate"><span class="pre">__anext__</span></code></p></td> <td><p><a class="reference internal" href="reference-core#trio.MemoryReceiveChannel" title="trio.MemoryReceiveChannel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MemoryReceiveChannel</span></code></a></p></td> </tr> <tr class="row-even">
<td><p><a class="reference internal" href="#trio.abc.Channel" title="trio.abc.Channel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Channel</span></code></a></p></td> <td><p><a class="reference internal" href="#trio.abc.SendChannel" title="trio.abc.SendChannel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SendChannel</span></code></a>, <a class="reference internal" href="#trio.abc.ReceiveChannel" title="trio.abc.ReceiveChannel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReceiveChannel</span></code></a></p></td> <td></td> <td></td> <td></td> </tr> </tbody> </table> <dl class="class"> <h3 id="trio.abc.AsyncResource"><code><em>class</em> trio.abc.AsyncResource</code></h3> <dd>
<p>A standard interface for resources that needs to be cleaned up, and where that cleanup may require blocking operations.</p> <p>This class distinguishes between “graceful” closes, which may perform I/O and thus block, and a “forceful” close, which cannot. For example, cleanly shutting down a TLS-encrypted connection requires sending a “goodbye” message; but if a peer has become non-responsive, then sending this message might block forever, so we may want to just drop the connection instead. Therefore the <a class="reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> method is unusual in that it should always close the connection (or at least make its best attempt) <em>even if it fails</em>; failure indicates a failure to achieve grace, not a failure to close the connection.</p> <p>Objects that implement this interface can be used as async context managers, i.e., you can write:</p> <pre data-language="python">async with create_resource() as some_async_resource:
    ...</pre> <p>Entering the context manager is synchronous (not a checkpoint); exiting it calls <a class="reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a>. The default implementations of <code class="docutils literal notranslate"><span class="pre">__aenter__</span></code> and <code class="docutils literal notranslate"><span class="pre">__aexit__</span></code> should be adequate for all subclasses.</p> <dl class="method"> <h3 id="trio.abc.AsyncResource.aclose"><code><em>abstractmethod await</em> aclose()</code></h3> <dd>
<p>Close this resource, possibly blocking.</p> <p>IMPORTANT: This method may block in order to perform a “graceful” shutdown. But, if this fails, then it still <em>must</em> close any underlying resources before returning. An error from this method indicates a failure to achieve grace, <em>not</em> a failure to close the connection.</p> <p>For example, suppose we call <a class="reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> on a TLS-encrypted connection. This requires sending a “goodbye” message; but if the peer has become non-responsive, then our attempt to send this message might block forever, and eventually time out and be cancelled. In this case the <a class="reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> method on <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> will immediately close the underlying transport stream using <a class="reference internal" href="#trio.aclose_forcefully" title="trio.aclose_forcefully"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.aclose_forcefully()</span></code></a> before raising <a class="reference internal" href="reference-core#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a>.</p> <p>If the resource is already closed, then this method should silently succeed.</p> <p>Once this method completes, any other pending or future operations on this resource should generally raise <a class="reference internal" href="reference-core#trio.ClosedResourceError" title="trio.ClosedResourceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ClosedResourceError</span></code></a>, unless there’s a good reason to do otherwise.</p> <p>See also: <a class="reference internal" href="#trio.aclose_forcefully" title="trio.aclose_forcefully"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.aclose_forcefully()</span></code></a>.</p> </dd>
</dl> </dd>
</dl> <dl class="function"> <h3 id="trio.aclose_forcefully"><code><em>await</em> trio.aclose_forcefully(resource)</code></h3> <dd>
<p>Close an async resource or async generator immediately, without blocking to do any graceful cleanup.</p> <p><a class="reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResource</span></code></a> objects guarantee that if their <a class="reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> method is cancelled, then they will still close the resource (albeit in a potentially ungraceful fashion). <a class="reference internal" href="#trio.aclose_forcefully" title="trio.aclose_forcefully"><code class="xref py py-func docutils literal notranslate"><span class="pre">aclose_forcefully()</span></code></a> is a convenience function that exploits this behavior to let you force a resource to be closed without blocking: it works by calling <code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">resource.aclose()</span></code> and then cancelling it immediately.</p> <p>Most users won’t need this, but it may be useful on cleanup paths where you can’t afford to block, or if you want to close a resource and don’t care about handling it gracefully. For example, if <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> encounters an error and cannot perform its own graceful close, then there’s no point in waiting to gracefully shut down the underlying transport either, so it calls <code class="docutils literal notranslate"><span class="pre">await</span>
<span class="pre">aclose_forcefully(self.transport_stream)</span></code>.</p> <p>Note that this function is async, and that it acts as a checkpoint, but unlike most async functions it cannot block indefinitely (at least, assuming the underlying resource object is correctly implemented).</p> </dd>
</dl> <dl class="class"> <h3 id="trio.abc.SendStream"><code><em>class</em> trio.abc.SendStream</code></h3> <dd>
<p>Bases: <a class="reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.AsyncResource</span></code></a></p> <p>A standard interface for sending data on a byte stream.</p> <p>The underlying stream may be unidirectional, or bidirectional. If it’s bidirectional, then you probably want to also implement <a class="reference internal" href="#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveStream</span></code></a>, which makes your object a <a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a>.</p> <p><a class="reference internal" href="#trio.abc.SendStream" title="trio.abc.SendStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendStream</span></code></a> objects also implement the <a class="reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResource</span></code></a> interface, so they can be closed by calling <a class="reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> or using an <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> block.</p> <p>If you want to send Python objects rather than raw bytes, see <a class="reference internal" href="#trio.abc.SendChannel" title="trio.abc.SendChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendChannel</span></code></a>.</p> <dl class="method"> <h3 id="trio.abc.SendStream.send_all"><code><em>abstractmethod await</em> send_all(data)</code></h3> <dd>
<p>Sends the given data through the stream, blocking if necessary.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<p><code>data</code> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytes" title="(in Python v3.7)"><em>bytes</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytearray" title="(in Python v3.7)"><em>bytearray</em></a><em>, or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#memoryview" title="(in Python v3.7)"><em>memoryview</em></a>) – The data to send.</p> </dd> <h4 class="field-even" style="margin: 0">Raises</h4> <dd class="field-even">
<ul class="simple"> <li><p><a class="reference internal" href="reference-core#trio.BusyResourceError" title="trio.BusyResourceError"><code>trio.BusyResourceError</code></a> – if another task is already executing a <a class="reference internal" href="#trio.abc.SendStream.send_all" title="trio.abc.SendStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_all()</span></code></a>, <a class="reference internal" href="#trio.abc.SendStream.wait_send_all_might_not_block" title="trio.abc.SendStream.wait_send_all_might_not_block"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait_send_all_might_not_block()</span></code></a>, or <a class="reference internal" href="#trio.abc.HalfCloseableStream.send_eof" title="trio.abc.HalfCloseableStream.send_eof"><code class="xref py py-meth docutils literal notranslate"><span class="pre">HalfCloseableStream.send_eof()</span></code></a> on this stream.</p></li> <li><p><a class="reference internal" href="reference-core#trio.BrokenResourceError" title="trio.BrokenResourceError"><code>trio.BrokenResourceError</code></a> – if something has gone wrong, and the stream is broken.</p></li> <li><p><a class="reference internal" href="reference-core#trio.ClosedResourceError" title="trio.ClosedResourceError"><code>trio.ClosedResourceError</code></a> – if you previously closed this stream object, or if another task closes this stream object while <a class="reference internal" href="#trio.abc.SendStream.send_all" title="trio.abc.SendStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_all()</span></code></a> is running.</p></li> </ul> </dd> </dl> <p>Most low-level operations in Trio provide a guarantee: if they raise <a class="reference internal" href="reference-core#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">trio.Cancelled</span></code></a>, this means that they had no effect, so the system remains in a known state. This is <strong>not true</strong> for <a class="reference internal" href="#trio.abc.SendStream.send_all" title="trio.abc.SendStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_all()</span></code></a>. If this operation raises <a class="reference internal" href="reference-core#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">trio.Cancelled</span></code></a> (or any other exception for that matter), then it may have sent some, all, or none of the requested data, and there is no way to know which.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.abc.SendStream.wait_send_all_might_not_block"><code><em>abstractmethod await</em> wait_send_all_might_not_block()</code></h3> <dd>
<p>Block until it’s possible that <a class="reference internal" href="#trio.abc.SendStream.send_all" title="trio.abc.SendStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_all()</span></code></a> might not block.</p> <p>This method may return early: it’s possible that after it returns, <a class="reference internal" href="#trio.abc.SendStream.send_all" title="trio.abc.SendStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_all()</span></code></a> will still block. (In the worst case, if no better implementation is available, then it might always return immediately without blocking. It’s nice to do better than that when possible, though.)</p> <p>This method <strong>must not</strong> return <em>late</em>: if it’s possible for <a class="reference internal" href="#trio.abc.SendStream.send_all" title="trio.abc.SendStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_all()</span></code></a> to complete without blocking, then it must return. When implementing it, err on the side of returning early.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Raises</h4> <dd class="field-odd">
<ul class="simple"> <li><p><a class="reference internal" href="reference-core#trio.BusyResourceError" title="trio.BusyResourceError"><code>trio.BusyResourceError</code></a> – if another task is already executing a <a class="reference internal" href="#trio.abc.SendStream.send_all" title="trio.abc.SendStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_all()</span></code></a>, <a class="reference internal" href="#trio.abc.SendStream.wait_send_all_might_not_block" title="trio.abc.SendStream.wait_send_all_might_not_block"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait_send_all_might_not_block()</span></code></a>, or <a class="reference internal" href="#trio.abc.HalfCloseableStream.send_eof" title="trio.abc.HalfCloseableStream.send_eof"><code class="xref py py-meth docutils literal notranslate"><span class="pre">HalfCloseableStream.send_eof()</span></code></a> on this stream.</p></li> <li><p><a class="reference internal" href="reference-core#trio.BrokenResourceError" title="trio.BrokenResourceError"><code>trio.BrokenResourceError</code></a> – if something has gone wrong, and the stream is broken.</p></li> <li><p><a class="reference internal" href="reference-core#trio.ClosedResourceError" title="trio.ClosedResourceError"><code>trio.ClosedResourceError</code></a> – if you previously closed this stream object, or if another task closes this stream object while <a class="reference internal" href="#trio.abc.SendStream.wait_send_all_might_not_block" title="trio.abc.SendStream.wait_send_all_might_not_block"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait_send_all_might_not_block()</span></code></a> is running.</p></li> </ul> </dd> </dl> <blockquote class="admonition note"> <h4 class="admonition-title">Note</h4> <p>This method is intended to aid in implementing protocols that want to delay choosing which data to send until the last moment. E.g., suppose you’re working on an implemention of a remote display server like <a class="reference external" href="https://en.wikipedia.org/wiki/Virtual_Network_Computing">VNC</a>, and the network connection is currently backed up so that if you call <a class="reference internal" href="#trio.abc.SendStream.send_all" title="trio.abc.SendStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_all()</span></code></a> now then it will sit for 0.5 seconds before actually sending anything. In this case it doesn’t make sense to take a screenshot, then wait 0.5 seconds, and then send it, because the screen will keep changing while you wait; it’s better to wait 0.5 seconds, then take the screenshot, and then send it, because this way the data you deliver will be more up-to-date. Using <a class="reference internal" href="#trio.abc.SendStream.wait_send_all_might_not_block" title="trio.abc.SendStream.wait_send_all_might_not_block"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait_send_all_might_not_block()</span></code></a> makes it possible to implement the better strategy.</p> <p>If you use this method, you might also want to read up on <code class="docutils literal notranslate"><span class="pre">TCP_NOTSENT_LOWAT</span></code>.</p> <p>Further reading:</p> <ul class="simple"> <li><p><a class="reference external" href="https://insouciant.org/tech/prioritization-only-works-when-theres-pending-data-to-prioritize/">Prioritization Only Works When There’s Pending Data to Prioritize</a></p></li> <li><p>WWDC 2015: Your App and Next Generation Networks: <a class="reference external" href="http://devstreaming.apple.com/videos/wwdc/2015/719ui2k57m/719/719_your_app_and_next_generation_networks.pdf?dl=1">slides</a>, <a class="reference external" href="https://developer.apple.com/videos/play/wwdc2015/719/">video and transcript</a></p></li> </ul> </blockquote> </dd>
</dl> </dd>
</dl> <dl class="class"> <h3 id="trio.abc.ReceiveStream"><code><em>class</em> trio.abc.ReceiveStream</code></h3> <dd>
<p>Bases: <a class="reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.AsyncResource</span></code></a></p> <p>A standard interface for receiving data on a byte stream.</p> <p>The underlying stream may be unidirectional, or bidirectional. If it’s bidirectional, then you probably want to also implement <a class="reference internal" href="#trio.abc.SendStream" title="trio.abc.SendStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendStream</span></code></a>, which makes your object a <a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a>.</p> <p><a class="reference internal" href="#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveStream</span></code></a> objects also implement the <a class="reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResource</span></code></a> interface, so they can be closed by calling <a class="reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> or using an <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> block.</p> <p>If you want to receive Python objects rather than raw bytes, see <a class="reference internal" href="#trio.abc.ReceiveChannel" title="trio.abc.ReceiveChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveChannel</span></code></a>.</p> <p><a class="reference internal" href="#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReceiveStream</span></code></a> objects can be used in <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> loops. Each iteration will produce an arbitrary sized chunk of bytes, like calling <a class="reference internal" href="#trio.abc.ReceiveStream.receive_some" title="trio.abc.ReceiveStream.receive_some"><code class="xref py py-obj docutils literal notranslate"><span class="pre">receive_some</span></code></a> with no arguments. Every chunk will contain at least one byte, and the loop automatically exits when reaching end-of-file.</p> <dl class="method"> <h3 id="trio.abc.ReceiveStream.receive_some"><code><em>abstractmethod await</em> receive_some(max_bytes=None)</code></h3> <dd>
<p>Wait until there is data available on this stream, and then return some of it.</p> <p>A return value of <code class="docutils literal notranslate"><span class="pre">b""</span></code> (an empty bytestring) indicates that the stream has reached end-of-file. Implementations should be careful that they return <code class="docutils literal notranslate"><span class="pre">b""</span></code> if, and only if, the stream has reached end-of-file!</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<p><code>max_bytes</code> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – The maximum number of bytes to return. Must be greater than zero. Optional; if omitted, then the stream object is free to pick a reasonable default.</p> </dd> <h4 class="field-even" style="margin: 0">Returns</h4> <dd class="field-even">
<p>The data received.</p> </dd> <h4 class="field-odd" style="margin: 0">Return type</h4> <dd class="field-odd">
<p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytes" title="(in Python v3.7)">bytes</a> or <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytearray" title="(in Python v3.7)">bytearray</a></p> </dd> <h4 class="field-even" style="margin: 0">Raises</h4> <dd class="field-even">
<ul class="simple"> <li><p><a class="reference internal" href="reference-core#trio.BusyResourceError" title="trio.BusyResourceError"><code>trio.BusyResourceError</code></a> – if two tasks attempt to call <a class="reference internal" href="#trio.abc.ReceiveStream.receive_some" title="trio.abc.ReceiveStream.receive_some"><code class="xref py py-meth docutils literal notranslate"><span class="pre">receive_some()</span></code></a> on the same stream at the same time.</p></li> <li><p><a class="reference internal" href="reference-core#trio.BrokenResourceError" title="trio.BrokenResourceError"><code>trio.BrokenResourceError</code></a> – if something has gone wrong, and the stream is broken.</p></li> <li><p><a class="reference internal" href="reference-core#trio.ClosedResourceError" title="trio.ClosedResourceError"><code>trio.ClosedResourceError</code></a> – if you previously closed this stream object, or if another task closes this stream object while <a class="reference internal" href="#trio.abc.ReceiveStream.receive_some" title="trio.abc.ReceiveStream.receive_some"><code class="xref py py-meth docutils literal notranslate"><span class="pre">receive_some()</span></code></a> is running.</p></li> </ul> </dd> </dl> </dd>
</dl> </dd>
</dl> <dl class="class"> <h3 id="trio.abc.Stream"><code><em>class</em> trio.abc.Stream</code></h3> <dd>
<p>Bases: <a class="reference internal" href="#trio.abc.SendStream" title="trio.abc.SendStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.SendStream</span></code></a>, <a class="reference internal" href="#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.ReceiveStream</span></code></a></p> <p>A standard interface for interacting with bidirectional byte streams.</p> <p>A <a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a> is an object that implements both the <a class="reference internal" href="#trio.abc.SendStream" title="trio.abc.SendStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendStream</span></code></a> and <a class="reference internal" href="#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveStream</span></code></a> interfaces.</p> <p>If implementing this interface, you should consider whether you can go one step further and implement <a class="reference internal" href="#trio.abc.HalfCloseableStream" title="trio.abc.HalfCloseableStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">HalfCloseableStream</span></code></a>.</p> </dd>
</dl> <dl class="class"> <h3 id="trio.abc.HalfCloseableStream"><code><em>class</em> trio.abc.HalfCloseableStream</code></h3> <dd>
<p>Bases: <a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.Stream</span></code></a></p> <p>This interface extends <a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a> to also allow closing the send part of the stream without closing the receive part.</p> <dl class="method"> <h3 id="trio.abc.HalfCloseableStream.send_eof"><code><em>abstractmethod await</em> send_eof()</code></h3> <dd>
<p>Send an end-of-file indication on this stream, if possible.</p> <p>The difference between <a class="reference internal" href="#trio.abc.HalfCloseableStream.send_eof" title="trio.abc.HalfCloseableStream.send_eof"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_eof()</span></code></a> and <a class="reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> is that <a class="reference internal" href="#trio.abc.HalfCloseableStream.send_eof" title="trio.abc.HalfCloseableStream.send_eof"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_eof()</span></code></a> is a <em>unidirectional</em> end-of-file indication. After you call this method, you shouldn’t try sending any more data on this stream, and your remote peer should receive an end-of-file indication (eventually, after receiving all the data you sent before that). But, they may continue to send data to you, and you can continue to receive it by calling <a class="reference internal" href="#trio.abc.ReceiveStream.receive_some" title="trio.abc.ReceiveStream.receive_some"><code class="xref py py-meth docutils literal notranslate"><span class="pre">receive_some()</span></code></a>. You can think of it as calling <a class="reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> on just the <a class="reference internal" href="#trio.abc.SendStream" title="trio.abc.SendStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendStream</span></code></a> “half” of the stream object (and in fact that’s literally how <a class="reference internal" href="#trio.StapledStream" title="trio.StapledStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.StapledStream</span></code></a> implements it).</p> <p>Examples:</p> <ul class="simple"> <li><p>On a socket, this corresponds to <code class="docutils literal notranslate"><span class="pre">shutdown(...,</span> <span class="pre">SHUT_WR)</span></code> (<a class="reference external" href="https://linux.die.net/man/2/shutdown">man page</a>).</p></li> <li><p>The SSH protocol provides the ability to multiplex bidirectional “channels” on top of a single encrypted connection. A Trio implementation of SSH could expose these channels as <a class="reference internal" href="#trio.abc.HalfCloseableStream" title="trio.abc.HalfCloseableStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">HalfCloseableStream</span></code></a> objects, and calling <a class="reference internal" href="#trio.abc.HalfCloseableStream.send_eof" title="trio.abc.HalfCloseableStream.send_eof"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_eof()</span></code></a> would send an <code class="docutils literal notranslate"><span class="pre">SSH_MSG_CHANNEL_EOF</span></code> request (see <a class="reference external" href="https://tools.ietf.org/html/rfc4254#section-5.3">RFC 4254 §5.3</a>).</p></li> <li><p>On an SSL/TLS-encrypted connection, the protocol doesn’t provide any way to do a unidirectional shutdown without closing the connection entirely, so <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> implements <a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a>, not <a class="reference internal" href="#trio.abc.HalfCloseableStream" title="trio.abc.HalfCloseableStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">HalfCloseableStream</span></code></a>.</p></li> </ul> <p>If an EOF has already been sent, then this method should silently succeed.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Raises</h4> <dd class="field-odd">
<ul class="simple"> <li><p><a class="reference internal" href="reference-core#trio.BusyResourceError" title="trio.BusyResourceError"><code>trio.BusyResourceError</code></a> – if another task is already executing a <a class="reference internal" href="#trio.abc.SendStream.send_all" title="trio.abc.SendStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_all()</span></code></a>, <a class="reference internal" href="#trio.abc.SendStream.wait_send_all_might_not_block" title="trio.abc.SendStream.wait_send_all_might_not_block"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait_send_all_might_not_block()</span></code></a>, or <a class="reference internal" href="#trio.abc.HalfCloseableStream.send_eof" title="trio.abc.HalfCloseableStream.send_eof"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_eof()</span></code></a> on this stream.</p></li> <li><p><a class="reference internal" href="reference-core#trio.BrokenResourceError" title="trio.BrokenResourceError"><code>trio.BrokenResourceError</code></a> – if something has gone wrong, and the stream is broken.</p></li> <li><p><a class="reference internal" href="reference-core#trio.ClosedResourceError" title="trio.ClosedResourceError"><code>trio.ClosedResourceError</code></a> – if you previously closed this stream object, or if another task closes this stream object while <a class="reference internal" href="#trio.abc.HalfCloseableStream.send_eof" title="trio.abc.HalfCloseableStream.send_eof"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_eof()</span></code></a> is running.</p></li> </ul> </dd> </dl> </dd>
</dl> </dd>
</dl> <dl class="class"> <h3 id="trio.abc.Listener"><code><em>class</em> trio.abc.Listener</code></h3> <dd>
<p>Bases: <a class="reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.AsyncResource</span></code></a>, <a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Generic" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Generic</span></code></a></p> <p>A standard interface for listening for incoming connections.</p> <p><a class="reference internal" href="#trio.abc.Listener" title="trio.abc.Listener"><code class="xref py py-class docutils literal notranslate"><span class="pre">Listener</span></code></a> objects also implement the <a class="reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResource</span></code></a> interface, so they can be closed by calling <a class="reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> or using an <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> block.</p> <dl class="method"> <h3 id="trio.abc.Listener.accept"><code><em>abstractmethod await</em> accept()</code></h3> <dd>
<p>Wait until an incoming connection arrives, and then return it.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Returns</h4> <dd class="field-odd">
<p>An object representing the incoming connection. In practice this is generally some kind of <a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a>, but in principle you could also define a <a class="reference internal" href="#trio.abc.Listener" title="trio.abc.Listener"><code class="xref py py-class docutils literal notranslate"><span class="pre">Listener</span></code></a> that returned, say, channel objects.</p> </dd> <h4 class="field-even" style="margin: 0">Return type</h4> <dd class="field-even">
<p><a class="reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource">AsyncResource</a></p> </dd> <h4 class="field-odd" style="margin: 0">Raises</h4> <dd class="field-odd">
<ul class="simple"> <li><p><a class="reference internal" href="reference-core#trio.BusyResourceError" title="trio.BusyResourceError"><code>trio.BusyResourceError</code></a> – if two tasks attempt to call <a class="reference internal" href="#trio.abc.Listener.accept" title="trio.abc.Listener.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">accept()</span></code></a> on the same listener at the same time.</p></li> <li><p><a class="reference internal" href="reference-core#trio.ClosedResourceError" title="trio.ClosedResourceError"><code>trio.ClosedResourceError</code></a> – if you previously closed this listener object, or if another task closes this listener object while <a class="reference internal" href="#trio.abc.Listener.accept" title="trio.abc.Listener.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">accept()</span></code></a> is running.</p></li> </ul> </dd> </dl> <p>Listeners don’t generally raise <a class="reference internal" href="reference-core#trio.BrokenResourceError" title="trio.BrokenResourceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BrokenResourceError</span></code></a>, because for listeners there is no general condition of “the network/remote peer broke the connection” that can be handled in a generic way, like there is for streams. Other errors <em>can</em> occur and be raised from <a class="reference internal" href="#trio.abc.Listener.accept" title="trio.abc.Listener.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">accept()</span></code></a> – for example, if you run out of file descriptors then you might get an <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#OSError" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">OSError</span></code></a> with its errno set to <code class="docutils literal notranslate"><span class="pre">EMFILE</span></code>.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <h3 id="trio.abc.SendChannel"><code><em>class</em> trio.abc.SendChannel</code></h3> <dd>
<p>Bases: <a class="reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.AsyncResource</span></code></a>, <a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Generic" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Generic</span></code></a></p> <p>A standard interface for sending Python objects to some receiver.</p> <p><a class="reference internal" href="#trio.abc.SendChannel" title="trio.abc.SendChannel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SendChannel</span></code></a> objects also implement the <a class="reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AsyncResource</span></code></a> interface, so they can be closed by calling <a class="reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">aclose</span></code></a> or using an <code class="docutils literal notranslate"><span class="pre">async</span>
<span class="pre">with</span></code> block.</p> <p>If you want to send raw bytes rather than Python objects, see <a class="reference internal" href="#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReceiveStream</span></code></a>.</p> <dl class="method"> <h3 id="trio.abc.SendChannel.send"><code><em>abstractmethod await</em> send(value: SendType) → None</code></h3> <dd>
<p>Attempt to send an object through the channel, blocking if necessary.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<p><code>value</code> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><em>object</em></a>) – The object to send.</p> </dd> <h4 class="field-even" style="margin: 0">Raises</h4> <dd class="field-even">
<ul class="simple"> <li><p><a class="reference internal" href="reference-core#trio.BrokenResourceError" title="trio.BrokenResourceError"><code>trio.BrokenResourceError</code></a> – if something has gone wrong, and the channel is broken. For example, you may get this if the receiver has already been closed.</p></li> <li><p><a class="reference internal" href="reference-core#trio.ClosedResourceError" title="trio.ClosedResourceError"><code>trio.ClosedResourceError</code></a> – if you previously closed this <a class="reference internal" href="#trio.abc.SendChannel" title="trio.abc.SendChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendChannel</span></code></a> object, or if another task closes it while <a class="reference internal" href="#trio.abc.SendChannel.send" title="trio.abc.SendChannel.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> is running.</p></li> <li><p><a class="reference internal" href="reference-core#trio.BusyResourceError" title="trio.BusyResourceError"><code>trio.BusyResourceError</code></a> – some channels allow multiple tasks to call <a class="reference internal" href="#trio.abc.SendChannel.send" title="trio.abc.SendChannel.send"><code class="xref py py-obj docutils literal notranslate"><span class="pre">send</span></code></a> at the same time, but others don’t. If you try to call <a class="reference internal" href="#trio.abc.SendChannel.send" title="trio.abc.SendChannel.send"><code class="xref py py-obj docutils literal notranslate"><span class="pre">send</span></code></a> simultaneously from multiple tasks on a channel that doesn’t support it, then you can get <a class="reference internal" href="reference-core#trio.BusyResourceError" title="trio.BusyResourceError"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BusyResourceError</span></code></a>.</p></li> </ul> </dd> </dl> </dd>
</dl> </dd>
</dl> <dl class="class"> <h3 id="trio.abc.ReceiveChannel"><code><em>class</em> trio.abc.ReceiveChannel</code></h3> <dd>
<p>Bases: <a class="reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.AsyncResource</span></code></a>, <a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Generic" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Generic</span></code></a></p> <p>A standard interface for receiving Python objects from some sender.</p> <p>You can iterate over a <a class="reference internal" href="#trio.abc.ReceiveChannel" title="trio.abc.ReceiveChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveChannel</span></code></a> using an <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> loop:</p> <pre data-language="python">async for value in receive_channel:
    ...</pre> <p>This is equivalent to calling <a class="reference internal" href="#trio.abc.ReceiveChannel.receive" title="trio.abc.ReceiveChannel.receive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">receive()</span></code></a> repeatedly. The loop exits without error when <a class="reference internal" href="#trio.abc.ReceiveChannel.receive" title="trio.abc.ReceiveChannel.receive"><code class="xref py py-obj docutils literal notranslate"><span class="pre">receive</span></code></a> raises <a class="reference internal" href="reference-core#trio.EndOfChannel" title="trio.EndOfChannel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">EndOfChannel</span></code></a>.</p> <p><a class="reference internal" href="#trio.abc.ReceiveChannel" title="trio.abc.ReceiveChannel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReceiveChannel</span></code></a> objects also implement the <a class="reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AsyncResource</span></code></a> interface, so they can be closed by calling <a class="reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">aclose</span></code></a> or using an <code class="docutils literal notranslate"><span class="pre">async</span>
<span class="pre">with</span></code> block.</p> <p>If you want to receive raw bytes rather than Python objects, see <a class="reference internal" href="#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReceiveStream</span></code></a>.</p> <dl class="method"> <h3 id="trio.abc.ReceiveChannel.receive"><code><em>abstractmethod await</em> receive() → ReceiveType</code></h3> <dd>
<p>Attempt to receive an incoming object, blocking if necessary.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Returns</h4> <dd class="field-odd">
<p>Whatever object was received.</p> </dd> <h4 class="field-even" style="margin: 0">Return type</h4> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)">object</a></p> </dd> <h4 class="field-odd" style="margin: 0">Raises</h4> <dd class="field-odd">
<ul class="simple"> <li><p><a class="reference internal" href="reference-core#trio.EndOfChannel" title="trio.EndOfChannel"><code>trio.EndOfChannel</code></a> – if the sender has been closed cleanly, and no more objects are coming. This is not an error condition.</p></li> <li><p><a class="reference internal" href="reference-core#trio.ClosedResourceError" title="trio.ClosedResourceError"><code>trio.ClosedResourceError</code></a> – if you previously closed this <a class="reference internal" href="#trio.abc.ReceiveChannel" title="trio.abc.ReceiveChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveChannel</span></code></a> object.</p></li> <li><p><a class="reference internal" href="reference-core#trio.BrokenResourceError" title="trio.BrokenResourceError"><code>trio.BrokenResourceError</code></a> – if something has gone wrong, and the channel is broken.</p></li> <li><p><a class="reference internal" href="reference-core#trio.BusyResourceError" title="trio.BusyResourceError"><code>trio.BusyResourceError</code></a> – some channels allow multiple tasks to call <a class="reference internal" href="#trio.abc.ReceiveChannel.receive" title="trio.abc.ReceiveChannel.receive"><code class="xref py py-obj docutils literal notranslate"><span class="pre">receive</span></code></a> at the same time, but others don’t. If you try to call <a class="reference internal" href="#trio.abc.ReceiveChannel.receive" title="trio.abc.ReceiveChannel.receive"><code class="xref py py-obj docutils literal notranslate"><span class="pre">receive</span></code></a> simultaneously from multiple tasks on a channel that doesn’t support it, then you can get <a class="reference internal" href="reference-core#trio.BusyResourceError" title="trio.BusyResourceError"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BusyResourceError</span></code></a>.</p></li> </ul> </dd> </dl> </dd>
</dl> </dd>
</dl> <dl class="class"> <h3 id="trio.abc.Channel"><code><em>class</em> trio.abc.Channel</code></h3> <dd>
<p>Bases: <a class="reference internal" href="#trio.abc.SendChannel" title="trio.abc.SendChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.SendChannel</span></code></a>, <a class="reference internal" href="#trio.abc.ReceiveChannel" title="trio.abc.ReceiveChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.ReceiveChannel</span></code></a></p> <p>A standard interface for interacting with bidirectional channels.</p> <p>A <a class="reference internal" href="#trio.abc.Channel" title="trio.abc.Channel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Channel</span></code></a> is an object that implements both the <a class="reference internal" href="#trio.abc.SendChannel" title="trio.abc.SendChannel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SendChannel</span></code></a> and <a class="reference internal" href="#trio.abc.ReceiveChannel" title="trio.abc.ReceiveChannel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReceiveChannel</span></code></a> interfaces, so you can both send and receive objects.</p> </dd>
</dl>   <h3>Generic stream tools</h3> <p>Trio currently provides a generic helper for writing servers that listen for connections using one or more <a class="reference internal" href="#trio.abc.Listener" title="trio.abc.Listener"><code class="xref py py-class docutils literal notranslate"><span class="pre">Listener</span></code></a>s, and a generic utility class for working with streams. And if you want to test code that’s written against the streams interface, you should also check out <a class="reference internal" href="reference-testing#testing-streams"><span class="std std-ref">Streams</span></a> in <a class="reference internal" href="reference-testing#module-trio.testing" title="trio.testing"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.testing</span></code></a>.</p> <dl class="function"> <h3 id="trio.serve_listeners"><code><em>await</em> trio.serve_listeners(handler, listeners, *, handler_nursery=None, task_status=TASK_STATUS_IGNORED)</code></h3> <dd>
<p>Listen for incoming connections on <code class="docutils literal notranslate"><span class="pre">listeners</span></code>, and for each one start a task running <code class="docutils literal notranslate"><span class="pre">handler(stream)</span></code>.</p> <blockquote class="admonition warning"> <h4 class="admonition-title">Warning</h4> <p>If <code class="docutils literal notranslate"><span class="pre">handler</span></code> raises an exception, then this function doesn’t do anything special to catch it – so by default the exception will propagate out and crash your server. If you don’t want this, then catch exceptions inside your <code class="docutils literal notranslate"><span class="pre">handler</span></code>, or use a <code class="docutils literal notranslate"><span class="pre">handler_nursery</span></code> object that responds to exceptions in some other way.</p> </blockquote> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<ul class="simple"> <li><p><code>handler</code> – An async callable, that will be invoked like <code class="docutils literal notranslate"><span class="pre">handler_nursery.start_soon(handler,</span> <span class="pre">stream)</span></code> for each incoming connection.</p></li> <li><p><code>listeners</code> – A list of <a class="reference internal" href="#trio.abc.Listener" title="trio.abc.Listener"><code class="xref py py-class docutils literal notranslate"><span class="pre">Listener</span></code></a> objects. <a class="reference internal" href="#trio.serve_listeners" title="trio.serve_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_listeners()</span></code></a> takes responsibility for closing them.</p></li> <li><p><code>handler_nursery</code> – The nursery used to start handlers, or any object with a <code class="docutils literal notranslate"><span class="pre">start_soon</span></code> method. If <code class="docutils literal notranslate"><span class="pre">None</span></code> (the default), then <a class="reference internal" href="#trio.serve_listeners" title="trio.serve_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_listeners()</span></code></a> will create a new nursery internally and use that.</p></li> <li><p><code>task_status</code> – This function can be used with <code class="docutils literal notranslate"><span class="pre">nursery.start</span></code>, which will return <code class="docutils literal notranslate"><span class="pre">listeners</span></code>.</p></li> </ul> </dd> <h4 class="field-even" style="margin: 0">Returns</h4> <dd class="field-even">
<p>This function never returns unless cancelled.</p> </dd> </dl> <p>Resource handling:</p> <blockquote> <div>
<p>If <code class="docutils literal notranslate"><span class="pre">handler</span></code> neglects to close the <code class="docutils literal notranslate"><span class="pre">stream</span></code>, then it will be closed using <a class="reference internal" href="#trio.aclose_forcefully" title="trio.aclose_forcefully"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.aclose_forcefully()</span></code></a>.</p> </div>
</blockquote> <p>Error handling:</p> <blockquote> <div>
<p>Most errors coming from <a class="reference internal" href="#trio.abc.Listener.accept" title="trio.abc.Listener.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">accept()</span></code></a> are allowed to propagate out (crashing the server in the process). However, some errors – those which indicate that the server is temporarily overloaded – are handled specially. These are <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#OSError" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">OSError</span></code></a>s with one of the following errnos:</p> <ul class="simple"> <li><p><code class="docutils literal notranslate"><span class="pre">EMFILE</span></code>: process is out of file descriptors</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">ENFILE</span></code>: system is out of file descriptors</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">ENOBUFS</span></code>, <code class="docutils literal notranslate"><span class="pre">ENOMEM</span></code>: the kernel hit some sort of memory limitation when trying to create a socket object</p></li> </ul> <p>When <a class="reference internal" href="#trio.serve_listeners" title="trio.serve_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_listeners()</span></code></a> gets one of these errors, then it:</p> <ul class="simple"> <li><p>Logs the error to the standard library logger <code class="docutils literal notranslate"><span class="pre">trio.serve_listeners</span></code> (level = ERROR, with exception information included). By default this causes it to be printed to stderr.</p></li> <li><p>Waits 100 ms before calling <code class="docutils literal notranslate"><span class="pre">accept</span></code> again, in hopes that the system will recover.</p></li> </ul> </div>
</blockquote> </dd>
</dl> <dl class="class"> <h3 id="trio.StapledStream"><code><em>class</em> trio.StapledStream(send_stream, receive_stream)</code></h3> <dd>
<p>Bases: <a class="reference internal" href="#trio.abc.HalfCloseableStream" title="trio.abc.HalfCloseableStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.HalfCloseableStream</span></code></a></p> <p>This class <a class="reference external" href="https://en.wikipedia.org/wiki/Staple_(fastener)">staples</a> together two unidirectional streams to make single bidirectional stream.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<ul class="simple"> <li><p><code>send_stream</code> (<a class="reference internal" href="#trio.abc.SendStream" title="trio.abc.SendStream"><em>SendStream</em></a>) – The stream to use for sending.</p></li> <li><p><code>receive_stream</code> (<a class="reference internal" href="#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream"><em>ReceiveStream</em></a>) – The stream to use for receiving.</p></li> </ul> </dd> </dl> <p class="rubric">Example</p> <p>A silly way to make a stream that echoes back whatever you write to it:</p> <pre data-language="python">left, right = trio.testing.memory_stream_pair()
echo_stream = StapledStream(SocketStream(left), SocketStream(right))
await echo_stream.send_all(b"x")
assert await echo_stream.receive_some() == b"x"</pre> <p><a class="reference internal" href="#trio.StapledStream" title="trio.StapledStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">StapledStream</span></code></a> objects implement the methods in the <a class="reference internal" href="#trio.abc.HalfCloseableStream" title="trio.abc.HalfCloseableStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">HalfCloseableStream</span></code></a> interface. They also have two additional public attributes:</p> <dl class="attribute"> <h3 id="trio.StapledStream.send_stream"><code>send_stream</code></h3> <dd>
<p>The underlying <a class="reference internal" href="#trio.abc.SendStream" title="trio.abc.SendStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendStream</span></code></a>. <a class="reference internal" href="#trio.StapledStream.send_all" title="trio.StapledStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_all()</span></code></a> and <a class="reference internal" href="#trio.StapledStream.wait_send_all_might_not_block" title="trio.StapledStream.wait_send_all_might_not_block"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait_send_all_might_not_block()</span></code></a> are delegated to this object.</p> </dd>
</dl> <dl class="attribute"> <h3 id="trio.StapledStream.receive_stream"><code>receive_stream</code></h3> <dd>
<p>The underlying <a class="reference internal" href="#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveStream</span></code></a>. <a class="reference internal" href="#trio.StapledStream.receive_some" title="trio.StapledStream.receive_some"><code class="xref py py-meth docutils literal notranslate"><span class="pre">receive_some()</span></code></a> is delegated to this object.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.StapledStream.aclose"><code><em>await</em> aclose()</code></h3> <dd>
<p>Calls <code class="docutils literal notranslate"><span class="pre">aclose</span></code> on both underlying streams.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.StapledStream.receive_some"><code><em>await</em> receive_some(max_bytes=None)</code></h3> <dd>
<p>Calls <code class="docutils literal notranslate"><span class="pre">self.receive_stream.receive_some</span></code>.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.StapledStream.send_all"><code><em>await</em> send_all(data)</code></h3> <dd>
<p>Calls <code class="docutils literal notranslate"><span class="pre">self.send_stream.send_all</span></code>.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.StapledStream.send_eof"><code><em>await</em> send_eof()</code></h3> <dd>
<p>Shuts down the send side of the stream.</p> <p>If <code class="docutils literal notranslate"><span class="pre">self.send_stream.send_eof</span></code> exists, then calls it. Otherwise, calls <code class="docutils literal notranslate"><span class="pre">self.send_stream.aclose()</span></code>.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.StapledStream.wait_send_all_might_not_block"><code><em>await</em> wait_send_all_might_not_block()</code></h3> <dd>
<p>Calls <code class="docutils literal notranslate"><span class="pre">self.send_stream.wait_send_all_might_not_block</span></code>.</p> </dd>
</dl> </dd>
</dl>   <h3>Sockets and networking</h3> <p>The high-level network interface is built on top of our stream abstraction.</p> <dl class="function"> <h3 id="trio.open_tcp_stream"><code><em>await</em> trio.open_tcp_stream(host, port, *, happy_eyeballs_delay=0.25)</code></h3> <dd>
<p>Connect to the given host and port over TCP.</p> <p>If the given <code class="docutils literal notranslate"><span class="pre">host</span></code> has multiple IP addresses associated with it, then we have a problem: which one do we use?</p> <p>One approach would be to attempt to connect to the first one, and then if that fails, attempt to connect to the second one … until we’ve tried all of them. But the problem with this is that if the first IP address is unreachable (for example, because it’s an IPv6 address and our network discards IPv6 packets), then we might end up waiting tens of seconds for the first connection attempt to timeout before we try the second address.</p> <p>Another approach would be to attempt to connect to all of the addresses at the same time, in parallel, and then use whichever connection succeeds first, abandoning the others. This would be fast, but create a lot of unnecessary load on the network and the remote server.</p> <p>This function strikes a balance between these two extremes: it works its way through the available addresses one at a time, like the first approach; but, if <code class="docutils literal notranslate"><span class="pre">happy_eyeballs_delay</span></code> seconds have passed and it’s still waiting for an attempt to succeed or fail, then it gets impatient and starts the next connection attempt in parallel. As soon as any one connection attempt succeeds, all the other attempts are cancelled. This avoids unnecessary load because most connections will succeed after just one or two attempts, but if one of the addresses is unreachable then it doesn’t slow us down too much.</p> <p>This is known as a “happy eyeballs” algorithm, and our particular variant is modelled after how Chrome connects to webservers; see <a class="reference external" href="https://tools.ietf.org/html/rfc6555">RFC 6555</a> for more details.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<ul class="simple"> <li><p><code>host</code> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><em>str</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytes" title="(in Python v3.7)"><em>bytes</em></a>) – The host to connect to. Can be an IPv4 address, IPv6 address, or a hostname.</p></li> <li><p><code>port</code> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – The port to connect to.</p></li> <li><p><code>happy_eyeballs_delay</code> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – How many seconds to wait for each connection attempt to succeed or fail before getting impatient and starting another one in parallel. Set to <a class="reference external" href="https://docs.python.org/3/library/math.html#math.inf" title="(in Python v3.7)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">math.inf</span></code></a> if you want to limit to only one connection attempt at a time (like <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.create_connection" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket.create_connection()</span></code></a>). Default: 0.3 (300 ms).</p></li> </ul> </dd> <h4 class="field-even" style="margin: 0">Returns</h4> <dd class="field-even">
<p>a <a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a> connected to the given server.</p> </dd> <h4 class="field-odd" style="margin: 0">Return type</h4> <dd class="field-odd">
<p><a class="reference internal" href="#trio.SocketStream" title="trio.SocketStream">SocketStream</a></p> </dd> <h4 class="field-even" style="margin: 0">Raises</h4> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#OSError" title="(in Python v3.7)"><code>OSError</code></a> – if the connection fails.</p> </dd> </dl> <blockquote class="admonition seealso"> <h4 class="admonition-title">See also</h4> <p>open_ssl_over_tcp_stream</p> </blockquote> </dd>
</dl> <dl class="function"> <h3 id="trio.serve_tcp"><code><em>await</em> trio.serve_tcp(handler, port, *, host=None, backlog=None, handler_nursery=None, task_status=TASK_STATUS_IGNORED)</code></h3> <dd>
<p>Listen for incoming TCP connections, and for each one start a task running <code class="docutils literal notranslate"><span class="pre">handler(stream)</span></code>.</p> <p>This is a thin convenience wrapper around <a class="reference internal" href="#trio.open_tcp_listeners" title="trio.open_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_listeners()</span></code></a> and <a class="reference internal" href="#trio.serve_listeners" title="trio.serve_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_listeners()</span></code></a> – see them for full details.</p> <blockquote class="admonition warning"> <h4 class="admonition-title">Warning</h4> <p>If <code class="docutils literal notranslate"><span class="pre">handler</span></code> raises an exception, then this function doesn’t do anything special to catch it – so by default the exception will propagate out and crash your server. If you don’t want this, then catch exceptions inside your <code class="docutils literal notranslate"><span class="pre">handler</span></code>, or use a <code class="docutils literal notranslate"><span class="pre">handler_nursery</span></code> object that responds to exceptions in some other way.</p> </blockquote> <p>When used with <code class="docutils literal notranslate"><span class="pre">nursery.start</span></code> you get back the newly opened listeners. So, for example, if you want to start a server in your test suite and then connect to it to check that it’s working properly, you can use something like:</p> <pre data-language="python">from trio.testing import open_stream_to_socket_listener

async with trio.open_nursery() as nursery:
    listeners = await nursery.start(serve_tcp, handler, 0)
    client_stream = await open_stream_to_socket_listener(listeners[0])

    # Then send and receive data on 'client_stream', for example:
    await client_stream.send_all(b"GET / HTTP/1.0\r\n\r\n")</pre> <p>This avoids several common pitfalls:</p> <ol class="arabic simple"> <li><p>It lets the kernel pick a random open port, so your test suite doesn’t depend on any particular port being open.</p></li> <li><p>It waits for the server to be accepting connections on that port before <code class="docutils literal notranslate"><span class="pre">start</span></code> returns, so there’s no race condition where the incoming connection arrives before the server is ready.</p></li> <li><p>It uses the Listener object to find out which port was picked, so it can connect to the right place.</p></li> </ol> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<ul class="simple"> <li><p><code>handler</code> – The handler to start for each incoming connection. Passed to <a class="reference internal" href="#trio.serve_listeners" title="trio.serve_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_listeners()</span></code></a>.</p></li> <li><p><code>port</code> – The port to listen on. Use 0 to let the kernel pick an open port. Passed to <a class="reference internal" href="#trio.open_tcp_listeners" title="trio.open_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_listeners()</span></code></a>.</p></li> <li><p><code>host</code> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><em>str</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytes" title="(in Python v3.7)"><em>bytes</em></a><em>, or </em><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)"><em>None</em></a>) – The host interface to listen on; use <code class="docutils literal notranslate"><span class="pre">None</span></code> to bind to the wildcard address. Passed to <a class="reference internal" href="#trio.open_tcp_listeners" title="trio.open_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_listeners()</span></code></a>.</p></li> <li><p><code>backlog</code> – The listen backlog, or None to have a good default picked. Passed to <a class="reference internal" href="#trio.open_tcp_listeners" title="trio.open_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_listeners()</span></code></a>.</p></li> <li><p><code>handler_nursery</code> – The nursery to start handlers in, or None to use an internal nursery. Passed to <a class="reference internal" href="#trio.serve_listeners" title="trio.serve_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_listeners()</span></code></a>.</p></li> <li><p><code>task_status</code> – This function can be used with <code class="docutils literal notranslate"><span class="pre">nursery.start</span></code>.</p></li> </ul> </dd> <h4 class="field-even" style="margin: 0">Returns</h4> <dd class="field-even">
<p>This function only returns when cancelled.</p> </dd> </dl> </dd>
</dl> <dl class="function"> <h3 id="trio.open_ssl_over_tcp_stream"><code><em>await</em> trio.open_ssl_over_tcp_stream(host, port, *, https_compatible=False, ssl_context=None, happy_eyeballs_delay=0.25)</code></h3> <dd>
<p>Make a TLS-encrypted Connection to the given host and port over TCP.</p> <p>This is a convenience wrapper that calls <a class="reference internal" href="#trio.open_tcp_stream" title="trio.open_tcp_stream"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_stream()</span></code></a> and wraps the result in an <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a>.</p> <p>This function does not perform the TLS handshake; you can do it manually by calling <a class="reference internal" href="#trio.SSLStream.do_handshake" title="trio.SSLStream.do_handshake"><code class="xref py py-meth docutils literal notranslate"><span class="pre">do_handshake()</span></code></a>, or else it will be performed automatically the first time you send or receive data.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<ul class="simple"> <li><p><code>host</code> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytes" title="(in Python v3.7)"><em>bytes</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><em>str</em></a>) – The host to connect to. We require the server to have a TLS certificate valid for this hostname.</p></li> <li><p><code>port</code> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – The port to connect to.</p></li> <li><p><code>https_compatible</code> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – Set this to True if you’re connecting to a web server. See <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> for details. Default: False.</p></li> <li><p><code>ssl_context</code> (<a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLContext" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> or None) – The SSL context to use. If None (the default), <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.create_default_context" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.create_default_context()</span></code></a> will be called to create a context.</p></li> <li><p><code>happy_eyeballs_delay</code> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – See <a class="reference internal" href="#trio.open_tcp_stream" title="trio.open_tcp_stream"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_stream()</span></code></a>.</p></li> </ul> </dd> <h4 class="field-even" style="margin: 0">Returns</h4> <dd class="field-even">
<p>the encrypted connection to the server.</p> </dd> <h4 class="field-odd" style="margin: 0">Return type</h4> <dd class="field-odd">
<p><a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream">trio.SSLStream</a></p> </dd> </dl> </dd>
</dl> <dl class="function"> <h3 id="trio.serve_ssl_over_tcp"><code><em>await</em> trio.serve_ssl_over_tcp(handler, port, ssl_context, *, host=None, https_compatible=False, backlog=None, handler_nursery=None, task_status=TASK_STATUS_IGNORED)</code></h3> <dd>
<p>Listen for incoming TCP connections, and for each one start a task running <code class="docutils literal notranslate"><span class="pre">handler(stream)</span></code>.</p> <p>This is a thin convenience wrapper around <a class="reference internal" href="#trio.open_ssl_over_tcp_listeners" title="trio.open_ssl_over_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_ssl_over_tcp_listeners()</span></code></a> and <a class="reference internal" href="#trio.serve_listeners" title="trio.serve_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_listeners()</span></code></a> – see them for full details.</p> <blockquote class="admonition warning"> <h4 class="admonition-title">Warning</h4> <p>If <code class="docutils literal notranslate"><span class="pre">handler</span></code> raises an exception, then this function doesn’t do anything special to catch it – so by default the exception will propagate out and crash your server. If you don’t want this, then catch exceptions inside your <code class="docutils literal notranslate"><span class="pre">handler</span></code>, or use a <code class="docutils literal notranslate"><span class="pre">handler_nursery</span></code> object that responds to exceptions in some other way.</p> </blockquote> <p>When used with <code class="docutils literal notranslate"><span class="pre">nursery.start</span></code> you get back the newly opened listeners. See the documentation for <a class="reference internal" href="#trio.serve_tcp" title="trio.serve_tcp"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_tcp()</span></code></a> for an example where this is useful.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<ul class="simple"> <li><p><code>handler</code> – The handler to start for each incoming connection. Passed to <a class="reference internal" href="#trio.serve_listeners" title="trio.serve_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_listeners()</span></code></a>.</p></li> <li><p><code>port</code> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – The port to listen on. Use 0 to let the kernel pick an open port. Ultimately passed to <a class="reference internal" href="#trio.open_tcp_listeners" title="trio.open_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_listeners()</span></code></a>.</p></li> <li><p><code>ssl_context</code> (<a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLContext" title="(in Python v3.7)"><em>SSLContext</em></a>) – The SSL context to use for all incoming connections. Passed to <a class="reference internal" href="#trio.open_ssl_over_tcp_listeners" title="trio.open_ssl_over_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_ssl_over_tcp_listeners()</span></code></a>.</p></li> <li><p><code>host</code> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><em>str</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytes" title="(in Python v3.7)"><em>bytes</em></a><em>, or </em><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)"><em>None</em></a>) – The address to bind to; use <code class="docutils literal notranslate"><span class="pre">None</span></code> to bind to the wildcard address. Ultimately passed to <a class="reference internal" href="#trio.open_tcp_listeners" title="trio.open_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_listeners()</span></code></a>.</p></li> <li><p><code>https_compatible</code> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – Set this to True if you want to use “HTTPS-style” TLS. See <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> for details.</p></li> <li><p><code>backlog</code> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)"><em>None</em></a>) – See <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> for details.</p></li> <li><p><code>handler_nursery</code> – The nursery to start handlers in, or None to use an internal nursery. Passed to <a class="reference internal" href="#trio.serve_listeners" title="trio.serve_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_listeners()</span></code></a>.</p></li> <li><p><code>task_status</code> – This function can be used with <code class="docutils literal notranslate"><span class="pre">nursery.start</span></code>.</p></li> </ul> </dd> <h4 class="field-even" style="margin: 0">Returns</h4> <dd class="field-even">
<p>This function only returns when cancelled.</p> </dd> </dl> </dd>
</dl> <dl class="function"> <h3 id="trio.open_unix_socket"><code><em>await</em> trio.open_unix_socket(filename)</code></h3> <dd>
<p>Opens a connection to the specified <a class="reference external" href="https://en.wikipedia.org/wiki/Unix_domain_socket">Unix domain socket</a>.</p> <p>You must have read/write permission on the specified file to connect.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<p><code>filename</code> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><em>str</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytes" title="(in Python v3.7)"><em>bytes</em></a>) – The filename to open the connection to.</p> </dd> <h4 class="field-even" style="margin: 0">Returns</h4> <dd class="field-even">
<p>a <a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a> connected to the given file.</p> </dd> <h4 class="field-odd" style="margin: 0">Return type</h4> <dd class="field-odd">
<p><a class="reference internal" href="#trio.SocketStream" title="trio.SocketStream">SocketStream</a></p> </dd> <h4 class="field-even" style="margin: 0">Raises</h4> <dd class="field-even">
<ul class="simple"> <li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#OSError" title="(in Python v3.7)"><code>OSError</code></a> – If the socket file could not be connected to.</p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.7)"><code>RuntimeError</code></a> – If AF_UNIX sockets are not supported.</p></li> </ul> </dd> </dl> </dd>
</dl> <dl class="class"> <h3 id="trio.SocketStream"><code><em>class</em> trio.SocketStream(socket)</code></h3> <dd>
<p>Bases: <a class="reference internal" href="#trio.abc.HalfCloseableStream" title="trio.abc.HalfCloseableStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.HalfCloseableStream</span></code></a></p> <p>An implementation of the <a class="reference internal" href="#trio.abc.HalfCloseableStream" title="trio.abc.HalfCloseableStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.HalfCloseableStream</span></code></a> interface based on a raw network socket.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<p><code>socket</code> – The Trio socket object to wrap. Must have type <code class="docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code>, and be connected.</p> </dd> </dl> <p>By default for TCP sockets, <a class="reference internal" href="#trio.SocketStream" title="trio.SocketStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketStream</span></code></a> enables <code class="docutils literal notranslate"><span class="pre">TCP_NODELAY</span></code>, and (on platforms where it’s supported) enables <code class="docutils literal notranslate"><span class="pre">TCP_NOTSENT_LOWAT</span></code> with a reasonable buffer size (currently 16 KiB) – see <a class="reference external" href="https://github.com/python-trio/trio/issues/72">issue #72</a> for discussion. You can of course override these defaults by calling <a class="reference internal" href="#trio.SocketStream.setsockopt" title="trio.SocketStream.setsockopt"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setsockopt()</span></code></a>.</p> <p>Once a <a class="reference internal" href="#trio.SocketStream" title="trio.SocketStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketStream</span></code></a> object is constructed, it implements the full <a class="reference internal" href="#trio.abc.HalfCloseableStream" title="trio.abc.HalfCloseableStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.HalfCloseableStream</span></code></a> interface. In addition, it provides a few extra features:</p> <dl class="attribute"> <h3 id="trio.SocketStream.socket"><code>socket</code></h3> <dd>
<p>The Trio socket object that this stream wraps.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.SocketStream.aclose"><code><em>await</em> aclose()</code></h3> 
</dl> <dl class="method"> <h3 id="trio.SocketStream.getsockopt"><code>getsockopt(level, option, buffersize=0)</code></h3> <dd>
<p>Check the current value of an option on the underlying socket.</p> <p>See <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.getsockopt" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.socket.getsockopt()</span></code></a> for details.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.SocketStream.receive_some"><code><em>await</em> receive_some(max_bytes=None)</code></h3> 
</dl> <dl class="method"> <h3 id="trio.SocketStream.send_all"><code><em>await</em> send_all(data)</code></h3> 
</dl> <dl class="method"> <h3 id="trio.SocketStream.send_eof"><code><em>await</em> send_eof()</code></h3> 
</dl> <dl class="method"> <h3 id="trio.SocketStream.setsockopt"><code>setsockopt(level, option, value)</code></h3> <dd>
<p>Set an option on the underlying socket.</p> <p>See <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.setsockopt" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.socket.setsockopt()</span></code></a> for details.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.SocketStream.wait_send_all_might_not_block"><code><em>await</em> wait_send_all_might_not_block()</code></h3> 
</dl> </dd>
</dl> <dl class="class"> <h3 id="trio.SocketListener"><code><em>class</em> trio.SocketListener(socket)</code></h3> <dd>
<p>Bases: <a class="reference internal" href="#trio.abc.Listener" title="trio.abc.Listener"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.Listener</span></code></a></p> <p>A <a class="reference internal" href="#trio.abc.Listener" title="trio.abc.Listener"><code class="xref py py-class docutils literal notranslate"><span class="pre">Listener</span></code></a> that uses a listening socket to accept incoming connections as <a class="reference internal" href="#trio.SocketStream" title="trio.SocketStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketStream</span></code></a> objects.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<p><code>socket</code> – The Trio socket object to wrap. Must have type <code class="docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code>, and be listening.</p> </dd> </dl> <p>Note that the <a class="reference internal" href="#trio.SocketListener" title="trio.SocketListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketListener</span></code></a> “takes ownership” of the given socket; closing the <a class="reference internal" href="#trio.SocketListener" title="trio.SocketListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketListener</span></code></a> will also close the socket.</p> <dl class="attribute"> <h3 id="trio.SocketListener.socket"><code>socket</code></h3> <dd>
<p>The Trio socket object that this stream wraps.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.SocketListener.accept"><code><em>await</em> accept()</code></h3> <dd>
<p>Accept an incoming connection.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Returns</h4> <dd class="field-odd">
<p><a class="reference internal" href="#trio.SocketStream" title="trio.SocketStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketStream</span></code></a></p> </dd> <h4 class="field-even" style="margin: 0">Raises</h4> <dd class="field-even">
<ul class="simple"> <li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#OSError" title="(in Python v3.7)"><code>OSError</code></a> – if the underlying call to <code class="docutils literal notranslate"><span class="pre">accept</span></code> raises an unexpected error.</p></li> <li><p><a class="reference internal" href="reference-core#trio.ClosedResourceError" title="trio.ClosedResourceError"><code>ClosedResourceError</code></a> – if you already closed the socket.</p></li> </ul> </dd> </dl> <p>This method handles routine errors like <code class="docutils literal notranslate"><span class="pre">ECONNABORTED</span></code>, but passes other errors on to its caller. In particular, it does <em>not</em> make any special effort to handle resource exhaustion errors like <code class="docutils literal notranslate"><span class="pre">EMFILE</span></code>, <code class="docutils literal notranslate"><span class="pre">ENFILE</span></code>, <code class="docutils literal notranslate"><span class="pre">ENOBUFS</span></code>, <code class="docutils literal notranslate"><span class="pre">ENOMEM</span></code>.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.SocketListener.aclose"><code><em>await</em> aclose()</code></h3> <dd>
<p>Close this listener and its underlying socket.</p> </dd>
</dl> </dd>
</dl> <dl class="function"> <h3 id="trio.open_tcp_listeners"><code><em>await</em> trio.open_tcp_listeners(port, *, host=None, backlog=None)</code></h3> <dd>
<p>Create <a class="reference internal" href="#trio.SocketListener" title="trio.SocketListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketListener</span></code></a> objects to listen for TCP connections.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<ul class="simple"> <li>
<p><code>port</code> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – </p>
<p>The port to listen on.</p> <p>If you use 0 as your port, then the kernel will automatically pick an arbitrary open port. But be careful: if you use this feature when binding to multiple IP addresses, then each IP address will get its own random port, and the returned listeners will probably be listening on different ports. In particular, this will happen if you use <code class="docutils literal notranslate"><span class="pre">host=None</span></code> – which is the default – because in this case <a class="reference internal" href="#trio.open_tcp_listeners" title="trio.open_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_listeners()</span></code></a> will bind to both the IPv4 wildcard address (<code class="docutils literal notranslate"><span class="pre">0.0.0.0</span></code>) and also the IPv6 wildcard address (<code class="docutils literal notranslate"><span class="pre">::</span></code>).</p> </li> <li>
<p><code>host</code> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><em>str</em></a><em>, </em><em>bytes-like</em><em>, or </em><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)"><em>None</em></a>) – </p>
<p>The local interface to bind to. This is passed to <a class="reference internal" href="#trio.socket.getaddrinfo" title="trio.socket.getaddrinfo"><code class="xref py py-func docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a> with the <code class="docutils literal notranslate"><span class="pre">AI_PASSIVE</span></code> flag set.</p> <p>If you want to bind to the wildcard address on both IPv4 and IPv6, in order to accept connections on all available interfaces, then pass <code class="docutils literal notranslate"><span class="pre">None</span></code>. This is the default.</p> <p>If you have a specific interface you want to bind to, pass its IP address or hostname here. If a hostname resolves to multiple IP addresses, this function will open one listener on each of them.</p> <p>If you want to use only IPv4, or only IPv6, but want to accept on all interfaces, pass the family-specific wildcard address: <code class="docutils literal notranslate"><span class="pre">"0.0.0.0"</span></code> for IPv4-only and <code class="docutils literal notranslate"><span class="pre">"::"</span></code> for IPv6-only.</p> </li> <li><p><code>backlog</code> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)"><em>None</em></a>) – The listen backlog to use. If you leave this as <code class="docutils literal notranslate"><span class="pre">None</span></code> then Trio will pick a good default. (Currently: whatever your system has configured as the maximum backlog.)</p></li> </ul> </dd> <h4 class="field-even" style="margin: 0">Returns</h4> <dd class="field-even">
<p>list of <a class="reference internal" href="#trio.SocketListener" title="trio.SocketListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketListener</span></code></a></p> </dd> </dl> </dd>
</dl> <dl class="function"> <h3 id="trio.open_ssl_over_tcp_listeners"><code><em>await</em> trio.open_ssl_over_tcp_listeners(port, ssl_context, *, host=None, https_compatible=False, backlog=None)</code></h3> <dd>
<p>Start listening for SSL/TLS-encrypted TCP connections to the given port.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<ul class="simple"> <li><p><code>port</code> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – The port to listen on. See <a class="reference internal" href="#trio.open_tcp_listeners" title="trio.open_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_listeners()</span></code></a>.</p></li> <li><p><code>ssl_context</code> (<a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLContext" title="(in Python v3.7)"><em>SSLContext</em></a>) – The SSL context to use for all incoming connections.</p></li> <li><p><code>host</code> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><em>str</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytes" title="(in Python v3.7)"><em>bytes</em></a><em>, or </em><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)"><em>None</em></a>) – The address to bind to; use <code class="docutils literal notranslate"><span class="pre">None</span></code> to bind to the wildcard address. See <a class="reference internal" href="#trio.open_tcp_listeners" title="trio.open_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_listeners()</span></code></a>.</p></li> <li><p><code>https_compatible</code> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – See <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> for details.</p></li> <li><p><code>backlog</code> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)"><em>None</em></a>) – See <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> for details.</p></li> </ul> </dd> </dl> </dd>
</dl>   <h3>SSL / TLS support</h3> <p>Trio provides SSL/TLS support based on the standard library <a class="reference external" href="https://docs.python.org/3/library/ssl.html#module-ssl" title="(in Python v3.7)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code></a> module. Trio’s <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> and <a class="reference internal" href="#trio.SSLListener" title="trio.SSLListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLListener</span></code></a> take their configuration from a <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLContext" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLContext</span></code></a>, which you can create using <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.create_default_context" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.create_default_context()</span></code></a> and customize using the other constants and functions in the <a class="reference external" href="https://docs.python.org/3/library/ssl.html#module-ssl" title="(in Python v3.7)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code></a> module.</p> <blockquote class="admonition warning"> <h4 class="admonition-title">Warning</h4> <p>Avoid instantiating <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLContext" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLContext</span></code></a> directly. A newly constructed <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLContext" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> has less secure defaults than one returned by <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.create_default_context" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.create_default_context()</span></code></a>, dramatically so before Python 3.6.</p> </blockquote> <p>Instead of using <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLContext.wrap_socket" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ssl.SSLContext.wrap_socket()</span></code></a>, you create a <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a>:</p> <dl class="class"> <h3 id="trio.SSLStream"><code><em>class</em> trio.SSLStream(transport_stream, ssl_context, *, server_hostname=None, server_side=False, https_compatible=False, max_refill_bytes='unused and deprecated')</code></h3> <dd>
<p>Bases: <a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.Stream</span></code></a></p> <p>Encrypted communication using SSL/TLS.</p> <p><a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> wraps an arbitrary <a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a>, and allows you to perform encrypted communication over it using the usual <a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a> interface. You pass regular data to <a class="reference internal" href="#trio.SSLStream.send_all" title="trio.SSLStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_all()</span></code></a>, then it encrypts it and sends the encrypted data on the underlying <a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a>; <a class="reference internal" href="#trio.SSLStream.receive_some" title="trio.SSLStream.receive_some"><code class="xref py py-meth docutils literal notranslate"><span class="pre">receive_some()</span></code></a> takes encrypted data out of the underlying <a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a> and decrypts it before returning it.</p> <p>You should read the standard library’s <a class="reference external" href="https://docs.python.org/3/library/ssl.html#module-ssl" title="(in Python v3.7)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code></a> documentation carefully before attempting to use this class, and probably other general documentation on SSL/TLS as well. SSL/TLS is subtle and quick to anger. Really. I’m not kidding.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<ul class="simple"> <li><p><code>transport_stream</code> (<a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><em>Stream</em></a>) – The stream used to transport encrypted data. Required.</p></li> <li><p><code>ssl_context</code> (<a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLContext" title="(in Python v3.7)"><em>SSLContext</em></a>) – The <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLContext" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> used for this connection. Required. Usually created by calling <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.create_default_context" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.create_default_context()</span></code></a>.</p></li> <li><p><code>server_hostname</code> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><em>str</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)"><em>None</em></a>) – The name of the server being connected to. Used for <a class="reference external" href="https://en.wikipedia.org/wiki/Server_Name_Indication">SNI</a> and for validating the server’s certificate (if hostname checking is enabled). This is effectively mandatory for clients, and actually mandatory if <code class="docutils literal notranslate"><span class="pre">ssl_context.check_hostname</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></li> <li><p><code>server_side</code> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – Whether this stream is acting as a client or server. Defaults to False, i.e. client mode.</p></li> <li>
<p><code>https_compatible</code> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – </p>
<p>There are two versions of SSL/TLS commonly encountered in the wild: the standard version, and the version used for HTTPS (HTTP-over-SSL/TLS).</p> <p>Standard-compliant SSL/TLS implementations always send a cryptographically signed <code class="docutils literal notranslate"><span class="pre">close_notify</span></code> message before closing the connection. This is important because if the underlying transport were simply closed, then there wouldn’t be any way for the other side to know whether the connection was intentionally closed by the peer that they negotiated a cryptographic connection to, or by some <a class="reference external" href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">man-in-the-middle</a> attacker who can’t manipulate the cryptographic stream, but can manipulate the transport layer (a so-called “truncation attack”).</p> <p>However, this part of the standard is widely ignored by real-world HTTPS implementations, which means that if you want to interoperate with them, then you NEED to ignore it too.</p> <p>Fortunately this isn’t as bad as it sounds, because the HTTP protocol already includes its own equivalent of <code class="docutils literal notranslate"><span class="pre">close_notify</span></code>, so doing this again at the SSL/TLS level is redundant. But not all protocols do! Therefore, by default Trio implements the safer standard-compliant version (<code class="docutils literal notranslate"><span class="pre">https_compatible=False</span></code>). But if you’re speaking HTTPS or some other protocol where <code class="docutils literal notranslate"><span class="pre">close_notify</span></code>s are commonly skipped, then you should set <code class="docutils literal notranslate"><span class="pre">https_compatible=True</span></code>; with this setting, Trio will neither expect nor send <code class="docutils literal notranslate"><span class="pre">close_notify</span></code> messages.</p> <p>If you have code that was written to use <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLSocket" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLSocket</span></code></a> and now you’re porting it to Trio, then it may be useful to know that a difference between <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> and <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLSocket" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLSocket</span></code></a> is that <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLSocket" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> implements the <code class="docutils literal notranslate"><span class="pre">https_compatible=True</span></code> behavior by default.</p> </li> </ul> </dd> </dl> <dl class="attribute"> <h3 id="trio.SSLStream.transport_stream"><code>transport_stream</code></h3> <dd>
<p>The underlying transport stream that was passed to <code class="docutils literal notranslate"><span class="pre">__init__</span></code>. An example of when this would be useful is if you’re using <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> over a <a class="reference internal" href="#trio.SocketStream" title="trio.SocketStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketStream</span></code></a> and want to call the <a class="reference internal" href="#trio.SocketStream" title="trio.SocketStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketStream</span></code></a>’s <a class="reference internal" href="#trio.SocketStream.setsockopt" title="trio.SocketStream.setsockopt"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setsockopt()</span></code></a> method.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Type</h4> <dd class="field-odd">
<p><a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream">trio.abc.Stream</a></p> </dd> </dl> </dd>
</dl> <p>Internally, this class is implemented using an instance of <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLObject" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLObject</span></code></a>, and all of <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLObject" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a>’s methods and attributes are re-exported as methods and attributes on this class. However, there is one difference: <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLObject" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a> has several methods that return information about the encrypted connection, like <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLSocket.cipher" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cipher()</span></code></a> or <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLSocket.selected_alpn_protocol" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">selected_alpn_protocol()</span></code></a>. If you call them before the handshake, when they can’t possibly return useful data, then <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLObject" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLObject</span></code></a> returns None, but <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.SSLStream</span></code></a> raises <a class="reference internal" href="#trio.NeedHandshakeError" title="trio.NeedHandshakeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NeedHandshakeError</span></code></a>.</p> <p>This also means that if you register a SNI callback using <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLContext.sni_callback" title="(in Python v3.7)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sni_callback</span></code></a>, then the first argument your callback receives will be a <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLObject" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLObject</span></code></a>.</p> <dl class="method"> <h3 id="trio.SSLStream.aclose"><code><em>await</em> aclose()</code></h3> <dd>
<p>Gracefully shut down this connection, and close the underlying transport.</p> <p>If <code class="docutils literal notranslate"><span class="pre">https_compatible</span></code> is False (the default), then this attempts to first send a <code class="docutils literal notranslate"><span class="pre">close_notify</span></code> and then close the underlying stream by calling its <a class="reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> method.</p> <p>If <code class="docutils literal notranslate"><span class="pre">https_compatible</span></code> is set to True, then this simply closes the underlying stream and marks this stream as closed.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.SSLStream.do_handshake"><code><em>await</em> do_handshake()</code></h3> <dd>
<p>Ensure that the initial handshake has completed.</p> <p>The SSL protocol requires an initial handshake to exchange certificates, select cryptographic keys, and so forth, before any actual data can be sent or received. You don’t have to call this method; if you don’t, then <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> will automatically peform the handshake as needed, the first time you try to send or receive data. But if you want to trigger it manually – for example, because you want to look at the peer’s certificate before you start talking to them – then you can call this method.</p> <p>If the initial handshake is already in progress in another task, this waits for it to complete and then returns.</p> <p>If the initial handshake has already completed, this returns immediately without doing anything (except executing a checkpoint).</p> <blockquote class="admonition warning"> <h4 class="admonition-title">Warning</h4> <p>If this method is cancelled, then it may leave the <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> in an unusable state. If this happens then any future attempt to use the object will raise <a class="reference internal" href="reference-core#trio.BrokenResourceError" title="trio.BrokenResourceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">trio.BrokenResourceError</span></code></a>.</p> </blockquote> </dd>
</dl> <dl class="method"> <h3 id="trio.SSLStream.receive_some"><code><em>await</em> receive_some(max_bytes=None)</code></h3> <dd>
<p>Read some data from the underlying transport, decrypt it, and return it.</p> <p>See <a class="reference internal" href="#trio.abc.ReceiveStream.receive_some" title="trio.abc.ReceiveStream.receive_some"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trio.abc.ReceiveStream.receive_some()</span></code></a> for details.</p> <blockquote class="admonition warning"> <h4 class="admonition-title">Warning</h4> <p>If this method is cancelled while the initial handshake or a renegotiation are in progress, then it may leave the <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> in an unusable state. If this happens then any future attempt to use the object will raise <a class="reference internal" href="reference-core#trio.BrokenResourceError" title="trio.BrokenResourceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">trio.BrokenResourceError</span></code></a>.</p> </blockquote> </dd>
</dl> <dl class="method"> <h3 id="trio.SSLStream.send_all"><code><em>await</em> send_all(data)</code></h3> <dd>
<p>Encrypt some data and then send it on the underlying transport.</p> <p>See <a class="reference internal" href="#trio.abc.SendStream.send_all" title="trio.abc.SendStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trio.abc.SendStream.send_all()</span></code></a> for details.</p> <blockquote class="admonition warning"> <h4 class="admonition-title">Warning</h4> <p>If this method is cancelled, then it may leave the <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> in an unusable state. If this happens then any attempt to use the object will raise <a class="reference internal" href="reference-core#trio.BrokenResourceError" title="trio.BrokenResourceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">trio.BrokenResourceError</span></code></a>.</p> </blockquote> </dd>
</dl> <dl class="method"> <h3 id="trio.SSLStream.unwrap"><code><em>await</em> unwrap()</code></h3> <dd>
<p>Cleanly close down the SSL/TLS encryption layer, allowing the underlying stream to be used for unencrypted communication.</p> <p>You almost certainly don’t need this.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Returns</h4> <dd class="field-odd">
<p>A pair <code class="docutils literal notranslate"><span class="pre">(transport_stream,</span> <span class="pre">trailing_bytes)</span></code>, where <code class="docutils literal notranslate"><span class="pre">transport_stream</span></code> is the underlying transport stream, and <code class="docutils literal notranslate"><span class="pre">trailing_bytes</span></code> is a byte string. Since <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> doesn’t necessarily know where the end of the encrypted data will be, it can happen that it accidentally reads too much from the underlying stream. <code class="docutils literal notranslate"><span class="pre">trailing_bytes</span></code> contains this extra data; you should process it as if it was returned from a call to <code class="docutils literal notranslate"><span class="pre">transport_stream.receive_some(...)</span></code>.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <h3 id="trio.SSLStream.wait_send_all_might_not_block"><code><em>await</em> wait_send_all_might_not_block()</code></h3> <dd>
<p>See <a class="reference internal" href="#trio.abc.SendStream.wait_send_all_might_not_block" title="trio.abc.SendStream.wait_send_all_might_not_block"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trio.abc.SendStream.wait_send_all_might_not_block()</span></code></a>.</p> </dd>
</dl> </dd>
</dl> <p>And if you’re implementing a server, you can use <a class="reference internal" href="#trio.SSLListener" title="trio.SSLListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLListener</span></code></a>:</p> <dl class="class"> <h3 id="trio.SSLListener"><code><em>class</em> trio.SSLListener(transport_listener, ssl_context, *, https_compatible=False, max_refill_bytes='unused and deprecated')</code></h3> <dd>
<p>Bases: <a class="reference internal" href="#trio.abc.Listener" title="trio.abc.Listener"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.Listener</span></code></a></p> <p>A <a class="reference internal" href="#trio.abc.Listener" title="trio.abc.Listener"><code class="xref py py-class docutils literal notranslate"><span class="pre">Listener</span></code></a> for SSL/TLS-encrypted servers.</p> <p><a class="reference internal" href="#trio.SSLListener" title="trio.SSLListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLListener</span></code></a> wraps around another Listener, and converts all incoming connections to encrypted connections by wrapping them in a <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a>.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<ul class="simple"> <li><p><code>transport_listener</code> (<a class="reference internal" href="#trio.abc.Listener" title="trio.abc.Listener"><em>Listener</em></a>) – The listener whose incoming connections will be wrapped in <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a>.</p></li> <li><p><code>ssl_context</code> (<a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLContext" title="(in Python v3.7)"><em>SSLContext</em></a>) – The <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLContext" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> that will be used for incoming connections.</p></li> <li><p><code>https_compatible</code> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – Passed on to <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a>.</p></li> </ul> </dd> </dl> <dl class="attribute"> <h3 id="trio.SSLListener.transport_listener"><code>transport_listener</code></h3> <dd>
<p>The underlying listener that was passed to <code class="docutils literal notranslate"><span class="pre">__init__</span></code>.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Type</h4> <dd class="field-odd">
<p><a class="reference internal" href="#trio.abc.Listener" title="trio.abc.Listener">trio.abc.Listener</a></p> </dd> </dl> </dd>
</dl> <dl class="method"> <h3 id="trio.SSLListener.accept"><code><em>await</em> accept()</code></h3> <dd>
<p>Accept the next connection and wrap it in an <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a>.</p> <p>See <a class="reference internal" href="#trio.abc.Listener.accept" title="trio.abc.Listener.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trio.abc.Listener.accept()</span></code></a> for details.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.SSLListener.aclose"><code><em>await</em> aclose()</code></h3> <dd>
<p>Close the transport listener.</p> </dd>
</dl> </dd>
</dl> <p>Some methods on <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> raise <a class="reference internal" href="#trio.NeedHandshakeError" title="trio.NeedHandshakeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NeedHandshakeError</span></code></a> if you call them before the handshake completes:</p> <dl class="exception"> <h3 id="trio.NeedHandshakeError"><code><em>exception</em> trio.NeedHandshakeError</code></h3> <dd>
<p>Some <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> methods can’t return any meaningful data until after the handshake. If you call them before the handshake, they raise this error.</p> </dd>
</dl>    <h2>Low-level networking with <a class="reference internal" href="#module-trio.socket" title="trio.socket"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.socket</span></code></a>
</h2> <p>The <a class="reference internal" href="#module-trio.socket" title="trio.socket"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.socket</span></code></a> module provides Trio’s basic low-level networking API. If you’re doing ordinary things with stream-oriented connections over IPv4/IPv6/Unix domain sockets, then you probably want to stick to the high-level API described above. If you want to use UDP, or exotic address families like <code class="docutils literal notranslate"><span class="pre">AF_BLUETOOTH</span></code>, or otherwise get direct access to all the quirky bits of your system’s networking API, then you’re in the right place.</p>  <h3>Top-level exports</h3> <p>Generally, the API exposed by <a class="reference internal" href="#module-trio.socket" title="trio.socket"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.socket</span></code></a> mirrors that of the standard library <a class="reference external" href="https://docs.python.org/3/library/socket.html#module-socket" title="(in Python v3.7)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> module. Most constants (like <code class="docutils literal notranslate"><span class="pre">SOL_SOCKET</span></code>) and simple utilities (like <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.inet_aton" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">inet_aton()</span></code></a>) are simply re-exported unchanged. But there are also some differences, which are described here.</p> <p>First, Trio provides analogues to all the standard library functions that return socket objects; their interface is identical, except that they’re modified to return Trio socket objects instead:</p> <dl class="function"> <h3 id="trio.socket.socket"><code>trio.socket.socket(family=<addressfamily.af_inet:>, type=<socketkind.sock_stream:>, proto=0, fileno=None)</socketkind.sock_stream:></addressfamily.af_inet:></code></h3> <dd>
<p>Create a new Trio socket, like <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket.socket()</span></code></a>.</p> <p>This function’s behavior can be customized using <a class="reference internal" href="reference-testing#trio.socket.set_custom_socket_factory" title="trio.socket.set_custom_socket_factory"><code class="xref py py-func docutils literal notranslate"><span class="pre">set_custom_socket_factory()</span></code></a>.</p> </dd>
</dl> <dl class="function"> <h3 id="trio.socket.socketpair"><code>trio.socket.socketpair(family=None, type=<socketkind.sock_stream:>, proto=0)</socketkind.sock_stream:></code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socketpair" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket.socketpair()</span></code></a>, but returns a pair of Trio socket objects.</p> </dd>
</dl> <dl class="function"> <h3 id="trio.socket.fromfd"><code>trio.socket.fromfd(fd, family, type, proto=0)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.fromfd" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket.fromfd()</span></code></a>, but returns a Trio socket object.</p> </dd>
</dl> <dl class="function"> <h3 id="trio.socket.fromshare"><code>trio.socket.fromshare(data)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.fromshare" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket.fromshare()</span></code></a>, but returns a Trio socket object.</p> </dd>
</dl> <p>In addition, there is a new function to directly convert a standard library socket into a Trio socket:</p> <dl class="function"> <h3 id="trio.socket.from_stdlib_socket"><code>trio.socket.from_stdlib_socket(sock)</code></h3> <dd>
<p>Convert a standard library <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket.socket()</span></code></a> object into a Trio socket object.</p> </dd>
</dl> <p>Unlike <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket.socket()</span></code></a>, <a class="reference internal" href="#trio.socket.socket" title="trio.socket.socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.socket.socket()</span></code></a> is a function, not a class; if you want to check whether an object is a Trio socket, use <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">trio.socket.SocketType)</span></code>.</p> <p>For name lookup, Trio provides the standard functions, but with some changes:</p> <dl class="function"> <h3 id="trio.socket.getaddrinfo"><code><em>await</em> trio.socket.getaddrinfo(host, port, family=0, type=0, proto=0, flags=0)</code></h3> <dd>
<p>Look up a numeric address given a name.</p> <p>Arguments and return values are identical to <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.getaddrinfo" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket.getaddrinfo()</span></code></a>, except that this version is async.</p> <p>Also, <a class="reference internal" href="#trio.socket.getaddrinfo" title="trio.socket.getaddrinfo"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.socket.getaddrinfo()</span></code></a> correctly uses IDNA 2008 to process non-ASCII domain names. (<a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.getaddrinfo" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket.getaddrinfo()</span></code></a> uses IDNA 2003, which can give the wrong result in some cases and cause you to connect to a different host than the one you intended; see <a class="reference external" href="https://bugs.python.org/issue17305">bpo-17305</a>.)</p> <p>This function’s behavior can be customized using <a class="reference internal" href="reference-testing#trio.socket.set_custom_hostname_resolver" title="trio.socket.set_custom_hostname_resolver"><code class="xref py py-func docutils literal notranslate"><span class="pre">set_custom_hostname_resolver()</span></code></a>.</p> </dd>
</dl> <dl class="function"> <h3 id="trio.socket.getnameinfo"><code><em>await</em> trio.socket.getnameinfo(sockaddr, flags)</code></h3> <dd>
<p>Look up a name given a numeric address.</p> <p>Arguments and return values are identical to <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.getnameinfo" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket.getnameinfo()</span></code></a>, except that this version is async.</p> <p>This function’s behavior can be customized using <a class="reference internal" href="reference-testing#trio.socket.set_custom_hostname_resolver" title="trio.socket.set_custom_hostname_resolver"><code class="xref py py-func docutils literal notranslate"><span class="pre">set_custom_hostname_resolver()</span></code></a>.</p> </dd>
</dl> <dl class="function"> <h3 id="trio.socket.getprotobyname"><code><em>await</em> trio.socket.getprotobyname(name)</code></h3> <dd>
<p>Look up a protocol number by name. (Rarely used.)</p> <p>Like <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.getprotobyname" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket.getprotobyname()</span></code></a>, but async.</p> </dd>
</dl> <p>Trio intentionally DOES NOT include some obsolete, redundant, or broken features:</p> <ul> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.gethostbyname" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">gethostbyname()</span></code></a>, <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.gethostbyname_ex" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">gethostbyname_ex()</span></code></a>, <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.gethostbyaddr" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">gethostbyaddr()</span></code></a>: obsolete; use <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.getaddrinfo" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a> and <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.getnameinfo" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">getnameinfo()</span></code></a> instead.</p></li> <li>
<p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.getservbyport" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">getservbyport()</span></code></a>: obsolete and <a class="reference external" href="https://bugs.python.org/issue30482">buggy</a>; instead, do:</p> <pre data-language="python">_, service_name = await getnameinfo((127.0.0.1, port), NI_NUMERICHOST))</pre> </li> <li>
<p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.getservbyname" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">getservbyname()</span></code></a>: obsolete and <a class="reference external" href="https://bugs.python.org/issue30482">buggy</a>; instead, do:</p> <pre data-language="python">await getaddrinfo(None, service_name)</pre> </li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.getfqdn" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">getfqdn()</span></code></a>: obsolete; use <a class="reference internal" href="#trio.socket.getaddrinfo" title="trio.socket.getaddrinfo"><code class="xref py py-func docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a> with the <code class="docutils literal notranslate"><span class="pre">AI_CANONNAME</span></code> flag.</p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.getdefaulttimeout" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">getdefaulttimeout()</span></code></a>, <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.setdefaulttimeout" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">setdefaulttimeout()</span></code></a>: instead, use Trio’s standard support for <a class="reference internal" href="reference-core#cancellation"><span class="std std-ref">Cancellation and timeouts</span></a>.</p></li> <li><p>On Windows, <code class="docutils literal notranslate"><span class="pre">SO_REUSEADDR</span></code> is not exported, because it’s a trap: the name is the same as Unix <code class="docutils literal notranslate"><span class="pre">SO_REUSEADDR</span></code>, but the semantics are <a class="reference external" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms740621(v=vs.85).aspx">different and extremely broken</a>. In the very rare cases where you actually want <code class="docutils literal notranslate"><span class="pre">SO_REUSEADDR</span></code> on Windows, then it can still be accessed from the standard library’s <a class="reference external" href="https://docs.python.org/3/library/socket.html#module-socket" title="(in Python v3.7)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> module.</p></li> </ul>   <h3>Socket objects</h3> <dl class="class"> <h3 id="trio.socket.SocketType"><code><em>class</em> trio.socket.SocketType</code></h3> <dd>
<blockquote class="admonition note"> <h4 class="admonition-title">Note</h4> <p><a class="reference internal" href="#trio.socket.SocketType" title="trio.socket.SocketType"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.socket.SocketType</span></code></a> is an abstract class and cannot be instantiated directly; you get concrete socket objects by calling constructors like <a class="reference internal" href="#trio.socket.socket" title="trio.socket.socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.socket.socket()</span></code></a>. However, you can use it to check if an object is a Trio socket via <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">trio.socket.SocketType)</span></code>.</p> </blockquote> <p>Trio socket objects are overall very similar to the <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket-objects" title="(in Python v3.7)"><span class="xref std std-ref">standard library socket objects</span></a>, with a few important differences:</p> <p>First, and most obviously, everything is made “Trio-style”: blocking methods become async methods, and the following attributes are <em>not</em> supported:</p> <ul class="simple"> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.setblocking" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setblocking()</span></code></a>: Trio sockets always act like blocking sockets; if you need to read/write from multiple sockets at once, then create multiple tasks.</p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.settimeout" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">settimeout()</span></code></a>: see <a class="reference internal" href="reference-core#cancellation"><span class="std std-ref">Cancellation and timeouts</span></a> instead.</p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.makefile" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">makefile()</span></code></a>: Python’s file-like API is synchronous, so it can’t be implemented on top of an async socket.</p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.sendall" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sendall()</span></code></a>: Could be supported, but you’re better off using the higher-level <a class="reference internal" href="#trio.SocketStream" title="trio.SocketStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketStream</span></code></a>, and specifically its <a class="reference internal" href="#trio.SocketStream.send_all" title="trio.SocketStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_all()</span></code></a> method, which also does additional error checking.</p></li> </ul> <p>In addition, the following methods are similar to the equivalents in <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket.socket()</span></code></a>, but have some Trio-specific quirks:</p> <dl class="method"> <h3 id="trio.socket.SocketType.connect"><code><em>await</em> connect()</code></h3> <dd>
<p>Connect the socket to a remote address.</p> <p>Similar to <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.connect" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.socket.connect()</span></code></a>, except async.</p> <blockquote class="admonition warning"> <h4 class="admonition-title">Warning</h4> <p>Due to limitations of the underlying operating system APIs, it is not always possible to properly cancel a connection attempt once it has begun. If <a class="reference internal" href="#trio.socket.SocketType.connect" title="trio.socket.SocketType.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect()</span></code></a> is cancelled, and is unable to abort the connection attempt, then it will:</p> <ol class="arabic simple"> <li><p>forcibly close the socket to prevent accidental re-use</p></li> <li><p>raise <a class="reference internal" href="reference-core#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a>.</p></li> </ol> <p>tl;dr: if <a class="reference internal" href="#trio.socket.SocketType.connect" title="trio.socket.SocketType.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect()</span></code></a> is cancelled then the socket is left in an unknown state – possibly open, and possibly closed. The only reasonable thing to do is to close it.</p> </blockquote> </dd>
</dl> <dl class="method"> <h3 id="trio.socket.SocketType.is_readable"><code>is_readable()</code></h3> <dd>
<p>Check whether the socket is readable or not.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.socket.SocketType.sendfile"><code>sendfile()</code></h3> <dd>
<p><a class="reference external" href="https://github.com/python-trio/trio/issues/45">Not implemented yet!</a></p> </dd>
</dl> <p>We also keep track of an extra bit of state, because it turns out to be useful for <a class="reference internal" href="#trio.SocketStream" title="trio.SocketStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.SocketStream</span></code></a>:</p> <dl class="attribute"> <h3 id="trio.socket.SocketType.did_shutdown_SHUT_WR"><code>did_shutdown_SHUT_WR</code></h3> <dd>
<p>This <a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a> attribute is True if you’ve called <code class="docutils literal notranslate"><span class="pre">sock.shutdown(SHUT_WR)</span></code> or <code class="docutils literal notranslate"><span class="pre">sock.shutdown(SHUT_RDWR)</span></code>, and False otherwise.</p> </dd>
</dl> <p>The following methods are identical to their equivalents in <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket.socket()</span></code></a>, except async, and the ones that take address arguments require pre-resolved addresses:</p> <ul class="simple"> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.accept" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">accept()</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.bind" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bind()</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.recv" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recv()</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.recv_into" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recv_into()</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.recvfrom" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recvfrom()</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.recvfrom_into" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recvfrom_into()</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.recvmsg" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recvmsg()</span></code></a> (if available)</p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.recvmsg_into" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recvmsg_into()</span></code></a> (if available)</p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.send" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.sendto" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sendto()</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.sendmsg" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sendmsg()</span></code></a> (if available)</p></li> </ul> <p>All methods and attributes <em>not</em> mentioned above are identical to their equivalents in <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket.socket()</span></code></a>:</p> <ul class="simple"> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.family" title="(in Python v3.7)"><code class="xref py py-attr docutils literal notranslate"><span class="pre">family</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.type" title="(in Python v3.7)"><code class="xref py py-attr docutils literal notranslate"><span class="pre">type</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.proto" title="(in Python v3.7)"><code class="xref py py-attr docutils literal notranslate"><span class="pre">proto</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.fileno" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fileno()</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.listen" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">listen()</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.getpeername" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getpeername()</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.getsockname" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getsockname()</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.close" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.shutdown" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">shutdown()</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.setsockopt" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setsockopt()</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.getsockopt" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getsockopt()</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.dup" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dup()</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.detach" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">detach()</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.share" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">share()</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.set_inheritable" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_inheritable()</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.get_inheritable" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_inheritable()</span></code></a></p></li> </ul> </dd>
</dl>    <h2>Asynchronous filesystem I/O</h2> <p>Trio provides built-in facilities for performing asynchronous filesystem operations like reading or renaming a file. Generally, we recommend that you use these instead of Python’s normal synchronous file APIs. But the tradeoffs here are somewhat subtle: sometimes people switch to async I/O, and then they’re surprised and confused when they find it doesn’t speed up their program. The next section explains the theory behind async file I/O, to help you better understand your code’s behavior. Or, if you just want to get started, you can <a class="reference external" href="ref:async-file-io-overview">jump down to the API overview</a>.</p>  <h3>Background: Why is async file I/O useful? The answer may surprise you</h3> <p>Many people expect that switching to from synchronous file I/O to async file I/O will always make their program faster. This is not true! If we just look at total throughput, then async file I/O might be faster, slower, or about the same, and it depends in a complicated way on things like your exact patterns of disk access, or how much RAM you have. The main motivation for async file I/O is not to improve throughput, but to <strong>reduce the frequency of latency glitches.</strong></p> <p>To understand why, you need to know two things.</p> <p>First, right now no mainstream operating system offers a generic, reliable, native API for async file or filesystem operations, so we have to fake it by using threads (specifically, <a class="reference internal" href="reference-core#trio.to_thread.run_sync" title="trio.to_thread.run_sync"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.to_thread.run_sync()</span></code></a>). This is cheap but isn’t free: on a typical PC, dispatching to a worker thread adds something like ~100 µs of overhead to each operation. (“µs” is pronounced “microseconds”, and there are 1,000,000 µs in a second. Note that all the numbers here are going to be rough orders of magnitude to give you a sense of scale; if you need precise numbers for your environment, measure!)</p> <p>And second, the cost of a disk operation is incredibly bimodal. Sometimes, the data you need is already cached in RAM, and then accessing it is very, very fast – calling <a class="reference external" href="https://docs.python.org/3/library/io.html#io.FileIO" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.FileIO</span></code></a>’s <code class="docutils literal notranslate"><span class="pre">read</span></code> method on a cached file takes on the order of ~1 µs. But when the data isn’t cached, then accessing it is much, much slower: the average is ~100 µs for SSDs and ~10,000 µs for spinning disks, and if you look at tail latencies then for both types of storage you’ll see cases where occasionally some operation will be 10x or 100x slower than average. And that’s assuming your program is the only thing trying to use that disk – if you’re on some oversold cloud VM fighting for I/O with other tenants then who knows what will happen. And some operations can require multiple disk accesses.</p> <p>Putting these together: if your data is in RAM then it should be clear that using a thread is a terrible idea – if you add 100 µs of overhead to a 1 µs operation, then that’s a 100x slowdown! On the other hand, if your data’s on a spinning disk, then using a thread is <em>great</em> – instead of blocking the main thread and all tasks for 10,000 µs, we only block them for 100 µs and can spend the rest of that time running other tasks to get useful work done, which can effectively be a 100x speedup.</p> <p>But here’s the problem: for any individual I/O operation, there’s no way to know in advance whether it’s going to be one of the fast ones or one of the slow ones, so you can’t pick and choose. When you switch to async file I/O, it makes all the fast operations slower, and all the slow operations faster. Is that a win? In terms of overall speed, it’s hard to say: it depends what kind of disks you’re using and your kernel’s disk cache hit rate, which in turn depends on your file access patterns, how much spare RAM you have, the load on your service, … all kinds of things. If the answer is important to you, then there’s no substitute for measuring your code’s actual behavior in your actual deployment environment. But what we <em>can</em> say is that async disk I/O makes performance much more predictable across a wider range of runtime conditions.</p> <p><strong>If you’re not sure what to do, then we recommend that you use async disk I/O by default,</strong> because it makes your code more robust when conditions are bad, especially with regards to tail latencies; this improves the chances that what your users see matches what you saw in testing. Blocking the main thread stops <em>all</em> tasks from running for that time. 10,000 µs is 10 ms, and it doesn’t take many 10 ms glitches to start adding up to <a class="reference external" href="https://google.com/search?q=latency+cost">real money</a>; async disk I/O can help prevent those. Just don’t expect it to be magic, and be aware of the tradeoffs.</p>   <h3>API overview</h3> <p>If you want to perform general filesystem operations like creating and listing directories, renaming files, or checking file metadata – or if you just want a friendly way to work with filesystem paths – then you want <a class="reference internal" href="#trio.Path" title="trio.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.Path</span></code></a>. It’s an asyncified replacement for the standard library’s <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">pathlib.Path</span></code></a>, and provides the same comprehensive set of operations.</p> <p>For reading and writing to files and file-like objects, Trio also provides a mechanism for wrapping any synchronous file-like object into an asynchronous interface. If you have a <a class="reference internal" href="#trio.Path" title="trio.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.Path</span></code></a> object you can get one of these by calling its <a class="reference internal" href="#trio.Path.open" title="trio.Path.open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">open()</span></code></a> method; or if you know the file’s name you can open it directly with <a class="reference internal" href="#trio.open_file" title="trio.open_file"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.open_file()</span></code></a>. Alternatively, if you already have an open file-like object, you can wrap it with <a class="reference internal" href="#trio.wrap_file" title="trio.wrap_file"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.wrap_file()</span></code></a> – one case where this is especially useful is to wrap <a class="reference external" href="https://docs.python.org/3/library/io.html#io.BytesIO" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BytesIO</span></code></a> or <a class="reference external" href="https://docs.python.org/3/library/io.html#io.StringIO" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.StringIO</span></code></a> when writing tests.</p>   <h3>Asynchronous path objects</h3> <dl class="class"> <h3 id="trio.Path"><code><em>class</em> trio.Path(*args)</code></h3> <dd>
<p>A <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">pathlib.Path</span></code></a> wrapper that executes blocking methods in <a class="reference internal" href="reference-core#trio.to_thread.run_sync" title="trio.to_thread.run_sync"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trio.to_thread.run_sync()</span></code></a>.</p> <dl class="method"> <h3 id="trio.Path.as_posix"><code>as_posix()</code></h3> <dd>
<p>Return the string representation of the path with forward (/) slashes.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Path.as_uri"><code>as_uri()</code></h3> <dd>
<p>Return the path as a ‘file’ URI.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Path.chmod"><code><em>await</em> chmod(*args, **kwargs)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.chmod" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">chmod()</span></code></a>, but async.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Path.cwd"><code><em>classmethod await</em> cwd(*args, **kwargs)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.cwd" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cwd()</span></code></a>, but async.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Path.exists"><code><em>await</em> exists(*args, **kwargs)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.exists" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exists()</span></code></a>, but async.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Path.expanduser"><code><em>await</em> expanduser(*args, **kwargs)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.expanduser" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">expanduser()</span></code></a>, but async.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Path.glob"><code><em>await</em> glob(*args, **kwargs)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.glob" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">glob()</span></code></a>, but async.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Path.group"><code><em>await</em> group(*args, **kwargs)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.group" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">group()</span></code></a>, but async.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Path.home"><code><em>classmethod await</em> home(*args, **kwargs)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.home" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">home()</span></code></a>, but async.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Path.is_absolute"><code>is_absolute()</code></h3> <dd>
<p>True if the path is absolute (has both a root and, if applicable, a drive).</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Path.is_block_device"><code><em>await</em> is_block_device(*args, **kwargs)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_block_device" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_block_device()</span></code></a>, but async.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Path.is_char_device"><code><em>await</em> is_char_device(*args, **kwargs)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_char_device" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_char_device()</span></code></a>, but async.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Path.is_dir"><code><em>await</em> is_dir(*args, **kwargs)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_dir" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_dir()</span></code></a>, but async.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Path.is_fifo"><code><em>await</em> is_fifo(*args, **kwargs)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_fifo" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_fifo()</span></code></a>, but async.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Path.is_file"><code><em>await</em> is_file(*args, **kwargs)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_file" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_file()</span></code></a>, but async.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Path.is_reserved"><code>is_reserved()</code></h3> <dd>
<p>Return True if the path contains one of the special names reserved by the system, if any.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Path.is_socket"><code><em>await</em> is_socket(*args, **kwargs)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_socket" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_socket()</span></code></a>, but async.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Path.is_symlink"><code><em>await</em> is_symlink(*args, **kwargs)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_symlink" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_symlink()</span></code></a>, but async.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Path.iterdir"><code><em>await</em> iterdir(*args, **kwargs)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.iterdir" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pathlib.Path.iterdir()</span></code></a>, but async.</p> <p>This is an async method that returns a synchronous iterator, so you use it like:</p> <pre data-language="python">for subpath in await mypath.iterdir():
    ...</pre> <p>Note that it actually loads the whole directory list into memory immediately, during the initial call. (See <a class="reference external" href="https://github.com/python-trio/trio/issues/501">issue #501</a> for discussion.)</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Path.joinpath"><code>joinpath(*args)</code></h3> <dd>
<p>Combine this path with one or several arguments, and return a new path representing either a subpath (if all arguments are relative paths) or a totally different path (if one of the arguments is anchored).</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Path.lchmod"><code><em>await</em> lchmod(*args, **kwargs)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.lchmod" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lchmod()</span></code></a>, but async.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Path.lstat"><code><em>await</em> lstat(*args, **kwargs)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.lstat" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lstat()</span></code></a>, but async.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Path.match"><code>match(path_pattern)</code></h3> <dd>
<p>Return True if this path matches the given pattern.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Path.mkdir"><code><em>await</em> mkdir(*args, **kwargs)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.mkdir" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mkdir()</span></code></a>, but async.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Path.open"><code><em>await</em> open(mode='r', buffering=-1, encoding=None, errors=None, newline=None)</code></h3> <dd>
<p>Open the file pointed by this path and return a file object, as the built-in open() function does.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Path.owner"><code><em>await</em> owner(*args, **kwargs)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.owner" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">owner()</span></code></a>, but async.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Path.read_bytes"><code><em>await</em> read_bytes(*args, **kwargs)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.read_bytes" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read_bytes()</span></code></a>, but async.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Path.read_text"><code><em>await</em> read_text(*args, **kwargs)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.read_text" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read_text()</span></code></a>, but async.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Path.relative_to"><code>relative_to(*other)</code></h3> <dd>
<p>Return the relative path to another path identified by the passed arguments. If the operation is not possible (because this is not a subpath of the other path), raise ValueError.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Path.rename"><code><em>await</em> rename(*args, **kwargs)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.rename" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rename()</span></code></a>, but async.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Path.replace"><code><em>await</em> replace(*args, **kwargs)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.replace" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">replace()</span></code></a>, but async.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Path.resolve"><code><em>await</em> resolve(*args, **kwargs)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.resolve" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">resolve()</span></code></a>, but async.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Path.rglob"><code><em>await</em> rglob(*args, **kwargs)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.rglob" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rglob()</span></code></a>, but async.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Path.rmdir"><code><em>await</em> rmdir(*args, **kwargs)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.rmdir" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rmdir()</span></code></a>, but async.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Path.samefile"><code><em>await</em> samefile(*args, **kwargs)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.samefile" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">samefile()</span></code></a>, but async.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Path.stat"><code><em>await</em> stat(*args, **kwargs)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.stat" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stat()</span></code></a>, but async.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Path.symlink_to"><code><em>await</em> symlink_to(*args, **kwargs)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.symlink_to" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">symlink_to()</span></code></a>, but async.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Path.touch"><code><em>await</em> touch(*args, **kwargs)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.touch" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">touch()</span></code></a>, but async.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Path.unlink"><code><em>await</em> unlink(*args, **kwargs)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.unlink" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unlink()</span></code></a>, but async.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Path.with_name"><code>with_name(name)</code></h3> <dd>
<p>Return a new path with the file name changed.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Path.with_suffix"><code>with_suffix(suffix)</code></h3> <dd>
<p>Return a new path with the file suffix changed (or added, if none).</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Path.write_bytes"><code><em>await</em> write_bytes(*args, **kwargs)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.write_bytes" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write_bytes()</span></code></a>, but async.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Path.write_text"><code><em>await</em> write_text(*args, **kwargs)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.write_text" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write_text()</span></code></a>, but async.</p> </dd>
</dl> </dd>
</dl>   <h3>Asynchronous file objects</h3> <dl class="function"> <h3 id="trio.open_file"><code><em>await</em> trio.open_file(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)</code></h3> <dd>
<p>Asynchronous version of <a class="reference external" href="https://docs.python.org/3/library/io.html#io.open" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">io.open()</span></code></a>.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Returns</h4> <dd class="field-odd">
<p>An <a class="reference internal" href="https://trio.readthedocs.io/en/v0.12.1/glossary.html#term-asynchronous-file-object"><span class="xref std std-term">asynchronous file object</span></a></p> </dd> </dl> <p>Example:</p> <pre data-language="python">async with await trio.open_file(filename) as f:
    async for line in f:
        pass

assert f.closed</pre> <blockquote class="admonition seealso"> <h4 class="admonition-title">See also</h4> <p><a class="reference internal" href="#trio.Path.open" title="trio.Path.open"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.Path.open()</span></code></a></p> </blockquote> </dd>
</dl> <dl class="function"> <h3 id="trio.wrap_file"><code>trio.wrap_file(file)</code></h3> <dd>
<p>This wraps any file object in a wrapper that provides an asynchronous file object interface.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<p><code>file</code> – a <a class="reference external" href="https://docs.python.org/3/glossary.html#term-file-object" title="(in Python v3.7)"><span class="xref std std-term">file object</span></a></p> </dd> <h4 class="field-even" style="margin: 0">Returns</h4> <dd class="field-even">
<p>An <a class="reference internal" href="https://trio.readthedocs.io/en/v0.12.1/glossary.html#term-asynchronous-file-object"><span class="xref std std-term">asynchronous file object</span></a> that wraps <code class="docutils literal notranslate"><span class="pre">file</span></code></p> </dd> </dl> <p>Example:</p> <pre data-language="python">async_file = trio.wrap_file(StringIO('asdf'))

assert await async_file.read() == 'asdf'</pre> </dd>
</dl> <dl class="interface"> <h3 id="trio.Asynchronous file interface"><code>Asynchronous file interface</code></h3> <dd>
<p>Trio’s asynchronous file objects have an interface that automatically adapts to the object being wrapped. Intuitively, you can mostly treat them like a regular <a class="reference external" href="https://docs.python.org/3/glossary.html#term-file-object" title="(in Python v3.7)"><span class="xref std std-term">file object</span></a>, except adding an <code class="docutils literal notranslate"><span class="pre">await</span></code> in front of any of methods that do I/O. The definition of <a class="reference external" href="https://docs.python.org/3/glossary.html#term-file-object" title="(in Python v3.7)"><span class="xref std std-term">file object</span></a> is a little vague in Python though, so here are the details:</p> <ul class="simple"> <li><p>Synchronous attributes/methods: if any of the following attributes or methods are present, then they’re re-exported unchanged: <code class="docutils literal notranslate"><span class="pre">closed</span></code>, <code class="docutils literal notranslate"><span class="pre">encoding</span></code>, <code class="docutils literal notranslate"><span class="pre">errors</span></code>, <code class="docutils literal notranslate"><span class="pre">fileno</span></code>, <code class="docutils literal notranslate"><span class="pre">isatty</span></code>, <code class="docutils literal notranslate"><span class="pre">newlines</span></code>, <code class="docutils literal notranslate"><span class="pre">readable</span></code>, <code class="docutils literal notranslate"><span class="pre">seekable</span></code>, <code class="docutils literal notranslate"><span class="pre">writable</span></code>, <code class="docutils literal notranslate"><span class="pre">buffer</span></code>, <code class="docutils literal notranslate"><span class="pre">raw</span></code>, <code class="docutils literal notranslate"><span class="pre">line_buffering</span></code>, <code class="docutils literal notranslate"><span class="pre">closefd</span></code>, <code class="docutils literal notranslate"><span class="pre">name</span></code>, <code class="docutils literal notranslate"><span class="pre">mode</span></code>, <code class="docutils literal notranslate"><span class="pre">getvalue</span></code>, <code class="docutils literal notranslate"><span class="pre">getbuffer</span></code>.</p></li> <li><p>Async methods: if any of the following methods are present, then they’re re-exported as an async method: <code class="docutils literal notranslate"><span class="pre">flush</span></code>, <code class="docutils literal notranslate"><span class="pre">read</span></code>, <code class="docutils literal notranslate"><span class="pre">read1</span></code>, <code class="docutils literal notranslate"><span class="pre">readall</span></code>, <code class="docutils literal notranslate"><span class="pre">readinto</span></code>, <code class="docutils literal notranslate"><span class="pre">readline</span></code>, <code class="docutils literal notranslate"><span class="pre">readlines</span></code>, <code class="docutils literal notranslate"><span class="pre">seek</span></code>, <code class="docutils literal notranslate"><span class="pre">tell</span></code>, <code class="docutils literal notranslate"><span class="pre">truncate</span></code>, <code class="docutils literal notranslate"><span class="pre">write</span></code>, <code class="docutils literal notranslate"><span class="pre">writelines</span></code>, <code class="docutils literal notranslate"><span class="pre">readinto1</span></code>, <code class="docutils literal notranslate"><span class="pre">peek</span></code>, <code class="docutils literal notranslate"><span class="pre">detach</span></code>.</p></li> </ul> <p>Special notes:</p> <ul> <li><p>Async file objects implement Trio’s <a class="reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResource</span></code></a> interface: you close them by calling <a class="reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> instead of <code class="docutils literal notranslate"><span class="pre">close</span></code> (!!), and they can be used as async context managers. Like all <a class="reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> methods, the <code class="docutils literal notranslate"><span class="pre">aclose</span></code> method on async file objects is guaranteed to close the file before returning, even if it is cancelled or otherwise raises an error.</p></li> <li><p>Using the same async file object from multiple tasks simultaneously: because the async methods on async file objects are implemented using threads, it’s only safe to call two of them at the same time from different tasks IF the underlying synchronous file object is thread-safe. You should consult the documentation for the object you’re wrapping. For objects returned from <a class="reference internal" href="#trio.open_file" title="trio.open_file"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.open_file()</span></code></a> or <a class="reference internal" href="#trio.Path.open" title="trio.Path.open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trio.Path.open()</span></code></a>, it depends on whether you open the file in binary mode or text mode: <a class="reference external" href="https://docs.python.org/3/library/io.html#multi-threading">binary mode files are task-safe/thread-safe, text mode files are not</a>.</p></li> <li>
<p>Async file objects can be used as async iterators to iterate over the lines of the file:</p> <pre data-language="python">async with await trio.open_file(...) as f:
    async for line in f:
        print(line)</pre> </li> <li><p>The <code class="docutils literal notranslate"><span class="pre">detach</span></code> method, if present, returns an async file object.</p></li> </ul> <p>This should include all the attributes exposed by classes in <a class="reference external" href="https://docs.python.org/3/library/io.html#module-io" title="(in Python v3.7)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a>. But if you’re wrapping an object that has other attributes that aren’t on the list above, then you can access them via the <code class="docutils literal notranslate"><span class="pre">.wrapped</span></code> attribute:</p> <dl class="attribute"> <h3 id="trio.Asynchronous file interface.wrapped"><code>wrapped</code></h3> <dd>
<p>The underlying synchronous file object.</p> </dd>
</dl> </dd>
</dl>    <h2>Spawning subprocesses</h2> <p>Trio provides support for spawning other programs as subprocesses, communicating with them via pipes, sending them signals, and waiting for them to exit. The interface for doing so consists of two layers:</p> <ul class="simple"> <li><p><a class="reference internal" href="#trio.run_process" title="trio.run_process"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run_process()</span></code></a> runs a process from start to finish and returns a <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">CompletedProcess</span></code></a> object describing its outputs and return value. This is what you should reach for if you want to run a process to completion before continuing, while possibly sending it some input or capturing its output. It is modelled after the standard <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.run" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">subprocess.run()</span></code></a> with some additional features and safer defaults.</p></li> <li><p><a class="reference internal" href="#trio.open_process" title="trio.open_process"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.open_process</span></code></a> starts a process in the background and returns a <a class="reference internal" href="#trio.Process" title="trio.Process"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Process</span></code></a> object to let you interact with it. Using it requires a bit more code than <a class="reference internal" href="#trio.run_process" title="trio.run_process"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run_process</span></code></a>, but exposes additional capabilities: back-and-forth communication, processing output as soon as it is generated, and so forth. It is modelled after the standard library <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">subprocess.Popen</span></code></a>.</p></li> </ul>  <h3>Options for starting subprocesses</h3> <p>All of Trio’s subprocess APIs accept the numerous keyword arguments used by the standard <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#module-subprocess" title="(in Python v3.7)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">subprocess</span></code></a> module to control the environment in which a process starts and the mechanisms used for communicating with it. These may be passed wherever you see <code class="docutils literal notranslate"><span class="pre">**options</span></code> in the documentation below. See the <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#popen-constructor">full list</a> or just the <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#frequently-used-arguments">frequently used ones</a> in the <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#module-subprocess" title="(in Python v3.7)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">subprocess</span></code></a> documentation. (You may need to <code class="docutils literal notranslate"><span class="pre">import</span>
<span class="pre">subprocess</span></code> in order to access constants such as <code class="docutils literal notranslate"><span class="pre">PIPE</span></code> or <code class="docutils literal notranslate"><span class="pre">DEVNULL</span></code>.)</p> <p>Currently, Trio always uses unbuffered byte streams for communicating with a process, so it does not support the <code class="docutils literal notranslate"><span class="pre">encoding</span></code>, <code class="docutils literal notranslate"><span class="pre">errors</span></code>, <code class="docutils literal notranslate"><span class="pre">universal_newlines</span></code> (alias <code class="docutils literal notranslate"><span class="pre">text</span></code> in 3.7+), and <code class="docutils literal notranslate"><span class="pre">bufsize</span></code> options.</p>   <h3>Running a process and waiting for it to finish</h3> <p>The basic interface for running a subprocess start-to-finish is <a class="reference internal" href="#trio.run_process" title="trio.run_process"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run_process()</span></code></a>. It always waits for the subprocess to exit before returning, so there’s no need to worry about leaving a process running by mistake after you’ve gone on to do other things. <a class="reference internal" href="#trio.run_process" title="trio.run_process"><code class="xref py py-func docutils literal notranslate"><span class="pre">run_process()</span></code></a> is similar to the standard library <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.run" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">subprocess.run()</span></code></a> function, but tries to have safer defaults: with no options, the subprocess’s input is empty rather than coming from the user’s terminal, and a failure in the subprocess will be propagated as a <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError" title="(in Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">subprocess.CalledProcessError</span></code></a> exception. Of course, these defaults can be changed where necessary.</p> <dl class="function"> <h3 id="trio.run_process"><code><em>await</em> trio.run_process(command, *, stdin=b'', capture_stdout=False, capture_stderr=False, check=True, **options)</code></h3> <dd>
<p>Run <code class="docutils literal notranslate"><span class="pre">command</span></code> in a subprocess, wait for it to complete, and return a <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">subprocess.CompletedProcess</span></code></a> instance describing the results.</p> <p>If cancelled, <a class="reference internal" href="#trio.run_process" title="trio.run_process"><code class="xref py py-func docutils literal notranslate"><span class="pre">run_process()</span></code></a> terminates the subprocess and waits for it to exit before propagating the cancellation, like <a class="reference internal" href="#trio.Process.aclose" title="trio.Process.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Process.aclose()</span></code></a>.</p> <p><strong>Input:</strong> The subprocess’s standard input stream is set up to receive the bytes provided as <code class="docutils literal notranslate"><span class="pre">stdin</span></code>. Once the given input has been fully delivered, or if none is provided, the subprocess will receive end-of-file when reading from its standard input. Alternatively, if you want the subprocess to read its standard input from the same place as the parent Trio process, you can pass <code class="docutils literal notranslate"><span class="pre">stdin=None</span></code>.</p> <p><strong>Output:</strong> By default, any output produced by the subprocess is passed through to the standard output and error streams of the parent Trio process. If you would like to capture this output and do something with it, you can pass <code class="docutils literal notranslate"><span class="pre">capture_stdout=True</span></code> to capture the subprocess’s standard output, and/or <code class="docutils literal notranslate"><span class="pre">capture_stderr=True</span></code> to capture its standard error. Captured data is provided as the <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess.stdout" title="(in Python v3.7)"><code class="xref py py-attr docutils literal notranslate"><span class="pre">stdout</span></code></a> and/or <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess.stderr" title="(in Python v3.7)"><code class="xref py py-attr docutils literal notranslate"><span class="pre">stderr</span></code></a> attributes of the returned <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">CompletedProcess</span></code></a> object. The value for any stream that was not captured will be <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p> <p>If you want to capture both stdout and stderr while keeping them separate, pass <code class="docutils literal notranslate"><span class="pre">capture_stdout=True,</span> <span class="pre">capture_stderr=True</span></code>.</p> <p>If you want to capture both stdout and stderr but mixed together in the order they were printed, use: <code class="docutils literal notranslate"><span class="pre">capture_stdout=True,</span> <span class="pre">stderr=subprocess.STDOUT</span></code>. This directs the child’s stderr into its stdout, so the combined output will be available in the <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess.stdout" title="(in Python v3.7)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stdout</span></code></a> attribute.</p> <p><strong>Error checking:</strong> If the subprocess exits with a nonzero status code, indicating failure, <a class="reference internal" href="#trio.run_process" title="trio.run_process"><code class="xref py py-func docutils literal notranslate"><span class="pre">run_process()</span></code></a> raises a <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError" title="(in Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">subprocess.CalledProcessError</span></code></a> exception rather than returning normally. The captured outputs are still available as the <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError.stdout" title="(in Python v3.7)"><code class="xref py py-attr docutils literal notranslate"><span class="pre">stdout</span></code></a> and <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError.stderr" title="(in Python v3.7)"><code class="xref py py-attr docutils literal notranslate"><span class="pre">stderr</span></code></a> attributes of that exception. To disable this behavior, so that <a class="reference internal" href="#trio.run_process" title="trio.run_process"><code class="xref py py-func docutils literal notranslate"><span class="pre">run_process()</span></code></a> returns normally even if the subprocess exits abnormally, pass <code class="docutils literal notranslate"><span class="pre">check=False</span></code>.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<ul class="simple"> <li><p><code>command</code> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.7)"><em>list</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><em>str</em></a>) – The command to run. Typically this is a sequence of strings such as <code class="docutils literal notranslate"><span class="pre">['ls',</span> <span class="pre">'-l',</span> <span class="pre">'directory</span> <span class="pre">with</span> <span class="pre">spaces']</span></code>, where the first element names the executable to invoke and the other elements specify its arguments. With <code class="docutils literal notranslate"><span class="pre">shell=True</span></code> in the <code class="docutils literal notranslate"><span class="pre">**options</span></code>, or on Windows, <code class="docutils literal notranslate"><span class="pre">command</span></code> may alternatively be a string, which will be parsed following platform-dependent <a class="reference internal" href="#subprocess-quoting"><span class="std std-ref">quoting rules</span></a>.</p></li> <li><p><code>stdin</code> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytes" title="(in Python v3.7)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bytes</span></code></a>, file descriptor, or None) – The bytes to provide to the subprocess on its standard input stream, or <code class="docutils literal notranslate"><span class="pre">None</span></code> if the subprocess’s standard input should come from the same place as the parent Trio process’s standard input. As is the case with the <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#module-subprocess" title="(in Python v3.7)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">subprocess</span></code></a> module, you can also pass a file descriptor or an object with a <code class="docutils literal notranslate"><span class="pre">fileno()</span></code> method, in which case the subprocess’s standard input will come from that file.</p></li> <li><p><code>capture_stdout</code> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – If true, capture the bytes that the subprocess writes to its standard output stream and return them in the <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess.stdout" title="(in Python v3.7)"><code class="xref py py-attr docutils literal notranslate"><span class="pre">stdout</span></code></a> attribute of the returned <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">CompletedProcess</span></code></a> object.</p></li> <li><p><code>capture_stderr</code> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – If true, capture the bytes that the subprocess writes to its standard error stream and return them in the <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess.stderr" title="(in Python v3.7)"><code class="xref py py-attr docutils literal notranslate"><span class="pre">stderr</span></code></a> attribute of the returned <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">CompletedProcess</span></code></a> object.</p></li> <li><p><code>check</code> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – If false, don’t validate that the subprocess exits successfully. You should be sure to check the <code class="docutils literal notranslate"><span class="pre">returncode</span></code> attribute of the returned object if you pass <code class="docutils literal notranslate"><span class="pre">check=False</span></code>, so that errors don’t pass silently.</p></li> <li><p><code>**options</code> – <a class="reference internal" href="#trio.run_process" title="trio.run_process"><code class="xref py py-func docutils literal notranslate"><span class="pre">run_process()</span></code></a> also accepts any <a class="reference internal" href="#subprocess-options"><span class="std std-ref">general subprocess options</span></a> and passes them on to the <a class="reference internal" href="#trio.Process" title="trio.Process"><code class="xref py py-class docutils literal notranslate"><span class="pre">Process</span></code></a> constructor. This includes the <code class="docutils literal notranslate"><span class="pre">stdout</span></code> and <code class="docutils literal notranslate"><span class="pre">stderr</span></code> options, which provide additional redirection possibilities such as <code class="docutils literal notranslate"><span class="pre">stderr=subprocess.STDOUT</span></code>, <code class="docutils literal notranslate"><span class="pre">stdout=subprocess.DEVNULL</span></code>, or file descriptors.</p></li> </ul> </dd> <h4 class="field-even" style="margin: 0">Returns</h4> <dd class="field-even">
<p>A <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">subprocess.CompletedProcess</span></code></a> instance describing the return code and outputs.</p> </dd> <h4 class="field-odd" style="margin: 0">Raises</h4> <dd class="field-odd">
<ul class="simple"> <li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#UnicodeError" title="(in Python v3.7)"><code>UnicodeError</code></a> – if <code class="docutils literal notranslate"><span class="pre">stdin</span></code> is specified as a Unicode string, rather than bytes</p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><code>ValueError</code></a> – if multiple redirections are specified for the same stream, e.g., both <code class="docutils literal notranslate"><span class="pre">capture_stdout=True</span></code> and <code class="docutils literal notranslate"><span class="pre">stdout=subprocess.DEVNULL</span></code></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError" title="(in Python v3.7)"><code>subprocess.CalledProcessError</code></a> – if <code class="docutils literal notranslate"><span class="pre">check=False</span></code> is not passed and the process exits with a nonzero exit status</p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#OSError" title="(in Python v3.7)"><code>OSError</code></a> – if an error is encountered starting or communicating with the process</p></li> </ul> </dd> </dl> <blockquote class="admonition note"> <h4 class="admonition-title">Note</h4> <p>The child process runs in the same process group as the parent Trio process, so a Ctrl+C will be delivered simultaneously to both parent and child. If you don’t want this behavior, consult your platform’s documentation for starting child processes in a different process group.</p> </blockquote> </dd>
</dl>   <h3>Interacting with a process as it runs</h3> <p>If you want more control than <a class="reference internal" href="#trio.run_process" title="trio.run_process"><code class="xref py py-func docutils literal notranslate"><span class="pre">run_process()</span></code></a> affords, you can use <a class="reference internal" href="#trio.open_process" title="trio.open_process"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.open_process</span></code></a> to spawn a subprocess, and then interact with it using the <a class="reference internal" href="#trio.Process" title="trio.Process"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Process</span></code></a> interface.</p> <dl class="function"> <h3 id="trio.open_process"><code><em>await</em> trio.open_process(command, *, stdin=None, stdout=None, stderr=None, **options) → trio.Process</code></h3> <dd>
<p>Execute a child program in a new process.</p> <p>After construction, you can interact with the child process by writing data to its <a class="reference internal" href="#trio.Process.stdin" title="trio.Process.stdin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stdin</span></code></a> stream (a <a class="reference internal" href="#trio.abc.SendStream" title="trio.abc.SendStream"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SendStream</span></code></a>), reading data from its <a class="reference internal" href="#trio.Process.stdout" title="trio.Process.stdout"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stdout</span></code></a> and/or <a class="reference internal" href="#trio.Process.stderr" title="trio.Process.stderr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stderr</span></code></a> streams (both <a class="reference internal" href="#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReceiveStream</span></code></a>s), sending it signals using <a class="reference internal" href="#trio.Process.terminate" title="trio.Process.terminate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">terminate</span></code></a>, <a class="reference internal" href="#trio.Process.kill" title="trio.Process.kill"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kill</span></code></a>, or <a class="reference internal" href="#trio.Process.send_signal" title="trio.Process.send_signal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">send_signal</span></code></a>, and waiting for it to exit using <a class="reference internal" href="#trio.Process.wait" title="trio.Process.wait"><code class="xref py py-obj docutils literal notranslate"><span class="pre">wait</span></code></a>. See <a class="reference internal" href="#trio.Process" title="trio.Process"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Process</span></code></a> for details.</p> <p>Each standard stream is only available if you specify that a pipe should be created for it. For example, if you pass <code class="docutils literal notranslate"><span class="pre">stdin=subprocess.PIPE</span></code>, you can write to the <a class="reference internal" href="#trio.Process.stdin" title="trio.Process.stdin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stdin</span></code></a> stream, else <a class="reference internal" href="#trio.Process.stdin" title="trio.Process.stdin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stdin</span></code></a> will be <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<ul class="simple"> <li><p><code>command</code> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.7)"><em>list</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><em>str</em></a>) – The command to run. Typically this is a sequence of strings such as <code class="docutils literal notranslate"><span class="pre">['ls',</span> <span class="pre">'-l',</span> <span class="pre">'directory</span> <span class="pre">with</span> <span class="pre">spaces']</span></code>, where the first element names the executable to invoke and the other elements specify its arguments. With <code class="docutils literal notranslate"><span class="pre">shell=True</span></code> in the <code class="docutils literal notranslate"><span class="pre">**options</span></code>, or on Windows, <code class="docutils literal notranslate"><span class="pre">command</span></code> may alternatively be a string, which will be parsed following platform-dependent <a class="reference internal" href="#subprocess-quoting"><span class="std std-ref">quoting rules</span></a>.</p></li> <li><p><code>stdin</code> – Specifies what the child process’s standard input stream should connect to: output written by the parent (<code class="docutils literal notranslate"><span class="pre">subprocess.PIPE</span></code>), nothing (<code class="docutils literal notranslate"><span class="pre">subprocess.DEVNULL</span></code>), or an open file (pass a file descriptor or something whose <code class="docutils literal notranslate"><span class="pre">fileno</span></code> method returns one). If <code class="docutils literal notranslate"><span class="pre">stdin</span></code> is unspecified, the child process will have the same standard input stream as its parent.</p></li> <li><p><code>stdout</code> – Like <code class="docutils literal notranslate"><span class="pre">stdin</span></code>, but for the child process’s standard output stream.</p></li> <li><p><code>stderr</code> – Like <code class="docutils literal notranslate"><span class="pre">stdin</span></code>, but for the child process’s standard error stream. An additional value <code class="docutils literal notranslate"><span class="pre">subprocess.STDOUT</span></code> is supported, which causes the child’s standard output and standard error messages to be intermixed on a single standard output stream, attached to whatever the <code class="docutils literal notranslate"><span class="pre">stdout</span></code> option says to attach it to.</p></li> <li><p><code>**options</code> – Other <a class="reference internal" href="#subprocess-options"><span class="std std-ref">general subprocess options</span></a> are also accepted.</p></li> </ul> </dd> <h4 class="field-even" style="margin: 0">Returns</h4> <dd class="field-even">
<p>A new <a class="reference internal" href="#trio.Process" title="trio.Process"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Process</span></code></a> object.</p> </dd> <h4 class="field-odd" style="margin: 0">Raises</h4> <dd class="field-odd">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#OSError" title="(in Python v3.7)"><code>OSError</code></a> – if the process spawning fails, for example because the specified command could not be found.</p> </dd> </dl> </dd>
</dl> <dl class="class"> <h3 id="trio.Process"><code><em>class</em> trio.Process(*args, **kwargs)</code></h3> <dd>
<p>A child process. Like <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">subprocess.Popen</span></code></a>, but async.</p> <p>This class has no public constructor. To create a child process, use <a class="reference internal" href="#trio.open_process" title="trio.open_process"><code class="xref py py-obj docutils literal notranslate"><span class="pre">open_process</span></code></a>:</p> <pre data-language="python">process = await trio.open_process(...)</pre> <p><a class="reference internal" href="#trio.Process" title="trio.Process"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Process</span></code></a> implements the <a class="reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AsyncResource</span></code></a> interface. In order to make sure your process doesn’t end up getting abandoned by mistake or after an exception, you can use <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code>:</p> <pre data-language="python">async with await trio.open_process(...) as process:
    ...</pre> <p>“Closing” a <a class="reference internal" href="#trio.Process" title="trio.Process"><code class="xref py py-class docutils literal notranslate"><span class="pre">Process</span></code></a> will close any pipes to the child and wait for it to exit; if cancelled, the child will be forcibly killed and we will ensure it has finished exiting before allowing the cancellation to propagate.</p> <dl class="attribute"> <h3 id="trio.Process.args"><code>args</code></h3> <dd>
<p>The <code class="docutils literal notranslate"><span class="pre">command</span></code> passed at construction time, specifying the process to execute and its arguments.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Type</h4> <dd class="field-odd">
<p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)">str</a> or <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.7)">list</a></p> </dd> </dl> </dd>
</dl> <dl class="attribute"> <h3 id="trio.Process.pid"><code>pid</code></h3> <dd>
<p>The process ID of the child process managed by this object.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Type</h4> <dd class="field-odd">
<p><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)">int</a></p> </dd> </dl> </dd>
</dl> <dl class="attribute"> <h3 id="trio.Process.stdin"><code>stdin</code></h3> <dd>
<p>A stream connected to the child’s standard input stream: when you write bytes here, they become available for the child to read. Only available if the <a class="reference internal" href="#trio.Process" title="trio.Process"><code class="xref py py-class docutils literal notranslate"><span class="pre">Process</span></code></a> was constructed using <code class="docutils literal notranslate"><span class="pre">stdin=PIPE</span></code>; otherwise this will be None.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Type</h4> <dd class="field-odd">
<p><a class="reference internal" href="#trio.abc.SendStream" title="trio.abc.SendStream">trio.abc.SendStream</a> or <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)">None</a></p> </dd> </dl> </dd>
</dl> <dl class="attribute"> <h3 id="trio.Process.stdout"><code>stdout</code></h3> <dd>
<p>A stream connected to the child’s standard output stream: when the child writes to standard output, the written bytes become available for you to read here. Only available if the <a class="reference internal" href="#trio.Process" title="trio.Process"><code class="xref py py-class docutils literal notranslate"><span class="pre">Process</span></code></a> was constructed using <code class="docutils literal notranslate"><span class="pre">stdout=PIPE</span></code>; otherwise this will be None.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Type</h4> <dd class="field-odd">
<p><a class="reference internal" href="#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream">trio.abc.ReceiveStream</a> or <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)">None</a></p> </dd> </dl> </dd>
</dl> <dl class="attribute"> <h3 id="trio.Process.stderr"><code>stderr</code></h3> <dd>
<p>A stream connected to the child’s standard error stream: when the child writes to standard error, the written bytes become available for you to read here. Only available if the <a class="reference internal" href="#trio.Process" title="trio.Process"><code class="xref py py-class docutils literal notranslate"><span class="pre">Process</span></code></a> was constructed using <code class="docutils literal notranslate"><span class="pre">stderr=PIPE</span></code>; otherwise this will be None.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Type</h4> <dd class="field-odd">
<p><a class="reference internal" href="#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream">trio.abc.ReceiveStream</a> or <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)">None</a></p> </dd> </dl> </dd>
</dl> <dl class="attribute"> <h3 id="trio.Process.stdio"><code>stdio</code></h3> <dd>
<p>A stream that sends data to the child’s standard input and receives from the child’s standard output. Only available if both <a class="reference internal" href="#trio.Process.stdin" title="trio.Process.stdin"><code class="xref py py-attr docutils literal notranslate"><span class="pre">stdin</span></code></a> and <a class="reference internal" href="#trio.Process.stdout" title="trio.Process.stdout"><code class="xref py py-attr docutils literal notranslate"><span class="pre">stdout</span></code></a> are available; otherwise this will be None.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Type</h4> <dd class="field-odd">
<p><a class="reference internal" href="#trio.StapledStream" title="trio.StapledStream">trio.StapledStream</a> or <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)">None</a></p> </dd> </dl> </dd>
</dl> <dl class="attribute"> <h3 id="trio.Process.returncode"><code>returncode</code></h3> <dd>
<p>The exit status of the process (an integer), or <code class="docutils literal notranslate"><span class="pre">None</span></code> if it is not yet known to have exited.</p> <p>By convention, a return code of zero indicates success. On UNIX, negative values indicate termination due to a signal, e.g., -11 if terminated by signal 11 (<code class="docutils literal notranslate"><span class="pre">SIGSEGV</span></code>). On Windows, a process that exits due to a call to <a class="reference internal" href="#trio.Process.terminate" title="trio.Process.terminate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Process.terminate()</span></code></a> will have an exit status of 1.</p> <p>Accessing this attribute does not check for termination; use <a class="reference internal" href="#trio.Process.poll" title="trio.Process.poll"><code class="xref py py-meth docutils literal notranslate"><span class="pre">poll()</span></code></a> or <a class="reference internal" href="#trio.Process.wait" title="trio.Process.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a> for that.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Process.aclose"><code><em>await</em> aclose()</code></h3> <dd>
<p>Close any pipes we have to the process (both input and output) and wait for it to exit.</p> <p>If cancelled, kills the process and waits for it to finish exiting before propagating the cancellation.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Process.wait"><code><em>await</em> wait()</code></h3> <dd>
<p>Block until the process exits.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Returns</h4> <dd class="field-odd">
<p>The exit status of the process; see <a class="reference internal" href="#trio.Process.returncode" title="trio.Process.returncode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">returncode</span></code></a>.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <h3 id="trio.Process.poll"><code>poll()</code></h3> <dd>
<p>Check if the process has exited yet.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Returns</h4> <dd class="field-odd">
<p>The exit status of the process, or <code class="docutils literal notranslate"><span class="pre">None</span></code> if it is still running; see <a class="reference internal" href="#trio.Process.returncode" title="trio.Process.returncode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">returncode</span></code></a>.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <h3 id="trio.Process.kill"><code>kill()</code></h3> <dd>
<p>Immediately terminate the process.</p> <p>On UNIX, this is equivalent to <code class="docutils literal notranslate"><span class="pre">send_signal(signal.SIGKILL)</span></code>. On Windows, it calls <code class="docutils literal notranslate"><span class="pre">TerminateProcess</span></code>. In both cases, the process cannot prevent itself from being killed, but the termination will be delivered asynchronously; use <a class="reference internal" href="#trio.Process.wait" title="trio.Process.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a> if you want to ensure the process is actually dead before proceeding.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Process.terminate"><code>terminate()</code></h3> <dd>
<p>Terminate the process, politely if possible.</p> <p>On UNIX, this is equivalent to <code class="docutils literal notranslate"><span class="pre">send_signal(signal.SIGTERM)</span></code>; by convention this requests graceful termination, but a misbehaving or buggy process might ignore it. On Windows, <a class="reference internal" href="#trio.Process.terminate" title="trio.Process.terminate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">terminate()</span></code></a> forcibly terminates the process in the same manner as <a class="reference internal" href="#trio.Process.kill" title="trio.Process.kill"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kill()</span></code></a>.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Process.send_signal"><code>send_signal(sig)</code></h3> <dd>
<p>Send signal <code class="docutils literal notranslate"><span class="pre">sig</span></code> to the process.</p> <p>On UNIX, <code class="docutils literal notranslate"><span class="pre">sig</span></code> may be any signal defined in the <a class="reference external" href="https://docs.python.org/3/library/signal.html#module-signal" title="(in Python v3.7)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">signal</span></code></a> module, such as <code class="docutils literal notranslate"><span class="pre">signal.SIGINT</span></code> or <code class="docutils literal notranslate"><span class="pre">signal.SIGTERM</span></code>. On Windows, it may be anything accepted by the standard library <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen.send_signal" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subprocess.Popen.send_signal()</span></code></a>.</p> </dd>
</dl> <blockquote class="admonition note"> <h4 class="admonition-title">Note</h4> <p><a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen.communicate" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">communicate()</span></code></a> is not provided as a method on <a class="reference internal" href="#trio.Process" title="trio.Process"><code class="xref py py-class docutils literal notranslate"><span class="pre">Process</span></code></a> objects; use <a class="reference internal" href="#trio.run_process" title="trio.run_process"><code class="xref py py-func docutils literal notranslate"><span class="pre">run_process()</span></code></a> instead, or write the loop yourself if you have unusual needs. <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen.communicate" title="(in Python v3.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">communicate()</span></code></a> has quite unusual cancellation behavior in the standard library (on some platforms it spawns a background thread which continues to read from the child process even after the timeout has expired) and we wanted to provide an interface with fewer surprises.</p> </blockquote> </dd>
</dl>   <h3>Quoting: more than you wanted to know</h3> <p>The command to run and its arguments usually must be passed to Trio’s subprocess APIs as a sequence of strings, where the first element in the sequence specifies the command to run and the remaining elements specify its arguments, one argument per element. This form is used because it avoids potential quoting pitfalls; for example, you can run <code class="docutils literal notranslate"><span class="pre">["cp",</span> <span class="pre">"-f",</span> <span class="pre">source_file,</span> <span class="pre">dest_file]</span></code> without worrying about whether <code class="docutils literal notranslate"><span class="pre">source_file</span></code> or <code class="docutils literal notranslate"><span class="pre">dest_file</span></code> contains spaces.</p> <p>If you only run subprocesses without <code class="docutils literal notranslate"><span class="pre">shell=True</span></code> and on UNIX, that’s all you need to know about specifying the command. If you use <code class="docutils literal notranslate"><span class="pre">shell=True</span></code> or run on Windows, you probably should read the rest of this section to be aware of potential pitfalls.</p> <p>With <code class="docutils literal notranslate"><span class="pre">shell=True</span></code> on UNIX, you must specify the command as a single string, which will be passed to the shell as if you’d entered it at an interactive prompt. The advantage of this option is that it lets you use shell features like pipes and redirection without writing code to handle them. For example, you can write <code class="docutils literal notranslate"><span class="pre">Process("ls</span> <span class="pre">|</span> <span class="pre">grep</span>
<span class="pre">some_string",</span> <span class="pre">shell=True)</span></code>. The disadvantage is that you must account for the shell’s quoting rules, generally by wrapping in <a class="reference external" href="https://docs.python.org/3/library/shlex.html#shlex.quote" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">shlex.quote()</span></code></a> any argument that might contain spaces, quotes, or other shell metacharacters. If you don’t do that, your safe-looking <code class="docutils literal notranslate"><span class="pre">f"ls</span> <span class="pre">|</span> <span class="pre">grep</span> <span class="pre">{some_string}"</span></code> might end in disaster when invoked with <code class="docutils literal notranslate"><span class="pre">some_string</span> <span class="pre">=</span> <span class="pre">"foo;</span> <span class="pre">rm</span> <span class="pre">-rf</span> <span class="pre">/"</span></code>.</p> <p>On Windows, the fundamental API for process spawning (the <code class="docutils literal notranslate"><span class="pre">CreateProcess()</span></code> system call) takes a string, not a list, and it’s actually up to the child process to decide how it wants to split that string into individual arguments. Since the C language specifies that <code class="docutils literal notranslate"><span class="pre">main()</span></code> should take a list of arguments, <em>most</em> programs you encounter will follow the rules used by the Microsoft C/C++ runtime. <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">subprocess.Popen</span></code></a>, and thus also Trio, uses these rules when it converts an argument sequence to a string, and they are <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#converting-argument-sequence">documented</a> alongside the <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#module-subprocess" title="(in Python v3.7)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">subprocess</span></code></a> module. There is no documented Python standard library function that can directly perform that conversion, so even on Windows, you almost always want to pass an argument sequence rather than a string. But if the program you’re spawning doesn’t split its command line back into individual arguments in the standard way, you might need to pass a string to work around this. (Or you might just be out of luck: as far as I can tell, there’s simply no way to pass an argument containing a double-quote to a Windows batch file.)</p> <p>On Windows with <code class="docutils literal notranslate"><span class="pre">shell=True</span></code>, things get even more chaotic. Now there are two separate sets of quoting rules applied, one by the Windows command shell <code class="docutils literal notranslate"><span class="pre">CMD.EXE</span></code> and one by the process being spawned, and they’re <em>different</em>. (And there’s no <a class="reference external" href="https://docs.python.org/3/library/shlex.html#shlex.quote" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">shlex.quote()</span></code></a> to save you: it uses UNIX-style quoting rules, even on Windows.) Most special characters interpreted by the shell <code class="docutils literal notranslate"><span class="pre">&amp;&lt;&gt;()^|</span></code> are not treated as special if the shell thinks they’re inside double quotes, but <code class="docutils literal notranslate"><span class="pre">%FOO%</span></code> environment variable substitutions still are, and the shell doesn’t provide any way to write a double quote inside a double-quoted string. Outside double quotes, any character (including a double quote) can be escaped using a leading <code class="docutils literal notranslate"><span class="pre">^</span></code>. But since a pipeline is processed by running each command in the pipeline in a subshell, multiple layers of escaping can be needed:</p> <pre data-language="python">echo ^^^&amp;x | find "x" | find "x"          # prints: &amp;x</pre> <p>And if you combine pipelines with () grouping, you can need even more levels of escaping:</p> <pre data-language="python">(echo ^^^^^^^&amp;x | find "x") | find "x"    # prints: &amp;x</pre> <p>Since process creation takes a single arguments string, <code class="docutils literal notranslate"><span class="pre">CMD.EXE</span></code>’s quoting does not influence word splitting, and double quotes are not removed during CMD.EXE’s expansion pass. Double quotes are troublesome because CMD.EXE handles them differently from the MSVC runtime rules; in:</p> <pre data-language="python">prog.exe "foo \"bar\" baz"</pre> <p>the program will see one argument <code class="docutils literal notranslate"><span class="pre">foo</span> <span class="pre">"bar"</span> <span class="pre">baz</span></code> but CMD.EXE thinks <code class="docutils literal notranslate"><span class="pre">bar\</span></code> is not quoted while <code class="docutils literal notranslate"><span class="pre">foo</span> <span class="pre">\</span></code> and <code class="docutils literal notranslate"><span class="pre">baz</span></code> are. All of this makes it a formidable task to reliably interpolate anything into a <code class="docutils literal notranslate"><span class="pre">shell=True</span></code> command line on Windows, and Trio falls back on the <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#module-subprocess" title="(in Python v3.7)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">subprocess</span></code></a> behavior: If you pass a sequence with <code class="docutils literal notranslate"><span class="pre">shell=True</span></code>, it’s quoted in the same way as a sequence with <code class="docutils literal notranslate"><span class="pre">shell=False</span></code>, and had better not contain any shell metacharacters you weren’t planning on.</p> <p>Further reading:</p> <ul class="simple"> <li><p><a class="reference external" href="https://stackoverflow.com/questions/30620876/how-to-properly-escape-filenames-in-windows-cmd-exe">https://stackoverflow.com/questions/30620876/how-to-properly-escape-filenames-in-windows-cmd-exe</a></p></li> <li><p><a class="reference external" href="https://stackoverflow.com/questions/4094699/how-does-the-windows-command-interpreter-cmd-exe-parse-scripts">https://stackoverflow.com/questions/4094699/how-does-the-windows-command-interpreter-cmd-exe-parse-scripts</a></p></li> </ul>    <h2>Signals</h2> <dl class="function"> <h3 id="trio.open_signal_receiver"><code><em>with</em> trio.open_signal_receiver(*signals) as signal_aiter</code></h3> <dd>
<p>A context manager for catching signals.</p> <p>Entering this context manager starts listening for the given signals and returns an async iterator; exiting the context manager stops listening.</p> <p>The async iterator blocks until a signal arrives, and then yields it.</p> <p>Note that if you leave the <code class="docutils literal notranslate"><span class="pre">with</span></code> block while the iterator has unextracted signals still pending inside it, then they will be re-delivered using Python’s regular signal handling logic. This avoids a race condition when signals arrives just before we exit the <code class="docutils literal notranslate"><span class="pre">with</span></code> block.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<p><code>signals</code> – the signals to listen for.</p> </dd> <h4 class="field-even" style="margin: 0">Raises</h4> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.7)"><code>RuntimeError</code></a> – if you try to use this anywhere except Python’s main thread. (This is a Python limitation.)</p> </dd> </dl> <p class="rubric">Example</p> <p>A common convention for Unix daemons is that they should reload their configuration when they receive a <code class="docutils literal notranslate"><span class="pre">SIGHUP</span></code>. Here’s a sketch of what that might look like using <a class="reference internal" href="#trio.open_signal_receiver" title="trio.open_signal_receiver"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_signal_receiver()</span></code></a>:</p> <pre data-language="python">with trio.open_signal_receiver(signal.SIGHUP) as signal_aiter:
    async for signum in signal_aiter:
        assert signum == signal.SIGHUP
        reload_configuration()</pre> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2017 Nathaniel J. Smith<br>Licensed under the MIT License.<br>
    <a href="https://trio.readthedocs.io/en/v0.12.1/reference-io.html" class="_attribution-link">https://trio.readthedocs.io/en/v0.12.1/reference-io.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
