
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Trio’s Core Functionality - Trio - W3cubDocs</title>
  
  <meta name="description" content=" If you want to use Trio, then the first thing you have to do is call trio.run()&#58; ">
  <meta name="keywords" content="trio’s, core, functionality, trio">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/trio/reference-core.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/trio.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/trio/" class="_nav-link" title="" style="margin-left:0;">Trio</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _simple">
				
				
<h1>Trio’s core functionality</h1>  <h2>Entering Trio</h2> <p>If you want to use Trio, then the first thing you have to do is call <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a>:</p> <dl class="function"> <h3 id="trio.run"><code>trio.run(async_fn, *args, clock=None, instruments=(), restrict_keyboard_interrupt_to_checkpoints=False)</code></h3> <dd>
<p>Run a Trio-flavored async function, and return the result.</p> <p>Calling:</p> <pre data-language="python">run(async_fn, *args)</pre> <p>is the equivalent of:</p> <pre data-language="python">await async_fn(*args)</pre> <p>except that <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a> can (and must) be called from a synchronous context.</p> <p>This is Trio’s main entry point. Almost every other function in Trio requires that you be inside a call to <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a>.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<ul class="simple"> <li><p><code>async_fn</code> – An async function.</p></li> <li><p><code>args</code> – Positional arguments to be passed to <em>async_fn</em>. If you need to pass keyword arguments, then use <a class="reference external" href="https://docs.python.org/3/library/functools.html#functools.partial" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a>.</p></li> <li><p><code>clock</code> – <code class="docutils literal notranslate"><span class="pre">None</span></code> to use the default system-specific monotonic clock; otherwise, an object implementing the <a class="reference internal" href="#trio.abc.Clock" title="trio.abc.Clock"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.Clock</span></code></a> interface, like (for example) a <a class="reference internal" href="reference-testing#trio.testing.MockClock" title="trio.testing.MockClock"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.testing.MockClock</span></code></a> instance.</p></li> <li><p><code>instruments</code> (list of <a class="reference internal" href="reference-hazmat#trio.abc.Instrument" title="trio.abc.Instrument"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.Instrument</span></code></a> objects) – Any instrumentation you want to apply to this run. This can also be modified during the run; see <a class="reference internal" href="reference-hazmat#instrumentation"><span class="std std-ref">Instrument API</span></a>.</p></li> <li>
<p><code>restrict_keyboard_interrupt_to_checkpoints</code> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – </p>
<p>What happens if the user hits control-C while <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a> is running? If this argument is False (the default), then you get the standard Python behavior: a <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> exception will immediately interrupt whatever task is running (or if no task is running, then Trio will wake up a task to be interrupted). Alternatively, if you set this argument to True, then <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> delivery will be delayed: it will be <em>only</em> be raised at <a class="reference internal" href="#checkpoints"><span class="std std-ref">checkpoints</span></a>, like a <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> exception.</p> <p>The default behavior is nice because it means that even if you accidentally write an infinite loop that never executes any checkpoints, then you can still break out of it using control-C. The alternative behavior is nice if you’re paranoid about a <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> at just the wrong place leaving your program in an inconsistent state, because it means that you only have to worry about <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> at the exact same places where you already have to worry about <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a>.</p> <p>This setting has no effect if your program has registered a custom SIGINT handler, or if <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a> is called from anywhere but the main thread (this is a Python limitation), or if you use <a class="reference internal" href="reference-io#trio.open_signal_receiver" title="trio.open_signal_receiver"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_signal_receiver()</span></code></a> to catch SIGINT.</p> </li> </ul> </dd> <h4 class="field-even" style="margin: 0">Returns</h4> <dd class="field-even">
<p>Whatever <code class="docutils literal notranslate"><span class="pre">async_fn</span></code> returns.</p> </dd> <h4 class="field-odd" style="margin: 0">Raises</h4> <dd class="field-odd">
<ul class="simple"> <li><p><a class="reference internal" href="#trio.TrioInternalError" title="trio.TrioInternalError"><code>TrioInternalError</code></a> – if an unexpected error is encountered inside Trio’s internal machinery. This is a bug and you should <a class="reference external" href="https://github.com/python-trio/trio/issues">let us know</a>.</p></li> <li><p><code>Anything else</code> – if <code class="docutils literal notranslate"><span class="pre">async_fn</span></code> raises an exception, then <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a> propagates it.</p></li> </ul> </dd> </dl> </dd>
</dl>   <h2>General principles</h2>  <h3>Checkpoints</h3> <p>When writing code using Trio, it’s very important to understand the concept of a <em>checkpoint</em>. Many of Trio’s functions act as checkpoints.</p> <p>A checkpoint is two things:</p> <ol class="arabic simple"> <li><p>It’s a point where Trio checks for cancellation. For example, if the code that called your function set a timeout, and that timeout has expired, then the next time your function executes a checkpoint Trio will raise a <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> exception. See <a class="reference internal" href="#cancellation"><span class="std std-ref">Cancellation and timeouts</span></a> below for more details.</p></li> <li><p>It’s a point where the Trio scheduler checks its scheduling policy to see if it’s a good time to switch to another task, and potentially does so. (Currently, this check is very simple: the scheduler always switches at every checkpoint. But <a class="reference external" href="https://github.com/python-trio/trio/issues/32">this might change in the future</a>.)</p></li> </ol> <p>When writing Trio code, you need to keep track of where your checkpoints are. Why? First, because checkpoints require extra scrutiny: whenever you execute a checkpoint, you need to be prepared to handle a <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> error, or for another task to run and <a class="reference external" href="https://glyph.twistedmatrix.com/2014/02/unyielding.html">rearrange some state out from under you</a>. And second, because you also need to make sure that you have <em>enough</em> checkpoints: if your code doesn’t pass through a checkpoint on a regular basis, then it will be slow to notice and respond to cancellation and – much worse – since Trio is a cooperative multi-tasking system where the <em>only</em> place the scheduler can switch tasks is at checkpoints, it’ll also prevent the scheduler from fairly allocating time between different tasks and adversely effect the response latency of all the other code running in the same process. (Informally we say that a task that does this is “hogging the run loop”.)</p> <p>So when you’re doing code review on a project that uses Trio, one of the things you’ll want to think about is whether there are enough checkpoints, and whether each one is handled correctly. Of course this means you need a way to recognize checkpoints. How do you do that? The underlying principle is that any operation that blocks has to be a checkpoint. This makes sense: if an operation blocks, then it might block for a long time, and you’ll want to be able to cancel it if a timeout expires; and in any case, while this task is blocked we want another task to be scheduled to run so our code can make full use of the CPU.</p> <p>But if we want to write correct code in practice, then this principle is a little too sloppy and imprecise to be useful. How do we know which functions might block? What if a function blocks sometimes, but not others, depending on the arguments passed / network speed / phase of the moon? How do we figure out where the checkpoints are when we’re stressed and sleep deprived but still want to get this code review right, and would prefer to reserve our mental energy for thinking about the actual logic instead of worrying about checkpoints?</p> <p id="checkpoint-rule">Don’t worry – Trio’s got your back. Since checkpoints are important and ubiquitous, we make it as simple as possible to keep track of them. Here are the rules:</p> <ul class="simple"> <li><p>Regular (synchronous) functions never contain any checkpoints.</p></li> <li>
<p>If you call an async function provided by Trio (<code class="docutils literal notranslate"><span class="pre">await</span>
<span class="pre">&lt;something</span> <span class="pre">in</span> <span class="pre">trio&gt;</span></code>), and it doesn’t raise an exception, then it <em>always</em> acts as a checkpoint. (If it does raise an exception, it might act as a checkpoint or might not.)</p> <ul> <li><p>This includes async iterators: If you write <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span> <span class="pre">...</span> <span class="pre">in</span> <span class="pre">&lt;a</span>
<span class="pre">trio</span> <span class="pre">object&gt;</span></code>, then there will be at least one checkpoint before each iteration of the loop and one checkpoint after the last iteration.</p></li> <li><p>Partial exception for async context managers: Both the entry and exit of an <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> block are defined as async functions; but for a particular type of async context manager, it’s often the case that only one of them is able to block, which means only that one will act as a checkpoint. This is documented on a case-by-case basis.</p></li> </ul> </li> <li><p>Third-party async functions / iterators / context managers can act as checkpoints; if you see <code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">&lt;something&gt;</span></code> or one of its friends, then that <em>might</em> be a checkpoint. So to be safe, you should prepare for scheduling or cancellation happening there.</p></li> </ul> <p>The reason we distinguish between Trio functions and other functions is that we can’t make any guarantees about third party code. Checkpoint-ness is a transitive property: if function A acts as a checkpoint, and you write a function that calls function A, then your function also acts as a checkpoint. If you don’t, then it isn’t. So there’s nothing stopping someone from writing a function like:</p> <pre data-language="python"># technically legal, but bad style:
async def why_is_this_async():
    return 7</pre> <p>that never calls any of Trio’s async functions. This is an async function, but it’s not a checkpoint. But why make a function async if it never calls any async functions? It’s possible, but it’s a bad idea. If you have a function that’s not calling any async functions, then you should make it synchronous. The people who use your function will thank you, because it makes it obvious that your function is not a checkpoint, and their code reviews will go faster.</p> <p>(Remember how in the tutorial we emphasized the importance of the <a class="reference internal" href="https://trio.readthedocs.io/en/v0.12.1/tutorial.html#async-sandwich"><span class="std std-ref">“async sandwich”</span></a>, and the way it means that <code class="docutils literal notranslate"><span class="pre">await</span></code> ends up being a marker that shows when you’re calling a function that calls a function that … eventually calls one of Trio’s built-in async functions? The transitivity of async-ness is a technical requirement that Python imposes, but since it exactly matches the transitivity of checkpoint-ness, we’re able to exploit it to help you keep track of checkpoints. Pretty sneaky, eh?)</p> <p>A slightly trickier case is a function like:</p> <pre data-language="python">async def sleep_or_not(should_sleep):
    if should_sleep:
        await trio.sleep(1)
    else:
        pass</pre> <p>Here the function acts as a checkpoint if you call it with <code class="docutils literal notranslate"><span class="pre">should_sleep</span></code> set to a true value, but not otherwise. This is why we emphasize that Trio’s own async functions are <em>unconditional</em> checkpoints: they <em>always</em> check for cancellation and check for scheduling, regardless of what arguments they’re passed. If you find an async function in Trio that doesn’t follow this rule, then it’s a bug and you should <a class="reference external" href="https://github.com/python-trio/trio/issues">let us know</a>.</p> <p>Inside Trio, we’re very picky about this, because Trio is the foundation of the whole system so we think it’s worth the extra effort to make things extra predictable. It’s up to you how picky you want to be in your code. To give you a more realistic example of what this kind of issue looks like in real life, consider this function:</p> <pre data-language="python">async def recv_exactly(sock, nbytes):
    data = bytearray()
    while nbytes &gt; 0:
        # recv() reads up to 'nbytes' bytes each time
        chunk = await sock.recv(nbytes)
        if not chunk:
            raise RuntimeError("socket unexpected closed")
        nbytes -= len(chunk)
        data += chunk
    return data</pre> <p>If called with an <code class="docutils literal notranslate"><span class="pre">nbytes</span></code> that’s greater than zero, then it will call <code class="docutils literal notranslate"><span class="pre">sock.recv</span></code> at least once, and <code class="docutils literal notranslate"><span class="pre">recv</span></code> is an async Trio function, and thus an unconditional checkpoint. So in this case, <code class="docutils literal notranslate"><span class="pre">recv_exactly</span></code> acts as a checkpoint. But if we do <code class="docutils literal notranslate"><span class="pre">await</span>
<span class="pre">recv_exactly(sock,</span> <span class="pre">0)</span></code>, then it will immediately return an empty buffer without executing a checkpoint. If this were a function in Trio itself, then this wouldn’t be acceptable, but you may decide you don’t want to worry about this kind of minor edge case in your own code.</p> <p>If you do want to be careful, or if you have some CPU-bound code that doesn’t have enough checkpoints in it, then it’s useful to know that <code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">trio.sleep(0)</span></code> is an idiomatic way to execute a checkpoint without doing anything else, and that <a class="reference internal" href="reference-testing#trio.testing.assert_checkpoints" title="trio.testing.assert_checkpoints"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.testing.assert_checkpoints()</span></code></a> can be used to test that an arbitrary block of code contains a checkpoint.</p>   <h3>Thread safety</h3> <p>The vast majority of Trio’s API is <em>not</em> thread safe: it can only be used from inside a call to <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a>. This manual doesn’t bother documenting this on individual calls; unless specifically noted otherwise, you should assume that it isn’t safe to call any Trio functions from anywhere except the Trio thread. (But <a class="reference internal" href="#threads"><span class="std std-ref">see below</span></a> if you really do need to work with threads.)</p>    <h2>Time and clocks</h2> <p>Every call to <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a> has an associated clock.</p> <p>By default, Trio uses an unspecified monotonic clock, but this can be changed by passing a custom clock object to <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a> (e.g. for testing).</p> <p>You should not assume that Trio’s internal clock matches any other clock you have access to, including the clocks of simultaneous calls to <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> happening in other processes or threads!</p> <p>The default clock is currently implemented as <a class="reference external" href="https://docs.python.org/3/library/time.html#time.perf_counter" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.perf_counter()</span></code></a> plus a large random offset. The idea here is to catch code that accidentally uses <a class="reference external" href="https://docs.python.org/3/library/time.html#time.perf_counter" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.perf_counter()</span></code></a> early, which should help keep our options open for <a class="reference external" href="https://github.com/python-trio/trio/issues/33">changing the clock implementation later</a>, and (more importantly) make sure you can be confident that custom clocks like <a class="reference internal" href="reference-testing#trio.testing.MockClock" title="trio.testing.MockClock"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.testing.MockClock</span></code></a> will work with third-party libraries you don’t control.</p> <dl class="function"> <h3 id="trio.current_time"><code>trio.current_time()</code></h3> <dd>
<p>Returns the current time according to Trio’s internal clock.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Returns</h4> <dd class="field-odd">
<p>The current time.</p> </dd> <h4 class="field-even" style="margin: 0">Return type</h4> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)">float</a></p> </dd> <h4 class="field-odd" style="margin: 0">Raises</h4> <dd class="field-odd">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.7)"><code>RuntimeError</code></a> – if not inside a call to <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a>.</p> </dd> </dl> </dd>
</dl> <dl class="function"> <h3 id="trio.sleep"><code><em>await</em> trio.sleep(seconds)</code></h3> <dd>
<p>Pause execution of the current task for the given number of seconds.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<p><code>seconds</code> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – The number of seconds to sleep. May be zero to insert a checkpoint without actually blocking.</p> </dd> <h4 class="field-even" style="margin: 0">Raises</h4> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><code>ValueError</code></a> – if <em>seconds</em> is negative.</p> </dd> </dl> </dd>
</dl> <dl class="function"> <h3 id="trio.sleep_until"><code><em>await</em> trio.sleep_until(deadline)</code></h3> <dd>
<p>Pause execution of the current task until the given time.</p> <p>The difference between <a class="reference internal" href="#trio.sleep" title="trio.sleep"><code class="xref py py-func docutils literal notranslate"><span class="pre">sleep()</span></code></a> and <a class="reference internal" href="#trio.sleep_until" title="trio.sleep_until"><code class="xref py py-func docutils literal notranslate"><span class="pre">sleep_until()</span></code></a> is that the former takes a relative time and the latter takes an absolute time.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<p><code>deadline</code> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – The time at which we should wake up again. May be in the past, in which case this function executes a checkpoint but does not block.</p> </dd> </dl> </dd>
</dl> <dl class="function"> <h3 id="trio.sleep_forever"><code><em>await</em> trio.sleep_forever()</code></h3> <dd>
<p>Pause execution of the current task forever (or until cancelled).</p> <p>Equivalent to calling <code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">sleep(math.inf)</span></code>.</p> </dd>
</dl> <p>If you’re a mad scientist or otherwise feel the need to take direct control over the PASSAGE OF TIME ITSELF, then you can implement a custom <a class="reference internal" href="#trio.abc.Clock" title="trio.abc.Clock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Clock</span></code></a> class:</p> <dl class="class"> <h3 id="trio.abc.Clock"><code><em>class</em> trio.abc.Clock</code></h3> <dd>
<p>The interface for custom run loop clocks.</p> <dl class="method"> <h3 id="trio.abc.Clock.current_time"><code><em>abstractmethod</em> current_time()</code></h3> <dd>
<p>Return the current time, according to this clock.</p> <p>This is used to implement functions like <a class="reference internal" href="#trio.current_time" title="trio.current_time"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.current_time()</span></code></a> and <a class="reference internal" href="#trio.move_on_after" title="trio.move_on_after"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.move_on_after()</span></code></a>.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Returns</h4> <dd class="field-odd">
<p>The current time.</p> </dd> <h4 class="field-even" style="margin: 0">Return type</h4> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)">float</a></p> </dd> </dl> </dd>
</dl> <dl class="method"> <h3 id="trio.abc.Clock.deadline_to_sleep_time"><code><em>abstractmethod</em> deadline_to_sleep_time(deadline)</code></h3> <dd>
<p>Compute the real time until the given deadline.</p> <p>This is called before we enter a system-specific wait function like <a class="reference external" href="https://docs.python.org/3/library/select.html#select.select" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">select.select()</span></code></a>, to get the timeout to pass.</p> <p>For a clock using wall-time, this should be something like:</p> <pre data-language="python">return deadline - self.current_time()</pre> <p>but of course it may be different if you’re implementing some kind of virtual clock.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<p><code>deadline</code> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – The absolute time of the next deadline, according to this clock.</p> </dd> <h4 class="field-even" style="margin: 0">Returns</h4> <dd class="field-even">
<p>The number of real seconds to sleep until the given deadline. May be <a class="reference external" href="https://docs.python.org/3/library/math.html#math.inf" title="(in Python v3.7)"><code class="xref py py-data docutils literal notranslate"><span class="pre">math.inf</span></code></a>.</p> </dd> <h4 class="field-odd" style="margin: 0">Return type</h4> <dd class="field-odd">
<p><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)">float</a></p> </dd> </dl> </dd>
</dl> <dl class="method"> <h3 id="trio.abc.Clock.start_clock"><code><em>abstractmethod</em> start_clock()</code></h3> <dd>
<p>Do any setup this clock might need.</p> <p>Called at the beginning of the run.</p> </dd>
</dl> </dd>
</dl>   <h2>Cancellation and timeouts</h2> <p>Trio has a rich, composable system for cancelling work, either explicitly or when a timeout expires.</p>  <h3>A simple timeout example</h3> <p>In the simplest case, you can apply a timeout to a block of code:</p> <pre data-language="python">with trio.move_on_after(30):
    result = await do_http_get("https://...")
    print("result is", result)
print("with block finished")</pre> <p>We refer to <a class="reference internal" href="#trio.move_on_after" title="trio.move_on_after"><code class="xref py py-func docutils literal notranslate"><span class="pre">move_on_after()</span></code></a> as creating a “cancel scope”, which contains all the code that runs inside the <code class="docutils literal notranslate"><span class="pre">with</span></code> block. If the HTTP request takes more than 30 seconds to run, then it will be cancelled: we’ll abort the request and we <em>won’t</em> see <code class="docutils literal notranslate"><span class="pre">result</span> <span class="pre">is</span> <span class="pre">...</span></code> printed on the console; instead we’ll go straight to printing the <code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">block</span>
<span class="pre">finished</span></code> message.</p> <blockquote class="admonition note"> <h4 class="admonition-title">Note</h4> <p>Note that this is a single 30 second timeout for the entire body of the <code class="docutils literal notranslate"><span class="pre">with</span></code> statement. This is different from what you might have seen with other Python libraries, where timeouts often refer to something <a class="reference external" href="http://docs.python-requests.org/en/master/user/quickstart/#timeouts">more complicated</a>. We think this way is easier to reason about.</p> </blockquote> <p>How does this work? There’s no magic here: Trio is built using ordinary Python functionality, so we can’t just abandon the code inside the <code class="docutils literal notranslate"><span class="pre">with</span></code> block. Instead, we take advantage of Python’s standard way of aborting a large and complex piece of code: we raise an exception.</p> <p>Here’s the idea: whenever you call a cancellable function like <code class="docutils literal notranslate"><span class="pre">await</span>
<span class="pre">trio.sleep(...)</span></code> or <code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">sock.recv(...)</span></code> – see <a class="reference internal" href="#checkpoints"><span class="std std-ref">Checkpoints</span></a> – then the first thing that function does is to check if there’s a surrounding cancel scope whose timeout has expired, or otherwise been cancelled. If so, then instead of performing the requested operation, the function fails immediately with a <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> exception. In this example, this probably happens somewhere deep inside the bowels of <code class="docutils literal notranslate"><span class="pre">do_http_get</span></code>. The exception then propagates out like any normal exception (you could even catch it if you wanted, but that’s generally a bad idea), until it reaches the <code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">move_on_after(...):</span></code>. And at this point, the <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> exception has done its job – it’s successfully unwound the whole cancelled scope – so <a class="reference internal" href="#trio.move_on_after" title="trio.move_on_after"><code class="xref py py-func docutils literal notranslate"><span class="pre">move_on_after()</span></code></a> catches it, and execution continues as normal after the <code class="docutils literal notranslate"><span class="pre">with</span></code> block. And this all works correctly even if you have nested cancel scopes, because every <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> object carries an invisible marker that makes sure that the cancel scope that triggered it is the only one that will catch it.</p>   <h3>Handling cancellation</h3> <p>Pretty much any code you write using Trio needs to have some strategy to handle <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> exceptions – even if you didn’t set a timeout, then your caller might (and probably will).</p> <p>You can catch <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a>, but you shouldn’t! Or more precisely, if you do catch it, then you should do some cleanup and then re-raise it or otherwise let it continue propagating (unless you encounter an error, in which case it’s OK to let that propagate instead). To help remind you of this fact, <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> inherits from <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#BaseException" title="(in Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BaseException</span></code></a>, like <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> and <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#SystemExit" title="(in Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SystemExit</span></code></a> do, so that it won’t be caught by catch-all <code class="docutils literal notranslate"><span class="pre">except</span>
<span class="pre">Exception:</span></code> blocks.</p> <p>It’s also important in any long-running code to make sure that you regularly check for cancellation, because otherwise timeouts won’t work! This happens implicitly every time you call a cancellable operation; see <a class="reference internal" href="#cancellable-primitives"><span class="std std-ref">below</span></a> for details. If you have a task that has to do a lot of work without any I/O, then you can use <code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">sleep(0)</span></code> to insert an explicit cancel+schedule point.</p> <p>Here’s a rule of thumb for designing good Trio-style (“trionic”?) APIs: if you’re writing a reusable function, then you shouldn’t take a <code class="docutils literal notranslate"><span class="pre">timeout=</span></code> parameter, and instead let your caller worry about it. This has several advantages. First, it leaves the caller’s options open for deciding how they prefer to handle timeouts – for example, they might find it easier to work with absolute deadlines instead of relative timeouts. If they’re the ones calling into the cancellation machinery, then they get to pick, and you don’t have to worry about it. Second, and more importantly, this makes it easier for others to re-use your code. If you write a <code class="docutils literal notranslate"><span class="pre">http_get</span></code> function, and then I come along later and write a <code class="docutils literal notranslate"><span class="pre">log_in_to_twitter</span></code> function that needs to internally make several <code class="docutils literal notranslate"><span class="pre">http_get</span></code> calls, I don’t want to have to figure out how to configure the individual timeouts on each of those calls – and with Trio’s timeout system, it’s totally unnecessary.</p> <p>Of course, this rule doesn’t apply to APIs that need to impose internal timeouts. For example, if you write a <code class="docutils literal notranslate"><span class="pre">start_http_server</span></code> function, then you probably should give your caller some way to configure timeouts on individual requests.</p>   <h3>Cancellation semantics</h3> <p>You can freely nest cancellation blocks, and each <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> exception “knows” which block it belongs to. So long as you don’t stop it, the exception will keep propagating until it reaches the block that raised it, at which point it will stop automatically.</p> <p>Here’s an example:</p> <pre data-language="python">print("starting...")
with trio.move_on_after(5):
    with trio.move_on_after(10):
        await sleep(20)
        print("sleep finished without error")
    print("move_on_after(10) finished without error")
print("move_on_after(5) finished without error")</pre> <p>In this code, the outer scope will expire after 5 seconds, causing the <a class="reference internal" href="#trio.sleep" title="trio.sleep"><code class="xref py py-func docutils literal notranslate"><span class="pre">sleep()</span></code></a> call to return early with a <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> exception. Then this exception will propagate through the <code class="docutils literal notranslate"><span class="pre">with</span>
<span class="pre">move_on_after(10)</span></code> line until it’s caught by the <code class="docutils literal notranslate"><span class="pre">with</span>
<span class="pre">move_on_after(5)</span></code> context manager. So this code will print:</p> <pre>starting...
move_on_after(5) finished without error</pre> <p>The end result is that Trio has successfully cancelled exactly the work that was happening within the scope that was cancelled.</p> <p>Looking at this, you might wonder how you can tell whether the inner block timed out – perhaps you want to do something different, like try a fallback procedure or report a failure to our caller. To make this easier, <a class="reference internal" href="#trio.move_on_after" title="trio.move_on_after"><code class="xref py py-func docutils literal notranslate"><span class="pre">move_on_after()</span></code></a>´s <code class="docutils literal notranslate"><span class="pre">__enter__</span></code> function returns an object representing this cancel scope, which we can use to check whether this scope caught a <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> exception:</p> <pre data-language="python">with trio.move_on_after(5) as cancel_scope:
    await sleep(10)
print(cancel_scope.cancelled_caught)  # prints "True"</pre> <p>The <code class="docutils literal notranslate"><span class="pre">cancel_scope</span></code> object also allows you to check or adjust this scope’s deadline, explicitly trigger a cancellation without waiting for the deadline, check if the scope has already been cancelled, and so forth – see <a class="reference internal" href="#trio.CancelScope" title="trio.CancelScope"><code class="xref py py-class docutils literal notranslate"><span class="pre">CancelScope</span></code></a> below for the full details.</p> <p id="blocking-cleanup-example">Cancellations in Trio are “level triggered”, meaning that once a block has been cancelled, <em>all</em> cancellable operations in that block will keep raising <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a>. This helps avoid some pitfalls around resource clean-up. For example, imagine that we have a function that connects to a remote server and sends some messages, and then cleans up on the way out:</p> <pre data-language="python">with trio.move_on_after(TIMEOUT):
    conn = make_connection()
    try:
        await conn.send_hello_msg()
    finally:
        await conn.send_goodbye_msg()</pre> <p>Now suppose that the remote server stops responding, so our call to <code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">conn.send_hello_msg()</span></code> hangs forever. Fortunately, we were clever enough to put a timeout around this code, so eventually the timeout will expire and <code class="docutils literal notranslate"><span class="pre">send_hello_msg</span></code> will raise <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a>. But then, in the <code class="docutils literal notranslate"><span class="pre">finally</span></code> block, we make another blocking operation, which will also hang forever! At this point, if we were using <a class="reference external" href="https://docs.python.org/3/library/asyncio.html#module-asyncio" title="(in Python v3.7)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code></a> or another library with “edge-triggered” cancellation, we’d be in trouble: since our timeout already fired, it wouldn’t fire again, and at this point our application would lock up forever. But in Trio, this <em>doesn’t</em> happen: the <code class="docutils literal notranslate"><span class="pre">await</span>
<span class="pre">conn.send_goodbye_msg()</span></code> call is still inside the cancelled block, so it will also raise <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a>.</p> <p>Of course, if you really want to make another blocking call in your cleanup handler, Trio will let you; it’s trying to prevent you from accidentally shooting yourself in the foot. Intentional foot-shooting is no problem (or at least – it’s not Trio’s problem). To do this, create a new scope, and set its <a class="reference internal" href="#trio.CancelScope.shield" title="trio.CancelScope.shield"><code class="xref py py-attr docutils literal notranslate"><span class="pre">shield</span></code></a> attribute to <a class="reference external" href="https://docs.python.org/3/library/constants.html#True" title="(in Python v3.7)"><code class="xref py py-data docutils literal notranslate"><span class="pre">True</span></code></a>:</p> <pre data-language="python">with trio.move_on_after(TIMEOUT):
    conn = make_connection()
    try:
        await conn.send_hello_msg()
    finally:
        with trio.move_on_after(CLEANUP_TIMEOUT) as cleanup_scope:
            cleanup_scope.shield = True
            await conn.send_goodbye_msg()</pre> <p>So long as you’re inside a scope with <code class="docutils literal notranslate"><span class="pre">shield</span> <span class="pre">=</span> <span class="pre">True</span></code> set, then you’ll be protected from outside cancellations. Note though that this <em>only</em> applies to <em>outside</em> cancellations: if <code class="docutils literal notranslate"><span class="pre">CLEANUP_TIMEOUT</span></code> expires then <code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">conn.send_goodbye_msg()</span></code> will still be cancelled, and if <code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">conn.send_goodbye_msg()</span></code> call uses any timeouts internally, then those will continue to work normally as well. This is a pretty advanced feature that most people probably won’t use, but it’s there for the rare cases where you need it.</p>   <h3>Cancellation and primitive operations</h3> <p>We’ve talked a lot about what happens when an operation is cancelled, and how you need to be prepared for this whenever calling a cancellable operation… but we haven’t gone into the details about which operations are cancellable, and how exactly they behave when they’re cancelled.</p> <p>Here’s the rule: if it’s in the <code class="docutils literal notranslate"><span class="pre">trio</span></code> namespace, and you use <code class="docutils literal notranslate"><span class="pre">await</span></code> to call it, then it’s cancellable (see <a class="reference internal" href="#checkpoints"><span class="std std-ref">Checkpoints</span></a> above). Cancellable means:</p> <ul class="simple"> <li><p>If you try to call it when inside a cancelled scope, then it will raise <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a>.</p></li> <li><p>If it blocks, and while it’s blocked then one of the scopes around it becomes cancelled, it will return early and raise <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a>.</p></li> <li><p>Raising <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> means that the operation <em>did not happen</em>. If a Trio socket’s <code class="docutils literal notranslate"><span class="pre">send</span></code> method raises <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a>, then no data was sent. If a Trio socket’s <code class="docutils literal notranslate"><span class="pre">recv</span></code> method raises <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> then no data was lost – it’s still sitting in the socket receive buffer waiting for you to call <code class="docutils literal notranslate"><span class="pre">recv</span></code> again. And so forth.</p></li> </ul> <p>There are a few idiosyncratic cases where external constraints make it impossible to fully implement these semantics. These are always documented. There is also one systematic exception:</p> <ul class="simple"> <li><p>Async cleanup operations – like <code class="docutils literal notranslate"><span class="pre">__aexit__</span></code> methods or async close methods – are cancellable just like anything else <em>except</em> that if they are cancelled, they still perform a minimum level of cleanup before raising <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a>.</p></li> </ul> <p>For example, closing a TLS-wrapped socket normally involves sending a notification to the remote peer, so that they can be cryptographically assured that you really meant to close the socket, and your connection wasn’t just broken by a man-in-the-middle attacker. But handling this robustly is a bit tricky. Remember our <a class="reference internal" href="#blocking-cleanup-example"><span class="std std-ref">example</span></a> above where the blocking <code class="docutils literal notranslate"><span class="pre">send_goodbye_msg</span></code> caused problems? That’s exactly how closing a TLS socket works: if the remote peer has disappeared, then our code may never be able to actually send our shutdown notification, and it would be nice if it didn’t block forever trying. Therefore, the method for closing a TLS-wrapped socket will <em>try</em> to send that notification – and if it gets cancelled, then it will give up on sending the message, but <em>will</em> still close the underlying socket before raising <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a>, so at least you don’t leak that resource.</p>   <h3>Cancellation API details</h3> <p><a class="reference internal" href="#trio.move_on_after" title="trio.move_on_after"><code class="xref py py-func docutils literal notranslate"><span class="pre">move_on_after()</span></code></a> and all the other cancellation facilities provided by Trio are ultimately implemented in terms of <a class="reference internal" href="#trio.CancelScope" title="trio.CancelScope"><code class="xref py py-class docutils literal notranslate"><span class="pre">CancelScope</span></code></a> objects.</p> <dl class="class"> <h3 id="trio.CancelScope"><code><em>class</em> trio.CancelScope(*, deadline=inf, shield=False)</code></h3> <dd>
<p>A <em>cancellation scope</em>: the link between a unit of cancellable work and Trio’s cancellation system.</p> <p>A <a class="reference internal" href="#trio.CancelScope" title="trio.CancelScope"><code class="xref py py-class docutils literal notranslate"><span class="pre">CancelScope</span></code></a> becomes associated with some cancellable work when it is used as a context manager surrounding that work:</p> <pre data-language="python">cancel_scope = trio.CancelScope()
...
with cancel_scope:
    await long_running_operation()</pre> <p>Inside the <code class="docutils literal notranslate"><span class="pre">with</span></code> block, a cancellation of <code class="docutils literal notranslate"><span class="pre">cancel_scope</span></code> (via a call to its <a class="reference internal" href="#trio.CancelScope.cancel" title="trio.CancelScope.cancel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cancel()</span></code></a> method or via the expiry of its <a class="reference internal" href="#trio.CancelScope.deadline" title="trio.CancelScope.deadline"><code class="xref py py-attr docutils literal notranslate"><span class="pre">deadline</span></code></a>) will immediately interrupt the <code class="docutils literal notranslate"><span class="pre">long_running_operation()</span></code> by raising <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> at its next <a class="reference internal" href="#checkpoints"><span class="std std-ref">checkpoint</span></a>.</p> <p>The context manager <code class="docutils literal notranslate"><span class="pre">__enter__</span></code> returns the <a class="reference internal" href="#trio.CancelScope" title="trio.CancelScope"><code class="xref py py-class docutils literal notranslate"><span class="pre">CancelScope</span></code></a> object itself, so you can also write <code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">trio.CancelScope()</span> <span class="pre">as</span>
<span class="pre">cancel_scope:</span></code>.</p> <p>If a cancel scope becomes cancelled before entering its <code class="docutils literal notranslate"><span class="pre">with</span></code> block, the <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> exception will be raised at the first checkpoint inside the <code class="docutils literal notranslate"><span class="pre">with</span></code> block. This allows a <a class="reference internal" href="#trio.CancelScope" title="trio.CancelScope"><code class="xref py py-class docutils literal notranslate"><span class="pre">CancelScope</span></code></a> to be created in one <a class="reference internal" href="#tasks"><span class="std std-ref">task</span></a> and passed to another, so that the first task can later cancel some work inside the second.</p> <p>Cancel scopes are not reusable or reentrant; that is, each cancel scope can be used for at most one <code class="docutils literal notranslate"><span class="pre">with</span></code> block. (You’ll get a <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> if you violate this rule.)</p> <p>The <a class="reference internal" href="#trio.CancelScope" title="trio.CancelScope"><code class="xref py py-class docutils literal notranslate"><span class="pre">CancelScope</span></code></a> constructor takes initial values for the cancel scope’s <a class="reference internal" href="#trio.CancelScope.deadline" title="trio.CancelScope.deadline"><code class="xref py py-attr docutils literal notranslate"><span class="pre">deadline</span></code></a> and <a class="reference internal" href="#trio.CancelScope.shield" title="trio.CancelScope.shield"><code class="xref py py-attr docutils literal notranslate"><span class="pre">shield</span></code></a> attributes; these may be freely modified after construction, whether or not the scope has been entered yet, and changes take immediate effect.</p> <dl class="attribute"> <h3 id="trio.CancelScope.deadline"><code>deadline</code></h3> <dd>
<p>Read-write, <a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>. An absolute time on the current run’s clock at which this scope will automatically become cancelled. You can adjust the deadline by modifying this attribute, e.g.:</p> <pre data-language="python"># I need a little more time!
cancel_scope.deadline += 30</pre> <p>Note that for efficiency, the core run loop only checks for expired deadlines every once in a while. This means that in certain cases there may be a short delay between when the clock says the deadline should have expired, and when checkpoints start raising <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a>. This is a very obscure corner case that you’re unlikely to notice, but we document it for completeness. (If this <em>does</em> cause problems for you, of course, then <a class="reference external" href="https://github.com/python-trio/trio/issues">we want to know!</a>)</p> <p>Defaults to <a class="reference external" href="https://docs.python.org/3/library/math.html#math.inf" title="(in Python v3.7)"><code class="xref py py-data docutils literal notranslate"><span class="pre">math.inf</span></code></a>, which means “no deadline”, though this can be overridden by the <code class="docutils literal notranslate"><span class="pre">deadline=</span></code> argument to the <a class="reference internal" href="#trio.CancelScope" title="trio.CancelScope"><code class="xref py py-class docutils literal notranslate"><span class="pre">CancelScope</span></code></a> constructor.</p> </dd>
</dl> <dl class="attribute"> <h3 id="trio.CancelScope.shield"><code>shield</code></h3> <dd>
<p>Read-write, <a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a>, default <a class="reference external" href="https://docs.python.org/3/library/constants.html#False" title="(in Python v3.7)"><code class="xref py py-data docutils literal notranslate"><span class="pre">False</span></code></a>. So long as this is set to <a class="reference external" href="https://docs.python.org/3/library/constants.html#True" title="(in Python v3.7)"><code class="xref py py-data docutils literal notranslate"><span class="pre">True</span></code></a>, then the code inside this scope will not receive <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> exceptions from scopes that are outside this scope. They can still receive <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> exceptions from (1) this scope, or (2) scopes inside this scope. You can modify this attribute:</p> <pre data-language="python">with trio.CancelScope() as cancel_scope:
    cancel_scope.shield = True
    # This cannot be interrupted by any means short of
    # killing the process:
    await sleep(10)

    cancel_scope.shield = False
    # Now this can be cancelled normally:
    await sleep(10)</pre> <p>Defaults to <a class="reference external" href="https://docs.python.org/3/library/constants.html#False" title="(in Python v3.7)"><code class="xref py py-data docutils literal notranslate"><span class="pre">False</span></code></a>, though this can be overridden by the <code class="docutils literal notranslate"><span class="pre">shield=</span></code> argument to the <a class="reference internal" href="#trio.CancelScope" title="trio.CancelScope"><code class="xref py py-class docutils literal notranslate"><span class="pre">CancelScope</span></code></a> constructor.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.CancelScope.cancel"><code>cancel()</code></h3> <dd>
<p>Cancels this scope immediately.</p> <p>This method is idempotent, i.e., if the scope was already cancelled then this method silently does nothing.</p> </dd>
</dl> <dl class="attribute"> <h3 id="trio.CancelScope.cancelled_caught"><code>cancelled_caught</code></h3> <dd>
<p>Readonly <a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a>. Records whether this scope caught a <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> exception. This requires two things: (1) the <code class="docutils literal notranslate"><span class="pre">with</span></code> block exited with a <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> exception, and (2) this scope is the one that was responsible for triggering this <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> exception.</p> </dd>
</dl> <dl class="attribute"> <h3 id="trio.CancelScope.cancel_called"><code>cancel_called</code></h3> <dd>
<p>Readonly <a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a>. Records whether cancellation has been requested for this scope, either by an explicit call to <a class="reference internal" href="#trio.CancelScope.cancel" title="trio.CancelScope.cancel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cancel()</span></code></a> or by the deadline expiring.</p> <p>This attribute being True does <em>not</em> necessarily mean that the code within the scope has been, or will be, affected by the cancellation. For example, if <a class="reference internal" href="#trio.CancelScope.cancel" title="trio.CancelScope.cancel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cancel()</span></code></a> was called after the last checkpoint in the <code class="docutils literal notranslate"><span class="pre">with</span></code> block, when it’s too late to deliver a <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> exception, then this attribute will still be True.</p> <p>This attribute is mostly useful for debugging and introspection. If you want to know whether or not a chunk of code was actually cancelled, then <a class="reference internal" href="#trio.CancelScope.cancelled_caught" title="trio.CancelScope.cancelled_caught"><code class="xref py py-attr docutils literal notranslate"><span class="pre">cancelled_caught</span></code></a> is usually more appropriate.</p> </dd>
</dl> </dd>
</dl> <p>Trio also provides several convenience functions for the common situation of just wanting to impose a timeout on some code:</p> <dl class="function"> <h3 id="trio.move_on_after"><code><em>with</em> trio.move_on_after(seconds) as cancel_scope</code></h3> <dd>
<p>Use as a context manager to create a cancel scope whose deadline is set to now + <em>seconds</em>.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<p><code>seconds</code> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – The timeout.</p> </dd> <h4 class="field-even" style="margin: 0">Raises</h4> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><code>ValueError</code></a> – if timeout is less than zero.</p> </dd> </dl> </dd>
</dl> <dl class="function"> <h3 id="trio.move_on_at"><code><em>with</em> trio.move_on_at(deadline) as cancel_scope</code></h3> <dd>
<p>Use as a context manager to create a cancel scope with the given absolute deadline.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<p><code>deadline</code> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – The deadline.</p> </dd> </dl> </dd>
</dl> <dl class="function"> <h3 id="trio.fail_after"><code><em>with</em> trio.fail_after(seconds) as cancel_scope</code></h3> <dd>
<p>Creates a cancel scope with the given timeout, and raises an error if it is actually cancelled.</p> <p>This function and <a class="reference internal" href="#trio.move_on_after" title="trio.move_on_after"><code class="xref py py-func docutils literal notranslate"><span class="pre">move_on_after()</span></code></a> are similar in that both create a cancel scope with a given timeout, and if the timeout expires then both will cause <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> to be raised within the scope. The difference is that when the <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> exception reaches <a class="reference internal" href="#trio.move_on_after" title="trio.move_on_after"><code class="xref py py-func docutils literal notranslate"><span class="pre">move_on_after()</span></code></a>, it’s caught and discarded. When it reaches <a class="reference internal" href="#trio.fail_after" title="trio.fail_after"><code class="xref py py-func docutils literal notranslate"><span class="pre">fail_after()</span></code></a>, then it’s caught and <a class="reference internal" href="#trio.TooSlowError" title="trio.TooSlowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TooSlowError</span></code></a> is raised in its place.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Raises</h4> <dd class="field-odd">
<ul class="simple"> <li><p><a class="reference internal" href="#trio.TooSlowError" title="trio.TooSlowError"><code>TooSlowError</code></a> – if a <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> exception is raised in this scope and caught by the context manager.</p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><code>ValueError</code></a> – if <em>seconds</em> is less than zero.</p></li> </ul> </dd> </dl> </dd>
</dl> <dl class="function"> <h3 id="trio.fail_at"><code><em>with</em> trio.fail_at(deadline) as cancel_scope</code></h3> <dd>
<p>Creates a cancel scope with the given deadline, and raises an error if it is actually cancelled.</p> <p>This function and <a class="reference internal" href="#trio.move_on_at" title="trio.move_on_at"><code class="xref py py-func docutils literal notranslate"><span class="pre">move_on_at()</span></code></a> are similar in that both create a cancel scope with a given absolute deadline, and if the deadline expires then both will cause <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> to be raised within the scope. The difference is that when the <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> exception reaches <a class="reference internal" href="#trio.move_on_at" title="trio.move_on_at"><code class="xref py py-func docutils literal notranslate"><span class="pre">move_on_at()</span></code></a>, it’s caught and discarded. When it reaches <a class="reference internal" href="#trio.fail_at" title="trio.fail_at"><code class="xref py py-func docutils literal notranslate"><span class="pre">fail_at()</span></code></a>, then it’s caught and <a class="reference internal" href="#trio.TooSlowError" title="trio.TooSlowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TooSlowError</span></code></a> is raised in its place.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Raises</h4> <dd class="field-odd">
<p><a class="reference internal" href="#trio.TooSlowError" title="trio.TooSlowError"><code>TooSlowError</code></a> – if a <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> exception is raised in this scope and caught by the context manager.</p> </dd> </dl> </dd>
</dl> <p>Cheat sheet:</p> <ul> <li>
<p>If you want to impose a timeout on a function, but you don’t care whether it timed out or not:</p> <pre data-language="python">with trio.move_on_after(TIMEOUT):
    await do_whatever()
# carry on!</pre> </li> <li>
<p>If you want to impose a timeout on a function, and then do some recovery if it timed out:</p> <pre data-language="python">with trio.move_on_after(TIMEOUT) as cancel_scope:
    await do_whatever()
if cancel_scope.cancelled_caught:
    # The operation timed out, try something else
    try_to_recover()</pre> </li> <li>
<p>If you want to impose a timeout on a function, and then if it times out then just give up and raise an error for your caller to deal with:</p> <pre data-language="python">with trio.fail_after(TIMEOUT):
    await do_whatever()</pre> </li> </ul> <p>It’s also possible to check what the current effective deadline is, which is sometimes useful:</p> <dl class="function"> <h3 id="trio.current_effective_deadline"><code>trio.current_effective_deadline()</code></h3> <dd>
<p>Returns the current effective deadline for the current task.</p> <p>This function examines all the cancellation scopes that are currently in effect (taking into account shielding), and returns the deadline that will expire first.</p> <p>One example of where this might be is useful is if your code is trying to decide whether to begin an expensive operation like an RPC call, but wants to skip it if it knows that it can’t possibly complete in the available time. Another example would be if you’re using a protocol like gRPC that <a class="reference external" href="http://www.grpc.io/docs/guides/concepts.html#deadlines">propagates timeout information to the remote peer</a>; this function gives a way to fetch that information so you can send it along.</p> <p>If this is called in a context where a cancellation is currently active (i.e., a blocking call will immediately raise <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a>), then returned deadline is <code class="docutils literal notranslate"><span class="pre">-inf</span></code>. If it is called in a context where no scopes have a deadline set, it returns <code class="docutils literal notranslate"><span class="pre">inf</span></code>.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Returns</h4> <dd class="field-odd">
<p>the effective deadline, as an absolute time.</p> </dd> <h4 class="field-even" style="margin: 0">Return type</h4> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)">float</a></p> </dd> </dl> </dd>
</dl>    <h2>Tasks let you do multiple things at once</h2> <p>One of Trio’s core design principles is: <em>no implicit concurrency</em>. Every function executes in a straightforward, top-to-bottom manner, finishing each operation before moving on to the next – <em>like Guido intended</em>.</p> <p>But, of course, the entire point of an async library is to let you do multiple things at once. The one and only way to do that in Trio is through the task spawning interface. So if you want your program to walk <em>and</em> chew gum, this is the section for you.</p>  <h3>Nurseries and spawning</h3> <p>Most libraries for concurrent programming let you start new child tasks (or threads, or whatever) willy-nilly, whenever and where-ever you feel like it. Trio is a bit different: you can’t start a child task unless you’re prepared to be a responsible parent. The way you demonstrate your responsibility is by creating a nursery:</p> <pre data-language="python">async with trio.open_nursery() as nursery:
    ...</pre> <p>And once you have a reference to a nursery object, you can start children in that nursery:</p> <pre data-language="python">async def child():
    ...

async def parent():
    async with trio.open_nursery() as nursery:
        # Make two concurrent calls to child()
        nursery.start_soon(child)
        nursery.start_soon(child)</pre> <p>This means that tasks form a tree: when you call <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a>, then this creates an initial task, and all your other tasks will be children, grandchildren, etc. of the initial task.</p> <p>Essentially, the body of the <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> block acts like an initial task that’s running inside the nursery, and then each call to <code class="docutils literal notranslate"><span class="pre">nursery.start_soon</span></code> adds another task that runs in parallel. Two crucial things to keep in mind:</p> <ul class="simple"> <li><p>If any task inside the nursery finishes with an unhandled exception, then the nursery immediately cancels all the tasks inside the nursery.</p></li> <li><p>Since all of the tasks are running concurrently inside the <code class="docutils literal notranslate"><span class="pre">async</span>
<span class="pre">with</span></code> block, the block does not exit until <em>all</em> tasks have completed. If you’ve used other concurrency frameworks, then you can think of it as, the de-indentation at the end of the <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> automatically “joins” (waits for) all of the tasks in the nursery.</p></li> <li>
<p>Once all the tasks have finished, then:</p> <ul> <li><p>The nursery is marked as “closed”, meaning that no new tasks can be started inside it.</p></li> <li><p>Any unhandled exceptions are re-raised inside the parent task. If there are multiple exceptions, then they’re collected up into a single <a class="reference internal" href="#trio.MultiError" title="trio.MultiError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">MultiError</span></code></a> exception.</p></li> </ul> </li> </ul> <p>Since all tasks are descendents of the initial task, one consequence of this is that <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a> can’t finish until all tasks have finished.</p> <blockquote class="admonition note"> <h4 class="admonition-title">Note</h4> <p>A return statement will not cancel the nursery if it still has tasks running:</p> <pre data-language="python">async def main():
    async with trio.open_nursery() as nursery:
        nursery.start_soon(trio.sleep, 5)
        return

trio.run(main)</pre> <p>This code will wait 5 seconds (for the child task to finish), and then return.</p> </blockquote>   <h3>Child tasks and cancellation</h3> <p>In Trio, child tasks inherit the parent nursery’s cancel scopes. So in this example, both the child tasks will be cancelled when the timeout expires:</p> <pre data-language="python">with move_on_after(TIMEOUT):
    async with trio.open_nursery() as nursery:
        nursery.start_soon(child1)
        nursery.start_soon(child2)</pre> <p>Note that what matters here is the scopes that were active when <a class="reference internal" href="#trio.open_nursery" title="trio.open_nursery"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_nursery()</span></code></a> was called, <em>not</em> the scopes active when <code class="docutils literal notranslate"><span class="pre">start_soon</span></code> is called. So for example, the timeout block below does nothing at all:</p> <pre data-language="python">async with trio.open_nursery() as nursery:
    with move_on_after(TIMEOUT):  # don't do this!
        nursery.start_soon(child)</pre>   <h3>Errors in multiple child tasks</h3> <p>Normally, in Python, only one thing happens at a time, which means that only one thing can wrong at a time. Trio has no such limitation. Consider code like:</p> <pre data-language="python">async def broken1():
    d = {}
    return d["missing"]

async def broken2():
    seq = range(10)
    return seq[20]

async def parent():
    async with trio.open_nursery() as nursery:
        nursery.start_soon(broken1)
        nursery.start_soon(broken2)</pre> <p><code class="docutils literal notranslate"><span class="pre">broken1</span></code> raises <code class="docutils literal notranslate"><span class="pre">KeyError</span></code>. <code class="docutils literal notranslate"><span class="pre">broken2</span></code> raises <code class="docutils literal notranslate"><span class="pre">IndexError</span></code>. Obviously <code class="docutils literal notranslate"><span class="pre">parent</span></code> should raise some error, but what? In some sense, the answer should be “both of these at once”, but in Python there can only be one exception at a time.</p> <p>Trio’s answer is that it raises a <a class="reference internal" href="#trio.MultiError" title="trio.MultiError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">MultiError</span></code></a> object. This is a special exception which encapsulates multiple exception objects – either regular exceptions or nested <a class="reference internal" href="#trio.MultiError" title="trio.MultiError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">MultiError</span></code></a>s. To make these easier to work with, Trio installs a custom <a class="reference external" href="https://docs.python.org/3/library/sys.html#sys.excepthook" title="(in Python v3.7)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sys.excepthook</span></code></a> that knows how to print nice tracebacks for unhandled <a class="reference internal" href="#trio.MultiError" title="trio.MultiError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">MultiError</span></code></a>s, and it also provides some helpful utilities like <a class="reference internal" href="#trio.MultiError.catch" title="trio.MultiError.catch"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiError.catch()</span></code></a>, which allows you to catch “part of” a <a class="reference internal" href="#trio.MultiError" title="trio.MultiError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">MultiError</span></code></a>.</p>   <h3>Spawning tasks without becoming a parent</h3> <p>Sometimes it doesn’t make sense for the task that starts a child to take on responsibility for watching it. For example, a server task may want to start a new task for each connection, but it can’t listen for connections and supervise children at the same time.</p> <p>The solution here is simple once you see it: there’s no requirement that a nursery object stay in the task that created it! We can write code like this:</p> <pre data-language="python">async def new_connection_listener(handler, nursery):
    while True:
        conn = await get_new_connection()
        nursery.start_soon(handler, conn)

async def server(handler):
    async with trio.open_nursery() as nursery:
        nursery.start_soon(new_connection_listener, handler, nursery)</pre> <p>Notice that <code class="docutils literal notranslate"><span class="pre">server</span></code> opens a nursery and passes it to <code class="docutils literal notranslate"><span class="pre">new_connection_listener</span></code>, and then <code class="docutils literal notranslate"><span class="pre">new_connection_listener</span></code> is able to start new tasks as “siblings” of itself. Of course, in this case, we could just as well have written:</p> <pre data-language="python">async def server(handler):
    async with trio.open_nursery() as nursery:
        while True:
            conn = await get_new_connection()
            nursery.start_soon(handler, conn)</pre> <p>…but sometimes things aren’t so simple, and this trick comes in handy.</p> <p>One thing to remember, though: cancel scopes are inherited from the nursery, <strong>not</strong> from the task that calls <code class="docutils literal notranslate"><span class="pre">start_soon</span></code>. So in this example, the timeout does <em>not</em> apply to <code class="docutils literal notranslate"><span class="pre">child</span></code> (or to anything else):</p> <pre data-language="python">async def do_spawn(nursery):
    with move_on_after(TIMEOUT):  # don't do this, it has no effect
        nursery.start_soon(child)

async with trio.open_nursery() as nursery:
    nursery.start_soon(do_spawn, nursery)</pre>   <h3>Custom supervisors</h3> <p>The default cleanup logic is often sufficient for simple cases, but what if you want a more sophisticated supervisor? For example, maybe you have <a class="reference external" href="http://learnyousomeerlang.com/supervisors">Erlang envy</a> and want features like automatic restart of crashed tasks. Trio itself doesn’t provide these kinds of features, but you can build them on top; Trio’s goal is to enforce basic hygiene and then get out of your way. (Specifically: Trio won’t let you build a supervisor that exits and leaves orphaned tasks behind, and if you have an unhandled exception due to bugs or laziness then Trio will make sure they propagate.) And then you can wrap your fancy supervisor up in a library and put it on PyPI, because supervisors are tricky and there’s no reason everyone should have to write their own.</p> <p>For example, here’s a function that takes a list of functions, runs them all concurrently, and returns the result from the one that finishes first:</p> <pre data-language="python">async def race(*async_fns):
    if not async_fns:
        raise ValueError("must pass at least one argument")

    send_channel, receive_channel = trio.open_memory_channel(0)

    async def jockey(async_fn):
        await send_channel.send(await async_fn())

    async with trio.open_nursery() as nursery:
        for async_fn in async_fns:
            nursery.start_soon(jockey, async_fn)
        winner = await receive_channel.receive()
        nursery.cancel_scope.cancel()
        return winner</pre> <p>This works by starting a set of tasks which each try to run their function, and then report back the value it returns. The main task uses <code class="docutils literal notranslate"><span class="pre">receive_channel.receive</span></code> to wait for one to finish; as soon as the first task crosses the finish line, it cancels the rest, and then returns the winning value.</p> <p>Here if one or more of the racing functions raises an unhandled exception then Trio’s normal handling kicks in: it cancels the others and then propagates the exception. If you want different behavior, you can get that by adding a <code class="docutils literal notranslate"><span class="pre">try</span></code> block to the <code class="docutils literal notranslate"><span class="pre">jockey</span></code> function to catch exceptions and handle them however you like.</p>   <h3>Task-related API details</h3>  <h4>The nursery API</h4> <dl class="function"> <h3 id="trio.open_nursery"><code><em>async with</em> trio.open_nursery() as nursery</code></h3> <dd>
<p>Returns an async context manager which must be used to create a new <a class="reference internal" href="#trio.Nursery" title="trio.Nursery"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Nursery</span></code></a>.</p> <p>It does not block on entry; on exit it blocks until all child tasks have exited.</p> </dd>
</dl> <dl class="class"> <h3 id="trio.Nursery"><code><em>class</em> trio.Nursery</code></h3> <dd>
<p>A context which may be used to spawn (or cancel) child tasks.</p> <p>Not constructed directly, use <a class="reference internal" href="#trio.open_nursery" title="trio.open_nursery"><code class="xref py py-obj docutils literal notranslate"><span class="pre">open_nursery</span></code></a> instead.</p> <p>The nursery will remain open until all child tasks have completed, or until it is cancelled, at which point it will cancel all its remaining child tasks and close.</p> <p>Nurseries ensure the absence of orphaned Tasks, since all running tasks will belong to an open Nursery.</p> <dl class="attribute"> <h3 id="trio.Nursery.cancel_scope"><code>cancel_scope</code></h3> <dd>
<p>Creating a nursery also implicitly creates a cancellation scope, which is exposed as the <a class="reference internal" href="#trio.Nursery.cancel_scope" title="trio.Nursery.cancel_scope"><code class="xref py py-attr docutils literal notranslate"><span class="pre">cancel_scope</span></code></a> attribute. This is used internally to implement the logic where if an error occurs then <code class="docutils literal notranslate"><span class="pre">__aexit__</span></code> cancels all children, but you can use it for other things, e.g. if you want to explicitly cancel all children in response to some external event.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Nursery.child_tasks"><code>child_tasks</code></h3> <dd>
<p>Contains all the child <a class="reference internal" href="reference-hazmat#trio.hazmat.Task" title="trio.hazmat.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> objects which are still running.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Type</h4> <dd class="field-odd">
<p>(<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#frozenset" title="(in Python v3.7)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">frozenset</span></code></a>)</p> </dd> </dl> </dd>
</dl> <dl class="method"> <h3 id="trio.Nursery.parent_task"><code>parent_task</code></h3> <dd>
<p>The Task that opened this nursery.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Type</h4> <dd class="field-odd">
<p>(<a class="reference internal" href="reference-hazmat#trio.hazmat.Task" title="trio.hazmat.Task"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Task</span></code></a>)</p> </dd> </dl> </dd>
</dl> <dl class="method"> <h3 id="trio.Nursery.start"><code><em>await</em> start(async_fn, *args, name=None)</code></h3> <dd>
<p>Creates and initalizes a child task.</p> <p>Like <a class="reference internal" href="#trio.Nursery.start_soon" title="trio.Nursery.start_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start_soon()</span></code></a>, but blocks until the new task has finished initializing itself, and optionally returns some information from it.</p> <p>The <code class="docutils literal notranslate"><span class="pre">async_fn</span></code> must accept a <code class="docutils literal notranslate"><span class="pre">task_status</span></code> keyword argument, and it must make sure that it (or someone) eventually calls <code class="docutils literal notranslate"><span class="pre">task_status.started()</span></code>.</p> <p>The conventional way to define <code class="docutils literal notranslate"><span class="pre">async_fn</span></code> is like:</p> <pre data-language="python">async def async_fn(arg1, arg2, \*, task_status=trio.TASK_STATUS_IGNORED):
    ...
    task_status.started()
    ...</pre> <p><a class="reference internal" href="#trio.TASK_STATUS_IGNORED" title="trio.TASK_STATUS_IGNORED"><code class="xref py py-attr docutils literal notranslate"><span class="pre">trio.TASK_STATUS_IGNORED</span></code></a> is a special global object with a do-nothing <code class="docutils literal notranslate"><span class="pre">started</span></code> method. This way your function supports being called either like <code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">nursery.start(async_fn,</span> <span class="pre">arg1,</span>
<span class="pre">arg2)</span></code> or directly like <code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">async_fn(arg1,</span> <span class="pre">arg2)</span></code>, and either way it can call <code class="docutils literal notranslate"><span class="pre">task_status.started()</span></code> without worrying about which mode it’s in. Defining your function like this will make it obvious to readers that it supports being used in both modes.</p> <p>Before the child calls <code class="docutils literal notranslate"><span class="pre">task_status.started()</span></code>, it’s effectively run underneath the call to <a class="reference internal" href="#trio.Nursery.start" title="trio.Nursery.start"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start()</span></code></a>: if it raises an exception then that exception is reported by <a class="reference internal" href="#trio.Nursery.start" title="trio.Nursery.start"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start()</span></code></a>, and does <em>not</em> propagate out of the nursery. If <a class="reference internal" href="#trio.Nursery.start" title="trio.Nursery.start"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start()</span></code></a> is cancelled, then the child task is also cancelled.</p> <p>When the child calls <code class="docutils literal notranslate"><span class="pre">task_status.started()</span></code>, it’s moved from out from underneath <a class="reference internal" href="#trio.Nursery.start" title="trio.Nursery.start"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start()</span></code></a> and into the given nursery.</p> <p>If the child task passes a value to <code class="docutils literal notranslate"><span class="pre">task_status.started(value)</span></code>, then <a class="reference internal" href="#trio.Nursery.start" title="trio.Nursery.start"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start()</span></code></a> returns this value. Otherwise it returns <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Nursery.start_soon"><code>start_soon(async_fn, *args, name=None)</code></h3> <dd>
<p>Creates a child task, scheduling <code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">async_fn(*args)</span></code>.</p> <p>This and <a class="reference internal" href="#trio.Nursery.start" title="trio.Nursery.start"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start()</span></code></a> are the two fundamental methods for creating concurrent tasks in Trio.</p> <p>Note that this is <em>not</em> an async function and you don’t use await when calling it. It sets up the new task, but then returns immediately, <em>before</em> it has a chance to run. The new task won’t actually get a chance to do anything until some later point when you execute a checkpoint and the scheduler decides to run it. If you want to run a function and immediately wait for its result, then you don’t need a nursery; just use <code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">async_fn(*args)</span></code>. If you want to wait for the task to initialize itself before continuing, see <a class="reference internal" href="#trio.Nursery.start" title="trio.Nursery.start"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start()</span></code></a>.</p> <p>It’s possible to pass a nursery object into another task, which allows that task to start new child tasks in the first task’s nursery.</p> <p>The child task inherits its parent nursery’s cancel scopes.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<ul class="simple"> <li><p><code>async_fn</code> – An async callable.</p></li> <li><p><code>args</code> – Positional arguments for <code class="docutils literal notranslate"><span class="pre">async_fn</span></code>. If you want to pass keyword arguments, use <a class="reference external" href="https://docs.python.org/3/library/functools.html#functools.partial" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a>.</p></li> <li><p><code>name</code> – The name for this task. Only used for debugging/introspection (e.g. <code class="docutils literal notranslate"><span class="pre">repr(task_obj)</span></code>). If this isn’t a string, <a class="reference internal" href="#trio.Nursery.start_soon" title="trio.Nursery.start_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start_soon()</span></code></a> will try to make it one. A common use case is if you’re wrapping a function before spawning a new task, you might pass the original function as the <code class="docutils literal notranslate"><span class="pre">name=</span></code> to make debugging easier.</p></li> </ul> </dd> <h4 class="field-even" style="margin: 0">Returns</h4> <dd class="field-even">
<p>True if successful, False otherwise.</p> </dd> <h4 class="field-odd" style="margin: 0">Raises</h4> <dd class="field-odd">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.7)"><code>RuntimeError</code></a> – If this nursery is no longer open (i.e. its <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> block has exited).</p> </dd> </dl> </dd>
</dl> </dd>
</dl> <dl class="attribute"> <h3 id="trio.TASK_STATUS_IGNORED"><code>trio.TASK_STATUS_IGNORED</code></h3> <dd>
<p>See <a class="reference internal" href="#trio.Nursery.start" title="trio.Nursery.start"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start()</span></code></a>.</p> </dd>
</dl>   <h4>Working with <a class="reference internal" href="#trio.MultiError" title="trio.MultiError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">MultiError</span></code></a>s</h4> <dl class="exception"> <h3 id="trio.MultiError"><code><em>exception</em> trio.MultiError(exceptions)</code></h3> <dd>
<p>An exception that contains other exceptions; also known as an “inception”.</p> <p>It’s main use is to represent the situation when multiple child tasks all raise errors “in parallel”.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<p><code>exceptions</code> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.7)"><em>list</em></a>) – The exceptions</p> </dd> <h4 class="field-even" style="margin: 0">Returns</h4> <dd class="field-even">

<p>If <code class="docutils literal notranslate"><span class="pre">len(exceptions)</span> <span class="pre">==</span> <span class="pre">1</span></code>, returns that exception. This means that a call to <code class="docutils literal notranslate"><span class="pre">MultiError(...)</span></code> is not guaranteed to return a <a class="reference internal" href="#trio.MultiError" title="trio.MultiError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">MultiError</span></code></a> object!</p> <p>Otherwise, returns a new <a class="reference internal" href="#trio.MultiError" title="trio.MultiError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">MultiError</span></code></a> object.</p> </dd> <h4 class="field-odd" style="margin: 0">Raises</h4> <dd class="field-odd">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#TypeError" title="(in Python v3.7)"><code>TypeError</code></a> – if any of the passed in objects are not instances of <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#BaseException" title="(in Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BaseException</span></code></a>.</p> </dd> </dl> <dl class="attribute"> <h3 id="trio.MultiError.exceptions"><code>exceptions</code></h3> <dd>
<p>The list of exception objects that this <a class="reference internal" href="#trio.MultiError" title="trio.MultiError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">MultiError</span></code></a> represents.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.MultiError.filter"><code><em>classmethod</em> filter(handler, root_exc)</code></h3> <dd>
<p>Apply the given <code class="docutils literal notranslate"><span class="pre">handler</span></code> to all the exceptions in <code class="docutils literal notranslate"><span class="pre">root_exc</span></code>.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<ul class="simple"> <li><p><code>handler</code> – A callable that takes an atomic (non-MultiError) exception as input, and returns either a new exception object or None.</p></li> <li><p><code>root_exc</code> – An exception, often (though not necessarily) a <a class="reference internal" href="#trio.MultiError" title="trio.MultiError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">MultiError</span></code></a>.</p></li> </ul> </dd> <h4 class="field-even" style="margin: 0">Returns</h4> <dd class="field-even">
<p>A new exception object in which each component exception <code class="docutils literal notranslate"><span class="pre">exc</span></code> has been replaced by the result of running <code class="docutils literal notranslate"><span class="pre">handler(exc)</span></code> – or, if <code class="docutils literal notranslate"><span class="pre">handler</span></code> returned None for all the inputs, returns None.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <h3 id="trio.MultiError.catch"><code><em>classmethod with</em> catch(handler)</code></h3> <dd>
<p>Return a context manager that catches and re-throws exceptions after running <a class="reference internal" href="#trio.MultiError.filter" title="trio.MultiError.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a> on them.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<p><code>handler</code> – as for <a class="reference internal" href="#trio.MultiError.filter" title="trio.MultiError.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a></p> </dd> </dl> </dd>
</dl> </dd>
</dl> <p>Examples:</p> <p>Suppose we have a handler function that discards <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>s:</p> <pre data-language="python">def handle_ValueError(exc):
    if isinstance(exc, ValueError):
        return None
    else:
        return exc</pre> <p>Then these both raise <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyError" title="(in Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a>:</p> <pre data-language="python">with MultiError.catch(handle_ValueError):
     raise MultiError([KeyError(), ValueError()])

with MultiError.catch(handle_ValueError):
     raise MultiError([
         ValueError(),
         MultiError([KeyError(), ValueError()]),
     ])</pre> <p>And both of these raise nothing at all:</p> <pre data-language="python">with MultiError.catch(handle_ValueError):
     raise MultiError([ValueError(), ValueError()])

with MultiError.catch(handle_ValueError):
     raise MultiError([
         MultiError([ValueError(), ValueError()]),
         ValueError(),
     ])</pre> <p>You can also return a new or modified exception, for example:</p> <pre data-language="python">def convert_ValueError_to_MyCustomError(exc):
    if isinstance(exc, ValueError):
        # Similar to 'raise MyCustomError from exc'
        new_exc = MyCustomError(...)
        new_exc.__cause__ = exc
        return new_exc
    else:
        return exc</pre> <p>In the example above, we set <code class="docutils literal notranslate"><span class="pre">__cause__</span></code> as a form of explicit context chaining. <a class="reference internal" href="#trio.MultiError.filter" title="trio.MultiError.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiError.filter()</span></code></a> and <a class="reference internal" href="#trio.MultiError.catch" title="trio.MultiError.catch"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiError.catch()</span></code></a> also perform implicit exception chaining – if you return a new exception object, then the new object’s <code class="docutils literal notranslate"><span class="pre">__context__</span></code> attribute will automatically be set to the original exception.</p> <p>We also monkey patch <a class="reference external" href="https://docs.python.org/3/library/traceback.html#traceback.TracebackException" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">traceback.TracebackException</span></code></a> to be able to handle formatting <a class="reference internal" href="#trio.MultiError" title="trio.MultiError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">MultiError</span></code></a>s. This means that anything that formats exception messages like <a class="reference external" href="https://docs.python.org/3/library/logging.html#module-logging" title="(in Python v3.7)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> will work out of the box:</p> <pre data-language="python">import logging

logging.basicConfig()

try:
    raise MultiError([ValueError("foo"), KeyError("bar")])
except:
    logging.exception("Oh no!")
    raise</pre> <p>Will properly log the inner exceptions:</p> <pre>ERROR:root:Oh no!
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 2, in &lt;module&gt;
trio.MultiError: ValueError('foo',), KeyError('bar',)

Details of embedded exception 1:

  ValueError: foo

Details of embedded exception 2:

  KeyError: 'bar'</pre>     <h2>Task-local storage</h2> <p>Suppose you’re writing a server that responds to network requests, and you log some information about each request as you process it. If the server is busy and there are multiple requests being handled at the same time, then you might end up with logs like this:</p> <pre>Request handler started
Request handler started
Request handler finished
Request handler finished</pre> <p>In this log, it’s hard to know which lines came from which request. (Did the request that started first also finish first, or not?) One way to solve this is to assign each request a unique identifier, and then include this identifier in each log message:</p> <pre>request 1: Request handler started
request 2: Request handler started
request 2: Request handler finished
request 1: Request handler finished</pre> <p>This way we can see that request 1 was slow: it started before request 2 but finished afterwards. (You can also get <a class="reference external" href="https://opentracing.io/docs/">much fancier</a>, but this is enough for an example.)</p> <p>Now, here’s the problem: how does the logging code know what the request identifier is? One approach would be to explicitly pass it around to every function that might want to emit logs… but that’s basically every function, because you never know when you might need to add a <code class="docutils literal notranslate"><span class="pre">log.debug(...)</span></code> call to some utility function buried deep in the call stack, and when you’re in the middle of a debugging a nasty problem that last thing you want is to have to stop first and refactor everything to pass through the request identifier! Sometimes this is the right solution, but other times it would be much more convenient if we could store the identifier in a global variable, so that the logging function could look it up whenever it needed it. Except… a global variable can only have one value at a time, so if we have multiple handlers running at once then this isn’t going to work. What we need is something that’s <em>like</em> a global variable, but that can have different values depending on which request handler is accessing it.</p> <p>To solve this problem, Python 3.7 added a new module to the standard library: <a class="reference external" href="https://docs.python.org/3/library/contextvars.html#module-contextvars" title="(in Python v3.7)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextvars</span></code></a>. And not only does Trio have built-in support for <a class="reference external" href="https://docs.python.org/3/library/contextvars.html#module-contextvars" title="(in Python v3.7)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextvars</span></code></a>, but if you’re using an earlier version of Python, then Trio makes sure that a backported version of <a class="reference external" href="https://docs.python.org/3/library/contextvars.html#module-contextvars" title="(in Python v3.7)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextvars</span></code></a> is installed. So you can assume <a class="reference external" href="https://docs.python.org/3/library/contextvars.html#module-contextvars" title="(in Python v3.7)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextvars</span></code></a> is there and works regardless of what version of Python you’re using.</p> <p>Here’s a toy example demonstrating how to use <a class="reference external" href="https://docs.python.org/3/library/contextvars.html#module-contextvars" title="(in Python v3.7)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextvars</span></code></a>:</p> <pre data-language="python">import random
import trio
import contextvars

request_info = contextvars.ContextVar("request_info")


# Example logging function that tags each line with the request identifier.
def log(msg):
    # Read from task-local storage:
    request_tag = request_info.get()

    print("request {}: {}".format(request_tag, msg))


# An example "request handler" that does some work itself and also
# spawns some helper tasks to do some concurrent work.
async def handle_request(tag):
    # Write to task-local storage:
    request_info.set(tag)

    log("Request handler started")
    await trio.sleep(random.random())
    async with trio.open_nursery() as nursery:
        nursery.start_soon(concurrent_helper, "a")
        nursery.start_soon(concurrent_helper, "b")
    await trio.sleep(random.random())
    log("Request received finished")


async def concurrent_helper(job):
    log("Helper task {} started".format(job))
    await trio.sleep(random.random())
    log("Helper task {} finished".format(job))


# Spawn several "request handlers" simultaneously, to simulate a
# busy server handling multiple requests at the same time.
async def main():
    async with trio.open_nursery() as nursery:
        for i in range(3):
            nursery.start_soon(handle_request, i)


trio.run(main)</pre> <p>Example output (yours may differ slightly):</p> <pre>request 1: Request handler started
request 2: Request handler started
request 0: Request handler started
request 2: Helper task a started
request 2: Helper task b started
request 1: Helper task a started
request 1: Helper task b started
request 0: Helper task b started
request 0: Helper task a started
request 2: Helper task b finished
request 2: Helper task a finished
request 2: Request received finished
request 0: Helper task a finished
request 1: Helper task a finished
request 1: Helper task b finished
request 1: Request received finished
request 0: Helper task b finished
request 0: Request received finished</pre> <p>For more information, read the <a class="reference external" href="https://docs.python.org/3.7/library/contextvars.html">contextvar docs</a>.</p>   <h2>Synchronizing and communicating between tasks</h2> <p>Trio provides a standard set of synchronization and inter-task communication primitives. These objects’ APIs are generally modelled off of the analogous classes in the standard library, but with some differences.</p>  <h3>Blocking and non-blocking methods</h3> <p>The standard library synchronization primitives have a variety of mechanisms for specifying timeouts and blocking behavior, and of signaling whether an operation returned due to success versus a timeout.</p> <p>In Trio, we standardize on the following conventions:</p> <ul class="simple"> <li><p>We don’t provide timeout arguments. If you want a timeout, then use a cancel scope.</p></li> <li><p>For operations that have a non-blocking variant, the blocking and non-blocking variants are different methods with names like <code class="docutils literal notranslate"><span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">X_nowait</span></code>, respectively. (This is similar to <a class="reference external" href="https://docs.python.org/3/library/queue.html#queue.Queue" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">queue.Queue</span></code></a>, but unlike most of the classes in <a class="reference external" href="https://docs.python.org/3/library/threading.html#module-threading" title="(in Python v3.7)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a>.) We like this approach because it allows us to make the blocking version async and the non-blocking version sync.</p></li> <li><p>When a non-blocking method cannot succeed (the channel is empty, the lock is already held, etc.), then it raises <a class="reference internal" href="#trio.WouldBlock" title="trio.WouldBlock"><code class="xref py py-exc docutils literal notranslate"><span class="pre">trio.WouldBlock</span></code></a>. There’s no equivalent to the <a class="reference external" href="https://docs.python.org/3/library/queue.html#queue.Empty" title="(in Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">queue.Empty</span></code></a> versus <a class="reference external" href="https://docs.python.org/3/library/queue.html#queue.Full" title="(in Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">queue.Full</span></code></a> distinction – we just have the one exception that we use consistently.</p></li> </ul>   <h3>Fairness</h3> <p>These classes are all guaranteed to be “fair”, meaning that when it comes time to choose who will be next to acquire a lock, get an item from a queue, etc., then it always goes to the task which has been waiting longest. It’s <a class="reference external" href="https://github.com/python-trio/trio/issues/54">not entirely clear</a> whether this is the best choice, but for now that’s how it works.</p> <p>As an example of what this means, here’s a small program in which two tasks compete for a lock. Notice that the task which releases the lock always immediately attempts to re-acquire it, before the other task has a chance to run. (And remember that we’re doing cooperative multi-tasking here, so it’s actually <em>deterministic</em> that the task releasing the lock will call <a class="reference internal" href="#trio.Lock.acquire" title="trio.Lock.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire()</span></code></a> before the other task wakes up; in Trio releasing a lock is not a checkpoint.) With an unfair lock, this would result in the same task holding the lock forever and the other task being starved out. But if you run this, you’ll see that the two tasks politely take turns:</p> <pre data-language="python"># fairness-demo.py

import trio

async def loopy_child(number, lock):
    while True:
        async with lock:
            print("Child {} has the lock!".format(number))
            await trio.sleep(0.5)

async def main():
    async with trio.open_nursery() as nursery:
        lock = trio.Lock()
        nursery.start_soon(loopy_child, 1, lock)
        nursery.start_soon(loopy_child, 2, lock)

trio.run(main)</pre>   <h3>Broadcasting an event with <a class="reference internal" href="#trio.Event" title="trio.Event"><code class="xref py py-class docutils literal notranslate"><span class="pre">Event</span></code></a>
</h3> <dl class="class"> <h3 id="trio.Event"><code><em>class</em> trio.Event</code></h3> <dd>
<p>A waitable boolean value useful for inter-task synchronization, inspired by <a class="reference external" href="https://docs.python.org/3/library/threading.html#threading.Event" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Event</span></code></a>.</p> <p>An event object has an internal boolean flag, representing whether the event has happened yet. The flag is initially False, and the <a class="reference internal" href="#trio.Event.wait" title="trio.Event.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a> method waits until the flag is True. If the flag is already True, then <a class="reference internal" href="#trio.Event.wait" title="trio.Event.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a> returns immediately. (If the event has already happened, there’s nothing to wait for.) The <a class="reference internal" href="#trio.Event.set" title="trio.Event.set"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set()</span></code></a> method sets the flag to True, and wakes up any waiters.</p> <p>This behavior is useful because it helps avoid race conditions and lost wakeups: it doesn’t matter whether <a class="reference internal" href="#trio.Event.set" title="trio.Event.set"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set()</span></code></a> gets called just before or after <a class="reference internal" href="#trio.Event.wait" title="trio.Event.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a>. If you want a lower-level wakeup primitive that doesn’t have this protection, consider <a class="reference internal" href="#trio.Condition" title="trio.Condition"><code class="xref py py-class docutils literal notranslate"><span class="pre">Condition</span></code></a> or <a class="reference internal" href="reference-hazmat#trio.hazmat.ParkingLot" title="trio.hazmat.ParkingLot"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.hazmat.ParkingLot</span></code></a>.</p> <blockquote class="admonition note"> <h4 class="admonition-title">Note</h4> <p>Unlike <a class="reference external" href="https://docs.python.org/3/library/threading.html#threading.Event" title="(in Python v3.7)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">threading.Event</span></code></a>, <a class="reference internal" href="#trio.Event" title="trio.Event"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.Event</span></code></a> has no <a class="reference external" href="https://docs.python.org/3/library/threading.html#threading.Event.clear" title="(in Python v3.7)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">clear</span></code></a> method. In Trio, once an <a class="reference internal" href="#trio.Event" title="trio.Event"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Event</span></code></a> has happened, it cannot un-happen. If you need to represent a series of events, consider creating a new <a class="reference internal" href="#trio.Event" title="trio.Event"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Event</span></code></a> object for each one (they’re cheap!), or other synchronization methods like <a class="reference internal" href="#channels"><span class="std std-ref">channels</span></a> or <a class="reference internal" href="reference-hazmat#trio.hazmat.ParkingLot" title="trio.hazmat.ParkingLot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.hazmat.ParkingLot</span></code></a>.</p> </blockquote> <dl class="method"> <h3 id="trio.Event.is_set"><code>is_set()</code></h3> <dd>
<p>Return the current value of the internal flag.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Event.set"><code>set()</code></h3> <dd>
<p>Set the internal flag value to True, and wake any waiting tasks.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Event.statistics"><code>statistics()</code></h3> <dd>
<p>Return an object containing debugging information.</p> <p>Currently the following fields are defined:</p> <ul class="simple"> <li><p><code class="docutils literal notranslate"><span class="pre">tasks_waiting</span></code>: The number of tasks blocked on this event’s <a class="reference internal" href="#trio.Event.wait" title="trio.Event.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a> method.</p></li> </ul> </dd>
</dl> <dl class="method"> <h3 id="trio.Event.wait"><code><em>await</em> wait()</code></h3> <dd>
<p>Block until the internal flag value becomes True.</p> <p>If it’s already True, then this method returns immediately.</p> </dd>
</dl> </dd>
</dl>   <h3>Using channels to pass values between tasks</h3> <p><em>Channels</em> allow you to safely and conveniently send objects between different tasks. They’re particularly useful for implementing producer/consumer patterns.</p> <p>The core channel API is defined by the abstract base classes <a class="reference internal" href="reference-io#trio.abc.SendChannel" title="trio.abc.SendChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.SendChannel</span></code></a> and <a class="reference internal" href="reference-io#trio.abc.ReceiveChannel" title="trio.abc.ReceiveChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.ReceiveChannel</span></code></a>. You can use these to implement your own custom channels, that do things like pass objects between processes or over the network. But in many cases, you just want to pass objects between different tasks inside a single process, and for that you can use <a class="reference internal" href="#trio.open_memory_channel" title="trio.open_memory_channel"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.open_memory_channel()</span></code></a>:</p> <dl class="function"> <h3 id="trio.open_memory_channel"><code>trio.open_memory_channel(max_buffer_size)</code></h3> <dd>
<p>Open a channel for passing objects between tasks within a process.</p> <p>Memory channels are lightweight, cheap to allocate, and entirely in-memory. They don’t involve any operating-system resources, or any kind of serialization. They just pass Python objects directly between tasks (with a possible stop in an internal buffer along the way).</p> <p>Channel objects can be closed by calling <a class="reference internal" href="reference-io#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">aclose</span></code></a> or using <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code>. They are <em>not</em> automatically closed when garbage collected. Closing memory channels isn’t mandatory, but it is generally a good idea, because it helps avoid situations where tasks get stuck waiting on a channel when there’s no-one on the other side. See <a class="reference internal" href="#channel-shutdown"><span class="std std-ref">Clean shutdown with channels</span></a> for details.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<p><code>max_buffer_size</code> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em> or </em><em>math.inf</em>) – The maximum number of items that can be buffered in the channel before <a class="reference internal" href="reference-io#trio.abc.SendChannel.send" title="trio.abc.SendChannel.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> blocks. Choosing a sensible value here is important to ensure that backpressure is communicated promptly and avoid unnecessary latency; see <a class="reference internal" href="#channel-buffering"><span class="std std-ref">Buffering in channels</span></a> for more details. If in doubt, use 0.</p> </dd> <h4 class="field-even" style="margin: 0">Returns</h4> <dd class="field-even">
<p>A pair <code class="docutils literal notranslate"><span class="pre">(send_channel,</span> <span class="pre">receive_channel)</span></code>. If you have trouble remembering which order these go in, remember: data flows from left → right.</p> </dd> </dl> <p>In addition to the standard channel methods, all memory channel objects provide a <code class="docutils literal notranslate"><span class="pre">statistics()</span></code> method, which returns an object with the following fields:</p> <ul class="simple"> <li><p><code class="docutils literal notranslate"><span class="pre">current_buffer_used</span></code>: The number of items currently stored in the channel buffer.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">max_buffer_size</span></code>: The maximum number of items allowed in the buffer, as passed to <a class="reference internal" href="#trio.open_memory_channel" title="trio.open_memory_channel"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_memory_channel()</span></code></a>.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">open_send_channels</span></code>: The number of open <a class="reference internal" href="#trio.MemorySendChannel" title="trio.MemorySendChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemorySendChannel</span></code></a> endpoints pointing to this channel. Initially 1, but can be increased by <a class="reference internal" href="#trio.MemorySendChannel.clone" title="trio.MemorySendChannel.clone"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MemorySendChannel.clone()</span></code></a>.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">open_receive_channels</span></code>: Likewise, but for open <a class="reference internal" href="#trio.MemoryReceiveChannel" title="trio.MemoryReceiveChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryReceiveChannel</span></code></a> endpoints.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">tasks_waiting_send</span></code>: The number of tasks blocked in <code class="docutils literal notranslate"><span class="pre">send</span></code> on this channel (summing over all clones).</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">tasks_waiting_receive</span></code>: The number of tasks blocked in <code class="docutils literal notranslate"><span class="pre">receive</span></code> on this channel (summing over all clones).</p></li> </ul> </dd>
</dl> <blockquote class="admonition note"> <h4 class="admonition-title">Note</h4> <p>If you’ve used the <a class="reference external" href="https://docs.python.org/3/library/threading.html#module-threading" title="(in Python v3.7)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> or <a class="reference external" href="https://docs.python.org/3/library/asyncio.html#module-asyncio" title="(in Python v3.7)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code></a> modules, you may be familiar with <a class="reference external" href="https://docs.python.org/3/library/queue.html#queue.Queue" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">queue.Queue</span></code></a> or <a class="reference external" href="https://docs.python.org/3/library/asyncio-queue.html#asyncio.Queue" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Queue</span></code></a>. In Trio, <a class="reference internal" href="#trio.open_memory_channel" title="trio.open_memory_channel"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_memory_channel()</span></code></a> is what you use when you’re looking for a queue. The main difference is that Trio splits the classic queue interface up into two objects. The advantage of this is that it makes it possible to put the two ends in different processes without rewriting your code, and that we can close the two sides separately.</p> </blockquote> <p><a class="reference internal" href="#trio.MemorySendChannel" title="trio.MemorySendChannel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MemorySendChannel</span></code></a> and <a class="reference internal" href="#trio.MemoryReceiveChannel" title="trio.MemoryReceiveChannel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MemoryReceiveChannel</span></code></a> also expose several more features beyond the core channel interface:</p> <dl class="class"> <h3 id="trio.MemorySendChannel"><code><em>class</em> trio.MemorySendChannel(state, closed=False, tasks=NOTHING)</code></h3> <dd>
<dl class="method"> <h3 id="trio.MemorySendChannel.clone"><code>clone()</code></h3> <dd>
<p>Clone this send channel object.</p> <p>This returns a new <a class="reference internal" href="#trio.MemorySendChannel" title="trio.MemorySendChannel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MemorySendChannel</span></code></a> object, which acts as a duplicate of the original: sending on the new object does exactly the same thing as sending on the old object. (If you’re familiar with <a class="reference external" href="https://docs.python.org/3/library/os.html#os.dup" title="(in Python v3.7)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">os.dup</span></code></a>, then this is a similar idea.)</p> <p>However, closing one of the objects does not close the other, and receivers don’t get <a class="reference internal" href="#trio.EndOfChannel" title="trio.EndOfChannel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">EndOfChannel</span></code></a> until <em>all</em> clones have been closed.</p> <p>This is useful for communication patterns that involve multiple producers all sending objects to the same destination. If you give each producer its own clone of the <a class="reference internal" href="#trio.MemorySendChannel" title="trio.MemorySendChannel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MemorySendChannel</span></code></a>, and then make sure to close each <a class="reference internal" href="#trio.MemorySendChannel" title="trio.MemorySendChannel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MemorySendChannel</span></code></a> when it’s finished, receivers will automatically get notified when all producers are finished. See <a class="reference internal" href="#channel-mpmc"><span class="std std-ref">Managing multiple producers and/or multiple consumers</span></a> for examples.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Raises</h4> <dd class="field-odd">
<p><a class="reference internal" href="#trio.ClosedResourceError" title="trio.ClosedResourceError"><code>trio.ClosedResourceError</code></a> – if you already closed this <a class="reference internal" href="#trio.MemorySendChannel" title="trio.MemorySendChannel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MemorySendChannel</span></code></a> object.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <h3 id="trio.MemorySendChannel.send"><code><em>await</em> send(value)</code></h3> <dd>
<p>See <a class="reference internal" href="reference-io#trio.abc.SendChannel.send" title="trio.abc.SendChannel.send"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SendChannel.send</span></code></a>.</p> <p>Memory channels allow multiple tasks to call <a class="reference internal" href="#trio.MemorySendChannel.send" title="trio.MemorySendChannel.send"><code class="xref py py-obj docutils literal notranslate"><span class="pre">send</span></code></a> at the same time.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.MemorySendChannel.send_nowait"><code>send_nowait(value)</code></h3> <dd>
<p>Like <a class="reference internal" href="reference-io#trio.abc.SendChannel.send" title="trio.abc.SendChannel.send"><code class="xref py py-obj docutils literal notranslate"><span class="pre">send</span></code></a>, but if the channel’s buffer is full, raises <a class="reference internal" href="#trio.WouldBlock" title="trio.WouldBlock"><code class="xref py py-obj docutils literal notranslate"><span class="pre">WouldBlock</span></code></a> instead of blocking.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <h3 id="trio.MemoryReceiveChannel"><code><em>class</em> trio.MemoryReceiveChannel(state, closed=False, tasks=NOTHING)</code></h3> <dd>
<dl class="method"> <h3 id="trio.MemoryReceiveChannel.clone"><code>clone()</code></h3> <dd>
<p>Clone this receive channel object.</p> <p>This returns a new <a class="reference internal" href="#trio.MemoryReceiveChannel" title="trio.MemoryReceiveChannel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MemoryReceiveChannel</span></code></a> object, which acts as a duplicate of the original: receiving on the new object does exactly the same thing as receiving on the old object.</p> <p>However, closing one of the objects does not close the other, and the underlying channel is not closed until all clones are closed. (If you’re familiar with <a class="reference external" href="https://docs.python.org/3/library/os.html#os.dup" title="(in Python v3.7)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">os.dup</span></code></a>, then this is a similar idea.)</p> <p>This is useful for communication patterns that involve multiple consumers all receiving objects from the same underlying channel. See <a class="reference internal" href="#channel-mpmc"><span class="std std-ref">Managing multiple producers and/or multiple consumers</span></a> for examples.</p> <blockquote class="admonition warning"> <h4 class="admonition-title">Warning</h4> <p>The clones all share the same underlying channel. Whenever a clone <a class="reference internal" href="#trio.MemoryReceiveChannel.receive" title="trio.MemoryReceiveChannel.receive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">receive()</span></code></a>s a value, it is removed from the channel and the other clones do <em>not</em> receive that value. If you want to send multiple copies of the same stream of values to multiple destinations, like <a class="reference external" href="https://docs.python.org/3/library/itertools.html#itertools.tee" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.tee()</span></code></a>, then you need to find some other solution; this method does <em>not</em> do that.</p> </blockquote> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Raises</h4> <dd class="field-odd">
<p><a class="reference internal" href="#trio.ClosedResourceError" title="trio.ClosedResourceError"><code>trio.ClosedResourceError</code></a> – if you already closed this <a class="reference internal" href="#trio.MemoryReceiveChannel" title="trio.MemoryReceiveChannel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MemoryReceiveChannel</span></code></a> object.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <h3 id="trio.MemoryReceiveChannel.receive"><code><em>await</em> receive()</code></h3> <dd>
<p>See <a class="reference internal" href="reference-io#trio.abc.ReceiveChannel.receive" title="trio.abc.ReceiveChannel.receive"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReceiveChannel.receive</span></code></a>.</p> <p>Memory channels allow multiple tasks to call <a class="reference internal" href="#trio.MemoryReceiveChannel.receive" title="trio.MemoryReceiveChannel.receive"><code class="xref py py-obj docutils literal notranslate"><span class="pre">receive</span></code></a> at the same time. The first task will get the first item sent, the second task will get the second item sent, and so on.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.MemoryReceiveChannel.receive_nowait"><code>receive_nowait()</code></h3> <dd>
<p>Like <a class="reference internal" href="reference-io#trio.abc.ReceiveChannel.receive" title="trio.abc.ReceiveChannel.receive"><code class="xref py py-obj docutils literal notranslate"><span class="pre">receive</span></code></a>, but if there’s nothing ready to receive, raises <a class="reference internal" href="#trio.WouldBlock" title="trio.WouldBlock"><code class="xref py py-obj docutils literal notranslate"><span class="pre">WouldBlock</span></code></a> instead of blocking.</p> </dd>
</dl> </dd>
</dl>  <h4>A simple channel example</h4> <p>Here’s a simple example of how to use memory channels:</p> <pre data-language="python">import trio

async def main():
    async with trio.open_nursery() as nursery:
        # Open a channel:
        send_channel, receive_channel = trio.open_memory_channel(0)
        # Start a producer and a consumer, passing one end of the channel to
        # each of them:
        nursery.start_soon(producer, send_channel)
        nursery.start_soon(consumer, receive_channel)

async def producer(send_channel):
    # Producer sends 3 messages
    for i in range(3):
        # The producer sends using 'await send_channel.send(...)'
        await send_channel.send("message {}".format(i))

async def consumer(receive_channel):
    # The consumer uses an 'async for' loop to receive the values:
    async for value in receive_channel:
        print("got value {!r}".format(value))

trio.run(main)</pre> <p>If you run this, it prints:</p> <pre>got value "message 0"
got value "message 1"
got value "message 2"</pre> <p>And then it hangs forever. (Use control-C to quit.)</p>   <h4>Clean shutdown with channels</h4> <p>Of course we don’t generally like it when programs hang. What happened? The problem is that the producer sent 3 messages and then exited, but the consumer has no way to tell that the producer is gone: for all it knows, another message might be coming along any moment. So it hangs forever waiting for the 4th message.</p> <p>Here’s a new version that fixes this: it produces the same output as the previous version, and then exits cleanly. The only change is the addition of <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> blocks inside the producer and consumer:</p> <pre data-language="python">import trio

async def main():
    async with trio.open_nursery() as nursery:
        send_channel, receive_channel = trio.open_memory_channel(0)
        nursery.start_soon(producer, send_channel)
        nursery.start_soon(consumer, receive_channel)

async def producer(send_channel):
    async with send_channel:
        for i in range(3):
            await send_channel.send("message {}".format(i))

async def consumer(receive_channel):
    async with receive_channel:
        async for value in receive_channel:
            print("got value {!r}".format(value))

trio.run(main)</pre> <p>The really important thing here is the producer’s <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> . When the producer exits, this closes the <code class="docutils literal notranslate"><span class="pre">send_channel</span></code>, and that tells the consumer that no more messages are coming, so it can cleanly exit its <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> loop. Then the program shuts down because both tasks have exited.</p> <p>We also added an <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> to the consumer. This isn’t as important, but it can help us catch mistakes or other problems. For example, suppose that the consumer exited early for some reason – maybe because of a bug. Then the producer would be sending messages into the void, and might get stuck indefinitely. But, if the consumer closes its <code class="docutils literal notranslate"><span class="pre">receive_channel</span></code>, then the producer will get a <a class="reference internal" href="#trio.BrokenResourceError" title="trio.BrokenResourceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BrokenResourceError</span></code></a> to alert it that it should stop sending messages because no-one is listening.</p> <p>If you want to see the effect of the consumer exiting early, try adding a <code class="docutils literal notranslate"><span class="pre">break</span></code> statement to the <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> loop – you should see a <a class="reference internal" href="#trio.BrokenResourceError" title="trio.BrokenResourceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BrokenResourceError</span></code></a> from the producer.</p>   <h4>Managing multiple producers and/or multiple consumers</h4> <p>You can also have multiple producers, and multiple consumers, all sharing the same channel. However, this makes shutdown a little more complicated.</p> <p>For example, consider this naive extension of our previous example, now with two producers and two consumers:</p> <pre data-language="python"># This example usually crashes!

import trio
import random

async def main():
    async with trio.open_nursery() as nursery:
        send_channel, receive_channel = trio.open_memory_channel(0)
        # Start two producers
        nursery.start_soon(producer, "A", send_channel)
        nursery.start_soon(producer, "B", send_channel)
        # And two consumers
        nursery.start_soon(consumer, "X", receive_channel)
        nursery.start_soon(consumer, "Y", receive_channel)

async def producer(name, send_channel):
    async with send_channel:
        for i in range(3):
            await send_channel.send("{} from producer {}".format(i, name))
            # Random sleeps help trigger the problem more reliably
            await trio.sleep(random.random())

async def consumer(name, receive_channel):
    async with receive_channel:
        async for value in receive_channel:
            print("consumer {} got value {!r}".format(name, value))
            # Random sleeps help trigger the problem more reliably
            await trio.sleep(random.random())

trio.run(main)</pre> <p>The two producers, A and B, send 3 messages apiece. These are then randomly distributed between the two consumers, X and Y. So we’re hoping to see some output like:</p> <pre>consumer Y got value '0 from producer B'
consumer X got value '0 from producer A'
consumer Y got value '1 from producer A'
consumer Y got value '1 from producer B'
consumer X got value '2 from producer B'
consumer X got value '2 from producer A'</pre> <p>However, on most runs, that’s not what happens – the first part of the output is OK, and then when we get to the end the program crashes with <a class="reference internal" href="#trio.ClosedResourceError" title="trio.ClosedResourceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ClosedResourceError</span></code></a>. If you run the program a few times, you’ll see that sometimes the traceback shows <code class="docutils literal notranslate"><span class="pre">send</span></code> crashing, and other times it shows <code class="docutils literal notranslate"><span class="pre">receive</span></code> crashing, and you might even find that on some runs it doesn’t crash at all.</p> <p>Here’s what’s happening: suppose that producer A finishes first. It exits, and its <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> block closes the <code class="docutils literal notranslate"><span class="pre">send_channel</span></code>. But wait! Producer B was still using that <code class="docutils literal notranslate"><span class="pre">send_channel</span></code>… so the next time B calls <code class="docutils literal notranslate"><span class="pre">send</span></code>, it gets a <a class="reference internal" href="#trio.ClosedResourceError" title="trio.ClosedResourceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ClosedResourceError</span></code></a>.</p> <p>Sometimes, though if we’re lucky, the two producers might finish at the same time (or close enough), so they both make their last <code class="docutils literal notranslate"><span class="pre">send</span></code> before either of them closes the <code class="docutils literal notranslate"><span class="pre">send_channel</span></code>.</p> <p>But, even if that happens, we’re not out of the woods yet! After the producers exit, the two consumers race to be the first to notice that the <code class="docutils literal notranslate"><span class="pre">send_channel</span></code> has closed. Suppose that X wins the race. It exits its <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> loop, then exits the <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> block… and closes the <code class="docutils literal notranslate"><span class="pre">receive_channel</span></code>, while Y is still using it. Again, this causes a crash.</p> <p>We could avoid this by using some complicated bookkeeping to make sure that only the <em>last</em> producer and the <em>last</em> consumer close their channel endpoints… but that would be tiresome and fragile. Fortunately, there’s a better way! Here’s a fixed version of our program above:</p> <pre data-language="python">import trio
import random

async def main():
    async with trio.open_nursery() as nursery:
        send_channel, receive_channel = trio.open_memory_channel(0)
        async with send_channel, receive_channel:
            # Start two producers, giving each its own private clone
            nursery.start_soon(producer, "A", send_channel.clone())
            nursery.start_soon(producer, "B", send_channel.clone())
            # And two consumers, giving each its own private clone
            nursery.start_soon(consumer, "X", receive_channel.clone())
            nursery.start_soon(consumer, "Y", receive_channel.clone())

async def producer(name, send_channel):
    async with send_channel:
        for i in range(3):
            await send_channel.send("{} from producer {}".format(i, name))
            # Random sleeps help trigger the problem more reliably
            await trio.sleep(random.random())

async def consumer(name, receive_channel):
    async with receive_channel:
        async for value in receive_channel:
            print("consumer {} got value {!r}".format(name, value))
            # Random sleeps help trigger the problem more reliably
            await trio.sleep(random.random())

trio.run(main)</pre> <p>This example demonstrates using the <a class="reference internal" href="#trio.MemorySendChannel.clone" title="trio.MemorySendChannel.clone"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MemorySendChannel.clone</span></code></a> and <a class="reference internal" href="#trio.MemoryReceiveChannel.clone" title="trio.MemoryReceiveChannel.clone"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MemoryReceiveChannel.clone</span></code></a> methods. What these do is create copies of our endpoints, that act just like the original – except that they can be closed independently. And the underlying channel is only closed after <em>all</em> the clones have been closed. So this completely solves our problem with shutdown, and if you run this program, you’ll see it print its six lines of output and then exits cleanly.</p> <p>Notice a small trick we use: the code in <code class="docutils literal notranslate"><span class="pre">main</span></code> creates clone objects to pass into all the child tasks, and then closes the original objects using <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code>. Another option is to pass clones into all-but-one of the child tasks, and then pass the original object into the last task, like:</p> <pre data-language="python"># Also works, but is more finicky:
send_channel, receive_channel = trio.open_memory_channel(0)
nursery.start_soon(producer, "A", send_channel.clone())
nursery.start_soon(producer, "B", send_channel)
nursery.start_soon(consumer, "X", receive_channel.clone())
nursery.start_soon(consumer, "Y", receive_channel)</pre> <p>But this is more error-prone, especially if you use a loop to spawn the producers/consumers.</p> <p>Just make sure that you don’t write:</p> <pre data-language="python"># Broken, will cause program to hang:
send_channel, receive_channel = trio.open_memory_channel(0)
nursery.start_soon(producer, "A", send_channel.clone())
nursery.start_soon(producer, "B", send_channel.clone())
nursery.start_soon(consumer, "X", receive_channel.clone())
nursery.start_soon(consumer, "Y", receive_channel.clone())</pre> <p>Here we pass clones into the tasks, but never close the original objects. That means we have 3 send channel objects (the original + two clones), but we only close 2 of them, so the consumers will hang around forever waiting for that last one to be closed.</p>   <h4>Buffering in channels</h4> <p>When you call <a class="reference internal" href="#trio.open_memory_channel" title="trio.open_memory_channel"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_memory_channel()</span></code></a>, you have to specify how many values can be buffered internally in the channel. If the buffer is full, then any task that calls <a class="reference internal" href="reference-io#trio.abc.SendChannel.send" title="trio.abc.SendChannel.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> will stop and wait for another task to call <a class="reference internal" href="reference-io#trio.abc.ReceiveChannel.receive" title="trio.abc.ReceiveChannel.receive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">receive()</span></code></a>. This is useful because it produces <em>backpressure</em>: if the channel producers are running faster than the consumers, then it forces the producers to slow down.</p> <p>You can disable buffering entirely, by doing <code class="docutils literal notranslate"><span class="pre">open_memory_channel(0)</span></code>. In that case any task calls <a class="reference internal" href="reference-io#trio.abc.SendChannel.send" title="trio.abc.SendChannel.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> will wait until another task calls <a class="reference internal" href="reference-io#trio.abc.ReceiveChannel.receive" title="trio.abc.ReceiveChannel.receive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">receive()</span></code></a>, and vice versa. This is similar to how channels work in the <a class="reference external" href="https://en.wikipedia.org/wiki/Channel_(programming)">classic Communicating Sequential Processes model</a>, and is a reasonable default if you aren’t sure what size buffer to use. (That’s why we used it in the examples above.)</p> <p>At the other extreme, you can make the buffer unbounded by using <code class="docutils literal notranslate"><span class="pre">open_memory_channel(math.inf)</span></code>. In this case, <a class="reference internal" href="reference-io#trio.abc.SendChannel.send" title="trio.abc.SendChannel.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> <em>always</em> returns immediately. Normally, this is a bad idea. To see why, consider a program where the producer runs more quickly than the consumer:</p> <pre data-language="python"># Simulate a producer that generates values 10x faster than the
# consumer can handle them.

import trio
import math

async def producer(send_channel):
    count = 0
    while True:
        # Pretend that we have to do some work to create this message, and it
        # takes 0.1 seconds:
        await trio.sleep(0.1)
        await send_channel.send(count)
        print("Sent message:", count)
        count += 1

async def consumer(receive_channel):
    async for value in receive_channel:
        print("Received message:", value)
        # Pretend that we have to do some work to handle this message, and it
        # takes 1 second
        await trio.sleep(1)

async def main():
    send_channel, receive_channel = trio.open_memory_channel(math.inf)
    async with trio.open_nursery() as nursery:
        nursery.start_soon(producer, send_channel)
        nursery.start_soon(consumer, receive_channel)

trio.run(main)</pre> <p>If you run this program, you’ll see output like:</p> <pre>Sent message: 0
Received message: 0
Sent message: 1
Sent message: 2
Sent message: 3
Sent message: 4
Sent message: 5
Sent message: 6
Sent message: 7
Sent message: 8
Sent message: 9
Received message: 1
Sent message: 10
Sent message: 11
Sent message: 12
...</pre> <p>On average, the producer sends ten messages per second, but the consumer only calls <code class="docutils literal notranslate"><span class="pre">receive</span></code> once per second. That means that each second, the channel’s internal buffer has to grow to hold an extra nine items. After a minute, the buffer will have ~540 items in it; after an hour, that grows to ~32,400. Eventually, the program will run out of memory. And well before we run out of memory, our latency on handling individual messages will become abysmal. For example, at the one minute mark, the producer is sending message ~600, but the producer is still processing message ~60. Message 600 will have to sit in the channel for ~9 minutes before the consumer catches up and processes it.</p> <p>Now try replacing <code class="docutils literal notranslate"><span class="pre">open_memory_channel(math.inf)</span></code> with <code class="docutils literal notranslate"><span class="pre">open_memory_channel(0)</span></code>, and run it again. We get output like:</p> <pre>Sent message: 0
Received message: 0
Received message: 1
Sent message: 1
Received message: 2
Sent message: 2
Sent message: 3
Received message: 3
...</pre> <p>Now the <code class="docutils literal notranslate"><span class="pre">send</span></code> calls wait for the <code class="docutils literal notranslate"><span class="pre">receive</span></code> calls to finish, which forces the producer to slow down to match the consumer’s speed. (It might look strange that some values are reported as “Received” before they’re reported as “Sent”; this happens because the actual send/receive happen at the same time, so which line gets printed first is random.)</p> <p>Now, let’s try setting a small but nonzero buffer size, like <code class="docutils literal notranslate"><span class="pre">open_memory_channel(3)</span></code>. what do you think will happen?</p> <p>I get:</p> <pre>Sent message: 0
Received message: 0
Sent message: 1
Sent message: 2
Sent message: 3
Received message: 1
Sent message: 4
Received message: 2
Sent message: 5
...</pre> <p>So you can see that the producer runs ahead by 3 messages, and then stops to wait: when the consumer reads message 1, it sends message 4, then when the consumer reads message 2, it sends message 5, and so on. Once it reaches the steady state, this version acts just like our previous version where we set the buffer size to 0, except that it uses a bit more memory and each message sits in the buffer for a bit longer before being processed (i.e., the message latency is higher).</p> <p>Of course real producers and consumers are usually more complicated than this, and in some situations, a modest amount of buffering might improve throughput. But too much buffering wastes memory and increases latency, so if you want to tune your application you should experiment to see what value works best for you.</p> <p><strong>Why do we even support unbounded buffers then?</strong> Good question! Despite everything we saw above, there are times when you actually do need an unbounded buffer. For example, consider a web crawler that uses a channel to keep track of all the URLs it still wants to crawl. Each crawler runs a loop where it takes a URL from the channel, fetches it, checks the HTML for outgoing links, and then adds the new URLs to the channel. This creates a <em>circular flow</em>, where each consumer is also a producer. In this case, if your channel buffer gets full, then the crawlers will block when they try to add new URLs to the channel, and if all the crawlers got blocked, then they aren’t taking any URLs out of the channel, so they’re stuck forever in a deadlock. Using an unbounded channel avoids this, because it means that <a class="reference internal" href="reference-io#trio.abc.SendChannel.send" title="trio.abc.SendChannel.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> never blocks.</p>    <h3>Lower-level synchronization primitives</h3> <p>Personally, I find that events and channels are usually enough to implement most things I care about, and lead to easier to read code than the lower-level primitives discussed in this section. But if you need them, they’re here. (If you find yourself reaching for these because you’re trying to implement a new higher-level synchronization primitive, then you might also want to check out the facilities in <a class="reference internal" href="reference-hazmat#module-trio.hazmat" title="trio.hazmat"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.hazmat</span></code></a> for a more direct exposure of Trio’s underlying synchronization logic. All of classes discussed in this section are implemented on top of the public APIs in <a class="reference internal" href="reference-hazmat#module-trio.hazmat" title="trio.hazmat"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.hazmat</span></code></a>; they don’t have any special access to Trio’s internals.)</p> <dl class="class"> <h3 id="trio.CapacityLimiter"><code><em>class</em> trio.CapacityLimiter(total_tokens)</code></h3> <dd>
<p>An object for controlling access to a resource with limited capacity.</p> <p>Sometimes you need to put a limit on how many tasks can do something at the same time. For example, you might want to use some threads to run multiple blocking I/O operations in parallel… but if you use too many threads at once, then your system can become overloaded and it’ll actually make things slower. One popular solution is to impose a policy like “run up to 40 threads at the same time, but no more”. But how do you implement a policy like this?</p> <p>That’s what <a class="reference internal" href="#trio.CapacityLimiter" title="trio.CapacityLimiter"><code class="xref py py-class docutils literal notranslate"><span class="pre">CapacityLimiter</span></code></a> is for. You can think of a <a class="reference internal" href="#trio.CapacityLimiter" title="trio.CapacityLimiter"><code class="xref py py-class docutils literal notranslate"><span class="pre">CapacityLimiter</span></code></a> object as a sack that starts out holding some fixed number of tokens:</p> <pre data-language="python">limit = trio.CapacityLimiter(40)</pre> <p>Then tasks can come along and borrow a token out of the sack:</p> <pre data-language="python"># Borrow a token:
async with limit:
    # We are holding a token!
    await perform_expensive_operation()
# Exiting the 'async with' block puts the token back into the sack</pre> <p>And crucially, if you try to borrow a token but the sack is empty, then you have to wait for another task to finish what it’s doing and put its token back first before you can take it and continue.</p> <p>Another way to think of it: a <a class="reference internal" href="#trio.CapacityLimiter" title="trio.CapacityLimiter"><code class="xref py py-class docutils literal notranslate"><span class="pre">CapacityLimiter</span></code></a> is like a sofa with a fixed number of seats, and if they’re all taken then you have to wait for someone to get up before you can sit down.</p> <p>By default, <a class="reference internal" href="#trio.to_thread.run_sync" title="trio.to_thread.run_sync"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.to_thread.run_sync()</span></code></a> uses a <a class="reference internal" href="#trio.CapacityLimiter" title="trio.CapacityLimiter"><code class="xref py py-class docutils literal notranslate"><span class="pre">CapacityLimiter</span></code></a> to limit the number of threads running at once; see <a class="reference internal" href="#trio.to_thread.current_default_thread_limiter" title="trio.to_thread.current_default_thread_limiter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.to_thread.current_default_thread_limiter</span></code></a> for details.</p> <p>If you’re familiar with semaphores, then you can think of this as a restricted semaphore that’s specialized for one common use case, with additional error checking. For a more traditional semaphore, see <a class="reference internal" href="#trio.Semaphore" title="trio.Semaphore"><code class="xref py py-class docutils literal notranslate"><span class="pre">Semaphore</span></code></a>.</p> <blockquote class="admonition note"> <h4 class="admonition-title">Note</h4> <p>Don’t confuse this with the <a class="reference external" href="https://en.wikipedia.org/wiki/Leaky_bucket">“leaky bucket”</a> or <a class="reference external" href="https://en.wikipedia.org/wiki/Token_bucket">“token bucket”</a> algorithms used to limit bandwidth usage on networks. The basic idea of using tokens to track a resource limit is similar, but this is a very simple sack where tokens aren’t automatically created or destroyed over time; they’re just borrowed and then put back.</p> </blockquote> <dl class="method"> <h3 id="trio.CapacityLimiter.acquire"><code><em>await</em> acquire()</code></h3> <dd>
<p>Borrow a token from the sack, blocking if necessary.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Raises</h4> <dd class="field-odd">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.7)"><code>RuntimeError</code></a> – if the current task already holds one of this sack’s tokens.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <h3 id="trio.CapacityLimiter.acquire_nowait"><code>acquire_nowait()</code></h3> <dd>
<p>Borrow a token from the sack, without blocking.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Raises</h4> <dd class="field-odd">
<ul class="simple"> <li><p><a class="reference internal" href="#trio.WouldBlock" title="trio.WouldBlock"><code>WouldBlock</code></a> – if no tokens are available.</p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.7)"><code>RuntimeError</code></a> – if the current task already holds one of this sack’s tokens.</p></li> </ul> </dd> </dl> </dd>
</dl> <dl class="method"> <h3 id="trio.CapacityLimiter.acquire_on_behalf_of"><code><em>await</em> acquire_on_behalf_of(borrower)</code></h3> <dd>
<p>Borrow a token from the sack on behalf of <code class="docutils literal notranslate"><span class="pre">borrower</span></code>, blocking if necessary.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<p><code>borrower</code> – A <a class="reference internal" href="reference-hazmat#trio.hazmat.Task" title="trio.hazmat.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.hazmat.Task</span></code></a> or arbitrary opaque object used to record who is borrowing this token; see <a class="reference internal" href="#trio.CapacityLimiter.acquire_on_behalf_of_nowait" title="trio.CapacityLimiter.acquire_on_behalf_of_nowait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire_on_behalf_of_nowait()</span></code></a> for details.</p> </dd> <h4 class="field-even" style="margin: 0">Raises</h4> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.7)"><code>RuntimeError</code></a> – if <code class="docutils literal notranslate"><span class="pre">borrower</span></code> task already holds one of this sack’s tokens.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <h3 id="trio.CapacityLimiter.acquire_on_behalf_of_nowait"><code>acquire_on_behalf_of_nowait(borrower)</code></h3> <dd>
<p>Borrow a token from the sack on behalf of <code class="docutils literal notranslate"><span class="pre">borrower</span></code>, without blocking.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<p><code>borrower</code> – A <a class="reference internal" href="reference-hazmat#trio.hazmat.Task" title="trio.hazmat.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.hazmat.Task</span></code></a> or arbitrary opaque object used to record who is borrowing this token. This is used by <a class="reference internal" href="#trio.to_thread.run_sync" title="trio.to_thread.run_sync"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.to_thread.run_sync()</span></code></a> to allow threads to “hold tokens”, with the intention in the future of using it to <a class="reference external" href="https://github.com/python-trio/trio/issues/182">allow deadlock detection and other useful things</a></p> </dd> <h4 class="field-even" style="margin: 0">Raises</h4> <dd class="field-even">
<ul class="simple"> <li><p><a class="reference internal" href="#trio.WouldBlock" title="trio.WouldBlock"><code>WouldBlock</code></a> – if no tokens are available.</p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.7)"><code>RuntimeError</code></a> – if <code class="docutils literal notranslate"><span class="pre">borrower</span></code> already holds one of this sack’s tokens.</p></li> </ul> </dd> </dl> </dd>
</dl> <dl class="method"> <h3 id="trio.CapacityLimiter.available_tokens"><code>available_tokens</code></h3> <dd>
<p>The amount of capacity that’s available to use.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.CapacityLimiter.borrowed_tokens"><code>borrowed_tokens</code></h3> <dd>
<p>The amount of capacity that’s currently in use.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.CapacityLimiter.release"><code>release()</code></h3> <dd>
<p>Put a token back into the sack.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Raises</h4> <dd class="field-odd">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.7)"><code>RuntimeError</code></a> – if the current task has not acquired one of this sack’s tokens.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <h3 id="trio.CapacityLimiter.release_on_behalf_of"><code>release_on_behalf_of(borrower)</code></h3> <dd>
<p>Put a token back into the sack on behalf of <code class="docutils literal notranslate"><span class="pre">borrower</span></code>.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Raises</h4> <dd class="field-odd">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.7)"><code>RuntimeError</code></a> – if the given borrower has not acquired one of this sack’s tokens.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <h3 id="trio.CapacityLimiter.statistics"><code>statistics()</code></h3> <dd>
<p>Return an object containing debugging information.</p> <p>Currently the following fields are defined:</p> <ul class="simple"> <li><p><code class="docutils literal notranslate"><span class="pre">borrowed_tokens</span></code>: The number of tokens currently borrowed from the sack.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">total_tokens</span></code>: The total number of tokens in the sack. Usually this will be larger than <code class="docutils literal notranslate"><span class="pre">borrowed_tokens</span></code>, but it’s possibly for it to be smaller if <a class="reference internal" href="#trio.CapacityLimiter.total_tokens" title="trio.CapacityLimiter.total_tokens"><code class="xref py py-attr docutils literal notranslate"><span class="pre">total_tokens</span></code></a> was recently decreased.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">borrowers</span></code>: A list of all tasks or other entities that currently hold a token.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">tasks_waiting</span></code>: The number of tasks blocked on this <a class="reference internal" href="#trio.CapacityLimiter" title="trio.CapacityLimiter"><code class="xref py py-class docutils literal notranslate"><span class="pre">CapacityLimiter</span></code></a>’s <a class="reference internal" href="#trio.CapacityLimiter.acquire" title="trio.CapacityLimiter.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire()</span></code></a> or <a class="reference internal" href="#trio.CapacityLimiter.acquire_on_behalf_of" title="trio.CapacityLimiter.acquire_on_behalf_of"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire_on_behalf_of()</span></code></a> methods.</p></li> </ul> </dd>
</dl> <dl class="method"> <h3 id="trio.CapacityLimiter.total_tokens"><code>total_tokens</code></h3> <dd>
<p>The total capacity available.</p> <p>You can change <a class="reference internal" href="#trio.CapacityLimiter.total_tokens" title="trio.CapacityLimiter.total_tokens"><code class="xref py py-attr docutils literal notranslate"><span class="pre">total_tokens</span></code></a> by assigning to this attribute. If you make it larger, then the appropriate number of waiting tasks will be woken immediately to take the new tokens. If you decrease total_tokens below the number of tasks that are currently using the resource, then all current tasks will be allowed to finish as normal, but no new tasks will be allowed in until the total number of tasks drops below the new total_tokens.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <h3 id="trio.Semaphore"><code><em>class</em> trio.Semaphore(initial_value, *, max_value=None)</code></h3> <dd>
<p>A <a class="reference external" href="https://en.wikipedia.org/wiki/Semaphore_(programming)">semaphore</a>.</p> <p>A semaphore holds an integer value, which can be incremented by calling <a class="reference internal" href="#trio.Semaphore.release" title="trio.Semaphore.release"><code class="xref py py-meth docutils literal notranslate"><span class="pre">release()</span></code></a> and decremented by calling <a class="reference internal" href="#trio.Semaphore.acquire" title="trio.Semaphore.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire()</span></code></a> – but the value is never allowed to drop below zero. If the value is zero, then <a class="reference internal" href="#trio.Semaphore.acquire" title="trio.Semaphore.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire()</span></code></a> will block until someone calls <a class="reference internal" href="#trio.Semaphore.release" title="trio.Semaphore.release"><code class="xref py py-meth docutils literal notranslate"><span class="pre">release()</span></code></a>.</p> <p>If you’re looking for a <a class="reference internal" href="#trio.Semaphore" title="trio.Semaphore"><code class="xref py py-class docutils literal notranslate"><span class="pre">Semaphore</span></code></a> to limit the number of tasks that can access some resource simultaneously, then consider using a <a class="reference internal" href="#trio.CapacityLimiter" title="trio.CapacityLimiter"><code class="xref py py-class docutils literal notranslate"><span class="pre">CapacityLimiter</span></code></a> instead.</p> <p>This object’s interface is similar to, but different from, that of <a class="reference external" href="https://docs.python.org/3/library/threading.html#threading.Semaphore" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Semaphore</span></code></a>.</p> <p>A <a class="reference internal" href="#trio.Semaphore" title="trio.Semaphore"><code class="xref py py-class docutils literal notranslate"><span class="pre">Semaphore</span></code></a> object can be used as an async context manager; it blocks on entry but not on exit.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<ul class="simple"> <li><p><code>initial_value</code> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – A non-negative integer giving semaphore’s initial value.</p></li> <li><p><code>max_value</code> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)"><em>None</em></a>) – If given, makes this a “bounded” semaphore that raises an error if the value is about to exceed the given <code class="docutils literal notranslate"><span class="pre">max_value</span></code>.</p></li> </ul> </dd> </dl> <dl class="method"> <h3 id="trio.Semaphore.acquire"><code><em>await</em> acquire()</code></h3> <dd>
<p>Decrement the semaphore value, blocking if necessary to avoid letting it drop below zero.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Semaphore.acquire_nowait"><code>acquire_nowait()</code></h3> <dd>
<p>Attempt to decrement the semaphore value, without blocking.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Raises</h4> <dd class="field-odd">
<p><a class="reference internal" href="#trio.WouldBlock" title="trio.WouldBlock"><code>WouldBlock</code></a> – if the value is zero.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <h3 id="trio.Semaphore.max_value"><code>max_value</code></h3> <dd>
<p>The maximum allowed value. May be None to indicate no limit.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Semaphore.release"><code>release()</code></h3> <dd>
<p>Increment the semaphore value, possibly waking a task blocked in <a class="reference internal" href="#trio.Semaphore.acquire" title="trio.Semaphore.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire()</span></code></a>.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Raises</h4> <dd class="field-odd">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><code>ValueError</code></a> – if incrementing the value would cause it to exceed <a class="reference internal" href="#trio.Semaphore.max_value" title="trio.Semaphore.max_value"><code class="xref py py-attr docutils literal notranslate"><span class="pre">max_value</span></code></a>.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <h3 id="trio.Semaphore.statistics"><code>statistics()</code></h3> <dd>
<p>Return an object containing debugging information.</p> <p>Currently the following fields are defined:</p> <ul class="simple"> <li><p><code class="docutils literal notranslate"><span class="pre">tasks_waiting</span></code>: The number of tasks blocked on this semaphore’s <a class="reference internal" href="#trio.Semaphore.acquire" title="trio.Semaphore.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire()</span></code></a> method.</p></li> </ul> </dd>
</dl> <dl class="method"> <h3 id="trio.Semaphore.value"><code>value</code></h3> <dd>
<p>The current value of the semaphore.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <h3 id="trio.Lock"><code><em>class</em> trio.Lock</code></h3> <dd>
<p>A classic <a class="reference external" href="https://en.wikipedia.org/wiki/Lock_(computer_science)">mutex</a>.</p> <p>This is a non-reentrant, single-owner lock. Unlike <a class="reference external" href="https://docs.python.org/3/library/threading.html#threading.Lock" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Lock</span></code></a>, only the owner of the lock is allowed to release it.</p> <p>A <a class="reference internal" href="#trio.Lock" title="trio.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lock</span></code></a> object can be used as an async context manager; it blocks on entry but not on exit.</p> <dl class="method"> <h3 id="trio.Lock.acquire"><code><em>await</em> acquire()</code></h3> <dd>
<p>Acquire the lock, blocking if necessary.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Lock.acquire_nowait"><code>acquire_nowait()</code></h3> <dd>
<p>Attempt to acquire the lock, without blocking.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Raises</h4> <dd class="field-odd">
<p><a class="reference internal" href="#trio.WouldBlock" title="trio.WouldBlock"><code>WouldBlock</code></a> – if the lock is held.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <h3 id="trio.Lock.locked"><code>locked()</code></h3> <dd>
<p>Check whether the lock is currently held.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Returns</h4> <dd class="field-odd">
<p>True if the lock is held, False otherwise.</p> </dd> <h4 class="field-even" style="margin: 0">Return type</h4> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)">bool</a></p> </dd> </dl> </dd>
</dl> <dl class="method"> <h3 id="trio.Lock.release"><code>release()</code></h3> <dd>
<p>Release the lock.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Raises</h4> <dd class="field-odd">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.7)"><code>RuntimeError</code></a> – if the calling task does not hold the lock.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <h3 id="trio.Lock.statistics"><code>statistics()</code></h3> <dd>
<p>Return an object containing debugging information.</p> <p>Currently the following fields are defined:</p> <ul class="simple"> <li><p><code class="docutils literal notranslate"><span class="pre">locked</span></code>: boolean indicating whether the lock is held.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">owner</span></code>: the <a class="reference internal" href="reference-hazmat#trio.hazmat.Task" title="trio.hazmat.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.hazmat.Task</span></code></a> currently holding the lock, or None if the lock is not held.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">tasks_waiting</span></code>: The number of tasks blocked on this lock’s <a class="reference internal" href="#trio.Lock.acquire" title="trio.Lock.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire()</span></code></a> method.</p></li> </ul> </dd>
</dl> </dd>
</dl> <dl class="class"> <h3 id="trio.StrictFIFOLock"><code><em>class</em> trio.StrictFIFOLock</code></h3> <dd>
<p>A variant of <a class="reference internal" href="#trio.Lock" title="trio.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lock</span></code></a> where tasks are guaranteed to acquire the lock in strict first-come-first-served order.</p> <p>An example of when this is useful is if you’re implementing something like <a class="reference internal" href="reference-io#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.SSLStream</span></code></a> or an HTTP/2 server using <a class="reference external" href="https://hyper-h2.readthedocs.io/">h2</a>, where you have multiple concurrent tasks that are interacting with a shared state machine, and at unpredictable moments the state machine requests that a chunk of data be sent over the network. (For example, when using h2 simply reading incoming data can occasionally <a class="reference external" href="https://http2.github.io/http2-spec/#PING">create outgoing data to send</a>.) The challenge is to make sure that these chunks are sent in the correct order, without being garbled.</p> <p>One option would be to use a regular <a class="reference internal" href="#trio.Lock" title="trio.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lock</span></code></a>, and wrap it around every interaction with the state machine:</p> <pre data-language="python"># This approach is sometimes workable but often sub-optimal; see below
async with lock:
    state_machine.do_something()
    if state_machine.has_data_to_send():
        await conn.sendall(state_machine.get_data_to_send())</pre> <p>But this can be problematic. If you’re using h2 then <em>usually</em> reading incoming data doesn’t create the need to send any data, so we don’t want to force every task that tries to read from the network to sit and wait a potentially long time for <code class="docutils literal notranslate"><span class="pre">sendall</span></code> to finish. And in some situations this could even potentially cause a deadlock, if the remote peer is waiting for you to read some data before it accepts the data you’re sending.</p> <p><a class="reference internal" href="#trio.StrictFIFOLock" title="trio.StrictFIFOLock"><code class="xref py py-class docutils literal notranslate"><span class="pre">StrictFIFOLock</span></code></a> provides an alternative. We can rewrite our example like:</p> <pre data-language="python"># Note: no awaits between when we start using the state machine and
# when we block to take the lock!
state_machine.do_something()
if state_machine.has_data_to_send():
    # Notice that we fetch the data to send out of the state machine
    # *before* sleeping, so that other tasks won't see it.
    chunk = state_machine.get_data_to_send()
    async with strict_fifo_lock:
        await conn.sendall(chunk)</pre> <p>First we do all our interaction with the state machine in a single scheduling quantum (notice there are no <code class="docutils literal notranslate"><span class="pre">await</span></code>s in there), so it’s automatically atomic with respect to other tasks. And then if and only if we have data to send, we get in line to send it – and <a class="reference internal" href="#trio.StrictFIFOLock" title="trio.StrictFIFOLock"><code class="xref py py-class docutils literal notranslate"><span class="pre">StrictFIFOLock</span></code></a> guarantees that each task will send its data in the same order that the state machine generated it.</p> <p>Currently, <a class="reference internal" href="#trio.StrictFIFOLock" title="trio.StrictFIFOLock"><code class="xref py py-class docutils literal notranslate"><span class="pre">StrictFIFOLock</span></code></a> is simply an alias for <a class="reference internal" href="#trio.Lock" title="trio.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lock</span></code></a>, but (a) this may not always be true in the future, especially if Trio ever implements <a class="reference external" href="https://github.com/python-trio/trio/issues/32">more sophisticated scheduling policies</a>, and (b) the above code is relying on a pretty subtle property of its lock. Using a <a class="reference internal" href="#trio.StrictFIFOLock" title="trio.StrictFIFOLock"><code class="xref py py-class docutils literal notranslate"><span class="pre">StrictFIFOLock</span></code></a> acts as an executable reminder that you’re relying on this property.</p> </dd>
</dl> <dl class="class"> <h3 id="trio.Condition"><code><em>class</em> trio.Condition(lock=None)</code></h3> <dd>
<p>A classic <a class="reference external" href="https://en.wikipedia.org/wiki/Monitor_(synchronization)">condition variable</a>, similar to <a class="reference external" href="https://docs.python.org/3/library/threading.html#threading.Condition" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Condition</span></code></a>.</p> <p>A <a class="reference internal" href="#trio.Condition" title="trio.Condition"><code class="xref py py-class docutils literal notranslate"><span class="pre">Condition</span></code></a> object can be used as an async context manager to acquire the underlying lock; it blocks on entry but not on exit.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<p><code>lock</code> (<a class="reference internal" href="#trio.Lock" title="trio.Lock"><em>Lock</em></a>) – the lock object to use. If given, must be a <a class="reference internal" href="#trio.Lock" title="trio.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.Lock</span></code></a>. If None, a new <a class="reference internal" href="#trio.Lock" title="trio.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lock</span></code></a> will be allocated and used.</p> </dd> </dl> <dl class="method"> <h3 id="trio.Condition.acquire"><code><em>await</em> acquire()</code></h3> <dd>
<p>Acquire the underlying lock, blocking if necessary.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Condition.acquire_nowait"><code>acquire_nowait()</code></h3> <dd>
<p>Attempt to acquire the underlying lock, without blocking.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Raises</h4> <dd class="field-odd">
<p><a class="reference internal" href="#trio.WouldBlock" title="trio.WouldBlock"><code>WouldBlock</code></a> – if the lock is currently held.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <h3 id="trio.Condition.locked"><code>locked()</code></h3> <dd>
<p>Check whether the underlying lock is currently held.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Returns</h4> <dd class="field-odd">
<p>True if the lock is held, False otherwise.</p> </dd> <h4 class="field-even" style="margin: 0">Return type</h4> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)">bool</a></p> </dd> </dl> </dd>
</dl> <dl class="method"> <h3 id="trio.Condition.notify"><code>notify(n=1)</code></h3> <dd>
<p>Wake one or more tasks that are blocked in <a class="reference internal" href="#trio.Condition.wait" title="trio.Condition.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a>.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<p><code>n</code> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – The number of tasks to wake.</p> </dd> <h4 class="field-even" style="margin: 0">Raises</h4> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.7)"><code>RuntimeError</code></a> – if the calling task does not hold the lock.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <h3 id="trio.Condition.notify_all"><code>notify_all()</code></h3> <dd>
<p>Wake all tasks that are currently blocked in <a class="reference internal" href="#trio.Condition.wait" title="trio.Condition.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a>.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Raises</h4> <dd class="field-odd">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.7)"><code>RuntimeError</code></a> – if the calling task does not hold the lock.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <h3 id="trio.Condition.release"><code>release()</code></h3> <dd>
<p>Release the underlying lock.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.Condition.statistics"><code>statistics()</code></h3> <dd>
<p>Return an object containing debugging information.</p> <p>Currently the following fields are defined:</p> <ul class="simple"> <li><p><code class="docutils literal notranslate"><span class="pre">tasks_waiting</span></code>: The number of tasks blocked on this condition’s <a class="reference internal" href="#trio.Condition.wait" title="trio.Condition.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a> method.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">lock_statistics</span></code>: The result of calling the underlying <a class="reference internal" href="#trio.Lock" title="trio.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lock</span></code></a>s <a class="reference internal" href="#trio.Lock.statistics" title="trio.Lock.statistics"><code class="xref py py-meth docutils literal notranslate"><span class="pre">statistics()</span></code></a> method.</p></li> </ul> </dd>
</dl> <dl class="method"> <h3 id="trio.Condition.wait"><code><em>await</em> wait()</code></h3> <dd>
<p>Wait for another thread to call <a class="reference internal" href="#trio.Condition.notify" title="trio.Condition.notify"><code class="xref py py-meth docutils literal notranslate"><span class="pre">notify()</span></code></a> or <a class="reference internal" href="#trio.Condition.notify_all" title="trio.Condition.notify_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">notify_all()</span></code></a>.</p> <p>When calling this method, you must hold the lock. It releases the lock while waiting, and then re-acquires it before waking up.</p> <p>There is a subtlety with how this method interacts with cancellation: when cancelled it will block to re-acquire the lock before raising <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a>. This may cause cancellation to be less prompt than expected. The advantage is that it makes code like this work:</p> <pre data-language="python">async with condition:
    await condition.wait()</pre> <p>If we didn’t re-acquire the lock before waking up, and <a class="reference internal" href="#trio.Condition.wait" title="trio.Condition.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a> were cancelled here, then we’d crash in <code class="docutils literal notranslate"><span class="pre">condition.__aexit__</span></code> when we tried to release the lock we no longer held.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Raises</h4> <dd class="field-odd">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.7)"><code>RuntimeError</code></a> – if the calling task does not hold the lock.</p> </dd> </dl> </dd>
</dl> </dd>
</dl>    <h2>Threads (if you must)</h2> <p>In a perfect world, all third-party libraries and low-level APIs would be natively async and integrated into Trio, and all would be happiness and rainbows.</p> <p>That world, alas, does not (yet) exist. Until it does, you may find yourself needing to interact with non-Trio APIs that do rude things like “blocking”.</p> <p>In acknowledgment of this reality, Trio provides two useful utilities for working with real, operating-system level, <a class="reference external" href="https://docs.python.org/3/library/threading.html#module-threading" title="(in Python v3.7)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a>-module-style threads. First, if you’re in Trio but need to push some blocking I/O into a thread, there’s <a class="reference internal" href="#trio.to_thread.run_sync" title="trio.to_thread.run_sync"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.to_thread.run_sync</span></code></a>. And if you’re in a thread and need to communicate back with Trio, you can use <a class="reference internal" href="#trio.from_thread.run" title="trio.from_thread.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.from_thread.run()</span></code></a> and <a class="reference internal" href="#trio.from_thread.run_sync" title="trio.from_thread.run_sync"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.from_thread.run_sync()</span></code></a>.</p>  <h3>Trio’s philosophy about managing worker threads</h3> <p>If you’ve used other I/O frameworks, you may have encountered the concept of a “thread pool”, which is most commonly implemented as a fixed size collection of threads that hang around waiting for jobs to be assigned to them. These solve two different problems: First, re-using the same threads over and over is more efficient than starting and stopping a new thread for every job you need done; basically, the pool acts as a kind of cache for idle threads. And second, having a fixed size avoids getting into a situation where 100,000 jobs are submitted simultaneously, and then 100,000 threads are spawned and the system gets overloaded and crashes. Instead, the N threads start executing the first N jobs, while the other (100,000 - N) jobs sit in a queue and wait their turn. Which is generally what you want, and this is how <a class="reference internal" href="#trio.to_thread.run_sync" title="trio.to_thread.run_sync"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.to_thread.run_sync()</span></code></a> works by default.</p> <p>The downside of this kind of thread pool is that sometimes, you need more sophisticated logic for controlling how many threads are run at once. For example, you might want a policy like “at most 20 threads total, but no more than 3 of those can be running jobs associated with the same user account”, or you might want a pool whose size is dynamically adjusted over time in response to system conditions.</p> <p>It’s even possible for a fixed-size policy to cause unexpected <a class="reference external" href="https://en.wikipedia.org/wiki/Deadlock">deadlocks</a>. Imagine a situation where we have two different types of blocking jobs that you want to run in the thread pool, type A and type B. Type A is pretty simple: it just runs and completes pretty quickly. But type B is more complicated: it has to stop in the middle and wait for some other work to finish, and that other work includes running a type A job. Now, suppose you submit N jobs of type B to the pool. They all start running, and then eventually end up submitting one or more jobs of type A. But since every thread in our pool is already busy, the type A jobs don’t actually start running – they just sit in a queue waiting for the type B jobs to finish. But the type B jobs will never finish, because they’re waiting for the type A jobs. Our system has deadlocked. The ideal solution to this problem is to avoid having type B jobs in the first place – generally it’s better to keep complex synchronization logic in the main Trio thread. But if you can’t do that, then you need a custom thread allocation policy that tracks separate limits for different types of jobs, and make it impossible for type B jobs to fill up all the slots that type A jobs need to run.</p> <p>So, we can see that it’s important to be able to change the policy controlling the allocation of threads to jobs. But in many frameworks, this requires implementing a new thread pool from scratch, which is highly non-trivial; and if different types of jobs need different policies, then you may have to create multiple pools, which is inefficient because now you effectively have two different thread caches that aren’t sharing resources.</p> <p>Trio’s solution to this problem is to split worker thread management into two layers. The lower layer is responsible for taking blocking I/O jobs and arranging for them to run immediately on some worker thread. It takes care of solving the tricky concurrency problems involved in managing threads and is responsible for optimizations like re-using threads, but has no admission control policy: if you give it 100,000 jobs, it will spawn 100,000 threads. The upper layer is responsible for providing the policy to make sure that this doesn’t happen – but since it <em>only</em> has to worry about policy, it can be much simpler. In fact, all there is to it is the <code class="docutils literal notranslate"><span class="pre">limiter=</span></code> argument passed to <a class="reference internal" href="#trio.to_thread.run_sync" title="trio.to_thread.run_sync"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.to_thread.run_sync()</span></code></a>. This defaults to a global <a class="reference internal" href="#trio.CapacityLimiter" title="trio.CapacityLimiter"><code class="xref py py-class docutils literal notranslate"><span class="pre">CapacityLimiter</span></code></a> object, which gives us the classic fixed-size thread pool behavior. (See <a class="reference internal" href="#trio.to_thread.current_default_thread_limiter" title="trio.to_thread.current_default_thread_limiter"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.to_thread.current_default_thread_limiter()</span></code></a>.) But if you want to use “separate pools” for type A jobs and type B jobs, then it’s just a matter of creating two separate <a class="reference internal" href="#trio.CapacityLimiter" title="trio.CapacityLimiter"><code class="xref py py-class docutils literal notranslate"><span class="pre">CapacityLimiter</span></code></a> objects and passing them in when running these jobs. Or here’s an example of defining a custom policy that respects the global thread limit, while making sure that no individual user can use more than 3 threads at a time:</p> <pre data-language="python">class CombinedLimiter:
     def __init__(self, first, second):
         self._first = first
         self._second = second

     async def acquire_on_behalf_of(self, borrower):
         # Acquire both, being careful to clean up properly on error
         await self._first.acquire_on_behalf_of(borrower)
         try:
             await self._second.acquire_on_behalf_of(borrower)
         except:
             self._first.release_on_behalf_of(borrower)
             raise

     def release_on_behalf_of(self, borrower):
         # Release both, being careful to clean up properly on error
         try:
             self._second.release_on_behalf_of(borrower)
         finally:
             self._first.release_on_behalf_of(borrower)


# Use a weak value dictionary, so that we don't waste memory holding
# limiter objects for users who don't have any worker threads running.
USER_LIMITERS = weakref.WeakValueDictionary()
MAX_THREADS_PER_USER = 3

def get_user_limiter(user_id):
    try:
        return USER_LIMITERS[user_id]
    except KeyError:
        per_user_limiter = trio.CapacityLimiter(MAX_THREADS_PER_USER)
        global_limiter = trio.current_default_thread_limiter()
        # IMPORTANT: acquire the per_user_limiter before the global_limiter.
        # If we get 100 jobs for a user at the same time, we want
        # to only allow 3 of them at a time to even compete for the
        # global thread slots.
        combined_limiter = CombinedLimiter(per_user_limiter, global_limiter)
        USER_LIMITERS[user_id] = combined_limiter
        return combined_limiter


async def run_sync_in_thread_for_user(user_id, sync_fn, *args):
    kwargs["limiter"] = get_user_limiter(user_id)
    return await trio.to_thread.run_sync(asycn_fn, *args)</pre>   <h3>Putting blocking I/O into worker threads</h3> <dl class="function"> <h3 id="trio.to_thread.run_sync"><code><em>await</em> trio.to_thread.run_sync(sync_fn, *args, cancellable=False, limiter=None)</code></h3> <dd>
<p>Convert a blocking operation into an async operation using a thread.</p> <p>These two lines are equivalent:</p> <pre data-language="python">sync_fn(*args)
await trio.to_thread.run_sync(sync_fn, *args)</pre> <p>except that if <code class="docutils literal notranslate"><span class="pre">sync_fn</span></code> takes a long time, then the first line will block the Trio loop while it runs, while the second line allows other Trio tasks to continue working while <code class="docutils literal notranslate"><span class="pre">sync_fn</span></code> runs. This is accomplished by pushing the call to <code class="docutils literal notranslate"><span class="pre">sync_fn(*args)</span></code> off into a worker thread.</p> <p>From inside the worker thread, you can get back into Trio using the functions in <a class="reference internal" href="#module-trio.from_thread" title="trio.from_thread"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.from_thread</span></code></a>.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<ul class="simple"> <li><p><code>sync_fn</code> – An arbitrary synchronous callable.</p></li> <li><p><code>*args</code> – Positional arguments to pass to sync_fn. If you need keyword arguments, use <a class="reference external" href="https://docs.python.org/3/library/functools.html#functools.partial" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a>.</p></li> <li><p><code>cancellable</code> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – Whether to allow cancellation of this operation. See discussion below.</p></li> <li>
<p><code>limiter</code> (<a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)"><em>None</em></a><em>, or </em><em>CapacityLimiter-like object</em>) – </p>
<p>An object used to limit the number of simultaneous threads. Most commonly this will be a <a class="reference internal" href="#trio.CapacityLimiter" title="trio.CapacityLimiter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CapacityLimiter</span></code></a>, but it could be anything providing compatible <a class="reference internal" href="#trio.CapacityLimiter.acquire_on_behalf_of" title="trio.CapacityLimiter.acquire_on_behalf_of"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire_on_behalf_of()</span></code></a> and <a class="reference internal" href="#trio.CapacityLimiter.release_on_behalf_of" title="trio.CapacityLimiter.release_on_behalf_of"><code class="xref py py-meth docutils literal notranslate"><span class="pre">release_on_behalf_of()</span></code></a> methods. This function will call <code class="docutils literal notranslate"><span class="pre">acquire_on_behalf_of</span></code> before starting the thread, and <code class="docutils literal notranslate"><span class="pre">release_on_behalf_of</span></code> after the thread has finished.</p> <p>If None (the default), uses the default <a class="reference internal" href="#trio.CapacityLimiter" title="trio.CapacityLimiter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CapacityLimiter</span></code></a>, as returned by <a class="reference internal" href="#trio.to_thread.current_default_thread_limiter" title="trio.to_thread.current_default_thread_limiter"><code class="xref py py-func docutils literal notranslate"><span class="pre">current_default_thread_limiter()</span></code></a>.</p> </li> </ul> </dd> </dl> <p><strong>Cancellation handling</strong>: Cancellation is a tricky issue here, because neither Python nor the operating systems it runs on provide any general mechanism for cancelling an arbitrary synchronous function running in a thread. This function will always check for cancellation on entry, before starting the thread. But once the thread is running, there are two ways it can handle being cancelled:</p> <ul> <li><p>If <code class="docutils literal notranslate"><span class="pre">cancellable=False</span></code>, the function ignores the cancellation and keeps going, just like if we had called <code class="docutils literal notranslate"><span class="pre">sync_fn</span></code> synchronously. This is the default behavior.</p></li> <li>
<p>If <code class="docutils literal notranslate"><span class="pre">cancellable=True</span></code>, then this function immediately raises <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Cancelled</span></code></a>. In this case <strong>the thread keeps running in background</strong> – we just abandon it to do whatever it’s going to do, and silently discard any return value or errors that it raises. Only use this if you know that the operation is safe and side-effect free. (For example: <a class="reference internal" href="reference-io#trio.socket.getaddrinfo" title="trio.socket.getaddrinfo"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.socket.getaddrinfo()</span></code></a> is uses a thread with <code class="docutils literal notranslate"><span class="pre">cancellable=True</span></code>, because it doesn’t really affect anything if a stray hostname lookup keeps running in the background.)</p> <p>The <code class="docutils literal notranslate"><span class="pre">limiter</span></code> is only released after the thread has <em>actually</em> finished – which in the case of cancellation may be some time after this function has returned. If <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> finishes before the thread does, then the limiter release method will never be called at all.</p> </li> </ul> <blockquote class="admonition warning"> <h4 class="admonition-title">Warning</h4> <p>You should not use this function to call long-running CPU-bound functions! In addition to the usual GIL-related reasons why using threads for CPU-bound work is not very effective in Python, there is an additional problem: on CPython, <a class="reference external" href="https://bugs.python.org/issue7946">CPU-bound threads tend to “starve out” IO-bound threads</a>, so using threads for CPU-bound work is likely to adversely affect the main thread running Trio. If you need to do this, you’re better off using a worker process, or perhaps PyPy (which still has a GIL, but may do a better job of fairly allocating CPU time between threads).</p> </blockquote> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Returns</h4> <dd class="field-odd">
<p>Whatever <code class="docutils literal notranslate"><span class="pre">sync_fn(*args)</span></code> returns.</p> </dd> <h4 class="field-even" style="margin: 0">Raises</h4> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#Exception" title="(in Python v3.7)"><code>Exception</code></a> – Whatever <code class="docutils literal notranslate"><span class="pre">sync_fn(*args)</span></code> raises.</p> </dd> </dl> </dd>
</dl> <dl class="function"> <h3 id="trio.to_thread.current_default_thread_limiter"><code>trio.to_thread.current_default_thread_limiter()</code></h3> <dd>
<p>Get the default <a class="reference internal" href="#trio.CapacityLimiter" title="trio.CapacityLimiter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CapacityLimiter</span></code></a> used by <a class="reference internal" href="#trio.to_thread.run_sync" title="trio.to_thread.run_sync"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.to_thread.run_sync</span></code></a>.</p> <p>The most common reason to call this would be if you want to modify its <a class="reference internal" href="#trio.CapacityLimiter.total_tokens" title="trio.CapacityLimiter.total_tokens"><code class="xref py py-attr docutils literal notranslate"><span class="pre">total_tokens</span></code></a> attribute.</p> </dd>
</dl>   <h3>Getting back into the Trio thread from another thread</h3> <dl class="function"> <h3 id="trio.from_thread.run"><code>trio.from_thread.run(afn, *args, trio_token=None)</code></h3> <dd>
<p>Run the given async function in the parent Trio thread, blocking until it is complete.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Returns</h4> <dd class="field-odd">
<p>Whatever <code class="docutils literal notranslate"><span class="pre">afn(*args)</span></code> returns.</p> </dd> </dl> <p>Returns or raises whatever the given function returns or raises. It can also raise exceptions of its own:</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Raises</h4> <dd class="field-odd">
<ul class="simple"> <li><p><a class="reference internal" href="#trio.RunFinishedError" title="trio.RunFinishedError"><code>RunFinishedError</code></a> – if the corresponding call to <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> has already completed.</p></li> <li><p><a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code>Cancelled</code></a> – if the corresponding call to <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> completes while <code class="docutils literal notranslate"><span class="pre">afn(*args)</span></code> is running, then <code class="docutils literal notranslate"><span class="pre">afn</span></code> is likely to raise <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">trio.Cancelled</span></code></a>, and this will propagate out into</p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.7)"><code>RuntimeError</code></a> – if you try calling this from inside the Trio thread, which would otherwise cause a deadlock.</p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#AttributeError" title="(in Python v3.7)"><code>AttributeError</code></a> – if no <code class="docutils literal notranslate"><span class="pre">trio_token</span></code> was provided, and we can’t infer one from context.</p></li> </ul> </dd> </dl> <p><strong>Locating a Trio Token</strong>: There are two ways to specify which <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.run</span></code></a> loop to reenter:</p> <blockquote> <div>
<ul class="simple"> <li><p>Spawn this thread from <a class="reference internal" href="#trio.to_thread.run_sync" title="trio.to_thread.run_sync"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.to_thread.run_sync</span></code></a>. Trio will automatically capture the relevant Trio token and use it when you want to re-enter Trio.</p></li> <li><p>Pass a keyword argument, <code class="docutils literal notranslate"><span class="pre">trio_token</span></code> specifiying a specific <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.run</span></code></a> loop to re-enter. This is useful in case you have a “foreign” thread, spawned using some other framework, and still want to enter Trio.</p></li> </ul> </div>
</blockquote> </dd>
</dl> <dl class="function"> <h3 id="trio.from_thread.run_sync"><code>trio.from_thread.run_sync(fn, *args, trio_token=None)</code></h3> <dd>
<p>Run the given sync function in the parent Trio thread, blocking until it is complete.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Returns</h4> <dd class="field-odd">
<p>Whatever <code class="docutils literal notranslate"><span class="pre">fn(*args)</span></code> returns.</p> </dd> </dl> <p>Returns or raises whatever the given function returns or raises. It can also raise exceptions of its own:</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Raises</h4> <dd class="field-odd">
<ul class="simple"> <li><p><a class="reference internal" href="#trio.RunFinishedError" title="trio.RunFinishedError"><code>RunFinishedError</code></a> – if the corresponding call to <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.run</span></code></a> has already completed.</p></li> <li><p><a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code>Cancelled</code></a> – if the corresponding call to <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.run</span></code></a> completes while <code class="docutils literal notranslate"><span class="pre">afn(*args)</span></code> is running, then <code class="docutils literal notranslate"><span class="pre">afn</span></code> is likely to raise <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">trio.Cancelled</span></code></a>, and this will propagate out into</p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.7)"><code>RuntimeError</code></a> – if you try calling this from inside the Trio thread, which would otherwise cause a deadlock.</p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#AttributeError" title="(in Python v3.7)"><code>AttributeError</code></a> – if no <code class="docutils literal notranslate"><span class="pre">trio_token</span></code> was provided, and we can’t infer one from context.</p></li> </ul> </dd> </dl> <p><strong>Locating a Trio Token</strong>: There are two ways to specify which <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.run</span></code></a> loop to reenter:</p> <blockquote> <div>
<ul class="simple"> <li><p>Spawn this thread from <a class="reference internal" href="#trio.to_thread.run_sync" title="trio.to_thread.run_sync"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.to_thread.run_sync</span></code></a>. Trio will automatically capture the relevant Trio token and use it when you want to re-enter Trio.</p></li> <li><p>Pass a keyword argument, <code class="docutils literal notranslate"><span class="pre">trio_token</span></code> specifiying a specific <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.run</span></code></a> loop to re-enter. This is useful in case you have a “foreign” thread, spawned using some other framework, and still want to enter Trio.</p></li> </ul> </div>
</blockquote> </dd>
</dl> <p>This will probably be clearer with an example. Here we demonstrate how to spawn a child thread, and then use a <a class="reference internal" href="#channels"><span class="std std-ref">memory channel</span></a> to send messages between the thread and a Trio task:</p> <pre data-language="python">import trio


def thread_fn(receive_from_trio, send_to_trio):
    while True:
        # Since we're in a thread, we can't call methods on Trio
        # objects directly -- so we use trio.from_thread to call them.
        try:
            request = trio.from_thread.run(receive_from_trio.receive)
        except trio.EndOfChannel:
            trio.from_thread.run(send_to_trio.aclose)
            return
        else:
            response = request + 1
            trio.from_thread.run(send_to_trio.send, response)


async def main():
    send_to_thread, receive_from_trio = trio.open_memory_channel(0)
    send_to_trio, receive_from_thread = trio.open_memory_channel(0)

    async with trio.open_nursery() as nursery:
        # In a background thread, run:
        #   thread_fn(portal, receive_from_trio, send_to_trio)
        nursery.start_soon(
            trio.to_thread.run_sync, thread_fn, receive_from_trio, send_to_trio
        )

        # prints "1"
        await send_to_thread.send(0)
        print(await receive_from_thread.receive())

        # prints "2"
        await send_to_thread.send(1)
        print(await receive_from_thread.receive())

        # When we close the channel, it signals the thread to exit.
        await send_to_thread.aclose()

        # When we exit the nursery, it waits for the background thread to
        # exit.


trio.run(main)</pre>    <h2>Exceptions and warnings</h2> <dl class="exception"> <h3 id="trio.Cancelled"><code><em>exception</em> trio.Cancelled</code></h3> <dd>
<p>Raised by blocking calls if the surrounding scope has been cancelled.</p> <p>You should let this exception propagate, to be caught by the relevant cancel scope. To remind you of this, it inherits from <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#BaseException" title="(in Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BaseException</span></code></a> instead of <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#Exception" title="(in Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Exception</span></code></a>, just like <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> and <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#SystemExit" title="(in Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SystemExit</span></code></a> do. This means that if you write something like:</p> <pre data-language="python">try:
    ...
except Exception:
    ...</pre> <p>then this <em>won’t</em> catch a <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> exception.</p> <p>You cannot raise <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> yourself. Attempting to do so will produce a <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#TypeError" title="(in Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>. Use <a class="reference internal" href="#trio.CancelScope.cancel" title="trio.CancelScope.cancel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cancel_scope.cancel()</span></code></a> instead.</p> <blockquote class="admonition note"> <h4 class="admonition-title">Note</h4> <p>In the US it’s also common to see this word spelled “canceled”, with only one “l”. This is a <a class="reference external" href="https://books.google.com/ngrams/graph?content=canceled%2Ccancelled&amp;year_start=1800&amp;year_end=2000&amp;corpus=5&amp;smoothing=3&amp;direct_url=t1%3B%2Ccanceled%3B%2Cc0%3B.t1%3B%2Ccancelled%3B%2Cc0">recent</a> and <a class="reference external" href="https://books.google.com/ngrams/graph?content=canceled%2Ccancelled&amp;year_start=1800&amp;year_end=2000&amp;corpus=18&amp;smoothing=3&amp;share=&amp;direct_url=t1%3B%2Ccanceled%3B%2Cc0%3B.t1%3B%2Ccancelled%3B%2Cc0">US-specific</a> innovation, and even in the US both forms are still commonly used. So for consistency with the rest of the world and with “cancellation” (which always has two “l”s), Trio uses the two “l” spelling everywhere.</p> </blockquote> </dd>
</dl> <dl class="exception"> <h3 id="trio.TooSlowError"><code><em>exception</em> trio.TooSlowError</code></h3> <dd>
<p>Raised by <a class="reference internal" href="#trio.fail_after" title="trio.fail_after"><code class="xref py py-func docutils literal notranslate"><span class="pre">fail_after()</span></code></a> and <a class="reference internal" href="#trio.fail_at" title="trio.fail_at"><code class="xref py py-func docutils literal notranslate"><span class="pre">fail_at()</span></code></a> if the timeout expires.</p> </dd>
</dl> <dl class="exception"> <h3 id="trio.WouldBlock"><code><em>exception</em> trio.WouldBlock</code></h3> <dd>
<p>Raised by <code class="docutils literal notranslate"><span class="pre">X_nowait</span></code> functions if <code class="docutils literal notranslate"><span class="pre">X</span></code> would block.</p> </dd>
</dl> <dl class="exception"> <h3 id="trio.EndOfChannel"><code><em>exception</em> trio.EndOfChannel</code></h3> <dd>
<p>Raised when trying to receive from a <a class="reference internal" href="reference-io#trio.abc.ReceiveChannel" title="trio.abc.ReceiveChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.ReceiveChannel</span></code></a> that has no more data to receive.</p> <p>This is analogous to an “end-of-file” condition, but for channels.</p> </dd>
</dl> <dl class="exception"> <h3 id="trio.BusyResourceError"><code><em>exception</em> trio.BusyResourceError</code></h3> <dd>
<p>Raised when a task attempts to use a resource that some other task is already using, and this would lead to bugs and nonsense.</p> <p>For example, if two tasks try to send data through the same socket at the same time, Trio will raise <a class="reference internal" href="#trio.BusyResourceError" title="trio.BusyResourceError"><code class="xref py py-class docutils literal notranslate"><span class="pre">BusyResourceError</span></code></a> instead of letting the data get scrambled.</p> </dd>
</dl> <dl class="exception"> <h3 id="trio.ClosedResourceError"><code><em>exception</em> trio.ClosedResourceError</code></h3> <dd>
<p>Raised when attempting to use a resource after it has been closed.</p> <p>Note that “closed” here means that <em>your</em> code closed the resource, generally by calling a method with a name like <code class="docutils literal notranslate"><span class="pre">close</span></code> or <code class="docutils literal notranslate"><span class="pre">aclose</span></code>, or by exiting a context manager. If a problem arises elsewhere – for example, because of a network failure, or because a remote peer closed their end of a connection – then that should be indicated by a different exception class, like <a class="reference internal" href="#trio.BrokenResourceError" title="trio.BrokenResourceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BrokenResourceError</span></code></a> or an <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#OSError" title="(in Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> subclass.</p> </dd>
</dl> <dl class="exception"> <h3 id="trio.BrokenResourceError"><code><em>exception</em> trio.BrokenResourceError</code></h3> <dd>
<p>Raised when an attempt to use a resource fails due to external circumstances.</p> <p>For example, you might get this if you try to send data on a stream where the remote side has already closed the connection.</p> <p>You <em>don’t</em> get this error if <em>you</em> closed the resource – in that case you get <a class="reference internal" href="#trio.ClosedResourceError" title="trio.ClosedResourceError"><code class="xref py py-class docutils literal notranslate"><span class="pre">ClosedResourceError</span></code></a>.</p> <p>This exception’s <code class="docutils literal notranslate"><span class="pre">__cause__</span></code> attribute will often contain more information about the underlying error.</p> </dd>
</dl> <dl class="exception"> <h3 id="trio.RunFinishedError"><code><em>exception</em> trio.RunFinishedError</code></h3> <dd>
<p>Raised by <a class="reference internal" href="#trio.from_thread.run" title="trio.from_thread.run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.from_thread.run</span></code></a> and similar functions if the corresponding call to <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> has already finished.</p> </dd>
</dl> <dl class="exception"> <h3 id="trio.TrioInternalError"><code><em>exception</em> trio.TrioInternalError</code></h3> <dd>
<p>Raised by <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a> if we encounter a bug in Trio, or (possibly) a misuse of one of the low-level <a class="reference internal" href="reference-hazmat#module-trio.hazmat" title="trio.hazmat"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.hazmat</span></code></a> APIs.</p> <p>This should never happen! If you get this error, please file a bug.</p> <p>Unfortunately, if you get this error it also means that all bets are off – Trio doesn’t know what is going on and its normal invariants may be void. (For example, we might have “lost track” of a task. Or lost track of all tasks.) Again, though, this shouldn’t happen.</p> </dd>
</dl> <dl class="exception"> <h3 id="trio.TrioDeprecationWarning"><code><em>exception</em> trio.TrioDeprecationWarning</code></h3> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#FutureWarning" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">FutureWarning</span></code></a></p> <p>Warning emitted if you use deprecated Trio functionality.</p> <p>As a young project, Trio is currently quite aggressive about deprecating and/or removing functionality that we realize was a bad idea. If you use Trio, you should subscribe to <a class="reference external" href="https://github.com/python-trio/trio/issues/1">issue #1</a> to get information about upcoming deprecations and other backwards compatibility breaking changes.</p> <p>Despite the name, this class currently inherits from <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#FutureWarning" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">FutureWarning</span></code></a>, not <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#DeprecationWarning" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a>, because while we’re in young-and-aggressive mode we want these warnings to be visible by default. You can hide them by installing a filter or with the <code class="docutils literal notranslate"><span class="pre">-W</span></code> switch: see the <a class="reference external" href="https://docs.python.org/3/library/warnings.html#module-warnings" title="(in Python v3.7)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">warnings</span></code></a> documentation for details.</p> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2017 Nathaniel J. Smith<br>Licensed under the MIT License.<br>
    <a href="https://trio.readthedocs.io/en/v0.12.1/reference-core.html" class="_attribution-link">https://trio.readthedocs.io/en/v0.12.1/reference-core.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
