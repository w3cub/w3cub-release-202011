
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>19. Functions - D - W3cubDocs</title>
  
  <meta name="description" content="The in and out blocks or expressions of a function declaration specify the pre- and post-conditions of the function. They are used in Contract &hellip;">
  <meta name="keywords" content="functions, d">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/d/function.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/d.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/d/" class="_nav-link" title="" style="margin-left:0;">D</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _d">
				
				
<h1>Functions</h1>       <b>Contents</b>  <ol> <li><a href="#grammar">Grammar</a></li> <li><a href="#contracts">Contracts</a></li> <li><a href="#function-return-values">Function Return Values</a></li> <li><a href="#function-declarations">Functions Without Bodies</a></li> <li><a href="#pure-functions">Pure Functions</a></li> <li><a href="#nothrow-functions">Nothrow Functions</a></li> <li><a href="#ref-functions">Ref Functions</a></li> <li><a href="#auto-functions">Auto Functions</a></li> <li><a href="#auto-ref-functions">Auto Ref Functions</a></li> <li><a href="#inout-functions">Inout Functions</a></li> <li><a href="#optional-parenthesis">Optional Parentheses</a></li> <li><a href="#property-functions">Property Functions</a></li> <li>
<a href="#virtual-functions">Virtual Functions</a><ol> <li><a href="#function-inheritance">Function Inheritance and Overriding</a></li> </ol>
</li> <li><a href="#inline-functions">Inline Functions</a></li> <li>
<a href="#function-overloading">Function Overloading</a><ol> <li><a href="#overload-sets">Overload Sets</a></li> </ol>
</li> <li>
<a href="#parameters">Function Parameters</a><ol> <li><a href="#param-storage">Parameter Storage Classes</a></li> <li><a href="#lazy-params">Lazy Parameters</a></li> <li><a href="#function-default-args">Function Default Arguments</a></li> <li><a href="#return-ref-parameters">Return Ref Parameters</a></li> <li><a href="#return-scope-parameters">Return Scope Parameters</a></li> <li><a href="#ref-return-scope-parameters">Ref Return Scope Parameters</a></li> <li><a href="#udas-parameters">User-Defined Attributes for Parameters</a></li> <li><a href="#variadic">Variadic Functions</a></li> </ol>
</li> <li>
<a href="#local-variables">Local Variables</a><ol> <li><a href="#local-static-variables">Local Static Variables</a></li> </ol>
</li> <li><a href="#nested">Nested Functions</a></li> <li>
<a href="#closures">Delegates, Function Pointers, and Closures</a><ol> <li><a href="#anonymous">Anonymous Functions and Anonymous Delegates</a></li> </ol>
</li> <li><a href="#main"><code>main()</code> Function</a></li> <li><a href="#function-templates">Function Templates</a></li> <li>
<a href="#interpretation">Compile Time Function Execution (CTFE)</a><ol> <li><a href="#string-mixins">String Mixins and Compile Time Function Execution</a></li> </ol>
</li> <li><a href="#nogc-functions">No-GC Functions</a></li> <li>
<a href="#function-safety">Function Safety</a><ol> <li><a href="#safe-functions">Safe Functions</a></li> <li><a href="#trusted-functions">Trusted Functions</a></li> <li><a href="#system-functions">System Functions</a></li> </ol>
</li> <li><a href="#function-attribute-inference">Function Attribute Inference</a></li> <li><a href="#pseudo-member">Uniform Function Call Syntax (UFCS)</a></li> </ol>   <h2 id="grammar">Grammar</h2>  <h3>Function declaration</h3>  <pre>FuncDeclaration:
    StorageClassesopt BasicType FuncDeclarator FunctionBody
    AutoFuncDeclaration

AutoFuncDeclaration:
    StorageClasses Identifier FuncDeclaratorSuffix FunctionBody

FuncDeclarator:
    BasicType2opt Identifier FuncDeclaratorSuffix

FuncDeclaratorSuffix:
    Parameters MemberFunctionAttributesopt
    TemplateParameters Parameters MemberFunctionAttributesopt Constraintopt
</pre>  <h3>Parameters</h3>  <pre>Parameters:
    ( ParameterListopt )

ParameterList:
    Parameter
    Parameter , ParameterList
    ...

Parameter:
    ParameterAttributesopt BasicType Declarator
    ParameterAttributesopt BasicType Declarator ...
    ParameterAttributesopt BasicType Declarator = AssignExpression
    ParameterAttributesopt Type
    ParameterAttributesopt Type ...

ParameterAttributes:
    InOut
    UserDefinedAttribute
    ParameterAttributes InOut
    ParameterAttributes UserDefinedAttribute
    ParameterAttributes

InOut:
    auto
    TypeCtor
    final
    in
    lazy
    out
    ref
    return ref
    scope
</pre>  <h3>Function attributes</h3>  <pre>FunctionAttributes:
    FunctionAttribute
    FunctionAttribute FunctionAttributes

FunctionAttribute:
    nothrow
    pure
    Property

MemberFunctionAttributes:
    MemberFunctionAttribute
    MemberFunctionAttribute MemberFunctionAttributes

MemberFunctionAttribute:
    const
    immutable
    inout
    return
    shared
    FunctionAttribute
</pre>  <h3>Function body</h3>  <pre>FunctionBody:
    SpecifiedFunctionBody
    MissingFunctionBody

FunctionLiteralBody:
    SpecifiedFunctionBody

SpecifiedFunctionBody:
    doopt BlockStatement
    FunctionContractsopt InOutContractExpression doopt BlockStatement
    FunctionContractsopt InOutStatement do BlockStatement

MissingFunctionBody:
    ;
    FunctionContractsopt InOutContractExpression ;
    FunctionContractsopt InOutStatement
</pre>  <h3>Function contracts</h3>  <pre>FunctionContracts:
    FunctionContract
    FunctionContract FunctionContracts

FunctionContract:
    InOutContractExpression
    InOutStatement

InOutContractExpression:
    InContractExpression
    OutContractExpression

InOutStatement:
    InStatement
    OutStatement

InContractExpression:
    in ( AssertArguments )

OutContractExpression:
    out ( ; AssertArguments )
    out ( Identifier ; AssertArguments )

InStatement:
    in BlockStatement

OutStatement:
    out BlockStatement
    out ( Identifier ) BlockStatement
</pre>  <h2 id="contracts">Contracts</h2>  <p>The <code>in</code> and <code>out</code> blocks or expressions of a function declaration specify the pre- and post-conditions of the function. They are used in <a href="contracts">Contract Programming</a>. The code inside these blocks should not have any side-effects, including modifying function parameters and/or return values. </p>  <h2 id="function-return-values">Function Return Values</h2>  <p>Function return values are considered to be rvalues. This means they cannot be passed by reference to other functions. </p>  <h2 id="function-declarations">Functions Without Bodies</h2>  <p>Functions without bodies:</p>  <pre data-language="d">int foo();
</pre>  <p>that are not declared as <code>abstract</code> are expected to have their implementations elsewhere, and that implementation will be provided at the link step. This enables an implementation of a function to be completely hidden from the user of it, and the implementation may be in another language such as C, assembler, etc. </p>  <h2 id="pure-functions">Pure Functions</h2>  <p>Pure functions are functions that cannot directly access global or static mutable state. <code>pure</code> guarantees that a pure function call won't access or modify any implicit state in the program. </p>  <p>Unlike other functional programming languages, D's <code>pure</code> functions allow modification of the caller state through their mutable parameters. </p>  <pre data-language="d">pure int foo(int[] arr) { arr[] += 1; return arr.length; }
int[] a = [1, 2, 3];
foo(a);
assert(a == [2, 3, 4]);
</pre>  <p>A <code>pure</code> function accepting parameters with mutable indirections offers what's called "weak purity" because it can change program state transitively through its arguments. A <code>pure</code> function that has no parameter with mutable indirections is called "strongly pure" and fulfills the purity definition in traditional functional languages. Weakly <code>pure</code> functions are useful as reusable building blocks for strongly pure functions. </p>  <p>To prevent mutation, D offers the <code>immutable</code> type qualifier. If all of a <code>pure</code> function's parameters are <code>immutable</code> or copied values without any indirections (e.g. <code>int</code>), the type system guarantees no side effects. </p>  <pre data-language="d">struct S { double x; }
pure int foo(immutable(int)[] arr, int num, S val)
{
    //arr[num] = 1; // compile error
    num = 2;        // has no side effect to the caller side
    val.x = 3.14;   // ditto
    return arr.length;
}
</pre>  <p>The maximum guarantee of <code>pure</code> is called "strong purity". It can enable optimizations based on the fact that a function is guaranteed to not mutate anything which isn't passed to it. For cases where the compiler can guarantee that a pure function cannot alter its arguments, it can enable full, functional purity (i.e. the guarantee that the function will always return the same result for the same arguments). To that end, a pure function: </p>  <ul> <li>does not read or write any global or static mutable state</li> <li>cannot call functions that are not pure</li> <li>can override an impure function, but cannot be overridden by an impure function</li> <li>is covariant with an impure function</li> <li>cannot perform I/O</li> </ul>  <p>This definition of mutable functions is more general than the one traditionally employed by pure functional languages because it allows a D pure function to use state mutation, as long as all state is created internally or reachable through its arguments. In particular, a pure function may allocate memory by means of e.g. <code>new</code> or <code>malloc</code> without these being special cases. A pure function is allowed to loop indefinitely or terminate the program.</p>  <p>As a concession to practicality, a pure function can also:</p>  <ul> <li>read and write the floating point exception flags</li> <li>read and write the floating point mode flags, as long as those flags are restored to their initial state upon function entry</li> <li>perform impure operations in statements that are in a <a href="version#ConditionalStatement"><i>ConditionalStatement</i></a> controlled by a <a href="version#DebugCondition"><i>DebugCondition</i></a>.</li> </ul>  <p>A pure function can throw exceptions.</p>  <pre data-language="d">import std.stdio;
int x;
immutable int y;
const int* pz;

pure int foo(int i,
             char* p,
             const char* q,
             immutable int* s)
{
    debug writeln("in foo()"); // ok, impure code allowed in debug statement
    x = i;   // error, modifying global state
    i = x;   // error, reading mutable global state
    i = y;   // ok, reading immutable global state
    i = *pz; // error, reading const global state
    return i;
}
</pre>  <p>An implementation may assume that a <code>pure</code> function that (a) accepts only parameters without mutable indirections, and (b) returns a result without mutable indirections, will have the same effect for all invocation with equivalent arguments, and is allowed to memoize the result of the function under the assumption that equivalent parameters always produce equivalent results. Such functions are termed <i>strongly <code>pure</code></i> functions in this document. Note that a strongly pure function may still have behavior inconsistent with memoization by e.g. using <code>cast</code>s or by changing behavior depending on the address of its parameters. An implementation is currently not required to enforce validity of memoization in all cases.</p>  <p>A pure function that accepts only parameters without mutable indirections and returns a result that has mutable indirections is called a <i>pure factory function</i>. An implementation may assume that all mutable memory returned by the call is not referenced by any other part of the program, i.e. it is newly allocated by the function. Conversely, the mutable references of the result may be assumed to not refer to any object that existed before the function call. For example:</p>   <pre data-language="d">struct List { int payload; List* next; }
pure List* make(int a, int b)
{
    auto result = new List(a, null);
    result.next = new List(b, result);
    return result;
}
</pre>   <p>Here, an implementation may assume (without having knowledge of the body of <code>make</code>) that all references in <code>make</code>'s result refer to other <code>List</code> objects created by <code>make</code>, and that no other part of the program refers to any of these objects.</p>  <p>Any <code>pure</code> function that is not strongly pure cannot be assumed to be memoizable, and calls to it may not be elided even if it returns <code>void</code> (save for compiler optimizations that prove the function has no effect). Function calls may still be elided, or results be memoized, by means of traditional inlining and optimization techniques available for all functions.</p>  <p>If a strongly pure function throws an exception or an error, the assumptions related to memoization and references do not carry to the thrown exception.</p>  <p>Pure destructors do not benefit of special elision.</p>  <h2 id="nothrow-functions">Nothrow Functions</h2>  <p>Nothrow functions can only throw exceptions derived from class <i>Error</i>. </p>  <p>Nothrow functions are covariant with throwing ones.</p>  <h2 id="ref-functions">Ref Functions</h2>  <p>Ref functions allow functions to return by reference. This is analogous to ref function parameters. </p>  <pre data-language="d">ref int foo()
{
    auto p = new int;
    return *p;
}
...
foo() = 3;  // reference returns can be lvalues
</pre>  <h2 id="auto-functions">Auto Functions</h2>  <p>Auto functions have their return type inferred from any <a href="statement#ReturnStatement"><i>ReturnStatement</i></a>s in the function body. </p>  <p>An auto function is declared without a return type. If it does not already have a storage class, use the <span class="d_keyword">auto</span> storage class. </p>  <p>If there are multiple <i>ReturnStatement</i>s, the types of them must be implicitly convertible to a common type. If there are no <i>ReturnStatement</i>s, the return type is inferred to be <span class="d_keyword">void</span>.</p>   <pre data-language="d">auto foo(int x) { return x + 3; }          // inferred to be int
auto bar(int x) { return x; return 2.5; }  // inferred to be double
</pre>   <h2 id="auto-ref-functions">Auto Ref Functions</h2>  <p>Auto ref functions infer their return type just as <a href="#auto-functions">auto functions</a> do. In addition, they become <a href="#ref-functions">ref functions</a> if all return expressions are lvalues, and it would not be a reference to a local or a parameter.</p>   <pre data-language="d">auto ref f1(int x)     { return x; }  // value return
auto ref f2()          { return 3; }  // value return
auto ref f3(ref int x) { return x; }  // ref return
auto ref f4(out int x) { return x; }  // ref return
auto ref f5() { static int x; return x; }  // ref return
</pre>   <p>The ref-ness of a function is determined from all <a href="statement#ReturnStatement"><i>ReturnStatement</i></a>s in the function body:</p>   <pre data-language="d">auto ref f1(ref int x) { return 3; return x; }  // ok, value return
auto ref f2(ref int x) { return x; return 3; }  // ok, value return
auto ref f3(ref int x, ref double y)
{
    return x; return y;
    // The return type is deduced to double, but cast(double)x is not an lvalue,
    // then become a value return.
}
</pre>   <p>Auto ref function can have explicit return type.</p>  <pre data-language="d">auto ref int (ref int x) { return x; }  // ok, ref return
auto ref int foo(double x) { return x; }   // error, cannot convert double to int
</pre>  <h2 id="inout-functions">Inout Functions</h2>  <p>Functions that deal with mutable, const, or immutable types with equanimity often need to transmit their type to the return value:</p>   <pre data-language="d">int[] f1(int[] a, int x, int y) { return a[x .. y]; }

const(int)[] f2(const(int)[] a, int x, int y) { return a[x .. y]; }

immutable(int)[] f3(immutable(int)[] a, int x, int y) { return a[x .. y]; }
</pre>   <p>The code generated by these three functions is identical. To indicate that these can be one function, the <span class="d_keyword">inout</span> type constructor is employed:</p>   <pre data-language="d">inout(int)[] foo(inout(int)[] a, int x, int y) { return a[x .. y]; }
</pre>   <p>The <span class="d_keyword">inout</span> forms a wildcard that stands in for any of mutable, const, immutable, inout, or inout const. When the function is called, the inout of the return type is changed to whatever the mutable, const, immutable, inout, or inout const status of the argument type to the parameter inout was. </p>  <p>Inout types can be implicitly converted to const or inout const, but to nothing else. Other types cannot be implicitly converted to inout. Casting to or from inout is not allowed in @safe functions. </p>  <p>A set of arguments to a function with inout parameters is considered a match if any inout argument types match exactly, or:</p>  <ol> <li>No argument types are composed of inout types.</li> <li>A mutable, const or immutable argument type can be matched against each corresponding parameter inout type.</li> </ol>  <p>If such a match occurs, the inout is considered the common qualifier of the matched qualifiers. If more than two parameters exist, the common qualifier calculation is recursively applied. </p>  <table>
<caption>Common qualifier of the two type qualifiers</caption> <tr>
<td></td>
<td><i>mutable</i></td>
<td><code>const</code></td>
<td><code>immutable</code></td>
<td><code>inout</code></td>
<td><code>inout const</code></td>
</tr> <tr>
<td>
<i>mutable</i> (= m)</td>
<td>m</td>
<td>c</td>
<td>c</td>
<td>c</td>
<td>c</td>
</tr> <tr>
<td>
<code>const</code> (= c)</td>
<td>c</td>
<td>c</td>
<td>c</td>
<td>c</td>
<td>c</td>
</tr> <tr>
<td>
<code>immutable</code> (= i)</td>
<td>c</td>
<td>c</td>
<td>i</td>
<td>wc</td>
<td>wc</td>
</tr> <tr>
<td>
<code>inout</code> (= w)</td>
<td>c</td>
<td>c</td>
<td>wc</td>
<td>w</td>
<td>wc</td>
</tr> <tr>
<td>
<code>inout const</code> (= wc)</td>
<td>c</td>
<td>c</td>
<td>wc</td>
<td>wc</td>
<td>wc</td>
</tr> </table>  <p>The inout in the return type is then rewritten to be the inout matched qualifiers:</p>   <pre data-language="d">int[] ma;
const(int)[] ca;
immutable(int)[] ia;

inout(int)[] foo(inout(int)[] a) { return a; }
void test1()
{
    // inout matches to mutable, so inout(int)[] is
    // rewritten to int[]
    int[] x = foo(ma);

    // inout matches to const, so inout(int)[] is
    // rewritten to const(int)[]
    const(int)[] y = foo(ca);

    // inout matches to immutable, so inout(int)[] is
    // rewritten to immutable(int)[]
    immutable(int)[] z = foo(ia);
}

inout(const(int))[] bar(inout(int)[] a) { return a; }
void test2()
{
    // inout matches to mutable, so inout(const(int))[] is
    // rewritten to const(int)[]
    const(int)[] x = bar(ma);

    // inout matches to const, so inout(const(int))[] is
    // rewritten to const(int)[]
    const(int)[] y = bar(ca);

    // inout matches to immutable, so inout(int)[] is
    // rewritten to immutable(int)[]
    immutable(int)[] z = bar(ia);
}
</pre>   <p><b>Note:</b> Shared types are not overlooked. Shared types cannot be matched with inout. </p>  <p><a href="#variadicnested">Nested functions</a> inside pure function are implicitly marked as pure.</p>  <pre data-language="d">pure int foo(int x, immutable int y)
{
    int bar()
    // implicitly marked as pure, to be "weak purity"
    // hidden context pointer is mutable
    {
        x = 10;     // can access states in enclosing scope
                    // through the mutable context pointer
        return x;
    }
    pragma(msg, typeof(&amp;bar));  // int delegate() pure

    int baz() immutable
    // qualify hidden context pointer with immutable,
    // and has no other parameters, make "strong purity"
    {
        //return x; // error, cannot access mutable data
                    // through the immutable context pointer
        return y;   // ok
    }

    // can call pure nested functions
    return bar() + baz();
}
</pre>  <h2 id="optional-parenthesis">Optional Parentheses</h2>  <p>If a function call passes no explicit argument, i.e. it would syntactically use <code>()</code>, then these parentheses may be omitted, similar to a getter invocation of a <a href="#property-functions">property function</a>. </p>   <pre data-language="d">void foo() {}   // no arguments
void fun(int x = 10) { }
void bar(int[] arr) {}  // for UFCS

void main()
{
    foo();      // OK
    foo;        // also OK
    fun;        // OK

    int[] arr;
    arr.bar();  // OK
    arr.bar;    // also OK
}
</pre>   <p>Optional parentheses are not applied to delegates or function pointers.</p>  <pre data-language="d">void main()
{
    int function() fp;

    assert(fp == 6);    // Error, incompatible types int function() and int
    assert(*fp == 6);   // Error, incompatible types int() and int

    int delegate() dg;
    assert(dg == 6);    // Error, incompatible types int delegate() and int
}
</pre>  <p>If a function returns a delegate or function pointer, the parantheses are required if the returned value is to be called. </p>   <pre data-language="d">struct S {
    int function() callfp() { return &amp;numfp; }
    int delegate() calldg() return { return &amp;numdg; }
    int numdg() { return 6; }
}

int numfp() { return 6; }

void main()
{
    S s;
    int function() fp;

    fp = s.callfp;
    assert(fp() == 6);

    fp = s.callfp();
    assert(fp() == 6);

    int x = s.callfp()();
    assert(x == 6);

    int delegate() dg;

    dg = s.calldg;
    assert(dg() == 6);

    dg = s.calldg();
    assert(dg() == 6);

    int y = s.calldg()();
    assert(y == 6);
}
</pre>   <h2 id="property-functions">Property Functions</h2>  <p>WARNING: The definition and usefulness of property functions is being reviewed, and the implementation is currently incomplete. Using property functions is not recommended until the definition is more certain and implementation more mature.</p>  <p>Properties are functions that can be syntactically treated as if they were fields or variables. Properties can be read from or written to. A property is read by calling a method or function with no arguments; a property is written by calling a method or function with its argument being the value it is set to. </p>  <p>Simple getter and setter properties can be written using <a href="#pseudo-member">UFCS</a>. These can be enhanced with the additon of the <code>@property</code> attribute to the function, which adds the following behaviors: </p>  <ul> <li>
<code>@property</code> functions cannot be overloaded with non-<code>@property</code> functions with the same name.</li> <li>
<code>@property</code> functions can only have zero, one or two parameters.</li> <li>
<code>@property</code> functions cannot have variadic parameters.</li> <li>For the expression <code>typeof(exp)</code> where <code>exp</code> is an <code>@property</code> function, the type is the return type of the function, rather than the type of the function.</li> <li>For the expression <code>__traits(compiles, exp)</code> where <code>exp</code> is an <code>@property</code> function, a further check is made to see if the function can be called.</li> <li>
<code>@property</code> are mangled differently, meaning that <code>@property</code> must be consistently used across different compilation units.</li> <li>The ObjectiveC interface recognizes <code>@property</code> setter functions as special and modifies them accordingly.</li> </ul>  <p>A simple property would be:</p>    <pre data-language="d">struct Foo
{
    @property int data() { return m_data; } // read property

    @property int data(int value) { return m_data = value; } // write property

  private:
    int m_data;
}
</pre>   <p>To use it:</p>  <pre data-language="d">int test()
{
    Foo f;

    f.data = 3;        // same as f.data(3);
    return f.data + 3; // same as return f.data() + 3;
}
</pre>  <p>The absence of a read method means that the property is write-only. The absence of a write method means that the property is read-only. Multiple write methods can exist; the correct one is selected using the usual function overloading rules. </p>  <p>In all the other respects, these methods are like any other methods. They can be static, have different linkages, have their address taken, etc. </p>  <p>The built in properties <code>.sizeof</code>, <code>.alignof</code>, and <code>.mangleof</code> may not be declared as fields or methods in structs, unions, classes or enums. </p>  <p>If a property function has no parameters, it works as a getter. If has exactly one parameter, it works as a setter. </p>   <h2 id="virtual-functions">Virtual Functions</h2>  <p>Virtual functions are functions that are called indirectly through a function pointer table, called a vtbl[], rather than directly. All <code>public</code> and <code>protected</code> member functions which are non-static and are not templatized are virtual unless the compiler can determine that they will never be overridden (e.g. they are marked with <code>final</code> and do not override any functions in a base class), in which case, it will make them non-virtual. Static or <code>final</code> functions with <code>Objective-C</code> linkage are virtual as well. This results in fewer bugs caused by not declaring a function virtual and then overriding it anyway. </p>  <p>Member functions which are <code>private</code> or <code>package</code> are never virtual, and hence cannot be overridden. </p>  <p>Functions with non-D linkage cannot be virtual and hence cannot be overridden. </p>  <p>Member template functions cannot be virtual and hence cannot be overridden. </p>  <p>Functions marked as <code>final</code> may not be overridden in a derived class, unless they are also <code>private</code>. For example: </p>  <pre data-language="d">class A
{
    int def() { ... }
    final int foo() { ... }
    final private int bar() { ... }
    private int abc() { ... }
}

class B : A
{
    override int def() { ... }  // ok, overrides A.def
    override int foo() { ... }  // error, A.foo is final
    int bar() { ... }  // ok, A.bar is final private, but not virtual
    int abc() { ... }  // ok, A.abc is not virtual, B.abc is virtual
}

void test(A a)
{
    a.def();    // calls B.def
    a.foo();    // calls A.foo
    a.bar();    // calls A.bar
    a.abc();    // calls A.abc
}

void func()
{
    B b = new B();
    test(b);
}
</pre>  <p>Covariant return types are supported, which means that the overriding function in a derived class can return a type that is derived from the type returned by the overridden function: </p>   <pre data-language="d">class A { }
class B : A { }

class Foo
{
    A test() { return null; }
}

class Bar : Foo
{
    // overrides and is covariant with Foo.test()
    override B test() { return null; }
}
</pre>   <p>Virtual functions all have a hidden parameter called the <i>this</i> reference, which refers to the class object for which the function is called. </p>  <p> Functions with <code>Objective-C</code> linkage has an additional hidden, unnamed, parameter which is the selector it was called with. </p>  <p>To avoid dynamic binding on member function call, insert base class name before the member function name. For example: </p>   <pre data-language="d">class B
{
    int foo() { return 1; }
}
class C : B
{
    override int foo() { return 2; }

    void test()
    {
        assert(B.foo() == 1);  // translated to this.B.foo(), and
                               // calls B.foo statically.
        assert(C.foo() == 2);  // calls C.foo statically, even if
                               // the actual instance of 'this' is D.
    }
}
class D : C
{
    override int foo() { return 3; }
}
void main()
{
    auto d = new D();
    assert(d.foo() == 3);    // calls D.foo
    assert(d.B.foo() == 1);  // calls B.foo
    assert(d.C.foo() == 2);  // calls C.foo
    d.test();
}
</pre>   <h3 id="function-inheritance">Function Inheritance and Overriding</h3>  <p>A function in a derived class with the same name and parameter types as a function in a base class overrides that function:</p>  <pre data-language="d">class A
{
    int foo(int x) { ... }
}

class B : A
{
    override int foo(int x) { ... }
}

void test()
{
    B b = new B();
    bar(b);
}

void bar(A a)
{
    a.foo(1);   // calls B.foo(int)
}
</pre>  <p>However, when doing overload resolution, the functions in the base class are not considered: </p>  <pre data-language="d">class A
{
    int foo(int x) { ... }
    int foo(long y) { ... }
}

class B : A
{
    override int foo(long x) { ... }
}

void test()
{
    B b = new B();
    b.foo(1);  // calls B.foo(long), since A.foo(int) not considered
    A a = b;

    a.foo(1);  // issues runtime error (instead of calling A.foo(int))
}
</pre>  <p>To consider the base class's functions in the overload resolution process, use an <i>AliasDeclaration</i>: </p>  <pre data-language="d">class A
{
    int foo(int x) { ... }
    int foo(long y) { ... }
}

class B : A
{
    alias foo = A.foo;
    override int foo(long x) { ... }
}

void test()
{
    B b = new B();
    bar(b);
}

void bar(A a)
{
    a.foo(1);      // calls A.foo(int)
    B b = new B();
    b.foo(1);      // calls A.foo(int)
}
</pre>  <p>If such an <i>AliasDeclaration</i> is not used, the derived class's functions completely override all the functions of the same name in the base class, even if the types of the parameters in the base class functions are different. If, through implicit conversions to the base class, those other functions do get called, a compile-time error will be given: </p> <pre data-language="d">class A
{
    void set(long i) { }
    void set(int i)  { }
}
class B : A
{
    void set(long i) { }
}

void foo(A a)
{
    int i;
    a.set(3);   // error, use of A.set(int) is hidden by B
                // use 'alias set = A.set;' to introduce base class overload set.
    assert(i == 1);
}

void main()
{
    foo(new B);
}
</pre> <p>If an error occurs during the compilation of your program, the use of overloads and overrides needs to be reexamined in the relevant classes.</p>  <p>The compiler will not give an error if the hidden function is disjoint, as far as overloading is concerned, from all the other virtual functions is the inheritance hierarchy.</p>   <p>A function parameter's default value is not inherited:</p>  <pre data-language="d">class A
{
    void foo(int x = 5) { ... }
}

class B : A
{
    void foo(int x = 7) { ... }
}

class C : B
{
    void foo(int x) { ... }
}

void test()
{
    A a = new A();
    a.foo();       // calls A.foo(5)

    B b = new B();
    b.foo();       // calls B.foo(7)

    C c = new C();
    c.foo();       // error, need an argument for C.foo
}
</pre>  <p>If a derived class overrides a base class member function with diferrent <a href="#FunctionAttributes"><i>FunctionAttributes</i></a>, the missing attributes will be automatically compensated by the compiler.</p>   <pre data-language="d">class B
{
    void foo() pure nothrow @safe {}
}
class D : B
{
    override void foo() {}
}
void main()
{
    auto d = new D();
    pragma(msg, typeof(&amp;d.foo));
    // prints "void delegate() pure nothrow @safe" in compile time
}
</pre>   <p>It's not allowed to mark an overridden method with the attributes <a href="attribute#disable"><code>@disable</code></a> or <a href="attribute#deprecated"><code>deprecated</code></a>. To stop the compilation or to output the deprecation message, the compiler must be able to determine the target of the call, which can't be guaranteed when it is virtual. </p>   <pre data-language="d">class B
{
    void foo() {}
}

class D : B
{
    @disable override void foo() {}
}

void main()
{
    B b = new D;
    b.foo(); // compiles and calls the most derived even if disabled.
}
</pre>   <p>Static functions with <code>Objective-C</code> linkage are overridable.</p>  <h2 id="inline-functions">Inline Functions</h2>  <p>The compiler makes the decision whether to inline a function or not. This decision may be controlled by <a href="pragma#inline"><code>pragma(inline)</code></a>, assuming that the compiler implements it, which is not mandatory.</p>  <p>Note that any <a href="expression#FunctionLiteral"><i>FunctionLiteral</i></a> should be inlined when used in its declaration scope. </p>  <h2 id="function-overloading">Function Overloading</h2>  <p>Functions are overloaded based on how well the arguments to a function can match up with the parameters. The function with the <i>best</i> match is selected. The levels of matching are: </p>  <ol> <li>no match</li> <li>match with implicit conversions</li> <li>match with qualifier conversion (if the argument type is <a href="http://dlang.org/glossary.html#qualifier-convertible">qualifier-convertible</a> to the parameter type)</li> <li>exact match</li> </ol>  <p>Each argument (including any <code>this</code> pointer) is compared against the function's corresponding parameter, to determine the match level for that argument. The match level for a function is the <i>worst</i> match level of each of its arguments.</p>  <p>Literals do not match <code>ref</code> or <code>out</code> parameters.</p>   <p id="partial-ordering">If two or more functions have the same match level, then <i>partial ordering</i> is used to try to find the best match. Partial ordering finds the most specialized function. If neither function is more specialized than the other, then it is an ambiguity error. Partial ordering is determined for functions <code>f()</code> and <code>g()</code> by taking the parameter types of <code>f()</code>, constructing a list of arguments by taking the default values of those types, and attempting to match them against <code>g()</code>. If it succeeds, then <code>g()</code> is at least as specialized as <code>f()</code>. For example: </p> <pre data-language="d">class A { }
class B : A { }
class C : B { }
void foo(A);
void foo(B);

void test()
{
    C c;
    /* Both foo(A) and foo(B) match with implicit conversion rules.
     * Applying partial ordering rules,
     * foo(B) cannot be called with an A, and foo(A) can be called
     * with a B. Therefore, foo(B) is more specialized, and is selected.
     */
    foo(c); // calls foo(B)
}
</pre> <p>A function with a variadic argument is considered less specialized than a function without. </p>   <p>Functions defined with non-D linkage cannot be overloaded. This is because the name mangling might not take the parameter types into account. </p>  <h3 id="overload-sets">Overload Sets</h3>  <p>Functions declared at the same scope overload against each other, and are called an <i>Overload Set</i>. A typical example of an overload set are functions defined at module level: </p>   <pre data-language="d">module A;
void foo() { }
void foo(long i) { }
</pre>   <p><code>A.foo()</code> and <code>A.foo(long)</code> form an overload set. A different module can also define functions with the same name: </p>   <pre data-language="d">module B;
class C { }
void foo(C) { }
void foo(int i) { }
</pre>   <p>and A and B can be imported by a third module, C. Both overload sets, the <code>A.foo</code> overload set and the <code>B.foo</code> overload set, are found. An instance of <code>foo</code> is selected based on it matching in exactly one overload set: </p>  <pre data-language="d">import A;
import B;

void bar(C c)
{
    foo();    // calls A.foo()
    foo(1L);  // calls A.foo(long)
    foo(c);   // calls B.foo(C)
    foo(1,2); // error, does not match any foo
    foo(1);   // error, matches A.foo(long) and B.foo(int)
    A.foo(1); // calls A.foo(long)
}
</pre>  <p>Even though <code>B.foo(int)</code> is a better match than <code> A.foo(long)</code> for <code>foo(1)</code>, it is an error because the two matches are in different overload sets. </p>  <p>Overload sets can be merged with an alias declaration:</p>  <pre data-language="d">import A;
import B;

alias foo = A.foo;
alias foo = B.foo;

void bar(C c)
{
    foo();    // calls A.foo()
    foo(1L);  // calls A.foo(long)
    foo(c);   // calls B.foo(C)
    foo(1,2); // error, does not match any foo
    foo(1);   // calls B.foo(int)
    A.foo(1); // calls A.foo(long)
}
</pre>  <h2 id="parameters">Function Parameters</h2>  <h3 id="param-storage">Parameter Storage Classes</h3>  <p>Parameter storage classes are <code>in</code>, <code>out</code>, <code>ref</code>, <code>lazy</code>, <code>const</code>, <code>immutable</code>, <code>shared</code>, <code>inout</code> or <code>scope</code>. For example: </p> <pre data-language="d">int foo(in int x, out int y, ref int z, int q);
</pre>  <p>x is <code>in</code>, y is <code>out</code>, z is <code>ref</code>, and q is none. </p>  <ul> <li>The function declaration makes it clear what the inputs and outputs to the function are.</li> <li>It eliminates the need for IDL (interface description language) as a separate language.</li> <li>It provides more information to the compiler, enabling more error checking and possibly better code generation.</li> </ul>  <table>
<caption>Parameter Storage Classes</caption> <tr>
<th class="donthyphenate"><b>Storage Class</b></th>
<th class="donthyphenate"><b>Description</b></th>
</tr> <tr>
<td><i>none</i></td>
<td>parameter becomes a mutable copy of its argument</td>
</tr>  <tr>
<td><code>in</code></td>
<td>defined as <code>scope const</code>. However <code>in</code> has not yet been properly implemented so it's current implementation is equivalent to <code>const</code>. It is recommended to avoid using <code>in</code> until it is properly defined and implemented. Use <code>scope const</code> or <code>const</code> explicitly instead.</td>
</tr> <tr>
<td><code>out</code></td>
<td>parameter is initialized upon function entry with the default value for its type</td>
</tr>  <tr>
<td><code>ref</code></td>
<td> parameter is passed by reference</td>
</tr> <tr>
<td><code>scope</code></td>
<td>references in the parameter cannot be escaped (e.g. assigned to a global variable). Ignored for parameters with no references</td>
</tr> <tr>
<td><code>return</code></td>
<td>Parameter may be returned or copied to the first parameter, but otherwise does not escape from the function. Such copies are required not to outlive the argument(s) they were derived from. Ignored for parameters with no references. See <a href="memory-safe-d#scope-return-params">Scope Parameters</a>.</td>
</tr> <tr>
<td><code>lazy</code></td>
<td>argument is evaluated by the called function and not by the caller</td>
</tr> <tr>
<td><code>const</code></td>
<td>argument is implicitly converted to a const type</td>
</tr> <tr>
<td><code>immutable</code></td>
<td>argument is implicitly converted to an immutable type</td>
</tr> <tr>
<td><code>shared</code></td>
<td>argument is implicitly converted to a shared type</td>
</tr> <tr>
<td><code>inout</code></td>
<td>argument is implicitly converted to an inout type</td>
</tr> </table>   <pre data-language="d">void foo(out int x)
{
    // x is set to int.init,
    // which is 0, at start of foo()
}

int a = 3;
foo(a);
// a is now 0

void abc(out int x)
{
    x = 2;
}

int y = 3;
abc(y);
// y is now 2

void def(ref int x)
{
    x += 1;
}

int z = 3;
def(z);
// z is now 4
</pre>   <p>For dynamic array and object parameters, which are passed by reference, in/out/ref apply only to the reference and not the contents. </p>  <h3 id="lazy-params">Lazy Parameters</h3>  <p>An argument to a <code>lazy</code> parameter is not evaluated before the function is called. The argument is only evaluated if/when the parameter is evaluated within the function. Hence, a <code>lazy</code> argument can be executed 0 or more times. </p>   <pre data-language="d">import std.stdio : writeln;

void main()
{
    int x;
    3.times(writeln(x++));
    writeln("-");
    writeln(x);
}

void times(int n, lazy void exp)
{
    while (n--)
        exp();
}
</pre>   <p>prints to the console:</p>  <pre>0
1
2
âˆ’
3
</pre>  <p>A <code>lazy</code> parameter cannot be an lvalue.</p>  <p>A <code>lazy</code> parameter of type <code>void</code> can accept an argument of any type.</p>  <p>See Also: <a href="#lazy_variadic_functions">Lazy Variadic Functions</a></p>  <h3 id="function-default-args">Function Default Arguments</h3>  <p>Function parameter declarations can have default values:</p>  <pre data-language="d">void foo(int x, int y = 3)
{
    ...
}
...
foo(4);   // same as foo(4, 3);
</pre>  <p>Default parameters are resolved and semantically checked in the context of the function declaration.</p> <pre data-language="d">module m;
private immutable int b;
pure void g(int a=b){}
</pre> <pre data-language="d">import m;
int b;
pure void f()
{
  g();  // ok, uses m.b
}
</pre>  <p>The attributes of the <a href="expression#AssignExpression"><i>AssignExpression</i></a> are applied where the default expression is used.</p> <pre data-language="d">module m;
int b;
pure void g(int a=b){}
</pre> <pre data-language="d">import m;
enum int b = 3;
pure void f()
{
  g();  // error, cannot access mutable global `m.b` in pure function
}
</pre>  <p>If the default value for a parameter is given, all following parameters must also have default values. </p>  <h3 id="return-ref-parameters">Return Ref Parameters</h3>  <p>Note: The <code>return</code> attribute is currently only enforced by <code>dmd</code> when the <code>-dip25</code> switch is passed. </p>  <p>Return ref parameters are used with <a href="#ref-functions">ref functions</a> to ensure that the returned reference will not outlive the matching argument's lifetime. </p>  <pre data-language="d">ref int identity(return ref int x) {
  return x; // pass-through function that does nothing
}

ref int fun() {
  int x;
  return identity(x); // Error: escaping reference to local variable x
}

ref int gun(return ref int x) {
  return identity(x); // OK
}
</pre>  <p>Struct non-static methods marked with the <code>return</code> attribute ensure the returned reference will not outlive the struct instance. </p>  <pre data-language="d">struct S
{
    private int x;
    ref int get() return { return x; }
}

ref int escape()
{
    S s;
    return s.get(); // Error: escaping reference to local variable s
}
</pre>  <p>Returning the address of a <code>ref</code> variable is also checked.</p>  <pre data-language="d">int* pluto(ref int i)
{
    return &amp;i; // error: returning &amp;i escapes a reference to parameter i
}

int* mars(return ref int i)
{
    return &amp;i;  // ok
}
</pre>  <p>If the function returns <code>void</code>, and the first parameter is <code>ref</code> or <code>out</code>, then all subsequent <code>return ref</code> parameters are considered as being assigned to the first parameter for lifetime checking. The <code>this</code> reference parameter to a struct non-static member function is considered the first parameter.</p>  <p>If there are multiple <code>return ref</code> parameters, the lifetime of the return value is the smallest lifetime of the corresponding arguments.</p>  <p>Neither the type of the <code>return ref</code> parameter(s) nor the type of the return value is considered when determining the lifetime of the return value.</p>  <p>It is not an error if the return type does not contain any indirections.</p>  <pre data-language="d">int mercury(return ref int i)
{
    return i; // ok
}
</pre>  <p>Template functions, auto functions, nested functions and lambdas can deduce the <code>return</code> attribute.</p>  <pre data-language="d">ref int templateFunction()(ref int i)
{
    return i; // ok
}

ref auto autoFunction(ref int i)
{
    return i; // ok
}

void uranus()
{
    ref int nestedFunction(ref int i)
    {
        return i; // ok
    }
}

void venus()
{
    auto lambdaFunction =
        (ref int i)
        {
            return &amp;i; // ok
        };
}
</pre>  <p><code>inout ref</code> parameters imply the <code>return</code> attribute.</p>  <pre data-language="d">inout(int)* neptune(inout ref int i)
{
    return &amp;i;  // ok
}
</pre>  <h3 id="return-scope-parameters">Return Scope Parameters</h3>  <p>Parameters marked as <code>return scope</code> that contain indirections can only escape those indirections via the function's return value.</p>  <pre data-language="d">@safe:

int* gp;
void thorin(scope int*);
void gloin(int*);
int* balin(return scope int* p, scope int* q, int* r)
{
     gp = p; // error, p escapes to global gp
     gp = q; // error, q escapes to global gp
     gp = r; // ok

     thorin(p); // ok, p does not escape thorin()
     thorin(q); // ok
     thorin(r); // ok

     gloin(p); // error, gloin() escapes p
     gloin(q); // error, gloin() escapes q
     gloin(r); // ok that gloin() escapes r

     return p; // ok
     return q; // error, cannot return 'scope' q
     return r; // ok
}
</pre>  <p>Class references are considered pointers that are subject to <code>scope</code>.</p>  <pre data-language="d">@safe:

class C { }
C gp;
void thorin(scope C);
void gloin(C);
C balin(return scope C p, scope C q, C r)
{
     gp = p; // error, p escapes to global gp
     gp = q; // error, q escapes to global gp
     gp = r; // ok

     thorin(p); // ok, p does not escape thorin()
     thorin(q); // ok
     thorin(r); // ok

     gloin(p); // error, gloin() escapes p
     gloin(q); // error, gloin() escapes q
     gloin(r); // ok that gloin() escapes r

     return p; // ok
     return q; // error, cannot return 'scope' q
     return r; // ok
}
</pre>  <p><code>return scope</code> can be applied to the <code>this</code> of class and interface member functions.</p>  <pre data-language="d">class C
{
    C bofur() return scope { return this; }
}
</pre>  <p>Template functions, auto functions, nested functions and lambdas can deduce the <code>return scope</code> attribute.</p>  <p><b>Note:</b> Checks for <code>scope</code> parameters are currently enabled only for <code>@safe</code> functions when compiled with the <code>-dip1000</code> flag.</p>  <h3 id="ref-return-scope-parameters">Ref Return Scope Parameters</h3>  <p>Parameters marked as <code>ref return scope</code> come in two forms:</p>  <pre data-language="d">U xerxes(ref return scope V v);      // (1) ref and return scope
ref U xerxes(ref return scope V v);  // (2) return ref and scope
</pre>  <p>The first form attaches the <code>return</code> to the <code>scope</code>, and has <a href="#return-scope-parameters">return scope parameter</a> semantics for the value of the <code>ref</code> parameter.</p>  <p>The second form attaches the <code>return</code> to the <code>ref</code>, and has <a href="#return-ref-parameters">return ref parameter</a> semantics with additional <a href="memory-safe-d#scope-return-params">scope parameter</a> semantics.</p>  <p>Although a struct constructor returns a reference to the instance being constructed, it is treated as form (1).</p>  <p>The lexical order of the attributes <code>ref</code>, <code>return</code>, and <code>scope</code> is not significant.</p>  <p>It is not possible to have both <code>return ref</code> and <code>return scope</code> semantics for the same parameter.</p>  <pre data-language="d">@safe:

struct S
{
    this(return scope   ref int* p) { ptr = p; }

    int  val;
    int* ptr;
}

int* foo1(return scope   ref S s);
int  foo2(return scope   ref S s);

ref int* foo3(return ref   scope S s);
ref int  foo4(return ref   scope S s);

int* test1(scope S s)
{
    return foo1(s);  // Error: scope variable `s` may not be returned
    return foo3(s);  // Error: scope variable `s` may not be returned
}

int test2(S s)
{
    return foo2(s);
    return foo4(s);
}

ref int* test3(S s)
{
    return foo3(s);  // Error: returning `foo3(s)` escapes a reference to parameter `s`
}

ref int test4(S s)
{
    return foo4(s);  // Error: returning `foo4(s)` escapes a reference to parameter `s`
}

S test5(ref scope int* p)
{
    return S(p); // Error: scope variable `p` may not be returned
}

S test6(ref return scope int* p)
{
    return S(p);
}
</pre>  <h3 id="udas-parameters">User-Defined Attributes for Parameters</h3>  See also: <a href="attribute#UserDefinedAttribute"><i>User-Defined Attributes</i></a>  <h3 id="variadic">Variadic Functions</h3>  <p>Functions taking a variable number of arguments are called variadic functions. A variadic function can take one of three forms:</p>  <ol> <li>C-style variadic functions</li> <li>Variadic functions with type info</li> <li>Typesafe variadic functions</li> </ol>   <h4 id="c_style_cariadic_functions">C-style Variadic Functions</h4>  <p>A C-style variadic function is declared as taking a parameter of ... after the required function parameters. It has non-D linkage, such as <code>extern (C)</code>:</p>  <pre data-language="d">extern (C) void foo(int x, int y, ...);

foo(3, 4);      // ok
foo(3, 4, 6.8); // ok, one variadic argument
foo(2);         // error, y is a required argument
</pre>  <p>There must be at least one non-variadic parameter declared.</p>  <pre data-language="d">extern (C) int def(...); // error, must have at least one parameter
</pre>  <p> C-style variadic functions match the C calling convention for variadic functions, and is most useful for calling C library functions like <code>printf</code>. </p>  <p>C-style variadic functions cannot be marked as <code>@safe</code>.</p>  <p>Access to variadic arguments is done using the standard library module <code>core.stdc.stdarg</code>. </p>  <pre data-language="d">import core.stdc.stdarg;

void test()
{
    foo(3, 4, 5);   // first variadic argument is 5
}

void foo(int x, int y, ...)
{
    va_list args;

    va_start(args, y);  // y is the last named parameter

    int z;
    va_arg(args, z);  // z is set to 5
}
</pre>   <h4 id="d_style_variadic_functions">D-style Variadic Functions</h4>  <p>Variadic functions with argument and type info are declared as taking a parameter of ... after the required function parameters. It has D linkage, and need not have any non-variadic parameters declared:</p>   <pre data-language="d">int abc(char c, ...);   // one required parameter: c
int def(...);           // ok
</pre>   <p>To access them, the following import is required:</p>  <pre data-language="d">import core.vararg;
</pre>  <p>These variadic functions have a special local variable declared for them, <code>_argptr</code>, which is a <code>core.vararg</code> reference to the first of the variadic arguments. To access the arguments, <code>_argptr</code> must be used in conjuction with <code>va_arg</code>:</p>  <pre data-language="d">import core.vararg;

void test()
{
    foo(3, 4, 5);   // first variadic argument is 5
}

void foo(int x, int y, ...)
{
    int z;

    z = va_arg!int(_argptr); // z is set to 5
}
</pre>  <p>An additional hidden argument with the name <code>_arguments</code> and type <code>TypeInfo[]</code> is passed to the function. <code>_arguments</code> gives the number of arguments and the type of each, enabling type safety to be checked at run time.</p>   <pre data-language="d">import std.stdio;
import core.vararg;

class Foo { int x = 3; }
class Bar { long y = 4; }

void printargs(int x, ...)
{
    writefln("%d arguments", _arguments.length);
    for (int i = 0; i &lt; _arguments.length; i++)
    {
        writeln(_arguments[i]);

        if (_arguments[i] == typeid(int))
        {
            int j = va_arg!(int)(_argptr);
            writefln("\t%d", j);
        }
        else if (_arguments[i] == typeid(long))
        {
            long j = va_arg!(long)(_argptr);
            writefln("\t%d", j);
        }
        else if (_arguments[i] == typeid(double))
        {
            double d = va_arg!(double)(_argptr);
            writefln("\t%g", d);
        }
        else if (_arguments[i] == typeid(Foo))
        {
            Foo f = va_arg!(Foo)(_argptr);
            writefln("\t%s", f);
        }
        else if (_arguments[i] == typeid(Bar))
        {
            Bar b = va_arg!(Bar)(_argptr);
            writefln("\t%s", b);
        }
        else
            assert(0);
    }
}

void main()
{
    Foo f = new Foo();
    Bar b = new Bar();

    writefln("%s", f);
    printargs(1, 2, 3L, 4.5, f, b);
}
</pre>   which prints:  <pre data-language="d">0x00870FE0
5 arguments
int
        2
long
        3
double
        4.5
Foo
        0x00870FE0
Bar
        0x00870FD0
</pre>  <p>D-style variadic functions cannot be marked as <code>@safe</code>.</p>   <h4 id="typesafe_variadic_functions">Typesafe Variadic Functions</h4>  <p>Typesafe variadic functions are used when the variable argument portion of the arguments are used to construct an array or class object.</p>  <p>For arrays:</p>   <pre data-language="d">int main()
{
    return sum(1, 2, 3) + sum(); // returns 6+0
}

int func()
{
    int[3] ii = [4, 5, 6];
    return sum(ii);             // returns 15
}

int sum(int[] ar ...)
{
    int s;
    foreach (int x; ar)
        s += x;
    return s;
}
</pre>   <p>For static arrays:</p>  <pre data-language="d">int test()
{
    return sum(2, 3);   // error, need 3 values for array
    return sum(1, 2, 3); // returns 6
}

int func()
{
    int[3] ii = [4, 5, 6];
    int[] jj = ii;
    return sum(ii); // returns 15
    return sum(jj); // error, type mismatch
}

int sum(int[3] ar ...)
{
    int s;
    foreach (int x; ar)
        s += x;
    return s;
}
</pre>  <p>For class objects:</p>  <pre data-language="d">class Foo
{
    int x;
    string s;

    this(int x, string s)
    {
        this.x = x;
        this.s = s;
    }
}

void test(int x, Foo f ...);

...

Foo g = new Foo(3, "abc");
test(1, g);         // ok, since g is an instance of Foo
test(1, 4, "def");  // ok
test(1, 5);         // error, no matching constructor for Foo
</pre>  <p>An implementation may construct the object or array instance on the stack. Therefore, it is an error to refer to that instance after the variadic function has returned:</p>  <pre data-language="d">Foo test(Foo f ...)
{
    return f;   // error, f instance contents invalid after return
}

int[] test(int[] a ...)
{
    return a;       // error, array contents invalid after return
    return a[0..1]; // error, array contents invalid after return
    return a.dup;   // ok, since copy is made
}
</pre>  <p>For other types, the argument is built with itself, as in:</p>  <pre data-language="d">int test(int i ...)
{
    return i;
}

...
test(3);    // returns 3
test(3, 4); // error, too many arguments
int[] x;
test(x);    // error, type mismatch
</pre>  <h4 id="lazy_variadic_functions">Lazy Variadic Functions</h4>  <p>If the variadic parameter is an array of delegates with no parameters: </p>  <pre data-language="d">void foo(int delegate()[] dgs ...);
</pre>  <p>Then each of the arguments whose type does not match that of the delegate is converted to a delegate. </p>  <pre data-language="d">int delegate() dg;
foo(1, 3+x, dg, cast(int delegate())null);
</pre>  <p>is the same as:</p>  <pre data-language="d">foo( { return 1; }, { return 3+x; }, dg, null );
</pre>  <p>The lazy variadic delegate solution is preferable to using a lazy variadic array, because each array index would evaluate every element:</p>  <pre data-language="d">import std.stdio;

void foo(lazy int[] arr...)
{
    writeln(arr[0]); // 1
    writeln(arr[1]); // 4, not 2
}

void main()
{
    int x;
    foo(++x, ++x);
}
</pre>  <h2><span id="Local Variables">Local Variables</span></h2>  <p>It is an error to use a local variable without first assigning it a value. The implementation may not always be able to detect these cases. Other language compilers sometimes issue a warning for this, but since it is always a bug, it should be an error. </p>  <p>It is an error to declare a local variable that hides another local variable in the same function: </p>  <pre data-language="d">void func(int x)
{
    int x;       // error, hides previous definition of x
    double y;
    ...
    {
        char y;  // error, hides previous definition of y
        int z;
    }
    {
        wchar z; // legal, previous z is out of scope
    }
}
</pre>  <p>While this might look unreasonable, in practice whenever this is done it either is a bug or at least looks like a bug. </p>  <p>It is an error to return the address of or a reference to a local variable. </p>  <p>It is an error to have a local variable and a label with the same name. </p>  <h3><span id="Local Static Variables">Local Static Variables</span></h3>  <p>Local variables in functions can be declared as static or <code>__gshared</code> in which case they are statically allocated rather than being allocated on the stack. As such, their value persists beyond the exit of the function. </p>   <pre data-language="d">void foo()
{
    static int n;
    if (++n == 100)
        writeln("called 100 times");
}
</pre>   <p>The initializer for a static variable must be evaluatable at compile time, and they are initialized upon the start of the thread (or the start of the program for <code>__gshared</code>). There are no static constructors or static destructors for static local variables. </p>  <p>Although static variable name visibility follows the usual scoping rules, the names of them must be unique within a particular function. </p>  <pre data-language="d">void main()
{
    { static int x; }
    { static int x; } // error
    { int i; }
    { int i; } // ok
}
</pre>  <h2 id="nested">Nested Functions</h2>  <p>Functions may be nested within other functions:</p>   <pre data-language="d">int bar(int a)
{
    int foo(int b)
    {
        int abc() { return 1; }

        return b + abc();
    }
    return foo(a);
}

void test()
{
    int i = bar(3); // i is assigned 4
}
</pre>   <p>Nested functions can be accessed only if the name is in scope.</p>  <pre data-language="d">void foo()
{
    void A()
    {
        B(); // error, B() is forward referenced
        C(); // error, C undefined
    }
    void B()
    {
        A(); // ok, in scope
        void C()
        {
            void D()
            {
                A();      // ok
                B();      // ok
                C();      // ok
                D();      // ok
            }
        }
    }
    A(); // ok
    B(); // ok
    C(); // error, C undefined
}
</pre>  and:  <pre data-language="d">int bar(int a)
{
    int foo(int b) { return b + 1; }
    int abc(int b) { return foo(b); }   // ok
    return foo(a);
}

void test()
{
    int i = bar(3);     // ok
    int j = bar.foo(3); // error, bar.foo not visible
}
</pre>  <p>Nested functions have access to the variables and other symbols defined by the lexically enclosing function. This access includes both the ability to read and write them. </p>   <pre data-language="d">int bar(int a)
{
    int c = 3;

    int foo(int b)
    {
        b += c;       // 4 is added to b
        c++;          // bar.c is now 5
        return b + c; // 12 is returned
    }
    c = 4;
    int i = foo(a); // i is set to 12
    return i + c;   // returns 17
}

void test()
{
    int i = bar(3); // i is assigned 17
}
</pre>   <p>This access can span multiple nesting levels:</p>   <pre data-language="d">int bar(int a)
{
    int c = 3;

    int foo(int b)
    {
        int abc()
        {
            return c;   // access bar.c
        }
        return b + c + abc();
    }
    return foo(3);
}
</pre>   <p>Static nested functions cannot access any stack variables of any lexically enclosing function, but can access static variables. This is analogous to how static member functions behave. </p>  <pre data-language="d">int bar(int a)
{
    int c;
    static int d;

    static int foo(int b)
    {
        b = d;          // ok
        b = c;          // error, foo() cannot access frame of bar()
        return b + 1;
    }
    return foo(a);
}
</pre>  <p>Functions can be nested within member functions:</p>   <pre data-language="d">struct Foo
{
    int a;

    int bar()
    {
        int c;

        int foo()
        {
            return c + a;
        }
        return 0;
    }
}
</pre>   <p>Nested functions always have the D function linkage type. </p>  <p>Unlike module level declarations, declarations within function scope are processed in order. This means that two nested functions cannot mutually call each other: </p>  <pre data-language="d">void test()
{
    void foo() { bar(); } // error, bar not defined
    void bar() { foo(); } // ok
}
</pre>  <p>There are several workarounds for this limitation:</p>  <ul> <li>Declare the functions to be static members of a nested struct:</li>  </ul>
<pre data-language="d">void test()
{
    static struct S
    {
        static void foo() { bar(); } // ok
        static void bar() { foo(); } // ok
    }

    S.foo();  // compiles (but note the infinite runtime loop)
}
</pre>  <li>Declare one or more of the functions to be function templates even if they take no specific template arguments:</li>   <pre data-language="d">void test()
{
    void foo()() { bar(); } // ok (foo is a function template)
    void bar()   { foo(); } // ok
}
</pre>   <li>Declare the functions inside of a mixin template:</li>   <pre data-language="d">mixin template T()
{
    void foo() { bar(); } // ok
    void bar() { foo(); } // ok
}

void main()
{
    mixin T!();
}
</pre>   <li>Use a delegate:</li>   <pre data-language="d">void test()
{
    void delegate() fp;
    void foo() { fp(); }
    void bar() { foo(); }
    fp = &amp;bar;
}
</pre>    <p>Nested functions cannot be overloaded.</p>  <h2 id="closures">Delegates, Function Pointers, and Closures</h2>  <p>A function pointer can point to a static nested function:</p>   <pre data-language="d">int function() fp;

void test()
{
    static int a = 7;
    static int foo() { return a + 3; }

    fp = &amp;foo;
}

void bar()
{
    test();
    int i = fp();       // i is set to 10
}
</pre>   <p><b>Note:</b> Two functions with identical bodies, or two functions that compile to identical assembly code, are not guaranteed to have distinct function pointer values. The compiler is free to merge functions bodies into one if they compile to identical code.</p>   <pre data-language="d">int abc(int x) { return x + 1; }
int def(int y) { return y + 1; }

int delegate(int) fp1 = &amp;abc;
int delegate(int) fp2 = &amp;def;
// Do not rely on fp1 and fp2 being different values; the compiler may merge
// them.
</pre>   <p>A delegate can be set to a non-static nested function:</p>   <pre data-language="d">int delegate() dg;

void test()
{
    int a = 7;
    int foo() { return a + 3; }

    dg = &amp;foo;
    int i = dg(); // i is set to 10
}
</pre>    <p>The stack variables referenced by a nested function are still valid even after the function exits (this is different from D 1.0). This is called a <i>closure</i>. Returning addresses of stack variables, however, is not a closure and is an error. </p>  <pre data-language="d">int* bar()
{
    int b;
    test();
    int i = dg(); // ok, test.a is in a closure and still exists
    return &amp;b;    // error, bar.b not valid after bar() exits
}
</pre>   <p>Delegates to non-static nested functions contain two pieces of data: the pointer to the stack frame of the lexically enclosing function (called the <i>frame pointer</i>) and the address of the function. This is analogous to struct/class non-static member function delegates consisting of a <i>this</i> pointer and the address of the member function. Both forms of delegates are interchangeable, and are actually the same type: </p>   <pre data-language="d">struct Foo
{
    int a = 7;
    int bar() { return a; }
}

int foo(int delegate() dg)
{
    return dg() + 1;
}

void test()
{
    int x = 27;
    int abc() { return x; }
    Foo f;
    int i;

    i = foo(&amp;abc);   // i is set to 28
    i = foo(&amp;f.bar); // i is set to 8
}
</pre>   <p>This combining of the environment and the function is called a <i>dynamic closure</i>. </p>  <p>The <code>.ptr</code> property of a delegate will return the <i>frame pointer</i> value as a <code>void*</code>. </p>  <p>The <code>.funcptr</code> property of a delegate will return the <i>function pointer</i> value as a function type. </p> <p>Functions and delegates declared at module scope are zero-initialized by default. However both can be initialized to any function pointer (including a function literal). For delegates, the context pointer <code>.ptr</code> is initialized to null. </p>   <pre data-language="d">int function() foo = { return 42; };
int delegate() bar = { return 43; };
int delegate() baz;
void main()
{
    assert(foo() == 42);
    assert(bar() == 43);
    assert(baz is null);
}
</pre>   <p>Function pointers can be passed to functions taking a delegate argument by passing them through the <a href="https://dlang.org/phobos/std_functional.html#toDelegate"><code>std.functional.toDelegate</code></a> template, which converts any callable to a delegate without context. </p>  <p><b>Future directions:</b> Function pointers and delegates may merge into a common syntax and be interchangeable with each other. </p>  <h3 id="anonymous">Anonymous Functions and Anonymous Delegates</h3>  <p>See <a href="expression#FunctionLiteral"><i>FunctionLiteral</i></a>s. </p>  <h2 id="main">
<code>main()</code> Function</h2>  <p>For console programs, <code>main()</code> serves as the entry point. It gets called after all the module initializers are run, and after any unittests are run. After it returns, all the module destructors are run. <code>main()</code> must be declared using one of the following forms: </p>  <pre data-language="d">void main() { ... }
void main(string[] args) { ... }
int main() { ... }
int main(string[] args) { ... }
</pre>  <h2 id="function-templates">Function Templates</h2>  <p>Template functions are useful for avoiding code duplication - instead of writing several copies of a function, each with a different parameter type, a single function template can be sufficient. For example: </p>   <pre data-language="d">// Only one copy of func needs to be written
void func(T)(T x)
{
    writeln(x);
}
void main()
{
    func!(int)(1); // pass an int
    func(1);    // pass an int, inferring T = int
    func("x");  // pass a string
    func(1.0);  // pass a float
    struct S {}
    S s;
    func(s);    // pass a struct
}
</pre>   <p><code>func</code> takes a template parameter <code>T</code> and a runtime parameter, <code>x</code>. <code>T</code> is a placeholder identifier that can accept any type. In this case <code>T</code> can be inferred from the runtime argument type.</p>  <p><b>Note:</b> Using the name <code>T</code> is just a convention. The name <code>TypeOfX</code> could have been used instead.</p>  <p>For more information, see <a href="template#function-templates">function templates</a>.</p>  <h2 id="interpretation">Compile Time Function Execution (CTFE)</h2>  <p>Functions which are both portable and free of global side-effects can be executed at compile time. In certain contexts, such compile time execution is guaranteed. It is called Compile Time Function Execution (CTFE) then. The contexts that trigger CTFE are:</p>  <ul> <li>initialization of a static variable or a <a href="enum#manifest_constants">manifest constant</a>
</li> <li>static initializers of struct/class members</li> <li>dimension of a <a href="arrays#static-arrays">static array</a>
</li> <li>argument for a <a href="template#template_value_parameter"> template value parameter</a>
</li> <li><a href="version#staticif"><code>static if</code></a></li> <li><a href="version#staticforeach"><code>static foreach</code></a></li> <li><a href="version#static-assert"><code>static assert</code></a></li> <li><a href="statement#mixin-statement"> <code>mixin</code> statement</a></li> <li><a href="pragma"><code>pragma</code> argument</a></li> </ul>   <pre data-language="d">enum eval(Args...) = Args[0];

int square(int i)
{
    return i * i;
}

void foo()
{
    static j = square(3);      // CTFE
    writeln(j);
    assert(square(4));         // run time
    writeln(eval!(square(5))); // CTFE
}
</pre>   <p>CTFE is subject to the following restrictions:</p>  <ol> <li>The function source code must be available to the compiler. Functions which exist in the source code only as <span class="d_keyword">extern</span> declarations cannot be executed in CTFE.</li>  <li>Executed expressions may not reference any global or local static variables.</li>  <li>
<span class="d_keyword">asm</span> statements are not permitted</li>  <li>Non-portable casts (eg, from <code>int[]</code> to <code>float[]</code>), including casts which depend on endianness, are not permitted. Casts between signed and unsigned types are permitted</li> <li>Reinterpretation of overlapped fields in a Union is not permitted.</li> </ol>  <p>Pointers are permitted in CTFE, provided they are used safely:</p>  <ul> <li> C-style semantics on pointer arithmetic are strictly enforced. Pointer arithmetic is permitted only on pointers which point to static or dynamic array elements. Such pointers must point to an element of the array, or to the first element past the array. Pointer arithmetic is completely forbidden on pointers which are null, or which point to a non-array. </li>  <li> The memory location of different memory blocks is not defined. Ordered comparison (<code>&lt;</code>, <code>&lt;</code><code>=</code>, <code>&gt;</code>, <code>&gt;=</code>) between two pointers is permitted when both pointers point to the same array, or when at least one pointer is <code>null</code>. </li>  <li> Pointer comparisons between independent memory blocks will generate a compile-time error, unless two such comparisons are combined using <code>&amp;&amp;</code> or <code>|</code><code>|</code> to yield a result which is independent of the ordering of memory blocks. Each comparison must consist of two pointer expressions compared with <code>&lt;</code>, <code>&lt;</code><code>=</code>, <code>&gt;</code>, or <code>&gt;</code><code>=</code>, and may optionally be negated with <code>!</code>.  <p> For example, the expression <code>(p1 &gt; q1 &amp;&amp; p2 &lt;= q2)</code> is permitted when <code>p1</code>, <code>p2</code> are expressions yielding pointers to memory block <i>P</i>, and <code>q1</code>, <code>q2</code> are expressions yielding pointers to memory block <i>Q</i>, even when <i>P</i> and <i>Q</i> are unrelated memory blocks. It returns true if <code>[p1..p2]</code> lies inside <code>[q1..q2]</code>, and false otherwise. Similarly, the expression <code>(p1 &lt; q1 || p2 &gt; q2)</code> is true if <code>[p1..p2]</code> lies outside <code>[q1..q2]</code>, and false otherwise. </p> </li>  <li> Equality comparisons (==, !=, <span class="d_keyword">is</span>, <span class="d_keyword">!is</span>) are permitted between all pointers, without restriction. </li>  <li> Any pointer may be cast to <code>void*</code> and from <code>void*</code> back to its original type. Casting between pointer and non-pointer types is prohibited. </li> </ul>  <p>Note that the above restrictions apply only to expressions which are actually executed. For example: </p> <pre data-language="d">static int y = 0;

int countTen(int x)
{
    if (x &gt; 10)
        ++y;
    return x;
}

static assert(countTen(6) == 6);    // OK
static assert(countTen(12) == 12);  // invalid, modifies y.
</pre> <p>The <code>__ctfe</code> boolean pseudo-variable, which evaluates to <span class="d_keyword">true</span> in CTFE, but <span class="d_keyword">false</span> otherwise, can be used to provide an alternative execution path to avoid operations which are forbidden in CTFE. Every usage of <code>__ctfe</code> is evaluated before code generation and therefore has no run-time cost, even if no optimizer is used. </p>  <p>Executing functions via CTFE can take considerably longer than executing it at run time. If the function goes into an infinite loop, it will hang at compile time (rather than hanging at run time). </p>  <p>Non-recoverable errors (such as <span class="d_keyword">assert</span> failures) do not throw exceptions; instead, they end interpretation immediately. </p>  <p>Functions executed via CTFE can give different results from run time in the following scenarios: </p>  <ul> <li>floating point computations may be done at a higher precision than run time</li> <li>dependency on implementation defined order of evaluation</li> <li>use of uninitialized variables</li>  </ul>  <p>These are the same kinds of scenarios where different optimization settings affect the results.</p>  <h3 id="string-mixins">String Mixins and Compile Time Function Execution</h3>  <p>Any functions that execute in CTFE must also be executable at run time. The compile time evaluation of a function does the equivalent of running the function at run time. This means that the semantics of a function cannot depend on compile time values of the function. For example:</p>  <pre data-language="d">int foo(string s)
{
    return mixin(s);
}

const int x = foo("1");
</pre>  is illegal, because the runtime code for <code>foo</code> cannot be generated. A function template would be the appropriate method to implement this sort of thing.  <h2 id="nogc-functions">No-GC Functions</h2>  <p>No-GC functions are functions marked with the <code>@nogc</code> attribute. Those functions do not allocate memory on the GC heap, through the following language features: </p>  <ul> <li>
<a href="https://dlang.org/expression.html#ArrayLiteral">constructing an array</a> on the heap</li> <li>resizing an array by writing to its <code>.length</code> property</li> <li>array <a href="https://dlang.org/expression.html#CatExpression">concatenation</a> and appending</li> <li>
<a href="https://dlang.org/expression.html#AssocArrayLiteral">constructing an associative array</a> on the heap</li> <li>
<a href="https://dlang.org/expression.html#IndexExpression">indexing</a> an associative array (because it may throw <code>RangeError</code> if the specified key is not present)</li> <li>
<a href="https://dlang.org/expression.html#NewExpression">allocating an object</a> on the heap</li> </ul>  <pre data-language="d">@nogc void foo()
{
    auto a = ['a'];    // error, allocates
    a.length = 1;      // error, array resizing allocates
    a = a ~ a;         // error, arrays concatenation allocates
    a ~= 'c';          // error, appending to arrays allocates

    auto aa = ["x":1]; // error, allocates
    aa["abc"];         // error, indexing may allocate and throws

    auto p = new int;  // error, operator new allocates
}
</pre>  <p>No-GC functions cannot call functions that are not <code>@nogc</code>. </p>  <pre data-language="d">@nogc void foo()
{
    bar();             // error, bar() may allocate
}

void bar() { }
</pre>  <p>No-GC functions cannot be closures. </p>  <pre data-language="d">@nogc int delegate() foo()
{
    int n;              // error, variable n cannot be allocated on heap
    return (){ return n; }
}
</pre>  <p><code>@nogc</code> affects the type of the function. A <code>@nogc</code> function is covariant with a non-<code>@nogc</code> function. </p>  <pre data-language="d">void function() fp;
void function() @nogc gp;  // pointer to @nogc function

void foo();
@nogc void bar();

void test()
{
    fp = &amp;foo; // ok
    fp = &amp;bar; // ok, it's covariant
    gp = &amp;foo; // error, not contravariant
    gp = &amp;bar; // ok
}
</pre>  <p>To ease debugging, in a <a href="version#ConditionalStatement"><i>ConditionalStatement</i></a> controlled by a <a href="version#DebugCondition"><i>DebugCondition</i></a> <code>@nogc</code> functions can call functions that are not <code>@nogc</code>.</p>  <h2 id="function-safety">Function Safety</h2>  <p><i>Safe functions</i> are functions that are statically checked to exhibit no possibility of <a href="https://dlang.org/glossary.html#undefined_behavior"><i>undefined behavior</i></a>. Undefined behavior is often used as a vector for malicious attacks. </p>  <h3 id="safe-functions">Safe Functions</h3>  <p>Safe functions are marked with the <code>@safe</code> attribute.</p>  <p>The following operations are not allowed in safe functions:</p>  <ul> <li>No casting from a pointer type to any type other than <code>void*</code>.</li> <li>No casting from any non-pointer type to a pointer type.</li> <li>No pointer arithmetic (including pointer indexing).</li> <li>Cannot access unions that have pointers or references overlapping with other types.</li> <li>Calling any system functions.</li> <li>No catching of exceptions that are not derived from <code>class Exception</code>.</li> <li>Disallow <code>@system</code> asm statements.</li> <li>No explicit casting of mutable objects to immutable.</li> <li>No explicit casting of immutable objects to mutable.</li> <li>No explicit casting of thread local objects to shared.</li> <li>No explicit casting of shared objects to thread local.</li> <li>No taking the address of a local variable or function parameter.</li> <li>Cannot access <code>__gshared</code> variables.</li> <li>Cannot use <code>void</code> initializers for pointers.</li> <li>Cannot use <code>void</code> initializers for class or interface references.</li> </ul>  <p>When indexing and slicing an array, an out of bounds access will cause a runtime error, in order to prevent undefined behavior. </p>  <p>Functions nested inside safe functions default to being safe functions. </p>  <p>Safe functions are covariant with trusted or system functions.</p>  <p><b>Note:</b> The verifiable safety of functions may be compromised by bugs in the compiler and specification. Please report all such errors so they can be corrected. </p>  <h3 id="trusted-functions">Trusted Functions</h3>  <p>Trusted functions are marked with the <code>@trusted</code> attribute.</p>  <p>Trusted functions are guaranteed to not exhibit any undefined behavior if called by a safe function. Furthermore, calls to trusted functions cannot lead to undefined behavior in <code>@safe</code> code that is executed afterwards. It is the responsibility of the programmer to ensure that these guarantees are upheld. </p>  <p>Example:</p>  <pre data-language="d">immutable(int)* f(int* p) @trusted
{
    version (none) p[2] = 13;
    // Invalid. p[2] is out of bounds. This line would exhibit undefined
    // behavior.

    version (none) p[1] = 13;
    // Invalid. In this program, p[1] happens to be in-bounds, so the
    // line would not exhibit undefined behavior, but a trusted function
    // is not allowed to rely on this.

    version (none) return cast(immutable) p;
    // Invalid. @safe code still has mutable access and could trigger
    // undefined behavior by overwriting the value later on.

    int* p2 = new int;
    *p2 = 42;
    return cast(immutable) p2;
    // Valid. After f returns, no mutable aliases of p2 can exist.
}

void main() @safe
{
    int[2] a = [10, 20];
    int* mp = &amp;a[0];
    immutable(int)* ip = f(mp);
    assert(a[1] == 20); // Guaranteed. f cannot access a[1].
    assert(ip !is mp); // Guaranteed. f cannot introduce unsafe aliasing.
}
</pre>  <p>Trusted functions may call safe, trusted, or system functions. </p>  <p>Trusted functions are covariant with safe or system functions.</p>  <b>Best Practices:</b> Trusted functions should be kept small so that they are easier to manually verify.   <h3 id="system-functions">System Functions</h3>  <p>System functions are functions not marked with <code>@safe</code> or <code>@trusted</code> and are not nested inside <code>@safe</code> functions. System functions may be marked with the <code>@system</code> attribute. A function being system does not mean it actually is unsafe, it just means that the compiler is unable to verify that it cannot exhibit undefined behavior. </p>  <p>System functions are <b>not</b> covariant with trusted or safe functions. </p>   <h2 id="function-attribute-inference">Function Attribute Inference</h2>  <p><a href="expression#FunctionLiteral"><i>FunctionLiteral</i></a>s and <a href="template#function-templates">function template</a>s, since their function bodies are always present, infer the <a href="#pure-functions"><code>pure</code></a>, <a href="#nothrow-functions"><code>nothrow</code></a>, <a href="#safe-functions"><code>@safe</code></a>, and <a href="#nogc-functions"><code>@nogc</code></a> attributes unless specifically overridden. </p>  <p>Attribute inference is not done for other functions, even if the function body is present. </p>  <p>The inference is done by determining if the function body follows the rules of the particular attribute. </p>  <p>Cyclic functions (i.e. functions that wind up directly or indirectly calling themselves) are inferred as being impure, throwing, and @system. </p>  <p>If a function attempts to test itself for those attributes, then the function is inferred as not having those attributes. </p>  <h2 id="pseudo-member">Uniform Function Call Syntax (UFCS)</h2>  <p>A free function can be called with a syntax that looks as if the function were a member function of its first parameter type. </p>  <pre data-language="d">void func(X thisObj);

X obj;
obj.func();
// If 'obj' does not have regular member 'func',
// it's automatically rewritten to 'func(obj)'
</pre>  <p>This provides a way to add functions to a class externally as if they were public final member functions, which enables <a href="http://www.drdobbs.com/architecture-and-design/component-programming-in-d/240008321"> function chaining and component programming</a>. </p>  <pre data-language="d">stdin.byLine(KeepTerminator.yes)
    .map!(a =&gt; a.idup)
    .array
    .sort
    .copy(stdout.lockingTextWriter());
</pre>  <p>It also works with <code>@property</code> functions:</p>  <pre data-language="d">@property prop(X thisObj);
@property prop(X thisObj, int value);

X obj;
obj.prop;      // Rewrites to: prop(obj);
obj.prop = 1;  // Rewrites to: prop(obj, 1);
</pre>  <p>Syntactically parenthesis-less check for <code>@property</code> functions is done at the same time as UFCS rewrite.</p>  <p>When UFCS rewrite is necessary, compiler searches the name on accessible module level scope, in order from the innermost scope.</p>  <pre data-language="d">module a;
void foo(X);
alias boo = foo;
void main()
{
    void bar(X);
    import b : baz;  // void baz(X);

    X obj;
    obj.foo();    // OK, calls a.foo;
    //obj.bar();  // NG, UFCS does not see nested functions
    obj.baz();    // OK, calls b.baz, because it is declared at the
                  // top level scope of module b

    import b : boo = baz;
    obj.boo();    // OK, calls aliased b.baz instead of a.boo (== a.foo),
                  // because the declared alias name 'boo' in local scope
                  // overrides module scope name
}
class C
{
    void mfoo(X);
    static void sbar(X);
    import b : ibaz = baz;  // void baz(X);
    void test()
    {
        X obj;
        //obj.mfoo();  // NG, UFCS does not see member functions
        //obj.sbar();  // NG, UFCS does not see static member functions
        obj.ibaz();    // OK, ibaz is an alias of baz which declared at
                       //     the top level scope of module b
    }
}
</pre>  <p>The reason why local symbols are not considered by UFCS, is to avoid unexpected name conflicts. See below problematic examples.</p>  <pre data-language="d">int front(int[] arr) { return arr[0]; }

void main()
{
    int[] a = [1,2,3];
    auto x = a.front();   // call .front by UFCS

    auto front = x;       // front is now a variable
    auto y = a.front();   // Error, front is not a function
}

class C
{
    int[] arr;
    int front()
    {
        return arr.front(); // Error, C.front is not callable
                            // using argument types (int[])
    }
}
</pre>     <div class="_attribution">
  <p class="_attribution-p">
    Â© 1999â€“2019 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/spec/function.html" class="_attribution-link">https://dlang.org/spec/function.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
