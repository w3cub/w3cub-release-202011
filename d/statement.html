
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>11. Statements - D - W3cubDocs</title>
  
  <meta name="description" content="The order of execution within a function is controlled by Statements. A function&#39;s body consists of a sequence of zero or more Statements. &hellip;">
  <meta name="keywords" content="statements, d">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/d/statement.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/d.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/d/" class="_nav-link" title="" style="margin-left:0;">D</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _d">
				
				
<h1>Statements</h1>       <b>Contents</b>  <ol> <li><a href="#scope-statement">Scope Statements</a></li> <li><a href="#scope-block-statement">Scope Block Statements</a></li> <li><a href="#labeled-statement">Labeled Statements</a></li> <li><a href="#block-statement">Block Statement</a></li> <li><a href="#expression-statement">Expression Statement</a></li> <li><a href="#declaration-statement">Declaration Statement</a></li> <li><a href="#if-statement">If Statement</a></li> <li><a href="#while-statement">While Statement</a></li> <li><a href="#do-statement">Do Statement</a></li> <li><a href="#for-statement">For Statement</a></li> <li>
<a href="#foreach-statement">Foreach Statement</a><ol> <li><a href="#foreach_over_arrays">Foreach over Arrays</a></li> <li><a href="#foreach_over_arrays_of_characters">Foreach over Arrays of Characters</a></li> <li><a href="#foreach_over_associative_arrays">Foreach over Associative Arrays</a></li> <li><a href="#foreach_over_struct_and_classes">Foreach over Structs and Classes with opApply</a></li> <li><a href="#foreach-with-ranges">Foreach over Structs and Classes with Ranges</a></li> <li><a href="#foreach_over_delegates">Foreach over Delegates</a></li> <li><a href="#foreach_over_tuples">Foreach over Sequences</a></li> <li><a href="#foreach_ref_parameters">Foreach Ref Parameters</a></li> <li><a href="#foreach_restrictions">Foreach Restrictions</a></li> </ol>
</li> <li>
<a href="#foreach-range-statement">Foreach Range Statement</a><ol> <li><a href="#break_and_continue_out_of_foreach">Break and Continue out of Foreach</a></li> </ol>
</li> <li><a href="#switch-statement">Switch Statement</a></li> <li><a href="#final-switch-statement">Final Switch Statement</a></li> <li><a href="#continue-statement">Continue Statement</a></li> <li><a href="#break-statement">Break Statement</a></li> <li><a href="#return-statement">Return Statement</a></li> <li><a href="#goto-statement">Goto Statement</a></li> <li><a href="#with-statement">With Statement</a></li> <li><a href="#synchronized-statement">Synchronized Statement</a></li> <li><a href="#try-statement">Try Statement</a></li> <li><a href="#throw-statement">Throw Statement</a></li> <li>
<a href="#scope-guard-statement">Scope Guard Statement</a><ol> <li><a href="#catching_cpp_class_objects">Catching C++ Class Objects</a></li> </ol>
</li> <li><a href="#asm">Asm Statement</a></li> <li><a href="#pragma-statement">Pragma Statement</a></li> <li><a href="#mixin-statement">Mixin Statement</a></li> </ol>   <p>The order of execution within a function is controlled by <a href="#Statement"><i>Statement</i></a>s. A function's body consists of a sequence of zero or more <i>Statement</i>s. Execution occurs in lexical order, though certain statements may have deferred effects. A <i>Statement</i> has no value; it is executed for its effects. </p>  <pre>Statement:
    ;
    NonEmptyStatement
    ScopeBlockStatement

NoScopeNonEmptyStatement:
    NonEmptyStatement
    BlockStatement

NoScopeStatement:
    ;
    NonEmptyStatement
    BlockStatement

NonEmptyOrScopeBlockStatement:
    NonEmptyStatement
    ScopeBlockStatement

NonEmptyStatement:
    NonEmptyStatementNoCaseNoDefault
    CaseStatement
    CaseRangeStatement
    DefaultStatement

NonEmptyStatementNoCaseNoDefault:
    LabeledStatement
    ExpressionStatement
    DeclarationStatement
    IfStatement
    WhileStatement
    DoStatement
    ForStatement
    ForeachStatement
    SwitchStatement
    FinalSwitchStatement
    ContinueStatement
    BreakStatement
    ReturnStatement
    GotoStatement
    WithStatement
    SynchronizedStatement
    TryStatement
    ScopeGuardStatement
    ThrowStatement
    AsmStatement
    PragmaStatement
    MixinStatement
    ForeachRangeStatement
    ConditionalStatement
    StaticForeachStatement
    StaticAssert
    TemplateMixin
    ImportDeclaration
</pre>   <p>Any ambiguities in the grammar between <i>Statement</i>s and <a href="declaration#Declaration"><i>Declaration</i></a>s are resolved by the declarations taking precedence. Wrapping such a statement in parentheses will disambiguate it in favor of being a <i>Statement</i>. </p>  <h2><span id="ScopeStatement">Scope Statements</span></h2>  <pre>ScopeStatement:
    NonEmptyStatement
    BlockStatement
</pre>  <p>A new scope for local symbols is introduced for the <i>NonEmptyStatement</i> or <a href="#BlockStatement"><i>BlockStatement</i></a>. </p>  <p>Even though a new scope is introduced, local symbol declarations cannot shadow (hide) other local symbol declarations in the same function. </p>  <pre data-language="d">void func1(int x)
{
    int x;    // illegal, x shadows parameter x

    int y;

    { int y; } // illegal, y shadows enclosing scope's y

    void delegate() dg;
    dg = { int y; }; // ok, this y is not in the same function

    struct S
    {
        int y;    // ok, this y is a member, not a local
    }

    { int z; }
    { int z; }  // ok, this z is not shadowing the other z

    { int t; }
    { t++;   }  // illegal, t is undefined
}
</pre>  <b>Best Practices:</b> Local declarations within a function should all have unique names, even if they are in non-overlapping scopes.    <h2><span id="ScopeBlockStatement">Scope Block Statements</span></h2>  <pre>ScopeBlockStatement:
    BlockStatement
</pre>  <p>A scope block statement introduces a new scope for the <a href="#BlockStatement"><i>BlockStatement</i></a>. </p>  <h2><span id="LabeledStatement">Labeled Statements</span></h2>  <p> Statements can be labeled. A label is an identifier that precedes a statement. </p>  <pre>LabeledStatement:
    Identifier :
    Identifier : NoScopeStatement
    Identifier : Statement
</pre>  <p> Any statement can be labeled, including empty statements, and so can serve as the target of a goto statement. Labeled statements can also serve as the target of a break or continue statement. </p> <p> A label can appear without a following statement at the end of a block. </p> <p> Labels are in a name space independent of declarations, variables, types, etc. Even so, labels cannot have the same name as local declarations. The label name space is the body of the function they appear in. Label name spaces do not nest, i.e. a label inside a block statement is accessible from outside that block. </p>  <p>Labels in one function cannot be referenced from another function.</p>   <h2><span id="BlockStatement">Block Statement</span></h2>  <pre>BlockStatement:
    { }
    { StatementList }

StatementList:
    Statement
    Statement StatementList
</pre>  <p>A block statement is a sequence of statements enclosed by <code>{ }</code>. The statements are executed in lexical order, until the end of the block is reached or a statement transfers control elsewhere. </p>   <h2><span id="ExpressionStatement">Expression Statement</span></h2>  <pre>ExpressionStatement:
    Expression ;
</pre>  <p>The expression is evaluated.</p>  <p>Expressions that have no effect, like <code>(x + x)</code>, are illegal as expression statements unless the are cast to <span class="d_keyword">void</span>.</p>  <pre data-language="d">int x;
x++;               // ok
x;                 // illegal
1+1;               // illegal
cast(void)(x + x); // ok
</pre>   <h2><span id="DeclarationStatement">Declaration Statement</span></h2>  <p>Declaration statements define variables, and declare types, templates, functions, imports, conditionals, static foreaches, and static asserts. </p>  <pre>DeclarationStatement:
    StorageClassesopt Declaration
</pre>  <p>Some declaration statements:</p>  <pre data-language="d">int a;        // declare a as type int and initialize it to 0
struct S { }  // declare struct s
alias myint = int;
</pre>  <h2><span id="IfStatement">If Statement</span></h2>  <p>If statements provide simple conditional execution of statements.</p>  <pre>IfStatement:
    if ( IfCondition ) ThenStatement
    if ( IfCondition ) ThenStatement else ElseStatement

IfCondition:
    Expression
    auto Identifier = Expression
    TypeCtors Identifier = Expression
    TypeCtorsopt BasicType Declarator = Expression

ThenStatement:
    ScopeStatement

ElseStatement:
    ScopeStatement
</pre>  <p><a href="expression#Expression"><i>Expression</i></a> is evaluated and must have a type that can be converted to a boolean. If it's true the <i>ThenStatement</i> is transferred to, else the <i>ElseStatement</i> is transferred to.</p>  <p>The <i>ElseStatement</i>is associated with the innermost if statement which does not already have an associated <i>ElseStatement</i>.</p>  <p>If an <code>auto</code> <i>Identifier</i> is provided, it is declared and initialized to the value and type of the <a href="expression#Expression"><i>Expression</i></a>. Its scope extends from when it is initialized to the end of the <i>ThenStatement</i>.</p>  <p>If a <i>TypeCtors</i> <i>Identifier</i> is provided, it is declared to be of the type specified by <i>TypeCtors</i> and is initialized with the value of the <a href="expression#Expression"><i>Expression</i></a>. Its scope extends from when it is initialized to the end of the <i>ThenStatement</i>.</p>  <p>If a <i>Declarator</i> is provided, it is declared and initialized to the value of the <a href="expression#Expression"><i>Expression</i></a>. Its scope extends from when it is initialized to the end of the <i>ThenStatement</i>.</p>  <pre data-language="d">import std.regex;
...
if (auto m = std.regex.matchFirst("abcdef", "b(c)d"))
{
    writefln("[%s]", m.pre);    // prints [a]
    writefln("[%s]", m.post);   // prints [ef]
    writefln("[%s]", m[0]);     // prints [bcd]
    writefln("[%s]", m[1]);     // prints [c]
}
else
{
    writeln(m.post); // Error: undefined identifier 'm'
}
writeln(m.pre);      // Error: undefined identifier 'm'
</pre>  <h2><span id="WhileStatement">While Statement</span></h2>  <pre>WhileStatement:
    while ( Expression ) ScopeStatement
</pre>  <p>A <i>While Statement</i> implements a simple loop.</p>  <p><a href="expression#Expression"><i>Expression</i></a> is evaluated and must have a type that can be converted to a boolean. If it's true the <a href="#ScopeStatement"><i>ScopeStatement</i></a> is executed. After the <a href="#ScopeStatement"><i>ScopeStatement</i></a> is executed, the <a href="expression#Expression"><i>Expression</i></a> is evaluated again, and if true the <a href="#ScopeStatement"><i>ScopeStatement</i></a> is executed again. This continues until the <a href="expression#Expression"><i>Expression</i></a> evaluates to false.</p>  <pre data-language="d">int i = 0;
while (i &lt; 10)
{
    foo(i);
    ++i;
}
</pre>  <p>A <a href="#BreakStatement"><i>BreakStatement</i></a> will exit the loop.</p>  <p>A <a href="#ContinueStatement"><i>ContinueStatement</i></a> will transfer directly to evaluating <a href="expression#Expression"><i>Expression</i></a> again.</p>  <p>A <i>While Statement</i> is equivalent to:</p>  <pre data-language="d">for (; Expression; ) ScopeStatement
</pre>  <h2><span id="DoStatement">Do Statement</span></h2>  <pre>DoStatement:
    do ScopeStatement  while ( Expression ) ;
</pre>   <p>Do while statements implement simple loops.</p>  <p><a href="#ScopeStatement"><i>ScopeStatement</i></a> is executed. Then <a href="expression#Expression"><i>Expression</i></a> is evaluated and must have a type that can be converted to a boolean. If it's true the loop is iterated again. This continues until the <a href="expression#Expression"><i>Expression</i></a> evaluates to false.</p>  <pre data-language="d">int i = 0;
do
{
    foo(i);
} while (++i &lt; 10);
</pre>  <p>A <a href="#BreakStatement"><i>BreakStatement</i></a> will exit the loop. A <a href="#ContinueStatement"><i>ContinueStatement</i></a> will transfer directly to evaluating <a href="expression#Expression"><i>Expression</i></a> again.</p>  <h2><span id="ForStatement">For Statement</span></h2>  <p>For statements implement loops with initialization, test, and increment clauses.</p>  <pre>ForStatement:
    for ( Initialize Testopt ; Incrementopt ) ScopeStatement

Initialize:
    ;
    NoScopeNonEmptyStatement

Test:
    Expression

Increment:
    Expression
</pre>  <p><i>Initialize</i> is executed. <i>Test</i> is evaluated and must have a type that can be converted to a boolean. If it's true the statement is executed. After the statement is executed, the <i>Increment</i> is executed. Then <i>Test</i> is evaluated again, and if true the statement is executed again. This continues until the <i>Test</i> evaluates to false. </p>  <p>A <a href="#BreakStatement"><i>BreakStatement</i></a> will exit the loop. A <a href="#ContinueStatement"><i>ContinueStatement</i></a> will transfer directly to the <i>Increment</i>. </p>  <p>A <i>ForStatement</i> creates a new scope. If <i>Initialize</i> declares a variable, that variable's scope extends through the end of the for statement. For example: </p>  <pre data-language="d">for (int i = 0; i &lt; 10; i++)
    foo(i);
</pre>  is equivalent to:  <pre data-language="d">{
    int i;
    for (i = 0; i &lt; 10; i++)
        foo(i);
}
</pre>  <p>Function bodies cannot be empty:</p>  <pre data-language="d">for (int i = 0; i &lt; 10; i++)
    ;       // illegal
</pre>  Use instead:  <pre data-language="d">for (int i = 0; i &lt; 10; i++)
{
}
</pre>  <p>The <i>Initialize</i> may be omitted (although the trailing <code>;</code> is still required). <i>Test</i> may also be omitted, and if so, it is treated as if it evaluated to true.</p>  <b>Best Practices:</b> Consider replacing <i>ForStatements</i> with <a href="statement#foreach-statement">Foreach Statements</a> or <a href="statement#ForeachRangeStatement">Foreach Range Statements</a>. Foreach loops are easier to understand, less prone to error, and easier to refactor.   <h2><span id="ForeachStatement">Foreach Statement</span></h2>  <p>A <code>foreach</code> statement loops over the contents of an aggregate.</p>  <pre>AggregateForeach:
    Foreach ( ForeachTypeList ; ForeachAggregate )

ForeachStatement:
    AggregateForeach NoScopeNonEmptyStatement

Foreach:
    foreach
    foreach_reverse

ForeachTypeList:
    ForeachType
    ForeachType , ForeachTypeList

ForeachType:
    ForeachTypeAttributesopt BasicType Declarator
    ForeachTypeAttributesopt Identifier
    ForeachTypeAttributesopt alias Identifier

ForeachTypeAttributes
    ForeachTypeAttribute
    ForeachTypeAttribute ForeachTypeAttributesopt

ForeachTypeAttribute:
    ref
    TypeCtor
    enum

ForeachAggregate:
    Expression
</pre>  <p> <i>ForeachAggregate</i> is evaluated. It must evaluate to an expression of type static array, dynamic array, associative array, struct, class, delegate, or sequence. The <a href="#NoScopeNonEmptyStatement"><i>NoScopeNonEmptyStatement</i></a> is executed, once for each element of the aggregate. At the start of each iteration, the variables declared by the <i>ForeachTypeList</i> are set to be a copy of the elements of the aggregate. If the variable is <code>ref</code>, it is a reference to the contents of that aggregate. </p> <p> The aggregate must be loop invariant, meaning that elements to the aggregate cannot be added or removed from it in the <a href="#NoScopeNonEmptyStatement"><i>NoScopeNonEmptyStatement</i></a>. </p>  <h3 id="foreach_over_arrays">Foreach over Arrays</h3>  <p> If the aggregate is a static or dynamic array, there can be one or two variables declared. If one, then the variable is said to be the <i>value</i> set to the elements of the array, one by one. The type of the variable must match the type of the array contents, except for the special cases outlined below. If there are two variables declared, the first is said to be the <i>index</i> and the second is said to be the <i>value</i>. The <i>index</i> must be of type <code>size_t</code> for dynamic arrays. Static arrays may use any integral type that spans the length of the array. <i>index</i> cannot be <code>ref</code>. It is set to be the index of the array element. </p> <pre data-language="d">char[] a;
...
foreach (int i, char c; a)
{
    writefln("a[%d] = '%c'", i, c);
}
</pre>  <p>For <code>foreach</code>, the elements for the array are iterated over starting at index 0 and continuing to the maximum of the array. For <code>foreach_reverse</code>, the array elements are visited in the reverse order. </p>  <p><b>Note:</b> The <i>ForeachTypeAttribute</i> is implicit, and when a type is not specified, it is inferred. In that case, <code>auto</code> is implied, and it is not necessary (and actually forbidden) to use it. </p>  <pre data-language="d">int[] arr;
...
foreach (n; arr) // ok, n is an int
    writeln(n);

foreach (auto n; arr) // error, auto is redundant
    writeln(n);
</pre>  <h3 id="foreach_over_arrays_of_characters">Foreach over Arrays of Characters</h3>  <p>If the aggregate expression is a static or dynamic array of <code>char</code>s, <code>wchar</code>s, or <code>dchar</code>s, then the <i>Type</i> of the <i>value</i> can be any of <code>char</code>, <code>wchar</code>, or <code>dchar</code>. In this manner any UTF array can be decoded into any UTF type: </p>  <pre data-language="d">char[] a = "\xE2\x89\xA0".dup;  // \u2260 encoded as 3 UTF-8 bytes

foreach (dchar c; a)
{
    writefln("a[] = %x", c); // prints 'a[] = 2260'
}

dchar[] b = "\u2260"d.dup;

foreach (char c; b)
{
    writef("%x, ", c);  // prints 'e2, 89, a0, '
}
</pre>   <p>Aggregates can be string literals, which can be accessed as char, wchar, or dchar arrays: </p>  <pre data-language="d">void test()
{
    foreach (char c; "ab")
    {
        writefln("'%s'", c);
    }
    foreach (wchar w; "xy")
    {
        writefln("'%s'", w);
    }
}
</pre>  <p>which would print: </p>  <pre>'a'
'b'
'x'
'y'
</pre>  <h3 id="foreach_over_associative_arrays">Foreach over Associative Arrays</h3>  <p>If the aggregate expression is an associative array, there can be one or two variables declared. If one, then the variable is said to be the <i>value</i> set to the elements of the array, one by one. The type of the variable must match the type of the array contents. If there are two variables declared, the first is said to be the <i>index</i> and the second is said to be the <i>value</i>. The <i>index</i> must be of the same type as the indexing type of the associative array. It cannot be <code>ref</code>, and it is set to be the index of the array element. The order in which the elements of the array are iterated over is unspecified for <code>foreach</code>. <code>foreach_reverse</code> for associative arrays is illegal. </p>  <pre data-language="d">double[string] a; // index type is string, value type is double
...
foreach (string s, double d; a)
{
    writefln("a['%s'] = %g", s, d);
}
</pre>  <h3 id="foreach_over_struct_and_classes">Foreach over Structs and Classes with opApply</h3>  <p>If the aggregate expression is a struct or class object, the <code>foreach</code> is defined by the special <span id="opApply"><code>opApply</code></span> member function, and the <code>foreach_reverse</code> behavior is defined by the special <span id="opApplyReverse"><code>opApplyReverse</code></span> member function. These functions have the type: </p>  <pre data-language="d">int opApply(scope int delegate(ref Type [, ...]) dg);

int opApplyReverse(scope int delegate(ref Type [, ...]) dg);
</pre>  <p>where <i>Type</i> matches the <i>Type</i> used in the <i>ForeachType</i> declaration of <i>Identifier</i>. Multiple <i>ForeachType</i>s correspond with multiple <i>Type</i>s in the delegate type passed to <code>opApply</code> or <code>opApplyReverse</code>. There can be multiple <code>opApply</code> and <code>opApplyReverse</code> functions, one is selected by matching the type of <i>dg</i> to the <i>ForeachType</i>s of the <i>ForeachStatement</i>. The body of the apply function iterates over the elements it aggregates, passing them each to the <i>dg</i> function. If the <i>dg</i> returns 0, then apply goes on to the next element. If the <i>dg</i> returns a nonzero value, apply must cease iterating and return that value. Otherwise, after done iterating across all the elements, apply will return 0. </p>  <p>For example, consider a class that is a container for two elements:</p>  <pre data-language="d">class Foo
{
    uint[2] array;

    int opApply(scope int delegate(ref uint) dg)
    {
        int result = 0;

        for (int i = 0; i &lt; array.length; i++)
        {
            result = dg(array[i]);
            if (result)
                break;
        }
        return result;
    }
}
</pre>  <p>An example using this might be:</p>  <pre data-language="d">void test()
{
    Foo a = new Foo();

    a.array[0] = 73;
    a.array[1] = 82;

    foreach (uint u; a)
    {
        writefln("%d", u);
    }
}
</pre>  <p>which would print:</p>  <pre>73
82
</pre> <p>The <code>scope</code> storage class on the <i>dg</i> parameter means that the parameter's value does not escape the scope of the <i>opApply</i> function (an example would be assigning <i>dg</i> to a global). If it cannot be statically guaranteed that <i>dg</i> does not escape, a closure may be allocated for it on the heap instead of the stack. Best practice is to annotate delegate parameters with <code>scope</code> when possible. </p>  <p><span id="opApply"><i>opApply</i></span> can also be a templated function, which will infer the types of parameters based on the <i>ForeachStatement</i>. </p>  <p>For example:</p>  <pre data-language="d">struct S
{
    import std.traits : ParameterTypeTuple;  // introspection template

    int opApply(Dg)(scope Dg dg)
    if (ParameterTypeTuple!Dg.length == 2) // foreach with 2 parameters
    {
        return 0;
    }

    int opApply(Dg)(scope Dg dg)
    if (ParameterTypeTuple!Dg.length == 3) // foreach with takes 3 parameters
    {
        return 0;
    }
}

void main()
{
    foreach (int a, int b; S()) { }  // calls first opApply function
    foreach (int a, int b, float c; S()) { }  // calls second opApply function
}
</pre>  <p>It is important to make sure that, if <code>opApply</code> catches any exceptions, that those exceptions did not originate from the delegate passed to <i>opApply</i>. The user would expect exceptions thrown from a <code>foreach</code> body to both terminate the loop, and propagate outside the <code>foreach</code> body. </p>  <h3><span id="foreach_with_ranges">Foreach over Structs and Classes with Ranges</span></h3>  <p>If the aggregate expression is a struct or class object, but the <code>opApply</code> for <code>foreach</code>, or <code>opApplyReverse</code> <code>foreach_reverse</code> do not exist, then iteration over struct and class objects can be done with range primitives. For <code>foreach</code>, this means the following properties and methods must be defined: </p>  <table>
<caption>Foreach Range Properties</caption> <tr>
<th class="donthyphenate"><b>Property</b></th>
<th class="donthyphenate"><b>Purpose</b></th>
</tr> <tr>
<td><code>.empty</code></td>
<td>returns true if no more elements</td>
</tr> <tr>
<td><code>.front</code></td>
<td>return the leftmost element of the range</td>
</tr> </table>  <table>
<caption>Foreach Range Methods</caption> <tr>
<th class="donthyphenate"><b>Method</b></th>
<th class="donthyphenate"><b>Purpose</b></th>
</tr> <tr>
<td><code>.popFront()</code></td>
<td>move the left edge of the range right by one</td>
</tr> </table>  <p>Meaning:</p>  <pre data-language="d">foreach (e; range) { ... }
</pre>  <p>translates to:</p>  <pre data-language="d">for (auto __r = range; !__r.empty; __r.popFront())
{
    auto e = __r.front;
    ...
}
</pre>  <p>Similarly, for <code>foreach_reverse</code>, the following properties and methods must be defined: </p>  <table>
<caption>Foreach_reverse Range Properties</caption> <tr>
<th class="donthyphenate"><b>Property</b></th>
<th class="donthyphenate"><b>Purpose</b></th>
</tr> <tr>
<td><code>.empty</code></td>
<td>returns true if no more elements</td>
</tr> <tr>
<td><code>.back</code></td>
<td>return the rightmost element of the range</td>
</tr> </table>  <table>
<caption>Foreach_reverse Range Methods</caption> <tr>
<th class="donthyphenate"><b>Method</b></th>
<th class="donthyphenate"><b>Purpose</b></th>
</tr> <tr>
<td><code>.popBack()</code></td>
<td>move the right edge of the range left by one</td>
</tr> </table>  <p>Meaning:</p>  <pre data-language="d">foreach_reverse (e; range) { ... }
</pre>  <p>translates to:</p>  <pre data-language="d">for (auto __r = range; !__r.empty; __r.popBack())
{
    auto e = __r.back;
    ...
}
</pre>  <h3 id="foreach_over_delegates">Foreach over Delegates</h3>  <p>If <i>ForeachAggregate</i> is a delegate, the type signature of the delegate is of the same as for <code>opApply</code>. This enables many different named looping strategies to coexist in the same class or struct.</p>  <p>For example:</p>  <pre data-language="d">void main()
{
    // Custom loop implementation, that iterates over powers of 2 with
    // alternating sign. The loop body is passed in dg.
    int myLoop(int delegate(ref int) dg)
    {
        for (int z = 1; z &lt; 128; z *= -2)
        {
            auto ret = dg(z);

            // If the loop body contains a break, ret will be non-zero.
            if (ret != 0)
                return ret;
        }
        return 0;
    }

    // This example loop simply collects the loop index values into an array.
    int[] result;
    foreach (ref x; &amp;myLoop)
    {
        result ~= x;
    }
    assert(result == [1, -2, 4, -8, 16, -32, 64, -128]);
}
</pre>  <p><b>Note:</b> When <i>ForeachAggregate</i> is a delegate, the compiler does not try to implement reverse traversal of the results returned by the delegate when <code>foreach_reverse</code> is used. This may result in code that is confusing to read. Therefore, using <code>foreach_reverse</code> with a delegate is now deprecated, and will be rejected in the future.</p>  <h3 id="foreach_over_tuples">Foreach over Sequences</h3>  <p> If the aggregate expression is a sequence, there can be one or two iteration symbols declared. If one, then the symbol is an <i>element alias</i> of each element in the sequence in turn. </p>
<p> If the sequence is a <i>TypeSeq</i>, then the foreach statement is executed once for each type, and the element alias is set to each type. </p>
<p> When the sequence is a <i>ValueSeq</i>, the element alias is a variable and is set to each value in the sequence. If the type of the variable is given, it must match the type of the sequence contents. If no type is given, the type of the variable is set to the type of the sequence element, which may change from iteration to iteration. </p>
<p> If there are two symbols declared, the first is the <i>index variable</i> and the second is the <i>element alias</i>. The index must be of <code>int</code>, <code>uint</code>, <code>long</code> or <code>ulong</code> type, it cannot be <code>ref</code>, and it is set to the index of each sequence element. </p> <p>Example:</p> <pre data-language="d">import std.meta : AliasSeq;

void main()
{
    alias Seq = AliasSeq!(int, "literal", main);

    foreach (sym; Seq)
    {
        pragma(msg, sym.stringof);
    }
}
</pre> <p>Output:</p>  <pre>int
"literal"
main()
</pre>  <p>See also: <a href="version#staticforeach">Static Foreach</a>.</p>  <h3 id="foreach_ref_parameters">Foreach Ref Parameters</h3>  <p><code>ref</code> can be used to update the original elements: </p>  <pre data-language="d">void test()
{
    static uint[2] a = [7, 8];

    foreach (ref uint u; a)
    {
        u++;
    }
    foreach (uint u; a)
    {
        writefln("%d", u);
    }
}
</pre>  which would print:  <pre>8
9
</pre> <p><code>ref</code> can not be applied to the index values.</p>  <p>If not specified, the <i>Type</i>s in the <i>ForeachType</i> can be inferred from the type of the <i>ForeachAggregate</i>. </p>  <h3 id="foreach_restrictions">Foreach Restrictions</h3>  <p>The aggregate itself must not be resized, reallocated, free'd, reassigned or destructed while the foreach is iterating over the elements. </p>  <pre data-language="d">int[] a;
int[] b;
foreach (int i; a)
{
    a = null;       // error
    a.length += 10; // error
    a = b;          // error
}
a = null;         // ok
</pre>  <h2><span id="ForeachRangeStatement">Foreach Range Statement</span></h2>  <p>A foreach range statement loops over the specified range.</p>  <pre>RangeForeach:
    Foreach ( ForeachType ; LwrExpression .. UprExpression )

LwrExpression:
    Expression

UprExpression:
    Expression

ForeachRangeStatement:
    RangeForeach ScopeStatement
</pre>  <p> <i>ForeachType</i> declares a variable with either an explicit type, or a type inferred from <i>LwrExpression</i> and <i>UprExpression</i>. The <i>ScopeStatement</i> is then executed <i>n</i> times, where <i>n</i> is the result of <i>UprExpression</i> - <i>LwrExpression</i>. If <i>UprExpression</i> is less than or equal to <i>LwrExpression</i>, the <i>ScopeStatement</i> is executed zero times. If <i>Foreach</i> is <code>foreach</code>, then the variable is set to <i>LwrExpression</i>, then incremented at the end of each iteration. If <i>Foreach</i> is <code>foreach_reverse</code>, then the variable is set to <i>UprExpression</i>, then decremented before each iteration. <i>LwrExpression</i> and <i>UprExpression</i> are each evaluated exactly once, regardless of how many times the <i>ScopeStatement</i> is executed. </p>  <pre data-language="d">import std.stdio;

int foo()
{
    write("foo");
    return 10;
}

void main()
{
    foreach (i; 0 .. foo())
    {
        write(i);
    }
}
</pre>  prints:  <pre>foo0123456789
</pre>   <h3 id="break_and_continue_out_of_foreach">Break and Continue out of Foreach</h3>   <p>A <a href="#BreakStatement"><i>BreakStatement</i></a> in the body of the foreach will exit the foreach, a <a href="#ContinueStatement"><i>ContinueStatement</i></a> will immediately start the next iteration. </p>  <h2><span id="SwitchStatement">Switch Statement</span></h2>  A switch statement goes to one of a collection of case statements depending on the value of the switch expression.  <pre>SwitchStatement:
    switch ( Expression ) ScopeStatement

CaseStatement:
    case ArgumentList : ScopeStatementList

CaseRangeStatement:
    case FirstExp : .. case LastExp : ScopeStatementList

FirstExp:
    AssignExpression

LastExp:
    AssignExpression

DefaultStatement:
    default : ScopeStatementList

ScopeStatementList:
    StatementListNoCaseNoDefault

StatementListNoCaseNoDefault:
    StatementNoCaseNoDefault
    StatementNoCaseNoDefault StatementListNoCaseNoDefault

StatementNoCaseNoDefault:
    ;
    NonEmptyStatementNoCaseNoDefault
    ScopeBlockStatement
</pre>  <p><a href="expression#Expression"><i>Expression</i></a> is evaluated. The result type T must be of integral type or <code>char[]</code>, <code>wchar[]</code> or <code>dchar[]</code>. The result is compared against each of the case expressions. If there is a match, the corresponding case statement is transferred to. </p>  <p>The case expressions, <a href="expression#ArgumentList"><i>ArgumentList</i></a>, are a comma separated list of expressions. </p>  <p>A <i>CaseRangeStatement</i> is a shorthand for listing a series of case statements from <i>FirstExp</i> to <i>LastExp</i>. </p>   <p>If none of the case expressions match, and there is a default statement, the default statement is transferred to. </p>   <p>A switch statement must have a default statement.</p>   <p>The case expressions must all evaluate to a constant value or array, or a runtime initialized const or immutable variable of integral type. They must be implicitly convertible to the type of the switch <a href="expression#Expression"><i>Expression</i></a>. </p>  <p>Case expressions must all evaluate to distinct values. Const or immutable variables must all have different names. If they share a value, the first case statement with that value gets control. There must be exactly one default statement.</p>  <p>The <a href="#ScopeStatementList"><i>ScopeStatementList</i></a> introduces a new scope. </p>  <p>Case statements and default statements associated with the switch can be nested within block statements; they do not have to be in the outermost block. For example, this is allowed: </p>  <pre data-language="d">switch (i)
{
    case 1:
    {
        case 2:
    }
    break;
}
</pre>    <p>A <a href="#ScopeStatementList"><i>ScopeStatementList</i></a> must either be empty, or be ended with a <a href="#ContinueStatement"><i>ContinueStatement</i></a>, <a href="#BreakStatement"><i>BreakStatement</i></a>, <a href="#ReturnStatement"><i>ReturnStatement</i></a>, <a href="#GotoStatement"><i>GotoStatement</i></a>, <a href="#ThrowStatement"><i>ThrowStatement</i></a> or assert(0) expression unless this is the last case. This is to set apart with C's error-prone implicit fall-through behavior. <code>goto case;</code> could be used for explicit fall-through: </p>  <pre data-language="d">int number;
string message;
switch (number)
{
    default:    // valid: ends with 'throw'
        throw new Exception("unknown number");

    case 3:     // valid: ends with 'break' (break out of the 'switch' only)
        message ~= "three ";
        break;

    case 4:     // valid: ends with 'continue' (continue the enclosing loop)
        message ~= "four ";
        continue;

    case 5:     // valid: ends with 'goto' (explicit fall-through to next case.)
        message ~= "five ";
        goto case;

    case 6:     // ERROR: implicit fall-through
        message ~= "six ";

    case 1:     // valid: the body is empty
    case 2:     // valid: this is the last case in the switch statement.
        message = "one or two";
}
</pre>  <p>A break statement will exit the switch <i>BlockStatement</i>.</p>   <p id="string-switch">Strings can be used in switch expressions. For example: </p>  <pre data-language="d">string name;
...
switch (name)
{
    case "fred":
    case "sally":
        ...
}
</pre>  <p>For applications like command line switch processing, this can lead to much more straightforward code, being clearer and less error prone. char, wchar and dchar strings are allowed. </p>  <p><code>Implementation Note:</code> The compiler's code generator may assume that the case statements are sorted by frequency of use, with the most frequent appearing first and the least frequent last. Although this is irrelevant as far as program correctness is concerned, it is of performance interest. </p>  <h2><span id="FinalSwitchStatement">Final Switch Statement</span></h2>  <pre>FinalSwitchStatement:
    final switch ( Expression ) ScopeStatement
</pre>  <p>A final switch statement is just like a switch statement, except that:</p>  <ul> <li>No <a href="#DefaultStatement"><i>DefaultStatement</i></a> is allowed.</li> <li>No <a href="#CaseRangeStatement"><i>CaseRangeStatement</i></a>s are allowed.</li> <li>If the switch <a href="expression#Expression"><i>Expression</i></a> is of enum type, all the enum members must appear in the <a href="#CaseStatement"><i>CaseStatement</i></a>s.</li> <li>The case expressions cannot evaluate to a run time initialized value.</li> </ul>    <h2><span id="ContinueStatement">Continue Statement</span></h2>  <pre>ContinueStatement:
    continue Identifieropt ;
</pre>  <p><code>continue</code> aborts the current iteration of its enclosing loop statement, and starts the next iteration.</p>  <p>continue executes the next iteration of its innermost enclosing while, for, foreach, or do loop. The increment clause is executed.</p>  <p>If continue is followed by <i>Identifier</i>, the <i>Identifier</i> must be the label of an enclosing while, for, or do loop, and the next iteration of that loop is executed. It is an error if there is no such statement.</p>  <p>Any intervening finally clauses are executed, and any intervening synchronization objects are released.</p>  <p><code>Note:</code> If a finally clause executes a throw out of the finally clause, the continue target is never reached.</p>  <pre data-language="d">for (i = 0; i &lt; 10; i++)
{
    if (foo(i))
        continue;
    bar();
}
</pre>  <h2><span id="BreakStatement">Break Statement</span></h2>  <pre>BreakStatement:
    break Identifieropt ;
</pre>  <p><code>break</code> exits the innermost enclosing while, for, foreach, do, or switch statement, resuming execution at the statement following it.</p>  <p>If break is followed by <i>Identifier</i>, the <i>Identifier</i> must be the label of an enclosing while, for, do or switch statement, and that statement is exited. It is an error if there is no such statement.</p>  <p>Any intervening finally clauses are executed, and any intervening synchronization objects are released.</p>  <p><code>Note:</code> If a finally clause executes a throw out of the finally clause, the break target is never reached.</p>  <pre data-language="d">for (i = 0; i &lt; 10; i++)
{
    if (foo(i))
        break;
}
</pre>  <h2><span id="ReturnStatement">Return Statement</span></h2>  <pre>ReturnStatement:
    return Expressionopt ;
</pre>  <p><code>return</code> exits the current function and supplies its return value.</p>  <p><a href="expression#Expression"><i>Expression</i></a> is required if the function specifies a return type that is not void. The <a href="expression#Expression"><i>Expression</i></a> is implicitly converted to the function return type.</p>  <p>At least one return statement, throw statement, or assert(0) expression is required if the function specifies a return type that is not void, unless the function contains inline assembler code.</p>  <p>Before the function actually returns, any objects with scope storage duration are destroyed, any enclosing finally clauses are executed, any scope(exit) statements are executed, any scope(success) statements are executed, and any enclosing synchronization objects are released.</p>  <p>The function will not return if any enclosing finally clause does a return, goto or throw that exits the finally clause.</p>  <p>If there is an out postcondition (see <a href="contracts">Contract Programming</a>), that postcondition is executed after the <a href="expression#Expression"><i>Expression</i></a> is evaluated and before the function actually returns.</p>  <pre data-language="d">int foo(int x)
{
    return x + 3;
}
</pre>  <h2><span id="GotoStatement">Goto Statement</span></h2>  <pre>GotoStatement:
    goto Identifier ;
    goto default ;
    goto case ;
    goto case Expression ;
</pre>  <p><code>goto</code> transfers to the statement labeled with <i>Identifier</i>.</p>  <pre data-language="d">    if (foo)
        goto L1;
    x = 3;
L1:
    x++;
</pre>  <p>The second form, <code>goto default;</code>, transfers to the innermost <a href="#DefaultStatement"><i>DefaultStatement</i></a> of an enclosing <a href="#SwitchStatement"><i>SwitchStatement</i></a>.</p>  <p>The third form, <code>goto case;</code>, transfers to the next <a href="#CaseStatement"><i>CaseStatement</i></a> of the innermost enclosing <a href="#SwitchStatement"><i>SwitchStatement</i></a>.</p>  <p>The fourth form, <code>goto case</code> <a href="expression#Expression"><i>Expression</i></a><code>;</code>, transfers to the <a href="#CaseStatement"><i>CaseStatement</i></a> of the innermost enclosing <a href="#SwitchStatement"><i>SwitchStatement</i></a> with a matching <a href="expression#Expression"><i>Expression</i></a>.</p>  <pre data-language="d">switch (x)
{
    case 3:
        goto case;
    case 4:
        goto default;
    case 5:
        goto case 4;
    default:
        x = 4;
        break;
}
</pre>  <p>Any intervening finally clauses are executed, along with releasing any intervening synchronization mutexes.</p>  <p>It is illegal for a <i>GotoStatement</i> to be used to skip initializations.</p>  <h2><span id="WithStatement">With Statement</span></h2>  <p>The <code>with</code> statement is a way to simplify repeated references to the same object.</p>  <pre>WithStatement:
    with ( Expression ) ScopeStatement
    with ( Symbol ) ScopeStatement
    with ( TemplateInstance ) ScopeStatement
</pre>  where <a href="expression#Expression"><i>Expression</i></a> evaluates to a class reference or struct instance. Within the with body the referenced object is searched first for identifier symbols.  <p>The <i>WithStatement</i></p>  <pre data-language="d">with (expression)
{
    ...
    ident;
}
</pre>  is semantically equivalent to:  <pre data-language="d">{
    Object tmp;
    tmp = expression;
    ...
    tmp.ident;
}
</pre>  <p>Note that <a href="expression#Expression"><i>Expression</i></a> only gets evaluated once and is not copied. The with statement does not change what <code>this</code> or <code>super</code> refer to. </p>  <p>For <i>Symbol</i> which is a scope or <i>TemplateInstance</i>, the corresponding scope is searched when looking up symbols. For example: </p>  <pre data-language="d">struct Foo
{
    alias Y = int;
}
...
Y y;        // error, Y undefined
with (Foo)
{
    Y y;    // same as Foo.Y y;
}
</pre>  <p>Use of with object symbols that shadow local symbols with the same identifier are not allowed. This is to reduce the risk of inadvertent breakage of with statements when new members are added to the object declaration. </p> <pre data-language="d">struct S
{
    float x;
}

void main()
{
    int x;
    S s;
    with (s)
    {
        x++;  // error, shadows the int x declaration
    }
}
</pre>  <p>In nested <i>WithStatement</i>s, the inner-most scope takes precedence. If a symbol cannot be resolved at the inner-most scope, resolution is forwarded incrementally up the scope hierarchy.</p> <pre data-language="d">import std.stdio;

struct Foo
{
    void f() { writeln("Foo.f"); }
}

struct Bar
{
    void f() { writeln("Bar.f"); }
}

struct Baz
{
    // f() is not implemented
}

void f()
{
    writeln("f");
}

void main()
{
    Foo foo;
    Bar bar;
    Baz baz;

    f();               // prints "f"

    with(foo)
    {
        f();           // prints "Foo.f"

        with(bar)
        {
            f();       // prints "Bar.f"

            with(baz)
            {
                f();   // prints "Bar.f".  `Baz` does not implement `f()` so
                       // resolution is forwarded to `with(bar)`'s scope
            }
        }
        with(baz)
        {
            f();       // prints "Foo.f".  `Baz` does not implement `f()` so
                       // resolution is forwarded to `with(foo)`'s scope
        }
    }
    with(baz)
    {
        f();           // prints "f".  `Baz` does not implement `f()` so
                       // resolution is forwarded to `main`'s scope. `f()` is
                       // not implemented in `main`'s scope, so resolution is
                       // subsequently forward to module scope.
    }
}

</pre>  <h2><span id="SynchronizedStatement">Synchronized Statement</span></h2>  <p>The synchronized statement wraps a statement with a mutex to synchronize access among multiple threads. </p>  <pre>SynchronizedStatement:
    synchronized ScopeStatement
    synchronized ( Expression ) ScopeStatement
</pre>  <p>Synchronized allows only one thread at a time to execute <i>ScopeStatement</i> by using a mutex. </p>  <p>What mutex is used is determined by the <a href="expression#Expression"><i>Expression</i></a>. If there is no <a href="expression#Expression"><i>Expression</i></a>, then a global mutex is created, one per such synchronized statement. Different synchronized statements will have different global mutexes. </p>  <p>If there is an <a href="expression#Expression"><i>Expression</i></a>, it must evaluate to either an Object or an instance of an <i>Interface</i>, in which case it is cast to the Object instance that implemented that <i>Interface</i>. The mutex used is specific to that Object instance, and is shared by all synchronized statements referring to that instance. </p>  <p>The synchronization gets released even if <i>ScopeStatement</i> terminates with an exception, goto, or return. </p>  <p>Example: </p>  <pre data-language="d">synchronized { ... }
</pre>  <p>This implements a standard critical section. </p>  <p>Synchronized statements support recursive locking; that is, a function wrapped in synchronized is allowed to recursively call itself and the behavior will be as expected: The mutex will be locked and unlocked as many times as there is recursion. </p>  <h2><span id="TryStatement">Try Statement</span></h2>  <p>Exception handling is done with the try-catch-finally statement.</p>  <pre>TryStatement:
    try ScopeStatement Catches
    try ScopeStatement Catches FinallyStatement
    try ScopeStatement FinallyStatement

Catches:
    Catch
    Catch Catches

Catch:
    catch ( CatchParameter ) NoScopeNonEmptyStatement

CatchParameter:
    BasicType Identifieropt

FinallyStatement:
    finally NoScopeNonEmptyStatement
</pre>  <p><i>CatchParameter</i> declares a variable v of type T, where T is Throwable or derived from Throwable. v is initialized by the throw expression if T is of the same type or a base class of the throw expression. The catch clause will be executed if the exception object is of type T or derived from T.</p>  <p>If just type T is given and no variable v, then the catch clause is still executed. </p>  <p>It is an error if any <i>CatchParameter</i> type T1 hides a subsequent <i>Catch</i> with type T2, i.e. it is an error if T1 is the same type as or a base class of T2. </p>  <p>The <i>FinallyStatement</i> is always executed, whether the <code>try</code> <i>ScopeStatement</i> exits with a goto, break, continue, return, exception, or fall-through. </p>  <p>If an exception is raised in the <i>FinallyStatement</i> and is not caught before the original exception is caught, it is chained to the previous exception via the <i>next</i> member of <i>Throwable</i>. Note that, in contrast to most other programming languages, the new exception does not replace the original exception. Instead, later exceptions are regarded as 'collateral damage' caused by the first exception. The original exception must be caught, and this results in the capture of the entire chain. </p>  <p>Thrown objects derived from <i>Error</i> are treated differently. They bypass the normal chaining mechanism, such that the chain can only be caught by catching the first <i>Error</i>. In addition to the list of subsequent exceptions, <i>Error</i> also contains a pointer that points to the original exception (the head of the chain) if a bypass occurred, so that the entire exception history is retained.</p>  <pre data-language="d">import std.stdio;

int main()
{
    try
    {
        try
        {
            throw new Exception("first");
        }
        finally
        {
            writeln("finally");
            throw new Exception("second");
        }
    }
    catch (Exception e)
    {
        writeln("catch %s", e.msg);
    }
    writeln("done");
    return 0;
}
</pre>  prints:  <pre>finally
catch first
done
</pre>   <p>A <i>FinallyStatement</i> may not exit with a goto, break, continue, or return; nor may it be entered with a goto. </p>  <p>A <i>FinallyStatement</i> may not contain any <i>Catches</i>. This restriction may be relaxed in future versions. </p>  <h2><span id="ThrowStatement">Throw Statement</span></h2>  <p>Throws an exception.</p>  <pre>ThrowStatement:
    throw Expression ;
</pre>  <p><a href="expression#Expression"><i>Expression</i></a> is evaluated and must be a <code>Throwable</code> reference. The <code>Throwable</code> reference is thrown as an exception.</p>  <pre data-language="d">throw new Exception("message");
</pre>  <h2><span id="ScopeGuardStatement">Scope Guard Statement</span></h2>  <pre>ScopeGuardStatement:
    scope(exit) NonEmptyOrScopeBlockStatement
    scope(success) NonEmptyOrScopeBlockStatement
    scope(failure) NonEmptyOrScopeBlockStatement
</pre>  <p>The <i>ScopeGuardStatement</i> executes <a href="#NonEmptyOrScopeBlockStatement"><i>NonEmptyOrScopeBlockStatement</i></a> at the close of the current scope, rather than at the point where the <i>ScopeGuardStatement</i> appears. <code>scope(exit)</code> executes <a href="#NonEmptyOrScopeBlockStatement"><i>NonEmptyOrScopeBlockStatement</i></a> when the scope exits normally or when it exits due to exception unwinding. <code>scope(failure)</code> executes <a href="#NonEmptyOrScopeBlockStatement"><i>NonEmptyOrScopeBlockStatement</i></a> when the scope exits due to exception unwinding. <code>scope(success)</code> executes <a href="#NonEmptyOrScopeBlockStatement"><i>NonEmptyOrScopeBlockStatement</i></a> when the scope exits normally.</p>  <p>If there are multiple <i>ScopeGuardStatement</i>s in a scope, they will be executed in the reverse lexical order in which they appear. If any scope instances are to be destroyed upon the close of the scope, their destructions will be interleaved with the <i>ScopeGuardStatement</i>s in the reverse lexical order in which they appear.</p>   <pre data-language="d">write("1");
{
    write("2");
    scope(exit) write("3");
    scope(exit) write("4");
    write("5");
}
writeln();
</pre>  writes:  <pre>12543
</pre>   <pre data-language="d">{
    scope(exit) write("1");
    scope(success) write("2");
    scope(exit) write("3");
    scope(success) write("4");
}
writeln();
</pre>  writes:  <pre>4321
</pre>   <pre data-language="d">struct Foo
{
    this(string s) { write(s); }
    ~this() { write("1"); }
}

try
{
    scope(exit) write("2");
    scope(success) write("3");
    Foo f = Foo("0");
    scope(failure) write("4");
    throw new Exception("msg");
    scope(exit) write("5");
    scope(success) write("6");
    scope(failure) write("7");
}
catch (Exception e)
{
}
writeln();
</pre>  writes:  <pre>0412
</pre>  A <code>scope(exit)</code> or <code>scope(success)</code> statement may not exit with a throw, goto, break, continue, or return; nor may it be entered with a goto.  <h3 id="catching_cpp_class_objects">Catching C++ Class Objects</h3>  <p> On many platforms, catching C++ class objects is supported. Catching C++ objects and D objects cannot both be done in the same <i>TryStatement</i>. Upon exit from the <i>Catch</i>, any destructors for the C++ object will be run and the storage used for it reclaimed. C++ objects cannot be caught in <code>@safe</code> code. </p>  <h2 id="asm">Asm Statement</h2>  <p>Inline assembler is supported with the asm statement:</p>  <pre>AsmStatement:
    asm FunctionAttributesopt { AsmInstructionListopt }

AsmInstructionList:
    AsmInstruction ;
    AsmInstruction ; AsmInstructionList
</pre>  <p>An asm statement enables the direct use of assembly language instructions. This makes it easy to obtain direct access to special CPU features without resorting to an external assembler. The D compiler will take care of the function calling conventions, stack setup, etc.</p>  <p>The format of the instructions is, of course, highly dependent on the native instruction set of the target CPU, and so is <a href="iasm">implementation defined</a>. But, the format will follow the following conventions:</p>  <ul> <li>It must use the same tokens as the D language uses.</li> <li>The comment form must match the D language comments.</li> <li>Asm instructions are terminated by a ;, not by an end of line.</li> </ul>  These rules exist to ensure that D source code can be tokenized independently of syntactic or semantic analysis.  <p>For example, for the Intel Pentium:</p>  <pre data-language="d">int x = 3;
asm
{
    mov EAX,x; // load x and put it in register EAX
}
</pre>  <p>Inline assembler can be used to access hardware directly:</p>  <pre data-language="d">int gethardware()
{
    asm
    {
        mov EAX, dword ptr 0x1234;
    }
}
</pre>  <p>For some D implementations, such as a translator from D to C, an inline assembler makes no sense, and need not be implemented. The version statement can be used to account for this:</p>  <pre data-language="d">version (D_InlineAsm_X86)
{
    asm
    {
        ...
    }
}
else
{
    /* ... some workaround ... */
}
</pre>  <p>Semantically consecutive <i>AsmStatement</i>s shall not have any other instructions (such as register save or restores) inserted between them by the compiler. </p>  <h2><span id="PragmaStatement">Pragma Statement</span></h2>  <pre>PragmaStatement:
    Pragma NoScopeStatement
</pre>  <h2><span id="MixinStatement">Mixin Statement</span></h2>  <pre>MixinStatement:
    mixin ( ArgumentList ) ;
</pre>  <p>Each <a href="expression#AssignExpression"><i>AssignExpression</i></a> in the <i>ArgumentList</i> is evaluated at compile time, and the result must be representable as a string. The resulting strings are concatenated to form a string. The text contents of the string must be compilable as a valid <a href="#StatementList"><i>StatementList</i></a>, and is compiled as such. </p>  <pre data-language="d">import std.stdio;

void main()
{
    int j;
    mixin("
        int x = 3;
        for (int i = 0; i &lt; 3; i++)
            writeln(x + i, ++j);
        ");    // ok

    string s = "int y;";
    mixin(s);  // ok
    y = 4;     // ok, mixin declared y

    string t = "y = 3;";
    mixin(t);  // error, t is not evaluatable at compile time

    mixin("y =") 4; // error, string must be complete statement

    mixin("y =" ~ "4;");  // ok

    mixin("y =", 2+2, ";");  // ok
}
</pre>     <div class="_attribution">
  <p class="_attribution-p">
     19992019 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/spec/statement.html" class="_attribution-link">https://dlang.org/spec/statement.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
