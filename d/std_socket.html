
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>std.socket - D - W3cubDocs</title>
  
  <meta name="description" content=" Socket primitives. ">
  <meta name="keywords" content="std, socket, d">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/d/std_socket.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/d.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/d/" class="_nav-link" title="" style="margin-left:0;">D</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _d">
				
				
<h1>std.socket</h1>  <p>Socket primitives. </p>
<dl>
<dt>Example</dt>
<dd> See <span class="sample_src"><a class="https" href="https://github.com/dlang/dmd/blob/master/samples/listener.d">/dmd/samples/d/listener.d</a></span> and <span class="sample_src"><a class="https" href="https://github.com/dlang/dmd/blob/master/samples/htmlget.d">/dmd/samples/d/htmlget.d</a></span> </dd>
</dl> <dl>
<dt>License:</dt>
<dd>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>Christopher E. Miller, <a href="http://klickverbot.at">David Nadlinger</a>, <a href="http://thecybershadow.net">Vladimir Panteleev</a> </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/socket.d">std/socket.d</a></span>
</dd>
</dl> <dl>
<dt class="d_decl" id="core.sys.posix.netinet.in_">public import <strong id="core.sys.posix.netinet.in_">core.sys.posix.netinet.in_</strong>; </dt>  <dt class="d_decl" id="SocketException">class <strong id="SocketException">SocketException</strong>: object.Exception; </dt> <dd>
<p>Base exception thrown by <code>std.socket</code>.</p> </dd> <dt class="d_decl" id="lastSocketError">@property @safe string <strong id="lastSocketError">lastSocketError</strong>(); </dt> <dd>
<p>Retrieve the error message for the most recently encountered network error.</p> </dd> <dt class="d_decl" id="SocketOSException">class <strong id="SocketOSException">SocketOSException</strong>: std.socket.SocketException; </dt> <dd>
<p>Socket exceptions representing network errors reported by the operating system.</p> <dl>
<dt class="d_decl" id="SocketOSException.errorCode">int <strong id="errorCode">errorCode</strong>; </dt> <dd>
<p>Platform-specific error code.</p> </dd> <dt class="d_decl" id="SocketOSException.this">@safe this(string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null, int err = _lasterr(), string function(int) @trusted errorFormatter = &amp;formatSocketError); </dt>  <dt class="d_decl" id="SocketOSException.this.2">@safe this(string msg, Throwable next, string file = __FILE__, size_t line = __LINE__, int err = _lasterr(), string function(int) @trusted errorFormatter = &amp;formatSocketError); </dt>  <dt class="d_decl" id="SocketOSException.this.3">@safe this(string msg, int err, string function(int) @trusted errorFormatter = &amp;formatSocketError, string file = __FILE__, size_t line = __LINE__, Throwable next = null); </dt>  </dl> </dd> <dt class="d_decl" id="SocketParameterException">class <strong id="SocketParameterException">SocketParameterException</strong>: std.socket.SocketException; </dt> <dd>
<p>Socket exceptions representing invalid parameters specified by user code.</p> </dd> <dt class="d_decl" id="SocketFeatureException">class <strong id="SocketFeatureException">SocketFeatureException</strong>: std.socket.SocketException; </dt> <dd>
<p>Socket exceptions representing attempts to use network capabilities not available on the current system.</p> </dd> <dt class="d_decl" id="wouldHaveBlocked">nothrow @nogc @safe bool <strong id="wouldHaveBlocked">wouldHaveBlocked</strong>(); </dt> <dd>
<dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if the last socket operation failed because the socket was in non-blocking mode and the operation would have blocked.</dd>
</dl> </dd> <dt class="d_decl" id="AddressFamily">enum <strong id="AddressFamily">AddressFamily</strong>: ushort; </dt> <dd>
<p>The communication domain used to resolve an address.</p> <dl>
<dt class="d_decl" id="AddressFamily.UNSPEC"><strong id="UNSPEC">UNSPEC</strong></dt> <dd>
<p>Unspecified address family</p> </dd> <dt class="d_decl" id="AddressFamily.UNIX"><strong id="UNIX">UNIX</strong></dt> <dd>
<p>Local communication</p> </dd> <dt class="d_decl" id="AddressFamily.INET"><strong id="INET">INET</strong></dt> <dd>
<p>Internet Protocol version 4</p> </dd> <dt class="d_decl" id="AddressFamily.IPX"><strong id="IPX">IPX</strong></dt> <dd>
<p>Novell IPX</p> </dd> <dt class="d_decl" id="AddressFamily.APPLETALK"><strong id="APPLETALK">APPLETALK</strong></dt> <dd>
<p>AppleTalk</p> </dd> <dt class="d_decl" id="AddressFamily.INET6"><strong id="INET6">INET6</strong></dt> <dd>
<p>Internet Protocol version 6</p> </dd> </dl> </dd> <dt class="d_decl" id="SocketType">enum <strong id="SocketType">SocketType</strong>: int; </dt> <dd>
<p>Communication semantics</p> <dl>
<dt class="d_decl" id="SocketType.STREAM"><strong id="STREAM">STREAM</strong></dt> <dd>
<p>Sequenced, reliable, two-way communication-based byte streams</p> </dd> <dt class="d_decl" id="SocketType.DGRAM"><strong id="DGRAM">DGRAM</strong></dt> <dd>
<p>Connectionless, unreliable datagrams with a fixed maximum length; data may be lost or arrive out of order</p> </dd> <dt class="d_decl" id="SocketType.RAW"><strong id="RAW">RAW</strong></dt> <dd>
<p>Raw protocol access</p> </dd> <dt class="d_decl" id="SocketType.RDM"><strong id="RDM">RDM</strong></dt> <dd>
<p>Reliably-delivered message datagrams</p> </dd> <dt class="d_decl" id="SocketType.SEQPACKET"><strong id="SEQPACKET">SEQPACKET</strong></dt> <dd>
<p>Sequenced, reliable, two-way connection-based datagrams with a fixed maximum length</p> </dd> </dl> </dd> <dt class="d_decl" id="ProtocolType">enum <strong id="ProtocolType">ProtocolType</strong>: int; </dt> <dd>
<p>Protocol</p> <dl>
<dt class="d_decl" id="ProtocolType.IP"><strong id="IP">IP</strong></dt> <dd>
<p>Internet Protocol version 4</p> </dd> <dt class="d_decl" id="ProtocolType.ICMP"><strong id="ICMP">ICMP</strong></dt> <dd>
<p>Internet Control Message Protocol</p> </dd> <dt class="d_decl" id="ProtocolType.IGMP"><strong id="IGMP">IGMP</strong></dt> <dd>
<p>Internet Group Management Protocol</p> </dd> <dt class="d_decl" id="ProtocolType.GGP"><strong id="GGP">GGP</strong></dt> <dd>
<p>Gateway to Gateway Protocol</p> </dd> <dt class="d_decl" id="ProtocolType.TCP"><strong id="TCP">TCP</strong></dt> <dd>
<p>Transmission Control Protocol</p> </dd> <dt class="d_decl" id="ProtocolType.PUP"><strong id="PUP">PUP</strong></dt> <dd>
<p>PARC Universal Packet Protocol</p> </dd> <dt class="d_decl" id="ProtocolType.UDP"><strong id="UDP">UDP</strong></dt> <dd>
<p>User Datagram Protocol</p> </dd> <dt class="d_decl" id="ProtocolType.IDP"><strong id="IDP">IDP</strong></dt> <dd>
<p>Xerox NS protocol</p> </dd> <dt class="d_decl" id="ProtocolType.RAW"><strong id="RAW">RAW</strong></dt> <dd>
<p>Raw IP packets</p> </dd> <dt class="d_decl" id="ProtocolType.IPV6"><strong id="IPV6">IPV6</strong></dt> <dd>
<p>Internet Protocol version 6</p> </dd> </dl> </dd> <dt class="d_decl" id="Protocol">class <strong id="Protocol">Protocol</strong>; </dt> <dd>
<p><code>Protocol</code> is a class for retrieving protocol information. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto proto = new Protocol;
writeln("About protocol TCP:");
if (proto.getProtocolByType(ProtocolType.TCP))
{
    writefln("  Name: %s", proto.name);
    foreach (string s; proto.aliases)
         writefln("  Alias: %s", s);
}
else
    writeln("  No information found");
</pre>  <dl>
<dt class="d_decl" id="Protocol.type">ProtocolType <strong id="type">type</strong>; <br><br>string <strong id="name">name</strong>; <br><br>string[] <strong id="aliases">aliases</strong>; </dt> <dd>
<p>These members are populated when one of the following functions are called successfully:</p> </dd> <dt class="d_decl" id="Protocol.getProtocolByName">nothrow @trusted bool <strong id="getProtocolByName">getProtocolByName</strong>(scope const(char)[] name); </dt> <dd>
<dl>
<dt>Returns:</dt>
<dd>false on failure</dd>
</dl> </dd> <dt class="d_decl" id="Protocol.getProtocolByType">nothrow @trusted bool <strong id="getProtocolByType">getProtocolByType</strong>(ProtocolType type); </dt> <dd>
<dl>
<dt>Returns:</dt>
<dd>false on failure</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="Service">class <strong id="Service">Service</strong>; </dt> <dd>
<p><code>Service</code> is a class for retrieving service information. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto serv = new Service;
writeln("About service epmap:");
if (serv.getServiceByName("epmap", "tcp"))
{
    writefln("  Service: %s", serv.name);
    writefln("  Port: %d", serv.port);
    writefln("  Protocol: %s", serv.protocolName);
    foreach (string s; serv.aliases)
         writefln("  Alias: %s", s);
}
else
    writefln("  No service for epmap.");
</pre>  <dl>
<dt class="d_decl" id="Service.name">string <strong id="name">name</strong>; <br><br>string[] <strong id="aliases">aliases</strong>; <br><br>ushort <strong id="port">port</strong>; <br><br>string <strong id="protocolName">protocolName</strong>; </dt> <dd>
<p>These members are populated when one of the following functions are called successfully:</p> </dd> <dt class="d_decl" id="Service.getServiceByName">nothrow @trusted bool <strong id="getServiceByName">getServiceByName</strong>(scope const(char)[] name, scope const(char)[] protocolName = null); <br><br>nothrow @trusted bool <strong id="getServiceByPort">getServiceByPort</strong>(ushort port, scope const(char)[] protocolName = null); </dt> <dd>
<p>If a protocol name is omitted, any protocol will be matched. </p>
<dl>
<dt>Returns:</dt>
<dd>false on failure.</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="HostException">class <strong id="HostException">HostException</strong>: std.socket.SocketOSException; </dt> <dd>
<p>Class for exceptions thrown from an <code>InternetHost</code>.</p> </dd> <dt class="d_decl" id="InternetHost">class <strong id="InternetHost">InternetHost</strong>; </dt> <dd>
<p><code>InternetHost</code> is a class for resolving IPv4 addresses. </p>
<p>Consider using <code>getAddress</code>, <code>parseAddress</code> and <code>Address</code> methods instead of using this class directly.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">InternetHost ih = new InternetHost;

ih.getHostByAddr(0x7F_00_00_01);
writeln(ih.addrList[0]); // 0x7F_00_00_01
ih.getHostByAddr("127.0.0.1");
writeln(ih.addrList[0]); // 0x7F_00_00_01

if (!ih.getHostByName("www.digitalmars.com"))
    return;             // don't fail if not connected to internet

assert(ih.addrList.length);
InternetAddress ia = new InternetAddress(ih.addrList[0], InternetAddress.PORT_ANY);
assert(ih.name == "www.digitalmars.com" || ih.name == "digitalmars.com",
        ih.name);

assert(ih.getHostByAddr(ih.addrList[0]));
string getHostNameFromInt = ih.name.dup;

assert(ih.getHostByAddr(ia.toAddrString()));
string getHostNameFromStr = ih.name.dup;

writeln(getHostNameFromInt); // getHostNameFromStr
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="InternetHost.name">string <strong id="name">name</strong>; <br><br>string[] <strong id="aliases">aliases</strong>; <br><br>uint[] <strong id="addrList">addrList</strong>; </dt> <dd>
<p>These members are populated when one of the following functions are called successfully:</p> </dd> <dt class="d_decl" id="InternetHost.getHostByName">@trusted bool <strong id="getHostByName">getHostByName</strong>(scope const(char)[] name); </dt> <dd>
<p>Resolve host name. </p>
<dl>
<dt>Returns:</dt>
<dd>false if unable to resolve.</dd>
</dl> </dd> <dt class="d_decl" id="InternetHost.getHostByAddr">@trusted bool <strong id="getHostByAddr">getHostByAddr</strong>(uint addr); </dt> <dd>
<p>Resolve IPv4 address number. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>uint <code>addr</code>
</td> <td>The IPv4 address to resolve, in host byte order.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>false if unable to resolve.</dd>
</dl> </dd> <dt class="d_decl" id="InternetHost.getHostByAddr.2">@trusted bool <strong id="getHostByAddr">getHostByAddr</strong>(scope const(char)[] addr); </dt> <dd>
<p>Same as previous, but addr is an IPv4 address string in the dotted-decimal form <i>a.b.c.d</i>. </p>
<dl>
<dt>Returns:</dt>
<dd>false if unable to resolve.</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="AddressInfo">struct <strong id="AddressInfo">AddressInfo</strong>; </dt> <dd>
<p>Holds information about a socket address retrieved by <code>getAddressInfo</code>.</p> <dl>
<dt class="d_decl" id="AddressInfo.family">AddressFamily <strong id="family">family</strong>; </dt> <dd>
<p>Address family</p> </dd> <dt class="d_decl" id="AddressInfo.type">SocketType <strong id="type">type</strong>; </dt> <dd>
<p>Socket type</p> </dd> <dt class="d_decl" id="AddressInfo.protocol">ProtocolType <strong id="protocol">protocol</strong>; </dt> <dd>
<p>Protocol</p> </dd> <dt class="d_decl" id="AddressInfo.address">Address <strong id="address">address</strong>; </dt> <dd>
<p>Socket address</p> </dd> <dt class="d_decl" id="AddressInfo.canonicalName">string <strong id="canonicalName">canonicalName</strong>; </dt> <dd>
<p>Canonical name, when <code>AddressInfoFlags.CANONNAME</code> is used.</p> </dd> </dl> </dd> <dt class="d_decl" id="AddressInfoFlags">enum <strong id="AddressInfoFlags">AddressInfoFlags</strong>: int; </dt> <dd>
<p>A subset of flags supported on all platforms with getaddrinfo. Specifies option flags for <code>getAddressInfo</code>.</p> <dl>
<dt class="d_decl" id="AddressInfoFlags.PASSIVE"><strong id="PASSIVE">PASSIVE</strong></dt> <dd>
<p>The resulting addresses will be used in a call to <code>Socket.bind</code>.</p> </dd> <dt class="d_decl" id="AddressInfoFlags.CANONNAME"><strong id="CANONNAME">CANONNAME</strong></dt> <dd>
<p>The canonical name is returned in <code>canonicalName</code> member in the first <code>AddressInfo</code>.</p> </dd> <dt class="d_decl" id="AddressInfoFlags.NUMERICHOST"><strong id="NUMERICHOST">NUMERICHOST</strong></dt> <dd>
<p>The <code>node</code> parameter passed to <code>getAddressInfo</code> must be a numeric string. This will suppress any potentially lengthy network host address lookups.</p> </dd> </dl> </dd> <dt class="d_decl" id="getAddressInfo">AddressInfo[] <strong id="getAddressInfo">getAddressInfo</strong>(T...)(scope const(char)[] node, scope T options); </dt> <dd>
<p>Provides protocol-independent translation from host names to socket addresses. If advanced functionality is not required, consider using <code>getAddress</code> for compatibility with older systems. </p>
<dl>
<dt>Returns:</dt>
<dd>Array with one <code>AddressInfo</code> per socket address. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<code>SocketOSException</code> on failure, or <code>SocketFeatureException</code> if this functionality is not available on the current system. </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)[] <code>node</code>
</td> <td>string containing host name or numeric address</td>
</tr> <tr>
<td>T <code>options</code>
</td> <td>optional additional parameters, identified by type: <ul>
<li>
<code>string</code> - service name or port number</li> <li>
<code>AddressInfoFlags</code> - option flags</li> <li>
<code>AddressFamily</code> - address family to filter by</li> <li>
<code>SocketType</code> - socket type to filter by</li> <li>
<code>ProtocolType</code> - protocol to filter by</li>
</ul>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">// Roundtrip DNS resolution
auto results = getAddressInfo("www.digitalmars.com");
assert(results[0].address.toHostNameString() ==
    "digitalmars.com");

// Canonical name
results = getAddressInfo("www.digitalmars.com",
    AddressInfoFlags.CANONNAME);
assert(results[0].canonicalName == "digitalmars.com");

// IPv6 resolution
results = getAddressInfo("ipv6.google.com");
assert(results[0].family == AddressFamily.INET6);

// Multihomed resolution
results = getAddressInfo("google.com");
assert(results.length &gt; 1);

// Parsing IPv4
results = getAddressInfo("127.0.0.1",
    AddressInfoFlags.NUMERICHOST);
assert(results.length &amp;&amp; results[0].family ==
    AddressFamily.INET);

// Parsing IPv6
results = getAddressInfo("::1",
    AddressInfoFlags.NUMERICHOST);
assert(results.length &amp;&amp; results[0].family ==
    AddressFamily.INET6);
</pre>  </dd> <dt class="d_decl" id="getAddress">@safe Address[] <strong id="getAddress">getAddress</strong>(scope const(char)[] hostname, scope const(char)[] service = null); <br><br>@safe Address[] <strong id="getAddress">getAddress</strong>(scope const(char)[] hostname, ushort port); </dt> <dd>
<p>Provides protocol-independent translation from host names to socket addresses. Uses <code>getAddressInfo</code> if the current system supports it, and <code>InternetHost</code> otherwise. </p>
<dl>
<dt>Returns:</dt>
<dd>Array with one <code>Address</code> instance per socket address. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<code>SocketOSException</code> on failure. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">writeln("Resolving www.digitalmars.com:");
try
{
    auto addresses = getAddress("www.digitalmars.com");
    foreach (address; addresses)
        writefln("  IP: %s", address.toAddrString());
}
catch (SocketException e)
    writefln("  Lookup failed: %s", e.msg);
</pre>  </dd> <dt class="d_decl" id="parseAddress">@safe Address <strong id="parseAddress">parseAddress</strong>(scope const(char)[] hostaddr, scope const(char)[] service = null); <br><br>@safe Address <strong id="parseAddress">parseAddress</strong>(scope const(char)[] hostaddr, ushort port); </dt> <dd>
<p>Provides protocol-independent parsing of network addresses. Does not attempt name resolution. Uses <code>getAddressInfo</code> with <code>AddressInfoFlags.NUMERICHOST</code> if the current system supports it, and <code>InternetAddress</code> otherwise. </p>
<dl>
<dt>Returns:</dt>
<dd>An <code>Address</code> instance representing specified address. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<code>SocketException</code> on failure. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">writeln("Enter IP address:");
string ip = readln().chomp();
try
{
    Address address = parseAddress(ip);
    writefln("Looking up reverse of %s:",
        address.toAddrString());
    try
    {
        string reverse = address.toHostNameString();
        if (reverse)
            writefln("  Reverse name: %s", reverse);
        else
            writeln("  Reverse hostname not found.");
    }
    catch (SocketException e)
        writefln("  Lookup error: %s", e.msg);
}
catch (SocketException e)
{
    writefln("  %s is not a valid IP address: %s",
        ip, e.msg);
}
</pre>  </dd> <dt class="d_decl" id="AddressException">class <strong id="AddressException">AddressException</strong>: std.socket.SocketOSException; </dt> <dd>
<p>Class for exceptions thrown from an <code>Address</code>.</p> </dd> <dt class="d_decl" id="Address">abstract class <strong id="Address">Address</strong>; </dt> <dd>
<p><code>Address</code> is an abstract class for representing a socket addresses. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">writeln("About www.google.com port 80:");
try
{
    Address[] addresses = getAddress("www.google.com", 80);
    writefln("  %d addresses found.", addresses.length);
    foreach (int i, Address a; addresses)
    {
        writefln("  Address %d:", i+1);
        writefln("    IP address: %s", a.toAddrString());
        writefln("    Hostname: %s", a.toHostNameString());
        writefln("    Port: %s", a.toPortString());
        writefln("    Service name: %s",
            a.toServiceNameString());
    }
}
catch (SocketException e)
    writefln("  Lookup error: %s", e.msg);
</pre>  <dl>
<dt class="d_decl" id="Address.name">abstract pure nothrow @nogc @property @safe sockaddr* <strong id="name">name</strong>(); <br><br>abstract const pure nothrow @nogc @property @safe const(sockaddr)* <strong id="name">name</strong>(); </dt> <dd>
<p>Returns pointer to underlying <code>sockaddr</code> structure.</p> </dd> <dt class="d_decl" id="Address.nameLen">abstract const pure nothrow @nogc @property @safe socklen_t <strong id="nameLen">nameLen</strong>(); </dt> <dd>
<p>Returns actual size of underlying <code>sockaddr</code> structure.</p> </dd> <dt class="d_decl" id="Address.addressFamily">const pure nothrow @nogc @property @safe AddressFamily <strong id="addressFamily">addressFamily</strong>(); </dt> <dd>
<p>Family of this address.</p> </dd> <dt class="d_decl" id="Address.toAddrString">const @safe string <strong id="toAddrString">toAddrString</strong>(); </dt> <dd>
<p>Attempts to retrieve the host address as a human-readable string. </p>
<dl>
<dt>Throws:</dt>
<dd>
<code>AddressException</code> on failure, or <code>SocketFeatureException</code> if address retrieval for this address family is not available on the current system.</dd>
</dl> </dd> <dt class="d_decl" id="Address.toHostNameString">const @safe string <strong id="toHostNameString">toHostNameString</strong>(); </dt> <dd>
<p>Attempts to retrieve the host name as a fully qualified domain name. </p>
<dl>
<dt>Returns:</dt>
<dd>The FQDN corresponding to this <code>Address</code>, or <code>null</code> if the host name did not resolve. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<code>AddressException</code> on error, or <code>SocketFeatureException</code> if host name lookup for this address family is not available on the current system.</dd>
</dl> </dd> <dt class="d_decl" id="Address.toPortString">const @safe string <strong id="toPortString">toPortString</strong>(); </dt> <dd>
<p>Attempts to retrieve the numeric port number as a string. </p>
<dl>
<dt>Throws:</dt>
<dd>
<code>AddressException</code> on failure, or <code>SocketFeatureException</code> if port number retrieval for this address family is not available on the current system.</dd>
</dl> </dd> <dt class="d_decl" id="Address.toServiceNameString">const @safe string <strong id="toServiceNameString">toServiceNameString</strong>(); </dt> <dd>
<p>Attempts to retrieve the service name as a string. </p>
<dl>
<dt>Throws:</dt>
<dd>
<code>AddressException</code> on failure, or <code>SocketFeatureException</code> if service name lookup for this address family is not available on the current system.</dd>
</dl> </dd> <dt class="d_decl" id="Address.toString">const @safe string <strong id="toString">toString</strong>(); </dt> <dd>
<p>Human readable string representing this address.</p> </dd> </dl> </dd> <dt class="d_decl" id="UnknownAddress">class <strong id="UnknownAddress">UnknownAddress</strong>: std.socket.Address; </dt> <dd>
<p><code>UnknownAddress</code> encapsulates an unknown socket address.</p> </dd> <dt class="d_decl" id="UnknownAddressReference">class <strong id="UnknownAddressReference">UnknownAddressReference</strong>: std.socket.Address; </dt> <dd>
<p><code>UnknownAddressReference</code> encapsulates a reference to an arbitrary socket address.</p> <dl>
<dt class="d_decl" id="UnknownAddressReference.this">pure nothrow @nogc @safe this(sockaddr* sa, socklen_t len); </dt> <dd>
<p>Constructs an <code>Address</code> with a reference to the specified <code>sockaddr</code>.</p> </dd> <dt class="d_decl" id="UnknownAddressReference.this.2">pure nothrow @system this(const(sockaddr)* sa, socklen_t len); </dt> <dd>
<p>Constructs an <code>Address</code> with a copy of the specified <code>sockaddr</code>.</p> </dd> </dl> </dd> <dt class="d_decl" id="InternetAddress">class <strong id="InternetAddress">InternetAddress</strong>: std.socket.Address; </dt> <dd>
<p><code>InternetAddress</code> encapsulates an IPv4 (Internet Protocol version 4) socket address. </p>
<p>Consider using <code>getAddress</code>, <code>parseAddress</code> and <code>Address</code> methods instead of using this class directly.</p> <dl>
<dt class="d_decl" id="InternetAddress.ADDR_ANY">enum uint <strong id="ADDR_ANY">ADDR_ANY</strong>; </dt> <dd>
<p>Any IPv4 host address.</p> </dd> <dt class="d_decl" id="InternetAddress.ADDR_NONE">enum uint <strong id="ADDR_NONE">ADDR_NONE</strong>; </dt> <dd>
<p>An invalid IPv4 host address.</p> </dd> <dt class="d_decl" id="InternetAddress.PORT_ANY">enum ushort <strong id="PORT_ANY">PORT_ANY</strong>; </dt> <dd>
<p>Any IPv4 port number.</p> </dd> <dt class="d_decl" id="InternetAddress.port">const pure nothrow @nogc @property @safe ushort <strong id="port">port</strong>(); </dt> <dd>
<p>Returns the IPv4 port number (in host byte order).</p> </dd> <dt class="d_decl" id="InternetAddress.addr">const pure nothrow @nogc @property @safe uint <strong id="addr">addr</strong>(); </dt> <dd>
<p>Returns the IPv4 address number (in host byte order).</p> </dd> <dt class="d_decl" id="InternetAddress.this">@safe this(scope const(char)[] addr, ushort port); </dt> <dd>
<p>Construct a new <code>InternetAddress</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)[] <code>addr</code>
</td> <td>an IPv4 address string in the dotted-decimal form a.b.c.d, or a host name which will be resolved using an <code>InternetHost</code> object.</td>
</tr> <tr>
<td>ushort <code>port</code>
</td> <td>port number, may be <code>PORT_ANY</code>.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="InternetAddress.this.2">pure nothrow @nogc @safe this(uint addr, ushort port); <br><br>pure nothrow @nogc @safe this(ushort port); </dt> <dd>
<p>Construct a new <code>InternetAddress</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>uint <code>addr</code>
</td> <td>(optional) an IPv4 address in host byte order, may be <code>ADDR_ANY</code>.</td>
</tr> <tr>
<td>ushort <code>port</code>
</td> <td>port number, may be <code>PORT_ANY</code>.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="InternetAddress.this.3">pure nothrow @nogc @safe this(sockaddr_in addr); </dt> <dd>
<p>Construct a new <code>InternetAddress</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>sockaddr_in <code>addr</code>
</td> <td>A sockaddr_in as obtained from lower-level API calls such as getifaddrs.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="InternetAddress.toAddrString">const @trusted string <strong id="toAddrString">toAddrString</strong>(); </dt> <dd>
<p>Human readable string representing the IPv4 address in dotted-decimal form.</p> </dd> <dt class="d_decl" id="InternetAddress.toPortString">const @safe string <strong id="toPortString">toPortString</strong>(); </dt> <dd>
<p>Human readable string representing the IPv4 port.</p> </dd> <dt class="d_decl" id="InternetAddress.toHostNameString">const @safe string <strong id="toHostNameString">toHostNameString</strong>(); </dt> <dd>
<p>Attempts to retrieve the host name as a fully qualified domain name. </p>
<dl>
<dt>Returns:</dt>
<dd>The FQDN corresponding to this <code>InternetAddress</code>, or <code>null</code> if the host name did not resolve. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<code>AddressException</code> on error.</dd>
</dl> </dd> <dt class="d_decl" id="InternetAddress.opEquals">const @safe bool <strong id="opEquals">opEquals</strong>(Object o); </dt> <dd>
<p>Compares with another InternetAddress of same type for equality </p>
<dl>
<dt>Returns:</dt>
<dd>true if the InternetAddresses share the same address and port number.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto addr1 = new InternetAddress("127.0.0.1", 80);
auto addr2 = new InternetAddress("127.0.0.2", 80);

writeln(addr1); // addr1
assert(addr1 != addr2);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="InternetAddress.parse">static nothrow @trusted uint <strong id="parse">parse</strong>(scope const(char)[] addr); </dt> <dd>
<p>Parse an IPv4 address string in the dotted-decimal form <i>a.b.c.d</i> and return the number. </p>
<dl>
<dt>Returns:</dt>
<dd>If the string is not a legitimate IPv4 address, <code>ADDR_NONE</code> is returned.</dd>
</dl> </dd> <dt class="d_decl" id="InternetAddress.addrToString">static nothrow @trusted string <strong id="addrToString">addrToString</strong>(uint addr); </dt> <dd>
<p>Convert an IPv4 address number in host byte order to a human readable string representing the IPv4 address in dotted-decimal form.</p> </dd> </dl> </dd> <dt class="d_decl" id="Internet6Address">class <strong id="Internet6Address">Internet6Address</strong>: std.socket.Address; </dt> <dd>
<p><code>Internet6Address</code> encapsulates an IPv6 (Internet Protocol version 6) socket address. </p>
<p>Consider using <code>getAddress</code>, <code>parseAddress</code> and <code>Address</code> methods instead of using this class directly.</p> <dl>
<dt class="d_decl" id="Internet6Address.ADDR_ANY">static pure nothrow @nogc @property ref @safe const(ubyte)[16] <strong id="ADDR_ANY">ADDR_ANY</strong>(); </dt> <dd>
<p>Any IPv6 host address.</p> </dd> <dt class="d_decl" id="Internet6Address.PORT_ANY">enum ushort <strong id="PORT_ANY">PORT_ANY</strong>; </dt> <dd>
<p>Any IPv6 port number.</p> </dd> <dt class="d_decl" id="Internet6Address.port">const pure nothrow @nogc @property @safe ushort <strong id="port">port</strong>(); </dt> <dd>
<p>Returns the IPv6 port number.</p> </dd> <dt class="d_decl" id="Internet6Address.addr">const pure nothrow @nogc @property @safe ubyte[16] <strong id="addr">addr</strong>(); </dt> <dd>
<p>Returns the IPv6 address.</p> </dd> <dt class="d_decl" id="Internet6Address.this">@trusted this(scope const(char)[] addr, scope const(char)[] service = null); </dt> <dd>
<p>Construct a new <code>Internet6Address</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)[] <code>addr</code>
</td> <td>an IPv6 host address string in the form described in RFC 2373, or a host name which will be resolved using <code>getAddressInfo</code>.</td>
</tr> <tr>
<td>const(char)[] <code>service</code>
</td> <td>(optional) service name.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Internet6Address.this.2">@safe this(scope const(char)[] addr, ushort port); </dt> <dd>
<p>Construct a new <code>Internet6Address</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)[] <code>addr</code>
</td> <td>an IPv6 host address string in the form described in RFC 2373, or a host name which will be resolved using <code>getAddressInfo</code>.</td>
</tr> <tr>
<td>ushort <code>port</code>
</td> <td>port number, may be <code>PORT_ANY</code>.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Internet6Address.this.3">pure nothrow @nogc @safe this(ubyte[16] addr, ushort port); <br><br>pure nothrow @nogc @safe this(ushort port); </dt> <dd>
<p>Construct a new <code>Internet6Address</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>ubyte[16] <code>addr</code>
</td> <td>(optional) an IPv6 host address in host byte order, or <code>ADDR_ANY</code>.</td>
</tr> <tr>
<td>ushort <code>port</code>
</td> <td>port number, may be <code>PORT_ANY</code>.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Internet6Address.this.4">pure nothrow @nogc @safe this(sockaddr_in6 addr); </dt> <dd>
<p>Construct a new <code>Internet6Address</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>sockaddr_in6 <code>addr</code>
</td> <td>A sockaddr_in6 as obtained from lower-level API calls such as getifaddrs.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Internet6Address.parse">static @trusted ubyte[16] <strong id="parse">parse</strong>(scope const(char)[] addr); </dt> <dd>
<p>Parse an IPv6 host address string as described in RFC 2373, and return the address. </p>
<dl>
<dt>Throws:</dt>
<dd>
<code>SocketException</code> on error.</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="UnixAddress">class <strong id="UnixAddress">UnixAddress</strong>: std.socket.Address; </dt> <dd>
<p><code>UnixAddress</code> encapsulates an address for a Unix domain socket (<code>AF_UNIX</code>), i.e. a socket bound to a path name in the file system. Available only on supported systems. </p>
<p>Linux also supports an abstract address namespace, in which addresses are independent of the file system. A socket address is abstract iff <code>path</code> starts with a null byte (<code>'\0'</code>). Null bytes in other positions of an abstract address are allowed and have no special meaning. </p> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto addr = new UnixAddress("/var/run/dbus/system_bus_socket");
auto abstractAddr = new UnixAddress("\0/tmp/dbus-OtHLWmCLPR");
</pre>  <dl>
<dt>See Also:</dt>
<dd><a href="http://http//man7.org/linux/man-pages/man7/unix.7.html">UNIX(7)</a></dd>
</dl> <dl>
<dt class="d_decl" id="UnixAddress.this">@safe this(scope const(char)[] path); </dt> <dd>
<p>Construct a new <code>UnixAddress</code> from the specified path.</p> </dd> <dt class="d_decl" id="UnixAddress.this.2">pure nothrow @nogc @safe this(sockaddr_un addr); </dt> <dd>
<p>Construct a new <code>UnixAddress</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>sockaddr_un <code>addr</code>
</td> <td>A sockaddr_un as obtained from lower-level API calls.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="UnixAddress.path">const @property @safe string <strong id="path">path</strong>(); <br><br>const @safe string <strong id="toString">toString</strong>(); </dt> <dd>
<p>Get the underlying path.</p> </dd> </dl> </dd> <dt class="d_decl" id="SocketAcceptException">class <strong id="SocketAcceptException">SocketAcceptException</strong>: std.socket.SocketOSException; </dt> <dd>
<p>Class for exceptions thrown by <code>Socket.accept</code>.</p> </dd> <dt class="d_decl" id="SocketShutdown">enum <strong id="SocketShutdown">SocketShutdown</strong>: int; </dt> <dd>
<p>How a socket is shutdown:</p> <dl>
<dt class="d_decl" id="SocketShutdown.RECEIVE"><strong id="RECEIVE">RECEIVE</strong></dt> <dd>
<p>socket receives are disallowed</p> </dd> <dt class="d_decl" id="SocketShutdown.SEND"><strong id="SEND">SEND</strong></dt> <dd>
<p>socket sends are disallowed</p> </dd> <dt class="d_decl" id="SocketShutdown.BOTH"><strong id="BOTH">BOTH</strong></dt> <dd>
<p>both RECEIVE and SEND</p> </dd> </dl> </dd> <dt class="d_decl" id="SocketFlags">enum <strong id="SocketFlags">SocketFlags</strong>: int; </dt> <dd>
<p>Flags may be OR'ed together:</p> <dl>
<dt class="d_decl" id="SocketFlags.NONE"><strong id="NONE">NONE</strong></dt> <dd>
<p>no flags specified</p> </dd> <dt class="d_decl" id="SocketFlags.OOB"><strong id="OOB">OOB</strong></dt> <dd>
<p>out-of-band stream data</p> </dd> <dt class="d_decl" id="SocketFlags.PEEK"><strong id="PEEK">PEEK</strong></dt> <dd>
<p>peek at incoming data without removing it from the queue, only for receiving</p> </dd> <dt class="d_decl" id="SocketFlags.DONTROUTE"><strong id="DONTROUTE">DONTROUTE</strong></dt> <dd>
<p>data should not be subject to routing; this flag may be ignored. Only for sending</p> </dd> </dl> </dd> <dt class="d_decl" id="TimeVal">struct <strong id="TimeVal">TimeVal</strong>; </dt> <dd>
<p>Duration timeout value.</p> <dl>
<dt class="d_decl" id="TimeVal.seconds">tv_sec_t <strong id="seconds">seconds</strong>; </dt> <dd>
<p>Number of seconds.</p> </dd> <dt class="d_decl" id="TimeVal.microseconds">tv_usec_t <strong id="microseconds">microseconds</strong>; </dt> <dd>
<p>Number of additional microseconds.</p> </dd> </dl> </dd> <dt class="d_decl" id="SocketSet">class <strong id="SocketSet">SocketSet</strong>; </dt> <dd>
<p>A collection of sockets for use with <code>Socket.select</code>. </p>
<p><code>SocketSet</code> wraps the platform <code>fd_set</code> type. However, unlike <code>fd_set</code>, <code>SocketSet</code> is not statically limited to <code>FD_SETSIZE</code> or any other limit, and grows as needed.</p> <dl>
<dt class="d_decl" id="SocketSet.this">pure nothrow @safe this(size_t size = FD_SETSIZE); </dt> <dd>
<p>Create a SocketSet with a specific initial capacity (defaults to <code>FD_SETSIZE</code>, the system's default capacity).</p> </dd> <dt class="d_decl" id="SocketSet.reset">pure nothrow @nogc @safe void <strong id="reset">reset</strong>(); </dt> <dd>
<p>Reset the <code>SocketSet</code> so that there are 0 <code>Socket</code>s in the collection.</p> </dd> <dt class="d_decl" id="SocketSet.add">pure nothrow @safe void <strong id="add">add</strong>(Socket s); </dt> <dd>
<p>Add a <code>Socket</code> to the collection. The socket must not already be in the collection.</p> </dd> <dt class="d_decl" id="SocketSet.remove">pure nothrow @safe void <strong id="remove">remove</strong>(Socket s); </dt> <dd>
<p>Remove this <code>Socket</code> from the collection. Does nothing if the socket is not in the collection already.</p> </dd> <dt class="d_decl" id="SocketSet.isSet">const pure nothrow @nogc @safe int <strong id="isSet">isSet</strong>(Socket s); </dt> <dd>
<p>Return nonzero if this <code>Socket</code> is in the collection.</p> </dd> <dt class="d_decl" id="SocketSet.max">const pure nothrow @nogc @property @safe uint <strong id="max">max</strong>(); </dt> <dd>
<dl>
<dt>Returns:</dt>
<dd>The current capacity of this <code>SocketSet</code>. The exact meaning of the return value varies from platform to platform. </dd>
</dl> <dl>
<dt>Note</dt>
<dd> Since D 2.065, this value does not indicate a restriction, and <code>SocketSet</code> will grow its capacity as needed automatically.</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="SocketOptionLevel">enum <strong id="SocketOptionLevel">SocketOptionLevel</strong>: int; </dt> <dd>
<p>The level at which a socket option is defined:</p> <dl>
<dt class="d_decl" id="SocketOptionLevel.SOCKET"><strong id="SOCKET">SOCKET</strong></dt> <dd>
<p>Socket level</p> </dd> <dt class="d_decl" id="SocketOptionLevel.IP"><strong id="IP">IP</strong></dt> <dd>
<p>Internet Protocol version 4 level</p> </dd> <dt class="d_decl" id="SocketOptionLevel.ICMP"><strong id="ICMP">ICMP</strong></dt> <dd>
<p>Internet Control Message Protocol level</p> </dd> <dt class="d_decl" id="SocketOptionLevel.IGMP"><strong id="IGMP">IGMP</strong></dt> <dd>
<p>Internet Group Management Protocol level</p> </dd> <dt class="d_decl" id="SocketOptionLevel.GGP"><strong id="GGP">GGP</strong></dt> <dd>
<p>Gateway to Gateway Protocol level</p> </dd> <dt class="d_decl" id="SocketOptionLevel.TCP"><strong id="TCP">TCP</strong></dt> <dd>
<p>Transmission Control Protocol level</p> </dd> <dt class="d_decl" id="SocketOptionLevel.PUP"><strong id="PUP">PUP</strong></dt> <dd>
<p>PARC Universal Packet Protocol level</p> </dd> <dt class="d_decl" id="SocketOptionLevel.UDP"><strong id="UDP">UDP</strong></dt> <dd>
<p>User Datagram Protocol level</p> </dd> <dt class="d_decl" id="SocketOptionLevel.IDP"><strong id="IDP">IDP</strong></dt> <dd>
<p>Xerox NS protocol level</p> </dd> <dt class="d_decl" id="SocketOptionLevel.RAW"><strong id="RAW">RAW</strong></dt> <dd>
<p>Raw IP packet level</p> </dd> <dt class="d_decl" id="SocketOptionLevel.IPV6"><strong id="IPV6">IPV6</strong></dt> <dd>
<p>Internet Protocol version 6 level</p> </dd> </dl> </dd> <dt class="d_decl" id="Linger">struct <strong id="Linger">Linger</strong>; </dt> <dd>
<p>Linger information for use with SocketOption.LINGER.</p> <dl>
<dt class="d_decl" id="Linger.on">l_onoff_t <strong id="on">on</strong>; </dt> <dd>
<p>Nonzero for on.</p> </dd> <dt class="d_decl" id="Linger.time">l_linger_t <strong id="time">time</strong>; </dt> <dd>
<p>Linger time.</p> </dd> </dl> </dd> <dt class="d_decl" id="SocketOption">enum <strong id="SocketOption">SocketOption</strong>: int; </dt> <dd>
<p>Specifies a socket option:</p> <dl>
<dt class="d_decl" id="SocketOption.DEBUG"><strong id="DEBUG">DEBUG</strong></dt> <dd>
<p>Record debugging information</p> </dd> <dt class="d_decl" id="SocketOption.BROADCAST"><strong id="BROADCAST">BROADCAST</strong></dt> <dd>
<p>Allow transmission of broadcast messages</p> </dd> <dt class="d_decl" id="SocketOption.REUSEADDR"><strong id="REUSEADDR">REUSEADDR</strong></dt> <dd>
<p>Allow local reuse of address</p> </dd> <dt class="d_decl" id="SocketOption.LINGER"><strong id="LINGER">LINGER</strong></dt> <dd>
<p>Linger on close if unsent data is present</p> </dd> <dt class="d_decl" id="SocketOption.OOBINLINE"><strong id="OOBINLINE">OOBINLINE</strong></dt> <dd>
<p>Receive out-of-band data in band</p> </dd> <dt class="d_decl" id="SocketOption.SNDBUF"><strong id="SNDBUF">SNDBUF</strong></dt> <dd>
<p>Send buffer size</p> </dd> <dt class="d_decl" id="SocketOption.RCVBUF"><strong id="RCVBUF">RCVBUF</strong></dt> <dd>
<p>Receive buffer size</p> </dd> <dt class="d_decl" id="SocketOption.DONTROUTE"><strong id="DONTROUTE">DONTROUTE</strong></dt> <dd>
<p>Do not route</p> </dd> <dt class="d_decl" id="SocketOption.SNDTIMEO"><strong id="SNDTIMEO">SNDTIMEO</strong></dt> <dd>
<p>Send timeout</p> </dd> <dt class="d_decl" id="SocketOption.RCVTIMEO"><strong id="RCVTIMEO">RCVTIMEO</strong></dt> <dd>
<p>Receive timeout</p> </dd> <dt class="d_decl" id="SocketOption.ERROR"><strong id="ERROR">ERROR</strong></dt> <dd>
<p>Retrieve and clear error status</p> </dd> <dt class="d_decl" id="SocketOption.KEEPALIVE"><strong id="KEEPALIVE">KEEPALIVE</strong></dt> <dd>
<p>Enable keep-alive packets</p> </dd> <dt class="d_decl" id="SocketOption.ACCEPTCONN"><strong id="ACCEPTCONN">ACCEPTCONN</strong></dt> <dd>
<p>Listen</p> </dd> <dt class="d_decl" id="SocketOption.RCVLOWAT"><strong id="RCVLOWAT">RCVLOWAT</strong></dt> <dd>
<p>Minimum number of input bytes to process</p> </dd> <dt class="d_decl" id="SocketOption.SNDLOWAT"><strong id="SNDLOWAT">SNDLOWAT</strong></dt> <dd>
<p>Minimum number of output bytes to process</p> </dd> <dt class="d_decl" id="SocketOption.TYPE"><strong id="TYPE">TYPE</strong></dt> <dd>
<p>Socket type</p> </dd> <dt class="d_decl" id="SocketOption.TCP_NODELAY"><strong id="TCP_NODELAY">TCP_NODELAY</strong></dt> <dd>
<p>Disable the Nagle algorithm for send coalescing</p> </dd> <dt class="d_decl" id="SocketOption.IPV6_UNICAST_HOPS"><strong id="IPV6_UNICAST_HOPS">IPV6_UNICAST_HOPS</strong></dt> <dd>
<p>IP unicast hop limit</p> </dd> <dt class="d_decl" id="SocketOption.IPV6_MULTICAST_IF"><strong id="IPV6_MULTICAST_IF">IPV6_MULTICAST_IF</strong></dt> <dd>
<p>IP multicast interface</p> </dd> <dt class="d_decl" id="SocketOption.IPV6_MULTICAST_LOOP"><strong id="IPV6_MULTICAST_LOOP">IPV6_MULTICAST_LOOP</strong></dt> <dd>
<p>IP multicast loopback</p> </dd> <dt class="d_decl" id="SocketOption.IPV6_MULTICAST_HOPS"><strong id="IPV6_MULTICAST_HOPS">IPV6_MULTICAST_HOPS</strong></dt> <dd>
<p>IP multicast hops</p> </dd> <dt class="d_decl" id="SocketOption.IPV6_JOIN_GROUP"><strong id="IPV6_JOIN_GROUP">IPV6_JOIN_GROUP</strong></dt> <dd>
<p>Add an IP group membership</p> </dd> <dt class="d_decl" id="SocketOption.IPV6_LEAVE_GROUP"><strong id="IPV6_LEAVE_GROUP">IPV6_LEAVE_GROUP</strong></dt> <dd>
<p>Drop an IP group membership</p> </dd> <dt class="d_decl" id="SocketOption.IPV6_V6ONLY"><strong id="IPV6_V6ONLY">IPV6_V6ONLY</strong></dt> <dd>
<p>Treat wildcard bind as AF_INET6-only</p> </dd> </dl> </dd> <dt class="d_decl" id="Socket">class <strong id="Socket">Socket</strong>; </dt> <dd>
<p><code>Socket</code> is a class that creates a network communication endpoint using the Berkeley sockets interface.</p> <dl>
<dt class="d_decl" id="Socket.this">@trusted this(AddressFamily af, SocketType type, ProtocolType protocol); <br><br>@safe this(AddressFamily af, SocketType type); <br><br>@trusted this(AddressFamily af, SocketType type, scope const(char)[] protocolName); </dt> <dd>
<p>Create a blocking socket. If a single protocol type exists to support this socket type within the address family, the <code>ProtocolType</code> may be omitted.</p> </dd> <dt class="d_decl" id="Socket.this.2">@safe this(in AddressInfo info); </dt> <dd>
<p>Create a blocking socket using the parameters from the specified <code>AddressInfo</code> structure.</p> </dd> <dt class="d_decl" id="Socket.this.3">pure nothrow @nogc @safe this(socket_t sock, AddressFamily af); </dt> <dd>
<p>Use an existing socket handle.</p> </dd> <dt class="d_decl" id="Socket.handle">const pure nothrow @nogc @property @safe socket_t <strong id="handle">handle</strong>(); </dt> <dd>
<p>Get underlying socket handle.</p> </dd> <dt class="d_decl" id="Socket.blocking">const nothrow @nogc @property @trusted bool <strong id="blocking">blocking</strong>(); <br><br>@property @trusted void <strong id="blocking">blocking</strong>(bool byes); </dt> <dd>
<p>Get/set socket's blocking flag. </p>
<p>When a socket is blocking, calls to receive(), accept(), and send() will block and wait for data/action. A non-blocking socket will immediately return instead of blocking.</p> </dd> <dt class="d_decl" id="Socket.addressFamily">@property @safe AddressFamily <strong id="addressFamily">addressFamily</strong>(); </dt> <dd>
<p>Get the socket's address family.</p> </dd> <dt class="d_decl" id="Socket.isAlive">const @property @trusted bool <strong id="isAlive">isAlive</strong>(); </dt> <dd>
<p>Property that indicates if this is a valid, alive socket.</p> </dd> <dt class="d_decl" id="Socket.bind">@trusted void <strong id="bind">bind</strong>(Address addr); </dt> <dd>
<p>Associate a local address with this socket.</p> </dd> <dt class="d_decl" id="Socket.connect">@trusted void <strong id="connect">connect</strong>(Address to); </dt> <dd>
<p>Establish a connection. If the socket is blocking, connect waits for the connection to be made. If the socket is nonblocking, connect returns immediately and the connection attempt is still in progress.</p> </dd> <dt class="d_decl" id="Socket.listen">@trusted void <strong id="listen">listen</strong>(int backlog); </dt> <dd>
<p>Listen for an incoming connection. <code>bind</code> must be called before you can <code>listen</code>. The <code>backlog</code> is a request of how many pending incoming connections are queued until <code>accept</code>ed.</p> </dd> <dt class="d_decl" id="Socket.accepting">protected pure nothrow @safe Socket <strong id="accepting">accepting</strong>(); </dt> <dd>
<p>Called by <code>accept</code> when a new <code>Socket</code> must be created for a new connection. To use a derived class, override this method and return an instance of your class. The returned <code>Socket</code>'s handle must not be set; <code>Socket</code> has a protected constructor <code>this()</code> to use in this situation. </p>
<p>Override to use a derived class. The returned socket's handle must not be set.</p> </dd> <dt class="d_decl" id="Socket.accept">@trusted Socket <strong id="accept">accept</strong>(); </dt> <dd>
<p>Accept an incoming connection. If the socket is blocking, <code>accept</code> waits for a connection request. Throws <code>SocketAcceptException</code> if unable to accept. See <code>accepting</code> for use with derived classes.</p> </dd> <dt class="d_decl" id="Socket.shutdown">nothrow @nogc @trusted void <strong id="shutdown">shutdown</strong>(SocketShutdown how); </dt> <dd>
<p>Disables sends and/or receives.</p> </dd> <dt class="d_decl" id="Socket.close">nothrow @nogc @trusted void <strong id="close">close</strong>(); </dt> <dd>
<p>Immediately drop any connections and release socket resources. The <code>Socket</code> object is no longer usable after <code>close</code>. Calling <code>shutdown</code> before <code>close</code> is recommended for connection-oriented sockets.</p> </dd> <dt class="d_decl" id="Socket.hostName">static @property @trusted string <strong id="hostName">hostName</strong>(); </dt> <dd>
<dl>
<dt>Returns:</dt>
<dd>the local machine's host name</dd>
</dl> </dd> <dt class="d_decl" id="Socket.remoteAddress">@property @trusted Address <strong id="remoteAddress">remoteAddress</strong>(); </dt> <dd>
<p>Remote endpoint <code>Address</code>.</p> </dd> <dt class="d_decl" id="Socket.localAddress">@property @trusted Address <strong id="localAddress">localAddress</strong>(); </dt> <dd>
<p>Local endpoint <code>Address</code>.</p> </dd> <dt class="d_decl" id="Socket.ERROR">enum int <strong id="ERROR">ERROR</strong>; </dt> <dd>
<p>Send or receive error code. See <code>wouldHaveBlocked</code>, <code>lastSocketError</code> and <code>Socket.getErrorText</code> for obtaining more information about the error.</p> </dd> <dt class="d_decl" id="Socket.send">@trusted ptrdiff_t <strong id="send">send</strong>(const(void)[] buf, SocketFlags flags); <br><br>@safe ptrdiff_t <strong id="send">send</strong>(const(void)[] buf); </dt> <dd>
<p>Send data on the connection. If the socket is blocking and there is no buffer space left, <code>send</code> waits. </p>
<dl>
<dt>Returns:</dt>
<dd>The number of bytes actually sent, or <code>Socket.ERROR</code> on failure.</dd>
</dl> </dd> <dt class="d_decl" id="Socket.sendTo">@trusted ptrdiff_t <strong id="sendTo">sendTo</strong>(const(void)[] buf, SocketFlags flags, Address to); <br><br>@safe ptrdiff_t <strong id="sendTo">sendTo</strong>(const(void)[] buf, Address to); <br><br>@trusted ptrdiff_t <strong id="sendTo">sendTo</strong>(const(void)[] buf, SocketFlags flags); <br><br>@safe ptrdiff_t <strong id="sendTo">sendTo</strong>(const(void)[] buf); </dt> <dd>
<p>Send data to a specific destination Address. If the destination address is not specified, a connection must have been made and that address is used. If the socket is blocking and there is no buffer space left, <code>sendTo</code> waits. </p>
<dl>
<dt>Returns:</dt>
<dd>The number of bytes actually sent, or <code>Socket.ERROR</code> on failure.</dd>
</dl> </dd> <dt class="d_decl" id="Socket.receive">@trusted ptrdiff_t <strong id="receive">receive</strong>(void[] buf, SocketFlags flags); <br><br>@safe ptrdiff_t <strong id="receive">receive</strong>(void[] buf); </dt> <dd>
<p>Receive data on the connection. If the socket is blocking, <code>receive</code> waits until there is data to be received. </p>
<dl>
<dt>Returns:</dt>
<dd>The number of bytes actually received, <code>0</code> if the remote side has closed the connection, or <code>Socket.ERROR</code> on failure.</dd>
</dl> </dd> <dt class="d_decl" id="Socket.receiveFrom">@trusted ptrdiff_t <strong id="receiveFrom">receiveFrom</strong>(void[] buf, SocketFlags flags, ref Address from); <br><br>@safe ptrdiff_t <strong id="receiveFrom">receiveFrom</strong>(void[] buf, ref Address from); <br><br>@trusted ptrdiff_t <strong id="receiveFrom">receiveFrom</strong>(void[] buf, SocketFlags flags); <br><br>@safe ptrdiff_t <strong id="receiveFrom">receiveFrom</strong>(void[] buf); </dt> <dd>
<p>Receive data and get the remote endpoint <code>Address</code>. If the socket is blocking, <code>receiveFrom</code> waits until there is data to be received. </p>
<dl>
<dt>Returns:</dt>
<dd>The number of bytes actually received, <code>0</code> if the remote side has closed the connection, or <code>Socket.ERROR</code> on failure.</dd>
</dl> </dd> <dt class="d_decl" id="Socket.getOption">@trusted int <strong id="getOption">getOption</strong>(SocketOptionLevel level, SocketOption option, void[] result); </dt> <dd>
<p>Get a socket option. </p>
<dl>
<dt>Returns:</dt>
<dd>The number of bytes written to <code>result</code>. The length, in bytes, of the actual result - very different from getsockopt()</dd>
</dl> </dd> <dt class="d_decl" id="Socket.getOption.2">@trusted int <strong id="getOption">getOption</strong>(SocketOptionLevel level, SocketOption option, out int32_t result); </dt> <dd>
<p>Common case of getting integer and boolean options.</p> </dd> <dt class="d_decl" id="Socket.getOption.3">@trusted int <strong id="getOption">getOption</strong>(SocketOptionLevel level, SocketOption option, out Linger result); </dt> <dd>
<p>Get the linger option.</p> </dd> <dt class="d_decl" id="Socket.getOption.4">@trusted void <strong id="getOption">getOption</strong>(SocketOptionLevel level, SocketOption option, out Duration result); </dt> <dd>
<p>Get a timeout (duration) option.</p> </dd> <dt class="d_decl" id="Socket.setOption">@trusted void <strong id="setOption">setOption</strong>(SocketOptionLevel level, SocketOption option, void[] value); </dt> <dd>
<p>Set a socket option.</p> </dd> <dt class="d_decl" id="Socket.setOption.2">@trusted void <strong id="setOption">setOption</strong>(SocketOptionLevel level, SocketOption option, int32_t value); </dt> <dd>
<p>Common case for setting integer and boolean options.</p> </dd> <dt class="d_decl" id="Socket.setOption.3">@trusted void <strong id="setOption">setOption</strong>(SocketOptionLevel level, SocketOption option, Linger value); </dt> <dd>
<p>Set the linger option.</p> </dd> <dt class="d_decl" id="Socket.setOption.4">@trusted void <strong id="setOption">setOption</strong>(SocketOptionLevel level, SocketOption option, Duration value); </dt> <dd>
<p>Sets a timeout (duration) option, i.e. <code>SocketOption.SNDTIMEO</code> or <code>RCVTIMEO</code>. Zero indicates no timeout. </p>
<p>In a typical application, you might also want to consider using a non-blocking socket instead of setting a timeout on a blocking one. </p> <dl>
<dt>Note</dt>
<dd> While the receive timeout setting is generally quite accurate on *nix systems even for smaller durations, there are two issues to be aware of on Windows: First, although undocumented, the effective timeout duration seems to be the one set on the socket plus half a second. <code>setOption()</code> tries to compensate for that, but still, timeouts under 500ms are not possible on Windows. Second, be aware that the actual amount of time spent until a blocking call returns randomly varies on the order of 10ms. </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>SocketOptionLevel <code>level</code>
</td> <td>The level at which a socket option is defined.</td>
</tr> <tr>
<td>SocketOption <code>option</code>
</td> <td>Either <code>SocketOption.SNDTIMEO</code> or <code>SocketOption.RCVTIMEO</code>.</td>
</tr> <tr>
<td>Duration <code>value</code>
</td> <td>The timeout duration to set. Must not be negative.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<code>SocketException</code> if setting the options fails. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">import std.datetime;
import std.typecons;
auto pair = socketPair();
scope(exit) foreach (s; pair) s.close();

// Set a receive timeout, and then wait at one end of
// the socket pair, knowing that no data will arrive.
pair[0].setOption(SocketOptionLevel.SOCKET,
    SocketOption.RCVTIMEO, dur!"seconds"(1));

auto sw = StopWatch(Yes.autoStart);
ubyte[1] buffer;
pair[0].receive(buffer);
writefln("Waited %s ms until the socket timed out.",
    sw.peek.msecs);
</pre>  </dd> <dt class="d_decl" id="Socket.getErrorText">@safe string <strong id="getErrorText">getErrorText</strong>(); </dt> <dd>
<p>Get a text description of this socket's error status, and clear the socket's error status.</p> </dd> <dt class="d_decl" id="Socket.setKeepAlive">@trusted void <strong id="setKeepAlive">setKeepAlive</strong>(int time, int interval); </dt> <dd>
<p>Enables TCP keep-alive with the specified parameters. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>int <code>time</code>
</td> <td>Number of seconds with no activity until the first keep-alive packet is sent.</td>
</tr> <tr>
<td>int <code>interval</code>
</td> <td>Number of seconds between when successive keep-alive packets are sent if no acknowledgement is received.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<code>SocketOSException</code> if setting the options fails, or <code>SocketFeatureException</code> if setting keep-alive parameters is unsupported on the current platform.</dd>
</dl> </dd> <dt class="d_decl" id="Socket.select">static @trusted int <strong id="select">select</strong>(SocketSet checkRead, SocketSet checkWrite, SocketSet checkError, Duration timeout); <br><br>static @safe int <strong id="select">select</strong>(SocketSet checkRead, SocketSet checkWrite, SocketSet checkError); <br><br>static @trusted int <strong id="select">select</strong>(SocketSet checkRead, SocketSet checkWrite, SocketSet checkError, TimeVal* timeout); </dt> <dd>
<p>Wait for a socket to change status. A wait timeout of <a href="core_time#Duration"><code>core.time.Duration</code></a> or <code>TimeVal</code>, may be specified; if a timeout is not specified or the <code>TimeVal</code> is <code>null</code>, the maximum timeout is used. The <code>TimeVal</code> timeout has an unspecified value when <code>select</code> returns. </p>
<dl>
<dt>Returns:</dt>
<dd>The number of sockets with status changes, <code>0</code> on timeout, or <code>-1</code> on interruption. If the return value is greater than <code>0</code>, the <code>SocketSets</code> are updated to only contain the sockets having status changes. For a connecting socket, a write status change means the connection is established and it's able to send. For a listening socket, a read status change means there is an incoming connection request and it's able to accept.  <code>SocketSet</code>'s updated to include only those sockets which an event occured. For a <code>connect()</code>ing socket, writeability means connected. For a <code>listen()</code>ing socket, readability means listening <code>Winsock</code>; possibly internally limited to 64 sockets per set. </dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>the number of events, 0 on timeout, or -1 on interruption</dd>
</dl> </dd> <dt class="d_decl" id="Socket.createAddress">protected pure nothrow @safe Address <strong id="createAddress">createAddress</strong>(); </dt> <dd>
<p>Can be overridden to support other addresses. </p>
<dl>
<dt>Returns:</dt>
<dd>a new <code>Address</code> object for the current address family.</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="TcpSocket">class <strong id="TcpSocket">TcpSocket</strong>: std.socket.Socket; </dt> <dd>
<p><code>TcpSocket</code> is a shortcut class for a TCP Socket.</p> <dl>
<dt class="d_decl" id="TcpSocket.this">@safe this(AddressFamily family); </dt> <dd>
<p>Constructs a blocking TCP Socket.</p> </dd> <dt class="d_decl" id="TcpSocket.this.2">@safe this(); </dt> <dd>
<p>Constructs a blocking IPv4 TCP Socket.</p> </dd> <dt class="d_decl" id="TcpSocket.this.3">@safe this(Address connectTo); </dt> <dd>
<p>Constructs a blocking TCP Socket and connects to an <code>Address</code>.</p> </dd> </dl> </dd> <dt class="d_decl" id="UdpSocket">class <strong id="UdpSocket">UdpSocket</strong>: std.socket.Socket; </dt> <dd>
<p><code>UdpSocket</code> is a shortcut class for a UDP Socket.</p> <dl>
<dt class="d_decl" id="UdpSocket.this">@safe this(AddressFamily family); </dt> <dd>
<p>Constructs a blocking UDP Socket.</p> </dd> <dt class="d_decl" id="UdpSocket.this.2">@safe this(); </dt> <dd>
<p>Constructs a blocking IPv4 UDP Socket.</p> </dd> </dl> </dd> <dt class="d_decl" id="socketPair">@trusted Socket[2] <strong id="socketPair">socketPair</strong>(); </dt> <dd>
<p>Creates a pair of connected sockets. </p>
<p>The two sockets are indistinguishable. </p> <dl>
<dt>Throws:</dt>
<dd>
<code>SocketException</code> if creation of the sockets fails.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">immutable ubyte[] data = [1, 2, 3, 4];
auto pair = socketPair();
scope(exit) foreach (s; pair) s.close();

pair[0].send(data);

auto buf = new ubyte[data.length];
pair[1].receive(buf);
writeln(buf); // data
</pre> </dd>
</dl> </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
     19992019 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_socket.html" class="_attribution-link">https://dlang.org/phobos/std_socket.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
