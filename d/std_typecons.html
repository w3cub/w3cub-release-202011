
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>std.typecons - D - W3cubDocs</title>
  
  <meta name="description" content=" This module implements a variety of type constructors, i.e., templates that allow construction of new, useful general-purpose types. ">
  <meta name="keywords" content="std, typecons, d">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/d/std_typecons.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/d.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/d/" class="_nav-link" title="" style="margin-left:0;">D</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _d">
				
				
<h1>std.typecons</h1>  <p>This module implements a variety of type constructors, i.e., templates that allow construction of new, useful general-purpose types. </p>
<p> </p>
<table>

<tr>
<th scope="col">Category</th> <th scope="col">Functions</th>
</tr> <tr>
<td>Tuple</td> <td> <a href="#isTuple"><code>isTuple</code></a> <a href="#Tuple"><code>Tuple</code></a> <a href="#tuple"><code>tuple</code></a> <a href="#reverse"><code>reverse</code></a> </td>
</tr> <tr>
<td>Flags</td> <td> <a href="#BitFlags"><code>BitFlags</code></a> <a href="#isBitFlagEnum"><code>isBitFlagEnum</code></a> <a href="#Flag"><code>Flag</code></a> <a href="#No"><code>No</code></a> <a href="#Yes"><code>Yes</code></a> </td>
</tr> <tr>
<td>Memory allocation</td> <td> <a href="#RefCounted"><code>RefCounted</code></a> <a href="#refCounted"><code>refCounted</code></a> <a href="#RefCountedAutoInitialize"><code>RefCountedAutoInitialize</code></a> <a href="#scoped"><code>scoped</code></a> <a href="#Unique"><code>Unique</code></a> </td>
</tr> <tr>
<td>Code generation</td> <td> <a href="#AutoImplement"><code>AutoImplement</code></a> <a href="#BlackHole"><code>BlackHole</code></a> <a href="#generateAssertTrap"><code>generateAssertTrap</code></a> <a href="#generateEmptyFunction"><code>generateEmptyFunction</code></a> <a href="#WhiteHole"><code>WhiteHole</code></a> </td>
</tr> <tr>
<td>Nullable</td> <td> <a href="#Nullable"><code>Nullable</code></a> <a href="#nullable"><code>nullable</code></a> <a href="#NullableRef"><code>NullableRef</code></a> <a href="#nullableRef"><code>nullableRef</code></a> </td>
</tr> <tr>
<td>Proxies</td> <td> <a href="#Proxy"><code>Proxy</code></a> <a href="#rebindable"><code>rebindable</code></a> <a href="#Rebindable"><code>Rebindable</code></a> <a href="#ReplaceType"><code>ReplaceType</code></a> <a href="#unwrap"><code>unwrap</code></a> <a href="#wrap"><code>wrap</code></a> </td>
</tr> <tr>
<td>Types</td> <td> <a href="#alignForSize"><code>alignForSize</code></a> <a href="#Ternary"><code>Ternary</code></a> <a href="#Typedef"><code>Typedef</code></a> <a href="#TypedefType"><code>TypedefType</code></a> <a href="#UnqualRef"><code>UnqualRef</code></a> </td>
</tr> </table>  <dl>
<dt>License:</dt>
<dd>
<a href="http://boost.org/LICENSE_1_0.txt">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/typecons.d">std/typecons.d</a></span> </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>
<a href="http://erdani.org">Andrei Alexandrescu</a>, <a href="http://bartoszmilewski.wordpress.com">Bartosz Milewski</a>, Don Clugston, Shin Fujishiro, Kenji Hara</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">// value tuples
alias Coord = Tuple!(int, "x", int, "y", int, "z");
Coord c;
c[1] = 1;       // access by index
c.z = 1;        // access by given name
writeln(c); // Coord(0, 1, 1)

// names can be omitted
alias DicEntry = Tuple!(string, string);

// tuples can also be constructed on instantiation
writeln(tuple(2, 3, 4)[1]); // 3
// construction on instantiation works with names too
writeln(tuple!("x", "y", "z")(2, 3, 4).y); // 3

// Rebindable references to const and immutable objects
{
    class Widget { void foo() const @safe {} }
    const w1 = new Widget, w2 = new Widget;
    w1.foo();
    // w1 = w2 would not work; can't rebind const object
    auto r = Rebindable!(const Widget)(w1);
    // invoke method as if r were a Widget object
    r.foo();
    // rebind r to refer to another object
    r = w2;
}
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="Unique">struct <strong id="Unique">Unique</strong>(T); </dt> <dd>
<p>Encapsulates unique ownership of a resource. </p>
<p>When a <code>Unique!T</code> goes out of scope it will call <code>destroy</code> on the resource <code>T</code> that it manages, unless it is transferred. One important consequence of <code>destroy</code> is that it will call the destructor of the resource <code>T</code>. GC-managed references are not guaranteed to be valid during a destructor call, but other members of <code>T</code>, such as file handles or pointers to <code>malloc</code> memory, will still be valid during the destructor call. This allows the resource <code>T</code> to deallocate or clean up any non-GC resources. <br><br> If it is desirable to persist a <code>Unique!T</code> outside of its original scope, then it can be transferred. The transfer can be explicit, by calling <code>release</code>, or implicit, when returning Unique from a function. The resource <code>T</code> can be a polymorphic class object or instance of an interface, in which case Unique behaves polymorphically too. <br><br> If <code>T</code> is a value type, then <code>Unique!T</code> will be implemented as a reference to a <code>T</code>.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static struct S
{
    int i;
    this(int i){this.i = i;}
}
Unique!S produce()
{
    // Construct a unique instance of S on the heap
    Unique!S ut = new S(5);
    // Implicit transfer of ownership
    return ut;
}
// Borrow a unique resource by ref
void increment(ref Unique!S ur)
{
    ur.i++;
}
void consume(Unique!S u2)
{
    writeln(u2.i); // 6
    // Resource automatically deleted here
}
Unique!S u1;
assert(u1.isEmpty);
u1 = produce();
increment(u1);
writeln(u1.i); // 6
//consume(u1); // Error: u1 is not copyable
// Transfer ownership of the resource
consume(u1.release);
assert(u1.isEmpty);
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="Unique.RefT">alias <strong id="RefT">RefT</strong> = T; </dt> <dd>
<p>Represents a reference to <code>T</code>. Resolves to <code>T*</code> if <code>T</code> is a value type.</p> </dd> <dt class="d_decl" id="Unique.create">Unique!T <strong id="create">create</strong>(A...)(auto ref A args)<br><small>  Constraints: if (__traits(compiles, new T(args))); </small>
</dt> <dd>
<p>Allows safe construction of <code>Unique</code>. It creates the resource and guarantees unique ownership of it (unless <code>T</code> publishes aliases of <code>this</code>). </p>
<dl>
<dt>Note</dt>
<dd> Nested structs/classes cannot be created. </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>A <code>args</code>
</td> <td>Arguments to pass to <code>T</code>'s constructor. <pre data-language="d">static class C {}
auto u = Unique!(C).create();
</pre> </td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Unique.this">this(RefT p); </dt> <dd>
<p> Constructor that takes an rvalue. It will ensure uniqueness, as long as the rvalue isn't just a view on an lvalue (e.g., a cast). Typical usage: </p>
<pre data-language="d">Unique!Foo f = new Foo;
</pre>  </dd> <dt class="d_decl" id="Unique.this.2">this(ref RefT p); </dt> <dd>
<p>Constructor that takes an lvalue. It nulls its source. The nulling will ensure uniqueness as long as there are no previous aliases to the source.</p> </dd> <dt class="d_decl" id="Unique.this.3">this(U)(Unique!U u)<br><small>  Constraints: if (is(u.RefT : RefT)); </small>
</dt> <dd>
<p>Constructor that takes a <code>Unique</code> of a type that is convertible to our type. </p>
<p>Typically used to transfer a <code>Unique</code> rvalue of derived type to a <code>Unique</code> of base type. </p> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">class C : Object {}

Unique!C uc = new C;
Unique!Object uo = uc.release;
</pre>  </dd> <dt class="d_decl" id="Unique.opAssign">void <strong id="opAssign">opAssign</strong>(U)(Unique!U u)<br><small>  Constraints: if (is(u.RefT : RefT)); </small>
</dt> <dd>
<p>Transfer ownership from a <code>Unique</code> of a type that is convertible to our type.</p> </dd> <dt class="d_decl" id="Unique.isEmpty">const @property bool <strong id="isEmpty">isEmpty</strong>(); </dt> <dd>
<p>Returns whether the resource exists.</p> </dd> <dt class="d_decl" id="Unique.release">Unique <strong id="release">release</strong>(); </dt> <dd>
<p>Transfer ownership to a <code>Unique</code> rvalue. Nullifies the current contents. Same as calling std.algorithm.move on it.</p> </dd> </dl> </dd> <dt class="d_decl" id="Tuple">struct <strong id="Tuple">Tuple</strong>(Specs...) if (distinctFieldNames!Specs); </dt> <dd>
<p>Tuple of values, for example <code>Tuple!(int, string)</code> is a record that stores an <code>int</code> and a <code>string</code>. <code>Tuple</code> can be used to bundle values together, notably when returning multiple values from a function. If <code>obj</code> is a <code>Tuple</code>, the individual members are accessible with the syntax <code>obj[0]</code> for the first field, <code>obj[1]</code> for the second, and so on. </p>
<dl>
<dt>See Also:</dt>
<dd>
<a href="#tuple"><code>tuple</code></a>. </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Specs</td> <td>A list of types (and optionally, member names) that the <code>Tuple</code> contains.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">Tuple!(int, int) point;
// assign coordinates
point[0] = 5;
point[1] = 6;
// read coordinates
auto x = point[0];
auto y = point[1];
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<code>Tuple</code> members can be named. It is legal to mix named and unnamed members. The method above is still applicable to all fields. <pre data-language="d">alias Entry = Tuple!(int, "index", string, "value");
Entry e;
e.index = 4;
e.value = "Hello";
writeln(e[1]); // "Hello"
writeln(e[0]); // 4
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>A <code>Tuple</code> with named fields is a distinct type from a <code>Tuple</code> with unnamed fields, i.e. each naming imparts a separate type for the <code>Tuple</code>. Two <code>Tuple</code>s differing in naming only are still distinct, even though they might have the same structure. <pre data-language="d">Tuple!(int, "x", int, "y") point1;
Tuple!(int, int) point2;
assert(!is(typeof(point1) == typeof(point2)));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Use tuples as ranges <pre data-language="d">import std.algorithm.iteration : sum;
import std.range : only;
auto t = tuple(1, 2);
writeln(t.expand.only.sum); // 3
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Concatenate tuples <pre data-language="d">import std.meta : AliasSeq;
auto t = tuple(1, "2") ~ tuple(ushort(42), true);
static assert(is(t.Types == AliasSeq!(int, string, ushort, bool)));
writeln(t[1]); // "2"
writeln(t[2]); // 42
writeln(t[3]); // true
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="Tuple.Types">alias <strong id="Types">Types</strong> = staticMap!(extractType, fieldSpecs); </dt> <dd>
<p>The types of the <code>Tuple</code>'s components.</p> </dd> <dt class="d_decl" id="Tuple.fieldNames">alias <strong id="fieldNames">fieldNames</strong> = staticMap!(extractName, fieldSpecs); </dt> <dd>
<p>The names of the <code>Tuple</code>'s components. Unnamed fields have empty names.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">alias Fields = Tuple!(int, "id", string, float);
static assert(Fields.fieldNames == AliasSeq!("id", "", ""));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Tuple.expand">Types <strong id="expand">expand</strong>; </dt> <dd>
<p>Use <code>t.expand</code> for a <code>Tuple</code> <code>t</code> to expand it into its components. The result of <code>expand</code> acts as if the <code>Tuple</code>'s components were listed as a list of values. (Ordinarily, a <code>Tuple</code> acts as a single value.)</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto t1 = tuple(1, " hello ", 'a');
writeln(t1.toString()); // `Tuple!(int, string, char)(1, " hello ", 'a')`

void takeSeveralTypes(int n, string s, bool b)
{
    assert(n == 4 &amp;&amp; s == "test" &amp;&amp; b == false);
}

auto t2 = tuple(4, "test", false);
//t.expand acting as a list of values
takeSeveralTypes(t2.expand);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Tuple.this">this(Types values); </dt> <dd>
<p>Constructor taking one value for each field. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Types <code>values</code>
</td> <td>A list of values that are either the same types as those given by the <code>Types</code> field of this <code>Tuple</code>, or can implicitly convert to those types. They must be in the same order as they appear in <code>Types</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">alias ISD = Tuple!(int, string, double);
auto tup = ISD(1, "test", 3.2);
writeln(tup.toString()); // `Tuple!(int, string, double)(1, "test", 3.2)`
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Tuple.this.2">this(U, size_t n)(U[n] values)<br><small>  Constraints: if (n == Types.length &amp;&amp; allSatisfy!(isBuildableFrom!U, Types)); </small>
</dt> <dd>
<p>Constructor taking a compatible array. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>U[n] <code>values</code>
</td> <td>A compatible static array to build the <code>Tuple</code> from. Array slices are not supported.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int[2] ints;
Tuple!(int, int) t = ints;
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Tuple.this.3">this(U)(U another)<br><small>  Constraints: if (areBuildCompatibleTuples!(typeof(this), U)); </small>
</dt> <dd>
<p>Constructor taking a compatible <code>Tuple</code>. Two <code>Tuple</code>s are compatible <b>iff</b> they are both of the same length, and, for each type <code>T</code> on the left-hand side, the corresponding type <code>U</code> on the right-hand side can implicitly convert to <code>T</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>U <code>another</code>
</td> <td>A compatible <code>Tuple</code> to build from. Its type must be compatible with the target <code>Tuple</code>'s type.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">alias IntVec = Tuple!(int, int, int);
alias DubVec = Tuple!(double, double, double);

IntVec iv = tuple(1, 1, 1);

//Ok, int can implicitly convert to double
DubVec dv = iv;
//Error: double cannot implicitly convert to int
//IntVec iv2 = dv;
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Tuple.opEquals">bool <strong id="opEquals">opEquals</strong>(R)(R rhs)<br><small>  Constraints: if (areCompatibleTuples!(typeof(this), R, "==")); </small><br><br>const bool <strong id="opEquals">opEquals</strong>(R)(R rhs)<br><small>  Constraints: if (areCompatibleTuples!(typeof(this), R, "==")); </small><br><br>bool <strong id="opEquals">opEquals</strong>(R...)(auto ref R rhs)<br><small>  Constraints: if (R.length &gt; 1 &amp;&amp; areCompatibleTuples!(typeof(this), Tuple!R, "==")); </small>
</dt> <dd>
<p>Comparison for equality. Two <code>Tuple</code>s are considered equal <b>iff</b> they fulfill the following criteria: </p>
<p></p>
<ul> <li>Each <code>Tuple</code> is the same length.</li> <li>For each type <code>T</code> on the left-hand side and each type <code>U</code> on the right-hand side, values of type <code>T</code> can be compared with values of type <code>U</code>.</li> <li>For each value <code>v1</code> on the left-hand side and each value <code>v2</code> on the right-hand side, the expression <code>v1 == v2</code> is true.</li>
</ul>  <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>rhs</code>
</td> <td>The <code>Tuple</code> to compare against. It must meeting the criteria for comparison between <code>Tuple</code>s.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>true if both <code>Tuple</code>s are equal, otherwise false.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">Tuple!(int, string) t1 = tuple(1, "test");
Tuple!(double, string) t2 =  tuple(1.0, "test");
//Ok, int can be compared with double and
//both have a value of 1
writeln(t1); // t2
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Tuple.opCmp">int <strong id="opCmp">opCmp</strong>(R)(R rhs)<br><small>  Constraints: if (areCompatibleTuples!(typeof(this), R, "&lt;")); </small><br><br>const int <strong id="opCmp">opCmp</strong>(R)(R rhs)<br><small>  Constraints: if (areCompatibleTuples!(typeof(this), R, "&lt;")); </small>
</dt> <dd>
<p>Comparison for ordering. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>rhs</code>
</td> <td>The <code>Tuple</code> to compare against. It must meet the criteria for comparison between <code>Tuple</code>s.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>For any values <code>v1</code> on the right-hand side and <code>v2</code> on the left-hand side:  <ul> <li>A negative integer if the expression <code>v1 &lt; v2</code> is true.</li> <li>A positive integer if the expression <code>v1 &gt; v2</code> is true.</li> <li>0 if the expression <code>v1 == v2</code> is true.</li>
</ul>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>The first <code>v1</code> for which <code>v1 &gt; v2</code> is true determines the result. This could lead to unexpected behaviour. <pre data-language="d">auto tup1 = tuple(1, 1, 1);
auto tup2 = tuple(1, 100, 100);
assert(tup1 &lt; tup2);

//Only the first result matters for comparison
tup1[0] = 2;
assert(tup1 &gt; tup2);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Tuple.opBinary">auto <strong id="opBinary">opBinary</strong>(string op, T)(auto ref T t)<br><small>  Constraints: if (op == "~" &amp;&amp; !(is(T : U[], U) &amp;&amp; isTuple!U)); </small><br><br>auto <strong id="opBinaryRight">opBinaryRight</strong>(string op, T)(auto ref T t)<br><small>  Constraints: if (op == "~" &amp;&amp; !(is(T : U[], U) &amp;&amp; isTuple!U)); </small>
</dt> <dd>
<p>Concatenate Tuples. Tuple concatenation is only allowed if all named fields are distinct (no named field of this tuple occurs in <code>t</code> and no named field of <code>t</code> occurs in this tuple). </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>t</code>
</td> <td>The <code>Tuple</code> to concatenate with</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A concatenation of this tuple and <code>t</code>
</dd>
</dl> </dd> <dt class="d_decl" id="Tuple.opAssign">ref Tuple <strong id="opAssign">opAssign</strong>(R)(auto ref R rhs)<br><small>  Constraints: if (areCompatibleTuples!(typeof(this), R, "=")); </small>
</dt> <dd>
<p>Assignment from another <code>Tuple</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>rhs</code>
</td> <td>The source <code>Tuple</code> to assign from. Each element of the source <code>Tuple</code> must be implicitly assignable to each respective element of the target <code>Tuple</code>.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Tuple.rename">inout ref auto <strong id="rename">rename</strong>(names...)() return<br><small>  Constraints: if (names.length == 0 || allSatisfy!(isSomeString, typeof(names))); </small>
</dt> <dd>
<p>Renames the elements of a <a href="#Tuple"><code>Tuple</code></a>. </p>
<p><code>rename</code> uses the passed <code>names</code> and returns a new <a href="#Tuple"><code>Tuple</code></a> using these names, with the content unchanged. If fewer names are passed than there are members of the <a href="#Tuple"><code>Tuple</code></a> then those trailing members are unchanged. An empty string will remove the name for that member. It is an compile-time error to pass more names than there are members of the <a href="#Tuple"><code>Tuple</code></a>.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto t0 = tuple(4, "hello");

auto t0Named = t0.rename!("val", "tag");
writeln(t0Named.val); // 4
writeln(t0Named.tag); // "hello"

Tuple!(float, "dat", size_t[2], "pos") t1;
t1.pos = [2, 1];
auto t1Named = t1.rename!"height";
t1Named.height = 3.4f;
writeln(t1Named.height); // 3.4f
writeln(t1Named.pos); // [2, 1]
t1Named.rename!"altitude".altitude = 5;
writeln(t1Named.height); // 5

Tuple!(int, "a", int, int, "c") t2;
t2 = tuple(3,4,5);
auto t2Named = t2.rename!("", "b");
// "a" no longer has a name
static assert(!hasMember!(typeof(t2Named), "a"));
writeln(t2Named[0]); // 3
writeln(t2Named.b); // 4
writeln(t2Named.c); // 5

// not allowed to specify more names than the tuple has members
static assert(!__traits(compiles, t2.rename!("a","b","c","d")));

// use it in a range pipeline
import std.range : iota, zip;
import std.algorithm.iteration : map, sum;
auto res = zip(iota(1, 4), iota(10, 13))
    .map!(t =&gt; t.rename!("a", "b"))
    .map!(t =&gt; t.a * t.b)
    .sum;
writeln(res); // 68

const tup = Tuple!(int, "a", int, "b")(2, 3);
const renamed = tup.rename!("c", "d");
writeln(renamed.c + renamed.d); // 5
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Tuple.rename.2">inout ref auto <strong id="rename">rename</strong>(alias translate)()<br><small>  Constraints: if (is(typeof(translate) : V[K], V, K) &amp;&amp; isSomeString!V &amp;&amp; (isSomeString!K || is(K : size_t))); </small>
</dt> <dd>
<p>Overload of <a href="#rename"><code>rename</code></a> that takes an associative array <code>translate</code> as a template parameter, where the keys are either the names or indices of the members to be changed and the new names are the corresponding values. Every key in <code>translate</code> must be the name of a member of the <a href="#tuple"><code>tuple</code></a>. The same rules for empty strings apply as for the variadic template overload of <a href="#rename"><code>rename</code></a>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">//replacing names by their current name

Tuple!(float, "dat", size_t[2], "pos") t1;
t1.pos = [2, 1];
auto t1Named = t1.rename!(["dat": "height"]);
t1Named.height = 3.4;
writeln(t1Named.pos); // [2, 1]
t1Named.rename!(["height": "altitude"]).altitude = 5;
writeln(t1Named.height); // 5

Tuple!(int, "a", int, "b") t2;
t2 = tuple(3, 4);
auto t2Named = t2.rename!(["a": "b", "b": "c"]);
writeln(t2Named.b); // 3
writeln(t2Named.c); // 4

const t3 = Tuple!(int, "a", int, "b")(3, 4);
const t3Named = t3.rename!(["a": "b", "b": "c"]);
writeln(t3Named.b); // 3
writeln(t3Named.c); // 4
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">//replace names by their position

Tuple!(float, "dat", size_t[2], "pos") t1;
t1.pos = [2, 1];
auto t1Named = t1.rename!([0: "height"]);
t1Named.height = 3.4;
writeln(t1Named.pos); // [2, 1]
t1Named.rename!([0: "altitude"]).altitude = 5;
writeln(t1Named.height); // 5

Tuple!(int, "a", int, "b", int, "c") t2;
t2 = tuple(3, 4, 5);
auto t2Named = t2.rename!([0: "c", 2: "a"]);
writeln(t2Named.a); // 5
writeln(t2Named.b); // 4
writeln(t2Named.c); // 3
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Tuple.slice">inout @property ref @trusted inout(Tuple!(sliceSpecs!(from, to))) <strong id="slice">slice</strong>(size_t from, size_t to)()<br><small>  Constraints: if (from &lt;= to &amp;&amp; (to &lt;= Types.length)); </small>
</dt> <dd>
<p>Takes a slice by-reference of this <code>Tuple</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>from</td> <td>A <code>size_t</code> designating the starting position of the slice.</td>
</tr> <tr>
<td>to</td> <td>A <code>size_t</code> designating the ending position (exclusive) of the slice.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A new <code>Tuple</code> that is a slice from <code>[from, to)</code> of the original. It has the same types and values as the range <code>[from, to)</code> in the original.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">Tuple!(int, string, float, double) a;
a[1] = "abc";
a[2] = 4.5;
auto s = a.slice!(1, 3);
static assert(is(typeof(s) == Tuple!(string, float)));
assert(s[0] == "abc" &amp;&amp; s[1] == 4.5);

// Phobos issue #15645
Tuple!(int, short, bool, double) b;
static assert(!__traits(compiles, b.slice!(2, 4)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Tuple.toHash">const nothrow @safe size_t <strong id="toHash">toHash</strong>(); </dt> <dd>
<p>Creates a hash of this <code>Tuple</code>. </p>
<dl>
<dt>Returns:</dt>
<dd>A <code>size_t</code> representing the hash of this <code>Tuple</code>.</dd>
</dl> </dd> <dt class="d_decl" id="Tuple.toString">const string <strong id="toString">toString</strong>()(); </dt> <dd>
<p>Converts to string. </p>
<dl>
<dt>Returns:</dt>
<dd>The string representation of this <code>Tuple</code>.</dd>
</dl> </dd> <dt class="d_decl" id="Tuple.toString.2">const void <strong id="toString">toString</strong>(DG)(scope DG sink); <br><br>const void <strong id="toString">toString</strong>(DG, Char)(scope DG sink, ref scope const FormatSpec!Char fmt); </dt> <dd>
<p>Formats <code>Tuple</code> with either <code>%s</code>, <code>%(inner%)</code> or <code>%(inner%|sep%)</code>. </p>
<center><table>
<caption>Formats supported by Tuple</caption> <tr>
<th class="donthyphenate"><b>Format</b></th>
<th class="donthyphenate"><b>Description</b></th>
</tr> <tr>
<td><p><code>%s</code></p></td>
<td><p>Format like <code>Tuple!(types)(elements formatted with %s each)</code>.</p></td>
</tr> <tr>
<td><p><code>%(inner%)</code></p></td>
<td><p>The format <code>inner</code> is applied the expanded <code>Tuple</code>, so it may contain as many formats as the <code>Tuple</code> has fields.</p></td>
</tr> <tr>
<td><p><code>%(inner%|sep%)</code></p></td>
<td><p>The format <code>inner</code> is one format, that is applied on all fields of the <code>Tuple</code>. The inner format must be compatible to all of them.</p></td>
</tr>
</table></center>  <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>DG <code>sink</code>
</td> <td>A <code>char</code> accepting delegate</td>
</tr> <tr>
<td>FormatSpec!Char <code>fmt</code>
</td> <td>A <a href="std_format#FormatSpec"><code>std.format.FormatSpec</code></a>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.format : format;

Tuple!(int, double)[3] tupList = [ tuple(1, 1.0), tuple(2, 4.0), tuple(3, 9.0) ];

// Default format
writeln(format("%s", tuple("a", 1))); // `Tuple!(string, int)("a", 1)`

// One Format for each individual component
writeln(format("%(%#x v %.4f w %#x%)", tuple(1, 1.0, 10))); // `0x1 v 1.0000 w 0xa`
writeln(format("%#x v %.4f w %#x", tuple(1, 1.0, 10).expand)); // `0x1 v 1.0000 w 0xa`

// One Format for all components
// `&gt;abc&lt; &amp; &gt;1&lt; &amp; &gt;2.3&lt; &amp; &gt;[4, 5]&lt;`
writeln(format("%(&gt;%s&lt;%| &amp; %)", tuple("abc", 1, 2.3, [4, 5])));

// Array of Tuples
writeln(format("%(%(f(%d) = %.1f%);  %)", tupList)); // `f(1) = 1.0;  f(2) = 4.0;  f(3) = 9.0`
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.exception : assertThrown;
import std.format : format, FormatException;

// Error: %( %) missing.
assertThrown!FormatException(
    format("%d, %f", tuple(1, 2.0)) == `1, 2.0`
);

// Error: %( %| %) missing.
assertThrown!FormatException(
    format("%d", tuple(1, 2)) == `1, 2`
);

// Error: %d inadequate for double
assertThrown!FormatException(
    format("%(%d%|, %)", tuple(1, 2.0)) == `1, 2.0`
);
</pre> </dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="reverse">auto <strong id="reverse">reverse</strong>(T)(T t)<br><small>  Constraints: if (isTuple!T); </small>
</dt> <dd>
<p>Creates a copy of a <a href="#Tuple"><code>Tuple</code></a> with its fields in reverse order. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>t</code>
</td> <td>The <code>Tuple</code> to copy.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A new <code>Tuple</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto tup = tuple(1, "2");
writeln(tup.reverse); // tuple("2", 1)
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="tuple">template <strong id="tuple">tuple</strong>(Names...)</dt> <dd>
<p>Constructs a <a href="#Tuple"><code>Tuple</code></a> object instantiated and initialized according to the given arguments. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Names</td> <td>An optional list of strings naming each successive field of the <code>Tuple</code> or a list of types that the elements are being casted to. For a list of names, each name matches up with the corresponding field given by <code>Args</code>. A name does not have to be provided for every field, but as the names must proceed in order, it is not possible to skip one field and name the next after it. For a list of types, there must be exactly as many types as parameters.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto value = tuple(5, 6.7, "hello");
writeln(value[0]); // 5
writeln(value[1]); // 6.7
writeln(value[2]); // "hello"

// Field names can be provided.
auto entry = tuple!("index", "value")(4, "Hello");
writeln(entry.index); // 4
writeln(entry.value); // "Hello"
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="tuple.tuple">auto <strong id="tuple">tuple</strong>(Args...)(Args args); </dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Args <code>args</code>
</td> <td>Values to initialize the <code>Tuple</code> with. The <code>Tuple</code>'s type will be inferred from the types of the values given.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A new <code>Tuple</code> with its type inferred from the arguments given.</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="isTuple">enum auto <strong id="isTuple">isTuple</strong>(T); </dt> <dd>
<p>Returns <code>true</code> if and only if <code>T</code> is an instance of <code>std.typecons.Tuple</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>The type to check.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>true if <code>T</code> is a <code>Tuple</code> type, false otherwise.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(isTuple!(Tuple!()));
static assert(isTuple!(Tuple!(int)));
static assert(isTuple!(Tuple!(int, real, string)));
static assert(isTuple!(Tuple!(int, "x", real, "y")));
static assert(isTuple!(Tuple!(int, Tuple!(real), string)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Rebindable">template <strong id="Rebindable">Rebindable</strong>(T) if (is(T == class) || is(T == interface) || isDynamicArray!T || isAssociativeArray!T)</dt> <dd>
<p><code>Rebindable!(T)</code> is a simple, efficient wrapper that behaves just like an object of type <code>T</code>, except that you can reassign it to refer to another object. For completeness, <code>Rebindable!(T)</code> aliases itself away to <code>T</code> if <code>T</code> is a non-const object type. </p>
<p>You may want to use <code>Rebindable</code> when you want to have mutable storage referring to <code>const</code> objects, for example an array of references that must be sorted in place. <code>Rebindable</code> does not break the soundness of D's type system and does not incur any of the risks usually associated with <code>cast</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>An object, interface, array slice type, or associative array type.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Regular <code>const</code> object references cannot be reassigned. <pre data-language="d">class Widget { int x; int y() @safe const { return x; } }
const a = new Widget;
// Fine
a.y();
// error! can't modify const a
// a.x = 5;
// error! can't modify const a
// a = new Widget;
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>However, <code>Rebindable!(Widget)</code> does allow reassignment, while otherwise behaving exactly like a <code>const Widget</code>. <pre data-language="d">class Widget { int x; int y() const @safe { return x; } }
auto a = Rebindable!(const Widget)(new Widget);
// Fine
a.y();
// error! can't modify const a
// a.x = 5;
// Fine
a = new Widget;
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="rebindable">Rebindable!T <strong id="rebindable">rebindable</strong>(T)(T obj)<br><small>  Constraints: if (is(T == class) || is(T == interface) || isDynamicArray!T || isAssociativeArray!T); </small>
</dt> <dd>
<p>Convenience function for creating a <code>Rebindable</code> using automatic type inference. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>obj</code>
</td> <td>A reference to an object, interface, associative array, or an array slice to initialize the <code>Rebindable</code> with.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A newly constructed <code>Rebindable</code> initialized with the given reference.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">class C
{
    int payload;
    this(int p) { payload = p; }
}
const c = new C(1);

auto c2 = c.rebindable;
writeln(c2.payload); // 1
// passing Rebindable to rebindable
c2 = c2.rebindable;

c2 = new C(2);
writeln(c2.payload); // 2

const c3 = c2.get;
writeln(c3.payload); // 2
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="rebindable.2">Rebindable!T <strong id="rebindable">rebindable</strong>(T)(Rebindable!T obj); </dt> <dd>
<p>This function simply returns the <code>Rebindable</code> object passed in. It's useful in generic programming cases when a given object may be either a regular <code>class</code> or a <code>Rebindable</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Rebindable!T <code>obj</code>
</td> <td>An instance of Rebindable!T.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>obj</code> without any modification.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">class C
{
    int payload;
    this(int p) { payload = p; }
}
const c = new C(1);

auto c2 = c.rebindable;
writeln(c2.payload); // 1
// passing Rebindable to rebindable
c2 = c2.rebindable;
writeln(c2.payload); // 1
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="UnqualRef">template <strong id="UnqualRef">UnqualRef</strong>(T) if (is(T == class) || is(T == interface))</dt> <dd>
<p>Similar to <code>Rebindable!(T)</code> but strips all qualifiers from the reference as opposed to just constness / immutability. Primary intended use case is with shared (having thread-local reference to shared class data) </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>A class or interface type.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">class Data {}

static shared(Data) a;
static UnqualRef!(shared Data) b;

import core.thread;

auto thread = new core.thread.Thread({
    a = new shared Data();
    b = new shared Data();
});

thread.start();
thread.join();

assert(a !is null);
assert(b is null);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="alignForSize">string <strong id="alignForSize">alignForSize</strong>(E...)(const char[][] names...); </dt> <dd>
<p>Order the provided members to minimize size while preserving alignment. Alignment is not always optimal for 80-bit reals, nor for structs declared as align(1). </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>E</td> <td>A list of the types to be aligned, representing fields of an aggregate such as a <code>struct</code> or <code>class</code>.</td>
</tr> <tr>
<td>char[][] <code>names</code>
</td> <td>The names of the fields that are to be aligned.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A string to be mixed in to an aggregate, such as a <code>struct</code> or <code>class</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">struct Banner {
    mixin(alignForSize!(byte[6], double)(["name", "height"]));
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Nullable">struct <strong id="Nullable">Nullable</strong>(T); <br><br>auto <strong id="nullable">nullable</strong>(T)(T t); </dt> <dd>
<p>Defines a value paired with a distinctive "null" state that denotes the absence of a value. If default constructed, a <code>Nullable!T</code> object starts in the null state. Assigning it renders it non-null. Calling <code>nullify</code> can nullify it again. </p>
<p>Practically <code>Nullable!T</code> stores a <code>T</code> and a <code>bool</code>.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">struct CustomerRecord
{
    string name;
    string address;
    int customerNum;
}

Nullable!CustomerRecord getByName(string name)
{
    //A bunch of hairy stuff

    return Nullable!CustomerRecord.init;
}

auto queryResult = getByName("Doe, John");
if (!queryResult.isNull)
{
    //Process Mr. Doe's customer record
    auto address = queryResult.get.address;
    auto customerNum = queryResult.get.customerNum;

    //Do some things with this customer's info
}
else
{
    //Add the customer to the database
}
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.exception : assertThrown;

auto a = 42.nullable;
assert(!a.isNull);
writeln(a.get); // 42

a.nullify();
assert(a.isNull);
assertThrown!Throwable(a.get);
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="Nullable.this">inout this(inout T value); </dt> <dd>
<p>Constructor initializing <code>this</code> with <code>value</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>value</code>
</td> <td>The value to initialize this <code>Nullable</code> with.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Nullable.opEquals">const bool <strong id="opEquals">opEquals</strong>()(auto ref const(typeof(this)) rhs); <br><br>const bool <strong id="opEquals">opEquals</strong>(U)(auto ref const(U) rhs)<br><small>  Constraints: if (is(typeof(this.get == rhs))); </small>
</dt> <dd>
<p>If they are both null, then they are equal. If one is null and the other is not, then they are not equal. If they are both non-null, then they are equal if their values are equal.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">Nullable!int empty;
Nullable!int a = 42;
Nullable!int b = 42;
Nullable!int c = 27;

writeln(empty); // empty
writeln(empty); // Nullable!int.init
assert(empty != a);
assert(empty != b);
assert(empty != c);

writeln(a); // b
assert(a != c);

assert(empty != 42);
writeln(a); // 42
assert(c != 42);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Nullable.toString">string <strong id="toString">toString</strong>(); <br><br>const string <strong id="toString">toString</strong>(); <br><br>void <strong id="toString">toString</strong>(W)(ref W writer, ref scope const FormatSpec!char fmt)<br><small>  Constraints: if (isOutputRange!(W, char)); </small><br><br>const void <strong id="toString">toString</strong>(W)(ref W writer, ref scope const FormatSpec!char fmt)<br><small>  Constraints: if (isOutputRange!(W, char)); </small>
</dt> <dd>
<p>Gives the string <code>"Nullable.null"</code> if <code>isNull</code> is <code>true</code>. Otherwise, the result is equivalent to calling <a href="std_format#formattedWrite"><code>std.format.formattedWrite</code></a> on the underlying value. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>W <code>writer</code>
</td> <td>A <code>char</code> accepting <a href="std_range_primitives#isOutputRange">output range</a>
</td>
</tr> <tr>
<td>FormatSpec!char <code>fmt</code>
</td> <td>A <a href="std_format#FormatSpec"><code>std.format.FormatSpec</code></a> which is used to represent the value if this Nullable is not null</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A <code>string</code> if <code>writer</code> and <code>fmt</code> are not set; <code>void</code> otherwise.</dd>
</dl> </dd> <dt class="d_decl" id="Nullable.isNull">const pure nothrow @property @safe bool <strong id="isNull">isNull</strong>(); </dt> <dd>
<p>Check if <code>this</code> is in the null state. </p>
<dl>
<dt>Returns:</dt>
<dd>true <b>iff</b> <code>this</code> is in the null state, otherwise false.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">Nullable!int ni;
assert(ni.isNull);

ni = 0;
assert(!ni.isNull);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Nullable.nullify">void <strong id="nullify">nullify</strong>()(); </dt> <dd>
<p>Forces <code>this</code> to the null state.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">Nullable!int ni = 0;
assert(!ni.isNull);

ni.nullify();
assert(ni.isNull);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Nullable.opAssign">void <strong id="opAssign">opAssign</strong>()(T value); </dt> <dd>
<p>Assigns <code>value</code> to the internally-held state. If the assignment succeeds, <code>this</code> becomes non-null. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>value</code>
</td> <td>A value of type <code>T</code> to assign to this <code>Nullable</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>If this <code>Nullable</code> wraps a type that already has a null value (such as a pointer), then assigning the null value to this <code>Nullable</code> is no different than assigning any other value of type <code>T</code>, and the resulting code will look very strange. It is strongly recommended that this be avoided by instead using the version of <code>Nullable</code> that takes an additional <code>nullValue</code> template argument. <pre data-language="d">//Passes
Nullable!(int*) npi;
assert(npi.isNull);

//Passes?!
npi = null;
assert(!npi.isNull);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Nullable.get">inout pure nothrow @property ref @safe inout(T) <strong id="get">get</strong>(); <br><br>inout pure nothrow @property @safe auto <strong id="get">get</strong>(U)(inout(U) fallback); </dt> <dd>
<p>Gets the value if not null. If <code>this</code> is in the null state, and the optional parameter <code>fallback</code> was provided, it will be returned. Without <code>fallback</code>, calling <code>get</code> with a null state is invalid. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>inout<span class="template_param_list" title="Template parameter list">(U)</span> <code>fallback</code>
</td> <td>the value to return in case the <code>Nullable</code> is null.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The value held internally by this <code>Nullable</code>.</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="Nullable.2">struct <strong id="Nullable">Nullable</strong>(T, T nullValue); <br><br>auto <strong id="nullable">nullable</strong>(alias nullValue, T)(T t)<br><small>  Constraints: if (is(typeof(nullValue) == T)); </small>
</dt> <dd>
<p>Just like <code>Nullable!T</code>, except that the null state is defined as a particular value. For example, <code>Nullable!(uint, uint.max)</code> is an <code>uint</code> that sets aside the value <code>uint.max</code> to denote a null state. <code>Nullable!(T, nullValue)</code> is more storage-efficient than <code>Nullable!T</code> because it does not need to store an extra <code>bool</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>The wrapped type for which Nullable provides a null value.</td>
</tr> <tr>
<td>nullValue</td> <td>The null value which denotes the null state of this <code>Nullable</code>. Must be of type <code>T</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">Nullable!(size_t, size_t.max) indexOf(string[] haystack, string needle)
{
    //Find the needle, returning -1 if not found

    return Nullable!(size_t, size_t.max).init;
}

void sendLunchInvite(string name)
{
}

//It's safer than C...
auto coworkers = ["Jane", "Jim", "Marry", "Fred"];
auto pos = indexOf(coworkers, "Bob");
if (!pos.isNull)
{
    //Send Bob an invitation to lunch
    sendLunchInvite(coworkers[pos]);
}
else
{
    //Bob not found; report the error
}

//And there's no overhead
static assert(Nullable!(size_t, size_t.max).sizeof == size_t.sizeof);
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.exception : assertThrown;

Nullable!(int, int.min) a;
assert(a.isNull);
assertThrown!Throwable(a.get);
a = 5;
assert(!a.isNull);
writeln(a); // 5
static assert(a.sizeof == int.sizeof);
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto a = nullable!(int.min)(8);
writeln(a); // 8
a.nullify();
assert(a.isNull);
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="Nullable.this.2">this(T value); </dt> <dd>
<p>Constructor initializing <code>this</code> with <code>value</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>value</code>
</td> <td>The value to initialize this <code>Nullable</code> with.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Nullable.isNull.2">const @property bool <strong id="isNull">isNull</strong>(); </dt> <dd>
<p>Check if <code>this</code> is in the null state. </p>
<dl>
<dt>Returns:</dt>
<dd>true <b>iff</b> <code>this</code> is in the null state, otherwise false.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">Nullable!(int, -1) ni;
//Initialized to "null" state
assert(ni.isNull);

ni = 0;
assert(!ni.isNull);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Nullable.nullify.2">void <strong id="nullify">nullify</strong>()(); </dt> <dd>
<p>Forces <code>this</code> to the null state.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">Nullable!(int, -1) ni = 0;
assert(!ni.isNull);

ni = -1;
assert(ni.isNull);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Nullable.opAssign.2">void <strong id="opAssign">opAssign</strong>()(T value); </dt> <dd>
<p>Assigns <code>value</code> to the internally-held state. If the assignment succeeds, <code>this</code> becomes non-null. No null checks are made. Note that the assignment may leave <code>this</code> in the null state. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>value</code>
</td> <td>A value of type <code>T</code> to assign to this <code>Nullable</code>. If it is <code>nullvalue</code>, then the internal state of this <code>Nullable</code> will be set to null.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>If this <code>Nullable</code> wraps a type that already has a null value (such as a pointer), and that null value is not given for <code>nullValue</code>, then assigning the null value to this <code>Nullable</code> is no different than assigning any other value of type <code>T</code>, and the resulting code will look very strange. It is strongly recommended that this be avoided by using <code>T</code>'s "built in" null value for <code>nullValue</code>. <pre data-language="d">//Passes
enum nullVal = cast(int*) 0xCAFEBABE;
Nullable!(int*, nullVal) npi;
assert(npi.isNull);

//Passes?!
npi = null;
assert(!npi.isNull);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Nullable.get.2">inout @property ref inout(T) <strong id="get">get</strong>(); </dt> <dd>
<p>Gets the value. <code>this</code> must not be in the null state. This function is also called for the implicit conversion to <code>T</code>. </p>
<dl>
<dt>Preconditions</dt>
<dd> <code>isNull</code> must be <code>false</code>. </dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The value held internally by this <code>Nullable</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.exception : assertThrown, assertNotThrown;

Nullable!(int, -1) ni;
//`get` is implicitly called. Will throw
//an error in non-release mode
assertThrown!Throwable(ni == 0);

ni = 0;
assertNotThrown!Throwable(ni == 0);
</pre> </dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="apply">template <strong id="apply">apply</strong>(alias fun)</dt> <dd>
<p>Unpacks the content of a <code>Nullable</code>, performs an operation and packs it again. Does nothing if isNull. </p>
<p>When called on a <code>Nullable</code>, <code>apply</code> will unpack the value contained in the <code>Nullable</code>, pass it to the function you provide and wrap the result in another <code>Nullable</code> (if necessary). If the <code>Nullable</code> is null, <code>apply</code> will return null itself. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T t</td> <td>a <code>Nullable</code>
</td>
</tr> <tr>
<td>fun</td> <td>a function operating on the content of the nullable</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>fun(t.get).nullable</code> if <code>!t.isNull</code>, else <code>Nullable.init</code>.  See also: <a href="https://en.wikipedia.org/wiki/Monad_(functional_programming)#The_Maybe_monad">The <code>Maybe</code> monad</a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">alias toFloat = i =&gt; cast(float) i;

Nullable!int sample;

// apply(null) results in a null `Nullable` of the function's return type.
Nullable!float f = sample.apply!toFloat;
assert(sample.isNull &amp;&amp; f.isNull);

sample = 3;

// apply(non-null) calls the function and wraps the result in a `Nullable`.
f = sample.apply!toFloat;
assert(!sample.isNull &amp;&amp; !f.isNull);
writeln(f.get); // 3.0f
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">alias greaterThree = i =&gt; (i &gt; 3) ? i.nullable : Nullable!(typeof(i)).init;

Nullable!int sample;

// when the function already returns a `Nullable`, that `Nullable` is not wrapped.
auto result = sample.apply!greaterThree;
assert(sample.isNull &amp;&amp; result.isNull);

// The function may decide to return a null `Nullable`.
sample = 3;
result = sample.apply!greaterThree;
assert(!sample.isNull &amp;&amp; result.isNull);

// Or it may return a value already wrapped in a `Nullable`.
sample = 4;
result = sample.apply!greaterThree;
assert(!sample.isNull &amp;&amp; !result.isNull);
writeln(result.get); // 4
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="NullableRef">struct <strong id="NullableRef">NullableRef</strong>(T); <br><br>auto <strong id="nullableRef">nullableRef</strong>(T)(T* t); </dt> <dd>
<p>Just like <code>Nullable!T</code>, except that the object refers to a value sitting elsewhere in memory. This makes assignments overwrite the initially assigned value. Internally <code>NullableRef!T</code> only stores a pointer to <code>T</code> (i.e., <code>Nullable!T.sizeof == (T*).sizeof</code>).</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.exception : assertThrown;

int x = 5, y = 7;
auto a = nullableRef(&amp;x);
assert(!a.isNull);
writeln(a); // 5
writeln(x); // 5
a = 42;
writeln(x); // 42
assert(!a.isNull);
writeln(a); // 42
a.nullify();
writeln(x); // 42
assert(a.isNull);
assertThrown!Throwable(a.get);
assertThrown!Throwable(a = 71);
a.bind(&amp;y);
writeln(a); // 7
y = 135;
writeln(a); // 135
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="NullableRef.this">pure nothrow @safe this(T* value); </dt> <dd>
<p>Constructor binding <code>this</code> to <code>value</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T* <code>value</code>
</td> <td>The value to bind to.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="NullableRef.bind">pure nothrow @safe void <strong id="bind">bind</strong>(T* value); </dt> <dd>
<p>Binds the internal state to <code>value</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T* <code>value</code>
</td> <td>A pointer to a value of type <code>T</code> to bind this <code>NullableRef</code> to.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">NullableRef!int nr = new int(42);
writeln(nr); // 42

int* n = new int(1);
nr.bind(n);
writeln(nr); // 1
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="NullableRef.isNull">const pure nothrow @property @safe bool <strong id="isNull">isNull</strong>(); </dt> <dd>
<p>Returns <code>true</code> if and only if <code>this</code> is in the null state. </p>
<dl>
<dt>Returns:</dt>
<dd>true if <code>this</code> is in the null state, otherwise false.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">NullableRef!int nr;
assert(nr.isNull);

int* n = new int(42);
nr.bind(n);
assert(!nr.isNull &amp;&amp; nr == 42);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="NullableRef.nullify">pure nothrow @safe void <strong id="nullify">nullify</strong>(); </dt> <dd>
<p>Forces <code>this</code> to the null state.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">NullableRef!int nr = new int(42);
assert(!nr.isNull);

nr.nullify();
assert(nr.isNull);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="NullableRef.opAssign">void <strong id="opAssign">opAssign</strong>()(T value)<br><small>  Constraints: if (isAssignable!T); </small>
</dt> <dd>
<p>Assigns <code>value</code> to the internally-held state. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>value</code>
</td> <td>A value of type <code>T</code> to assign to this <code>NullableRef</code>. If the internal state of this <code>NullableRef</code> has not been initialized, an error will be thrown in non-release mode.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.exception : assertThrown, assertNotThrown;

NullableRef!int nr;
assert(nr.isNull);
assertThrown!Throwable(nr = 42);

nr.bind(new int(0));
assert(!nr.isNull);
assertNotThrown!Throwable(nr = 42);
writeln(nr); // 42
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="NullableRef.get">inout pure nothrow @property ref @safe inout(T) <strong id="get">get</strong>(); </dt> <dd>
<p>Gets the value. <code>this</code> must not be in the null state. This function is also called for the implicit conversion to <code>T</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.exception : assertThrown, assertNotThrown;

NullableRef!int nr;
//`get` is implicitly called. Will throw
//an error in non-release mode
assertThrown!Throwable(nr == 0);

nr.bind(new int(0));
assertNotThrown!Throwable(nr == 0);
</pre> </dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="BlackHole">template <strong id="BlackHole">BlackHole</strong>(Base)</dt> <dd>
<p><code>BlackHole!Base</code> is a subclass of <code>Base</code> which automatically implements all abstract member functions in <code>Base</code> as do-nothing functions. Each auto-implemented function just returns the default value of the return type without doing anything. </p>
<p>The name came from <a href="http://search.cpan.org/~sburke/Class-BlackHole-0.04/lib/Class/BlackHole.pm">Class::BlackHole</a> Perl module by Sean M. Burke. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Base</td> <td>A non-final class for <code>BlackHole</code> to inherit from.</td>
</tr> </table></dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#AutoImplement"><code>AutoImplement</code></a>, <a href="#generateEmptyFunction"><code>generateEmptyFunction</code></a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.math : isNaN;

static abstract class C
{
    int m_value;
    this(int v) { m_value = v; }
    int value() @property { return m_value; }

    abstract real realValue() @property;
    abstract void doSomething();
}

auto c = new BlackHole!C(42);
writeln(c.value); // 42

// Returns real.init which is NaN
assert(c.realValue.isNaN);
// Abstract functions are implemented as do-nothing
c.doSomething();
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="WhiteHole">template <strong id="WhiteHole">WhiteHole</strong>(Base)</dt> <dd>
<p><code>WhiteHole!Base</code> is a subclass of <code>Base</code> which automatically implements all abstract member functions as functions that always fail. These functions simply throw an <code>Error</code> and never return. <code>Whitehole</code> is useful for trapping the use of class member functions that haven't been implemented. </p>
<p>The name came from <a href="http://search.cpan.org/~mschwern/Class-WhiteHole-0.04/lib/Class/WhiteHole.pm">Class::WhiteHole</a> Perl module by Michael G Schwern. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Base</td> <td>A non-final class for <code>WhiteHole</code> to inherit from.</td>
</tr> </table></dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#AutoImplement"><code>AutoImplement</code></a>, <a href="#generateAssertTrap"><code>generateAssertTrap</code></a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.exception : assertThrown;

static class C
{
    abstract void notYetImplemented();
}

auto c = new WhiteHole!C;
assertThrown!NotImplementedError(c.notYetImplemented()); // throws an Error
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="AutoImplement">class <strong id="AutoImplement">AutoImplement</strong>(Base, alias how, alias what = isAbstractFunction) if (!is(how == class)): Base; <br><br>class <strong id="AutoImplement">AutoImplement</strong>(Interface, BaseClass, alias how, alias what = isAbstractFunction) if (is(Interface == interface) &amp;&amp; is(BaseClass == class)): BaseClass, Interface; </dt> <dd>
<p><code>AutoImplement</code> automatically implements (by default) all abstract member functions in the class or interface <code>Base</code> in specified way. </p>
<p>The second version of <code>AutoImplement</code> automatically implements <code>Interface</code>, while deriving from <code>BaseClass</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>how</td> <td>template which specifies how functions will be implemented/overridden.  Two arguments are passed to <code>how</code>: the type <code>Base</code> and an alias to an implemented function. Then <code>how</code> must return an implemented function body as a string.  The generated function body can use these keywords: <ul> <li>
<code>a0</code>, <code>a1</code>, : arguments passed to the function;</li> <li>
<code>args</code>: a tuple of the arguments;</li> <li>
<code>self</code>: an alias to the function itself;</li> <li>
<code>parent</code>: an alias to the overridden function (if any).</li> </ul>  You may want to use templated property functions (instead of Implicit Template Properties) to generate complex functions: <pre data-language="d">// Prints log messages for each call to overridden functions.
string generateLogger(C, alias fun)() @property
{
    import std.traits;
    enum qname = C.stringof ~ "." ~ __traits(identifier, fun);
    string stmt;

    stmt ~= q{ struct Importer { import std.stdio; } };
    stmt ~= `Importer.writeln("Log: ` ~ qname ~ `(", args, ")");`;
    static if (!__traits(isAbstractFunction, fun))
    {
        static if (is(ReturnType!fun == void))
            stmt ~= q{ parent(args); };
        else
            stmt ~= q{
                auto r = parent(args);
                Importer.writeln("--&gt; ", r);
                return r;
            };
    }
    return stmt;
}
</pre> </td>
</tr> <tr>
<td>what</td> <td>template which determines what functions should be implemented/overridden.  An argument is passed to <code>what</code>: an alias to a non-final member function in <code>Base</code>. Then <code>what</code> must return a boolean value. Return <code>true</code> to indicate that the passed function should be implemented/overridden.  <pre data-language="d">// Sees if fun returns something.
enum bool hasValue(alias fun) = !is(ReturnType!(fun) == void);
</pre> </td>
</tr> </table></dd>
</dl> <dl>
<dt>Note</dt>
<dd> Generated code is inserted in the scope of <code>std.typecons</code> module. Thus, any useful functions outside <code>std.typecons</code> cannot be used in the generated code. To workaround this problem, you may <code>import</code> necessary things in a local struct, as done in the <code>generateLogger()</code> template in the above example. </dd>
</dl>  <dl>
<dt>Bugs:</dt>
<dd><ul> <li>Variadic arguments to constructors are not forwarded to super.</li> <li>Deep interface inheritance causes compile error with messages like "Error: function std.typecons.AutoImplement!(Foo).AutoImplement.bar does not override any function". [<span class="bugzilla"><a class="https" href="https://issues.dlang.org/show_bug.cgi?id=2525">Bugzilla 2525</a></span>] </li> <li>The <code>parent</code> keyword is actually a delegate to the super class' corresponding member function. [<span class="bugzilla"><a class="https" href="https://issues.dlang.org/show_bug.cgi?id=2540">Bugzilla 2540</a></span>] </li> <li>Using alias template parameter in <code>how</code> and/or <code>what</code> may cause strange compile error. Use template tuple parameter instead to workaround this problem. [<span class="bugzilla"><a class="https" href="https://issues.dlang.org/show_bug.cgi?id=4217">Bugzilla 4217</a></span>] </li> </ul></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">interface PackageSupplier
{
    int foo();
    int bar();
}

static abstract class AbstractFallbackPackageSupplier : PackageSupplier
{
    protected PackageSupplier default_, fallback;

    this(PackageSupplier default_, PackageSupplier fallback)
    {
        this.default_ = default_;
        this.fallback = fallback;
    }

    abstract int foo();
    abstract int bar();
}

template fallback(T, alias func)
{
    import std.format : format;
    // for all implemented methods:
    // - try default first
    // - only on a failure run &amp; return fallback
    enum fallback = q{
        scope (failure) return fallback.%1&amp;dollar;s(args);
        return default_.%1&amp;dollar;s(args);
    }.format(__traits(identifier, func));
}

// combines two classes and use the second one as fallback
alias FallbackPackageSupplier = AutoImplement!(AbstractFallbackPackageSupplier, fallback);

class FailingPackageSupplier : PackageSupplier
{
    int foo(){ throw new Exception("failure"); }
    int bar(){ return 2;}
}

class BackupPackageSupplier : PackageSupplier
{
    int foo(){ return -1; }
    int bar(){ return -1;}
}

auto registry = new FallbackPackageSupplier(new FailingPackageSupplier(), new BackupPackageSupplier());

writeln(registry.foo()); // -1
writeln(registry.bar()); // 2
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="generateEmptyFunction">template <strong id="generateEmptyFunction">generateEmptyFunction</strong>(C, func...)<br><br>enum string <strong id="generateAssertTrap">generateAssertTrap</strong>(C, func...); </dt> <dd>
<p>Predefined how-policies for <code>AutoImplement</code>. These templates are also used by <code>BlackHole</code> and <code>WhiteHole</code>, respectively.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">alias BlackHole(Base) = AutoImplement!(Base, generateEmptyFunction);

interface I
{
    int foo();
    string bar();
}

auto i = new BlackHole!I();
// generateEmptyFunction returns the default value of the return type without doing anything
writeln(i.foo); // 0
assert(i.bar is null);
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.exception : assertThrown;

alias WhiteHole(Base) = AutoImplement!(Base, generateAssertTrap);

interface I
{
    int foo();
    string bar();
}

auto i = new WhiteHole!I();
// generateAssertTrap throws an exception for every unimplemented function of the interface
assertThrown!NotImplementedError(i.foo);
assertThrown!NotImplementedError(i.bar);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="wrap">template <strong id="wrap">wrap</strong>(Targets...) if (Targets.length &gt;= 1 &amp;&amp; allSatisfy!(isMutable, Targets))<br><br>template <strong id="wrap">wrap</strong>(Targets...) if (Targets.length &gt;= 1 &amp;&amp; !allSatisfy!(isMutable, Targets))<br><br>template <strong id="unwrap">unwrap</strong>(Target) if (isMutable!Target)<br><br>template <strong id="unwrap">unwrap</strong>(Target) if (!isMutable!Target)</dt> <dd>
<p>Supports structural based typesafe conversion. </p>
<p>If <code>Source</code> has structural conformance with the <code>interface</code> <code>Targets</code>, wrap creates an internal wrapper class which inherits <code>Targets</code> and wraps the <code>src</code> object, then returns it. <br><br> <code>unwrap</code> can be used to extract objects which have been wrapped by <code>wrap</code>.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">interface Quack
{
    int quack();
    @property int height();
}
interface Flyer
{
    @property int height();
}
class Duck : Quack
{
    int quack() { return 1; }
    @property int height() { return 10; }
}
class Human
{
    int quack() { return 2; }
    @property int height() { return 20; }
}

Duck d1 = new Duck();
Human h1 = new Human();

interface Refleshable
{
    int reflesh();
}

// does not have structural conformance
static assert(!__traits(compiles, d1.wrap!Refleshable));
static assert(!__traits(compiles, h1.wrap!Refleshable));

// strict upcast
Quack qd = d1.wrap!Quack;
assert(qd is d1);
assert(qd.quack() == 1);    // calls Duck.quack
// strict downcast
Duck d2 = qd.unwrap!Duck;
assert(d2 is d1);

// structural upcast
Quack qh = h1.wrap!Quack;
assert(qh.quack() == 2);    // calls Human.quack
// structural downcast
Human h2 = qh.unwrap!Human;
assert(h2 is h1);

// structural upcast (two steps)
Quack qx = h1.wrap!Quack;   // Human -&gt; Quack
Flyer fx = qx.wrap!Flyer;   // Quack -&gt; Flyer
assert(fx.height == 20);    // calls Human.height
// structural downcast (two steps)
Quack qy = fx.unwrap!Quack; // Flyer -&gt; Quack
Human hy = qy.unwrap!Human; // Quack -&gt; Human
assert(hy is h1);
// structural downcast (one step)
Human hz = fx.unwrap!Human; // Flyer -&gt; Human
assert(hz is h1);
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.traits : FunctionAttribute, functionAttributes;
interface A { int run(); }
interface B { int stop(); @property int status(); }
class X
{
    int run() { return 1; }
    int stop() { return 2; }
    @property int status() { return 3; }
}

auto x = new X();
auto ab = x.wrap!(A, B);
A a = ab;
B b = ab;
writeln(a.run()); // 1
writeln(b.stop()); // 2
writeln(b.status); // 3
static assert(functionAttributes!(typeof(ab).status) &amp; FunctionAttribute.property);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="RefCountedAutoInitialize">enum <strong id="RefCountedAutoInitialize">RefCountedAutoInitialize</strong>: int; </dt> <dd>
<p>Options regarding auto-initialization of a <code>RefCounted</code> object (see the definition of <code>RefCounted</code> below).</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import core.exception : AssertError;
import std.exception : assertThrown;

struct Foo
{
    int a = 42;
}

RefCounted!(Foo, RefCountedAutoInitialize.yes) rcAuto;
RefCounted!(Foo, RefCountedAutoInitialize.no) rcNoAuto;

writeln(rcAuto.refCountedPayload.a); // 42

assertThrown!AssertError(rcNoAuto.refCountedPayload);
rcNoAuto.refCountedStore.ensureInitialized;
writeln(rcNoAuto.refCountedPayload.a); // 42
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="RefCountedAutoInitialize.no"><strong id="no">no</strong></dt> <dd>
<p>Do not auto-initialize the object</p> </dd> <dt class="d_decl" id="RefCountedAutoInitialize.yes"><strong id="yes">yes</strong></dt> <dd>
<p>Auto-initialize the object</p> </dd> </dl> </dd> <dt class="d_decl" id="RefCounted">struct <strong id="RefCounted">RefCounted</strong>(T, RefCountedAutoInitialize autoInit = RefCountedAutoInitialize.yes) if (!is(T == class) &amp;&amp; !is(T == interface)); </dt> <dd>
<p>Defines a reference-counted object containing a <code>T</code> value as payload. </p>
<p>An instance of <code>RefCounted</code> is a reference to a structure, which is referred to as the <i>store</i>, or <i>storage implementation struct</i> in this documentation. The store contains a reference count and the <code>T</code> payload. <code>RefCounted</code> uses <code>malloc</code> to allocate the store. As instances of <code>RefCounted</code> are copied or go out of scope, they will automatically increment or decrement the reference count. When the reference count goes down to zero, <code>RefCounted</code> will call <code>destroy</code> against the payload and call <code>free</code> to deallocate the store. If the <code>T</code> payload contains any references to GC-allocated memory, then <code>RefCounted</code> will add it to the GC memory that is scanned for pointers, and remove it from GC scanning before <code>free</code> is called on the store. <br><br> One important consequence of <code>destroy</code> is that it will call the destructor of the <code>T</code> payload. GC-managed references are not guaranteed to be valid during a destructor call, but other members of <code>T</code>, such as file handles or pointers to <code>malloc</code> memory, will still be valid during the destructor call. This allows the <code>T</code> to deallocate or clean up any non-GC resources immediately after the reference count has reached zero. <br><br> <code>RefCounted</code> is unsafe and should be used with care. No references to the payload should be escaped outside the <code>RefCounted</code> object. <br><br> The <code>autoInit</code> option makes the object ensure the store is automatically initialized. Leaving <code>autoInit == RefCountedAutoInitialize.yes</code> (the default option) is convenient but has the cost of a test whenever the payload is accessed. If <code>autoInit == RefCountedAutoInitialize.no</code>, user code must call either <code>refCountedStore.isInitialized</code> or <code>refCountedStore.ensureInitialized</code> before attempting to access the payload. Not doing so results in null pointer dereference.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">// A pair of an `int` and a `size_t` - the latter being the
// reference count - will be dynamically allocated
auto rc1 = RefCounted!int(5);
writeln(rc1); // 5
// No more allocation, add just one extra reference count
auto rc2 = rc1;
// Reference semantics
rc2 = 42;
writeln(rc1); // 42
// the pair will be freed when rc1 and rc2 go out of scope
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="RefCounted.RefCountedStore">struct <strong id="RefCountedStore">RefCountedStore</strong>; </dt> <dd>
<p><code>RefCounted</code> storage implementation.</p> <dl>
<dt class="d_decl" id="RefCounted.RefCountedStore.isInitialized">const pure nothrow @nogc @property @safe bool <strong id="isInitialized">isInitialized</strong>(); </dt> <dd>
<p>Returns <code>true</code> if and only if the underlying store has been allocated and initialized.</p> </dd> <dt class="d_decl" id="RefCounted.RefCountedStore.refCount">const pure nothrow @nogc @property @safe size_t <strong id="refCount">refCount</strong>(); </dt> <dd>
<p>Returns underlying reference count if it is allocated and initialized (a positive integer), and <code>0</code> otherwise.</p> </dd> <dt class="d_decl" id="RefCounted.RefCountedStore.ensureInitialized">void <strong id="ensureInitialized">ensureInitialized</strong>(); </dt> <dd>
<p>Makes sure the payload was properly initialized. Such a call is typically inserted before using the payload.</p> </dd> </dl> </dd> <dt class="d_decl" id="RefCounted.refCountedStore">inout nothrow @property ref @safe inout(RefCountedStore) <strong id="refCountedStore">refCountedStore</strong>(); </dt> <dd>
<p>Returns storage implementation struct.</p> </dd> <dt class="d_decl" id="RefCounted.this">this(A...)(auto ref A args)<br><small>  Constraints: if (A.length &gt; 0); </small><br><br>this(T val); </dt> <dd>
<p>Constructor that initializes the payload. </p>
<dl>
<dt>Postcondition</dt>
<dd> <code>refCountedStore.isInitialized</code>
</dd>
</dl> </dd> <dt class="d_decl" id="RefCounted.opAssign">void <strong id="opAssign">opAssign</strong>(typeof(this) rhs); <br><br>void <strong id="opAssign">opAssign</strong>(T rhs); </dt> <dd>
<p>Assignment operators</p> </dd> <dt class="d_decl" id="RefCounted.refCountedPayload">@property ref @trusted T <strong id="refCountedPayload">refCountedPayload</strong>() return; <br><br>inout pure nothrow @nogc @property ref @safe inout(T) <strong id="refCountedPayload">refCountedPayload</strong>() return; </dt> <dd>
<p>Returns a reference to the payload. If (autoInit == RefCountedAutoInitialize.yes), calls <code> refCountedStore.ensureInitialized</code>. Otherwise, just issues <code> assert(refCountedStore.isInitialized)</code>. Used with <code>alias refCountedPayload this;</code>, so callers can just use the <code>RefCounted</code> object as a <code>T</code>. </p>
<p><span class="blue">The first overload exists only if <code>autoInit == RefCountedAutoInitialize.yes</code>.</span> So if <code>autoInit == RefCountedAutoInitialize.no</code> or called for a constant or immutable object, then <code>refCountedPayload</code> will also be qualified as safe and nothrow (but will still assert if not initialized).</p> </dd> </dl> </dd> <dt class="d_decl" id="refCounted">RefCounted!(T, RefCountedAutoInitialize.no) <strong id="refCounted">refCounted</strong>(T)(T val); </dt> <dd>
<p>Initializes a <code>RefCounted</code> with <code>val</code>. The template parameter <code>T</code> of <code>RefCounted</code> is inferred from <code>val</code>. This function can be used to move non-copyable values to the heap. It also disables the <code>autoInit</code> option of <code>RefCounted</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>val</code>
</td> <td>The value to be reference counted</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>An initialized <code>RefCounted</code> containing <code>val</code>. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared">C++'s make_shared</a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static struct File
{
    string name;
    @disable this(this); // not copyable
    ~this() { name = null; }
}

auto file = File("name");
writeln(file.name); // "name"
// file cannot be copied and has unique ownership
static assert(!__traits(compiles, {auto file2 = file;}));

// make the file refcounted to share ownership
import std.algorithm.mutation : move;
auto rcFile = refCounted(move(file));
writeln(rcFile.name); // "name"
writeln(file.name); // null
auto rcFile2 = rcFile;
writeln(rcFile.refCountedStore.refCount); // 2
// file gets properly closed when last reference is dropped
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Proxy">template <strong id="Proxy">Proxy</strong>(alias a)</dt> <dd>
<p>Creates a proxy for the value <code>a</code> that will forward all operations while disabling implicit conversions. The aliased item <code>a</code> must be an <b>lvalue</b>. This is useful for creating a new type from the "base" type (though this is <b>not</b> a subtype-supertype relationship; the new type is not related to the old type in any way, by design). </p>
<p>The new type supports all operations that the underlying type does, including all operators such as <code>+</code>, <code>--</code>, <code>&lt;</code>, <code>[]</code>, etc. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>a</td> <td>The value to act as a proxy for all operations. It must be an lvalue.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">struct MyInt
{
    private int value;
    mixin Proxy!value;

    this(int n){ value = n; }
}

MyInt n = 10;

// Enable operations that original type has.
++n;
writeln(n); // 11
writeln(n * 2); // 22

void func(int n) { }

// Disable implicit conversions to original type.
//int x = n;
//func(n);
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>The proxied value must be an <b>lvalue</b>. <pre data-language="d">struct NewIntType
{
    //Won't work; the literal '1'
    //is an rvalue, not an lvalue
    //mixin Proxy!1;

    //Okay, n is an lvalue
    int n;
    mixin Proxy!n;

    this(int n) { this.n = n; }
}

NewIntType nit = 0;
nit++;
writeln(nit); // 1


struct NewObjectType
{
    Object obj;
    //Ok, obj is an lvalue
    mixin Proxy!obj;

    this (Object o) { obj = o; }
}

NewObjectType not = new Object();
assert(__traits(compiles, not.toHash()));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>There is one exception to the fact that the new type is not related to the old type. <a href="https://dlang.org/spec/function.html#pseudo-member">Pseudo-member</a> functions are usable with the new type; they will be forwarded on to the proxied value. <pre data-language="d">import std.math;

float f = 1.0;
assert(!f.isInfinity);

struct NewFloat
{
    float _;
    mixin Proxy!_;

    this(float f) { _ = f; }
}

NewFloat nf = 1.0f;
assert(!nf.isInfinity);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Typedef">struct <strong id="Typedef">Typedef</strong>(T, T init = T.init, string cookie = null); </dt> <dd>
<p><b>Typedef</b> allows the creation of a unique type which is based on an existing type. Unlike the <code>alias</code> feature, <b>Typedef</b> ensures the two types are not considered as equals. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>init</td> <td>Optional initial value for the new type.</td>
</tr> <tr>
<td>cookie</td> <td>Optional, used to create multiple unique types which are based on the same origin type <code>T</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Note</dt>
<dd> If a library routine cannot handle the Typedef type, you can use the <code>TypedefType</code> template to extract the type which the Typedef wraps.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">alias MyInt = Typedef!int;
MyInt foo = 10;
foo++;
writeln(foo); // 11
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>custom initialization values <pre data-language="d">alias MyIntInit = Typedef!(int, 42);
static assert(is(TypedefType!MyIntInit == int));
static assert(MyIntInit() == 42);
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Typedef creates a new type <pre data-language="d">alias MyInt = Typedef!int;
static void takeInt(int) {}
static void takeMyInt(MyInt) {}

int i;
takeInt(i);    // ok
static assert(!__traits(compiles, takeMyInt(i)));

MyInt myInt;
static assert(!__traits(compiles, takeInt(myInt)));
takeMyInt(myInt);  // ok
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Use the optional <code>cookie</code> argument to create different types of the same base type <pre data-language="d">alias TypeInt1 = Typedef!int;
alias TypeInt2 = Typedef!int;

// The two Typedefs are the same type.
static assert(is(TypeInt1 == TypeInt2));

alias MoneyEuros = Typedef!(float, float.init, "euros");
alias MoneyDollars = Typedef!(float, float.init, "dollars");

// The two Typedefs are _not_ the same type.
static assert(!is(MoneyEuros == MoneyDollars));
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="Typedef.toString">string <strong id="toString">toString</strong>(this T)(); <br><br>void <strong id="toString">toString</strong>(this T, W)(ref W writer, ref scope const FormatSpec!char fmt)<br><small>  Constraints: if (isOutputRange!(W, char)); </small>
</dt> <dd>
<p>Convert wrapped value to a human readable string</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.conv : to;

int i = 123;
auto td = Typedef!int(i);
writeln(i.to!string); // td.to!string
</pre> </dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="TypedefType">template <strong id="TypedefType">TypedefType</strong>(T)</dt> <dd>
<p>Get the underlying type which a <code>Typedef</code> wraps. If <code>T</code> is not a <code>Typedef</code> it will alias itself to <code>T</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.conv : to;

alias MyInt = Typedef!int;
static assert(is(TypedefType!MyInt == int));

/// Instantiating with a non-Typedef will return that type
static assert(is(TypedefType!int == int));

string num = "5";

// extract the needed type
MyInt myInt = MyInt( num.to!(TypedefType!MyInt) );
writeln(myInt); // 5

// cast to the underlying type to get the value that's being wrapped
int x = cast(TypedefType!MyInt) myInt;

alias MyIntInit = Typedef!(int, 42);
static assert(is(TypedefType!MyIntInit == int));
static assert(MyIntInit() == 42);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="scoped">template <strong id="scoped">scoped</strong>(T) if (is(T == class))</dt> <dd>
<p>Allocates a <code>class</code> object right inside the current scope, therefore avoiding the overhead of <code>new</code>. This facility is unsafe; it is the responsibility of the user to not escape a reference to the object outside the scope. </p>
<p>The class destructor will be called when the result of <code>scoped()</code> is itself destroyed. <br><br> Scoped class instances can be embedded in a parent <code>class</code> or <code>struct</code>, just like a child struct instance. Scoped member variables must have type <code>typeof(scoped!Class(args))</code>, and be initialized with a call to scoped. See below for an example. </p> <dl>
<dt>Note</dt>
<dd> It's illegal to move a class instance even if you are sure there are no pointers to it. As such, it is illegal to move a scoped object.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">class A
{
    int x;
    this()     {x = 0;}
    this(int i){x = i;}
    ~this()    {}
}

// Standard usage, constructing A on the stack
auto a1 = scoped!A();
a1.x = 42;

// Result of `scoped` call implicitly converts to a class reference
A aRef = a1;
writeln(aRef.x); // 42

// Scoped destruction
{
    auto a2 = scoped!A(1);
    writeln(a2.x); // 1
    aRef = a2;
    // a2 is destroyed here, calling A's destructor
}
// aRef is now an invalid reference

// Here the temporary scoped A is immediately destroyed.
// This means the reference is then invalid.
version (Bug)
{
    // Wrong, should use `auto`
    A invalid = scoped!A();
}

// Restrictions
version (Bug)
{
    import std.algorithm.mutation : move;
    auto invalid = a1.move; // illegal, scoped objects can't be moved
}
static assert(!is(typeof({
    auto e1 = a1; // illegal, scoped objects can't be copied
    assert([a1][0].x == 42); // ditto
})));
static assert(!is(typeof({
    alias ScopedObject = typeof(a1);
    auto e2 = ScopedObject();  // illegal, must be built via scoped!A
    auto e3 = ScopedObject(1); // ditto
})));

// Use with alias
alias makeScopedA = scoped!A;
auto a3 = makeScopedA();
auto a4 = makeScopedA(1);

// Use as member variable
struct B
{
    typeof(scoped!A()) a; // note the trailing parentheses

    this(int i)
    {
        // construct member
        a = scoped!A(i);
    }
}

// Stack-allocate
auto b1 = B(5);
aRef = b1.a;
writeln(aRef.x); // 5
destroy(b1); // calls A's destructor for b1.a
// aRef is now an invalid reference

// Heap-allocate
auto b2 = new B(6);
writeln(b2.a.x); // 6
destroy(*b2); // calls A's destructor for b2.a
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="scoped.scoped">@system auto <strong id="scoped">scoped</strong>(Args...)(auto ref Args args); </dt> <dd>
<p>Returns the scoped object. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Args <code>args</code>
</td> <td>Arguments to pass to <code>T</code>'s constructor.</td>
</tr> </table></dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="Flag">template <strong id="Flag">Flag</strong>(string name)</dt> <dd>
<p>Defines a simple, self-documenting yes/no flag. This makes it easy for APIs to define functions accepting flags without resorting to <code>bool</code>, which is opaque in calls, and without needing to define an enumerated type separately. Using <code>Flag!"Name"</code> instead of <code>bool</code> makes the flag's meaning visible in calls. Each yes/no flag has its own type, which makes confusions and mix-ups impossible. </p>
<dl>
<dt>Example</dt>
<dd> Code calling <code>getLine</code> (usually far away from its definition) can't be understood without looking at the documentation, even by users familiar with the API: </dd>
</dl>
<pre data-language="d">string getLine(bool keepTerminator)
{
    ...
    if (keepTerminator) ...
    ...
}
...
auto line = getLine(false);
</pre>  Assuming the reverse meaning (i.e. "ignoreTerminator") and inserting the wrong code compiles and runs with erroneous results.  After replacing the boolean parameter with an instantiation of <code>Flag</code>, code calling <code>getLine</code> can be easily read and understood even by people not fluent with the API:  <pre data-language="d">string getLine(Flag!"keepTerminator" keepTerminator)
{
    ...
    if (keepTerminator) ...
    ...
}
...
auto line = getLine(Yes.keepTerminator);
</pre>  The structs <code>Yes</code> and <code>No</code> are provided as shorthand for <code>Flag!"Name".yes</code> and <code>Flag!"Name".no</code> and are preferred for brevity and readability. These convenience structs mean it is usually unnecessary and counterproductive to create an alias of a <code>Flag</code> as a way of avoiding typing out the full type while specifying the affirmative or negative options.  Passing categorical data by means of unstructured <code>bool</code> parameters is classified under "simple-data coupling" by Steve McConnell in the <a href="https://google.com/search?btnI=I%27m+Feeling+Lucky&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=Code%20Complete">Code Complete</a> book, along with three other kinds of coupling. The author argues citing several studies that coupling has a negative effect on code quality. <code>Flag</code> offers a simple structuring method for passing yes/no flags to APIs. <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">Flag!"abc" flag;

writeln(flag); // Flag!"abc".no
writeln(flag); // No.abc
assert(!flag);
if (flag) assert(0);
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto flag = Yes.abc;

assert(flag);
writeln(flag); // Yes.abc
if (!flag) assert(0);
if (flag) {} else assert(0);
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="Flag.Flag">enum <strong id="Flag">Flag</strong>: bool; </dt> <dd> <dl>
<dt class="d_decl" id="Flag.Flag.no"><strong id="no">no</strong></dt> <dd>
<p>When creating a value of type <code>Flag!"Name"</code>, use <code> Flag!"Name".no</code> for the negative option. When using a value of type <code>Flag!"Name"</code>, compare it against <code> Flag!"Name".no</code> or just <code>false</code> or <code>0</code>.</p> </dd> <dt class="d_decl" id="Flag.Flag.yes"><strong id="yes">yes</strong></dt> <dd>
<p>When creating a value of type <code>Flag!"Name"</code>, use <code> Flag!"Name".yes</code> for the affirmative option. When using a value of type <code>Flag!"Name"</code>, compare it against <code> Flag!"Name".yes</code>.</p> </dd> </dl> </dd> </dl> </dd> <dt class="d_decl" id="Yes">struct <strong id="Yes">Yes</strong>; <br><br>struct <strong id="No">No</strong>; </dt> <dd>
<p>Convenience names that allow using e.g. <code>Yes.encryption</code> instead of <code>Flag!"encryption".yes</code> and <code>No.encryption</code> instead of <code>Flag!"encryption".no</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">Flag!"abc" flag;

writeln(flag); // Flag!"abc".no
writeln(flag); // No.abc
assert(!flag);
if (flag) assert(0);
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto flag = Yes.abc;

assert(flag);
writeln(flag); // Yes.abc
if (!flag) assert(0);
if (flag) {} else assert(0);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isBitFlagEnum">template <strong id="isBitFlagEnum">isBitFlagEnum</strong>(E)</dt> <dd>
<p>Detect whether an enum is of integral type and has only "flag" values (i.e. values with a bit count of exactly 1). Additionally, a zero value is allowed for compatibility with enums including a "None" value.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">enum A
{
    None,
    A = 1 &lt;&lt; 0,
    B = 1 &lt;&lt; 1,
    C = 1 &lt;&lt; 2,
    D = 1 &lt;&lt; 3,
}

static assert(isBitFlagEnum!A);
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Test an enum with default (consecutive) values <pre data-language="d">enum B
{
    A,
    B,
    C,
    D // D == 3
}

static assert(!isBitFlagEnum!B);
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Test an enum with non-integral values <pre data-language="d">enum C: double
{
    A = 1 &lt;&lt; 0,
    B = 1 &lt;&lt; 1
}

static assert(!isBitFlagEnum!C);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="BitFlags">struct <strong id="BitFlags">BitFlags</strong>(E, Flag!"unsafe" unsafe = No.unsafe) if (unsafe || isBitFlagEnum!E); </dt> <dd>
<p>A typesafe structure for storing combinations of enum values. </p>
<p>This template defines a simple struct to represent bitwise OR combinations of enum values. It can be used if all the enum values are integral constants with a bit count of at most 1, or if the <code>unsafe</code> parameter is explicitly set to Yes. This is much safer than using the enum itself to store the OR combination, which can produce surprising effects like this: </p>
<pre data-language="d">enum E
{
    A = 1 &lt;&lt; 0,
    B = 1 &lt;&lt; 1
}
E e = E.A | E.B;
// will throw SwitchError
final switch (e)
{
    case E.A:
        return;
    case E.B:
        return;
}
</pre>  <dl>
<dt>Examples:</dt>
<dd>Set values with the | operator and test with &amp; <pre data-language="d">enum Enum
{
    A = 1 &lt;&lt; 0,
}

// A default constructed BitFlags has no value set
immutable BitFlags!Enum flags_empty;
assert(!flags_empty.A);

// Value can be set with the | operator
immutable flags_A = flags_empty | Enum.A;

// and tested using property access
assert(flags_A.A);

// or the &amp; operator
assert(flags_A &amp; Enum.A);
// which commutes.
assert(Enum.A &amp; flags_A);
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>A default constructed BitFlags has no value set <pre data-language="d">enum Enum
{
    None,
    A = 1 &lt;&lt; 0,
    B = 1 &lt;&lt; 1,
    C = 1 &lt;&lt; 2
}

immutable BitFlags!Enum flags_empty;
assert(!(flags_empty &amp; (Enum.A | Enum.B | Enum.C)));
assert(!(flags_empty &amp; Enum.A) &amp;&amp; !(flags_empty &amp; Enum.B) &amp;&amp; !(flags_empty &amp; Enum.C));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Binary operations: subtracting and intersecting flags <pre data-language="d">enum Enum
{
    A = 1 &lt;&lt; 0,
    B = 1 &lt;&lt; 1,
    C = 1 &lt;&lt; 2,
}
immutable BitFlags!Enum flags_AB = BitFlags!Enum(Enum.A, Enum.B);
immutable BitFlags!Enum flags_BC = BitFlags!Enum(Enum.B, Enum.C);

// Use the ~ operator for subtracting flags
immutable BitFlags!Enum flags_B = flags_AB &amp; ~BitFlags!Enum(Enum.A);
assert(!flags_B.A &amp;&amp; flags_B.B &amp;&amp; !flags_B.C);

// use &amp; between BitFlags for intersection
writeln(flags_B); // (flags_BC &amp; flags_AB)
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>All the binary operators work in their assignment version <pre data-language="d">enum Enum
{
    A = 1 &lt;&lt; 0,
    B = 1 &lt;&lt; 1,
}

BitFlags!Enum flags_empty, temp, flags_AB;
flags_AB = Enum.A | Enum.B;

temp |= flags_AB;
writeln(temp); // (flags_empty | flags_AB)

temp = flags_empty;
temp |= Enum.B;
writeln(temp); // (flags_empty | Enum.B)

temp = flags_empty;
temp &amp;= flags_AB;
writeln(temp); // (flags_empty &amp; flags_AB)

temp = flags_empty;
temp &amp;= Enum.A;
writeln(temp); // (flags_empty &amp; Enum.A)
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Conversion to bool and int <pre data-language="d">enum Enum
{
    A = 1 &lt;&lt; 0,
    B = 1 &lt;&lt; 1,
}

BitFlags!Enum flags;

// BitFlags with no value set evaluate to false
assert(!flags);

// BitFlags with at least one value set evaluate to true
flags |= Enum.A;
assert(flags);

// This can be useful to check intersection between BitFlags
BitFlags!Enum flags_AB = Enum.A | Enum.B;
assert(flags &amp; flags_AB);
assert(flags &amp; Enum.A);

// You can of course get you raw value out of flags
auto value = cast(int) flags;
writeln(value); // Enum.A
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>You need to specify the <code>unsafe</code> parameter for enums with custom values <pre data-language="d">enum UnsafeEnum
{
    A = 1,
    B = 2,
    C = 4,
    BC = B|C
}
static assert(!__traits(compiles, { BitFlags!UnsafeEnum flags; }));
BitFlags!(UnsafeEnum, Yes.unsafe) flags;

// property access tests for exact match of unsafe enums
flags.B = true;
assert(!flags.BC); // only B
flags.C = true;
assert(flags.BC); // both B and C
flags.B = false;
assert(!flags.BC); // only C

// property access sets all bits of unsafe enum group
flags = flags.init;
flags.BC = true;
assert(!flags.A &amp;&amp; flags.B &amp;&amp; flags.C);
flags.A = true;
flags.BC = false;
assert(flags.A &amp;&amp; !flags.B &amp;&amp; !flags.C);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="ReplaceType">template <strong id="ReplaceType">ReplaceType</strong>(From, To, T...)</dt> <dd>
<p>Replaces all occurrences of <code>From</code> into <code>To</code>, in one or more types <code>T</code>. For example, <code>ReplaceType!(int, uint, Tuple!(int, float)[string])</code> yields <code>Tuple!(uint, float)[string]</code>. The types in which replacement is performed may be arbitrarily complex, including qualifiers, built-in type constructors (pointers, arrays, associative arrays, functions, and delegates), and template instantiations; replacement proceeds transitively through the type definition. However, member types in <code>struct</code>s or <code>class</code>es are not replaced because there are no ways to express the types resulting after replacement. </p>
<p>This is an advanced type manipulation necessary e.g. for replacing the placeholder type <code>This</code> in <a href="std_variant#Algebraic"><code>std.variant.Algebraic</code></a>. </p> <dl>
<dt>Returns:</dt>
<dd>
<code>ReplaceType</code> aliases itself to the type(s) that result after replacement.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(
    is(ReplaceType!(int, string, int[]) == string[]) &amp;&amp;
    is(ReplaceType!(int, string, int[int]) == string[string]) &amp;&amp;
    is(ReplaceType!(int, string, const(int)[]) == const(string)[]) &amp;&amp;
    is(ReplaceType!(int, string, Tuple!(int[], float))
        == Tuple!(string[], float))
);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="ReplaceTypeUnless">template <strong id="ReplaceTypeUnless">ReplaceTypeUnless</strong>(alias pred, From, To, T...)</dt> <dd>
<p>Like <a href="#ReplaceType"><code>ReplaceType</code></a>, but does not perform replacement in types for which <code>pred</code> evaluates to <code>true</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.traits : isArray;

static assert(
    is(ReplaceTypeUnless!(isArray, int, string, int*) == string*) &amp;&amp;
    is(ReplaceTypeUnless!(isArray, int, string, int[]) == int[]) &amp;&amp;
    is(ReplaceTypeUnless!(isArray, int, string, Tuple!(int, int[]))
        == Tuple!(string, int[]))
);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Ternary">struct <strong id="Ternary">Ternary</strong>; </dt> <dd>
<p>Ternary type with three truth values: </p>
<p></p>
<ul> <li>
<code>Ternary.yes</code> for <code>true</code>
</li> <li>
<code>Ternary.no</code> for <code>false</code>
</li> <li>
<code>Ternary.unknown</code> as an unknown state</li> </ul> <br><br> Also known as trinary, trivalent, or trilean.  <dl>
<dt>See Also:</dt>
<dd><a href="http://en.wikipedia.org/wiki/Three-valued_logic"> Three Valued Logic on Wikipedia</a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">Ternary a;
writeln(a); // Ternary.unknown

writeln(~Ternary.yes); // Ternary.no
writeln(~Ternary.no); // Ternary.yes
writeln(~Ternary.unknown); // Ternary.unknown
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="Ternary.no">enum Ternary <strong id="no">no</strong>; <br><br>enum Ternary <strong id="yes">yes</strong>; <br><br>enum Ternary <strong id="unknown">unknown</strong>; </dt> <dd>
<p>The possible states of the <code>Ternary</code></p> </dd> <dt class="d_decl" id="Ternary.this">pure nothrow @nogc @safe this(bool b); <br><br>pure nothrow @nogc @safe void <strong id="opAssign">opAssign</strong>(bool b); </dt> <dd>
<p>Construct and assign from a <code>bool</code>, receiving <code>no</code> for <code>false</code> and <code>yes</code> for <code>true</code>.</p> </dd> <dt class="d_decl" id="Ternary.this.2">pure nothrow @nogc @safe this(const Ternary b); </dt> <dd>
<p>Construct a ternary value from another ternary value</p> </dd> <dt class="d_decl" id="Ternary.opUnary">Ternary <strong id="opUnary">opUnary</strong>(string s)()<br><small>  Constraints: if (s == "~"); </small><br><br>Ternary <strong id="opBinary">opBinary</strong>(string s)(Ternary rhs)<br><small>  Constraints: if (s == "|"); </small><br><br>Ternary <strong id="opBinary">opBinary</strong>(string s)(Ternary rhs)<br><small>  Constraints: if (s == "&amp;"); </small><br><br>Ternary <strong id="opBinary">opBinary</strong>(string s)(Ternary rhs)<br><small>  Constraints: if (s == "^"); </small><br><br>Ternary <strong id="opBinary">opBinary</strong>(string s)(bool rhs)<br><small>  Constraints: if (s == "|" || s == "&amp;" || s == "^"); </small>
</dt> <dd>
<p></p>
<table>
<caption>Truth table for logical operations</caption> <tr>
<th scope="col"><code>a</code></th> <th scope="col"><code>b</code></th> <th scope="col"><code>a</code></th> <th scope="col"><code>a | b</code></th> <th scope="col"><code>a &amp; b</code></th> <th scope="col"><code>a ^ b</code></th>
</tr> <tr>
<td><code>no</code></td> <td><code>no</code></td> <td><code>yes</code></td> <td><code>no</code></td> <td><code>no</code></td> <td><code>no</code></td>
</tr> <tr>
<td><code>no</code></td> <td><code>yes</code></td> <td></td> <td><code>yes</code></td> <td><code>no</code></td> <td><code>yes</code></td>
</tr> <tr>
<td><code>no</code></td> <td><code>unknown</code></td> <td></td> <td><code>unknown</code></td> <td><code>no</code></td> <td><code>unknown</code></td>
</tr> <tr>
<td><code>yes</code></td> <td><code>no</code></td> <td><code>no</code></td> <td><code>yes</code></td> <td><code>no</code></td> <td><code>yes</code></td>
</tr> <tr>
<td><code>yes</code></td> <td><code>yes</code></td> <td></td> <td><code>yes</code></td> <td><code>yes</code></td> <td><code>no</code></td>
</tr> <tr>
<td><code>yes</code></td> <td><code>unknown</code></td> <td></td> <td><code>yes</code></td> <td><code>unknown</code></td> <td><code>unknown</code></td>
</tr> <tr>
<td><code>unknown</code></td> <td><code>no</code></td> <td><code>unknown</code></td> <td><code>unknown</code></td> <td><code>no</code></td> <td><code>unknown</code></td>
</tr> <tr>
<td><code>unknown</code></td> <td><code>yes</code></td> <td></td> <td><code>yes</code></td> <td><code>unknown</code></td> <td><code>unknown</code></td>
</tr> <tr>
<td><code>unknown</code></td> <td><code>unknown</code></td> <td></td> <td><code>unknown</code></td> <td><code>unknown</code></td> <td><code>unknown</code></td>
</tr> </table> </dd> </dl> </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
     19992019 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_typecons.html" class="_attribution-link">https://dlang.org/phobos/std_typecons.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
