
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>std.stdio - D - W3cubDocs</title>
  
  <meta name="description" content=" Standard I&#47;O functions that extend core.stdc.stdio. core.stdc.stdio is publically imported when importing std.stdio. ">
  <meta name="keywords" content="std, stdio, d">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/d/std_stdio.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/d.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/d/" class="_nav-link" title="" style="margin-left:0;">D</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _d">
				
				
<h1>std.stdio</h1>  <p>Standard I/O functions that extend <b>core.stdc.stdio</b>. <b>core.stdc.stdio</b> is <span class="d_param">public</span>ally imported when importing <b>std.stdio</b>. </p>
<dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/stdio.d">std/stdio.d</a></span> </dd>
</dl> <dl>
<dt>License:</dt>
<dd>
<a href="http://boost.org/LICENSE_1_0.txt">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>
<a href="http://digitalmars.com">Walter Bright</a>, <a href="http://erdani.org">Andrei Alexandrescu</a>, Alex RÃ¸nne Petersen</dd>
</dl> <dl>
<dt class="d_decl" id="core.stdc.stdio">public import <strong id="core.stdc.stdio">core.stdc.stdio</strong>; </dt>  <dt class="d_decl" id="KeepTerminator">alias <strong id="KeepTerminator">KeepTerminator</strong> = std.typecons.Flag!"keepTerminator".Flag; </dt> <dd>
<p>If flag <code>KeepTerminator</code> is set to <code>KeepTerminator.yes</code>, then the delimiter is included in the strings returned.</p> </dd> <dt class="d_decl" id="File">struct <strong id="File">File</strong>; </dt> <dd>
<p>Encapsulates a <code>FILE*</code>. Generally D does not attempt to provide thin wrappers over equivalent functions in the C standard library, but manipulating <code>FILE*</code> values directly is unsafe and error-prone in many ways. The <code>File</code> type ensures safe manipulation, automatic file closing, and a lot of convenience. </p>
<p>The underlying <code>FILE*</code> handle is maintained in a reference-counted manner, such that as soon as the last <code>File</code> variable bound to a given <code>FILE*</code> goes out of scope, the underlying <code>FILE*</code> is automatically closed. </p> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">// test.d
void main(string[] args)
{
    auto f = File("test.txt", "w"); // open for writing
    f.write("Hello");
    if (args.length &gt; 1)
    {
        auto g = f; // now g and f write to the same file
                    // internal reference count is 2
        g.write(", ", args[1]);
        // g exits scope, reference count decreases to 1
    }
    f.writeln("!");
    // f exits scope, reference count falls to zero,
    // underlying `FILE*` is closed.
}
</pre> <pre>% rdmd test.d Jimmy
% cat test.txt
Hello, Jimmy!
% _
</pre> <dl>
<dt class="d_decl" id="File.this">@safe this(string name, scope const(char)[] stdioOpenmode = "rb"); <br><br>this(R1, R2)(R1 name)<br><small>  Constraints: if (isInputRange!R1 &amp;&amp; isSomeChar!(ElementEncodingType!R1)); </small><br><br>this(R1, R2)(R1 name, R2 mode)<br><small>  Constraints: if (isInputRange!R1 &amp;&amp; isSomeChar!(ElementEncodingType!R1) &amp;&amp; isInputRange!R2 &amp;&amp; isSomeChar!(ElementEncodingType!R2)); </small>
</dt> <dd>
<p>Constructor taking the name of the file to open and the open mode. </p>
<p>Copying one <code>File</code> object to another results in the two <code>File</code> objects referring to the same underlying file. <br><br> The destructor automatically closes the file as soon as no <code>File</code> object refers to it anymore. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>string <code>name</code>
</td> <td>range or string representing the file name</td>
</tr> <tr>
<td>const(char)[] <code>stdioOpenmode</code>
</td> <td>range or string represting the open mode (with the same semantics as in the C standard library <a href="http://cplusplus.com/reference/clibrary/cstdio/fopen.html">fopen</a> function)</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<code>ErrnoException</code> if the file could not be opened.</dd>
</dl> </dd> <dt class="d_decl" id="File.opAssign">ref @safe File <strong id="opAssign">opAssign</strong>(File rhs) return; </dt> <dd>
<p>Assigns a file to another. The target of the assignment gets detached from whatever file it was attached to, and attaches itself to the new file.</p> </dd> <dt class="d_decl" id="File.open">@trusted void <strong id="open">open</strong>(string name, scope const(char)[] stdioOpenmode = "rb"); </dt> <dd>
<p>Detaches from the current file (throwing on failure), and then attempts to open file <code>name</code> with mode <code>stdioOpenmode</code>. The mode has the same semantics as in the C standard library <a href="http://cplusplus.com/reference/clibrary/cstdio/fopen.html">fopen</a> function. </p>
<dl>
<dt>Throws:</dt>
<dd>
<code>ErrnoException</code> in case of error.</dd>
</dl> </dd> <dt class="d_decl" id="File.reopen">@trusted void <strong id="reopen">reopen</strong>(string name, scope const(char)[] stdioOpenmode = "rb"); </dt> <dd>
<p>Reuses the <code>File</code> object to either open a different file, or change the file mode. If <code>name</code> is <code>null</code>, the mode of the currently open file is changed; otherwise, a new file is opened, reusing the C <code>FILE*</code>. The function has the same semantics as in the C standard library <a href="http://cplusplus.com/reference/cstdio/freopen/">freopen</a> function. </p>
<dl>
<dt>Note</dt>
<dd> Calling <code>reopen</code> with a <code>null</code> <code>name</code> is not implemented in all C runtimes. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<code>ErrnoException</code> in case of error.</dd>
</dl> </dd> <dt class="d_decl" id="File.popen">@safe void <strong id="popen">popen</strong>(string command, scope const(char)[] stdioOpenmode = "r"); </dt> <dd>
<p>Detaches from the current file (throwing on failure), and then runs a command by calling the C standard library function <a href="http://opengroup.org/onlinepubs/007908799/xsh/popen.html">popen</a>. </p>
<dl>
<dt>Throws:</dt>
<dd>
<code>ErrnoException</code> in case of error.</dd>
</dl> </dd> <dt class="d_decl" id="File.fdopen">@safe void <strong id="fdopen">fdopen</strong>(int fd, scope const(char)[] stdioOpenmode = "rb"); </dt> <dd>
<p>First calls <code>detach</code> (throwing on failure), and then attempts to associate the given file descriptor with the <code>File</code>. The mode must be compatible with the mode of the file descriptor. </p>
<dl>
<dt>Throws:</dt>
<dd>
<code>ErrnoException</code> in case of error.</dd>
</dl> </dd> <dt class="d_decl" id="File.windowsHandleOpen">void <strong id="windowsHandleOpen">windowsHandleOpen</strong>(HANDLE handle, scope const(char)[] stdioOpenmode); </dt> <dd>
<p>First calls <code>detach</code> (throwing on failure), and then attempts to associate the given Windows <code>HANDLE</code> with the <code>File</code>. The mode must be compatible with the access attributes of the handle. Windows only. </p>
<dl>
<dt>Throws:</dt>
<dd>
<code>ErrnoException</code> in case of error.</dd>
</dl> </dd> <dt class="d_decl" id="File.isOpen">const pure nothrow @property @safe bool <strong id="isOpen">isOpen</strong>(); </dt> <dd>
<p>Returns <code>true</code> if the file is opened.</p> </dd> <dt class="d_decl" id="File.eof">const pure @property @trusted bool <strong id="eof">eof</strong>(); </dt> <dd>
<p>Returns <code>true</code> if the file is at end (see <a href="http://cplusplus.com/reference/clibrary/cstdio/feof.html">feof</a>). </p>
<dl>
<dt>Throws:</dt>
<dd>
<code>Exception</code> if the file is not opened.</dd>
</dl> </dd> <dt class="d_decl" id="File.name">const pure nothrow @property @safe string <strong id="name">name</strong>(); </dt> <dd>
<p>Returns the name of the last opened file, if any. If a <code>File</code> was created with <a href="#tmpfile"><code>tmpfile</code></a> and <a href="#wrapFile"><code>wrapFile</code></a> it has no name.</p> </dd> <dt class="d_decl" id="File.error">const pure nothrow @property @trusted bool <strong id="error">error</strong>(); </dt> <dd>
<p>If the file is not opened, returns <code>true</code>. Otherwise, returns <a href="http://cplusplus.com/reference/clibrary/cstdio/ferror.html">ferror</a> for the file handle.</p> </dd> <dt class="d_decl" id="File.detach">@trusted void <strong id="detach">detach</strong>(); </dt> <dd>
<p>Detaches from the underlying file. If the sole owner, calls <code>close</code>. </p>
<dl>
<dt>Throws:</dt>
<dd>
<code>ErrnoException</code> on failure if closing the file.</dd>
</dl> </dd> <dt class="d_decl" id="File.close">@trusted void <strong id="close">close</strong>(); </dt> <dd>
<p>If the file was unopened, succeeds vacuously. Otherwise closes the file (by calling <a href="http://cplusplus.com/reference/clibrary/cstdio/fclose.html">fclose</a>), throwing on error. Even if an exception is thrown, afterwards the <code>File</code> object is empty. This is different from <code>detach</code> in that it always closes the file; consequently, all other <code>File</code> objects referring to the same handle will see a closed file henceforth. </p>
<dl>
<dt>Throws:</dt>
<dd>
<code>ErrnoException</code> on error.</dd>
</dl> </dd> <dt class="d_decl" id="File.clearerr">pure nothrow @safe void <strong id="clearerr">clearerr</strong>(); </dt> <dd>
<p>If the file is not opened, succeeds vacuously. Otherwise, returns <a href="http://cplusplus.com/reference/clibrary/cstdio/clearerr.html">clearerr</a> for the file handle.</p> </dd> <dt class="d_decl" id="File.flush">@trusted void <strong id="flush">flush</strong>(); </dt> <dd>
<p>Flushes the C <code>FILE</code> buffers. </p>
<p>Calls <a href="http://cplusplus.com/reference/clibrary/cstdio/fflush.html">fflush</a> for the file handle. </p> <dl>
<dt>Throws:</dt>
<dd>
<code>Exception</code> if the file is not opened or if the call to <code>fflush</code> fails.</dd>
</dl> </dd> <dt class="d_decl" id="File.sync">@trusted void <strong id="sync">sync</strong>(); </dt> <dd>
<p>Forces any data buffered by the OS to be written to disk. Call <a href="#flush"><code>flush</code></a> before calling this function to flush the C <code>FILE</code> buffers first. </p>
<p>This function calls <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa364439%28v=vs.85%29.aspx"><code>FlushFileBuffers</code></a> on Windows and <a href="http://pubs.opengroup.org/onlinepubs/7908799/xsh/fsync.html"><code>fsync</code></a> on POSIX for the file handle. </p> <dl>
<dt>Throws:</dt>
<dd>
<code>Exception</code> if the file is not opened or if the OS call fails.</dd>
</dl> </dd> <dt class="d_decl" id="File.rawRead">T[] <strong id="rawRead">rawRead</strong>(T)(T[] buffer); </dt> <dd>
<p>Calls <a href="http://cplusplus.com/reference/clibrary/cstdio/fread.html">fread</a> for the file handle. The number of items to read and the size of each item is inferred from the size and type of the input array, respectively. </p>
<dl>
<dt>Returns:</dt>
<dd>The slice of <code>buffer</code> containing the data that was actually read. This will be shorter than <code>buffer</code> if EOF was reached before the buffer could be filled. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<code>Exception</code> if <code>buffer</code> is empty. <code>ErrnoException</code> if the file is not opened or the call to <code>fread</code> fails.  <code>rawRead</code> always reads in binary mode on Windows.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static import std.file;

auto testFile = std.file.deleteme();
std.file.write(testFile, "\r\n\n\r\n");
scope(exit) std.file.remove(testFile);

auto f = File(testFile, "r");
auto buf = f.rawRead(new char[5]);
f.close();
writeln(buf); // "\r\n\n\r\n"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="File.rawWrite">void <strong id="rawWrite">rawWrite</strong>(T)(in T[] buffer); </dt> <dd>
<p>Calls <a href="http://cplusplus.com/reference/clibrary/cstdio/fwrite.html">fwrite</a> for the file handle. The number of items to write and the size of each item is inferred from the size and type of the input array, respectively. An error is thrown if the buffer could not be written in its entirety. </p>
<p><code>rawWrite</code> always writes in binary mode on Windows. </p> <dl>
<dt>Throws:</dt>
<dd>
<code>ErrnoException</code> if the file is not opened or if the call to <code>fwrite</code> fails.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static import std.file;

auto testFile = std.file.deleteme();
auto f = File(testFile, "w");
scope(exit) std.file.remove(testFile);

f.rawWrite("\r\n\n\r\n");
f.close();
writeln(std.file.read(testFile)); // "\r\n\n\r\n"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="File.seek">@trusted void <strong id="seek">seek</strong>(long offset, int origin = SEEK_SET); </dt> <dd>
<p>Calls <a href="http://cplusplus.com/reference/clibrary/cstdio/fseek.html">fseek</a> for the file handle to move its position indicator. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>long <code>offset</code>
</td> <td>Binary files: Number of bytes to offset from origin.<br> Text files: Either zero, or a value returned by <a href="#tell"><code>tell</code></a>.</td>
</tr> <tr>
<td>int <code>origin</code>
</td> <td>Binary files: Position used as reference for the offset, must be one of <a href="core_stdc_stdio#SEEK_SET">SEEK_SET</a>, <a href="core_stdc_stdio#SEEK_CUR">SEEK_CUR</a> or <a href="core_stdc_stdio#SEEK_END">SEEK_END</a>.<br> Text files: Shall necessarily be <a href="core_stdc_stdio#SEEK_SET">SEEK_SET</a>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<code>Exception</code> if the file is not opened. <code>ErrnoException</code> if the call to <code>fseek</code> fails.</dd>
</dl> </dd> <dt class="d_decl" id="File.tell">const @property @trusted ulong <strong id="tell">tell</strong>(); </dt> <dd>
<p>Calls <a href="http://cplusplus.com/reference/clibrary/cstdio/ftell.html">ftell</a> for the managed file handle. </p>
<dl>
<dt>Throws:</dt>
<dd>
<code>Exception</code> if the file is not opened. <code>ErrnoException</code> if the call to <code>ftell</code> fails.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.conv : text;
static import std.file;

auto testFile = std.file.deleteme();
std.file.write(testFile, "abcdefghijklmnopqrstuvwqxyz");
scope(exit) { std.file.remove(testFile); }

auto f = File(testFile);
auto a = new ubyte[4];
f.rawRead(a);
writeln(f.tell); // 4
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="File.rewind">@safe void <strong id="rewind">rewind</strong>(); </dt> <dd>
<p>Calls <a href="http://cplusplus.com/reference/clibrary/cstdio/rewind.html">rewind</a> for the file handle. </p>
<dl>
<dt>Throws:</dt>
<dd>
<code>Exception</code> if the file is not opened.</dd>
</dl> </dd> <dt class="d_decl" id="File.setvbuf">@trusted void <strong id="setvbuf">setvbuf</strong>(size_t size, int mode = _IOFBF); </dt> <dd>
<p>Calls <a href="http://cplusplus.com/reference/clibrary/cstdio/setvbuf.html">setvbuf</a> for the file handle. </p>
<dl>
<dt>Throws:</dt>
<dd>
<code>Exception</code> if the file is not opened. <code>ErrnoException</code> if the call to <code>setvbuf</code> fails.</dd>
</dl> </dd> <dt class="d_decl" id="File.setvbuf.2">@trusted void <strong id="setvbuf">setvbuf</strong>(void[] buf, int mode = _IOFBF); </dt> <dd>
<p>Calls <a href="http://cplusplus.com/reference/clibrary/cstdio/setvbuf.html">setvbuf</a> for the file handle. </p>
<dl>
<dt>Throws:</dt>
<dd>
<code>Exception</code> if the file is not opened. <code>ErrnoException</code> if the call to <code>setvbuf</code> fails.</dd>
</dl> </dd> <dt class="d_decl" id="File.lock">void <strong id="lock">lock</strong>(LockType lockType = LockType.readWrite, ulong start = 0, ulong length = 0); </dt> <dd>
<p>Locks the specified file segment. If the file segment is already locked by another process, waits until the existing lock is released. If both <code>start</code> and <code>length</code> are zero, the entire file is locked. </p>
<p>Locks created using <code>lock</code> and <code>tryLock</code> have the following properties: </p>
<ul> <li>All locks are automatically released when the process terminates.</li> <li>Locks are not inherited by child processes.</li> <li>Closing a file will release all locks associated with the file. On POSIX, even locks acquired via a different <code>File</code> will be released as well.</li> <li>Not all NFS implementations correctly implement file locking.</li> </ul> </dd> <dt class="d_decl" id="File.tryLock">bool <strong id="tryLock">tryLock</strong>(LockType lockType = LockType.readWrite, ulong start = 0, ulong length = 0); </dt> <dd>
<p>Attempts to lock the specified file segment. If both <code>start</code> and <code>length</code> are zero, the entire file is locked. </p>
<dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if the lock was successful, and <code>false</code> if the specified file segment was already locked.</dd>
</dl> </dd> <dt class="d_decl" id="File.unlock">void <strong id="unlock">unlock</strong>(ulong start = 0, ulong length = 0); </dt> <dd>
<p>Removes the lock over the specified file segment.</p> </dd> <dt class="d_decl" id="File.write">void <strong id="write">write</strong>(S...)(S args); </dt> <dd>
<p>Writes its arguments in text format to the file. </p>
<dl>
<dt>Throws:</dt>
<dd>
<code>Exception</code> if the file is not opened. <code>ErrnoException</code> on an error writing to the file.</dd>
</dl> </dd> <dt class="d_decl" id="File.writeln">void <strong id="writeln">writeln</strong>(S...)(S args); </dt> <dd>
<p>Writes its arguments in text format to the file, followed by a newline. </p>
<dl>
<dt>Throws:</dt>
<dd>
<code>Exception</code> if the file is not opened. <code>ErrnoException</code> on an error writing to the file.</dd>
</dl> </dd> <dt class="d_decl" id="File.writef">void <strong id="writef">writef</strong>(alias fmt, A...)(A args)<br><small>  Constraints: if (isSomeString!(typeof(fmt))); </small><br><br>void <strong id="writef">writef</strong>(Char, A...)(in Char[] fmt, A args); </dt> <dd>
<p>Writes its arguments in text format to the file, according to the format string fmt. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Char[] <code>fmt</code>
</td> <td>The <a href="std_format#formattedWrite">format string</a>. When passed as a compile-time argument, the string will be statically checked against the argument types passed.</td>
</tr> <tr>
<td>A <code>args</code>
</td> <td>Items to write.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<code>Exception</code> if the file is not opened. <code>ErrnoException</code> on an error writing to the file.</dd>
</dl> </dd> <dt class="d_decl" id="File.writefln">void <strong id="writefln">writefln</strong>(alias fmt, A...)(A args)<br><small>  Constraints: if (isSomeString!(typeof(fmt))); </small><br><br>void <strong id="writefln">writefln</strong>(Char, A...)(in Char[] fmt, A args); </dt> <dd>
<p>Equivalent to <code>file.writef(fmt, args, '\n')</code>.</p> </dd> <dt class="d_decl" id="File.readln">S <strong id="readln">readln</strong>(S = string)(dchar terminator = '\x0a')<br><small>  Constraints: if (isSomeString!S); </small>
</dt> <dd>
<p>Read line from the file handle and return it as a specified type. </p>
<p>This version manages its own read buffer, which means one memory allocation per call. If you are not retaining a reference to the read data, consider the <code>File.readln(buf)</code> version, which may offer better performance as it can reuse its read buffer. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S</td> <td>Template parameter; the type of the allocated buffer, and the type returned. Defaults to <code>string</code>.</td>
</tr> <tr>
<td>dchar <code>terminator</code>
</td> <td>Line terminator (by default, <code>'\n'</code>).</td>
</tr> </table></dd>
</dl> <dl>
<dt>Note</dt>
<dd> String terminators are not supported due to ambiguity with readln(buf) below. </dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The line that was read, including the line terminator character. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<code>StdioException</code> on I/O error, or <code>UnicodeException</code> on Unicode conversion error. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">// Reads `stdin` and writes it to `stdout`.
import std.stdio;

void main()
{
    string line;
    while ((line = stdin.readln()) !is null)
        write(line);
}
</pre>  </dd> <dt class="d_decl" id="File.readln.2">size_t <strong id="readln">readln</strong>(C)(ref C[] buf, dchar terminator = '\x0a')<br><small>  Constraints: if (isSomeChar!C &amp;&amp; is(Unqual!C == C) &amp;&amp; !is(C == enum)); </small><br><br>size_t <strong id="readln">readln</strong>(C, R)(ref C[] buf, R terminator)<br><small>  Constraints: if (isSomeChar!C &amp;&amp; is(Unqual!C == C) &amp;&amp; !is(C == enum) &amp;&amp; isBidirectionalRange!R &amp;&amp; is(typeof(terminator.front == (dchar).init))); </small>
</dt> <dd>
<p>Read line from the file handle and write it to <code>buf[]</code>, including terminating character. </p>
<p>This can be faster than <code>line = File.readln()</code> because you can reuse the buffer for each call. Note that reusing the buffer means that you must copy the previous contents if you wish to retain them. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>C[] <code>buf</code>
</td> <td>Buffer used to store the resulting line data. buf is enlarged if necessary, then set to the slice exactly containing the line.</td>
</tr> <tr>
<td>dchar <code>terminator</code>
</td> <td>Line terminator (by default, <code>'\n'</code>). Use <a href="std_ascii#newline"><code>std.ascii.newline</code></a> for portability (unless the file was opened in text mode).</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>0 for end of file, otherwise number of characters read. The return value will always be equal to <code>buf.length</code>. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<code>StdioException</code> on I/O error, or <code>UnicodeException</code> on Unicode conversion error. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">// Read lines from `stdin` into a string
// Ignore lines starting with '#'
// Write the string to `stdout`

void main()
{
    string output;
    char[] buf;

    while (stdin.readln(buf))
    {
        if (buf[0] == '#')
            continue;

        output ~= buf;
    }

    write(output);
}
</pre>  This method can be more efficient than the one in the previous example because <code>stdin.readln(buf)</code> reuses (if possible) memory allocated for <code>buf</code>, whereas <code>line = stdin.readln()</code> makes a new memory allocation for every line.  For even better performance you can help <code>readln</code> by passing in a large buffer to avoid memory reallocations. This can be done by reusing the largest buffer returned by <code>readln</code>:  <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">// Read lines from `stdin` and count words

void main()
{
    char[] buf;
    size_t words = 0;

    while (!stdin.eof)
    {
        char[] line = buf;
        stdin.readln(line);
        if (line.length &gt; buf.length)
            buf = line;

        words += line.split.length;
    }

    writeln(words);
}
</pre> This is actually what <a href="#byLine"><code>byLine</code></a> does internally, so its usage is recommended if you want to process a complete file. </dd> <dt class="d_decl" id="File.readf">uint <strong id="readf">readf</strong>(alias format, Data...)(auto ref Data data)<br><small>  Constraints: if (isSomeString!(typeof(format))); </small><br><br>uint <strong id="readf">readf</strong>(Data...)(scope const(char)[] format, auto ref Data data); </dt> <dd>
<p>Reads formatted data from the file using <a href="std_format#formattedRead"><code>std.format.formattedRead</code></a>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)[] <code>format</code>
</td> <td>The <a href="std%20format_#formattedWrite">format string</a>. When passed as a compile-time argument, the string will be statically checked against the argument types passed.</td>
</tr> <tr>
<td>Data <code>data</code>
</td> <td>Items to be read.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">// test.d
void main()
{
    import std.stdio;
    auto f = File("input");
    foreach (_; 0 .. 3)
    {
        int a;
        f.readf!" %d"(a);
        writeln(++a);
    }
}
</pre> <pre>% echo "1 2 3" &gt; input
% rdmd test.d
2
3
4
</pre> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static import std.file;

auto deleteme = std.file.deleteme();
std.file.write(deleteme, "hello\nworld\ntrue\nfalse\n");
scope(exit) std.file.remove(deleteme);
string s;
auto f = File(deleteme);
f.readf!"%s\n"(s);
writeln(s); // "hello"
f.readf("%s\n", s);
writeln(s); // "world"

bool b1, b2;
f.readf("%s\n%s\n", b1, b2);
assert(b1 == true &amp;&amp; b2 == false);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="File.tmpfile">static @safe File <strong id="tmpfile">tmpfile</strong>(); </dt> <dd>
<p>Returns a temporary file by calling <a href="http://cplusplus.com/reference/clibrary/cstdio/tmpfile.html">tmpfile</a>. Note that the created file has no <a href="#name"><code>name</code></a>.</p> </dd> <dt class="d_decl" id="File.wrapFile">static @safe File <strong id="wrapFile">wrapFile</strong>(FILE* f); </dt> <dd>
<p>Unsafe function that wraps an existing <code>FILE*</code>. The resulting <code>File</code> never takes the initiative in closing the file. Note that the created file has no <a href="#name"><code>name</code></a></p> </dd> <dt class="d_decl" id="File.getFP">pure @safe FILE* <strong id="getFP">getFP</strong>(); </dt> <dd>
<p>Returns the <code>FILE*</code> corresponding to this object.</p> </dd> <dt class="d_decl" id="File.fileno">const @property @trusted int <strong id="fileno">fileno</strong>(); </dt> <dd>
<p>Returns the file number corresponding to this object.</p> </dd> <dt class="d_decl" id="File.windowsHandle">@property HANDLE <strong id="windowsHandle">windowsHandle</strong>(); </dt> <dd>
<p>Returns the underlying operating system <code>HANDLE</code> (Windows only).</p> </dd> <dt class="d_decl" id="File.byLine">auto <strong id="byLine">byLine</strong>(Terminator = char, Char = char)(KeepTerminator keepTerminator = No.keepTerminator, Terminator terminator = '\x0a')<br><small>  Constraints: if (isScalarType!Terminator); </small><br><br>auto <strong id="byLine">byLine</strong>(Terminator, Char = char)(KeepTerminator keepTerminator, Terminator terminator)<br><small>  Constraints: if (is(Unqual!(ElementEncodingType!Terminator) == Char)); </small>
</dt> <dd>
<p>Returns an <a href="std_range_primitives#isInputRange">input range</a> set up to read from the file handle one line at a time. </p>
<p>The element type for the range will be <code>Char[]</code>. Range primitives may throw <code>StdioException</code> on I/O error. </p> <dl>
<dt>Note</dt>
<dd> Each <code>front</code> will not persist after <code>popFront</code> is called, so the caller must copy its contents (e.g. by calling <code>to!string</code>) when retention is needed. If the caller needs to retain a copy of every line, use the <a href="#byLineCopy"><code>byLineCopy</code></a> function instead. </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Char</td> <td>Character type for each line, defaulting to <code>char</code>.</td>
</tr> <tr>
<td>KeepTerminator <code>keepTerminator</code>
</td> <td>Use <code>Yes.keepTerminator</code> to include the terminator at the end of each line.</td>
</tr> <tr>
<td>Terminator <code>terminator</code>
</td> <td>Line separator (<code>'\n'</code> by default). Use <a href="std_ascii#newline"><code>std.ascii.newline</code></a> for portability (unless the file was opened in text mode).</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">import std.algorithm, std.stdio, std.string;
// Count words in a file using ranges.
void main()
{
    auto file = File("file.txt"); // Open for reading
    const wordCount = file.byLine()            // Read lines
                          .map!split           // Split into words
                          .map!(a =&gt; a.length) // Count words per line
                          .sum();              // Total word count
    writeln(wordCount);
}
</pre>  <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">import std.range, std.stdio;
// Read lines using foreach.
void main()
{
    auto file = File("file.txt"); // Open for reading
    auto range = file.byLine();
    // Print first three lines
    foreach (line; range.take(3))
        writeln(line);
    // Print remaining lines beginning with '#'
    foreach (line; range)
    {
        if (!line.empty &amp;&amp; line[0] == '#')
            writeln(line);
    }
}
</pre> Notice that neither example accesses the line data returned by <code>front</code> after the corresponding <code>popFront</code> call is made (because the contents may well have changed). </dd> <dt class="d_decl" id="File.byLineCopy">auto <strong id="byLineCopy">byLineCopy</strong>(Terminator = char, Char = immutable(char))(KeepTerminator keepTerminator = No.keepTerminator, Terminator terminator = '\x0a')<br><small>  Constraints: if (isScalarType!Terminator); </small><br><br>auto <strong id="byLineCopy">byLineCopy</strong>(Terminator, Char = immutable(char))(KeepTerminator keepTerminator, Terminator terminator)<br><small>  Constraints: if (is(Unqual!(ElementEncodingType!Terminator) == Unqual!Char)); </small>
</dt> <dd>
<p>Returns an <a href="std_range_primitives#isInputRange">input range</a> set up to read from the file handle one line at a time. Each line will be newly allocated. <code>front</code> will cache its value to allow repeated calls without unnecessary allocations. </p>
<dl>
<dt>Note</dt>
<dd> Due to caching byLineCopy can be more memory-efficient than <code>File.byLine.map!idup</code>. </dd>
</dl> The element type for the range will be <code>Char[]</code>. Range primitives may throw <code>StdioException</code> on I/O error.  <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Char</td> <td>Character type for each line, defaulting to <code>immutable char</code>.</td>
</tr> <tr>
<td>KeepTerminator <code>keepTerminator</code>
</td> <td>Use <code>Yes.keepTerminator</code> to include the terminator at the end of each line.</td>
</tr> <tr>
<td>Terminator <code>terminator</code>
</td> <td>Line separator (<code>'\n'</code> by default). Use <a href="std_ascii#newline"><code>std.ascii.newline</code></a> for portability (unless the file was opened in text mode).</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">import std.algorithm, std.array, std.stdio;
// Print sorted lines of a file.
void main()
{
    auto sortedLines = File("file.txt")   // Open for reading
                       .byLineCopy()      // Read persistent lines
                       .array()           // into an array
                       .sort();           // then sort them
    foreach (line; sortedLines)
        writeln(line);
}
</pre>  <dl>
<dt>See Also:</dt>
<dd><a href="std_file#readText"><code>std.file.readText</code></a></dd>
</dl> </dd> <dt class="d_decl" id="File.byRecord">auto <strong id="byRecord">byRecord</strong>(Fields...)(string format); </dt> <dd>
<p>Creates an <a href="std_range_primitives#isInputRange">input range</a> set up to parse one line at a time from the file into a tuple. </p>
<p>Range primitives may throw <code>StdioException</code> on I/O error. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>string <code>format</code>
</td> <td>tuple record <a href="std_format#formattedRead">format</a>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The input range set up to parse one line at a time into a record tuple. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>It is similar to <a href="#byLine"><code>byLine</code></a> and uses <a href="std_format#formattedRead">format</a> under the hood.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static import std.file;
import std.typecons : tuple;

// prepare test file
auto testFile = std.file.deleteme();
scope(failure) printf("Failed test at line %d\n", __LINE__);
std.file.write(testFile, "1 2\n4 1\n5 100");
scope(exit) std.file.remove(testFile);

File f = File(testFile);
scope(exit) f.close();

auto expected = [tuple(1, 2), tuple(4, 1), tuple(5, 100)];
uint i;
foreach (e; f.byRecord!(int, int)("%s %s"))
{
    writeln(e); // expected[i++]
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="File.byChunk">auto <strong id="byChunk">byChunk</strong>(size_t chunkSize); <br><br>auto <strong id="byChunk">byChunk</strong>(ubyte[] buffer); </dt> <dd>
<p>Returns an <a href="std_range_primitives#isInputRange">input range</a> set up to read from the file handle a chunk at a time. </p>
<p>The element type for the range will be <code>ubyte[]</code>. Range primitives may throw <code>StdioException</code> on I/O error. </p> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">void main()
{
    // Read standard input 4KB at a time
    foreach (ubyte[] buffer; stdin.byChunk(4096))
    {
        ... use buffer ...
    }
}
</pre>  The parameter may be a number (as shown in the example above) dictating the size of each chunk. Alternatively, <code>byChunk</code> accepts a user-provided buffer that it uses directly.  <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">void main()
{
    // Read standard input 4KB at a time
    foreach (ubyte[] buffer; stdin.byChunk(new ubyte[4096]))
    {
        ... use buffer ...
    }
}
</pre>  In either case, the content of the buffer is reused across calls. That means <code>front</code> will not persist after <code>popFront</code> is called, so if retention is needed, the caller must copy its contents (e.g. by calling <code>buffer.dup</code>).  In the example above, <code>buffer.length</code> is 4096 for all iterations, except for the last one, in which case <code>buffer.length</code> may be less than 4096 (but always greater than zero).  With the mentioned limitations, <code>byChunk</code> works with any algorithm compatible with input ranges.  <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">// Efficient file copy, 1MB at a time.
import std.algorithm, std.stdio;
void main()
{
    stdin.byChunk(1024 * 1024).copy(stdout.lockingTextWriter());
}
</pre>  <a href="std_algorithm_iteration#joiner"><code>std.algorithm.iteration.joiner</code></a> can be used to join chunks together into a single range lazily.  <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">import std.algorithm, std.stdio;
void main()
{
    //Range of ranges
    static assert(is(typeof(stdin.byChunk(4096).front) == ubyte[]));
    //Range of elements
    static assert(is(typeof(stdin.byChunk(4096).joiner.front) == ubyte));
}
</pre>  <dl>
<dt>Returns:</dt>
<dd>A call to <code>byChunk</code> returns a range initialized with the <code>File</code> object and the appropriate buffer. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>If the user-provided size is zero or the user-provided buffer is empty, throws an <code>Exception</code>. In case of an I/O error throws <code>StdioException</code>.</dd>
</dl> </dd> <dt class="d_decl" id="File.lockingTextWriter">@safe auto <strong id="lockingTextWriter">lockingTextWriter</strong>(); </dt> <dd>
<p>Output range which locks the file when created, and unlocks the file when it goes out of scope. </p>
<dl>
<dt>Returns:</dt>
<dd>An <a href="std_range_primitives#isOutputRange">output range</a> which accepts string types, <code>ubyte[]</code>, individual character types, and individual <code>ubyte</code>s. </dd>
</dl> <dl>
<dt>Note</dt>
<dd> Writing either arrays of <code>char</code>s or <code>ubyte</code>s is faster than writing each character individually from a range. For large amounts of data, writing the contents in chunks using an intermediary array can result in a speed increase. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_utf#UTFException"><code>std.utf.UTFException</code></a> if the data given is a <code>char</code> range and it contains malformed UTF data. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#byChunk"><code>byChunk</code></a> for an example.</dd>
</dl> </dd> <dt class="d_decl" id="File.lockingBinaryWriter">auto <strong id="lockingBinaryWriter">lockingBinaryWriter</strong>(); </dt> <dd>
<p>Returns an output range that locks the file and allows fast writing to it. </p>
<dl>
<dt>Example</dt>
<dd> Produce a grayscale image of the <a href="https://en.wikipedia.org/wiki/Mandelbrot_set">Mandelbrot set</a> in binary <a href="https://en.wikipedia.org/wiki/Netpbm_format">Netpbm format</a> to standard output. </dd>
</dl>
<pre data-language="d">import std.algorithm, std.range, std.stdio;

void main()
{
    enum size = 500;
    writef("P5\n%d %d %d\n", size, size, ubyte.max);

    iota(-1, 3, 2.0/size).map!(y =&gt;
        iota(-1.5, 0.5, 2.0/size).map!(x =&gt;
            cast(ubyte)(1+
                recurrence!((a, n) =&gt; x + y*1i + a[n-1]^^2)(0+0i)
                .take(ubyte.max)
                .countUntil!(z =&gt; z.re^^2 + z.im^^2 &gt; 4))
        )
    )
    .copy(stdout.lockingBinaryWriter);
}
</pre>  </dd> <dt class="d_decl" id="File.size">@property @safe ulong <strong id="size">size</strong>(); </dt> <dd>
<p>Get the size of the file, ulong.max if file is not searchable, but still throws if an actual error occurs.</p> </dd> </dl> </dd> <dt class="d_decl" id="LockType">enum <strong id="LockType">LockType</strong>: int; </dt> <dd>
<p>Used to specify the lock type for <code>File.lock</code> and <code>File.tryLock</code>.</p> <dl>
<dt class="d_decl" id="LockType.read"><strong id="read">read</strong></dt> <dd>
<p>Specifies a read (shared) lock. A read lock denies all processes write access to the specified region of the file, including the process that first locks the region. All processes can read the locked region. Multiple simultaneous read locks are allowed, as long as there are no exclusive locks.</p> </dd> <dt class="d_decl" id="LockType.readWrite"><strong id="readWrite">readWrite</strong></dt> <dd>
<p>Specifies a read/write (exclusive) lock. A read/write lock denies all other processes both read and write access to the locked file region. If a segment has an exclusive lock, it may not have any shared locks or other exclusive locks.</p> </dd> </dl> </dd> <dt class="d_decl" id="isFileHandle">enum auto <strong id="isFileHandle">isFileHandle</strong>(T); </dt> <dd>
<p>Indicates whether <code>T</code> is a file handle, i.e. the type is implicitly convertable to <a href="#File"><code>File</code></a> or a pointer to a <a href="core_stdc_stdio#FILE"><code>core.stdc.stdio.FILE</code></a>. </p>
<dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if <code>T</code> is a file handle, <code>false</code> otherwise.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(isFileHandle!(FILE*));
static assert(isFileHandle!(File));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="write">void <strong id="write">write</strong>(T...)(T args)<br><small>  Constraints: if (!is(T[0] : File)); </small>
</dt> <dd>
<p>Writes its arguments in text format to standard output (without a trailing newline). </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>args</code>
</td> <td>the items to write to <code>stdout</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>In case of an I/O error, throws an <code>StdioException</code>. </dd>
</dl> <dl>
<dt>Example</dt>
<dd> Reads <code>stdin</code> and writes it to <code>stdout</code> with an argument counter. </dd>
</dl>
<pre data-language="d">import std.stdio;

void main()
{
    string line;

    for (size_t count = 0; (line = readln) !is null; count++)
    {
         write("Input ", count, ": ", line, "\n");
    }
}
</pre>  </dd> <dt class="d_decl" id="writeln">void <strong id="writeln">writeln</strong>(T...)(T args); </dt> <dd>
<p>Equivalent to <code>write(args, '\n')</code>. Calling <code>writeln</code> without arguments is valid and just prints a newline to the standard output. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>args</code>
</td> <td>the items to write to <code>stdout</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>In case of an I/O error, throws an <a href="#StdioException"><code>StdioException</code></a>. </dd>
</dl> <dl>
<dt>Example</dt>
<dd> Reads <code>stdin</code> and writes it to <code>stdout</code> with a argument counter. </dd>
</dl>
<pre data-language="d">import std.stdio;

void main()
{
    string line;

    for (size_t count = 0; (line = readln) !is null; count++)
    {
         writeln("Input ", count, ": ", line);
    }
}
</pre>  </dd> <dt class="d_decl" id="writef">void <strong id="writef">writef</strong>(alias fmt, A...)(A args)<br><small>  Constraints: if (isSomeString!(typeof(fmt))); </small><br><br>void <strong id="writef">writef</strong>(Char, A...)(in Char[] fmt, A args); </dt> <dd>
<p>Writes formatted data to standard output (without a trailing newline). </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Char[] <code>fmt</code>
</td> <td>The <a href="std_format#formattedWrite">format string</a>. When passed as a compile-time argument, the string will be statically checked against the argument types passed.</td>
</tr> <tr>
<td>A <code>args</code>
</td> <td>Items to write.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Note</dt>
<dd> In older versions of Phobos, it used to be possible to write: </dd>
</dl> <pre data-language="d">writef(stderr, "%s", "message");
</pre>  to print a message to <code>stderr</code>. This syntax is no longer supported, and has been superceded by:  <pre data-language="d">stderr.writef("%s", "message");
</pre>  </dd> <dt class="d_decl" id="writefln">void <strong id="writefln">writefln</strong>(alias fmt, A...)(A args)<br><small>  Constraints: if (isSomeString!(typeof(fmt))); </small><br><br>void <strong id="writefln">writefln</strong>(Char, A...)(in Char[] fmt, A args); </dt> <dd>
<p>Equivalent to <code>writef(fmt, args, '\n')</code>.</p> </dd> <dt class="d_decl" id="readf">uint <strong id="readf">readf</strong>(alias format, A...)(auto ref A args)<br><small>  Constraints: if (isSomeString!(typeof(format))); </small><br><br>uint <strong id="readf">readf</strong>(A...)(scope const(char)[] format, auto ref A args); </dt> <dd>
<p>Reads formatted data from <code>stdin</code> using <a href="std_format#formattedRead"><code>std.format.formattedRead</code></a>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)[] <code>format</code>
</td> <td>The <a href="std_format#formattedWrite">format string</a>. When passed as a compile-time argument, the string will be statically checked against the argument types passed.</td>
</tr> <tr>
<td>A <code>args</code>
</td> <td>Items to be read.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">// test.d
void main()
{
    import std.stdio;
    foreach (_; 0 .. 3)
    {
        int a;
        readf!" %d"(a);
        writeln(++a);
    }
}
</pre> <pre>% echo "1 2 3" | rdmd test.d
2
3
4
</pre> </dd> <dt class="d_decl" id="readln">S <strong id="readln">readln</strong>(S = string)(dchar terminator = '\x0a')<br><small>  Constraints: if (isSomeString!S); </small>
</dt> <dd>
<p>Read line from <code>stdin</code>. </p>
<p>This version manages its own read buffer, which means one memory allocation per call. If you are not retaining a reference to the read data, consider the <code>readln(buf)</code> version, which may offer better performance as it can reuse its read buffer. </p> <dl>
<dt>Returns:</dt>
<dd>The line that was read, including the line terminator character. </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S</td> <td>Template parameter; the type of the allocated buffer, and the type returned. Defaults to <code>string</code>.</td>
</tr> <tr>
<td>dchar <code>terminator</code>
</td> <td>Line terminator (by default, <code>'\n'</code>).</td>
</tr> </table></dd>
</dl> <dl>
<dt>Note</dt>
<dd> String terminators are not supported due to ambiguity with readln(buf) below. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<code>StdioException</code> on I/O error, or <code>UnicodeException</code> on Unicode conversion error. </dd>
</dl> <dl>
<dt>Example</dt>
<dd> Reads <code>stdin</code> and writes it to <code>stdout</code>. </dd>
</dl>
<pre data-language="d">import std.stdio;

void main()
{
    string line;
    while ((line = readln()) !is null)
        write(line);
}
</pre>  </dd> <dt class="d_decl" id="readln.2">size_t <strong id="readln">readln</strong>(C)(ref C[] buf, dchar terminator = '\x0a')<br><small>  Constraints: if (isSomeChar!C &amp;&amp; is(Unqual!C == C) &amp;&amp; !is(C == enum)); </small><br><br>size_t <strong id="readln">readln</strong>(C, R)(ref C[] buf, R terminator)<br><small>  Constraints: if (isSomeChar!C &amp;&amp; is(Unqual!C == C) &amp;&amp; !is(C == enum) &amp;&amp; isBidirectionalRange!R &amp;&amp; is(typeof(terminator.front == (dchar).init))); </small>
</dt> <dd>
<p>Read line from <code>stdin</code> and write it to buf[], including terminating character. </p>
<p>This can be faster than <code>line = readln()</code> because you can reuse the buffer for each call. Note that reusing the buffer means that you must copy the previous contents if you wish to retain them. </p> <dl>
<dt>Returns:</dt>
<dd>
<code>size_t</code> 0 for end of file, otherwise number of characters read </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>C[] <code>buf</code>
</td> <td>Buffer used to store the resulting line data. buf is resized as necessary.</td>
</tr> <tr>
<td>dchar <code>terminator</code>
</td> <td>Line terminator (by default, <code>'\n'</code>). Use <a href="std_ascii#newline"><code>std.ascii.newline</code></a> for portability (unless the file was opened in text mode).</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<code>StdioException</code> on I/O error, or <code>UnicodeException</code> on Unicode conversion error. </dd>
</dl> <dl>
<dt>Example</dt>
<dd> Reads <code>stdin</code> and writes it to <code>stdout</code>. </dd>
</dl>
<pre data-language="d">import std.stdio;

void main()
{
    char[] buf;
    while (readln(buf))
        write(buf);
}
</pre>  </dd> <dt class="d_decl" id="_popen">nothrow @nogc @trusted FILE* <strong id="_popen">_popen</strong>(R1, R2)(R1 name, R2 mode = "r")<br><small>  Constraints: if ((isInputRange!R1 &amp;&amp; isSomeChar!(ElementEncodingType!R1) || isSomeString!R1) &amp;&amp; (isInputRange!R2 &amp;&amp; isSomeChar!(ElementEncodingType!R2) || isSomeString!R2)); </small>
</dt> <dd>
<p>Convenience function that forwards to <code>core.sys.posix.stdio.popen</code> with appropriately-constructed C-style strings.</p> </dd> <dt class="d_decl" id="lines">struct <strong id="lines">lines</strong>; </dt> <dd>
<p>Iterates through the lines of a file by using <code>foreach</code>. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">void main()
{
  foreach (string line; lines(stdin))
  {
    ... use line ...
  }
}
</pre> The line terminator (<code>'\n'</code> by default) is part of the string read (it could be missing in the last line of the file). Several types are supported for <code>line</code>, and the behavior of <code>lines</code> changes accordingly:  <ol>
<li>If <code>line</code> has type <code>string</code>, <code>wstring</code>, or <code>dstring</code>, a new string of the respective type is allocated every read.</li> <li>If <code>line</code> has type <code>char[]</code>, <code>wchar[]</code>, <code>dchar[]</code>, the line's content will be reused (overwritten) across reads.</li> <li>If <code>line</code> has type <code>immutable(ubyte)[]</code>, the behavior is similar to case (1), except that no UTF checking is attempted upon input.</li> <li>If <code>line</code> has type <code>ubyte[]</code>, the behavior is similar to case (2), except that no UTF checking is attempted upon input.</li>
</ol>  In all cases, a two-symbols versions is also accepted, in which case the first symbol (of integral type, e.g. <code>ulong</code> or <code>uint</code>) tracks the zero-based number of the current line.  <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">  foreach (ulong i, string line; lines(stdin))
  {
    ... use line ...
  }
</pre>  In case of an I/O error, an <code>StdioException</code> is thrown.  <dl>
<dt>See Also:</dt>
<dd><a href="#byLine"><code>byLine</code></a></dd>
</dl> <dl>
<dt class="d_decl" id="lines.this">this(File f, dchar terminator = '\x0a'); </dt> <dd>
<p>Constructor. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>File <code>f</code>
</td> <td>File to read lines from.</td>
</tr> <tr>
<td>dchar <code>terminator</code>
</td> <td>Line separator (<code>'\n'</code> by default).</td>
</tr> </table></dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="chunks">auto <strong id="chunks">chunks</strong>(File f, size_t size); </dt> <dd>
<p>Iterates through a file a chunk at a time by using <code>foreach</code>. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">void main()
{
    foreach (ubyte[] buffer; chunks(stdin, 4096))
    {
        ... use buffer ...
    }
}
</pre>  The content of <code>buffer</code> is reused across calls. In the example above, <code>buffer.length</code> is 4096 for all iterations, except for the last one, in which case <code>buffer.length</code> may be less than 4096 (but always greater than zero).  In case of an I/O error, an <code>StdioException</code> is thrown. </dd> <dt class="d_decl" id="toFile">void <strong id="toFile">toFile</strong>(T)(T data, string fileName)<br><small>  Constraints: if (is(typeof(copy(data, stdout.lockingBinaryWriter)))); </small>
</dt> <dd>
<p>Writes an array or range to a file. Shorthand for <code>data.copy(File(fileName, "wb").lockingBinaryWriter)</code>. Similar to <a href="std_file#write"><code>std.file.write</code></a>, strings are written as-is, rather than encoded according to the <code>File</code>'s <a href="http://en.cppreference.com/w/c/io#Narrow_and_wide_orientation">orientation</a>.</p> </dd> <dt class="d_decl" id="StdioException">class <strong id="StdioException">StdioException</strong>: object.Exception; </dt> <dd>
<p>Thrown if I/O errors happen.</p> <dl>
<dt class="d_decl" id="StdioException.errno">uint <strong id="errno">errno</strong>; </dt> <dd>
<p>Operating system error code.</p> </dd> <dt class="d_decl" id="StdioException.this">@trusted this(string message, uint e = core.stdc.errno.errno); </dt> <dd>
<p>Initialize with a message and an error code.</p> </dd> <dt class="d_decl" id="StdioException.opCall">static void <strong id="opCall">opCall</strong>(string msg); <br><br>static void <strong id="opCall">opCall</strong>(); </dt> <dd>
<p>Convenience functions that throw an <code>StdioException</code>.</p> </dd> </dl> </dd> <dt class="d_decl" id="stdin">alias <strong id="stdin">stdin</strong> = makeGlobal!"core.stdc.stdio.<strong id="stdin">stdin</strong>".makeGlobal; </dt> <dd>
<p>The standard input stream. </p>
<dl>
<dt>Returns:</dt>
<dd>stdin as a <a href="#File"><code>File</code></a>. </dd>
</dl> <dl>
<dt>Note</dt>
<dd> The returned <a href="#File"><code>File</code></a> wraps <a href="core_stdio#stdin"><code>core.stdio.stdin</code></a>, and is therefore thread global. Reassigning <code>stdin</code> to a different <code>File</code> must be done in a single-threaded or locked context in order to avoid race conditions. </dd>
</dl> All reading from <code>stdin</code> automatically locks the file globally, and will cause all other threads calling <code>read</code> to wait until the lock is released. <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">// Read stdin, sort lines, write to stdout
import std.algorithm.mutation : copy;
import std.algorithm.sorting : sort;
import std.array : array;
import std.typecons : Yes;

void main()
{
    stdin                       // read from stdin
    .byLineCopy(Yes.keepTerminator) // copying each line
    .array()                    // convert to array of lines
    .sort()                     // sort the lines
    .copy(                      // copy output of .sort to an OutputRange
        stdout.lockingTextWriter()); // the OutputRange
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="stdout">alias <strong id="stdout">stdout</strong> = makeGlobal!"core.stdc.stdio.<strong id="stdout">stdout</strong>".makeGlobal; </dt> <dd>
<p>The standard output stream. </p>
<dl>
<dt>Returns:</dt>
<dd>stdout as a <a href="#File"><code>File</code></a>. </dd>
</dl> <dl>
<dt>Note</dt>
<dd> The returned <a href="#File"><code>File</code></a> wraps <a href="core_stdio#stdout"><code>core.stdio.stdout</code></a>, and is therefore thread global. Reassigning <code>stdout</code> to a different <code>File</code> must be done in a single-threaded or locked context in order to avoid race conditions. </dd>
</dl> All writing to <code>stdout</code> automatically locks the file globally, and will cause all other threads calling <code>write</code> to wait until the lock is released. <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">void main()
{
    stdout.writeln("Write a message to stdout.");
}
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">void main()
{
    import std.algorithm.iteration : filter, map, sum;
    import std.format : format;
    import std.range : iota, tee;

    int len;
    const r = 6.iota
              .filter!(a =&gt; a % 2) // 1 3 5
              .map!(a =&gt; a * 2) // 2 6 10
              .tee!(_ =&gt; stdout.writefln("len: %d", len++))
              .sum;

    writeln(r); // 18
}
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">void main()
{
    import std.algorithm.mutation : copy;
    import std.algorithm.iteration : map;
    import std.format : format;
    import std.range : iota;

    10.iota
    .map!(e =&gt; "N: %d".format(e))
    .copy(stdout.lockingTextWriter()); // the OutputRange
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="stderr">alias <strong id="stderr">stderr</strong> = makeGlobal!"core.stdc.stdio.<strong id="stderr">stderr</strong>".makeGlobal; </dt> <dd>
<p>The standard error stream. </p>
<dl>
<dt>Returns:</dt>
<dd>stderr as a <a href="#File"><code>File</code></a>. </dd>
</dl> <dl>
<dt>Note</dt>
<dd> The returned <a href="#File"><code>File</code></a> wraps <a href="core_stdio#stderr"><code>core.stdio.stderr</code></a>, and is therefore thread global. Reassigning <code>stderr</code> to a different <code>File</code> must be done in a single-threaded or locked context in order to avoid race conditions. </dd>
</dl> All writing to <code>stderr</code> automatically locks the file globally, and will cause all other threads calling <code>write</code> to wait until the lock is released. <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">void main()
{
    stderr.writeln("Write a message to stderr.");
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="openNetwork">File <strong id="openNetwork">openNetwork</strong>(string host, ushort port); </dt> <dd>
<p>Experimental network access via the File interface </p>
<p>Opens a TCP connection to the given host and port, then returns a File struct with read and write access through the same interface as any other file (meaning writef and the byLine ranges work!). </p> <dl>
<dt>Authors:</dt>
<dd>Adam D. Ruppe </dd>
</dl> <dl>
<dt>Bugs:</dt>
<dd>Only works on Linux</dd>
</dl> </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
    Â© 1999â2019 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_stdio.html" class="_attribution-link">https://dlang.org/phobos/std_stdio.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
