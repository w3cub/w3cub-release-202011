
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>std.datetime.date - D - W3cubDocs</title>
  
  <meta name="description" content=" ">
  <meta name="keywords" content="std, datetime, date, d">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/d/std_datetime_date.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/d.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/d/" class="_nav-link" title="" style="margin-left:0;">D</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _d">
				
				
<h1>std.datetime.date</h1>  <p> </p>
<table>

<tr>
<th scope="col">Category</th> <th scope="col">Functions</th>
</tr> <tr>
<td>Main date types</td> <td> <a href="#Date"><code>Date</code></a> <a href="#DateTime"><code>DateTime</code></a> </td>
</tr> <tr>
<td>Other date types</td> <td> <a href="#Month"><code>Month</code></a> <a href="#DayOfWeek"><code>DayOfWeek</code></a> <a href="#TimeOfDay"><code>TimeOfDay</code></a> </td>
</tr> <tr>
<td>Date checking</td> <td> <a href="#valid"><code>valid</code></a> <a href="#validTimeUnits"><code>validTimeUnits</code></a> <a href="#yearIsLeapYear"><code>yearIsLeapYear</code></a> <a href="#isTimePoint"><code>isTimePoint</code></a> <a href="#enforceValid"><code>enforceValid</code></a> </td>
</tr> <tr>
<td>Date conversion</td> <td> <a href="#daysToDayOfWeek"><code>daysToDayOfWeek</code></a> <a href="#monthsToMonth"><code>monthsToMonth</code></a> </td>
</tr> <tr>
<td>Time units</td> <td> <a href="#cmpTimeUnits"><code>cmpTimeUnits</code></a> <a href="#timeStrings"><code>timeStrings</code></a> </td>
</tr> <tr>
<td>Other</td> <td> <a href="#AllowDayOverflow"><code>AllowDayOverflow</code></a> <a href="#DateTimeException"><code>DateTimeException</code></a> </td>
</tr> </table> 
<dl>
<dt>License:</dt>
<dd>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>
<a href="http://jmdavisprog.com">Jonathan M Davis</a> </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/datetime/date.d">std/datetime/date.d</a></span>
</dd>
</dl> <dl>
<dt class="d_decl" id="DateTimeException">alias <strong id="DateTimeException">DateTimeException</strong> = core.time.TimeException; </dt> <dd>
<p>Exception type used by std.datetime. It's an alias to <a href="core_time#TimeException"><code>core.time.TimeException</code></a>. Either can be caught without concern about which module it came from.</p> </dd> <dt class="d_decl" id="Month">enum <strong id="Month">Month</strong>: ubyte; </dt> <dd>
<p>Represents the 12 months of the Gregorian year (January is 1).</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(Date(2018, 10, 1).month); // Month.oct
writeln(DateTime(1, 1, 1).month); // Month.jan
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="Month.jan"><strong id="jan">jan</strong></dt>  <dt class="d_decl" id="Month.feb"><strong id="feb">feb</strong></dt>  <dt class="d_decl" id="Month.mar"><strong id="mar">mar</strong></dt>  <dt class="d_decl" id="Month.apr"><strong id="apr">apr</strong></dt>  <dt class="d_decl" id="Month.may"><strong id="may">may</strong></dt>  <dt class="d_decl" id="Month.jun"><strong id="jun">jun</strong></dt>  <dt class="d_decl" id="Month.jul"><strong id="jul">jul</strong></dt>  <dt class="d_decl" id="Month.aug"><strong id="aug">aug</strong></dt>  <dt class="d_decl" id="Month.sep"><strong id="sep">sep</strong></dt>  <dt class="d_decl" id="Month.oct"><strong id="oct">oct</strong></dt>  <dt class="d_decl" id="Month.nov"><strong id="nov">nov</strong></dt>  <dt class="d_decl" id="Month.dec"><strong id="dec">dec</strong></dt>  </dl> </dd> <dt class="d_decl" id="DayOfWeek">enum <strong id="DayOfWeek">DayOfWeek</strong>: ubyte; </dt> <dd>
<p>Represents the 7 days of the Gregorian week (Sunday is 0).</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(Date(2018, 10, 1).dayOfWeek); // DayOfWeek.mon
writeln(DateTime(5, 5, 5).dayOfWeek); // DayOfWeek.thu
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="DayOfWeek.sun"><strong id="sun">sun</strong></dt>  <dt class="d_decl" id="DayOfWeek.mon"><strong id="mon">mon</strong></dt>  <dt class="d_decl" id="DayOfWeek.tue"><strong id="tue">tue</strong></dt>  <dt class="d_decl" id="DayOfWeek.wed"><strong id="wed">wed</strong></dt>  <dt class="d_decl" id="DayOfWeek.thu"><strong id="thu">thu</strong></dt>  <dt class="d_decl" id="DayOfWeek.fri"><strong id="fri">fri</strong></dt>  <dt class="d_decl" id="DayOfWeek.sat"><strong id="sat">sat</strong></dt>  </dl> </dd> <dt class="d_decl" id="AllowDayOverflow">alias <strong id="AllowDayOverflow">AllowDayOverflow</strong> = std.typecons.Flag!"allowDayOverflow".Flag; </dt> <dd>
<p>In some date calculations, adding months or years can cause the date to fall on a day of the month which is not valid (e.g. February 29th 2001 or June 31st 2000). If overflow is allowed (as is the default), then the month will be incremented accordingly (so, February 29th 2001 would become March 1st 2001, and June 31st 2000 would become July 1st 2000). If overflow is not allowed, then the day will be adjusted to the last valid day in that month (so, February 29th 2001 would become February 28th 2001 and June 31st 2000 would become June 30th 2000). </p>
<p>AllowDayOverflow only applies to calculations involving months or years. <br><br> If set to <code>AllowDayOverflow.no</code>, then day overflow is not allowed. <br><br> Otherwise, if set to <code>AllowDayOverflow.yes</code>, then day overflow is allowed.</p> </dd> <dt class="d_decl" id="timeStrings">immutable string[] <strong id="timeStrings">timeStrings</strong>; </dt> <dd>
<p>Array of the strings representing time units, starting with the smallest unit and going to the largest. It does not include <code>"nsecs"</code>. </p>
<p>Includes <code>"hnsecs"</code> (hecto-nanoseconds (100 ns)), <code>"usecs"</code> (microseconds), <code>"msecs"</code> (milliseconds), <code>"seconds"</code>, <code>"minutes"</code>, <code>"hours"</code>, <code>"days"</code>, <code>"weeks"</code>, <code>"months"</code>, and <code>"years"</code></p> </dd> <dt class="d_decl" id="DateTime">struct <strong id="DateTime">DateTime</strong>; </dt> <dd>
<p>Combines the <a href="std_datetime_date#Date"><code>std.datetime.date.Date</code></a> and <a href="std_datetime_date#TimeOfDay"><code>std.datetime.date.TimeOfDay</code></a> structs to give an object which holds both the date and the time. It is optimized for calendar-based operations and has no concept of time zone. For an object which is optimized for time operations based on the system time, use <a href="std_datetime_systime#SysTime"><code>std.datetime.systime.SysTime</code></a>. <a href="std_datetime_systime#SysTime"><code>std.datetime.systime.SysTime</code></a> has a concept of time zone and has much higher precision (hnsecs). <code>DateTime</code> is intended primarily for calendar-based uses rather than precise time operations.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import core.time : days, seconds;

auto dt = DateTime(2000, 6, 1, 10, 30, 0);

writeln(dt.date); // Date(2000, 6, 1)
writeln(dt.timeOfDay); // TimeOfDay(10, 30, 0)
writeln(dt.dayOfYear); // 153
writeln(dt.dayOfWeek); // DayOfWeek.thu

dt += 10.days + 100.seconds;
writeln(dt); // DateTime(2000, 6, 11, 10, 31, 40)

writeln(dt.toISOExtString()); // "2000-06-11T10:31:40"
writeln(dt.toISOString()); // "20000611T103140"
writeln(dt.toSimpleString()); // "2000-Jun-11 10:31:40"

writeln(DateTime.fromISOExtString("2018-01-01T12:00:00")); // DateTime(2018, 1, 1, 12, 0, 0)
writeln(DateTime.fromISOString("20180101T120000")); // DateTime(2018, 1, 1, 12, 0, 0)
writeln(DateTime.fromSimpleString("2018-Jan-01 12:00:00")); // DateTime(2018, 1, 1, 12, 0, 0)
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="DateTime.this">pure nothrow @nogc @safe this(Date date, TimeOfDay tod = TimeOfDay.init); </dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Date <code>date</code>
</td> <td>The date portion of <a href="#DateTime"><code>DateTime</code></a>.</td>
</tr> <tr>
<td>TimeOfDay <code>tod</code>
</td> <td>The time portion of <a href="#DateTime"><code>DateTime</code></a>.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="DateTime.this.2">pure @safe this(int year, int month, int day, int hour = 0, int minute = 0, int second = 0); </dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>int <code>year</code>
</td> <td>The year portion of the date.</td>
</tr> <tr>
<td>int <code>month</code>
</td> <td>The month portion of the date (January is 1).</td>
</tr> <tr>
<td>int <code>day</code>
</td> <td>The day portion of the date.</td>
</tr> <tr>
<td>int <code>hour</code>
</td> <td>The hour portion of the time;</td>
</tr> <tr>
<td>int <code>minute</code>
</td> <td>The minute portion of the time;</td>
</tr> <tr>
<td>int <code>second</code>
</td> <td>The second portion of the time;</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="DateTime.opCmp">const pure nothrow @nogc @safe int <strong id="opCmp">opCmp</strong>(DateTime rhs); </dt> <dd>
<p>Compares this <a href="#DateTime"><code>DateTime</code></a> with the given <code>DateTime.</code>. </p>
<dl>
<dt>Returns:</dt>
<dd><table>
 <tr>
<td>this &lt; rhs</td> <td>&lt; 0</td>
</tr> <tr>
<td>this == rhs</td> <td>0</td>
</tr> <tr>
<td>this &gt; rhs</td> <td>&gt; 0</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="DateTime.date">const pure nothrow @nogc @property @safe Date <strong id="date">date</strong>(); </dt> <dd>
<p>The date portion of <a href="#DateTime"><code>DateTime</code></a>.</p> </dd> <dt class="d_decl" id="DateTime.date.2">pure nothrow @nogc @property @safe void <strong id="date">date</strong>(Date <strong id="date">date</strong>); </dt> <dd>
<p>The date portion of <a href="#DateTime"><code>DateTime</code></a>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Date <code>date</code>
</td> <td>The Date to set this <a href="#DateTime"><code>DateTime</code></a>'s date portion to.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="DateTime.timeOfDay">const pure nothrow @nogc @property @safe TimeOfDay <strong id="timeOfDay">timeOfDay</strong>(); </dt> <dd>
<p>The time portion of <a href="#DateTime"><code>DateTime</code></a>.</p> </dd> <dt class="d_decl" id="DateTime.timeOfDay.2">pure nothrow @nogc @property @safe void <strong id="timeOfDay">timeOfDay</strong>(TimeOfDay tod); </dt> <dd>
<p>The time portion of <a href="#DateTime"><code>DateTime</code></a>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TimeOfDay <code>tod</code>
</td> <td>The <a href="std_datetime_date#TimeOfDay"><code>std.datetime.date.TimeOfDay</code></a> to set this <a href="#DateTime"><code>DateTime</code></a>'s time portion to.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="DateTime.year">const pure nothrow @nogc @property @safe short <strong id="year">year</strong>(); </dt> <dd>
<p>Year of the Gregorian Calendar. Positive numbers are A.D. Non-positive are B.C.</p> </dd> <dt class="d_decl" id="DateTime.year.2">pure @property @safe void <strong id="year">year</strong>(int <strong id="year">year</strong>); </dt> <dd>
<p>Year of the Gregorian Calendar. Positive numbers are A.D. Non-positive are B.C. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>int <code>year</code>
</td> <td>The year to set this <a href="#DateTime"><code>DateTime</code></a>'s year to.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the new year is not a leap year and if the resulting date would be on February 29th.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(DateTime(Date(1999, 7, 6), TimeOfDay(9, 7, 5)).year); // 1999
writeln(DateTime(Date(2010, 10, 4), TimeOfDay(0, 0, 30)).year); // 2010
writeln(DateTime(Date(-7, 4, 5), TimeOfDay(7, 45, 2)).year); // -7
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="DateTime.yearBC">const pure @property @safe short <strong id="yearBC">yearBC</strong>(); </dt> <dd>
<p>Year B.C. of the Gregorian Calendar counting year 0 as 1 B.C. </p>
<dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if <code>isAD</code> is true.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(DateTime(Date(0, 1, 1), TimeOfDay(12, 30, 33)).yearBC); // 1
writeln(DateTime(Date(-1, 1, 1), TimeOfDay(10, 7, 2)).yearBC); // 2
writeln(DateTime(Date(-100, 1, 1), TimeOfDay(4, 59, 0)).yearBC); // 101
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="DateTime.yearBC.2">pure @property @safe void <strong id="yearBC">yearBC</strong>(int year); </dt> <dd>
<p>Year B.C. of the Gregorian Calendar counting year 0 as 1 B.C. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>int <code>year</code>
</td> <td>The year B.C. to set this <a href="#DateTime"><code>DateTime</code></a>'s year to.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if a non-positive value is given.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto dt = DateTime(Date(2010, 1, 1), TimeOfDay(7, 30, 0));
dt.yearBC = 1;
writeln(dt); // DateTime(Date(0, 1, 1), TimeOfDay(7, 30, 0))

dt.yearBC = 10;
writeln(dt); // DateTime(Date(-9, 1, 1), TimeOfDay(7, 30, 0))
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="DateTime.month">const pure nothrow @nogc @property @safe Month <strong id="month">month</strong>(); </dt> <dd>
<p>Month of a Gregorian Year.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(DateTime(Date(1999, 7, 6), TimeOfDay(9, 7, 5)).month); // 7
writeln(DateTime(Date(2010, 10, 4), TimeOfDay(0, 0, 30)).month); // 10
writeln(DateTime(Date(-7, 4, 5), TimeOfDay(7, 45, 2)).month); // 4
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="DateTime.month.2">pure @property @safe void <strong id="month">month</strong>(Month <strong id="month">month</strong>); </dt> <dd>
<p>Month of a Gregorian Year. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Month <code>month</code>
</td> <td>The month to set this <a href="#DateTime"><code>DateTime</code></a>'s month to.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given month is not a valid month.</dd>
</dl> </dd> <dt class="d_decl" id="DateTime.day">const pure nothrow @nogc @property @safe ubyte <strong id="day">day</strong>(); </dt> <dd>
<p>Day of a Gregorian Month.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(DateTime(Date(1999, 7, 6), TimeOfDay(9, 7, 5)).day); // 6
writeln(DateTime(Date(2010, 10, 4), TimeOfDay(0, 0, 30)).day); // 4
writeln(DateTime(Date(-7, 4, 5), TimeOfDay(7, 45, 2)).day); // 5
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="DateTime.day.2">pure @property @safe void <strong id="day">day</strong>(int <strong id="day">day</strong>); </dt> <dd>
<p>Day of a Gregorian Month. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>int <code>day</code>
</td> <td>The day of the month to set this <a href="#DateTime"><code>DateTime</code></a>'s day to.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given day is not a valid day of the current month.</dd>
</dl> </dd> <dt class="d_decl" id="DateTime.hour">const pure nothrow @nogc @property @safe ubyte <strong id="hour">hour</strong>(); </dt> <dd>
<p>Hours past midnight.</p> </dd> <dt class="d_decl" id="DateTime.hour.2">pure @property @safe void <strong id="hour">hour</strong>(int <strong id="hour">hour</strong>); </dt> <dd>
<p>Hours past midnight. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>int <code>hour</code>
</td> <td>The hour of the day to set this <a href="#DateTime"><code>DateTime</code></a>'s hour to.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given hour would result in an invalid <a href="#DateTime"><code>DateTime</code></a>.</dd>
</dl> </dd> <dt class="d_decl" id="DateTime.minute">const pure nothrow @nogc @property @safe ubyte <strong id="minute">minute</strong>(); </dt> <dd>
<p>Minutes past the hour.</p> </dd> <dt class="d_decl" id="DateTime.minute.2">pure @property @safe void <strong id="minute">minute</strong>(int <strong id="minute">minute</strong>); </dt> <dd>
<p>Minutes past the hour. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>int <code>minute</code>
</td> <td>The minute to set this <a href="#DateTime"><code>DateTime</code></a>'s minute to.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given minute would result in an invalid <a href="#DateTime"><code>DateTime</code></a>.</dd>
</dl> </dd> <dt class="d_decl" id="DateTime.second">const pure nothrow @nogc @property @safe ubyte <strong id="second">second</strong>(); </dt> <dd>
<p>Seconds past the minute.</p> </dd> <dt class="d_decl" id="DateTime.second.2">pure @property @safe void <strong id="second">second</strong>(int <strong id="second">second</strong>); </dt> <dd>
<p>Seconds past the minute. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>int <code>second</code>
</td> <td>The second to set this <a href="#DateTime"><code>DateTime</code></a>'s second to.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given seconds would result in an invalid <a href="#DateTime"><code>DateTime</code></a>.</dd>
</dl> </dd> <dt class="d_decl" id="DateTime.add">pure nothrow @nogc ref @safe DateTime <strong id="add">add</strong>(string units)(long value, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)<br><small>  Constraints: if (units == "years" || units == "months"); </small>
</dt> <dd>
<p>Adds the given number of years or months to this <a href="#DateTime"><code>DateTime</code></a>, mutating it. A negative number will subtract. </p>
<p>Note that if day overflow is allowed, and the date with the adjusted year/month overflows the number of days in the new month, then the month will be incremented by one, and the day set to the number of days overflowed. (e.g. if the day were 31 and the new month were June, then the month would be incremented to July, and the new day would be 1). If day overflow is not allowed, then the day will be set to the last valid day in the month (e.g. June 31st would become June 30th). </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>units</td> <td>The type of units to add ("years" or "months").</td>
</tr> <tr>
<td>long <code>value</code>
</td> <td>The number of months or years to add to this <a href="#DateTime"><code>DateTime</code></a>.</td>
</tr> <tr>
<td>AllowDayOverflow <code>allowOverflow</code>
</td> <td>Whether the days should be allowed to overflow, causing the month to increment.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A reference to the <code>DateTime</code> (<code>this</code>).</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto dt1 = DateTime(2010, 1, 1, 12, 30, 33);
dt1.add!"months"(11);
writeln(dt1); // DateTime(2010, 12, 1, 12, 30, 33)

auto dt2 = DateTime(2010, 1, 1, 12, 30, 33);
dt2.add!"months"(-11);
writeln(dt2); // DateTime(2009, 2, 1, 12, 30, 33)

auto dt3 = DateTime(2000, 2, 29, 12, 30, 33);
dt3.add!"years"(1);
writeln(dt3); // DateTime(2001, 3, 1, 12, 30, 33)

auto dt4 = DateTime(2000, 2, 29, 12, 30, 33);
dt4.add!"years"(1, AllowDayOverflow.no);
writeln(dt4); // DateTime(2001, 2, 28, 12, 30, 33)
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="DateTime.roll">pure nothrow @nogc ref @safe DateTime <strong id="roll">roll</strong>(string units)(long value, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)<br><small>  Constraints: if (units == "years" || units == "months"); </small>
</dt> <dd>
<p>Adds the given number of years or months to this <a href="#DateTime"><code>DateTime</code></a>, mutating it. A negative number will subtract. </p>
<p>The difference between rolling and adding is that rolling does not affect larger units. Rolling a <a href="#DateTime"><code>DateTime</code></a> 12 months gets the exact same <a href="#DateTime"><code>DateTime</code></a>. However, the days can still be affected due to the differing number of days in each month. <br><br> Because there are no units larger than years, there is no difference between adding and rolling years. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>units</td> <td>The type of units to add ("years" or "months").</td>
</tr> <tr>
<td>long <code>value</code>
</td> <td>The number of months or years to add to this <a href="#DateTime"><code>DateTime</code></a>.</td>
</tr> <tr>
<td>AllowDayOverflow <code>allowOverflow</code>
</td> <td>Whether the days should be allowed to overflow, causing the month to increment.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A reference to the <code>DateTime</code> (<code>this</code>).</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto dt1 = DateTime(2010, 1, 1, 12, 33, 33);
dt1.roll!"months"(1);
writeln(dt1); // DateTime(2010, 2, 1, 12, 33, 33)

auto dt2 = DateTime(2010, 1, 1, 12, 33, 33);
dt2.roll!"months"(-1);
writeln(dt2); // DateTime(2010, 12, 1, 12, 33, 33)

auto dt3 = DateTime(1999, 1, 29, 12, 33, 33);
dt3.roll!"months"(1);
writeln(dt3); // DateTime(1999, 3, 1, 12, 33, 33)

auto dt4 = DateTime(1999, 1, 29, 12, 33, 33);
dt4.roll!"months"(1, AllowDayOverflow.no);
writeln(dt4); // DateTime(1999, 2, 28, 12, 33, 33)

auto dt5 = DateTime(2000, 2, 29, 12, 30, 33);
dt5.roll!"years"(1);
writeln(dt5); // DateTime(2001, 3, 1, 12, 30, 33)

auto dt6 = DateTime(2000, 2, 29, 12, 30, 33);
dt6.roll!"years"(1, AllowDayOverflow.no);
writeln(dt6); // DateTime(2001, 2, 28, 12, 30, 33)
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="DateTime.roll.2">pure nothrow @nogc ref @safe DateTime <strong id="roll">roll</strong>(string units)(long value)<br><small>  Constraints: if (units == "days"); </small><br><br>pure nothrow @nogc ref @safe DateTime <strong id="roll">roll</strong>(string units)(long value)<br><small>  Constraints: if (units == "hours" || units == "minutes" || units == "seconds"); </small>
</dt> <dd>
<p>Adds the given number of units to this <a href="#DateTime"><code>DateTime</code></a>, mutating it. A negative number will subtract. </p>
<p>The difference between rolling and adding is that rolling does not affect larger units. For instance, rolling a <a href="#DateTime"><code>DateTime</code></a> one year's worth of days gets the exact same <a href="#DateTime"><code>DateTime</code></a>. <br><br> Accepted units are <code>"days"</code>, <code>"minutes"</code>, <code>"hours"</code>, <code>"minutes"</code>, and <code>"seconds"</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>units</td> <td>The units to add.</td>
</tr> <tr>
<td>long <code>value</code>
</td> <td>The number of <span class="d_param">units</span> to add to this <a href="#DateTime"><code>DateTime</code></a>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A reference to the <code>DateTime</code> (<code>this</code>).</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto dt1 = DateTime(2010, 1, 1, 11, 23, 12);
dt1.roll!"days"(1);
writeln(dt1); // DateTime(2010, 1, 2, 11, 23, 12)
dt1.roll!"days"(365);
writeln(dt1); // DateTime(2010, 1, 26, 11, 23, 12)
dt1.roll!"days"(-32);
writeln(dt1); // DateTime(2010, 1, 25, 11, 23, 12)

auto dt2 = DateTime(2010, 7, 4, 12, 0, 0);
dt2.roll!"hours"(1);
writeln(dt2); // DateTime(2010, 7, 4, 13, 0, 0)

auto dt3 = DateTime(2010, 1, 1, 0, 0, 0);
dt3.roll!"seconds"(-1);
writeln(dt3); // DateTime(2010, 1, 1, 0, 0, 59)
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="DateTime.Duration">public import core.time : <strong id="Duration">Duration</strong>; </dt>  <dt class="d_decl" id="DateTime.opBinary">const pure nothrow @nogc @safe DateTime <strong id="opBinary">opBinary</strong>(string op)(Duration duration)<br><small>  Constraints: if (op == "+" || op == "-"); </small>
</dt> <dd>
<p>Gives the result of adding or subtracting a <a href="core_time#Duration"><code>core.time.Duration</code></a> from this <a href="#DateTime"><code>DateTime</code></a>. </p>
<p>The legal types of arithmetic for <a href="#DateTime"><code>DateTime</code></a> using this operator are <br><br> </p>
<table>
 <tr>
<td>DateTime</td> <td>+</td> <td>Duration</td> <td>--&gt;</td> <td>DateTime</td>
</tr> <tr>
<td>DateTime</td> <td>-</td> <td>Duration</td> <td>--&gt;</td> <td>DateTime</td>
</tr> </table>  <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Duration <code>duration</code>
</td> <td>The <a href="core_time#Duration"><code>core.time.Duration</code></a> to add to or subtract from this <a href="#DateTime"><code>DateTime</code></a>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import core.time : hours, seconds;

assert(DateTime(2015, 12, 31, 23, 59, 59) + seconds(1) ==
       DateTime(2016, 1, 1, 0, 0, 0));

assert(DateTime(2015, 12, 31, 23, 59, 59) + hours(1) ==
       DateTime(2016, 1, 1, 0, 59, 59));

assert(DateTime(2016, 1, 1, 0, 0, 0) - seconds(1) ==
       DateTime(2015, 12, 31, 23, 59, 59));

assert(DateTime(2016, 1, 1, 0, 59, 59) - hours(1) ==
       DateTime(2015, 12, 31, 23, 59, 59));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="DateTime.opOpAssign">pure nothrow @nogc ref @safe DateTime <strong id="opOpAssign">opOpAssign</strong>(string op)(Duration duration)<br><small>  Constraints: if (op == "+" || op == "-"); </small>
</dt> <dd>
<p>Gives the result of adding or subtracting a duration from this <a href="#DateTime"><code>DateTime</code></a>, as well as assigning the result to this <a href="#DateTime"><code>DateTime</code></a>. </p>
<p>The legal types of arithmetic for <a href="#DateTime"><code>DateTime</code></a> using this operator are <br><br> </p>
<table>
 <tr>
<td>DateTime</td> <td>+</td> <td>duration</td> <td>--&gt;</td> <td>DateTime</td>
</tr> <tr>
<td>DateTime</td> <td>-</td> <td>duration</td> <td>--&gt;</td> <td>DateTime</td>
</tr> </table>  <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Duration <code>duration</code>
</td> <td>The duration to add to or subtract from this <a href="#DateTime"><code>DateTime</code></a>.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="DateTime.opBinary.2">const pure nothrow @nogc @safe Duration <strong id="opBinary">opBinary</strong>(string op)(DateTime rhs)<br><small>  Constraints: if (op == "-"); </small>
</dt> <dd>
<p>Gives the difference between two <a href="#DateTime"><code>DateTime</code></a>s. </p>
<p>The legal types of arithmetic for <a href="#DateTime"><code>DateTime</code></a> using this operator are <br><br> </p>
<table>
 <tr>
<td>DateTime</td> <td>-</td> <td>DateTime</td> <td>--&gt;</td> <td>duration</td>
</tr> </table> </dd> <dt class="d_decl" id="DateTime.diffMonths">const pure nothrow @nogc @safe int <strong id="diffMonths">diffMonths</strong>(DateTime rhs); </dt> <dd>
<p>Returns the difference between the two <a href="#DateTime"><code>DateTime</code></a>s in months. </p>
<p>To get the difference in years, subtract the year property of two <a href="#DateTime"><code>DateTime</code></a>s. To get the difference in days or weeks, subtract the <a href="#DateTime"><code>DateTime</code></a>s themselves and use the <a href="core_time#Duration"><code>core.time.Duration</code></a> that results. Because converting between months and smaller units requires a specific date (which <a href="core_time#Duration"><code>core.time.Duration</code></a>s don't have), getting the difference in months requires some math using both the year and month properties, so this is a convenience function for getting the difference in months. <br><br> Note that the number of days in the months or how far into the month either date is is irrelevant. It is the difference in the month property combined with the difference in years * 12. So, for instance, December 31st and January 1st are one month apart just as December 1st and January 31st are one month apart. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>DateTime <code>rhs</code>
</td> <td>The <a href="#DateTime"><code>DateTime</code></a> to subtract from this one.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(DateTime(1999, 2, 1, 12, 2, 3).diffMonths(
           DateTime(1999, 1, 31, 23, 59, 59)) == 1);

assert(DateTime(1999, 1, 31, 0, 0, 0).diffMonths(
           DateTime(1999, 2, 1, 12, 3, 42)) == -1);

assert(DateTime(1999, 3, 1, 5, 30, 0).diffMonths(
           DateTime(1999, 1, 1, 2, 4, 7)) == 2);

assert(DateTime(1999, 1, 1, 7, 2, 4).diffMonths(
           DateTime(1999, 3, 31, 0, 30, 58)) == -2);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="DateTime.isLeapYear">const pure nothrow @nogc @property @safe bool <strong id="isLeapYear">isLeapYear</strong>(); </dt> <dd>
<p>Whether this <a href="#DateTime"><code>DateTime</code></a> is in a leap year.</p> </dd> <dt class="d_decl" id="DateTime.dayOfWeek">const pure nothrow @nogc @property @safe DayOfWeek <strong id="dayOfWeek">dayOfWeek</strong>(); </dt> <dd>
<p>Day of the week this <a href="#DateTime"><code>DateTime</code></a> is on.</p> </dd> <dt class="d_decl" id="DateTime.dayOfYear">const pure nothrow @nogc @property @safe ushort <strong id="dayOfYear">dayOfYear</strong>(); </dt> <dd>
<p>Day of the year this <a href="#DateTime"><code>DateTime</code></a> is on.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(DateTime(Date(1999, 1, 1), TimeOfDay(12, 22, 7)).dayOfYear); // 1
writeln(DateTime(Date(1999, 12, 31), TimeOfDay(7, 2, 59)).dayOfYear); // 365
writeln(DateTime(Date(2000, 12, 31), TimeOfDay(21, 20, 0)).dayOfYear); // 366
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="DateTime.dayOfYear.2">pure @property @safe void <strong id="dayOfYear">dayOfYear</strong>(int day); </dt> <dd>
<p>Day of the year. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>int <code>day</code>
</td> <td>The day of the year to set which day of the year this <a href="#DateTime"><code>DateTime</code></a> is on.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="DateTime.dayOfGregorianCal">const pure nothrow @nogc @property @safe int <strong id="dayOfGregorianCal">dayOfGregorianCal</strong>(); </dt> <dd>
<p>The Xth day of the Gregorian Calendar that this <a href="#DateTime"><code>DateTime</code></a> is on.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(DateTime(Date(1, 1, 1), TimeOfDay(0, 0, 0)).dayOfGregorianCal); // 1
writeln(DateTime(Date(1, 12, 31), TimeOfDay(23, 59, 59)).dayOfGregorianCal); // 365
writeln(DateTime(Date(2, 1, 1), TimeOfDay(2, 2, 2)).dayOfGregorianCal); // 366

writeln(DateTime(Date(0, 12, 31), TimeOfDay(7, 7, 7)).dayOfGregorianCal); // 0
writeln(DateTime(Date(0, 1, 1), TimeOfDay(19, 30, 0)).dayOfGregorianCal); // -365
writeln(DateTime(Date(-1, 12, 31), TimeOfDay(4, 7, 0)).dayOfGregorianCal); // -366

writeln(DateTime(Date(2000, 1, 1), TimeOfDay(9, 30, 20)).dayOfGregorianCal); // 730_120
writeln(DateTime(Date(2010, 12, 31), TimeOfDay(15, 45, 50)).dayOfGregorianCal); // 734_137
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="DateTime.dayOfGregorianCal.2">pure nothrow @nogc @property @safe void <strong id="dayOfGregorianCal">dayOfGregorianCal</strong>(int days); </dt> <dd>
<p>The Xth day of the Gregorian Calendar that this <a href="#DateTime"><code>DateTime</code></a> is on. Setting this property does not affect the time portion of <a href="#DateTime"><code>DateTime</code></a>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>int <code>days</code>
</td> <td>The day of the Gregorian Calendar to set this <a href="#DateTime"><code>DateTime</code></a> to.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto dt = DateTime(Date.init, TimeOfDay(12, 0, 0));
dt.dayOfGregorianCal = 1;
writeln(dt); // DateTime(Date(1, 1, 1), TimeOfDay(12, 0, 0))

dt.dayOfGregorianCal = 365;
writeln(dt); // DateTime(Date(1, 12, 31), TimeOfDay(12, 0, 0))

dt.dayOfGregorianCal = 366;
writeln(dt); // DateTime(Date(2, 1, 1), TimeOfDay(12, 0, 0))

dt.dayOfGregorianCal = 0;
writeln(dt); // DateTime(Date(0, 12, 31), TimeOfDay(12, 0, 0))

dt.dayOfGregorianCal = -365;
writeln(dt); // DateTime(Date(-0, 1, 1), TimeOfDay(12, 0, 0))

dt.dayOfGregorianCal = -366;
writeln(dt); // DateTime(Date(-1, 12, 31), TimeOfDay(12, 0, 0))

dt.dayOfGregorianCal = 730_120;
writeln(dt); // DateTime(Date(2000, 1, 1), TimeOfDay(12, 0, 0))

dt.dayOfGregorianCal = 734_137;
writeln(dt); // DateTime(Date(2010, 12, 31), TimeOfDay(12, 0, 0))
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="DateTime.isoWeek">const pure nothrow @property @safe ubyte <strong id="isoWeek">isoWeek</strong>(); </dt> <dd>
<p>The ISO 8601 week of the year that this <a href="#DateTime"><code>DateTime</code></a> is in. </p>
<dl>
<dt>See Also:</dt>
<dd><a href="http://en.wikipedia.org/wiki/ISO_week_date">ISO Week Date</a></dd>
</dl> </dd> <dt class="d_decl" id="DateTime.endOfMonth">const pure nothrow @property @safe DateTime <strong id="endOfMonth">endOfMonth</strong>(); </dt> <dd>
<p><a href="#DateTime"><code>DateTime</code></a> for the last day in the month that this <a href="#DateTime"><code>DateTime</code></a> is in. The time portion of endOfMonth is always 23:59:59.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(DateTime(Date(1999, 1, 6), TimeOfDay(0, 0, 0)).endOfMonth ==
       DateTime(Date(1999, 1, 31), TimeOfDay(23, 59, 59)));

assert(DateTime(Date(1999, 2, 7), TimeOfDay(19, 30, 0)).endOfMonth ==
       DateTime(Date(1999, 2, 28), TimeOfDay(23, 59, 59)));

assert(DateTime(Date(2000, 2, 7), TimeOfDay(5, 12, 27)).endOfMonth ==
       DateTime(Date(2000, 2, 29), TimeOfDay(23, 59, 59)));

assert(DateTime(Date(2000, 6, 4), TimeOfDay(12, 22, 9)).endOfMonth ==
       DateTime(Date(2000, 6, 30), TimeOfDay(23, 59, 59)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="DateTime.daysInMonth">const pure nothrow @nogc @property @safe ubyte <strong id="daysInMonth">daysInMonth</strong>(); </dt> <dd>
<p>The last day in the month that this <a href="#DateTime"><code>DateTime</code></a> is in.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(DateTime(Date(1999, 1, 6), TimeOfDay(0, 0, 0)).daysInMonth); // 31
writeln(DateTime(Date(1999, 2, 7), TimeOfDay(19, 30, 0)).daysInMonth); // 28
writeln(DateTime(Date(2000, 2, 7), TimeOfDay(5, 12, 27)).daysInMonth); // 29
writeln(DateTime(Date(2000, 6, 4), TimeOfDay(12, 22, 9)).daysInMonth); // 30
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="DateTime.isAD">const pure nothrow @nogc @property @safe bool <strong id="isAD">isAD</strong>(); </dt> <dd>
<p>Whether the current year is a date in A.D.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(DateTime(Date(1, 1, 1), TimeOfDay(12, 7, 0)).isAD);
assert(DateTime(Date(2010, 12, 31), TimeOfDay(0, 0, 0)).isAD);
assert(!DateTime(Date(0, 12, 31), TimeOfDay(23, 59, 59)).isAD);
assert(!DateTime(Date(-2010, 1, 1), TimeOfDay(2, 2, 2)).isAD);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="DateTime.julianDay">const pure nothrow @nogc @property @safe long <strong id="julianDay">julianDay</strong>(); </dt> <dd>
<p>The <a href="http://en.wikipedia.org/wiki/Julian_day">Julian day</a> for this <a href="#DateTime"><code>DateTime</code></a> at the given time. For example, prior to noon, 1996-03-31 would be the Julian day number 2_450_173, so this function returns 2_450_173, while from noon onward, the julian day number would be 2_450_174, so this function returns 2_450_174.</p> </dd> <dt class="d_decl" id="DateTime.modJulianDay">const pure nothrow @nogc @property @safe long <strong id="modJulianDay">modJulianDay</strong>(); </dt> <dd>
<p>The modified <a href="http://en.wikipedia.org/wiki/Julian_day">Julian day</a> for any time on this date (since, the modified Julian day changes at midnight).</p> </dd> <dt class="d_decl" id="DateTime.toISOString">const pure nothrow @safe string <strong id="toISOString">toISOString</strong>(); <br><br>const void <strong id="toISOString">toISOString</strong>(W)(ref W writer)<br><small>  Constraints: if (isOutputRange!(W, char)); </small>
</dt> <dd>
<p>Converts this <a href="#DateTime"><code>DateTime</code></a> to a string with the format <code>YYYYMMDDTHHMMSS</code>. If <code>writer</code> is set, the resulting string will be written directly to it. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>W <code>writer</code>
</td> <td>A <code>char</code> accepting <a href="std_range_primitives#isOutputRange">output range</a>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A <code>string</code> when not using an output range; <code>void</code> otherwise.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)).toISOString() ==
       "20100704T070612");

assert(DateTime(Date(1998, 12, 25), TimeOfDay(2, 15, 0)).toISOString() ==
       "19981225T021500");

assert(DateTime(Date(0, 1, 5), TimeOfDay(23, 9, 59)).toISOString() ==
       "00000105T230959");

assert(DateTime(Date(-4, 1, 5), TimeOfDay(0, 0, 2)).toISOString() ==
       "-00040105T000002");
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="DateTime.toISOExtString">const pure nothrow @safe string <strong id="toISOExtString">toISOExtString</strong>(); <br><br>const void <strong id="toISOExtString">toISOExtString</strong>(W)(ref W writer)<br><small>  Constraints: if (isOutputRange!(W, char)); </small>
</dt> <dd>
<p>Converts this <a href="#DateTime"><code>DateTime</code></a> to a string with the format <code>YYYY-MM-DDTHH:MM:SS</code>. If <code>writer</code> is set, the resulting string will be written directly to it. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>W <code>writer</code>
</td> <td>A <code>char</code> accepting <a href="std_range_primitives#isOutputRange">output range</a>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A <code>string</code> when not using an output range; <code>void</code> otherwise.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)).toISOExtString() ==
       "2010-07-04T07:06:12");

assert(DateTime(Date(1998, 12, 25), TimeOfDay(2, 15, 0)).toISOExtString() ==
       "1998-12-25T02:15:00");

assert(DateTime(Date(0, 1, 5), TimeOfDay(23, 9, 59)).toISOExtString() ==
       "0000-01-05T23:09:59");

assert(DateTime(Date(-4, 1, 5), TimeOfDay(0, 0, 2)).toISOExtString() ==
       "-0004-01-05T00:00:02");
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="DateTime.toSimpleString">const pure nothrow @safe string <strong id="toSimpleString">toSimpleString</strong>(); <br><br>const void <strong id="toSimpleString">toSimpleString</strong>(W)(ref W writer)<br><small>  Constraints: if (isOutputRange!(W, char)); </small>
</dt> <dd>
<p>Converts this <a href="#DateTime"><code>DateTime</code></a> to a string with the format <code>YYYY-Mon-DD HH:MM:SS</code>. If <code>writer</code> is set, the resulting string will be written directly to it. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>W <code>writer</code>
</td> <td>A <code>char</code> accepting <a href="std_range_primitives#isOutputRange">output range</a>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A <code>string</code> when not using an output range; <code>void</code> otherwise.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)).toSimpleString() ==
       "2010-Jul-04 07:06:12");

assert(DateTime(Date(1998, 12, 25), TimeOfDay(2, 15, 0)).toSimpleString() ==
       "1998-Dec-25 02:15:00");

assert(DateTime(Date(0, 1, 5), TimeOfDay(23, 9, 59)).toSimpleString() ==
       "0000-Jan-05 23:09:59");

assert(DateTime(Date(-4, 1, 5), TimeOfDay(0, 0, 2)).toSimpleString() ==
       "-0004-Jan-05 00:00:02");
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="DateTime.toString">const pure nothrow @safe string <strong id="toString">toString</strong>(); <br><br>const void <strong id="toString">toString</strong>(W)(ref W writer)<br><small>  Constraints: if (isOutputRange!(W, char)); </small>
</dt> <dd>
<p>Converts this <a href="#DateTime"><code>DateTime</code></a> to a string. </p>
<p>This function exists to make it easy to convert a <a href="#DateTime"><code>DateTime</code></a> to a string for code that does not care what the exact format is - just that it presents the information in a clear manner. It also makes it easy to simply convert a <a href="#DateTime"><code>DateTime</code></a> to a string when using functions such as <code>to!string</code>, <code>format</code>, or <code>writeln</code> which use toString to convert user-defined types. So, it is unlikely that much code will call toString directly. <br><br> The format of the string is purposefully unspecified, and code that cares about the format of the string should use <code>toISOString</code>, <code>toISOExtString</code>, <code>toSimpleString</code>, or some other custom formatting function that explicitly generates the format that the code needs. The reason is that the code is then clear about what format it's using, making it less error-prone to maintain the code and interact with other software that consumes the generated strings. It's for this same reason that <a href="#DateTime"><code>DateTime</code></a> has no <code>fromString</code> function, whereas it does have <code>fromISOString</code>, <code>fromISOExtString</code>, and <code>fromSimpleString</code>. <br><br> The format returned by toString may or may not change in the future.</p> </dd> <dt class="d_decl" id="DateTime.fromISOString">pure @safe DateTime <strong id="fromISOString">fromISOString</strong>(S)(scope const S isoString)<br><small>  Constraints: if (isSomeString!S); </small>
</dt> <dd>
<p>Creates a <a href="#DateTime"><code>DateTime</code></a> from a string with the format YYYYMMDDTHHMMSS. Whitespace is stripped from the given string. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S <code>isoString</code>
</td> <td>A string formatted in the ISO format for dates and times.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given string is not in the ISO format or if the resulting <a href="#DateTime"><code>DateTime</code></a> would not be valid.</dd>
</dl> </dd> <dt class="d_decl" id="DateTime.fromISOExtString">pure @safe DateTime <strong id="fromISOExtString">fromISOExtString</strong>(S)(scope const S isoExtString)<br><small>  Constraints: if (isSomeString!S); </small>
</dt> <dd>
<p>Creates a <a href="#DateTime"><code>DateTime</code></a> from a string with the format YYYY-MM-DDTHH:MM:SS. Whitespace is stripped from the given string. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S <code>isoExtString</code>
</td> <td>A string formatted in the ISO Extended format for dates and times.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given string is not in the ISO Extended format or if the resulting <a href="#DateTime"><code>DateTime</code></a> would not be valid.</dd>
</dl> </dd> <dt class="d_decl" id="DateTime.fromSimpleString">pure @safe DateTime <strong id="fromSimpleString">fromSimpleString</strong>(S)(scope const S simpleString)<br><small>  Constraints: if (isSomeString!S); </small>
</dt> <dd>
<p>Creates a <a href="#DateTime"><code>DateTime</code></a> from a string with the format YYYY-Mon-DD HH:MM:SS. Whitespace is stripped from the given string. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S <code>simpleString</code>
</td> <td>A string formatted in the way that toSimpleString formats dates and times.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given string is not in the correct format or if the resulting <a href="#DateTime"><code>DateTime</code></a> would not be valid.</dd>
</dl> </dd> <dt class="d_decl" id="DateTime.min">static pure nothrow @nogc @property @safe DateTime <strong id="min">min</strong>(); </dt> <dd>
<p>Returns the <a href="#DateTime"><code>DateTime</code></a> farthest in the past which is representable by <a href="#DateTime"><code>DateTime</code></a>.</p> </dd> <dt class="d_decl" id="DateTime.max">static pure nothrow @nogc @property @safe DateTime <strong id="max">max</strong>(); </dt> <dd>
<p>Returns the <a href="#DateTime"><code>DateTime</code></a> farthest in the future which is representable by <a href="#DateTime"><code>DateTime</code></a>.</p> </dd> </dl> </dd> <dt class="d_decl" id="Date">struct <strong id="Date">Date</strong>; </dt> <dd>
<p>Represents a date in the <a href="http://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar">Proleptic Gregorian Calendar</a> ranging from 32,768 B.C. to 32,767 A.D. Positive years are A.D. Non-positive years are B.C. </p>
<p>Year, month, and day are kept separately internally so that <code>Date</code> is optimized for calendar-based operations. <br><br> <code>Date</code> uses the Proleptic Gregorian Calendar, so it assumes the Gregorian leap year calculations for its entire length. As per <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a>, it treats 1 B.C. as year 0, i.e. 1 B.C. is 0, 2 B.C. is -1, etc. Use <a href="#yearBC"><code>yearBC</code></a> to use B.C. as a positive integer with 1 B.C. being the year prior to 1 A.D. <br><br> Year 0 is a leap year.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import core.time : days;

auto d = Date(2000, 6, 1);

writeln(d.dayOfYear); // 153
writeln(d.dayOfWeek); // DayOfWeek.thu

d += 10.days;
writeln(d); // Date(2000, 6, 11)

writeln(d.toISOExtString()); // "2000-06-11"
writeln(d.toISOString()); // "20000611"
writeln(d.toSimpleString()); // "2000-Jun-11"

writeln(Date.fromISOExtString("2018-01-01")); // Date(2018, 1, 1)
writeln(Date.fromISOString("20180101")); // Date(2018, 1, 1)
writeln(Date.fromSimpleString("2018-Jan-01")); // Date(2018, 1, 1)
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="Date.this">pure @safe this(int year, int month, int day); </dt> <dd>
<dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the resulting <a href="#Date"><code>Date</code></a> would not be valid. </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>int <code>year</code>
</td> <td>Year of the Gregorian Calendar. Positive values are A.D. Non-positive values are B.C. with year 0 being the year prior to 1 A.D.</td>
</tr> <tr>
<td>int <code>month</code>
</td> <td>Month of the year (January is 1).</td>
</tr> <tr>
<td>int <code>day</code>
</td> <td>Day of the month.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Date.this.2">pure nothrow @nogc @safe this(int day); </dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>int <code>day</code>
</td> <td>The Xth day of the Gregorian Calendar that the constructed <a href="#Date"><code>Date</code></a> will be for.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Date.opCmp">const pure nothrow @nogc @safe int <strong id="opCmp">opCmp</strong>(Date rhs); </dt> <dd>
<p>Compares this <a href="#Date"><code>Date</code></a> with the given <a href="#Date"><code>Date</code></a>. </p>
<dl>
<dt>Returns:</dt>
<dd><table>
 <tr>
<td>this &lt; rhs</td> <td>&lt; 0</td>
</tr> <tr>
<td>this == rhs</td> <td>0</td>
</tr> <tr>
<td>this &gt; rhs</td> <td>&gt; 0</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Date.year">const pure nothrow @nogc @property @safe short <strong id="year">year</strong>(); </dt> <dd>
<p>Year of the Gregorian Calendar. Positive numbers are A.D. Non-positive are B.C.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(Date(1999, 7, 6).year); // 1999
writeln(Date(2010, 10, 4).year); // 2010
writeln(Date(-7, 4, 5).year); // -7
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Date.year.2">pure @property @safe void <strong id="year">year</strong>(int <strong id="year">year</strong>); </dt> <dd>
<p>Year of the Gregorian Calendar. Positive numbers are A.D. Non-positive are B.C. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>int <code>year</code>
</td> <td>The year to set this Date's year to.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the new year is not a leap year and the resulting date would be on February 29th.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(Date(1999, 7, 6).year); // 1999
writeln(Date(2010, 10, 4).year); // 2010
writeln(Date(-7, 4, 5).year); // -7
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Date.yearBC">const pure @property @safe ushort <strong id="yearBC">yearBC</strong>(); </dt> <dd>
<p>Year B.C. of the Gregorian Calendar counting year 0 as 1 B.C. </p>
<dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if <code>isAD</code> is true.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(Date(0, 1, 1).yearBC); // 1
writeln(Date(-1, 1, 1).yearBC); // 2
writeln(Date(-100, 1, 1).yearBC); // 101
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Date.yearBC.2">pure @property @safe void <strong id="yearBC">yearBC</strong>(int year); </dt> <dd>
<p>Year B.C. of the Gregorian Calendar counting year 0 as 1 B.C. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>int <code>year</code>
</td> <td>The year B.C. to set this <a href="#Date"><code>Date</code></a>'s year to.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if a non-positive value is given.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto date = Date(2010, 1, 1);
date.yearBC = 1;
writeln(date); // Date(0, 1, 1)

date.yearBC = 10;
writeln(date); // Date(-9, 1, 1)
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Date.month">const pure nothrow @nogc @property @safe Month <strong id="month">month</strong>(); </dt> <dd>
<p>Month of a Gregorian Year.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(Date(1999, 7, 6).month); // 7
writeln(Date(2010, 10, 4).month); // 10
writeln(Date(-7, 4, 5).month); // 4
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Date.month.2">pure @property @safe void <strong id="month">month</strong>(Month <strong id="month">month</strong>); </dt> <dd>
<p>Month of a Gregorian Year. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Month <code>month</code>
</td> <td>The month to set this <a href="#Date"><code>Date</code></a>'s month to.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given month is not a valid month or if the current day would not be valid in the given month.</dd>
</dl> </dd> <dt class="d_decl" id="Date.day">const pure nothrow @nogc @property @safe ubyte <strong id="day">day</strong>(); </dt> <dd>
<p>Day of a Gregorian Month.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(Date(1999, 7, 6).day); // 6
writeln(Date(2010, 10, 4).day); // 4
writeln(Date(-7, 4, 5).day); // 5
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Date.day.2">pure @property @safe void <strong id="day">day</strong>(int <strong id="day">day</strong>); </dt> <dd>
<p>Day of a Gregorian Month. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>int <code>day</code>
</td> <td>The day of the month to set this <a href="#Date"><code>Date</code></a>'s day to.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given day is not a valid day of the current month.</dd>
</dl> </dd> <dt class="d_decl" id="Date.add">pure nothrow @nogc ref @safe Date <strong id="add">add</strong>(string units)(long value, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)<br><small>  Constraints: if (units == "years"); </small>
</dt> <dd>
<p>Adds the given number of years or months to this <a href="#Date"><code>Date</code></a>, mutating it. A negative number will subtract. </p>
<p>Note that if day overflow is allowed, and the date with the adjusted year/month overflows the number of days in the new month, then the month will be incremented by one, and the day set to the number of days overflowed. (e.g. if the day were 31 and the new month were June, then the month would be incremented to July, and the new day would be 1). If day overflow is not allowed, then the day will be set to the last valid day in the month (e.g. June 31st would become June 30th). </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>units</td> <td>The type of units to add ("years" or "months").</td>
</tr> <tr>
<td>long <code>value</code>
</td> <td>The number of months or years to add to this <a href="#Date"><code>Date</code></a>.</td>
</tr> <tr>
<td>AllowDayOverflow <code>allowOverflow</code>
</td> <td>Whether the day should be allowed to overflow, causing the month to increment.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A reference to the <code>Date</code> (<code>this</code>).</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto d1 = Date(2010, 1, 1);
d1.add!"months"(11);
writeln(d1); // Date(2010, 12, 1)

auto d2 = Date(2010, 1, 1);
d2.add!"months"(-11);
writeln(d2); // Date(2009, 2, 1)

auto d3 = Date(2000, 2, 29);
d3.add!"years"(1);
writeln(d3); // Date(2001, 3, 1)

auto d4 = Date(2000, 2, 29);
d4.add!"years"(1, AllowDayOverflow.no);
writeln(d4); // Date(2001, 2, 28)
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Date.roll">pure nothrow @nogc ref @safe Date <strong id="roll">roll</strong>(string units)(long value, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)<br><small>  Constraints: if (units == "years"); </small>
</dt> <dd>
<p>Adds the given number of years or months to this <a href="#Date"><code>Date</code></a>, mutating it. A negative number will subtract. </p>
<p>The difference between rolling and adding is that rolling does not affect larger units. Rolling a <a href="#Date"><code>Date</code></a> 12 months gets the exact same <a href="#Date"><code>Date</code></a>. However, the days can still be affected due to the differing number of days in each month. <br><br> Because there are no units larger than years, there is no difference between adding and rolling years. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>units</td> <td>The type of units to add ("years" or "months").</td>
</tr> <tr>
<td>long <code>value</code>
</td> <td>The number of months or years to add to this <a href="#Date"><code>Date</code></a>.</td>
</tr> <tr>
<td>AllowDayOverflow <code>allowOverflow</code>
</td> <td>Whether the day should be allowed to overflow, causing the month to increment.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A reference to the <code>Date</code> (<code>this</code>).</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto d1 = Date(2010, 1, 1);
d1.roll!"months"(1);
writeln(d1); // Date(2010, 2, 1)

auto d2 = Date(2010, 1, 1);
d2.roll!"months"(-1);
writeln(d2); // Date(2010, 12, 1)

auto d3 = Date(1999, 1, 29);
d3.roll!"months"(1);
writeln(d3); // Date(1999, 3, 1)

auto d4 = Date(1999, 1, 29);
d4.roll!"months"(1, AllowDayOverflow.no);
writeln(d4); // Date(1999, 2, 28)

auto d5 = Date(2000, 2, 29);
d5.roll!"years"(1);
writeln(d5); // Date(2001, 3, 1)

auto d6 = Date(2000, 2, 29);
d6.roll!"years"(1, AllowDayOverflow.no);
writeln(d6); // Date(2001, 2, 28)
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Date.roll.2">pure nothrow @nogc ref @safe Date <strong id="roll">roll</strong>(string units)(long days)<br><small>  Constraints: if (units == "days"); </small>
</dt> <dd>
<p>Adds the given number of units to this <a href="#Date"><code>Date</code></a>, mutating it. A negative number will subtract. </p>
<p>The difference between rolling and adding is that rolling does not affect larger units. For instance, rolling a <a href="#Date"><code>Date</code></a> one year's worth of days gets the exact same <a href="#Date"><code>Date</code></a>. <br><br> The only accepted units are <code>"days"</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>units</td> <td>The units to add. Must be <code>"days"</code>.</td>
</tr> <tr>
<td>long <code>days</code>
</td> <td>The number of days to add to this <a href="#Date"><code>Date</code></a>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A reference to the <code>Date</code> (<code>this</code>).</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto d = Date(2010, 1, 1);
d.roll!"days"(1);
writeln(d); // Date(2010, 1, 2)
d.roll!"days"(365);
writeln(d); // Date(2010, 1, 26)
d.roll!"days"(-32);
writeln(d); // Date(2010, 1, 25)
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Date.Duration">public import core.time : <strong id="Duration">Duration</strong>; </dt>  <dt class="d_decl" id="Date.opBinary">const pure nothrow @nogc @safe Date <strong id="opBinary">opBinary</strong>(string op)(Duration duration)<br><small>  Constraints: if (op == "+" || op == "-"); </small>
</dt> <dd>
<p>Gives the result of adding or subtracting a <a href="core_time#Duration"><code>core.time.Duration</code></a> from </p>
<p>The legal types of arithmetic for <a href="#Date"><code>Date</code></a> using this operator are <br><br> </p>
<table>
 <tr>
<td>Date</td> <td>+</td> <td>Duration</td> <td>--&gt;</td> <td>Date</td>
</tr> <tr>
<td>Date</td> <td>-</td> <td>Duration</td> <td>--&gt;</td> <td>Date</td>
</tr> </table>  <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Duration <code>duration</code>
</td> <td>The <a href="core_time#Duration"><code>core.time.Duration</code></a> to add to or subtract from this <a href="#Date"><code>Date</code></a>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import core.time : days;

writeln(Date(2015, 12, 31) + days(1)); // Date(2016, 1, 1)
writeln(Date(2004, 2, 26) + days(4)); // Date(2004, 3, 1)

writeln(Date(2016, 1, 1) - days(1)); // Date(2015, 12, 31)
writeln(Date(2004, 3, 1) - days(4)); // Date(2004, 2, 26)
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Date.opOpAssign">pure nothrow @nogc ref @safe Date <strong id="opOpAssign">opOpAssign</strong>(string op)(Duration duration)<br><small>  Constraints: if (op == "+" || op == "-"); </small>
</dt> <dd>
<p>Gives the result of adding or subtracting a <a href="core_time#Duration"><code>core.time.Duration</code></a> from this <a href="#Date"><code>Date</code></a>, as well as assigning the result to this <a href="#Date"><code>Date</code></a>. </p>
<p>The legal types of arithmetic for <a href="#Date"><code>Date</code></a> using this operator are <br><br> </p>
<table>
 <tr>
<td>Date</td> <td>+</td> <td>Duration</td> <td>--&gt;</td> <td>Date</td>
</tr> <tr>
<td>Date</td> <td>-</td> <td>Duration</td> <td>--&gt;</td> <td>Date</td>
</tr> </table>  <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Duration <code>duration</code>
</td> <td>The <a href="core_time#Duration"><code>core.time.Duration</code></a> to add to or subtract from this <a href="#Date"><code>Date</code></a>.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Date.opBinary.2">const pure nothrow @nogc @safe Duration <strong id="opBinary">opBinary</strong>(string op)(Date rhs)<br><small>  Constraints: if (op == "-"); </small>
</dt> <dd>
<p>Gives the difference between two <a href="#Date"><code>Date</code></a>s. </p>
<p>The legal types of arithmetic for <a href="#Date"><code>Date</code></a> using this operator are <br><br> </p>
<table>
 <tr>
<td>Date</td> <td>-</td> <td>Date</td> <td>--&gt;</td> <td>duration</td>
</tr> </table> </dd> <dt class="d_decl" id="Date.diffMonths">const pure nothrow @nogc @safe int <strong id="diffMonths">diffMonths</strong>(Date rhs); </dt> <dd>
<p>Returns the difference between the two <a href="#Date"><code>Date</code></a>s in months. </p>
<p>To get the difference in years, subtract the year property of two <a href="#Date"><code>Date</code></a>s. To get the difference in days or weeks, subtract the <a href="#Date"><code>Date</code></a>s themselves and use the <a href="core_time#Duration"><code>core.time.Duration</code></a> that results. Because converting between months and smaller units requires a specific date (which <a href="core_time#Duration"><code>core.time.Duration</code></a>s don't have), getting the difference in months requires some math using both the year and month properties, so this is a convenience function for getting the difference in months. <br><br> Note that the number of days in the months or how far into the month either <a href="#Date"><code>Date</code></a> is is irrelevant. It is the difference in the month property combined with the difference in years * 12. So, for instance, December 31st and January 1st are one month apart just as December 1st and January 31st are one month apart. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Date <code>rhs</code>
</td> <td>The <a href="#Date"><code>Date</code></a> to subtract from this one.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(Date(1999, 2, 1).diffMonths(Date(1999, 1, 31))); // 1
writeln(Date(1999, 1, 31).diffMonths(Date(1999, 2, 1))); // -1
writeln(Date(1999, 3, 1).diffMonths(Date(1999, 1, 1))); // 2
writeln(Date(1999, 1, 1).diffMonths(Date(1999, 3, 31))); // -2
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Date.isLeapYear">const pure nothrow @nogc @property @safe bool <strong id="isLeapYear">isLeapYear</strong>(); </dt> <dd>
<p>Whether this <a href="#Date"><code>Date</code></a> is in a leap year.</p> </dd> <dt class="d_decl" id="Date.dayOfWeek">const pure nothrow @nogc @property @safe DayOfWeek <strong id="dayOfWeek">dayOfWeek</strong>(); </dt> <dd>
<p>Day of the week this <a href="#Date"><code>Date</code></a> is on.</p> </dd> <dt class="d_decl" id="Date.dayOfYear">const pure nothrow @nogc @property @safe ushort <strong id="dayOfYear">dayOfYear</strong>(); </dt> <dd>
<p>Day of the year this <a href="#Date"><code>Date</code></a> is on.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(Date(1999, 1, 1).dayOfYear); // 1
writeln(Date(1999, 12, 31).dayOfYear); // 365
writeln(Date(2000, 12, 31).dayOfYear); // 366
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Date.dayOfYear.2">pure @property @safe void <strong id="dayOfYear">dayOfYear</strong>(int day); </dt> <dd>
<p>Day of the year. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>int <code>day</code>
</td> <td>The day of the year to set which day of the year this <a href="#Date"><code>Date</code></a> is on.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given day is an invalid day of the year.</dd>
</dl> </dd> <dt class="d_decl" id="Date.dayOfGregorianCal">const pure nothrow @nogc @property @safe int <strong id="dayOfGregorianCal">dayOfGregorianCal</strong>(); </dt> <dd>
<p>The Xth day of the Gregorian Calendar that this <a href="#Date"><code>Date</code></a> is on.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(Date(1, 1, 1).dayOfGregorianCal); // 1
writeln(Date(1, 12, 31).dayOfGregorianCal); // 365
writeln(Date(2, 1, 1).dayOfGregorianCal); // 366

writeln(Date(0, 12, 31).dayOfGregorianCal); // 0
writeln(Date(0, 1, 1).dayOfGregorianCal); // -365
writeln(Date(-1, 12, 31).dayOfGregorianCal); // -366

writeln(Date(2000, 1, 1).dayOfGregorianCal); // 730_120
writeln(Date(2010, 12, 31).dayOfGregorianCal); // 734_137
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Date.dayOfGregorianCal.2">pure nothrow @nogc @property @safe void <strong id="dayOfGregorianCal">dayOfGregorianCal</strong>(int day); </dt> <dd>
<p>The Xth day of the Gregorian Calendar that this <a href="#Date"><code>Date</code></a> is on. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>int <code>day</code>
</td> <td>The day of the Gregorian Calendar to set this <a href="#Date"><code>Date</code></a> to.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto date = Date.init;
date.dayOfGregorianCal = 1;
writeln(date); // Date(1, 1, 1)

date.dayOfGregorianCal = 365;
writeln(date); // Date(1, 12, 31)

date.dayOfGregorianCal = 366;
writeln(date); // Date(2, 1, 1)

date.dayOfGregorianCal = 0;
writeln(date); // Date(0, 12, 31)

date.dayOfGregorianCal = -365;
writeln(date); // Date(-0, 1, 1)

date.dayOfGregorianCal = -366;
writeln(date); // Date(-1, 12, 31)

date.dayOfGregorianCal = 730_120;
writeln(date); // Date(2000, 1, 1)

date.dayOfGregorianCal = 734_137;
writeln(date); // Date(2010, 12, 31)
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Date.isoWeek">const pure nothrow @property @safe ubyte <strong id="isoWeek">isoWeek</strong>(); </dt> <dd>
<p>The ISO 8601 week of the year that this <a href="#Date"><code>Date</code></a> is in. </p>
<dl>
<dt>See Also:</dt>
<dd><a href="http://en.wikipedia.org/wiki/ISO_week_date">ISO Week Date</a></dd>
</dl> </dd> <dt class="d_decl" id="Date.endOfMonth">const pure nothrow @property @safe Date <strong id="endOfMonth">endOfMonth</strong>(); </dt> <dd>
<p><a href="#Date"><code>Date</code></a> for the last day in the month that this <a href="#Date"><code>Date</code></a> is in.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(Date(1999, 1, 6).endOfMonth); // Date(1999, 1, 31)
writeln(Date(1999, 2, 7).endOfMonth); // Date(1999, 2, 28)
writeln(Date(2000, 2, 7).endOfMonth); // Date(2000, 2, 29)
writeln(Date(2000, 6, 4).endOfMonth); // Date(2000, 6, 30)
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Date.daysInMonth">const pure nothrow @nogc @property @safe ubyte <strong id="daysInMonth">daysInMonth</strong>(); </dt> <dd>
<p>The last day in the month that this <a href="#Date"><code>Date</code></a> is in.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(Date(1999, 1, 6).daysInMonth); // 31
writeln(Date(1999, 2, 7).daysInMonth); // 28
writeln(Date(2000, 2, 7).daysInMonth); // 29
writeln(Date(2000, 6, 4).daysInMonth); // 30
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Date.isAD">const pure nothrow @nogc @property @safe bool <strong id="isAD">isAD</strong>(); </dt> <dd>
<p>Whether the current year is a date in A.D.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(Date(1, 1, 1).isAD);
assert(Date(2010, 12, 31).isAD);
assert(!Date(0, 12, 31).isAD);
assert(!Date(-2010, 1, 1).isAD);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Date.julianDay">const pure nothrow @nogc @property @safe long <strong id="julianDay">julianDay</strong>(); </dt> <dd>
<p>The <a href="http://en.wikipedia.org/wiki/Julian_day">Julian day</a> for this <a href="#Date"><code>Date</code></a> at noon (since the Julian day changes at noon).</p> </dd> <dt class="d_decl" id="Date.modJulianDay">const pure nothrow @nogc @property @safe long <strong id="modJulianDay">modJulianDay</strong>(); </dt> <dd>
<p>The modified <a href="http://en.wikipedia.org/wiki/Julian_day">Julian day</a> for any time on this date (since, the modified Julian day changes at midnight).</p> </dd> <dt class="d_decl" id="Date.toISOString">const pure nothrow @safe string <strong id="toISOString">toISOString</strong>(); <br><br>const void <strong id="toISOString">toISOString</strong>(W)(ref W writer)<br><small>  Constraints: if (isOutputRange!(W, char)); </small>
</dt> <dd>
<p>Converts this <a href="#Date"><code>Date</code></a> to a string with the format <code>YYYYMMDD</code>. If <code>writer</code> is set, the resulting string will be written directly to it. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>W <code>writer</code>
</td> <td>A <code>char</code> accepting <a href="std_range_primitives#isOutputRange">output range</a>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A <code>string</code> when not using an output range; <code>void</code> otherwise.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(Date(2010, 7, 4).toISOString()); // "20100704"
writeln(Date(1998, 12, 25).toISOString()); // "19981225"
writeln(Date(0, 1, 5).toISOString()); // "00000105"
writeln(Date(-4, 1, 5).toISOString()); // "-00040105"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Date.toISOExtString">const pure nothrow @safe string <strong id="toISOExtString">toISOExtString</strong>(); <br><br>const void <strong id="toISOExtString">toISOExtString</strong>(W)(ref W writer)<br><small>  Constraints: if (isOutputRange!(W, char)); </small>
</dt> <dd>
<p>Converts this <a href="#Date"><code>Date</code></a> to a string with the format <code>YYYY-MM-DD</code>. If <code>writer</code> is set, the resulting string will be written directly to it. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>W <code>writer</code>
</td> <td>A <code>char</code> accepting <a href="std_range_primitives#isOutputRange">output range</a>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A <code>string</code> when not using an output range; <code>void</code> otherwise.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(Date(2010, 7, 4).toISOExtString()); // "2010-07-04"
writeln(Date(1998, 12, 25).toISOExtString()); // "1998-12-25"
writeln(Date(0, 1, 5).toISOExtString()); // "0000-01-05"
writeln(Date(-4, 1, 5).toISOExtString()); // "-0004-01-05"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Date.toSimpleString">const pure nothrow @safe string <strong id="toSimpleString">toSimpleString</strong>(); <br><br>const void <strong id="toSimpleString">toSimpleString</strong>(W)(ref W writer)<br><small>  Constraints: if (isOutputRange!(W, char)); </small>
</dt> <dd>
<p>Converts this <a href="#Date"><code>Date</code></a> to a string with the format <code>YYYY-Mon-DD</code>. If <code>writer</code> is set, the resulting string will be written directly to it. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>W <code>writer</code>
</td> <td>A <code>char</code> accepting <a href="std_range_primitives#isOutputRange">output range</a>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A <code>string</code> when not using an output range; <code>void</code> otherwise.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(Date(2010, 7, 4).toSimpleString()); // "2010-Jul-04"
writeln(Date(1998, 12, 25).toSimpleString()); // "1998-Dec-25"
writeln(Date(0, 1, 5).toSimpleString()); // "0000-Jan-05"
writeln(Date(-4, 1, 5).toSimpleString()); // "-0004-Jan-05"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Date.toString">const pure nothrow @safe string <strong id="toString">toString</strong>(); <br><br>const void <strong id="toString">toString</strong>(W)(ref W writer)<br><small>  Constraints: if (isOutputRange!(W, char)); </small>
</dt> <dd>
<p>Converts this <a href="#Date"><code>Date</code></a> to a string. </p>
<p>This function exists to make it easy to convert a <a href="#Date"><code>Date</code></a> to a string for code that does not care what the exact format is - just that it presents the information in a clear manner. It also makes it easy to simply convert a <a href="#Date"><code>Date</code></a> to a string when using functions such as <code>to!string</code>, <code>format</code>, or <code>writeln</code> which use toString to convert user-defined types. So, it is unlikely that much code will call toString directly. <br><br> The format of the string is purposefully unspecified, and code that cares about the format of the string should use <code>toISOString</code>, <code>toISOExtString</code>, <code>toSimpleString</code>, or some other custom formatting function that explicitly generates the format that the code needs. The reason is that the code is then clear about what format it's using, making it less error-prone to maintain the code and interact with other software that consumes the generated strings. It's for this same reason <a href="#Date"><code>Date</code></a> has no <code>fromString</code> function, whereas it does have <code>fromISOString</code>, <code>fromISOExtString</code>, and <code>fromSimpleString</code>. <br><br> The format returned by toString may or may not change in the future.</p> </dd> <dt class="d_decl" id="Date.fromISOString">pure @safe Date <strong id="fromISOString">fromISOString</strong>(S)(scope const S isoString)<br><small>  Constraints: if (isSomeString!S); </small>
</dt> <dd>
<p>Creates a <a href="#Date"><code>Date</code></a> from a string with the format YYYYMMDD. Whitespace is stripped from the given string. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S <code>isoString</code>
</td> <td>A string formatted in the ISO format for dates.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given string is not in the ISO format or if the resulting <a href="#Date"><code>Date</code></a> would not be valid.</dd>
</dl> </dd> <dt class="d_decl" id="Date.fromISOExtString">pure @safe Date <strong id="fromISOExtString">fromISOExtString</strong>(S)(scope const S isoExtString)<br><small>  Constraints: if (isSomeString!S); </small>
</dt> <dd>
<p>Creates a <a href="#Date"><code>Date</code></a> from a string with the format YYYY-MM-DD. Whitespace is stripped from the given string. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S <code>isoExtString</code>
</td> <td>A string formatted in the ISO Extended format for dates.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given string is not in the ISO Extended format or if the resulting <a href="#Date"><code>Date</code></a> would not be valid.</dd>
</dl> </dd> <dt class="d_decl" id="Date.fromSimpleString">pure @safe Date <strong id="fromSimpleString">fromSimpleString</strong>(S)(scope const S simpleString)<br><small>  Constraints: if (isSomeString!S); </small>
</dt> <dd>
<p>Creates a <a href="#Date"><code>Date</code></a> from a string with the format YYYY-Mon-DD. Whitespace is stripped from the given string. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S <code>simpleString</code>
</td> <td>A string formatted in the way that toSimpleString formats dates.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given string is not in the correct format or if the resulting <a href="#Date"><code>Date</code></a> would not be valid.</dd>
</dl> </dd> <dt class="d_decl" id="Date.min">static pure nothrow @nogc @property @safe Date <strong id="min">min</strong>(); </dt> <dd>
<p>Returns the <a href="#Date"><code>Date</code></a> farthest in the past which is representable by <a href="#Date"><code>Date</code></a>.</p> </dd> <dt class="d_decl" id="Date.max">static pure nothrow @nogc @property @safe Date <strong id="max">max</strong>(); </dt> <dd>
<p>Returns the <a href="#Date"><code>Date</code></a> farthest in the future which is representable by <a href="#Date"><code>Date</code></a>.</p> </dd> </dl> </dd> <dt class="d_decl" id="TimeOfDay">struct <strong id="TimeOfDay">TimeOfDay</strong>; </dt> <dd>
<p>Represents a time of day with hours, minutes, and seconds. It uses 24 hour time.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import core.time : minutes, seconds;

auto t = TimeOfDay(12, 30, 0);

t += 10.minutes + 100.seconds;
writeln(t); // TimeOfDay(12, 41, 40)

writeln(t.toISOExtString()); // "12:41:40"
writeln(t.toISOString()); // "124140"

writeln(TimeOfDay.fromISOExtString("15:00:00")); // TimeOfDay(15, 0, 0)
writeln(TimeOfDay.fromISOString("015000")); // TimeOfDay(1, 50, 0)
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="TimeOfDay.this">pure @safe this(int hour, int minute, int second = 0); </dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>int <code>hour</code>
</td> <td>Hour of the day [0 - 24).</td>
</tr> <tr>
<td>int <code>minute</code>
</td> <td>Minute of the hour [0 - 60).</td>
</tr> <tr>
<td>int <code>second</code>
</td> <td>Second of the minute [0 - 60).</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the resulting <a href="#TimeOfDay"><code>TimeOfDay</code></a> would be not be valid.</dd>
</dl> </dd> <dt class="d_decl" id="TimeOfDay.opCmp">const pure nothrow @nogc @safe int <strong id="opCmp">opCmp</strong>(TimeOfDay rhs); </dt> <dd>
<p>Compares this <a href="#TimeOfDay"><code>TimeOfDay</code></a> with the given <a href="#TimeOfDay"><code>TimeOfDay</code></a>. </p>
<dl>
<dt>Returns:</dt>
<dd><table>
 <tr>
<td>this &lt; rhs</td> <td>&lt; 0</td>
</tr> <tr>
<td>this == rhs</td> <td>0</td>
</tr> <tr>
<td>this &gt; rhs</td> <td>&gt; 0</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="TimeOfDay.hour">const pure nothrow @nogc @property @safe ubyte <strong id="hour">hour</strong>(); </dt> <dd>
<p>Hours past midnight.</p> </dd> <dt class="d_decl" id="TimeOfDay.hour.2">pure @property @safe void <strong id="hour">hour</strong>(int <strong id="hour">hour</strong>); </dt> <dd>
<p>Hours past midnight. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>int <code>hour</code>
</td> <td>The hour of the day to set this <a href="#TimeOfDay"><code>TimeOfDay</code></a>'s hour to.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given hour would result in an invalid <a href="#TimeOfDay"><code>TimeOfDay</code></a>.</dd>
</dl> </dd> <dt class="d_decl" id="TimeOfDay.minute">const pure nothrow @nogc @property @safe ubyte <strong id="minute">minute</strong>(); </dt> <dd>
<p>Minutes past the hour.</p> </dd> <dt class="d_decl" id="TimeOfDay.minute.2">pure @property @safe void <strong id="minute">minute</strong>(int <strong id="minute">minute</strong>); </dt> <dd>
<p>Minutes past the hour. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>int <code>minute</code>
</td> <td>The minute to set this <a href="#TimeOfDay"><code>TimeOfDay</code></a>'s minute to.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given minute would result in an invalid <a href="#TimeOfDay"><code>TimeOfDay</code></a>.</dd>
</dl> </dd> <dt class="d_decl" id="TimeOfDay.second">const pure nothrow @nogc @property @safe ubyte <strong id="second">second</strong>(); </dt> <dd>
<p>Seconds past the minute.</p> </dd> <dt class="d_decl" id="TimeOfDay.second.2">pure @property @safe void <strong id="second">second</strong>(int <strong id="second">second</strong>); </dt> <dd>
<p>Seconds past the minute. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>int <code>second</code>
</td> <td>The second to set this <a href="#TimeOfDay"><code>TimeOfDay</code></a>'s second to.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given second would result in an invalid <a href="#TimeOfDay"><code>TimeOfDay</code></a>.</dd>
</dl> </dd> <dt class="d_decl" id="TimeOfDay.roll">pure nothrow @nogc ref @safe TimeOfDay <strong id="roll">roll</strong>(string units)(long value)<br><small>  Constraints: if (units == "hours"); </small><br><br>pure nothrow @nogc ref @safe TimeOfDay <strong id="roll">roll</strong>(string units)(long value)<br><small>  Constraints: if (units == "minutes" || units == "seconds"); </small>
</dt> <dd>
<p>Adds the given number of units to this <a href="#TimeOfDay"><code>TimeOfDay</code></a>, mutating it. A negative number will subtract. </p>
<p>The difference between rolling and adding is that rolling does not affect larger units. For instance, rolling a <a href="#TimeOfDay"><code>TimeOfDay</code></a> one hours's worth of minutes gets the exact same <a href="#TimeOfDay"><code>TimeOfDay</code></a>. <br><br> Accepted units are <code>"hours"</code>, <code>"minutes"</code>, and <code>"seconds"</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>units</td> <td>The units to add.</td>
</tr> <tr>
<td>long <code>value</code>
</td> <td>The number of <span class="d_param">units</span> to add to this <a href="#TimeOfDay"><code>TimeOfDay</code></a>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A reference to the <code>TimeOfDay</code> (<code>this</code>).</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto tod1 = TimeOfDay(7, 12, 0);
tod1.roll!"hours"(1);
writeln(tod1); // TimeOfDay(8, 12, 0)

auto tod2 = TimeOfDay(7, 12, 0);
tod2.roll!"hours"(-1);
writeln(tod2); // TimeOfDay(6, 12, 0)

auto tod3 = TimeOfDay(23, 59, 0);
tod3.roll!"minutes"(1);
writeln(tod3); // TimeOfDay(23, 0, 0)

auto tod4 = TimeOfDay(0, 0, 0);
tod4.roll!"minutes"(-1);
writeln(tod4); // TimeOfDay(0, 59, 0)

auto tod5 = TimeOfDay(23, 59, 59);
tod5.roll!"seconds"(1);
writeln(tod5); // TimeOfDay(23, 59, 0)

auto tod6 = TimeOfDay(0, 0, 0);
tod6.roll!"seconds"(-1);
writeln(tod6); // TimeOfDay(0, 0, 59)
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="TimeOfDay.Duration">public import core.time : <strong id="Duration">Duration</strong>; </dt>  <dt class="d_decl" id="TimeOfDay.opBinary">const pure nothrow @nogc @safe TimeOfDay <strong id="opBinary">opBinary</strong>(string op)(Duration duration)<br><small>  Constraints: if (op == "+" || op == "-"); </small>
</dt> <dd>
<p>Gives the result of adding or subtracting a <a href="core_time#Duration"><code>core.time.Duration</code></a> from this <a href="#TimeOfDay"><code>TimeOfDay</code></a>. </p>
<p>The legal types of arithmetic for <a href="#TimeOfDay"><code>TimeOfDay</code></a> using this operator are <br><br> </p>
<table>
 <tr>
<td>TimeOfDay</td> <td>+</td> <td>Duration</td> <td>--&gt;</td> <td>TimeOfDay</td>
</tr> <tr>
<td>TimeOfDay</td> <td>-</td> <td>Duration</td> <td>--&gt;</td> <td>TimeOfDay</td>
</tr> </table>  <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Duration <code>duration</code>
</td> <td>The <a href="core_time#Duration"><code>core.time.Duration</code></a> to add to or subtract from this <a href="#TimeOfDay"><code>TimeOfDay</code></a>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import core.time : hours, minutes, seconds;

writeln(TimeOfDay(12, 12, 12) + seconds(1)); // TimeOfDay(12, 12, 13)
writeln(TimeOfDay(12, 12, 12) + minutes(1)); // TimeOfDay(12, 13, 12)
writeln(TimeOfDay(12, 12, 12) + hours(1)); // TimeOfDay(13, 12, 12)
writeln(TimeOfDay(23, 59, 59) + seconds(1)); // TimeOfDay(0, 0, 0)

writeln(TimeOfDay(12, 12, 12) - seconds(1)); // TimeOfDay(12, 12, 11)
writeln(TimeOfDay(12, 12, 12) - minutes(1)); // TimeOfDay(12, 11, 12)
writeln(TimeOfDay(12, 12, 12) - hours(1)); // TimeOfDay(11, 12, 12)
writeln(TimeOfDay(0, 0, 0) - seconds(1)); // TimeOfDay(23, 59, 59)
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="TimeOfDay.opOpAssign">pure nothrow @nogc ref @safe TimeOfDay <strong id="opOpAssign">opOpAssign</strong>(string op)(Duration duration)<br><small>  Constraints: if (op == "+" || op == "-"); </small>
</dt> <dd>
<p>Gives the result of adding or subtracting a <a href="core_time#Duration"><code>core.time.Duration</code></a> from this <a href="#TimeOfDay"><code>TimeOfDay</code></a>, as well as assigning the result to this <a href="#TimeOfDay"><code>TimeOfDay</code></a>. </p>
<p>The legal types of arithmetic for <a href="#TimeOfDay"><code>TimeOfDay</code></a> using this operator are <br><br> </p>
<table>
 <tr>
<td>TimeOfDay</td> <td>+</td> <td>Duration</td> <td>--&gt;</td> <td>TimeOfDay</td>
</tr> <tr>
<td>TimeOfDay</td> <td>-</td> <td>Duration</td> <td>--&gt;</td> <td>TimeOfDay</td>
</tr> </table>  <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Duration <code>duration</code>
</td> <td>The <a href="core_time#Duration"><code>core.time.Duration</code></a> to add to or subtract from this <a href="#TimeOfDay"><code>TimeOfDay</code></a>.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="TimeOfDay.opBinary.2">const pure nothrow @nogc @safe Duration <strong id="opBinary">opBinary</strong>(string op)(TimeOfDay rhs)<br><small>  Constraints: if (op == "-"); </small>
</dt> <dd>
<p>Gives the difference between two <a href="#TimeOfDay"><code>TimeOfDay</code></a>s. </p>
<p>The legal types of arithmetic for <a href="#TimeOfDay"><code>TimeOfDay</code></a> using this operator are <br><br> </p>
<table>
 <tr>
<td>TimeOfDay</td> <td>-</td> <td>TimeOfDay</td> <td>--&gt;</td> <td>duration</td>
</tr> </table>  <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TimeOfDay <code>rhs</code>
</td> <td>The <a href="#TimeOfDay"><code>TimeOfDay</code></a> to subtract from this one.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="TimeOfDay.toISOString">const pure nothrow @safe string <strong id="toISOString">toISOString</strong>(); <br><br>const void <strong id="toISOString">toISOString</strong>(W)(ref W writer)<br><small>  Constraints: if (isOutputRange!(W, char)); </small>
</dt> <dd>
<p>Converts this <a href="#TimeOfDay"><code>TimeOfDay</code></a> to a string with the format <code>HHMMSS</code>. If <code>writer</code> is set, the resulting string will be written directly to it. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>W <code>writer</code>
</td> <td>A <code>char</code> accepting <a href="std_range_primitives#isOutputRange">output range</a>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A <code>string</code> when not using an output range; <code>void</code> otherwise.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(TimeOfDay(0, 0, 0).toISOString()); // "000000"
writeln(TimeOfDay(12, 30, 33).toISOString()); // "123033"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="TimeOfDay.toISOExtString">const pure nothrow @safe string <strong id="toISOExtString">toISOExtString</strong>(); <br><br>const void <strong id="toISOExtString">toISOExtString</strong>(W)(ref W writer)<br><small>  Constraints: if (isOutputRange!(W, char)); </small>
</dt> <dd>
<p>Converts this <a href="#TimeOfDay"><code>TimeOfDay</code></a> to a string with the format <code>HH:MM:SS</code>. If <code>writer</code> is set, the resulting string will be written directly to it. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>W <code>writer</code>
</td> <td>A <code>char</code> accepting <a href="std_range_primitives#isOutputRange">output range</a>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A <code>string</code> when not using an output range; <code>void</code> otherwise.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(TimeOfDay(0, 0, 0).toISOExtString()); // "00:00:00"
writeln(TimeOfDay(12, 30, 33).toISOExtString()); // "12:30:33"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="TimeOfDay.toString">const pure nothrow @safe string <strong id="toString">toString</strong>(); <br><br>const void <strong id="toString">toString</strong>(W)(ref W writer)<br><small>  Constraints: if (isOutputRange!(W, char)); </small>
</dt> <dd>
<p>Converts this TimeOfDay to a string. </p>
<p>This function exists to make it easy to convert a <a href="#TimeOfDay"><code>TimeOfDay</code></a> to a string for code that does not care what the exact format is - just that it presents the information in a clear manner. It also makes it easy to simply convert a <a href="#TimeOfDay"><code>TimeOfDay</code></a> to a string when using functions such as <code>to!string</code>, <code>format</code>, or <code>writeln</code> which use toString to convert user-defined types. So, it is unlikely that much code will call toString directly. <br><br> The format of the string is purposefully unspecified, and code that cares about the format of the string should use <code>toISOString</code>, <code>toISOExtString</code>, or some other custom formatting function that explicitly generates the format that the code needs. The reason is that the code is then clear about what format it's using, making it less error-prone to maintain the code and interact with other software that consumes the generated strings. It's for this same reason that <a href="#TimeOfDay"><code>TimeOfDay</code></a> has no <code>fromString</code> function, whereas it does have <code>fromISOString</code> and <code>fromISOExtString</code>. <br><br> The format returned by toString may or may not change in the future. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>W <code>writer</code>
</td> <td>A <code>char</code> accepting <a href="std_range_primitives#isOutputRange">output range</a>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A <code>string</code> when not using an output range; <code>void</code> otherwise.</dd>
</dl> </dd> <dt class="d_decl" id="TimeOfDay.fromISOString">pure @safe TimeOfDay <strong id="fromISOString">fromISOString</strong>(S)(scope const S isoString)<br><small>  Constraints: if (isSomeString!S); </small>
</dt> <dd>
<p>Creates a <a href="#TimeOfDay"><code>TimeOfDay</code></a> from a string with the format HHMMSS. Whitespace is stripped from the given string. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S <code>isoString</code>
</td> <td>A string formatted in the ISO format for times.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given string is not in the ISO format or if the resulting <a href="#TimeOfDay"><code>TimeOfDay</code></a> would not be valid.</dd>
</dl> </dd> <dt class="d_decl" id="TimeOfDay.fromISOExtString">pure @safe TimeOfDay <strong id="fromISOExtString">fromISOExtString</strong>(S)(scope const S isoExtString)<br><small>  Constraints: if (isSomeString!S); </small>
</dt> <dd>
<p>Creates a <a href="#TimeOfDay"><code>TimeOfDay</code></a> from a string with the format HH:MM:SS. Whitespace is stripped from the given string. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S <code>isoExtString</code>
</td> <td>A string formatted in the ISO Extended format for times.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given string is not in the ISO Extended format or if the resulting <a href="#TimeOfDay"><code>TimeOfDay</code></a> would not be valid.</dd>
</dl> </dd> <dt class="d_decl" id="TimeOfDay.min">static pure nothrow @nogc @property @safe TimeOfDay <strong id="min">min</strong>(); </dt> <dd>
<p>Returns midnight.</p> </dd> <dt class="d_decl" id="TimeOfDay.max">static pure nothrow @nogc @property @safe TimeOfDay <strong id="max">max</strong>(); </dt> <dd>
<p>Returns one second short of midnight.</p> </dd> </dl> </dd> <dt class="d_decl" id="valid">pure nothrow @nogc @safe bool <strong id="valid">valid</strong>(string units)(int value)<br><small>  Constraints: if (units == "months" || units == "hours" || units == "minutes" || units == "seconds"); </small>
</dt> <dd>
<p>Returns whether the given value is valid for the given unit type when in a time point. Naturally, a duration is not held to a particular range, but the values in a time point are (e.g. a month must be in the range of 1 - 12 inclusive). </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>units</td> <td>The units of time to validate.</td>
</tr> <tr>
<td>int <code>value</code>
</td> <td>The number to validate.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(valid!"hours"(12));
assert(!valid!"hours"(32));
assert(valid!"months"(12));
assert(!valid!"months"(13));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="valid.2">pure nothrow @nogc @safe bool <strong id="valid">valid</strong>(string units)(int year, int month, int day)<br><small>  Constraints: if (units == "days"); </small>
</dt> <dd>
<p>Returns whether the given day is valid for the given year and month. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>units</td> <td>The units of time to validate.</td>
</tr> <tr>
<td>int <code>year</code>
</td> <td>The year of the day to validate.</td>
</tr> <tr>
<td>int <code>month</code>
</td> <td>The month of the day to validate (January is 1).</td>
</tr> <tr>
<td>int <code>day</code>
</td> <td>The day to validate.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(valid!"days"(2016, 2, 29));
assert(!valid!"days"(2016, 2, 30));
assert(valid!"days"(2017, 2, 20));
assert(!valid!"days"(2017, 2, 29));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="enforceValid">pure @safe void <strong id="enforceValid">enforceValid</strong>(string units)(int value, string file = __FILE__, size_t line = __LINE__)<br><small>  Constraints: if (units == "months" || units == "hours" || units == "minutes" || units == "seconds"); </small>
</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>units</td> <td>The units of time to validate.</td>
</tr> <tr>
<td>int <code>value</code>
</td> <td>The number to validate.</td>
</tr> <tr>
<td>string <code>file</code>
</td> <td>The file that the <a href="#DateTimeException"><code>DateTimeException</code></a> will list if thrown.</td>
</tr> <tr>
<td>size_t <code>line</code>
</td> <td>The line number that the <a href="#DateTimeException"><code>DateTimeException</code></a> will list if thrown.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="#DateTimeException"><code>DateTimeException</code></a> if <code>valid!units(value)</code> is false.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.exception : assertThrown, assertNotThrown;

assertNotThrown(enforceValid!"months"(10));
assertNotThrown(enforceValid!"seconds"(40));

assertThrown!DateTimeException(enforceValid!"months"(0));
assertThrown!DateTimeException(enforceValid!"hours"(24));
assertThrown!DateTimeException(enforceValid!"minutes"(60));
assertThrown!DateTimeException(enforceValid!"seconds"(60));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="enforceValid.2">pure @safe void <strong id="enforceValid">enforceValid</strong>(string units)(int year, Month month, int day, string file = __FILE__, size_t line = __LINE__)<br><small>  Constraints: if (units == "days"); </small>
</dt> <dd>
<p>Because the validity of the day number depends on both on the year and month of which the day is occurring, take all three variables to validate the day. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>units</td> <td>The units of time to validate.</td>
</tr> <tr>
<td>int <code>year</code>
</td> <td>The year of the day to validate.</td>
</tr> <tr>
<td>Month <code>month</code>
</td> <td>The month of the day to validate.</td>
</tr> <tr>
<td>int <code>day</code>
</td> <td>The day to validate.</td>
</tr> <tr>
<td>string <code>file</code>
</td> <td>The file that the <a href="#DateTimeException"><code>DateTimeException</code></a> will list if thrown.</td>
</tr> <tr>
<td>size_t <code>line</code>
</td> <td>The line number that the <a href="#DateTimeException"><code>DateTimeException</code></a> will list if thrown.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="#DateTimeException"><code>DateTimeException</code></a> if <code>valid!"days"(year, month, day)</code> is false.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.exception : assertThrown, assertNotThrown;

assertNotThrown(enforceValid!"days"(2000, Month.jan, 1));
// leap year
assertNotThrown(enforceValid!"days"(2000, Month.feb, 29));

assertThrown!DateTimeException(enforceValid!"days"(2001, Month.feb, 29));
assertThrown!DateTimeException(enforceValid!"days"(2000, Month.jan, 32));
assertThrown!DateTimeException(enforceValid!"days"(2000, Month.apr, 31));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="daysToDayOfWeek">pure nothrow @nogc @safe int <strong id="daysToDayOfWeek">daysToDayOfWeek</strong>(DayOfWeek currDoW, DayOfWeek dow); </dt> <dd>
<p>Returns the number of days from the current day of the week to the given day of the week. If they are the same, then the result is 0. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>DayOfWeek <code>currDoW</code>
</td> <td>The current day of the week.</td>
</tr> <tr>
<td>DayOfWeek <code>dow</code>
</td> <td>The day of the week to get the number of days to.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(daysToDayOfWeek(DayOfWeek.mon, DayOfWeek.mon)); // 0
writeln(daysToDayOfWeek(DayOfWeek.mon, DayOfWeek.sun)); // 6
writeln(daysToDayOfWeek(DayOfWeek.mon, DayOfWeek.wed)); // 2
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="monthsToMonth">pure @safe int <strong id="monthsToMonth">monthsToMonth</strong>(int currMonth, int month); </dt> <dd>
<p>Returns the number of months from the current months of the year to the given month of the year. If they are the same, then the result is 0. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>int <code>currMonth</code>
</td> <td>The current month of the year.</td>
</tr> <tr>
<td>int <code>month</code>
</td> <td>The month of the year to get the number of months to.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(monthsToMonth(Month.jan, Month.jan)); // 0
writeln(monthsToMonth(Month.jan, Month.dec)); // 11
writeln(monthsToMonth(Month.jul, Month.oct)); // 3
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="yearIsLeapYear">pure nothrow @nogc @safe bool <strong id="yearIsLeapYear">yearIsLeapYear</strong>(int year); </dt> <dd>
<p>Whether the given Gregorian Year is a leap year. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>int <code>year</code>
</td> <td>The year to to be tested.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">foreach (year; [1, 2, 100, 2001, 2002, 2003, 2005, 2006, 2007, 2009, 2010])
{
    assert(!yearIsLeapYear(year));
    assert(!yearIsLeapYear(-year));
}

foreach (year; [0, 4, 8, 400, 800, 1600, 1996, 2000, 2004, 2008, 2012])
{
    assert(yearIsLeapYear(year));
    assert(yearIsLeapYear(-year));
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isTimePoint">enum auto <strong id="isTimePoint">isTimePoint</strong>(T); </dt> <dd>
<p>Whether the given type defines all of the necessary functions for it to function as a time point. </p>
<p></p>
<ol>
<li>
<code>T</code> must define a static property named <code>min</code> which is the smallest value of <code>T</code> as <code>Unqual!T</code>. </li> <li>
<code>T</code> must define a static property named <code>max</code> which is the largest value of <code>T</code> as <code>Unqual!T</code>. </li> <li>
<code>T</code> must define an <code>opBinary</code> for addition and subtraction that accepts <a href="core_time#Duration"><code>core.time.Duration</code></a> and returns <code>Unqual!T</code>. </li> <li>
<code>T</code> must define an <code>opOpAssign</code> for addition and subtraction that accepts <a href="core_time#Duration"><code>core.time.Duration</code></a> and returns <code>ref Unqual!T</code>. </li> <li>
<code>T</code> must define a <code>opBinary</code> for subtraction which accepts <code>T</code> and returns returns <a href="core_time#Duration"><code>core.time.Duration</code></a>.</li> </ol> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import core.time : Duration;
import std.datetime.interval : Interval;
import std.datetime.systime : SysTime;

static assert(isTimePoint!Date);
static assert(isTimePoint!DateTime);
static assert(isTimePoint!SysTime);
static assert(isTimePoint!TimeOfDay);

static assert(!isTimePoint!int);
static assert(!isTimePoint!Duration);
static assert(!isTimePoint!(Interval!SysTime));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="validTimeUnits">pure nothrow @nogc @safe bool <strong id="validTimeUnits">validTimeUnits</strong>(string[] units...); </dt> <dd>
<p>Whether all of the given strings are valid units of time. </p>
<p><code>"nsecs"</code> is not considered a valid unit of time. Nothing in std.datetime can handle precision greater than hnsecs, and the few functions in core.time which deal with "nsecs" deal with it explicitly.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(validTimeUnits("msecs", "seconds", "minutes"));
assert(validTimeUnits("days", "weeks", "months"));
assert(!validTimeUnits("ms", "seconds", "minutes"));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="cmpTimeUnits">pure @safe int <strong id="cmpTimeUnits">cmpTimeUnits</strong>(string lhs, string rhs); </dt> <dd>
<p>Compares two time unit strings. <code>"years"</code> are the largest units and <code>"hnsecs"</code> are the smallest. </p>
<dl>
<dt>Returns:</dt>
<dd>
<table>
 <tr>
<td>this &lt; rhs</td> <td>&lt; 0</td>
</tr> <tr>
<td>this == rhs</td> <td>0</td>
</tr> <tr>
<td>this &gt; rhs</td> <td>&gt; 0</td>
</tr> </table> </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="#DateTimeException"><code>DateTimeException</code></a> if either of the given strings is not a valid time unit string.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.exception : assertThrown;

writeln(cmpTimeUnits("hours", "hours")); // 0
assert(cmpTimeUnits("hours", "weeks") &lt; 0);
assert(cmpTimeUnits("months", "seconds") &gt; 0);

assertThrown!DateTimeException(cmpTimeUnits("month", "second"));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="CmpTimeUnits">template <strong id="CmpTimeUnits">CmpTimeUnits</strong>(string lhs, string rhs) if (validTimeUnits(lhs, rhs))</dt> <dd>
<p>Compares two time unit strings at compile time. <code>"years"</code> are the largest units and <code>"hnsecs"</code> are the smallest. </p>
<p>This template is used instead of <code>cmpTimeUnits</code> because exceptions can't be thrown at compile time and <code>cmpTimeUnits</code> must enforce that the strings it's given are valid time unit strings. This template uses a template constraint instead. </p> <dl>
<dt>Returns:</dt>
<dd><table>
 <tr>
<td>this &lt; rhs</td> <td>&lt; 0</td>
</tr> <tr>
<td>this == rhs</td> <td>0</td>
</tr> <tr>
<td>this &gt; rhs</td> <td>&gt; 0</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(CmpTimeUnits!("years", "weeks") &gt; 0);
static assert(CmpTimeUnits!("days", "days") == 0);
static assert(CmpTimeUnits!("seconds", "hours") &lt; 0);
</pre> </dd>
</dl> </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
     19992019 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_datetime_date.html" class="_attribution-link">https://dlang.org/phobos/std_datetime_date.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
