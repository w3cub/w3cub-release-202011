
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>15. Classes - D - W3cubDocs</title>
  
  <meta name="description" content="The object-oriented features of D all come from classes. The class hierarchy has as its root the class Object. Object defines a minimum level of &hellip;">
  <meta name="keywords" content="classes, d">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/d/class.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/d.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/d/" class="_nav-link" title="" style="margin-left:0;">D</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _d">
				
				
<h1>Classes</h1>       <b>Contents</b>  <ol> <li><a href="#access_control">Access Control</a></li> <li><a href="#fields">Fields</a></li> <li><a href="#field_properties">Field Properties</a></li> <li><a href="#class_properties">Class Properties</a></li> <li><a href="#super_class">Super Class</a></li> <li><a href="#member-functions">Member Functions</a></li> <li><a href="#synchronized-classes">Synchronized Classes</a></li> <li><a href="#constructors">Constructors</a></li> <li><a href="#field-init">Field initialization inside constructor</a></li> <li><a href="#destructors">Destructors</a></li> <li><a href="#static-constructor">Static Constructors</a></li> <li><a href="#static-destructor">Static Destructors</a></li> <li><a href="#shared_static_constructors">Shared Static Constructors</a></li> <li><a href="#shared_static_destructors">Shared Static Destructors</a></li> <li><a href="#invariants">Class Invariants</a></li> <li><a href="#allocators">Class Allocators</a></li> <li><a href="#deallocators">Class Deallocators</a></li> <li><a href="#alias-this">Alias This</a></li> <li><a href="#auto">Scope Classes</a></li> <li><a href="#final">Final Classes</a></li> <li><a href="#nested">Nested Classes</a></li> <li><a href="#anonymous">Anonymous Nested Classes</a></li> <li><a href="#const-class">Const, Immutable and Shared Classes</a></li> </ol>   <p>The object-oriented features of D all come from classes. The class hierarchy has as its root the class Object. Object defines a minimum level of functionality that each derived class has, and a default implementation for that functionality. </p>  <p>Classes are programmer defined types. Support for classes are what make D an object oriented language, giving it encapsulation, inheritance, and polymorphism. D classes support the single inheritance paradigm, extended by adding support for interfaces. Class objects are instantiated by reference only. </p>  <p>A class can be exported, which means its name and all its non-private members are exposed externally to the DLL or EXE. </p>  <p>A class declaration is defined: </p>  <pre>ClassDeclaration:
    class Identifier ;
    class Identifier BaseClassListopt AggregateBody
    ClassTemplateDeclaration

BaseClassList:
    : SuperClass
    : SuperClass , Interfaces
    : Interfaces

SuperClass:
    BasicType

Interfaces:
    Interface
    Interface , Interfaces

Interface:
    BasicType
</pre>  <p>Classes consist of:</p>  <ul> <li>a super class</li> <li>interfaces</li> <li>a nested anonymous metaclass for classes declared with <code>extern (Objective-C)</code>
</li> <li>dynamic fields</li> <li>static fields</li> <li>types</li> <li><a href="#synchronized-classes">an optional synchronized attribute</a></li> <li>
<a href="#member-functions">member functions</a> <ul> <li>static member functions</li> <li><a href="function#virtual-functions">Virtual Functions</a></li> <li><a href="#constructors">Constructors</a></li> <li><a href="#destructors">Destructors</a></li> <li><a href="#static-constructor">Static Constructors</a></li> <li><a href="#static-destructor">Static Destructors</a></li> <li>
<a href="#SharedStaticConstructor"><i>SharedStaticConstructor</i></a>s</li> <li>
<a href="#SharedStaticDestructor"><i>SharedStaticDestructor</i></a>s</li> <li><a href="#invariants">Class Invariants</a></li> <li><a href="unittest#unittest">Unit Tests</a></li> <li><a href="#allocators">Class Allocators</a></li> <li><a href="#deallocators">Class Deallocators</a></li> <li><a href="#alias-this">Alias This</a></li> </ul> </li> </ul>  <p>A class is defined:</p>  <pre data-language="d">class Foo
{
    ... members ...
}
</pre>  <p>Note that there is no trailing <code>;</code> after the closing <code>}</code> of the class definition. It is also not possible to declare a variable var like:</p>  <pre data-language="d">class Foo { } var;
</pre>  Instead:  <pre data-language="d">class Foo { }
Foo var;
</pre>  <h2 id="access_control">Access Control</h2>  <p>Access to class members is controlled using <a href="attribute#visibility_attributes"> visibility attributes</a>. The default visibility attribute is <code>public</code>. </p>  <h2 id="fields">Fields</h2>  <p>Class members are always accessed with the . operator. </p>  <p>Members of a base class can be accessed by prepending the name of the base class followed by a dot:</p>  <pre data-language="d">class A { int a; int a2;}
class B : A { int a; }

void foo(B b)
{
    b.a = 3;   // accesses field B.a
    b.a2 = 4;  // accesses field A.a2
    b.A.a = 5; // accesses field A.a
}
</pre>  <p>The D compiler is free to rearrange the order of fields in a class to optimally pack them in an implementation-defined manner. Consider the fields much like the local variables in a function - the compiler assigns some to registers and shuffles others around all to get the optimal stack frame layout. This frees the code designer to organize the fields in a manner that makes the code more readable rather than being forced to organize it according to machine optimization rules. Explicit control of field layout is provided by struct/union types, not classes. </p>  <p>Fields of <code>extern(Objective-C)</code> classes have a dynamic offset. That means that the base class can change (add or remove instance variables) without the subclasses needing to recompile or relink. </p>  <h2 id="field_properties">Field Properties</h2>  <p>The <code>.offsetof</code> property gives the offset in bytes of the field from the beginning of the class instantiation. <code>.offsetof</code> is not available for fields of <code>extern(Objective-C)</code> classes due to their fields having a dynamic offset. <code>.offsetof</code> can only be applied to expressions which produce the type of the field itself, not the class type: </p>  <pre data-language="d">class Foo
{
    int x;
}
...
void test(Foo foo)
{
    size_t o;

    o = Foo.x.offsetof; // error, Foo.x needs a 'this' reference
    o = foo.x.offsetof; // ok
}
</pre>  <h2 id="class_properties">Class Properties</h2>  <p>The <code>.tupleof</code> property is an <a href="template#variadic-templates">expression sequence</a> of all the fields in the class, excluding the hidden fields and the fields in the base class. <code>.tupleof</code> is not available for <code>extern(Objective-C)</code> classes due to their fields having a dynamic offset. </p> <pre data-language="d">class Foo { int x; long y; }

void test(Foo foo)
{
    import std.stdio;
    static assert(typeof(foo.tupleof).stringof == `(int, long)`);

    foo.tupleof[0] = 1; // set foo.x to 1
    foo.tupleof[1] = 2; // set foo.y to 2
    foreach (x; foo.tupleof)
        write(x);       // prints 12
}
</pre>  <p>The properties <code>.__vptr</code> and <code>.__monitor</code> give access to the class object's vtbl[] and monitor, respectively, but should not be used in user code. </p>  <h2 id="super_class">Super Class</h2>  All classes inherit from a super class. If one is not specified, it inherits from Object. Object forms the root of the D class inheritance hierarchy.  <h2 id="member-functions">Member Functions</h2>  <p>Non-static member functions or static member functions with <code>Objective-C</code> linkage have an extra hidden parameter called <i>this</i> through which the class object's other members can be accessed. </p>  <p>Member functions with the Objective-C linkage has an additional hidden, anonymous, parameter which is the selector the function was called with. </p>  <p>Non-static member functions can have, in addition to the usual <a href="function#FunctionAttribute"><i>FunctionAttribute</i></a>s, the attributes <code>const</code>, <code>immutable</code>, <code>shared</code>, or <code>inout</code>. These attributes apply to the hidden <i>this</i> parameter. </p>  <p>Static member functions with the Objective-C linkage are placed in the hidden nested metaclass as non-static member functions. </p> <pre data-language="d">class C
{
    int a;
    const void foo()
    {
        a = 3; // error, 'this' is const
    }
    void foo() immutable
    {
        a = 3; // error, 'this' is immutable
    }
}
</pre>   <h2 id="synchronized-classes">Synchronized Classes</h2>  <p>All member functions of synchronized classes are synchronized. A static member function is synchronized on the <i>classinfo</i> object for the class, which means that one monitor is used for all static member functions for that synchronized class. For non-static functions of a synchronized class, the monitor used is part of the class object. For example: </p>  <pre data-language="d">synchronized class Foo
{
    void bar() { ...statements... }
}
</pre>  <p>is equivalent to (as far as the monitors go): </p>  <pre data-language="d">synchronized class Foo
{
    void bar()
    {
        synchronized (this) { ...statements... }
    }
}
</pre>  <p>Member functions of non-synchronized classes can be individually marked as synchronized. </p>  <pre data-language="d">class Foo
{
    synchronized void foo() { }  // foo is synchronized
}
</pre>  <p>Member fields of a synchronized class cannot be public: </p>  <pre data-language="d">synchronized class Foo
{
    int foo;  // disallowed: public field
}

synchronized class Bar
{
    private int bar;  // ok
}
</pre>  <p>The <code>synchronized</code> attribute can only be applied to classes, structs cannot be marked to be synchronized.</p>  <h2 id="constructors">Constructors</h2>  <pre>Constructor:
    this Parameters MemberFunctionAttributesopt ;
    this Parameters MemberFunctionAttributesopt FunctionBody
    ConstructorTemplate
</pre>  <p id="class-default-initializer">Fields are by default initialized to the default initializer for their type (usually 0 for integer types and NAN for floating point types). If the field declaration has an optional <a href="declaration#Initializer"><i>Initializer</i></a> that will be used instead of the default. </p> <pre data-language="d">class Abc
{
    int a;      // default initializer for a is 0
    long b = 7; // default initializer for b is 7
    float f;    // default initializer for f is NAN
}
</pre>  <p>The <i>Initializer</i> is evaluated at compile time.</p>  <p>This initialization is done before any constructors are called.</p>  <p>Constructors are defined with a function name of <code>this</code> and having no return value:</p>  <pre data-language="d">class Foo
{
    this(int x)  // declare constructor for Foo
    {   ...
    }
    this()
    {   ...
    }
}
</pre>  <p>Base class construction is done by calling the base class constructor by the name <code>super</code>:</p>  <pre data-language="d">class A { this(int y) { } }

class B : A
{
    int j;
    this()
    {
        ...
        super(3);  // call base constructor A.this(3)
        ...
    }
}
</pre>  <p id="delegating-constructors">Constructors can call other constructors for the same class in order to share common initializations (this is called a delegating constructor): </p>  <pre data-language="d">class C
{
    int j;
    this()
    {
        ...
    }
    this(int i)
    {
        this(); // delegating constructor call
        j = i;
    }
}
</pre>  <p>If no call to constructors via <code>this</code> or <code>super</code> appear in a constructor, and the base class has a constructor, a call to <code>super()</code> is inserted at the beginning of the constructor.</p>  <p>If there is no constructor for a class, but there is a constructor for the base class, a default constructor is implicitly generated with the form:</p>  <pre data-language="d">this() { }
</pre>  <p>The following restrictions apply to class construction:</p>  <ol> <li>It is illegal for constructors to mutually call each other.  <pre data-language="d">this() { this(1); }
this(int i) { this(); } // illegal, cyclic constructor calls
</pre>  <b>Implementation Defined</b>: The compiler is not required to detect cyclic constructor calls.  <b>Undefined Behavior</b>: If the program executes with cyclic constructor calls. </li>  <li>If a constructor's code contains a delegate constructor call, all possible execution paths through the constructor must make exactly one delegate constructor call:  <pre data-language="d">this() { a || super(); }       // illegal

this() { (a) ? this(1) : super(); }     // ok

this()
{
    for (...)
    {
        super();  // illegal, inside loop
    }
}
</pre> </li>  <li>It is illegal to refer to <code>this</code> implicitly or explicitly prior to making a delegate constructor call.</li>  <li>Delegate constructor calls cannot appear after labels.</li> </ol>  <p>Instances of class objects are created with a <a href="expression#NewExpression"><i>NewExpression</i></a>:</p>  <pre data-language="d">A a = new A(3);
</pre>  <p>The following steps happen:</p>  <ol> <li>Storage is allocated for the object. If this fails, rather than return <code>null</code>, an <a href="https://dlang.org/library/core/exception/out_of_memory_error.html">OutOfMemoryError</a> is thrown. Thus, tedious checks for null references are unnecessary. </li>  <li>The raw data is statically initialized using the values provided in the class definition. The pointer to the vtbl[] (the array of pointers to virtual functions) is assigned. Constructors are passed fully formed objects for which virtual functions can be called. This operation is equivalent to doing a memory copy of a static version of the object onto the newly allocated one. </li>  <li>If there is a constructor defined for the class, the constructor matching the argument list is called. </li>  <li>If a delegating constructor is not called, a call to the base class's default constructor is issued.</li>  <li>The body of the constructor is executed.</li>  <li>If class invariant checking is turned on, the class invariant is called at the end of the constructor. </li> </ol>  <p>Constructors can have one of these member function attributes: <code>const</code>, <code>immutable</code>, and <code>shared</code>. Construction of qualified objects will then be restricted to the implemented qualified constructors. </p> <pre data-language="d">class C
{
    this();   // non-shared mutable constructor
}

// create mutable object
C m = new C();

// create const object using by mutable constructor
const C c2 = new const C();

// a mutable constructor cannot create an immutable object
// immutable C i = new immutable C();

// a mutable constructor cannot create a shared object
// shared C s = new shared C();
</pre>  <p>Constructors can be overloaded with different attributes. </p> <pre data-language="d">class C
{
    this();               // non-shared mutable constructor
    this() shared;        // shared mutable constructor
    this() immutable;     // immutable constructor
}

C m = new C();
shared s = new shared C();
immutable i = new immutable C();
</pre>  <p>If the constructor can create a unique object (e.g. if it is <code>pure</code>), the object can be implicitly convertible to any qualifiers. </p> <pre data-language="d">class C
{
    this() pure;
    // Based on the definition, this creates a mutable object. But the
    // created object cannot contain any mutable global data.
    // Therefore the created object is unique.

    this(int[] arr) immutable pure;
    // Based on the definition, this creates an immutable object. But
    // the argument int[] never appears in the created object so it
    // isn't implicitly convertible to immutable. Also, it cannot store
    // any immutable global data.
    // Therefore the created object is unique.
}

immutable i = new immutable C();           // this() pure is called
shared s = new shared C();                 // this() pure is called
C m = new C([1,2,3]);       // this(int[]) immutable pure is called
</pre>  <h2 id="field-init">Field initialization inside constructor</h2>  <p>In a constructor body, the first instance of field assignment is its initialization. </p>  <pre data-language="d">class C
{
    int num;
    this()
    {
        num = 1;  // initialization
        num = 2;  // assignment
    }
}
</pre>  <p>If the field type has an <a href="operatoroverloading#assignment"><code>opAssign</code></a> method, it will not be used for initialization.</p>  <pre data-language="d">struct A
{
    this(int n) {}
    void opAssign(A rhs) {}
}
class C
{
    A val;
    this()
    {
        val = A(1);  // val is initialized to the value of A(1)
        val = A(2);  // rewritten to val.opAssign(A(2))
    }
}
</pre>  <p>If the field type is not mutable, multiple initialization will be rejected.</p>  <pre data-language="d">class C
{
    immutable int num;
    this()
    {
        num = 1;  // OK
        num = 2;  // Error: multiple field initialization
    }
}
</pre>  <p>If the field is initialized on one path, it must be initialized on all paths.</p> <pre data-language="d">class C
{
    immutable int num;
    immutable int ber;
    this(int i)
    {
        if (i)
            num = 3;   // initialization
        else
            num = 4;   // initialization
    }
    this(long j)
    {
        j ? (num = 3) : (num = 4); // ok
        j || (ber = 3);  // error, intialized on only one path
        j &amp;&amp; (ber = 3);  // error, intialized on only one path
    }
}
</pre>  <p>A field initialization may not appear in a loop or after a label.</p>  <pre data-language="d">class C
{
    immutable int num;
    immutable string str;
    this()
    {
        foreach (i; 0..2)
        {
            num = 1;    // Error: field initialization not allowed in loops
        }
        size_t i = 0;
    Label:
        str = "hello";  // Error: field initialization not allowed after labels
        if (i++ &lt; 2)
            goto Label;
    }
}
</pre>  <p>If a field's type has disabled default construction, then it must be initialized in the constructor.</p> <pre data-language="d">struct S { int y; @disable this(); }

class C
{
    S s;
    this(S t) { s = t; }    // ok
    this(int i) { this(); } // ok
    this() { }              // error, s not initialized
}
</pre>  <h2 id="destructors">Destructors</h2>  <pre>Destructor:
    ~ this ( ) MemberFunctionAttributesopt ;
    ~ this ( ) MemberFunctionAttributesopt FunctionBody
</pre>  <p>The garbage collector calls the destructor function when the object is deleted. The syntax is:</p>  <pre data-language="d">class Foo
{
    ~this() // destructor for Foo
    {
    }
}
</pre>  <p>There can be only one destructor per class, the destructor does not have any parameters, and has no attributes. It is always virtual. </p>  <p>The destructor is expected to release any resources held by the object. </p>  <p>The program can explicitly inform the garbage collector that an object is no longer referred to with <a href="https://dlang.org/phobos/object.html#destroy"><code>destroy</code></a>, and then the garbage collector calls the destructor immediately. The destructor is guaranteed to never be called twice. </p>  <p>The destructor for the super class automatically gets called when the destructor ends. There is no way to call the super destructor explicitly. </p>  <p>The garbage collector is not guaranteed to run the destructor for all unreferenced objects. Furthermore, the order in which the garbage collector calls destructors for unreferenced objects is not specified. This means that when the garbage collector calls a destructor for an object of a class that has members which are references to garbage collected objects, those references may no longer be valid. This means that destructors cannot reference sub objects. This rule does not apply to auto objects or objects destructed with <a href="https://dlang.org/phobos/object.html#destroy"><code>destroy</code></a>, as the destructor is not being run by the garbage collector, meaning all references are valid. </p>  <p>Objects referenced from the data segment never get collected by the gc. </p>  <h2 id="static-constructor">Static Constructors</h2>  <pre>StaticConstructor:
    static this ( ) MemberFunctionAttributesopt ;
    static this ( ) MemberFunctionAttributesopt FunctionBody
</pre>  <p>A static constructor is a function that performs initializations of thread local data before the <code>main()</code> function gets control for the main thread, and upon thread startup.</p>  <p>Static constructors are used to initialize static class members with values that cannot be computed at compile time.</p>  <p>Static constructors in other languages are built implicitly by using member initializers that can't be computed at compile time. The trouble with this stems from not having good control over exactly when the code is executed, for example: </p>  <pre data-language="d">class Foo
{
    static int a = b + 1;
    static int b = a * 2;
}
</pre>  What values do a and b end up with, what order are the initializations executed in, what are the values of a and b before the initializations are run, is this a compile error, or is this a runtime error? Additional confusion comes from it not being obvious if an initializer is static or dynamic.  <p>D makes this simple. All member initializations must be determinable by the compiler at compile time, hence there is no order-of-evaluation dependency for member initializations, and it is not possible to read a value that has not been initialized. Dynamic initialization is performed by a static constructor, defined with a special syntax <code>static this()</code>.</p>  <pre data-language="d">class Foo
{
    static int a;         // default initialized to 0
    static int b = 1;
    static int c = b + a; // error, not a constant initializer

    static this()    // static constructor
    {
        a = b + 1;          // a is set to 2
        b = a * 2;          // b is set to 4
    }
}
</pre>  <p>If <code>main()</code> or the thread returns normally, (does not throw an exception), the static destructor is added to the list of functions to be called on thread termination.</p>  <p>Static constructors have empty parameter lists.</p>  <p> Static constructors within a module are executed in the lexical order in which they appear. All the static constructors for modules that are directly or indirectly imported are executed before the static constructors for the importer. </p>  <p> The <code>static</code> in the static constructor declaration is not an attribute, it must appear immediately before the <code>this</code>: </p>  <pre data-language="d">class Foo
{
    static this() { ... } // a static constructor
    static private this() { ... } // not a static constructor
    static
    {
        this() { ... }      // not a static constructor
    }
    static:
        this() { ... }      // not a static constructor
}
</pre>  <h2 id="static-destructor">Static Destructors</h2>  <pre>StaticDestructor:
    static ~ this ( ) MemberFunctionAttributesopt ;
    static ~ this ( ) MemberFunctionAttributesopt FunctionBody
</pre>  A static destructor is defined as a special static function with the syntax <code>static ~this()</code>.  <pre data-language="d">class Foo
{
    static ~this() // static destructor
    {
    }
}
</pre>  <p> A static destructor gets called on thread termination, but only if the static constructor completed successfully. Static destructors have empty parameter lists. Static destructors get called in the reverse order that the static constructors were called in. </p>  <p> The <code>static</code> in the static destructor declaration is not an attribute, it must appear immediately before the <code>~this</code>: </p>  <pre data-language="d">class Foo
{
    static ~this() { ... }  // a static destructor
    static private ~this() { ... } // not a static destructor
    static
    {
        ~this() { ... }  // not a static destructor
    }
    static:
        ~this() { ... }  // not a static destructor
}
</pre>  <h2 id="shared_static_constructors">Shared Static Constructors</h2>  <pre>SharedStaticConstructor:
    shared static this ( ) MemberFunctionAttributesopt ;
    shared static this ( ) MemberFunctionAttributesopt FunctionBody
</pre>  <p>Shared static constructors are executed before any <a href="#StaticConstructor"><i>StaticConstructor</i></a>s, and are intended for initializing any shared global data. </p>  <h2 id="shared_static_destructors">Shared Static Destructors</h2>  <pre>SharedStaticDestructor:
    shared static ~ this ( ) MemberFunctionAttributesopt ;
    shared static ~ this ( ) MemberFunctionAttributesopt FunctionBody
</pre>  <p>Shared static destructors are executed at program termination in the reverse order that <a href="#SharedStaticConstructor"><i>SharedStaticConstructor</i></a>s were executed. </p>   <h2 id="invariants">Class Invariants</h2>  <pre>ClassInvariant:
    invariant ( ) BlockStatement
    invariant BlockStatement
    invariant ( AssertArguments ) ;
</pre>  <p><i>ClassInvariant</i> specify the relationships among the members of a class instance. Those relationships must hold for any interactions with the instance from its public interface. </p>  <p>The invariant is in the form of a <code>const</code> member function. The invariant is defined to <i>hold</i> if all the <a href="expression#AssertExpression"><i>AssertExpression</i></a>s within the invariant that are executed succeed. </p>  <p>If the invariant does not hold, then the program enters an invalid state.</p>  <p>Any class invariants for base classes are applied before the class invariant for the derived class.</p>  <p>There may be multiple invariants in a class. They are applied in lexical order.</p>  <p><i>ClassInvariant</i>s must hold at the exit of the class constructor (if any), at the entry of the class destructor (if any).</p>  <p><i>ClassInvariant</i>s must hold at the entry and exit of all public or exported non-static member functions. The order of application of invariants is: </p>
<ol> <li>preconditions</li> <li>invariant</li> <li>function body</li> <li>invariant</li> <li>postconditions</li> </ol>  <p>The invariant need not hold if the class instance is implicitly constructed using the default <code>.init</code> value.</p>  <pre data-language="d">class Date
{
    this(int d, int h)
    {
        day = d;    // days are 1..31
        hour = h;   // hours are 0..23
    }

    invariant
    {
        assert(1 &lt;= day &amp;&amp; day &lt;= 31);
        assert(0 &lt;= hour &amp;&amp; hour &lt; 24);
    }

  private:
    int day;
    int hour;
}
</pre>  <p>Public or exported non-static member functions cannot be called from within an invariant.</p>  <pre data-language="d">class Foo
{
    public void f() { }
    private void g() { }

    invariant
    {
        f();  // error, cannot call public member function from invariant
        g();  // ok, g() is not public
    }
}
</pre>  <b>Undefined Behavior</b>: happens if the invariant does not hold and execution continues.  <b>Implementation Defined</b>: <ol> <li>Whether the <i>Class Invariant</i> is executed at runtime or not. This is typically controlled with a compiler switch.</li> <li>The behavior when the invariant does not hold is typically the same as for when <a href="expression#AssertExpression"><i>AssertExpression</i></a>s fail.</li> </ol>   <b>Best Practices:</b> <ol> <li>Do not indirectly call exported or public member functions within a class invariant, as this can result in infinite recursion.</li> <li>Avoid reliance on side effects in the invariant. as the invariant may or may not be executed.</li> <li>Avoid having mutable public fields of classes with invariants, as then the invariant cannot verify the public interface.</li> </ol>    <h2 id="allocators">Class Allocators</h2> <b>Note</b>: Class allocators are deprecated in D2. <pre>Allocator:
    new Parameters ;
    new Parameters FunctionBody
</pre>  <p>A class member function of the form:</p>  <pre data-language="d">new(uint size)
{
    ...
}
</pre>  is called a class allocator. The class allocator can have any number of parameters, provided the first one is of type uint. Any number can be defined for a class, the correct one is determined by the usual function overloading rules. When a new expression:  <pre data-language="d">new Foo;
</pre>  is executed, and Foo is a class that has an allocator, the allocator is called with the first argument set to the size in bytes of the memory to be allocated for the instance. The allocator must allocate the memory and return it as a <code>void*</code>. If the allocator fails, it must not return a <code>null</code>, but must throw an exception. If there is more than one parameter to the allocator, the additional arguments are specified within parentheses after the <code>new</code> in the <i>NewExpression</i>:  <pre data-language="d">class Foo
{
    this(string a) { ... }

    new(uint size, int x, int y)
    {
        ...
    }
}

...

new(1,2) Foo(a);        // calls new(Foo.sizeof,1,2)
</pre>  <p>Derived classes inherit any allocator from their base class, if one is not specified. </p>  <p>The class allocator is not called if the instance is created on the stack. </p>  <p>See also <a href="https://wiki.dlang.org/Memory_Management#Explicit_Class_Instance_Allocation"> Explicit Class Instance Allocation</a>. </p>  <h2 id="deallocators">Class Deallocators</h2> <b>Note</b>: Class deallocators and the delete operator are deprecated in D2. Use the <code>destroy</code> function to finalize an object by calling its destructor. The memory of the object is <b>not</b> immediately deallocated, instead the GC will collect the memory of the object at an undetermined point after finalization:  <pre data-language="d">class Foo { int x; this() { x = 1; } }
Foo foo = new Foo;
destroy(foo);
assert(foo.x == int.init);  // object is still accessible
</pre>  <pre>Deallocator:
    delete Parameters ;
    delete Parameters FunctionBody
</pre>  <p>A class member function of the form:</p>  <pre data-language="d">delete(void *p)
{
    ...
}
</pre>  is called a class deallocator. The deallocator must have exactly one parameter of type <code>void*</code>. Only one can be specified for a class. When a delete expression:  <pre data-language="d">delete f;
</pre>  is executed, and f is a reference to a class instance that has a deallocator, the deallocator is called with a pointer to the class instance after the destructor (if any) for the class is called. It is the responsibility of the deallocator to free the memory.  <p>Derived classes inherit any deallocator from their base class, if one is not specified. </p>  <p>The class allocator is not called if the instance is created on the stack. </p>  <p>See also <a href="https://wiki.dlang.org/Memory_Management#Explicit_Class_Instance_Allocation"> Explicit Class Instance Allocation</a>. </p>  <h2><span id="AliasThis">Alias This</span></h2>  <pre>AliasThis:
    alias Identifier this ;
</pre>  <p>An <i>AliasThis</i> declaration names a member to subtype. The <i>Identifier</i> names that member. </p>  <p>A class or struct can be implicitly converted to the <i>AliasThis</i> member. </p>  <pre data-language="d">struct S
{
    int x;
    alias x this;
}

int foo(int i) { return i * 2; }

void test()
{
    S s;
    s.x = 7;
    int i = -s;  // i == -7
    i = s + 8;   // i == 15
    i = s + s;   // i == 14
    i = 9 + s;   // i == 16
    i = foo(s);  // implicit conversion to int
}
</pre>  <p>If the member is a class or struct, undefined lookups will be forwarded to the <i>AliasThis</i> member. </p>  <pre data-language="d">struct Foo
{
    int baz = 4;
    int get() { return 7; }
}

class Bar
{
    Foo foo;
    alias foo this;
}

void test()
{
    auto bar = new Bar;
    int i = bar.baz; // i == 4
    i = bar.get(); // i == 7
}
</pre>  <p>If the <i>Identifier</i> refers to a property member function with no parameters, conversions and undefined lookups are forwarded to the return value of the function. </p>  <pre data-language="d">struct S
{
    int x;
    @property int get()
    {
        return x * 2;
    }
    alias get this;
}

void test()
{
    S s;
    s.x = 2;
    int i = s; // i == 4
}
</pre> <p>If an aggregate declaration defines an <code>opCmp</code> or <code>opEquals</code> method, it will take precedence to that of the aliased this member. Note that, unlike an <code>opCmp</code> method, an <code>opEquals</code> method is implicitly defined for a <code>struct</code> declaration if a user defined one isn't provided; this means that if the aliased this member <code>opEquals</code> is preferred it should be explicitly defined: </p> <pre data-language="d">struct S
{
    int a;
    bool opEquals(S rhs) const
    {
        return this.a == rhs.a;
    }
}

struct T
{
    int b;
    S s;
    alias s this;
}

struct U
{
    int a;
    bool opCmp(U rhs) const
    {
        return this.a &lt; rhs.a;
    }
}

struct V
{
    int b;
    U u;
    alias u this;
}

void main()
{
    S s1, s2;
    T t1, t2;
    U u1, u2;
    V v1, v2;

    assert(s1 == s2);      // calls S.opEquals
    assert(t1 == t2);      // calls compiler generated T.opEquals that implements member-wise equality
    assert(!(u1 &lt; u2));    // calls U.opCmp
    assert(!(v1 &lt; v2));    // calls U.opCmp because V does not define an opCmp method
                           // so the alias this of v1 is employed; U.opCmp expects a
                           // paramter of type U, so alias this of v2 is used

    assert(s1 == t1);      // calls s1.opEquals(t1.s);
    assert(t1 == s1);      // calls t1.s.opEquals(s1);
    assert(!(u1 &lt; v1));    // calls u1.opCmp(v1.u);
    assert(!(v1 &lt; u1));    // calls v1.u.opCmp(v1);
}
</pre> <p><a href="attribute#Attribute"><i>Attribute</i></a>s are ignored for <code>AliasThis</code>. </p>  <p>Multiple <i>AliasThis</i> are allowed. For implicit conversions and forwarded lookups, all <i>AliasThis</i> declarations are attempted; if more than one <i>AliasThis</i> is eligible, the ambiguity is disallowed by raising an error. Note: Multiple <i>AliasThis</i> is currently unimplemented. </p>   <h2 id="auto">Scope Classes</h2> <b>Note</b>: Scope classes have been <a href="https://dlang.org/deprecate.html#scope%20for%20allocating%20classes%20on%20the%20stack">recommended for deprecation</a>.  <p>A scope class is a class with the <code>scope</code> attribute, as in:</p>  <pre data-language="d">scope class Foo { ... }
</pre>  <p>The scope characteristic is inherited, so any classes derived from a scope class are also scope.</p>  <p>A scope class reference can only appear as a function local variable. It must be declared as being <code>scope</code>:</p>  <pre data-language="d">scope class Foo { ... }

void func()
{
    Foo f;    // error, reference to scope class must be scope
    scope Foo g = new Foo(); // correct
}
</pre>  <p>When a scope class reference goes out of scope, the destructor (if any) for it is automatically called. This holds true even if the scope was exited via a thrown exception.</p>  <h2 id="final">Final Classes</h2>  <p>Final classes cannot be subclassed:</p>  <pre data-language="d">final class A { }
class B : A { }  // error, class A is final
</pre>  <p>Methods of a final class are <code>final</code> by default.</p>  <h2 id="nested">Nested Classes</h2>  <p>A <i>nested class</i> is a class that is declared inside the scope of a function or another class. A nested class has access to the variables and other symbols of the classes and functions it is nested inside:</p>  <pre data-language="d">class Outer
{
    int m;

    class Inner
    {
        int foo()
        {
            return m;   // Ok to access member of Outer
        }
    }
}

void func()
{
    int m;

    class Inner
    {
        int foo()
        {
            return m; // Ok to access local variable m of func()
        }
    }
}
</pre>  <p>If a nested class has the <code>static</code> attribute, then it can not access variables of the enclosing scope that are local to the stack or need a <code>this</code>:</p>  <pre data-language="d">class Outer
{
    int m;
    static int n;

    static class Inner
    {
        int foo()
        {
            return m;   // Error, Inner is static and m needs a this
            return n;   // Ok, n is static
        }
    }
}

void func()
{
    int m;
    static int n;

    static class Inner
    {
        int foo()
        {
            return m;   // Error, Inner is static and m is local to the stack
            return n;   // Ok, n is static
        }
    }
}
</pre>  <p>Non-static nested classes work by containing an extra hidden member (called the context pointer) that is the frame pointer of the enclosing function if it is nested inside a function, or the <code>this</code> of the enclosing class's instance if it is nested inside a class.</p>  <p>When a non-static nested class is instantiated, the context pointer is assigned before the class's constructor is called, therefore the constructor has full access to the enclosing variables. A non-static nested class can only be instantiated when the necessary context pointer information is available:</p>  <pre data-language="d">class Outer
{
    class Inner { }

    static class SInner { }
}

void func()
{
    class Nested { }

    Outer o = new Outer;        // Ok
    Outer.Inner oi = new Outer.Inner;   // Error, no 'this' for Outer
    Outer.SInner os = new Outer.SInner; // Ok

    Nested n = new Nested;      // Ok
}
</pre>    <p>A <i>this</i> can be supplied to the creation of an inner class instance by prefixing it to the <i>NewExpression</i>: </p>  <pre data-language="d">class Outer
{
    int a;

    class Inner
    {
        int foo()
        {
            return a;
        }
    }
}

int bar()
{
    Outer o = new Outer;
    o.a = 3;
    Outer.Inner oi = o.new Inner;
    return oi.foo();    // returns 3
}
</pre>  <p>Here <code>o</code> supplies the <i>this</i> to the outer class instance of <code>Outer</code>. </p>  <p>The property <code>.outer</code> used in a nested class gives the <code>this</code> pointer to its enclosing class. If there is no enclosing class context, <code>.outer</code> would return a pointer to enclosing function frame with <code>void*</code>. </p>  <pre data-language="d">class Outer
{
    class Inner1
    {
        Outer getOuter()
        {
            return this.outer;
        }
    }

    void foo()
    {
        Inner1 i = new Inner1;
        assert(i.getOuter() is this);
    }

    void bar()
    {
        // x is referenced from nested scope, so
        // bar makes a closure envronment.
        int x = 1;

        class Inner2
        {
            Outer getOuter()
            {
                x = 2;
                // The Inner2 instance owns function frame of bar
                // as static frame pointer, but .outer yet returns
                // the enclosing Outer class instance property.
                return this.outer;
            }
        }

        Inner2 i = new Inner2;
        assert(i.getOuter() is this);
    }

    static void baz()
    {
        // make a closure envronment
        int x = 1;

        class Inner3
        {
            void* getOuter()
            {
                x = 2;
                // There's no accessible enclosing class instance, so
                // .outer property returns the function frame of bar.
                return this.outer;
            }
        }

        Inner3 i = new Inner3;
        assert(i.getOuter() !is null);
    }
}
</pre>  <h2 id="anonymous">Anonymous Nested Classes</h2>  <p>An anonymous nested class is both defined and instantiated with a <i>NewAnonClassExpression</i>: </p>  <pre>NewAnonClassExpression:
    new AllocatorArgumentsopt class ClassArgumentsopt SuperClassopt Interfacesopt AggregateBody

ClassArguments:
    ( ArgumentListopt )
</pre>  which is equivalent to:  <pre>class Identifier : SuperClass Interfaces AggregateBody
new (ArgumentList) Identifier (ArgumentList);
</pre>  where <i>Identifier</i> is the name generated for the anonymous nested class.  <h2><span id="ConstClass">Const, Immutable and Shared Classes</span></h2> <p>If a <i>ClassDeclaration</i> has a <code>const</code>, <code>immutable</code> or <code>shared</code> storage class, then it is as if each member of the class was declared with that storage class. If a base class is const, immutable or shared, then all classes derived from it are also const, immutable or shared. </p>    <div class="_attribution">
  <p class="_attribution-p">
    © 1999–2019 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/spec/class.html" class="_attribution-link">https://dlang.org/spec/class.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
