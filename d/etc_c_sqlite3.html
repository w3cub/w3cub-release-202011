
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>etc.c.sqlite3 - D - W3cubDocs</title>
  
  <meta name="description" content=" The type for a callback function. This is legacy and deprecated. It is included for historical compatibility and is not documented. ">
  <meta name="keywords" content="etc, c, sqlite, d">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/d/etc_c_sqlite3.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/d.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/d/" class="_nav-link" title="" style="margin-left:0;">D</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _d">
				
				
<h1>etc.c.sqlite3</h1>  <dl>
<dt class="d_decl" id="SQLITE_VERSION">enum string <strong id="SQLITE_VERSION">SQLITE_VERSION</strong>; <br><br>enum int <strong id="SQLITE_VERSION_NUMBER">SQLITE_VERSION_NUMBER</strong>; <br><br>enum string <strong id="SQLITE_SOURCE_ID">SQLITE_SOURCE_ID</strong>; </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Compile-Time Library Version Numbers</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_version">immutable(char)* <strong id="sqlite3_version">sqlite3_version</strong>; <br><br>nothrow immutable(char)* <strong id="sqlite3_libversion">sqlite3_libversion</strong>(); <br><br>nothrow immutable(char)* <strong id="sqlite3_sourceid">sqlite3_sourceid</strong>(); <br><br>nothrow int <strong id="sqlite3_libversion_number">sqlite3_libversion_number</strong>(); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Run-Time Library Version Numbers</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_compileoption_used">nothrow int <strong id="sqlite3_compileoption_used">sqlite3_compileoption_used</strong>(const char* zOptName); <br><br>nothrow immutable(char)* <strong id="sqlite3_compileoption_get">sqlite3_compileoption_get</strong>(int N); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Run-Time Library Compilation Options Diagnostics</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_threadsafe">nothrow int <strong id="sqlite3_threadsafe">sqlite3_threadsafe</strong>(); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Test To See If The Library Is Threadsafe</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3">struct <strong id="sqlite3">sqlite3</strong>; </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Database Connection Handle</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_int64">alias <strong id="sqlite3_int64">sqlite3_int64</strong> = long; </dt>  <dt class="d_decl" id="sqlite3_uint64">alias <strong id="sqlite3_uint64">sqlite3_uint64</strong> = ulong; </dt>  <dt class="d_decl" id="sqlite3_close">nothrow int <strong id="sqlite3_close">sqlite3_close</strong>(sqlite3*); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Closing A Database Connection</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_callback">alias <strong id="sqlite3_callback">sqlite3_callback</strong> = extern (C) int function(void*, int, char**, char**) nothrow; </dt> <dd>
<p>The type for a callback function. This is legacy and deprecated. It is included for historical compatibility and is not documented.</p> </dd> <dt class="d_decl" id="sqlite3_exec">nothrow int <strong id="sqlite3_exec">sqlite3_exec</strong>(sqlite3*, const(char)* sql, int function(void*, int, char**, char**) callback, void*, char** errmsg); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> One-Step Query Execution Interface</dd>
</dl> </dd> <dt class="d_decl" id="SQLITE_OK"><strong id="SQLITE_OK">SQLITE_OK</strong></dt> <dd>
<p>Successful result</p> </dd> <dt class="d_decl" id="SQLITE_ERROR"><strong id="SQLITE_ERROR">SQLITE_ERROR</strong></dt> <dd>
<p>Ditto </p>
<p>Generic error</p> </dd> <dt class="d_decl" id="SQLITE_INTERNAL"><strong id="SQLITE_INTERNAL">SQLITE_INTERNAL</strong></dt> <dd>
<p>Internal logic error in SQLite</p> </dd> <dt class="d_decl" id="SQLITE_PERM"><strong id="SQLITE_PERM">SQLITE_PERM</strong></dt> <dd>
<p>Access permission denied</p> </dd> <dt class="d_decl" id="SQLITE_ABORT"><strong id="SQLITE_ABORT">SQLITE_ABORT</strong></dt> <dd>
<p>Callback routine requested an abort</p> </dd> <dt class="d_decl" id="SQLITE_BUSY"><strong id="SQLITE_BUSY">SQLITE_BUSY</strong></dt> <dd>
<p>The database file is locked</p> </dd> <dt class="d_decl" id="SQLITE_LOCKED"><strong id="SQLITE_LOCKED">SQLITE_LOCKED</strong></dt> <dd>
<p>A table in the database is locked</p> </dd> <dt class="d_decl" id="SQLITE_NOMEM"><strong id="SQLITE_NOMEM">SQLITE_NOMEM</strong></dt> <dd>
<p>A malloc() failed</p> </dd> <dt class="d_decl" id="SQLITE_READONLY"><strong id="SQLITE_READONLY">SQLITE_READONLY</strong></dt> <dd>
<p>Attempt to write a readonly database</p> </dd> <dt class="d_decl" id="SQLITE_INTERRUPT"><strong id="SQLITE_INTERRUPT">SQLITE_INTERRUPT</strong></dt> <dd>
<p>Operation terminated by sqlite3_interrupt()</p> </dd> <dt class="d_decl" id="SQLITE_IOERR"><strong id="SQLITE_IOERR">SQLITE_IOERR</strong></dt> <dd>
<p>Some kind of disk I/O error occurred</p> </dd> <dt class="d_decl" id="SQLITE_CORRUPT"><strong id="SQLITE_CORRUPT">SQLITE_CORRUPT</strong></dt> <dd>
<p>The database disk image is malformed</p> </dd> <dt class="d_decl" id="SQLITE_NOTFOUND"><strong id="SQLITE_NOTFOUND">SQLITE_NOTFOUND</strong></dt> <dd>
<p>Unknown opcode in sqlite3_file_control()</p> </dd> <dt class="d_decl" id="SQLITE_FULL"><strong id="SQLITE_FULL">SQLITE_FULL</strong></dt> <dd>
<p>Insertion failed because database is full</p> </dd> <dt class="d_decl" id="SQLITE_CANTOPEN"><strong id="SQLITE_CANTOPEN">SQLITE_CANTOPEN</strong></dt> <dd>
<p>Unable to open the database file</p> </dd> <dt class="d_decl" id="SQLITE_PROTOCOL"><strong id="SQLITE_PROTOCOL">SQLITE_PROTOCOL</strong></dt> <dd>
<p>Database lock protocol error</p> </dd> <dt class="d_decl" id="SQLITE_EMPTY"><strong id="SQLITE_EMPTY">SQLITE_EMPTY</strong></dt> <dd>
<p>Internal use only</p> </dd> <dt class="d_decl" id="SQLITE_SCHEMA"><strong id="SQLITE_SCHEMA">SQLITE_SCHEMA</strong></dt> <dd>
<p>The database schema changed</p> </dd> <dt class="d_decl" id="SQLITE_TOOBIG"><strong id="SQLITE_TOOBIG">SQLITE_TOOBIG</strong></dt> <dd>
<p>String or BLOB exceeds size limit</p> </dd> <dt class="d_decl" id="SQLITE_CONSTRAINT"><strong id="SQLITE_CONSTRAINT">SQLITE_CONSTRAINT</strong></dt> <dd>
<p>Abort due to constraint violation</p> </dd> <dt class="d_decl" id="SQLITE_MISMATCH"><strong id="SQLITE_MISMATCH">SQLITE_MISMATCH</strong></dt> <dd>
<p>Data type mismatch</p> </dd> <dt class="d_decl" id="SQLITE_MISUSE"><strong id="SQLITE_MISUSE">SQLITE_MISUSE</strong></dt> <dd>
<p>Library used incorrectly</p> </dd> <dt class="d_decl" id="SQLITE_NOLFS"><strong id="SQLITE_NOLFS">SQLITE_NOLFS</strong></dt> <dd>
<p>Uses OS features not supported on host</p> </dd> <dt class="d_decl" id="SQLITE_AUTH"><strong id="SQLITE_AUTH">SQLITE_AUTH</strong></dt> <dd>
<p>Authorization denied</p> </dd> <dt class="d_decl" id="SQLITE_FORMAT"><strong id="SQLITE_FORMAT">SQLITE_FORMAT</strong></dt> <dd>
<p>Not used</p> </dd> <dt class="d_decl" id="SQLITE_RANGE"><strong id="SQLITE_RANGE">SQLITE_RANGE</strong></dt> <dd>
<p>2nd parameter to sqlite3_bind out of range</p> </dd> <dt class="d_decl" id="SQLITE_NOTADB"><strong id="SQLITE_NOTADB">SQLITE_NOTADB</strong></dt> <dd>
<p>File opened that is not a database file</p> </dd> <dt class="d_decl" id="SQLITE_ROW"><strong id="SQLITE_ROW">SQLITE_ROW</strong></dt> <dd>
<p>sqlite3_step() has another row ready</p> </dd> <dt class="d_decl" id="SQLITE_DONE"><strong id="SQLITE_DONE">SQLITE_DONE</strong></dt> <dd>
<p>sqlite3_step() has finished executing</p> </dd> <dt class="d_decl" id="SQLITE_OPEN_READONLY"><strong id="SQLITE_OPEN_READONLY">SQLITE_OPEN_READONLY</strong></dt> <dd>
<p>Ok for sqlite3_open_v2()</p> </dd> <dt class="d_decl" id="SQLITE_OPEN_READWRITE"><strong id="SQLITE_OPEN_READWRITE">SQLITE_OPEN_READWRITE</strong></dt> <dd>
<p>Ok for sqlite3_open_v2()</p> </dd> <dt class="d_decl" id="SQLITE_OPEN_CREATE"><strong id="SQLITE_OPEN_CREATE">SQLITE_OPEN_CREATE</strong></dt> <dd>
<p>Ok for sqlite3_open_v2()</p> </dd> <dt class="d_decl" id="SQLITE_OPEN_DELETEONCLOSE"><strong id="SQLITE_OPEN_DELETEONCLOSE">SQLITE_OPEN_DELETEONCLOSE</strong></dt> <dd>
<p>VFS only</p> </dd> <dt class="d_decl" id="SQLITE_OPEN_EXCLUSIVE"><strong id="SQLITE_OPEN_EXCLUSIVE">SQLITE_OPEN_EXCLUSIVE</strong></dt> <dd>
<p>VFS only</p> </dd> <dt class="d_decl" id="SQLITE_OPEN_AUTOPROXY"><strong id="SQLITE_OPEN_AUTOPROXY">SQLITE_OPEN_AUTOPROXY</strong></dt> <dd>
<p>VFS only</p> </dd> <dt class="d_decl" id="SQLITE_OPEN_URI"><strong id="SQLITE_OPEN_URI">SQLITE_OPEN_URI</strong></dt> <dd>
<p>Ok for sqlite3_open_v2()</p> </dd> <dt class="d_decl" id="SQLITE_OPEN_MEMORY"><strong id="SQLITE_OPEN_MEMORY">SQLITE_OPEN_MEMORY</strong></dt> <dd>
<p>Ok for sqlite3_open_v2()</p> </dd> <dt class="d_decl" id="SQLITE_OPEN_MAIN_DB"><strong id="SQLITE_OPEN_MAIN_DB">SQLITE_OPEN_MAIN_DB</strong></dt> <dd>
<p>VFS only</p> </dd> <dt class="d_decl" id="SQLITE_OPEN_TEMP_DB"><strong id="SQLITE_OPEN_TEMP_DB">SQLITE_OPEN_TEMP_DB</strong></dt> <dd>
<p>VFS only</p> </dd> <dt class="d_decl" id="SQLITE_OPEN_TRANSIENT_DB"><strong id="SQLITE_OPEN_TRANSIENT_DB">SQLITE_OPEN_TRANSIENT_DB</strong></dt> <dd>
<p>VFS only</p> </dd> <dt class="d_decl" id="SQLITE_OPEN_MAIN_JOURNAL"><strong id="SQLITE_OPEN_MAIN_JOURNAL">SQLITE_OPEN_MAIN_JOURNAL</strong></dt> <dd>
<p>VFS only</p> </dd> <dt class="d_decl" id="SQLITE_OPEN_TEMP_JOURNAL"><strong id="SQLITE_OPEN_TEMP_JOURNAL">SQLITE_OPEN_TEMP_JOURNAL</strong></dt> <dd>
<p>VFS only</p> </dd> <dt class="d_decl" id="SQLITE_OPEN_SUBJOURNAL"><strong id="SQLITE_OPEN_SUBJOURNAL">SQLITE_OPEN_SUBJOURNAL</strong></dt> <dd>
<p>VFS only</p> </dd> <dt class="d_decl" id="SQLITE_OPEN_MASTER_JOURNAL"><strong id="SQLITE_OPEN_MASTER_JOURNAL">SQLITE_OPEN_MASTER_JOURNAL</strong></dt> <dd>
<p>VFS only</p> </dd> <dt class="d_decl" id="SQLITE_OPEN_NOMUTEX"><strong id="SQLITE_OPEN_NOMUTEX">SQLITE_OPEN_NOMUTEX</strong></dt> <dd>
<p>Ok for sqlite3_open_v2()</p> </dd> <dt class="d_decl" id="SQLITE_OPEN_FULLMUTEX"><strong id="SQLITE_OPEN_FULLMUTEX">SQLITE_OPEN_FULLMUTEX</strong></dt> <dd>
<p>Ok for sqlite3_open_v2()</p> </dd> <dt class="d_decl" id="SQLITE_OPEN_SHAREDCACHE"><strong id="SQLITE_OPEN_SHAREDCACHE">SQLITE_OPEN_SHAREDCACHE</strong></dt> <dd>
<p>Ok for sqlite3_open_v2()</p> </dd> <dt class="d_decl" id="SQLITE_OPEN_PRIVATECACHE"><strong id="SQLITE_OPEN_PRIVATECACHE">SQLITE_OPEN_PRIVATECACHE</strong></dt> <dd>
<p>Ok for sqlite3_open_v2()</p> </dd> <dt class="d_decl" id="SQLITE_OPEN_WAL"><strong id="SQLITE_OPEN_WAL">SQLITE_OPEN_WAL</strong></dt> <dd>
<p>VFS only</p> </dd> <dt class="d_decl" id="sqlite3_file">struct <strong id="sqlite3_file">sqlite3_file</strong>; </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> OS Interface Open File Handle</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_io_methods">struct <strong id="sqlite3_io_methods">sqlite3_io_methods</strong>; </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> OS Interface File Virtual Methods Object</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_mutex">struct <strong id="sqlite3_mutex">sqlite3_mutex</strong>; </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Mutex Handle</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_api_routines">struct <strong id="sqlite3_api_routines">sqlite3_api_routines</strong>; </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Loadable Extension Thunk</dd>
</dl> </dd> <dt class="d_decl" id="xDlSymReturn">alias <strong id="xDlSymReturn">xDlSymReturn</strong> = extern (C) void* function() nothrow; <br><br>alias <strong id="sqlite3_syscall_ptr">sqlite3_syscall_ptr</strong> = extern (C) void function() nothrow; </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> OS Interface Object</dd>
</dl> </dd> <dt class="d_decl" id="SQLITE_ACCESS_READWRITE"><strong id="SQLITE_ACCESS_READWRITE">SQLITE_ACCESS_READWRITE</strong></dt> <dd>
<p>Used by PRAGMA temp_store_directory</p> </dd> <dt class="d_decl" id="SQLITE_ACCESS_READ"><strong id="SQLITE_ACCESS_READ">SQLITE_ACCESS_READ</strong></dt> <dd>
<p>Unused</p> </dd> <dt class="d_decl" id="SQLITE_SHM_NLOCK">enum int <strong id="SQLITE_SHM_NLOCK">SQLITE_SHM_NLOCK</strong>; </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Maximum xShmLock index</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_initialize">nothrow int <strong id="sqlite3_initialize">sqlite3_initialize</strong>(); <br><br>nothrow int <strong id="sqlite3_shutdown">sqlite3_shutdown</strong>(); <br><br>nothrow int <strong id="sqlite3_os_init">sqlite3_os_init</strong>(); <br><br>nothrow int <strong id="sqlite3_os_end">sqlite3_os_end</strong>(); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Initialize The SQLite Library</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_config">nothrow int <strong id="sqlite3_config">sqlite3_config</strong>(int, ...); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Configuring The SQLite Library</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_db_config">nothrow int <strong id="sqlite3_db_config">sqlite3_db_config</strong>(sqlite3*, int op, ...); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Configure database connections</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_mem_methods">struct <strong id="sqlite3_mem_methods">sqlite3_mem_methods</strong>; </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Memory Allocation Routines</dd>
</dl> <dl>
<dt class="d_decl" id="sqlite3_mem_methods.xMalloc">void* function(int) <strong id="xMalloc">xMalloc</strong>; </dt> <dd>
<p>Memory allocation function</p> </dd> <dt class="d_decl" id="sqlite3_mem_methods.xFree">void function(void*) <strong id="xFree">xFree</strong>; </dt> <dd>
<p>Free a prior allocation</p> </dd> <dt class="d_decl" id="sqlite3_mem_methods.xRealloc">void* function(void*, int) <strong id="xRealloc">xRealloc</strong>; </dt> <dd>
<p>Resize an allocation</p> </dd> <dt class="d_decl" id="sqlite3_mem_methods.xSize">int function(void*) <strong id="xSize">xSize</strong>; </dt> <dd>
<p>Return the size of an allocation</p> </dd> <dt class="d_decl" id="sqlite3_mem_methods.xRoundup">int function(int) <strong id="xRoundup">xRoundup</strong>; </dt> <dd>
<p>Round up request size to allocation size</p> </dd> <dt class="d_decl" id="sqlite3_mem_methods.xInit">int function(void*) <strong id="xInit">xInit</strong>; </dt> <dd>
<p>Initialize the memory allocator</p> </dd> <dt class="d_decl" id="sqlite3_mem_methods.xShutdown">void function(void*) <strong id="xShutdown">xShutdown</strong>; </dt> <dd>
<p>Deinitialize the memory allocator</p> </dd> <dt class="d_decl" id="sqlite3_mem_methods.pAppData">void* <strong id="pAppData">pAppData</strong>; </dt> <dd>
<p>Argument to xInit() and xShutdown()</p> </dd> </dl> </dd> <dt class="d_decl" id="SQLITE_CONFIG_SINGLETHREAD"><strong id="SQLITE_CONFIG_SINGLETHREAD">SQLITE_CONFIG_SINGLETHREAD</strong></dt> <dd>
<p>nil</p> </dd> <dt class="d_decl" id="SQLITE_CONFIG_MULTITHREAD"><strong id="SQLITE_CONFIG_MULTITHREAD">SQLITE_CONFIG_MULTITHREAD</strong></dt> <dd>
<p>nil</p> </dd> <dt class="d_decl" id="SQLITE_CONFIG_SERIALIZED"><strong id="SQLITE_CONFIG_SERIALIZED">SQLITE_CONFIG_SERIALIZED</strong></dt> <dd>
<p>nil</p> </dd> <dt class="d_decl" id="SQLITE_CONFIG_MALLOC"><strong id="SQLITE_CONFIG_MALLOC">SQLITE_CONFIG_MALLOC</strong></dt> <dd>
<p>sqlite3_mem_methods*</p> </dd> <dt class="d_decl" id="SQLITE_CONFIG_GETMALLOC"><strong id="SQLITE_CONFIG_GETMALLOC">SQLITE_CONFIG_GETMALLOC</strong></dt> <dd>
<p>sqlite3_mem_methods*</p> </dd> <dt class="d_decl" id="SQLITE_CONFIG_SCRATCH"><strong id="SQLITE_CONFIG_SCRATCH">SQLITE_CONFIG_SCRATCH</strong></dt> <dd>
<p>No longer used</p> </dd> <dt class="d_decl" id="SQLITE_CONFIG_PAGECACHE"><strong id="SQLITE_CONFIG_PAGECACHE">SQLITE_CONFIG_PAGECACHE</strong></dt> <dd>
<p>void*, int sz, int N</p> </dd> <dt class="d_decl" id="SQLITE_CONFIG_HEAP"><strong id="SQLITE_CONFIG_HEAP">SQLITE_CONFIG_HEAP</strong></dt> <dd>
<p>void*, int nByte, int min</p> </dd> <dt class="d_decl" id="SQLITE_CONFIG_MEMSTATUS"><strong id="SQLITE_CONFIG_MEMSTATUS">SQLITE_CONFIG_MEMSTATUS</strong></dt> <dd>
<p>boolean</p> </dd> <dt class="d_decl" id="SQLITE_CONFIG_MUTEX"><strong id="SQLITE_CONFIG_MUTEX">SQLITE_CONFIG_MUTEX</strong></dt> <dd>
<p>sqlite3_mutex_methods*</p> </dd> <dt class="d_decl" id="SQLITE_CONFIG_GETMUTEX"><strong id="SQLITE_CONFIG_GETMUTEX">SQLITE_CONFIG_GETMUTEX</strong></dt> <dd>
<p>sqlite3_mutex_methods*</p> </dd> <dt class="d_decl" id="SQLITE_CONFIG_LOOKASIDE"><strong id="SQLITE_CONFIG_LOOKASIDE">SQLITE_CONFIG_LOOKASIDE</strong></dt> <dd>
<p>int int</p> </dd> <dt class="d_decl" id="SQLITE_CONFIG_PCACHE"><strong id="SQLITE_CONFIG_PCACHE">SQLITE_CONFIG_PCACHE</strong></dt> <dd>
<p>no-op</p> </dd> <dt class="d_decl" id="SQLITE_CONFIG_GETPCACHE"><strong id="SQLITE_CONFIG_GETPCACHE">SQLITE_CONFIG_GETPCACHE</strong></dt> <dd>
<p>no-op</p> </dd> <dt class="d_decl" id="SQLITE_CONFIG_LOG"><strong id="SQLITE_CONFIG_LOG">SQLITE_CONFIG_LOG</strong></dt> <dd>
<p>xFunc, void*</p> </dd> <dt class="d_decl" id="SQLITE_CONFIG_URI"><strong id="SQLITE_CONFIG_URI">SQLITE_CONFIG_URI</strong></dt> <dd>
<p>int</p> </dd> <dt class="d_decl" id="SQLITE_CONFIG_PCACHE2"><strong id="SQLITE_CONFIG_PCACHE2">SQLITE_CONFIG_PCACHE2</strong></dt> <dd>
<p>sqlite3_pcache_methods2*</p> </dd> <dt class="d_decl" id="SQLITE_CONFIG_GETPCACHE2"><strong id="SQLITE_CONFIG_GETPCACHE2">SQLITE_CONFIG_GETPCACHE2</strong></dt> <dd>
<p>sqlite3_pcache_methods2*</p> </dd> <dt class="d_decl" id="SQLITE_CONFIG_COVERING_INDEX_SCAN"><strong id="SQLITE_CONFIG_COVERING_INDEX_SCAN">SQLITE_CONFIG_COVERING_INDEX_SCAN</strong></dt> <dd>
<p>int</p> </dd> <dt class="d_decl" id="SQLITE_CONFIG_SQLLOG"><strong id="SQLITE_CONFIG_SQLLOG">SQLITE_CONFIG_SQLLOG</strong></dt> <dd>
<p>xSqllog, void*</p> </dd> <dt class="d_decl" id="SQLITE_CONFIG_MMAP_SIZE"><strong id="SQLITE_CONFIG_MMAP_SIZE">SQLITE_CONFIG_MMAP_SIZE</strong></dt> <dd>
<p>sqlite3_int64, sqlite3_int64</p> </dd> <dt class="d_decl" id="SQLITE_CONFIG_WIN32_HEAPSIZE"><strong id="SQLITE_CONFIG_WIN32_HEAPSIZE">SQLITE_CONFIG_WIN32_HEAPSIZE</strong></dt> <dd>
<p>int nByte</p> </dd> <dt class="d_decl" id="SQLITE_CONFIG_PCACHE_HDRSZ"><strong id="SQLITE_CONFIG_PCACHE_HDRSZ">SQLITE_CONFIG_PCACHE_HDRSZ</strong></dt> <dd>
<p>int *psz</p> </dd> <dt class="d_decl" id="SQLITE_CONFIG_PMASZ"><strong id="SQLITE_CONFIG_PMASZ">SQLITE_CONFIG_PMASZ</strong></dt> <dd>
<p>unsigned int szPma</p> </dd> <dt class="d_decl" id="SQLITE_CONFIG_STMTJRNL_SPILL"><strong id="SQLITE_CONFIG_STMTJRNL_SPILL">SQLITE_CONFIG_STMTJRNL_SPILL</strong></dt> <dd>
<p>int nByte</p> </dd> <dt class="d_decl" id="SQLITE_CONFIG_SMALL_MALLOC"><strong id="SQLITE_CONFIG_SMALL_MALLOC">SQLITE_CONFIG_SMALL_MALLOC</strong></dt> <dd>
<p>boolean</p> </dd> <dt class="d_decl" id="SQLITE_CONFIG_SORTERREF_SIZE"><strong id="SQLITE_CONFIG_SORTERREF_SIZE">SQLITE_CONFIG_SORTERREF_SIZE</strong></dt> <dd>
<p>int nByte</p> </dd> <dt class="d_decl" id="SQLITE_CONFIG_MEMDB_MAXSIZE"><strong id="SQLITE_CONFIG_MEMDB_MAXSIZE">SQLITE_CONFIG_MEMDB_MAXSIZE</strong></dt> <dd>
<p>sqlite3_int64</p> </dd> <dt class="d_decl" id="SQLITE_DBCONFIG_MAINDBNAME"><strong id="SQLITE_DBCONFIG_MAINDBNAME">SQLITE_DBCONFIG_MAINDBNAME</strong></dt> <dd>
<p>const char*</p> </dd> <dt class="d_decl" id="SQLITE_DBCONFIG_LOOKASIDE"><strong id="SQLITE_DBCONFIG_LOOKASIDE">SQLITE_DBCONFIG_LOOKASIDE</strong></dt> <dd>
<p>void* int int</p> </dd> <dt class="d_decl" id="SQLITE_DBCONFIG_ENABLE_FKEY"><strong id="SQLITE_DBCONFIG_ENABLE_FKEY">SQLITE_DBCONFIG_ENABLE_FKEY</strong></dt> <dd>
<p>int int*</p> </dd> <dt class="d_decl" id="SQLITE_DBCONFIG_ENABLE_TRIGGER"><strong id="SQLITE_DBCONFIG_ENABLE_TRIGGER">SQLITE_DBCONFIG_ENABLE_TRIGGER</strong></dt> <dd>
<p>int int*</p> </dd> <dt class="d_decl" id="SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER"><strong id="SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER">SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER</strong></dt> <dd>
<p>int int*</p> </dd> <dt class="d_decl" id="SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION"><strong id="SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION">SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION</strong></dt> <dd>
<p>int int*</p> </dd> <dt class="d_decl" id="SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE"><strong id="SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE">SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE</strong></dt> <dd>
<p>int int*</p> </dd> <dt class="d_decl" id="SQLITE_DBCONFIG_ENABLE_QPSG"><strong id="SQLITE_DBCONFIG_ENABLE_QPSG">SQLITE_DBCONFIG_ENABLE_QPSG</strong></dt> <dd>
<p>int int*</p> </dd> <dt class="d_decl" id="SQLITE_DBCONFIG_TRIGGER_EQP"><strong id="SQLITE_DBCONFIG_TRIGGER_EQP">SQLITE_DBCONFIG_TRIGGER_EQP</strong></dt> <dd>
<p>int int*</p> </dd> <dt class="d_decl" id="SQLITE_DBCONFIG_RESET_DATABASE"><strong id="SQLITE_DBCONFIG_RESET_DATABASE">SQLITE_DBCONFIG_RESET_DATABASE</strong></dt> <dd>
<p>int int*</p> </dd> <dt class="d_decl" id="SQLITE_DBCONFIG_DEFENSIVE"><strong id="SQLITE_DBCONFIG_DEFENSIVE">SQLITE_DBCONFIG_DEFENSIVE</strong></dt> <dd>
<p>int int*</p> </dd> <dt class="d_decl" id="SQLITE_DBCONFIG_WRITABLE_SCHEMA"><strong id="SQLITE_DBCONFIG_WRITABLE_SCHEMA">SQLITE_DBCONFIG_WRITABLE_SCHEMA</strong></dt> <dd>
<p>int int*</p> </dd> <dt class="d_decl" id="SQLITE_DBCONFIG_MAX"><strong id="SQLITE_DBCONFIG_MAX">SQLITE_DBCONFIG_MAX</strong></dt> <dd>
<p>Largest DBCONFIG</p> </dd> <dt class="d_decl" id="sqlite3_extended_result_codes">nothrow int <strong id="sqlite3_extended_result_codes">sqlite3_extended_result_codes</strong>(sqlite3*, int onoff); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Enable Or Disable Extended Result Codes</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_last_insert_rowid">nothrow sqlite3_int64 <strong id="sqlite3_last_insert_rowid">sqlite3_last_insert_rowid</strong>(sqlite3*); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Last Insert Rowid</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_set_last_insert_rowid">nothrow void <strong id="sqlite3_set_last_insert_rowid">sqlite3_set_last_insert_rowid</strong>(sqlite3*, sqlite3_int64); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Set the Last Insert Rowid value</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_changes">nothrow int <strong id="sqlite3_changes">sqlite3_changes</strong>(sqlite3*); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Count The Number Of Rows Modified</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_total_changes">nothrow int <strong id="sqlite3_total_changes">sqlite3_total_changes</strong>(sqlite3*); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Total Number Of Rows Modified</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_interrupt">nothrow void <strong id="sqlite3_interrupt">sqlite3_interrupt</strong>(sqlite3*); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Interrupt A Long-Running Query</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_complete">nothrow int <strong id="sqlite3_complete">sqlite3_complete</strong>(const char* sql); <br><br>nothrow int <strong id="sqlite3_complete16">sqlite3_complete16</strong>(const void* sql); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Determine If An SQL Statement Is Complete</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_busy_handler">nothrow int <strong id="sqlite3_busy_handler">sqlite3_busy_handler</strong>(sqlite3*, int function(void*, int), void*); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Register A Callback To Handle SQLITE_BUSY Errors</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_busy_timeout">nothrow int <strong id="sqlite3_busy_timeout">sqlite3_busy_timeout</strong>(sqlite3*, int ms); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Set A Busy Timeout</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_get_table">nothrow int <strong id="sqlite3_get_table">sqlite3_get_table</strong>(sqlite3* db, const(char)* zSql, char*** pazResult, int* pnRow, int* pnColumn, char** pzErrmsg); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Convenience Routines For Running Queries</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_free_table">nothrow void <strong id="sqlite3_free_table">sqlite3_free_table</strong>(char** result); </dt>  <dt class="d_decl" id="sqlite3_mprintf">nothrow char* <strong id="sqlite3_mprintf">sqlite3_mprintf</strong>(const char*, ...); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Formatted String Printing Functions</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_malloc">nothrow void* <strong id="sqlite3_malloc">sqlite3_malloc</strong>(int); <br><br>nothrow void* <strong id="sqlite3_malloc64">sqlite3_malloc64</strong>(sqlite3_uint64); <br><br>nothrow void* <strong id="sqlite3_realloc">sqlite3_realloc</strong>(void*, int); <br><br>nothrow void* <strong id="sqlite3_realloc64">sqlite3_realloc64</strong>(void*, sqlite3_uint64); <br><br>nothrow void <strong id="sqlite3_free">sqlite3_free</strong>(void*); <br><br>nothrow sqlite3_uint64 <strong id="sqlite3_msize">sqlite3_msize</strong>(void*); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Memory Allocation Subsystem</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_memory_used">nothrow sqlite3_int64 <strong id="sqlite3_memory_used">sqlite3_memory_used</strong>(); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Memory Allocator Statistics</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_randomness">nothrow void <strong id="sqlite3_randomness">sqlite3_randomness</strong>(int N, void* P); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Pseudo-Random Number Generator</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_set_authorizer">nothrow int <strong id="sqlite3_set_authorizer">sqlite3_set_authorizer</strong>(sqlite3*, int function(void*, int, const char*, const char*, const char*, const char*) xAuth, void* pUserData); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Compile-Time Authorization Callbacks</dd>
</dl> </dd> <dt class="d_decl" id="SQLITE_DENY"><strong id="SQLITE_DENY">SQLITE_DENY</strong></dt> <dd>
<p>Abort the SQL statement with an error</p> </dd> <dt class="d_decl" id="SQLITE_IGNORE"><strong id="SQLITE_IGNORE">SQLITE_IGNORE</strong></dt> <dd>
<p>Don't allow access, but don't generate an error</p> </dd> <dt class="d_decl" id="SQLITE_CREATE_INDEX"><strong id="SQLITE_CREATE_INDEX">SQLITE_CREATE_INDEX</strong></dt> <dd>
<p>Index Name Table Name</p> </dd> <dt class="d_decl" id="SQLITE_CREATE_TABLE"><strong id="SQLITE_CREATE_TABLE">SQLITE_CREATE_TABLE</strong></dt> <dd>
<p>Table Name NULL</p> </dd> <dt class="d_decl" id="SQLITE_CREATE_TEMP_INDEX"><strong id="SQLITE_CREATE_TEMP_INDEX">SQLITE_CREATE_TEMP_INDEX</strong></dt> <dd>
<p>Index Name Table Name</p> </dd> <dt class="d_decl" id="SQLITE_CREATE_TEMP_TABLE"><strong id="SQLITE_CREATE_TEMP_TABLE">SQLITE_CREATE_TEMP_TABLE</strong></dt> <dd>
<p>Table Name NULL</p> </dd> <dt class="d_decl" id="SQLITE_CREATE_TEMP_TRIGGER"><strong id="SQLITE_CREATE_TEMP_TRIGGER">SQLITE_CREATE_TEMP_TRIGGER</strong></dt> <dd>
<p>Trigger Name Table Name</p> </dd> <dt class="d_decl" id="SQLITE_CREATE_TEMP_VIEW"><strong id="SQLITE_CREATE_TEMP_VIEW">SQLITE_CREATE_TEMP_VIEW</strong></dt> <dd>
<p>View Name NULL</p> </dd> <dt class="d_decl" id="SQLITE_CREATE_TRIGGER"><strong id="SQLITE_CREATE_TRIGGER">SQLITE_CREATE_TRIGGER</strong></dt> <dd>
<p>Trigger Name Table Name</p> </dd> <dt class="d_decl" id="SQLITE_CREATE_VIEW"><strong id="SQLITE_CREATE_VIEW">SQLITE_CREATE_VIEW</strong></dt> <dd>
<p>View Name NULL</p> </dd> <dt class="d_decl" id="SQLITE_DELETE"><strong id="SQLITE_DELETE">SQLITE_DELETE</strong></dt> <dd>
<p>Table Name NULL</p> </dd> <dt class="d_decl" id="SQLITE_DROP_INDEX"><strong id="SQLITE_DROP_INDEX">SQLITE_DROP_INDEX</strong></dt> <dd>
<p>Index Name Table Name</p> </dd> <dt class="d_decl" id="SQLITE_DROP_TABLE"><strong id="SQLITE_DROP_TABLE">SQLITE_DROP_TABLE</strong></dt> <dd>
<p>Table Name NULL</p> </dd> <dt class="d_decl" id="SQLITE_DROP_TEMP_INDEX"><strong id="SQLITE_DROP_TEMP_INDEX">SQLITE_DROP_TEMP_INDEX</strong></dt> <dd>
<p>Index Name Table Name</p> </dd> <dt class="d_decl" id="SQLITE_DROP_TEMP_TABLE"><strong id="SQLITE_DROP_TEMP_TABLE">SQLITE_DROP_TEMP_TABLE</strong></dt> <dd>
<p>Table Name NULL</p> </dd> <dt class="d_decl" id="SQLITE_DROP_TEMP_TRIGGER"><strong id="SQLITE_DROP_TEMP_TRIGGER">SQLITE_DROP_TEMP_TRIGGER</strong></dt> <dd>
<p>Trigger Name Table Name</p> </dd> <dt class="d_decl" id="SQLITE_DROP_TEMP_VIEW"><strong id="SQLITE_DROP_TEMP_VIEW">SQLITE_DROP_TEMP_VIEW</strong></dt> <dd>
<p>View Name NULL</p> </dd> <dt class="d_decl" id="SQLITE_DROP_TRIGGER"><strong id="SQLITE_DROP_TRIGGER">SQLITE_DROP_TRIGGER</strong></dt> <dd>
<p>Trigger Name Table Name</p> </dd> <dt class="d_decl" id="SQLITE_DROP_VIEW"><strong id="SQLITE_DROP_VIEW">SQLITE_DROP_VIEW</strong></dt> <dd>
<p>View Name NULL</p> </dd> <dt class="d_decl" id="SQLITE_INSERT"><strong id="SQLITE_INSERT">SQLITE_INSERT</strong></dt> <dd>
<p>Table Name NULL</p> </dd> <dt class="d_decl" id="SQLITE_PRAGMA"><strong id="SQLITE_PRAGMA">SQLITE_PRAGMA</strong></dt> <dd>
<p>Pragma Name 1st arg or NULL</p> </dd> <dt class="d_decl" id="SQLITE_READ"><strong id="SQLITE_READ">SQLITE_READ</strong></dt> <dd>
<p>Table Name Column Name</p> </dd> <dt class="d_decl" id="SQLITE_SELECT"><strong id="SQLITE_SELECT">SQLITE_SELECT</strong></dt> <dd>
<p>NULL NULL</p> </dd> <dt class="d_decl" id="SQLITE_TRANSACTION"><strong id="SQLITE_TRANSACTION">SQLITE_TRANSACTION</strong></dt> <dd>
<p>Operation NULL</p> </dd> <dt class="d_decl" id="SQLITE_UPDATE"><strong id="SQLITE_UPDATE">SQLITE_UPDATE</strong></dt> <dd>
<p>Table Name Column Name</p> </dd> <dt class="d_decl" id="SQLITE_ATTACH"><strong id="SQLITE_ATTACH">SQLITE_ATTACH</strong></dt> <dd>
<p>Filename NULL</p> </dd> <dt class="d_decl" id="SQLITE_DETACH"><strong id="SQLITE_DETACH">SQLITE_DETACH</strong></dt> <dd>
<p>Database Name NULL</p> </dd> <dt class="d_decl" id="SQLITE_ALTER_TABLE"><strong id="SQLITE_ALTER_TABLE">SQLITE_ALTER_TABLE</strong></dt> <dd>
<p>Database Name Table Name</p> </dd> <dt class="d_decl" id="SQLITE_REINDEX"><strong id="SQLITE_REINDEX">SQLITE_REINDEX</strong></dt> <dd>
<p>Index Name NULL</p> </dd> <dt class="d_decl" id="SQLITE_ANALYZE"><strong id="SQLITE_ANALYZE">SQLITE_ANALYZE</strong></dt> <dd>
<p>Table Name NULL</p> </dd> <dt class="d_decl" id="SQLITE_CREATE_VTABLE"><strong id="SQLITE_CREATE_VTABLE">SQLITE_CREATE_VTABLE</strong></dt> <dd>
<p>Table Name Module Name</p> </dd> <dt class="d_decl" id="SQLITE_DROP_VTABLE"><strong id="SQLITE_DROP_VTABLE">SQLITE_DROP_VTABLE</strong></dt> <dd>
<p>Table Name Module Name</p> </dd> <dt class="d_decl" id="SQLITE_FUNCTION"><strong id="SQLITE_FUNCTION">SQLITE_FUNCTION</strong></dt> <dd>
<p>NULL Function Name</p> </dd> <dt class="d_decl" id="SQLITE_SAVEPOINT"><strong id="SQLITE_SAVEPOINT">SQLITE_SAVEPOINT</strong></dt> <dd>
<p>Operation Savepoint Name</p> </dd> <dt class="d_decl" id="SQLITE_COPY"><strong id="SQLITE_COPY">SQLITE_COPY</strong></dt> <dd>
<p>No longer used</p> </dd> <dt class="d_decl" id="SQLITE_RECURSIVE"><strong id="SQLITE_RECURSIVE">SQLITE_RECURSIVE</strong></dt> <dd>
<p>NULL NULL</p> </dd> <dt class="d_decl" id="sqlite3_trace">deprecated nothrow void* <strong id="sqlite3_trace">sqlite3_trace</strong>(sqlite3*, void function(void*, const char*) xTrace, void*); <br><br>deprecated nothrow void* <strong id="sqlite3_profile">sqlite3_profile</strong>(sqlite3*, void function(void*, const char*, sqlite3_uint64) xProfile, void*); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Tracing And Profiling Functions</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_trace_v2">nothrow int <strong id="sqlite3_trace_v2">sqlite3_trace_v2</strong>(sqlite3*, uint uMask, int function(uint, void*, void*, void*) xCallback, void* pCtx); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> SQL Trace Hook</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_progress_handler">nothrow void <strong id="sqlite3_progress_handler">sqlite3_progress_handler</strong>(sqlite3*, int, int function(void*), void*); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Query Progress Callbacks</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_open">nothrow int <strong id="sqlite3_open">sqlite3_open</strong>(const(char)* filename, sqlite3** ppDb); <br><br>nothrow int <strong id="sqlite3_open16">sqlite3_open16</strong>(const(void)* filename, sqlite3** ppDb); <br><br>nothrow int <strong id="sqlite3_open_v2">sqlite3_open_v2</strong>(const(char)* filename, sqlite3** ppDb, int flags, const(char)* zVfs); <br><br>nothrow int <strong id="sqlite3_uri_boolean">sqlite3_uri_boolean</strong>(const(char)* zFile, const(char)* zParam, int bDefault); <br><br>nothrow sqlite3_int64 <strong id="sqlite3_uri_int64">sqlite3_uri_int64</strong>(const char*, const char*, sqlite3_int64); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Opening A New Database Connection</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_errcode">nothrow int <strong id="sqlite3_errcode">sqlite3_errcode</strong>(sqlite3* db); <br><br>nothrow int <strong id="sqlite3_extended_errcode">sqlite3_extended_errcode</strong>(sqlite3* db); <br><br>nothrow const(char)* <strong id="sqlite3_errmsg">sqlite3_errmsg</strong>(sqlite3*); <br><br>nothrow const(void)* <strong id="sqlite3_errmsg16">sqlite3_errmsg16</strong>(sqlite3*); <br><br>nothrow const(char)* <strong id="sqlite3_errstr">sqlite3_errstr</strong>(int); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Error Codes And Messages</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_stmt">struct <strong id="sqlite3_stmt">sqlite3_stmt</strong>; </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> SQL Statement Object</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_limit">nothrow int <strong id="sqlite3_limit">sqlite3_limit</strong>(sqlite3*, int id, int newVal); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Run-time Limits</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_prepare">nothrow int <strong id="sqlite3_prepare">sqlite3_prepare</strong>(sqlite3* db, const(char)* zSql, int nByte, sqlite3_stmt** ppStmt, const(char*)* pzTail); <br><br>nothrow int <strong id="sqlite3_prepare_v2">sqlite3_prepare_v2</strong>(sqlite3* db, const(char)* zSql, int nByte, sqlite3_stmt** ppStmt, const(char*)* pzTail); <br><br>nothrow int <strong id="sqlite3_prepare_v3">sqlite3_prepare_v3</strong>(sqlite3* db, const(char)* zSql, int nByte, uint prepFlags, sqlite3_stmt** ppStmt, const(char*)* pzTail); <br><br>nothrow int <strong id="sqlite3_prepare16">sqlite3_prepare16</strong>(sqlite3* db, const(void)* zSql, int nByte, sqlite3_stmt** ppStmt, const(void*)* pzTail); <br><br>nothrow int <strong id="sqlite3_prepare16_v2">sqlite3_prepare16_v2</strong>(sqlite3* db, const(void)* zSql, int nByte, sqlite3_stmt** ppStmt, const(void*)* pzTail); <br><br>nothrow int <strong id="sqlite3_prepare16_v3">sqlite3_prepare16_v3</strong>(sqlite3* db, const(void)* zSql, int nByte, uint prepFlags, sqlite3_stmt** ppStmt, const(void*)* pzTail); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Compiling An SQL Statement</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_sql">nothrow const(char)* <strong id="sqlite3_sql">sqlite3_sql</strong>(sqlite3_stmt* pStmt); <br><br>nothrow char* <strong id="sqlite3_expanded_sql">sqlite3_expanded_sql</strong>(sqlite3_stmt* pStmt); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Retrieving Statement SQL</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_stmt_busy">nothrow int <strong id="sqlite3_stmt_busy">sqlite3_stmt_busy</strong>(sqlite3_stmt*); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Determine If A Prepared Statement Has Been Reset</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_value">struct <strong id="sqlite3_value">sqlite3_value</strong>; </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Dynamically Typed Value Object</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_context">struct <strong id="sqlite3_context">sqlite3_context</strong>; </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> SQL Function Context Object</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_bind_blob">nothrow int <strong id="sqlite3_bind_blob">sqlite3_bind_blob</strong>(sqlite3_stmt*, int, const void*, int n, void function(void*)); <br><br>nothrow int <strong id="sqlite3_bind_blob64">sqlite3_bind_blob64</strong>(sqlite3_stmt*, int, const void*, sqlite3_uint64, void function(void*)); <br><br>nothrow int <strong id="sqlite3_bind_double">sqlite3_bind_double</strong>(sqlite3_stmt*, int, double); <br><br>nothrow int <strong id="sqlite3_bind_int">sqlite3_bind_int</strong>(sqlite3_stmt*, int, int); <br><br>nothrow int <strong id="sqlite3_bind_int64">sqlite3_bind_int64</strong>(sqlite3_stmt*, int, sqlite3_int64); <br><br>nothrow int <strong id="sqlite3_bind_null">sqlite3_bind_null</strong>(sqlite3_stmt*, int); <br><br>nothrow int <strong id="sqlite3_bind_text">sqlite3_bind_text</strong>(sqlite3_stmt*, int, const char*, int n, void function(void*)); <br><br>nothrow int <strong id="sqlite3_bind_text16">sqlite3_bind_text16</strong>(sqlite3_stmt*, int, const void*, int, void function(void*)); <br><br>nothrow int <strong id="sqlite3_bind_text64">sqlite3_bind_text64</strong>(sqlite3_stmt*, int, const char*, sqlite3_uint64, void function(void*), ubyte encoding); <br><br>nothrow int <strong id="sqlite3_bind_value">sqlite3_bind_value</strong>(sqlite3_stmt*, int, const sqlite3_value*); <br><br>nothrow int <strong id="sqlite3_bind_zeroblob">sqlite3_bind_zeroblob</strong>(sqlite3_stmt*, int, int n); <br><br>nothrow int <strong id="sqlite3_bind_zeroblob64">sqlite3_bind_zeroblob64</strong>(sqlite3_stmt*, int, sqlite3_uint64 n); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Binding Values To Prepared Statements</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_bind_parameter_count">nothrow int <strong id="sqlite3_bind_parameter_count">sqlite3_bind_parameter_count</strong>(sqlite3_stmt*); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Number Of SQL Parameters</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_bind_parameter_name">nothrow const(char)* <strong id="sqlite3_bind_parameter_name">sqlite3_bind_parameter_name</strong>(sqlite3_stmt*, int); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Name Of A Host Parameter</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_bind_parameter_index">nothrow int <strong id="sqlite3_bind_parameter_index">sqlite3_bind_parameter_index</strong>(sqlite3_stmt*, const char* zName); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Index Of A Parameter With A Given Name</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_clear_bindings">nothrow int <strong id="sqlite3_clear_bindings">sqlite3_clear_bindings</strong>(sqlite3_stmt*); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Reset All Bindings On A Prepared Statement</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_column_count">nothrow int <strong id="sqlite3_column_count">sqlite3_column_count</strong>(sqlite3_stmt* pStmt); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Number Of Columns In A Result Set</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_column_name">nothrow const(char)* <strong id="sqlite3_column_name">sqlite3_column_name</strong>(sqlite3_stmt*, int N); <br><br>nothrow const(void)* <strong id="sqlite3_column_name16">sqlite3_column_name16</strong>(sqlite3_stmt*, int N); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Column Names In A Result Set</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_column_database_name">nothrow const(char)* <strong id="sqlite3_column_database_name">sqlite3_column_database_name</strong>(sqlite3_stmt*, int); <br><br>nothrow const(void)* <strong id="sqlite3_column_database_name16">sqlite3_column_database_name16</strong>(sqlite3_stmt*, int); <br><br>nothrow const(char)* <strong id="sqlite3_column_table_name">sqlite3_column_table_name</strong>(sqlite3_stmt*, int); <br><br>nothrow const(void)* <strong id="sqlite3_column_table_name16">sqlite3_column_table_name16</strong>(sqlite3_stmt*, int); <br><br>nothrow const(char)* <strong id="sqlite3_column_origin_name">sqlite3_column_origin_name</strong>(sqlite3_stmt*, int); <br><br>nothrow const(void)* <strong id="sqlite3_column_origin_name16">sqlite3_column_origin_name16</strong>(sqlite3_stmt*, int); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Source Of Data In A Query Result</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_column_decltype">nothrow const(char)* <strong id="sqlite3_column_decltype">sqlite3_column_decltype</strong>(sqlite3_stmt*, int); <br><br>nothrow const(void)* <strong id="sqlite3_column_decltype16">sqlite3_column_decltype16</strong>(sqlite3_stmt*, int); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Declared Datatype Of A Query Result</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_step">nothrow int <strong id="sqlite3_step">sqlite3_step</strong>(sqlite3_stmt*); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Evaluate An SQL Statement</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_data_count">nothrow int <strong id="sqlite3_data_count">sqlite3_data_count</strong>(sqlite3_stmt* pStmt); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Number of columns in a result set</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_column_blob">nothrow const(void)* <strong id="sqlite3_column_blob">sqlite3_column_blob</strong>(sqlite3_stmt*, int iCol); <br><br>nothrow double <strong id="sqlite3_column_double">sqlite3_column_double</strong>(sqlite3_stmt*, int iCol); <br><br>nothrow int <strong id="sqlite3_column_int">sqlite3_column_int</strong>(sqlite3_stmt*, int iCol); <br><br>nothrow sqlite3_int64 <strong id="sqlite3_column_int64">sqlite3_column_int64</strong>(sqlite3_stmt*, int iCol); <br><br>nothrow const(char)* <strong id="sqlite3_column_text">sqlite3_column_text</strong>(sqlite3_stmt*, int iCol); <br><br>nothrow const(void)* <strong id="sqlite3_column_text16">sqlite3_column_text16</strong>(sqlite3_stmt*, int iCol); <br><br>nothrow sqlite3_value* <strong id="sqlite3_column_value">sqlite3_column_value</strong>(sqlite3_stmt*, int iCol); <br><br>nothrow int <strong id="sqlite3_column_bytes">sqlite3_column_bytes</strong>(sqlite3_stmt*, int iCol); <br><br>nothrow int <strong id="sqlite3_column_bytes16">sqlite3_column_bytes16</strong>(sqlite3_stmt*, int iCol); <br><br>nothrow int <strong id="sqlite3_column_type">sqlite3_column_type</strong>(sqlite3_stmt*, int iCol); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Result Values From A Query</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_finalize">nothrow int <strong id="sqlite3_finalize">sqlite3_finalize</strong>(sqlite3_stmt* pStmt); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Destroy A Prepared Statement Object</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_reset">nothrow int <strong id="sqlite3_reset">sqlite3_reset</strong>(sqlite3_stmt* pStmt); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Reset A Prepared Statement Object</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_create_function">nothrow int <strong id="sqlite3_create_function">sqlite3_create_function</strong>(sqlite3* db, const(char)* zFunctionName, int nArg, int eTextRep, void* pApp, void function(sqlite3_context*, int, sqlite3_value**) xFunc, void function(sqlite3_context*, int, sqlite3_value**) xStep, void function(sqlite3_context*) xFinal); <br><br>nothrow int <strong id="sqlite3_create_function16">sqlite3_create_function16</strong>(sqlite3* db, const(void)* zFunctionName, int nArg, int eTextRep, void* pApp, void function(sqlite3_context*, int, sqlite3_value**) xFunc, void function(sqlite3_context*, int, sqlite3_value**) xStep, void function(sqlite3_context*) xFinal); <br><br>nothrow int <strong id="sqlite3_create_function_v2">sqlite3_create_function_v2</strong>(sqlite3* db, const(char)* zFunctionName, int nArg, int eTextRep, void* pApp, void function(sqlite3_context*, int, sqlite3_value**) xFunc, void function(sqlite3_context*, int, sqlite3_value**) xStep, void function(sqlite3_context*) xFinal, void function(void*) xDestroy); <br><br>nothrow int <strong id="sqlite3_create_window_function">sqlite3_create_window_function</strong>(sqlite3* db, const(char)* zFunctionName, int nArg, int eTextRep, void* pApp, void function(sqlite3_context*, int, sqlite3_value**) xStep, void function(sqlite3_context*) xFinal, void function(sqlite3_context*) xValue, void function(sqlite3_context*, int, sqlite3_value**) xInverse, void function(void*) xDestroy); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Create Or Redefine SQL Functions</dd>
</dl> </dd> <dt class="d_decl" id="SQLITE_UTF8"><strong id="SQLITE_UTF8">SQLITE_UTF8</strong></dt> <dd>
<dl>
<dt>IMP</dt>
<dd> R-37514-35566</dd>
</dl> </dd> <dt class="d_decl" id="SQLITE_UTF16LE"><strong id="SQLITE_UTF16LE">SQLITE_UTF16LE</strong></dt> <dd>
<dl>
<dt>IMP</dt>
<dd> R-03371-37637</dd>
</dl> </dd> <dt class="d_decl" id="SQLITE_UTF16BE"><strong id="SQLITE_UTF16BE">SQLITE_UTF16BE</strong></dt> <dd>
<dl>
<dt>IMP</dt>
<dd> R-51971-34154</dd>
</dl> </dd> <dt class="d_decl" id="SQLITE_UTF16"><strong id="SQLITE_UTF16">SQLITE_UTF16</strong></dt> <dd>
<p>Use native byte order</p> </dd> <dt class="d_decl" id="SQLITE_ANY"><strong id="SQLITE_ANY">SQLITE_ANY</strong></dt> <dd>
<p>sqlite3_create_function only</p> </dd> <dt class="d_decl" id="SQLITE_UTF16_ALIGNED"><strong id="SQLITE_UTF16_ALIGNED">SQLITE_UTF16_ALIGNED</strong></dt> <dd>
<p>sqlite3_create_collation only</p> </dd> <dt class="d_decl" id="SQLITE_DETERMINISTIC">enum int <strong id="SQLITE_DETERMINISTIC">SQLITE_DETERMINISTIC</strong>; </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Function Flags</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_aggregate_count">deprecated nothrow int <strong id="sqlite3_aggregate_count">sqlite3_aggregate_count</strong>(sqlite3_context*); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Deprecated Functions</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_value_blob">nothrow const(void)* <strong id="sqlite3_value_blob">sqlite3_value_blob</strong>(sqlite3_value*); <br><br>nothrow int <strong id="sqlite3_value_bytes">sqlite3_value_bytes</strong>(sqlite3_value*); <br><br>nothrow int <strong id="sqlite3_value_bytes16">sqlite3_value_bytes16</strong>(sqlite3_value*); <br><br>nothrow double <strong id="sqlite3_value_double">sqlite3_value_double</strong>(sqlite3_value*); <br><br>nothrow int <strong id="sqlite3_value_int">sqlite3_value_int</strong>(sqlite3_value*); <br><br>nothrow sqlite3_int64 <strong id="sqlite3_value_int64">sqlite3_value_int64</strong>(sqlite3_value*); <br><br>nothrow const(char)* <strong id="sqlite3_value_text">sqlite3_value_text</strong>(sqlite3_value*); <br><br>nothrow const(void)* <strong id="sqlite3_value_text16">sqlite3_value_text16</strong>(sqlite3_value*); <br><br>nothrow const(void)* <strong id="sqlite3_value_text16le">sqlite3_value_text16le</strong>(sqlite3_value*); <br><br>nothrow const(void)* <strong id="sqlite3_value_text16be">sqlite3_value_text16be</strong>(sqlite3_value*); <br><br>nothrow int <strong id="sqlite3_value_type">sqlite3_value_type</strong>(sqlite3_value*); <br><br>nothrow int <strong id="sqlite3_value_numeric_type">sqlite3_value_numeric_type</strong>(sqlite3_value*); <br><br>nothrow int <strong id="sqlite3_value_nochange">sqlite3_value_nochange</strong>(sqlite3_value*); <br><br>nothrow int <strong id="sqlite3_value_frombind">sqlite3_value_frombind</strong>(sqlite3_value*); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Obtaining SQL Function Parameter Values</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_aggregate_context">nothrow void* <strong id="sqlite3_aggregate_context">sqlite3_aggregate_context</strong>(sqlite3_context*, int nBytes); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Obtain Aggregate Function Context</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_user_data">nothrow void* <strong id="sqlite3_user_data">sqlite3_user_data</strong>(sqlite3_context*); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> User Data For Functions</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_context_db_handle">nothrow sqlite3* <strong id="sqlite3_context_db_handle">sqlite3_context_db_handle</strong>(sqlite3_context*); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Database Connection For Functions</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_get_auxdata">nothrow void* <strong id="sqlite3_get_auxdata">sqlite3_get_auxdata</strong>(sqlite3_context*, int N); <br><br>nothrow void <strong id="sqlite3_set_auxdata">sqlite3_set_auxdata</strong>(sqlite3_context*, int N, void*, void function(void*)); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Function Auxiliary Data</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_destructor_type">alias <strong id="sqlite3_destructor_type">sqlite3_destructor_type</strong> = extern (C) void function(void*) nothrow; </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Constants Defining Special Destructor Behavior</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_result_blob">nothrow void <strong id="sqlite3_result_blob">sqlite3_result_blob</strong>(sqlite3_context*, const void*, int, void function(void*)); <br><br>nothrow void <strong id="sqlite3_result_blob64">sqlite3_result_blob64</strong>(sqlite3_context*, const void*, sqlite3_uint64, void function(void*)); <br><br>nothrow void <strong id="sqlite3_result_double">sqlite3_result_double</strong>(sqlite3_context*, double); <br><br>nothrow void <strong id="sqlite3_result_error">sqlite3_result_error</strong>(sqlite3_context*, const char*, int); <br><br>nothrow void <strong id="sqlite3_result_error16">sqlite3_result_error16</strong>(sqlite3_context*, const void*, int); <br><br>nothrow void <strong id="sqlite3_result_error_toobig">sqlite3_result_error_toobig</strong>(sqlite3_context*); <br><br>nothrow void <strong id="sqlite3_result_error_nomem">sqlite3_result_error_nomem</strong>(sqlite3_context*); <br><br>nothrow void <strong id="sqlite3_result_error_code">sqlite3_result_error_code</strong>(sqlite3_context*, int); <br><br>nothrow void <strong id="sqlite3_result_int">sqlite3_result_int</strong>(sqlite3_context*, int); <br><br>nothrow void <strong id="sqlite3_result_int64">sqlite3_result_int64</strong>(sqlite3_context*, sqlite3_int64); <br><br>nothrow void <strong id="sqlite3_result_null">sqlite3_result_null</strong>(sqlite3_context*); <br><br>nothrow void <strong id="sqlite3_result_text">sqlite3_result_text</strong>(sqlite3_context*, const char*, int, void function(void*)); <br><br>nothrow void <strong id="sqlite3_result_text64">sqlite3_result_text64</strong>(sqlite3_context*, const char*, sqlite3_uint64, void function(void*), ubyte encoding); <br><br>nothrow void <strong id="sqlite3_result_text16">sqlite3_result_text16</strong>(sqlite3_context*, const void*, int, void function(void*)); <br><br>nothrow void <strong id="sqlite3_result_text16le">sqlite3_result_text16le</strong>(sqlite3_context*, const void*, int, void function(void*)); <br><br>nothrow void <strong id="sqlite3_result_text16be">sqlite3_result_text16be</strong>(sqlite3_context*, const void*, int, void function(void*)); <br><br>nothrow void <strong id="sqlite3_result_value">sqlite3_result_value</strong>(sqlite3_context*, sqlite3_value*); <br><br>nothrow void <strong id="sqlite3_result_zeroblob">sqlite3_result_zeroblob</strong>(sqlite3_context*, int n); <br><br>nothrow int <strong id="sqlite3_result_zeroblob64">sqlite3_result_zeroblob64</strong>(sqlite3_context*, sqlite3_uint64 n); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Setting The Result Of An SQL Function</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_create_collation">nothrow int <strong id="sqlite3_create_collation">sqlite3_create_collation</strong>(sqlite3*, const(char)* zName, int eTextRep, void* pArg, int function(void*, int, const void*, int, const void*) xCompare); <br><br>nothrow int <strong id="sqlite3_create_collation_v2">sqlite3_create_collation_v2</strong>(sqlite3*, const(char)* zName, int eTextRep, void* pArg, int function(void*, int, const void*, int, const void*) xCompare, void function(void*) xDestroy); <br><br>nothrow int <strong id="sqlite3_create_collation16">sqlite3_create_collation16</strong>(sqlite3*, const(void)* zName, int eTextRep, void* pArg, int function(void*, int, const void*, int, const void*) xCompare); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Define New Collating Sequences</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_collation_needed">nothrow int <strong id="sqlite3_collation_needed">sqlite3_collation_needed</strong>(sqlite3*, void*, void function(void*, sqlite3*, int eTextRep, const char*)); <br><br>nothrow int <strong id="sqlite3_collation_needed16">sqlite3_collation_needed16</strong>(sqlite3*, void*, void function(void*, sqlite3*, int eTextRep, const void*)); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Collation Needed Callbacks</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_key">nothrow int <strong id="sqlite3_key">sqlite3_key</strong>(sqlite3* db, const(void)* pKey, int nKey); <br><br>nothrow int <strong id="sqlite3_key_v2">sqlite3_key_v2</strong>(sqlite3* db, const(char)* zDbName, const(void)* pKey, int nKey); </dt>  <dt class="d_decl" id="sqlite3_rekey">nothrow int <strong id="sqlite3_rekey">sqlite3_rekey</strong>(sqlite3* db, const(void)* pKey, int nKey); </dt> <dd>
<p>Change the key on an open database. If the current database is not encrypted, this routine will encrypt it. If pNew == 0 or nNew == 0, the database is decrypted. </p>
<p>The code to implement this API is not available in the public release of SQLite.</p> </dd> <dt class="d_decl" id="sqlite3_activate_see">nothrow void <strong id="sqlite3_activate_see">sqlite3_activate_see</strong>(const(char)* zPassPhrase); </dt> <dd>
<p>Specify the activation key for a SEE database. Unless activated, none of the SEE routines will work.</p> </dd> <dt class="d_decl" id="sqlite3_activate_cerod">nothrow void <strong id="sqlite3_activate_cerod">sqlite3_activate_cerod</strong>(const(char)* zPassPhrase); </dt> <dd>
<p>Specify the activation key for a CEROD database. Unless activated, none of the CEROD routines will work.</p> </dd> <dt class="d_decl" id="sqlite3_sleep">nothrow int <strong id="sqlite3_sleep">sqlite3_sleep</strong>(int); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Suspend Execution For A Short Time</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_temp_directory">char* <strong id="sqlite3_temp_directory">sqlite3_temp_directory</strong>; </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Name Of The Folder Holding Temporary Files</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_data_directory">char* <strong id="sqlite3_data_directory">sqlite3_data_directory</strong>; </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Name Of The Folder Holding Database Files</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_win32_set_directory">nothrow int <strong id="sqlite3_win32_set_directory">sqlite3_win32_set_directory</strong>(c_ulong type, void* zValue); <br><br>nothrow int <strong id="sqlite3_win32_set_directory8">sqlite3_win32_set_directory8</strong>(c_ulong type, void* zValue); <br><br>nothrow int <strong id="sqlite3_win32_set_directory16">sqlite3_win32_set_directory16</strong>(c_ulong type, void* zValue); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Win32 Specific Interface</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_get_autocommit">nothrow int <strong id="sqlite3_get_autocommit">sqlite3_get_autocommit</strong>(sqlite3*); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Test For Auto-Commit Mode</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_db_handle">nothrow sqlite3* <strong id="sqlite3_db_handle">sqlite3_db_handle</strong>(sqlite3_stmt*); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Find The Database Handle Of A Prepared Statement</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_db_filename">nothrow const(char)* <strong id="sqlite3_db_filename">sqlite3_db_filename</strong>(sqlite3* db, const char* zDbName); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Return The Filename For A Database Connection</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_db_readonly">nothrow int <strong id="sqlite3_db_readonly">sqlite3_db_readonly</strong>(sqlite3* db, const char* zDbName); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Determine if a database is read-only</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_commit_hook">nothrow void* <strong id="sqlite3_commit_hook">sqlite3_commit_hook</strong>(sqlite3*, int function(void*), void*); <br><br>nothrow void* <strong id="sqlite3_rollback_hook">sqlite3_rollback_hook</strong>(sqlite3*, void function(void*), void*); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Commit And Rollback Notification Callbacks</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_update_hook">nothrow void* <strong id="sqlite3_update_hook">sqlite3_update_hook</strong>(sqlite3*, void function(void*, int, char*, char*, sqlite3_int64), void*); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Data Change Notification Callbacks</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_enable_shared_cache">nothrow int <strong id="sqlite3_enable_shared_cache">sqlite3_enable_shared_cache</strong>(int); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Enable Or Disable Shared Pager Cache</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_release_memory">nothrow int <strong id="sqlite3_release_memory">sqlite3_release_memory</strong>(int); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Attempt To Free Heap Memory</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_db_release_memory">nothrow int <strong id="sqlite3_db_release_memory">sqlite3_db_release_memory</strong>(sqlite3*); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Free Memory Used By A Database Connection</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_soft_heap_limit">deprecated nothrow void <strong id="sqlite3_soft_heap_limit">sqlite3_soft_heap_limit</strong>(int N); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Deprecated Soft Heap Limit Interface</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_table_column_metadata">nothrow int <strong id="sqlite3_table_column_metadata">sqlite3_table_column_metadata</strong>(sqlite3* db, const(char)* zDbName, const(char)* zTableName, const(char)* zColumnName, char** pzDataType, char** pzCollSeq, int* pNotNull, int* pPrimaryKey, int* pAutoinc); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Extract Metadata About A Column Of A Table</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_load_extension">nothrow int <strong id="sqlite3_load_extension">sqlite3_load_extension</strong>(sqlite3* db, const(char)* zFile, const(char)* zProc, char** pzErrMsg); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Load An Extension</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_enable_load_extension">nothrow int <strong id="sqlite3_enable_load_extension">sqlite3_enable_load_extension</strong>(sqlite3* db, int onoff); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Enable Or Disable Extension Loading</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_auto_extension">nothrow int <strong id="sqlite3_auto_extension">sqlite3_auto_extension</strong>(void function() xEntryPoint); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Automatically Load Statically Linked Extensions</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_cancel_auto_extension">nothrow int <strong id="sqlite3_cancel_auto_extension">sqlite3_cancel_auto_extension</strong>(void function() xEntryPoint); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Cancel Automatic Extension Loading</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_reset_auto_extension">nothrow void <strong id="sqlite3_reset_auto_extension">sqlite3_reset_auto_extension</strong>(); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Reset Automatic Extension Loading</dd>
</dl> </dd> <dt class="d_decl" id="mapFunction">alias <strong id="mapFunction">mapFunction</strong> = extern (C) void function(sqlite3_context*, int, sqlite3_value**) nothrow; <br><br>struct <strong id="sqlite3_module">sqlite3_module</strong>; </dt> <dd>
<p>The interface to the virtual-table mechanism is currently considered to be experimental. The interface might change in incompatible ways. If this is a problem for you, do not use the interface at this time. </p>
<p>When the virtual-table mechanism stabilizes, we will declare the interface fixed, support it indefinitely, and remove this comment. </p> <dl>
<dt>CAPI3REF</dt>
<dd> Virtual Table Object</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_index_info">struct <strong id="sqlite3_index_info">sqlite3_index_info</strong>; </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Virtual Table Indexing Information</dd>
</dl> <dl>
<dt class="d_decl" id="sqlite3_index_info.nConstraint">int <strong id="nConstraint">nConstraint</strong>; </dt> <dd>
<p>Number of entries in aConstraint</p> </dd> <dt class="d_decl" id="sqlite3_index_info.aConstraint">sqlite3_index_constraint* <strong id="aConstraint">aConstraint</strong>; </dt> <dd>
<p>Table of WHERE clause constraints</p> </dd> <dt class="d_decl" id="sqlite3_index_info.nOrderBy">int <strong id="nOrderBy">nOrderBy</strong>; </dt> <dd>
<p>Number of terms in the ORDER BY clause</p> </dd> <dt class="d_decl" id="sqlite3_index_info.aOrderBy">sqlite3_index_orderby* <strong id="aOrderBy">aOrderBy</strong>; </dt> <dd>
<p>The ORDER BY clause</p> </dd> <dt class="d_decl" id="sqlite3_index_info.idxNum">int <strong id="idxNum">idxNum</strong>; </dt> <dd>
<p>Number used to identify the index</p> </dd> <dt class="d_decl" id="sqlite3_index_info.idxStr">char* <strong id="idxStr">idxStr</strong>; </dt> <dd>
<p>String, possibly obtained from sqlite3_malloc</p> </dd> <dt class="d_decl" id="sqlite3_index_info.needToFreeIdxStr">int <strong id="needToFreeIdxStr">needToFreeIdxStr</strong>; </dt> <dd>
<p>Free idxStr using sqlite3_free() if true</p> </dd> <dt class="d_decl" id="sqlite3_index_info.orderByConsumed">int <strong id="orderByConsumed">orderByConsumed</strong>; </dt> <dd>
<p>True if output is already ordered</p> </dd> <dt class="d_decl" id="sqlite3_index_info.estimatedCost">double <strong id="estimatedCost">estimatedCost</strong>; </dt> <dd>
<p>Estimated cost of using this index</p> </dd> </dl> </dd> <dt class="d_decl" id="sqlite3_create_module">nothrow int <strong id="sqlite3_create_module">sqlite3_create_module</strong>(sqlite3* db, const(char)* zName, const(sqlite3_module)* p, void* pClientData); <br><br>nothrow int <strong id="sqlite3_create_module_v2">sqlite3_create_module_v2</strong>(sqlite3* db, const(char)* zName, const(sqlite3_module)* p, void* pClientData, void function(void*) xDestroy); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Register A Virtual Table Implementation</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_vtab">struct <strong id="sqlite3_vtab">sqlite3_vtab</strong>; </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Virtual Table Instance Object</dd>
</dl> <dl>
<dt class="d_decl" id="sqlite3_vtab.pModule">const(sqlite3_module)* <strong id="pModule">pModule</strong>; </dt> <dd>
<p>The module for this virtual table</p> </dd> <dt class="d_decl" id="sqlite3_vtab.nRef">int <strong id="nRef">nRef</strong>; </dt> <dd>
<p>NO LONGER USED</p> </dd> <dt class="d_decl" id="sqlite3_vtab.zErrMsg">char* <strong id="zErrMsg">zErrMsg</strong>; </dt> <dd>
<p>Error message from sqlite3_mprintf()</p> </dd> </dl> </dd> <dt class="d_decl" id="sqlite3_vtab_cursor">struct <strong id="sqlite3_vtab_cursor">sqlite3_vtab_cursor</strong>; </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Virtual Table Cursor Object</dd>
</dl> <dl>
<dt class="d_decl" id="sqlite3_vtab_cursor.pVtab">sqlite3_vtab* <strong id="pVtab">pVtab</strong>; </dt> <dd>
<p>Virtual table of this cursor</p> </dd> </dl> </dd> <dt class="d_decl" id="sqlite3_declare_vtab">nothrow int <strong id="sqlite3_declare_vtab">sqlite3_declare_vtab</strong>(sqlite3*, const char* zSQL); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Declare The Schema Of A Virtual Table</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_overload_function">nothrow int <strong id="sqlite3_overload_function">sqlite3_overload_function</strong>(sqlite3*, const char* zFuncName, int nArg); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Overload A Function For A Virtual Table</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_blob">struct <strong id="sqlite3_blob">sqlite3_blob</strong>; </dt> <dd>
<p>The interface to the virtual-table mechanism defined above (back up to a comment remarkably similar to this one) is currently considered to be experimental. The interface might change in incompatible ways. If this is a problem for you, do not use the interface at this time. </p>
<p>When the virtual-table mechanism stabilizes, we will declare the interface fixed, support it indefinitely, and remove this comment.</p> </dd> <dt class="d_decl" id="sqlite3_blob_open">nothrow int <strong id="sqlite3_blob_open">sqlite3_blob_open</strong>(sqlite3*, const(char)* zDb, const(char)* zTable, const(char)* zColumn, sqlite3_int64 iRow, int flags, sqlite3_blob** ppBlob); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Open A BLOB For Incremental I/O</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_blob_reopen">nothrow int <strong id="sqlite3_blob_reopen">sqlite3_blob_reopen</strong>(sqlite3_blob*, sqlite3_int64); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Move a BLOB Handle to a New Row</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_blob_close">nothrow int <strong id="sqlite3_blob_close">sqlite3_blob_close</strong>(sqlite3_blob*); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Close A BLOB Handle</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_blob_bytes">nothrow int <strong id="sqlite3_blob_bytes">sqlite3_blob_bytes</strong>(sqlite3_blob*); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Return The Size Of An Open BLOB</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_blob_read">nothrow int <strong id="sqlite3_blob_read">sqlite3_blob_read</strong>(sqlite3_blob*, void* Z, int N, int iOffset); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Read Data From A BLOB Incrementally</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_blob_write">nothrow int <strong id="sqlite3_blob_write">sqlite3_blob_write</strong>(sqlite3_blob*, const void* z, int n, int iOffset); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Write Data Into A BLOB Incrementally</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_vfs_find">nothrow sqlite3_vfs* <strong id="sqlite3_vfs_find">sqlite3_vfs_find</strong>(const char* zVfsName); <br><br>nothrow int <strong id="sqlite3_vfs_register">sqlite3_vfs_register</strong>(sqlite3_vfs*, int makeDflt); <br><br>nothrow int <strong id="sqlite3_vfs_unregister">sqlite3_vfs_unregister</strong>(sqlite3_vfs*); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Virtual File System Objects</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_mutex_alloc">nothrow sqlite3_mutex* <strong id="sqlite3_mutex_alloc">sqlite3_mutex_alloc</strong>(int); <br><br>nothrow void <strong id="sqlite3_mutex_free">sqlite3_mutex_free</strong>(sqlite3_mutex*); <br><br>nothrow void <strong id="sqlite3_mutex_enter">sqlite3_mutex_enter</strong>(sqlite3_mutex*); <br><br>nothrow int <strong id="sqlite3_mutex_try">sqlite3_mutex_try</strong>(sqlite3_mutex*); <br><br>nothrow void <strong id="sqlite3_mutex_leave">sqlite3_mutex_leave</strong>(sqlite3_mutex*); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Mutexes</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_mutex_methods">struct <strong id="sqlite3_mutex_methods">sqlite3_mutex_methods</strong>; </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Mutex Methods Object</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_mutex_held">nothrow int <strong id="sqlite3_mutex_held">sqlite3_mutex_held</strong>(sqlite3_mutex*); <br><br>nothrow int <strong id="sqlite3_mutex_notheld">sqlite3_mutex_notheld</strong>(sqlite3_mutex*); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Mutex Verification Routines</dd>
</dl> </dd> <dt class="d_decl" id="SQLITE_MUTEX_STATIC_MEM"><strong id="SQLITE_MUTEX_STATIC_MEM">SQLITE_MUTEX_STATIC_MEM</strong></dt> <dd>
<p>sqlite3_malloc()</p> </dd> <dt class="d_decl" id="SQLITE_MUTEX_STATIC_MEM2"><strong id="SQLITE_MUTEX_STATIC_MEM2">SQLITE_MUTEX_STATIC_MEM2</strong></dt> <dd>
<p>NOT USED</p> </dd> <dt class="d_decl" id="SQLITE_MUTEX_STATIC_OPEN"><strong id="SQLITE_MUTEX_STATIC_OPEN">SQLITE_MUTEX_STATIC_OPEN</strong></dt> <dd>
<p>sqlite3BtreeOpen()</p> </dd> <dt class="d_decl" id="SQLITE_MUTEX_STATIC_PRNG"><strong id="SQLITE_MUTEX_STATIC_PRNG">SQLITE_MUTEX_STATIC_PRNG</strong></dt> <dd>
<p>sqlite3_randomness()</p> </dd> <dt class="d_decl" id="SQLITE_MUTEX_STATIC_LRU"><strong id="SQLITE_MUTEX_STATIC_LRU">SQLITE_MUTEX_STATIC_LRU</strong></dt> <dd>
<p>lru page list</p> </dd> <dt class="d_decl" id="SQLITE_MUTEX_STATIC_LRU2"><strong id="SQLITE_MUTEX_STATIC_LRU2">SQLITE_MUTEX_STATIC_LRU2</strong></dt> <dd>
<p>NOT USED</p> </dd> <dt class="d_decl" id="SQLITE_MUTEX_STATIC_PMEM"><strong id="SQLITE_MUTEX_STATIC_PMEM">SQLITE_MUTEX_STATIC_PMEM</strong></dt> <dd>
<p>sqlite3PageMalloc()</p> </dd> <dt class="d_decl" id="SQLITE_MUTEX_STATIC_APP1"><strong id="SQLITE_MUTEX_STATIC_APP1">SQLITE_MUTEX_STATIC_APP1</strong></dt> <dd>
<p>For use by application</p> </dd> <dt class="d_decl" id="SQLITE_MUTEX_STATIC_APP2"><strong id="SQLITE_MUTEX_STATIC_APP2">SQLITE_MUTEX_STATIC_APP2</strong></dt> <dd>
<p>For use by application</p> </dd> <dt class="d_decl" id="SQLITE_MUTEX_STATIC_APP3"><strong id="SQLITE_MUTEX_STATIC_APP3">SQLITE_MUTEX_STATIC_APP3</strong></dt> <dd>
<p>For use by application</p> </dd> <dt class="d_decl" id="SQLITE_MUTEX_STATIC_VFS1"><strong id="SQLITE_MUTEX_STATIC_VFS1">SQLITE_MUTEX_STATIC_VFS1</strong></dt> <dd>
<p>For use by built-in VFS</p> </dd> <dt class="d_decl" id="SQLITE_MUTEX_STATIC_VFS2"><strong id="SQLITE_MUTEX_STATIC_VFS2">SQLITE_MUTEX_STATIC_VFS2</strong></dt> <dd>
<p>For use by extension VFS</p> </dd> <dt class="d_decl" id="SQLITE_MUTEX_STATIC_VFS3"><strong id="SQLITE_MUTEX_STATIC_VFS3">SQLITE_MUTEX_STATIC_VFS3</strong></dt> <dd>
<p>For use by application VFS</p> </dd> <dt class="d_decl" id="sqlite3_db_mutex">nothrow sqlite3_mutex* <strong id="sqlite3_db_mutex">sqlite3_db_mutex</strong>(sqlite3*); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Retrieve the mutex for a database connection</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_file_control">nothrow int <strong id="sqlite3_file_control">sqlite3_file_control</strong>(sqlite3*, const char* zDbName, int op, void*); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Low-Level Control Of Database Files</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_test_control">nothrow int <strong id="sqlite3_test_control">sqlite3_test_control</strong>(int op, ...); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Testing Interface</dd>
</dl> </dd> <dt class="d_decl" id="SQLITE_TESTCTRL_ISKEYWORD"><strong id="SQLITE_TESTCTRL_ISKEYWORD">SQLITE_TESTCTRL_ISKEYWORD</strong></dt> <dd>
<p>NOT USED</p> </dd> <dt class="d_decl" id="SQLITE_TESTCTRL_SCRATCHMALLOC"><strong id="SQLITE_TESTCTRL_SCRATCHMALLOC">SQLITE_TESTCTRL_SCRATCHMALLOC</strong></dt> <dd>
<p>NOT USED</p> </dd> <dt class="d_decl" id="SQLITE_TESTCTRL_EXPLAIN_STMT"><strong id="SQLITE_TESTCTRL_EXPLAIN_STMT">SQLITE_TESTCTRL_EXPLAIN_STMT</strong></dt> <dd>
<p>NOT USED</p> </dd> <dt class="d_decl" id="SQLITE_TESTCTRL_LAST"><strong id="SQLITE_TESTCTRL_LAST">SQLITE_TESTCTRL_LAST</strong></dt> <dd>
<p>NOT USED</p> </dd> <dt class="d_decl" id="sqlite3_keyword_count">nothrow int <strong id="sqlite3_keyword_count">sqlite3_keyword_count</strong>(); <br><br>nothrow int <strong id="sqlite3_keyword_name">sqlite3_keyword_name</strong>(int, const(char*)*, int*); <br><br>nothrow int <strong id="sqlite3_keyword_check">sqlite3_keyword_check</strong>(const(char)*, int); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> SQL Keyword Checking</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_str">struct <strong id="sqlite3_str">sqlite3_str</strong>; </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Dynamic String Object</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_str_new">nothrow sqlite3_str* <strong id="sqlite3_str_new">sqlite3_str_new</strong>(sqlite3*); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Create A New Dynamic String Object</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_str_finish">nothrow char* <strong id="sqlite3_str_finish">sqlite3_str_finish</strong>(sqlite3_str*); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Finalize A Dynamic String</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_str_appendf">nothrow void <strong id="sqlite3_str_appendf">sqlite3_str_appendf</strong>(sqlite3_str*, const(char)* zFormat, ...); <br><br>nothrow void <strong id="sqlite3_str_vappendf">sqlite3_str_vappendf</strong>(sqlite3_str*, const(char)* zFormat, va_list); <br><br>nothrow void <strong id="sqlite3_str_append">sqlite3_str_append</strong>(sqlite3_str*, const(char)* zIn, int N); <br><br>nothrow void <strong id="sqlite3_str_appendall">sqlite3_str_appendall</strong>(sqlite3_str*, const(char)* zIn); <br><br>nothrow void <strong id="sqlite3_str_appendchar">sqlite3_str_appendchar</strong>(sqlite3_str*, int N, char C); <br><br>nothrow void <strong id="sqlite3_str_reset">sqlite3_str_reset</strong>(sqlite3_str*); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Add Content To A Dynamic String</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_str_errcode">nothrow int <strong id="sqlite3_str_errcode">sqlite3_str_errcode</strong>(sqlite3_str*); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Status Of A Dynamic String</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_status">nothrow int <strong id="sqlite3_status">sqlite3_status</strong>(int op, int* pCurrent, int* pHighwater, int resetFlag); <br><br>nothrow int <strong id="sqlite3_status64">sqlite3_status64</strong>(int op, long* pCurrent, long* pHighwater, int resetFlag); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> SQLite Runtime Status</dd>
</dl> </dd> <dt class="d_decl" id="SQLITE_STATUS_SCRATCH_USED"><strong id="SQLITE_STATUS_SCRATCH_USED">SQLITE_STATUS_SCRATCH_USED</strong></dt> <dd>
<p>NOT USED</p> </dd> <dt class="d_decl" id="SQLITE_STATUS_SCRATCH_OVERFLOW"><strong id="SQLITE_STATUS_SCRATCH_OVERFLOW">SQLITE_STATUS_SCRATCH_OVERFLOW</strong></dt> <dd>
<p>NOT USED</p> </dd> <dt class="d_decl" id="SQLITE_STATUS_SCRATCH_SIZE"><strong id="SQLITE_STATUS_SCRATCH_SIZE">SQLITE_STATUS_SCRATCH_SIZE</strong></dt> <dd>
<p>NOT USED</p> </dd> <dt class="d_decl" id="sqlite3_db_status">nothrow int <strong id="sqlite3_db_status">sqlite3_db_status</strong>(sqlite3*, int op, int* pCur, int* pHiwtr, int resetFlg); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Database Connection Status</dd>
</dl> </dd> <dt class="d_decl" id="SQLITE_DBSTATUS_MAX"><strong id="SQLITE_DBSTATUS_MAX">SQLITE_DBSTATUS_MAX</strong></dt> <dd>
<p>Largest defined DBSTATUS</p> </dd> <dt class="d_decl" id="sqlite3_stmt_status">nothrow int <strong id="sqlite3_stmt_status">sqlite3_stmt_status</strong>(sqlite3_stmt*, int op, int resetFlg); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Prepared Statement Status</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_pcache">struct <strong id="sqlite3_pcache">sqlite3_pcache</strong>; </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Custom Page Cache Object</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_pcache_page">struct <strong id="sqlite3_pcache_page">sqlite3_pcache_page</strong>; </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Custom Page Cache Object</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_pcache_methods2">struct <strong id="sqlite3_pcache_methods2">sqlite3_pcache_methods2</strong>; </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Application Defined Page Cache.</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_backup">struct <strong id="sqlite3_backup">sqlite3_backup</strong>; </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Online Backup Object</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_backup_init">nothrow sqlite3_backup* <strong id="sqlite3_backup_init">sqlite3_backup_init</strong>(sqlite3* pDest, const(char)* zDestName, sqlite3* pSource, const(char)* zSourceName); <br><br>nothrow int <strong id="sqlite3_backup_step">sqlite3_backup_step</strong>(sqlite3_backup* p, int nPage); <br><br>nothrow int <strong id="sqlite3_backup_finish">sqlite3_backup_finish</strong>(sqlite3_backup* p); <br><br>nothrow int <strong id="sqlite3_backup_remaining">sqlite3_backup_remaining</strong>(sqlite3_backup* p); <br><br>nothrow int <strong id="sqlite3_backup_pagecount">sqlite3_backup_pagecount</strong>(sqlite3_backup* p); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Online Backup API.</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_unlock_notify">nothrow int <strong id="sqlite3_unlock_notify">sqlite3_unlock_notify</strong>(sqlite3* pBlocked, void function(void** apArg, int nArg) xNotify, void* pNotifyArg); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Unlock Notification</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_stricmp">nothrow int <strong id="sqlite3_stricmp">sqlite3_stricmp</strong>(const char*, const char*); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> String Comparison</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_log">nothrow void <strong id="sqlite3_log">sqlite3_log</strong>(int iErrCode, const char* zFormat, ...); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Error Logging Interface</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_wal_hook">nothrow void* <strong id="sqlite3_wal_hook">sqlite3_wal_hook</strong>(sqlite3*, int function(void*, sqlite3*, const char*, int), void*); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Write-Ahead Log Commit Hook</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_wal_autocheckpoint">nothrow int <strong id="sqlite3_wal_autocheckpoint">sqlite3_wal_autocheckpoint</strong>(sqlite3* db, int N); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Configure an auto-checkpoint</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_wal_checkpoint">nothrow int <strong id="sqlite3_wal_checkpoint">sqlite3_wal_checkpoint</strong>(sqlite3* db, const char* zDb); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Checkpoint a database</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_wal_checkpoint_v2">nothrow int <strong id="sqlite3_wal_checkpoint_v2">sqlite3_wal_checkpoint_v2</strong>(sqlite3* db, const(char)* zDb, int eMode, int* pnLog, int* pnCkpt); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Checkpoint a database</dd>
</dl> </dd> <dt class="d_decl" id="SQLITE_VTAB_CONSTRAINT_SUPPORT">enum int <strong id="SQLITE_VTAB_CONSTRAINT_SUPPORT">SQLITE_VTAB_CONSTRAINT_SUPPORT</strong>; <br><br>nothrow int <strong id="sqlite3_preupdate_old">sqlite3_preupdate_old</strong>(sqlite3*, int, sqlite3_value**); <br><br>nothrow int <strong id="sqlite3_preupdate_count">sqlite3_preupdate_count</strong>(sqlite3*); <br><br>nothrow int <strong id="sqlite3_preupdate_depth">sqlite3_preupdate_depth</strong>(sqlite3*); <br><br>nothrow int <strong id="sqlite3_preupdate_new">sqlite3_preupdate_new</strong>(sqlite3*, int, sqlite3_value**); </dt> <dd>
<dl>
<dt>CAPI3REF</dt>
<dd> Virtual Table Configuration Options</dd>
</dl> </dd> <dt class="d_decl" id="sqlite3_rtree_geometry_callback">nothrow int <strong id="sqlite3_rtree_geometry_callback">sqlite3_rtree_geometry_callback</strong>(sqlite3* db, const(char)* zGeom, int function(sqlite3_rtree_geometry*, int nCoord, double* aCoord, int* pRes) xGeom, void* pContext); </dt> <dd>
<p>Register a geometry callback named zGeom that can be used as part of an R-Tree geometry query as follows: </p>
<p>SELECT ... FROM &lt;rtree&gt; WHERE &lt;rtree col&gt; MATCH zGeom(... params ...)</p> </dd> <dt class="d_decl" id="sqlite3_rtree_geometry">struct <strong id="sqlite3_rtree_geometry">sqlite3_rtree_geometry</strong>; </dt> <dd>
<p>A pointer to a structure of the following type is passed as the first argument to callbacks registered using rtree_geometry_callback().</p> <dl>
<dt class="d_decl" id="sqlite3_rtree_geometry.pContext">void* <strong id="pContext">pContext</strong>; </dt> <dd>
<p>Copy of pContext passed to s_r_g_c()</p> </dd> <dt class="d_decl" id="sqlite3_rtree_geometry.nParam">int <strong id="nParam">nParam</strong>; </dt> <dd>
<p>Size of array aParam[]</p> </dd> <dt class="d_decl" id="sqlite3_rtree_geometry.aParam">double* <strong id="aParam">aParam</strong>; </dt> <dd>
<p>Parameters passed to SQL geom function</p> </dd> <dt class="d_decl" id="sqlite3_rtree_geometry.pUser">void* <strong id="pUser">pUser</strong>; </dt> <dd>
<p>Callback implementation user data</p> </dd> <dt class="d_decl" id="sqlite3_rtree_geometry.xDelUser">void function(void*) <strong id="xDelUser">xDelUser</strong>; </dt> <dd>
<p>Called by SQLite to clean up pUser</p> </dd> </dl> </dd> <dt class="d_decl" id="NOT_WITHIN"><strong id="NOT_WITHIN">NOT_WITHIN</strong></dt> <dd>
<p>Object completely outside of query region</p> </dd> <dt class="d_decl" id="PARTLY_WITHIN"><strong id="PARTLY_WITHIN">PARTLY_WITHIN</strong></dt> <dd>
<p>Object partially overlaps query region</p> </dd> <dt class="d_decl" id="FULLY_WITHIN">
<strong id="FULLY_WITHIN">FULLY_WITHIN</strong><br><br>nothrow int <strong id="sqlite3changeset_start_v2">sqlite3changeset_start_v2</strong>(sqlite3_changeset_iter** pp, int nChangeset, void* pChangeset, int flags); <br><br>nothrow int <strong id="sqlite3changeset_apply_v2">sqlite3changeset_apply_v2</strong>(sqlite3* db, int nChangeset, void* pChangeset, int function(void* pCtx, const(char)* zTab) xFilter, int function(void* pCtx, int eConflict, sqlite3_changeset_iter* p) xConflict, void* pCtx, void** ppRebase, int* pnRebase, int flags); <br><br>nothrow int <strong id="sqlite3changeset_apply_v2_strm">sqlite3changeset_apply_v2_strm</strong>(sqlite3* db, int function(void* pIn, void* pData, int* pnData) xInput, void* pIn, int function(void* pCtx, const(char)* zTab) xFilter, int function(void* pCtx, int eConflict, sqlite3_changeset_iter* p) xConflict, void* pCtx, void** ppRebase, int* pnRebase, int flags); <br><br>nothrow int <strong id="sqlite3changeset_concat_strm">sqlite3changeset_concat_strm</strong>(int function(void* pIn, void* pData, int* pnData) xInputA, void* pInA, int function(void* pIn, void* pData, int* pnData) xInputB, void* pInB, int function(void* pOut, const(void)* pData, int nData) xOutput, void* pOut); <br><br>nothrow int <strong id="sqlite3changeset_invert_strm">sqlite3changeset_invert_strm</strong>(int function(void* pIn, void* pData, int* pnData) xInput, void* pIn, int function(void* pOut, const(void)* pData, int nData) xOutput, void* pOut); <br><br>nothrow int <strong id="sqlite3changeset_start_strm">sqlite3changeset_start_strm</strong>(sqlite3_changeset_iter** pp, int function(void* pIn, void* pData, int* pnData) xInput, void* pIn); <br><br>nothrow int <strong id="sqlite3changeset_start_v2_strm">sqlite3changeset_start_v2_strm</strong>(sqlite3_changeset_iter** pp, int function(void* pIn, void* pData, int* pnData) xInput, void* pIn, int flags); <br><br>nothrow int <strong id="sqlite3session_changeset_strm">sqlite3session_changeset_strm</strong>(sqlite3_session* pSession, int function(void* pOut, const(void)* pData, int nData) xOutput, void* pOut); <br><br>nothrow int <strong id="sqlite3session_patchset_strm">sqlite3session_patchset_strm</strong>(sqlite3_session* pSession, int function(void* pOut, const(void)* pData, int nData) xOutput, void* pOut); <br><br>nothrow int <strong id="sqlite3changegroup_add_strm">sqlite3changegroup_add_strm</strong>(sqlite3_changegroup*, int function(void* pIn, void* pData, int* pnData) xInput, void* pIn); <br><br>nothrow int <strong id="sqlite3changegroup_output_strm">sqlite3changegroup_output_strm</strong>(sqlite3_changegroup*, int function(void* pOut, const(void)* pData, int nData) xOutput, void* pOut); <br><br>nothrow int <strong id="sqlite3rebaser_rebase_strm">sqlite3rebaser_rebase_strm</strong>(sqlite3_rebaser* pRebaser, int function(void* pIn, void* pData, int* pnData) xInput, void* pIn, int function(void* pOut, const(void)* pData, int nData) xOutput, void* pOut); </dt> <dd>
<p>Object fully contained within query region</p> </dd> <dt class="d_decl" id="Fts5Context">struct <strong id="Fts5Context">Fts5Context</strong>; <br><br>alias <strong id="fts5_extension_function">fts5_extension_function</strong> = extern (C) void function(const(Fts5ExtensionApi*) pApi, Fts5Context* pFts, sqlite3_context* pCtx, int nVal, sqlite3_value** apVal) nothrow; <br><br>struct <strong id="Fts5PhraseIter">Fts5PhraseIter</strong>; <br><br>struct <strong id="Fts5ExtensionApi">Fts5ExtensionApi</strong>; <br><br>struct <strong id="Fts5Tokenizer">Fts5Tokenizer</strong>; <br><br>enum int <strong id="FTS5_TOKENIZE_QUERY">FTS5_TOKENIZE_QUERY</strong>; <br><br>enum int <strong id="FTS5_TOKENIZE_PREFIX">FTS5_TOKENIZE_PREFIX</strong>; <br><br>enum int <strong id="FTS5_TOKENIZE_DOCUMENT">FTS5_TOKENIZE_DOCUMENT</strong>; <br><br>enum int <strong id="FTS5_TOKENIZE_AUX">FTS5_TOKENIZE_AUX</strong>; <br><br>enum int <strong id="FTS5_TOKEN_COLOCATED">FTS5_TOKEN_COLOCATED</strong>; <br><br>struct <strong id="fts5_api">fts5_api</strong>; </dt> <dd>
<p>Interfaces to extend FTS5.</p> </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
     19992019 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/etc_c_sqlite3.html" class="_attribution-link">https://dlang.org/phobos/etc_c_sqlite3.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
