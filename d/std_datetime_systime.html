
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>std.datetime.systime - D - W3cubDocs</title>
  
  <meta name="description" content=" ">
  <meta name="keywords" content="std, datetime, systime, d">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/d/std_datetime_systime.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/d.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/d/" class="_nav-link" title="" style="margin-left:0;">D</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _d">
				
				
<h1>std.datetime.systime</h1>  <p> </p>
<table>

<tr>
<th scope="col">Category</th> <th scope="col">Functions</th>
</tr> <tr>
<td>Types</td> <td> <a href="#Clock"><code>Clock</code></a> <a href="#SysTime"><code>SysTime</code></a> <a href="#DosFileTime"><code>DosFileTime</code></a> </td>
</tr> <tr>
<td>Conversion</td> <td> <a href="#parseRFC822DateTime"><code>parseRFC822DateTime</code></a> <a href="#DosFileTimeToSysTime"><code>DosFileTimeToSysTime</code></a> <a href="#FILETIMEToStdTime"><code>FILETIMEToStdTime</code></a> <a href="#FILETIMEToSysTime"><code>FILETIMEToSysTime</code></a> <a href="#stdTimeToFILETIME"><code>stdTimeToFILETIME</code></a> <a href="#stdTimeToUnixTime"><code>stdTimeToUnixTime</code></a> <a href="#SYSTEMTIMEToSysTime"><code>SYSTEMTIMEToSysTime</code></a> <a href="#SysTimeToDosFileTime"><code>SysTimeToDosFileTime</code></a> <a href="#SysTimeToFILETIME"><code>SysTimeToFILETIME</code></a> <a href="#SysTimeToSYSTEMTIME"><code>SysTimeToSYSTEMTIME</code></a> <a href="#unixTimeToStdTime"><code>unixTimeToStdTime</code></a> </td>
</tr> </table> 
<dl>
<dt>License:</dt>
<dd>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>
<a href="http://jmdavisprog.com">Jonathan M Davis</a> </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/datetime/systime.d">std/datetime/systime.d</a></span>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Get the current time as a <a href="#SysTime"><code>SysTime</code></a> <pre data-language="d">import std.datetime.timezone : LocalTime;
SysTime today = Clock.currTime();
assert(today.timezone is LocalTime());
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Construct a <a href="#SysTime"><code>SysTime</code></a> from a ISO time string <pre data-language="d">import std.datetime.date : DateTime;
import std.datetime.timezone : UTC;

auto st = SysTime.fromISOExtString("2018-01-01T10:30:00Z");
writeln(st); // SysTime(DateTime(2018, 1, 1, 10, 30, 0), UTC())
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Make a specific point in time in the New York timezone <pre data-language="d">import core.time : hours;
import std.datetime.date : DateTime;
import std.datetime.timezone : SimpleTimeZone;

auto ny = SysTime(
    DateTime(2018, 1, 1, 10, 30, 0),
    new immutable SimpleTimeZone(-5.hours, "America/New_York")
);

// ISO standard time strings
writeln(ny.toISOString()); // "20180101T103000-05:00"
writeln(ny.toISOExtString()); // "2018-01-01T10:30:00-05:00"
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="Clock">class <strong id="Clock">Clock</strong>; </dt> <dd>
<p>Effectively a namespace to make it clear that the methods it contains are getting the time from the system clock. It cannot be instantiated.</p>
<dl>
<dt>Examples:</dt>
<dd>Get the current time as a <a href="#SysTime"><code>SysTime</code></a> <pre data-language="d">import std.datetime.timezone : LocalTime;
SysTime today = Clock.currTime();
assert(today.timezone is LocalTime());
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="Clock.currTime">@safe SysTime <strong id="currTime">currTime</strong>(ClockType clockType = ClockType.normal)(immutable TimeZone tz = LocalTime()); </dt> <dd>
<p>Returns the current time in the given time zone. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>clockType</td> <td>The <a href="core_time#ClockType"><code>core.time.ClockType</code></a> indicates which system clock to use to get the current time. Very few programs need to use anything other than the default.</td>
</tr> <tr>
<td>TimeZone <code>tz</code>
</td> <td>The time zone for the SysTime that's returned.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if it fails to get the time.</dd>
</dl> </dd> <dt class="d_decl" id="Clock.currStdTime">@property @trusted long <strong id="currStdTime">currStdTime</strong>(ClockType clockType = ClockType.normal)(); </dt> <dd>
<p>Returns the number of hnsecs since midnight, January 1st, 1 A.D. for the current time. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>clockType</td> <td>The <a href="core_time#ClockType"><code>core.time.ClockType</code></a> indicates which system clock to use to get the current time. Very few programs need to use anything other than the default.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if it fails to get the time.</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="SysTime">struct <strong id="SysTime">SysTime</strong>; </dt> <dd>
<p><code>SysTime</code> is the type used to get the current time from the system or doing anything that involves time zones. Unlike <a href="std_datetime_date#DateTime"><code>std.datetime.date.DateTime</code></a>, the time zone is an integral part of <code>SysTime</code> (though for local time applications, time zones can be ignored and it will work, since it defaults to using the local time zone). It holds its internal time in std time (hnsecs since midnight, January 1st, 1 A.D. UTC), so it interfaces well with the system time. However, that means that, unlike <a href="std_datetime_date#DateTime"><code>std.datetime.date.DateTime</code></a>, it is not optimized for calendar-based operations, and getting individual units from it such as years or days is going to involve conversions and be less efficient. </p>
<p>For calendar-based operations that don't care about time zones, then <a href="std_datetime_date#DateTime"><code>std.datetime.date.DateTime</code></a> would be the type to use. For system time, use <code>SysTime</code>. <br><br> <a href="#Clock.currTime"><code>Clock.currTime</code></a> will return the current time as a <code>SysTime</code>. To convert a <code>SysTime</code> to a <a href="std_datetime_date#Date"><code>std.datetime.date.Date</code></a> or <a href="std_datetime_date#DateTime"><code>std.datetime.date.DateTime</code></a>, simply cast it. To convert a <a href="std_datetime_date#Date"><code>std.datetime.date.Date</code></a> or <a href="std_datetime_date#DateTime"><code>std.datetime.date.DateTime</code></a> to a <code>SysTime</code>, use <code>SysTime</code>'s constructor, and pass in the ntended time zone with it (or don't pass in a <a href="std_datetime_timezone#TimeZone"><code>std.datetime.timezone.TimeZone</code></a>, and the local time zone will be used). Be aware, however, that converting from a <a href="std_datetime_date#DateTime"><code>std.datetime.date.DateTime</code></a> to a <code>SysTime</code> will not necessarily be 100% accurate due to DST (one hour of the year doesn't exist and another occurs twice). To not risk any conversion errors, keep times as <code>SysTime</code>s. Aside from DST though, there shouldn't be any conversion problems. <br><br> For using time zones other than local time or UTC, use <a href="std_datetime_timezone#PosixTimeZone"><code>std.datetime.timezone.PosixTimeZone</code></a> on Posix systems (or on Windows, if providing the TZ Database files), and use <a href="std_datetime_timezone#WindowsTimeZone"><code>std.datetime.timezone.WindowsTimeZone</code></a> on Windows systems. The time in <code>SysTime</code> is kept internally in hnsecs from midnight, January 1st, 1 A.D. UTC. Conversion error cannot happen when changing the time zone of a <code>SysTime</code>. <a href="std_datetime_timezone#LocalTime"><code>std.datetime.timezone.LocalTime</code></a> is the <a href="std_datetime_timezone#TimeZone"><code>std.datetime.timezone.TimeZone</code></a> class which represents the local time, and <code>UTC</code> is the <a href="std_datetime_timezone#TimeZone"><code>std.datetime.timezone.TimeZone</code></a> class which represents UTC. <code>SysTime</code> uses <a href="std_datetime_timezone#LocalTime"><code>std.datetime.timezone.LocalTime</code></a> if no <a href="std_datetime_timezone#TimeZone"><code>std.datetime.timezone.TimeZone</code></a> is provided. For more details on time zones, see the documentation for <a href="std_datetime_timezone#TimeZone"><code>std.datetime.timezone.TimeZone</code></a>, <a href="std_datetime_timezone#PosixTimeZone"><code>std.datetime.timezone.PosixTimeZone</code></a>, and <a href="std_datetime_timezone#WindowsTimeZone"><code>std.datetime.timezone.WindowsTimeZone</code></a>. <br><br> <code>SysTime</code>'s range is from approximately 29,000 B.C. to approximately 29,000 A.D.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import core.time : days, hours, seconds;
import std.datetime.date : DateTime;
import std.datetime.timezone : SimpleTimeZone, UTC;

// make a specific point in time in the UTC timezone
auto st = SysTime(DateTime(2018, 1, 1, 10, 30, 0), UTC());
// make a specific point in time in the New York timezone
auto ny = SysTime(
    DateTime(2018, 1, 1, 10, 30, 0),
    new immutable SimpleTimeZone(-5.hours, "America/New_York")
);

// ISO standard time strings
writeln(st.toISOString()); // "20180101T103000Z"
writeln(st.toISOExtString()); // "2018-01-01T10:30:00Z"

// add two days and 30 seconds
st += 2.days + 30.seconds;
writeln(st.toISOExtString()); // "2018-01-03T10:30:30Z"
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="SysTime.this">nothrow @safe this(DateTime dateTime, immutable TimeZone tz = null); </dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>DateTime <code>dateTime</code>
</td> <td>The <a href="std_datetime_date#DateTime"><code>std.datetime.date.DateTime</code></a> to use to set this <a href="#SysTime"><code>SysTime</code></a>'s internal std time. As <a href="std_datetime_date#DateTime"><code>std.datetime.date.DateTime</code></a> has no concept of time zone, tz is used as its time zone.</td>
</tr> <tr>
<td>TimeZone <code>tz</code>
</td> <td>The <a href="std_datetime_timezone#TimeZone"><code>std.datetime.timezone.TimeZone</code></a> to use for this <a href="#SysTime"><code>SysTime</code></a>. If null, <a href="std_datetime_timezone#LocalTime"><code>std.datetime.timezone.LocalTime</code></a> will be used. The given <a href="std_datetime_date#DateTime"><code>std.datetime.date.DateTime</code></a> is assumed to be in the given time zone.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="SysTime.this.2">@safe this(DateTime dateTime, Duration fracSecs, immutable TimeZone tz = null); </dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>DateTime <code>dateTime</code>
</td> <td>The <a href="std_datetime_date#DateTime"><code>std.datetime.date.DateTime</code></a> to use to set this <a href="#SysTime"><code>SysTime</code></a>'s internal std time. As <a href="std_datetime_date#DateTime"><code>std.datetime.date.DateTime</code></a> has no concept of time zone, tz is used as its time zone.</td>
</tr> <tr>
<td>Duration <code>fracSecs</code>
</td> <td>The fractional seconds portion of the time.</td>
</tr> <tr>
<td>TimeZone <code>tz</code>
</td> <td>The <a href="std_datetime_timezone#TimeZone"><code>std.datetime.timezone.TimeZone</code></a> to use for this <a href="#SysTime"><code>SysTime</code></a>. If null, <a href="std_datetime_timezone#LocalTime"><code>std.datetime.timezone.LocalTime</code></a> will be used. The given <a href="std_datetime_date#DateTime"><code>std.datetime.date.DateTime</code></a> is assumed to be in the given time zone.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if <code>fracSecs</code> is negative or if it's greater than or equal to one second.</dd>
</dl> </dd> <dt class="d_decl" id="SysTime.this.3">nothrow @safe this(Date date, immutable TimeZone tz = null); </dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Date <code>date</code>
</td> <td>The <a href="std_datetime_date#Date"><code>std.datetime.date.Date</code></a> to use to set this <a href="#SysTime"><code>SysTime</code></a>'s internal std time. As <a href="std_datetime_date#Date"><code>std.datetime.date.Date</code></a> has no concept of time zone, tz is used as its time zone.</td>
</tr> <tr>
<td>TimeZone <code>tz</code>
</td> <td>The <a href="std_datetime_timezone#TimeZone"><code>std.datetime.timezone.TimeZone</code></a> to use for this <a href="#SysTime"><code>SysTime</code></a>. If null, <a href="std_datetime_timezone#LocalTime"><code>std.datetime.timezone.LocalTime</code></a> will be used. The given <a href="std_datetime_date#Date"><code>std.datetime.date.Date</code></a> is assumed to be in the given time zone.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="SysTime.this.4">pure nothrow @safe this(long stdTime, immutable TimeZone tz = null); </dt> <dd>
<dl>
<dt>Note</dt>
<dd> Whereas the other constructors take in the given date/time, assume that it's in the given time zone, and convert it to hnsecs in UTC since midnight, January 1st, 1 A.D. UTC - i.e. std time - this constructor takes a std time, which is specifically already in UTC, so no conversion takes place. Of course, the various getter properties and functions will use the given time zone's conversion function to convert the results to that time zone, but no conversion of the arguments to this constructor takes place. </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>long <code>stdTime</code>
</td> <td>The number of hnsecs since midnight, January 1st, 1 A.D. UTC.</td>
</tr> <tr>
<td>TimeZone <code>tz</code>
</td> <td>The <a href="std_datetime_timezone#TimeZone"><code>std.datetime.timezone.TimeZone</code></a> to use for this <a href="#SysTime"><code>SysTime</code></a>. If null, <a href="std_datetime_timezone#LocalTime"><code>std.datetime.timezone.LocalTime</code></a> will be used.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="SysTime.opAssign">pure nothrow ref scope @safe SysTime <strong id="opAssign">opAssign</strong>()(auto ref const(SysTime) rhs) return; </dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(SysTime) <code>rhs</code>
</td> <td>The <a href="#SysTime"><code>SysTime</code></a> to assign to this one.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The <code>this</code> of this <code>SysTime</code>.</dd>
</dl> </dd> <dt class="d_decl" id="SysTime.opEquals">const pure nothrow scope @safe bool <strong id="opEquals">opEquals</strong>()(auto ref const(SysTime) rhs); </dt> <dd>
<p>Checks for equality between this <a href="#SysTime"><code>SysTime</code></a> and the given <a href="#SysTime"><code>SysTime</code></a>. </p>
<p>Note that the time zone is ignored. Only the internal std times (which are in UTC) are compared.</p> </dd> <dt class="d_decl" id="SysTime.opCmp">const pure nothrow scope @safe int <strong id="opCmp">opCmp</strong>()(auto ref const(SysTime) rhs); </dt> <dd>
<p>Compares this <a href="#SysTime"><code>SysTime</code></a> with the given <a href="#SysTime"><code>SysTime</code></a>. </p>
<p>Time zone is irrelevant when comparing <a href="#SysTime"><code>SysTime</code></a>s. </p> <dl>
<dt>Returns:</dt>
<dd><table>
 <tr>
<td>this &lt; rhs</td> <td>&lt; 0</td>
</tr> <tr>
<td>this == rhs</td> <td>0</td>
</tr> <tr>
<td>this &gt; rhs</td> <td>&gt; 0</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="SysTime.toHash">const pure nothrow @nogc scope @safe size_t <strong id="toHash">toHash</strong>(); </dt> <dd>
<dl>
<dt>Returns:</dt>
<dd>A hash of the <a href="#SysTime"><code>SysTime</code></a>.</dd>
</dl> </dd> <dt class="d_decl" id="SysTime.year">const nothrow @property scope @safe short <strong id="year">year</strong>(); </dt> <dd>
<p>Year of the Gregorian Calendar. Positive numbers are A.D. Non-positive are B.C.</p> </dd> <dt class="d_decl" id="SysTime.year.2">@property scope @safe void <strong id="year">year</strong>(int <strong id="year">year</strong>); </dt> <dd>
<p>Year of the Gregorian Calendar. Positive numbers are A.D. Non-positive are B.C. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>int <code>year</code>
</td> <td>The year to set this <a href="#SysTime"><code>SysTime</code></a>'s year to.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the new year is not a leap year and the resulting date would be on February 29th.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.datetime.date : DateTime;

writeln(SysTime(DateTime(1999, 7, 6, 9, 7, 5)).year); // 1999
writeln(SysTime(DateTime(2010, 10, 4, 0, 0, 30)).year); // 2010
writeln(SysTime(DateTime(-7, 4, 5, 7, 45, 2)).year); // -7
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="SysTime.yearBC">const @property scope @safe ushort <strong id="yearBC">yearBC</strong>(); </dt> <dd>
<p>Year B.C. of the Gregorian Calendar counting year 0 as 1 B.C. </p>
<dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if <code>isAD</code> is true.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.datetime.date : DateTime;

writeln(SysTime(DateTime(0, 1, 1, 12, 30, 33)).yearBC); // 1
writeln(SysTime(DateTime(-1, 1, 1, 10, 7, 2)).yearBC); // 2
writeln(SysTime(DateTime(-100, 1, 1, 4, 59, 0)).yearBC); // 101
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="SysTime.yearBC.2">@property scope @safe void <strong id="yearBC">yearBC</strong>(int year); </dt> <dd>
<p>Year B.C. of the Gregorian Calendar counting year 0 as 1 B.C. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>int <code>year</code>
</td> <td>The year B.C. to set this <a href="#SysTime"><code>SysTime</code></a>'s year to.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if a non-positive value is given.</dd>
</dl> </dd> <dt class="d_decl" id="SysTime.month">const nothrow @property scope @safe Month <strong id="month">month</strong>(); </dt> <dd>
<p>Month of a Gregorian Year.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.datetime.date : DateTime;

writeln(SysTime(DateTime(1999, 7, 6, 9, 7, 5)).month); // 7
writeln(SysTime(DateTime(2010, 10, 4, 0, 0, 30)).month); // 10
writeln(SysTime(DateTime(-7, 4, 5, 7, 45, 2)).month); // 4
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="SysTime.month.2">@property scope @safe void <strong id="month">month</strong>(Month <strong id="month">month</strong>); </dt> <dd>
<p>Month of a Gregorian Year. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Month <code>month</code>
</td> <td>The month to set this <a href="#SysTime"><code>SysTime</code></a>'s month to.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given month is not a valid month.</dd>
</dl> </dd> <dt class="d_decl" id="SysTime.day">const nothrow @property scope @safe ubyte <strong id="day">day</strong>(); </dt> <dd>
<p>Day of a Gregorian Month.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.datetime.date : DateTime;

writeln(SysTime(DateTime(1999, 7, 6, 9, 7, 5)).day); // 6
writeln(SysTime(DateTime(2010, 10, 4, 0, 0, 30)).day); // 4
writeln(SysTime(DateTime(-7, 4, 5, 7, 45, 2)).day); // 5
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="SysTime.day.2">@property scope @safe void <strong id="day">day</strong>(int <strong id="day">day</strong>); </dt> <dd>
<p>Day of a Gregorian Month. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>int <code>day</code>
</td> <td>The day of the month to set this <a href="#SysTime"><code>SysTime</code></a>'s day to.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given day is not a valid day of the current month.</dd>
</dl> </dd> <dt class="d_decl" id="SysTime.hour">const nothrow @property scope @safe ubyte <strong id="hour">hour</strong>(); </dt> <dd>
<p>Hours past midnight.</p> </dd> <dt class="d_decl" id="SysTime.hour.2">@property scope @safe void <strong id="hour">hour</strong>(int <strong id="hour">hour</strong>); </dt> <dd>
<p>Hours past midnight. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>int <code>hour</code>
</td> <td>The hours to set this <a href="#SysTime"><code>SysTime</code></a>'s hour to.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given hour are not a valid hour of the day.</dd>
</dl> </dd> <dt class="d_decl" id="SysTime.minute">const nothrow @property scope @safe ubyte <strong id="minute">minute</strong>(); </dt> <dd>
<p>Minutes past the current hour.</p> </dd> <dt class="d_decl" id="SysTime.minute.2">@property scope @safe void <strong id="minute">minute</strong>(int <strong id="minute">minute</strong>); </dt> <dd>
<p>Minutes past the current hour. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>int <code>minute</code>
</td> <td>The minute to set this <a href="#SysTime"><code>SysTime</code></a>'s minute to.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given minute are not a valid minute of an hour.</dd>
</dl> </dd> <dt class="d_decl" id="SysTime.second">const nothrow @property scope @safe ubyte <strong id="second">second</strong>(); </dt> <dd>
<p>Seconds past the current minute.</p> </dd> <dt class="d_decl" id="SysTime.second.2">@property scope @safe void <strong id="second">second</strong>(int <strong id="second">second</strong>); </dt> <dd>
<p>Seconds past the current minute. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>int <code>second</code>
</td> <td>The second to set this <a href="#SysTime"><code>SysTime</code></a>'s second to.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given second are not a valid second of a minute.</dd>
</dl> </dd> <dt class="d_decl" id="SysTime.fracSecs">const nothrow @property scope @safe Duration <strong id="fracSecs">fracSecs</strong>(); </dt> <dd>
<p>Fractional seconds past the second (i.e. the portion of a <a href="#SysTime"><code>SysTime</code></a> which is less than a second).</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import core.time : msecs, usecs, hnsecs, nsecs;
import std.datetime.date : DateTime;

auto dt = DateTime(1982, 4, 1, 20, 59, 22);
writeln(SysTime(dt, msecs(213)).fracSecs); // msecs(213)
writeln(SysTime(dt, usecs(5202)).fracSecs); // usecs(5202)
writeln(SysTime(dt, hnsecs(1234567)).fracSecs); // hnsecs(1234567)

// SysTime and Duration both have a precision of hnsecs (100 ns),
// so nsecs are going to be truncated.
writeln(SysTime(dt, nsecs(123456789)).fracSecs); // nsecs(123456700)
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="SysTime.fracSecs.2">@property scope @safe void <strong id="fracSecs">fracSecs</strong>(Duration <strong id="fracSecs">fracSecs</strong>); </dt> <dd>
<p>Fractional seconds past the second (i.e. the portion of a <a href="#SysTime"><code>SysTime</code></a> which is less than a second). </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Duration <code>fracSecs</code>
</td> <td>The duration to set this <a href="#SysTime"><code>SysTime</code></a>'s fractional seconds to.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given duration is negative or if it's greater than or equal to one second.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import core.time : Duration, msecs, hnsecs, nsecs;
import std.datetime.date : DateTime;

auto st = SysTime(DateTime(1982, 4, 1, 20, 59, 22));
writeln(st.fracSecs); // Duration.zero

st.fracSecs = msecs(213);
writeln(st.fracSecs); // msecs(213)

st.fracSecs = hnsecs(1234567);
writeln(st.fracSecs); // hnsecs(1234567)

// SysTime has a precision of hnsecs (100 ns), so nsecs are
// going to be truncated.
st.fracSecs = nsecs(123456789);
writeln(st.fracSecs); // hnsecs(1234567)
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="SysTime.stdTime">const pure nothrow @property scope @safe long <strong id="stdTime">stdTime</strong>(); </dt> <dd>
<p>The total hnsecs from midnight, January 1st, 1 A.D. UTC. This is the internal representation of <a href="#SysTime"><code>SysTime</code></a>.</p> </dd> <dt class="d_decl" id="SysTime.stdTime.2">pure nothrow @property scope @safe void <strong id="stdTime">stdTime</strong>(long <strong id="stdTime">stdTime</strong>); </dt> <dd>
<p>The total hnsecs from midnight, January 1st, 1 A.D. UTC. This is the internal representation of <a href="#SysTime"><code>SysTime</code></a>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>long <code>stdTime</code>
</td> <td>The number of hnsecs since January 1st, 1 A.D. UTC.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="SysTime.timezone">const pure nothrow @property scope @safe immutable(TimeZone) <strong id="timezone">timezone</strong>(); </dt> <dd>
<p>The current time zone of this <a href="#SysTime"><code>SysTime</code></a>. Its internal time is always kept in UTC, so there are no conversion issues between time zones due to DST. Functions which return all or part of the time - such as hours - adjust the time to this <a href="#SysTime"><code>SysTime</code></a>'s time zone before returning.</p> </dd> <dt class="d_decl" id="SysTime.timezone.2">pure nothrow @property scope @safe void <strong id="timezone">timezone</strong>(immutable TimeZone <strong id="timezone">timezone</strong>); </dt> <dd>
<p>The current time zone of this <a href="#SysTime"><code>SysTime</code></a>. It's internal time is always kept in UTC, so there are no conversion issues between time zones due to DST. Functions which return all or part of the time - such as hours - adjust the time to this <a href="#SysTime"><code>SysTime</code></a>'s time zone before returning. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TimeZone <code>timezone</code>
</td> <td>The <a href="std_datetime_timezone#TimeZone"><code>std.datetime.timezone.TimeZone</code></a> to set this <a href="#SysTime"><code>SysTime</code></a>'s time zone to.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="SysTime.dstInEffect">const nothrow @property scope @safe bool <strong id="dstInEffect">dstInEffect</strong>(); </dt> <dd>
<p>Returns whether DST is in effect for this <a href="#SysTime"><code>SysTime</code></a>.</p> </dd> <dt class="d_decl" id="SysTime.utcOffset">const nothrow @property scope @safe Duration <strong id="utcOffset">utcOffset</strong>(); </dt> <dd>
<p>Returns what the offset from UTC is for this <a href="#SysTime"><code>SysTime</code></a>. It includes the DST offset in effect at that time (if any).</p> </dd> <dt class="d_decl" id="SysTime.toLocalTime">const pure nothrow scope @safe SysTime <strong id="toLocalTime">toLocalTime</strong>(); </dt> <dd>
<p>Returns a <a href="#SysTime"><code>SysTime</code></a> with the same std time as this one, but with <a href="std_datetime_timezone#LocalTime"><code>std.datetime.timezone.LocalTime</code></a> as its time zone.</p> </dd> <dt class="d_decl" id="SysTime.toUTC">const pure nothrow scope @safe SysTime <strong id="toUTC">toUTC</strong>(); </dt> <dd>
<p>Returns a <a href="#SysTime"><code>SysTime</code></a> with the same std time as this one, but with <code>UTC</code> as its time zone.</p> </dd> <dt class="d_decl" id="SysTime.toOtherTZ">const pure nothrow scope @safe SysTime <strong id="toOtherTZ">toOtherTZ</strong>(immutable TimeZone tz); </dt> <dd>
<p>Returns a <a href="#SysTime"><code>SysTime</code></a> with the same std time as this one, but with given time zone as its time zone.</p> </dd> <dt class="d_decl" id="SysTime.toUnixTime">const pure nothrow scope @safe T <strong id="toUnixTime">toUnixTime</strong>(T = time_t)()<br><small>  Constraints: if (is(T == int) || is(T == long)); </small>
</dt> <dd>
<p>Converts this <a href="#SysTime"><code>SysTime</code></a> to unix time (i.e. seconds from midnight, January 1st, 1970 in UTC). </p>
<p>The C standard does not specify the representation of time_t, so it is implementation defined. On POSIX systems, unix time is equivalent to time_t, but that's not necessarily true on other systems (e.g. it is not true for the Digital Mars C runtime). So, be careful when using unix time with C functions on non-POSIX systems. <br><br> By default, the return type is time_t (which is normally an alias for int on 32-bit systems and long on 64-bit systems), but if a different size is required than either int or long can be passed as a template argument to get the desired size. <br><br> If the return type is int, and the result can't fit in an int, then the closest value that can be held in 32 bits will be used (so <code>int.max</code> if it goes over and <code>int.min</code> if it goes under). However, no attempt is made to deal with integer overflow if the return type is long. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>The return type (int or long). It defaults to time_t, which is normally 32 bits on a 32-bit system and 64 bits on a 64-bit system.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A signed integer representing the unix time which is equivalent to this SysTime.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import core.time : hours;
import std.datetime.date : DateTime;
import std.datetime.timezone : SimpleTimeZone, UTC;

writeln(SysTime(DateTime(1970, 1, 1), UTC()).toUnixTime()); // 0

auto pst = new immutable SimpleTimeZone(hours(-8));
writeln(SysTime(DateTime(1970, 1, 1), pst).toUnixTime()); // 28800

auto utc = SysTime(DateTime(2007, 12, 22, 8, 14, 45), UTC());
writeln(utc.toUnixTime()); // 1_198_311_285

auto ca = SysTime(DateTime(2007, 12, 22, 8, 14, 45), pst);
writeln(ca.toUnixTime()); // 1_198_340_085

static void testScope(scope ref SysTime st) @safe
{
    auto result = st.toUnixTime();
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="SysTime.fromUnixTime">static pure nothrow @safe SysTime <strong id="fromUnixTime">fromUnixTime</strong>(long unixTime, immutable TimeZone tz = LocalTime()); </dt> <dd>
<p>Converts from unix time (i.e. seconds from midnight, January 1st, 1970 in UTC) to a <a href="#SysTime"><code>SysTime</code></a>. </p>
<p>The C standard does not specify the representation of time_t, so it is implementation defined. On POSIX systems, unix time is equivalent to time_t, but that's not necessarily true on other systems (e.g. it is not true for the Digital Mars C runtime). So, be careful when using unix time with C functions on non-POSIX systems. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>long <code>unixTime</code>
</td> <td>Seconds from midnight, January 1st, 1970 in UTC.</td>
</tr> <tr>
<td>TimeZone <code>tz</code>
</td> <td>The time zone for the SysTime that's returned.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import core.time : hours;
import std.datetime.date : DateTime;
import std.datetime.timezone : SimpleTimeZone, UTC;

assert(SysTime.fromUnixTime(0) ==
       SysTime(DateTime(1970, 1, 1), UTC()));

auto pst = new immutable SimpleTimeZone(hours(-8));
assert(SysTime.fromUnixTime(28800) ==
       SysTime(DateTime(1970, 1, 1), pst));

auto st1 = SysTime.fromUnixTime(1_198_311_285, UTC());
writeln(st1); // SysTime(DateTime(2007, 12, 22, 8, 14, 45), UTC())
assert(st1.timezone is UTC());
writeln(st1); // SysTime(DateTime(2007, 12, 22, 0, 14, 45), pst)

auto st2 = SysTime.fromUnixTime(1_198_311_285, pst);
writeln(st2); // SysTime(DateTime(2007, 12, 22, 8, 14, 45), UTC())
assert(st2.timezone is pst);
writeln(st2); // SysTime(DateTime(2007, 12, 22, 0, 14, 45), pst)
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="SysTime.toTimeVal">const pure nothrow scope @safe timeval <strong id="toTimeVal">toTimeVal</strong>(); </dt> <dd>
<p>Returns a <code>timeval</code> which represents this <a href="#SysTime"><code>SysTime</code></a>. </p>
<p>Note that like all conversions in std.datetime, this is a truncating conversion. <br><br> If <code>timeval.tv_sec</code> is int, and the result can't fit in an int, then the closest value that can be held in 32 bits will be used for <code>tv_sec</code>. (so <code>int.max</code> if it goes over and <code>int.min</code> if it goes under).</p> </dd> <dt class="d_decl" id="SysTime.toTimeSpec">const pure nothrow scope @safe timespec <strong id="toTimeSpec">toTimeSpec</strong>(); </dt> <dd>
<p>Returns a <code>timespec</code> which represents this <a href="#SysTime"><code>SysTime</code></a>. </p>
<p><span class="blue">This function is Posix-Only.</span></p> </dd> <dt class="d_decl" id="SysTime.toTM">const nothrow scope @safe tm <strong id="toTM">toTM</strong>(); </dt> <dd>
<p>Returns a <code>tm</code> which represents this <a href="#SysTime"><code>SysTime</code></a>.</p> </dd> <dt class="d_decl" id="SysTime.add">nothrow ref scope @safe SysTime <strong id="add">add</strong>(string units)(long value, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)<br><small>  Constraints: if (units == "years" || units == "months"); </small>
</dt> <dd>
<p>Adds the given number of years or months to this <a href="#SysTime"><code>SysTime</code></a>. A negative number will subtract. </p>
<p>Note that if day overflow is allowed, and the date with the adjusted year/month overflows the number of days in the new month, then the month will be incremented by one, and the day set to the number of days overflowed. (e.g. if the day were 31 and the new month were June, then the month would be incremented to July, and the new day would be 1). If day overflow is not allowed, then the day will be set to the last valid day in the month (e.g. June 31st would become June 30th). </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>units</td> <td>The type of units to add ("years" or "months").</td>
</tr> <tr>
<td>long <code>value</code>
</td> <td>The number of months or years to add to this <a href="#SysTime"><code>SysTime</code></a>.</td>
</tr> <tr>
<td>AllowDayOverflow <code>allowOverflow</code>
</td> <td>Whether the days should be allowed to overflow, causing the month to increment.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="SysTime.roll">nothrow ref scope @safe SysTime <strong id="roll">roll</strong>(string units)(long value, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)<br><small>  Constraints: if (units == "years"); </small>
</dt> <dd>
<p>Adds the given number of years or months to this <a href="#SysTime"><code>SysTime</code></a>. A negative number will subtract. </p>
<p>The difference between rolling and adding is that rolling does not affect larger units. Rolling a <a href="#SysTime"><code>SysTime</code></a> 12 months gets the exact same <a href="#SysTime"><code>SysTime</code></a>. However, the days can still be affected due to the differing number of days in each month. <br><br> Because there are no units larger than years, there is no difference between adding and rolling years. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>units</td> <td>The type of units to add ("years" or "months").</td>
</tr> <tr>
<td>long <code>value</code>
</td> <td>The number of months or years to add to this <a href="#SysTime"><code>SysTime</code></a>.</td>
</tr> <tr>
<td>AllowDayOverflow <code>allowOverflow</code>
</td> <td>Whether the days should be allowed to overflow, causing the month to increment.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.datetime.date : AllowDayOverflow, DateTime;

auto st1 = SysTime(DateTime(2010, 1, 1, 12, 33, 33));
st1.roll!"months"(1);
writeln(st1); // SysTime(DateTime(2010, 2, 1, 12, 33, 33))

auto st2 = SysTime(DateTime(2010, 1, 1, 12, 33, 33));
st2.roll!"months"(-1);
writeln(st2); // SysTime(DateTime(2010, 12, 1, 12, 33, 33))

auto st3 = SysTime(DateTime(1999, 1, 29, 12, 33, 33));
st3.roll!"months"(1);
writeln(st3); // SysTime(DateTime(1999, 3, 1, 12, 33, 33))

auto st4 = SysTime(DateTime(1999, 1, 29, 12, 33, 33));
st4.roll!"months"(1, AllowDayOverflow.no);
writeln(st4); // SysTime(DateTime(1999, 2, 28, 12, 33, 33))

auto st5 = SysTime(DateTime(2000, 2, 29, 12, 30, 33));
st5.roll!"years"(1);
writeln(st5); // SysTime(DateTime(2001, 3, 1, 12, 30, 33))

auto st6 = SysTime(DateTime(2000, 2, 29, 12, 30, 33));
st6.roll!"years"(1, AllowDayOverflow.no);
writeln(st6); // SysTime(DateTime(2001, 2, 28, 12, 30, 33))
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="SysTime.roll.2">nothrow ref scope @safe SysTime <strong id="roll">roll</strong>(string units)(long value)<br><small>  Constraints: if (units == "days"); </small>
</dt> <dd>
<p>Adds the given number of units to this <a href="#SysTime"><code>SysTime</code></a>. A negative number will subtract. </p>
<p>The difference between rolling and adding is that rolling does not affect larger units. For instance, rolling a <a href="#SysTime"><code>SysTime</code></a> one year's worth of days gets the exact same <a href="#SysTime"><code>SysTime</code></a>. <br><br> Accepted units are <code>"days"</code>, <code>"minutes"</code>, <code>"hours"</code>, <code>"minutes"</code>, <code>"seconds"</code>, <code>"msecs"</code>, <code>"usecs"</code>, and <code>"hnsecs"</code>. <br><br> Note that when rolling msecs, usecs or hnsecs, they all add up to a second. So, for example, rolling 1000 msecs is exactly the same as rolling 100,000 usecs. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>units</td> <td>The units to add.</td>
</tr> <tr>
<td>long <code>value</code>
</td> <td>The number of <span class="d_param">units</span> to add to this <a href="#SysTime"><code>SysTime</code></a>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import core.time : msecs, hnsecs;
import std.datetime.date : DateTime;

auto st1 = SysTime(DateTime(2010, 1, 1, 11, 23, 12));
st1.roll!"days"(1);
writeln(st1); // SysTime(DateTime(2010, 1, 2, 11, 23, 12))
st1.roll!"days"(365);
writeln(st1); // SysTime(DateTime(2010, 1, 26, 11, 23, 12))
st1.roll!"days"(-32);
writeln(st1); // SysTime(DateTime(2010, 1, 25, 11, 23, 12))

auto st2 = SysTime(DateTime(2010, 7, 4, 12, 0, 0));
st2.roll!"hours"(1);
writeln(st2); // SysTime(DateTime(2010, 7, 4, 13, 0, 0))

auto st3 = SysTime(DateTime(2010, 2, 12, 12, 0, 0));
st3.roll!"hours"(-1);
writeln(st3); // SysTime(DateTime(2010, 2, 12, 11, 0, 0))

auto st4 = SysTime(DateTime(2009, 12, 31, 0, 0, 0));
st4.roll!"minutes"(1);
writeln(st4); // SysTime(DateTime(2009, 12, 31, 0, 1, 0))

auto st5 = SysTime(DateTime(2010, 1, 1, 0, 0, 0));
st5.roll!"minutes"(-1);
writeln(st5); // SysTime(DateTime(2010, 1, 1, 0, 59, 0))

auto st6 = SysTime(DateTime(2009, 12, 31, 0, 0, 0));
st6.roll!"seconds"(1);
writeln(st6); // SysTime(DateTime(2009, 12, 31, 0, 0, 1))

auto st7 = SysTime(DateTime(2010, 1, 1, 0, 0, 0));
st7.roll!"seconds"(-1);
writeln(st7); // SysTime(DateTime(2010, 1, 1, 0, 0, 59))

auto dt = DateTime(2010, 1, 1, 0, 0, 0);
auto st8 = SysTime(dt);
st8.roll!"msecs"(1);
writeln(st8); // SysTime(dt, msecs(1))

auto st9 = SysTime(dt);
st9.roll!"msecs"(-1);
writeln(st9); // SysTime(dt, msecs(999))

auto st10 = SysTime(dt);
st10.roll!"hnsecs"(1);
writeln(st10); // SysTime(dt, hnsecs(1))

auto st11 = SysTime(dt);
st11.roll!"hnsecs"(-1);
writeln(st11); // SysTime(dt, hnsecs(9_999_999))
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="SysTime.opBinary">const pure nothrow scope @safe SysTime <strong id="opBinary">opBinary</strong>(string op)(Duration duration)<br><small>  Constraints: if (op == "+" || op == "-"); </small>
</dt> <dd>
<p>Gives the result of adding or subtracting a <a href="core_time#Duration"><code>core.time.Duration</code></a> from this <a href="#SysTime"><code>SysTime</code></a>. </p>
<p>The legal types of arithmetic for <a href="#SysTime"><code>SysTime</code></a> using this operator are <br><br> </p>
<table>
 <tr>
<td>SysTime</td> <td>+</td> <td>Duration</td> <td>--&gt;</td> <td>SysTime</td>
</tr> <tr>
<td>SysTime</td> <td>-</td> <td>Duration</td> <td>--&gt;</td> <td>SysTime</td>
</tr> </table>  <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Duration <code>duration</code>
</td> <td>The <a href="core_time#Duration"><code>core.time.Duration</code></a> to add to or subtract from this <a href="#SysTime"><code>SysTime</code></a>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import core.time : hours, seconds;
import std.datetime.date : DateTime;

assert(SysTime(DateTime(2015, 12, 31, 23, 59, 59)) + seconds(1) ==
       SysTime(DateTime(2016, 1, 1, 0, 0, 0)));

assert(SysTime(DateTime(2015, 12, 31, 23, 59, 59)) + hours(1) ==
       SysTime(DateTime(2016, 1, 1, 0, 59, 59)));

assert(SysTime(DateTime(2016, 1, 1, 0, 0, 0)) - seconds(1) ==
       SysTime(DateTime(2015, 12, 31, 23, 59, 59)));

assert(SysTime(DateTime(2016, 1, 1, 0, 59, 59)) - hours(1) ==
       SysTime(DateTime(2015, 12, 31, 23, 59, 59)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="SysTime.opOpAssign">pure nothrow ref scope @safe SysTime <strong id="opOpAssign">opOpAssign</strong>(string op)(Duration duration)<br><small>  Constraints: if (op == "+" || op == "-"); </small>
</dt> <dd>
<p>Gives the result of adding or subtracting a <a href="core_time#Duration"><code>core.time.Duration</code></a> from this <a href="#SysTime"><code>SysTime</code></a>, as well as assigning the result to this <a href="#SysTime"><code>SysTime</code></a>. </p>
<p>The legal types of arithmetic for <a href="#SysTime"><code>SysTime</code></a> using this operator are <br><br> </p>
<table>
 <tr>
<td>SysTime</td> <td>+</td> <td>Duration</td> <td>--&gt;</td> <td>SysTime</td>
</tr> <tr>
<td>SysTime</td> <td>-</td> <td>Duration</td> <td>--&gt;</td> <td>SysTime</td>
</tr> </table>  <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Duration <code>duration</code>
</td> <td>The <a href="core_time#Duration"><code>core.time.Duration</code></a> to add to or subtract from this <a href="#SysTime"><code>SysTime</code></a>.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="SysTime.opBinary.2">const pure nothrow scope @safe Duration <strong id="opBinary">opBinary</strong>(string op)(SysTime rhs)<br><small>  Constraints: if (op == "-"); </small>
</dt> <dd>
<p>Gives the difference between two <a href="#SysTime"><code>SysTime</code></a>s. </p>
<p>The legal types of arithmetic for <a href="#SysTime"><code>SysTime</code></a> using this operator are <br><br> </p>
<table>
 <tr>
<td>SysTime</td> <td>-</td> <td>SysTime</td> <td>--&gt;</td> <td>duration</td>
</tr> </table> </dd> <dt class="d_decl" id="SysTime.diffMonths">const nothrow scope @safe int <strong id="diffMonths">diffMonths</strong>(scope SysTime rhs); </dt> <dd>
<p>Returns the difference between the two <a href="#SysTime"><code>SysTime</code></a>s in months. </p>
<p>To get the difference in years, subtract the year property of two <a href="#SysTime"><code>SysTime</code></a>s. To get the difference in days or weeks, subtract the <a href="#SysTime"><code>SysTime</code></a>s themselves and use the <a href="core_time#Duration"><code>core.time.Duration</code></a> that results. Because converting between months and smaller units requires a specific date (which <a href="core_time#Duration"><code>core.time.Duration</code></a>s don't have), getting the difference in months requires some math using both the year and month properties, so this is a convenience function for getting the difference in months. <br><br> Note that the number of days in the months or how far into the month either date is is irrelevant. It is the difference in the month property combined with the difference in years * 12. So, for instance, December 31st and January 1st are one month apart just as December 1st and January 31st are one month apart. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>SysTime <code>rhs</code>
</td> <td>The <a href="#SysTime"><code>SysTime</code></a> to subtract from this one.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import core.time;
import std.datetime.date : Date;

assert(SysTime(Date(1999, 2, 1)).diffMonths(
           SysTime(Date(1999, 1, 31))) == 1);

assert(SysTime(Date(1999, 1, 31)).diffMonths(
           SysTime(Date(1999, 2, 1))) == -1);

assert(SysTime(Date(1999, 3, 1)).diffMonths(
           SysTime(Date(1999, 1, 1))) == 2);

assert(SysTime(Date(1999, 1, 1)).diffMonths(
           SysTime(Date(1999, 3, 31))) == -2);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="SysTime.isLeapYear">const nothrow @property scope @safe bool <strong id="isLeapYear">isLeapYear</strong>(); </dt> <dd>
<p>Whether this <a href="#SysTime"><code>SysTime</code></a> is in a leap year.</p> </dd> <dt class="d_decl" id="SysTime.dayOfWeek">const nothrow @property scope @safe DayOfWeek <strong id="dayOfWeek">dayOfWeek</strong>(); </dt> <dd>
<p>Day of the week this <a href="#SysTime"><code>SysTime</code></a> is on.</p> </dd> <dt class="d_decl" id="SysTime.dayOfYear">const nothrow @property scope @safe ushort <strong id="dayOfYear">dayOfYear</strong>(); </dt> <dd>
<p>Day of the year this <a href="#SysTime"><code>SysTime</code></a> is on.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import core.time;
import std.datetime.date : DateTime;

writeln(SysTime(DateTime(1999, 1, 1, 12, 22, 7)).dayOfYear); // 1
writeln(SysTime(DateTime(1999, 12, 31, 7, 2, 59)).dayOfYear); // 365
writeln(SysTime(DateTime(2000, 12, 31, 21, 20, 0)).dayOfYear); // 366
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="SysTime.dayOfYear.2">@property scope @safe void <strong id="dayOfYear">dayOfYear</strong>(int day); </dt> <dd>
<p>Day of the year. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>int <code>day</code>
</td> <td>The day of the year to set which day of the year this <a href="#SysTime"><code>SysTime</code></a> is on.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="SysTime.dayOfGregorianCal">const nothrow @property scope @safe int <strong id="dayOfGregorianCal">dayOfGregorianCal</strong>(); </dt> <dd>
<p>The Xth day of the Gregorian Calendar that this <a href="#SysTime"><code>SysTime</code></a> is on.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import core.time;
import std.datetime.date : DateTime;

writeln(SysTime(DateTime(1, 1, 1, 0, 0, 0)).dayOfGregorianCal); // 1
writeln(SysTime(DateTime(1, 12, 31, 23, 59, 59)).dayOfGregorianCal); // 365
writeln(SysTime(DateTime(2, 1, 1, 2, 2, 2)).dayOfGregorianCal); // 366

writeln(SysTime(DateTime(0, 12, 31, 7, 7, 7)).dayOfGregorianCal); // 0
writeln(SysTime(DateTime(0, 1, 1, 19, 30, 0)).dayOfGregorianCal); // -365
writeln(SysTime(DateTime(-1, 12, 31, 4, 7, 0)).dayOfGregorianCal); // -366

writeln(SysTime(DateTime(2000, 1, 1, 9, 30, 20)).dayOfGregorianCal); // 730_120
writeln(SysTime(DateTime(2010, 12, 31, 15, 45, 50)).dayOfGregorianCal); // 734_137
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="SysTime.dayOfGregorianCal.2">nothrow @property scope @safe void <strong id="dayOfGregorianCal">dayOfGregorianCal</strong>(int days); </dt> <dd>
<p>The Xth day of the Gregorian Calendar that this <a href="#SysTime"><code>SysTime</code></a> is on. Setting this property does not affect the time portion of <a href="#SysTime"><code>SysTime</code></a>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>int <code>days</code>
</td> <td>The day of the Gregorian Calendar to set this <a href="#SysTime"><code>SysTime</code></a> to.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import core.time;
import std.datetime.date : DateTime;

auto st = SysTime(DateTime(0, 1, 1, 12, 0, 0));
st.dayOfGregorianCal = 1;
writeln(st); // SysTime(DateTime(1, 1, 1, 12, 0, 0))

st.dayOfGregorianCal = 365;
writeln(st); // SysTime(DateTime(1, 12, 31, 12, 0, 0))

st.dayOfGregorianCal = 366;
writeln(st); // SysTime(DateTime(2, 1, 1, 12, 0, 0))

st.dayOfGregorianCal = 0;
writeln(st); // SysTime(DateTime(0, 12, 31, 12, 0, 0))

st.dayOfGregorianCal = -365;
writeln(st); // SysTime(DateTime(-0, 1, 1, 12, 0, 0))

st.dayOfGregorianCal = -366;
writeln(st); // SysTime(DateTime(-1, 12, 31, 12, 0, 0))

st.dayOfGregorianCal = 730_120;
writeln(st); // SysTime(DateTime(2000, 1, 1, 12, 0, 0))

st.dayOfGregorianCal = 734_137;
writeln(st); // SysTime(DateTime(2010, 12, 31, 12, 0, 0))
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="SysTime.isoWeek">const nothrow @property scope @safe ubyte <strong id="isoWeek">isoWeek</strong>(); </dt> <dd>
<p>The ISO 8601 week of the year that this <a href="#SysTime"><code>SysTime</code></a> is in. </p>
<dl>
<dt>See Also:</dt>
<dd>
<a href="http://en.wikipedia.org/wiki/ISO_week_date">ISO Week Date</a>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import core.time;
import std.datetime.date : Date;

auto st = SysTime(Date(1999, 7, 6));
const cst = SysTime(Date(2010, 5, 1));
immutable ist = SysTime(Date(2015, 10, 10));

writeln(st.isoWeek); // 27
writeln(cst.isoWeek); // 17
writeln(ist.isoWeek); // 41
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="SysTime.endOfMonth">const nothrow @property scope @safe SysTime <strong id="endOfMonth">endOfMonth</strong>(); </dt> <dd>
<p><a href="#SysTime"><code>SysTime</code></a> for the last day in the month that this Date is in. The time portion of endOfMonth is always 23:59:59.9999999.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import core.time : msecs, usecs, hnsecs;
import std.datetime.date : DateTime;

assert(SysTime(DateTime(1999, 1, 6, 0, 0, 0)).endOfMonth ==
       SysTime(DateTime(1999, 1, 31, 23, 59, 59), hnsecs(9_999_999)));

assert(SysTime(DateTime(1999, 2, 7, 19, 30, 0), msecs(24)).endOfMonth ==
       SysTime(DateTime(1999, 2, 28, 23, 59, 59), hnsecs(9_999_999)));

assert(SysTime(DateTime(2000, 2, 7, 5, 12, 27), usecs(5203)).endOfMonth ==
       SysTime(DateTime(2000, 2, 29, 23, 59, 59), hnsecs(9_999_999)));

assert(SysTime(DateTime(2000, 6, 4, 12, 22, 9), hnsecs(12345)).endOfMonth ==
       SysTime(DateTime(2000, 6, 30, 23, 59, 59), hnsecs(9_999_999)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="SysTime.daysInMonth">const nothrow @property scope @safe ubyte <strong id="daysInMonth">daysInMonth</strong>(); </dt> <dd>
<p>The last day in the month that this <a href="#SysTime"><code>SysTime</code></a> is in.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import core.time;
import std.datetime.date : DateTime;

writeln(SysTime(DateTime(1999, 1, 6, 0, 0, 0)).daysInMonth); // 31
writeln(SysTime(DateTime(1999, 2, 7, 19, 30, 0)).daysInMonth); // 28
writeln(SysTime(DateTime(2000, 2, 7, 5, 12, 27)).daysInMonth); // 29
writeln(SysTime(DateTime(2000, 6, 4, 12, 22, 9)).daysInMonth); // 30
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="SysTime.isAD">const nothrow @property scope @safe bool <strong id="isAD">isAD</strong>(); </dt> <dd>
<p>Whether the current year is a date in A.D.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import core.time;
import std.datetime.date : DateTime;

assert(SysTime(DateTime(1, 1, 1, 12, 7, 0)).isAD);
assert(SysTime(DateTime(2010, 12, 31, 0, 0, 0)).isAD);
assert(!SysTime(DateTime(0, 12, 31, 23, 59, 59)).isAD);
assert(!SysTime(DateTime(-2010, 1, 1, 2, 2, 2)).isAD);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="SysTime.julianDay">const nothrow @property scope @safe long <strong id="julianDay">julianDay</strong>(); </dt> <dd>
<p>The <a href="http://en.wikipedia.org/wiki/Julian_day">Julian day</a> for this <a href="#SysTime"><code>SysTime</code></a> at the given time. For example, prior to noon, 1996-03-31 would be the Julian day number 2_450_173, so this function returns 2_450_173, while from noon onward, the Julian day number would be 2_450_174, so this function returns 2_450_174.</p> </dd> <dt class="d_decl" id="SysTime.modJulianDay">const nothrow @property scope @safe long <strong id="modJulianDay">modJulianDay</strong>(); </dt> <dd>
<p>The modified <a href="http://en.wikipedia.org/wiki/Julian_day">Julian day</a> for any time on this date (since, the modified Julian day changes at midnight).</p> </dd> <dt class="d_decl" id="SysTime.opCast">const nothrow scope @safe Date <strong id="opCast">opCast</strong>(T)()<br><small>  Constraints: if (is(Unqual!T == Date)); </small>
</dt> <dd>
<p>Returns a <a href="std_datetime_date#Date"><code>std.datetime.date.Date</code></a> equivalent to this <a href="#SysTime"><code>SysTime</code></a>.</p> </dd> <dt class="d_decl" id="SysTime.opCast.2">const nothrow scope @safe DateTime <strong id="opCast">opCast</strong>(T)()<br><small>  Constraints: if (is(Unqual!T == DateTime)); </small>
</dt> <dd>
<p>Returns a <a href="std_datetime_date#DateTime"><code>std.datetime.date.DateTime</code></a> equivalent to this <a href="#SysTime"><code>SysTime</code></a>.</p> </dd> <dt class="d_decl" id="SysTime.opCast.3">const nothrow scope @safe TimeOfDay <strong id="opCast">opCast</strong>(T)()<br><small>  Constraints: if (is(Unqual!T == TimeOfDay)); </small>
</dt> <dd>
<p>Returns a <a href="std_datetime_date#TimeOfDay"><code>std.datetime.date.TimeOfDay</code></a> equivalent to this <a href="#SysTime"><code>SysTime</code></a>.</p> </dd> <dt class="d_decl" id="SysTime.toISOString">const nothrow scope @safe string <strong id="toISOString">toISOString</strong>(); <br><br>const scope void <strong id="toISOString">toISOString</strong>(W)(ref W writer)<br><small>  Constraints: if (isOutputRange!(W, char)); </small>
</dt> <dd>
<p>Converts this <a href="#SysTime"><code>SysTime</code></a> to a string with the format YYYYMMDDTHHMMSS.FFFFFFFTZ (where F is fractional seconds and TZ is time zone). </p>
<p>Note that the number of digits in the fractional seconds varies with the number of fractional seconds. It's a maximum of 7 (which would be hnsecs), but only has as many as are necessary to hold the correct value (so no trailing zeroes), and if there are no fractional seconds, then there is no decimal point. <br><br> If this <a href="#SysTime"><code>SysTime</code></a>'s time zone is <a href="std_datetime_timezone#LocalTime"><code>std.datetime.timezone.LocalTime</code></a>, then TZ is empty. If its time zone is <code>UTC</code>, then it is "Z". Otherwise, it is the offset from UTC (e.g. +0100 or -0700). Note that the offset from UTC is <i>not</i> enough to uniquely identify the time zone. <br><br> Time zone offsets will be in the form +HHMM or -HHMM. <br><br> <span class="red">Warning: Previously, toISOString did the same as <a href="#toISOExtString"><code>toISOExtString</code></a> and generated +HH:MM or -HH:MM for the time zone when it was not <a href="std_datetime_timezone#LocalTime"><code>std.datetime.timezone.LocalTime</code></a> or <a href="std_datetime_timezone#UTC"><code>std.datetime.timezone.UTC</code></a>, which is not in conformance with ISO 8601 for the non-extended string format. This has now been fixed. However, for now, fromISOString will continue to accept the extended format for the time zone so that any code which has been writing out the result of toISOString to read in later will continue to work. The current behavior will be kept until July 2019 at which point, fromISOString will be fixed to be standards compliant.</span> </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>W <code>writer</code>
</td> <td>A <code>char</code> accepting <a href="std_range_primitives#isOutputRange">output range</a>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A <code>string</code> when not using an output range; <code>void</code> otherwise.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import core.time : msecs, hnsecs;
import std.datetime.date : DateTime;

assert(SysTime(DateTime(2010, 7, 4, 7, 6, 12)).toISOString() ==
       "20100704T070612");

assert(SysTime(DateTime(1998, 12, 25, 2, 15, 0), msecs(24)).toISOString() ==
       "19981225T021500.024");

assert(SysTime(DateTime(0, 1, 5, 23, 9, 59)).toISOString() ==
       "00000105T230959");

assert(SysTime(DateTime(-4, 1, 5, 0, 0, 2), hnsecs(520_920)).toISOString() ==
       "-00040105T000002.052092");
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="SysTime.toISOExtString">const nothrow scope @safe string <strong id="toISOExtString">toISOExtString</strong>(); <br><br>const scope void <strong id="toISOExtString">toISOExtString</strong>(W)(ref W writer)<br><small>  Constraints: if (isOutputRange!(W, char)); </small>
</dt> <dd>
<p>Converts this <a href="#SysTime"><code>SysTime</code></a> to a string with the format YYYY-MM-DDTHH:MM:SS.FFFFFFFTZ (where F is fractional seconds and TZ is the time zone). </p>
<p>Note that the number of digits in the fractional seconds varies with the number of fractional seconds. It's a maximum of 7 (which would be hnsecs), but only has as many as are necessary to hold the correct value (so no trailing zeroes), and if there are no fractional seconds, then there is no decimal point. <br><br> If this <a href="#SysTime"><code>SysTime</code></a>'s time zone is <a href="std_datetime_timezone#LocalTime"><code>std.datetime.timezone.LocalTime</code></a>, then TZ is empty. If its time zone is <code>UTC</code>, then it is "Z". Otherwise, it is the offset from UTC (e.g. +01:00 or -07:00). Note that the offset from UTC is <i>not</i> enough to uniquely identify the time zone. <br><br> Time zone offsets will be in the form +HH:MM or -HH:MM. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>W <code>writer</code>
</td> <td>A <code>char</code> accepting <a href="std_range_primitives#isOutputRange">output range</a>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A <code>string</code> when not using an output range; <code>void</code> otherwise.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import core.time : msecs, hnsecs;
import std.datetime.date : DateTime;

assert(SysTime(DateTime(2010, 7, 4, 7, 6, 12)).toISOExtString() ==
       "2010-07-04T07:06:12");

assert(SysTime(DateTime(1998, 12, 25, 2, 15, 0), msecs(24)).toISOExtString() ==
       "1998-12-25T02:15:00.024");

assert(SysTime(DateTime(0, 1, 5, 23, 9, 59)).toISOExtString() ==
       "0000-01-05T23:09:59");

assert(SysTime(DateTime(-4, 1, 5, 0, 0, 2), hnsecs(520_920)).toISOExtString() ==
       "-0004-01-05T00:00:02.052092");
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="SysTime.toSimpleString">const nothrow scope @safe string <strong id="toSimpleString">toSimpleString</strong>(); <br><br>const scope void <strong id="toSimpleString">toSimpleString</strong>(W)(ref W writer)<br><small>  Constraints: if (isOutputRange!(W, char)); </small>
</dt> <dd>
<p>Converts this <a href="#SysTime"><code>SysTime</code></a> to a string with the format YYYY-Mon-DD HH:MM:SS.FFFFFFFTZ (where F is fractional seconds and TZ is the time zone). </p>
<p>Note that the number of digits in the fractional seconds varies with the number of fractional seconds. It's a maximum of 7 (which would be hnsecs), but only has as many as are necessary to hold the correct value (so no trailing zeroes), and if there are no fractional seconds, then there is no decimal point. <br><br> If this <a href="#SysTime"><code>SysTime</code></a>'s time zone is <a href="std_datetime_timezone#LocalTime"><code>std.datetime.timezone.LocalTime</code></a>, then TZ is empty. If its time zone is <code>UTC</code>, then it is "Z". Otherwise, it is the offset from UTC (e.g. +01:00 or -07:00). Note that the offset from UTC is <i>not</i> enough to uniquely identify the time zone. <br><br> Time zone offsets will be in the form +HH:MM or -HH:MM. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>W <code>writer</code>
</td> <td>A <code>char</code> accepting <a href="std_range_primitives#isOutputRange">output range</a>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A <code>string</code> when not using an output range; <code>void</code> otherwise.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import core.time : msecs, hnsecs;
import std.datetime.date : DateTime;

assert(SysTime(DateTime(2010, 7, 4, 7, 6, 12)).toSimpleString() ==
       "2010-Jul-04 07:06:12");

assert(SysTime(DateTime(1998, 12, 25, 2, 15, 0), msecs(24)).toSimpleString() ==
       "1998-Dec-25 02:15:00.024");

assert(SysTime(DateTime(0, 1, 5, 23, 9, 59)).toSimpleString() ==
       "0000-Jan-05 23:09:59");

assert(SysTime(DateTime(-4, 1, 5, 0, 0, 2), hnsecs(520_920)).toSimpleString() ==
        "-0004-Jan-05 00:00:02.052092");
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="SysTime.toString">const nothrow scope @safe string <strong id="toString">toString</strong>(); <br><br>const scope void <strong id="toString">toString</strong>(W)(ref W writer)<br><small>  Constraints: if (isOutputRange!(W, char)); </small>
</dt> <dd>
<p>Converts this <a href="#SysTime"><code>SysTime</code></a> to a string. </p>
<p>This function exists to make it easy to convert a <a href="#SysTime"><code>SysTime</code></a> to a string for code that does not care what the exact format is - just that it presents the information in a clear manner. It also makes it easy to simply convert a <a href="#SysTime"><code>SysTime</code></a> to a string when using functions such as <code>to!string</code>, <code>format</code>, or <code>writeln</code> which use toString to convert user-defined types. So, it is unlikely that much code will call toString directly. <br><br> The format of the string is purposefully unspecified, and code that cares about the format of the string should use <code>toISOString</code>, <code>toISOExtString</code>, <code>toSimpleString</code>, or some other custom formatting function that explicitly generates the format that the code needs. The reason is that the code is then clear about what format it's using, making it less error-prone to maintain the code and interact with other software that consumes the generated strings. It's for this same reason that <a href="#SysTime"><code>SysTime</code></a> has no <code>fromString</code> function, whereas it does have <code>fromISOString</code>, <code>fromISOExtString</code>, and <code>fromSimpleString</code>. <br><br> The format returned by toString may or may not change in the future. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>W <code>writer</code>
</td> <td>A <code>char</code> accepting <a href="std_range_primitives#isOutputRange">output range</a>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A <code>string</code> when not using an output range; <code>void</code> otherwise.</dd>
</dl> </dd> <dt class="d_decl" id="SysTime.fromISOString">@safe SysTime <strong id="fromISOString">fromISOString</strong>(S)(scope const S isoString, immutable TimeZone tz = null)<br><small>  Constraints: if (isSomeString!S); </small>
</dt> <dd>
<p>Creates a <a href="#SysTime"><code>SysTime</code></a> from a string with the format YYYYMMDDTHHMMSS.FFFFFFFTZ (where F is fractional seconds is the time zone). Whitespace is stripped from the given string. </p>
<p>The exact format is exactly as described in <code>toISOString</code> except that trailing zeroes are permitted - including having fractional seconds with all zeroes. However, a decimal point with nothing following it is invalid. Also, while <a href="#toISOString"><code>toISOString</code></a> will never generate a string with more than 7 digits in the fractional seconds (because that's the limit with hecto-nanosecond precision), it will allow more than 7 digits in order to read strings from other sources that have higher precision (however, any digits beyond 7 will be truncated). <br><br> If there is no time zone in the string, then <a href="std_datetime_timezone#LocalTime"><code>std.datetime.timezone.LocalTime</code></a> is used. If the time zone is "Z", then <code>UTC</code> is used. Otherwise, a <a href="std_datetime_timezone#SimpleTimeZone"><code>std.datetime.timezone.SimpleTimeZone</code></a> which corresponds to the given offset from UTC is used. To get the returned <a href="#SysTime"><code>SysTime</code></a> to be a particular time zone, pass in that time zone and the <a href="#SysTime"><code>SysTime</code></a> to be returned will be converted to that time zone (though it will still be read in as whatever time zone is in its string). <br><br> The accepted formats for time zone offsets are +HH, -HH, +HHMM, and -HHMM. <br><br> <span class="red">Warning: Previously, <a href="#toISOString"><code>toISOString</code></a> did the same as <a href="#toISOExtString"><code>toISOExtString</code></a> and generated +HH:MM or -HH:MM for the time zone when it was not <a href="std_datetime_timezone#LocalTime"><code>std.datetime.timezone.LocalTime</code></a> or <a href="std_datetime_timezone#UTC"><code>std.datetime.timezone.UTC</code></a>, which is not in conformance with ISO 8601 for the non-extended string format. This has now been fixed. However, for now, fromISOString will continue to accept the extended format for the time zone so that any code which has been writing out the result of toISOString to read in later will continue to work. The current behavior will be kept until July 2019 at which point, fromISOString will be fixed to be standards compliant.</span> </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S <code>isoString</code>
</td> <td>A string formatted in the ISO format for dates and times.</td>
</tr> <tr>
<td>TimeZone <code>tz</code>
</td> <td>The time zone to convert the given time to (no conversion occurs if null).</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given string is not in the ISO format or if the resulting <a href="#SysTime"><code>SysTime</code></a> would not be valid.</dd>
</dl> </dd> <dt class="d_decl" id="SysTime.fromISOExtString">@safe SysTime <strong id="fromISOExtString">fromISOExtString</strong>(S)(scope const S isoExtString, immutable TimeZone tz = null)<br><small>  Constraints: if (isSomeString!S); </small>
</dt> <dd>
<p>Creates a <a href="#SysTime"><code>SysTime</code></a> from a string with the format YYYY-MM-DDTHH:MM:SS.FFFFFFFTZ (where F is fractional seconds is the time zone). Whitespace is stripped from the given string. </p>
<p>The exact format is exactly as described in <code>toISOExtString</code> except that trailing zeroes are permitted - including having fractional seconds with all zeroes. However, a decimal point with nothing following it is invalid. Also, while <a href="#toISOExtString"><code>toISOExtString</code></a> will never generate a string with more than 7 digits in the fractional seconds (because that's the limit with hecto-nanosecond precision), it will allow more than 7 digits in order to read strings from other sources that have higher precision (however, any digits beyond 7 will be truncated). <br><br> If there is no time zone in the string, then <a href="std_datetime_timezone#LocalTime"><code>std.datetime.timezone.LocalTime</code></a> is used. If the time zone is "Z", then <code>UTC</code> is used. Otherwise, a <a href="std_datetime_timezone#SimpleTimeZone"><code>std.datetime.timezone.SimpleTimeZone</code></a> which corresponds to the given offset from UTC is used. To get the returned <a href="#SysTime"><code>SysTime</code></a> to be a particular time zone, pass in that time zone and the <a href="#SysTime"><code>SysTime</code></a> to be returned will be converted to that time zone (though it will still be read in as whatever time zone is in its string). <br><br> The accepted formats for time zone offsets are +HH, -HH, +HH:MM, and -HH:MM. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S <code>isoExtString</code>
</td> <td>A string formatted in the ISO Extended format for dates and times.</td>
</tr> <tr>
<td>TimeZone <code>tz</code>
</td> <td>The time zone to convert the given time to (no conversion occurs if null).</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given string is not in the ISO format or if the resulting <a href="#SysTime"><code>SysTime</code></a> would not be valid.</dd>
</dl> </dd> <dt class="d_decl" id="SysTime.fromSimpleString">@safe SysTime <strong id="fromSimpleString">fromSimpleString</strong>(S)(scope const S simpleString, immutable TimeZone tz = null)<br><small>  Constraints: if (isSomeString!S); </small>
</dt> <dd>
<p>Creates a <a href="#SysTime"><code>SysTime</code></a> from a string with the format YYYY-MM-DD HH:MM:SS.FFFFFFFTZ (where F is fractional seconds is the time zone). Whitespace is stripped from the given string. </p>
<p>The exact format is exactly as described in <code>toSimpleString</code> except that trailing zeroes are permitted - including having fractional seconds with all zeroes. However, a decimal point with nothing following it is invalid. Also, while <a href="#toSimpleString"><code>toSimpleString</code></a> will never generate a string with more than 7 digits in the fractional seconds (because that's the limit with hecto-nanosecond precision), it will allow more than 7 digits in order to read strings from other sources that have higher precision (however, any digits beyond 7 will be truncated). <br><br> If there is no time zone in the string, then <a href="std_datetime_timezone#LocalTime"><code>std.datetime.timezone.LocalTime</code></a> is used. If the time zone is "Z", then <code>UTC</code> is used. Otherwise, a <a href="std_datetime_timezone#SimpleTimeZone"><code>std.datetime.timezone.SimpleTimeZone</code></a> which corresponds to the given offset from UTC is used. To get the returned <a href="#SysTime"><code>SysTime</code></a> to be a particular time zone, pass in that time zone and the <a href="#SysTime"><code>SysTime</code></a> to be returned will be converted to that time zone (though it will still be read in as whatever time zone is in its string). <br><br> The accepted formats for time zone offsets are +HH, -HH, +HH:MM, and -HH:MM. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S <code>simpleString</code>
</td> <td>A string formatted in the way that <code>toSimpleString</code> formats dates and times.</td>
</tr> <tr>
<td>TimeZone <code>tz</code>
</td> <td>The time zone to convert the given time to (no conversion occurs if null).</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given string is not in the ISO format or if the resulting <a href="#SysTime"><code>SysTime</code></a> would not be valid.</dd>
</dl> </dd> <dt class="d_decl" id="SysTime.min">static pure nothrow @property @safe SysTime <strong id="min">min</strong>(); </dt> <dd>
<p>Returns the <a href="#SysTime"><code>SysTime</code></a> farthest in the past which is representable by <a href="#SysTime"><code>SysTime</code></a>. </p>
<p>The <a href="#SysTime"><code>SysTime</code></a> which is returned is in UTC.</p> </dd> <dt class="d_decl" id="SysTime.max">static pure nothrow @property @safe SysTime <strong id="max">max</strong>(); </dt> <dd>
<p>Returns the <a href="#SysTime"><code>SysTime</code></a> farthest in the future which is representable by <a href="#SysTime"><code>SysTime</code></a>. </p>
<p>The <a href="#SysTime"><code>SysTime</code></a> which is returned is in UTC.</p> </dd> </dl> </dd> <dt class="d_decl" id="unixTimeToStdTime">pure nothrow @nogc @safe long <strong id="unixTimeToStdTime">unixTimeToStdTime</strong>(long unixTime); </dt> <dd>
<p>Converts from unix time (which uses midnight, January 1st, 1970 UTC as its epoch and seconds as its units) to "std time" (which uses midnight, January 1st, 1 A.D. UTC and hnsecs as its units). </p>
<p>The C standard does not specify the representation of time_t, so it is implementation defined. On POSIX systems, unix time is equivalent to time_t, but that's not necessarily true on other systems (e.g. it is not true for the Digital Mars C runtime). So, be careful when using unix time with C functions on non-POSIX systems. <br><br> "std time"'s epoch is based on the Proleptic Gregorian Calendar per ISO 8601 and is what <a href="#SysTime"><code>SysTime</code></a> uses internally. However, holding the time as an integer in hnsecs since that epoch technically isn't actually part of the standard, much as it's based on it, so the name "std time" isn't particularly good, but there isn't an official name for it. C# uses "ticks" for the same thing, but they aren't actually clock ticks, and the term "ticks" <i>is</i> used for actual clock ticks for <a href="core_time#MonoTime"><code>core.time.MonoTime</code></a>, so it didn't make sense to use the term ticks here. So, for better or worse, std.datetime uses the term "std time" for this. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>long <code>unixTime</code>
</td> <td>The unix time to convert.</td>
</tr> </table></dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>SysTime.fromUnixTime</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.datetime.date : DateTime;
import std.datetime.timezone : UTC;

// Midnight, January 1st, 1970
writeln(unixTimeToStdTime(0)); // 621_355_968_000_000_000L
assert(SysTime(unixTimeToStdTime(0)) ==
       SysTime(DateTime(1970, 1, 1), UTC()));

writeln(unixTimeToStdTime(int.max)); // 642_830_804_470_000_000L
assert(SysTime(unixTimeToStdTime(int.max)) ==
       SysTime(DateTime(2038, 1, 19, 3, 14, 07), UTC()));

writeln(unixTimeToStdTime(-127_127)); // 621_354_696_730_000_000L
assert(SysTime(unixTimeToStdTime(-127_127)) ==
       SysTime(DateTime(1969, 12, 30, 12, 41, 13), UTC()));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="stdTimeToUnixTime">pure nothrow @safe T <strong id="stdTimeToUnixTime">stdTimeToUnixTime</strong>(T = time_t)(long stdTime)<br><small>  Constraints: if (is(T == int) || is(T == long)); </small>
</dt> <dd>
<p>Converts std time (which uses midnight, January 1st, 1 A.D. UTC as its epoch and hnsecs as its units) to unix time (which uses midnight, January 1st, 1970 UTC as its epoch and seconds as its units). </p>
<p>The C standard does not specify the representation of time_t, so it is implementation defined. On POSIX systems, unix time is equivalent to time_t, but that's not necessarily true on other systems (e.g. it is not true for the Digital Mars C runtime). So, be careful when using unix time with C functions on non-POSIX systems. <br><br> "std time"'s epoch is based on the Proleptic Gregorian Calendar per ISO 8601 and is what <a href="#SysTime"><code>SysTime</code></a> uses internally. However, holding the time as an integer in hnescs since that epoch technically isn't actually part of the standard, much as it's based on it, so the name "std time" isn't particularly good, but there isn't an official name for it. C# uses "ticks" for the same thing, but they aren't actually clock ticks, and the term "ticks" <i>is</i> used for actual clock ticks for <a href="core_time#MonoTime"><code>core.time.MonoTime</code></a>, so it didn't make sense to use the term ticks here. So, for better or worse, std.datetime uses the term "std time" for this. <br><br> By default, the return type is time_t (which is normally an alias for int on 32-bit systems and long on 64-bit systems), but if a different size is required than either int or long can be passed as a template argument to get the desired size. <br><br> If the return type is int, and the result can't fit in an int, then the closest value that can be held in 32 bits will be used (so <code>int.max</code> if it goes over and <code>int.min</code> if it goes under). However, no attempt is made to deal with integer overflow if the return type is long. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>The return type (int or long). It defaults to time_t, which is normally 32 bits on a 32-bit system and 64 bits on a 64-bit system.</td>
</tr> <tr>
<td>long <code>stdTime</code>
</td> <td>The std time to convert.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A signed integer representing the unix time which is equivalent to the given std time. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>SysTime.toUnixTime</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">// Midnight, January 1st, 1970 UTC
writeln(stdTimeToUnixTime(621_355_968_000_000_000L)); // 0

// 2038-01-19 03:14:07 UTC
writeln(stdTimeToUnixTime(642_830_804_470_000_000L)); // int.max
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="SYSTEMTIMEToSysTime">@safe SysTime <strong id="SYSTEMTIMEToSysTime">SYSTEMTIMEToSysTime</strong>(scope const SYSTEMTIME* st, immutable TimeZone tz = LocalTime()); </dt> <dd>
<p><span class="blue">This function is Windows-Only.</span> </p>
<p>Converts a <code>SYSTEMTIME</code> struct to a <a href="#SysTime"><code>SysTime</code></a>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>SYSTEMTIME* <code>st</code>
</td> <td>The <code>SYSTEMTIME</code> struct to convert.</td>
</tr> <tr>
<td>TimeZone <code>tz</code>
</td> <td>The time zone that the time in the <code>SYSTEMTIME</code> struct is assumed to be (if the <code>SYSTEMTIME</code> was supplied by a Windows system call, the <code>SYSTEMTIME</code> will either be in local time or UTC, depending on the call).</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given <code>SYSTEMTIME</code> will not fit in a <a href="#SysTime"><code>SysTime</code></a>, which is highly unlikely to happen given that <code>SysTime.max</code> is in 29,228 A.D. and the maximum <code>SYSTEMTIME</code> is in 30,827 A.D.</dd>
</dl> </dd> <dt class="d_decl" id="SysTimeToSYSTEMTIME">@safe SYSTEMTIME <strong id="SysTimeToSYSTEMTIME">SysTimeToSYSTEMTIME</strong>(scope SysTime sysTime); </dt> <dd>
<p><span class="blue">This function is Windows-Only.</span> </p>
<p>Converts a <a href="#SysTime"><code>SysTime</code></a> to a <code>SYSTEMTIME</code> struct. <br><br> The <code>SYSTEMTIME</code> which is returned will be set using the given <a href="#SysTime"><code>SysTime</code></a>'s time zone, so to get the <code>SYSTEMTIME</code> in UTC, set the <a href="#SysTime"><code>SysTime</code></a>'s time zone to UTC. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>SysTime <code>sysTime</code>
</td> <td>The <a href="#SysTime"><code>SysTime</code></a> to convert.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given <a href="#SysTime"><code>SysTime</code></a> will not fit in a <code>SYSTEMTIME</code>. This will only happen if the <a href="#SysTime"><code>SysTime</code></a>'s date is prior to 1601 A.D.</dd>
</dl> </dd> <dt class="d_decl" id="FILETIMEToStdTime">@safe long <strong id="FILETIMEToStdTime">FILETIMEToStdTime</strong>(scope const FILETIME* ft); </dt> <dd>
<p><span class="blue">This function is Windows-Only.</span> </p>
<p>Converts a <code>FILETIME</code> struct to the number of hnsecs since midnight, January 1st, 1 A.D. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>FILETIME* <code>ft</code>
</td> <td>The <code>FILETIME</code> struct to convert.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given <code>FILETIME</code> cannot be represented as the return value.</dd>
</dl> </dd> <dt class="d_decl" id="FILETIMEToSysTime">@safe SysTime <strong id="FILETIMEToSysTime">FILETIMEToSysTime</strong>(scope const FILETIME* ft, immutable TimeZone tz = LocalTime()); </dt> <dd>
<p><span class="blue">This function is Windows-Only.</span> </p>
<p>Converts a <code>FILETIME</code> struct to a <a href="#SysTime"><code>SysTime</code></a>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>FILETIME* <code>ft</code>
</td> <td>The <code>FILETIME</code> struct to convert.</td>
</tr> <tr>
<td>TimeZone <code>tz</code>
</td> <td>The time zone that the <a href="#SysTime"><code>SysTime</code></a> will be in (<code>FILETIME</code>s are in UTC).</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given <code>FILETIME</code> will not fit in a <a href="#SysTime"><code>SysTime</code></a>.</dd>
</dl> </dd> <dt class="d_decl" id="stdTimeToFILETIME">@safe FILETIME <strong id="stdTimeToFILETIME">stdTimeToFILETIME</strong>(long stdTime); </dt> <dd>
<p><span class="blue">This function is Windows-Only.</span> </p>
<p>Converts a number of hnsecs since midnight, January 1st, 1 A.D. to a <code>FILETIME</code> struct. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>long <code>stdTime</code>
</td> <td>The number of hnsecs since midnight, January 1st, 1 A.D. UTC.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given value will not fit in a <code>FILETIME</code>.</dd>
</dl> </dd> <dt class="d_decl" id="SysTimeToFILETIME">@safe FILETIME <strong id="SysTimeToFILETIME">SysTimeToFILETIME</strong>(scope SysTime sysTime); </dt> <dd>
<p><span class="blue">This function is Windows-Only.</span> </p>
<p>Converts a <a href="#SysTime"><code>SysTime</code></a> to a <code>FILETIME</code> struct. <br><br> <code>FILETIME</code>s are always in UTC. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>SysTime <code>sysTime</code>
</td> <td>The <a href="#SysTime"><code>SysTime</code></a> to convert.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given <a href="#SysTime"><code>SysTime</code></a> will not fit in a <code>FILETIME</code>.</dd>
</dl> </dd> <dt class="d_decl" id="DosFileTime">alias <strong id="DosFileTime">DosFileTime</strong> = uint; </dt> <dd>
<p>Type representing the DOS file date/time format.</p> </dd> <dt class="d_decl" id="DosFileTimeToSysTime">@safe SysTime <strong id="DosFileTimeToSysTime">DosFileTimeToSysTime</strong>(DosFileTime dft, immutable TimeZone tz = LocalTime()); </dt> <dd>
<p>Converts from DOS file date/time to <a href="#SysTime"><code>SysTime</code></a>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>DosFileTime <code>dft</code>
</td> <td>The DOS file time to convert.</td>
</tr> <tr>
<td>TimeZone <code>tz</code>
</td> <td>The time zone which the DOS file time is assumed to be in.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the <code>DosFileTime</code> is invalid.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.datetime.date : DateTime;

// SysTime(DateTime(1980, 1, 1, 0, 0, 0))
writeln(DosFileTimeToSysTime(0b00000000001000010000000000000000));
// SysTime(DateTime(2107, 12, 31, 23, 59, 58))
writeln(DosFileTimeToSysTime(0b11111111100111111011111101111101));
writeln(DosFileTimeToSysTime(0x3E3F8456)); // SysTime(DateTime(2011, 1, 31, 16, 34, 44))
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="SysTimeToDosFileTime">@safe DosFileTime <strong id="SysTimeToDosFileTime">SysTimeToDosFileTime</strong>(scope SysTime sysTime); </dt> <dd>
<p>Converts from <a href="#SysTime"><code>SysTime</code></a> to DOS file date/time. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>SysTime <code>sysTime</code>
</td> <td>The <a href="#SysTime"><code>SysTime</code></a> to convert.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given <a href="#SysTime"><code>SysTime</code></a> cannot be converted to a <code>DosFileTime</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.datetime.date : DateTime;

// 0b00000000001000010000000000000000
writeln(SysTimeToDosFileTime(SysTime(DateTime(1980, 1, 1, 0, 0, 0))));
// 0b11111111100111111011111101111101
writeln(SysTimeToDosFileTime(SysTime(DateTime(2107, 12, 31, 23, 59, 58))));
writeln(SysTimeToDosFileTime(SysTime(DateTime(2011, 1, 31, 16, 34, 44)))); // 0x3E3F8456
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="parseRFC822DateTime">@safe SysTime <strong id="parseRFC822DateTime">parseRFC822DateTime</strong>()(scope const char[] value); <br><br>SysTime <strong id="parseRFC822DateTime">parseRFC822DateTime</strong>(R)(scope R value)<br><small>  Constraints: if (isRandomAccessRange!R &amp;&amp; hasSlicing!R &amp;&amp; hasLength!R &amp;&amp; (is(Unqual!(ElementType!R) == char) || is(Unqual!(ElementType!R) == ubyte))); </small>
</dt> <dd>
<p>The given array of <code>char</code> or random-access range of <code>char</code> or <code>ubyte</code> is expected to be in the format specified in <a href="http://tools.ietf.org/html/rfc5322">RFC 5322</a> section 3.3 with the grammar rule <i>date-time</i>. It is the date-time format commonly used in internet messages such as e-mail and HTTP. The corresponding <a href="#SysTime"><code>SysTime</code></a> will be returned. </p>
<p>RFC 822 was the original spec (hence the function's name), whereas RFC 5322 is the current spec. <br><br> The day of the week is ignored beyond verifying that it's a valid day of the week, as the day of the week can be inferred from the date. It is not checked whether the given day of the week matches the actual day of the week of the given date (though it is technically invalid per the spec if the day of the week doesn't match the actual day of the week of the given date). <br><br> If the time zone is <code>"-0000"</code> (or considered to be equivalent to <code>"-0000"</code> by section 4.3 of the spec), a <a href="std_datetime_timezone#SimpleTimeZone"><code>std.datetime.timezone.SimpleTimeZone</code></a> with a utc offset of <code>0</code> is used rather than <a href="std_datetime_timezone#UTC"><code>std.datetime.timezone.UTC</code></a>, whereas <code>"+0000"</code> uses <a href="std_datetime_timezone#UTC"><code>std.datetime.timezone.UTC</code></a>. <br><br> Note that because <a href="#SysTime"><code>SysTime</code></a> does not currently support having a second value of 60 (as is sometimes done for leap seconds), if the date-time value does have a value of 60 for the seconds, it is treated as 59. <br><br> The one area in which this function violates RFC 5322 is that it accepts <code>"\n"</code> in folding whitespace in the place of <code>"\r\n"</code>, because the HTTP spec requires it. </p> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given string doesn't follow the grammar for a date-time field or if the resulting <a href="#SysTime"><code>SysTime</code></a> is invalid.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import core.time : hours;
import std.datetime.date : DateTime, DateTimeException;
import std.datetime.timezone : SimpleTimeZone, UTC;
import std.exception : assertThrown;

auto tz = new immutable SimpleTimeZone(hours(-8));
assert(parseRFC822DateTime("Sat, 6 Jan 1990 12:14:19 -0800") ==
       SysTime(DateTime(1990, 1, 6, 12, 14, 19), tz));

assert(parseRFC822DateTime("9 Jul 2002 13:11 +0000") ==
       SysTime(DateTime(2002, 7, 9, 13, 11, 0), UTC()));

auto badStr = "29 Feb 2001 12:17:16 +0200";
assertThrown!DateTimeException(parseRFC822DateTime(badStr));
</pre> </dd>
</dl> </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
     19992019 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_datetime_systime.html" class="_attribution-link">https://dlang.org/phobos/std_datetime_systime.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
