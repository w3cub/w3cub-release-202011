
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>8. Attributes - D - W3cubDocs</title>
  
  <meta name="description" content=" Attributes are a way to modify one or more declarations. The general forms are&#58; ">
  <meta name="keywords" content="attributes, d">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/d/attribute.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/d.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/d/" class="_nav-link" title="" style="margin-left:0;">D</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _d">
				
				
<h1>Attributes</h1>       <b>Contents</b>  <ol> <li><a href="#linkage">Linkage Attribute</a></li> <li><a href="#align"><code>align</code> Attribute</a></li> <li><a href="#deprecated"><code>deprecated</code> Attribute</a></li> <li><a href="#visibility_attributes">Visibility Attribute</a></li> <li><a href="#const"><code>const</code> Attribute</a></li> <li><a href="#immutable"><code>immutable</code> Attribute</a></li> <li><a href="#inout"><code>inout</code> Attribute</a></li> <li><a href="#shared"><code>shared</code> Attribute</a></li> <li><a href="#gshared"><code>__gshared</code> Attribute</a></li> <li><a href="#disable"><code>@disable</code> Attribute</a></li> <li><a href="#safe"><code>@safe</code>, <code>@trusted</code>, and <code>@system</code> Attribute</a></li> <li><a href="#nogc"><code>@nogc</code> Attribute</a></li> <li><a href="#property"><code>@property</code> Attribute</a></li> <li><a href="#nothrow"><code>nothrow</code> Attribute</a></li> <li><a href="#pure"><code>pure</code> Attribute</a></li> <li><a href="#ref"><code>ref</code> Attribute</a></li> <li><a href="#return"><code>return</code> Attribute</a></li> <li><a href="#override"><code>override</code> Attribute</a></li> <li><a href="#static"><code>static</code> Attribute</a></li> <li><a href="#auto"><code>auto</code> Attribute</a></li> <li><a href="#scope"><code>scope</code> Attribute</a></li> <li><a href="#abstract"><code>abstract</code> Attribute</a></li> <li><a href="#uda">User-Defined Attributes</a></li> </ol>   <pre>AttributeSpecifier:
    Attribute :
    Attribute DeclarationBlock

Attribute:
    LinkageAttribute
    AlignAttribute
    DeprecatedAttribute
    VisibilityAttribute
    Pragma
    static
    extern
    abstract
    final
    override
    synchronized
    auto
    scope
    const
    immutable
    inout
    shared
    __gshared
    AtAttribute
    nothrow
    pure
    ref
    return

AtAttribute:
    @ disable
    @ nogc
    Property
    @ safe
    @ system
    @ trusted
    UserDefinedAttribute

Property:
    @ property

DeclarationBlock:
    DeclDef
    { DeclDefsopt }
</pre>  <p>Attributes are a way to modify one or more declarations. The general forms are: </p>  <pre data-language="d">attribute declaration; // affects the declaration

attribute:     // affects all declarations until the end of
               // the current scope
  declaration;
  declaration;
  ...

attribute {    // affects all declarations in the block
  declaration;
  declaration;
  ...
}
</pre>  <h2 id="linkage">Linkage Attribute</h2>  <pre>LinkageAttribute:
    extern ( LinkageType )
    extern ( C++, IdentifierList )

LinkageType:
    C
    C++
    D
    Windows
    System
    Objective-C
</pre>  <p>D provides an easy way to call C functions and operating system API functions, as compatibility with both is essential. The <i>LinkageType</i> is case sensitive, and is meant to be extensible by the implementation (<code>they are not keywords</code>). <code>C</code> and <code>D</code> must be supplied, the others are what makes sense for the implementation. <code>C++</code> offers limited compatibility with C++. <code>Objective-C</code> offers limited compatibility with Objective-C, see the <a href="objc_interface">Interfacing to Objective-C</a> documentation for more information. <code>System</code> is the same as <code>Windows</code> on Windows platforms, and <code>C</code> on other platforms. <code>Implementation Note:</code> for Win32 platforms, <code>Windows</code> should exist. </p>  <p>C function calling conventions are specified by: </p>  <pre data-language="d">extern (C):
    int foo(); // call foo() with C conventions
</pre> Note that <code>extern(C)</code> can be provided for all types of declarations, including <code>struct</code> or <code>class</code>, even though there is no corresponding match on the <code>C</code> side. In that case, the attribute is ignored. This behavior applies for nested functions and nested variables as well. However, for <code>static</code> member methods and <code>static</code> nested functions, adding <code>extern(C)</code> will change the calling convention, but not the mangling.  <p>D conventions are:</p>  <pre data-language="d">extern (D):
</pre>  <p>Windows API conventions are:</p>  <pre data-language="d">extern (Windows):
    void *VirtualAlloc(
        void *lpAddress,
        uint dwSize,
        uint flAllocationType,
        uint flProtect
    );
</pre>  <p>The Windows convention is distinct from the C convention only on Win32 platforms, where it is equivalent to the <a href="https://en.wikipedia.org/wiki/X86_calling_conventions">stdcall</a> convention.</p>  <p>Note that a lone <code>extern</code> declaration is used as a <a href="declaration#extern">storage class</a>.</p>  <h3 id="namespace">C++ Namespaces</h3>  <p>The linkage form <code>extern (C++, </code><i>IdentifierList</i><code>)</code> creates C++ declarations that reside in C++ namespaces. The <i>IdentifierList</i> specifies the namespaces. </p>  <pre data-language="d">extern (C++, N) { void foo(); }
</pre>  <p>refers to the C++ declaration:</p>  <pre>namespace N { void foo(); }</pre>  <p>and can be referred to with or without qualification:</p>  <pre data-language="d">foo();
N.foo();
</pre>  <p>Namespaces create a new named scope that is imported into its enclosing scope.</p>  <pre data-language="d">extern (C++, N) { void foo(); void bar(); }
extern (C++, M) { void foo(); }

bar();   // ok
foo();   // error - N.foo() or M.foo() ?
M.foo(); // ok
</pre>  <p>Multiple identifiers in the <i>IdentifierList</i> create nested namespaces:</p>  <pre data-language="d">extern (C++, N.M) { extern (C++) { extern (C++, R) { void foo(); } } }
N.M.R.foo();
</pre>  <p>refers to the C++ declaration:</p>  <pre>namespace N { namespace M { namespace R { void foo(); } } }</pre>   <h2 id="align">
<code>align</code> Attribute</h2>  <pre>AlignAttribute:
    align
    align ( AssignExpression )
</pre>   <p>Specifies the alignment of:</p>  <ol> <li>variables</li> <li>struct fields</li> <li>union fields</li> <li>class fields</li> <li>struct, union, and class types</li> </ol>  <p><code>align</code> by itself sets it to the default, which matches the default member alignment of the companion C compiler.</p>  <pre data-language="d">struct S
{
  align:
    byte a;   // placed at offset 0
    int b;    // placed at offset 4
    long c;   // placed at offset 8
}
auto sz = S.sizeof;  // 16
</pre>  <p><i>AssignExpression</i> specifies the alignment which matches the behavior of the companion C compiler when non-default alignments are used. It must be a positive power of 2. </p>  <p>A value of 1 means that no alignment is done; fields are packed together. </p>  <pre data-language="d">struct S
{
  align (1):
    byte a;   // placed at offset 0
    int b;    // placed at offset 1
    long c;   // placed at offset 5
}
auto sz = S.sizeof;  // 16
</pre>  <p>The alignment for the fields of an aggregate does not affect the alignment of the aggregate itself - that is affected by the alignment setting outside of the aggregate.</p>  <pre data-language="d">align (2) struct S
{
  align (1):
    byte a;   // placed at offset 0
    int b;    // placed at offset 1
    long c;   // placed at offset 5
}
auto sz = S.sizeof;  // 14
</pre>  <p>Setting the alignment of a field aligns it to that power of 2, regardless of the size of the field.</p>  <pre data-language="d">struct S
{
  align (4):
    byte a;   // placed at offset 0
    byte b;   // placed at offset 4
    short c;  // placed at offset 8
}
auto sz = S.sizeof;  // 12
</pre>   <p>Do not align references or pointers that were allocated using <a href="expression#NewExpression"><i>NewExpression</i></a> on boundaries that are not a multiple of <code>size_t</code>. The garbage collector assumes that pointers and references to GC allocated objects will be on <code>size_t</code> byte boundaries. </p>  <b>Undefined Behavior</b>: If any pointers and references to GC allocated objects are not aligned on <code>size_t</code> byte boundaries.  <p>The <i>AlignAttribute</i> is reset to the default when entering a function scope or a non-anonymous struct, union, class, and restored when exiting that scope. It is not inherited from a base class. </p>    <h2 id="deprecated">
<code>deprecated</code> Attribute</h2>  <pre>DeprecatedAttribute:
    deprecated
    deprecated ( AssignExpression )
</pre>  <p>It is often necessary to deprecate a feature in a library, yet retain it for backwards compatibility. Such declarations can be marked as <code>deprecated</code>, which means that the compiler can be instructed to produce an error if any code refers to deprecated declarations: </p>  <pre data-language="d">deprecated
{
    void oldFoo();
}

oldFoo();   // Deprecated: function test.oldFoo is deprecated
</pre>  <p>Optionally a string literal or manifest constant can be used to provide additional information in the deprecation message. </p>  <pre data-language="d">deprecated("Don't use bar") void oldBar();
oldBar();   // Deprecated: function test.oldBar is deprecated - Don't use bar
</pre>  <p>Calling CTFE-able functions or using manifest constants is also possible. </p>  <pre data-language="d">import std.format;
enum Message = format("%s and all its members are obsolete", Foobar.stringof);
deprecated(Message) class Foobar {}
auto f = new Foobar();   // Deprecated: class test.Foobar is deprecated - Foobar
     // and all its members are obsolete
deprecated(format("%s is also obsolete", "This class")) class BarFoo {}
auto bf = new BarFoo();  // Deprecated: class test.BarFoo is deprecated - This
     // class is also obsolete
</pre>  <p><code>Implementation Note:</code> The compiler should have a switch specifying if <code>deprecated</code> should be ignored, cause a warning, or cause an error during compilation. </p>   <h2 id="visibility_attributes">Visibility Attribute</h2>  <pre>VisibilityAttribute:
    private
    package
    package ( IdentifierList )
    protected
    public
    export
</pre>  <p>Visibility is an attribute that is one of <code>private</code>, <code>package</code>, <code>protected</code>, <code>public</code>, or <code>export</code>. They may be referred to as protection attributes in documents predating <a href="http://wiki.dlang.org/DIP22">DIP22</a>.</p>  <p>Symbols with <code>private</code> visibility can only be accessed from within the same module. Private member functions are implicitly final and cannot be overridden. </p>  <p><code>package</code> extends private so that package members can be accessed from code in other modules that are in the same package. If no identifier is provided, this applies to the innermost package only, or defaults to <code>private</code> if a module is not nested in a package. </p>  <p><code>package</code> may have an optional parameter in the form of a dot-separated identifier list which is resolved as the qualified package name. The package must be either the module's parent package or one of its anscestors. If this optional parameter is present, the symbol will be visible in the specified package and all of its descendants. </p>  <p><code>protected</code> only applies inside classes (and templates as they can be mixed in) and means that a symbol can only be seen by members of the same module, or by a derived class. If accessing a protected instance member through a derived class member function, that member can only be accessed for the object instance which can be implicitly cast to the same type as ‘this’. <code>protected</code> module members are illegal. </p>  <p><code>public</code> means that any code within the executable can see the member. It is the default visibility attribute. </p>  <p><code>export</code> means that any code outside the executable can access the member. <code>export</code> is analogous to exporting definitions from a DLL. </p>  <p>Visibility participates in <a href="module#name_lookup">symbol name lookup</a>. </p>   <h2 id="const">
<code>const</code> Attribute</h2>  <p>The <code>const</code> attribute changes the type of the declared symbol from <code>T</code> to <code>const(T)</code>, where <code>T</code> is the type specified (or inferred) for the introduced symbol in the absence of <code>const</code>. </p>  <pre data-language="d">const int foo = 7;
static assert(is(typeof(foo) == const(int)));

const
{
    double bar = foo + 6;
}
static assert(is(typeof(bar) == const(double)));

class C
{
    const void foo();
    const
    {
        void bar();
    }
    void baz() const;
}
pragma(msg, typeof(C.foo)); // const void()
pragma(msg, typeof(C.bar)); // const void()
pragma(msg, typeof(C.baz)); // const void()
static assert(is(typeof(C.foo) == typeof(C.bar)) &amp;&amp;
              is(typeof(C.bar) == typeof(C.baz)));
</pre>  <h2 id="immutable">
<code>immutable</code> Attribute</h2>  <p>The <code>immutable</code> attribute modifies the type from <code>T</code> to <code>immutable(T)</code>, the same way as <code>const</code> does. </p>  <h2 id="inout">
<code>inout</code> Attribute</h2>  <p>The <code>inout</code> attribute modifies the type from <code>T</code> to <code>inout(T)</code>, the same way as <code>const</code> does. </p>  <h2 id="shared">
<code>shared</code> Attribute</h2>  <p>The <code>shared</code> attribute modifies the type from <code>T</code> to <code>shared(T)</code>, the same way as <code>const</code> does. </p>  <h2 id="gshared">
<code>__gshared</code> Attribute</h2>  <p>By default, non-immutable global declarations reside in thread local storage. When a global variable is marked with the <code>__gshared</code> attribute, its value is shared across all threads.</p>  <pre data-language="d">int foo;            // Each thread has its own exclusive copy of foo.
__gshared int bar;  // bar is shared by all threads.
</pre>  <p><code>__gshared</code> may also be applied to member variables and local variables. In these cases, <code>__gshared</code> is equivalent to <code>static</code>, except that the variable is shared by all threads rather than being thread local.</p>  <pre data-language="d">class Foo
{
    __gshared int bar;
}

int foo()
{
    __gshared int bar = 0;
    return bar++; // Not thread safe.
}
</pre>  <p>Unlike the <code>shared</code> attribute, <code>__gshared</code> provides no safe-guards against data races or other multi-threaded synchronization issues. It is the responsibility of the programmer to ensure that access to variables marked <code>__gshared</code> is synchronized correctly.</p>  <p><code>__gshared</code> is disallowed in safe mode.</p>  <h2 id="disable">
<code>@disable</code> Attribute</h2>  <p>A reference to a declaration marked with the <code>@disable</code> attribute causes a compile time error. This can be used to explicitly disallow certain operations or overloads at compile time rather than relying on generating a runtime error.</p>  <pre data-language="d">@disable void foo() { }
</pre> <pre data-language="d">void main() { foo(); /* error, foo is disabled */ }
</pre>  <p><a href="struct#Struct-Constructor">Disabling struct no-arg constructor</a> disallows default construction of the struct. </p>  <p><a href="struct#StructPostblit">Disabling struct postblit</a> makes the struct not copyable. </p>  <h2 id="safe">
<code>@safe</code>, <code>@trusted</code>, and <code>@system</code> Attribute</h2>  <p>See <a href="https://dlang.org/function.html#function-safety">Function Safety</a>.</p>  <h2 id="nogc">
<code>@nogc</code> Attribute</h2>  <p>See <a href="https://dlang.org/function.html#nogc-functions">No-GC Functions</a>.</p>  <h2 id="property">
<code>@property</code> Attribute</h2>  <p>See <a href="function#property-functions">Property Functions</a>.</p>  <h2 id="nothrow">
<code>nothrow</code> Attribute</h2>  <p>See <a href="function#nothrow-functions">Nothrow Functions</a>.</p>  <h2 id="pure">
<code>pure</code> Attribute</h2>  <p>See <a href="function#pure-functions">Pure Functions</a>.</p>  <h2 id="ref">
<code>ref</code> Attribute</h2>  <p>See <a href="function#ref-functions">Ref Functions</a>.</p>  <h2 id="return">
<code>return</code> Attribute</h2>  <p>See <a href="function#return-ref-parameters">Return Ref Parameters</a>.</p>  <h2 id="override">
<code>override</code> Attribute</h2>  <p>The <code>override</code> attribute applies to virtual functions. It means that the function must override a function with the same name and parameters in a base class. The override attribute is useful for catching errors when a base class's member function gets its parameters changed, and all derived classes need to have their overriding functions updated. </p>  <pre data-language="d">class Foo
{
    int bar();
    int abc(int x);
}

class Foo2 : Foo
{
    override
    {
        int bar(char c); // error, no bar(char) in Foo
        int abc(int x);  // ok
    }
}
</pre>  <h2 id="static">
<code>static</code> Attribute</h2>  <p>The <code>static</code> attribute applies to functions and data. It means that the declaration does not apply to a particular instance of an object, but to the type of the object. In other words, it means there is no <code>this</code> reference. <code>static</code> is ignored when applied to other declarations. </p>  <pre data-language="d">class Foo
{
    static int bar() { return 6; }
    int foobar() { return 7; }
}

...

Foo f = new Foo;
Foo.bar();      // produces 6
Foo.foobar();   // error, no instance of Foo
f.bar();        // produces 6;
f.foobar();     // produces 7;
</pre>  <p> Static functions are never virtual. </p> <p> Static data has one instance per thread, not one per object. </p> <p> Static does not have the additional C meaning of being local to a file. Use the <code>private</code> attribute in D to achieve that. For example: </p>  <pre data-language="d">module foo;
int x = 3;         // x is global
private int y = 4; // y is local to module foo
</pre>   <h2 id="auto">
<code>auto</code> Attribute</h2>  <p>The <code>auto</code> attribute is used when there are no other attributes and type inference is desired. </p>  <pre data-language="d">auto i = 6.8;   // declare i as a double
</pre>  <p>For functions, the <code>auto</code> attribute means return type inference. See <a href="https://dlang.org/function.html#auto-functions">Auto Functions</a>. </p>  <h2 id="scope">
<code>scope</code> Attribute</h2>  <p> The <code>scope</code> attribute is used for local variables and for class declarations. For class declarations, the <code>scope</code> attribute creates a <i>scope</i> class. For local declarations, <code>scope</code> implements the RAII (Resource Acquisition Is Initialization) protocol. This means that the destructor for an object is automatically called when the reference to it goes out of scope. The destructor is called even if the scope is exited via a thrown exception, thus <code>scope</code> is used to guarantee cleanup. </p> <p> If there is more than one <code>scope</code> variable going out of scope at the same point, then the destructors are called in the reverse order that the variables were constructed. </p> <p> <code>scope</code> cannot be applied to globals, statics, data members, ref or out parameters. Arrays of <code>scope</code>s are not allowed, and <code>scope</code> function return values are not allowed. Assignment to a <code>scope</code>, other than initialization, is not allowed. <code>Rationale:</code> These restrictions may get relaxed in the future if a compelling reason to appears. </p>  <h2 id="abstract">
<code>abstract</code> Attribute</h2>  <p> An abstract member function must be overridden by a derived class. Only virtual member functions may be declared abstract; non-virtual member functions and free-standing functions cannot be declared abstract. </p>  <p> Classes become abstract if any of its virtual member functions are declared abstract or if they are defined within an abstract attribute. Note that an abstract class may also contain non-virtual member functions. </p>  <p> Classes defined within an abstract attribute or with abstract member functions cannot be instantiated directly. They can only be instantiated as a base class of another, non-abstract, class. </p>  <p> Member functions declared as abstract can still have function bodies. This is so that even though they must be overridden, they can still provide ‘base class functionality’, e.g. through <code>super.foo()</code> in a derived class. Note that the class is still abstract and cannot be instantiated directly. </p>  <h2 id="uda">User-Defined Attributes</h2>  <pre>UserDefinedAttribute:
    @ ( ArgumentList )
    @ Identifier
    @ Identifier ( ArgumentListopt )
    @ TemplateInstance
    @ TemplateInstance ( ArgumentListopt )
</pre>  <p> User-Defined Attributes (UDA) are compile-time expressions that can be attached to a declaration. These attributes can then be queried, extracted, and manipulated at compile time. There is no runtime component to them. </p>  A user-defined attribute looks like:  <pre data-language="d">@(3) int a;
</pre> <pre data-language="d">@("string", 7) int b;

enum Foo;
@Foo int c;

struct Bar
{
    int x;
}

@Bar(3) int d;
</pre>  <p> If there are multiple UDAs in scope for a declaration, they are concatenated: </p>  <pre data-language="d">@(1)
{
    @(2) int a;         // has UDAs (1, 2)
    @("string") int b;  // has UDAs (1, "string")
}
</pre>  <p> UDAs can be extracted into an expression tuple using <code>__traits</code>: </p>  <pre data-language="d">@('c') string s;
pragma(msg, __traits(getAttributes, s)); // prints tuple('c')
</pre>  <p> If there are no user-defined attributes for the symbol, an empty tuple is returned. The expression tuple can be turned into a manipulatable tuple: </p>  <pre data-language="d">enum EEE = 7;
@("hello") struct SSS { }
@(3) { @(4) @EEE @SSS int foo; }

alias TP = __traits(getAttributes, foo);

pragma(msg, TP); // prints tuple(3, 4, 7, (SSS))
pragma(msg, TP[2]); // prints 7
</pre>  <p> Of course the tuple types can be used to declare things: </p>  <pre data-language="d">TP[3] a; // a is declared as an SSS
</pre>  <p> The attribute of the type name is not the same as the attribute of the variable: </p>  <pre data-language="d">pragma(msg, __traits(getAttributes, typeof(a))); // prints tuple("hello")
</pre>  <p> Of course, the real value of UDAs is to be able to create user-defined types with specific values. Having attribute values of basic types does not scale. The attribute tuples can be manipulated like any other tuple, and can be passed as the argument list to a template. </p>  <p> Whether the attributes are values or types is up to the user, and whether later attributes accumulate or override earlier ones is also up to how the user interprets them. </p> <p> UDAs cannot be attached to template parameters. </p>    <div class="_attribution">
  <p class="_attribution-p">
    © 1999–2019 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/spec/attribute.html" class="_attribution-link">https://dlang.org/spec/attribute.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
