
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>std.random - D - W3cubDocs</title>
  
  <meta name="description" content=" Facilities for random number generation. ">
  <meta name="keywords" content="std, random, d">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/d/std_random.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/d.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/d/" class="_nav-link" title="" style="margin-left:0;">D</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _d">
				
				
<h1>std.random</h1>  <p>Facilities for random number generation. </p>
<p> </p>
<table>

<tr>
<th scope="col">Category</th> <th scope="col">Functions</th>
</tr> <tr>
<td>Uniform sampling</td> <td> <a href="#uniform"><code>uniform</code></a> <a href="#uniform01"><code>uniform01</code></a> <a href="#uniformDistribution"><code>uniformDistribution</code></a> </td>
</tr> <tr>
<td>Element sampling</td> <td> <a href="#choice"><code>choice</code></a> <a href="#dice"><code>dice</code></a> </td>
</tr> <tr>
<td>Range sampling</td> <td> <a href="#randomCover"><code>randomCover</code></a> <a href="#randomSample"><code>randomSample</code></a> </td>
</tr> <tr>
<td>Default Random Engines</td> <td> <a href="#rndGen"><code>rndGen</code></a> <a href="#Random"><code>Random</code></a> <a href="#unpredictableSeed"><code>unpredictableSeed</code></a> </td>
</tr> <tr>
<td>Linear Congruential Engines</td> <td> <a href="#MinstdRand"><code>MinstdRand</code></a> <a href="#MinstdRand0"><code>MinstdRand0</code></a> <a href="#LinearCongruentialEngine"><code>LinearCongruentialEngine</code></a> </td>
</tr> <tr>
<td>Mersenne Twister Engines</td> <td> <a href="#Mt19937"><code>Mt19937</code></a> <a href="#Mt19937_64"><code>Mt19937_64</code></a> <a href="#MersenneTwisterEngine"><code>MersenneTwisterEngine</code></a> </td>
</tr> <tr>
<td>Xorshift Engines</td> <td> <a href="#Xorshift"><code>Xorshift</code></a> <a href="#XorshiftEngine"><code>XorshiftEngine</code></a> <a href="#Xorshift32"><code>Xorshift32</code></a> <a href="#Xorshift64"><code>Xorshift64</code></a> <a href="#Xorshift96"><code>Xorshift96</code></a> <a href="#Xorshift128"><code>Xorshift128</code></a> <a href="#Xorshift160"><code>Xorshift160</code></a> <a href="#Xorshift192"><code>Xorshift192</code></a> </td>
</tr> <tr>
<td>Shuffle</td> <td> <a href="#partialShuffle"><code>partialShuffle</code></a> <a href="#randomShuffle"><code>randomShuffle</code></a> </td>
</tr> <tr>
<td>Traits</td> <td> <a href="#isSeedable"><code>isSeedable</code></a> <a href="#isUniformRNG"><code>isUniformRNG</code></a> </td>
</tr> </table> <br><br> <span class="red">Disclaimer:</span> The random number generators and API provided in this module are not designed to be cryptographically secure, and are therefore unsuitable for cryptographic or security-related purposes such as generating authentication tokens or network sequence numbers. For such needs, please use a reputable cryptographic library instead. <br><br> The new-style generator objects hold their own state so they are immune of threading issues. The generators feature a number of well-known and well-documented methods of generating random numbers. An overall fast and reliable means to generate random numbers is the <span class="d_param">Mt19937</span> generator, which derives its name from "<a href="https://en.wikipedia.org/wiki/Mersenne_Twister">Mersenne Twister</a> with a period of 2 to the power of 19937". In memory-constrained situations, <a href="https://en.wikipedia.org/wiki/Linear_congruential_generator">linear congruential generators</a> such as <code>MinstdRand0</code> and <code>MinstdRand</code> might be useful. The standard library provides an alias <span class="d_param">Random</span> for whichever generator it considers the most fit for the target environment. <br><br> In addition to random number generators, this module features distributions, which skew a generator's output statistical distribution in various ways. So far the uniform distribution for integers and real numbers have been implemented.  <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/random.d">std/random.d</a></span> </dd>
</dl> <dl>
<dt>License:</dt>
<dd>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>
<a href="http://erdani.org">Andrei Alexandrescu</a> Masahiro Nakagawa (Xorshift random generator) <a href="http://braingam.es">Joseph Rushton Wakeling</a> (Algorithm D for random sampling) Ilya Yaroshenko (Mersenne Twister implementation, adapted from <a href="https://github.com/libmir/mir-random">mir-random</a>) </dd>
</dl> <dl>
<dt>Credits</dt>
<dd> The entire random number library architecture is derived from the excellent <a href="http://open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2461.pdf">C++0X</a> random number facility proposed by Jens Maurer and contributed to by researchers at the Fermi laboratory (excluding Xorshift).</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : among, equal;
import std.range : iota;

// seed a random generator with a constant
auto rnd = Random(42);

// Generate a uniformly-distributed integer in the range [0, 14]
// If no random generator is passed, the global `rndGen` would be used
auto i = uniform(0, 15, rnd);
assert(i &gt;= 0 &amp;&amp; i &lt; 15);

// Generate a uniformly-distributed real in the range [0, 100)
auto r = uniform(0.0L, 100.0L, rnd);
assert(r &gt;= 0 &amp;&amp; r &lt; 100);

// Sample from a custom type
enum Fruit { apple, mango, pear }
auto f = rnd.uniform!Fruit;
with(Fruit)
assert(f.among(apple, mango, pear));

// Generate a 32-bit random number
auto u = uniform!uint(rnd);
static assert(is(typeof(u) == uint));

// Generate a random number in the range in the range [0, 1)
auto u2 = uniform01(rnd);
assert(u2 &gt;= 0 &amp;&amp; u2 &lt; 1);

// Select an element randomly
auto el = 10.iota.choice(rnd);
assert(0 &lt;= el &amp;&amp; el &lt; 10);

// Throw a dice with custom proportions
// 0: 20%, 1: 10%, 2: 60%
auto val = rnd.dice(0.2, 0.1, 0.6);
assert(0 &lt;= val &amp;&amp; val &lt;= 2);

auto rnd2 = MinstdRand0(42);

// Select a random subsample from a range
assert(10.iota.randomSample(3, rnd2).equal([7, 8, 9]));

// Cover all elements in an array in random order
version (X86_64) // Issue 15147
assert(10.iota.randomCover(rnd2).equal([7, 4, 2, 0, 1, 6, 8, 3, 9, 5]));

// Shuffle an array
version (X86_64) // Issue 15147
assert([0, 1, 2, 4, 5].randomShuffle(rnd2).equal([2, 0, 4, 5, 1]));
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="isUniformRNG">enum bool <strong id="isUniformRNG">isUniformRNG</strong>(Rng, ElementType); <br><br>enum bool <strong id="isUniformRNG">isUniformRNG</strong>(Rng); </dt> <dd>
<p>Test if Rng is a random-number generator. The overload taking a ElementType also makes sure that the Rng generates values of that type. </p>
<p>A random-number generator has at least the following features: </p>
<ul> <li>it's an InputRange</li> <li>it has a 'bool isUniformRandom' field readable in CTFE</li> </ul> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">struct NoRng
{
    @property uint front() {return 0;}
    @property bool empty() {return false;}
    void popFront() {}
}
static assert(!isUniformRNG!(NoRng));

struct validRng
{
    @property uint front() {return 0;}
    @property bool empty() {return false;}
    void popFront() {}

    enum isUniformRandom = true;
}
static assert(isUniformRNG!(validRng, uint));
static assert(isUniformRNG!(validRng));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isSeedable">enum bool <strong id="isSeedable">isSeedable</strong>(Rng, SeedType); <br><br>enum bool <strong id="isSeedable">isSeedable</strong>(Rng); </dt> <dd>
<p>Test if Rng is seedable. The overload taking a SeedType also makes sure that the Rng can be seeded with SeedType. </p>
<p>A seedable random-number generator has the following additional features: </p>
<ul> <li>it has a 'seed(ElementType)' function</li> </ul> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">struct validRng
{
    @property uint front() {return 0;}
    @property bool empty() {return false;}
    void popFront() {}

    enum isUniformRandom = true;
}
static assert(!isSeedable!(validRng, uint));
static assert(!isSeedable!(validRng));

struct seedRng
{
    @property uint front() {return 0;}
    @property bool empty() {return false;}
    void popFront() {}
    void seed(uint val){}
    enum isUniformRandom = true;
}
static assert(isSeedable!(seedRng, uint));
static assert(!isSeedable!(seedRng, ulong));
static assert(isSeedable!(seedRng));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="LinearCongruentialEngine">struct <strong id="LinearCongruentialEngine">LinearCongruentialEngine</strong>(UIntType, UIntType a, UIntType c, UIntType m) if (isUnsigned!UIntType); </dt> <dd>
<p>Linear Congruential generator.</p>
<dl>
<dt>Examples:</dt>
<dd>Declare your own linear congruential engine <pre data-language="d">alias CPP11LCG = LinearCongruentialEngine!(uint, 48271, 0, 2_147_483_647);

// seed with a constant
auto rnd = CPP11LCG(42);
auto n = rnd.front; // same for each run
writeln(n); // 2027382
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Declare your own linear congruential engine <pre data-language="d">// glibc's LCG
alias GLibcLCG = LinearCongruentialEngine!(uint, 1103515245, 12345, 2_147_483_648);

// Seed with an unpredictable value
auto rnd = GLibcLCG(unpredictableSeed);
auto n = rnd.front; // different across runs
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="LinearCongruentialEngine.isUniformRandom">enum bool <strong id="isUniformRandom">isUniformRandom</strong>; </dt> <dd>
<p>Mark this as a Rng</p> </dd> <dt class="d_decl" id="LinearCongruentialEngine.hasFixedRange">enum bool <strong id="hasFixedRange">hasFixedRange</strong>; </dt> <dd>
<p>Does this generator have a fixed range? (<span class="d_param">true</span>).</p> </dd> <dt class="d_decl" id="LinearCongruentialEngine.min">enum UIntType <strong id="min">min</strong>; </dt> <dd>
<p>Lowest generated value (<code>1</code> if <code>c == 0</code>, <code>0</code> otherwise).</p> </dd> <dt class="d_decl" id="LinearCongruentialEngine.max">enum UIntType <strong id="max">max</strong>; </dt> <dd>
<p>Highest generated value (<code>modulus - 1</code>).</p> </dd> <dt class="d_decl" id="LinearCongruentialEngine.multiplier">enum UIntType <strong id="multiplier">multiplier</strong>; <br><br>enum UIntType <strong id="increment">increment</strong>; <br><br>enum UIntType <strong id="modulus">modulus</strong>; </dt> <dd>
<p>The parameters of this distribution. The random number is <span class="d_param">x = (x * multipler + increment) % modulus</span>.</p> </dd> <dt class="d_decl" id="LinearCongruentialEngine.this">pure nothrow @nogc @safe this(UIntType x0); </dt> <dd>
<p>Constructs a <span class="d_param">LinearCongruentialEngine</span> generator seeded with <code>x0</code>.</p> </dd> <dt class="d_decl" id="LinearCongruentialEngine.seed">pure nothrow @nogc @safe void <strong id="seed">seed</strong>(UIntType x0 = 1); </dt> <dd>
<p>(Re)seeds the generator.</p> </dd> <dt class="d_decl" id="LinearCongruentialEngine.popFront">pure nothrow @nogc @safe void <strong id="popFront">popFront</strong>(); </dt> <dd>
<p>Advances the random sequence.</p> </dd> <dt class="d_decl" id="LinearCongruentialEngine.front">const pure nothrow @nogc @property @safe UIntType <strong id="front">front</strong>(); </dt> <dd>
<p>Returns the current number in the random sequence.</p> </dd> <dt class="d_decl" id="LinearCongruentialEngine.save">const pure nothrow @nogc @property @safe typeof(this) <strong id="save">save</strong>(); </dt>  <dt class="d_decl" id="LinearCongruentialEngine.empty">enum bool <strong id="empty">empty</strong>; </dt> <dd>
<p>Always <code>false</code> (random generators are infinite ranges).</p> </dd> </dl> </dd> <dt class="d_decl" id="MinstdRand0">alias <strong id="MinstdRand0">MinstdRand0</strong> = LinearCongruentialEngine!(uint, 16807u, 0u, 2147483647u).LinearCongruentialEngine; <br><br>alias <strong id="MinstdRand">MinstdRand</strong> = LinearCongruentialEngine!(uint, 48271u, 0u, 2147483647u).LinearCongruentialEngine; </dt> <dd>
<p>Define <span class="d_param">LinearCongruentialEngine</span> generators with well-chosen parameters. <code>MinstdRand0</code> implements Park and Miller's "minimal standard" <a href="http://wikipedia.org/wiki/Park%E2%80%93Miller_random_number_generator">generator</a> that uses 16807 for the multiplier. <code>MinstdRand</code> implements a variant that has slightly better spectral behavior by using the multiplier 48271. Both generators are rather simplistic.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">// seed with a constant
auto rnd0 = MinstdRand0(1);
auto n = rnd0.front;
 // same for each run
writeln(n); // 16807

// Seed with an unpredictable value
rnd0.seed(unpredictableSeed);
n = rnd0.front; // different across runs
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="MersenneTwisterEngine">struct <strong id="MersenneTwisterEngine">MersenneTwisterEngine</strong>(UIntType, size_t w, size_t n, size_t m, size_t r, UIntType a, size_t u, UIntType d, size_t s, UIntType b, size_t t, UIntType c, size_t l, UIntType f) if (isUnsigned!UIntType); </dt> <dd>
<p>The <a href="https://en.wikipedia.org/wiki/Mersenne_Twister">Mersenne Twister</a> generator.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">// seed with a constant
Mt19937 gen;
auto n = gen.front; // same for each run
writeln(n); // 3499211612

// Seed with an unpredictable value
gen.seed(unpredictableSeed);
n = gen.front; // different across runs
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="MersenneTwisterEngine.isUniformRandom">enum bool <strong id="isUniformRandom">isUniformRandom</strong>; </dt> <dd>
<p>Mark this as a Rng</p> </dd> <dt class="d_decl" id="MersenneTwisterEngine.wordSize">enum size_t <strong id="wordSize">wordSize</strong>; <br><br>enum size_t <strong id="stateSize">stateSize</strong>; <br><br>enum size_t <strong id="shiftSize">shiftSize</strong>; <br><br>enum size_t <strong id="maskBits">maskBits</strong>; <br><br>enum UIntType <strong id="xorMask">xorMask</strong>; <br><br>enum size_t <strong id="temperingU">temperingU</strong>; <br><br>enum UIntType <strong id="temperingD">temperingD</strong>; <br><br>enum size_t <strong id="temperingS">temperingS</strong>; <br><br>enum UIntType <strong id="temperingB">temperingB</strong>; <br><br>enum size_t <strong id="temperingT">temperingT</strong>; <br><br>enum UIntType <strong id="temperingC">temperingC</strong>; <br><br>enum size_t <strong id="temperingL">temperingL</strong>; <br><br>enum UIntType <strong id="initializationMultiplier">initializationMultiplier</strong>; </dt> <dd>
<p>Parameters for the generator.</p> </dd> <dt class="d_decl" id="MersenneTwisterEngine.min">enum UIntType <strong id="min">min</strong>; </dt> <dd>
<p>Smallest generated value (0).</p> </dd> <dt class="d_decl" id="MersenneTwisterEngine.max">enum UIntType <strong id="max">max</strong>; </dt> <dd>
<p>Largest generated value.</p> </dd> <dt class="d_decl" id="MersenneTwisterEngine.defaultSeed">enum UIntType <strong id="defaultSeed">defaultSeed</strong>; </dt> <dd>
<p>The default seed value.</p> </dd> <dt class="d_decl" id="MersenneTwisterEngine.this">pure nothrow @nogc @safe this(UIntType value); </dt> <dd>
<p>Constructs a MersenneTwisterEngine object.</p> </dd> <dt class="d_decl" id="MersenneTwisterEngine.seed">pure nothrow @nogc @safe void <strong id="seed">seed</strong>()(UIntType value = defaultSeed); </dt> <dd>
<p>Seeds a MersenneTwisterEngine object. </p>
<dl>
<dt>Note</dt>
<dd> This seed function gives 2^w starting points (the lowest w bits of the value provided will be used). To allow the RNG to be started in any one of its internal states use the seed overload taking an InputRange.</dd>
</dl> </dd> <dt class="d_decl" id="MersenneTwisterEngine.seed.2">void <strong id="seed">seed</strong>(T)(T range)<br><small>  Constraints: if (isInputRange!T &amp;&amp; is(Unqual!(ElementType!T) == UIntType)); </small>
</dt> <dd>
<p>Seeds a MersenneTwisterEngine object using an InputRange. </p>
<dl>
<dt>Throws:</dt>
<dd>
<code>Exception</code> if the InputRange didn't provide enough elements to seed the generator. The number of elements required is the 'n' template parameter of the MersenneTwisterEngine struct.</dd>
</dl> </dd> <dt class="d_decl" id="MersenneTwisterEngine.popFront">pure nothrow @nogc @safe void <strong id="popFront">popFront</strong>(); </dt> <dd>
<p>Advances the generator.</p> </dd> <dt class="d_decl" id="MersenneTwisterEngine.front">const pure nothrow @nogc @property @safe UIntType <strong id="front">front</strong>(); </dt> <dd>
<p>Returns the current random value.</p> </dd> <dt class="d_decl" id="MersenneTwisterEngine.save">const pure nothrow @nogc @property @safe typeof(this) <strong id="save">save</strong>(); </dt>  <dt class="d_decl" id="MersenneTwisterEngine.empty">enum bool <strong id="empty">empty</strong>; </dt> <dd>
<p>Always <code>false</code>.</p> </dd> </dl> </dd> <dt class="d_decl" id="Mt19937">alias <strong id="Mt19937">Mt19937</strong> = MersenneTwisterEngine!(uint, 32LU, 624LU, 397LU, 31LU, 2567483615u, 11LU, 4294967295u, 7LU, 2636928640u, 15LU, 4022730752u, 18LU, 1812433253u).MersenneTwisterEngine; </dt> <dd>
<p>A <code>MersenneTwisterEngine</code> instantiated with the parameters of the original engine <a href="http://math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html">MT19937</a>, generating uniformly-distributed 32-bit numbers with a period of 2 to the power of 19937. Recommended for random number generation unless memory is severely restricted, in which case a <a href="#LinearCongruentialEngine"><code>LinearCongruentialEngine</code></a> would be the generator of choice.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">// seed with a constant
Mt19937 gen;
auto n = gen.front; // same for each run
writeln(n); // 3499211612

// Seed with an unpredictable value
gen.seed(unpredictableSeed);
n = gen.front; // different across runs
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Mt19937_64">alias <strong id="Mt19937_64">Mt19937_64</strong> = MersenneTwisterEngine!(ulong, 64LU, 312LU, 156LU, 31LU, 13043109905998158313LU, 29LU, 6148914691236517205LU, 17LU, 8202884508482404352LU, 37LU, 18444473444759240704LU, 43LU, 6364136223846793005LU).MersenneTwisterEngine; </dt> <dd>
<p>A <code>MersenneTwisterEngine</code> instantiated with the parameters of the original engine <a href="http://en.wikipedia.org/wiki/Mersenne_Twister">MT19937-64</a>, generating uniformly-distributed 64-bit numbers with a period of 2 to the power of 19937.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">// Seed with a constant
auto gen = Mt19937_64(12345);
auto n = gen.front; // same for each run
writeln(n); // 6597103971274460346

// Seed with an unpredictable value
gen.seed(unpredictableSeed!ulong);
n = gen.front; // different across runs
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="XorshiftEngine">struct <strong id="XorshiftEngine">XorshiftEngine</strong>(UIntType, uint nbits, int sa, int sb, int sc) if (isUnsigned!UIntType &amp;&amp; !(sa &gt; 0 &amp;&amp; (sb &gt; 0) &amp;&amp; (sc &gt; 0))); <br><br>template <strong id="XorshiftEngine">XorshiftEngine</strong>(UIntType, int bits, int a, int b, int c) if (isUnsigned!UIntType &amp;&amp; (a &gt; 0) &amp;&amp; (b &gt; 0) &amp;&amp; (c &gt; 0))</dt> <dd>
<p>Xorshift generator. Implemented according to <a href="http://www.jstatsoft.org/v08/i14/paper">Xorshift RNGs</a> (Marsaglia, 2003) when the size is small. For larger sizes the generator uses Sebastino Vigna's optimization of using an index to avoid needing to rotate the internal array. </p>
<p>Period is <code>2 ^^ nbits - 1</code> except for a legacy 192-bit uint version (see note below). </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>UIntType</td> <td>Word size of this xorshift generator and the return type of <code>opCall</code>.</td>
</tr> <tr>
<td>nbits</td> <td>The number of bits of state of this generator. This must be a positive multiple of the size in bits of UIntType. If nbits is large this struct may occupy slightly more memory than this so it can use a circular counter instead of shifting the entire array.</td>
</tr> <tr>
<td>sa</td> <td>The direction and magnitude of the 1st shift. Positive means left, negative means right.</td>
</tr> <tr>
<td>sb</td> <td>The direction and magnitude of the 2nd shift. Positive means left, negative means right.</td>
</tr> <tr>
<td>sc</td> <td>The direction and magnitude of the 3rd shift. Positive means left, negative means right.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Note</dt>
<dd> For historical compatibility when <code>nbits == 192</code> and <code>UIntType</code> is <code>uint</code> a legacy hybrid PRNG is used consisting of a 160-bit xorshift combined with a 32-bit counter. This combined generator has period equal to the least common multiple of <code>2^^160 - 1</code> and <code>2^^32</code>. </dd>
</dl> Previous versions of <code>XorshiftEngine</code> did not provide any mechanism to specify the directions of the shifts, taking each shift as an unsigned magnitude. For backwards compatibility, because three shifts in the same direction cannot result in a full-period XorshiftEngine, when all three of <code>sa</code>, <code>sb</code>, <code>sc, are positive </code>XorshiftEngine` treats them as unsigned magnitudes and uses shift directions to match the old behavior of <code>XorshiftEngine</code>.  Not every set of shifts results in a full-period xorshift generator. The template does not currently at compile-time perform a full check for maximum period but in a future version might reject parameters resulting in shorter periods. <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">alias Xorshift96  = XorshiftEngine!(uint, 96,  10, 5,  26);
auto rnd = Xorshift96(42);
auto num = rnd.front;  // same for each run
writeln(num); // 2704588748
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="XorshiftEngine.isUniformRandom">enum bool <strong id="isUniformRandom">isUniformRandom</strong>; </dt> <dd>
<p>Mark this as a Rng</p> </dd> <dt class="d_decl" id="XorshiftEngine.empty">enum auto <strong id="empty">empty</strong>; </dt> <dd>
<p>Always <code>false</code> (random generators are infinite ranges).</p> </dd> <dt class="d_decl" id="XorshiftEngine.min">enum UIntType <strong id="min">min</strong>; </dt> <dd>
<p>Smallest generated value.</p> </dd> <dt class="d_decl" id="XorshiftEngine.max">enum UIntType <strong id="max">max</strong>; </dt> <dd>
<p>Largest generated value.</p> </dd> <dt class="d_decl" id="XorshiftEngine.this">pure nothrow @nogc @safe this()(UIntType x0); </dt> <dd>
<p>Constructs a <code>XorshiftEngine</code> generator seeded with <span class="d_param">x0</span>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>UIntType <code>x0</code>
</td> <td>value used to deterministically initialize internal state</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="XorshiftEngine.seed">pure nothrow @nogc @safe void <strong id="seed">seed</strong>()(UIntType x0); </dt> <dd>
<p>(Re)seeds the generator. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>UIntType <code>x0</code>
</td> <td>value used to deterministically initialize internal state</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="XorshiftEngine.front">const pure nothrow @nogc @property @safe UIntType <strong id="front">front</strong>(); </dt> <dd>
<p>Returns the current number in the random sequence.</p> </dd> <dt class="d_decl" id="XorshiftEngine.popFront">pure nothrow @nogc @safe void <strong id="popFront">popFront</strong>(); </dt> <dd>
<p>Advances the random sequence.</p> </dd> <dt class="d_decl" id="XorshiftEngine.save">const pure nothrow @nogc @property @safe typeof(this) <strong id="save">save</strong>(); </dt> <dd>
<p>Captures a range state.</p> </dd> </dl> </dd> <dt class="d_decl" id="Xorshift32">alias <strong id="Xorshift32">Xorshift32</strong> = XorshiftEngine!(uint, 32u, 13, -17, 15).XorshiftEngine; <br><br>alias <strong id="Xorshift64">Xorshift64</strong> = XorshiftEngine!(uint, 64u, 10, -13, -10).XorshiftEngine; <br><br>alias <strong id="Xorshift96">Xorshift96</strong> = XorshiftEngine!(uint, 96u, 10, -5, -26).XorshiftEngine; <br><br>alias <strong id="Xorshift128">Xorshift128</strong> = XorshiftEngine!(uint, 128u, 11, -8, -19).XorshiftEngine; <br><br>alias <strong id="Xorshift160">Xorshift160</strong> = XorshiftEngine!(uint, 160u, 2, -1, -4).XorshiftEngine; <br><br>alias <strong id="Xorshift192">Xorshift192</strong> = XorshiftEngine!(uint, 192u, -2, 1, 4).XorshiftEngine; <br><br>alias <strong id="Xorshift">Xorshift</strong> = XorshiftEngine!(uint, 128u, 11, -8, -19).XorshiftEngine; </dt> <dd>
<p>Define <code>XorshiftEngine</code> generators with well-chosen parameters. See each bits examples of "Xorshift RNGs". <code>Xorshift</code> is a Xorshift128's alias because 128bits implementation is mostly used.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">// Seed with a constant
auto rnd = Xorshift(1);
auto num = rnd.front;  // same for each run
writeln(num); // 1405313047

// Seed with an unpredictable value
rnd.seed(unpredictableSeed);
num = rnd.front; // different across rnd
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="unpredictableSeed">nothrow @nogc @property @trusted uint <strong id="unpredictableSeed">unpredictableSeed</strong>(); <br><br>template <strong id="unpredictableSeed">unpredictableSeed</strong>(UIntType) if (isUnsigned!UIntType)</dt> <dd>
<p>A "good" seed for initializing random number engines. Initializing with <span class="d_param">unpredictableSeed</span> makes engines generate different random number sequences every run. </p>
<dl>
<dt>Returns:</dt>
<dd>A single unsigned integer seed value, different on each successive call </dd>
</dl> <dl>
<dt>Note</dt>
<dd> In general periodically 'reseeding' a PRNG does not improve its quality and in some cases may harm it. For an extreme example the Mersenne Twister has <code>2 ^^ 19937 - 1</code> distinct states but after <code>seed(uint)</code> is called it can only be in one of <code>2 ^^ 32</code> distinct states regardless of how excellent the source of entropy is.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto rnd = Random(unpredictableSeed);
auto n = rnd.front;
static assert(is(typeof(n) == uint));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Random">alias <strong id="Random">Random</strong> = MersenneTwisterEngine!(uint, 32LU, 624LU, 397LU, 31LU, 2567483615u, 11LU, 4294967295u, 7LU, 2636928640u, 15LU, 4022730752u, 18LU, 1812433253u).MersenneTwisterEngine; </dt> <dd>
<p>The "default", "favorite", "suggested" random number generator type on the current platform. It is an alias for one of the previously-defined generators. You may want to use it if (1) you need to generate some nice random numbers, and (2) you don't care for the minutiae of the method being used.</p> </dd> <dt class="d_decl" id="rndGen">nothrow @nogc @property ref @safe Random <strong id="rndGen">rndGen</strong>(); </dt> <dd>
<p>Global random number generator used by various functions in this module whenever no generator is specified. It is allocated per-thread and initialized to an unpredictable value for each thread. </p>
<dl>
<dt>Returns:</dt>
<dd>A singleton instance of the default random number generator</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.iteration : sum;
import std.range : take;
auto rnd = rndGen;
assert(rnd.take(3).sum &gt; 0);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="uniform">auto <strong id="uniform">uniform</strong>(string boundaries = "[)", T1, T2)(T1 a, T2 b)<br><small>  Constraints: if (!is(CommonType!(T1, T2) == void)); </small><br><br>auto <strong id="uniform">uniform</strong>(string boundaries = "[)", T1, T2, UniformRandomNumberGenerator)(T1 a, T2 b, ref UniformRandomNumberGenerator urng)<br><small>  Constraints: if (isFloatingPoint!(CommonType!(T1, T2)) &amp;&amp; isUniformRNG!UniformRandomNumberGenerator); </small>
</dt> <dd>
<p>Generates a number between <code>a</code> and <code>b</code>. The <code>boundaries</code> parameter controls the shape of the interval (open vs. closed on either side). Valid values for <code>boundaries</code> are <code>"[]"</code>, <code>"(]"</code>, <code>"[)"</code>, and <code>"()"</code>. The default interval is closed to the left and open to the right. The version that does not take <code>urng</code> uses the default generator <code>rndGen</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T1 <code>a</code>
</td> <td>lower bound of the uniform distribution</td>
</tr> <tr>
<td>T2 <code>b</code>
</td> <td>upper bound of the uniform distribution</td>
</tr> <tr>
<td>UniformRandomNumberGenerator <code>urng</code>
</td> <td>(optional) random number generator to use; if not specified, defaults to <code>rndGen</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A single random variate drawn from the uniform distribution between <code>a</code> and <code>b</code>, whose type is the common type of these parameters</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto rnd = Random(unpredictableSeed);

// Generate an integer in [0, 1023]
auto a = uniform(0, 1024, rnd);
assert(0 &lt;= a &amp;&amp; a &lt; 1024);

// Generate a float in [0, 1)
auto b = uniform(0.0f, 1.0f, rnd);
assert(0 &lt;= b &amp;&amp; b &lt; 1);

// Generate a float in [0, 1]
b = uniform!"[]"(0.0f, 1.0f, rnd);
assert(0 &lt;= b &amp;&amp; b &lt;= 1);

// Generate a float in (0, 1)
b = uniform!"()"(0.0f, 1.0f, rnd);
assert(0 &lt; b &amp;&amp; b &lt; 1);
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Create an array of random numbers using range functions and UFCS <pre data-language="d">import std.array : array;
import std.range : generate, takeExactly;

int[] arr = generate!(() =&gt; uniform(0, 100)).takeExactly(10).array;
writeln(arr.length); // 10
assert(arr[0] &gt;= 0 &amp;&amp; arr[0] &lt; 100);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="uniform.2">auto <strong id="uniform">uniform</strong>(T, UniformRandomNumberGenerator)(ref UniformRandomNumberGenerator urng)<br><small>  Constraints: if (!is(T == enum) &amp;&amp; (isIntegral!T || isSomeChar!T) &amp;&amp; isUniformRNG!UniformRandomNumberGenerator); </small><br><br>auto <strong id="uniform">uniform</strong>(T)()<br><small>  Constraints: if (!is(T == enum) &amp;&amp; (isIntegral!T || isSomeChar!T)); </small><br><br>auto <strong id="uniform">uniform</strong>(E, UniformRandomNumberGenerator)(ref UniformRandomNumberGenerator urng)<br><small>  Constraints: if (is(E == enum) &amp;&amp; isUniformRNG!UniformRandomNumberGenerator); </small><br><br>auto <strong id="uniform">uniform</strong>(E)()<br><small>  Constraints: if (is(E == enum)); </small>
</dt> <dd>
<p>Generates a uniformly-distributed number in the range <code>[T.min, T.max]</code> for any integral or character type <code>T</code>. If no random number generator is passed, uses the default <code>rndGen</code>. </p>
<p>If an <code>enum</code> is used as type, the random variate is drawn with equal probability from any of the possible values of the enum <code>E</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>UniformRandomNumberGenerator <code>urng</code>
</td> <td>(optional) random number generator to use; if not specified, defaults to <code>rndGen</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Random variate drawn from the uniform distribution across all possible values of the integral, character or enum type <code>T</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto rnd = MinstdRand0(42);

writeln(rnd.uniform!ubyte); // 102
writeln(rnd.uniform!ulong); // 4838462006927449017

enum Fruit { apple, mango, pear }
version (X86_64) // Issue 15147
writeln(rnd.uniform!Fruit); // Fruit.mango
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="uniform01">T <strong id="uniform01">uniform01</strong>(T = double)()<br><small>  Constraints: if (isFloatingPoint!T); </small><br><br>T <strong id="uniform01">uniform01</strong>(T = double, UniformRNG)(ref UniformRNG rng)<br><small>  Constraints: if (isFloatingPoint!T &amp;&amp; isUniformRNG!UniformRNG); </small>
</dt> <dd>
<p>Generates a uniformly-distributed floating point number of type <code>T</code> in the range [0, 1). If no random number generator is specified, the default RNG <code>rndGen</code> will be used as the source of randomness. </p>
<p><code>uniform01</code> offers a faster generation of random variates than the equivalent <code>uniform!"[)"(0.0, 1.0)</code> and so may be preferred for some applications. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>UniformRNG <code>rng</code>
</td> <td>(optional) random number generator to use; if not specified, defaults to <code>rndGen</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Floating-point random variate of type <code>T</code> drawn from the uniform distribution across the half-open interval [0, 1).</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.math : feqrel;

auto rnd = MinstdRand0(42);

assert(rnd.uniform01.feqrel(0.000328707) &gt; 20);
assert(rnd.uniform01!float.feqrel(0.524587) &gt; 20);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="uniformDistribution">F[] <strong id="uniformDistribution">uniformDistribution</strong>(F = double)(size_t n, F[] useThis = null)<br><small>  Constraints: if (isFloatingPoint!F); </small>
</dt> <dd>
<p>Generates a uniform probability distribution of size <code>n</code>, i.e., an array of size <code>n</code> of positive numbers of type <code>F</code> that sum to <code>1</code>. If <code>useThis</code> is provided, it is used as storage.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.iteration : reduce;
import std.math : approxEqual;

auto a = uniformDistribution(5);
writeln(a.length); // 5
assert(approxEqual(reduce!"a + b"(a), 1));

a = uniformDistribution(10, a);
writeln(a.length); // 10
assert(approxEqual(reduce!"a + b"(a), 1));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="choice">ref auto <strong id="choice">choice</strong>(Range, RandomGen = Random)(auto ref Range range, ref RandomGen urng)<br><small>  Constraints: if (isRandomAccessRange!Range &amp;&amp; hasLength!Range &amp;&amp; isUniformRNG!RandomGen); </small><br><br>ref auto <strong id="choice">choice</strong>(Range)(auto ref Range range); </dt> <dd>
<p>Returns a random, uniformly chosen, element <code>e</code> from the supplied <code>Range range</code>. If no random number generator is passed, the default <code>rndGen</code> is used. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>range</code>
</td> <td>a random access range that has the <code>length</code> property defined</td>
</tr> <tr>
<td>RandomGen <code>urng</code>
</td> <td>(optional) random number generator to use; if not specified, defaults to <code>rndGen</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A single random element drawn from the <code>range</code>. If it can, it will return a <code>ref</code> to the <code>range element</code>, otherwise it will return a copy.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto rnd = MinstdRand0(42);

auto elem  = [1, 2, 3, 4, 5].choice(rnd);
version (X86_64) // Issue 15147
writeln(elem); // 3
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="randomShuffle">Range <strong id="randomShuffle">randomShuffle</strong>(Range, RandomGen)(Range r, ref RandomGen gen)<br><small>  Constraints: if (isRandomAccessRange!Range &amp;&amp; isUniformRNG!RandomGen); </small><br><br>Range <strong id="randomShuffle">randomShuffle</strong>(Range)(Range r)<br><small>  Constraints: if (isRandomAccessRange!Range); </small>
</dt> <dd>
<p>Shuffles elements of <code>r</code> using <code>gen</code> as a shuffler. <code>r</code> must be a random-access range with length. If no RNG is specified, <code>rndGen</code> will be used. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>r</code>
</td> <td>random-access range whose elements are to be shuffled</td>
</tr> <tr>
<td>RandomGen <code>gen</code>
</td> <td>(optional) random number generator to use; if not specified, defaults to <code>rndGen</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The shuffled random-access range.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto rnd = MinstdRand0(42);

auto arr = [1, 2, 3, 4, 5].randomShuffle(rnd);
version (X86_64) // Issue 15147
writeln(arr); // [3, 5, 2, 4, 1]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="partialShuffle">Range <strong id="partialShuffle">partialShuffle</strong>(Range, RandomGen)(Range r, in size_t n, ref RandomGen gen)<br><small>  Constraints: if (isRandomAccessRange!Range &amp;&amp; isUniformRNG!RandomGen); </small><br><br>Range <strong id="partialShuffle">partialShuffle</strong>(Range)(Range r, in size_t n)<br><small>  Constraints: if (isRandomAccessRange!Range); </small>
</dt> <dd>
<p>Partially shuffles the elements of <code>r</code> such that upon returning <code>r[0 .. n]</code> is a random subset of <code>r</code> and is randomly ordered. <code>r[n .. r.length]</code> will contain the elements not in <code>r[0 .. n]</code>. These will be in an undefined order, but will not be random in the sense that their order after <code>partialShuffle</code> returns will not be independent of their order before <code>partialShuffle</code> was called. </p>
<p><code>r</code> must be a random-access range with length. <code>n</code> must be less than or equal to <code>r.length</code>. If no RNG is specified, <code>rndGen</code> will be used. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>r</code>
</td> <td>random-access range whose elements are to be shuffled</td>
</tr> <tr>
<td>size_t <code>n</code>
</td> <td>number of elements of <code>r</code> to shuffle (counting from the beginning); must be less than <code>r.length</code>
</td>
</tr> <tr>
<td>RandomGen <code>gen</code>
</td> <td>(optional) random number generator to use; if not specified, defaults to <code>rndGen</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The shuffled random-access range.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto rnd = MinstdRand0(42);

auto arr = [1, 2, 3, 4, 5, 6];
arr = arr.dup.partialShuffle(1, rnd);

version (X86_64) // Issue 15147
assert(arr == [2, 1, 3, 4, 5, 6]); // 1&lt;-&gt;2

arr = arr.dup.partialShuffle(2, rnd);
version (X86_64) // Issue 15147
assert(arr == [1, 4, 3, 2, 5, 6]); // 1&lt;-&gt;2, 2&lt;-&gt;4

arr = arr.dup.partialShuffle(3, rnd);
version (X86_64) // Issue 15147
assert(arr == [5, 4, 6, 2, 1, 3]); // 1&lt;-&gt;5, 2&lt;-&gt;4, 3&lt;-&gt;6
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="dice">size_t <strong id="dice">dice</strong>(Rng, Num)(ref Rng rnd, Num[] proportions...)<br><small>  Constraints: if (isNumeric!Num &amp;&amp; isForwardRange!Rng); </small><br><br>size_t <strong id="dice">dice</strong>(R, Range)(ref R rnd, Range proportions)<br><small>  Constraints: if (isForwardRange!Range &amp;&amp; isNumeric!(ElementType!Range) &amp;&amp; !isArray!Range); </small><br><br>size_t <strong id="dice">dice</strong>(Range)(Range proportions)<br><small>  Constraints: if (isForwardRange!Range &amp;&amp; isNumeric!(ElementType!Range) &amp;&amp; !isArray!Range); </small><br><br>size_t <strong id="dice">dice</strong>(Num)(Num[] proportions...)<br><small>  Constraints: if (isNumeric!Num); </small>
</dt> <dd>
<p>Rolls a dice with relative probabilities stored in <code>proportions</code>. Returns the index in <code>proportions</code> that was chosen. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Rng <code>rnd</code>
</td> <td>(optional) random number generator to use; if not specified, defaults to <code>rndGen</code>
</td>
</tr> <tr>
<td>Num[] <code>proportions</code>
</td> <td>forward range or list of individual values whose elements correspond to the probabilities with which to choose the corresponding index value</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Random variate drawn from the index values [0, ... <code>proportions.length</code> - 1], with the probability of getting an individual index value <code>i</code> being proportional to <code>proportions[i]</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto x = dice(0.5, 0.5);   // x is 0 or 1 in equal proportions
auto y = dice(50, 50);     // y is 0 or 1 in equal proportions
auto z = dice(70, 20, 10); // z is 0 70% of the time, 1 20% of the time,
                           // and 2 10% of the time
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto rnd = MinstdRand0(42);
auto z = rnd.dice(70, 20, 10);
writeln(z); // 0
z = rnd.dice(30, 20, 40, 10);
writeln(z); // 2
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="RandomCover">struct <strong id="RandomCover">RandomCover</strong>(Range, UniformRNG = void) if (isRandomAccessRange!Range &amp;&amp; (isUniformRNG!UniformRNG || is(UniformRNG == void))); <br><br>auto <strong id="randomCover">randomCover</strong>(Range, UniformRNG)(Range r, auto ref UniformRNG rng)<br><small>  Constraints: if (isRandomAccessRange!Range &amp;&amp; isUniformRNG!UniformRNG); </small><br><br>auto <strong id="randomCover">randomCover</strong>(Range)(Range r)<br><small>  Constraints: if (isRandomAccessRange!Range); </small>
</dt> <dd>
<p>Covers a given range <code>r</code> in a random manner, i.e. goes through each element of <code>r</code> once and only once, just in a random order. <code>r</code> must be a random-access range with length. </p>
<p>If no random number generator is passed to <code>randomCover</code>, the thread-global RNG rndGen will be used internally. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>r</code>
</td> <td>random-access range to cover</td>
</tr> <tr>
<td>UniformRNG <code>rng</code>
</td> <td>(optional) random number generator to use; if not specified, defaults to <code>rndGen</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Range whose elements consist of the elements of <code>r</code>, in random order. Will be a forward range if both <code>r</code> and <code>rng</code> are forward ranges, an <a href="std_range_primitives#isInputRange">input range</a> otherwise.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.range : iota;
auto rnd = MinstdRand0(42);

version (X86_64) // Issue 15147
assert(10.iota.randomCover(rnd).equal([7, 4, 2, 0, 1, 6, 8, 3, 9, 5]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="RandomSample">struct <strong id="RandomSample">RandomSample</strong>(Range, UniformRNG = void) if (isInputRange!Range &amp;&amp; (isUniformRNG!UniformRNG || is(UniformRNG == void))); <br><br>auto <strong id="randomSample">randomSample</strong>(Range)(Range r, size_t n, size_t total)<br><small>  Constraints: if (isInputRange!Range); </small><br><br>auto <strong id="randomSample">randomSample</strong>(Range)(Range r, size_t n)<br><small>  Constraints: if (isInputRange!Range &amp;&amp; hasLength!Range); </small><br><br>auto <strong id="randomSample">randomSample</strong>(Range, UniformRNG)(Range r, size_t n, size_t total, auto ref UniformRNG rng)<br><small>  Constraints: if (isInputRange!Range &amp;&amp; isUniformRNG!UniformRNG); </small><br><br>auto <strong id="randomSample">randomSample</strong>(Range, UniformRNG)(Range r, size_t n, auto ref UniformRNG rng)<br><small>  Constraints: if (isInputRange!Range &amp;&amp; hasLength!Range &amp;&amp; isUniformRNG!UniformRNG); </small>
</dt> <dd>
<p>Selects a random subsample out of <code>r</code>, containing exactly <code>n</code> elements. The order of elements is the same as in the original range. The total length of <code>r</code> must be known. If <code>total</code> is passed in, the total number of sample is considered to be <code>total</code>. Otherwise, <code>RandomSample</code> uses <code>r.length</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>r</code>
</td> <td>range to sample from</td>
</tr> <tr>
<td>size_t <code>n</code>
</td> <td>number of elements to include in the sample; must be less than or equal to the total number of elements in <code>r</code> and/or the parameter <code>total</code> (if provided)</td>
</tr> <tr>
<td>size_t <code>total</code>
</td> <td>(semi-optional) number of elements of <code>r</code> from which to select the sample (counting from the beginning); must be less than or equal to the total number of elements in <code>r</code> itself. May be omitted if <code>r</code> has the <code>.length</code> property and the sample is to be drawn from all elements of <code>r</code>.</td>
</tr> <tr>
<td>UniformRNG <code>rng</code>
</td> <td>(optional) random number generator to use; if not specified, defaults to <code>rndGen</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Range whose elements consist of a randomly selected subset of the elements of <code>r</code>, in the same order as these elements appear in <code>r</code> itself. Will be a forward range if both <code>r</code> and <code>rng</code> are forward ranges, an input range otherwise.  <code>RandomSample</code> implements Jeffrey Scott Vitter's Algorithm D (see Vitter <a href="http://dx.doi.org/10.1145/358105.893">1984</a>, <a href="http://dx.doi.org/10.1145/23002.23003">1987</a>), which selects a sample of size <code>n</code> in O(n) steps and requiring O(n) random variates, regardless of the size of the data being sampled. The exception to this is if traversing k elements on the input range is itself an O(k) operation (e.g. when sampling lines from an input file), in which case the sampling calculation will inevitably be of O(total).  RandomSample will throw an exception if <code>total</code> is verifiably less than the total number of elements available in the input, or if <code>n &gt; total</code>.  If no random number generator is passed to <code>randomSample</code>, the thread-global RNG rndGen will be used internally.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.range : iota;
auto rnd = MinstdRand0(42);
assert(10.iota.randomSample(3, rnd).equal([7, 8, 9]));
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="RandomSample.empty">const @property bool <strong id="empty">empty</strong>(); <br><br>@property ref auto <strong id="front">front</strong>(); <br><br>void <strong id="popFront">popFront</strong>(); <br><br>const @property typeof(this) <strong id="save">save</strong>(); <br><br>const @property size_t <strong id="length">length</strong>(); </dt> <dd>
<p>Range primitives.</p> </dd> <dt class="d_decl" id="RandomSample.index">@property size_t <strong id="index">index</strong>(); </dt> <dd>
<p>Returns the index of the visited record.</p> </dd> </dl> </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2019 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_random.html" class="_attribution-link">https://dlang.org/phobos/std_random.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
