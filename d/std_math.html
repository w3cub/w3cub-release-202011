
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>std.math - D - W3cubDocs</title>
  
  <meta name="description" content="Contains the elementary mathematical functions (powers, roots, and trigonometric functions), and low-level floating-point operations. Mathematical &hellip;">
  <meta name="keywords" content="std, math, d">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/d/std_math.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/d.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/d/" class="_nav-link" title="" style="margin-left:0;">D</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _d">
				
				
<h1>std.math</h1>  <p>Contains the elementary mathematical functions (powers, roots, and trigonometric functions), and low-level floating-point operations. Mathematical special functions are available in <code>std.mathspecial</code>. </p>
<table>

<tr>
<th scope="col">Category</th> <th scope="col">Members</th> </tr> <tr>
<td>Constants</td> <td> <a href="#E"><em class="tt">E</em></a> <a href="#PI"><em class="tt">PI</em></a> <a href="#PI_2"><em class="tt">PI_2</em></a> <a href="#PI_4"><em class="tt">PI_4</em></a> <a href="#M_1_PI"><em class="tt">M_1_PI</em></a> <a href="#M_2_PI"><em class="tt">M_2_PI</em></a> <a href="#M_2_SQRTPI"><em class="tt">M_2_SQRTPI</em></a> <a href="#LN10"><em class="tt">LN10</em></a> <a href="#LN2"><em class="tt">LN2</em></a> <a href="#LOG2"><em class="tt">LOG2</em></a> <a href="#LOG2E"><em class="tt">LOG2E</em></a> <a href="#LOG2T"><em class="tt">LOG2T</em></a> <a href="#LOG10E"><em class="tt">LOG10E</em></a> <a href="#SQRT2"><em class="tt">SQRT2</em></a> <a href="#SQRT1_2"><em class="tt">SQRT1_2</em></a> </td>
</tr> <tr>
<td>Classics</td> <td> <a href="#abs"><em class="tt">abs</em></a> <a href="#fabs"><em class="tt">fabs</em></a> <a href="#sqrt"><em class="tt">sqrt</em></a> <a href="#cbrt"><em class="tt">cbrt</em></a> <a href="#hypot"><em class="tt">hypot</em></a> <a href="#poly"><em class="tt">poly</em></a> <a href="#nextPow2"><em class="tt">nextPow2</em></a> <a href="#truncPow2"><em class="tt">truncPow2</em></a> </td>
</tr> <tr>
<td>Trigonometry</td> <td> <a href="#sin"><em class="tt">sin</em></a> <a href="#cos"><em class="tt">cos</em></a> <a href="#tan"><em class="tt">tan</em></a> <a href="#asin"><em class="tt">asin</em></a> <a href="#acos"><em class="tt">acos</em></a> <a href="#atan"><em class="tt">atan</em></a> <a href="#atan2"><em class="tt">atan2</em></a> <a href="#sinh"><em class="tt">sinh</em></a> <a href="#cosh"><em class="tt">cosh</em></a> <a href="#tanh"><em class="tt">tanh</em></a> <a href="#asinh"><em class="tt">asinh</em></a> <a href="#acosh"><em class="tt">acosh</em></a> <a href="#atanh"><em class="tt">atanh</em></a> <a href="#expi"><em class="tt">expi</em></a> </td>
</tr> <tr>
<td>Rounding</td> <td> <a href="#ceil"><em class="tt">ceil</em></a> <a href="#floor"><em class="tt">floor</em></a> <a href="#round"><em class="tt">round</em></a> <a href="#lround"><em class="tt">lround</em></a> <a href="#trunc"><em class="tt">trunc</em></a> <a href="#rint"><em class="tt">rint</em></a> <a href="#lrint"><em class="tt">lrint</em></a> <a href="#nearbyint"><em class="tt">nearbyint</em></a> <a href="#rndtol"><em class="tt">rndtol</em></a> <a href="#quantize"><em class="tt">quantize</em></a> </td>
</tr> <tr>
<td>Exponentiation &amp; Logarithms</td> <td> <a href="#pow"><em class="tt">pow</em></a> <a href="#exp"><em class="tt">exp</em></a> <a href="#exp2"><em class="tt">exp2</em></a> <a href="#expm1"><em class="tt">expm1</em></a> <a href="#ldexp"><em class="tt">ldexp</em></a> <a href="#frexp"><em class="tt">frexp</em></a> <a href="#log"><em class="tt">log</em></a> <a href="#log2"><em class="tt">log2</em></a> <a href="#log10"><em class="tt">log10</em></a> <a href="#logb"><em class="tt">logb</em></a> <a href="#ilogb"><em class="tt">ilogb</em></a> <a href="#log1p"><em class="tt">log1p</em></a> <a href="#scalbn"><em class="tt">scalbn</em></a> </td>
</tr> <tr>
<td>Modulus</td> <td> <a href="#fmod"><em class="tt">fmod</em></a> <a href="#modf"><em class="tt">modf</em></a> <a href="#remainder"><em class="tt">remainder</em></a> </td>
</tr> <tr>
<td>Floating-point operations</td> <td> <a href="#approxEqual"><em class="tt">approxEqual</em></a> <a href="#feqrel"><em class="tt">feqrel</em></a> <a href="#fdim"><em class="tt">fdim</em></a> <a href="#fmax"><em class="tt">fmax</em></a> <a href="#fmin"><em class="tt">fmin</em></a> <a href="#fma"><em class="tt">fma</em></a> <a href="#nextDown"><em class="tt">nextDown</em></a> <a href="#nextUp"><em class="tt">nextUp</em></a> <a href="#nextafter"><em class="tt">nextafter</em></a> <a href="#NaN"><em class="tt">NaN</em></a> <a href="#getNaNPayload"><em class="tt">getNaNPayload</em></a> <a href="#cmp"><em class="tt">cmp</em></a> </td>
</tr> <tr>
<td>Introspection</td> <td> <a href="#isFinite"><em class="tt">isFinite</em></a> <a href="#isIdentical"><em class="tt">isIdentical</em></a> <a href="#isInfinity"><em class="tt">isInfinity</em></a> <a href="#isNaN"><em class="tt">isNaN</em></a> <a href="#isNormal"><em class="tt">isNormal</em></a> <a href="#isSubnormal"><em class="tt">isSubnormal</em></a> <a href="#signbit"><em class="tt">signbit</em></a> <a href="#sgn"><em class="tt">sgn</em></a> <a href="#copysign"><em class="tt">copysign</em></a> <a href="#isPowerOf2"><em class="tt">isPowerOf2</em></a> </td>
</tr> <tr>
<td>Hardware Control</td> <td> <a href="#IeeeFlags"><em class="tt">IeeeFlags</em></a> <a href="#FloatingPointControl"><em class="tt">FloatingPointControl</em></a> </td>
</tr> </table> <p>    The functionality closely follows the IEEE754-2008 standard for floating-point arithmetic, including the use of camelCase names rather than C99-style lower case names. All of these functions behave correctly when presented with an infinity or NaN. <br><br> The following IEEE 'real' formats are currently supported: </p>
<ul> <li>64 bit Big-endian 'double' (eg PowerPC)</li> <li>128 bit Big-endian 'quadruple' (eg SPARC)</li> <li>64 bit Little-endian 'double' (eg x86-SSE2)</li> <li>80 bit Little-endian, with implied bit 'real80' (eg x87, Itanium)</li> <li>128 bit Little-endian 'quadruple' (not implemented on any known processor!)</li> <li>Non-IEEE 128 bit Big-endian 'doubledouble' (eg PowerPC) has partial support</li> </ul> Unlike C, there is no global 'errno' variable. Consequently, almost all of these functions are pure nothrow.  <dl>
<dt>License:</dt>
<dd>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>
<a href="http://digitalmars.com">Walter Bright</a>, Don Clugston, Conversion of CEPHES math library to D by Iain Buclaw and David Nadlinger </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/math.d">std/math.d</a></span>
</dd>
</dl> <dl>
<dt class="d_decl" id="E">enum real <strong id="E">E</strong>; </dt> <dd>
<p>e = 2.718281...</p> </dd> <dt class="d_decl" id="LOG2T">enum real <strong id="LOG2T">LOG2T</strong>; </dt> <dd>
<p>log<sub>2</sub>10 = 3.321928...</p> </dd> <dt class="d_decl" id="LOG2E">enum real <strong id="LOG2E">LOG2E</strong>; </dt> <dd>
<p>log<sub>2</sub>e = 1.442695...</p> </dd> <dt class="d_decl" id="LOG2">enum real <strong id="LOG2">LOG2</strong>; </dt> <dd>
<p>log<sub>10</sub>2 = 0.301029...</p> </dd> <dt class="d_decl" id="LOG10E">enum real <strong id="LOG10E">LOG10E</strong>; </dt> <dd>
<p>log<sub>10</sub>e = 0.434294...</p> </dd> <dt class="d_decl" id="LN2">enum real <strong id="LN2">LN2</strong>; </dt> <dd>
<p>ln 2 = 0.693147...</p> </dd> <dt class="d_decl" id="LN10">enum real <strong id="LN10">LN10</strong>; </dt> <dd>
<p>ln 10 = 2.302585...</p> </dd> <dt class="d_decl" id="PI">enum real <strong id="PI">PI</strong>; </dt> <dd>
<p>π = 3.141592...</p> </dd> <dt class="d_decl" id="PI_2">enum real <strong id="PI_2">PI_2</strong>; </dt> <dd>
<p>π / 2 = 1.570796...</p> </dd> <dt class="d_decl" id="PI_4">enum real <strong id="PI_4">PI_4</strong>; </dt> <dd>
<p>π / 4 = 0.785398...</p> </dd> <dt class="d_decl" id="M_1_PI">enum real <strong id="M_1_PI">M_1_PI</strong>; </dt> <dd>
<p>1 / π = 0.318309...</p> </dd> <dt class="d_decl" id="M_2_PI">enum real <strong id="M_2_PI">M_2_PI</strong>; </dt> <dd>
<p>2 / π = 0.636619...</p> </dd> <dt class="d_decl" id="M_2_SQRTPI">enum real <strong id="M_2_SQRTPI">M_2_SQRTPI</strong>; </dt> <dd>
<p>2 / √π = 1.128379...</p> </dd> <dt class="d_decl" id="SQRT2">enum real <strong id="SQRT2">SQRT2</strong>; </dt> <dd>
<p>√2 = 1.414213...</p> </dd> <dt class="d_decl" id="SQRT1_2">enum real <strong id="SQRT1_2">SQRT1_2</strong>; </dt> <dd>
<p>√½ = 0.707106...</p> </dd> <dt class="d_decl" id="abs">auto <strong id="abs">abs</strong>(Num)(Num x)<br><small>  Constraints: if (is(Unqual!Num == short) || is(Unqual!Num == byte) || is(typeof(Num.init &gt;= 0)) &amp;&amp; is(typeof(-Num.init))); </small>
</dt> <dd>
<p>Calculates the absolute value of a number </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Num</td> <td>(template parameter) type of number</td>
</tr> <tr>
<td>Num <code>x</code>
</td> <td>real number value</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The absolute value of the number. If floating-point or integral, the return type will be the same as the input;</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>ditto <pre data-language="d">assert(isIdentical(abs(-0.0L), 0.0L));
assert(isNaN(abs(real.nan)));
writeln(abs(-real.infinity)); // real.infinity
writeln(abs(-56)); // 56
writeln(abs(2321312L)); // 2321312L
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="AliasSeq">public import std.meta : <strong id="AliasSeq">AliasSeq</strong>; </dt>  <dt class="d_decl" id="cos">pure nothrow @nogc @safe real <strong id="cos">cos</strong>(real x); <br><br>pure nothrow @nogc @safe double <strong id="cos">cos</strong>(double x); <br><br>pure nothrow @nogc @safe float <strong id="cos">cos</strong>(float x); </dt> <dd>
<p>Returns cosine of x. x is in radians. </p>
<p></p>
<table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">cos(x)</th> <th scope="col">invalid?</th>
</tr> <tr>
<td><span class="red">NAN</span></td> <td><span class="red">NAN</span></td> <td>yes</td> </tr> <tr>
<td>±∞</td> <td><span class="red">NAN</span></td> <td>yes</td> </tr> </table>  <dl>
<dt>Bugs:</dt>
<dd>Results are undefined if |x| &gt;= 2<sup>64</sup>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(cos(0.0)); // 1.0
assert(cos(1.0).approxEqual(0.540));
assert(cos(3.0).approxEqual(-0.989));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="sin">pure nothrow @nogc @safe real <strong id="sin">sin</strong>(real x); <br><br>pure nothrow @nogc @safe double <strong id="sin">sin</strong>(double x); <br><br>pure nothrow @nogc @safe float <strong id="sin">sin</strong>(float x); </dt> <dd>
<p>Returns <a href="http://en.wikipedia.org/wiki/Sine">sine</a> of x. x is in <a href="http://en.wikipedia.org/wiki/Radian">radians</a>. </p>
<p></p>
<table> <caption>Special Values</caption> <tr>
<th scope="col">x </th> <th scope="col"> sin(x) </th> <th scope="col"> invalid?</th>
</tr> <tr>
<td>
<span class="red">NAN</span> </td> <td> <span class="red">NAN</span> </td> <td> yes </td>
</tr> <tr>
<td>±0.0</td> <td> ±0.0</td> <td> no </td>
</tr> <tr>
<td>±∞</td> <td> <span class="red">NAN</span> </td> <td> yes </td>
</tr> </table>  <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>real <code>x</code>
</td> <td>angle in radians (not degrees)</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>sine of x </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#cos"><em class="tt">cos</em></a> , <a href="#tan"><em class="tt">tan</em></a> , <a href="#asin"><em class="tt">asin</em></a> </dd>
</dl> <dl>
<dt>Bugs:</dt>
<dd>Results are undefined if |x| &gt;= 2<sup>64</sup>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.math : sin, PI;
import std.stdio : writefln;

void someFunc()
{
  real x = 30.0;
  auto result = sin(x * (PI / 180)); // convert degrees to radians
  writefln("The sine of %s degrees is %s", x, result);
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="tan">pure nothrow @nogc @trusted real <strong id="tan">tan</strong>(real x); <br><br>pure nothrow @nogc @safe double <strong id="tan">tan</strong>(double x); <br><br>pure nothrow @nogc @safe float <strong id="tan">tan</strong>(float x); </dt> <dd>
<p>Returns tangent of x. x is in radians. </p>
<p></p>
<table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">tan(x)</th> <th scope="col">invalid?</th>
</tr> <tr>
<td><span class="red">NAN</span></td> <td><span class="red">NAN</span></td> <td>yes</td>
</tr> <tr>
<td>±0.0</td> <td>±0.0</td> <td>no</td>
</tr> <tr>
<td>±∞</td> <td><span class="red">NAN</span></td> <td>yes</td>
</tr> </table> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(isIdentical(tan(0.0), 0.0));
assert(tan(PI).approxEqual(0));
assert(tan(PI / 3).approxEqual(sqrt(3.0)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="acos">pure nothrow @nogc @safe real <strong id="acos">acos</strong>(real x); <br><br>pure nothrow @nogc @safe double <strong id="acos">acos</strong>(double x); <br><br>pure nothrow @nogc @safe float <strong id="acos">acos</strong>(float x); </dt> <dd>
<p>Calculates the arc cosine of x, returning a value ranging from 0 to π. </p>
<p></p>
<table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">acos(x)</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>&gt;1.0</td> <td><span class="red">NAN</span></td> <td>yes</td>
</tr> <tr>
<td>&lt;-1.0</td> <td><span class="red">NAN</span></td> <td>yes</td>
</tr> <tr>
<td><span class="red">NAN</span></td> <td><span class="red">NAN</span></td> <td>yes</td>
</tr> </table> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(acos(0.0).approxEqual(1.570));
assert(acos(0.5).approxEqual(std.math.PI / 3));
assert(acos(PI).isNaN);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="asin">pure nothrow @nogc @safe real <strong id="asin">asin</strong>(real x); <br><br>pure nothrow @nogc @safe double <strong id="asin">asin</strong>(double x); <br><br>pure nothrow @nogc @safe float <strong id="asin">asin</strong>(float x); </dt> <dd>
<p>Calculates the arc sine of x, returning a value ranging from -π/2 to π/2. </p>
<p></p>
<table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">asin(x)</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>±0.0</td> <td>±0.0</td> <td>no</td>
</tr> <tr>
<td>&gt;1.0</td> <td><span class="red">NAN</span></td> <td>yes</td>
</tr> <tr>
<td>&lt;-1.0</td> <td><span class="red">NAN</span></td> <td>yes</td>
</tr> </table> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(isIdentical(asin(0.0), 0.0));
assert(asin(0.5).approxEqual(PI / 6));
assert(asin(PI).isNaN);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="atan">pure nothrow @nogc @safe real <strong id="atan">atan</strong>(real x); <br><br>pure nothrow @nogc @safe double <strong id="atan">atan</strong>(double x); <br><br>pure nothrow @nogc @safe float <strong id="atan">atan</strong>(float x); </dt> <dd>
<p>Calculates the arc tangent of x, returning a value ranging from -π/2 to π/2. </p>
<p></p>
<table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">atan(x)</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>±0.0</td> <td>±0.0</td> <td>no</td>
</tr> <tr>
<td>±∞</td> <td><span class="red">NAN</span></td> <td>yes</td>
</tr> </table> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(isIdentical(atan(0.0), 0.0));
assert(atan(sqrt(3.0)).approxEqual(PI / 3));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="atan2">pure nothrow @nogc @trusted real <strong id="atan2">atan2</strong>(real y, real x); <br><br>pure nothrow @nogc @safe double <strong id="atan2">atan2</strong>(double y, double x); <br><br>pure nothrow @nogc @safe float <strong id="atan2">atan2</strong>(float y, float x); </dt> <dd>
<p>Calculates the arc tangent of y / x, returning a value ranging from -π to π. </p>
<p></p>
<table> <caption>Special Values</caption> <tr>
<th scope="col">y</th> <th scope="col">x</th> <th scope="col">atan(y, x)</th>
</tr> <tr>
<td><span class="red">NAN</span></td> <td>anything</td> <td><span class="red">NAN</span></td> </tr> <tr>
<td>anything</td> <td><span class="red">NAN</span></td> <td><span class="red">NAN</span></td> </tr> <tr>
<td>±0.0</td> <td>&gt;0.0</td> <td>±0.0</td> </tr> <tr>
<td>±0.0</td> <td>+0.0</td> <td>±0.0</td> </tr> <tr>
<td>±0.0</td> <td>&lt;0.0</td> <td>±π</td>
</tr> <tr>
<td>±0.0</td> <td>-0.0</td> <td>±π</td>
</tr> <tr>
<td>&gt;0.0</td> <td>±0.0</td> <td>π/2</td> </tr> <tr>
<td>&lt;0.0</td> <td>±0.0</td> <td>-π/2</td> </tr> <tr>
<td>&gt;0.0</td> <td>∞</td> <td>±0.0</td> </tr> <tr>
<td>±∞</td> <td>anything</td> <td>±π/2</td>
</tr> <tr>
<td>&gt;0.0</td> <td>-∞</td> <td>±π</td> </tr> <tr>
<td>±∞</td> <td>∞</td> <td>±π/4</td>
</tr> <tr>
<td>±∞</td> <td>-∞</td> <td>±3π/4</td>
</tr> </table> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(atan2(1.0, sqrt(3.0)).approxEqual(PI / 6));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="cosh">pure nothrow @nogc @safe real <strong id="cosh">cosh</strong>(real x); <br><br>pure nothrow @nogc @safe double <strong id="cosh">cosh</strong>(double x); <br><br>pure nothrow @nogc @safe float <strong id="cosh">cosh</strong>(float x); </dt> <dd>
<p>Calculates the hyperbolic cosine of x. </p>
<p></p>
<table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">cosh(x)</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>±∞</td> <td>±0.0</td> <td>no</td> </tr> </table> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(cosh(0.0)); // 1.0
assert(cosh(1.0).approxEqual((E + 1.0 / E) / 2));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="sinh">pure nothrow @nogc @safe real <strong id="sinh">sinh</strong>(real x); <br><br>pure nothrow @nogc @safe double <strong id="sinh">sinh</strong>(double x); <br><br>pure nothrow @nogc @safe float <strong id="sinh">sinh</strong>(float x); </dt> <dd>
<p>Calculates the hyperbolic sine of x. </p>
<p></p>
<table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">sinh(x)</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>±0.0</td> <td>±0.0</td> <td>no</td>
</tr> <tr>
<td>±∞</td> <td>±∞</td> <td>no</td>
</tr> </table> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(isIdentical(sinh(0.0), 0.0));
assert(sinh(1.0).approxEqual((E - 1.0 / E) / 2));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="tanh">pure nothrow @nogc @safe real <strong id="tanh">tanh</strong>(real x); <br><br>pure nothrow @nogc @safe double <strong id="tanh">tanh</strong>(double x); <br><br>pure nothrow @nogc @safe float <strong id="tanh">tanh</strong>(float x); </dt> <dd>
<p>Calculates the hyperbolic tangent of x. </p>
<p></p>
<table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">tanh(x)</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>±0.0</td> <td>±0.0</td> <td>no</td> </tr> <tr>
<td>±∞</td> <td>±1.0</td> <td>no</td>
</tr> </table> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(isIdentical(tanh(0.0), 0.0));
assert(tanh(1.0).approxEqual(sinh(1.0) / cosh(1.0)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="acosh">pure nothrow @nogc @safe real <strong id="acosh">acosh</strong>(real x); <br><br>pure nothrow @nogc @safe double <strong id="acosh">acosh</strong>(double x); <br><br>pure nothrow @nogc @safe float <strong id="acosh">acosh</strong>(float x); </dt> <dd>
<p>Calculates the inverse hyperbolic cosine of x. </p>
<p>Mathematically, acosh(x) = log(x + sqrt( x*x - 1)) <br><br> </p>
<table> <tr>
<th scope="col">Domain X</th> <th scope="col">Range Y</th>
</tr> <tr>
<td> 1..∞</td> <td> 0..∞ </td>
</tr> </table> <br><br> <table> <caption>Special Values</caption> <tr>
<th scope="col"> x</th> <th scope="col"> acosh(x) </th>
</tr> <tr>
<td> <span class="red">NAN</span>
</td> <td>
<span class="red">NAN</span> </td>
</tr> <tr>
<td> &lt;1</td> <td> <span class="red">NAN</span> </td>
</tr> <tr>
<td> 1</td> <td> 0 </td>
</tr> <tr>
<td> +∞</td> <td>+∞</td>
</tr> </table> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(isNaN(acosh(0.9)));
assert(isNaN(acosh(real.nan)));
assert(isIdentical(acosh(1.0), 0.0));
writeln(acosh(real.infinity)); // real.infinity
assert(isNaN(acosh(0.5)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="asinh">pure nothrow @nogc @safe real <strong id="asinh">asinh</strong>(real x); <br><br>pure nothrow @nogc @safe double <strong id="asinh">asinh</strong>(double x); <br><br>pure nothrow @nogc @safe float <strong id="asinh">asinh</strong>(float x); </dt> <dd>
<p>Calculates the inverse hyperbolic sine of x. </p>
<p> Mathematically, </p>
<pre data-language="d">asinh(x) =  log( x + sqrt( x*x + 1 )) // if x &gt;= +0
asinh(x) = -log(-x + sqrt( x*x + 1 )) // if x &lt;= -0
</pre> <br><br> <table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col"> asinh(x) </th>
</tr> <tr>
<td> <span class="red">NAN</span>
</td> <td> <span class="red">NAN</span> </td>
</tr> <tr>
<td> ±0</td> <td> ±0 </td>
</tr> <tr>
<td> ±∞</td> <td>±∞</td>
</tr> </table> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(isIdentical(asinh(0.0), 0.0));
assert(isIdentical(asinh(-0.0), -0.0));
writeln(asinh(real.infinity)); // real.infinity
writeln(asinh(-real.infinity)); // -real.infinity
assert(isNaN(asinh(real.nan)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="atanh">pure nothrow @nogc @safe real <strong id="atanh">atanh</strong>(real x); <br><br>pure nothrow @nogc @safe double <strong id="atanh">atanh</strong>(double x); <br><br>pure nothrow @nogc @safe float <strong id="atanh">atanh</strong>(float x); </dt> <dd>
<p>Calculates the inverse hyperbolic tangent of x, returning a value from ranging from -1 to 1. </p>
<p>Mathematically, atanh(x) = log( (1+x)/(1-x) ) / 2 <br><br> </p>
<table> <tr>
<th scope="col">Domain X</th> <th scope="col">Range Y</th>
</tr> <tr>
<td> -∞..∞</td> <td> -1 .. 1 </td>
</tr> </table> <br> <table> <caption>Special Values</caption> <tr>
<th scope="col"> x</th> <th scope="col"> acosh(x) </th>
</tr> <tr>
<td> <span class="red">NAN</span>
</td> <td>
<span class="red">NAN</span> </td>
</tr> <tr>
<td> ±0</td> <td>±0</td>
</tr> <tr>
<td> -∞</td> <td>-0</td>
</tr> </table> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(isIdentical(atanh(0.0), 0.0));
assert(isIdentical(atanh(-0.0),-0.0));
assert(isNaN(atanh(real.nan)));
assert(isNaN(atanh(-real.infinity)));
writeln(atanh(0.0)); // 0
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="rndtol">pure nothrow @nogc @safe long <strong id="rndtol">rndtol</strong>(real x); <br><br>pure nothrow @nogc @safe long <strong id="rndtol">rndtol</strong>(double x); <br><br>pure nothrow @nogc @safe long <strong id="rndtol">rndtol</strong>(float x); </dt> <dd>
<p>Returns x rounded to a long value using the current rounding mode. If the integer value of x is greater than long.max, the result is indeterminate.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(rndtol(1.0)); // 1L
writeln(rndtol(1.2)); // 1L
writeln(rndtol(1.7)); // 2L
writeln(rndtol(1.0001)); // 1L
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="rndtonl">deprecated real <strong id="rndtonl">rndtonl</strong>(real x); </dt> <dd>
<p><span class="red">Deprecated. Please use <a href="#round"><code>round</code></a> instead.</span> </p>
<p>Returns <code>x</code> rounded to a <code>long</code> value using the <code>FE_TONEAREST</code> rounding mode. If the integer value of <code>x</code> is greater than <code>long.max</code>, the result is indeterminate. <br><br> Only works with the Digital Mars C Runtime. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>real <code>x</code>
</td> <td>the number to round</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>x</code> rounded to an integer value</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">version (CRuntime_DigitalMars)
{
    assert(rndtonl(1.0) is -real.nan);
    assert(rndtonl(1.2) is -real.nan);
    assert(rndtonl(1.7) is -real.nan);
    assert(rndtonl(1.0001) is -real.nan);
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="sqrt">pure nothrow @nogc @safe float <strong id="sqrt">sqrt</strong>(float x); <br><br>pure nothrow @nogc @safe double <strong id="sqrt">sqrt</strong>(double x); <br><br>pure nothrow @nogc @safe real <strong id="sqrt">sqrt</strong>(real x); </dt> <dd>
<p>Compute square root of x. </p>
<p></p>
<table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">sqrt(x)</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>-0.0</td> <td>-0.0</td> <td>no</td>
</tr> <tr>
<td>&lt;0.0</td> <td><span class="red">NAN</span></td> <td>yes</td>
</tr> <tr>
<td>+∞</td> <td>+∞</td> <td>no</td>
</tr> </table> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(sqrt(2.0).feqrel(1.4142) &gt; 16);
assert(sqrt(9.0).feqrel(3.0) &gt; 16);

assert(isNaN(sqrt(-1.0f)));
assert(isNaN(sqrt(-1.0)));
assert(isNaN(sqrt(-1.0L)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="exp">pure nothrow @nogc @trusted real <strong id="exp">exp</strong>(real x); <br><br>pure nothrow @nogc @safe double <strong id="exp">exp</strong>(double x); <br><br>pure nothrow @nogc @safe float <strong id="exp">exp</strong>(float x); </dt> <dd>
<p>Calculates e<sup>x</sup>. </p>
<p></p>
<table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">e<sup>x</sup>
</th> </tr> <tr>
<td>+∞</td> <td>+∞</td> </tr> <tr>
<td>-∞</td> <td>+0.0</td> </tr> <tr>
<td><span class="red">NAN</span></td> <td><span class="red">NAN</span></td> </tr> </table> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(exp(0.0)); // 1.0
assert(exp(3.0).feqrel(E * E * E) &gt; 16);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="expm1">pure nothrow @nogc @trusted real <strong id="expm1">expm1</strong>(real x); <br><br>pure nothrow @nogc @safe double <strong id="expm1">expm1</strong>(double x); <br><br>pure nothrow @nogc @safe float <strong id="expm1">expm1</strong>(float x); </dt> <dd>
<p>Calculates the value of the natural logarithm base (e) raised to the power of x, minus 1. </p>
<p>For very small x, expm1(x) is more accurate than exp(x)-1. <br><br> </p>
<table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">e<sup>x</sup>-1</th> </tr> <tr>
<td>±0.0</td> <td>±0.0</td> </tr> <tr>
<td>+∞</td> <td>+∞</td> </tr> <tr>
<td>-∞</td> <td>-1.0</td> </tr> <tr>
<td><span class="red">NAN</span></td> <td><span class="red">NAN</span></td> </tr> </table> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(isIdentical(expm1(0.0), 0.0));
assert(expm1(1.0).feqrel(1.71828) &gt; 16);
assert(expm1(2.0).feqrel(6.3890) &gt; 16);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="exp2">pure nothrow @nogc @trusted real <strong id="exp2">exp2</strong>(real x); <br><br>pure nothrow @nogc @safe double <strong id="exp2">exp2</strong>(double x); <br><br>pure nothrow @nogc @safe float <strong id="exp2">exp2</strong>(float x); </dt> <dd>
<p>Calculates 2<sup>x</sup>. </p>
<p></p>
<table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">exp2(x)</th> </tr> <tr>
<td>+∞</td> <td>+∞</td> </tr> <tr>
<td>-∞</td> <td>+0.0</td> </tr> <tr>
<td><span class="red">NAN</span></td> <td><span class="red">NAN</span></td> </tr> </table> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(isIdentical(exp2(0.0), 1.0));
assert(exp2(2.0).feqrel(4.0) &gt; 16);
assert(exp2(8.0).feqrel(256.0) &gt; 16);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="frexp">pure nothrow @nogc @trusted T <strong id="frexp">frexp</strong>(T)(const T value, out int exp)<br><small>  Constraints: if (isFloatingPoint!T); </small>
</dt> <dd>
<p>Separate floating point value into significand and exponent. </p>
<dl>
<dt>Returns:</dt>
<dd>Calculate and return <i>x</i> and <i>exp</i> such that value =<i>x</i>*2<sup>exp</sup> and .5 &lt;= |<i>x</i>| &lt; 1.0  <i>x</i> has same sign as value.  <table> <caption>Special Values</caption> <tr>
<th scope="col">value</th> <th scope="col">returns</th> <th scope="col">exp</th>
</tr> <tr>
<td>±0.0</td> <td>±0.0</td> <td>0</td>
</tr> <tr>
<td>+∞</td> <td>+∞</td> <td>int.max</td>
</tr> <tr>
<td>-∞</td> <td>-∞</td> <td>int.min</td>
</tr> <tr>
<td>±<span class="red">NAN</span>
</td> <td>±<span class="red">NAN</span>
</td> <td>int.min</td>
</tr> </table>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int exp;
real mantissa = frexp(123.456L, exp);

assert(approxEqual(mantissa * pow(2.0L, cast(real) exp), 123.456L));

assert(frexp(-real.nan, exp) &amp;&amp; exp == int.min);
assert(frexp(real.nan, exp) &amp;&amp; exp == int.min);
assert(frexp(-real.infinity, exp) == -real.infinity &amp;&amp; exp == int.min);
assert(frexp(real.infinity, exp) == real.infinity &amp;&amp; exp == int.max);
assert(frexp(-0.0, exp) == -0.0 &amp;&amp; exp == 0);
assert(frexp(0.0, exp) == 0.0 &amp;&amp; exp == 0);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="ilogb">pure nothrow @nogc @trusted int <strong id="ilogb">ilogb</strong>(T)(const T x)<br><small>  Constraints: if (isFloatingPoint!T); </small><br><br>pure nothrow @nogc @safe int <strong id="ilogb">ilogb</strong>(T)(const T x)<br><small>  Constraints: if (isIntegral!T &amp;&amp; isUnsigned!T); </small><br><br>pure nothrow @nogc @safe int <strong id="ilogb">ilogb</strong>(T)(const T x)<br><small>  Constraints: if (isIntegral!T &amp;&amp; isSigned!T); </small>
</dt> <dd>
<p>Extracts the exponent of x as a signed integral value. </p>
<p>If x is not a special value, the result is the same as <code>cast(int) logb(x)</code>. <br><br> </p>
<table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">ilogb(x)</th> <th scope="col">Range error?</th>
</tr> <tr>
<td>0</td> <td>FP_ILOGB0</td> <td>yes</td>
</tr> <tr>
<td>±∞</td> <td>int.max</td> <td>no</td>
</tr> <tr>
<td><span class="red">NAN</span></td> <td>FP_ILOGBNAN</td> <td>no</td>
</tr> </table> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(ilogb(1)); // 0
writeln(ilogb(3)); // 1
writeln(ilogb(3.0)); // 1
writeln(ilogb(100_000_000)); // 26

writeln(ilogb(0)); // FP_ILOGB0
writeln(ilogb(0.0)); // FP_ILOGB0
writeln(ilogb(double.nan)); // FP_ILOGBNAN
writeln(ilogb(double.infinity)); // int.max
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="FP_ILOGB0">alias <strong id="FP_ILOGB0">FP_ILOGB0</strong> = core.stdc.math.<strong id="FP_ILOGB0">FP_ILOGB0</strong>; <br><br>alias <strong id="FP_ILOGBNAN">FP_ILOGBNAN</strong> = core.stdc.math.<strong id="FP_ILOGBNAN">FP_ILOGBNAN</strong>; </dt> <dd>
<p>Special return values of <a href="#ilogb"><code>ilogb</code></a>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(ilogb(0)); // FP_ILOGB0
writeln(ilogb(0.0)); // FP_ILOGB0
writeln(ilogb(double.nan)); // FP_ILOGBNAN
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="ldexp">pure nothrow @nogc @safe real <strong id="ldexp">ldexp</strong>(real n, int exp); <br><br>pure nothrow @nogc @safe double <strong id="ldexp">ldexp</strong>(double n, int exp); <br><br>pure nothrow @nogc @safe float <strong id="ldexp">ldexp</strong>(float n, int exp); </dt> <dd>
<p>Compute n * 2<sup>exp</sup> </p>
<dl>
<dt>References</dt>
<dd> frexp</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.meta : AliasSeq;
static foreach (T; AliasSeq!(float, double, real))
{{
    T r;

    r = ldexp(3.0L, 3);
    writeln(r); // 24

    r = ldexp(cast(T) 3.0, cast(int) 3);
    writeln(r); // 24

    T n = 3.0;
    int exp = 3;
    r = ldexp(n, exp);
    writeln(r); // 24
}}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="log">pure nothrow @nogc @safe real <strong id="log">log</strong>(real x); </dt> <dd>
<p>Calculate the natural logarithm of x. </p>
<p></p>
<table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">log(x)</th> <th scope="col">divide by 0?</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>±0.0</td> <td>-∞</td> <td>yes</td> <td>no</td>
</tr> <tr>
<td>&lt;0.0</td> <td><span class="red">NAN</span></td> <td>no</td> <td>yes</td>
</tr> <tr>
<td>+∞</td> <td>+∞</td> <td>no</td> <td>no</td>
</tr> </table> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(feqrel(log(E), 1) &gt;= real.mant_dig - 1);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="log10">pure nothrow @nogc @safe real <strong id="log10">log10</strong>(real x); </dt> <dd>
<p>Calculate the base-10 logarithm of x. </p>
<p></p>
<table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">log10(x)</th> <th scope="col">divide by 0?</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>±0.0</td> <td>-∞</td> <td>yes</td> <td>no</td>
</tr> <tr>
<td>&lt;0.0</td> <td><span class="red">NAN</span></td> <td>no</td> <td>yes</td>
</tr> <tr>
<td>+∞</td> <td>+∞</td> <td>no</td> <td>no</td>
</tr> </table> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(fabs(log10(1000) - 3) &lt; .000001);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="log1p">pure nothrow @nogc @safe real <strong id="log1p">log1p</strong>(real x); </dt> <dd>
<p>Calculates the natural logarithm of 1 + x. </p>
<p>For very small x, log1p(x) will be more accurate than log(1 + x). <br><br> </p>
<table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">log1p(x)</th> <th scope="col">divide by 0?</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>±0.0</td> <td>±0.0</td> <td>no</td> <td>no</td>
</tr> <tr>
<td>-1.0</td> <td>-∞</td> <td>yes</td> <td>no</td>
</tr> <tr>
<td>&lt;-1.0</td> <td>-<span class="red">NAN</span>
</td> <td>no</td> <td>yes</td>
</tr> <tr>
<td>+∞</td> <td>+∞</td> <td>no</td> <td>no</td>
</tr> </table> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(isIdentical(log1p(0.0), 0.0));
assert(log1p(1.0).feqrel(0.69314) &gt; 16);

writeln(log1p(-1.0)); // -real.infinity
assert(isNaN(log1p(-2.0)));
assert(log1p(real.nan) is real.nan);
assert(log1p(-real.nan) is -real.nan);
writeln(log1p(real.infinity)); // real.infinity
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="log2">pure nothrow @nogc @safe real <strong id="log2">log2</strong>(real x); </dt> <dd>
<p>Calculates the base-2 logarithm of x: log<sub>2</sub>x </p>
<p></p>
<table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">log2(x)</th> <th scope="col">divide by 0?</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>±0.0</td> <td>-∞</td> <td>yes</td> <td>no</td> </tr> <tr>
<td>&lt;0.0</td> <td><span class="red">NAN</span></td> <td>no</td> <td>yes</td> </tr> <tr>
<td>+∞</td> <td>+∞</td> <td>no</td> <td>no</td> </tr> </table> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(approxEqual(log2(1024.0L), 10));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="logb">nothrow @nogc @trusted real <strong id="logb">logb</strong>(real x); </dt> <dd>
<p>Extracts the exponent of x as a signed integral value. </p>
<p>If x is subnormal, it is treated as if it were normalized. For a positive, finite x: <br><br> 1 &lt;= <i>x</i> * FLT_RADIX<sup>-logb(x)</sup> &lt; FLT_RADIX <br><br> </p>
<table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">logb(x)</th> <th scope="col">divide by 0?</th> </tr> <tr>
<td>±∞</td> <td>+∞</td> <td>no</td>
</tr> <tr>
<td>±0.0</td> <td>-∞</td> <td>yes</td> </tr> </table> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(logb(1.0)); // 0
writeln(logb(100.0)); // 6

writeln(logb(0.0)); // -real.infinity
writeln(logb(real.infinity)); // real.infinity
writeln(logb(-real.infinity)); // real.infinity
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="fmod">nothrow @nogc @trusted real <strong id="fmod">fmod</strong>(real x, real y); </dt> <dd>
<p>Calculates the remainder from the calculation x/y. </p>
<dl>
<dt>Returns:</dt>
<dd>The value of x - i * y, where i is the number of times that y can be completely subtracted from x. The result has the same sign as x.  <table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">y</th> <th scope="col">fmod(x, y)</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>±0.0</td> <td>not 0.0</td> <td>±0.0</td> <td>no</td>
</tr> <tr>
<td>±∞</td> <td>anything</td> <td><span class="red">NAN</span></td> <td>yes</td>
</tr> <tr>
<td>anything</td> <td>±0.0</td> <td><span class="red">NAN</span></td> <td>yes</td>
</tr> <tr>
<td>!=±∞</td> <td>±∞</td> <td>x</td> <td>no</td>
</tr> </table>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(isIdentical(fmod(0.0, 1.0), 0.0));
assert(fmod(5.0, 3.0).feqrel(2.0) &gt; 16);
assert(isNaN(fmod(5.0, 0.0)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="modf">nothrow @nogc @trusted real <strong id="modf">modf</strong>(real x, ref real i); </dt> <dd>
<p>Breaks x into an integral part and a fractional part, each of which has the same sign as x. The integral part is stored in i. </p>
<dl>
<dt>Returns:</dt>
<dd>The fractional part of x.  <table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">i (on input)</th> <th scope="col">modf(x, i)</th> <th scope="col">i (on return)</th>
</tr> <tr>
<td>±∞</td> <td>anything</td> <td>±0.0</td> <td>±∞</td>
</tr> </table>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">real frac;
real intpart;

frac = modf(3.14159, intpart);
assert(intpart.feqrel(3.0) &gt; 16);
assert(frac.feqrel(0.14159) &gt; 16);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="scalbn">nothrow @nogc @trusted real <strong id="scalbn">scalbn</strong>(real x, int n); </dt> <dd>
<p>Efficiently calculates x * 2<sup>n</sup>. </p>
<p>scalbn handles underflow and overflow in the same fashion as the basic arithmetic operators. <br><br> </p>
<table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">scalb(x)</th>
</tr> <tr>
<td>±∞</td> <td>±∞</td> </tr> <tr>
<td>±0.0</td> <td>±0.0</td> </tr> </table> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(scalbn(-real.infinity, 5)); // -real.infinity
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="cbrt">nothrow @nogc @trusted real <strong id="cbrt">cbrt</strong>(real x); </dt> <dd>
<p>Calculates the cube root of x. </p>
<p></p>
<table> <caption>Special Values</caption> <tr>
<th scope="col"><i>x</i></th> <th scope="col">cbrt(x)</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>±0.0</td> <td>±0.0</td> <td>no</td> </tr> <tr>
<td><span class="red">NAN</span></td> <td><span class="red">NAN</span></td> <td>yes</td> </tr> <tr>
<td>±∞</td> <td>±∞</td> <td>no</td> </tr> </table> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(cbrt(1.0).feqrel(1.0) &gt; 16);
assert(cbrt(27.0).feqrel(3.0) &gt; 16);
assert(cbrt(15.625).feqrel(2.5) &gt; 16);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="fabs">pure nothrow @nogc @safe real <strong id="fabs">fabs</strong>(real x); <br><br>pure nothrow @nogc @safe double <strong id="fabs">fabs</strong>(double x); <br><br>pure nothrow @nogc @safe float <strong id="fabs">fabs</strong>(float x); </dt> <dd>
<p>Returns |x| </p>
<p></p>
<table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">fabs(x)</th>
</tr> <tr>
<td>±0.0</td> <td>+0.0</td> </tr> <tr>
<td>±∞</td> <td>+∞</td> </tr> </table> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(isIdentical(fabs(0.0), 0.0));
assert(isIdentical(fabs(-0.0), 0.0));
writeln(fabs(-10.0)); // 10.0
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="hypot">pure nothrow @nogc @safe real <strong id="hypot">hypot</strong>(real x, real y); </dt> <dd>
<p>Calculates the length of the hypotenuse of a right-angled triangle with sides of length x and y. The hypotenuse is the value of the square root of the sums of the squares of x and y: </p>
<p>sqrt(x<sup>2</sup> + y<sup>2</sup>) <br><br> Note that hypot(x, y), hypot(y, x) and hypot(x, -y) are equivalent. <br><br> </p>
<table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">y</th> <th scope="col">hypot(x, y)</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>x</td> <td>±0.0</td> <td>|x|</td> <td>no</td>
</tr> <tr>
<td>±∞</td> <td>y</td> <td>+∞</td> <td>no</td>
</tr> <tr>
<td>±∞</td> <td><span class="red">NAN</span></td> <td>+∞</td> <td>no</td>
</tr> </table> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(hypot(1.0, 1.0).feqrel(1.4142) &gt; 16);
assert(hypot(3.0, 4.0).feqrel(5.0) &gt; 16);
writeln(hypot(real.infinity, 1.0)); // real.infinity
writeln(hypot(real.infinity, real.nan)); // real.infinity
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="ceil">pure nothrow @nogc @trusted real <strong id="ceil">ceil</strong>(real x); <br><br>pure nothrow @nogc @trusted double <strong id="ceil">ceil</strong>(double x); <br><br>pure nothrow @nogc @trusted float <strong id="ceil">ceil</strong>(float x); </dt> <dd>
<p>Returns the value of x rounded upward to the next integer (toward positive infinity).</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(ceil(+123.456L)); // +124
writeln(ceil(-123.456L)); // -123
writeln(ceil(-1.234L)); // -1
writeln(ceil(-0.123L)); // 0
writeln(ceil(0.0L)); // 0
writeln(ceil(+0.123L)); // 1
writeln(ceil(+1.234L)); // 2
writeln(ceil(real.infinity)); // real.infinity
assert(isNaN(ceil(real.nan)));
assert(isNaN(ceil(real.init)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="floor">pure nothrow @nogc @trusted real <strong id="floor">floor</strong>(real x); <br><br>pure nothrow @nogc @trusted double <strong id="floor">floor</strong>(double x); <br><br>pure nothrow @nogc @trusted float <strong id="floor">floor</strong>(float x); </dt> <dd>
<p>Returns the value of x rounded downward to the next integer (toward negative infinity).</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(floor(+123.456L)); // +123
writeln(floor(-123.456L)); // -124
writeln(floor(+123.0L)); // +123
writeln(floor(-124.0L)); // -124
writeln(floor(-1.234L)); // -2
writeln(floor(-0.123L)); // -1
writeln(floor(0.0L)); // 0
writeln(floor(+0.123L)); // 0
writeln(floor(+1.234L)); // 1
writeln(floor(real.infinity)); // real.infinity
assert(isNaN(floor(real.nan)));
assert(isNaN(floor(real.init)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="quantize">Unqual!F <strong id="quantize">quantize</strong>(alias rfunc = rint, F)(const F val, const F unit)<br><small>  Constraints: if (is(typeof(rfunc(F.init)) : F) &amp;&amp; isFloatingPoint!F); </small>
</dt> <dd>
<p>Round <code>val</code> to a multiple of <code>unit</code>. <code>rfunc</code> specifies the rounding function to use; by default this is <code>rint</code>, which uses the current rounding mode.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(12345.6789L.quantize(0.01L)); // 12345.68L
writeln(12345.6789L.quantize!floor(0.01L)); // 12345.67L
writeln(12345.6789L.quantize(22.0L)); // 12342.0L
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(12345.6789L.quantize(0)); // 12345.6789L
assert(12345.6789L.quantize(real.infinity).isNaN);
assert(12345.6789L.quantize(real.nan).isNaN);
writeln(real.infinity.quantize(0.01L)); // real.infinity
assert(real.infinity.quantize(real.nan).isNaN);
assert(real.nan.quantize(0.01L).isNaN);
assert(real.nan.quantize(real.infinity).isNaN);
assert(real.nan.quantize(real.nan).isNaN);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="quantize.2">Unqual!F <strong id="quantize">quantize</strong>(real base, alias rfunc = rint, F, E)(const F val, const E exp)<br><small>  Constraints: if (is(typeof(rfunc(F.init)) : F) &amp;&amp; isFloatingPoint!F &amp;&amp; isIntegral!E); </small><br><br>Unqual!F <strong id="quantize">quantize</strong>(real base, long exp = 1, alias rfunc = rint, F)(const F val)<br><small>  Constraints: if (is(typeof(rfunc(F.init)) : F) &amp;&amp; isFloatingPoint!F); </small>
</dt> <dd>
<p>Round <code>val</code> to a multiple of <code>pow(base, exp)</code>. <code>rfunc</code> specifies the rounding function to use; by default this is <code>rint</code>, which uses the current rounding mode.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(12345.6789L.quantize!10(-2)); // 12345.68L
writeln(12345.6789L.quantize!(10, -2)); // 12345.68L
writeln(12345.6789L.quantize!(10, floor)(-2)); // 12345.67L
writeln(12345.6789L.quantize!(10, -2, floor)); // 12345.67L

writeln(12345.6789L.quantize!22(1)); // 12342.0L
writeln(12345.6789L.quantize!22); // 12342.0L
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="nearbyint">pure nothrow @nogc @safe real <strong id="nearbyint">nearbyint</strong>(real x); </dt> <dd>
<p>Rounds x to the nearest integer value, using the current rounding mode. </p>
<p>Unlike the rint functions, nearbyint does not raise the FE_INEXACT exception. </p> <dl>
<dt>Note</dt>
<dd> Not implemented for Microsoft C Runtime</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">version (CRuntime_Microsoft) {}
else
{
    writeln(nearbyint(0.4)); // 0
    writeln(nearbyint(0.5)); // 0
    writeln(nearbyint(0.6)); // 1
    writeln(nearbyint(100.0)); // 100

    assert(isNaN(nearbyint(real.nan)));
    writeln(nearbyint(real.infinity)); // real.infinity
    writeln(nearbyint(-real.infinity)); // -real.infinity
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="rint">pure nothrow @nogc @safe real <strong id="rint">rint</strong>(real x); <br><br>pure nothrow @nogc @safe double <strong id="rint">rint</strong>(double x); <br><br>pure nothrow @nogc @safe float <strong id="rint">rint</strong>(float x); </dt> <dd>
<p>Rounds x to the nearest integer value, using the current rounding mode. </p>
<p>If the return value is not equal to x, the FE_INEXACT exception is raised. <br><br> <a href="#nearbyint"><code>nearbyint</code></a> performs the same operation, but does not set the FE_INEXACT exception.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">version (InlineAsm_X86_Any)
{
    resetIeeeFlags();
    writeln(rint(0.4)); // 0
    assert(ieeeFlags.inexact);

    writeln(rint(0.5)); // 0
    writeln(rint(0.6)); // 1
    writeln(rint(100.0)); // 100

    assert(isNaN(rint(real.nan)));
    writeln(rint(real.infinity)); // real.infinity
    writeln(rint(-real.infinity)); // -real.infinity
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="lrint">pure nothrow @nogc @trusted long <strong id="lrint">lrint</strong>(real x); </dt> <dd>
<p>Rounds x to the nearest integer value, using the current rounding mode. </p>
<p>This is generally the fastest method to convert a floating-point number to an integer. Note that the results from this function depend on the rounding mode, if the fractional part of x is exactly 0.5. If using the default rounding mode (ties round to even integers) lrint(4.5) == 4, lrint(5.5)==6.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(lrint(4.5)); // 4
writeln(lrint(5.5)); // 6
writeln(lrint(-4.5)); // -4
writeln(lrint(-5.5)); // -6

writeln(lrint(int.max - 0.5)); // 2147483646L
writeln(lrint(int.max + 0.5)); // 2147483648L
writeln(lrint(int.min - 0.5)); // -2147483648L
writeln(lrint(int.min + 0.5)); // -2147483648L
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="round">nothrow @nogc @trusted auto <strong id="round">round</strong>(real x); </dt> <dd>
<p>Return the value of x rounded to the nearest integer. If the fractional part of x is exactly 0.5, the return value is rounded away from zero. </p>
<dl>
<dt>Returns:</dt>
<dd>A <code>real</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(round(4.5)); // 5
writeln(round(5.4)); // 5
writeln(round(-4.5)); // -5
writeln(round(-5.1)); // -5
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="lround">nothrow @nogc @trusted long <strong id="lround">lround</strong>(real x); </dt> <dd>
<p>Return the value of x rounded to the nearest integer. </p>
<p>If the fractional part of x is exactly 0.5, the return value is rounded away from zero. <br><br> <span class="blue">This function is Posix-Only.</span></p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">version (Posix)
{
    writeln(lround(0.49)); // 0
    writeln(lround(0.5)); // 1
    writeln(lround(1.5)); // 2
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="trunc">pure nothrow @nogc @trusted real <strong id="trunc">trunc</strong>(real x); </dt> <dd>
<p>Returns the integer portion of x, dropping the fractional portion. This is also known as "chop" rounding. <code>pure</code> on all platforms.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(trunc(0.01)); // 0
writeln(trunc(0.49)); // 0
writeln(trunc(0.5)); // 0
writeln(trunc(1.5)); // 1
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="remainder">nothrow @nogc @trusted real <strong id="remainder">remainder</strong>(real x, real y); <br><br>nothrow @nogc @trusted real <strong id="remquo">remquo</strong>(real x, real y, out int n); </dt> <dd>
<p>Calculate the remainder x REM y, following IEC 60559. </p>
<p>REM is the value of x - y * n, where n is the integer nearest the exact value of x / y. If |n - x / y| == 0.5, n is even. If the result is zero, it has the same sign as x. Otherwise, the sign of the result is the sign of x / y. Precision mode has no effect on the remainder functions. <br><br> remquo returns <code>n</code> in the parameter <code>n</code>. <br><br> </p>
<table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">y</th> <th scope="col">remainder(x, y)</th> <th scope="col">n</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>±0.0</td> <td>not 0.0</td> <td>±0.0</td> <td>0.0</td> <td>no</td>
</tr> <tr>
<td>±∞</td> <td>anything</td> <td>-<span class="red">NAN</span>
</td> <td>?</td> <td>yes</td>
</tr> <tr>
<td>anything</td> <td>±0.0</td> <td>±<span class="red">NAN</span>
</td> <td>?</td> <td>yes</td>
</tr> <tr>
<td>!= ±∞</td> <td>±∞</td> <td>x</td> <td>?</td> <td>no</td>
</tr> </table> <br><br> <span class="blue"><code>remquo</code> and <code>remainder</code> not supported on Windows.</span> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">version (Posix)
{
    assert(remainder(5.1, 3.0).feqrel(-0.9) &gt; 16);
    assert(remainder(-5.1, 3.0).feqrel(0.9) &gt; 16);
    writeln(remainder(0.0, 3.0)); // 0.0

    assert(isNaN(remainder(1.0, 0.0)));
    assert(isNaN(remainder(-1.0, 0.0)));
}
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">version (Posix)
{
    int n;

    assert(remquo(5.1, 3.0, n).feqrel(-0.9) &gt; 16 &amp;&amp; n == 2);
    assert(remquo(-5.1, 3.0, n).feqrel(0.9) &gt; 16 &amp;&amp; n == -2);
    assert(remquo(0.0, 3.0, n) == 0.0 &amp;&amp; n == 0);
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="IeeeFlags">struct <strong id="IeeeFlags">IeeeFlags</strong>; </dt> <dd>
<p>IEEE exception status flags ('sticky bits') </p>
<p>These flags indicate that an exceptional floating-point condition has occurred. They indicate that a NaN or an infinity has been generated, that a result is inexact, or that a signalling NaN has been encountered. If floating-point exceptions are enabled (unmasked), a hardware exception will be generated instead of setting these flags.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">version (InlineAsm_X86_Any)
{
    static void func() {
        int a = 10 * 10;
    }

    real a = 3.5;
    // Set all the flags to zero
    resetIeeeFlags();
    assert(!ieeeFlags.divByZero);
    // Perform a division by zero.
    a /= 0.0L;
    writeln(a); // real.infinity
    assert(ieeeFlags.divByZero);
    // Create a NaN
    a *= 0.0L;
    assert(ieeeFlags.invalid);
    assert(isNaN(a));

    // Check that calling func() has no effect on the
    // status flags.
    IeeeFlags f = ieeeFlags;
    func();
    writeln(ieeeFlags); // f
}
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="IeeeFlags.inexact">const nothrow @nogc @property @safe bool <strong id="inexact">inexact</strong>(); </dt> <dd>
<p>The result cannot be represented exactly, so rounding occurred. </p>
<dl>
<dt>Example</dt>
<dd> <code>x = sin(0.1);</code>
</dd>
</dl> </dd> <dt class="d_decl" id="IeeeFlags.underflow">const nothrow @nogc @property @safe bool <strong id="underflow">underflow</strong>(); </dt> <dd>
<p>A zero was generated by underflow </p>
<dl>
<dt>Example</dt>
<dd> <code>x = real.min*real.epsilon/2;</code>
</dd>
</dl> </dd> <dt class="d_decl" id="IeeeFlags.overflow">const nothrow @nogc @property @safe bool <strong id="overflow">overflow</strong>(); </dt> <dd>
<p>An infinity was generated by overflow </p>
<dl>
<dt>Example</dt>
<dd> <code>x = real.max*2;</code>
</dd>
</dl> </dd> <dt class="d_decl" id="IeeeFlags.divByZero">const nothrow @nogc @property @safe bool <strong id="divByZero">divByZero</strong>(); </dt> <dd>
<p>An infinity was generated by division by zero </p>
<dl>
<dt>Example</dt>
<dd> <code>x = 3/0.0;</code>
</dd>
</dl> </dd> <dt class="d_decl" id="IeeeFlags.invalid">const nothrow @nogc @property @safe bool <strong id="invalid">invalid</strong>(); </dt> <dd>
<p>A machine NaN was generated. </p>
<dl>
<dt>Example</dt>
<dd> <code>x = real.infinity * 0.0;</code>
</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="resetIeeeFlags">nothrow @nogc @trusted void <strong id="resetIeeeFlags">resetIeeeFlags</strong>(); </dt> <dd>
<p>Set all of the floating-point status flags to false.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">version (InlineAsm_X86_Any)
{
    resetIeeeFlags();
    real a = 3.5;
    a /= 0.0L;
    writeln(a); // real.infinity
    assert(ieeeFlags.divByZero);

    resetIeeeFlags();
    assert(!ieeeFlags.divByZero);
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="ieeeFlags">pure nothrow @nogc @property @trusted IeeeFlags <strong id="ieeeFlags">ieeeFlags</strong>(); </dt> <dd>
<dl>
<dt>Returns:</dt>
<dd>snapshot of the current state of the floating-point status flags</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">version (InlineAsm_X86_Any)
{
    resetIeeeFlags();
    real a = 3.5;

    a /= 0.0L;
    writeln(a); // real.infinity
    assert(ieeeFlags.divByZero);

    a *= 0.0L;
    assert(isNaN(a));
    assert(ieeeFlags.invalid);
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="FloatingPointControl">struct <strong id="FloatingPointControl">FloatingPointControl</strong>; </dt> <dd>
<p>Control the Floating point hardware </p>
<p>Change the IEEE754 floating-point rounding mode and the floating-point hardware exceptions. <br><br> By default, the rounding mode is roundToNearest and all hardware exceptions are disabled. For most applications, debugging is easier if the <i>division by zero</i>, <i>overflow</i>, and <i>invalid operation</i> exceptions are enabled. These three are combined into a <i>severeExceptions</i> value for convenience. Note in particular that if <i>invalidException</i> is enabled, a hardware trap will be generated whenever an uninitialized floating-point variable is used. <br><br> All changes are temporary. The previous state is restored at the end of the scope. <br><br> </p> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">{
    FloatingPointControl fpctrl;

    // Enable hardware exceptions for division by zero, overflow to infinity,
    // invalid operations, and uninitialized floating-point variables.
    fpctrl.enableExceptions(FloatingPointControl.severeExceptions);

    // This will generate a hardware exception, if x is a
    // default-initialized floating point variable:
    real x; // Add `= 0` or even `= real.nan` to not throw the exception.
    real y = x * 3.0;

    // The exception is only thrown for default-uninitialized NaN-s.
    // NaN-s with other payload are valid:
    real z = y * real.nan; // ok

    // The set hardware exceptions and rounding modes will be disabled when
    // leaving this scope.
}
</pre>  <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">version (InlineAsm_X86_Any)
{
    FloatingPointControl fpctrl;

    fpctrl.rounding = FloatingPointControl.roundDown;
    writeln(lrint(1.5)); // 1.0

    fpctrl.rounding = FloatingPointControl.roundUp;
    writeln(lrint(1.4)); // 2.0

    fpctrl.rounding = FloatingPointControl.roundToNearest;
    writeln(lrint(1.5)); // 2.0
}
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="FloatingPointControl.RoundingMode">alias <strong id="RoundingMode">RoundingMode</strong> = uint; </dt>  <dt class="d_decl" id="FloatingPointControl.roundToNearest">
<strong id="roundToNearest">roundToNearest</strong><br><br><strong id="roundDown">roundDown</strong><br><br><strong id="roundUp">roundUp</strong><br><br><strong id="roundToZero">roundToZero</strong><br><br><strong id="roundingMask">roundingMask</strong>
</dt> <dd>
<p>IEEE rounding modes. The default mode is roundToNearest. </p>
<p>roundingMask = A mask of all rounding modes.</p> </dd> <dt class="d_decl" id="FloatingPointControl.rounding">nothrow @nogc @property @trusted void <strong id="rounding">rounding</strong>(RoundingMode newMode); </dt> <dd>
<p>Change the floating-point hardware rounding mode </p>
<p> Changing the rounding mode in the middle of a function can interfere with optimizations of floating point expressions, as the optimizer assumes that the rounding mode does not change. It is best to change the rounding mode only at the beginning of the function, and keep it until the function returns. It is also best to add the line: </p>
<pre data-language="d">pragma(inline, false);
</pre> as the first line of the function so it will not get inlined.  <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>RoundingMode <code>newMode</code>
</td> <td>the new rounding mode</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="FloatingPointControl.rounding.2">static pure nothrow @nogc @property @trusted RoundingMode <strong id="rounding">rounding</strong>(); </dt> <dd>
<dl>
<dt>Returns:</dt>
<dd>the currently active rounding mode</dd>
</dl> </dd> <dt class="d_decl" id="FloatingPointControl.ExceptionMask">alias <strong id="ExceptionMask">ExceptionMask</strong> = uint; </dt>  <dt class="d_decl" id="FloatingPointControl.subnormalException">
<strong id="subnormalException">subnormalException</strong><br><br><strong id="inexactException">inexactException</strong><br><br><strong id="underflowException">underflowException</strong><br><br><strong id="overflowException">overflowException</strong><br><br><strong id="divByZeroException">divByZeroException</strong><br><br><strong id="invalidException">invalidException</strong><br><br><strong id="severeExceptions">severeExceptions</strong><br><br><strong id="allExceptions">allExceptions</strong>
</dt> <dd>
<p>IEEE hardware exceptions. By default, all exceptions are masked (disabled). </p>
<p>severeExceptions = The overflow, division by zero, and invalid exceptions.</p> </dd> <dt class="d_decl" id="FloatingPointControl.hasExceptionTraps">static pure nothrow @nogc @property @safe bool <strong id="hasExceptionTraps">hasExceptionTraps</strong>(); </dt> <dd>
<dl>
<dt>Returns:</dt>
<dd>true if the current FPU supports exception trapping</dd>
</dl> </dd> <dt class="d_decl" id="FloatingPointControl.enableExceptions">nothrow @nogc @trusted void <strong id="enableExceptions">enableExceptions</strong>(ExceptionMask exceptions); </dt> <dd>
<p>Enable (unmask) specific hardware exceptions. Multiple exceptions may be ORed together.</p> </dd> <dt class="d_decl" id="FloatingPointControl.disableExceptions">nothrow @nogc @trusted void <strong id="disableExceptions">disableExceptions</strong>(ExceptionMask exceptions); </dt> <dd>
<p>Disable (mask) specific hardware exceptions. Multiple exceptions may be ORed together.</p> </dd> <dt class="d_decl" id="FloatingPointControl.enabledExceptions">static pure nothrow @nogc @property @trusted ExceptionMask <strong id="enabledExceptions">enabledExceptions</strong>(); </dt> <dd>
<dl>
<dt>Returns:</dt>
<dd>the exceptions which are currently enabled (unmasked)</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="isNaN">pure nothrow @nogc @trusted bool <strong id="isNaN">isNaN</strong>(X)(X x)<br><small>  Constraints: if (isFloatingPoint!X); </small>
</dt> <dd>
<p>Determines if <span class="d_param">x</span> is NaN. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>X <code>x</code>
</td> <td>a floating point number.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if <span class="d_param">x</span> is Nan.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert( isNaN(float.init));
assert( isNaN(-double.init));
assert( isNaN(real.nan));
assert( isNaN(-real.nan));
assert(!isNaN(cast(float) 53.6));
assert(!isNaN(cast(real)-53.6));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isFinite">pure nothrow @nogc @trusted bool <strong id="isFinite">isFinite</strong>(X)(X x); </dt> <dd>
<p>Determines if <span class="d_param">x</span> is finite. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>X <code>x</code>
</td> <td>a floating point number.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if <span class="d_param">x</span> is finite.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert( isFinite(1.23f));
assert( isFinite(float.max));
assert( isFinite(float.min_normal));
assert(!isFinite(float.nan));
assert(!isFinite(float.infinity));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isNormal">pure nothrow @nogc @trusted bool <strong id="isNormal">isNormal</strong>(X)(X x); </dt> <dd>
<p>Determines if <span class="d_param">x</span> is normalized. </p>
<p>A normalized number must not be zero, subnormal, infinite nor <span class="red">NAN</span>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>X <code>x</code>
</td> <td>a floating point number.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if <span class="d_param">x</span> is normalized.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">float f = 3;
double d = 500;
real e = 10e+48;

assert(isNormal(f));
assert(isNormal(d));
assert(isNormal(e));
f = d = e = 0;
assert(!isNormal(f));
assert(!isNormal(d));
assert(!isNormal(e));
assert(!isNormal(real.infinity));
assert(isNormal(-real.max));
assert(!isNormal(real.min_normal/4));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isSubnormal">pure nothrow @nogc @trusted bool <strong id="isSubnormal">isSubnormal</strong>(X)(X x); </dt> <dd>
<p>Determines if <span class="d_param">x</span> is subnormal. </p>
<p>Subnormals (also known as "denormal number"), have a 0 exponent and a 0 most significant mantissa bit. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>X <code>x</code>
</td> <td>a floating point number.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if <span class="d_param">x</span> is a denormal number.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.meta : AliasSeq;

static foreach (T; AliasSeq!(float, double, real))
{{
    T f;
    for (f = 1.0; !isSubnormal(f); f /= 2)
        assert(f != 0);
}}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isInfinity">pure nothrow @nogc @trusted bool <strong id="isInfinity">isInfinity</strong>(X)(X x)<br><small>  Constraints: if (isFloatingPoint!X); </small>
</dt> <dd>
<p>Determines if <span class="d_param">x</span> is ±∞. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>X <code>x</code>
</td> <td>a floating point number.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if <span class="d_param">x</span> is ±∞.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(!isInfinity(float.init));
assert(!isInfinity(-float.init));
assert(!isInfinity(float.nan));
assert(!isInfinity(-float.nan));
assert(isInfinity(float.infinity));
assert(isInfinity(-float.infinity));
assert(isInfinity(-1.0f / 0.0f));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isIdentical">pure nothrow @nogc @trusted bool <strong id="isIdentical">isIdentical</strong>(real x, real y); </dt> <dd>
<p>Is the binary representation of x identical to y? </p>
<p>Same as ==, except that positive and negative zero are not identical, and two <span class="red">NAN</span>s are identical if they have the same 'payload'.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert( isIdentical(0.0, 0.0));
assert( isIdentical(1.0, 1.0));
assert( isIdentical(real.infinity, real.infinity));
assert( isIdentical(-real.infinity, -real.infinity));

assert(!isIdentical(0.0, -0.0));
assert(!isIdentical(real.nan, -real.nan));
assert(!isIdentical(real.infinity, -real.infinity));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="signbit">pure nothrow @nogc @trusted int <strong id="signbit">signbit</strong>(X)(X x); </dt> <dd>
<p>Return 1 if sign bit of e is set, 0 if not.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(!signbit(float.nan));
assert(signbit(-float.nan));
assert(!signbit(168.1234f));
assert(signbit(-168.1234f));
assert(!signbit(0.0f));
assert(signbit(-0.0f));
assert(signbit(-float.max));
assert(!signbit(float.max));

assert(!signbit(double.nan));
assert(signbit(-double.nan));
assert(!signbit(168.1234));
assert(signbit(-168.1234));
assert(!signbit(0.0));
assert(signbit(-0.0));
assert(signbit(-double.max));
assert(!signbit(double.max));

assert(!signbit(real.nan));
assert(signbit(-real.nan));
assert(!signbit(168.1234L));
assert(signbit(-168.1234L));
assert(!signbit(0.0L));
assert(signbit(-0.0L));
assert(signbit(-real.max));
assert(!signbit(real.max));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="copysign">pure nothrow @nogc @trusted R <strong id="copysign">copysign</strong>(R, X)(R to, X from)<br><small>  Constraints: if (isFloatingPoint!R &amp;&amp; isFloatingPoint!X); </small><br><br>pure nothrow @nogc @trusted R <strong id="copysign">copysign</strong>(R, X)(X to, R from)<br><small>  Constraints: if (isIntegral!X &amp;&amp; isFloatingPoint!R); </small>
</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>to</code>
</td> <td>the numeric value to use</td>
</tr> <tr>
<td>X <code>from</code>
</td> <td>the sign value to use</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>a value composed of to with from's sign bit.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(copysign(1.0, 1.0)); // 1.0
writeln(copysign(1.0, -0.0)); // -1.0
writeln(copysign(1UL, -1.0)); // -1.0
writeln(copysign(-1.0, -1.0)); // -1.0

writeln(copysign(real.infinity, -1.0)); // -real.infinity
assert(copysign(real.nan, 1.0) is real.nan);
assert(copysign(-real.nan, 1.0) is real.nan);
assert(copysign(real.nan, -1.0) is -real.nan);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="sgn">pure nothrow @nogc @safe F <strong id="sgn">sgn</strong>(F)(F x)<br><small>  Constraints: if (isFloatingPoint!F || isIntegral!F); </small>
</dt> <dd>
<p>Returns <code>-1</code> if <code>x &lt; 0</code>, <code>x</code> if <code>x == 0</code>, <code>1</code> if <code>x &gt; 0</code>, and <span class="red">NAN</span> if x==<span class="red">NAN</span>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(sgn(168.1234)); // 1
writeln(sgn(-168.1234)); // -1
writeln(sgn(0.0)); // 0
writeln(sgn(-0.0)); // 0
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="NaN">pure nothrow @nogc @trusted real <strong id="NaN">NaN</strong>(ulong payload); </dt> <dd>
<p>Create a quiet <span class="red">NAN</span>, storing an integer inside the payload. </p>
<p>For floats, the largest possible payload is 0x3F_FFFF. For doubles, it is 0x3_FFFF_FFFF_FFFF. For 80-bit or 128-bit reals, it is 0x3FFF_FFFF_FFFF_FFFF.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">real a = NaN(1_000_000);
assert(isNaN(a));
writeln(getNaNPayload(a)); // 1_000_000
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="getNaNPayload">pure nothrow @nogc @trusted ulong <strong id="getNaNPayload">getNaNPayload</strong>(real x); </dt> <dd>
<p>Extract an integral payload from a <span class="red">NAN</span>. </p>
<dl>
<dt>Returns:</dt>
<dd>the integer payload as a ulong.  For floats, the largest possible payload is 0x3F_FFFF. For doubles, it is 0x3_FFFF_FFFF_FFFF. For 80-bit or 128-bit reals, it is 0x3FFF_FFFF_FFFF_FFFF.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">real a = NaN(1_000_000);
assert(isNaN(a));
writeln(getNaNPayload(a)); // 1_000_000
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="nextUp">pure nothrow @nogc @trusted real <strong id="nextUp">nextUp</strong>(real x); <br><br>pure nothrow @nogc @trusted double <strong id="nextUp">nextUp</strong>(double x); <br><br>pure nothrow @nogc @trusted float <strong id="nextUp">nextUp</strong>(float x); </dt> <dd>
<p>Calculate the next largest floating point value after x. </p>
<p>Return the least number greater than x that is representable as a real; thus, it gives the next point on the IEEE number line. <br><br> </p>
<table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col"> nextUp(x) </th>
</tr> <tr>
<td> -∞</td> <td> -real.max </td>
</tr> <tr>
<td> ±0.0</td> <td>real.min_normal*real.epsilon </td>
</tr> <tr>
<td> real.max</td> <td> ∞ </td>
</tr> <tr>
<td> ∞</td> <td> ∞ </td>
</tr> <tr>
<td> <span class="red">NAN</span>
</td> <td> <span class="red">NAN</span> </td>
</tr> </table> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(nextUp(1.0 - 1.0e-6).feqrel(0.999999) &gt; 16);
assert(nextUp(1.0 - real.epsilon).feqrel(1.0) &gt; 16);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="nextDown">pure nothrow @nogc @safe real <strong id="nextDown">nextDown</strong>(real x); <br><br>pure nothrow @nogc @safe double <strong id="nextDown">nextDown</strong>(double x); <br><br>pure nothrow @nogc @safe float <strong id="nextDown">nextDown</strong>(float x); </dt> <dd>
<p>Calculate the next smallest floating point value before x. </p>
<p>Return the greatest number less than x that is representable as a real; thus, it gives the previous point on the IEEE number line. <br><br> </p>
<table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col"> nextDown(x) </th>
</tr> <tr>
<td> ∞</td> <td> real.max </td>
</tr> <tr>
<td> ±0.0</td> <td>-real.min_normal*real.epsilon </td>
</tr> <tr>
<td> -real.max</td> <td> -∞ </td>
</tr> <tr>
<td> -∞</td> <td> -∞ </td>
</tr> <tr>
<td> <span class="red">NAN</span>
</td> <td> <span class="red">NAN</span> </td>
</tr> </table> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(nextDown(1.0 + real.epsilon)); // 1.0
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="nextafter">pure nothrow @nogc @safe T <strong id="nextafter">nextafter</strong>(T)(const T x, const T y); </dt> <dd>
<p>Calculates the next representable value after x in the direction of y. </p>
<p>If y &gt; x, the result will be the next largest floating-point value; if y &lt; x, the result will be the next smallest value. If x == y, the result is y. </p> <dl>
<dt>Remarks</dt>
<dd> This function is not generally very useful; it's almost always better to use the faster functions nextUp() or nextDown() instead. </dd>
</dl> The FE_INEXACT and FE_OVERFLOW exceptions will be raised if x is finite and the function result is infinite. The FE_INEXACT and FE_UNDERFLOW exceptions will be raised if the function value is subnormal, and x is not equal to y. <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">float a = 1;
assert(is(typeof(nextafter(a, a)) == float));
assert(nextafter(a, a.infinity) &gt; a);

double b = 2;
assert(is(typeof(nextafter(b, b)) == double));
assert(nextafter(b, b.infinity) &gt; b);

real c = 3;
assert(is(typeof(nextafter(c, c)) == real));
assert(nextafter(c, c.infinity) &gt; c);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="fdim">pure nothrow @nogc @safe real <strong id="fdim">fdim</strong>(real x, real y); </dt> <dd>
<p>Returns the positive difference between x and y. </p>
<p>Equivalent to <code>fmax(x-y, 0)</code>. </p> <dl>
<dt>Returns:</dt>
<dd><table> <caption>Special Values</caption> <tr>
<th scope="col">x, y</th> <th scope="col">fdim(x, y)</th>
</tr> <tr>
<td>x &gt; y</td> <td>x - y</td>
</tr> <tr>
<td>x &lt;= y</td> <td>+0.0</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(fdim(2.0, 0.0)); // 2.0
writeln(fdim(-2.0, 0.0)); // 0.0
writeln(fdim(real.infinity, 2.0)); // real.infinity
assert(isNaN(fdim(real.nan, 2.0)));
assert(isNaN(fdim(2.0, real.nan)));
assert(isNaN(fdim(real.nan, real.nan)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="fmax">pure nothrow @nogc @safe real <strong id="fmax">fmax</strong>(real x, real y); </dt> <dd>
<p>Returns the larger of x and y. </p>
<p>If one of the arguments is a NaN, the other is returned.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(fmax(0.0, 2.0)); // 2.0
writeln(fmax(-2.0, 0.0)); // 0.0
writeln(fmax(real.infinity, 2.0)); // real.infinity
writeln(fmax(real.nan, 2.0)); // 2.0
writeln(fmax(2.0, real.nan)); // 2.0
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="fmin">pure nothrow @nogc @safe real <strong id="fmin">fmin</strong>(real x, real y); </dt> <dd>
<p>Returns the smaller of x and y. </p>
<p>If one of the arguments is a NaN, the other is returned.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(fmin(0.0, 2.0)); // 0.0
writeln(fmin(-2.0, 0.0)); // -2.0
writeln(fmin(real.infinity, 2.0)); // 2.0
writeln(fmin(real.nan, 2.0)); // 2.0
writeln(fmin(2.0, real.nan)); // 2.0
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="fma">pure nothrow @nogc @safe real <strong id="fma">fma</strong>(real x, real y, real z); </dt> <dd>
<p>Returns (x * y) + z, rounding only once according to the current rounding mode. </p>
<dl>
<dt>Bugs:</dt>
<dd>Not currently implemented - rounds twice.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(fma(0.0, 2.0, 2.0)); // 2.0
writeln(fma(2.0, 2.0, 2.0)); // 6.0
writeln(fma(real.infinity, 2.0, 2.0)); // real.infinity
assert(fma(real.nan, 2.0, 2.0) is real.nan);
assert(fma(2.0, 2.0, real.nan) is real.nan);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="pow">pure nothrow @nogc @trusted Unqual!F <strong id="pow">pow</strong>(F, G)(F x, G n)<br><small>  Constraints: if (isFloatingPoint!F &amp;&amp; isIntegral!G); </small>
</dt> <dd>
<p>Compute the value of x <sup>n</sup>, where n is an integer</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(pow(2.0, 5)); // 32.0
assert(pow(1.5, 9).feqrel(38.4433) &gt; 16);
assert(pow(real.nan, 2) is real.nan);
writeln(pow(real.infinity, 2)); // real.infinity
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="pow.2">pure nothrow @nogc @trusted typeof(Unqual!F.init * Unqual!G.init) <strong id="pow">pow</strong>(F, G)(F x, G n)<br><small>  Constraints: if (isIntegral!F &amp;&amp; isIntegral!G); </small>
</dt> <dd>
<p>Compute the value of an integer x, raised to the power of a positive integer n. </p>
<p>If both x and n are 0, the result is 1. If n is negative, an integer divide error will occur at runtime, regardless of the value of x.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">immutable int one = 1;
immutable byte two = 2;
immutable ubyte three = 3;
immutable short four = 4;
immutable long ten = 10;

writeln(pow(two, three)); // 8
writeln(pow(two, ten)); // 1024
writeln(pow(one, ten)); // 1
writeln(pow(ten, four)); // 10_000
writeln(pow(four, 10)); // 1_048_576
writeln(pow(three, four)); // 81
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="pow.3">pure nothrow @nogc @trusted real <strong id="pow">pow</strong>(I, F)(I x, F y)<br><small>  Constraints: if (isIntegral!I &amp;&amp; isFloatingPoint!F); </small>
</dt> <dd>
<p>Computes integer to floating point powers.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(pow(2, 5.0)); // 32.0
writeln(pow(7, 3.0)); // 343.0
assert(pow(2, real.nan) is real.nan);
writeln(pow(2, real.infinity)); // real.infinity
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="pow.4">pure nothrow @nogc @trusted Unqual!(Largest!(F, G)) <strong id="pow">pow</strong>(F, G)(F x, G y)<br><small>  Constraints: if (isFloatingPoint!F &amp;&amp; isFloatingPoint!G); </small>
</dt> <dd>
<p>Calculates x<sup>y</sup>. </p>
<p></p>
<table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">y</th> <th scope="col">pow(x, y)</th> <th scope="col">div 0</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>anything</td> <td>±0.0</td> <td>1.0</td> <td>no</td> <td>no</td> </tr> <tr>
<td>|x| &gt; 1</td> <td>+∞</td> <td>+∞</td> <td>no</td> <td>no</td> </tr> <tr>
<td>|x| &lt; 1</td> <td>+∞</td> <td>+0.0</td> <td>no</td> <td>no</td> </tr> <tr>
<td>|x| &gt; 1</td> <td>-∞</td> <td>+0.0</td> <td>no</td> <td>no</td> </tr> <tr>
<td>|x| &lt; 1</td> <td>-∞</td> <td>+∞</td> <td>no</td> <td>no</td> </tr> <tr>
<td>+∞</td> <td>&gt; 0.0</td> <td>+∞</td> <td>no</td> <td>no</td> </tr> <tr>
<td>+∞</td> <td>&lt; 0.0</td> <td>+0.0</td> <td>no</td> <td>no</td> </tr> <tr>
<td>-∞</td> <td>odd integer &gt; 0.0</td> <td>-∞</td> <td>no</td> <td>no</td> </tr> <tr>
<td>-∞</td> <td>&gt; 0.0, not odd integer</td> <td>+∞</td> <td>no</td> <td>no</td>
</tr> <tr>
<td>-∞</td> <td>odd integer &lt; 0.0</td> <td>-0.0</td> <td>no</td> <td>no</td> </tr> <tr>
<td>-∞</td> <td>&lt; 0.0, not odd integer</td> <td>+0.0</td> <td>no</td> <td>no</td> </tr> <tr>
<td>±1.0</td> <td>±∞</td> <td>-<span class="red">NAN</span>
</td> <td>no</td> <td>yes</td> </tr> <tr>
<td>&lt; 0.0</td> <td>finite, nonintegral</td> <td><span class="red">NAN</span></td> <td>no</td> <td>yes</td>
</tr> <tr>
<td>±0.0</td> <td>odd integer &lt; 0.0</td> <td>±∞</td> <td>yes</td> <td>no</td> </tr> <tr>
<td>±0.0</td> <td>&lt; 0.0, not odd integer</td> <td>+∞</td> <td>yes</td> <td>no</td>
</tr> <tr>
<td>±0.0</td> <td>odd integer &gt; 0.0</td> <td>±0.0</td> <td>no</td> <td>no</td> </tr> <tr>
<td>±0.0</td> <td>&gt; 0.0, not odd integer</td> <td>+0.0</td> <td>no</td> <td>no</td> </tr> </table> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(pow(1.0, 2.0)); // 1.0
writeln(pow(0.0, 0.0)); // 1.0
assert(pow(1.5, 10.0).feqrel(57.665) &gt; 16);

// special values
writeln(pow(1.5, real.infinity)); // real.infinity
writeln(pow(0.5, real.infinity)); // 0.0
writeln(pow(1.5, -real.infinity)); // 0.0
writeln(pow(0.5, -real.infinity)); // real.infinity
writeln(pow(real.infinity, 1.0)); // real.infinity
writeln(pow(real.infinity, -1.0)); // 0.0
writeln(pow(-real.infinity, 1.0)); // -real.infinity
writeln(pow(-real.infinity, 2.0)); // real.infinity
writeln(pow(-real.infinity, -1.0)); // -0.0
writeln(pow(-real.infinity, -2.0)); // 0.0
assert(pow(1.0, real.infinity) is -real.nan);
writeln(pow(0.0, -1.0)); // real.infinity
writeln(pow(real.nan, 0.0)); // 1.0
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="powmod">Unqual!(Largest!(F, H)) <strong id="powmod">powmod</strong>(F, G, H)(F x, G n, H m)<br><small>  Constraints: if (isUnsigned!F &amp;&amp; isUnsigned!G &amp;&amp; isUnsigned!H); </small>
</dt> <dd>
<p>Computes the value of a positive integer <code>x</code>, raised to the power <code>n</code>, modulo <code>m</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>F <code>x</code>
</td> <td>base</td>
</tr> <tr>
<td>G <code>n</code>
</td> <td>exponent</td>
</tr> <tr>
<td>H <code>m</code>
</td> <td>modulus</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>x</code> to the power <code>n</code>, modulo <code>m</code>. The return type is the largest of <code>x</code>'s and <code>m</code>'s type.  The function requires that all values have unsigned types.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(powmod(1U, 10U, 3U)); // 1
writeln(powmod(3U, 2U, 6U)); // 3
writeln(powmod(5U, 5U, 15U)); // 5
writeln(powmod(2U, 3U, 5U)); // 3
writeln(powmod(2U, 4U, 5U)); // 1
writeln(powmod(2U, 5U, 5U)); // 2
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="feqrel">pure nothrow @nogc @trusted int <strong id="feqrel">feqrel</strong>(X)(const X x, const X y)<br><small>  Constraints: if (isFloatingPoint!X); </small>
</dt> <dd>
<p>To what precision is x equal to y? </p>
<dl>
<dt>Returns:</dt>
<dd>the number of mantissa bits which are equal in x and y. eg, 0x1.F8p+60 and 0x1.F1p+60 are equal to 5 bits of precision.  <table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">y</th> <th scope="col">feqrel(x, y)</th>
</tr> <tr>
<td>x</td> <td>x</td> <td>real.mant_dig</td>
</tr> <tr>
<td>x</td> <td>&gt;= 2*x</td> <td>0</td>
</tr> <tr>
<td>x</td> <td>&lt;= x/2</td> <td>0</td>
</tr> <tr>
<td><span class="red">NAN</span></td> <td>any</td> <td>0</td>
</tr> <tr>
<td>any</td> <td><span class="red">NAN</span></td> <td>0</td>
</tr> </table>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(feqrel(2.0, 2.0)); // 53
writeln(feqrel(2.0f, 2.0f)); // 24
writeln(feqrel(2.0, double.nan)); // 0

// Test that numbers are within n digits of each
// other by testing if feqrel &gt; n * log2(10)

// five digits
assert(feqrel(2.0, 2.00001) &gt; 16);
// ten digits
assert(feqrel(2.0, 2.00000000001) &gt; 33);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="poly">pure nothrow @nogc @trusted Unqual!(CommonType!(T1, T2)) <strong id="poly">poly</strong>(T1, T2)(T1 x, in T2[] A)<br><small>  Constraints: if (isFloatingPoint!T1 &amp;&amp; isFloatingPoint!T2); </small><br><br>pure nothrow @nogc @safe Unqual!(CommonType!(T1, T2)) <strong id="poly">poly</strong>(T1, T2, int N)(T1 x, ref const T2[N] A)<br><small>  Constraints: if (isFloatingPoint!T1 &amp;&amp; isFloatingPoint!T2 &amp;&amp; (N &gt; 0) &amp;&amp; (N &lt;= 10)); </small>
</dt> <dd>
<p>Evaluate polynomial A(x) = a<sub>0</sub> + a<sub>1</sub>x + a<sub>2</sub>x<sup>2</sup> + a<sub>3</sub>x<sup>3</sup>; ... </p>
<p>Uses Horner's rule A(x) = a<sub>0</sub> + x(a<sub>1</sub> + x(a<sub>2</sub> + x(a<sub>3</sub> + ...))) </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T1 <code>x</code>
</td> <td>the value to evaluate.</td>
</tr> <tr>
<td>T2[] <code>A</code>
</td> <td>array of coefficients a<sub>0</sub>, a<sub>1</sub>, etc.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">real x = 3.1;
static real[] pp = [56.1, 32.7, 6];

writeln(poly(x, pp)); // (56.1L + (32.7L + 6.0L * x) * x)
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="approxEqual">bool <strong id="approxEqual">approxEqual</strong>(T, U, V)(T lhs, U rhs, V maxRelDiff, V maxAbsDiff = 1e-05); <br><br>bool <strong id="approxEqual">approxEqual</strong>(T, U)(T lhs, U rhs); </dt> <dd>
<p>Computes whether two values are approximately equal, admitting a maximum relative difference, and a maximum absolute difference. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>lhs</code>
</td> <td>First item to compare.</td>
</tr> <tr>
<td>U <code>rhs</code>
</td> <td>Second item to compare.</td>
</tr> <tr>
<td>V <code>maxRelDiff</code>
</td> <td>Maximum allowable difference relative to <code>rhs</code>. Defaults to <code>1e-2</code>.</td>
</tr> <tr>
<td>V <code>maxAbsDiff</code>
</td> <td>Maximum absolute difference. Defaults to <code>1e-5</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if the two items are approximately equal under either criterium. If one item is a range, and the other is a single value, then the result is the logical and-ing of calling <code>approxEqual</code> on each element of the ranged item against the single item. If both items are ranges, then <code>approxEqual</code> returns <code>true</code> if and only if the ranges have the same number of elements and if <code>approxEqual</code> evaluates to <code>true</code> for each pair of elements. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>Use <a href="#feqrel"><code>feqrel</code></a> to get the number of equal bits in the mantissa.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(approxEqual(1.0, 1.0099));
assert(!approxEqual(1.0, 1.011));
float[] arr1 = [ 1.0, 2.0, 3.0 ];
double[] arr2 = [ 1.001, 1.999, 3 ];
assert(approxEqual(arr1, arr2));

real num = real.infinity;
assert(num == real.infinity);  // Passes.
assert(approxEqual(num, real.infinity));  // Fails.
num = -real.infinity;
assert(num == -real.infinity);  // Passes.
assert(approxEqual(num, -real.infinity));  // Fails.

assert(!approxEqual(3, 0));
assert(approxEqual(3, 3));
assert(approxEqual(3.0, 3));
assert(approxEqual([3, 3, 3], 3.0));
assert(approxEqual([3.0, 3.0, 3.0], 3));
int a = 10;
assert(approxEqual(10, a));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="cmp">pure nothrow @nogc @trusted int <strong id="cmp">cmp</strong>(T)(const(T) x, const(T) y)<br><small>  Constraints: if (isFloatingPoint!T); </small>
</dt> <dd>
<p>Defines a total order on all floating-point numbers. </p>
<p>The order is defined as follows: </p>
<ul> <li>All numbers in [-∞, +∞] are ordered the same way as by built-in comparison, with the exception of -0.0, which is less than +0.0;</li> <li>If the sign bit is set (that is, it's 'negative'), <span class="red">NAN</span> is less than any number; if the sign bit is not set (it is 'positive'), <span class="red">NAN</span> is greater than any number;</li> <li>
<span class="red">NAN</span>s of the same sign are ordered by the payload ('negative' ones - in reverse order).</li> </ul>  <dl>
<dt>Returns:</dt>
<dd>negative value if <code>x</code> precedes <code>y</code> in the order specified above; 0 if <code>x</code> and <code>y</code> are identical, and positive value otherwise. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#isIdentical"><em class="tt">isIdentical</em></a> </dd>
</dl> <dl>
<dt>Standards:</dt>
<dd>Conforms to IEEE 754-2008</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Most numbers are ordered naturally. <pre data-language="d">assert(cmp(-double.infinity, -double.max) &lt; 0);
assert(cmp(-double.max, -100.0) &lt; 0);
assert(cmp(-100.0, -0.5) &lt; 0);
assert(cmp(-0.5, 0.0) &lt; 0);
assert(cmp(0.0, 0.5) &lt; 0);
assert(cmp(0.5, 100.0) &lt; 0);
assert(cmp(100.0, double.max) &lt; 0);
assert(cmp(double.max, double.infinity) &lt; 0);

writeln(cmp(1.0, 1.0)); // 0
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Positive and negative zeroes are distinct. <pre data-language="d">assert(cmp(-0.0, +0.0) &lt; 0);
assert(cmp(+0.0, -0.0) &gt; 0);
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Depending on the sign, <span class="red">NAN</span>s go to either end of the spectrum. <pre data-language="d">assert(cmp(-double.nan, -double.infinity) &lt; 0);
assert(cmp(double.infinity, double.nan) &lt; 0);
assert(cmp(-double.nan, double.nan) &lt; 0);
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<span class="red">NAN</span>s of the same sign are ordered by the payload. <pre data-language="d">assert(cmp(NaN(10), NaN(20)) &lt; 0);
assert(cmp(-NaN(20), -NaN(10)) &lt; 0);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="nextPow2">T <strong id="nextPow2">nextPow2</strong>(T)(const T val)<br><small>  Constraints: if (isIntegral!T); </small><br><br>T <strong id="nextPow2">nextPow2</strong>(T)(const T val)<br><small>  Constraints: if (isFloatingPoint!T); </small>
</dt> <dd>
<p>Gives the next power of two after <code>val</code>. <code>T</code> can be any built-in numerical type. </p>
<p>If the operation would lead to an over/underflow, this function will return <code>0</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>val</code>
</td> <td>any number</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>the next power of two after <code>val</code>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(nextPow2(2)); // 4
writeln(nextPow2(10)); // 16
writeln(nextPow2(4000)); // 4096

writeln(nextPow2(-2)); // -4
writeln(nextPow2(-10)); // -16

writeln(nextPow2(uint.max)); // 0
writeln(nextPow2(uint.min)); // 0
writeln(nextPow2(size_t.max)); // 0
writeln(nextPow2(size_t.min)); // 0

writeln(nextPow2(int.max)); // 0
writeln(nextPow2(int.min)); // 0
writeln(nextPow2(long.max)); // 0
writeln(nextPow2(long.min)); // 0
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(nextPow2(2.1)); // 4.0
writeln(nextPow2(-2.0)); // -4.0
writeln(nextPow2(0.25)); // 0.5
writeln(nextPow2(-4.0)); // -8.0

writeln(nextPow2(double.max)); // 0.0
writeln(nextPow2(double.infinity)); // double.infinity
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="truncPow2">T <strong id="truncPow2">truncPow2</strong>(T)(const T val)<br><small>  Constraints: if (isIntegral!T); </small><br><br>T <strong id="truncPow2">truncPow2</strong>(T)(const T val)<br><small>  Constraints: if (isFloatingPoint!T); </small>
</dt> <dd>
<p>Gives the last power of two before <code>val</code>. &lt;&gt;&gt; can be any built-in numerical type. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>val</code>
</td> <td>any number</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>the last power of two before <code>val</code>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(truncPow2(3)); // 2
writeln(truncPow2(4)); // 4
writeln(truncPow2(10)); // 8
writeln(truncPow2(4000)); // 2048

writeln(truncPow2(-5)); // -4
writeln(truncPow2(-20)); // -16

writeln(truncPow2(uint.max)); // int.max + 1
writeln(truncPow2(uint.min)); // 0
writeln(truncPow2(ulong.max)); // long.max + 1
writeln(truncPow2(ulong.min)); // 0

writeln(truncPow2(int.max)); // (int.max / 2) + 1
writeln(truncPow2(int.min)); // int.min
writeln(truncPow2(long.max)); // (long.max / 2) + 1
writeln(truncPow2(long.min)); // long.min
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(truncPow2(2.1)); // 2.0
writeln(truncPow2(7.0)); // 4.0
writeln(truncPow2(-1.9)); // -1.0
writeln(truncPow2(0.24)); // 0.125
writeln(truncPow2(-7.0)); // -4.0

writeln(truncPow2(double.infinity)); // double.infinity
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isPowerOf2">pure nothrow @nogc @safe bool <strong id="isPowerOf2">isPowerOf2</strong>(X)(const X x)<br><small>  Constraints: if (isNumeric!X); </small>
</dt> <dd>
<p>Check whether a number is an integer power of two. </p>
<p>Note that only positive numbers can be integer powers of two. This function always return <code>false</code> if <code>x</code> is negative or zero. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>X <code>x</code>
</td> <td>the number to test</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if <code>x</code> is an integer power of two.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert( isPowerOf2(1.0L));
assert( isPowerOf2(2.0L));
assert( isPowerOf2(0.5L));
assert( isPowerOf2(pow(2.0L, 96)));
assert( isPowerOf2(pow(2.0L, -77)));

assert(!isPowerOf2(-2.0L));
assert(!isPowerOf2(-0.5L));
assert(!isPowerOf2(0.0L));
assert(!isPowerOf2(4.315));
assert(!isPowerOf2(1.0L / 3.0L));

assert(!isPowerOf2(real.nan));
assert(!isPowerOf2(real.infinity));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert( isPowerOf2(1));
assert( isPowerOf2(2));
assert( isPowerOf2(1uL &lt;&lt; 63));

assert(!isPowerOf2(-4));
assert(!isPowerOf2(0));
assert(!isPowerOf2(1337u));
</pre> </dd>
</dl> </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2019 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_math.html" class="_attribution-link">https://dlang.org/phobos/std_math.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
