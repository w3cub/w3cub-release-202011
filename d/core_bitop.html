
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>core.bitop - D - W3cubDocs</title>
  
  <meta name="description" content=" This module contains a collection of bit-level operations. ">
  <meta name="keywords" content="core, bitop, d">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/d/core_bitop.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/d.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/d/" class="_nav-link" title="" style="margin-left:0;">D</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _d">
				
				
<h1>core.bitop</h1>  <p>This module contains a collection of bit-level operations. </p>
<dl>
<dt>License:</dt>
<dd>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a> </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>Don Clugston, Sean Kelly, Walter Bright, Alex Rønne Petersen, Thomas Stuart Bockman </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <a href="https://github.com/dlang/druntime/blob/master/src/core/bitop.d">core/bitop.d</a>
</dd>
</dl> <dl>
<dt class="d_decl" id="bsf">pure nothrow @nogc @safe int <strong id="bsf">bsf</strong>(uint v); <br><br>pure nothrow @nogc @safe int <strong id="bsf">bsf</strong>(ulong v); </dt> <dd>
<p>Scans the bits in v starting with bit 0, looking for the first set bit. </p>
<dl>
<dt>Returns:</dt>
<dd>The bit number of the first bit set. The return value is undefined if v is zero.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(bsf(0x21) == 0);
assert(bsf(ulong.max &lt;&lt; 39) == 39);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="bsr">pure nothrow @nogc @safe int <strong id="bsr">bsr</strong>(uint v); <br><br>pure nothrow @nogc @safe int <strong id="bsr">bsr</strong>(ulong v); </dt> <dd>
<p>Scans the bits in v from the most significant bit to the least significant bit, looking for the first set bit. </p>
<dl>
<dt>Returns:</dt>
<dd>The bit number of the first bit set. The return value is undefined if v is zero.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(bsr(0x21) == 5);
assert(bsr((ulong.max &gt;&gt; 15) - 1) == 48);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="bt">pure nothrow @nogc @system int <strong id="bt">bt</strong>(scope const size_t* p, size_t bitnum); </dt> <dd>
<p>Tests the bit. (No longer an intrisic - the compiler recognizes the patterns in the body.)</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">size_t[2] array;

array[0] = 2;
array[1] = 0x100;

assert(bt(array.ptr, 1));
assert(array[0] == 2);
assert(array[1] == 0x100);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="btc">pure nothrow @nogc @system int <strong id="btc">btc</strong>(size_t* p, size_t bitnum); </dt> <dd>
<p>Tests and complements the bit.</p> </dd> <dt class="d_decl" id="btr">pure nothrow @nogc @system int <strong id="btr">btr</strong>(size_t* p, size_t bitnum); </dt> <dd>
<p>Tests and resets (sets to 0) the bit.</p> </dd> <dt class="d_decl" id="bts">pure nothrow @nogc @system int <strong id="bts">bts</strong>(size_t* p, size_t bitnum); </dt> <dd>
<p>Tests and sets the bit. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>size_t* <code>p</code>
</td> <td>a non-NULL pointer to an array of size_ts.</td>
</tr> <tr>
<td>size_t <code>bitnum</code>
</td> <td>a bit number, starting with bit 0 of p[0], and progressing. It addresses bits like the expression: <pre data-language="d">p[index / (size_t.sizeof*8)] &amp; (1 &lt;&lt; (index &amp; ((size_t.sizeof*8) - 1)))
</pre> </td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A non-zero value if the bit was set, and a zero if it was clear.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">size_t[2] array;

array[0] = 2;
array[1] = 0x100;

assert(btc(array.ptr, 35) == 0);
if (size_t.sizeof == 8)
{
    assert(array[0] == 0x8_0000_0002);
    assert(array[1] == 0x100);
}
else
{
    assert(array[0] == 2);
    assert(array[1] == 0x108);
}

assert(btc(array.ptr, 35));
assert(array[0] == 2);
assert(array[1] == 0x100);

assert(bts(array.ptr, 35) == 0);
if (size_t.sizeof == 8)
{
    assert(array[0] == 0x8_0000_0002);
    assert(array[1] == 0x100);
}
else
{
    assert(array[0] == 2);
    assert(array[1] == 0x108);
}

assert(btr(array.ptr, 35));
assert(array[0] == 2);
assert(array[1] == 0x100);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="BitRange">struct <strong id="BitRange">BitRange</strong>; </dt> <dd>
<p>Range over bit set. Each element is the bit number that is set. </p>
<p>This is more efficient than testing each bit in a sparsely populated bit set. Note that the first bit in the bit set would be bit 0.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import core.stdc.stdlib : malloc, free;
import core.stdc.string : memset;

// initialize a bit array
enum nBytes = (100 + BitRange.bitsPerWord - 1) / 8;
size_t *bitArr = cast(size_t *)malloc(nBytes);
scope(exit) free(bitArr);
memset(bitArr, 0, nBytes);

// set some bits
bts(bitArr, 48);
bts(bitArr, 24);
bts(bitArr, 95);
bts(bitArr, 78);

enum sum = 48 + 24 + 95 + 78;

// iterate
size_t testSum;
size_t nBits;
foreach (b; BitRange(bitArr, 100))
{
    testSum += b;
    ++nBits;
}

assert(testSum == sum);
assert(nBits == 4);
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="BitRange.bitsPerWord">enum ulong <strong id="bitsPerWord">bitsPerWord</strong>; </dt> <dd>
<p>Number of bits in each size_t</p> </dd> <dt class="d_decl" id="BitRange.this">pure nothrow @nogc @system this(const(size_t)* bitarr, size_t numBits); </dt> <dd>
<p>Construct a BitRange. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(size_t)* <code>bitarr</code>
</td> <td>The array of bits to iterate over</td>
</tr> <tr>
<td>size_t <code>numBits</code>
</td> <td>The total number of valid bits in the given bit array</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="BitRange.front">pure nothrow @nogc @safe size_t <strong id="front">front</strong>(); <br><br>const pure nothrow @nogc @safe bool <strong id="empty">empty</strong>(); <br><br>pure nothrow @nogc @system void <strong id="popFront">popFront</strong>(); </dt> <dd>
<p>Range functions</p> </dd> </dl> </dd> <dt class="d_decl" id="bswap">pure nothrow @nogc @safe uint <strong id="bswap">bswap</strong>(uint v); </dt> <dd>
<p>Swaps bytes in a 4 byte uint end-to-end, i.e. byte 0 becomes byte 3, byte 1 becomes byte 2, byte 2 becomes byte 1, byte 3 becomes byte 0.</p> </dd> <dt class="d_decl" id="bswap.2">pure nothrow @nogc @safe ulong <strong id="bswap">bswap</strong>(ulong v); </dt> <dd>
<p>Swaps bytes in an 8 byte ulong end-to-end, i.e. byte 0 becomes byte 7, byte 1 becomes byte 6, etc.</p> </dd> <dt class="d_decl" id="inp">nothrow @nogc @system ubyte <strong id="inp">inp</strong>(uint port_address); <br><br>nothrow @nogc @system ushort <strong id="inpw">inpw</strong>(uint port_address); <br><br>nothrow @nogc @system uint <strong id="inpl">inpl</strong>(uint port_address); </dt> <dd>
<p>Reads I/O port at port_address.</p> </dd> <dt class="d_decl" id="outp">nothrow @nogc @system ubyte <strong id="outp">outp</strong>(uint port_address, ubyte value); <br><br>nothrow @nogc @system ushort <strong id="outpw">outpw</strong>(uint port_address, ushort value); <br><br>nothrow @nogc @system uint <strong id="outpl">outpl</strong>(uint port_address, uint value); </dt> <dd>
<p>Writes and returns value to I/O port at port_address.</p> </dd> <dt class="d_decl" id="popcnt">pure nothrow @nogc @safe int <strong id="popcnt">popcnt</strong>(uint x); <br><br>pure nothrow @nogc @safe int <strong id="popcnt">popcnt</strong>(ulong x); </dt> <dd>
<p>Calculates the number of set bits in an integer.</p> </dd> <dt class="d_decl" id="_popcnt">pure nothrow @nogc @safe ushort <strong id="_popcnt">_popcnt</strong>(ushort x); <br><br>pure nothrow @nogc @safe int <strong id="_popcnt">_popcnt</strong>(uint x); <br><br>pure nothrow @nogc @safe int <strong id="_popcnt">_popcnt</strong>(ulong x); </dt> <dd>
<p>Calculates the number of set bits in an integer using the X86 SSE4 POPCNT instruction. POPCNT is not available on all X86 CPUs.</p> </dd> <dt class="d_decl" id="volatileLoad">nothrow @nogc @safe ubyte <strong id="volatileLoad">volatileLoad</strong>(ubyte* ptr); <br><br>nothrow @nogc @safe ushort <strong id="volatileLoad">volatileLoad</strong>(ushort* ptr); <br><br>nothrow @nogc @safe uint <strong id="volatileLoad">volatileLoad</strong>(uint* ptr); <br><br>nothrow @nogc @safe ulong <strong id="volatileLoad">volatileLoad</strong>(ulong* ptr); <br><br>nothrow @nogc @safe void <strong id="volatileStore">volatileStore</strong>(ubyte* ptr, ubyte value); <br><br>nothrow @nogc @safe void <strong id="volatileStore">volatileStore</strong>(ushort* ptr, ushort value); <br><br>nothrow @nogc @safe void <strong id="volatileStore">volatileStore</strong>(uint* ptr, uint value); <br><br>nothrow @nogc @safe void <strong id="volatileStore">volatileStore</strong>(ulong* ptr, ulong value); </dt> <dd>
<p>Read/write value from/to the memory location indicated by ptr. </p>
<p>These functions are recognized by the compiler, and calls to them are guaranteed to not be removed (as dead assignment elimination or presumed to have no effect) or reordered in the same thread. <br><br> These reordering guarantees are only made with regards to other operations done through these functions; the compiler is free to reorder regular loads/stores with regards to loads/stores done through these functions. <br><br> This is useful when dealing with memory-mapped I/O (MMIO) where a store can have an effect other than just writing a value, or where sequential loads with no intervening stores can retrieve different values from the same location due to external stores to the location. <br><br> These functions will, when possible, do the load/store as a single operation. In general, this is possible when the size of the operation is less than or equal to <code>(void*).sizeof</code>, although some targets may support larger operations. If the load/store cannot be done as a single operation, multiple smaller operations will be used. <br><br> These are not to be conflated with atomic operations. They do not guarantee any atomicity. This may be provided by coincidence as a result of the instructions used on the target, but this should not be relied on for portable programs. Further, no memory fences are implied by these functions. They should not be used for communication between threads. They may be used to guarantee a write or read cycle occurs at a specified address.</p> </dd> <dt class="d_decl" id="bitswap">pure nothrow @nogc @safe uint <strong id="bitswap">bitswap</strong>(uint x); </dt> <dd>
<p>Reverses the order of bits in a 32-bit integer.</p> </dd> <dt class="d_decl" id="bitswap.2">pure nothrow @nogc @safe ulong <strong id="bitswap">bitswap</strong>(ulong x); </dt> <dd>
<p>Reverses the order of bits in a 64-bit integer.</p> </dd> <dt class="d_decl" id="rol">pure T <strong id="rol">rol</strong>(T)(const T value, const uint count)<br><small>  Constraints: if (__traits(isIntegral, T) &amp;&amp; __traits(isUnsigned, T)); </small><br><br>pure T <strong id="ror">ror</strong>(T)(const T value, const uint count)<br><small>  Constraints: if (__traits(isIntegral, T) &amp;&amp; __traits(isUnsigned, T)); </small><br><br>pure T <strong id="rol">rol</strong>(uint count, T)(const T value)<br><small>  Constraints: if (__traits(isIntegral, T) &amp;&amp; __traits(isUnsigned, T)); </small><br><br>pure T <strong id="ror">ror</strong>(uint count, T)(const T value)<br><small>  Constraints: if (__traits(isIntegral, T) &amp;&amp; __traits(isUnsigned, T)); </small>
</dt> <dd>
<p>Bitwise rotate <code>value</code> left (<code>rol</code>) or right (<code>ror</code>) by <code>count</code> bit positions.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">ubyte a = 0b11110000U;
ulong b = ~1UL;

assert(rol(a, 1) == 0b11100001);
assert(ror(a, 1) == 0b01111000);
assert(rol(a, 3) == 0b10000111);
assert(ror(a, 3) == 0b00011110);

assert(rol(a, 0) == a);
assert(ror(a, 0) == a);

assert(rol(b, 63) == ~(1UL &lt;&lt; 63));
assert(ror(b, 63) == ~2UL);

assert(rol!3(a) == 0b10000111);
assert(ror!3(a) == 0b00011110);
</pre> </dd>
</dl> </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2019 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/core_bitop.html" class="_attribution-link">https://dlang.org/phobos/core_bitop.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
