
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>std.datetime.interval - D - W3cubDocs</title>
  
  <meta name="description" content=" ">
  <meta name="keywords" content="std, datetime, interval, d">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/d/std_datetime_interval.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/d.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/d/" class="_nav-link" title="" style="margin-left:0;">D</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _d">
				
				
<h1>std.datetime.interval</h1>  <p> </p>
<table>

<tr>
<th scope="col">Category</th> <th scope="col">Functions</th>
</tr> <tr>
<td>Main types</td> <td> <a href="#Interval"><code>Interval</code></a> <a href="#Direction"><code>Direction</code></a> </td>
</tr> <tr>
<td>Special intervals</td> <td> <a href="#everyDayOfWeek"><code>everyDayOfWeek</code></a> <a href="#everyMonth"><code>everyMonth</code></a> <a href="#everyDuration"><code>everyDuration</code></a> </td>
</tr> <tr>
<td>Special intervals</td> <td> <a href="#NegInfInterval"><code>NegInfInterval</code></a> <a href="#PosInfInterval"><code>PosInfInterval</code></a> </td>
</tr> <tr>
<td>Underlying ranges</td> <td> <a href="#IntervalRange"><code>IntervalRange</code></a> <a href="#NegInfIntervalRange"><code>NegInfIntervalRange</code></a> <a href="#PosInfIntervalRange"><code>PosInfIntervalRange</code></a> </td>
</tr> <tr>
<td>Flags</td> <td> <a href="#PopFirst"><code>PopFirst</code></a> </td>
</tr> </table> 
<dl>
<dt>License:</dt>
<dd>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>
<a href="http://jmdavisprog.com">Jonathan M Davis</a> </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/datetime/interval.d">std/datetime/interval.d</a></span>
</dd>
</dl> <dl>
<dt class="d_decl" id="Direction">enum <strong id="Direction">Direction</strong>: int; </dt> <dd>
<p>Indicates a direction in time. One example of its use is <a href="#Interval"><code>Interval</code></a>'s <a href="#expand"><code>expand</code></a> function which uses it to indicate whether the interval should be expanded backwards (into the past), forwards (into the future), or both.</p> <dl>
<dt class="d_decl" id="Direction.bwd"><strong id="bwd">bwd</strong></dt> <dd>
<p>Backward.</p> </dd> <dt class="d_decl" id="Direction.fwd"><strong id="fwd">fwd</strong></dt> <dd>
<p>Forward.</p> </dd> <dt class="d_decl" id="Direction.both"><strong id="both">both</strong></dt> <dd>
<p>Both backward and forward.</p> </dd> </dl> </dd> <dt class="d_decl" id="PopFirst">alias <strong id="PopFirst">PopFirst</strong> = std.typecons.Flag!"popFirst".Flag; </dt> <dd>
<p>Used to indicate whether <code>popFront</code> should be called immediately upon creating a range. The idea is that for some functions used to generate a range for an interval, <code>front</code> is not necessarily a time point which would ever be generated by the range (e.g. if the range were every Sunday within an interval, but the interval started on a Monday), so there needs to be a way to deal with that. To get the first time point in the range to match what the function generates, then use <code>PopFirst.yes</code> to indicate that the range should have <code>popFront</code> called on it before the range is returned so that <code>front</code> is a time point which the function would generate. To let the first time point not match the generator function, use <code>PopFront.no</code>. </p>
<p>For instance, if the function used to generate a range of time points generated successive Easters (i.e. you're iterating over all of the Easters within the interval), the initial date probably isn't an Easter. Using <code>PopFirst.yes</code> would tell the function which returned the range that <code>popFront</code> was to be called so that front would then be an Easter - the next one generated by the function (which when iterating forward would be the Easter following the original <code>front</code>, while when iterating backward, it would be the Easter prior to the original <code>front</code>). If <code>PopFirst.no</code> were used, then <code>front</code> would remain the original time point and it would not necessarily be a time point which would be generated by the range-generating function (which in many cases is exactly what is desired - e.g. if iterating over every day starting at the beginning of the interval). <br><br> If set to <code>PopFirst.no</code>, then popFront is not called before returning the range. <br><br> Otherwise, if set to <code>PopFirst.yes</code>, then popFront is called before returning the range.</p> </dd> <dt class="d_decl" id="Interval">struct <strong id="Interval">Interval</strong>(TP); </dt> <dd>
<p>Represents an interval of time. </p>
<p>An <code>Interval</code> has a starting point and an end point. The interval of time is therefore the time starting at the starting point up to, but not including, the end point. e.g. <br><br> </p>
<table>
 <tr><td>[January 5th, 2010 - March 10th, 2010)</td></tr> <tr><td>[05:00:30 - 12:00:00)</td></tr> <tr><td>[1982-01-04T08:59:00 - 2010-07-04T12:00:00)</td></tr> </table> <br><br> A range can be obtained from an <code>Interval</code>, allowing iteration over that interval, with the exact time points which are iterated over depending on the function which generates the range. <dl>
<dt class="d_decl" id="Interval.this">pure this(U)(scope const TP begin, scope const U end)<br><small>  Constraints: if (is(Unqual!TP == Unqual!U)); </small>
</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TP <code>begin</code>
</td> <td>The time point which begins the interval.</td>
</tr> <tr>
<td>U <code>end</code>
</td> <td>The time point which ends (but is not included in) the interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if <span class="d_param">end</span> is before <span class="d_param">begin</span>. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1));
</pre>  </dd> <dt class="d_decl" id="Interval.this.2">pure this(D)(scope const TP begin, scope const D duration)<br><small>  Constraints: if (__traits(compiles, begin + duration)); </small>
</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TP <code>begin</code>
</td> <td>The time point which begins the interval.</td>
</tr> <tr>
<td>D <code>duration</code>
</td> <td>The duration from the starting point to the end point.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the resulting <code>end</code> is before <code>begin</code>. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(Interval!Date(Date(1996, 1, 2), dur!"days"(3)) ==
       Interval!Date(Date(1996, 1, 2), Date(1996, 1, 5)));
</pre>  </dd> <dt class="d_decl" id="Interval.opAssign">pure nothrow ref Interval <strong id="opAssign">opAssign</strong>(ref const Interval rhs); </dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval <code>rhs</code>
</td> <td>The <a href="#Interval"><code>Interval</code></a> to assign to this one.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Interval.opAssign.2">pure nothrow ref Interval <strong id="opAssign">opAssign</strong>(Interval rhs); </dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval <code>rhs</code>
</td> <td>The <a href="#Interval"><code>Interval</code></a> to assign to this one.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Interval.begin">const pure nothrow @property TP <strong id="begin">begin</strong>(); </dt> <dd>
<p>The starting point of the interval. It is included in the interval. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).begin ==
       Date(1996, 1, 2));
</pre>  </dd> <dt class="d_decl" id="Interval.begin.2">pure @property void <strong id="begin">begin</strong>(TP timePoint); </dt> <dd>
<p>The starting point of the interval. It is included in the interval. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TP <code>timePoint</code>
</td> <td>The time point to set <code>begin</code> to.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the resulting interval would be invalid.</dd>
</dl> </dd> <dt class="d_decl" id="Interval.end">const pure nothrow @property TP <strong id="end">end</strong>(); </dt> <dd>
<p>The end point of the interval. It is excluded from the interval. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).end ==
       Date(2012, 3, 1));
</pre>  </dd> <dt class="d_decl" id="Interval.end.2">pure @property void <strong id="end">end</strong>(TP timePoint); </dt> <dd>
<p>The end point of the interval. It is excluded from the interval. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TP <code>timePoint</code>
</td> <td>The time point to set end to.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the resulting interval would be invalid.</dd>
</dl> </dd> <dt class="d_decl" id="Interval.length">const pure nothrow @property auto <strong id="length">length</strong>(); </dt> <dd>
<p>Returns the duration between <code>begin</code> and <code>end</code>. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).length ==
       dur!"days"(5903));
</pre>  </dd> <dt class="d_decl" id="Interval.empty">const pure nothrow @property bool <strong id="empty">empty</strong>(); </dt> <dd>
<p>Whether the interval's length is 0, that is, whether <code>begin == end</code>. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(Interval!Date(Date(1996, 1, 2), Date(1996, 1, 2)).empty);
assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).empty);
</pre>  </dd> <dt class="d_decl" id="Interval.contains">const pure bool <strong id="contains">contains</strong>(scope const TP timePoint); </dt> <dd>
<p>Whether the given time point is within this interval. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TP <code>timePoint</code>
</td> <td>The time point to check for inclusion in this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this interval is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(
            Date(1994, 12, 24)));

assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(
            Date(2000, 1, 5)));
assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(
            Date(2012, 3, 1)));
</pre>  </dd> <dt class="d_decl" id="Interval.contains.2">const pure bool <strong id="contains">contains</strong>(scope const Interval interval); </dt> <dd>
<p>Whether the given interval is completely within this interval. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval <code>interval</code>
</td> <td>The interval to check for inclusion in this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if either interval is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));

assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));

assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(
            Interval!Date(Date(1998, 2, 28), Date(2013, 5, 1))));
</pre>  </dd> <dt class="d_decl" id="Interval.contains.3">const pure bool <strong id="contains">contains</strong>(scope const PosInfInterval!TP interval); </dt> <dd>
<p>Whether the given interval is completely within this interval. </p>
<p>Always returns false (unless this interval is empty), because an interval going to positive infinity can never be contained in a finite interval. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval!TP <code>interval</code>
</td> <td>The interval to check for inclusion in this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this interval is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(
            PosInfInterval!Date(Date(1999, 5, 4))));
</pre>  </dd> <dt class="d_decl" id="Interval.contains.4">const pure bool <strong id="contains">contains</strong>(scope const NegInfInterval!TP interval); </dt> <dd>
<p>Whether the given interval is completely within this interval. </p>
<p>Always returns false (unless this interval is empty), because an interval beginning at negative infinity can never be contained in a finite interval. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval!TP <code>interval</code>
</td> <td>The interval to check for inclusion in this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this interval is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(
            NegInfInterval!Date(Date(1996, 5, 4))));
</pre>  </dd> <dt class="d_decl" id="Interval.isBefore">const pure bool <strong id="isBefore">isBefore</strong>(scope const TP timePoint); </dt> <dd>
<p>Whether this interval is before the given time point. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TP <code>timePoint</code>
</td> <td>The time point to check whether this interval is before it.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this interval is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(
            Date(1994, 12, 24)));

assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(
            Date(2000, 1, 5)));

assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(
            Date(2012, 3, 1)));
</pre>  </dd> <dt class="d_decl" id="Interval.isBefore.2">const pure bool <strong id="isBefore">isBefore</strong>(scope const Interval interval); </dt> <dd>
<p>Whether this interval is before the given interval and does not intersect with it. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval <code>interval</code>
</td> <td>The interval to check for against this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if either interval is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));

assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));

assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(
            Interval!Date(Date(2012, 3, 1), Date(2013, 5, 1))));
</pre>  </dd> <dt class="d_decl" id="Interval.isBefore.3">const pure bool <strong id="isBefore">isBefore</strong>(scope const PosInfInterval!TP interval); </dt> <dd>
<p>Whether this interval is before the given interval and does not intersect with it. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval!TP <code>interval</code>
</td> <td>The interval to check for against this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this interval is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(
            PosInfInterval!Date(Date(1999, 5, 4))));

assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(
            PosInfInterval!Date(Date(2013, 3, 7))));
</pre>  </dd> <dt class="d_decl" id="Interval.isBefore.4">const pure bool <strong id="isBefore">isBefore</strong>(scope const NegInfInterval!TP interval); </dt> <dd>
<p>Whether this interval is before the given interval and does not intersect with it. </p>
<p>Always returns false (unless this interval is empty) because a finite interval can never be before an interval beginning at negative infinity. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval!TP <code>interval</code>
</td> <td>The interval to check for against this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this interval is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(
            NegInfInterval!Date(Date(1996, 5, 4))));
</pre>  </dd> <dt class="d_decl" id="Interval.isAfter">const pure bool <strong id="isAfter">isAfter</strong>(scope const TP timePoint); </dt> <dd>
<p>Whether this interval is after the given time point. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TP <code>timePoint</code>
</td> <td>The time point to check whether this interval is after it.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this interval is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(
            Date(1994, 12, 24)));

assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(
            Date(2000, 1, 5)));

assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(
            Date(2012, 3, 1)));
</pre>  </dd> <dt class="d_decl" id="Interval.isAfter.2">const pure bool <strong id="isAfter">isAfter</strong>(scope const Interval interval); </dt> <dd>
<p>Whether this interval is after the given interval and does not intersect it. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval <code>interval</code>
</td> <td>The interval to check against this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if either interval is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));

assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));

assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(
            Interval!Date(Date(1989, 3, 1), Date(1996, 1, 2))));
</pre>  </dd> <dt class="d_decl" id="Interval.isAfter.3">const pure bool <strong id="isAfter">isAfter</strong>(scope const PosInfInterval!TP interval); </dt> <dd>
<p>Whether this interval is after the given interval and does not intersect it. </p>
<p>Always returns false (unless this interval is empty) because a finite interval can never be after an interval going to positive infinity. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval!TP <code>interval</code>
</td> <td>The interval to check against this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this interval is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(
            PosInfInterval!Date(Date(1999, 5, 4))));
</pre>  </dd> <dt class="d_decl" id="Interval.isAfter.4">const pure bool <strong id="isAfter">isAfter</strong>(scope const NegInfInterval!TP interval); </dt> <dd>
<p>Whether this interval is after the given interval and does not intersect it. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval!TP <code>interval</code>
</td> <td>The interval to check against this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this interval is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(
            NegInfInterval!Date(Date(1996, 1, 2))));
</pre>  </dd> <dt class="d_decl" id="Interval.intersects">const pure bool <strong id="intersects">intersects</strong>(scope const Interval interval); </dt> <dd>
<p>Whether the given interval overlaps this interval. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval <code>interval</code>
</td> <td>The interval to check for intersection with this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if either interval is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersects(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));

assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersects(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));

assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersects(
            Interval!Date(Date(1989, 3, 1), Date(1996, 1, 2))));
</pre>  </dd> <dt class="d_decl" id="Interval.intersects.2">const pure bool <strong id="intersects">intersects</strong>(scope const PosInfInterval!TP interval); </dt> <dd>
<p>Whether the given interval overlaps this interval. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval!TP <code>interval</code>
</td> <td>The interval to check for intersection with this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this interval is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersects(
            PosInfInterval!Date(Date(1999, 5, 4))));

assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersects(
            PosInfInterval!Date(Date(2012, 3, 1))));
</pre>  </dd> <dt class="d_decl" id="Interval.intersects.3">const pure bool <strong id="intersects">intersects</strong>(scope const NegInfInterval!TP interval); </dt> <dd>
<p>Whether the given interval overlaps this interval. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval!TP <code>interval</code>
</td> <td>The interval to check for intersection with this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this interval is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersects(
            NegInfInterval!Date(Date(1996, 1, 2))));

assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersects(
            NegInfInterval!Date(Date(2000, 1, 2))));
</pre>  </dd> <dt class="d_decl" id="Interval.intersection">const Interval <strong id="intersection">intersection</strong>(scope const Interval interval); </dt> <dd>
<p>Returns the intersection of two intervals </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval <code>interval</code>
</td> <td>The interval to intersect with this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the two intervals do not intersect or if either interval is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersection(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==
       Interval!Date(Date(1996, 1 , 2), Date(2000, 8, 2)));

assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersection(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))) ==
       Interval!Date(Date(1999, 1 , 12), Date(2011, 9, 17)));
</pre>  </dd> <dt class="d_decl" id="Interval.intersection.2">const Interval <strong id="intersection">intersection</strong>(scope const PosInfInterval!TP interval); </dt> <dd>
<p>Returns the intersection of two intervals </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval!TP <code>interval</code>
</td> <td>The interval to intersect with this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the two intervals do not intersect or if this interval is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersection(
            PosInfInterval!Date(Date(1990, 7, 6))) ==
       Interval!Date(Date(1996, 1 , 2), Date(2012, 3, 1)));

assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersection(
            PosInfInterval!Date(Date(1999, 1, 12))) ==
       Interval!Date(Date(1999, 1 , 12), Date(2012, 3, 1)));
</pre>  </dd> <dt class="d_decl" id="Interval.intersection.3">const Interval <strong id="intersection">intersection</strong>(scope const NegInfInterval!TP interval); </dt> <dd>
<p>Returns the intersection of two intervals </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval!TP <code>interval</code>
</td> <td>The interval to intersect with this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the two intervals do not intersect or if this interval is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersection(
            NegInfInterval!Date(Date(1999, 7, 6))) ==
       Interval!Date(Date(1996, 1 , 2), Date(1999, 7, 6)));

assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersection(
            NegInfInterval!Date(Date(2013, 1, 12))) ==
       Interval!Date(Date(1996, 1 , 2), Date(2012, 3, 1)));
</pre>  </dd> <dt class="d_decl" id="Interval.isAdjacent">const pure bool <strong id="isAdjacent">isAdjacent</strong>(scope const Interval interval); </dt> <dd>
<p>Whether the given interval is adjacent to this interval. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval <code>interval</code>
</td> <td>The interval to check whether its adjecent to this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if either interval is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAdjacent(
            Interval!Date(Date(1990, 7, 6), Date(1996, 1, 2))));

assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAdjacent(
            Interval!Date(Date(2012, 3, 1), Date(2013, 9, 17))));

assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAdjacent(
            Interval!Date(Date(1989, 3, 1), Date(2012, 3, 1))));
</pre>  </dd> <dt class="d_decl" id="Interval.isAdjacent.2">const pure bool <strong id="isAdjacent">isAdjacent</strong>(scope const PosInfInterval!TP interval); </dt> <dd>
<p>Whether the given interval is adjacent to this interval. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval!TP <code>interval</code>
</td> <td>The interval to check whether its adjecent to this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this interval is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAdjacent(
            PosInfInterval!Date(Date(1999, 5, 4))));

assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAdjacent(
            PosInfInterval!Date(Date(2012, 3, 1))));
</pre>  </dd> <dt class="d_decl" id="Interval.isAdjacent.3">const pure bool <strong id="isAdjacent">isAdjacent</strong>(scope const NegInfInterval!TP interval); </dt> <dd>
<p>Whether the given interval is adjacent to this interval. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval!TP <code>interval</code>
</td> <td>The interval to check whether its adjecent to this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this interval is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAdjacent(
            NegInfInterval!Date(Date(1996, 1, 2))));

assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAdjacent(
            NegInfInterval!Date(Date(2000, 1, 2))));
</pre>  </dd> <dt class="d_decl" id="Interval.merge">const Interval <strong id="merge">merge</strong>(scope const Interval interval); </dt> <dd>
<p>Returns the union of two intervals </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval <code>interval</code>
</td> <td>The interval to merge with this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the two intervals do not intersect and are not adjacent or if either interval is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).merge(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==
       Interval!Date(Date(1990, 7 , 6), Date(2012, 3, 1)));

assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).merge(
            Interval!Date(Date(2012, 3, 1), Date(2013, 5, 7))) ==
       Interval!Date(Date(1996, 1 , 2), Date(2013, 5, 7)));
</pre>  </dd> <dt class="d_decl" id="Interval.merge.2">const PosInfInterval!TP <strong id="merge">merge</strong>(scope const PosInfInterval!TP interval); </dt> <dd>
<p>Returns the union of two intervals </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval!TP <code>interval</code>
</td> <td>The interval to merge with this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the two intervals do not intersect and are not adjacent or if this interval is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).merge(
            PosInfInterval!Date(Date(1990, 7, 6))) ==
       PosInfInterval!Date(Date(1990, 7 , 6)));

assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).merge(
            PosInfInterval!Date(Date(2012, 3, 1))) ==
       PosInfInterval!Date(Date(1996, 1 , 2)));
</pre>  </dd> <dt class="d_decl" id="Interval.merge.3">const NegInfInterval!TP <strong id="merge">merge</strong>(scope const NegInfInterval!TP interval); </dt> <dd>
<p>Returns the union of two intervals </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval!TP <code>interval</code>
</td> <td>The interval to merge with this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the two intervals do not intersect and are not adjacent or if this interval is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).merge(
            NegInfInterval!Date(Date(1996, 1, 2))) ==
       NegInfInterval!Date(Date(2012, 3 , 1)));

assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).merge(
            NegInfInterval!Date(Date(2013, 1, 12))) ==
       NegInfInterval!Date(Date(2013, 1 , 12)));
</pre>  </dd> <dt class="d_decl" id="Interval.span">const pure Interval <strong id="span">span</strong>(scope const Interval interval); </dt> <dd>
<p>Returns an interval that covers from the earliest time point of two intervals up to (but not including) the latest time point of two intervals. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval <code>interval</code>
</td> <td>The interval to create a span together with this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if either interval is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).span(
            Interval!Date(Date(1990, 7, 6), Date(1991, 1, 8))) ==
       Interval!Date(Date(1990, 7 , 6), Date(2012, 3, 1)));

assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).span(
            Interval!Date(Date(2012, 3, 1), Date(2013, 5, 7))) ==
       Interval!Date(Date(1996, 1 , 2), Date(2013, 5, 7)));
</pre>  </dd> <dt class="d_decl" id="Interval.span.2">const pure PosInfInterval!TP <strong id="span">span</strong>(scope const PosInfInterval!TP interval); </dt> <dd>
<p>Returns an interval that covers from the earliest time point of two intervals up to (but not including) the latest time point of two intervals. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval!TP <code>interval</code>
</td> <td>The interval to create a span together with this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this interval is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).span(
            PosInfInterval!Date(Date(1990, 7, 6))) ==
       PosInfInterval!Date(Date(1990, 7 , 6)));

assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).span(
            PosInfInterval!Date(Date(2050, 1, 1))) ==
       PosInfInterval!Date(Date(1996, 1 , 2)));
</pre>  </dd> <dt class="d_decl" id="Interval.span.3">const pure NegInfInterval!TP <strong id="span">span</strong>(scope const NegInfInterval!TP interval); </dt> <dd>
<p>Returns an interval that covers from the earliest time point of two intervals up to (but not including) the latest time point of two intervals. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval!TP <code>interval</code>
</td> <td>The interval to create a span together with this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this interval is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).span(
            NegInfInterval!Date(Date(1602, 5, 21))) ==
       NegInfInterval!Date(Date(2012, 3 , 1)));

assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).span(
            NegInfInterval!Date(Date(2013, 1, 12))) ==
       NegInfInterval!Date(Date(2013, 1 , 12)));
</pre>  </dd> <dt class="d_decl" id="Interval.shift">pure void <strong id="shift">shift</strong>(D)(D duration)<br><small>  Constraints: if (__traits(compiles, begin + duration)); </small>
</dt> <dd>
<p>Shifts the interval forward or backwards in time by the given duration (a positive duration shifts the interval forward; a negative duration shifts it backward). Effectively, it does <code>begin += duration</code> and <code>end += duration</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>D <code>duration</code>
</td> <td>The duration to shift the interval by.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> this interval is empty or if the resulting interval would be invalid. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto interval1 = Interval!Date(Date(1996, 1, 2), Date(2012, 4, 5));
auto interval2 = Interval!Date(Date(1996, 1, 2), Date(2012, 4, 5));

interval1.shift(dur!"days"(50));
assert(interval1 == Interval!Date(Date(1996, 2, 21), Date(2012, 5, 25)));

interval2.shift(dur!"days"(-50));
assert(interval2 == Interval!Date(Date(1995, 11, 13), Date(2012, 2, 15)));
</pre>  </dd> <dt class="d_decl" id="Interval.shift.2">void <strong id="shift">shift</strong>(T)(T years, T months = 0, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)<br><small>  Constraints: if (isIntegral!T); </small>
</dt> <dd>
<p>Shifts the interval forward or backwards in time by the given number of years and/or months (a positive number of years and months shifts the interval forward; a negative number shifts it backward). It adds the years the given years and months to both begin and end. It effectively calls <code>add!"years"()</code> and then <code>add!"months"()</code> on begin and end with the given number of years and months. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>years</code>
</td> <td>The number of years to shift the interval by.</td>
</tr> <tr>
<td>T <code>months</code>
</td> <td>The number of months to shift the interval by.</td>
</tr> <tr>
<td>AllowDayOverflow <code>allowOverflow</code>
</td> <td>Whether the days should be allowed to overflow on <code>begin</code> and <code>end</code>, causing their month to increment.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this interval is empty or if the resulting interval would be invalid. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto interval1 = Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1));
auto interval2 = Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1));

interval1.shift(2);
assert(interval1 == Interval!Date(Date(1998, 1, 2), Date(2014, 3, 1)));

interval2.shift(-2);
assert(interval2 == Interval!Date(Date(1994, 1, 2), Date(2010, 3, 1)));
</pre>  </dd> <dt class="d_decl" id="Interval.expand">pure void <strong id="expand">expand</strong>(D)(D duration, Direction dir = Direction.both)<br><small>  Constraints: if (__traits(compiles, begin + duration)); </small>
</dt> <dd>
<p>Expands the interval forwards and/or backwards in time. Effectively, it does <code>begin -= duration</code> and/or <code>end += duration</code>. Whether it expands forwards and/or backwards in time is determined by <span class="d_param">dir</span>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>D <code>duration</code>
</td> <td>The duration to expand the interval by.</td>
</tr> <tr>
<td>Direction <code>dir</code>
</td> <td>The direction in time to expand the interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> this interval is empty or if the resulting interval would be invalid. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto interval1 = Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1));
auto interval2 = Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1));

interval1.expand(2);
assert(interval1 == Interval!Date(Date(1994, 1, 2), Date(2014, 3, 1)));

interval2.expand(-2);
assert(interval2 == Interval!Date(Date(1998, 1, 2), Date(2010, 3, 1)));
</pre>  </dd> <dt class="d_decl" id="Interval.expand.2">void <strong id="expand">expand</strong>(T)(T years, T months = 0, AllowDayOverflow allowOverflow = AllowDayOverflow.yes, Direction dir = Direction.both)<br><small>  Constraints: if (isIntegral!T); </small>
</dt> <dd>
<p>Expands the interval forwards and/or backwards in time. Effectively, it subtracts the given number of months/years from <code>begin</code> and adds them to <code>end</code>. Whether it expands forwards and/or backwards in time is determined by <span class="d_param">dir</span>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>years</code>
</td> <td>The number of years to expand the interval by.</td>
</tr> <tr>
<td>T <code>months</code>
</td> <td>The number of months to expand the interval by.</td>
</tr> <tr>
<td>AllowDayOverflow <code>allowOverflow</code>
</td> <td>Whether the days should be allowed to overflow on <code>begin</code> and <code>end</code>, causing their month to increment.</td>
</tr> <tr>
<td>Direction <code>dir</code>
</td> <td>The direction in time to expand the interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this interval is empty or if the resulting interval would be invalid. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto interval1 = Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1));
auto interval2 = Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1));

interval1.expand(2);
assert(interval1 == Interval!Date(Date(1994, 1, 2), Date(2014, 3, 1)));

interval2.expand(-2);
assert(interval2 == Interval!Date(Date(1998, 1, 2), Date(2010, 3, 1)));
</pre>  </dd> <dt class="d_decl" id="Interval.fwdRange">const IntervalRange!(TP, Direction.fwd) <strong id="fwdRange">fwdRange</strong>(TP delegate(scope const TP) func, PopFirst popFirst = PopFirst.no); </dt> <dd>
<p>Returns a range which iterates forward over the interval, starting at <code>begin</code>, using <span class="d_param">func</span> to generate each successive time point. </p>
<p>The range's <code>front</code> is the interval's <code>begin</code>. <span class="d_param">func</span> is used to generate the next <code>front</code> when <code>popFront</code> is called. If <span class="d_param">popFirst</span> is <code>PopFirst.yes</code>, then <code>popFront</code> is called before the range is returned (so that <code>front</code> is a time point which <span class="d_param">func</span> would generate). <br><br> If <span class="d_param">func</span> ever generates a time point less than or equal to the current <code>front</code> of the range, then a <a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> will be thrown. The range will be empty and iteration complete when <span class="d_param">func</span> generates a time point equal to or beyond the <code>end</code> of the interval. <br><br> There are helper functions in this module which generate common delegates to pass to <code>fwdRange</code>. Their documentation starts with "Range-generating function," making them easily searchable. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TP delegate(scope const TP) <code>func</code>
</td> <td>The function used to generate the time points of the range over the interval.</td>
</tr> <tr>
<td>PopFirst <code>popFirst</code>
</td> <td>Whether <code>popFront</code> should be called on the range before returning it.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this interval is empty. </dd>
</dl> <dl>
<dt>Warning</dt>
<dd> <span class="d_param">func</span> must be logically pure. Ideally, <span class="d_param">func</span> would be a function pointer to a pure function, but forcing <span class="d_param">func</span> to be pure is far too restrictive to be useful, and in order to have the ease of use of having functions which generate functions to pass to <code>fwdRange</code>, <span class="d_param">func</span> must be a delegate. </dd>
</dl> If <span class="d_param">func</span> retains state which changes as it is called, then some algorithms will not work correctly, because the range's <code>save</code> will have failed to have really saved the range's state. To avoid such bugs, don't pass a delegate which is not logically pure to <code>fwdRange</code>. If <span class="d_param">func</span> is given the same time point with two different calls, it must return the same result both times.  Of course, none of the functions in this module have this problem, so it's only relevant if when creating a custom delegate.  <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto interval = Interval!Date(Date(2010, 9, 1), Date(2010, 9, 9));
auto func = delegate (scope const Date date) // For iterating over even-numbered days.
            {
                if ((date.day &amp; 1) == 0)
                    return date + dur!"days"(2);

                return date + dur!"days"(1);
            };
auto range = interval.fwdRange(func);

// An odd day. Using PopFirst.yes would have made this Date(2010, 9, 2).
assert(range.front == Date(2010, 9, 1));

range.popFront();
assert(range.front == Date(2010, 9, 2));

range.popFront();
assert(range.front == Date(2010, 9, 4));

range.popFront();
assert(range.front == Date(2010, 9, 6));

range.popFront();
assert(range.front == Date(2010, 9, 8));

range.popFront();
assert(range.empty);
</pre>  </dd> <dt class="d_decl" id="Interval.bwdRange">const IntervalRange!(TP, Direction.bwd) <strong id="bwdRange">bwdRange</strong>(TP delegate(scope const TP) func, PopFirst popFirst = PopFirst.no); </dt> <dd>
<p>Returns a range which iterates backwards over the interval, starting at <code>end</code>, using <span class="d_param">func</span> to generate each successive time point. </p>
<p>The range's <code>front</code> is the interval's <code>end</code>. <span class="d_param">func</span> is used to generate the next <code>front</code> when <code>popFront</code> is called. If <span class="d_param">popFirst</span> is <code>PopFirst.yes</code>, then <code>popFront</code> is called before the range is returned (so that <code>front</code> is a time point which <span class="d_param">func</span> would generate). <br><br> If <span class="d_param">func</span> ever generates a time point greater than or equal to the current <code>front</code> of the range, then a <a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> will be thrown. The range will be empty and iteration complete when <span class="d_param">func</span> generates a time point equal to or less than the <code>begin</code> of the interval. <br><br> There are helper functions in this module which generate common delegates to pass to <code>bwdRange</code>. Their documentation starts with "Range-generating function," making them easily searchable. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TP delegate(scope const TP) <code>func</code>
</td> <td>The function used to generate the time points of the range over the interval.</td>
</tr> <tr>
<td>PopFirst <code>popFirst</code>
</td> <td>Whether <code>popFront</code> should be called on the range before returning it.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this interval is empty. </dd>
</dl> <dl>
<dt>Warning</dt>
<dd> <span class="d_param">func</span> must be logically pure. Ideally, <span class="d_param">func</span> would be a function pointer to a pure function, but forcing <span class="d_param">func</span> to be pure is far too restrictive to be useful, and in order to have the ease of use of having functions which generate functions to pass to <code>fwdRange</code>, <span class="d_param">func</span> must be a delegate. </dd>
</dl> If <span class="d_param">func</span> retains state which changes as it is called, then some algorithms will not work correctly, because the range's <code>save</code> will have failed to have really saved the range's state. To avoid such bugs, don't pass a delegate which is not logically pure to <code>fwdRange</code>. If <span class="d_param">func</span> is given the same time point with two different calls, it must return the same result both times.  Of course, none of the functions in this module have this problem, so it's only relevant for custom delegates.  <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto interval = Interval!Date(Date(2010, 9, 1), Date(2010, 9, 9));
auto func = delegate (scope const Date date) // For iterating over even-numbered days.
            {
                if ((date.day &amp; 1) == 0)
                    return date - dur!"days"(2);

                return date - dur!"days"(1);
            };
auto range = interval.bwdRange(func);

// An odd day. Using PopFirst.yes would have made this Date(2010, 9, 8).
assert(range.front == Date(2010, 9, 9));

range.popFront();
assert(range.front == Date(2010, 9, 8));

range.popFront();
assert(range.front == Date(2010, 9, 6));

range.popFront();
assert(range.front == Date(2010, 9, 4));

range.popFront();
assert(range.front == Date(2010, 9, 2));

range.popFront();
assert(range.empty);
</pre>  </dd> <dt class="d_decl" id="Interval.toString">const nothrow @safe string <strong id="toString">toString</strong>(); <br><br>const void <strong id="toString">toString</strong>(Writer)(ref Writer w)<br><small>  Constraints: if (isOutputRange!(Writer, char)); </small>
</dt> <dd>
<p>Converts this interval to a string. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Writer <code>w</code>
</td> <td>A <code>char</code> accepting <a href="std_range_primitives#isOutputRange">output range</a>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A <code>string</code> when not using an output range; <code>void</code> otherwise.</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="PosInfInterval">struct <strong id="PosInfInterval">PosInfInterval</strong>(TP); </dt> <dd>
<p>Represents an interval of time which has positive infinity as its end point. </p>
<p>Any ranges which iterate over a <code>PosInfInterval</code> are infinite. So, the main purpose of using <code>PosInfInterval</code> is to create an infinite range which starts at a fixed point in time and goes to positive infinity.</p> <dl>
<dt class="d_decl" id="PosInfInterval.this">pure nothrow this(scope const TP begin); </dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TP <code>begin</code>
</td> <td>The time point which begins the interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto interval = PosInfInterval!Date(Date(1996, 1, 2));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.opAssign">pure nothrow ref PosInfInterval <strong id="opAssign">opAssign</strong>(ref const PosInfInterval rhs); </dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval <code>rhs</code>
</td> <td>The <code>PosInfInterval</code> to assign to this one.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="PosInfInterval.opAssign.2">pure nothrow ref PosInfInterval <strong id="opAssign">opAssign</strong>(PosInfInterval rhs); </dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval <code>rhs</code>
</td> <td>The <code>PosInfInterval</code> to assign to this one.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="PosInfInterval.begin">const pure nothrow @property TP <strong id="begin">begin</strong>(); </dt> <dd>
<p>The starting point of the interval. It is included in the interval. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(PosInfInterval!Date(Date(1996, 1, 2)).begin == Date(1996, 1, 2));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.begin.2">pure nothrow @property void <strong id="begin">begin</strong>(TP timePoint); </dt> <dd>
<p>The starting point of the interval. It is included in the interval. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TP <code>timePoint</code>
</td> <td>The time point to set <code>begin</code> to.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="PosInfInterval.empty">enum bool <strong id="empty">empty</strong>; </dt> <dd>
<p>Whether the interval's length is 0. Always returns false. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!PosInfInterval!Date(Date(1996, 1, 2)).empty);
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.contains">const pure nothrow bool <strong id="contains">contains</strong>(TP timePoint); </dt> <dd>
<p>Whether the given time point is within this interval. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TP <code>timePoint</code>
</td> <td>The time point to check for inclusion in this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!PosInfInterval!Date(Date(1996, 1, 2)).contains(Date(1994, 12, 24)));
assert(PosInfInterval!Date(Date(1996, 1, 2)).contains(Date(2000, 1, 5)));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.contains.2">const pure bool <strong id="contains">contains</strong>(scope const Interval!TP interval); </dt> <dd>
<p>Whether the given interval is completely within this interval. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval!TP <code>interval</code>
</td> <td>The interval to check for inclusion in this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given interval is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!PosInfInterval!Date(Date(1996, 1, 2)).contains(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));

assert(PosInfInterval!Date(Date(1996, 1, 2)).contains(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));

assert(PosInfInterval!Date(Date(1996, 1, 2)).contains(
            Interval!Date(Date(1998, 2, 28), Date(2013, 5, 1))));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.contains.3">const pure nothrow bool <strong id="contains">contains</strong>(scope const PosInfInterval interval); </dt> <dd>
<p>Whether the given interval is completely within this interval. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval <code>interval</code>
</td> <td>The interval to check for inclusion in this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(PosInfInterval!Date(Date(1996, 1, 2)).contains(
            PosInfInterval!Date(Date(1999, 5, 4))));

assert(!PosInfInterval!Date(Date(1996, 1, 2)).contains(
            PosInfInterval!Date(Date(1995, 7, 2))));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.contains.4">const pure nothrow bool <strong id="contains">contains</strong>(scope const NegInfInterval!TP interval); </dt> <dd>
<p>Whether the given interval is completely within this interval. </p>
<p>Always returns false because an interval going to positive infinity can never contain an interval beginning at negative infinity. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval!TP <code>interval</code>
</td> <td>The interval to check for inclusion in this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!PosInfInterval!Date(Date(1996, 1, 2)).contains(
            NegInfInterval!Date(Date(1996, 5, 4))));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.isBefore">const pure nothrow bool <strong id="isBefore">isBefore</strong>(scope const TP timePoint); </dt> <dd>
<p>Whether this interval is before the given time point. </p>
<p>Always returns false because an interval going to positive infinity can never be before any time point. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TP <code>timePoint</code>
</td> <td>The time point to check whether this interval is before it.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!PosInfInterval!Date(Date(1996, 1, 2)).isBefore(Date(1994, 12, 24)));
assert(!PosInfInterval!Date(Date(1996, 1, 2)).isBefore(Date(2000, 1, 5)));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.isBefore.2">const pure bool <strong id="isBefore">isBefore</strong>(scope const Interval!TP interval); </dt> <dd>
<p>Whether this interval is before the given interval and does not intersect it. </p>
<p>Always returns false (unless the given interval is empty) because an interval going to positive infinity can never be before any other interval. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval!TP <code>interval</code>
</td> <td>The interval to check for against this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given interval is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!PosInfInterval!Date(Date(1996, 1, 2)).isBefore(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));

assert(!PosInfInterval!Date(Date(1996, 1, 2)).isBefore(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.isBefore.3">const pure nothrow bool <strong id="isBefore">isBefore</strong>(scope const PosInfInterval interval); </dt> <dd>
<p>Whether this interval is before the given interval and does not intersect it. </p>
<p>Always returns false because an interval going to positive infinity can never be before any other interval. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval <code>interval</code>
</td> <td>The interval to check for against this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!PosInfInterval!Date(Date(1996, 1, 2)).isBefore(
            PosInfInterval!Date(Date(1992, 5, 4))));

assert(!PosInfInterval!Date(Date(1996, 1, 2)).isBefore(
            PosInfInterval!Date(Date(2013, 3, 7))));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.isBefore.4">const pure nothrow bool <strong id="isBefore">isBefore</strong>(scope const NegInfInterval!TP interval); </dt> <dd>
<p>Whether this interval is before the given interval and does not intersect it. </p>
<p>Always returns false because an interval going to positive infinity can never be before any other interval. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval!TP <code>interval</code>
</td> <td>The interval to check for against this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!PosInfInterval!Date(Date(1996, 1, 2)).isBefore(
            NegInfInterval!Date(Date(1996, 5, 4))));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.isAfter">const pure nothrow bool <strong id="isAfter">isAfter</strong>(scope const TP timePoint); </dt> <dd>
<p>Whether this interval is after the given time point. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TP <code>timePoint</code>
</td> <td>The time point to check whether this interval is after it.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(PosInfInterval!Date(Date(1996, 1, 2)).isAfter(Date(1994, 12, 24)));
assert(!PosInfInterval!Date(Date(1996, 1, 2)).isAfter(Date(2000, 1, 5)));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.isAfter.2">const pure bool <strong id="isAfter">isAfter</strong>(scope const Interval!TP interval); </dt> <dd>
<p>Whether this interval is after the given interval and does not intersect it. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval!TP <code>interval</code>
</td> <td>The interval to check against this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given interval is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!PosInfInterval!Date(Date(1996, 1, 2)).isAfter(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));

assert(!PosInfInterval!Date(Date(1996, 1, 2)).isAfter(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));

assert(PosInfInterval!Date(Date(1996, 1, 2)).isAfter(
            Interval!Date(Date(1989, 3, 1), Date(1996, 1, 2))));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.isAfter.3">const pure nothrow bool <strong id="isAfter">isAfter</strong>(scope const PosInfInterval interval); </dt> <dd>
<p>Whether this interval is after the given interval and does not intersect it. </p>
<p>Always returns false because an interval going to positive infinity can never be after another interval going to positive infinity. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval <code>interval</code>
</td> <td>The interval to check against this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!PosInfInterval!Date(Date(1996, 1, 2)).isAfter(
            PosInfInterval!Date(Date(1990, 1, 7))));

assert(!PosInfInterval!Date(Date(1996, 1, 2)).isAfter(
            PosInfInterval!Date(Date(1999, 5, 4))));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.isAfter.4">const pure nothrow bool <strong id="isAfter">isAfter</strong>(scope const NegInfInterval!TP interval); </dt> <dd>
<p>Whether this interval is after the given interval and does not intersect it. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval!TP <code>interval</code>
</td> <td>The interval to check against this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(PosInfInterval!Date(Date(1996, 1, 2)).isAfter(
            NegInfInterval!Date(Date(1996, 1, 2))));

assert(!PosInfInterval!Date(Date(1996, 1, 2)).isAfter(
            NegInfInterval!Date(Date(2000, 7, 1))));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.intersects">const pure bool <strong id="intersects">intersects</strong>(scope const Interval!TP interval); </dt> <dd>
<p>Whether the given interval overlaps this interval. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval!TP <code>interval</code>
</td> <td>The interval to check for intersection with this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given interval is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(PosInfInterval!Date(Date(1996, 1, 2)).intersects(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));

assert(PosInfInterval!Date(Date(1996, 1, 2)).intersects(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));

assert(!PosInfInterval!Date(Date(1996, 1, 2)).intersects(
            Interval!Date(Date(1989, 3, 1), Date(1996, 1, 2))));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.intersects.2">const pure nothrow bool <strong id="intersects">intersects</strong>(scope const PosInfInterval interval); </dt> <dd>
<p>Whether the given interval overlaps this interval. </p>
<p>Always returns true because two intervals going to positive infinity always overlap. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval <code>interval</code>
</td> <td>The interval to check for intersection with this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(PosInfInterval!Date(Date(1996, 1, 2)).intersects(
            PosInfInterval!Date(Date(1990, 1, 7))));

assert(PosInfInterval!Date(Date(1996, 1, 2)).intersects(
            PosInfInterval!Date(Date(1999, 5, 4))));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.intersects.3">const pure nothrow bool <strong id="intersects">intersects</strong>(scope const NegInfInterval!TP interval); </dt> <dd>
<p>Whether the given interval overlaps this interval. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval!TP <code>interval</code>
</td> <td>The interval to check for intersection with this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!PosInfInterval!Date(Date(1996, 1, 2)).intersects(
            NegInfInterval!Date(Date(1996, 1, 2))));

assert(PosInfInterval!Date(Date(1996, 1, 2)).intersects(
            NegInfInterval!Date(Date(2000, 7, 1))));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.intersection">const Interval!TP <strong id="intersection">intersection</strong>(scope const Interval!TP interval); </dt> <dd>
<p>Returns the intersection of two intervals </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval!TP <code>interval</code>
</td> <td>The interval to intersect with this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the two intervals do not intersect or if the given interval is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(PosInfInterval!Date(Date(1996, 1, 2)).intersection(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==
       Interval!Date(Date(1996, 1 , 2), Date(2000, 8, 2)));

assert(PosInfInterval!Date(Date(1996, 1, 2)).intersection(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))) ==
       Interval!Date(Date(1999, 1 , 12), Date(2011, 9, 17)));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.intersection.2">const pure nothrow PosInfInterval <strong id="intersection">intersection</strong>(scope const PosInfInterval interval); </dt> <dd>
<p>Returns the intersection of two intervals </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval <code>interval</code>
</td> <td>The interval to intersect with this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(PosInfInterval!Date(Date(1996, 1, 2)).intersection(
            PosInfInterval!Date(Date(1990, 7, 6))) ==
       PosInfInterval!Date(Date(1996, 1 , 2)));

assert(PosInfInterval!Date(Date(1996, 1, 2)).intersection(
            PosInfInterval!Date(Date(1999, 1, 12))) ==
       PosInfInterval!Date(Date(1999, 1 , 12)));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.intersection.3">const Interval!TP <strong id="intersection">intersection</strong>(scope const NegInfInterval!TP interval); </dt> <dd>
<p>Returns the intersection of two intervals </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval!TP <code>interval</code>
</td> <td>The interval to intersect with this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the two intervals do not intersect. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(PosInfInterval!Date(Date(1996, 1, 2)).intersection(
            NegInfInterval!Date(Date(1999, 7, 6))) ==
       Interval!Date(Date(1996, 1 , 2), Date(1999, 7, 6)));

assert(PosInfInterval!Date(Date(1996, 1, 2)).intersection(
            NegInfInterval!Date(Date(2013, 1, 12))) ==
       Interval!Date(Date(1996, 1 , 2), Date(2013, 1, 12)));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.isAdjacent">const pure bool <strong id="isAdjacent">isAdjacent</strong>(scope const Interval!TP interval); </dt> <dd>
<p>Whether the given interval is adjacent to this interval. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval!TP <code>interval</code>
</td> <td>The interval to check whether its adjecent to this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given interval is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(PosInfInterval!Date(Date(1996, 1, 2)).isAdjacent(
            Interval!Date(Date(1989, 3, 1), Date(1996, 1, 2))));

assert(!PosInfInterval!Date(Date(1999, 1, 12)).isAdjacent(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.isAdjacent.2">const pure nothrow bool <strong id="isAdjacent">isAdjacent</strong>(scope const PosInfInterval interval); </dt> <dd>
<p>Whether the given interval is adjacent to this interval. </p>
<p>Always returns false because two intervals going to positive infinity can never be adjacent to one another. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval <code>interval</code>
</td> <td>The interval to check whether its adjecent to this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!PosInfInterval!Date(Date(1996, 1, 2)).isAdjacent(
            PosInfInterval!Date(Date(1990, 1, 7))));

assert(!PosInfInterval!Date(Date(1996, 1, 2)).isAdjacent(
            PosInfInterval!Date(Date(1996, 1, 2))));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.isAdjacent.3">const pure nothrow bool <strong id="isAdjacent">isAdjacent</strong>(scope const NegInfInterval!TP interval); </dt> <dd>
<p>Whether the given interval is adjacent to this interval. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval!TP <code>interval</code>
</td> <td>The interval to check whether its adjecent to this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(PosInfInterval!Date(Date(1996, 1, 2)).isAdjacent(
            NegInfInterval!Date(Date(1996, 1, 2))));

assert(!PosInfInterval!Date(Date(1996, 1, 2)).isAdjacent(
            NegInfInterval!Date(Date(2000, 7, 1))));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.merge">const PosInfInterval <strong id="merge">merge</strong>(scope const Interval!TP interval); </dt> <dd>
<p>Returns the union of two intervals </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval!TP <code>interval</code>
</td> <td>The interval to merge with this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the two intervals do not intersect and are not adjacent or if the given interval is empty. </dd>
</dl> <dl>
<dt>Note</dt>
<dd> There is no overload for <code>merge</code> which takes a <code>NegInfInterval</code>, because an interval going from negative infinity to positive infinity is not possible. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(PosInfInterval!Date(Date(1996, 1, 2)).merge(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==
       PosInfInterval!Date(Date(1990, 7 , 6)));

assert(PosInfInterval!Date(Date(1996, 1, 2)).merge(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))) ==
       PosInfInterval!Date(Date(1996, 1 , 2)));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.merge.2">const pure nothrow PosInfInterval <strong id="merge">merge</strong>(scope const PosInfInterval interval); </dt> <dd>
<p>Returns the union of two intervals </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval <code>interval</code>
</td> <td>The interval to merge with this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Note</dt>
<dd> There is no overload for <code>merge</code> which takes a <code>NegInfInterval</code>, because an interval going from negative infinity to positive infinity is not possible. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(PosInfInterval!Date(Date(1996, 1, 2)).merge(
            PosInfInterval!Date(Date(1990, 7, 6))) ==
       PosInfInterval!Date(Date(1990, 7 , 6)));

assert(PosInfInterval!Date(Date(1996, 1, 2)).merge(
            PosInfInterval!Date(Date(1999, 1, 12))) ==
       PosInfInterval!Date(Date(1996, 1 , 2)));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.span">const pure PosInfInterval <strong id="span">span</strong>(scope const Interval!TP interval); </dt> <dd>
<p>Returns an interval that covers from the earliest time point of two intervals up to (but not including) the latest time point of two intervals. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval!TP <code>interval</code>
</td> <td>The interval to create a span together with this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given interval is empty. </dd>
</dl> <dl>
<dt>Note</dt>
<dd> There is no overload for <code>span</code> which takes a <code>NegInfInterval</code>, because an interval going from negative infinity to positive infinity is not possible. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(PosInfInterval!Date(Date(1996, 1, 2)).span(
            Interval!Date(Date(500, 8, 9), Date(1602, 1, 31))) ==
       PosInfInterval!Date(Date(500, 8, 9)));

assert(PosInfInterval!Date(Date(1996, 1, 2)).span(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==
       PosInfInterval!Date(Date(1990, 7 , 6)));

assert(PosInfInterval!Date(Date(1996, 1, 2)).span(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))) ==
       PosInfInterval!Date(Date(1996, 1 , 2)));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.span.2">const pure nothrow PosInfInterval <strong id="span">span</strong>(scope const PosInfInterval interval); </dt> <dd>
<p>Returns an interval that covers from the earliest time point of two intervals up to (but not including) the latest time point of two intervals. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval <code>interval</code>
</td> <td>The interval to create a span together with this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Note</dt>
<dd> There is no overload for <code>span</code> which takes a <code>NegInfInterval</code>, because an interval going from negative infinity to positive infinity is not possible. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(PosInfInterval!Date(Date(1996, 1, 2)).span(
            PosInfInterval!Date(Date(1990, 7, 6))) ==
       PosInfInterval!Date(Date(1990, 7 , 6)));

assert(PosInfInterval!Date(Date(1996, 1, 2)).span(
            PosInfInterval!Date(Date(1999, 1, 12))) ==
       PosInfInterval!Date(Date(1996, 1 , 2)));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.shift">pure nothrow void <strong id="shift">shift</strong>(D)(D duration)<br><small>  Constraints: if (__traits(compiles, begin + duration)); </small>
</dt> <dd>
<p>Shifts the <code>begin</code> of this interval forward or backwards in time by the given duration (a positive duration shifts the interval forward; a negative duration shifts it backward). Effectively, it does <code>begin += duration</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>D <code>duration</code>
</td> <td>The duration to shift the interval by.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto interval1 = PosInfInterval!Date(Date(1996, 1, 2));
auto interval2 = PosInfInterval!Date(Date(1996, 1, 2));

interval1.shift(dur!"days"(50));
assert(interval1 == PosInfInterval!Date(Date(1996, 2, 21)));

interval2.shift(dur!"days"(-50));
assert(interval2 == PosInfInterval!Date(Date(1995, 11, 13)));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.shift.2">void <strong id="shift">shift</strong>(T)(T years, T months = 0, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)<br><small>  Constraints: if (isIntegral!T); </small>
</dt> <dd>
<p>Shifts the <code>begin</code> of this interval forward or backwards in time by the given number of years and/or months (a positive number of years and months shifts the interval forward; a negative number shifts it backward). It adds the years the given years and months to <code>begin</code>. It effectively calls <code>add!"years"()</code> and then <code>add!"months"()</code> on <code>begin</code> with the given number of years and months. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>years</code>
</td> <td>The number of years to shift the interval by.</td>
</tr> <tr>
<td>T <code>months</code>
</td> <td>The number of months to shift the interval by.</td>
</tr> <tr>
<td>AllowDayOverflow <code>allowOverflow</code>
</td> <td>Whether the days should be allowed to overflow on <code>begin</code>, causing its month to increment.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this interval is empty or if the resulting interval would be invalid. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto interval1 = PosInfInterval!Date(Date(1996, 1, 2));
auto interval2 = PosInfInterval!Date(Date(1996, 1, 2));

interval1.shift(dur!"days"(50));
assert(interval1 == PosInfInterval!Date(Date(1996, 2, 21)));

interval2.shift(dur!"days"(-50));
assert(interval2 == PosInfInterval!Date(Date(1995, 11, 13)));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.expand">pure nothrow void <strong id="expand">expand</strong>(D)(D duration)<br><small>  Constraints: if (__traits(compiles, begin + duration)); </small>
</dt> <dd>
<p>Expands the interval backwards in time. Effectively, it does <code>begin -= duration</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>D <code>duration</code>
</td> <td>The duration to expand the interval by.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto interval1 = PosInfInterval!Date(Date(1996, 1, 2));
auto interval2 = PosInfInterval!Date(Date(1996, 1, 2));

interval1.expand(dur!"days"(2));
assert(interval1 == PosInfInterval!Date(Date(1995, 12, 31)));

interval2.expand(dur!"days"(-2));
assert(interval2 == PosInfInterval!Date(Date(1996, 1, 4)));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.expand.2">void <strong id="expand">expand</strong>(T)(T years, T months = 0, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)<br><small>  Constraints: if (isIntegral!T); </small>
</dt> <dd>
<p>Expands the interval forwards and/or backwards in time. Effectively, it subtracts the given number of months/years from <code>begin</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>years</code>
</td> <td>The number of years to expand the interval by.</td>
</tr> <tr>
<td>T <code>months</code>
</td> <td>The number of months to expand the interval by.</td>
</tr> <tr>
<td>AllowDayOverflow <code>allowOverflow</code>
</td> <td>Whether the days should be allowed to overflow on <code>begin</code>, causing its month to increment.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this interval is empty or if the resulting interval would be invalid. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto interval1 = PosInfInterval!Date(Date(1996, 1, 2));
auto interval2 = PosInfInterval!Date(Date(1996, 1, 2));

interval1.expand(2);
assert(interval1 == PosInfInterval!Date(Date(1994, 1, 2)));

interval2.expand(-2);
assert(interval2 == PosInfInterval!Date(Date(1998, 1, 2)));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.fwdRange">const PosInfIntervalRange!TP <strong id="fwdRange">fwdRange</strong>(TP delegate(scope const TP) func, PopFirst popFirst = PopFirst.no); </dt> <dd>
<p>Returns a range which iterates forward over the interval, starting at <code>begin</code>, using <span class="d_param">func</span> to generate each successive time point. </p>
<p>The range's <code>front</code> is the interval's <code>begin</code>. <span class="d_param">func</span> is used to generate the next <code>front</code> when <code>popFront</code> is called. If <span class="d_param">popFirst</span> is <code>PopFirst.yes</code>, then <code>popFront</code> is called before the range is returned (so that <code>front</code> is a time point which <span class="d_param">func</span> would generate). <br><br> If <span class="d_param">func</span> ever generates a time point less than or equal to the current <code>front</code> of the range, then a <a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> will be thrown. <br><br> There are helper functions in this module which generate common delegates to pass to <code>fwdRange</code>. Their documentation starts with "Range-generating function," to make them easily searchable. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TP delegate(scope const TP) <code>func</code>
</td> <td>The function used to generate the time points of the range over the interval.</td>
</tr> <tr>
<td>PopFirst <code>popFirst</code>
</td> <td>Whether <code>popFront</code> should be called on the range before returning it.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this interval is empty. </dd>
</dl> <dl>
<dt>Warning</dt>
<dd> <span class="d_param">func</span> must be logically pure. Ideally, <span class="d_param">func</span> would be a function pointer to a pure function, but forcing <span class="d_param">func</span> to be pure is far too restrictive to be useful, and in order to have the ease of use of having functions which generate functions to pass to <code>fwdRange</code>, <span class="d_param">func</span> must be a delegate. </dd>
</dl> If <span class="d_param">func</span> retains state which changes as it is called, then some algorithms will not work correctly, because the range's <code>save</code> will have failed to have really saved the range's state. To avoid such bugs, don't pass a delegate which is not logically pure to <code>fwdRange</code>. If <span class="d_param">func</span> is given the same time point with two different calls, it must return the same result both times.  Of course, none of the functions in this module have this problem, so it's only relevant for custom delegates.  <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto interval = PosInfInterval!Date(Date(2010, 9, 1));
auto func = delegate (scope const Date date) //For iterating over even-numbered days.
            {
                if ((date.day &amp; 1) == 0)
                    return date + dur!"days"(2);

                return date + dur!"days"(1);
            };
auto range = interval.fwdRange(func);

//An odd day. Using PopFirst.yes would have made this Date(2010, 9, 2).
assert(range.front == Date(2010, 9, 1));

range.popFront();
assert(range.front == Date(2010, 9, 2));

range.popFront();
assert(range.front == Date(2010, 9, 4));

range.popFront();
assert(range.front == Date(2010, 9, 6));

range.popFront();
assert(range.front == Date(2010, 9, 8));

range.popFront();
assert(!range.empty);
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.toString">const nothrow string <strong id="toString">toString</strong>(); </dt> <dd>
<p>Converts this interval to a string.</p> </dd> </dl> </dd> <dt class="d_decl" id="NegInfInterval">struct <strong id="NegInfInterval">NegInfInterval</strong>(TP); </dt> <dd>
<p>Represents an interval of time which has negative infinity as its starting point. </p>
<p>Any ranges which iterate over a <code>NegInfInterval</code> are infinite. So, the main purpose of using <code>NegInfInterval</code> is to create an infinite range which starts at negative infinity and goes to a fixed end point. Iterate over it in reverse.</p> <dl>
<dt class="d_decl" id="NegInfInterval.this">pure nothrow this(scope const TP end); </dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TP <code>end</code>
</td> <td>The time point which ends the interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto interval = PosInfInterval!Date(Date(1996, 1, 2));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.opAssign">pure nothrow ref NegInfInterval <strong id="opAssign">opAssign</strong>(ref const NegInfInterval rhs); </dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval <code>rhs</code>
</td> <td>The <code>NegInfInterval</code> to assign to this one.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="NegInfInterval.opAssign.2">pure nothrow ref NegInfInterval <strong id="opAssign">opAssign</strong>(NegInfInterval rhs); </dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval <code>rhs</code>
</td> <td>The <code>NegInfInterval</code> to assign to this one.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="NegInfInterval.end">const pure nothrow @property TP <strong id="end">end</strong>(); </dt> <dd>
<p>The end point of the interval. It is excluded from the interval. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(NegInfInterval!Date(Date(2012, 3, 1)).end == Date(2012, 3, 1));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.end.2">pure nothrow @property void <strong id="end">end</strong>(TP timePoint); </dt> <dd>
<p>The end point of the interval. It is excluded from the interval. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TP <code>timePoint</code>
</td> <td>The time point to set end to.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="NegInfInterval.empty">enum bool <strong id="empty">empty</strong>; </dt> <dd>
<p>Whether the interval's length is 0. Always returns false. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!NegInfInterval!Date(Date(1996, 1, 2)).empty);
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.contains">const pure nothrow bool <strong id="contains">contains</strong>(TP timePoint); </dt> <dd>
<p>Whether the given time point is within this interval. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TP <code>timePoint</code>
</td> <td>The time point to check for inclusion in this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(NegInfInterval!Date(Date(2012, 3, 1)).contains(Date(1994, 12, 24)));
assert(NegInfInterval!Date(Date(2012, 3, 1)).contains(Date(2000, 1, 5)));
assert(!NegInfInterval!Date(Date(2012, 3, 1)).contains(Date(2012, 3, 1)));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.contains.2">const pure bool <strong id="contains">contains</strong>(scope const Interval!TP interval); </dt> <dd>
<p>Whether the given interval is completely within this interval. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval!TP <code>interval</code>
</td> <td>The interval to check for inclusion in this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given interval is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(NegInfInterval!Date(Date(2012, 3, 1)).contains(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));

assert(NegInfInterval!Date(Date(2012, 3, 1)).contains(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));

assert(!NegInfInterval!Date(Date(2012, 3, 1)).contains(
            Interval!Date(Date(1998, 2, 28), Date(2013, 5, 1))));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.contains.3">const pure nothrow bool <strong id="contains">contains</strong>(scope const PosInfInterval!TP interval); </dt> <dd>
<p>Whether the given interval is completely within this interval. </p>
<p>Always returns false because an interval beginning at negative infinity can never contain an interval going to positive infinity. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval!TP <code>interval</code>
</td> <td>The interval to check for inclusion in this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!NegInfInterval!Date(Date(2012, 3, 1)).contains(
            PosInfInterval!Date(Date(1999, 5, 4))));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.contains.4">const pure nothrow bool <strong id="contains">contains</strong>(scope const NegInfInterval interval); </dt> <dd>
<p>Whether the given interval is completely within this interval. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval <code>interval</code>
</td> <td>The interval to check for inclusion in this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(NegInfInterval!Date(Date(2012, 3, 1)).contains(
            NegInfInterval!Date(Date(1996, 5, 4))));

assert(!NegInfInterval!Date(Date(2012, 3, 1)).contains(
            NegInfInterval!Date(Date(2013, 7, 9))));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.isBefore">const pure nothrow bool <strong id="isBefore">isBefore</strong>(scope const TP timePoint); </dt> <dd>
<p>Whether this interval is before the given time point. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TP <code>timePoint</code>
</td> <td>The time point to check whether this interval is before it.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!NegInfInterval!Date(Date(2012, 3, 1)).isBefore(Date(1994, 12, 24)));
assert(!NegInfInterval!Date(Date(2012, 3, 1)).isBefore(Date(2000, 1, 5)));
assert(NegInfInterval!Date(Date(2012, 3, 1)).isBefore(Date(2012, 3, 1)));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.isBefore.2">const pure bool <strong id="isBefore">isBefore</strong>(scope const Interval!TP interval); </dt> <dd>
<p>Whether this interval is before the given interval and does not intersect it. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval!TP <code>interval</code>
</td> <td>The interval to check for against this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given interval is empty </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!NegInfInterval!Date(Date(2012, 3, 1)).isBefore(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));

assert(!NegInfInterval!Date(Date(2012, 3, 1)).isBefore(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));

assert(NegInfInterval!Date(Date(2012, 3, 1)).isBefore(
            Interval!Date(Date(2022, 10, 19), Date(2027, 6, 3))));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.isBefore.3">const pure nothrow bool <strong id="isBefore">isBefore</strong>(scope const PosInfInterval!TP interval); </dt> <dd>
<p>Whether this interval is before the given interval and does not intersect it. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval!TP <code>interval</code>
</td> <td>The interval to check for against this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!NegInfInterval!Date(Date(2012, 3, 1)).isBefore(
            PosInfInterval!Date(Date(1999, 5, 4))));

assert(NegInfInterval!Date(Date(2012, 3, 1)).isBefore(
            PosInfInterval!Date(Date(2012, 3, 1))));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.isBefore.4">const pure nothrow bool <strong id="isBefore">isBefore</strong>(scope const NegInfInterval interval); </dt> <dd>
<p>Whether this interval is before the given interval and does not intersect it. </p>
<p>Always returns false because an interval beginning at negative infinity can never be before another interval beginning at negative infinity. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval <code>interval</code>
</td> <td>The interval to check for against this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!NegInfInterval!Date(Date(2012, 3, 1)).isBefore(
            NegInfInterval!Date(Date(1996, 5, 4))));

assert(!NegInfInterval!Date(Date(2012, 3, 1)).isBefore(
            NegInfInterval!Date(Date(2013, 7, 9))));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.isAfter">const pure nothrow bool <strong id="isAfter">isAfter</strong>(scope const TP timePoint); </dt> <dd>
<p>Whether this interval is after the given time point. </p>
<p>Always returns false because an interval beginning at negative infinity can never be after any time point. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TP <code>timePoint</code>
</td> <td>The time point to check whether this interval is after it.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(Date(1994, 12, 24)));
assert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(Date(2000, 1, 5)));
assert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(Date(2012, 3, 1)));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.isAfter.2">const pure bool <strong id="isAfter">isAfter</strong>(scope const Interval!TP interval); </dt> <dd>
<p>Whether this interval is after the given interval and does not intersect it. </p>
<p>Always returns false (unless the given interval is empty) because an interval beginning at negative infinity can never be after any other interval. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval!TP <code>interval</code>
</td> <td>The interval to check against this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given interval is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));

assert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));

assert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(
            Interval!Date(Date(2022, 10, 19), Date(2027, 6, 3))));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.isAfter.3">const pure nothrow bool <strong id="isAfter">isAfter</strong>(scope const PosInfInterval!TP interval); </dt> <dd>
<p>Whether this interval is after the given interval and does not intersect it. </p>
<p>Always returns false because an interval beginning at negative infinity can never be after any other interval. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval!TP <code>interval</code>
</td> <td>The interval to check against this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(
            PosInfInterval!Date(Date(1999, 5, 4))));

assert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(
            PosInfInterval!Date(Date(2012, 3, 1))));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.isAfter.4">const pure nothrow bool <strong id="isAfter">isAfter</strong>(scope const NegInfInterval interval); </dt> <dd>
<p>Whether this interval is after the given interval and does not intersect it. </p>
<p>Always returns false because an interval beginning at negative infinity can never be after any other interval. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval <code>interval</code>
</td> <td>The interval to check against this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(
            NegInfInterval!Date(Date(1996, 5, 4))));

assert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(
            NegInfInterval!Date(Date(2013, 7, 9))));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.intersects">const pure bool <strong id="intersects">intersects</strong>(scope const Interval!TP interval); </dt> <dd>
<p>Whether the given interval overlaps this interval. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval!TP <code>interval</code>
</td> <td>The interval to check for intersection with this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given interval is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(NegInfInterval!Date(Date(2012, 3, 1)).intersects(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));

assert(NegInfInterval!Date(Date(2012, 3, 1)).intersects(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));

assert(!NegInfInterval!Date(Date(2012, 3, 1)).intersects(
            Interval!Date(Date(2022, 10, 19), Date(2027, 6, 3))));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.intersects.2">const pure nothrow bool <strong id="intersects">intersects</strong>(scope const PosInfInterval!TP interval); </dt> <dd>
<p>Whether the given interval overlaps this interval. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval!TP <code>interval</code>
</td> <td>The interval to check for intersection with this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(NegInfInterval!Date(Date(2012, 3, 1)).intersects(
            PosInfInterval!Date(Date(1999, 5, 4))));

assert(!NegInfInterval!Date(Date(2012, 3, 1)).intersects(
            PosInfInterval!Date(Date(2012, 3, 1))));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.intersects.3">const pure nothrow bool <strong id="intersects">intersects</strong>(scope const NegInfInterval!TP interval); </dt> <dd>
<p>Whether the given interval overlaps this interval. </p>
<p>Always returns true because two intervals beginning at negative infinity always overlap. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval!TP <code>interval</code>
</td> <td>The interval to check for intersection with this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(NegInfInterval!Date(Date(2012, 3, 1)).intersects(
            NegInfInterval!Date(Date(1996, 5, 4))));

assert(NegInfInterval!Date(Date(2012, 3, 1)).intersects(
            NegInfInterval!Date(Date(2013, 7, 9))));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.intersection">const Interval!TP <strong id="intersection">intersection</strong>(scope const Interval!TP interval); </dt> <dd>
<p>Returns the intersection of two intervals </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval!TP <code>interval</code>
</td> <td>The interval to intersect with this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the two intervals do not intersect or if the given interval is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(NegInfInterval!Date(Date(2012, 3, 1)).intersection(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==
       Interval!Date(Date(1990, 7 , 6), Date(2000, 8, 2)));

assert(NegInfInterval!Date(Date(2012, 3, 1)).intersection(
            Interval!Date(Date(1999, 1, 12), Date(2015, 9, 2))) ==
       Interval!Date(Date(1999, 1 , 12), Date(2012, 3, 1)));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.intersection.2">const Interval!TP <strong id="intersection">intersection</strong>(scope const PosInfInterval!TP interval); </dt> <dd>
<p>Returns the intersection of two intervals </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval!TP <code>interval</code>
</td> <td>The interval to intersect with this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the two intervals do not intersect. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(NegInfInterval!Date(Date(2012, 3, 1)).intersection(
            PosInfInterval!Date(Date(1990, 7, 6))) ==
       Interval!Date(Date(1990, 7 , 6), Date(2012, 3, 1)));

assert(NegInfInterval!Date(Date(2012, 3, 1)).intersection(
            PosInfInterval!Date(Date(1999, 1, 12))) ==
       Interval!Date(Date(1999, 1 , 12), Date(2012, 3, 1)));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.intersection.3">const nothrow NegInfInterval <strong id="intersection">intersection</strong>(scope const NegInfInterval interval); </dt> <dd>
<p>Returns the intersection of two intervals </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval <code>interval</code>
</td> <td>The interval to intersect with this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(NegInfInterval!Date(Date(2012, 3, 1)).intersection(
            NegInfInterval!Date(Date(1999, 7, 6))) ==
       NegInfInterval!Date(Date(1999, 7 , 6)));

assert(NegInfInterval!Date(Date(2012, 3, 1)).intersection(
            NegInfInterval!Date(Date(2013, 1, 12))) ==
       NegInfInterval!Date(Date(2012, 3 , 1)));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.isAdjacent">const pure bool <strong id="isAdjacent">isAdjacent</strong>(scope const Interval!TP interval); </dt> <dd>
<p>Whether the given interval is adjacent to this interval. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval!TP <code>interval</code>
</td> <td>The interval to check whether its adjecent to this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given interval is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));

assert(!NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(
            Interval!Date(Date(1999, 1, 12), Date(2012, 3, 1))));

assert(NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(
            Interval!Date(Date(2012, 3, 1), Date(2019, 2, 2))));

assert(!NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(
            Interval!Date(Date(2022, 10, 19), Date(2027, 6, 3))));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.isAdjacent.2">const pure nothrow bool <strong id="isAdjacent">isAdjacent</strong>(scope const PosInfInterval!TP interval); </dt> <dd>
<p>Whether the given interval is adjacent to this interval. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval!TP <code>interval</code>
</td> <td>The interval to check whether its adjecent to this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(
            PosInfInterval!Date(Date(1999, 5, 4))));

assert(NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(
            PosInfInterval!Date(Date(2012, 3, 1))));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.isAdjacent.3">const pure nothrow bool <strong id="isAdjacent">isAdjacent</strong>(scope const NegInfInterval interval); </dt> <dd>
<p>Whether the given interval is adjacent to this interval. </p>
<p>Always returns false because two intervals beginning at negative infinity can never be adjacent to one another. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval <code>interval</code>
</td> <td>The interval to check whether its adjecent to this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(
            NegInfInterval!Date(Date(1996, 5, 4))));

assert(!NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(
            NegInfInterval!Date(Date(2012, 3, 1))));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.merge">const NegInfInterval <strong id="merge">merge</strong>(scope const Interval!TP interval); </dt> <dd>
<p>Returns the union of two intervals </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval!TP <code>interval</code>
</td> <td>The interval to merge with this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the two intervals do not intersect and are not adjacent or if the given interval is empty. </dd>
</dl> <dl>
<dt>Note</dt>
<dd> There is no overload for <code>merge</code> which takes a <code>PosInfInterval</code>, because an interval going from negative infinity to positive infinity is not possible. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(NegInfInterval!Date(Date(2012, 3, 1)).merge(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==
       NegInfInterval!Date(Date(2012, 3 , 1)));

assert(NegInfInterval!Date(Date(2012, 3, 1)).merge(
            Interval!Date(Date(1999, 1, 12), Date(2015, 9, 2))) ==
       NegInfInterval!Date(Date(2015, 9 , 2)));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.merge.2">const pure nothrow NegInfInterval <strong id="merge">merge</strong>(scope const NegInfInterval interval); </dt> <dd>
<p>Returns the union of two intervals </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval <code>interval</code>
</td> <td>The interval to merge with this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Note</dt>
<dd> There is no overload for <code>merge</code> which takes a <code>PosInfInterval</code>, because an interval going from negative infinity to positive infinity is not possible. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(NegInfInterval!Date(Date(2012, 3, 1)).merge(
            NegInfInterval!Date(Date(1999, 7, 6))) ==
       NegInfInterval!Date(Date(2012, 3 , 1)));

assert(NegInfInterval!Date(Date(2012, 3, 1)).merge(
            NegInfInterval!Date(Date(2013, 1, 12))) ==
       NegInfInterval!Date(Date(2013, 1 , 12)));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.span">const pure NegInfInterval <strong id="span">span</strong>(scope const Interval!TP interval); </dt> <dd>
<p>Returns an interval that covers from the earliest time point of two intervals up to (but not including) the latest time point of two intervals. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval!TP <code>interval</code>
</td> <td>The interval to create a span together with this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given interval is empty. </dd>
</dl> <dl>
<dt>Note</dt>
<dd> There is no overload for <code>span</code> which takes a <code>PosInfInterval</code>, because an interval going from negative infinity to positive infinity is not possible. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(NegInfInterval!Date(Date(2012, 3, 1)).span(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==
       NegInfInterval!Date(Date(2012, 3 , 1)));

assert(NegInfInterval!Date(Date(2012, 3, 1)).span(
            Interval!Date(Date(1999, 1, 12), Date(2015, 9, 2))) ==
       NegInfInterval!Date(Date(2015, 9 , 2)));

assert(NegInfInterval!Date(Date(1600, 1, 7)).span(
            Interval!Date(Date(2012, 3, 11), Date(2017, 7, 1))) ==
       NegInfInterval!Date(Date(2017, 7 , 1)));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.span.2">const pure nothrow NegInfInterval <strong id="span">span</strong>(scope const NegInfInterval interval); </dt> <dd>
<p>Returns an interval that covers from the earliest time point of two intervals up to (but not including) the latest time point of two intervals. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval <code>interval</code>
</td> <td>The interval to create a span together with this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Note</dt>
<dd> There is no overload for <code>span</code> which takes a <code>PosInfInterval</code>, because an interval going from negative infinity to positive infinity is not possible. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(NegInfInterval!Date(Date(2012, 3, 1)).span(
            NegInfInterval!Date(Date(1999, 7, 6))) ==
       NegInfInterval!Date(Date(2012, 3 , 1)));

assert(NegInfInterval!Date(Date(2012, 3, 1)).span(
            NegInfInterval!Date(Date(2013, 1, 12))) ==
       NegInfInterval!Date(Date(2013, 1 , 12)));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.shift">pure nothrow void <strong id="shift">shift</strong>(D)(D duration)<br><small>  Constraints: if (__traits(compiles, end + duration)); </small>
</dt> <dd>
<p>Shifts the <code>end</code> of this interval forward or backwards in time by the given duration (a positive duration shifts the interval forward; a negative duration shifts it backward). Effectively, it does <code>end += duration</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>D <code>duration</code>
</td> <td>The duration to shift the interval by.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto interval1 = NegInfInterval!Date(Date(2012, 4, 5));
auto interval2 = NegInfInterval!Date(Date(2012, 4, 5));

interval1.shift(dur!"days"(50));
assert(interval1 == NegInfInterval!Date(Date(2012, 5, 25)));

interval2.shift(dur!"days"(-50));
assert(interval2 == NegInfInterval!Date( Date(2012, 2, 15)));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.shift.2">void <strong id="shift">shift</strong>(T)(T years, T months = 0, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)<br><small>  Constraints: if (isIntegral!T); </small>
</dt> <dd>
<p>Shifts the <code>end</code> of this interval forward or backwards in time by the given number of years and/or months (a positive number of years and months shifts the interval forward; a negative number shifts it backward). It adds the years the given years and months to end. It effectively calls <code>add!"years"()</code> and then <code>add!"months"()</code> on end with the given number of years and months. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>years</code>
</td> <td>The number of years to shift the interval by.</td>
</tr> <tr>
<td>T <code>months</code>
</td> <td>The number of months to shift the interval by.</td>
</tr> <tr>
<td>AllowDayOverflow <code>allowOverflow</code>
</td> <td>Whether the days should be allowed to overflow on <code>end</code>, causing its month to increment.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if empty is true or if the resulting interval would be invalid. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto interval1 = NegInfInterval!Date(Date(2012, 3, 1));
auto interval2 = NegInfInterval!Date(Date(2012, 3, 1));

interval1.shift(2);
assert(interval1 == NegInfInterval!Date(Date(2014, 3, 1)));

interval2.shift(-2);
assert(interval2 == NegInfInterval!Date(Date(2010, 3, 1)));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.expand">pure nothrow void <strong id="expand">expand</strong>(D)(D duration)<br><small>  Constraints: if (__traits(compiles, end + duration)); </small>
</dt> <dd>
<p>Expands the interval forwards in time. Effectively, it does <code>end += duration</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>D <code>duration</code>
</td> <td>The duration to expand the interval by.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto interval1 = NegInfInterval!Date(Date(2012, 3, 1));
auto interval2 = NegInfInterval!Date(Date(2012, 3, 1));

interval1.expand(dur!"days"(2));
assert(interval1 == NegInfInterval!Date(Date(2012, 3, 3)));

interval2.expand(dur!"days"(-2));
assert(interval2 == NegInfInterval!Date(Date(2012, 2, 28)));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.expand.2">void <strong id="expand">expand</strong>(T)(T years, T months = 0, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)<br><small>  Constraints: if (isIntegral!T); </small>
</dt> <dd>
<p>Expands the interval forwards and/or backwards in time. Effectively, it adds the given number of months/years to end. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>years</code>
</td> <td>The number of years to expand the interval by.</td>
</tr> <tr>
<td>T <code>months</code>
</td> <td>The number of months to expand the interval by.</td>
</tr> <tr>
<td>AllowDayOverflow <code>allowOverflow</code>
</td> <td>Whether the days should be allowed to overflow on <code>end</code>, causing their month to increment.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if empty is true or if the resulting interval would be invalid. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto interval1 = NegInfInterval!Date(Date(2012, 3, 1));
auto interval2 = NegInfInterval!Date(Date(2012, 3, 1));

interval1.expand(2);
assert(interval1 == NegInfInterval!Date(Date(2014, 3, 1)));

interval2.expand(-2);
assert(interval2 == NegInfInterval!Date(Date(2010, 3, 1)));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.bwdRange">const NegInfIntervalRange!TP <strong id="bwdRange">bwdRange</strong>(TP delegate(scope const TP) func, PopFirst popFirst = PopFirst.no); </dt> <dd>
<p>Returns a range which iterates backwards over the interval, starting at <code>end</code>, using <span class="d_param">func</span> to generate each successive time point. </p>
<p>The range's <code>front</code> is the interval's <code>end</code>. <span class="d_param">func</span> is used to generate the next <code>front</code> when <code>popFront</code> is called. If <span class="d_param">popFirst</span> is <code>PopFirst.yes</code>, then <code>popFront</code> is called before the range is returned (so that <code>front</code> is a time point which <span class="d_param">func</span> would generate). <br><br> If <span class="d_param">func</span> ever generates a time point greater than or equal to the current <code>front</code> of the range, then a <a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> will be thrown. <br><br> There are helper functions in this module which generate common delegates to pass to <code>bwdRange</code>. Their documentation starts with "Range-generating function," to make them easily searchable. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TP delegate(scope const TP) <code>func</code>
</td> <td>The function used to generate the time points of the range over the interval.</td>
</tr> <tr>
<td>PopFirst <code>popFirst</code>
</td> <td>Whether <code>popFront</code> should be called on the range before returning it.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this interval is empty. </dd>
</dl> <dl>
<dt>Warning</dt>
<dd> <span class="d_param">func</span> must be logically pure. Ideally, <span class="d_param">func</span> would be a function pointer to a pure function, but forcing <span class="d_param">func</span> to be pure is far too restrictive to be useful, and in order to have the ease of use of having functions which generate functions to pass to <code>fwdRange</code>, <span class="d_param">func</span> must be a delegate. </dd>
</dl> If <span class="d_param">func</span> retains state which changes as it is called, then some algorithms will not work correctly, because the range's <code>save</code> will have failed to have really saved the range's state. To avoid such bugs, don't pass a delegate which is not logically pure to <code>fwdRange</code>. If <span class="d_param">func</span> is given the same time point with two different calls, it must return the same result both times.  Of course, none of the functions in this module have this problem, so it's only relevant for custom delegates.  <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto interval = NegInfInterval!Date(Date(2010, 9, 9));
auto func = delegate (scope const Date date) //For iterating over even-numbered days.
            {
                if ((date.day &amp; 1) == 0)
                    return date - dur!"days"(2);

                return date - dur!"days"(1);
            };
auto range = interval.bwdRange(func);

assert(range.front == Date(2010, 9, 9)); //An odd day. Using PopFirst.yes would have made this Date(2010, 9, 8).

range.popFront();
assert(range.front == Date(2010, 9, 8));

range.popFront();
assert(range.front == Date(2010, 9, 6));

range.popFront();
assert(range.front == Date(2010, 9, 4));

range.popFront();
assert(range.front == Date(2010, 9, 2));

range.popFront();
assert(!range.empty);
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.toString">const nothrow string <strong id="toString">toString</strong>(); </dt> <dd>
<p>Converts this interval to a string.</p> </dd> </dl> </dd> <dt class="d_decl" id="everyDayOfWeek">nothrow TP delegate(scope const TP) <strong id="everyDayOfWeek">everyDayOfWeek</strong>(TP, Direction dir = Direction.fwd)(DayOfWeek dayOfWeek)<br><small>  Constraints: if (isTimePoint!TP &amp;&amp; (dir == Direction.fwd || dir == Direction.bwd) &amp;&amp; __traits(hasMember, TP, "dayOfWeek") &amp;&amp; !__traits(isStaticFunction, TP.dayOfWeek) &amp;&amp; is(typeof(TP.dayOfWeek) == DayOfWeek)); </small>
</dt> <dd>
<p>Range-generating function. </p>
<p>Returns a delegate which returns the next time point with the given <code>DayOfWeek</code> in a range. <br><br> Using this delegate allows iteration over successive time points which are all the same day of the week. e.g. passing <code>DayOfWeek.mon</code> to <code>everyDayOfWeek</code> would result in a delegate which could be used to iterate over all of the Mondays in a range. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dir</td> <td>The direction to iterate in. If passing the return value to <code>fwdRange</code>, use <code>Direction.fwd</code>. If passing it to <code>bwdRange</code>, use <code>Direction.bwd</code>.</td>
</tr> <tr>
<td>DayOfWeek <code>dayOfWeek</code>
</td> <td>The week that each time point in the range will be.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.datetime.date : Date, DayOfWeek;

auto interval = Interval!Date(Date(2010, 9, 2), Date(2010, 9, 27));
auto func = everyDayOfWeek!Date(DayOfWeek.mon);
auto range = interval.fwdRange(func);

// A Thursday. Using PopFirst.yes would have made this Date(2010, 9, 6).
writeln(range.front); // Date(2010, 9, 2)

range.popFront();
writeln(range.front); // Date(2010, 9, 6)

range.popFront();
writeln(range.front); // Date(2010, 9, 13)

range.popFront();
writeln(range.front); // Date(2010, 9, 20)

range.popFront();
assert(range.empty);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="everyMonth">TP delegate(scope const TP) <strong id="everyMonth">everyMonth</strong>(TP, Direction dir = Direction.fwd)(int month)<br><small>  Constraints: if (isTimePoint!TP &amp;&amp; (dir == Direction.fwd || dir == Direction.bwd) &amp;&amp; __traits(hasMember, TP, "month") &amp;&amp; !__traits(isStaticFunction, TP.month) &amp;&amp; is(typeof(TP.month) == Month)); </small>
</dt> <dd>
<p>Range-generating function. </p>
<p>Returns a delegate which returns the next time point with the given month which would be reached by adding months to the given time point. <br><br> So, using this delegate allows iteration over successive time points which are in the same month but different years. For example, iterate over each successive December 25th in an interval by starting with a date which had the 25th as its day and passed <code>Month.dec</code> to <code>everyMonth</code> to create the delegate. <br><br> Since it wouldn't really make sense to be iterating over a specific month and end up with some of the time points in the succeeding month or two years after the previous time point, <code>AllowDayOverflow.no</code> is always used when calculating the next time point. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dir</td> <td>The direction to iterate in. If passing the return value to <code>fwdRange</code>, use <code>Direction.fwd</code>. If passing it to <code>bwdRange</code>, use <code>Direction.bwd</code>.</td>
</tr> <tr>
<td>int <code>month</code>
</td> <td>The month that each time point in the range will be in (January is 1).</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.datetime.date : Date, Month;

auto interval = Interval!Date(Date(2000, 1, 30), Date(2004, 8, 5));
auto func = everyMonth!Date(Month.feb);
auto range = interval.fwdRange(func);

// Using PopFirst.yes would have made this Date(2010, 2, 29).
writeln(range.front); // Date(2000, 1, 30)

range.popFront();
writeln(range.front); // Date(2000, 2, 29)

range.popFront();
writeln(range.front); // Date(2001, 2, 28)

range.popFront();
writeln(range.front); // Date(2002, 2, 28)

range.popFront();
writeln(range.front); // Date(2003, 2, 28)

range.popFront();
writeln(range.front); // Date(2004, 2, 28)

range.popFront();
assert(range.empty);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="everyDuration">nothrow TP delegate(scope const TP) <strong id="everyDuration">everyDuration</strong>(TP, Direction dir = Direction.fwd, D)(D duration)<br><small>  Constraints: if (isTimePoint!TP &amp;&amp; __traits(compiles, TP.init + duration) &amp;&amp; (dir == Direction.fwd || dir == Direction.bwd)); </small>
</dt> <dd>
<p>Range-generating function. </p>
<p>Returns a delegate which returns the next time point which is the given duration later. <br><br> Using this delegate allows iteration over successive time points which are apart by the given duration e.g. passing <code>dur!"days"(3)</code> to <code>everyDuration</code> would result in a delegate which could be used to iterate over a range of days which are each 3 days apart. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dir</td> <td>The direction to iterate in. If passing the return value to <code>fwdRange</code>, use <code>Direction.fwd</code>. If passing it to <code>bwdRange</code>, use <code>Direction.bwd</code>.</td>
</tr> <tr>
<td>D <code>duration</code>
</td> <td>The duration which separates each successive time point in the range.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import core.time : dur;
import std.datetime.date : Date;

auto interval = Interval!Date(Date(2010, 9, 2), Date(2010, 9, 27));
auto func = everyDuration!Date(dur!"days"(8));
auto range = interval.fwdRange(func);

// Using PopFirst.yes would have made this Date(2010, 9, 10).
writeln(range.front); // Date(2010, 9, 2)

range.popFront();
writeln(range.front); // Date(2010, 9, 10)

range.popFront();
writeln(range.front); // Date(2010, 9, 18)

range.popFront();
writeln(range.front); // Date(2010, 9, 26)

range.popFront();
assert(range.empty);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="everyDuration.2">nothrow TP delegate(scope const TP) <strong id="everyDuration">everyDuration</strong>(TP, Direction dir = Direction.fwd, D)(int years, int months = 0, AllowDayOverflow allowOverflow = AllowDayOverflow.yes, D duration = dur!"days"(0))<br><small>  Constraints: if (isTimePoint!TP &amp;&amp; __traits(compiles, TP.init + duration) &amp;&amp; __traits(compiles, TP.init.add!"years"(years)) &amp;&amp; __traits(compiles, TP.init.add!"months"(months)) &amp;&amp; (dir == Direction.fwd || dir == Direction.bwd)); </small>
</dt> <dd>
<p>Range-generating function. </p>
<p>Returns a delegate which returns the next time point which is the given number of years, month, and duration later. <br><br> The difference between this version of <code>everyDuration</code> and the version which just takes a <a href="core_time#Duration"><code>core.time.Duration</code></a> is that this one also takes the number of years and months (along with an <code>AllowDayOverflow</code> to indicate whether adding years and months should allow the days to overflow). <br><br> Note that if iterating forward, <code>add!"years"()</code> is called on the given time point, then <code>add!"months"()</code>, and finally the duration is added to it. However, if iterating backwards, the duration is added first, then <code>add!"months"()</code> is called, and finally <code>add!"years"()</code> is called. That way, going backwards generates close to the same time points that iterating forward does, but since adding years and months is not entirely reversible (due to possible day overflow, regardless of whether <code>AllowDayOverflow.yes</code> or <code>AllowDayOverflow.no</code> is used), it can't be guaranteed that iterating backwards will give the same time points as iterating forward would have (even assuming that the end of the range is a time point which would be returned by the delegate when iterating forward from <code>begin</code>). </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dir</td> <td>The direction to iterate in. If passing the return value to <code>fwdRange</code>, use <code>Direction.fwd</code>. If passing it to <code>bwdRange</code>, use <code>Direction.bwd</code>.</td>
</tr> <tr>
<td>int <code>years</code>
</td> <td>The number of years to add to the time point passed to the delegate.</td>
</tr> <tr>
<td>int <code>months</code>
</td> <td>The number of months to add to the time point passed to the delegate.</td>
</tr> <tr>
<td>AllowDayOverflow <code>allowOverflow</code>
</td> <td>Whether the days should be allowed to overflow on <code>begin</code> and <code>end</code>, causing their month to increment.</td>
</tr> <tr>
<td>D <code>duration</code>
</td> <td>The duration to add to the time point passed to the delegate.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import core.time : dur;
import std.datetime.date : AllowDayOverflow, Date;

auto interval = Interval!Date(Date(2010, 9, 2), Date(2025, 9, 27));
auto func = everyDuration!Date(4, 1, AllowDayOverflow.yes, dur!"days"(2));
auto range = interval.fwdRange(func);

// Using PopFirst.yes would have made this Date(2014, 10, 12).
writeln(range.front); // Date(2010, 9, 2)

range.popFront();
writeln(range.front); // Date(2014, 10, 4)

range.popFront();
writeln(range.front); // Date(2018, 11, 6)

range.popFront();
writeln(range.front); // Date(2022, 12, 8)

range.popFront();
assert(range.empty);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="IntervalRange">struct <strong id="IntervalRange">IntervalRange</strong>(TP, Direction dir) if (isTimePoint!TP &amp;&amp; (dir != Direction.both)); </dt> <dd>
<p>A range over an <a href="#Interval"><code>Interval</code></a>. </p>
<p><code>IntervalRange</code> is only ever constructed by <a href="#Interval"><code>Interval</code></a>. However, when it is constructed, it is given a function, <code>func</code>, which is used to generate the time points which are iterated over. <code>func</code> takes a time point and returns a time point of the same type. For instance, to iterate over all of the days in the interval <code>Interval!Date</code>, pass a function to <a href="#Interval"><code>Interval</code></a>'s <code>fwdRange</code> where that function took a <a href="std_datetime_date#Date"><code>std.datetime.date.Date</code></a> and returned a <a href="std_datetime_date#Date"><code>std.datetime.date.Date</code></a> which was one day later. That function would then be used by <code>IntervalRange</code>'s <code>popFront</code> to iterate over the <a href="std_datetime_date#Date"><code>std.datetime.date.Date</code></a>s in the interval. <br><br> If <code>dir == Direction.fwd</code>, then a range iterates forward in time, whereas if <code>dir == Direction.bwd</code>, then it iterates backwards in time. So, if <code>dir == Direction.fwd</code> then <code>front == interval.begin</code>, whereas if <code>dir == Direction.bwd</code> then <code>front == interval.end</code>. <code>func</code> must generate a time point going in the proper direction of iteration, or a <a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> will be thrown. So, to iterate forward in time, the time point that <code>func</code> generates must be later in time than the one passed to it. If it's either identical or earlier in time, then a <a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> will be thrown. To iterate backwards, then the generated time point must be before the time point which was passed in. <br><br> If the generated time point is ever passed the edge of the range in the proper direction, then the edge of that range will be used instead. So, if iterating forward, and the generated time point is past the interval's <code>end</code>, then <code>front</code> becomes <code>end</code>. If iterating backwards, and the generated time point is before <code>begin</code>, then <code>front</code> becomes <code>begin</code>. In either case, the range would then be empty. <br><br> Also note that while normally the <code>begin</code> of an interval is included in it and its <code>end</code> is excluded from it, if <code>dir == Direction.bwd</code>, then <code>begin</code> is treated as excluded and <code>end</code> is treated as included. This allows for the same behavior in both directions. This works because none of <a href="#Interval"><code>Interval</code></a>'s functions which care about whether <code>begin</code> or <code>end</code> is included or excluded are ever called by <code>IntervalRange</code>. <code>interval</code> returns a normal interval, regardless of whether <code>dir == Direction.fwd</code> or if <code>dir == Direction.bwd</code>, so any <a href="#Interval"><code>Interval</code></a> functions which are called on it which care about whether <code>begin</code> or <code>end</code> are included or excluded will treat <code>begin</code> as included and <code>end</code> as excluded.</p> <dl>
<dt class="d_decl" id="IntervalRange.opAssign">pure nothrow ref IntervalRange <strong id="opAssign">opAssign</strong>(ref IntervalRange rhs); <br><br>pure nothrow ref IntervalRange <strong id="opAssign">opAssign</strong>(IntervalRange rhs); </dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>IntervalRange <code>rhs</code>
</td> <td>The <code>IntervalRange</code> to assign to this one.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="IntervalRange.empty">const pure nothrow @property bool <strong id="empty">empty</strong>(); </dt> <dd>
<p>Whether this <code>IntervalRange</code> is empty.</p> </dd> <dt class="d_decl" id="IntervalRange.front">const pure @property TP <strong id="front">front</strong>(); </dt> <dd>
<p>The first time point in the range. </p>
<dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the range is empty.</dd>
</dl> </dd> <dt class="d_decl" id="IntervalRange.popFront">void <strong id="popFront">popFront</strong>(); </dt> <dd>
<p>Pops <code>front</code> from the range, using <code>func</code> to generate the next time point in the range. If the generated time point is beyond the edge of the range, then <code>front</code> is set to that edge, and the range is then empty. So, if iterating forwards, and the generated time point is greater than the interval's <code>end</code>, then <code>front</code> is set to <code>end</code>. If iterating backwards, and the generated time point is less than the interval's <code>begin</code>, then <code>front</code> is set to <code>begin</code>. </p>
<dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the range is empty or if the generated time point is in the wrong direction (i.e. if iterating forward and the generated time point is before <code>front</code>, or if iterating backwards and the generated time point is after <code>front</code>).</dd>
</dl> </dd> <dt class="d_decl" id="IntervalRange.save">pure nothrow @property IntervalRange <strong id="save">save</strong>(); </dt> <dd>
<p>Returns a copy of <code>this</code>.</p> </dd> <dt class="d_decl" id="IntervalRange.interval">const pure nothrow @property Interval!TP <strong id="interval">interval</strong>(); </dt> <dd>
<p>The interval that this <code>IntervalRange</code> currently covers.</p> </dd> <dt class="d_decl" id="IntervalRange.func">pure nothrow @property TP delegate(scope const TP) <strong id="func">func</strong>(); </dt> <dd>
<p>The function used to generate the next time point in the range.</p> </dd> <dt class="d_decl" id="IntervalRange.direction">const pure nothrow @property Direction <strong id="direction">direction</strong>(); </dt> <dd>
<p>The <code>Direction</code> that this range iterates in.</p> </dd> </dl> </dd> <dt class="d_decl" id="PosInfIntervalRange">struct <strong id="PosInfIntervalRange">PosInfIntervalRange</strong>(TP) if (isTimePoint!TP); </dt> <dd>
<p>A range over a <code>PosInfInterval</code>. It is an infinite range. </p>
<p><code>PosInfIntervalRange</code> is only ever constructed by <code>PosInfInterval</code>. However, when it is constructed, it is given a function, <code>func</code>, which is used to generate the time points which are iterated over. <code>func</code> takes a time point and returns a time point of the same type. For instance, to iterate over all of the days in the interval <code>PosInfInterval!Date</code>, pass a function to <code>PosInfInterval</code>'s <code>fwdRange</code> where that function took a <a href="std_datetime_date#Date"><code>std.datetime.date.Date</code></a> and returned a <a href="std_datetime_date#Date"><code>std.datetime.date.Date</code></a> which was one day later. That function would then be used by <code>PosInfIntervalRange</code>'s <code>popFront</code> to iterate over the <a href="std_datetime_date#Date"><code>std.datetime.date.Date</code></a>s in the interval - though obviously, since the range is infinite, use a function such as <code>std.range.take</code> with it rather than iterating over <i>all</i> of the dates. <br><br> As the interval goes to positive infinity, the range is always iterated over forwards, never backwards. <code>func</code> must generate a time point going in the proper direction of iteration, or a <a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> will be thrown. So, the time points that <code>func</code> generates must be later in time than the one passed to it. If it's either identical or earlier in time, then a <a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> will be thrown.</p> <dl>
<dt class="d_decl" id="PosInfIntervalRange.opAssign">pure nothrow ref PosInfIntervalRange <strong id="opAssign">opAssign</strong>(ref PosInfIntervalRange rhs); <br><br>pure nothrow ref PosInfIntervalRange <strong id="opAssign">opAssign</strong>(PosInfIntervalRange rhs); </dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfIntervalRange <code>rhs</code>
</td> <td>The <code>PosInfIntervalRange</code> to assign to this one.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="PosInfIntervalRange.empty">enum bool <strong id="empty">empty</strong>; </dt> <dd>
<p>This is an infinite range, so it is never empty.</p> </dd> <dt class="d_decl" id="PosInfIntervalRange.front">const pure nothrow @property TP <strong id="front">front</strong>(); </dt> <dd>
<p>The first time point in the range.</p> </dd> <dt class="d_decl" id="PosInfIntervalRange.popFront">void <strong id="popFront">popFront</strong>(); </dt> <dd>
<p>Pops <code>front</code> from the range, using <code>func</code> to generate the next time point in the range. </p>
<dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the generated time point is less than <code>front</code>.</dd>
</dl> </dd> <dt class="d_decl" id="PosInfIntervalRange.save">pure nothrow @property PosInfIntervalRange <strong id="save">save</strong>(); </dt> <dd>
<p>Returns a copy of <code>this</code>.</p> </dd> <dt class="d_decl" id="PosInfIntervalRange.interval">const pure nothrow @property PosInfInterval!TP <strong id="interval">interval</strong>(); </dt> <dd>
<p>The interval that this range currently covers.</p> </dd> <dt class="d_decl" id="PosInfIntervalRange.func">pure nothrow @property TP delegate(scope const TP) <strong id="func">func</strong>(); </dt> <dd>
<p>The function used to generate the next time point in the range.</p> </dd> </dl> </dd> <dt class="d_decl" id="NegInfIntervalRange">struct <strong id="NegInfIntervalRange">NegInfIntervalRange</strong>(TP) if (isTimePoint!TP); </dt> <dd>
<p>A range over a <code>NegInfInterval</code>. It is an infinite range. </p>
<p><code>NegInfIntervalRange</code> is only ever constructed by <code>NegInfInterval</code>. However, when it is constructed, it is given a function, <code>func</code>, which is used to generate the time points which are iterated over. <code>func</code> takes a time point and returns a time point of the same type. For instance, to iterate over all of the days in the interval <code>NegInfInterval!Date</code>, pass a function to <code>NegInfInterval</code>'s <code>bwdRange</code> where that function took a <a href="std_datetime_date#Date"><code>std.datetime.date.Date</code></a> and returned a <a href="std_datetime_date#Date"><code>std.datetime.date.Date</code></a> which was one day earlier. That function would then be used by <code>NegInfIntervalRange</code>'s <code>popFront</code> to iterate over the <a href="std_datetime_date#Date"><code>std.datetime.date.Date</code></a>s in the interval - though obviously, since the range is infinite, use a function such as <code>std.range.take</code> with it rather than iterating over <i>all</i> of the dates. <br><br> As the interval goes to negative infinity, the range is always iterated over backwards, never forwards. <code>func</code> must generate a time point going in the proper direction of iteration, or a <a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> will be thrown. So, the time points that <code>func</code> generates must be earlier in time than the one passed to it. If it's either identical or later in time, then a <a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> will be thrown. <br><br> Also note that while normally the <code>end</code> of an interval is excluded from it, <code>NegInfIntervalRange</code> treats it as if it were included. This allows for the same behavior as with <code>PosInfIntervalRange</code>. This works because none of <code>NegInfInterval</code>'s functions which care about whether <code>end</code> is included or excluded are ever called by <code>NegInfIntervalRange</code>. <code>interval</code> returns a normal interval, so any <code>NegInfInterval</code> functions which are called on it which care about whether <code>end</code> is included or excluded will treat <code>end</code> as excluded.</p> <dl>
<dt class="d_decl" id="NegInfIntervalRange.opAssign">pure nothrow ref NegInfIntervalRange <strong id="opAssign">opAssign</strong>(ref NegInfIntervalRange rhs); <br><br>pure nothrow ref NegInfIntervalRange <strong id="opAssign">opAssign</strong>(NegInfIntervalRange rhs); </dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfIntervalRange <code>rhs</code>
</td> <td>The <code>NegInfIntervalRange</code> to assign to this one.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="NegInfIntervalRange.empty">enum bool <strong id="empty">empty</strong>; </dt> <dd>
<p>This is an infinite range, so it is never empty.</p> </dd> <dt class="d_decl" id="NegInfIntervalRange.front">const pure nothrow @property TP <strong id="front">front</strong>(); </dt> <dd>
<p>The first time point in the range.</p> </dd> <dt class="d_decl" id="NegInfIntervalRange.popFront">void <strong id="popFront">popFront</strong>(); </dt> <dd>
<p>Pops <code>front</code> from the range, using <code>func</code> to generate the next time point in the range. </p>
<dl>
<dt>Throws:</dt>
<dd>
<a href="std_datetime_date#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the generated time point is greater than <code>front</code>.</dd>
</dl> </dd> <dt class="d_decl" id="NegInfIntervalRange.save">pure nothrow @property NegInfIntervalRange <strong id="save">save</strong>(); </dt> <dd>
<p>Returns a copy of <code>this</code>.</p> </dd> <dt class="d_decl" id="NegInfIntervalRange.interval">const pure nothrow @property NegInfInterval!TP <strong id="interval">interval</strong>(); </dt> <dd>
<p>The interval that this range currently covers.</p> </dd> <dt class="d_decl" id="NegInfIntervalRange.func">pure nothrow @property TP delegate(scope const TP) <strong id="func">func</strong>(); </dt> <dd>
<p>The function used to generate the next time point in the range.</p> </dd> </dl> </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
     19992019 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_datetime_interval.html" class="_attribution-link">https://dlang.org/phobos/std_datetime_interval.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
