
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>std.array - D - W3cubDocs</title>
  
  <meta name="description" content=" Functions and types that manipulate built-in arrays and associative arrays. ">
  <meta name="keywords" content="std, array, d">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/d/std_array.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/d.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/d/" class="_nav-link" title="" style="margin-left:0;">D</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _d">
				
				
<h1>std.array</h1>  <p>Functions and types that manipulate built-in arrays and associative arrays. </p>
<p>This module provides all kinds of functions to create, manipulate or convert arrays: <br><br>  </p>
<table>

<tr>
<th scope="col">Function Name</th> <th scope="col">Description</th> </tr> <tr>
<td><a href="#array"><code>array</code></a></td> <td>Returns a copy of the input in a newly allocated dynamic array. </td>
</tr> <tr>
<td><a href="#appender"><code>appender</code></a></td> <td>Returns a new <a href="#Appender"><code>Appender</code></a> or <a href="#RefAppender"><code>RefAppender</code></a> initialized with a given array. </td>
</tr> <tr>
<td><a href="#assocArray"><code>assocArray</code></a></td> <td>Returns a newly allocated associative array from a range of key/value tuples. </td>
</tr> <tr>
<td><a href="#byPair"><code>byPair</code></a></td> <td>Construct a range iterating over an associative array by key/value tuples. </td>
</tr> <tr>
<td><a href="#insertInPlace"><code>insertInPlace</code></a></td> <td>Inserts into an existing array at a given position. </td>
</tr> <tr>
<td><a href="#join"><code>join</code></a></td> <td>Concatenates a range of ranges into one array. </td>
</tr> <tr>
<td><a href="#minimallyInitializedArray"><code>minimallyInitializedArray</code></a></td> <td>Returns a new array of type <code>T</code>. </td>
</tr> <tr>
<td><a href="#replace"><code>replace</code></a></td> <td>Returns a new array with all occurrences of a certain subrange replaced. </td>
</tr> <tr>
<td><a href="#replaceFirst"><code>replaceFirst</code></a></td> <td>Returns a new array with the first occurrence of a certain subrange replaced. </td>
</tr> <tr>
<td><a href="#replaceInPlace"><code>replaceInPlace</code></a></td> <td>Replaces all occurrences of a certain subrange and puts the result into a given array. </td>
</tr> <tr>
<td><a href="#replaceInto"><code>replaceInto</code></a></td> <td>Replaces all occurrences of a certain subrange and puts the result into an output range. </td>
</tr> <tr>
<td><a href="#replaceLast"><code>replaceLast</code></a></td> <td>Returns a new array with the last occurrence of a certain subrange replaced. </td>
</tr> <tr>
<td><a href="#replaceSlice"><code>replaceSlice</code></a></td> <td>Returns a new array with a given slice replaced. </td>
</tr> <tr>
<td><a href="#replicate"><code>replicate</code></a></td> <td>Creates a new array out of several copies of an input array or range. </td>
</tr> <tr>
<td><a href="#sameHead"><code>sameHead</code></a></td> <td>Checks if the initial segments of two arrays refer to the same place in memory. </td>
</tr> <tr>
<td><a href="#sameTail"><code>sameTail</code></a></td> <td>Checks if the final segments of two arrays refer to the same place in memory. </td>
</tr> <tr>
<td><a href="#split"><code>split</code></a></td> <td>Eagerly split a range or string into an array. </td>
</tr> <tr>
<td><a href="#staticArray"><code>staticArray</code></a></td> <td>Creates a new static array from given data. </td>
</tr> <tr>
<td><a href="#uninitializedArray"><code>uninitializedArray</code></a></td> <td>Returns a new array of type <code>T</code> without initializing its elements. </td>
</tr> </table>  <dl>
<dt>License:</dt>
<dd>
<a href="http://boost.org/LICENSE_1_0.txt">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>
<a href="http://erdani.org">Andrei Alexandrescu</a> and <a href="http://jmdavisprog.com">Jonathan M Davis</a> </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/array.d">std/array.d</a></span>
</dd>
</dl> <dl>
<dt class="d_decl" id="back">public import std.range.primitives : <strong id="save">save</strong>, <strong id="empty">empty</strong>, <strong id="popFront">popFront</strong>, <strong id="popBack">popBack</strong>, <strong id="front">front</strong>, <strong id="back">back</strong>; </dt>  <dt class="d_decl" id="array">ForeachType!Range[] <strong id="array">array</strong>(Range)(Range r)<br><small>  Constraints: if (isIterable!Range &amp;&amp; !isNarrowString!Range &amp;&amp; !isInfinite!Range); </small><br><br>ForeachType!(PointerTarget!Range)[] <strong id="array">array</strong>(Range)(Range r)<br><small>  Constraints: if (isPointer!Range &amp;&amp; isIterable!(PointerTarget!Range) &amp;&amp; !isNarrowString!Range &amp;&amp; !isInfinite!Range); </small>
</dt> <dd>
<p>Allocates an array and initializes it with copies of the elements of range <code>r</code>. </p>
<p>Narrow strings are handled as a special case in an overload. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>r</code>
</td> <td>range (or aggregate with <code>opApply</code> function) whose elements are copied into the allocated array</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>allocated and initialized array</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto a = array([1, 2, 3, 4, 5][]);
writeln(a); // [1, 2, 3, 4, 5]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="array.2">ElementType!String[] <strong id="array">array</strong>(String)(scope String str)<br><small>  Constraints: if (isNarrowString!String); </small>
</dt> <dd>
<p>Convert a narrow string to an array type that fully supports random access. This is handled as a special case and always returns an array of <code>dchar</code> </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>String <code>str</code>
</td> <td>
<code>isNarrowString</code> to be converted to an array of <code>dchar</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>a <code>dchar[]</code>, <code>const(dchar)[]</code>, or <code>immutable(dchar)[]</code> depending on the constness of the input.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.range.primitives : isRandomAccessRange;

writeln("Hello D".array); // "Hello D"d
static assert(isRandomAccessRange!string == false);

writeln("Hello D"w.array); // "Hello D"d
static assert(isRandomAccessRange!dstring == true);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="assocArray">auto <strong id="assocArray">assocArray</strong>(Range)(Range r)<br><small>  Constraints: if (isInputRange!Range); </small><br><br>auto <strong id="assocArray">assocArray</strong>(Keys, Values)(Keys keys, Values values)<br><small>  Constraints: if (isInputRange!Values &amp;&amp; isInputRange!Keys); </small>
</dt> <dd>
<p>Returns a newly allocated associative array from a range of key/value tuples or from a range of keys and a range of values. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>r</code>
</td> <td>An <a href="std_range_primitives#isInputRange">input range</a> of tuples of keys and values.</td>
</tr> <tr>
<td>Keys <code>keys</code>
</td> <td>An <a href="std_range_primitives#isInputRange">input range</a> of keys</td>
</tr> <tr>
<td>Values <code>values</code>
</td> <td>An <a href="std_range_primitives#isInputRange">input range</a> of values</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A newly allocated associative array out of elements of the input range, which must be a range of tuples (Key, Value) or a range of keys and a range of values. If given two ranges of unequal lengths after the elements of the shorter are exhausted the remaining elements of the longer will not be considered. Returns a null associative array reference when given an empty range. </dd>
</dl> <dl>
<dt>Duplicates</dt>
<dd> Associative arrays have unique keys. If r contains duplicate keys, then the result will contain the value of the last pair for that key in r. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="std_typecons#Tuple"><code>std.typecons.Tuple</code></a>, <a href="std_range#zip"><code>std.range.zip</code></a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.range : repeat, zip;
import std.typecons : tuple;
auto a = assocArray(zip([0, 1, 2], ["a", "b", "c"])); // aka zipMap
static assert(is(typeof(a) == string[int]));
writeln(a); // [0:"a", 1:"b", 2:"c"]

auto b = assocArray([ tuple("foo", "bar"), tuple("baz", "quux") ]);
static assert(is(typeof(b) == string[string]));
writeln(b); // ["foo":"bar", "baz":"quux"]

auto c = assocArray("ABCD", true.repeat);
static assert(is(typeof(c) == bool[dchar]));
bool[dchar] expected = ['D':true, 'A':true, 'B':true, 'C':true];
writeln(c); // expected
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="byPair">auto <strong id="byPair">byPair</strong>(AA)(AA aa)<br><small>  Constraints: if (isAssociativeArray!AA); </small>
</dt> <dd>
<p>Construct a range iterating over an associative array by key/value tuples. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>AA <code>aa</code>
</td> <td>The associative array to iterate over.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A <a href="std_range_primitives#isForwardRange">forward range</a> of Tuple's of key and value pairs from the given associative array. The members of each pair can be accessed by name (<code>.key</code> and <code>.value</code>). or by integer index (0 and 1 respectively).</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.sorting : sort;
import std.typecons : tuple, Tuple;

auto aa = ["a": 1, "b": 2, "c": 3];
Tuple!(string, int)[] pairs;

// Iteration over key/value pairs.
foreach (pair; aa.byPair)
{
    if (pair.key == "b")
        pairs ~= tuple("B", pair.value);
    else
        pairs ~= pair;
}

// Iteration order is implementation-dependent, so we should sort it to get
// a fixed order.
pairs.sort();
assert(pairs == [
    tuple("B", 2),
    tuple("a", 1),
    tuple("c", 3)
]);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="uninitializedArray">nothrow @system auto <strong id="uninitializedArray">uninitializedArray</strong>(T, I...)(I sizes)<br><small>  Constraints: if (isDynamicArray!T &amp;&amp; allSatisfy!(isIntegral, I) &amp;&amp; hasIndirections!(ElementEncodingType!T)); </small><br><br>nothrow @trusted auto <strong id="uninitializedArray">uninitializedArray</strong>(T, I...)(I sizes)<br><small>  Constraints: if (isDynamicArray!T &amp;&amp; allSatisfy!(isIntegral, I) &amp;&amp; !hasIndirections!(ElementEncodingType!T)); </small>
</dt> <dd>
<p>Returns a new array of type <code>T</code> allocated on the garbage collected heap without initializing its elements. This can be a useful optimization if every element will be immediately initialized. <code>T</code> may be a multidimensional array. In this case sizes may be specified for any number of dimensions from 0 to the number in <code>T</code>. </p>
<p>uninitializedArray is <code>nothrow</code> and weakly <code>pure</code>. <br><br> uninitializedArray is <code>@system</code> if the uninitialized element type has pointers. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>The type of the resulting array elements</td>
</tr> <tr>
<td>I <code>sizes</code>
</td> <td>The length dimension(s) of the resulting array</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>An array of <code>T</code> with <code>I.length</code> dimensions.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">double[] arr = uninitializedArray!(double[])(100);
writeln(arr.length); // 100

double[][] matrix = uninitializedArray!(double[][])(42, 31);
writeln(matrix.length); // 42
writeln(matrix[0].length); // 31

char*[] ptrs = uninitializedArray!(char*[])(100);
writeln(ptrs.length); // 100
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="minimallyInitializedArray">nothrow @trusted auto <strong id="minimallyInitializedArray">minimallyInitializedArray</strong>(T, I...)(I sizes)<br><small>  Constraints: if (isDynamicArray!T &amp;&amp; allSatisfy!(isIntegral, I)); </small>
</dt> <dd>
<p>Returns a new array of type <code>T</code> allocated on the garbage collected heap. </p>
<p>Partial initialization is done for types with indirections, for preservation of memory safety. Note that elements will only be initialized to 0, but not necessarily the element type's <code>.init</code>. <br><br> minimallyInitializedArray is <code>nothrow</code> and weakly <code>pure</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>The type of the array elements</td>
</tr> <tr>
<td>I <code>sizes</code>
</td> <td>The length dimension(s) of the resulting array</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>An array of <code>T</code> with <code>I.length</code> dimensions.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.range : repeat;

auto arr = minimallyInitializedArray!(int[])(42);
writeln(arr.length); // 42

// Elements aren't necessarily initialized to 0, so don't do this:
// assert(arr.equal(0.repeat(42)));
// If that is needed, initialize the array normally instead:
auto arr2 = new int[42];
assert(arr2.equal(0.repeat(42)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="overlap">@trusted CommonType!(T[], U[]) <strong id="overlap">overlap</strong>(T, U)(T[] a, U[] b)<br><small>  Constraints: if (is(typeof(a.ptr &lt; b.ptr) == bool)); </small>
</dt> <dd>
<p>Returns the overlapping portion, if any, of two arrays. Unlike <code>equal</code>, <code>overlap</code> only compares the pointers and lengths in the ranges, not the values referred by them. If <code>r1</code> and <code>r2</code> have an overlapping slice, returns that slice. Otherwise, returns the null slice. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T[] <code>a</code>
</td> <td>The first array to compare</td>
</tr> <tr>
<td>U[] <code>b</code>
</td> <td>The second array to compare</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The overlapping portion of the two arrays.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int[] a = [ 10, 11, 12, 13, 14 ];
int[] b = a[1 .. 3];
writeln(overlap(a, b)); // [11, 12]
b = b.dup;
// overlap disappears even though the content is the same
assert(overlap(a, b).empty);

static test()() @nogc
{
    auto a = "It's three o'clock"d;
    auto b = a[5 .. 10];
    return b.overlap(a);
}

//works at compile-time
static assert(test == "three"d);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="insertInPlace">void <strong id="insertInPlace">insertInPlace</strong>(T, U...)(ref T[] array, size_t pos, U stuff)<br><small>  Constraints: if (!isSomeString!(T[]) &amp;&amp; allSatisfy!(isInputRangeOrConvertible!T, U) &amp;&amp; (U.length &gt; 0)); </small><br><br>void <strong id="insertInPlace">insertInPlace</strong>(T, U...)(ref T[] array, size_t pos, U stuff)<br><small>  Constraints: if (isSomeString!(T[]) &amp;&amp; allSatisfy!(isCharOrStringOrDcharRange, U)); </small>
</dt> <dd>
<p>Inserts <code>stuff</code> (which must be an input range or any number of implicitly convertible items) in <code>array</code> at position <code>pos</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T[] <code>array</code>
</td> <td>The array that <code>stuff</code> will be inserted into.</td>
</tr> <tr>
<td>size_t <code>pos</code>
</td> <td>The position in <code>array</code> to insert the <code>stuff</code>.</td>
</tr> <tr>
<td>U <code>stuff</code>
</td> <td>An <a href="std_range_primitives#isInputRange">input range</a>, or any number of implicitly convertible items to insert into <code>array</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int[] a = [ 1, 2, 3, 4 ];
a.insertInPlace(2, [ 1, 2 ]);
writeln(a); // [1, 2, 1, 2, 3, 4]
a.insertInPlace(3, 10u, 11);
writeln(a); // [1, 2, 1, 10, 11, 2, 3, 4]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="sameHead">pure nothrow @safe bool <strong id="sameHead">sameHead</strong>(T)(in T[] lhs, in T[] rhs); </dt> <dd>
<p>Returns whether the <code>front</code>s of <code>lhs</code> and <code>rhs</code> both refer to the same place in memory, making one of the arrays a slice of the other which starts at index <code>0</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T[] <code>lhs</code>
</td> <td>the first array to compare</td>
</tr> <tr>
<td>T[] <code>rhs</code>
</td> <td>the second array to compare</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if <code>lhs.ptr == rhs.ptr</code>, <code>false</code> otherwise.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto a = [1, 2, 3, 4, 5];
auto b = a[0 .. 2];

assert(a.sameHead(b));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="sameTail">pure nothrow @trusted bool <strong id="sameTail">sameTail</strong>(T)(in T[] lhs, in T[] rhs); </dt> <dd>
<p>Returns whether the <code>back</code>s of <code>lhs</code> and <code>rhs</code> both refer to the same place in memory, making one of the arrays a slice of the other which end at index <code>$</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T[] <code>lhs</code>
</td> <td>the first array to compare</td>
</tr> <tr>
<td>T[] <code>rhs</code>
</td> <td>the second array to compare</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if both arrays are the same length and <code>lhs.ptr == rhs.ptr</code>, <code>false</code> otherwise.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto a = [1, 2, 3, 4, 5];
auto b = a[3..$];

assert(a.sameTail(b));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="replicate">ElementEncodingType!S[] <strong id="replicate">replicate</strong>(S)(S s, size_t n)<br><small>  Constraints: if (isDynamicArray!S); </small><br><br>ElementType!S[] <strong id="replicate">replicate</strong>(S)(S s, size_t n)<br><small>  Constraints: if (isInputRange!S &amp;&amp; !isDynamicArray!S); </small>
</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S <code>s</code>
</td> <td>an <a href="std_range_primitives#isInputRange">input range</a> or a dynamic array</td>
</tr> <tr>
<td>size_t <code>n</code>
</td> <td>number of times to repeat <code>s</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>An array that consists of <code>s</code> repeated <code>n</code> times. This function allocates, fills, and returns a new array. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>For a lazy version, refer to <a href="std_range#repeat"><code>std.range.repeat</code></a>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto a = "abc";
auto s = replicate(a, 3);

writeln(s); // "abcabcabc"

auto b = [1, 2, 3];
auto c = replicate(b, 3);

writeln(c); // [1, 2, 3, 1, 2, 3, 1, 2, 3]

auto d = replicate(b, 0);

writeln(d); // []
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="split">pure @safe S[] <strong id="split">split</strong>(S)(S s)<br><small>  Constraints: if (isSomeString!S); </small><br><br>auto <strong id="split">split</strong>(Range, Separator)(Range range, Separator sep)<br><small>  Constraints: if (isForwardRange!Range &amp;&amp; (is(typeof(ElementType!Range.init == Separator.init)) || is(typeof(ElementType!Range.init == ElementType!Separator.init)) &amp;&amp; isForwardRange!Separator)); </small><br><br>auto <strong id="split">split</strong>(alias isTerminator, Range)(Range range)<br><small>  Constraints: if (isForwardRange!Range &amp;&amp; is(typeof(unaryFun!isTerminator(range.front)))); </small>
</dt> <dd>
<p>Eagerly splits <code>range</code> into an array, using <code>sep</code> as the delimiter. </p>
<p>When no delimiter is provided, strings are split into an array of words, using whitespace as delimiter. Runs of whitespace are merged together (no empty words are produced). <br><br> The <code>range</code> must be a <a href="std_range_primitives#isForwardRange">forward range</a>. The separator can be a value of the same type as the elements in <code>range</code> or it can be another forward <code>range</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S <code>s</code>
</td> <td>the string to split by word if no separator is given</td>
</tr> <tr>
<td>Range <code>range</code>
</td> <td>the range to split</td>
</tr> <tr>
<td>Separator <code>sep</code>
</td> <td>a value of the same type as the elements of <code>range</code> or another</td>
</tr> <tr>
<td>isTerminator</td> <td>a predicate that splits the range when it returns <code>true</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>An array containing the divided parts of <code>range</code> (or the words of <code>s</code>). </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="std_algorithm_iteration#splitter"><code>std.algorithm.iteration.splitter</code></a> for a lazy version without allocating memory.  <a href="std_regex#splitter"><code>std.regex.splitter</code></a> for a version that splits using a regular expression defined separator.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.uni : isWhite;
writeln("Learning,D,is,fun".split(",")); // ["Learning", "D", "is", "fun"]
writeln("Learning D is fun".split!isWhite); // ["Learning", "D", "is", "fun"]
writeln("Learning D is fun".split(" D ")); // ["Learning", "is fun"]
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">string str = "Hello World!";
writeln(str.split); // ["Hello", "World!"]

string str2 = "Hello\t\tWorld\t!";
writeln(str2.split); // ["Hello", "World", "!"]
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(split("hello world")); // ["hello", "world"]
writeln(split("192.168.0.1", ".")); // ["192", "168", "0", "1"]

auto a = split([1, 2, 3, 4, 5, 1, 2, 3, 4, 5], [2, 3]);
writeln(a); // [[1], [4, 5, 1], [4, 5]]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="join">ElementEncodingType!(ElementType!RoR)[] <strong id="join">join</strong>(RoR, R)(RoR ror, scope R sep)<br><small>  Constraints: if (isInputRange!RoR &amp;&amp; isInputRange!(Unqual!(ElementType!RoR)) &amp;&amp; isInputRange!R &amp;&amp; is(Unqual!(ElementType!(ElementType!RoR)) == Unqual!(ElementType!R))); </small><br><br>ElementEncodingType!(ElementType!RoR)[] <strong id="join">join</strong>(RoR, E)(RoR ror, scope E sep)<br><small>  Constraints: if (isInputRange!RoR &amp;&amp; isInputRange!(Unqual!(ElementType!RoR)) &amp;&amp; is(E : ElementType!(ElementType!RoR))); </small><br><br>ElementEncodingType!(ElementType!RoR)[] <strong id="join">join</strong>(RoR)(RoR ror)<br><small>  Constraints: if (isInputRange!RoR &amp;&amp; isInputRange!(Unqual!(ElementType!RoR))); </small>
</dt> <dd>
<p>Eagerly concatenates all of the ranges in <code>ror</code> together (with the GC) into one array using <code>sep</code> as the separator if present. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>RoR <code>ror</code>
</td> <td>An <a href="std_range_primitives#isInputRange">input range</a> of input ranges</td>
</tr> <tr>
<td>R <code>sep</code>
</td> <td>An input range, or a single element, to join the ranges on</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>An array of elements </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>For a lazy version, see <a href="std_algorithm_iteration#joiner"><code>std.algorithm.iteration.joiner</code></a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(join(["hello", "silly", "world"], " ")); // "hello silly world"
writeln(join(["hello", "silly", "world"])); // "hellosillyworld"

writeln(join([[1, 2, 3], [4, 5]], [72, 73])); // [1, 2, 3, 72, 73, 4, 5]
writeln(join([[1, 2, 3], [4, 5]])); // [1, 2, 3, 4, 5]

const string[] arr = ["apple", "banana"];
writeln(arr.join(",")); // "apple,banana"
writeln(arr.join()); // "applebanana"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="replace">E[] <strong id="replace">replace</strong>(E, R1, R2)(E[] subject, R1 from, R2 to)<br><small>  Constraints: if (isForwardRange!R1 &amp;&amp; isForwardRange!R2 &amp;&amp; (hasLength!R2 || isSomeString!R2) || is(Unqual!E : Unqual!R1)); </small>
</dt> <dd>
<p>Replace occurrences of <code>from</code> with <code>to</code> in <code>subject</code> in a new array. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>E[] <code>subject</code>
</td> <td>the array to scan</td>
</tr> <tr>
<td>R1 <code>from</code>
</td> <td>the item to replace</td>
</tr> <tr>
<td>R2 <code>to</code>
</td> <td>the item to replace all instances of <code>from</code> with</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A new array without changing the contents of <code>subject</code>, or the original array if no match is found. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="std_algorithm_iteration#substitute"><code>std.algorithm.iteration.substitute</code></a> for a lazy replace.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln("Hello Wörld".replace("o Wö", "o Wo")); // "Hello World"
writeln("Hello Wörld".replace("l", "h")); // "Hehho Wörhd"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="replaceInto">void <strong id="replaceInto">replaceInto</strong>(E, Sink, R1, R2)(Sink sink, E[] subject, R1 from, R2 to)<br><small>  Constraints: if (isOutputRange!(Sink, E) &amp;&amp; (isForwardRange!R1 &amp;&amp; isForwardRange!R2 &amp;&amp; (hasLength!R2 || isSomeString!R2) || is(Unqual!E : Unqual!R1))); </small>
</dt> <dd>
<p>Replace occurrences of <code>from</code> with <code>to</code> in <code>subject</code> and output the result into <code>sink</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Sink <code>sink</code>
</td> <td>an <a href="std_range_primitives#isOutputRange">output range</a>
</td>
</tr> <tr>
<td>E[] <code>subject</code>
</td> <td>the array to scan</td>
</tr> <tr>
<td>R1 <code>from</code>
</td> <td>the item to replace</td>
</tr> <tr>
<td>R2 <code>to</code>
</td> <td>the item to replace all instances of <code>from</code> with</td>
</tr> </table></dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="std_algorithm_iteration#substitute"><code>std.algorithm.iteration.substitute</code></a> for a lazy replace.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto arr = [1, 2, 3, 4, 5];
auto from = [2, 3];
auto to = [4, 6];
auto sink = appender!(int[])();

replaceInto(sink, arr, from, to);

writeln(sink.data); // [1, 4, 6, 4, 5]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="replace.2">T[] <strong id="replace">replace</strong>(T, Range)(T[] subject, size_t from, size_t to, Range stuff)<br><small>  Constraints: if (isInputRange!Range &amp;&amp; (is(ElementType!Range : T) || isSomeString!(T[]) &amp;&amp; is(ElementType!Range : dchar))); </small>
</dt> <dd>
<p>Replaces elements from <code>array</code> with indices ranging from <code>from</code> (inclusive) to <code>to</code> (exclusive) with the range <code>stuff</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T[] <code>subject</code>
</td> <td>the array to scan</td>
</tr> <tr>
<td>size_t <code>from</code>
</td> <td>the starting index</td>
</tr> <tr>
<td>size_t <code>to</code>
</td> <td>the ending index</td>
</tr> <tr>
<td>Range <code>stuff</code>
</td> <td>the items to replace in-between <code>from</code> and <code>to</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A new array without changing the contents of <code>subject</code>. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="std_algorithm_iteration#substitute"><code>std.algorithm.iteration.substitute</code></a> for a lazy replace.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto a = [ 1, 2, 3, 4 ];
auto b = a.replace(1, 3, [ 9, 9, 9 ]);
writeln(a); // [1, 2, 3, 4]
writeln(b); // [1, 9, 9, 9, 4]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="replaceInPlace">void <strong id="replaceInPlace">replaceInPlace</strong>(T, Range)(ref T[] array, size_t from, size_t to, Range stuff)<br><small>  Constraints: if (is(typeof(replace(array, from, to, stuff)))); </small>
</dt> <dd>
<p>Replaces elements from <code>array</code> with indices ranging from <code>from</code> (inclusive) to <code>to</code> (exclusive) with the range <code>stuff</code>. Expands or shrinks the array as needed. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T[] <code>array</code>
</td> <td>the array to scan</td>
</tr> <tr>
<td>size_t <code>from</code>
</td> <td>the starting index</td>
</tr> <tr>
<td>size_t <code>to</code>
</td> <td>the ending index</td>
</tr> <tr>
<td>Range <code>stuff</code>
</td> <td>the items to replace in-between <code>from</code> and <code>to</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int[] a = [1, 4, 5];
replaceInPlace(a, 1u, 2u, [2, 3, 4]);
writeln(a); // [1, 2, 3, 4, 5]
replaceInPlace(a, 1u, 2u, cast(int[])[]);
writeln(a); // [1, 3, 4, 5]
replaceInPlace(a, 1u, 3u, a[2 .. 4]);
writeln(a); // [1, 4, 5, 5]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="replaceFirst">E[] <strong id="replaceFirst">replaceFirst</strong>(E, R1, R2)(E[] subject, R1 from, R2 to)<br><small>  Constraints: if (isDynamicArray!(E[]) &amp;&amp; isForwardRange!R1 &amp;&amp; is(typeof(appender!(E[])().put(from[0..1]))) &amp;&amp; isForwardRange!R2 &amp;&amp; is(typeof(appender!(E[])().put(to[0..1])))); </small>
</dt> <dd>
<p>Replaces the first occurrence of <code>from</code> with <code>to</code> in <code>subject</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>E[] <code>subject</code>
</td> <td>the array to scan</td>
</tr> <tr>
<td>R1 <code>from</code>
</td> <td>the item to replace</td>
</tr> <tr>
<td>R2 <code>to</code>
</td> <td>the item to replace <code>from</code> with</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A new array without changing the contents of <code>subject</code>, or the original array if no match is found.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto a = [1, 2, 2, 3, 4, 5];
auto b = a.replaceFirst([2], [1337]);
writeln(b); // [1, 1337, 2, 3, 4, 5]

auto s = "This is a foo foo list";
auto r = s.replaceFirst("foo", "silly");
writeln(r); // "This is a silly foo list"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="replaceLast">E[] <strong id="replaceLast">replaceLast</strong>(E, R1, R2)(E[] subject, R1 from, R2 to)<br><small>  Constraints: if (isDynamicArray!(E[]) &amp;&amp; isForwardRange!R1 &amp;&amp; is(typeof(appender!(E[])().put(from[0..1]))) &amp;&amp; isForwardRange!R2 &amp;&amp; is(typeof(appender!(E[])().put(to[0..1])))); </small>
</dt> <dd>
<p>Replaces the last occurrence of <code>from</code> with <code>to</code> in <code>subject</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>E[] <code>subject</code>
</td> <td>the array to scan</td>
</tr> <tr>
<td>R1 <code>from</code>
</td> <td>the item to replace</td>
</tr> <tr>
<td>R2 <code>to</code>
</td> <td>the item to replace <code>from</code> with</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A new array without changing the contents of <code>subject</code>, or the original array if no match is found.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto a = [1, 2, 2, 3, 4, 5];
auto b = a.replaceLast([2], [1337]);
writeln(b); // [1, 2, 1337, 3, 4, 5]

auto s = "This is a foo foo list";
auto r = s.replaceLast("foo", "silly");
writeln(r); // "This is a foo silly list"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="replaceSlice">inout(T)[] <strong id="replaceSlice">replaceSlice</strong>(T)(inout(T)[] s, in T[] slice, in T[] replacement); </dt> <dd>
<p>Creates a new array such that the items in <code>slice</code> are replaced with the items in <code>replacement</code>. <code>slice</code> and <code>replacement</code> do not need to be the same length. The result will grow or shrink based on the items given. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>inout<span class="template_param_list" title="Template parameter list">(T)</span>[] <code>s</code>
</td> <td>the base of the new array</td>
</tr> <tr>
<td>T[] <code>slice</code>
</td> <td>the slice of <code>s</code> to be replaced</td>
</tr> <tr>
<td>T[] <code>replacement</code>
</td> <td>the items to replace <code>slice</code> with</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A new array that is <code>s</code> with <code>slice</code> replaced by <code>replacement[]</code>. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="std_algorithm_iteration#substitute"><code>std.algorithm.iteration.substitute</code></a> for a lazy replace.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto a = [1, 2, 3, 4, 5];
auto b = replaceSlice(a, a[1 .. 4], [0, 0, 0]);

writeln(b); // [1, 0, 0, 0, 5]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Appender">struct <strong id="Appender">Appender</strong>(A) if (isDynamicArray!A); </dt> <dd>
<p>Implements an output range that appends data to an array. This is recommended over <code>array ~= data</code> when appending many elements because it is more efficient. <code>Appender</code> maintains its own array metadata locally, so it can avoid global locking for each append where <a href="#capacity"><code>capacity</code></a> is non-zero. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>A</td> <td>the array type to simulate.</td>
</tr> </table></dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="#appender"><code>appender</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto app = appender!string();
string b = "abcdefg";
foreach (char c; b)
    app.put(c);
writeln(app[]); // "abcdefg"

int[] a = [ 1, 2 ];
auto app2 = appender(a);
app2.put(3);
app2.put([ 4, 5, 6 ]);
writeln(app2[]); // [1, 2, 3, 4, 5, 6]
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="Appender.this">pure nothrow @trusted this(A arr); </dt> <dd>
<p>Constructs an <code>Appender</code> with a given array. Note that this does not copy the data. If the array has a larger capacity as determined by <code>arr.capacity</code>, it will be used by the appender. After initializing an appender on an array, appending to the original array will reallocate.</p> </dd> <dt class="d_decl" id="Appender.reserve">void <strong id="reserve">reserve</strong>(size_t newCapacity); </dt> <dd>
<p>Reserve at least newCapacity elements for appending. Note that more elements may be reserved than requested. If <code>newCapacity &lt;= capacity</code>, then nothing is done. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>size_t <code>newCapacity</code>
</td> <td>the capacity the <code>Appender</code> should have</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Appender.capacity">const pure nothrow @property @safe size_t <strong id="capacity">capacity</strong>(); </dt> <dd>
<dl>
<dt>Returns:</dt>
<dd>the capacity of the array (the maximum number of elements the managed array can accommodate before triggering a reallocation). If any appending will reallocate, <code>0</code> will be returned.</dd>
</dl> </dd> <dt class="d_decl" id="Appender.data">inout pure nothrow @property @trusted inout(ElementEncodingType!A)[] <strong id="data">data</strong>(); </dt> <dd>
<p>Use opSlice() from now on. </p>
<dl>
<dt>Returns:</dt>
<dd>The managed array.</dd>
</dl> </dd> <dt class="d_decl" id="Appender.opSlice">inout pure nothrow @property @trusted inout(ElementEncodingType!A)[] <strong id="opSlice">opSlice</strong>(); </dt> <dd>
<dl>
<dt>Returns:</dt>
<dd>The managed array.</dd>
</dl> </dd> <dt class="d_decl" id="Appender.put">void <strong id="put">put</strong>(U)(U item)<br><small>  Constraints: if (canPutItem!U); </small>
</dt> <dd>
<p>Appends <code>item</code> to the managed array. Performs encoding for <code>char</code> types if <code>A</code> is a differently typed <code>char</code> array. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>U <code>item</code>
</td> <td>the single item to append</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Appender.put.2">void <strong id="put">put</strong>(Range)(Range items)<br><small>  Constraints: if (canPutRange!Range); </small>
</dt> <dd>
<p>Appends an entire range to the managed array. Performs encoding for <code>char</code> elements if <code>A</code> is a differently typed <code>char</code> array. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>items</code>
</td> <td>the range of items to append</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Appender.opOpAssign">template <strong id="opOpAssign">opOpAssign</strong>(string op : "~")</dt> <dd>
<p>Appends to the managed array. </p>
<dl>
<dt>See Also:</dt>
<dd><a href="#Appender.put"><code>Appender.put</code></a></dd>
</dl> </dd> <dt class="d_decl" id="Appender.clear">pure nothrow @trusted void <strong id="clear">clear</strong>(); </dt> <dd>
<p>Clears the managed array. This allows the elements of the array to be reused for appending. </p>
<dl>
<dt>Note</dt>
<dd> clear is disabled for immutable or const element types, due to the possibility that <code>Appender</code> might overwrite immutable data.</dd>
</dl> </dd> <dt class="d_decl" id="Appender.shrinkTo">pure @trusted void <strong id="shrinkTo">shrinkTo</strong>(size_t newlength); </dt> <dd>
<p>Shrinks the managed array to the given length. </p>
<dl>
<dt>Throws:</dt>
<dd>
<code>Exception</code> if newlength is greater than the current array length. </dd>
</dl> <dl>
<dt>Note</dt>
<dd> shrinkTo is disabled for immutable or const element types.</dd>
</dl> </dd> <dt class="d_decl" id="Appender.toString">const string <strong id="toString">toString</strong>(); <br><br>const void <strong id="toString">toString</strong>(Writer)(ref Writer w, ref scope const FormatSpec!char fmt)<br><small>  Constraints: if (isOutputRange!(Writer, char)); </small>
</dt> <dd>
<p>Gives a string in the form of <code>Appender!(A)(data)</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Writer <code>w</code>
</td> <td>A <code>char</code> accepting <a href="std_range_primitives#isOutputRange">output range</a>.</td>
</tr> <tr>
<td>FormatSpec!char <code>fmt</code>
</td> <td>A <a href="std_format#FormatSpec"><code>std.format.FormatSpec</code></a> which controls how the array is formatted.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A <code>string</code> if <code>writer</code> is not set; <code>void</code> otherwise.</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="RefAppender">struct <strong id="RefAppender">RefAppender</strong>(A) if (isDynamicArray!A); </dt> <dd>
<p>A version of <a href="#Appender"><code>Appender</code></a> that can update an array in-place. It forwards all calls to an underlying appender implementation. Any calls made to the appender also update the pointer to the original array passed in. </p>
<dl>
<dt>Tip</dt>
<dd> Use the <code>arrayPtr</code> overload of <a href="#appender"><code>appender</code></a> for construction with type-inference. </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>A</td> <td>The array type to simulate</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int[] a = [1, 2];
auto app2 = appender(&amp;a);
writeln(app2[]); // [1, 2]
writeln(a); // [1, 2]
app2 ~= 3;
app2 ~= [4, 5, 6];
writeln(app2[]); // [1, 2, 3, 4, 5, 6]
writeln(a); // [1, 2, 3, 4, 5, 6]

app2.reserve(5);
assert(app2.capacity &gt;= 5);
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="RefAppender.this">this(A* arr); </dt> <dd>
<p>Constructs a <code>RefAppender</code> with a given array reference. This does not copy the data. If the array has a larger capacity as determined by <code>arr.capacity</code>, it will be used by the appender. </p>
<dl>
<dt>Note</dt>
<dd> Do not use built-in appending (i.e. <code>~=</code>) on the original array until you are done with the appender, because subsequent calls to the appender will reallocate the array data without those appends. </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>A* <code>arr</code>
</td> <td>Pointer to an array. Must not be null.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="RefAppender.opDispatch">void <strong id="opDispatch">opDispatch</strong>(string fn, Args...)(Args args)<br><small>  Constraints: if (__traits(compiles, (Appender!A a) =&gt; mixin("a." ~ fn ~ "(args)"))); </small>
</dt> <dd>
<p>Wraps remaining <code>Appender</code> methods such as <a href="#put"><code>put</code></a>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>fn</td> <td>Method name to call.</td>
</tr> <tr>
<td>Args <code>args</code>
</td> <td>Arguments to pass to the method.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="RefAppender.opOpAssign">void <strong id="opOpAssign">opOpAssign</strong>(string op : "~", U)(U rhs)<br><small>  Constraints: if (__traits(compiles, (Appender!A a) { a.put(rhs); } )); </small>
</dt> <dd>
<p>Appends <code>rhs</code> to the managed array. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>U <code>rhs</code>
</td> <td>Element or range.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="RefAppender.capacity">const @property size_t <strong id="capacity">capacity</strong>(); </dt> <dd>
<p>Returns the capacity of the array (the maximum number of elements the managed array can accommodate before triggering a reallocation). If any appending will reallocate, <code>capacity</code> returns <code>0</code>.</p> </dd> <dt class="d_decl" id="RefAppender.opSlice">inout @property inout(ElementEncodingType!A)[] <strong id="opSlice">opSlice</strong>(); </dt> <dd>
<dl>
<dt>Returns:</dt>
<dd>the managed array.</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="appender">Appender!A <strong id="appender">appender</strong>(A)()<br><small>  Constraints: if (isDynamicArray!A); </small><br><br>Appender!(E[]) <strong id="appender">appender</strong>(A : E[], E)(auto ref A array); </dt> <dd>
<p>Convenience function that returns an <a href="#Appender"><code>Appender</code></a> instance, optionally initialized with <code>array</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto w = appender!string;
// pre-allocate space for at least 10 elements (this avoids costly reallocations)
w.reserve(10);
assert(w.capacity &gt;= 10);

w.put('a'); // single elements
w.put("bc"); // multiple elements

// use the append syntax
w ~= 'd';
w ~= "ef";

writeln(w[]); // "abcdef"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="appender.2">RefAppender!(E[]) <strong id="appender">appender</strong>(P : E[]*, E)(P arrayPtr); </dt> <dd>
<p>Convenience function that returns a <a href="#RefAppender"><code>RefAppender</code></a> instance initialized with <code>arrayPtr</code>. Don't use null for the array pointer, use the other version of <code>appender</code> instead.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int[] a = [1, 2];
auto app2 = appender(&amp;a);
writeln(app2[]); // [1, 2]
writeln(a); // [1, 2]
app2 ~= 3;
app2 ~= [4, 5, 6];
writeln(app2[]); // [1, 2, 3, 4, 5, 6]
writeln(a); // [1, 2, 3, 4, 5, 6]

app2.reserve(5);
assert(app2.capacity &gt;= 5);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="staticArray">T[n] <strong id="staticArray">staticArray</strong>(T, size_t n)(auto ref T[n] a); <br><br>auto <strong id="staticArray">staticArray</strong>(size_t n, T)(scope T a)<br><small>  Constraints: if (isInputRange!T); </small><br><br>auto <strong id="staticArray">staticArray</strong>(size_t n, T)(scope T a, out size_t rangeLength)<br><small>  Constraints: if (isInputRange!T); </small><br><br>auto <strong id="staticArray">staticArray</strong>(Un : U[n], U, size_t n, T)(scope T a)<br><small>  Constraints: if (isInputRange!T &amp;&amp; is(ElementType!T : U)); </small><br><br>auto <strong id="staticArray">staticArray</strong>(Un : U[n], U, size_t n, T)(scope T a, out size_t rangeLength)<br><small>  Constraints: if (isInputRange!T &amp;&amp; is(ElementType!T : U)); </small><br><br>auto <strong id="staticArray">staticArray</strong>(alias a)()<br><small>  Constraints: if (isInputRange!(typeof(a))); </small><br><br>auto <strong id="staticArray">staticArray</strong>(U, alias a)()<br><small>  Constraints: if (isInputRange!(typeof(a))); </small>
</dt> <dd>
<p>Constructs a static array from <code>a</code>. The type of elements can be specified implicitly so that <code>[1, 2].staticArray</code> results in <code>int[2]</code>, or explicitly, e.g. <code>[1, 2].staticArray!float</code> returns <code>float[2]</code>. When <code>a</code> is a range whose length is not known at compile time, the number of elements must be given as template argument (e.g. <code>myrange.staticArray!2</code>). Size and type can be combined, if the source range elements are implicitly convertible to the requested element type (eg: <code>2.iota.staticArray!(long[2])</code>). When the range <code>a</code> is known at compile time, it can also be specified as a template argument to avoid having to specify the number of elements (e.g.: <code>staticArray!(2.iota)</code> or <code>staticArray!(double, 2.iota)</code>). </p>
<dl>
<dt>Note</dt>
<dd> <code>staticArray</code> returns by value, so expressions involving large arrays may be inefficient. </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T[n] <code>a</code>
</td> <td>The input elements. If there are less elements than the specified length of the static array, the rest of it is default-initialized. If there are more than specified, the first elements up to the specified length are used.</td>
</tr> <tr>
<td>size_t <code>rangeLength</code>
</td> <td>outputs the number of elements used from <code>a</code> to it. Optional.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A static array constructed from <code>a</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>static array from array literal <pre data-language="d">auto a = [0, 1].staticArray;
static assert(is(typeof(a) == int[2]));
writeln(a); // [0, 1]
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>static array from range + size <pre data-language="d">import std.range : iota;

auto input = 3.iota;
auto a = input.staticArray!2;
static assert(is(typeof(a) == int[2]));
writeln(a); // [0, 1]
auto b = input.staticArray!(long[4]);
static assert(is(typeof(b) == long[4]));
writeln(b); // [0, 1, 2, 0]
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>static array from CT range <pre data-language="d">import std.range : iota;

enum a = staticArray!(2.iota);
static assert(is(typeof(a) == int[2]));
writeln(a); // [0, 1]

enum b = staticArray!(long, 2.iota);
static assert(is(typeof(b) == long[2]));
writeln(b); // [0, 1]
</pre> </dd>
</dl> </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2019 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_array.html" class="_attribution-link">https://dlang.org/phobos/std_array.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
