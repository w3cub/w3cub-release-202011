
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>std.xml - D - W3cubDocs</title>
  
  <meta name="description" content="Warning&#58; This module is considered out-dated and not up to Phobos&#39; current standards. It will remain until we have a suitable replacement, &hellip;">
  <meta name="keywords" content="std, xml, d">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/d/std_xml.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/d.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/d/" class="_nav-link" title="" style="margin-left:0;">D</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _d">
				
				
<h1>std.xml</h1>  <p><span class="red">Warning: This module is considered out-dated and not up to Phobos' current standards. It will remain until we have a suitable replacement, but be aware that it will not remain long term.</span> </p>
<p>Classes and functions for creating and parsing XML <br><br> The basic architecture of this module is that there are standalone functions, classes for constructing an XML document from scratch (Tag, Element and Document), and also classes for parsing a pre-existing XML file (ElementParser and DocumentParser). The parsing classes <i>may</i> be used to build a Document, but that is not their primary purpose. The handling capabilities of DocumentParser and ElementParser are sufficiently customizable that you can make them do pretty much whatever you want. </p> <dl>
<dt>Example</dt>
<dd> This example creates a DOM (Document Object Model) tree from an XML file. </dd>
</dl>
<pre data-language="d">import std.xml;
import std.stdio;
import std.string;
import std.file;

// books.xml is used in various samples throughout the Microsoft XML Core
// Services (MSXML) SDK.
//
// See http://msdn2.microsoft.com/en-us/library/ms762271(VS.85).aspx

void main()
{
    string s = cast(string) std.file.read("books.xml");

    // Check for well-formedness
    check(s);

    // Make a DOM tree
    auto doc = new Document(s);

    // Plain-print it
    writeln(doc);
}
</pre>  <dl>
<dt>Example</dt>
<dd> This example does much the same thing, except that the file is deconstructed and reconstructed by hand. This is more work, but the techniques involved offer vastly more power. </dd>
</dl>
<pre data-language="d">import std.xml;
import std.stdio;
import std.string;

struct Book
{
    string id;
    string author;
    string title;
    string genre;
    string price;
    string pubDate;
    string description;
}

void main()
{
    string s = cast(string) std.file.read("books.xml");

    // Check for well-formedness
    check(s);

    // Take it apart
    Book[] books;

    auto xml = new DocumentParser(s);
    xml.onStartTag["book"] = (ElementParser xml)
    {
        Book book;
        book.id = xml.tag.attr["id"];

        xml.onEndTag["author"]       = (in Element e) { book.author      = e.text(); };
        xml.onEndTag["title"]        = (in Element e) { book.title       = e.text(); };
        xml.onEndTag["genre"]        = (in Element e) { book.genre       = e.text(); };
        xml.onEndTag["price"]        = (in Element e) { book.price       = e.text(); };
        xml.onEndTag["publish-date"] = (in Element e) { book.pubDate     = e.text(); };
        xml.onEndTag["description"]  = (in Element e) { book.description = e.text(); };

        xml.parse();

        books ~= book;
    };
    xml.parse();

    // Put it back together again;
    auto doc = new Document(new Tag("catalog"));
    foreach (book;books)
    {
        auto element = new Element("book");
        element.tag.attr["id"] = book.id;

        element ~= new Element("author",      book.author);
        element ~= new Element("title",       book.title);
        element ~= new Element("genre",       book.genre);
        element ~= new Element("price",       book.price);
        element ~= new Element("publish-date",book.pubDate);
        element ~= new Element("description", book.description);

        doc ~= element;
    }

    // Pretty-print it
    writefln(join(doc.pretty(3),"\n"));
}
</pre>  <dl>
<dt>License:</dt>
<dd>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>Janice Caron </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/xml.d">std/xml.d</a></span>
</dd>
</dl> <dl>
<dt class="d_decl" id="isChar">pure nothrow @nogc @safe bool <strong id="isChar">isChar</strong>(dchar c); </dt> <dd>
<p>Returns true if the character is a character according to the XML standard </p>
<dl>
<dt>Standards:</dt>
<dd>
<a href="http://www.w3.org/TR/1998/REC-xml-19980210">XML 1.0</a> </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dchar <code>c</code>
</td> <td>the character to be tested</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="isSpace">pure nothrow @nogc @safe bool <strong id="isSpace">isSpace</strong>(dchar c); </dt> <dd>
<p>Returns true if the character is whitespace according to the XML standard </p>
<p>Only the following characters are considered whitespace in XML - space, tab, carriage return and linefeed </p> <dl>
<dt>Standards:</dt>
<dd>
<a href="http://www.w3.org/TR/1998/REC-xml-19980210">XML 1.0</a> </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dchar <code>c</code>
</td> <td>the character to be tested</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="isDigit">pure nothrow @nogc @safe bool <strong id="isDigit">isDigit</strong>(dchar c); </dt> <dd>
<p>Returns true if the character is a digit according to the XML standard </p>
<dl>
<dt>Standards:</dt>
<dd>
<a href="http://www.w3.org/TR/1998/REC-xml-19980210">XML 1.0</a> </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dchar <code>c</code>
</td> <td>the character to be tested</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="isLetter">pure nothrow @nogc @safe bool <strong id="isLetter">isLetter</strong>(dchar c); </dt> <dd>
<p>Returns true if the character is a letter according to the XML standard </p>
<dl>
<dt>Standards:</dt>
<dd>
<a href="http://www.w3.org/TR/1998/REC-xml-19980210">XML 1.0</a> </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dchar <code>c</code>
</td> <td>the character to be tested</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="isIdeographic">pure nothrow @nogc @safe bool <strong id="isIdeographic">isIdeographic</strong>(dchar c); </dt> <dd>
<p>Returns true if the character is an ideographic character according to the XML standard </p>
<dl>
<dt>Standards:</dt>
<dd>
<a href="http://www.w3.org/TR/1998/REC-xml-19980210">XML 1.0</a> </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dchar <code>c</code>
</td> <td>the character to be tested</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="isBaseChar">pure nothrow @nogc @safe bool <strong id="isBaseChar">isBaseChar</strong>(dchar c); </dt> <dd>
<p>Returns true if the character is a base character according to the XML standard </p>
<dl>
<dt>Standards:</dt>
<dd>
<a href="http://www.w3.org/TR/1998/REC-xml-19980210">XML 1.0</a> </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dchar <code>c</code>
</td> <td>the character to be tested</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="isCombiningChar">pure nothrow @nogc @safe bool <strong id="isCombiningChar">isCombiningChar</strong>(dchar c); </dt> <dd>
<p>Returns true if the character is a combining character according to the XML standard </p>
<dl>
<dt>Standards:</dt>
<dd>
<a href="http://www.w3.org/TR/1998/REC-xml-19980210">XML 1.0</a> </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dchar <code>c</code>
</td> <td>the character to be tested</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="isExtender">pure nothrow @nogc @safe bool <strong id="isExtender">isExtender</strong>(dchar c); </dt> <dd>
<p>Returns true if the character is an extender according to the XML standard </p>
<dl>
<dt>Standards:</dt>
<dd>
<a href="http://www.w3.org/TR/1998/REC-xml-19980210">XML 1.0</a> </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dchar <code>c</code>
</td> <td>the character to be tested</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="encode">S <strong id="encode">encode</strong>(S)(S s); </dt> <dd>
<p>Encodes a string by replacing all characters which need to be escaped with appropriate predefined XML entities. </p>
<p>encode() escapes certain characters (ampersand, quote, apostrophe, less-than and greater-than), and similarly, decode() unescapes them. These functions are provided for convenience only. You do not need to use them when using the std.xml classes, because then all the encoding and decoding will be done for you automatically. <br><br> If the string is not modified, the original will be returned. </p> <dl>
<dt>Standards:</dt>
<dd>
<a href="http://www.w3.org/TR/1998/REC-xml-19980210">XML 1.0</a> </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S <code>s</code>
</td> <td>The string to be encoded</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The encoded string </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">writefln(encode("a &gt; b")); // writes "a &amp;gt; b"
</pre>  </dd> <dt class="d_decl" id="DecodeMode">enum <strong id="DecodeMode">DecodeMode</strong>: int; </dt> <dd>
<p>Mode to use for decoding. </p>
<p></p>
<dl>NONE</dl> Do not decode <dl>LOOSE</dl> Decode, but ignore errors <dl>STRICT</dl> Decode, and throw exception on error </dd> <dt class="d_decl" id="decode">pure @safe string <strong id="decode">decode</strong>(string s, DecodeMode mode = DecodeMode.LOOSE); </dt> <dd>
<p>Decodes a string by unescaping all predefined XML entities. </p>
<p>encode() escapes certain characters (ampersand, quote, apostrophe, less-than and greater-than), and similarly, decode() unescapes them. These functions are provided for convenience only. You do not need to use them when using the std.xml classes, because then all the encoding and decoding will be done for you automatically. <br><br> This function decodes the entities &amp;amp;, &amp;quot;, &amp;apos;, &amp;lt; and &amp;gt, as well as decimal and hexadecimal entities such as &amp;#x20AC; <br><br> If the string does not contain an ampersand, the original will be returned. <br><br> Note that the "mode" parameter can be one of DecodeMode.NONE (do not decode), DecodeMode.LOOSE (decode, but ignore errors), or DecodeMode.STRICT (decode, and throw a DecodeException in the event of an error). </p> <dl>
<dt>Standards:</dt>
<dd>
<a href="http://www.w3.org/TR/1998/REC-xml-19980210">XML 1.0</a> </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>string <code>s</code>
</td> <td>The string to be decoded</td>
</tr> <tr>
<td>DecodeMode <code>mode</code>
</td> <td>(optional) Mode to use for decoding. (Defaults to LOOSE).</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>DecodeException if mode == DecodeMode.STRICT and decode fails </dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The decoded string </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">writefln(decode("a &amp;gt; b")); // writes "a &gt; b"
</pre>  </dd> <dt class="d_decl" id="Document">class <strong id="Document">Document</strong>: std.xml.Element; </dt> <dd>
<p>Class representing an XML document. </p>
<dl>
<dt>Standards:</dt>
<dd><a href="http://www.w3.org/TR/1998/REC-xml-19980210">XML 1.0</a></dd>
</dl> <dl>
<dt class="d_decl" id="Document.prolog">string <strong id="prolog">prolog</strong>; </dt> <dd>
<p>Contains all text which occurs before the root element. Defaults to &lt;?xml version="1.0"?&gt;</p> </dd> <dt class="d_decl" id="Document.epilog">string <strong id="epilog">epilog</strong>; </dt> <dd>
<p>Contains all text which occurs after the root element. Defaults to the empty string</p> </dd> <dt class="d_decl" id="Document.this">this(string s); </dt> <dd>
<p>Constructs a Document by parsing XML text. </p>
<p>This function creates a complete DOM (Document Object Model) tree. <br><br> The input to this function MUST be valid XML. This is enforced by DocumentParser's in contract. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>string <code>s</code>
</td> <td>the complete XML text.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Document.this.2">this(const(Tag) tag); </dt> <dd>
<p>Constructs a Document from a Tag. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(Tag) <code>tag</code>
</td> <td>the start tag of the document.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Document.opEquals">const bool <strong id="opEquals">opEquals</strong>(scope const Object o); </dt> <dd>
<p>Compares two Documents for equality </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">Document d1,d2;
if (d1 == d2) { }
</pre>  </dd> <dt class="d_decl" id="Document.opCmp">const scope int <strong id="opCmp">opCmp</strong>(scope const Object o); </dt> <dd>
<p>Compares two Documents </p>
<p>You should rarely need to call this function. It exists so that Documents can be used as associative array keys. </p> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">Document d1,d2;
if (d1 &lt; d2) { }
</pre>  </dd> <dt class="d_decl" id="Document.toHash">const scope @trusted size_t <strong id="toHash">toHash</strong>(); </dt> <dd>
<p>Returns the hash of a Document </p>
<p>You should rarely need to call this function. It exists so that Documents can be used as associative array keys.</p> </dd> <dt class="d_decl" id="Document.toString">const scope @safe string <strong id="toString">toString</strong>(); </dt> <dd>
<p>Returns the string representation of a Document. (That is, the complete XML of a document).</p> </dd> </dl> </dd> <dt class="d_decl" id="Element">class <strong id="Element">Element</strong>: std.xml.Item; </dt> <dd>
<p>Class representing an XML element. </p>
<dl>
<dt>Standards:</dt>
<dd><a href="http://www.w3.org/TR/1998/REC-xml-19980210">XML 1.0</a></dd>
</dl> <dl>
<dt class="d_decl" id="Element.tag">Tag <strong id="tag">tag</strong>; </dt> <dd>
<p>The start tag of the element</p> </dd> <dt class="d_decl" id="Element.items">Item[] <strong id="items">items</strong>; </dt> <dd>
<p>The element's items</p> </dd> <dt class="d_decl" id="Element.texts">Text[] <strong id="texts">texts</strong>; </dt> <dd>
<p>The element's text items</p> </dd> <dt class="d_decl" id="Element.cdatas">CData[] <strong id="cdatas">cdatas</strong>; </dt> <dd>
<p>The element's CData items</p> </dd> <dt class="d_decl" id="Element.comments">Comment[] <strong id="comments">comments</strong>; </dt> <dd>
<p>The element's comments</p> </dd> <dt class="d_decl" id="Element.pis">ProcessingInstruction[] <strong id="pis">pis</strong>; </dt> <dd>
<p>The element's processing instructions</p> </dd> <dt class="d_decl" id="Element.elements">Element[] <strong id="elements">elements</strong>; </dt> <dd>
<p>The element's child elements</p> </dd> <dt class="d_decl" id="Element.this">pure @safe this(string name, string interior = null); </dt> <dd>
<p>Constructs an Element given a name and a string to be used as a Text interior. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>string <code>name</code>
</td> <td>the name of the element.</td>
</tr> <tr>
<td>string <code>interior</code>
</td> <td>(optional) the string interior.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto element = new Element("title","Serenity")
    // constructs the element &lt;title&gt;Serenity&lt;/title&gt;
</pre>  </dd> <dt class="d_decl" id="Element.this.2">pure @safe this(const(Tag) tag_); </dt> <dd>
<p>Constructs an Element from a Tag. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(Tag) <code>tag_</code>
</td> <td>the start or empty tag of the element.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Element.opOpAssign">pure @safe void <strong id="opOpAssign">opOpAssign</strong>(string op)(Text item)<br><small>  Constraints: if (op == "~"); </small>
</dt> <dd>
<p>Append a text item to the interior of this element </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Text <code>item</code>
</td> <td>the item you wish to append.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">Element element;
element ~= new Text("hello");
</pre>  </dd> <dt class="d_decl" id="Element.opOpAssign.2">pure @safe void <strong id="opOpAssign">opOpAssign</strong>(string op)(CData item)<br><small>  Constraints: if (op == "~"); </small>
</dt> <dd>
<p>Append a CData item to the interior of this element </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>CData <code>item</code>
</td> <td>the item you wish to append.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">Element element;
element ~= new CData("hello");
</pre>  </dd> <dt class="d_decl" id="Element.opOpAssign.3">pure @safe void <strong id="opOpAssign">opOpAssign</strong>(string op)(Comment item)<br><small>  Constraints: if (op == "~"); </small>
</dt> <dd>
<p>Append a comment to the interior of this element </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Comment <code>item</code>
</td> <td>the item you wish to append.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">Element element;
element ~= new Comment("hello");
</pre>  </dd> <dt class="d_decl" id="Element.opOpAssign.4">pure @safe void <strong id="opOpAssign">opOpAssign</strong>(string op)(ProcessingInstruction item)<br><small>  Constraints: if (op == "~"); </small>
</dt> <dd>
<p>Append a processing instruction to the interior of this element </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>ProcessingInstruction <code>item</code>
</td> <td>the item you wish to append.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">Element element;
element ~= new ProcessingInstruction("hello");
</pre>  </dd> <dt class="d_decl" id="Element.opOpAssign.5">pure @safe void <strong id="opOpAssign">opOpAssign</strong>(string op)(Element item)<br><small>  Constraints: if (op == "~"); </small>
</dt> <dd>
<p>Append a complete element to the interior of this element </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Element <code>item</code>
</td> <td>the item you wish to append.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">Element element;
Element other = new Element("br");
element ~= other;
   // appends element representing &lt;br /&gt;
</pre>  </dd> <dt class="d_decl" id="Element.opEquals">const bool <strong id="opEquals">opEquals</strong>(scope const Object o); </dt> <dd>
<p>Compares two Elements for equality </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">Element e1,e2;
if (e1 == e2) { }
</pre>  </dd> <dt class="d_decl" id="Element.opCmp">const @safe int <strong id="opCmp">opCmp</strong>(scope const Object o); </dt> <dd>
<p>Compares two Elements </p>
<p>You should rarely need to call this function. It exists so that Elements can be used as associative array keys. </p> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">Element e1,e2;
if (e1 &lt; e2) { }
</pre>  </dd> <dt class="d_decl" id="Element.toHash">const scope @safe size_t <strong id="toHash">toHash</strong>(); </dt> <dd>
<p>Returns the hash of an Element </p>
<p>You should rarely need to call this function. It exists so that Elements can be used as associative array keys.</p> </dd> <dt class="d_decl" id="Element.text">const string <strong id="text">text</strong>(DecodeMode mode = DecodeMode.LOOSE); </dt> <dd>
<p>Returns the decoded interior of an element. </p>
<p>The element is assumed to contain text <i>only</i>. So, for example, given XML such as "&lt;title&gt;Good &amp;amp; Bad&lt;/title&gt;", will return "Good &amp; Bad". </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>DecodeMode <code>mode</code>
</td> <td>(optional) Mode to use for decoding. (Defaults to LOOSE).</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>DecodeException if decode fails</dd>
</dl> </dd> <dt class="d_decl" id="Element.pretty">const scope string[] <strong id="pretty">pretty</strong>(uint indent = 2); </dt> <dd>
<p>Returns an indented string representation of this item </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>uint <code>indent</code>
</td> <td>(optional) number of spaces by which to indent this element. Defaults to 2.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Element.toString">const scope @safe string <strong id="toString">toString</strong>(); </dt> <dd>
<p>Returns the string representation of an Element </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto element = new Element("br");
writefln(element.toString()); // writes "&lt;br /&gt;"
</pre>  </dd> </dl> </dd> <dt class="d_decl" id="TagType">enum <strong id="TagType">TagType</strong>: int; </dt> <dd>
<p>Tag types. </p>
<p></p>
<dl>START</dl> Used for start tags <dl>END</dl> Used for end tags <dl>EMPTY</dl> Used for empty tags </dd> <dt class="d_decl" id="Tag">class <strong id="Tag">Tag</strong>; </dt> <dd>
<p>Class representing an XML tag. </p>
<dl>
<dt>Standards:</dt>
<dd>
<a href="http://www.w3.org/TR/1998/REC-xml-19980210">XML 1.0</a>  The class invariant guarantees <ul> <li> that <b>type</b> is a valid enum TagType value</li> <li> that <b>name</b> consists of valid characters</li> <li> that each attribute name consists of valid characters</li> </ul>
</dd>
</dl> <dl>
<dt class="d_decl" id="Tag.type">TagType <strong id="type">type</strong>; </dt> <dd>
<p>Type of tag</p> </dd> <dt class="d_decl" id="Tag.name">string <strong id="name">name</strong>; </dt> <dd>
<p>Tag name</p> </dd> <dt class="d_decl" id="Tag.attr">string[string] <strong id="attr">attr</strong>; </dt> <dd>
<p>Associative array of attributes</p> </dd> <dt class="d_decl" id="Tag.this">pure @safe this(string name, TagType type = TagType.START); </dt> <dd>
<p>Constructs an instance of Tag with a specified name and type </p>
<p>The constructor does not initialize the attributes. To initialize the attributes, you access the <b>attr</b> member variable. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>string <code>name</code>
</td> <td>the Tag's name</td>
</tr> <tr>
<td>TagType <code>type</code>
</td> <td>(optional) the Tag's type. If omitted, defaults to TagType.START.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto tag = new Tag("img",Tag.EMPTY);
tag.attr["src"] = "http://example.com/example.jpg";
</pre>  </dd> <dt class="d_decl" id="Tag.opEquals">const bool <strong id="opEquals">opEquals</strong>(scope Object o); </dt> <dd>
<p>Compares two Tags for equality </p>
<p>You should rarely need to call this function. It exists so that Tags can be used as associative array keys. </p> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">Tag tag1,tag2
if (tag1 == tag2) { }
</pre>  </dd> <dt class="d_decl" id="Tag.opCmp">const int <strong id="opCmp">opCmp</strong>(Object o); </dt> <dd>
<p>Compares two Tags </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">Tag tag1,tag2
if (tag1 &lt; tag2) { }
</pre>  </dd> <dt class="d_decl" id="Tag.toHash">const size_t <strong id="toHash">toHash</strong>(); </dt> <dd>
<p>Returns the hash of a Tag </p>
<p>You should rarely need to call this function. It exists so that Tags can be used as associative array keys.</p> </dd> <dt class="d_decl" id="Tag.toString">const @safe string <strong id="toString">toString</strong>(); </dt> <dd>
<p>Returns the string representation of a Tag </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto tag = new Tag("book",TagType.START);
writefln(tag.toString()); // writes "&lt;book&gt;"
</pre>  </dd> <dt class="d_decl" id="Tag.isStart">const pure nothrow @nogc @property @safe bool <strong id="isStart">isStart</strong>(); </dt> <dd>
<p>Returns true if the Tag is a start tag </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">if (tag.isStart) { }
</pre>  </dd> <dt class="d_decl" id="Tag.isEnd">const pure nothrow @nogc @property @safe bool <strong id="isEnd">isEnd</strong>(); </dt> <dd>
<p>Returns true if the Tag is an end tag </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">if (tag.isEnd) { }
</pre>  </dd> <dt class="d_decl" id="Tag.isEmpty">const pure nothrow @nogc @property @safe bool <strong id="isEmpty">isEmpty</strong>(); </dt> <dd>
<p>Returns true if the Tag is an empty tag </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">if (tag.isEmpty) { }
</pre>  </dd> </dl> </dd> <dt class="d_decl" id="Comment">class <strong id="Comment">Comment</strong>: std.xml.Item; </dt> <dd>
<p>Class representing a comment</p> <dl>
<dt class="d_decl" id="Comment.this">pure @safe this(string content); </dt> <dd>
<p>Construct a comment </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>string <code>content</code>
</td> <td>the body of the comment</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>CommentException if the comment body is illegal (contains "--" or exactly equals "-") </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto item = new Comment("This is a comment");
   // constructs &lt;!--This is a comment--&gt;
</pre>  </dd> <dt class="d_decl" id="Comment.opEquals">const bool <strong id="opEquals">opEquals</strong>(scope const Object o); </dt> <dd>
<p>Compares two comments for equality </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">Comment item1,item2;
if (item1 == item2) { }
</pre>  </dd> <dt class="d_decl" id="Comment.opCmp">const scope int <strong id="opCmp">opCmp</strong>(scope const Object o); </dt> <dd>
<p>Compares two comments </p>
<p>You should rarely need to call this function. It exists so that Comments can be used as associative array keys. </p> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">Comment item1,item2;
if (item1 &lt; item2) { }
</pre>  </dd> <dt class="d_decl" id="Comment.toHash">const nothrow scope size_t <strong id="toHash">toHash</strong>(); </dt> <dd>
<p>Returns the hash of a Comment </p>
<p>You should rarely need to call this function. It exists so that Comments can be used as associative array keys.</p> </dd> <dt class="d_decl" id="Comment.toString">const pure nothrow scope @safe string <strong id="toString">toString</strong>(); </dt> <dd>
<p>Returns a string representation of this comment</p> </dd> <dt class="d_decl" id="Comment.isEmptyXML">const pure nothrow @nogc @property scope @safe bool <strong id="isEmptyXML">isEmptyXML</strong>(); </dt> <dd>
<p>Returns false always</p> </dd> </dl> </dd> <dt class="d_decl" id="CData">class <strong id="CData">CData</strong>: std.xml.Item; </dt> <dd>
<p>Class representing a Character Data section</p> <dl>
<dt class="d_decl" id="CData.this">pure @safe this(string content); </dt> <dd>
<p>Construct a character data section </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>string <code>content</code>
</td> <td>the body of the character data segment</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>CDataException if the segment body is illegal (contains "]]&gt;") </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto item = new CData("&lt;b&gt;hello&lt;/b&gt;");
   // constructs &lt;![CDATA[&lt;b&gt;hello&lt;/b&gt;]]&gt;
</pre>  </dd> <dt class="d_decl" id="CData.opEquals">const bool <strong id="opEquals">opEquals</strong>(scope const Object o); </dt> <dd>
<p>Compares two CDatas for equality </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">CData item1,item2;
if (item1 == item2) { }
</pre>  </dd> <dt class="d_decl" id="CData.opCmp">const scope int <strong id="opCmp">opCmp</strong>(scope const Object o); </dt> <dd>
<p>Compares two CDatas </p>
<p>You should rarely need to call this function. It exists so that CDatas can be used as associative array keys. </p> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">CData item1,item2;
if (item1 &lt; item2) { }
</pre>  </dd> <dt class="d_decl" id="CData.toHash">const nothrow scope size_t <strong id="toHash">toHash</strong>(); </dt> <dd>
<p>Returns the hash of a CData </p>
<p>You should rarely need to call this function. It exists so that CDatas can be used as associative array keys.</p> </dd> <dt class="d_decl" id="CData.toString">const pure nothrow scope @safe string <strong id="toString">toString</strong>(); </dt> <dd>
<p>Returns a string representation of this CData section</p> </dd> <dt class="d_decl" id="CData.isEmptyXML">const pure nothrow @nogc @property scope @safe bool <strong id="isEmptyXML">isEmptyXML</strong>(); </dt> <dd>
<p>Returns false always</p> </dd> </dl> </dd> <dt class="d_decl" id="Text">class <strong id="Text">Text</strong>: std.xml.Item; </dt> <dd>
<p>Class representing a text (aka Parsed Character Data) section</p> <dl>
<dt class="d_decl" id="Text.this">pure @safe this(string content); </dt> <dd>
<p>Construct a text (aka PCData) section </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>string <code>content</code>
</td> <td>the text. This function encodes the text before insertion, so it is safe to insert any text</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto Text = new CData("a &lt; b");
   // constructs a &amp;lt; b
</pre>  </dd> <dt class="d_decl" id="Text.opEquals">const bool <strong id="opEquals">opEquals</strong>(scope const Object o); </dt> <dd>
<p>Compares two text sections for equality </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">Text item1,item2;
if (item1 == item2) { }
</pre>  </dd> <dt class="d_decl" id="Text.opCmp">const scope int <strong id="opCmp">opCmp</strong>(scope const Object o); </dt> <dd>
<p>Compares two text sections </p>
<p>You should rarely need to call this function. It exists so that Texts can be used as associative array keys. </p> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">Text item1,item2;
if (item1 &lt; item2) { }
</pre>  </dd> <dt class="d_decl" id="Text.toHash">const nothrow scope size_t <strong id="toHash">toHash</strong>(); </dt> <dd>
<p>Returns the hash of a text section </p>
<p>You should rarely need to call this function. It exists so that Texts can be used as associative array keys.</p> </dd> <dt class="d_decl" id="Text.toString">const pure nothrow @nogc scope @safe string <strong id="toString">toString</strong>(); </dt> <dd>
<p>Returns a string representation of this Text section</p> </dd> <dt class="d_decl" id="Text.isEmptyXML">const pure nothrow @nogc @property scope @safe bool <strong id="isEmptyXML">isEmptyXML</strong>(); </dt> <dd>
<p>Returns true if the content is the empty string</p> </dd> </dl> </dd> <dt class="d_decl" id="XMLInstruction">class <strong id="XMLInstruction">XMLInstruction</strong>: std.xml.Item; </dt> <dd>
<p>Class representing an XML Instruction section</p> <dl>
<dt class="d_decl" id="XMLInstruction.this">pure @safe this(string content); </dt> <dd>
<p>Construct an XML Instruction section </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>string <code>content</code>
</td> <td>the body of the instruction segment</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>XIException if the segment body is illegal (contains "&gt;") </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto item = new XMLInstruction("ATTLIST");
   // constructs &lt;!ATTLIST&gt;
</pre>  </dd> <dt class="d_decl" id="XMLInstruction.opEquals">const bool <strong id="opEquals">opEquals</strong>(scope const Object o); </dt> <dd>
<p>Compares two XML instructions for equality </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">XMLInstruction item1,item2;
if (item1 == item2) { }
</pre>  </dd> <dt class="d_decl" id="XMLInstruction.opCmp">const scope int <strong id="opCmp">opCmp</strong>(scope const Object o); </dt> <dd>
<p>Compares two XML instructions </p>
<p>You should rarely need to call this function. It exists so that XmlInstructions can be used as associative array keys. </p> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">XMLInstruction item1,item2;
if (item1 &lt; item2) { }
</pre>  </dd> <dt class="d_decl" id="XMLInstruction.toHash">const nothrow scope size_t <strong id="toHash">toHash</strong>(); </dt> <dd>
<p>Returns the hash of an XMLInstruction </p>
<p>You should rarely need to call this function. It exists so that XmlInstructions can be used as associative array keys.</p> </dd> <dt class="d_decl" id="XMLInstruction.toString">const pure nothrow scope @safe string <strong id="toString">toString</strong>(); </dt> <dd>
<p>Returns a string representation of this XmlInstruction</p> </dd> <dt class="d_decl" id="XMLInstruction.isEmptyXML">const pure nothrow @nogc @property scope @safe bool <strong id="isEmptyXML">isEmptyXML</strong>(); </dt> <dd>
<p>Returns false always</p> </dd> </dl> </dd> <dt class="d_decl" id="ProcessingInstruction">class <strong id="ProcessingInstruction">ProcessingInstruction</strong>: std.xml.Item; </dt> <dd>
<p>Class representing a Processing Instruction section</p> <dl>
<dt class="d_decl" id="ProcessingInstruction.this">pure @safe this(string content); </dt> <dd>
<p>Construct a Processing Instruction section </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>string <code>content</code>
</td> <td>the body of the instruction segment</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>PIException if the segment body is illegal (contains "?&gt;") </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto item = new ProcessingInstruction("php");
   // constructs &lt;?php?&gt;
</pre>  </dd> <dt class="d_decl" id="ProcessingInstruction.opEquals">const bool <strong id="opEquals">opEquals</strong>(scope const Object o); </dt> <dd>
<p>Compares two processing instructions for equality </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">ProcessingInstruction item1,item2;
if (item1 == item2) { }
</pre>  </dd> <dt class="d_decl" id="ProcessingInstruction.opCmp">const scope int <strong id="opCmp">opCmp</strong>(scope const Object o); </dt> <dd>
<p>Compares two processing instructions </p>
<p>You should rarely need to call this function. It exists so that ProcessingInstructions can be used as associative array keys. </p> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">ProcessingInstruction item1,item2;
if (item1 &lt; item2) { }
</pre>  </dd> <dt class="d_decl" id="ProcessingInstruction.toHash">const nothrow scope size_t <strong id="toHash">toHash</strong>(); </dt> <dd>
<p>Returns the hash of a ProcessingInstruction </p>
<p>You should rarely need to call this function. It exists so that ProcessingInstructions can be used as associative array keys.</p> </dd> <dt class="d_decl" id="ProcessingInstruction.toString">const pure nothrow scope @safe string <strong id="toString">toString</strong>(); </dt> <dd>
<p>Returns a string representation of this ProcessingInstruction</p> </dd> <dt class="d_decl" id="ProcessingInstruction.isEmptyXML">const pure nothrow @nogc @property scope @safe bool <strong id="isEmptyXML">isEmptyXML</strong>(); </dt> <dd>
<p>Returns false always</p> </dd> </dl> </dd> <dt class="d_decl" id="Item">abstract class <strong id="Item">Item</strong>; </dt> <dd>
<p>Abstract base class for XML items</p> <dl>
<dt class="d_decl" id="Item.opEquals">abstract const @safe bool <strong id="opEquals">opEquals</strong>(scope const Object o); </dt> <dd>
<p>Compares with another Item of same type for equality</p> </dd> <dt class="d_decl" id="Item.opCmp">abstract const @safe int <strong id="opCmp">opCmp</strong>(scope const Object o); </dt> <dd>
<p>Compares with another Item of same type</p> </dd> <dt class="d_decl" id="Item.toHash">abstract const scope @safe size_t <strong id="toHash">toHash</strong>(); </dt> <dd>
<p>Returns the hash of this item</p> </dd> <dt class="d_decl" id="Item.toString">abstract const scope @safe string <strong id="toString">toString</strong>(); </dt> <dd>
<p>Returns a string representation of this item</p> </dd> <dt class="d_decl" id="Item.pretty">const scope @safe string[] <strong id="pretty">pretty</strong>(uint indent); </dt> <dd>
<p>Returns an indented string representation of this item </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>uint <code>indent</code>
</td> <td>number of spaces by which to indent child elements</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Item.isEmptyXML">abstract const pure nothrow @nogc @property scope @safe bool <strong id="isEmptyXML">isEmptyXML</strong>(); </dt> <dd>
<p>Returns true if the item represents empty XML text</p> </dd> </dl> </dd> <dt class="d_decl" id="DocumentParser">class <strong id="DocumentParser">DocumentParser</strong>: std.xml.ElementParser; </dt> <dd>
<p>Class for parsing an XML Document. </p>
<p>This is a subclass of ElementParser. Most of the useful functions are documented there. </p> <dl>
<dt>Standards:</dt>
<dd>
<a href="http://www.w3.org/TR/1998/REC-xml-19980210">XML 1.0</a> </dd>
</dl> <dl>
<dt>Bugs:</dt>
<dd>Currently only supports UTF documents.  If there is an encoding attribute in the prolog, it is ignored.</dd>
</dl> <dl>
<dt class="d_decl" id="DocumentParser.this">this(string xmlText_); </dt> <dd>
<p>Constructs a DocumentParser. </p>
<p>The input to this function MUST be valid XML. This is enforced by the function's in contract. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>string <code>xmlText_</code>
</td> <td>the entire XML document as text</td>
</tr> </table></dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="ElementParser">class <strong id="ElementParser">ElementParser</strong>; </dt> <dd>
<p>Class for parsing an XML element. </p>
<dl>
<dt>Standards:</dt>
<dd>
<a href="http://www.w3.org/TR/1998/REC-xml-19980210">XML 1.0</a>  Note that you cannot construct instances of this class directly. You can construct a DocumentParser (which is a subclass of ElementParser), but otherwise, Instances of ElementParser will be created for you by the library, and passed your way via onStartTag handlers.</dd>
</dl> <dl>
<dt class="d_decl" id="ElementParser.tag">const pure nothrow @nogc @property @safe const(Tag) <strong id="tag">tag</strong>(); </dt> <dd>
<p>The Tag at the start of the element being parsed. You can read this to determine the tag's name and attributes.</p> </dd> <dt class="d_decl" id="ElementParser.onStartTag">ParserHandler[string] <strong id="onStartTag">onStartTag</strong>; </dt> <dd>
<p>Register a handler which will be called whenever a start tag is encountered which matches the specified name. You can also pass null as the name, in which case the handler will be called for any unmatched start tag. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">// Call this function whenever a &lt;podcast&gt; start tag is encountered
onStartTag["podcast"] = (ElementParser xml)
{
    // Your code here
    //
    // This is a a closure, so code here may reference
    // variables which are outside of this scope
};

// call myEpisodeStartHandler (defined elsewhere) whenever an &lt;episode&gt;
// start tag is encountered
onStartTag["episode"] = &amp;myEpisodeStartHandler;

// call delegate dg for all other start tags
onStartTag[null] = dg;
</pre>  This library will supply your function with a new instance of ElementHandler, which may be used to parse inside the element whose start tag was just found, or to identify the tag attributes of the element, etc.  Note that your function will be called for both start tags and empty tags. That is, we make no distinction between &lt;br&gt;&lt;/br&gt; and &lt;br/&gt;. </dd> <dt class="d_decl" id="ElementParser.onEndTag">ElementHandler[string] <strong id="onEndTag">onEndTag</strong>; </dt> <dd>
<p>Register a handler which will be called whenever an end tag is encountered which matches the specified name. You can also pass null as the name, in which case the handler will be called for any unmatched end tag. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">// Call this function whenever a &lt;/podcast&gt; end tag is encountered
onEndTag["podcast"] = (in Element e)
{
    // Your code here
    //
    // This is a a closure, so code here may reference
    // variables which are outside of this scope
};

// call myEpisodeEndHandler (defined elsewhere) whenever an &lt;/episode&gt;
// end tag is encountered
onEndTag["episode"] = &amp;myEpisodeEndHandler;

// call delegate dg for all other end tags
onEndTag[null] = dg;
</pre>  Note that your function will be called for both start tags and empty tags. That is, we make no distinction between &lt;br&gt;&lt;/br&gt; and &lt;br/&gt;. </dd> <dt class="d_decl" id="ElementParser.onText">pure nothrow @nogc @property @safe void <strong id="onText">onText</strong>(Handler handler); </dt> <dd>
<p>Register a handler which will be called whenever text is encountered. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">// Call this function whenever text is encountered
onText = (string s)
{
    // Your code here

    // The passed parameter s will have been decoded by the time you see
    // it, and so may contain any character.
    //
    // This is a a closure, so code here may reference
    // variables which are outside of this scope
};
</pre>  </dd> <dt class="d_decl" id="ElementParser.onTextRaw">pure nothrow @nogc @safe void <strong id="onTextRaw">onTextRaw</strong>(Handler handler); </dt> <dd>
<p>Register an alternative handler which will be called whenever text is encountered. This differs from onText in that onText will decode the text, whereas onTextRaw will not. This allows you to make design choices, since onText will be more accurate, but slower, while onTextRaw will be faster, but less accurate. Of course, you can still call decode() within your handler, if you want, but you'd probably want to use onTextRaw only in circumstances where you know that decoding is unnecessary. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">// Call this function whenever text is encountered
onText = (string s)
{
    // Your code here

    // The passed parameter s will NOT have been decoded.
    //
    // This is a a closure, so code here may reference
    // variables which are outside of this scope
};
</pre>  </dd> <dt class="d_decl" id="ElementParser.onCData">pure nothrow @nogc @property @safe void <strong id="onCData">onCData</strong>(Handler handler); </dt> <dd>
<p>Register a handler which will be called whenever a character data segment is encountered. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">// Call this function whenever a CData section is encountered
onCData = (string s)
{
    // Your code here

    // The passed parameter s does not include the opening &lt;![CDATA[
    // nor closing ]]&gt;
    //
    // This is a a closure, so code here may reference
    // variables which are outside of this scope
};
</pre>  </dd> <dt class="d_decl" id="ElementParser.onComment">pure nothrow @nogc @property @safe void <strong id="onComment">onComment</strong>(Handler handler); </dt> <dd>
<p>Register a handler which will be called whenever a comment is encountered. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">// Call this function whenever a comment is encountered
onComment = (string s)
{
    // Your code here

    // The passed parameter s does not include the opening &lt;!-- nor
    // closing --&gt;
    //
    // This is a a closure, so code here may reference
    // variables which are outside of this scope
};
</pre>  </dd> <dt class="d_decl" id="ElementParser.onPI">pure nothrow @nogc @property @safe void <strong id="onPI">onPI</strong>(Handler handler); </dt> <dd>
<p>Register a handler which will be called whenever a processing instruction is encountered. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">// Call this function whenever a processing instruction is encountered
onPI = (string s)
{
    // Your code here

    // The passed parameter s does not include the opening &lt;? nor
    // closing ?&gt;
    //
    // This is a a closure, so code here may reference
    // variables which are outside of this scope
};
</pre>  </dd> <dt class="d_decl" id="ElementParser.onXI">pure nothrow @nogc @property @safe void <strong id="onXI">onXI</strong>(Handler handler); </dt> <dd>
<p>Register a handler which will be called whenever an XML instruction is encountered. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">// Call this function whenever an XML instruction is encountered
// (Note: XML instructions may only occur preceding the root tag of a
// document).
onPI = (string s)
{
    // Your code here

    // The passed parameter s does not include the opening &lt;! nor
    // closing &gt;
    //
    // This is a a closure, so code here may reference
    // variables which are outside of this scope
};
</pre>  </dd> <dt class="d_decl" id="ElementParser.parse">void <strong id="parse">parse</strong>(); </dt> <dd>
<p>Parse an XML element. </p>
<p>Parsing will continue until the end of the current element. Any items encountered for which a handler has been registered will invoke that handler. </p> <dl>
<dt>Throws:</dt>
<dd>various kinds of XMLException</dd>
</dl> </dd> <dt class="d_decl" id="ElementParser.toString">const pure nothrow @nogc @safe string <strong id="toString">toString</strong>(); </dt> <dd>
<p>Returns that part of the element which has already been parsed</p> </dd> </dl> </dd> <dt class="d_decl" id="check">pure @safe void <strong id="check">check</strong>(string s); </dt> <dd>
<p>Check an entire XML document for well-formedness </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>string <code>s</code>
</td> <td>the document to be checked, passed as a string</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>CheckException if the document is not well formed  CheckException's toString() method will yield the complete hierarchy of parse failure (the XML equivalent of a stack trace), giving the line and column number of every failure at every level.</dd>
</dl> </dd> <dt class="d_decl" id="XMLException">class <strong id="XMLException">XMLException</strong>: object.Exception; </dt> <dd>
<p>The base class for exceptions thrown by this module</p> </dd> <dt class="d_decl" id="CommentException">class <strong id="CommentException">CommentException</strong>: std.xml.XMLException; </dt> <dd>
<p>Thrown during Comment constructor</p> </dd> <dt class="d_decl" id="CDataException">class <strong id="CDataException">CDataException</strong>: std.xml.XMLException; </dt> <dd>
<p>Thrown during CData constructor</p> </dd> <dt class="d_decl" id="XIException">class <strong id="XIException">XIException</strong>: std.xml.XMLException; </dt> <dd>
<p>Thrown during XMLInstruction constructor</p> </dd> <dt class="d_decl" id="PIException">class <strong id="PIException">PIException</strong>: std.xml.XMLException; </dt> <dd>
<p>Thrown during ProcessingInstruction constructor</p> </dd> <dt class="d_decl" id="TextException">class <strong id="TextException">TextException</strong>: std.xml.XMLException; </dt> <dd>
<p>Thrown during Text constructor</p> </dd> <dt class="d_decl" id="DecodeException">class <strong id="DecodeException">DecodeException</strong>: std.xml.XMLException; </dt> <dd>
<p>Thrown during decode()</p> </dd> <dt class="d_decl" id="InvalidTypeException">class <strong id="InvalidTypeException">InvalidTypeException</strong>: std.xml.XMLException; </dt> <dd>
<p>Thrown if comparing with wrong type</p> </dd> <dt class="d_decl" id="TagException">class <strong id="TagException">TagException</strong>: std.xml.XMLException; </dt> <dd>
<p>Thrown when parsing for Tags</p> </dd> <dt class="d_decl" id="CheckException">class <strong id="CheckException">CheckException</strong>: std.xml.XMLException; </dt> <dd>
<p>Thrown during check()</p> <dl>
<dt class="d_decl" id="CheckException.err">CheckException <strong id="err">err</strong>; </dt> <dd>
<p>Parent in hierarchy</p> </dd> <dt class="d_decl" id="CheckException.msg">string <strong id="msg">msg</strong>; </dt> <dd>
<p>Name of production rule which failed to parse, or specific error message</p> </dd> <dt class="d_decl" id="CheckException.line">size_t <strong id="line">line</strong>; </dt> <dd>
<p>Line number at which parse failure occurred</p> </dd> <dt class="d_decl" id="CheckException.column">size_t <strong id="column">column</strong>; </dt> <dd>
<p>Column number at which parse failure occurred</p> </dd> </dl> </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
     19992019 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_xml.html" class="_attribution-link">https://dlang.org/phobos/std_xml.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
