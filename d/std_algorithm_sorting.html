
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>std.algorithm.sorting - D - W3cubDocs</title>
  
  <meta name="description" content=" This is a submodule of std.algorithm. It contains generic sorting algorithms. ">
  <meta name="keywords" content="std, algorithm, sorting, d">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/d/std_algorithm_sorting.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/d.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/d/" class="_nav-link" title="" style="margin-left:0;">D</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _d">
				
				
<h1>std.algorithm.sorting</h1>  <p>This is a submodule of <a href="std_algorithm"><code>std.algorithm</code></a>. It contains generic sorting algorithms. </p>
<p> </p>
<table>
<caption>Cheat Sheet</caption>
<tr>
<th scope="col">Function Name</th> <th scope="col">Description</th>
</tr> <tr>
<td><a href="#completeSort"><code>completeSort</code></a></td> <td> If <code>a = [10, 20, 30]</code> and <code>b = [40, 6, 15]</code>, then <code>completeSort(a, b)</code> leaves <code>a = [6, 10, 15]</code> and <code>b = [20, 30, 40]</code>. The range <code>a</code> must be sorted prior to the call, and as a result the combination <code><a href="std_range#chain">std.range.chain</a>(a, b)</code> is sorted.</td>
</tr> <tr>
<td><a href="#isPartitioned"><code>isPartitioned</code></a></td> <td> <code>isPartitioned!"a &lt; 0"([-1, -2, 1, 0, 2])</code> returns <code>true</code> because the predicate is <code>true</code> for a portion of the range and <code>false</code> afterwards.</td>
</tr> <tr>
<td><a href="#isSorted"><code>isSorted</code></a></td> <td> <code>isSorted([1, 1, 2, 3])</code> returns <code>true</code>.</td>
</tr> <tr>
<td><a href="#isStrictlyMonotonic"><code>isStrictlyMonotonic</code></a></td> <td> <code>isStrictlyMonotonic([1, 1, 2, 3])</code> returns <code>false</code>.</td>
</tr> <tr>
<td><a href="#ordered"><code>ordered</code></a></td> <td> <code>ordered(1, 1, 2, 3)</code> returns <code>true</code>.</td>
</tr> <tr>
<td><a href="#strictlyOrdered"><code>strictlyOrdered</code></a></td> <td> <code>strictlyOrdered(1, 1, 2, 3)</code> returns <code>false</code>.</td>
</tr> <tr>
<td><a href="#makeIndex"><code>makeIndex</code></a></td> <td> Creates a separate index for a range.</td>
</tr> <tr>
<td><a href="#merge"><code>merge</code></a></td> <td> Lazily merges two or more sorted ranges.</td>
</tr> <tr>
<td><a href="#multiSort"><code>multiSort</code></a></td> <td> Sorts by multiple keys.</td>
</tr> <tr>
<td><a href="#nextEvenPermutation"><code>nextEvenPermutation</code></a></td> <td> Computes the next lexicographically greater even permutation of a range in-place.</td>
</tr> <tr>
<td><a href="#nextPermutation"><code>nextPermutation</code></a></td> <td> Computes the next lexicographically greater permutation of a range in-place.</td>
</tr> <tr>
<td><a href="#nthPermutation"><code>nthPermutation</code></a></td> <td> Computes the nth permutation of a range in-place.</td>
</tr> <tr>
<td><a href="#partialSort"><code>partialSort</code></a></td> <td> If <code>a = [5, 4, 3, 2, 1]</code>, then <code>partialSort(a, 3)</code> leaves <code>a[0 .. 3] = [1, 2, 3]</code>. The other elements of <code>a</code> are left in an unspecified order.</td>
</tr> <tr>
<td><a href="#partition"><code>partition</code></a></td> <td> Partitions a range according to a unary predicate.</td>
</tr> <tr>
<td><a href="#partition3"><code>partition3</code></a></td> <td> Partitions a range according to a binary predicate in three parts (less than, equal, greater than the given pivot). Pivot is not given as an index, but instead as an element independent from the range's content.</td>
</tr> <tr>
<td><a href="#pivotPartition"><code>pivotPartition</code></a></td> <td> Partitions a range according to a binary predicate in two parts: less than or equal, and greater than or equal to the given pivot, passed as an index in the range.</td>
</tr> <tr>
<td><a href="#schwartzSort"><code>schwartzSort</code></a></td> <td> Sorts with the help of the <a href="https://en.wikipedia.org/wiki/Schwartzian_transform">Schwartzian transform</a>.</td>
</tr> <tr>
<td><a href="#sort"><code>sort</code></a></td> <td> Sorts.</td>
</tr> <tr>
<td><a href="#topN"><code>topN</code></a></td> <td> Separates the top elements in a range.</td>
</tr> <tr>
<td><a href="#topNCopy"><code>topNCopy</code></a></td> <td> Copies out the top elements of a range.</td>
</tr> <tr>
<td><a href="#topNIndex"><code>topNIndex</code></a></td> <td> Builds an index of the top elements of a range.</td>
</tr> </table>  <dl>
<dt>License:</dt>
<dd>
<a href="http://boost.org/LICENSE_1_0.txt">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>
<a href="http://erdani.com">Andrei Alexandrescu</a> </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/algorithm/sorting.d">std/algorithm/sorting.d</a></span> </dd>
</dl> <dl>
<dt class="d_decl" id="SortOutput">alias <strong id="SortOutput">SortOutput</strong> = std.typecons.Flag!"sortOutput".Flag; </dt> <dd>
<p>Specifies whether the output of certain algorithm is desired in sorted format. </p>
<p>If set to <code>SortOutput.no</code>, the output should not be sorted. <br><br> Otherwise if set to <code>SortOutput.yes</code>, the output should be sorted.</p> </dd> <dt class="d_decl" id="completeSort">void <strong id="completeSort">completeSort</strong>(alias less = "a &lt; b", SwapStrategy ss = SwapStrategy.unstable, Lhs, Rhs)(SortedRange!(Lhs, less) lhs, Rhs rhs)<br><small>  Constraints: if (hasLength!Rhs &amp;&amp; hasSlicing!Rhs &amp;&amp; hasSwappableElements!Lhs &amp;&amp; hasSwappableElements!Rhs); </small>
</dt> <dd>
<p>Sorts the random-access range <code>chain(lhs, rhs)</code> according to predicate <code>less</code>. The left-hand side of the range <code>lhs</code> is assumed to be already sorted; <code>rhs</code> is assumed to be unsorted. The exact strategy chosen depends on the relative sizes of <code>lhs</code> and <code>rhs</code>. Performs <span class="bigoh">Ο(<code>lhs.length + rhs.length * log(rhs.length)</code>)</span> (best case) to <span class="bigoh">Ο(<code>(lhs.length + rhs.length) * log(lhs.length + rhs.length)</code>)</span> (worst-case) evaluations of <code>swap</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>less</td> <td>The predicate to sort by.</td>
</tr> <tr>
<td>ss</td> <td>The swapping strategy to use.</td>
</tr> <tr>
<td>SortedRange!(Lhs, less) <code>lhs</code>
</td> <td>The sorted, left-hand side of the random access range to be sorted.</td>
</tr> <tr>
<td>Rhs <code>rhs</code>
</td> <td>The unsorted, right-hand side of the random access range to be sorted.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.range : assumeSorted;
int[] a = [ 1, 2, 3 ];
int[] b = [ 4, 0, 6, 5 ];
completeSort(assumeSorted(a), b);
writeln(a); // [0, 1, 2]
writeln(b); // [3, 4, 5, 6]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isSorted">bool <strong id="isSorted">isSorted</strong>(alias less = "a &lt; b", Range)(Range r)<br><small>  Constraints: if (isForwardRange!Range); </small><br><br>bool <strong id="isStrictlyMonotonic">isStrictlyMonotonic</strong>(alias less = "a &lt; b", Range)(Range r)<br><small>  Constraints: if (isForwardRange!Range); </small>
</dt> <dd>
<p>Checks whether a <a href="std_range_primitives#isForwardRange">forward range</a> is sorted according to the comparison operation <code>less</code>. Performs <span class="bigoh">Ο(<code>r.length</code>)</span> evaluations of <code>less</code>. </p>
<p>Unlike <code>isSorted</code>, <code>isStrictlyMonotonic</code> does not allow for equal values, i.e. values for which both <code>less(a, b)</code> and <code>less(b, a)</code> are false. <br><br> With either function, the predicate must be a strict ordering just like with <code>isSorted</code>. For example, using <code>"a &lt;= b"</code> instead of <code>"a &lt; b"</code> is incorrect and will cause failed assertions. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>less</td> <td>Predicate the range should be sorted by.</td>
</tr> <tr>
<td>Range <code>r</code>
</td> <td>Forward range to check for sortedness.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if the range is sorted, false otherwise. <code>isSorted</code> allows duplicates, <code>isStrictlyMonotonic</code> not.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert([1, 1, 2].isSorted);
// strictly monotonic doesn't allow duplicates
assert(![1, 1, 2].isStrictlyMonotonic);

int[] arr = [4, 3, 2, 1];
assert(!isSorted(arr));
assert(!isStrictlyMonotonic(arr));

assert(isSorted!"a &gt; b"(arr));
assert(isStrictlyMonotonic!"a &gt; b"(arr));

sort(arr);
assert(isSorted(arr));
assert(isStrictlyMonotonic(arr));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="ordered">bool <strong id="ordered">ordered</strong>(alias less = "a &lt; b", T...)(T values)<br><small>  Constraints: if (T.length == 2 &amp;&amp; is(typeof(binaryFun!less(values[1], values[0])) : bool) || T.length &gt; 2 &amp;&amp; is(typeof(ordered!less(values[0..1 + $ / 2]))) &amp;&amp; is(typeof(ordered!less(values[$ / 2..$])))); </small><br><br>bool <strong id="strictlyOrdered">strictlyOrdered</strong>(alias less = "a &lt; b", T...)(T values)<br><small>  Constraints: if (is(typeof(ordered!less(values)))); </small>
</dt> <dd>
<p>Like <code>isSorted</code>, returns <code>true</code> if the given <code>values</code> are ordered according to the comparison operation <code>less</code>. Unlike <code>isSorted</code>, takes values directly instead of structured in a range. </p>
<p><code>ordered</code> allows repeated values, e.g. <code>ordered(1, 1, 2)</code> is <code>true</code>. To verify that the values are ordered strictly monotonically, use <code>strictlyOrdered</code>; <code>strictlyOrdered(1, 1, 2)</code> is <code>false</code>. <br><br> With either function, the predicate must be a strict ordering. For example, using <code>"a &lt;= b"</code> instead of <code>"a &lt; b"</code> is incorrect and will cause failed assertions. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>values</code>
</td> <td>The tested value</td>
</tr> <tr>
<td>less</td> <td>The comparison predicate</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if the values are ordered; <code>ordered</code> allows for duplicates, <code>strictlyOrdered</code> does not.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(ordered(42, 42, 43));
assert(!strictlyOrdered(43, 42, 45));
assert(ordered(42, 42, 43));
assert(!strictlyOrdered(42, 42, 43));
assert(!ordered(43, 42, 45));
// Ordered lexicographically
assert(ordered("Jane", "Jim", "Joe"));
assert(strictlyOrdered("Jane", "Jim", "Joe"));
// Incidentally also ordered by length decreasing
assert(ordered!((a, b) =&gt; a.length &gt; b.length)("Jane", "Jim", "Joe"));
// ... but not strictly so: "Jim" and "Joe" have the same length
assert(!strictlyOrdered!((a, b) =&gt; a.length &gt; b.length)("Jane", "Jim", "Joe"));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="partition">Range <strong id="partition">partition</strong>(alias predicate, SwapStrategy ss, Range)(Range r)<br><small>  Constraints: if (ss == SwapStrategy.stable &amp;&amp; isRandomAccessRange!Range &amp;&amp; hasLength!Range &amp;&amp; hasSlicing!Range &amp;&amp; hasSwappableElements!Range); </small><br><br>Range <strong id="partition">partition</strong>(alias predicate, SwapStrategy ss = SwapStrategy.unstable, Range)(Range r)<br><small>  Constraints: if (ss != SwapStrategy.stable &amp;&amp; isInputRange!Range &amp;&amp; hasSwappableElements!Range); </small>
</dt> <dd>
<p>Partitions a range in two using the given <code>predicate</code>. Specifically, reorders the range <code>r = [left, right)</code> using <code>swap</code> such that all elements <code>i</code> for which <code>predicate(i)</code> is <code>true</code> come before all elements <code>j</code> for which <code>predicate(j)</code> returns <code>false</code>. </p>
<p>Performs <span class="bigoh">Ο(<code>r.length</code>)</span> (if unstable or semistable) or <span class="bigoh">Ο(<code>r.length * log(r.length)</code>)</span> (if stable) evaluations of <code>less</code> and <code>swap</code>. The unstable version computes the minimum possible evaluations of <code>swap</code> (roughly half of those performed by the semistable version). </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>predicate</td> <td>The predicate to partition by.</td>
</tr> <tr>
<td>ss</td> <td>The swapping strategy to employ.</td>
</tr> <tr>
<td>Range <code>r</code>
</td> <td>The random-access range to partition.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The right part of <code>r</code> after partitioning.  If <code>ss == SwapStrategy.stable</code>, <code>partition</code> preserves the relative ordering of all elements <code>a</code>, <code>b</code> in <code>r</code> for which <code>predicate(a) == predicate(b)</code>. If <code>ss == SwapStrategy.semistable</code>, <code>partition</code> preserves the relative ordering of all elements <code>a</code>, <code>b</code> in the left part of <code>r</code> for which <code>predicate(a) == predicate(b)</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.mutation : SwapStrategy;
import std.algorithm.searching : count, find;
import std.conv : text;
import std.range.primitives : empty;

auto Arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
auto arr = Arr.dup;
static bool even(int a) { return (a &amp; 1) == 0; }
// Partition arr such that even numbers come first
auto r = partition!(even)(arr);
// Now arr is separated in evens and odds.
// Numbers may have become shuffled due to instability
writeln(r); // arr[5 .. &amp;dollar;]
writeln(count!(even)(arr[0 .. 5])); // 5
assert(find!(even)(r).empty);

// Can also specify the predicate as a string.
// Use 'a' as the predicate argument name
arr[] = Arr[];
r = partition!(q{(a &amp; 1) == 0})(arr);
writeln(r); // arr[5 .. &amp;dollar;]

// Now for a stable partition:
arr[] = Arr[];
r = partition!(q{(a &amp; 1) == 0}, SwapStrategy.stable)(arr);
// Now arr is [2 4 6 8 10 1 3 5 7 9], and r points to 1
assert(arr == [2, 4, 6, 8, 10, 1, 3, 5, 7, 9] &amp;&amp; r == arr[5 .. $]);

// In case the predicate needs to hold its own state, use a delegate:
arr[] = Arr[];
int x = 3;
// Put stuff greater than 3 on the left
bool fun(int a) { return a &gt; x; }
r = partition!(fun, SwapStrategy.semistable)(arr);
// Now arr is [4 5 6 7 8 9 10 2 3 1] and r points to 2
assert(arr == [4, 5, 6, 7, 8, 9, 10, 2, 3, 1] &amp;&amp; r == arr[7 .. $]);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="pivotPartition">size_t <strong id="pivotPartition">pivotPartition</strong>(alias less = "a &lt; b", Range)(Range r, size_t pivot)<br><small>  Constraints: if (isRandomAccessRange!Range &amp;&amp; hasLength!Range &amp;&amp; hasSlicing!Range &amp;&amp; hasAssignableElements!Range); </small>
</dt> <dd>
<p>Partitions <code>r</code> around <code>pivot</code> using comparison function <code>less</code>, algorithm akin to <a href="https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme">Hoare partition</a>. Specifically, permutes elements of <code>r</code> and returns an index <code>k &lt; r.length</code> such that: </p>
<p></p>
<ul>
<br><br> <li>
<code>r[pivot]</code> is swapped to <code>r[k]</code>
</li> <br><br> <li>All elements <code>e</code> in subrange <code>r[0 .. k]</code> satisfy <code>!less(r[k], e)</code> (i.e. <code>r[k]</code> is greater than or equal to each element to its left according to predicate <code>less</code>)</li> <br><br> <li>All elements <code>e</code> in subrange <code>r[k .. $]</code> satisfy <code>!less(e, r[k])</code> (i.e. <code>r[k]</code> is less than or equal to each element to its right according to predicate <code>less</code>)</li>
</ul> <br><br> If <code>r</code> contains equivalent elements, multiple permutations of <code>r</code> satisfy these constraints. In such cases, <code>pivotPartition</code> attempts to distribute equivalent elements fairly to the left and right of <code>k</code> such that <code>k</code> stays close to <code>r.length / 2</code>.  <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>less</td> <td>The predicate used for comparison, modeled as a <a href="https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings"> strict weak ordering</a> (irreflexive, antisymmetric, transitive, and implying a transitive equivalence)</td>
</tr> <tr>
<td>Range <code>r</code>
</td> <td>The range being partitioned</td>
</tr> <tr>
<td>size_t <code>pivot</code>
</td> <td>The index of the pivot for partitioning, must be less than <code>r.length</code> or <code>0</code> if <code>r.length</code> is <code>0</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The new position of the pivot </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="http://jgrcs.info/index.php/jgrcs/article/view/142">Engineering of a Quicksort Partitioning Algorithm</a>, D. Abhyankar, Journal of Global Research in Computer Science, February 2011. <a href="https://youtube.com/watch?v=AxnotgLql0k">ACCU 2016 Keynote</a>, Andrei Alexandrescu.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int[] a = [5, 3, 2, 6, 4, 1, 3, 7];
size_t pivot = pivotPartition(a, a.length / 2);
import std.algorithm.searching : all;
assert(a[0 .. pivot].all!(x =&gt; x &lt;= a[pivot]));
assert(a[pivot .. $].all!(x =&gt; x &gt;= a[pivot]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isPartitioned">bool <strong id="isPartitioned">isPartitioned</strong>(alias pred, Range)(Range r)<br><small>  Constraints: if (isForwardRange!Range); </small>
</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>pred</td> <td>The predicate that the range should be partitioned by.</td>
</tr> <tr>
<td>Range <code>r</code>
</td> <td>The range to check.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if <code>r</code> is partitioned according to predicate <code>pred</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int[] r = [ 1, 3, 5, 7, 8, 2, 4, ];
assert(isPartitioned!"a &amp; 1"(r));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="partition3">auto <strong id="partition3">partition3</strong>(alias less = "a &lt; b", SwapStrategy ss = SwapStrategy.unstable, Range, E)(Range r, E pivot)<br><small>  Constraints: if (ss == SwapStrategy.unstable &amp;&amp; isRandomAccessRange!Range &amp;&amp; hasSwappableElements!Range &amp;&amp; hasLength!Range &amp;&amp; hasSlicing!Range &amp;&amp; is(typeof(binaryFun!less(r.front, pivot)) == bool) &amp;&amp; is(typeof(binaryFun!less(pivot, r.front)) == bool) &amp;&amp; is(typeof(binaryFun!less(r.front, r.front)) == bool)); </small>
</dt> <dd>
<p>Rearranges elements in <code>r</code> in three adjacent ranges and returns them. The first and leftmost range only contains elements in <code>r</code> less than <code>pivot</code>. The second and middle range only contains elements in <code>r</code> that are equal to <code>pivot</code>. Finally, the third and rightmost range only contains elements in <code>r</code> that are greater than <code>pivot</code>. The less-than test is defined by the binary function <code>less</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>less</td> <td>The predicate to use for the rearrangement.</td>
</tr> <tr>
<td>ss</td> <td>The swapping strategy to use.</td>
</tr> <tr>
<td>Range <code>r</code>
</td> <td>The random-access range to rearrange.</td>
</tr> <tr>
<td>E <code>pivot</code>
</td> <td>The pivot element.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A <a href="std_typecons#Tuple"><code>std.typecons.Tuple</code></a> of the three resulting ranges. These ranges are slices of the original range. </dd>
</dl> <dl>
<dt>Bugs:</dt>
<dd>stable <code>partition3</code> has not been implemented yet.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto a = [ 8, 3, 4, 1, 4, 7, 4 ];
auto pieces = partition3(a, 4);
writeln(pieces[0]); // [1, 3]
writeln(pieces[1]); // [4, 4, 4]
writeln(pieces[2]); // [8, 7]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="makeIndex">SortedRange!(RangeIndex, (a, b) =&gt; binaryFun!less(*a, *b)) <strong id="makeIndex">makeIndex</strong>(alias less = "a &lt; b", SwapStrategy ss = SwapStrategy.unstable, Range, RangeIndex)(Range r, RangeIndex index)<br><small>  Constraints: if (isForwardRange!Range &amp;&amp; isRandomAccessRange!RangeIndex &amp;&amp; is(ElementType!RangeIndex : ElementType!Range*) &amp;&amp; hasAssignableElements!RangeIndex); </small><br><br>void <strong id="makeIndex">makeIndex</strong>(alias less = "a &lt; b", SwapStrategy ss = SwapStrategy.unstable, Range, RangeIndex)(Range r, RangeIndex index)<br><small>  Constraints: if (isRandomAccessRange!Range &amp;&amp; !isInfinite!Range &amp;&amp; isRandomAccessRange!RangeIndex &amp;&amp; !isInfinite!RangeIndex &amp;&amp; isIntegral!(ElementType!RangeIndex) &amp;&amp; hasAssignableElements!RangeIndex); </small>
</dt> <dd>
<p>Computes an index for <code>r</code> based on the comparison <code>less</code>. The index is a sorted array of pointers or indices into the original range. This technique is similar to sorting, but it is more flexible because (1) it allows "sorting" of immutable collections, (2) allows binary search even if the original collection does not offer random access, (3) allows multiple indexes, each on a different predicate, and (4) may be faster when dealing with large objects. However, using an index may also be slower under certain circumstances due to the extra indirection, and is always larger than a sorting-based solution because it needs space for the index in addition to the original collection. The complexity is the same as <code>sort</code>'s. </p>
<p>The first overload of <code>makeIndex</code> writes to a range containing pointers, and the second writes to a range containing offsets. The first overload requires <code>Range</code> to be a <a href="std_range_primitives#isForwardRange">forward range</a>, and the latter requires it to be a random-access range. <br><br> <code>makeIndex</code> overwrites its second argument with the result, but never reallocates it. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>less</td> <td>The comparison to use.</td>
</tr> <tr>
<td>ss</td> <td>The swapping strategy.</td>
</tr> <tr>
<td>Range <code>r</code>
</td> <td>The range to index.</td>
</tr> <tr>
<td>RangeIndex <code>index</code>
</td> <td>The resulting index.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The pointer-based version returns a <code>SortedRange</code> wrapper over index, of type <code>SortedRange!(RangeIndex, (a, b) =&gt; binaryFun!less(*a, *b))</code> thus reflecting the ordering of the index. The index-based version returns <code>void</code> because the ordering relation involves not only <code>index</code> but also <code>r</code>. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>If the second argument's length is less than that of the range indexed, an exception is thrown.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">immutable(int[]) arr = [ 2, 3, 1, 5, 0 ];
// index using pointers
auto index1 = new immutable(int)*[arr.length];
makeIndex!("a &lt; b")(arr, index1);
assert(isSorted!("*a &lt; *b")(index1));
// index using offsets
auto index2 = new size_t[arr.length];
makeIndex!("a &lt; b")(arr, index2);
assert(isSorted!
    ((size_t a, size_t b){ return arr[a] &lt; arr[b];})
    (index2));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="merge">Merge!(less, Rs) <strong id="merge">merge</strong>(alias less = "a &lt; b", Rs...)(Rs rs)<br><small>  Constraints: if (Rs.length &gt;= 2 &amp;&amp; allSatisfy!(isInputRange, Rs) &amp;&amp; !is(CommonType!(staticMap!(ElementType, Rs)) == void)); </small>
</dt> <dd>
<p>Merge multiple sorted ranges <code>rs</code> with less-than predicate function <code>pred</code> into one single sorted output range containing the sorted union of the elements of inputs. Duplicates are not eliminated, meaning that the total number of elements in the output is the sum of all elements in the ranges passed to it; the <code>length</code> member is offered if all inputs also have <code>length</code>. The element types of all the inputs must have a common type <code>CommonType</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>less</td> <td>Predicate the given ranges are sorted by.</td>
</tr> <tr>
<td>Rs <code>rs</code>
</td> <td>The ranges to compute the union for.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A range containing the union of the given ranges. </dd>
</dl> <dl>
<dt>Details</dt>
<dd> All of its inputs are assumed to be sorted. This can mean that inputs are instances of <a href="std_range#SortedRange"><code>std.range.SortedRange</code></a>. Use the result of <a href="std_algorithm_sorting#sort"><code> std.algorithm.sorting.sort</code></a>, or <a href="std_range#assumeSorted"><code>std.range.assumeSorted</code></a> to merge ranges known to be sorted (show in the example below). Note that there is currently no way of ensuring that two or more instances of <a href="std_range#SortedRange"><code> std.range.SortedRange</code></a> are sorted using a specific comparison function <code>pred</code>. Therefore no checking is done here to assure that all inputs <code>rs</code> are instances of <a href="std_range#SortedRange"><code>std.range.SortedRange</code></a>. </dd>
</dl> This algorithm is lazy, doing work progressively as elements are pulled off the result.  Time complexity is proportional to the sum of element counts over all inputs.  If all inputs have the same element type and offer it by <code>ref</code>, output becomes a range with mutable <code>front</code> (and <code>back</code> where appropriate) that reflects in the original inputs.  If any of the inputs <code>rs</code> is infinite so is the result (<code>empty</code> being always <code>false</code>).  <dl>
<dt>See Also:</dt>
<dd>
<a href="std_algorithm_setops#multiwayMerge"><code>std.algorithm.setops.multiwayMerge</code></a> for an analogous function that merges a dynamic number of ranges.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.range : retro;

int[] a = [1, 3, 5];
int[] b = [2, 3, 4];

assert(a.merge(b).equal([1, 2, 3, 3, 4, 5]));
assert(a.merge(b).retro.equal([5, 4, 3, 3, 2, 1]));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>test bi-directional access and common type <pre data-language="d">import std.algorithm.comparison : equal;
import std.range : retro;
import std.traits : CommonType;

alias S = short;
alias I = int;
alias D = double;

S[] a = [1, 2, 3];
I[] b = [50, 60];
D[] c = [10, 20, 30, 40];

auto m = merge(a, b, c);

static assert(is(typeof(m.front) == CommonType!(S, I, D)));

assert(equal(m, [1, 2, 3, 10, 20, 30, 40, 50, 60]));
assert(equal(m.retro, [60, 50, 40, 30, 20, 10, 3, 2, 1]));

m.popFront();
assert(equal(m, [2, 3, 10, 20, 30, 40, 50, 60]));
m.popBack();
assert(equal(m, [2, 3, 10, 20, 30, 40, 50]));
m.popFront();
assert(equal(m, [3, 10, 20, 30, 40, 50]));
m.popBack();
assert(equal(m, [3, 10, 20, 30, 40]));
m.popFront();
assert(equal(m, [10, 20, 30, 40]));
m.popBack();
assert(equal(m, [10, 20, 30]));
m.popFront();
assert(equal(m, [20, 30]));
m.popBack();
assert(equal(m, [20]));
m.popFront();
assert(m.empty);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="multiSort">template <strong id="multiSort">multiSort</strong>(less...)</dt> <dd>
<p>Sorts a range by multiple keys. The call <code>multiSort!("a.id &lt; b.id", "a.date &gt; b.date")(r)</code> sorts the range <code>r</code> by <code>id</code> ascending, and sorts elements that have the same <code>id</code> by <code>date</code> descending. Such a call is equivalent to <code>sort!"a.id != b.id ? a.id &lt; b.id : a.date &gt; b.date"(r)</code>, but <code>multiSort</code> is faster because it does fewer comparisons (in addition to being more convenient). </p>
<dl>
<dt>Returns:</dt>
<dd>The initial range wrapped as a <code>SortedRange</code> with its predicates converted to an equivalent single predicate.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.mutation : SwapStrategy;
static struct Point { int x, y; }
auto pts1 = [ Point(0, 0), Point(5, 5), Point(0, 1), Point(0, 2) ];
auto pts2 = [ Point(0, 0), Point(0, 1), Point(0, 2), Point(5, 5) ];
multiSort!("a.x &lt; b.x", "a.y &lt; b.y", SwapStrategy.unstable)(pts1);
writeln(pts1); // pts2
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="sort">SortedRange!(Range, less) <strong id="sort">sort</strong>(alias less = "a &lt; b", SwapStrategy ss = SwapStrategy.unstable, Range)(Range r)<br><small>  Constraints: if ((ss == SwapStrategy.unstable &amp;&amp; (hasSwappableElements!Range || hasAssignableElements!Range) || ss != SwapStrategy.unstable &amp;&amp; hasAssignableElements!Range) &amp;&amp; isRandomAccessRange!Range &amp;&amp; hasSlicing!Range &amp;&amp; hasLength!Range); </small>
</dt> <dd>
<p>Sorts a random-access range according to the predicate <code>less</code>. Performs <span class="bigoh">Ο(<code>r.length * log(r.length)</code>)</span> evaluations of <code>less</code>. If <code>less</code> involves expensive computations on the sort key, it may be worthwhile to use <a href="#schwartzSort"><code>schwartzSort</code></a> instead. </p>
<p>Stable sorting requires <code>hasAssignableElements!Range</code> to be true. <br><br> <code>sort</code> returns a <a href="std_range#SortedRange"><code>std.range.SortedRange</code></a> over the original range, allowing functions that can take advantage of sorted data to know that the range is sorted and adjust accordingly. The <a href="std_range#SortedRange"><code>std.range.SortedRange</code></a> is a wrapper around the original range, so both it and the original range are sorted. Other functions can't know that the original range has been sorted, but they <i>can</i> know that <a href="std_range#SortedRange"><code>std.range.SortedRange</code></a> has been sorted. </p> <dl>
<dt>Preconditions</dt>
<dd> The predicate is expected to satisfy certain rules in order for <code>sort</code> to behave as expected - otherwise, the program may fail on certain inputs (but not others) when not compiled in release mode, due to the cursory <code>assumeSorted</code> check. Specifically, <code>sort</code> expects <code>less(a,b) &amp;&amp; less(b,c)</code> to imply <code>less(a,c)</code> (transitivity), and, conversely, <code>!less(a,b) &amp;&amp; !less(b,c)</code> to imply <code>!less(a,c)</code>. Note that the default predicate (<code>"a &lt; b"</code>) does not always satisfy these conditions for floating point types, because the expression will always be <code>false</code> when either <code>a</code> or <code>b</code> is NaN. Use <a href="std_math#cmp"><code>std.math.cmp</code></a> instead. </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>less</td> <td>The predicate to sort by.</td>
</tr> <tr>
<td>ss</td> <td>The swapping strategy to use.</td>
</tr> <tr>
<td>Range <code>r</code>
</td> <td>The range to sort.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The initial range wrapped as a <code>SortedRange</code> with the predicate <code>binaryFun!less</code>. </dd>
</dl> <dl>
<dt>Algorithms</dt>
<dd> <a href="http://en.wikipedia.org/wiki/Introsort">Introsort</a> is used for unstable sorting and <a href="http://en.wikipedia.org/wiki/Timsort">Timsort</a> is used for stable sorting. Each algorithm has benefits beyond stability. Introsort is generally faster but Timsort may achieve greater speeds on data with low entropy or if predicate calls are expensive. Introsort performs no allocations whereas Timsort will perform one or more allocations per call. Both algorithms have <span class="bigoh">Ο(<code>n log n</code>)</span> worst-case time complexity. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="std_range#assumeSorted"><code>std.range.assumeSorted</code></a><br> <a href="std_range#SortedRange"><code>std.range.SortedRange</code></a><br> <a href="std_algorithm_mutation#SwapStrategy"><code>std.algorithm.mutation.SwapStrategy</code></a><br> <a href="std_functional#binaryFun"><code>std.functional.binaryFun</code></a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int[] array = [ 1, 2, 3, 4 ];

// sort in descending order
array.sort!("a &gt; b");
writeln(array); // [4, 3, 2, 1]

// sort in ascending order
array.sort();
writeln(array); // [1, 2, 3, 4]

// sort with reusable comparator and chain
alias myComp = (x, y) =&gt; x &gt; y;
writeln(array.sort!(myComp).release); // [4, 3, 2, 1]
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">// Showcase stable sorting
import std.algorithm.mutation : SwapStrategy;
string[] words = [ "aBc", "a", "abc", "b", "ABC", "c" ];
sort!("toUpper(a) &lt; toUpper(b)", SwapStrategy.stable)(words);
writeln(words); // ["a", "aBc", "abc", "ABC", "b", "c"]
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">// Sorting floating-point numbers in presence of NaN
double[] numbers = [-0.0, 3.0, -2.0, double.nan, 0.0, -double.nan];

import std.algorithm.comparison : equal;
import std.math : cmp, isIdentical;

sort!((a, b) =&gt; cmp(a, b) &lt; 0)(numbers);

double[] sorted = [-double.nan, -2.0, -0.0, 0.0, 3.0, double.nan];
assert(numbers.equal!isIdentical(sorted));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="schwartzSort">SortedRange!(R, (a, b) =&gt; binaryFun!less(unaryFun!transform(a), unaryFun!transform(b))) <strong id="schwartzSort">schwartzSort</strong>(alias transform, alias less = "a &lt; b", SwapStrategy ss = SwapStrategy.unstable, R)(R r)<br><small>  Constraints: if (isRandomAccessRange!R &amp;&amp; hasLength!R &amp;&amp; hasSwappableElements!R &amp;&amp; !is(typeof(binaryFun!less) == SwapStrategy)); </small><br><br>auto <strong id="schwartzSort">schwartzSort</strong>(alias transform, SwapStrategy ss, R)(R r)<br><small>  Constraints: if (isRandomAccessRange!R &amp;&amp; hasLength!R &amp;&amp; hasSwappableElements!R); </small>
</dt> <dd>
<p>Alternative sorting method that should be used when comparing keys involves an expensive computation. Instead of using <code>less(a, b)</code> for comparing elements, <code>schwartzSort</code> uses <code>less(transform(a), transform(b))</code>. The values of the <code>transform</code> function are precomputed in a temporary array, thus saving on repeatedly computing it. Conversely, if the cost of <code>transform</code> is small compared to the cost of allocating and filling the precomputed array, <code>sort</code> may be faster and therefore preferable. </p>
<p>This approach to sorting is akin to the <a href="http://wikipedia.org/wiki/Schwartzian_transform">Schwartzian transform</a>, also known as the decorate-sort-undecorate pattern in Python and Lisp. The complexity is the same as that of the corresponding <code>sort</code>, but <code>schwartzSort</code> evaluates <code>transform</code> only <code>r.length</code> times (less than half when compared to regular sorting). The usage can be best illustrated with an example. </p> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">uint hashFun(string) { ... expensive computation ... }
string[] array = ...;
// Sort strings by hash, slow
sort!((a, b) =&gt; hashFun(a) &lt; hashFun(b))(array);
// Sort strings by hash, fast (only computes arr.length hashes):
schwartzSort!(hashFun, "a &lt; b")(array);
</pre>  The <code>schwartzSort</code> function might require less temporary data and be faster than the Perl idiom or the decorate-sort-undecorate idiom present in Python and Lisp. This is because sorting is done in-place and only minimal extra data (one array of transformed elements) is created.  To check whether an array was sorted and benefit of the speedup of Schwartz sorting, a function <code>schwartzIsSorted</code> is not provided because the effect can be achieved by calling <code>isSorted!less(map!transform(r))</code>.  <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>transform</td> <td>The transformation to apply.</td>
</tr> <tr>
<td>less</td> <td>The predicate to sort by.</td>
</tr> <tr>
<td>ss</td> <td>The swapping strategy to use.</td>
</tr> <tr>
<td>R <code>r</code>
</td> <td>The range to sort.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The initial range wrapped as a <code>SortedRange</code> with the predicate <code>(a, b) =&gt; binaryFun!less(transform(a), transform(b))</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.iteration : map;
import std.numeric : entropy;

auto lowEnt = [ 1.0, 0, 0 ],
     midEnt = [ 0.1, 0.1, 0.8 ],
    highEnt = [ 0.31, 0.29, 0.4 ];
auto arr = new double[][3];
arr[0] = midEnt;
arr[1] = lowEnt;
arr[2] = highEnt;

schwartzSort!(entropy, "a &gt; b")(arr);

writeln(arr[0]); // highEnt
writeln(arr[1]); // midEnt
writeln(arr[2]); // lowEnt
assert(isSorted!("a &gt; b")(map!(entropy)(arr)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="partialSort">void <strong id="partialSort">partialSort</strong>(alias less = "a &lt; b", SwapStrategy ss = SwapStrategy.unstable, Range)(Range r, size_t n)<br><small>  Constraints: if (isRandomAccessRange!Range &amp;&amp; hasLength!Range &amp;&amp; hasSlicing!Range); </small>
</dt> <dd>
<p>Reorders the random-access range <code>r</code> such that the range <code>r[0 .. mid]</code> is the same as if the entire <code>r</code> were sorted, and leaves the range <code>r[mid .. r.length]</code> in no particular order. Performs <span class="bigoh">Ο(<code>r.length * log(mid)</code>)</span> evaluations of <code>pred</code>. The implementation simply calls <code>topN!(less, ss)(r, n)</code> and then <code>sort!(less, ss)(r[0 .. n])</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>less</td> <td>The predicate to sort by.</td>
</tr> <tr>
<td>ss</td> <td>The swapping strategy to use.</td>
</tr> <tr>
<td>Range <code>r</code>
</td> <td>The random-access range to reorder.</td>
</tr> <tr>
<td>size_t <code>n</code>
</td> <td>The length of the initial segment of <code>r</code> to sort.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int[] a = [ 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 ];
partialSort(a, 5);
writeln(a[0 .. 5]); // [0, 1, 2, 3, 4]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="partialSort.2">void <strong id="partialSort">partialSort</strong>(alias less = "a &lt; b", SwapStrategy ss = SwapStrategy.unstable, Range1, Range2)(Range1 r1, Range2 r2)<br><small>  Constraints: if (isRandomAccessRange!Range1 &amp;&amp; hasLength!Range1 &amp;&amp; isInputRange!Range2 &amp;&amp; is(ElementType!Range1 == ElementType!Range2) &amp;&amp; hasLvalueElements!Range1 &amp;&amp; hasLvalueElements!Range2); </small>
</dt> <dd>
<p>Stores the smallest elements of the two ranges in the left-hand range in sorted order. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>less</td> <td>The predicate to sort by.</td>
</tr> <tr>
<td>ss</td> <td>The swapping strategy to use.</td>
</tr> <tr>
<td>Range1 <code>r1</code>
</td> <td>The first range.</td>
</tr> <tr>
<td>Range2 <code>r2</code>
</td> <td>The second range.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int[] a = [5, 7, 2, 6, 7];
int[] b = [2, 1, 5, 6, 7, 3, 0];

partialSort(a, b);
writeln(a); // [0, 1, 2, 2, 3]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="topN">auto <strong id="topN">topN</strong>(alias less = "a &lt; b", SwapStrategy ss = SwapStrategy.unstable, Range)(Range r, size_t nth)<br><small>  Constraints: if (isRandomAccessRange!Range &amp;&amp; hasLength!Range &amp;&amp; hasSlicing!Range &amp;&amp; hasAssignableElements!Range); </small>
</dt> <dd>
<p>Reorders the range <code>r</code> using <code>swap</code> such that <code>r[nth]</code> refers to the element that would fall there if the range were fully sorted. In addition, it also partitions <code>r</code> such that all elements <code>e1</code> from <code>r[0]</code> to <code>r[nth]</code> satisfy <code>!less(r[nth], e1)</code>, and all elements <code>e2</code> from <code>r[nth]</code> to <code>r[r.length]</code> satisfy <code>!less(e2, r[nth])</code>. Effectively, it finds the nth smallest (according to <code>less</code>) elements in <code>r</code>. Performs an expected <span class="bigoh">Ο(<code>r.length</code>)</span> (if unstable) or <span class="bigoh">Ο(<code>r.length * log(r.length)</code>)</span> (if stable) evaluations of <code>less</code> and <code>swap</code>. </p>
<p>If <code>n &gt;= r.length</code>, the algorithm has no effect and returns <code>r[0 .. r.length]</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>less</td> <td>The predicate to sort by.</td>
</tr> <tr>
<td>ss</td> <td>The swapping strategy to use.</td>
</tr> <tr>
<td>Range <code>r</code>
</td> <td>The random-access range to reorder.</td>
</tr> <tr>
<td>size_t <code>nth</code>
</td> <td>The index of the element that should be in sorted position after the function is done.</td>
</tr> </table></dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#topNIndex"><code>topNIndex</code></a>, </dd>
</dl> <dl>
<dt>Bugs:</dt>
<dd>Stable topN has not been implemented yet.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int[] v = [ 25, 7, 9, 2, 0, 5, 21 ];
topN!"a &lt; b"(v, 100);
writeln(v); // [25, 7, 9, 2, 0, 5, 21]
auto n = 4;
topN!((a, b) =&gt; a &lt; b)(v, n);
writeln(v[n]); // 9
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="topN.2">auto <strong id="topN">topN</strong>(alias less = "a &lt; b", SwapStrategy ss = SwapStrategy.unstable, Range1, Range2)(Range1 r1, Range2 r2)<br><small>  Constraints: if (isRandomAccessRange!Range1 &amp;&amp; hasLength!Range1 &amp;&amp; isInputRange!Range2 &amp;&amp; is(ElementType!Range1 == ElementType!Range2) &amp;&amp; hasLvalueElements!Range1 &amp;&amp; hasLvalueElements!Range2); </small>
</dt> <dd>
<p>Stores the smallest elements of the two ranges in the left-hand range. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>less</td> <td>The predicate to sort by.</td>
</tr> <tr>
<td>ss</td> <td>The swapping strategy to use.</td>
</tr> <tr>
<td>Range1 <code>r1</code>
</td> <td>The first range.</td>
</tr> <tr>
<td>Range2 <code>r2</code>
</td> <td>The second range.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int[] a = [ 5, 7, 2, 6, 7 ];
int[] b = [ 2, 1, 5, 6, 7, 3, 0 ];
topN(a, b);
sort(a);
writeln(a); // [0, 1, 2, 2, 3]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="topNCopy">TRange <strong id="topNCopy">topNCopy</strong>(alias less = "a &lt; b", SRange, TRange)(SRange source, TRange target, SortOutput sorted = No.sortOutput)<br><small>  Constraints: if (isInputRange!SRange &amp;&amp; isRandomAccessRange!TRange &amp;&amp; hasLength!TRange &amp;&amp; hasSlicing!TRange); </small>
</dt> <dd>
<p>Copies the top <code>n</code> elements of the <a href="std_range_primitives#isInputRange">input range</a> <code>source</code> into the random-access range <code>target</code>, where <code>n = target.length</code>. Elements of <code>source</code> are not touched. If <code>sorted</code> is <code>true</code>, the target is sorted. Otherwise, the target respects the <a href="http://en.wikipedia.org/wiki/Binary_heap">heap property</a>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>less</td> <td>The predicate to sort by.</td>
</tr> <tr>
<td>SRange <code>source</code>
</td> <td>The source range.</td>
</tr> <tr>
<td>TRange <code>target</code>
</td> <td>The target range.</td>
</tr> <tr>
<td>SortOutput <code>sorted</code>
</td> <td>Whether to sort the elements copied into <code>target</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The slice of <code>target</code> containing the copied elements.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.typecons : Yes;

int[] a = [ 10, 16, 2, 3, 1, 5, 0 ];
int[] b = new int[3];
topNCopy(a, b, Yes.sortOutput);
writeln(b); // [0, 1, 2]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="topNIndex">void <strong id="topNIndex">topNIndex</strong>(alias less = "a &lt; b", SwapStrategy ss = SwapStrategy.unstable, Range, RangeIndex)(Range r, RangeIndex index, SortOutput sorted = No.sortOutput)<br><small>  Constraints: if (isRandomAccessRange!Range &amp;&amp; isRandomAccessRange!RangeIndex &amp;&amp; hasAssignableElements!RangeIndex); </small>
</dt> <dd>
<p>Given a range of elements, constructs an index of its top <i>n</i> elements (i.e., the first <i>n</i> elements if the range were sorted). </p>
<p>Similar to <a href="#topN"><code>topN</code></a>, except that the range is not modified. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>less</td> <td>A binary predicate that defines the ordering of range elements. Defaults to <code>a &lt; b</code>.</td>
</tr> <tr>
<td>ss</td> <td>
<span class="red">(Not implemented yet.)</span> Specify the swapping strategy.</td>
</tr> <tr>
<td>Range <code>r</code>
</td> <td>A <a href="std_range_primitives#isRandomAccessRange">random-access range</a> of elements to make an index for.</td>
</tr> <tr>
<td>RangeIndex <code>index</code>
</td> <td>A <a href="std_range_primitives#isRandomAccessRange">random-access range</a> with assignable elements to build the index in. The length of this range determines how many top elements to index in <code>r</code>.  This index range can either have integral elements, in which case the constructed index will consist of zero-based numerical indices into <code>r</code>; or it can have pointers to the element type of <code>r</code>, in which case the constructed index will be pointers to the top elements in <code>r</code>.</td>
</tr> <tr>
<td>SortOutput <code>sorted</code>
</td> <td>Determines whether to sort the index by the elements they refer to.</td>
</tr> </table></dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#topN"><code>topN</code></a>, <a href="#topNCopy"><code>topNCopy</code></a>. </dd>
</dl> <dl>
<dt>Bugs:</dt>
<dd>The swapping strategy parameter is not implemented yet; currently it is ignored.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.typecons : Yes;

// Construct index to top 3 elements using numerical indices:
int[] a = [ 10, 2, 7, 5, 8, 1 ];
int[] index = new int[3];
topNIndex(a, index, Yes.sortOutput);
assert(index == [5, 1, 3]); // because a[5]==1, a[1]==2, a[3]==5

// Construct index to top 3 elements using pointer indices:
int*[] ptrIndex = new int*[3];
topNIndex(a, ptrIndex, Yes.sortOutput);
writeln(ptrIndex); // [&amp;a[5], &amp;a[1], &amp;a[3]]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="nextPermutation">bool <strong id="nextPermutation">nextPermutation</strong>(alias less = "a &lt; b", BidirectionalRange)(BidirectionalRange range)<br><small>  Constraints: if (isBidirectionalRange!BidirectionalRange &amp;&amp; hasSwappableElements!BidirectionalRange); </small>
</dt> <dd>
<p>Permutes <code>range</code> in-place to the next lexicographically greater permutation. </p>
<p> The predicate <code>less</code> defines the lexicographical ordering to be used on the range. <br><br> If the range is currently the lexicographically greatest permutation, it is permuted back to the least permutation and false is returned. Otherwise, true is returned. One can thus generate all permutations of a range by sorting it according to <code>less</code>, which produces the lexicographically least permutation, and then calling nextPermutation until it returns false. This is guaranteed to generate all distinct permutations of the range exactly once. If there are <i>N</i> elements in the range and all of them are unique, then <i>N</i>! permutations will be generated. Otherwise, if there are some duplicated elements, fewer permutations will be produced. </p>
<pre data-language="d">// Enumerate all permutations
int[] a = [1,2,3,4,5];
do
{
    // use the current permutation and
    // proceed to the next permutation of the array.
} while (nextPermutation(a));
</pre>  <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>less</td> <td>The ordering to be used to determine lexicographical ordering of the permutations.</td>
</tr> <tr>
<td>BidirectionalRange <code>range</code>
</td> <td>The range to permute.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>false if the range was lexicographically the greatest, in which case the range is reversed back to the lexicographically smallest permutation; otherwise returns true. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="std_algorithm_iteration#permutations"><code>std.algorithm.iteration.permutations</code></a>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">// Step through all permutations of a sorted array in lexicographic order
int[] a = [1,2,3];
writeln(nextPermutation(a)); // true
writeln(a); // [1, 3, 2]
writeln(nextPermutation(a)); // true
writeln(a); // [2, 1, 3]
writeln(nextPermutation(a)); // true
writeln(a); // [2, 3, 1]
writeln(nextPermutation(a)); // true
writeln(a); // [3, 1, 2]
writeln(nextPermutation(a)); // true
writeln(a); // [3, 2, 1]
writeln(nextPermutation(a)); // false
writeln(a); // [1, 2, 3]
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">// Step through permutations of an array containing duplicate elements:
int[] a = [1,1,2];
writeln(nextPermutation(a)); // true
writeln(a); // [1, 2, 1]
writeln(nextPermutation(a)); // true
writeln(a); // [2, 1, 1]
writeln(nextPermutation(a)); // false
writeln(a); // [1, 1, 2]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="nextEvenPermutation">bool <strong id="nextEvenPermutation">nextEvenPermutation</strong>(alias less = "a &lt; b", BidirectionalRange)(BidirectionalRange range)<br><small>  Constraints: if (isBidirectionalRange!BidirectionalRange &amp;&amp; hasSwappableElements!BidirectionalRange); </small>
</dt> <dd>
<p>Permutes <code>range</code> in-place to the next lexicographically greater <i>even</i> permutation. </p>
<p> The predicate <code>less</code> defines the lexicographical ordering to be used on the range. <br><br> An even permutation is one which is produced by swapping an even number of pairs of elements in the original range. The set of <i>even</i> permutations is distinct from the set of <i>all</i> permutations only when there are no duplicate elements in the range. If the range has <i>N</i> unique elements, then there are exactly <i>N</i>!/2 even permutations. <br><br> If the range is already the lexicographically greatest even permutation, it is permuted back to the least even permutation and false is returned. Otherwise, true is returned, and the range is modified in-place to be the lexicographically next even permutation. <br><br> One can thus generate the even permutations of a range with unique elements by starting with the lexicographically smallest permutation, and repeatedly calling nextEvenPermutation until it returns false. </p>
<pre data-language="d">// Enumerate even permutations
int[] a = [1,2,3,4,5];
do
{
    // use the current permutation and
    // proceed to the next even permutation of the array.
} while (nextEvenPermutation(a));
</pre> One can also generate the <i>odd</i> permutations of a range by noting that permutations obey the rule that even + even = even, and odd + even = odd. Thus, by swapping the last two elements of a lexicographically least range, it is turned into the first odd permutation. Then calling nextEvenPermutation on this first odd permutation will generate the next even permutation relative to this odd permutation, which is actually the next odd permutation of the original range. Thus, by repeatedly calling nextEvenPermutation until it returns false, one enumerates the odd permutations of the original range. <pre data-language="d">// Enumerate odd permutations
int[] a = [1,2,3,4,5];
swap(a[$-2], a[$-1]);    // a is now the first odd permutation of [1,2,3,4,5]
do
{
    // use the current permutation and
    // proceed to the next odd permutation of the original array
    // (which is an even permutation of the first odd permutation).
} while (nextEvenPermutation(a));
</pre>  <dl>
<dt>Warning</dt>
<dd> Since even permutations are only distinct from all permutations when the range elements are unique, this function assumes that there are no duplicate elements under the specified ordering. If this is not true, some permutations may fail to be generated. When the range has non-unique elements, you should use <a href="#nextPermutation"><em class="tt">nextPermutation</em></a> instead. </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>less</td> <td>The ordering to be used to determine lexicographical ordering of the permutations.</td>
</tr> <tr>
<td>BidirectionalRange <code>range</code>
</td> <td>The range to permute.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>false if the range was lexicographically the greatest, in which case the range is reversed back to the lexicographically smallest permutation; otherwise returns true.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">// Step through even permutations of a sorted array in lexicographic order
int[] a = [1,2,3];
writeln(nextEvenPermutation(a)); // true
writeln(a); // [2, 3, 1]
writeln(nextEvenPermutation(a)); // true
writeln(a); // [3, 1, 2]
writeln(nextEvenPermutation(a)); // false
writeln(a); // [1, 2, 3]
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Even permutations are useful for generating coordinates of certain geometric shapes. Here's a non-trivial example: <pre data-language="d">import std.math : sqrt;

// Print the 60 vertices of a uniform truncated icosahedron (soccer ball)
enum real Phi = (1.0 + sqrt(5.0)) / 2.0;    // Golden ratio
real[][] seeds = [
    [0.0, 1.0, 3.0*Phi],
    [1.0, 2.0+Phi, 2.0*Phi],
    [Phi, 2.0, Phi^^3]
];
size_t n;
foreach (seed; seeds)
{
    // Loop over even permutations of each seed
    do
    {
        // Loop over all sign changes of each permutation
        size_t i;
        do
        {
            // Generate all possible sign changes
            for (i=0; i &lt; seed.length; i++)
            {
                if (seed[i] != 0.0)
                {
                    seed[i] = -seed[i];
                    if (seed[i] &lt; 0.0)
                        break;
                }
            }
            n++;
        } while (i &lt; seed.length);
    } while (nextEvenPermutation(seed));
}
writeln(n); // 60
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="nthPermutation">ref Range <strong id="nthPermutation">nthPermutation</strong>(Range)(auto ref Range range, const ulong perm)<br><small>  Constraints: if (isRandomAccessRange!Range &amp;&amp; hasLength!Range); </small>
</dt> <dd>
<p>Permutes <code>range</code> into the <code>perm</code> permutation. The algorithm has a constant runtime complexity with respect to the number of permutations created. Due to the number of unique values of <code>ulong</code> only the first 21 elements of <code>range</code> can be permuted. The rest of the range will therefore not be permuted. This algorithm uses the <a href="http://en.wikipedia.org/wiki/Lehmer_code">Lehmer Code</a>. </p>
<p>The algorithm works as follows: </p>
<pre data-language="d">    auto pem = [4,0,4,1,0,0,0]; // permutation 2982 in factorial
    auto src = [0,1,2,3,4,5,6]; // the range to permutate


    auto i = 0;                    // range index
    // range index iterates pem and src in sync
    // pem[i] + i is used as index into src
    // first src[pem[i] + i] is stored in t
    auto t = 4;                    // tmp value
    src = [0,1,2,3,n,5,6];


    // then the values between i and pem[i] + i are moved one
    // to the right
    src = [n,0,1,2,3,5,6];
    // at last t is inserted into position i
    src = [4,0,1,2,3,5,6];
    // finally i is incremented
    ++i;


    // this process is repeated while i &lt; pem.length


    t = 0;
    src = [4,n,1,2,3,5,6];
    src = [4,0,1,2,3,5,6];
    ++i;
    t = 6;
    src = [4,0,1,2,3,5,n];
    src = [4,0,n,1,2,3,5];
    src = [4,0,6,1,2,3,5];
</pre>  <dl>
<dt>Returns:</dt>
<dd>The permuted range. </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>range</code>
</td> <td>The Range to permute. The original ordering will be lost.</td>
</tr> <tr>
<td>ulong <code>perm</code>
</td> <td>The permutation to permutate <code>range</code> to.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto src = [0, 1, 2, 3, 4, 5, 6];
auto rslt = [4, 0, 6, 2, 1, 3, 5];

src = nthPermutation(src, 2982);
writeln(src); // rslt
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="nthPermutationImpl">bool <strong id="nthPermutationImpl">nthPermutationImpl</strong>(Range)(auto ref Range range, ulong perm)<br><small>  Constraints: if (isRandomAccessRange!Range &amp;&amp; hasLength!Range); </small>
</dt> <dd>
<dl>
<dt>Returns:</dt>
<dd>
<code>true</code> in case the permutation worked, <code>false</code> in case <code>perm</code> had more digits in the factorial number system than range had elements. This case must not occur as this would lead to out of range accesses.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto src = [0, 1, 2, 3, 4, 5, 6];
auto rslt = [4, 0, 6, 2, 1, 3, 5];

bool worked = nthPermutationImpl(src, 2982);
assert(worked);
writeln(src); // rslt
</pre> </dd>
</dl> </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2019 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_algorithm_sorting.html" class="_attribution-link">https://dlang.org/phobos/std_algorithm_sorting.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
