
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>std.algorithm.mutation - D - W3cubDocs</title>
  
  <meta name="description" content=" This is a submodule of std.algorithm. It contains generic mutation algorithms. ">
  <meta name="keywords" content="std, algorithm, mutation, d">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/d/std_algorithm_mutation.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/d.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/d/" class="_nav-link" title="" style="margin-left:0;">D</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _d">
				
				
<h1>std.algorithm.mutation</h1>  <p>This is a submodule of <a href="std_algorithm"><code>std.algorithm</code></a>. It contains generic mutation algorithms. </p>
<p> </p>
<table>
<caption>Cheat Sheet</caption>
<tr>
<th scope="col">Function Name</th> <th scope="col">Description</th>
</tr> <tr>
<td><a href="#bringToFront"><code>bringToFront</code></a></td> <td> If <code>a = [1, 2, 3]</code> and <code>b = [4, 5, 6, 7]</code>, <code>bringToFront(a, b)</code> leaves <code>a = [4, 5, 6]</code> and <code>b = [7, 1, 2, 3]</code>.</td>
</tr> <tr>
<td><a href="#copy"><code>copy</code></a></td> <td> Copies a range to another. If <code>a = [1, 2, 3]</code> and <code>b = new int[5]</code>, then <code>copy(a, b)</code> leaves <code>b = [1, 2, 3, 0, 0]</code> and returns <code>b[3 .. $]</code>.</td>
</tr> <tr>
<td><a href="#fill"><code>fill</code></a></td> <td> Fills a range with a pattern, e.g., if <code>a = new int[3]</code>, then <code>fill(a, 4)</code> leaves <code>a = [4, 4, 4]</code> and <code>fill(a, [3, 4])</code> leaves <code>a = [3, 4, 3]</code>.</td>
</tr> <tr>
<td><a href="#initializeAll"><code>initializeAll</code></a></td> <td> If <code>a = [1.2, 3.4]</code>, then <code>initializeAll(a)</code> leaves <code>a = [double.init, double.init]</code>.</td>
</tr> <tr>
<td><a href="#move"><code>move</code></a></td> <td> <code>move(a, b)</code> moves <code>a</code> into <code>b</code>. <code>move(a)</code> reads <code>a</code> destructively when necessary.</td>
</tr> <tr>
<td><a href="#moveEmplace"><code>moveEmplace</code></a></td> <td> Similar to <code>move</code> but assumes <code>target</code> is uninitialized.</td>
</tr> <tr>
<td><a href="#moveAll"><code>moveAll</code></a></td> <td> Moves all elements from one range to another.</td>
</tr> <tr>
<td><a href="#moveEmplaceAll"><code>moveEmplaceAll</code></a></td> <td> Similar to <code>moveAll</code> but assumes all elements in <code>target</code> are uninitialized.</td>
</tr> <tr>
<td><a href="#moveSome"><code>moveSome</code></a></td> <td> Moves as many elements as possible from one range to another.</td>
</tr> <tr>
<td><a href="#moveEmplaceSome"><code>moveEmplaceSome</code></a></td> <td> Similar to <code>moveSome</code> but assumes all elements in <code>target</code> are uninitialized.</td>
</tr> <tr>
<td><a href="#remove"><code>remove</code></a></td> <td> Removes elements from a range in-place, and returns the shortened range.</td>
</tr> <tr>
<td><a href="#reverse"><code>reverse</code></a></td> <td> If <code>a = [1, 2, 3]</code>, <code>reverse(a)</code> changes it to <code>[3, 2, 1]</code>.</td>
</tr> <tr>
<td><a href="#strip"><code>strip</code></a></td> <td> Strips all leading and trailing elements equal to a value, or that satisfy a predicate. If <code>a = [1, 1, 0, 1, 1]</code>, then <code>strip(a, 1)</code> and <code>strip!(e =&gt; e == 1)(a)</code> returns <code>[0]</code>.</td>
</tr> <tr>
<td><a href="#stripLeft"><code>stripLeft</code></a></td> <td> Strips all leading elements equal to a value, or that satisfy a predicate. If <code>a = [1, 1, 0, 1, 1]</code>, then <code>stripLeft(a, 1)</code> and <code>stripLeft!(e =&gt; e == 1)(a)</code> returns <code>[0, 1, 1]</code>.</td>
</tr> <tr>
<td><a href="#stripRight"><code>stripRight</code></a></td> <td> Strips all trailing elements equal to a value, or that satisfy a predicate. If <code>a = [1, 1, 0, 1, 1]</code>, then <code>stripRight(a, 1)</code> and <code>stripRight!(e =&gt; e == 1)(a)</code> returns <code>[1, 1, 0]</code>.</td>
</tr> <tr>
<td><a href="#swap"><code>swap</code></a></td> <td> Swaps two values.</td>
</tr> <tr>
<td><a href="#swapAt"><code>swapAt</code></a></td> <td> Swaps two values by indices.</td>
</tr> <tr>
<td><a href="#swapRanges"><code>swapRanges</code></a></td> <td> Swaps all elements of two ranges.</td>
</tr> <tr>
<td><a href="#uninitializedFill"><code>uninitializedFill</code></a></td> <td> Fills a range (assumed uninitialized) with a value.</td>
</tr> </table>  <dl>
<dt>License:</dt>
<dd>
<a href="http://boost.org/LICENSE_1_0.txt">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>
<a href="http://erdani.com">Andrei Alexandrescu</a> </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/algorithm/mutation.d">std/algorithm/mutation.d</a></span> </dd>
</dl> <dl>
<dt class="d_decl" id="bringToFront">size_t <strong id="bringToFront">bringToFront</strong>(InputRange, ForwardRange)(InputRange front, ForwardRange back)<br><small>  Constraints: if (isInputRange!InputRange &amp;&amp; isForwardRange!ForwardRange); </small>
</dt> <dd>
<p><code>bringToFront</code> takes two ranges <code>front</code> and <code>back</code>, which may be of different types. Considering the concatenation of <code>front</code> and <code>back</code> one unified range, <code>bringToFront</code> rotates that unified range such that all elements in <code>back</code> are brought to the beginning of the unified range. The relative ordering of elements in <code>front</code> and <code>back</code>, respectively, remains unchanged. </p>
<p>The <code>bringToFront</code> function treats strings at the code unit level and it is not concerned with Unicode character integrity. <code>bringToFront</code> is designed as a function for moving elements in ranges, not as a string function. <br><br> Performs <span class="bigoh">Ο(<code>max(front.length, back.length)</code>)</span> evaluations of <code>swap</code>. <br><br> The <code>bringToFront</code> function can rotate elements in one buffer left or right, swap buffers of equal length, and even move elements across disjoint buffers of different types and different lengths. </p> <dl>
<dt>Preconditions</dt>
<dd> Either <code>front</code> and <code>back</code> are disjoint, or <code>back</code> is reachable from <code>front</code> and <code>front</code> is not reachable from <code>back</code>. </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>InputRange <code>front</code>
</td> <td>an <a href="std_range_primitives#isInputRange">input range</a>
</td>
</tr> <tr>
<td>ForwardRange <code>back</code>
</td> <td>a <a href="std_range_primitives#isForwardRange">forward range</a>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The number of elements brought to the front, i.e., the length of <code>back</code>. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="http://en.cppreference.com/w/cpp/algorithm/rotate">STL's <code>rotate</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>The simplest use of <code>bringToFront</code> is for rotating elements in a buffer. For example: <pre data-language="d">auto arr = [4, 5, 6, 7, 1, 2, 3];
auto p = bringToFront(arr[0 .. 4], arr[4 .. $]);
writeln(p); // arr.length - 4
writeln(arr); // [1, 2, 3, 4, 5, 6, 7]
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>The <code>front</code> range may actually "step over" the <code>back</code> range. This is very useful with forward ranges that cannot compute comfortably right-bounded subranges like <code>arr[0 .. 4]</code> above. In the example below, <code>r2</code> is a right subrange of <code>r1</code>. <pre data-language="d">import std.algorithm.comparison : equal;
import std.container : SList;
import std.range.primitives : popFrontN;

auto list = SList!(int)(4, 5, 6, 7, 1, 2, 3);
auto r1 = list[];
auto r2 = list[]; popFrontN(r2, 4);
assert(equal(r2, [ 1, 2, 3 ]));
bringToFront(r1, r2);
assert(equal(list[], [ 1, 2, 3, 4, 5, 6, 7 ]));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Elements can be swapped across ranges of different types: <pre data-language="d">import std.algorithm.comparison : equal;
import std.container : SList;

auto list = SList!(int)(4, 5, 6, 7);
auto vec = [ 1, 2, 3 ];
bringToFront(list[], vec);
assert(equal(list[], [ 1, 2, 3, 4 ]));
assert(equal(vec, [ 5, 6, 7 ]));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Unicode integrity is not preserved: <pre data-language="d">import std.string : representation;
auto ar = representation("a".dup);
auto br = representation("ç".dup);

bringToFront(ar, br);

auto a = cast(char[]) ar;
auto b = cast(char[]) br;

// Illegal UTF-8
writeln(a); // "\303"
// Illegal UTF-8
writeln(b); // "\247a"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="copy">TargetRange <strong id="copy">copy</strong>(SourceRange, TargetRange)(SourceRange source, TargetRange target)<br><small>  Constraints: if (isInputRange!SourceRange &amp;&amp; isOutputRange!(TargetRange, ElementType!SourceRange)); </small>
</dt> <dd>
<p>Copies the content of <code>source</code> into <code>target</code> and returns the remaining (unfilled) part of <code>target</code>. </p>
<dl>
<dt>Preconditions</dt>
<dd> <code>target</code> shall have enough room to accommodate the entirety of <code>source</code>. </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>SourceRange <code>source</code>
</td> <td>an <a href="std_range_primitives#isInputRange">input range</a>
</td>
</tr> <tr>
<td>TargetRange <code>target</code>
</td> <td>an output range</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The unfilled part of target</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int[] a = [ 1, 5 ];
int[] b = [ 9, 8 ];
int[] buf = new int[](a.length + b.length + 10);
auto rem = a.copy(buf);    // copy a into buf
rem = b.copy(rem);         // copy b into remainder of buf
writeln(buf[0 .. a.length + b.length]); // [1, 5, 9, 8]
assert(rem.length == 10);   // unused slots in buf
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>As long as the target range elements support assignment from source range elements, different types of ranges are accepted: <pre data-language="d">float[] src = [ 1.0f, 5 ];
double[] dest = new double[src.length];
src.copy(dest);
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>To copy at most <code>n</code> elements from a range, you may want to use <a href="std_range#take"><code>std.range.take</code></a>: <pre data-language="d">import std.range;
int[] src = [ 1, 5, 8, 9, 10 ];
auto dest = new int[](3);
src.take(dest.length).copy(dest);
writeln(dest); // [1, 5, 8]
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>To copy just those elements from a range that satisfy a predicate, use <a href="#filter"><code>filter</code></a>: <pre data-language="d">import std.algorithm.iteration : filter;
int[] src = [ 1, 5, 8, 9, 10, 1, 2, 0 ];
auto dest = new int[src.length];
auto rem = src
    .filter!(a =&gt; (a &amp; 1) == 1)
    .copy(dest);
writeln(dest[0 .. $ - rem.length]); // [1, 5, 9, 1]
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<a href="std_range#retro"><code>std.range.retro</code></a> can be used to achieve behavior similar to <a href="http://en.cppreference.com/w/cpp/algorithm/copy_backward">STL's <code>copy_backward</code>'</a>: <pre data-language="d">import std.algorithm, std.range;
int[] src = [1, 2, 4];
int[] dest = [0, 0, 0, 0, 0];
src.retro.copy(dest.retro);
writeln(dest); // [0, 0, 1, 2, 4]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="fill">void <strong id="fill">fill</strong>(Range, Value)(auto ref Range range, auto ref Value value)<br><small>  Constraints: if (isInputRange!Range &amp;&amp; is(typeof(range.front = value)) || isSomeChar!Value &amp;&amp; is(typeof(range[] = value))); </small><br><br>void <strong id="fill">fill</strong>(InputRange, ForwardRange)(InputRange range, ForwardRange filler)<br><small>  Constraints: if (isInputRange!InputRange &amp;&amp; (isForwardRange!ForwardRange || isInputRange!ForwardRange &amp;&amp; isInfinite!ForwardRange) &amp;&amp; is(typeof(InputRange.init.front = ForwardRange.init.front))); </small>
</dt> <dd>
<p>Assigns <code>value</code> to each element of input range <code>range</code>. </p>
<p>Alternatively, instead of using a single <code>value</code> to fill the <code>range</code>, a <code>filter</code> <a href="std_range_primitives#isForwardRange">forward range</a> can be provided. The length of <code>filler</code> and <code>range</code> do not need to match, but <code>filler</code> must not be empty. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>range</code>
</td> <td>An <a href="std_range_primitives#isInputRange">input range</a> that exposes references to its elements and has assignable elements</td>
</tr> <tr>
<td>Value <code>value</code>
</td> <td>Assigned to each element of range</td>
</tr> <tr>
<td>ForwardRange <code>filler</code>
</td> <td>A <a href="std_range_primitives#isForwardRange">forward range</a> representing the fill pattern.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>If <code>filler</code> is empty. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#uninitializedFill"><code>uninitializedFill</code></a> <a href="#initializeAll"><code>initializeAll</code></a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int[] a = [ 1, 2, 3, 4 ];
fill(a, 5);
writeln(a); // [5, 5, 5, 5]
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int[] a = [ 1, 2, 3, 4, 5 ];
int[] b = [ 8, 9 ];
fill(a, b);
writeln(a); // [8, 9, 8, 9, 8]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="initializeAll">void <strong id="initializeAll">initializeAll</strong>(Range)(Range range)<br><small>  Constraints: if (isInputRange!Range &amp;&amp; hasLvalueElements!Range &amp;&amp; hasAssignableElements!Range); </small><br><br>void <strong id="initializeAll">initializeAll</strong>(Range)(Range range)<br><small>  Constraints: if (is(Range == char[]) || is(Range == wchar[])); </small>
</dt> <dd>
<p>Initializes all elements of <code>range</code> with their <code>.init</code> value. Assumes that the elements of the range are uninitialized. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>range</code>
</td> <td>An <a href="std_range_primitives#isInputRange">input range</a> that exposes references to its elements and has assignable elements</td>
</tr> </table></dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#fill"><code>fill</code></a> <a href="#uninitializeFill"><code>uninitializeFill</code></a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import core.stdc.stdlib : malloc, free;

struct S
{
    int a = 10;
}

auto s = (cast(S*) malloc(5 * S.sizeof))[0 .. 5];
initializeAll(s);
writeln(s); // [S(10), S(10), S(10), S(10), S(10)]

scope(exit) free(s.ptr);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="move">void <strong id="move">move</strong>(T)(ref T source, ref T target); <br><br>T <strong id="move">move</strong>(T)(return ref scope T source); </dt> <dd>
<p>Moves <code>source</code> into <code>target</code>, via a destructive copy when necessary. </p>
<p>If <code>T</code> is a struct with a destructor or postblit defined, source is reset to its <code>.init</code> value after it is moved into target, otherwise it is left unchanged. </p> <dl>
<dt>Preconditions</dt>
<dd> If source has internal pointers that point to itself and doesn't define opPostMove, it cannot be moved, and will trigger an assertion failure. </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>source</code>
</td> <td>Data to copy.</td>
</tr> <tr>
<td>T <code>target</code>
</td> <td>Where to copy into. The destructor, if any, is invoked before the copy is performed.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>For non-struct types, <code>move</code> just performs <code>target = source</code>: <pre data-language="d">Object obj1 = new Object;
Object obj2 = obj1;
Object obj3;

move(obj2, obj3);
assert(obj3 is obj1);
// obj2 unchanged
assert(obj2 is obj1);
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">// Structs without destructors are simply copied
struct S1
{
    int a = 1;
    int b = 2;
}
S1 s11 = { 10, 11 };
S1 s12;

move(s11, s12);

writeln(s12); // S1(10, 11)
writeln(s11); // s12

// But structs with destructors or postblits are reset to their .init value
// after copying to the target.
struct S2
{
    int a = 1;
    int b = 2;

    ~this() pure nothrow @safe @nogc { }
}
S2 s21 = { 3, 4 };
S2 s22;

move(s21, s22);

writeln(s21); // S2(1, 2)
writeln(s22); // S2(3, 4)
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Non-copyable structs can still be moved: <pre data-language="d">struct S
{
    int a = 1;
    @disable this(this);
    ~this() pure nothrow @safe @nogc {}
}
S s1;
s1.a = 2;
S s2 = move(s1);
writeln(s1.a); // 1
writeln(s2.a); // 2
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<code>opPostMove</code> will be called if defined: <pre data-language="d">struct S
{
    int a;
    void opPostMove(const ref S old)
    {
        writeln(a); // old.a
        a++;
    }
}
S s1;
s1.a = 41;
S s2 = move(s1);
writeln(s2.a); // 42
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="moveEmplace">pure @system void <strong id="moveEmplace">moveEmplace</strong>(T)(ref T source, ref T target); </dt> <dd>
<p>Similar to <a href="#move"><code>move</code></a> but assumes <code>target</code> is uninitialized. This is more efficient because <code>source</code> can be blitted over <code>target</code> without destroying or initializing it first. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>source</code>
</td> <td>value to be moved into target</td>
</tr> <tr>
<td>T <code>target</code>
</td> <td>uninitialized value to be filled by source</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static struct Foo
{
pure nothrow @nogc:
    this(int* ptr) { _ptr = ptr; }
    ~this() { if (_ptr) ++*_ptr; }
    int* _ptr;
}

int val;
Foo foo1 = void; // uninitialized
auto foo2 = Foo(&amp;val); // initialized
assert(foo2._ptr is &amp;val);

// Using `move(foo2, foo1)` would have an undefined effect because it would destroy
// the uninitialized foo1.
// moveEmplace directly overwrites foo1 without destroying or initializing it first.
moveEmplace(foo2, foo1);
assert(foo1._ptr is &amp;val);
assert(foo2._ptr is null);
writeln(val); // 0
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="moveAll">InputRange2 <strong id="moveAll">moveAll</strong>(InputRange1, InputRange2)(InputRange1 src, InputRange2 tgt)<br><small>  Constraints: if (isInputRange!InputRange1 &amp;&amp; isInputRange!InputRange2 &amp;&amp; is(typeof(move(src.front, tgt.front)))); </small>
</dt> <dd>
<p>Calls <code>move(a, b)</code> for each element <code>a</code> in <code>src</code> and the corresponding element <code>b</code> in <code>tgt</code>, in increasing order. </p>
<dl>
<dt>Preconditions</dt>
<dd> <code>walkLength(src) &lt;= walkLength(tgt)</code>. This precondition will be asserted. If you cannot ensure there is enough room in <code>tgt</code> to accommodate all of <code>src</code> use <a href="#moveSome"><code>moveSome</code></a> instead. </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>InputRange1 <code>src</code>
</td> <td>An <a href="std_range_primitives#isInputRange">input range</a> with movable elements.</td>
</tr> <tr>
<td>InputRange2 <code>tgt</code>
</td> <td>An <a href="std_range_primitives#isInputRange">input range</a> with elements that elements from <code>src</code> can be moved into.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The leftover portion of <code>tgt</code> after all elements from <code>src</code> have been moved.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int[3] a = [ 1, 2, 3 ];
int[5] b;
assert(moveAll(a[], b[]) is b[3 .. $]);
writeln(a[]); // b[0 .. 3]
int[3] cmp = [ 1, 2, 3 ];
writeln(a[]); // cmp[]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="moveEmplaceAll">@system InputRange2 <strong id="moveEmplaceAll">moveEmplaceAll</strong>(InputRange1, InputRange2)(InputRange1 src, InputRange2 tgt)<br><small>  Constraints: if (isInputRange!InputRange1 &amp;&amp; isInputRange!InputRange2 &amp;&amp; is(typeof(moveEmplace(src.front, tgt.front)))); </small>
</dt> <dd>
<p>Similar to <a href="#moveAll"><code>moveAll</code></a> but assumes all elements in <code>tgt</code> are uninitialized. Uses <a href="#moveEmplace"><code>moveEmplace</code></a> to move elements from <code>src</code> over elements from <code>tgt</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static struct Foo
{
    ~this() pure nothrow @nogc { if (_ptr) ++*_ptr; }
    int* _ptr;
}
int[3] refs = [0, 1, 2];
Foo[3] src = [Foo(&amp;refs[0]), Foo(&amp;refs[1]), Foo(&amp;refs[2])];
Foo[5] dst = void;

auto tail = moveEmplaceAll(src[], dst[]); // move 3 value from src over dst
assert(tail.length == 2); // returns remaining uninitialized values
initializeAll(tail);

import std.algorithm.searching : all;
assert(src[].all!(e =&gt; e._ptr is null));
assert(dst[0 .. 3].all!(e =&gt; e._ptr !is null));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="moveSome">Tuple!(InputRange1, InputRange2) <strong id="moveSome">moveSome</strong>(InputRange1, InputRange2)(InputRange1 src, InputRange2 tgt)<br><small>  Constraints: if (isInputRange!InputRange1 &amp;&amp; isInputRange!InputRange2 &amp;&amp; is(typeof(move(src.front, tgt.front)))); </small>
</dt> <dd>
<p>Calls <code>move(a, b)</code> for each element <code>a</code> in <code>src</code> and the corresponding element <code>b</code> in <code>tgt</code>, in increasing order, stopping when either range has been exhausted. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>InputRange1 <code>src</code>
</td> <td>An <a href="std_range_primitives#isInputRange">input range</a> with movable elements.</td>
</tr> <tr>
<td>InputRange2 <code>tgt</code>
</td> <td>An <a href="std_range_primitives#isInputRange">input range</a> with elements that elements from <code>src</code> can be moved into.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The leftover portions of the two ranges after one or the other of the ranges have been exhausted.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int[5] a = [ 1, 2, 3, 4, 5 ];
int[3] b;
assert(moveSome(a[], b[])[0] is a[3 .. $]);
writeln(a[0 .. 3]); // b
writeln(a); // [1, 2, 3, 4, 5]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="moveEmplaceSome">@system Tuple!(InputRange1, InputRange2) <strong id="moveEmplaceSome">moveEmplaceSome</strong>(InputRange1, InputRange2)(InputRange1 src, InputRange2 tgt)<br><small>  Constraints: if (isInputRange!InputRange1 &amp;&amp; isInputRange!InputRange2 &amp;&amp; is(typeof(move(src.front, tgt.front)))); </small>
</dt> <dd>
<p>Same as <a href="#moveSome"><code>moveSome</code></a> but assumes all elements in <code>tgt</code> are uninitialized. Uses <a href="#moveEmplace"><code>moveEmplace</code></a> to move elements from <code>src</code> over elements from <code>tgt</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static struct Foo
{
    ~this() pure nothrow @nogc { if (_ptr) ++*_ptr; }
    int* _ptr;
}
int[4] refs = [0, 1, 2, 3];
Foo[4] src = [Foo(&amp;refs[0]), Foo(&amp;refs[1]), Foo(&amp;refs[2]), Foo(&amp;refs[3])];
Foo[3] dst = void;

auto res = moveEmplaceSome(src[], dst[]);
writeln(res.length); // 2

import std.algorithm.searching : all;
assert(src[0 .. 3].all!(e =&gt; e._ptr is null));
assert(src[3]._ptr !is null);
assert(dst[].all!(e =&gt; e._ptr !is null));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="SwapStrategy">enum <strong id="SwapStrategy">SwapStrategy</strong>: int; </dt> <dd>
<p>Defines the swapping strategy for algorithms that need to swap elements in a range (such as partition and sort). The strategy concerns the swapping of elements that are not the core concern of the algorithm. For example, consider an algorithm that sorts <code>[ "abc", "b", "aBc" ]</code> according to <code>toUpper(a) &lt; toUpper(b)</code>. That algorithm might choose to swap the two equivalent strings <code>"abc"</code> and <code>"aBc"</code>. That does not affect the sorting since both <code>["abc", "aBc", "b" ]</code> and <code>[ "aBc", "abc", "b" ]</code> are valid outcomes. </p>
<p>Some situations require that the algorithm must NOT ever change the relative ordering of equivalent elements (in the example above, only <code>[ "abc", "aBc", "b" ]</code> would be the correct result). Such algorithms are called <b>stable</b>. If the ordering algorithm may swap equivalent elements discretionarily, the ordering is called <b>unstable</b>. <br><br> Yet another class of algorithms may choose an intermediate tradeoff by being stable only on a well-defined subrange of the range. There is no established terminology for such behavior; this library calls it <b>semistable</b>. <br><br> Generally, the <code>stable</code> ordering strategy may be more costly in time and/or space than the other two because it imposes additional constraints. Similarly, <code>semistable</code> may be costlier than <code>unstable</code>. As (semi-)stability is not needed very often, the ordering algorithms in this module parameterized by <code>SwapStrategy</code> all choose <code>SwapStrategy.unstable</code> as the default.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int[] a = [0, 1, 2, 3];
writeln(remove!(SwapStrategy.stable)(a, 1)); // [0, 2, 3]
a = [0, 1, 2, 3];
writeln(remove!(SwapStrategy.unstable)(a, 1)); // [0, 3, 2]
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.sorting : partition;

// Put stuff greater than 3 on the left
auto arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
writeln(partition!(a =&gt; a &gt; 3, SwapStrategy.stable)(arr)); // [1, 2, 3]
writeln(arr); // [4, 5, 6, 7, 8, 9, 10, 1, 2, 3]

arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
writeln(partition!(a =&gt; a &gt; 3, SwapStrategy.semistable)(arr)); // [2, 3, 1]
writeln(arr); // [4, 5, 6, 7, 8, 9, 10, 2, 3, 1]

arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
writeln(partition!(a =&gt; a &gt; 3, SwapStrategy.unstable)(arr)); // [3, 2, 1]
writeln(arr); // [10, 9, 8, 4, 5, 6, 7, 3, 2, 1]
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="SwapStrategy.unstable"><strong id="unstable">unstable</strong></dt> <dd>
<p>Allows freely swapping of elements as long as the output satisfies the algorithm's requirements.</p> </dd> <dt class="d_decl" id="SwapStrategy.semistable"><strong id="semistable">semistable</strong></dt> <dd>
<p>In algorithms partitioning ranges in two, preserve relative ordering of elements only to the left of the partition point.</p> </dd> <dt class="d_decl" id="SwapStrategy.stable"><strong id="stable">stable</strong></dt> <dd>
<p>Preserve the relative ordering of elements to the largest extent allowed by the algorithm's requirements.</p> </dd> </dl> </dd> <dt class="d_decl" id="remove">Range <strong id="remove">remove</strong>(SwapStrategy s = SwapStrategy.stable, Range, Offset...)(Range range, Offset offset)<br><small>  Constraints: if (Offset.length &gt;= 1 &amp;&amp; allSatisfy!(isValidIntegralTuple, Offset)); </small>
</dt> <dd>
<p>Eliminates elements at given offsets from <code>range</code> and returns the shortened range. </p>
<p>For example, here is how to remove a single element from an array: <br><br> </p>
<pre data-language="d">string[] a = [ "a", "b", "c", "d" ];
a = a.remove(1); // remove element at offset 1
assert(a == [ "a", "c", "d"]);
</pre> <br><br> Note that <code>remove</code> does not change the length of the original range directly; instead, it returns the shortened range. If its return value is not assigned to the original range, the original range will retain its original length, though its contents will have changed: <br><br> <pre data-language="d">int[] a = [ 3, 5, 7, 8 ];
assert(remove(a, 1) == [ 3, 7, 8 ]);
assert(a == [ 3, 7, 8, 8 ]);
</pre> <br><br> The element at offset <code>1</code> has been removed and the rest of the elements have shifted up to fill its place, however, the original array remains of the same length. This is because all functions in <code>std.algorithm</code> only change <i>content</i>, not <i>topology</i>. The value <code>8</code> is repeated because <a href="#move"><code>move</code></a> was invoked to rearrange elements, and on integers <code>move</code> simply copies the source to the destination. To replace <code>a</code> with the effect of the removal, simply assign the slice returned by <code>remove</code> to it, as shown in the first example. <br><br> Multiple indices can be passed into <code>remove</code>. In that case, elements at the respective indices are all removed. The indices must be passed in increasing order, otherwise an exception occurs. <br><br> <pre data-language="d">int[] a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];
assert(remove(a, 1, 3, 5) ==
    [ 0, 2, 4, 6, 7, 8, 9, 10 ]);
</pre> <br><br> (Note that all indices refer to slots in the <i>original</i> array, not in the array as it is being progressively shortened.) <br><br> Tuples of two integral offsets can be used to remove an indices range: <br><br> <pre data-language="d">int[] a = [ 3, 4, 5, 6, 7];
assert(remove(a, 1, tuple(1, 3), 9) == [ 3, 6, 7 ]);
</pre> <br><br> The tuple passes in a range closed to the left and open to the right (consistent with built-in slices), e.g. <code>tuple(1, 3)</code> means indices <code>1</code> and <code>2</code> but not <code>3</code>. <br><br> Finally, any combination of integral offsets and tuples composed of two integral offsets can be passed in: <br><br> <pre data-language="d">int[] a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];
assert(remove(a, 1, tuple(3, 5), 9) == [ 0, 2, 5, 6, 7, 8, 10 ]);
</pre> <br><br> In this case, the slots at positions 1, 3, 4, and 9 are removed from the array. <br><br> If the need is to remove some elements in the range but the order of the remaining elements does not have to be preserved, you may want to pass <code>SwapStrategy.unstable</code> to <code>remove</code>. <br><br> <pre data-language="d">int[] a = [ 0, 1, 2, 3 ];
assert(remove!(SwapStrategy.unstable)(a, 1) == [ 0, 3, 2 ]);
</pre> <br><br> In the case above, the element at slot <code>1</code> is removed, but replaced with the last element of the range. Taking advantage of the relaxation of the stability requirement, <code>remove</code> moved elements from the end of the array over the slots to be removed. This way there is less data movement to be done which improves the execution time of the function. <br><br> The function <code>remove</code> works on bidirectional ranges that have assignable lvalue elements. The moving strategy is (listed from fastest to slowest): <br><br> <ul> <li>If <code>s == SwapStrategy.unstable &amp;&amp; isRandomAccessRange!Range &amp;&amp; hasLength!Range &amp;&amp; hasLvalueElements!Range</code>, then elements are moved from the end of the range into the slots to be filled. In this case, the absolute minimum of moves is performed.</li> <li>Otherwise, if <code>s == SwapStrategy.unstable &amp;&amp; isBidirectionalRange!Range &amp;&amp; hasLength!Range &amp;&amp; hasLvalueElements!Range</code>, then elements are still moved from the end of the range, but time is spent on advancing between slots by repeated calls to <code>range.popFront</code>.</li> <li>Otherwise, elements are moved incrementally towards the front of <code>range</code>; a given element is never moved several times, but more elements are moved than in the previous cases.</li> </ul>  <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>s</td> <td>a SwapStrategy to determine if the original order needs to be preserved</td>
</tr> <tr>
<td>Range <code>range</code>
</td> <td>a <a href="std_range_primitives#isBidirectionalRange">bidirectional range</a> with a length member</td>
</tr> <tr>
<td>Offset <code>offset</code>
</td> <td>which element(s) to remove</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A range containing all of the elements of range with offset removed.</dd>
</dl> </dd> <dt class="d_decl" id="remove.2">Range <strong id="remove">remove</strong>(alias pred, SwapStrategy s = SwapStrategy.stable, Range)(Range range); </dt> <dd>
<p>Reduces the length of the <a href="std_range_primitives#isBidirectionalRange">bidirectional range</a> <code>range</code> by removing elements that satisfy <code>pred</code>. If <code>s = SwapStrategy.unstable</code>, elements are moved from the right end of the range over the elements to eliminate. If <code>s = SwapStrategy.stable</code> (the default), elements are moved progressively to front such that their relative order is preserved. Returns the filtered range. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>range</code>
</td> <td>a bidirectional ranges with lvalue elements or mutable character arrays</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>the range with all of the elements where <code>pred</code> is <code>true</code> removed</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static immutable base = [1, 2, 3, 2, 4, 2, 5, 2];

int[] arr = base[].dup;

// using a string-based predicate
writeln(remove!("a == 2")(arr)); // [1, 3, 4, 5]

// The original array contents have been modified,
// so we need to reset it to its original state.
// The length is unmodified however.
arr[] = base[];

// using a lambda predicate
writeln(remove!(a =&gt; a == 2)(arr)); // [1, 3, 4, 5]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="reverse">Range <strong id="reverse">reverse</strong>(Range)(Range r)<br><small>  Constraints: if (isBidirectionalRange!Range &amp;&amp; (hasSwappableElements!Range || hasAssignableElements!Range &amp;&amp; hasLength!Range &amp;&amp; isRandomAccessRange!Range || isNarrowString!Range &amp;&amp; isAssignable!(ElementType!Range))); </small>
</dt> <dd>
<p>Reverses <code>r</code> in-place. Performs <code>r.length / 2</code> evaluations of <code>swap</code>. UTF sequences consisting of multiple code units are preserved properly. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>r</code>
</td> <td>a <a href="std_range_primitives#isBidirectionalRange">bidirectional range</a> with either swappable elements, a random access range with a length member, or a narrow string</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>r</code> </dd>
</dl> <dl>
<dt>Note</dt>
<dd> When passing a string with unicode modifiers on characters, such as <code>\u0301</code>, this function will not properly keep the position of the modifier. For example, reversing <code>ba\u0301d</code> ("bád") will result in d\u0301ab ("d́ab") instead of <code>da\u0301b</code> ("dáb"). </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="std_range#retro"><code>std.range.retro</code></a> for a lazy reverse without changing <code>r</code>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int[] arr = [ 1, 2, 3 ];
writeln(arr.reverse); // [3, 2, 1]
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">char[] arr = "hello\U00010143\u0100\U00010143".dup;
writeln(arr.reverse); // "\U00010143\u0100\U00010143olleh"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="strip">Range <strong id="strip">strip</strong>(Range, E)(Range range, E element)<br><small>  Constraints: if (isBidirectionalRange!Range &amp;&amp; is(typeof(range.front == element) : bool)); </small><br><br>Range <strong id="strip">strip</strong>(alias pred, Range)(Range range)<br><small>  Constraints: if (isBidirectionalRange!Range &amp;&amp; is(typeof(pred(range.back)) : bool)); </small><br><br>Range <strong id="stripLeft">stripLeft</strong>(Range, E)(Range range, E element)<br><small>  Constraints: if (isInputRange!Range &amp;&amp; is(typeof(range.front == element) : bool)); </small><br><br>Range <strong id="stripLeft">stripLeft</strong>(alias pred, Range)(Range range)<br><small>  Constraints: if (isInputRange!Range &amp;&amp; is(typeof(pred(range.front)) : bool)); </small><br><br>Range <strong id="stripRight">stripRight</strong>(Range, E)(Range range, E element)<br><small>  Constraints: if (isBidirectionalRange!Range &amp;&amp; is(typeof(range.back == element) : bool)); </small><br><br>Range <strong id="stripRight">stripRight</strong>(alias pred, Range)(Range range)<br><small>  Constraints: if (isBidirectionalRange!Range &amp;&amp; is(typeof(pred(range.back)) : bool)); </small>
</dt> <dd>
<p>The strip group of functions allow stripping of either leading, trailing, or both leading and trailing elements. </p>
<p>The <code>stripLeft</code> function will strip the <code>front</code> of the range, the <code>stripRight</code> function will strip the <code>back</code> of the range, while the <code>strip</code> function will strip both the <code>front</code> and <code>back</code> of the range. <br><br> Note that the <code>strip</code> and <code>stripRight</code> functions require the range to be a <a href="#BidirectionalRange"><code>BidirectionalRange</code></a> range. <br><br> All of these functions come in two varieties: one takes a target element, where the range will be stripped as long as this element can be found. The other takes a lambda predicate, where the range will be stripped as long as the predicate returns true. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>range</code>
</td> <td>a <a href="std_range_primitives#isBidirectionalRange">bidirectional range</a> or <a href="std_range_primitives#isInputRange">input range</a>
</td>
</tr> <tr>
<td>E <code>element</code>
</td> <td>the elements to remove</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>a Range with all of range except element at the start and end</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Strip leading and trailing elements equal to the target element. <pre data-language="d">writeln("  foobar  ".strip(' ')); // "foobar"
writeln("00223.444500".strip('0')); // "223.4445"
writeln("ëëêéüŗōpéêëë".strip('ë')); // "êéüŗōpéê"
writeln([1, 1, 0, 1, 1].strip(1)); // [0]
writeln([0.0, 0.01, 0.01, 0.0].strip(0).length); // 2
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Strip leading and trailing elements while the predicate returns true. <pre data-language="d">writeln("  foobar  ".strip!(a =&gt; a == ' ')()); // "foobar"
writeln("00223.444500".strip!(a =&gt; a == '0')()); // "223.4445"
writeln("ëëêéüŗōpéêëë".strip!(a =&gt; a == 'ë')()); // "êéüŗōpéê"
writeln([1, 1, 0, 1, 1].strip!(a =&gt; a == 1)()); // [0]
writeln([0.0, 0.01, 0.5, 0.6, 0.01, 0.0].strip!(a =&gt; a &lt; 0.4)().length); // 2
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Strip leading elements equal to the target element. <pre data-language="d">writeln("  foobar  ".stripLeft(' ')); // "foobar  "
writeln("00223.444500".stripLeft('0')); // "223.444500"
writeln("ůůűniçodêéé".stripLeft('ů')); // "űniçodêéé"
writeln([1, 1, 0, 1, 1].stripLeft(1)); // [0, 1, 1]
writeln([0.0, 0.01, 0.01, 0.0].stripLeft(0).length); // 3
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Strip leading elements while the predicate returns true. <pre data-language="d">writeln("  foobar  ".stripLeft!(a =&gt; a == ' ')()); // "foobar  "
writeln("00223.444500".stripLeft!(a =&gt; a == '0')()); // "223.444500"
writeln("ůůűniçodêéé".stripLeft!(a =&gt; a == 'ů')()); // "űniçodêéé"
writeln([1, 1, 0, 1, 1].stripLeft!(a =&gt; a == 1)()); // [0, 1, 1]
writeln([0.0, 0.01, 0.10, 0.5, 0.6].stripLeft!(a =&gt; a &lt; 0.4)().length); // 2
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Strip trailing elements equal to the target element. <pre data-language="d">writeln("  foobar  ".stripRight(' ')); // "  foobar"
writeln("00223.444500".stripRight('0')); // "00223.4445"
writeln("ùniçodêéé".stripRight('é')); // "ùniçodê"
writeln([1, 1, 0, 1, 1].stripRight(1)); // [1, 1, 0]
writeln([0.0, 0.01, 0.01, 0.0].stripRight(0).length); // 3
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Strip trailing elements while the predicate returns true. <pre data-language="d">writeln("  foobar  ".stripRight!(a =&gt; a == ' ')()); // "  foobar"
writeln("00223.444500".stripRight!(a =&gt; a == '0')()); // "00223.4445"
writeln("ùniçodêéé".stripRight!(a =&gt; a == 'é')()); // "ùniçodê"
writeln([1, 1, 0, 1, 1].stripRight!(a =&gt; a == 1)()); // [1, 1, 0]
writeln([0.0, 0.01, 0.10, 0.5, 0.6].stripRight!(a =&gt; a &gt; 0.4)().length); // 3
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="swap">pure nothrow @nogc @trusted void <strong id="swap">swap</strong>(T)(ref T lhs, ref T rhs)<br><small>  Constraints: if (isBlitAssignable!T &amp;&amp; !is(typeof(lhs.proxySwap(rhs)))); </small><br><br>void <strong id="swap">swap</strong>(T)(ref T lhs, ref T rhs)<br><small>  Constraints: if (is(typeof(lhs.proxySwap(rhs)))); </small>
</dt> <dd>
<p>Swaps <code>lhs</code> and <code>rhs</code>. The instances <code>lhs</code> and <code>rhs</code> are moved in memory, without ever calling <code>opAssign</code>, nor any other function. <code>T</code> need not be assignable at all to be swapped. </p>
<p>If <code>lhs</code> and <code>rhs</code> reference the same instance, then nothing is done. <br><br> <code>lhs</code> and <code>rhs</code> must be mutable. If <code>T</code> is a struct or union, then its fields must also all be (recursively) mutable. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>lhs</code>
</td> <td>Data to be swapped with <code>rhs</code>.</td>
</tr> <tr>
<td>T <code>rhs</code>
</td> <td>Data to be swapped with <code>lhs</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">// Swapping POD (plain old data) types:
int a = 42, b = 34;
swap(a, b);
assert(a == 34 &amp;&amp; b == 42);

// Swapping structs with indirection:
static struct S { int x; char c; int[] y; }
S s1 = { 0, 'z', [ 1, 2 ] };
S s2 = { 42, 'a', [ 4, 6 ] };
swap(s1, s2);
writeln(s1.x); // 42
writeln(s1.c); // 'a'
writeln(s1.y); // [4, 6]

writeln(s2.x); // 0
writeln(s2.c); // 'z'
writeln(s2.y); // [1, 2]

// Immutables cannot be swapped:
immutable int imm1 = 1, imm2 = 2;
static assert(!__traits(compiles, swap(imm1, imm2)));

int c = imm1 + 0;
int d = imm2 + 0;
swap(c, d);
writeln(c); // 2
writeln(d); // 1
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">// Non-copyable types can still be swapped.
static struct NoCopy
{
    this(this) { assert(0); }
    int n;
    string s;
}
NoCopy nc1, nc2;
nc1.n = 127; nc1.s = "abc";
nc2.n = 513; nc2.s = "uvwxyz";

swap(nc1, nc2);
assert(nc1.n == 513 &amp;&amp; nc1.s == "uvwxyz");
assert(nc2.n == 127 &amp;&amp; nc2.s == "abc");

swap(nc1, nc1);
swap(nc2, nc2);
assert(nc1.n == 513 &amp;&amp; nc1.s == "uvwxyz");
assert(nc2.n == 127 &amp;&amp; nc2.s == "abc");

// Types containing non-copyable fields can also be swapped.
static struct NoCopyHolder
{
    NoCopy noCopy;
}
NoCopyHolder h1, h2;
h1.noCopy.n = 31; h1.noCopy.s = "abc";
h2.noCopy.n = 65; h2.noCopy.s = null;

swap(h1, h2);
assert(h1.noCopy.n == 65 &amp;&amp; h1.noCopy.s == null);
assert(h2.noCopy.n == 31 &amp;&amp; h2.noCopy.s == "abc");

swap(h1, h1);
swap(h2, h2);
assert(h1.noCopy.n == 65 &amp;&amp; h1.noCopy.s == null);
assert(h2.noCopy.n == 31 &amp;&amp; h2.noCopy.s == "abc");

// Const types cannot be swapped.
const NoCopy const1, const2;
assert(const1.n == 0 &amp;&amp; const2.n == 0);
static assert(!__traits(compiles, swap(const1, const2)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="swapAt">void <strong id="swapAt">swapAt</strong>(R)(auto ref R r, size_t i1, size_t i2); </dt> <dd>
<p>Swaps two elements in-place of a range <code>r</code>, specified by their indices <code>i1</code> and <code>i2</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>r</code>
</td> <td>a range with swappable elements</td>
</tr> <tr>
<td>size_t <code>i1</code>
</td> <td>first index</td>
</tr> <tr>
<td>size_t <code>i2</code>
</td> <td>second index</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
auto a = [1, 2, 3];
a.swapAt(1, 2);
assert(a.equal([1, 3, 2]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="swapRanges">Tuple!(InputRange1, InputRange2) <strong id="swapRanges">swapRanges</strong>(InputRange1, InputRange2)(InputRange1 r1, InputRange2 r2)<br><small>  Constraints: if (hasSwappableElements!InputRange1 &amp;&amp; hasSwappableElements!InputRange2 &amp;&amp; is(ElementType!InputRange1 == ElementType!InputRange2)); </small>
</dt> <dd>
<p>Swaps all elements of <code>r1</code> with successive elements in <code>r2</code>. Returns a tuple containing the remainder portions of <code>r1</code> and <code>r2</code> that were not swapped (one of them will be empty). The ranges may be of different types but must have the same element type and support swapping. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>InputRange1 <code>r1</code>
</td> <td>an <a href="std_range_primitives#isInputRange">input range</a> with swappable elements</td>
</tr> <tr>
<td>InputRange2 <code>r2</code>
</td> <td>an <a href="std_range_primitives#isInputRange">input range</a> with swappable elements</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Tuple containing the remainder portions of r1 and r2 that were not swapped</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.range : empty;
int[] a = [ 100, 101, 102, 103 ];
int[] b = [ 0, 1, 2, 3 ];
auto c = swapRanges(a[1 .. 3], b[2 .. 4]);
assert(c[0].empty &amp;&amp; c[1].empty);
writeln(a); // [100, 2, 3, 103]
writeln(b); // [0, 1, 101, 102]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="uninitializedFill">void <strong id="uninitializedFill">uninitializedFill</strong>(Range, Value)(Range range, Value value)<br><small>  Constraints: if (isInputRange!Range &amp;&amp; hasLvalueElements!Range &amp;&amp; is(typeof(range.front = value))); </small>
</dt> <dd>
<p>Initializes each element of <code>range</code> with <code>value</code>. Assumes that the elements of the range are uninitialized. This is of interest for structs that define copy constructors (for all other types, <a href="#fill"><code>fill</code></a> and uninitializedFill are equivalent). </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>range</code>
</td> <td>An <a href="std_range_primitives#isInputRange">input range</a> that exposes references to its elements and has assignable elements</td>
</tr> <tr>
<td>Value <code>value</code>
</td> <td>Assigned to each element of range</td>
</tr> </table></dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#fill"><code>fill</code></a> <a href="#initializeAll"><code>initializeAll</code></a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import core.stdc.stdlib : malloc, free;

auto s = (cast(int*) malloc(5 * int.sizeof))[0 .. 5];
uninitializedFill(s, 42);
writeln(s); // [42, 42, 42, 42, 42]

scope(exit) free(s.ptr);
</pre> </dd>
</dl> </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2019 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_algorithm_mutation.html" class="_attribution-link">https://dlang.org/phobos/std_algorithm_mutation.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
