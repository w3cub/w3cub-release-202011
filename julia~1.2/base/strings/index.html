
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Strings - Julia 1.2 - W3cubDocs</title>
  
  <meta name="description" content="The AbstractChar type is the supertype of all character implementations in Julia. A character represents a Unicode code point, and can be converted &hellip;">
  <meta name="keywords" content="strings, julia, julia~1.2">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/julia~1.2/base/strings/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/julia~1.2.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/julia~1.2/" class="_nav-link" title="" style="margin-left:0;">Julia 1.2</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _julia">
				
				
<h1 id="lib-strings-1">Strings</h1>
<h3 id="Core.AbstractChar">
<code>Core.AbstractChar</code><span class="docstring-category">Type</span>
</h3>
<p>The <code>AbstractChar</code> type is the supertype of all character implementations in Julia. A character represents a Unicode code point, and can be converted to an integer via the <a href="#Base.codepoint"><code>codepoint</code></a> function in order to obtain the numerical value of the code point, or constructed from the same integer. These numerical values determine how characters are compared with <code>&lt;</code> and <code>==</code>, for example. New <code>T &lt;: AbstractChar</code> types should define a <code>codepoint(::T)</code> method and a <code>T(::UInt32)</code> constructor, at minimum.</p>
<p>A given <code>AbstractChar</code> subtype may be capable of representing only a subset of Unicode, in which case conversion from an unsupported <code>UInt32</code> value may throw an error. Conversely, the built-in <a href="#Core.Char"><code>Char</code></a> type represents a <em>superset</em> of Unicode (in order to losslessly encode invalid byte streams), in which case conversion of a non-Unicode value <em>to</em> <code>UInt32</code> throws an error. The <a href="#Base.isvalid-Tuple%7BAny%7D"><code>isvalid</code></a> function can be used to check which codepoints are representable in a given <code>AbstractChar</code> type.</p>
<p>Internally, an <code>AbstractChar</code> type may use a variety of encodings. Conversion via <code>codepoint(char)</code> will not reveal this encoding because it always returns the Unicode value of the character. <code>print(io, c)</code> of any <code>c::AbstractChar</code> produces an encoding determined by <code>io</code> (UTF-8 for all built-in <code>IO</code> types), via conversion to <code>Char</code> if necessary.</p>
<p><code>write(io, c)</code>, in contrast, may emit an encoding depending on <code>typeof(c)</code>, and <code>read(io, typeof(c))</code> should read the same encoding as <code>write</code>. New <code>AbstractChar</code> types must provide their own implementations of <code>write</code> and <code>read</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/char.jl#L3-L30">source</a><h3 id="Core.Char">
<code>Core.Char</code><span class="docstring-category">Type</span>
</h3>
<pre data-language="julia">Char(c::Union{Number,AbstractChar})</pre>
<p><code>Char</code> is a 32-bit <a href="#Core.AbstractChar"><code>AbstractChar</code></a> type that is the default representation of characters in Julia. <code>Char</code> is the type used for character literals like <code>'x'</code> and it is also the element type of <a href="#Core.String-Tuple%7BAbstractString%7D"><code>String</code></a>.</p>
<p>In order to losslessly represent arbitrary byte streams stored in a <code>String</code>, a <code>Char</code> value may store information that cannot be converted to a Unicode codepoint — converting such a <code>Char</code> to <code>UInt32</code> will throw an error. The <a href="#Base.isvalid-Tuple%7BAny%7D"><code>isvalid(c::Char)</code></a> function can be used to query whether <code>c</code> represents a valid Unicode character.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/char.jl#L33-L45">source</a><h3 id="Base.codepoint">
<code>Base.codepoint</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">codepoint(c::AbstractChar) -&gt; Integer</pre>
<p>Return the Unicode codepoint (an unsigned integer) corresponding to the character <code>c</code> (or throw an exception if <code>c</code> does not represent a valid character). For <code>Char</code>, this is a <code>UInt32</code> value, but <code>AbstractChar</code> types that represent only a subset of Unicode may return a different-sized integer (e.g. <code>UInt8</code>).</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/char.jl#L66-L74">source</a><h3 id="Base.length-Tuple{AbstractString}">
<code>Base.length</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">length(s::AbstractString) -&gt; Int
length(s::AbstractString, i::Integer, j::Integer) -&gt; Int</pre>
<p>The number of characters in string <code>s</code> from indices <code>i</code> through <code>j</code>. This is computed as the number of code unit indices from <code>i</code> to <code>j</code> which are valid character indices. With only a single string argument, this computes the number of characters in the entire string. With <code>i</code> and <code>j</code> arguments it computes the number of indices between <code>i</code> and <code>j</code> inclusive that are valid indices in the string <code>s</code>. In addition to in-bounds values, <code>i</code> may take the out-of-bounds value <code>ncodeunits(s) + 1</code> and <code>j</code> may take the out-of-bounds value <code>0</code>.</p>
<p>See also: <a href="#Base.isvalid-Tuple%7BAny%7D"><code>isvalid</code></a>, <a href="#Base.ncodeunits-Tuple%7BAbstractString%7D"><code>ncodeunits</code></a>, <a href="../collections/index#Base.lastindex"><code>lastindex</code></a>, <a href="#Base.thisind"><code>thisind</code></a>, <a href="#Base.nextind"><code>nextind</code></a>, <a href="#Base.prevind"><code>prevind</code></a></p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; length("jμΛIα")
5</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/basic.jl#L324-L345">source</a><h3 id="Base.sizeof-Tuple{AbstractString}">
<code>Base.sizeof</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">sizeof(str::AbstractString)</pre>
<p>Size, in bytes, of the string <code>str</code>. Equal to the number of code units in <code>str</code> multiplied by the size, in bytes, of one code unit in <code>str</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; sizeof("")
0

julia&gt; sizeof("∀")
3</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/basic.jl#L142-L156">source</a><h3 id="Base.:*-Tuple{Union{AbstractChar, AbstractString},Vararg{Union{AbstractChar, AbstractString},N} where N}">
<code>Base.:*</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">*(s::Union{AbstractString, AbstractChar}, t::Union{AbstractString, AbstractChar}...) -&gt; AbstractString</pre>
<p>Concatenate strings and/or characters, producing a <a href="#Core.String-Tuple%7BAbstractString%7D"><code>String</code></a>. This is equivalent to calling the <a href="#Base.string"><code>string</code></a> function on the arguments. Concatenation of built-in string types always produces a value of type <code>String</code> but other string types may choose to return a string of a different type as appropriate.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; "Hello " * "world"
"Hello world"

julia&gt; 'j' * "ulia"
"julia"</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/basic.jl#L213-L229">source</a><h3 id="Base.:^-Tuple{AbstractString,Integer}">
<code>Base.:^</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">^(s::Union{AbstractString,AbstractChar}, n::Integer)</pre>
<p>Repeat a string or character <code>n</code> times. This can also be written as <code>repeat(s, n)</code>.</p>
<p>See also: <a href="../arrays/index#Base.repeat"><code>repeat</code></a></p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; "Test "^3
"Test Test Test "</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/basic.jl#L661-L673">source</a><h3 id="Base.string">
<code>Base.string</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">string(n::Integer; base::Integer = 10, pad::Integer = 1)</pre>
<p>Convert an integer <code>n</code> to a string in the given <code>base</code>, optionally specifying a number of digits to pad to.</p>
<pre data-language="julia">julia&gt; string(5, base = 13, pad = 4)
"0005"

julia&gt; string(13, base = 5, pad = 4)
"0023"</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/intfuncs.jl#L623-L636">source</a><pre data-language="julia">string(xs...)</pre>
<p>Create a string from any values, except <code>nothing</code>, using the <a href="../io-network/index#Base.print"><code>print</code></a> function.</p>
<p><code>string</code> should usually not be defined directly. Instead, define a method <code>print(io::IO, x::MyType)</code>. If <code>string(x)</code> for a certain type needs to be highly efficient, then it may make sense to add a method to <code>string</code> and define <code>print(io::IO, x::MyType) = print(io, string(x))</code> to ensure the functions are consistent.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; string("a", 1, true)
"a1true"</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/io.jl#L151-L167">source</a><h3 id="Base.repeat-Tuple{AbstractString,Integer}">
<code>Base.repeat</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">repeat(s::AbstractString, r::Integer)</pre>
<p>Repeat a string <code>r</code> times. This can be written as <code>s^r</code>.</p>
<p>See also: <a href="#Base.:%5E-Tuple%7BAbstractString,Integer%7D"><code>^</code></a></p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; repeat("ha", 3)
"hahaha"</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/basic.jl#L646-L658">source</a><h3 id="Base.repeat-Tuple{AbstractChar,Integer}">
<code>Base.repeat</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">repeat(c::AbstractChar, r::Integer) -&gt; String</pre>
<p>Repeat a character <code>r</code> times. This can equivalently be accomplished by calling <a href="#Base.:%5E-Tuple%7BAbstractString,Integer%7D"><code>c^r</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; repeat('A', 3)
"AAA"</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/string.jl#L305-L315">source</a><h3 id="Base.repr-Tuple{Any}">
<code>Base.repr</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">repr(x; context=nothing)</pre>
<p>Create a string from any value using the <a href="#"><code>show</code></a> function. You should not add methods to <code>repr</code>; define a <code>show</code> method instead.</p>
<p>The optional keyword argument <code>context</code> can be set to an <code>IO</code> or <a href="../io-network/index#Base.IOContext"><code>IOContext</code></a> object whose attributes are used for the I/O stream passed to <code>show</code>.</p>
<p>Note that <code>repr(x)</code> is usually similar to how the value of <code>x</code> would be entered in Julia. See also <a href="#Base.repr-Tuple%7BAny%7D"><code>repr(MIME("text/plain"), x)</code></a> to instead return a "pretty-printed" version of <code>x</code> designed more for human consumption, equivalent to the REPL display of <code>x</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; repr(1)
"1"

julia&gt; repr(zeros(3))
"[0.0, 0.0, 0.0]"

julia&gt; repr(big(1/3))
"0.333333333333333314829616256247390992939472198486328125"

julia&gt; repr(big(1/3), context=:compact =&gt; true)
"0.333333"
</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/io.jl#L191-L220">source</a><h3 id="Core.String-Tuple{AbstractString}">
<code>Core.String</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">String(s::AbstractString)</pre>
<p>Convert a string to a contiguous byte array representation encoded as UTF-8 bytes. This representation is often appropriate for passing strings to C.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/string.jl#L62-L67">source</a><h3 id="Base.SubString">
<code>Base.SubString</code><span class="docstring-category">Type</span>
</h3>
<pre data-language="julia">SubString(s::AbstractString, i::Integer, j::Integer=lastindex(s))
SubString(s::AbstractString, r::UnitRange{&lt;:Integer})</pre>
<p>Like <a href="../collections/index#Base.getindex"><code>getindex</code></a>, but returns a view into the parent string <code>s</code> within range <code>i:j</code> or <code>r</code> respectively instead of making a copy.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; SubString("abc", 1, 2)
"ab"

julia&gt; SubString("abc", 1:2)
"ab"

julia&gt; SubString("abc", 2)
"bc"</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/substring.jl#L3-L21">source</a><h3 id="Base.transcode">
<code>Base.transcode</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">transcode(T, src)</pre>
<p>Convert string data between Unicode encodings. <code>src</code> is either a <code>String</code> or a <code>Vector{UIntXX}</code> of UTF-XX code units, where <code>XX</code> is 8, 16, or 32. <code>T</code> indicates the encoding of the return value: <code>String</code> to return a (UTF-8 encoded) <code>String</code> or <code>UIntXX</code> to return a <code>Vector{UIntXX}</code> of UTF-<code>XX</code> data. (The alias <a href="../c/index#Base.Cwchar_t"><code>Cwchar_t</code></a> can also be used as the integer type, for converting <code>wchar_t*</code> strings used by external C libraries.)</p>
<p>The <code>transcode</code> function succeeds as long as the input data can be reasonably represented in the target encoding; it always succeeds for conversions between UTF-XX encodings, even for invalid Unicode data.</p>
<p>Only conversion to/from UTF-8 is currently supported.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/c.jl#L257-L273">source</a><h3 id="Base.unsafe_string">
<code>Base.unsafe_string</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">unsafe_string(p::Ptr{UInt8}, [length::Integer])</pre>
<p>Copy a string from the address of a C-style (NUL-terminated) string encoded as UTF-8. (The pointer can be safely freed afterwards.) If <code>length</code> is specified (the length of the data in bytes), the string does not have to be NUL-terminated.</p>
<p>This function is labeled "unsafe" because it will crash if <code>p</code> is not a valid memory address to data of the requested length.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/string.jl#L41-L50">source</a><h3 id="Base.ncodeunits-Tuple{AbstractString}">
<code>Base.ncodeunits</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">ncodeunits(s::AbstractString) -&gt; Int</pre>
<p>Return the number of code units in a string. Indices that are in bounds to access this string must satisfy <code>1 ≤ i ≤ ncodeunits(s)</code>. Not all such indices are valid – they may not be the start of a character, but they will return a code unit value when calling <code>codeunit(s,i)</code>.</p>
<p>See also: <a href="#Base.codeunit"><code>codeunit</code></a>, <a href="../arrays/index#Base.checkbounds"><code>checkbounds</code></a>, <a href="#Base.sizeof-Tuple%7BAbstractString%7D"><code>sizeof</code></a>, <a href="../collections/index#Base.length"><code>length</code></a>, <a href="../collections/index#Base.lastindex"><code>lastindex</code></a></p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/basic.jl#L45-L55">source</a><h3 id="Base.codeunit">
<code>Base.codeunit</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">codeunit(s::AbstractString) -&gt; Type{&lt;:Union{UInt8, UInt16, UInt32}}</pre>
<p>Return the code unit type of the given string object. For ASCII, Latin-1, or UTF-8 encoded strings, this would be <code>UInt8</code>; for UCS-2 and UTF-16 it would be <code>UInt16</code>; for UTF-32 it would be <code>UInt32</code>. The unit code type need not be limited to these three types, but it's hard to think of widely used string encodings that don't use one of these units. <code>codeunit(s)</code> is the same as <code>typeof(codeunit(s,1))</code> when <code>s</code> is a non-empty string.</p>
<p>See also: <a href="#Base.ncodeunits-Tuple%7BAbstractString%7D"><code>ncodeunits</code></a></p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/basic.jl#L58-L69">source</a><pre data-language="julia">codeunit(s::AbstractString, i::Integer) -&gt; Union{UInt8, UInt16, UInt32}</pre>
<p>Return the code unit value in the string <code>s</code> at index <code>i</code>. Note that</p>
<pre data-language="julia">codeunit(s, i) :: codeunit(s)</pre>
<p>I.e. the value returned by <code>codeunit(s, i)</code> is of the type returned by <code>codeunit(s)</code>.</p>
<p>See also: <a href="#Base.ncodeunits-Tuple%7BAbstractString%7D"><code>ncodeunits</code></a>, <a href="../arrays/index#Base.checkbounds"><code>checkbounds</code></a></p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/basic.jl#L72-L83">source</a><h3 id="Base.codeunits">
<code>Base.codeunits</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">codeunits(s::AbstractString)</pre>
<p>Obtain a vector-like object containing the code units of a string. Returns a <code>CodeUnits</code> wrapper by default, but <code>codeunits</code> may optionally be defined for new string types if necessary.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/basic.jl#L706-L712">source</a><h3 id="Base.ascii">
<code>Base.ascii</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">ascii(s::AbstractString)</pre>
<p>Convert a string to <code>String</code> type and check that it contains only ASCII data, otherwise throwing an <code>ArgumentError</code> indicating the position of the first non-ASCII byte.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; ascii("abcdeγfgh")
ERROR: ArgumentError: invalid ASCII at index 6 in "abcdeγfgh"
Stacktrace:
[...]

julia&gt; ascii("abcdefgh")
"abcdefgh"</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/util.jl#L616-L632">source</a><h3 id="Base.@r_str">
<code>Base.@r_str</code><span class="docstring-category">Macro</span>
</h3>
<pre data-language="julia">@r_str -&gt; Regex</pre>
<p>Construct a regex, such as <code>r"^[a-z]*$"</code>, without interpolation and unescaping (except for quotation mark <code>"</code> which still has to be escaped). The regex also accepts one or more flags, listed after the ending quote, to change its behaviour:</p>
<ul>
<li>
<code>i</code> enables case-insensitive matching</li>
<li>
<code>m</code> treats the <code>^</code> and <code>$</code> tokens as matching the start and end of individual lines, as opposed to the whole string.</li>
<li>
<code>s</code> allows the <code>.</code> modifier to match newlines.</li>
<li>
<code>x</code> enables "comment mode": whitespace is enabled except when escaped with <code>\</code>, and <code>#</code> is treated as starting a comment.</li>
<li>
<code>a</code> disables <code>UCP</code> mode (enables ASCII mode). By default <code>\B</code>, <code>\b</code>, <code>\D</code>, <code>\d</code>, <code>\S</code>, <code>\s</code>, <code>\W</code>, <code>\w</code>, etc. match based on Unicode character properties. With this option, these sequences only match ASCII characters.</li>
</ul>
<p>See <code>Regex</code> if interpolation is needed.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; match(r"a+.*b+.*?d$"ism, "Goodbye,\nOh, angry,\nBad world\n")
RegexMatch("angry,\nBad world")</pre>
<p>This regex has the first three flags enabled.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/regex.jl#L77-L102">source</a><h3 id="Base.SubstitutionString">
<code>Base.SubstitutionString</code><span class="docstring-category">Type</span>
</h3>
<pre data-language="julia">SubstitutionString(substr)</pre>
<p>Stores the given string <code>substr</code> as a <code>SubstitutionString</code>, for use in regular expression substitutions. Most commonly constructed using the <a href="#Base.@s_str"><code>@s_str</code></a> macro.</p>
<pre data-language="julia">julia&gt; SubstitutionString("Hello \\g&lt;name&gt;, it's \\1")
s"Hello \\g&lt;name&gt;, it's \\1"

julia&gt; subst = s"Hello \g&lt;name&gt;, it's \1"
s"Hello \\g&lt;name&gt;, it's \\1"

julia&gt; typeof(subst)
SubstitutionString{String}
</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/regex.jl#L313-L331">source</a><h3 id="Base.@s_str">
<code>Base.@s_str</code><span class="docstring-category">Macro</span>
</h3>
<pre data-language="julia">@s_str -&gt; SubstitutionString</pre>
<p>Construct a substitution string, used for regular expression substitutions. Within the string, sequences of the form <code>\N</code> refer to the Nth capture group in the regex, and <code>\g&lt;groupname&gt;</code> refers to a named capture group with name <code>groupname</code>.</p>
<pre data-language="julia">julia&gt; msg = "#Hello# from Julia";

julia&gt; replace(msg, r"#(.+)# from (?&lt;from&gt;\w+)" =&gt; s"FROM: \g&lt;from&gt;; MESSAGE: \1")
"FROM: Julia; MESSAGE: Hello"</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/regex.jl#L347-L360">source</a><h3 id="Base.@raw_str">
<code>Base.@raw_str</code><span class="docstring-category">Macro</span>
</h3>
<pre data-language="julia">@raw_str -&gt; String</pre>
<p>Create a raw string without interpolation and unescaping. The exception is that quotation marks still must be escaped. Backslashes escape both quotation marks and other backslashes, but only when a sequence of backslashes precedes a quote character. Thus, 2n backslashes followed by a quote encodes n backslashes and the end of the literal while 2n+1 backslashes followed by a quote encodes n backslashes followed by a quote character.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; println(raw"\ $x")
\ $x

julia&gt; println(raw"\"")
"

julia&gt; println(raw"\\\"")
\"

julia&gt; println(raw"\\x \\\"")
\\x \"</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/io.jl#L481-L505">source</a><h3 id="Base.@b_str">
<code>Base.@b_str</code><span class="docstring-category">Macro</span>
</h3>
<pre data-language="julia">@b_str</pre>
<p>Create an immutable byte (<code>UInt8</code>) vector using string syntax.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; v = b"12\x01\x02"
4-element Base.CodeUnits{UInt8,String}:
 0x31
 0x32
 0x01
 0x02

julia&gt; v[2]
0x32</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/io.jl#L458-L475">source</a><h3 id="Base.Docs.@html_str">
<code>Base.Docs.@html_str</code><span class="docstring-category">Macro</span>
</h3>
<pre data-language="julia">@html_str -&gt; Docs.HTML</pre>
<p>Create an <code>HTML</code> object from a literal string.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/docs/utils.jl#L37-L41">source</a><h3 id="Base.Docs.@text_str">
<code>Base.Docs.@text_str</code><span class="docstring-category">Macro</span>
</h3>
<pre data-language="julia">@text_str -&gt; Docs.Text</pre>
<p>Create a <code>Text</code> object from a literal string.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/docs/utils.jl#L78-L82">source</a><h3 id="Base.isvalid-Tuple{Any}">
<code>Base.isvalid</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">isvalid(value) -&gt; Bool</pre>
<p>Returns <code>true</code> if the given value is valid for its type, which currently can be either <code>AbstractChar</code> or <code>String</code> or <code>SubString{String}</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; isvalid(Char(0xd800))
false

julia&gt; isvalid(SubString(String(UInt8[0xfe,0x80,0x80,0x80,0x80,0x80]),1,2))
false

julia&gt; isvalid(Char(0xd799))
true</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/unicode.jl#L11-L28">source</a><h3 id="Base.isvalid-Tuple{Any,Any}">
<code>Base.isvalid</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">isvalid(T, value) -&gt; Bool</pre>
<p>Returns <code>true</code> if the given value is valid for that type. Types currently can be either <code>AbstractChar</code> or <code>String</code>. Values for <code>AbstractChar</code> can be of type <code>AbstractChar</code> or <a href="../numbers/index#Core.UInt32"><code>UInt32</code></a>. Values for <code>String</code> can be of that type, or <code>Vector{UInt8}</code> or <code>SubString{String}</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; isvalid(Char, 0xd800)
false

julia&gt; isvalid(String, SubString("thisisvalid",1,5))
true

julia&gt; isvalid(Char, 0xd799)
true</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/unicode.jl#L31-L49">source</a><h3 id="Base.isvalid-Tuple{AbstractString,Integer}">
<code>Base.isvalid</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">isvalid(s::AbstractString, i::Integer) -&gt; Bool</pre>
<p>Predicate indicating whether the given index is the start of the encoding of a character in <code>s</code> or not. If <code>isvalid(s, i)</code> is true then <code>s[i]</code> will return the character whose encoding starts at that index, if it's false, then <code>s[i]</code> will raise an invalid index error or a bounds error depending on if <code>i</code> is in bounds. In order for <code>isvalid(s, i)</code> to be an O(1) function, the encoding of <code>s</code> must be <a href="https://en.wikipedia.org/wiki/Self-synchronizing_code">self-synchronizing</a> this is a basic assumption of Julia's generic string support.</p>
<p>See also: <a href="../collections/index#Base.getindex"><code>getindex</code></a>, <a href="../collections/index#Base.iterate"><code>iterate</code></a>, <a href="#Base.thisind"><code>thisind</code></a>, <a href="#Base.nextind"><code>nextind</code></a>, <a href="#Base.prevind"><code>prevind</code></a>, <a href="../collections/index#Base.length"><code>length</code></a></p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; str = "αβγdef";

julia&gt; isvalid(str, 1)
true

julia&gt; str[1]
'α': Unicode U+03b1 (category Ll: Letter, lowercase)

julia&gt; isvalid(str, 2)
false

julia&gt; str[2]
ERROR: StringIndexError("αβγdef", 2)
Stacktrace:
[...]</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/basic.jl#L87-L120">source</a><h3 id="Base.match">
<code>Base.match</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">match(r::Regex, s::AbstractString[, idx::Integer[, addopts]])</pre>
<p>Search for the first match of the regular expression <code>r</code> in <code>s</code> and return a <code>RegexMatch</code> object containing the match, or nothing if the match failed. The matching substring can be retrieved by accessing <code>m.match</code> and the captured sequences can be retrieved by accessing <code>m.captures</code> The optional <code>idx</code> argument specifies an index at which to start the search.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; rx = r"a(.)a"
r"a(.)a"

julia&gt; m = match(rx, "cabac")
RegexMatch("aba", 1="b")

julia&gt; m.captures
1-element Array{Union{Nothing, SubString{String}},1}:
 "b"

julia&gt; m.match
"aba"

julia&gt; match(rx, "cabac", 3) === nothing
true</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/regex.jl#L245-L271">source</a><h3 id="Base.eachmatch">
<code>Base.eachmatch</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">eachmatch(r::Regex, s::AbstractString; overlap::Bool=false)</pre>
<p>Search for all matches of a the regular expression <code>r</code> in <code>s</code> and return a iterator over the matches. If overlap is <code>true</code>, the matching sequences are allowed to overlap indices in the original string, otherwise they must be from distinct character ranges.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; rx = r"a.a"
r"a.a"

julia&gt; m = eachmatch(rx, "a1a2a3a")
Base.RegexMatchIterator(r"a.a", "a1a2a3a", false)

julia&gt; collect(m)
2-element Array{RegexMatch,1}:
 RegexMatch("a1a")
 RegexMatch("a3a")

julia&gt; collect(eachmatch(rx, "a1a2a3a", overlap = true))
3-element Array{RegexMatch,1}:
 RegexMatch("a1a")
 RegexMatch("a2a")
 RegexMatch("a3a")</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/regex.jl#L476-L502">source</a><h3 id="Base.isless-Tuple{AbstractString,AbstractString}">
<code>Base.isless</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">isless(a::AbstractString, b::AbstractString) -&gt; Bool</pre>
<p>Test whether string <code>a</code> comes before string <code>b</code> in alphabetical order (technically, in lexicographical order by Unicode code points).</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; isless("a", "b")
true

julia&gt; isless("β", "α")
false

julia&gt; isless("a", "a")
false</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/basic.jl#L296-L313">source</a><h3 id="Base.:==-Tuple{AbstractString,AbstractString}">
<code>Base.:==</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">==(a::AbstractString, b::AbstractString) -&gt; Bool</pre>
<p>Test whether two strings are equal character by character (technically, Unicode code point by code point).</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; "abc" == "abc"
true

julia&gt; "abc" == "αβγ"
false</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/basic.jl#L279-L293">source</a><h3 id="Base.cmp-Tuple{AbstractString,AbstractString}">
<code>Base.cmp</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">cmp(a::AbstractString, b::AbstractString) -&gt; Int</pre>
<p>Compare two strings. Return <code>0</code> if both strings have the same length and the character at each index is the same in both strings. Return <code>-1</code> if <code>a</code> is a prefix of <code>b</code>, or if <code>a</code> comes before <code>b</code> in alphabetical order. Return <code>1</code> if <code>b</code> is a prefix of <code>a</code>, or if <code>b</code> comes before <code>a</code> in alphabetical order (technically, lexicographical order by Unicode code points).</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; cmp("abc", "abc")
0

julia&gt; cmp("ab", "abc")
-1

julia&gt; cmp("abc", "ab")
1

julia&gt; cmp("ab", "ac")
-1

julia&gt; cmp("ac", "ab")
1

julia&gt; cmp("α", "a")
1

julia&gt; cmp("b", "β")
-1</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/basic.jl#L236-L268">source</a><h3 id="Base.lpad">
<code>Base.lpad</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">lpad(s, n::Integer, p::Union{AbstractChar,AbstractString}=' ') -&gt; String</pre>
<p>Stringify <code>s</code> and pad the resulting string on the left with <code>p</code> to make it <code>n</code> characters (code points) long. If <code>s</code> is already <code>n</code> characters long, an equal string is returned. Pad with spaces by default.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; lpad("March", 10)
"     March"</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/util.jl#L228-L240">source</a><h3 id="Base.rpad">
<code>Base.rpad</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">rpad(s, n::Integer, p::Union{AbstractChar,AbstractString}=' ') -&gt; String</pre>
<p>Stringify <code>s</code> and pad the resulting string on the right with <code>p</code> to make it <code>n</code> characters (code points) long. If <code>s</code> is already <code>n</code> characters long, an equal string is returned. Pad with spaces by default.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; rpad("March", 20)
"March               "</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/util.jl#L255-L267">source</a><h3 id="Base.findfirst-Tuple{AbstractString,AbstractString}">
<code>Base.findfirst</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">findfirst(pattern::AbstractString, string::AbstractString)
findfirst(pattern::Regex, string::String)</pre>
<p>Find the first occurrence of <code>pattern</code> in <code>string</code>. Equivalent to <a href="#Base.findnext-Tuple%7BAbstractString,AbstractString,Integer%7D"><code>findnext(pattern, string, firstindex(s))</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; findfirst("z", "Hello to the world") # returns nothing, but not printed in the REPL

julia&gt; findfirst("Julia", "JuliaLang")
1:5</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/search.jl#L89-L103">source</a><h3 id="Base.findnext-Tuple{AbstractString,AbstractString,Integer}">
<code>Base.findnext</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">findnext(pattern::AbstractString, string::AbstractString, start::Integer)
findnext(pattern::Regex, string::String, start::Integer)</pre>
<p>Find the next occurrence of <code>pattern</code> in <code>string</code> starting at position <code>start</code>. <code>pattern</code> can be either a string, or a regular expression, in which case <code>string</code> must be of type <code>String</code>.</p>
<p>The return value is a range of indices where the matching sequence is found, such that <code>s[findnext(x, s, i)] == x</code>:</p>
<p><code>findnext("substring", string, i)</code> == <code>start:stop</code> such that <code>string[start:stop] == "substring"</code> and <code>i &lt;= start</code>, or <code>nothing</code> if unmatched.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; findnext("z", "Hello to the world", 1) === nothing
true

julia&gt; findnext("o", "Hello to the world", 6)
8:8

julia&gt; findnext("Lang", "JuliaLang", 2)
6:9</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/search.jl#L230-L255">source</a><h3 id="Base.findlast-Tuple{AbstractString,AbstractString}">
<code>Base.findlast</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">findlast(pattern::AbstractString, string::AbstractString)</pre>
<p>Find the last occurrence of <code>pattern</code> in <code>string</code>. Equivalent to <a href="#Base.findprev-Tuple%7BAbstractString,AbstractString,Integer%7D"><code>findprev(pattern, string, lastindex(string))</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; findlast("o", "Hello to the world")
15:15

julia&gt; findfirst("Julia", "JuliaLang")
1:5</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/search.jl#L258-L272">source</a><h3 id="Base.findprev-Tuple{AbstractString,AbstractString,Integer}">
<code>Base.findprev</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">findprev(pattern::AbstractString, string::AbstractString, start::Integer)</pre>
<p>Find the previous occurrence of <code>pattern</code> in <code>string</code> starting at position <code>start</code>.</p>
<p>The return value is a range of indices where the matching sequence is found, such that <code>s[findprev(x, s, i)] == x</code>:</p>
<p><code>findprev("substring", string, i)</code> == <code>start:stop</code> such that <code>string[start:stop] == "substring"</code> and <code>stop &lt;= i</code>, or <code>nothing</code> if unmatched.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; findprev("z", "Hello to the world", 18) === nothing
true

julia&gt; findprev("o", "Hello to the world", 18)
15:15

julia&gt; findprev("Julia", "JuliaLang", 6)
1:5</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/search.jl#L406-L428">source</a><h3 id="Base.occursin">
<code>Base.occursin</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">occursin(needle::Union{AbstractString,Regex,AbstractChar}, haystack::AbstractString)</pre>
<p>Determine whether the first argument is a substring of the second. If <code>needle</code> is a regular expression, checks whether <code>haystack</code> contains a match.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; occursin("Julia", "JuliaLang is pretty cool!")
true

julia&gt; occursin('a', "JuliaLang is pretty cool!")
true

julia&gt; occursin(r"a.a", "aba")
true

julia&gt; occursin(r"a.a", "abba")
false</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/search.jl#L431-L451">source</a><h3 id="Base.reverse-Tuple{Union{SubString{String}, String}}">
<code>Base.reverse</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">reverse(s::AbstractString) -&gt; AbstractString</pre>
<p>Reverses a string. Technically, this function reverses the codepoints in a string and its main utility is for reversed-order string processing, especially for reversed regular-expression searches. See also <a href="../arrays/index#Base.reverseind"><code>reverseind</code></a> to convert indices in <code>s</code> to indices in <code>reverse(s)</code> and vice-versa, and <code>graphemes</code> from module <code>Unicode</code> to operate on user-visible "characters" (graphemes) rather than codepoints. See also <a href="../iterators/index#Base.Iterators.reverse"><code>Iterators.reverse</code></a> for reverse-order iteration without making a copy. Custom string types must implement the <code>reverse</code> function themselves and should typically return a string with the same type and encoding. If they return a string with a different encoding, they must also override <code>reverseind</code> for that string type to satisfy <code>s[reverseind(s,i)] == reverse(s)[i]</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; reverse("JuliaLang")
"gnaLailuJ"

julia&gt; reverse("ax̂e") # combining characters can lead to surprising results
"êxa"

julia&gt; using Unicode

julia&gt; join(reverse(collect(graphemes("ax̂e")))) # reverses graphemes
"ex̂a"</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/substring.jl#L113-L140">source</a><h3 id="Base.replace-Tuple{AbstractString,Pair}">
<code>Base.replace</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">replace(s::AbstractString, pat=&gt;r; [count::Integer])</pre>
<p>Search for the given pattern <code>pat</code> in <code>s</code>, and replace each occurrence with <code>r</code>. If <code>count</code> is provided, replace at most <code>count</code> occurrences. <code>pat</code> may be a single character, a vector or a set of characters, a string, or a regular expression. If <code>r</code> is a function, each occurrence is replaced with <code>r(s)</code> where <code>s</code> is the matched substring (when <code>pat</code>is a <code>Regex</code> or <code>AbstractString</code>) or character (when <code>pat</code> is an <code>AbstractChar</code> or a collection of <code>AbstractChar</code>). If <code>pat</code> is a regular expression and <code>r</code> is a <a href="#Base.SubstitutionString"><code>SubstitutionString</code></a>, then capture group references in <code>r</code> are replaced with the corresponding matched text. To remove instances of <code>pat</code> from <code>string</code>, set <code>r</code> to the empty <code>String</code> (<code>""</code>).</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; replace("Python is a programming language.", "Python" =&gt; "Julia")
"Julia is a programming language."

julia&gt; replace("The quick foxes run quickly.", "quick" =&gt; "slow", count=1)
"The slow foxes run quickly."

julia&gt; replace("The quick foxes run quickly.", "quick" =&gt; "", count=1)
"The  foxes run quickly."

julia&gt; replace("The quick foxes run quickly.", r"fox(es)?" =&gt; s"bus\1")
"The quick buses run quickly."</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/util.jl#L462-L490">source</a><h3 id="Base.split">
<code>Base.split</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">split(str::AbstractString, dlm; limit::Integer=0, keepempty::Bool=true)
split(str::AbstractString; limit::Integer=0, keepempty::Bool=false)</pre>
<p>Split <code>str</code> into an array of substrings on occurrences of the delimiter(s) <code>dlm</code>. <code>dlm</code> can be any of the formats allowed by <a href="#Base.findnext-Tuple%7BAbstractString,AbstractString,Integer%7D"><code>findnext</code></a>'s first argument (i.e. as a string, regular expression or a function), or as a single character or collection of characters.</p>
<p>If <code>dlm</code> is omitted, it defaults to <a href="#Base.Unicode.isspace"><code>isspace</code></a>.</p>
<p>The optional keyword arguments are:</p>
<ul>
<li>
<code>limit</code>: the maximum size of the result. <code>limit=0</code> implies no maximum (default)</li>
<li>
<code>keepempty</code>: whether empty fields should be kept in the result. Default is <code>false</code> without a <code>dlm</code> argument, <code>true</code> with a <code>dlm</code> argument.</li>
</ul>
<p>See also <a href="#Base.rsplit"><code>rsplit</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; a = "Ma.rch"
"Ma.rch"

julia&gt; split(a,".")
2-element Array{SubString{String},1}:
 "Ma"
 "rch"</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/util.jl#L282-L310">source</a><h3 id="Base.rsplit">
<code>Base.rsplit</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">rsplit(s::AbstractString; limit::Integer=0, keepempty::Bool=false)
rsplit(s::AbstractString, chars; limit::Integer=0, keepempty::Bool=true)</pre>
<p>Similar to <a href="#Base.split"><code>split</code></a>, but starting from the end of the string.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; a = "M.a.r.c.h"
"M.a.r.c.h"

julia&gt; rsplit(a,".")
5-element Array{SubString{String},1}:
 "M"
 "a"
 "r"
 "c"
 "h"

julia&gt; rsplit(a,".";limit=1)
1-element Array{SubString{String},1}:
 "M.a.r.c.h"

julia&gt; rsplit(a,".";limit=2)
2-element Array{SubString{String},1}:
 "M.a.r.c"
 "h"</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/util.jl#L356-L384">source</a><h3 id="Base.strip">
<code>Base.strip</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">strip([pred=isspace,] str::AbstractString)
strip(str::AbstractString, chars)</pre>
<p>Remove leading and trailing characters from <code>str</code>, either those specified by <code>chars</code> or those for which the function <code>pred</code> returns <code>true</code>.</p>
<p>The default behaviour is to remove leading whitespace and delimiters: see <a href="#Base.Unicode.isspace"><code>isspace</code></a> for precise details.</p>
<p>The optional <code>chars</code> argument specifies which characters to remove: it can be a single character, vector or set of characters.</p>
<div class="admonition compat">
<div class="admonition-title">Julia 1.2</div>
<div class="admonition-text"><p>The method which accepts a predicate function requires Julia 1.2 or later.</p></div>
</div>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; strip("{3, 5}\n", ['{', '}', '\n'])
"3, 5"</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/util.jl#L200-L221">source</a><h3 id="Base.lstrip">
<code>Base.lstrip</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">lstrip([pred=isspace,] str::AbstractString)
lstrip(str::AbstractString, chars)</pre>
<p>Remove leading characters from <code>str</code>, either those specified by <code>chars</code> or those for which the function <code>pred</code> returns <code>true</code>.</p>
<p>The default behaviour is to remove leading whitespace and delimiters: see <a href="#Base.Unicode.isspace"><code>isspace</code></a> for precise details.</p>
<p>The optional <code>chars</code> argument specifies which characters to remove: it can be a single character, or a vector or set of characters.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; a = lpad("March", 20)
"               March"

julia&gt; lstrip(a)
"March"</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/util.jl#L137-L158">source</a><h3 id="Base.rstrip">
<code>Base.rstrip</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">rstrip([pred=isspace,] str::AbstractString)
rstrip(str::AbstractString, chars)</pre>
<p>Remove trailing characters from <code>str</code>, either those specified by <code>chars</code> or those for which the function <code>pred</code> returns <code>true</code>.</p>
<p>The default behaviour is to remove trailing whitespace and delimiters: see <a href="#Base.Unicode.isspace"><code>isspace</code></a> for precise details.</p>
<p>The optional <code>chars</code> argument specifies which characters to remove: it can be a single character, or a vector or set of characters.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; a = rpad("March", 20)
"March               "

julia&gt; rstrip(a)
"March"</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/util.jl#L169-L190">source</a><h3 id="Base.startswith">
<code>Base.startswith</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">startswith(s::AbstractString, prefix::AbstractString)</pre>
<p>Return <code>true</code> if <code>s</code> starts with <code>prefix</code>. If <code>prefix</code> is a vector or set of characters, test whether the first character of <code>s</code> belongs to that set.</p>
<p>See also <a href="#Base.endswith"><code>endswith</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; startswith("JuliaLang", "Julia")
true</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/util.jl#L7-L20">source</a><pre data-language="julia">startswith(s::AbstractString, prefix::Regex)</pre>
<p>Return <code>true</code> if <code>s</code> starts with the regex pattern, <code>prefix</code>.</p>
<div class="admonition note">
<div class="admonition-title">Note</div>
<div class="admonition-text"><p><code>startswith</code> does not compile the anchoring into the regular expression, but instead passes the anchoring as <code>match_option</code> to PCRE. If compile time is amortized, <code>occursin(r"^...", s)</code> is faster than <code>startswith(s, r"...")</code>.</p></div>
</div>
<p>See also <a href="#Base.occursin"><code>occursin</code></a> and <a href="#Base.endswith"><code>endswith</code></a>.</p>
<div class="admonition compat">
<div class="admonition-title">Julia 1.2</div>
<div class="admonition-text"><p>This method requires at least Julia 1.2.</p></div>
</div>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; startswith("JuliaLang", r"Julia|Romeo")
true</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/regex.jl#L177-L198">source</a><h3 id="Base.endswith">
<code>Base.endswith</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">endswith(s::AbstractString, suffix::AbstractString)</pre>
<p>Return <code>true</code> if <code>s</code> ends with <code>suffix</code>. If <code>suffix</code> is a vector or set of characters, test whether the last character of <code>s</code> belongs to that set.</p>
<p>See also <a href="#Base.startswith"><code>startswith</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; endswith("Sunday", "day")
true</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/util.jl#L27-L40">source</a><pre data-language="julia">endswith(s::AbstractString, suffix::Regex)</pre>
<p>Return <code>true</code> if <code>s</code> ends with the regex pattern, <code>suffix</code>.</p>
<div class="admonition note">
<div class="admonition-title">Note</div>
<div class="admonition-text"><p><code>endswith</code> does not compile the anchoring into the regular expression, but instead passes the anchoring as <code>match_option</code> to PCRE. If compile time is amortized, <code>occursin(r"...$", s)</code> is faster than <code>endswith(s, r"...")</code>.</p></div>
</div>
<p>See also <a href="#Base.occursin"><code>occursin</code></a> and <a href="#Base.startswith"><code>startswith</code></a>.</p>
<div class="admonition compat">
<div class="admonition-title">Julia 1.2</div>
<div class="admonition-text"><p>This method requires at least Julia 1.2.</p></div>
</div>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; endswith("JuliaLang", r"Lang|Roberts")
true</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/regex.jl#L211-L232">source</a><h3 id="Base.first-Tuple{AbstractString,Integer}">
<code>Base.first</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">first(s::AbstractString, n::Integer)</pre>
<p>Get a string consisting of the first <code>n</code> characters of <code>s</code>.</p>
<pre data-language="julia">julia&gt; first("∀ϵ≠0: ϵ²&gt;0", 0)
""

julia&gt; first("∀ϵ≠0: ϵ²&gt;0", 1)
"∀"

julia&gt; first("∀ϵ≠0: ϵ²&gt;0", 3)
"∀ϵ≠"</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/basic.jl#L590-L605">source</a><h3 id="Base.last-Tuple{AbstractString,Integer}">
<code>Base.last</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">last(s::AbstractString, n::Integer)</pre>
<p>Get a string consisting of the last <code>n</code> characters of <code>s</code>.</p>
<pre data-language="julia">julia&gt; last("∀ϵ≠0: ϵ²&gt;0", 0)
""

julia&gt; last("∀ϵ≠0: ϵ²&gt;0", 1)
"0"

julia&gt; last("∀ϵ≠0: ϵ²&gt;0", 3)
"²&gt;0"</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/basic.jl#L608-L623">source</a><h3 id="Base.Unicode.uppercase">
<code>Base.Unicode.uppercase</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">uppercase(s::AbstractString)</pre>
<p>Return <code>s</code> with all characters converted to uppercase.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; uppercase("Julia")
"JULIA"</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/unicode.jl#L507-L517">source</a><h3 id="Base.Unicode.lowercase">
<code>Base.Unicode.lowercase</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">lowercase(s::AbstractString)</pre>
<p>Return <code>s</code> with all characters converted to lowercase.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; lowercase("STRINGS AND THINGS")
"strings and things"</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/unicode.jl#L520-L530">source</a><h3 id="Base.Unicode.titlecase">
<code>Base.Unicode.titlecase</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">titlecase(s::AbstractString; [wordsep::Function], strict::Bool=true) -&gt; String</pre>
<p>Capitalize the first character of each word in <code>s</code>; if <code>strict</code> is true, every other character is converted to lowercase, otherwise they are left unchanged. By default, all non-letters are considered as word separators; a predicate can be passed as the <code>wordsep</code> keyword to determine which characters should be considered as word separators. See also <a href="#Base.Unicode.uppercasefirst"><code>uppercasefirst</code></a> to capitalize only the first character in <code>s</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; titlecase("the JULIA programming language")
"The Julia Programming Language"

julia&gt; titlecase("ISS - international space station", strict=false)
"ISS - International Space Station"

julia&gt; titlecase("a-a b-b", wordsep = c-&gt;c==' ')
"A-a B-b"</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/unicode.jl#L533-L556">source</a><h3 id="Base.Unicode.uppercasefirst">
<code>Base.Unicode.uppercasefirst</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">uppercasefirst(s::AbstractString) -&gt; String</pre>
<p>Return <code>s</code> with the first character converted to uppercase (technically "title case" for Unicode). See also <a href="#Base.Unicode.titlecase"><code>titlecase</code></a> to capitalize the first character of every word in <code>s</code>.</p>
<p>See also: <a href="#Base.Unicode.lowercasefirst"><code>lowercasefirst</code></a>, <a href="#Base.Unicode.uppercase"><code>uppercase</code></a>, <a href="#Base.Unicode.lowercase"><code>lowercase</code></a>, <a href="#Base.Unicode.titlecase"><code>titlecase</code></a></p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; uppercasefirst("python")
"Python"</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/unicode.jl#L572-L587">source</a><h3 id="Base.Unicode.lowercasefirst">
<code>Base.Unicode.lowercasefirst</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">lowercasefirst(s::AbstractString)</pre>
<p>Return <code>s</code> with the first character converted to lowercase.</p>
<p>See also: <a href="#Base.Unicode.uppercasefirst"><code>uppercasefirst</code></a>, <a href="#Base.Unicode.uppercase"><code>uppercase</code></a>, <a href="#Base.Unicode.lowercase"><code>lowercase</code></a>, <a href="#Base.Unicode.titlecase"><code>titlecase</code></a></p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; lowercasefirst("Julia")
"julia"</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/unicode.jl#L596-L609">source</a><h3 id="Base.join">
<code>Base.join</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">join([io::IO,] strings, delim, [last])</pre>
<p>Join an array of <code>strings</code> into a single string, inserting the given delimiter between adjacent strings. If <code>last</code> is given, it will be used instead of <code>delim</code> between the last two strings. If <code>io</code> is given, the result is written to <code>io</code> rather than returned as as a <code>String</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; join(["apples", "bananas", "pineapples"], ", ", " and ")
"apples, bananas and pineapples"</pre>
<p><code>strings</code> can be any iterable over elements <code>x</code> which are convertible to strings via <code>print(io::IOBuffer, x)</code>. <code>strings</code> will be printed to <code>io</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/io.jl#L248-L264">source</a><h3 id="Base.chop">
<code>Base.chop</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">chop(s::AbstractString; head::Integer = 0, tail::Integer = 1)</pre>
<p>Remove the first <code>head</code> and the last <code>tail</code> characters from <code>s</code>. The call <code>chop(s)</code> removes the last character from <code>s</code>. If it is requested to remove more characters than <code>length(s)</code> then an empty string is returned.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; a = "March"
"March"

julia&gt; chop(a)
"Marc"

julia&gt; chop(a, head = 1, tail = 2)
"ar"

julia&gt; chop(a, head = 5, tail = 5)
""</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/util.jl#L75-L97">source</a><h3 id="Base.chomp">
<code>Base.chomp</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">chomp(s::AbstractString)</pre>
<p>Remove a single trailing newline from a string.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; chomp("Hello\n")
"Hello"</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/util.jl#L108-L118">source</a><h3 id="Base.thisind">
<code>Base.thisind</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">thisind(s::AbstractString, i::Integer) -&gt; Int</pre>
<p>If <code>i</code> is in bounds in <code>s</code> return the index of the start of the character whose encoding code unit <code>i</code> is part of. In other words, if <code>i</code> is the start of a character, return <code>i</code>; if <code>i</code> is not the start of a character, rewind until the start of a character and return that index. If <code>i</code> is equal to 0 or <code>ncodeunits(s)+1</code> return <code>i</code>. In all other cases throw <code>BoundsError</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; thisind("α", 0)
0

julia&gt; thisind("α", 1)
1

julia&gt; thisind("α", 2)
1

julia&gt; thisind("α", 3)
3

julia&gt; thisind("α", 4)
ERROR: BoundsError: attempt to access "α"
  at index [4]
[...]

julia&gt; thisind("α", -1)
ERROR: BoundsError: attempt to access "α"
  at index [-1]
[...]</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/basic.jl#L363-L396">source</a><h3 id="Base.nextind">
<code>Base.nextind</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">nextind(str::AbstractString, i::Integer, n::Integer=1) -&gt; Int</pre>
<ul>
<li>
<p>Case <code>n == 1</code></p>
<p>If <code>i</code> is in bounds in <code>s</code> return the index of the start of the character whose encoding starts after index <code>i</code>. In other words, if <code>i</code> is the start of a character, return the start of the next character; if <code>i</code> is not the start of a character, move forward until the start of a character and return that index. If <code>i</code> is equal to <code>0</code> return <code>1</code>. If <code>i</code> is in bounds but greater or equal to <code>lastindex(str)</code> return <code>ncodeunits(str)+1</code>. Otherwise throw <code>BoundsError</code>.</p>
</li>
<li>
<p>Case <code>n &gt; 1</code></p>
<p>Behaves like applying <code>n</code> times <code>nextind</code> for <code>n==1</code>. The only difference is that if <code>n</code> is so large that applying <code>nextind</code> would reach <code>ncodeunits(str)+1</code> then each remaining iteration increases the returned value by <code>1</code>. This means that in this case <code>nextind</code> can return a value greater than <code>ncodeunits(str)+1</code>.</p>
</li>
<li>
<p>Case <code>n == 0</code></p>
<p>Return <code>i</code> only if <code>i</code> is a valid index in <code>s</code> or is equal to <code>0</code>. Otherwise <code>StringIndexError</code> or <code>BoundsError</code> is thrown.</p>
</li>
</ul>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; nextind("α", 0)
1

julia&gt; nextind("α", 1)
3

julia&gt; nextind("α", 3)
ERROR: BoundsError: attempt to access "α"
  at index [3]
[...]

julia&gt; nextind("α", 0, 2)
3

julia&gt; nextind("α", 1, 2)
4</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/basic.jl#L469-L513">source</a><h3 id="Base.prevind">
<code>Base.prevind</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">prevind(str::AbstractString, i::Integer, n::Integer=1) -&gt; Int</pre>
<ul>
<li>
<p>Case <code>n == 1</code></p>
<p>If <code>i</code> is in bounds in <code>s</code> return the index of the start of the character whose encoding starts before index <code>i</code>. In other words, if <code>i</code> is the start of a character, return the start of the previous character; if <code>i</code> is not the start of a character, rewind until the start of a character and return that index. If <code>i</code> is equal to <code>1</code> return <code>0</code>. If <code>i</code> is equal to <code>ncodeunits(str)+1</code> return <code>lastindex(str)</code>. Otherwise throw <code>BoundsError</code>.</p>
</li>
<li>
<p>Case <code>n &gt; 1</code></p>
<p>Behaves like applying <code>n</code> times <code>prevind</code> for <code>n==1</code>. The only difference is that if <code>n</code> is so large that applying <code>prevind</code> would reach <code>0</code> then each remaining iteration decreases the returned value by <code>1</code>. This means that in this case <code>prevind</code> can return a negative value.</p>
</li>
<li>
<p>Case <code>n == 0</code></p>
<p>Return <code>i</code> only if <code>i</code> is a valid index in <code>str</code> or is equal to <code>ncodeunits(str)+1</code>. Otherwise <code>StringIndexError</code> or <code>BoundsError</code> is thrown.</p>
</li>
</ul>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; prevind("α", 3)
1

julia&gt; prevind("α", 1)
0

julia&gt; prevind("α", 0)
ERROR: BoundsError: attempt to access "α"
  at index [0]
[...]

julia&gt; prevind("α", 2, 2)
0

julia&gt; prevind("α", 2, 3)
-1</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/basic.jl#L409-L453">source</a><h3 id="Base.Unicode.textwidth">
<code>Base.Unicode.textwidth</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">textwidth(c)</pre>
<p>Give the number of columns needed to print a character.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; textwidth('α')
1

julia&gt; textwidth('⛵')
2</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/unicode.jl#L213-L226">source</a><pre data-language="julia">textwidth(s::AbstractString)</pre>
<p>Give the number of columns needed to print a string.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; textwidth("March")
5</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/unicode.jl#L232-L242">source</a><h3 id="Base.isascii">
<code>Base.isascii</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">isascii(c::Union{AbstractChar,AbstractString}) -&gt; Bool</pre>
<p>Test whether a character belongs to the ASCII character set, or whether this is true for all elements of a string.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; isascii('a')
true

julia&gt; isascii('α')
false

julia&gt; isascii("abc")
true

julia&gt; isascii("αβγ")
false</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/basic.jl#L542-L562">source</a><h3 id="Base.Unicode.iscntrl">
<code>Base.Unicode.iscntrl</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">iscntrl(c::AbstractChar) -&gt; Bool</pre>
<p>Tests whether a character is a control character. Control characters are the non-printing characters of the Latin-1 subset of Unicode.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; iscntrl('\x01')
true

julia&gt; iscntrl('a')
false</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/unicode.jl#L405-L419">source</a><h3 id="Base.Unicode.isdigit">
<code>Base.Unicode.isdigit</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">isdigit(c::AbstractChar) -&gt; Bool</pre>
<p>Tests whether a character is a decimal digit (0-9).</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; isdigit('❤')
false

julia&gt; isdigit('9')
true

julia&gt; isdigit('α')
false</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/unicode.jl#L336-L352">source</a><h3 id="Base.Unicode.isletter">
<code>Base.Unicode.isletter</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">isletter(c::AbstractChar) -&gt; Bool</pre>
<p>Test whether a character is a letter. A character is classified as a letter if it belongs to the Unicode general category Letter, i.e. a character whose category code begins with 'L'.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; isletter('❤')
false

julia&gt; isletter('α')
true

julia&gt; isletter('9')
false</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/unicode.jl#L355-L373">source</a><h3 id="Base.Unicode.islowercase">
<code>Base.Unicode.islowercase</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">islowercase(c::AbstractChar) -&gt; Bool</pre>
<p>Tests whether a character is a lowercase letter. A character is classified as lowercase if it belongs to Unicode category Ll, Letter: Lowercase.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; islowercase('α')
true

julia&gt; islowercase('Γ')
false

julia&gt; islowercase('❤')
false</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/unicode.jl#L276-L294">source</a><h3 id="Base.Unicode.isnumeric">
<code>Base.Unicode.isnumeric</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">isnumeric(c::AbstractChar) -&gt; Bool</pre>
<p>Tests whether a character is numeric. A character is classified as numeric if it belongs to the Unicode general category Number, i.e. a character whose category code begins with 'N'.</p>
<p>Note that this broad category includes characters such as ¾ and ௰. Use <a href="#Base.Unicode.isdigit"><code>isdigit</code></a> to check whether a character a decimal digit between 0 and 9.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; isnumeric('௰')
true

julia&gt; isnumeric('9')
true

julia&gt; isnumeric('α')
false

julia&gt; isnumeric('❤')
false</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/unicode.jl#L376-L400">source</a><h3 id="Base.Unicode.isprint">
<code>Base.Unicode.isprint</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">isprint(c::AbstractChar) -&gt; Bool</pre>
<p>Tests whether a character is printable, including spaces, but not a control character.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; isprint('\x01')
false

julia&gt; isprint('A')
true</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/unicode.jl#L470-L483">source</a><h3 id="Base.Unicode.ispunct">
<code>Base.Unicode.ispunct</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">ispunct(c::AbstractChar) -&gt; Bool</pre>
<p>Tests whether a character belongs to the Unicode general category Punctuation, i.e. a character whose category code begins with 'P'.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; ispunct('α')
false

julia&gt; ispunct('/')
true

julia&gt; ispunct(';')
true</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/unicode.jl#L422-L439">source</a><h3 id="Base.Unicode.isspace">
<code>Base.Unicode.isspace</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">isspace(c::AbstractChar) -&gt; Bool</pre>
<p>Tests whether a character is any whitespace character. Includes ASCII characters '\t', '\n', '\v', '\f', '\r', and ' ', Latin-1 character U+0085, and characters in Unicode category Zs.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; isspace('\n')
true

julia&gt; isspace('\r')
true

julia&gt; isspace(' ')
true

julia&gt; isspace('\x20')
true</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/unicode.jl#L444-L465">source</a><h3 id="Base.Unicode.isuppercase">
<code>Base.Unicode.isuppercase</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">isuppercase(c::AbstractChar) -&gt; Bool</pre>
<p>Tests whether a character is an uppercase letter. A character is classified as uppercase if it belongs to Unicode category Lu, Letter: Uppercase, or Lt, Letter: Titlecase.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; isuppercase('γ')
false

julia&gt; isuppercase('Γ')
true

julia&gt; isuppercase('❤')
false</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/unicode.jl#L299-L317">source</a><h3 id="Base.Unicode.isxdigit">
<code>Base.Unicode.isxdigit</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">isxdigit(c::AbstractChar) -&gt; Bool</pre>
<p>Test whether a character is a valid hexadecimal digit. Note that this does not include <code>x</code> (as in the standard <code>0x</code> prefix).</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; isxdigit('a')
true

julia&gt; isxdigit('x')
false</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/unicode.jl#L488-L502">source</a><h3 id="Base.escape_string">
<code>Base.escape_string</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">escape_string(str::AbstractString[, esc])::AbstractString
escape_string(io, str::AbstractString[, esc::])::Nothing</pre>
<p>General escaping of traditional C and Unicode escape sequences. The first form returns the escaped string, the second prints the result to <code>io</code>.</p>
<p>Backslashes (<code>\</code>) are escaped with a double-backslash (<code>"\\"</code>). Non-printable characters are escaped either with their standard C escape codes, <code>"\0"</code> for NUL (if unambiguous), unicode code point (<code>"\u"</code> prefix) or hex (<code>"\x"</code> prefix).</p>
<p>The optional <code>esc</code> argument specifies any additional characters that should also be escaped by a prepending backslash (<code>"</code> is also escaped by default in the first form).</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; escape_string("aaa\nbbb")
"aaa\\nbbb"

julia&gt; escape_string("\xfe\xff") # invalid utf-8
"\\xfe\\xff"

julia&gt; escape_string(string('\u2135','\0')) # unambiguous
"ℵ\\0"

julia&gt; escape_string(string('\u2135','\0','0')) # \0 would be ambiguous
"ℵ\\x000"</pre>
<p><strong>See also</strong></p>
<p><a href="#Base.unescape_string"><code>unescape_string</code></a> for the reverse operation.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/io.jl#L301-L332">source</a><h3 id="Base.unescape_string">
<code>Base.unescape_string</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">unescape_string(str::AbstractString)::AbstractString
unescape_string(io, str::AbstractString)::Nothing</pre>
<p>General unescaping of traditional C and Unicode escape sequences. The first form returns the escaped string, the second prints the result to <code>io</code>.</p>
<p>The following escape sequences are recognised:</p>
<ul>
<li>Escaped backslash (<code>\\</code>)</li>
<li>Escaped double-quote (<code>\"</code>)</li>
<li>Standard C escape sequences (<code>\a</code>, <code>\b</code>, <code>\t</code>, <code>\n</code>, <code>\v</code>, <code>\f</code>, <code>\r</code>, <code>\e</code>)</li>
<li>Unicode code points (<code>\u</code> or <code>\U</code> prefixes with 1-4 trailing hex digits)</li>
<li>Hex bytes (<code>\x</code> with 1-2 trailing hex digits)</li>
<li>Octal bytes (<code>\</code> with 1-3 trailing octal digits)</li>
</ul>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; unescape_string("aaa\\nbbb") # C escape sequence
"aaa\nbbb"

julia&gt; unescape_string("\\u03c0") # unicode
"π"

julia&gt; unescape_string("\\101") # octal
"A"</pre>
<p><strong>See also</strong></p>
<p><a href="#Base.escape_string"><code>escape_string</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/io.jl#L371-L400">source</a><div class="_attribution">
  <p class="_attribution-p">
    © 2009–2019 Jeff Bezanson, Stefan Karpinski, Viral B. Shah, and other contributors<br>Licensed under the MIT License.<br>
    <a href="https://docs.julialang.org/en/v1.2.0/base/strings/" class="_attribution-link">https://docs.julialang.org/en/v1.2.0/base/strings/</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
