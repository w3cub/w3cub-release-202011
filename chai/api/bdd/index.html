
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>BDD - Chai - W3cubDocs</title>
  
  <meta name="description" content="The BDD styles are expect and should. Both use the same chainable language to construct assertions, but they differ in the way an assertion is &hellip;">
  <meta name="keywords" content="bdd, chai">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/chai/api/bdd/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/chai.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/chai/" class="_nav-link" title="" style="margin-left:0;">Chai</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _simple">
				
				
<h1 id="bdd">BDD</h1> <p>The BDD styles are <code class="language-js highlighter-rouge"><span class="nx">expect</span></code> and <code class="language-js highlighter-rouge"><span class="nx">should</span></code>. Both use the same chainable language to construct assertions, but they differ in the way an assertion is initially constructed. Check out the <a href="../../guide/styles/index">Style Guide</a> for a comparison.</p> <h2>API Reference</h2> <div id="method_language-chains" class="api_method_wrapper"> <h3 id="language-chains">Language Chains</h3>  <p>The following are provided as chainable getters to improve the readability of your assertions.</p> <p><strong>Chains</strong></p> <ul> <li>to</li> <li>be</li> <li>been</li> <li>is</li> <li>that</li> <li>which</li> <li>and</li> <li>has</li> <li>have</li> <li>with</li> <li>at</li> <li>of</li> <li>same</li> <li>but</li> <li>does</li> <li>still</li> </ul> </div> <div id="method_not" class="api_method_wrapper"> <h3 id="not">.not</h3>  <p>Negates all assertions that follow in the chain.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(function () {}).to.not.throw();
expect({a: 1}).to.not.have.property('b');
expect([1, 2]).to.be.an('array').that.does.not.include(3);
</pre></div></div> <p>Just because you can negate any assertion with <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">not</span></code> doesn’t mean you should. With great power comes great responsibility. It’s often best to assert that the one expected output was produced, rather than asserting that one of countless unexpected outputs wasn’t produced. See individual assertions for specific guidance.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(2).to.equal(2); // Recommended
expect(2).to.not.equal(1); // Not recommended
</pre></div></div> </div> <div id="method_deep" class="api_method_wrapper"> <h3 id="deep">.deep</h3>  <p>Causes all <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">equal</span></code>, <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">include</span></code>, <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">members</span></code>, <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">keys</span></code>, and <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">property</span></code> assertions that follow in the chain to use deep equality instead of strict (<code class="language-js highlighter-rouge"><span class="o">===</span></code>) equality. See the <code class="language-js highlighter-rouge"><span class="nx">deep</span><span class="o">-</span><span class="nx">eql</span></code> project page for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">// Target object deeply (but not strictly) equals `{a: 1}`
expect({a: 1}).to.deep.equal({a: 1});
expect({a: 1}).to.not.equal({a: 1});

// Target array deeply (but not strictly) includes `{a: 1}`
expect([{a: 1}]).to.deep.include({a: 1});
expect([{a: 1}]).to.not.include({a: 1});

// Target object deeply (but not strictly) includes `x: {a: 1}`
expect({x: {a: 1}}).to.deep.include({x: {a: 1}});
expect({x: {a: 1}}).to.not.include({x: {a: 1}});

// Target array deeply (but not strictly) has member `{a: 1}`
expect([{a: 1}]).to.have.deep.members([{a: 1}]);
expect([{a: 1}]).to.not.have.members([{a: 1}]);

// Target set deeply (but not strictly) has key `{a: 1}`
expect(new Set([{a: 1}])).to.have.deep.keys([{a: 1}]);
expect(new Set([{a: 1}])).to.not.have.keys([{a: 1}]);

// Target object deeply (but not strictly) has property `x: {a: 1}`
expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});
expect({x: {a: 1}}).to.not.have.property('x', {a: 1});
</pre></div></div> </div> <div id="method_nested" class="api_method_wrapper"> <h3 id="nested">.nested</h3>  <p>Enables dot- and bracket-notation in all <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">property</span></code> and <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">include</span></code> assertions that follow in the chain.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');
expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});
</pre></div></div> <p>If <code class="language-js highlighter-rouge"><span class="p">.</span></code> or <code class="language-js highlighter-rouge"><span class="p">[]</span></code> are part of an actual property name, they can be escaped by adding two backslashes before them.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\.a.\\[b\\]');
expect({'.a': {'[b]': 'x'}}).to.nested.include({'\\.a.\\[b\\]': 'x'});
</pre></div></div> <p><code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">nested</span></code> cannot be combined with <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">own</span></code>.</p> </div> <div id="method_own" class="api_method_wrapper"> <h3 id="own">.own</h3>  <p>Causes all <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">property</span></code> and <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">include</span></code> assertions that follow in the chain to ignore inherited properties.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">Object.prototype.b = 2;

expect({a: 1}).to.have.own.property('a');
expect({a: 1}).to.have.property('b');
expect({a: 1}).to.not.have.own.property('b');

expect({a: 1}).to.own.include({a: 1});
expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});
</pre></div></div> <p><code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">own</span></code> cannot be combined with <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">nested</span></code>.</p> </div> <div id="method_ordered" class="api_method_wrapper"> <h3 id="ordered">.ordered</h3>  <p>Causes all <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">members</span></code> assertions that follow in the chain to require that members be in the same order.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect([1, 2]).to.have.ordered.members([1, 2])
  .but.not.have.ordered.members([2, 1]);
</pre></div></div> <p>When <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">include</span></code> and <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">ordered</span></code> are combined, the ordering begins at the start of both arrays.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect([1, 2, 3]).to.include.ordered.members([1, 2])
  .but.not.include.ordered.members([2, 3]);
</pre></div></div> </div> <div id="method_any" class="api_method_wrapper"> <h3 id="any">.any</h3>  <p>Causes all <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">keys</span></code> assertions that follow in the chain to only require that the target have at least one of the given keys. This is the opposite of <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">all</span></code>, which requires that the target have all of the given keys.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');
</pre></div></div> <p>See the <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">keys</span></code> doc for guidance on when to use <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">any</span></code> or <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">all</span></code>.</p> </div> <div id="method_all" class="api_method_wrapper"> <h3 id="all">.all</h3>  <p>Causes all <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">keys</span></code> assertions that follow in the chain to require that the target have all of the given keys. This is the opposite of <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">any</span></code>, which only requires that the target have at least one of the given keys.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
</pre></div></div> <p>Note that <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">all</span></code> is used by default when neither <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">all</span></code> nor <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">any</span></code> are added earlier in the chain. However, it’s often best to add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">all</span></code> anyway because it improves readability.</p> <p>See the <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">keys</span></code> doc for guidance on when to use <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">any</span></code> or <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">all</span></code>.</p> </div> <div id="method_a" class="api_method_wrapper"> <h3 id="atype-msg">.a(type[, msg])</h3> <ul class="tags"> <li class="tag">
<span class="type">@param</span> <span class="types">{ String }</span> <span class="name">type</span> 
</li> <li class="tag">
<span class="type">@param</span> <span class="types">{ String }</span> <span class="name">msg</span> <span class="desc">_optional_</span>
</li> </ul> <p>Asserts that the target’s type is equal to the given string <code class="language-js highlighter-rouge"><span class="nx">type</span></code>. Types are case insensitive. See the <code class="language-js highlighter-rouge"><span class="nx">type</span><span class="o">-</span><span class="nx">detect</span></code> project page for info on the type detection algorithm: https://github.com/chaijs/type-detect.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect('foo').to.be.a('string');
expect({a: 1}).to.be.an('object');
expect(null).to.be.a('null');
expect(undefined).to.be.an('undefined');
expect(new Error).to.be.an('error');
expect(Promise.resolve()).to.be.a('promise');
expect(new Float32Array).to.be.a('float32array');
expect(Symbol()).to.be.a('symbol');
</pre></div></div> <p><code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">a</span></code> supports objects that have a custom type set via <code class="language-js highlighter-rouge"><span class="nb">Symbol</span><span class="p">.</span><span class="nx">toStringTag</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">var myObj = {
  [Symbol.toStringTag]: 'myCustomType'
};

expect(myObj).to.be.a('myCustomType').but.not.an('object');
</pre></div></div> <p>It’s often best to use <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">a</span></code> to check a target’s type before making more assertions on the same target. That way, you avoid unexpected behavior from any assertion that does different things based on the target’s type.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect([1, 2, 3]).to.be.an('array').that.includes(2);
expect([]).to.be.an('array').that.is.empty;
</pre></div></div> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">not</span></code> earlier in the chain to negate <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">a</span></code>. However, it’s often best to assert that the target is the expected type, rather than asserting that it isn’t one of many unexpected types.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect('foo').to.be.a('string'); // Recommended
expect('foo').to.not.be.an('array'); // Not recommended
</pre></div></div> <p><code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">a</span></code> accepts an optional <code class="language-js highlighter-rouge"><span class="nx">msg</span></code> argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to <code class="language-js highlighter-rouge"><span class="nx">expect</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(1).to.be.a('string', 'nooo why fail??');
expect(1, 'nooo why fail??').to.be.a('string');
</pre></div></div> <p><code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">a</span></code> can also be used as a language chain to improve the readability of your assertions.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect({b: 2}).to.have.a.property('b');
</pre></div></div> <p>The alias <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">an</span></code> can be used interchangeably with <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">a</span></code>.</p> </div> <div id="method_include" class="api_method_wrapper"> <h3 id="includeval-msg">.include(val[, msg])</h3> <ul class="tags"> <li class="tag">
<span class="type">@param</span> <span class="types">{ Mixed }</span> <span class="name">val</span> 
</li> <li class="tag">
<span class="type">@param</span> <span class="types">{ String }</span> <span class="name">msg</span> <span class="desc">_optional_</span>
</li> </ul> <p>When the target is a string, <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">include</span></code> asserts that the given string <code class="language-js highlighter-rouge"><span class="nx">val</span></code> is a substring of the target.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect('foobar').to.include('foo');
</pre></div></div> <p>When the target is an array, <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">include</span></code> asserts that the given <code class="language-js highlighter-rouge"><span class="nx">val</span></code> is a member of the target.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect([1, 2, 3]).to.include(2);
</pre></div></div> <p>When the target is an object, <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">include</span></code> asserts that the given object <code class="language-js highlighter-rouge"><span class="nx">val</span></code>’s properties are a subset of the target’s properties.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect({a: 1, b: 2, c: 3}).to.include({a: 1, b: 2});
</pre></div></div> <p>When the target is a Set or WeakSet, <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">include</span></code> asserts that the given <code class="language-js highlighter-rouge"><span class="nx">val</span></code> is a member of the target. SameValueZero equality algorithm is used.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(new Set([1, 2])).to.include(2);
</pre></div></div> <p>When the target is a Map, <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">include</span></code> asserts that the given <code class="language-js highlighter-rouge"><span class="nx">val</span></code> is one of the values of the target. SameValueZero equality algorithm is used.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(new Map([['a', 1], ['b', 2]])).to.include(2);
</pre></div></div> <p>Because <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">include</span></code> does different things based on the target’s type, it’s important to check the target’s type before using <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">include</span></code>. See the <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">a</span></code> doc for info on testing a target’s type.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect([1, 2, 3]).to.be.an('array').that.includes(2);
</pre></div></div> <p>By default, strict (<code class="language-js highlighter-rouge"><span class="o">===</span></code>) equality is used to compare array members and object properties. Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">deep</span></code> earlier in the chain to use deep equality instead (WeakSet targets are not supported). See the <code class="language-js highlighter-rouge"><span class="nx">deep</span><span class="o">-</span><span class="nx">eql</span></code> project page for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">// Target array deeply (but not strictly) includes `{a: 1}`
expect([{a: 1}]).to.deep.include({a: 1});
expect([{a: 1}]).to.not.include({a: 1});

// Target object deeply (but not strictly) includes `x: {a: 1}`
expect({x: {a: 1}}).to.deep.include({x: {a: 1}});
expect({x: {a: 1}}).to.not.include({x: {a: 1}});
</pre></div></div> <p>By default, all of the target’s properties are searched when working with objects. This includes properties that are inherited and/or non-enumerable. Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">own</span></code> earlier in the chain to exclude the target’s inherited properties from the search.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">Object.prototype.b = 2;

expect({a: 1}).to.own.include({a: 1});
expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});
</pre></div></div> <p>Note that a target object is always only searched for <code class="language-js highlighter-rouge"><span class="nx">val</span></code>’s own enumerable properties.</p> <p><code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">deep</span></code> and <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">own</span></code> can be combined.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect({a: {b: 2}}).to.deep.own.include({a: {b: 2}});
</pre></div></div> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">nested</span></code> earlier in the chain to enable dot- and bracket-notation when referencing nested properties.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});
</pre></div></div> <p>If <code class="language-js highlighter-rouge"><span class="p">.</span></code> or <code class="language-js highlighter-rouge"><span class="p">[]</span></code> are part of an actual property name, they can be escaped by adding two backslashes before them.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect({'.a': {'[b]': 2}}).to.nested.include({'\\.a.\\[b\\]': 2});
</pre></div></div> <p><code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">deep</span></code> and <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">nested</span></code> can be combined.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect({a: {b: [{c: 3}]}}).to.deep.nested.include({'a.b[0]': {c: 3}});
</pre></div></div> <p><code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">own</span></code> and <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">nested</span></code> cannot be combined.</p> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">not</span></code> earlier in the chain to negate <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">include</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect('foobar').to.not.include('taco');
expect([1, 2, 3]).to.not.include(4);
</pre></div></div> <p>However, it’s dangerous to negate <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">include</span></code> when the target is an object. The problem is that it creates uncertain expectations by asserting that the target object doesn’t have all of <code class="language-js highlighter-rouge"><span class="nx">val</span></code>’s key/value pairs but may or may not have some of them. It’s often best to identify the exact output that’s expected, and then write an assertion that only accepts that exact output.</p> <p>When the target object isn’t even expected to have <code class="language-js highlighter-rouge"><span class="nx">val</span></code>’s keys, it’s often best to assert exactly that.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect({c: 3}).to.not.have.any.keys('a', 'b'); // Recommended
expect({c: 3}).to.not.include({a: 1, b: 2}); // Not recommended
</pre></div></div> <p>When the target object is expected to have <code class="language-js highlighter-rouge"><span class="nx">val</span></code>’s keys, it’s often best to assert that each of the properties has its expected value, rather than asserting that each property doesn’t have one of many unexpected values.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect({a: 3, b: 4}).to.include({a: 3, b: 4}); // Recommended
expect({a: 3, b: 4}).to.not.include({a: 1, b: 2}); // Not recommended
</pre></div></div> <p><code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">include</span></code> accepts an optional <code class="language-js highlighter-rouge"><span class="nx">msg</span></code> argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to <code class="language-js highlighter-rouge"><span class="nx">expect</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect([1, 2, 3]).to.include(4, 'nooo why fail??');
expect([1, 2, 3], 'nooo why fail??').to.include(4);
</pre></div></div> <p><code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">include</span></code> can also be used as a language chain, causing all <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">members</span></code> and <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">keys</span></code> assertions that follow in the chain to require the target to be a superset of the expected set, rather than an identical set. Note that <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">members</span></code> ignores duplicates in the subset when <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">include</span></code> is added.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">// Target object's keys are a superset of ['a', 'b'] but not identical
expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');
expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');

// Target array is a superset of [1, 2] but not identical
expect([1, 2, 3]).to.include.members([1, 2]);
expect([1, 2, 3]).to.not.have.members([1, 2]);

// Duplicates in the subset are ignored
expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);
</pre></div></div> <p>Note that adding <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">any</span></code> earlier in the chain causes the <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">keys</span></code> assertion to ignore <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">include</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">// Both assertions are identical
expect({a: 1}).to.include.any.keys('a', 'b');
expect({a: 1}).to.have.any.keys('a', 'b');
</pre></div></div> <p>The aliases <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">includes</span></code>, <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">contain</span></code>, and <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">contains</span></code> can be used interchangeably with <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">include</span></code>.</p> </div> <div id="method_ok" class="api_method_wrapper"> <h3 id="ok">.ok</h3>  <p>Asserts that the target is a truthy value (considered <code class="language-js highlighter-rouge"><span class="kc">true</span></code> in boolean context). However, it’s often best to assert that the target is strictly (<code class="language-js highlighter-rouge"><span class="o">===</span></code>) or deeply equal to its expected value.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(1).to.equal(1); // Recommended
expect(1).to.be.ok; // Not recommended

expect(true).to.be.true; // Recommended
expect(true).to.be.ok; // Not recommended
</pre></div></div> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">not</span></code> earlier in the chain to negate <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">ok</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(0).to.equal(0); // Recommended
expect(0).to.not.be.ok; // Not recommended

expect(false).to.be.false; // Recommended
expect(false).to.not.be.ok; // Not recommended

expect(null).to.be.null; // Recommended
expect(null).to.not.be.ok; // Not recommended

expect(undefined).to.be.undefined; // Recommended
expect(undefined).to.not.be.ok; // Not recommended
</pre></div></div> <p>A custom error message can be given as the second argument to <code class="language-js highlighter-rouge"><span class="nx">expect</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(false, 'nooo why fail??').to.be.ok;
</pre></div></div> </div> <div id="method_true" class="api_method_wrapper"> <h3 id="true">.true</h3>  <p>Asserts that the target is strictly (<code class="language-js highlighter-rouge"><span class="o">===</span></code>) equal to <code class="language-js highlighter-rouge"><span class="kc">true</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(true).to.be.true;
</pre></div></div> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">not</span></code> earlier in the chain to negate <code class="language-js highlighter-rouge"><span class="p">.</span><span class="kc">true</span></code>. However, it’s often best to assert that the target is equal to its expected value, rather than not equal to <code class="language-js highlighter-rouge"><span class="kc">true</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(false).to.be.false; // Recommended
expect(false).to.not.be.true; // Not recommended

expect(1).to.equal(1); // Recommended
expect(1).to.not.be.true; // Not recommended
</pre></div></div> <p>A custom error message can be given as the second argument to <code class="language-js highlighter-rouge"><span class="nx">expect</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(false, 'nooo why fail??').to.be.true;
</pre></div></div> </div> <div id="method_false" class="api_method_wrapper"> <h3 id="false">.false</h3>  <p>Asserts that the target is strictly (<code class="language-js highlighter-rouge"><span class="o">===</span></code>) equal to <code class="language-js highlighter-rouge"><span class="kc">false</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(false).to.be.false;
</pre></div></div> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">not</span></code> earlier in the chain to negate <code class="language-js highlighter-rouge"><span class="p">.</span><span class="kc">false</span></code>. However, it’s often best to assert that the target is equal to its expected value, rather than not equal to <code class="language-js highlighter-rouge"><span class="kc">false</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(true).to.be.true; // Recommended
expect(true).to.not.be.false; // Not recommended

expect(1).to.equal(1); // Recommended
expect(1).to.not.be.false; // Not recommended
</pre></div></div> <p>A custom error message can be given as the second argument to <code class="language-js highlighter-rouge"><span class="nx">expect</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(true, 'nooo why fail??').to.be.false;
</pre></div></div> </div> <div id="method_null" class="api_method_wrapper"> <h3 id="null">.null</h3>  <p>Asserts that the target is strictly (<code class="language-js highlighter-rouge"><span class="o">===</span></code>) equal to <code class="language-js highlighter-rouge"><span class="kc">null</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(null).to.be.null;
</pre></div></div> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">not</span></code> earlier in the chain to negate <code class="language-js highlighter-rouge"><span class="p">.</span><span class="kc">null</span></code>. However, it’s often best to assert that the target is equal to its expected value, rather than not equal to <code class="language-js highlighter-rouge"><span class="kc">null</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(1).to.equal(1); // Recommended
expect(1).to.not.be.null; // Not recommended
</pre></div></div> <p>A custom error message can be given as the second argument to <code class="language-js highlighter-rouge"><span class="nx">expect</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(42, 'nooo why fail??').to.be.null;
</pre></div></div> </div> <div id="method_undefined" class="api_method_wrapper"> <h3 id="undefined">.undefined</h3>  <p>Asserts that the target is strictly (<code class="language-js highlighter-rouge"><span class="o">===</span></code>) equal to <code class="language-js highlighter-rouge"><span class="kc">undefined</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(undefined).to.be.undefined;
</pre></div></div> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">not</span></code> earlier in the chain to negate <code class="language-js highlighter-rouge"><span class="p">.</span><span class="kc">undefined</span></code>. However, it’s often best to assert that the target is equal to its expected value, rather than not equal to <code class="language-js highlighter-rouge"><span class="kc">undefined</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(1).to.equal(1); // Recommended
expect(1).to.not.be.undefined; // Not recommended
</pre></div></div> <p>A custom error message can be given as the second argument to <code class="language-js highlighter-rouge"><span class="nx">expect</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(42, 'nooo why fail??').to.be.undefined;
</pre></div></div> </div> <div id="method_nan" class="api_method_wrapper"> <h3 id="nan">.NaN</h3>  <p>Asserts that the target is exactly <code class="language-js highlighter-rouge"><span class="kc">NaN</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(NaN).to.be.NaN;
</pre></div></div> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">not</span></code> earlier in the chain to negate <code class="language-js highlighter-rouge"><span class="p">.</span><span class="kc">NaN</span></code>. However, it’s often best to assert that the target is equal to its expected value, rather than not equal to <code class="language-js highlighter-rouge"><span class="kc">NaN</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect('foo').to.equal('foo'); // Recommended
expect('foo').to.not.be.NaN; // Not recommended
</pre></div></div> <p>A custom error message can be given as the second argument to <code class="language-js highlighter-rouge"><span class="nx">expect</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(42, 'nooo why fail??').to.be.NaN;
</pre></div></div> </div> <div id="method_exist" class="api_method_wrapper"> <h3 id="exist">.exist</h3>  <p>Asserts that the target is not strictly (<code class="language-js highlighter-rouge"><span class="o">===</span></code>) equal to either <code class="language-js highlighter-rouge"><span class="kc">null</span></code> or <code class="language-js highlighter-rouge"><span class="kc">undefined</span></code>. However, it’s often best to assert that the target is equal to its expected value.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(1).to.equal(1); // Recommended
expect(1).to.exist; // Not recommended

expect(0).to.equal(0); // Recommended
expect(0).to.exist; // Not recommended
</pre></div></div> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">not</span></code> earlier in the chain to negate <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">exist</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(null).to.be.null; // Recommended
expect(null).to.not.exist; // Not recommended

expect(undefined).to.be.undefined; // Recommended
expect(undefined).to.not.exist; // Not recommended
</pre></div></div> <p>A custom error message can be given as the second argument to <code class="language-js highlighter-rouge"><span class="nx">expect</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(null, 'nooo why fail??').to.exist;
</pre></div></div> </div> <div id="method_empty" class="api_method_wrapper"> <h3 id="empty">.empty</h3>  <p>When the target is a string or array, <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">empty</span></code> asserts that the target’s <code class="language-js highlighter-rouge"><span class="nx">length</span></code> property is strictly (<code class="language-js highlighter-rouge"><span class="o">===</span></code>) equal to <code class="language-js highlighter-rouge"><span class="mi">0</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect([]).to.be.empty;
expect('').to.be.empty;
</pre></div></div> <p>When the target is a map or set, <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">empty</span></code> asserts that the target’s <code class="language-js highlighter-rouge"><span class="nx">size</span></code> property is strictly equal to <code class="language-js highlighter-rouge"><span class="mi">0</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(new Set()).to.be.empty;
expect(new Map()).to.be.empty;
</pre></div></div> <p>When the target is a non-function object, <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">empty</span></code> asserts that the target doesn’t have any own enumerable properties. Properties with Symbol-based keys are excluded from the count.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect({}).to.be.empty;
</pre></div></div> <p>Because <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">empty</span></code> does different things based on the target’s type, it’s important to check the target’s type before using <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">empty</span></code>. See the <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">a</span></code> doc for info on testing a target’s type.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect([]).to.be.an('array').that.is.empty;
</pre></div></div> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">not</span></code> earlier in the chain to negate <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">empty</span></code>. However, it’s often best to assert that the target contains its expected number of values, rather than asserting that it’s not empty.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
expect([1, 2, 3]).to.not.be.empty; // Not recommended

expect(new Set([1, 2, 3])).to.have.property('size', 3); // Recommended
expect(new Set([1, 2, 3])).to.not.be.empty; // Not recommended

expect(Object.keys({a: 1})).to.have.lengthOf(1); // Recommended
expect({a: 1}).to.not.be.empty; // Not recommended
</pre></div></div> <p>A custom error message can be given as the second argument to <code class="language-js highlighter-rouge"><span class="nx">expect</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect([1, 2, 3], 'nooo why fail??').to.be.empty;
</pre></div></div> </div> <div id="method_arguments" class="api_method_wrapper"> <h3 id="arguments">.arguments</h3>  <p>Asserts that the target is an <code class="language-js highlighter-rouge"><span class="kr">arguments</span></code> object.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">function test () {
  expect(arguments).to.be.arguments;
}

test();
</pre></div></div> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">not</span></code> earlier in the chain to negate <code class="language-js highlighter-rouge"><span class="p">.</span><span class="kr">arguments</span></code>. However, it’s often best to assert which type the target is expected to be, rather than asserting that its not an <code class="language-js highlighter-rouge"><span class="kr">arguments</span></code> object.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect('foo').to.be.a('string'); // Recommended
expect('foo').to.not.be.arguments; // Not recommended
</pre></div></div> <p>A custom error message can be given as the second argument to <code class="language-js highlighter-rouge"><span class="nx">expect</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect({}, 'nooo why fail??').to.be.arguments;
</pre></div></div> <p>The alias <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">Arguments</span></code> can be used interchangeably with <code class="language-js highlighter-rouge"><span class="p">.</span><span class="kr">arguments</span></code>.</p> </div> <div id="method_equal" class="api_method_wrapper"> <h3 id="equalval-msg">.equal(val[, msg])</h3> <ul class="tags"> <li class="tag">
<span class="type">@param</span> <span class="types">{ Mixed }</span> <span class="name">val</span> 
</li> <li class="tag">
<span class="type">@param</span> <span class="types">{ String }</span> <span class="name">msg</span> <span class="desc">_optional_</span>
</li> </ul> <p>Asserts that the target is strictly (<code class="language-js highlighter-rouge"><span class="o">===</span></code>) equal to the given <code class="language-js highlighter-rouge"><span class="nx">val</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(1).to.equal(1);
expect('foo').to.equal('foo');
</pre></div></div> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">deep</span></code> earlier in the chain to use deep equality instead. See the <code class="language-js highlighter-rouge"><span class="nx">deep</span><span class="o">-</span><span class="nx">eql</span></code> project page for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">// Target object deeply (but not strictly) equals `{a: 1}`
expect({a: 1}).to.deep.equal({a: 1});
expect({a: 1}).to.not.equal({a: 1});

// Target array deeply (but not strictly) equals `[1, 2]`
expect([1, 2]).to.deep.equal([1, 2]);
expect([1, 2]).to.not.equal([1, 2]);
</pre></div></div> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">not</span></code> earlier in the chain to negate <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">equal</span></code>. However, it’s often best to assert that the target is equal to its expected value, rather than not equal to one of countless unexpected values.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(1).to.equal(1); // Recommended
expect(1).to.not.equal(2); // Not recommended
</pre></div></div> <p><code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">equal</span></code> accepts an optional <code class="language-js highlighter-rouge"><span class="nx">msg</span></code> argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to <code class="language-js highlighter-rouge"><span class="nx">expect</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(1).to.equal(2, 'nooo why fail??');
expect(1, 'nooo why fail??').to.equal(2);
</pre></div></div> <p>The aliases <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">equals</span></code> and <code class="language-js highlighter-rouge"><span class="nx">eq</span></code> can be used interchangeably with <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">equal</span></code>.</p> </div> <div id="method_eql" class="api_method_wrapper"> <h3 id="eqlobj-msg">.eql(obj[, msg])</h3> <ul class="tags"> <li class="tag">
<span class="type">@param</span> <span class="types">{ Mixed }</span> <span class="name">obj</span> 
</li> <li class="tag">
<span class="type">@param</span> <span class="types">{ String }</span> <span class="name">msg</span> <span class="desc">_optional_</span>
</li> </ul> <p>Asserts that the target is deeply equal to the given <code class="language-js highlighter-rouge"><span class="nx">obj</span></code>. See the <code class="language-js highlighter-rouge"><span class="nx">deep</span><span class="o">-</span><span class="nx">eql</span></code> project page for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">// Target object is deeply (but not strictly) equal to {a: 1}
expect({a: 1}).to.eql({a: 1}).but.not.equal({a: 1});

// Target array is deeply (but not strictly) equal to [1, 2]
expect([1, 2]).to.eql([1, 2]).but.not.equal([1, 2]);
</pre></div></div> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">not</span></code> earlier in the chain to negate <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">eql</span></code>. However, it’s often best to assert that the target is deeply equal to its expected value, rather than not deeply equal to one of countless unexpected values.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect({a: 1}).to.eql({a: 1}); // Recommended
expect({a: 1}).to.not.eql({b: 2}); // Not recommended
</pre></div></div> <p><code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">eql</span></code> accepts an optional <code class="language-js highlighter-rouge"><span class="nx">msg</span></code> argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to <code class="language-js highlighter-rouge"><span class="nx">expect</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect({a: 1}).to.eql({b: 2}, 'nooo why fail??');
expect({a: 1}, 'nooo why fail??').to.eql({b: 2});
</pre></div></div> <p>The alias <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">eqls</span></code> can be used interchangeably with <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">eql</span></code>.</p> <p>The <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">deep</span><span class="p">.</span><span class="nx">equal</span></code> assertion is almost identical to <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">eql</span></code> but with one difference: <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">deep</span><span class="p">.</span><span class="nx">equal</span></code> causes deep equality comparisons to also be used for any other assertions that follow in the chain.</p> </div> <div id="method_above" class="api_method_wrapper"> <h3 id="aboven-msg">.above(n[, msg])</h3> <ul class="tags"> <li class="tag">
<span class="type">@param</span> <span class="types">{ Number }</span> <span class="name">n</span> 
</li> <li class="tag">
<span class="type">@param</span> <span class="types">{ String }</span> <span class="name">msg</span> <span class="desc">_optional_</span>
</li> </ul> <p>Asserts that the target is a number or a date greater than the given number or date <code class="language-js highlighter-rouge"><span class="nx">n</span></code> respectively. However, it’s often best to assert that the target is equal to its expected value.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(2).to.equal(2); // Recommended
expect(2).to.be.above(1); // Not recommended
</pre></div></div> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">lengthOf</span></code> earlier in the chain to assert that the target’s <code class="language-js highlighter-rouge"><span class="nx">length</span></code> or <code class="language-js highlighter-rouge"><span class="nx">size</span></code> is greater than the given number <code class="language-js highlighter-rouge"><span class="nx">n</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect('foo').to.have.lengthOf(3); // Recommended
expect('foo').to.have.lengthOf.above(2); // Not recommended

expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
expect([1, 2, 3]).to.have.lengthOf.above(2); // Not recommended
</pre></div></div> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">not</span></code> earlier in the chain to negate <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">above</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(2).to.equal(2); // Recommended
expect(1).to.not.be.above(2); // Not recommended
</pre></div></div> <p><code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">above</span></code> accepts an optional <code class="language-js highlighter-rouge"><span class="nx">msg</span></code> argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to <code class="language-js highlighter-rouge"><span class="nx">expect</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(1).to.be.above(2, 'nooo why fail??');
expect(1, 'nooo why fail??').to.be.above(2);
</pre></div></div> <p>The aliases <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">gt</span></code> and <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">greaterThan</span></code> can be used interchangeably with <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">above</span></code>.</p> </div> <div id="method_least" class="api_method_wrapper"> <h3 id="leastn-msg">.least(n[, msg])</h3> <ul class="tags"> <li class="tag">
<span class="type">@param</span> <span class="types">{ Number }</span> <span class="name">n</span> 
</li> <li class="tag">
<span class="type">@param</span> <span class="types">{ String }</span> <span class="name">msg</span> <span class="desc">_optional_</span>
</li> </ul> <p>Asserts that the target is a number or a date greater than or equal to the given number or date <code class="language-js highlighter-rouge"><span class="nx">n</span></code> respectively. However, it’s often best to assert that the target is equal to its expected value.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(2).to.equal(2); // Recommended
expect(2).to.be.at.least(1); // Not recommended
expect(2).to.be.at.least(2); // Not recommended
</pre></div></div> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">lengthOf</span></code> earlier in the chain to assert that the target’s <code class="language-js highlighter-rouge"><span class="nx">length</span></code> or <code class="language-js highlighter-rouge"><span class="nx">size</span></code> is greater than or equal to the given number <code class="language-js highlighter-rouge"><span class="nx">n</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect('foo').to.have.lengthOf(3); // Recommended
expect('foo').to.have.lengthOf.at.least(2); // Not recommended

expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
expect([1, 2, 3]).to.have.lengthOf.at.least(2); // Not recommended
</pre></div></div> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">not</span></code> earlier in the chain to negate <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">least</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(1).to.equal(1); // Recommended
expect(1).to.not.be.at.least(2); // Not recommended
</pre></div></div> <p><code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">least</span></code> accepts an optional <code class="language-js highlighter-rouge"><span class="nx">msg</span></code> argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to <code class="language-js highlighter-rouge"><span class="nx">expect</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(1).to.be.at.least(2, 'nooo why fail??');
expect(1, 'nooo why fail??').to.be.at.least(2);
</pre></div></div> <p>The alias <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">gte</span></code> can be used interchangeably with <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">least</span></code>.</p> </div> <div id="method_below" class="api_method_wrapper"> <h3 id="belown-msg">.below(n[, msg])</h3> <ul class="tags"> <li class="tag">
<span class="type">@param</span> <span class="types">{ Number }</span> <span class="name">n</span> 
</li> <li class="tag">
<span class="type">@param</span> <span class="types">{ String }</span> <span class="name">msg</span> <span class="desc">_optional_</span>
</li> </ul> <p>Asserts that the target is a number or a date less than the given number or date <code class="language-js highlighter-rouge"><span class="nx">n</span></code> respectively. However, it’s often best to assert that the target is equal to its expected value.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(1).to.equal(1); // Recommended
expect(1).to.be.below(2); // Not recommended
</pre></div></div> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">lengthOf</span></code> earlier in the chain to assert that the target’s <code class="language-js highlighter-rouge"><span class="nx">length</span></code> or <code class="language-js highlighter-rouge"><span class="nx">size</span></code> is less than the given number <code class="language-js highlighter-rouge"><span class="nx">n</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect('foo').to.have.lengthOf(3); // Recommended
expect('foo').to.have.lengthOf.below(4); // Not recommended

expect([1, 2, 3]).to.have.length(3); // Recommended
expect([1, 2, 3]).to.have.lengthOf.below(4); // Not recommended
</pre></div></div> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">not</span></code> earlier in the chain to negate <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">below</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(2).to.equal(2); // Recommended
expect(2).to.not.be.below(1); // Not recommended
</pre></div></div> <p><code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">below</span></code> accepts an optional <code class="language-js highlighter-rouge"><span class="nx">msg</span></code> argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to <code class="language-js highlighter-rouge"><span class="nx">expect</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(2).to.be.below(1, 'nooo why fail??');
expect(2, 'nooo why fail??').to.be.below(1);
</pre></div></div> <p>The aliases <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">lt</span></code> and <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">lessThan</span></code> can be used interchangeably with <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">below</span></code>.</p> </div> <div id="method_most" class="api_method_wrapper"> <h3 id="mostn-msg">.most(n[, msg])</h3> <ul class="tags"> <li class="tag">
<span class="type">@param</span> <span class="types">{ Number }</span> <span class="name">n</span> 
</li> <li class="tag">
<span class="type">@param</span> <span class="types">{ String }</span> <span class="name">msg</span> <span class="desc">_optional_</span>
</li> </ul> <p>Asserts that the target is a number or a date less than or equal to the given number or date <code class="language-js highlighter-rouge"><span class="nx">n</span></code> respectively. However, it’s often best to assert that the target is equal to its expected value.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(1).to.equal(1); // Recommended
expect(1).to.be.at.most(2); // Not recommended
expect(1).to.be.at.most(1); // Not recommended
</pre></div></div> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">lengthOf</span></code> earlier in the chain to assert that the target’s <code class="language-js highlighter-rouge"><span class="nx">length</span></code> or <code class="language-js highlighter-rouge"><span class="nx">size</span></code> is less than or equal to the given number <code class="language-js highlighter-rouge"><span class="nx">n</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect('foo').to.have.lengthOf(3); // Recommended
expect('foo').to.have.lengthOf.at.most(4); // Not recommended

expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
expect([1, 2, 3]).to.have.lengthOf.at.most(4); // Not recommended
</pre></div></div> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">not</span></code> earlier in the chain to negate <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">most</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(2).to.equal(2); // Recommended
expect(2).to.not.be.at.most(1); // Not recommended
</pre></div></div> <p><code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">most</span></code> accepts an optional <code class="language-js highlighter-rouge"><span class="nx">msg</span></code> argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to <code class="language-js highlighter-rouge"><span class="nx">expect</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(2).to.be.at.most(1, 'nooo why fail??');
expect(2, 'nooo why fail??').to.be.at.most(1);
</pre></div></div> <p>The alias <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">lte</span></code> can be used interchangeably with <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">most</span></code>.</p> </div> <div id="method_within" class="api_method_wrapper"> <h3 id="withinstart-finish-msg">.within(start, finish[, msg])</h3> <ul class="tags"> <li class="tag">
<span class="type">@param</span> <span class="types">{ Number }</span> <span class="name">start</span> <span class="desc">lower bound inclusive</span>
</li> <li class="tag">
<span class="type">@param</span> <span class="types">{ Number }</span> <span class="name">finish</span> <span class="desc">upper bound inclusive</span>
</li> <li class="tag">
<span class="type">@param</span> <span class="types">{ String }</span> <span class="name">msg</span> <span class="desc">_optional_</span>
</li> </ul> <p>Asserts that the target is a number or a date greater than or equal to the given number or date <code class="language-js highlighter-rouge"><span class="nx">start</span></code>, and less than or equal to the given number or date <code class="language-js highlighter-rouge"><span class="nx">finish</span></code> respectively. However, it’s often best to assert that the target is equal to its expected value.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(2).to.equal(2); // Recommended
expect(2).to.be.within(1, 3); // Not recommended
expect(2).to.be.within(2, 3); // Not recommended
expect(2).to.be.within(1, 2); // Not recommended
</pre></div></div> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">lengthOf</span></code> earlier in the chain to assert that the target’s <code class="language-js highlighter-rouge"><span class="nx">length</span></code> or <code class="language-js highlighter-rouge"><span class="nx">size</span></code> is greater than or equal to the given number <code class="language-js highlighter-rouge"><span class="nx">start</span></code>, and less than or equal to the given number <code class="language-js highlighter-rouge"><span class="nx">finish</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect('foo').to.have.lengthOf(3); // Recommended
expect('foo').to.have.lengthOf.within(2, 4); // Not recommended

expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
expect([1, 2, 3]).to.have.lengthOf.within(2, 4); // Not recommended
</pre></div></div> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">not</span></code> earlier in the chain to negate <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">within</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(1).to.equal(1); // Recommended
expect(1).to.not.be.within(2, 4); // Not recommended
</pre></div></div> <p><code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">within</span></code> accepts an optional <code class="language-js highlighter-rouge"><span class="nx">msg</span></code> argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to <code class="language-js highlighter-rouge"><span class="nx">expect</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(4).to.be.within(1, 3, 'nooo why fail??');
expect(4, 'nooo why fail??').to.be.within(1, 3);
</pre></div></div> </div> <div id="method_instanceof" class="api_method_wrapper"> <h3 id="instanceofconstructor-msg">.instanceof(constructor[, msg])</h3> <ul class="tags"> <li class="tag">
<span class="type">@param</span> <span class="types">{ Constructor }</span> <span class="name">constructor</span> 
</li> <li class="tag">
<span class="type">@param</span> <span class="types">{ String }</span> <span class="name">msg</span> <span class="desc">_optional_</span>
</li> </ul> <p>Asserts that the target is an instance of the given <code class="language-js highlighter-rouge"><span class="kd">constructor</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">function Cat () { }

expect(new Cat()).to.be.an.instanceof(Cat);
expect([1, 2]).to.be.an.instanceof(Array);
</pre></div></div> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">not</span></code> earlier in the chain to negate <code class="language-js highlighter-rouge"><span class="p">.</span><span class="k">instanceof</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect({a: 1}).to.not.be.an.instanceof(Array);
</pre></div></div> <p><code class="language-js highlighter-rouge"><span class="p">.</span><span class="k">instanceof</span></code> accepts an optional <code class="language-js highlighter-rouge"><span class="nx">msg</span></code> argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to <code class="language-js highlighter-rouge"><span class="nx">expect</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(1).to.be.an.instanceof(Array, 'nooo why fail??');
expect(1, 'nooo why fail??').to.be.an.instanceof(Array);
</pre></div></div> <p>Due to limitations in ES5, <code class="language-js highlighter-rouge"><span class="p">.</span><span class="k">instanceof</span></code> may not always work as expected when using a transpiler such as Babel or TypeScript. In particular, it may produce unexpected results when subclassing built-in object such as <code class="language-js highlighter-rouge"><span class="nb">Array</span></code>, <code class="language-js highlighter-rouge"><span class="nb">Error</span></code>, and <code class="language-js highlighter-rouge"><span class="nb">Map</span></code>. See your transpiler’s docs for details:</p> <ul> <li>(<a href="https://babeljs.io/docs/usage/caveats/#classes">Babel</a>)</li> <li>(<a href="https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work">TypeScript</a>)</li> </ul> <p>The alias <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">instanceOf</span></code> can be used interchangeably with <code class="language-js highlighter-rouge"><span class="p">.</span><span class="k">instanceof</span></code>.</p> </div> <div id="method_property" class="api_method_wrapper"> <h3 id="propertyname-val-msg">.property(name[, val[, msg]])</h3> <ul class="tags"> <li class="tag">
<span class="type">@param</span> <span class="types">{ String }</span> <span class="name">name</span> 
</li> <li class="tag">
<span class="type">@param</span> <span class="types">{ Mixed }</span> <span class="name">val</span> <span class="desc">(optional)</span>
</li> <li class="tag">
<span class="type">@param</span> <span class="types">{ String }</span> <span class="name">msg</span> <span class="desc">_optional_</span>
</li> </ul> <p>Asserts that the target has a property with the given key <code class="language-js highlighter-rouge"><span class="nx">name</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect({a: 1}).to.have.property('a');
</pre></div></div> <p>When <code class="language-js highlighter-rouge"><span class="nx">val</span></code> is provided, <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">property</span></code> also asserts that the property’s value is equal to the given <code class="language-js highlighter-rouge"><span class="nx">val</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect({a: 1}).to.have.property('a', 1);
</pre></div></div> <p>By default, strict (<code class="language-js highlighter-rouge"><span class="o">===</span></code>) equality is used. Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">deep</span></code> earlier in the chain to use deep equality instead. See the <code class="language-js highlighter-rouge"><span class="nx">deep</span><span class="o">-</span><span class="nx">eql</span></code> project page for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">// Target object deeply (but not strictly) has property `x: {a: 1}`
expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});
expect({x: {a: 1}}).to.not.have.property('x', {a: 1});
</pre></div></div> <p>The target’s enumerable and non-enumerable properties are always included in the search. By default, both own and inherited properties are included. Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">own</span></code> earlier in the chain to exclude inherited properties from the search.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">Object.prototype.b = 2;

expect({a: 1}).to.have.own.property('a');
expect({a: 1}).to.have.own.property('a', 1);
expect({a: 1}).to.have.property('b');
expect({a: 1}).to.not.have.own.property('b');
</pre></div></div> <p><code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">deep</span></code> and <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">own</span></code> can be combined.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect({x: {a: 1}}).to.have.deep.own.property('x', {a: 1});
</pre></div></div> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">nested</span></code> earlier in the chain to enable dot- and bracket-notation when referencing nested properties.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');
expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]', 'y');
</pre></div></div> <p>If <code class="language-js highlighter-rouge"><span class="p">.</span></code> or <code class="language-js highlighter-rouge"><span class="p">[]</span></code> are part of an actual property name, they can be escaped by adding two backslashes before them.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\.a.\\[b\\]');
</pre></div></div> <p><code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">deep</span></code> and <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">nested</span></code> can be combined.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect({a: {b: [{c: 3}]}})
  .to.have.deep.nested.property('a.b[0]', {c: 3});
</pre></div></div> <p><code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">own</span></code> and <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">nested</span></code> cannot be combined.</p> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">not</span></code> earlier in the chain to negate <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">property</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect({a: 1}).to.not.have.property('b');
</pre></div></div> <p>However, it’s dangerous to negate <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">property</span></code> when providing <code class="language-js highlighter-rouge"><span class="nx">val</span></code>. The problem is that it creates uncertain expectations by asserting that the target either doesn’t have a property with the given key <code class="language-js highlighter-rouge"><span class="nx">name</span></code>, or that it does have a property with the given key <code class="language-js highlighter-rouge"><span class="nx">name</span></code> but its value isn’t equal to the given <code class="language-js highlighter-rouge"><span class="nx">val</span></code>. It’s often best to identify the exact output that’s expected, and then write an assertion that only accepts that exact output.</p> <p>When the target isn’t expected to have a property with the given key <code class="language-js highlighter-rouge"><span class="nx">name</span></code>, it’s often best to assert exactly that.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect({b: 2}).to.not.have.property('a'); // Recommended
expect({b: 2}).to.not.have.property('a', 1); // Not recommended
</pre></div></div> <p>When the target is expected to have a property with the given key <code class="language-js highlighter-rouge"><span class="nx">name</span></code>, it’s often best to assert that the property has its expected value, rather than asserting that it doesn’t have one of many unexpected values.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect({a: 3}).to.have.property('a', 3); // Recommended
expect({a: 3}).to.not.have.property('a', 1); // Not recommended
</pre></div></div> <p><code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">property</span></code> changes the target of any assertions that follow in the chain to be the value of the property from the original target object.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect({a: 1}).to.have.property('a').that.is.a('number');
</pre></div></div> <p><code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">property</span></code> accepts an optional <code class="language-js highlighter-rouge"><span class="nx">msg</span></code> argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to <code class="language-js highlighter-rouge"><span class="nx">expect</span></code>. When not providing <code class="language-js highlighter-rouge"><span class="nx">val</span></code>, only use the second form.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">// Recommended
expect({a: 1}).to.have.property('a', 2, 'nooo why fail??');
expect({a: 1}, 'nooo why fail??').to.have.property('a', 2);
expect({a: 1}, 'nooo why fail??').to.have.property('b');

// Not recommended
expect({a: 1}).to.have.property('b', undefined, 'nooo why fail??');
</pre></div></div> <p>The above assertion isn’t the same thing as not providing <code class="language-js highlighter-rouge"><span class="nx">val</span></code>. Instead, it’s asserting that the target object has a <code class="language-js highlighter-rouge"><span class="nx">b</span></code> property that’s equal to <code class="language-js highlighter-rouge"><span class="kc">undefined</span></code>.</p> <p>The assertions <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">ownProperty</span></code> and <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">haveOwnProperty</span></code> can be used interchangeably with <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">own</span><span class="p">.</span><span class="nx">property</span></code>.</p> </div> <div id="method_ownpropertydescriptor" class="api_method_wrapper"> <h3 id="ownpropertydescriptorname-descriptor-msg">.ownPropertyDescriptor(name[, descriptor[, msg]])</h3> <ul class="tags"> <li class="tag">
<span class="type">@param</span> <span class="types">{ String }</span> <span class="name">name</span> 
</li> <li class="tag">
<span class="type">@param</span> <span class="types">{ Object }</span> <span class="name">descriptor</span> <span class="desc">_optional_</span>
</li> <li class="tag">
<span class="type">@param</span> <span class="types">{ String }</span> <span class="name">msg</span> <span class="desc">_optional_</span>
</li> </ul> <p>Asserts that the target has its own property descriptor with the given key <code class="language-js highlighter-rouge"><span class="nx">name</span></code>. Enumerable and non-enumerable properties are included in the search.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect({a: 1}).to.have.ownPropertyDescriptor('a');
</pre></div></div> <p>When <code class="language-js highlighter-rouge"><span class="nx">descriptor</span></code> is provided, <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">ownPropertyDescriptor</span></code> also asserts that the property’s descriptor is deeply equal to the given <code class="language-js highlighter-rouge"><span class="nx">descriptor</span></code>. See the <code class="language-js highlighter-rouge"><span class="nx">deep</span><span class="o">-</span><span class="nx">eql</span></code> project page for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect({a: 1}).to.have.ownPropertyDescriptor('a', {
  configurable: true,
  enumerable: true,
  writable: true,
  value: 1,
});
</pre></div></div> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">not</span></code> earlier in the chain to negate <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">ownPropertyDescriptor</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect({a: 1}).to.not.have.ownPropertyDescriptor('b');
</pre></div></div> <p>However, it’s dangerous to negate <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">ownPropertyDescriptor</span></code> when providing a <code class="language-js highlighter-rouge"><span class="nx">descriptor</span></code>. The problem is that it creates uncertain expectations by asserting that the target either doesn’t have a property descriptor with the given key <code class="language-js highlighter-rouge"><span class="nx">name</span></code>, or that it does have a property descriptor with the given key <code class="language-js highlighter-rouge"><span class="nx">name</span></code> but its not deeply equal to the given <code class="language-js highlighter-rouge"><span class="nx">descriptor</span></code>. It’s often best to identify the exact output that’s expected, and then write an assertion that only accepts that exact output.</p> <p>When the target isn’t expected to have a property descriptor with the given key <code class="language-js highlighter-rouge"><span class="nx">name</span></code>, it’s often best to assert exactly that.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">// Recommended
expect({b: 2}).to.not.have.ownPropertyDescriptor('a');

// Not recommended
expect({b: 2}).to.not.have.ownPropertyDescriptor('a', {
  configurable: true,
  enumerable: true,
  writable: true,
  value: 1,
});
</pre></div></div> <p>When the target is expected to have a property descriptor with the given key <code class="language-js highlighter-rouge"><span class="nx">name</span></code>, it’s often best to assert that the property has its expected descriptor, rather than asserting that it doesn’t have one of many unexpected descriptors.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">// Recommended
expect({a: 3}).to.have.ownPropertyDescriptor('a', {
  configurable: true,
  enumerable: true,
  writable: true,
  value: 3,
});

// Not recommended
expect({a: 3}).to.not.have.ownPropertyDescriptor('a', {
  configurable: true,
  enumerable: true,
  writable: true,
  value: 1,
});
</pre></div></div> <p><code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">ownPropertyDescriptor</span></code> changes the target of any assertions that follow in the chain to be the value of the property descriptor from the original target object.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect({a: 1}).to.have.ownPropertyDescriptor('a')
  .that.has.property('enumerable', true);
</pre></div></div> <p><code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">ownPropertyDescriptor</span></code> accepts an optional <code class="language-js highlighter-rouge"><span class="nx">msg</span></code> argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to <code class="language-js highlighter-rouge"><span class="nx">expect</span></code>. When not providing <code class="language-js highlighter-rouge"><span class="nx">descriptor</span></code>, only use the second form.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">// Recommended
expect({a: 1}).to.have.ownPropertyDescriptor('a', {
  configurable: true,
  enumerable: true,
  writable: true,
  value: 2,
}, 'nooo why fail??');

// Recommended
expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('a', {
  configurable: true,
  enumerable: true,
  writable: true,
  value: 2,
});

// Recommended
expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('b');

// Not recommended
expect({a: 1})
  .to.have.ownPropertyDescriptor('b', undefined, 'nooo why fail??');
</pre></div></div> <p>The above assertion isn’t the same thing as not providing <code class="language-js highlighter-rouge"><span class="nx">descriptor</span></code>. Instead, it’s asserting that the target object has a <code class="language-js highlighter-rouge"><span class="nx">b</span></code> property descriptor that’s deeply equal to <code class="language-js highlighter-rouge"><span class="kc">undefined</span></code>.</p> <p>The alias <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">haveOwnPropertyDescriptor</span></code> can be used interchangeably with <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">ownPropertyDescriptor</span></code>.</p> </div> <div id="method_lengthof" class="api_method_wrapper"> <h3 id="lengthofn-msg">.lengthOf(n[, msg])</h3> <ul class="tags"> <li class="tag">
<span class="type">@param</span> <span class="types">{ Number }</span> <span class="name">n</span> 
</li> <li class="tag">
<span class="type">@param</span> <span class="types">{ String }</span> <span class="name">msg</span> <span class="desc">_optional_</span>
</li> </ul> <p>Asserts that the target’s <code class="language-js highlighter-rouge"><span class="nx">length</span></code> or <code class="language-js highlighter-rouge"><span class="nx">size</span></code> is equal to the given number <code class="language-js highlighter-rouge"><span class="nx">n</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect([1, 2, 3]).to.have.lengthOf(3);
expect('foo').to.have.lengthOf(3);
expect(new Set([1, 2, 3])).to.have.lengthOf(3);
expect(new Map([['a', 1], ['b', 2], ['c', 3]])).to.have.lengthOf(3);
</pre></div></div> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">not</span></code> earlier in the chain to negate <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">lengthOf</span></code>. However, it’s often best to assert that the target’s <code class="language-js highlighter-rouge"><span class="nx">length</span></code> property is equal to its expected value, rather than not equal to one of many unexpected values.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect('foo').to.have.lengthOf(3); // Recommended
expect('foo').to.not.have.lengthOf(4); // Not recommended
</pre></div></div> <p><code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">lengthOf</span></code> accepts an optional <code class="language-js highlighter-rouge"><span class="nx">msg</span></code> argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to <code class="language-js highlighter-rouge"><span class="nx">expect</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect([1, 2, 3]).to.have.lengthOf(2, 'nooo why fail??');
expect([1, 2, 3], 'nooo why fail??').to.have.lengthOf(2);
</pre></div></div> <p><code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">lengthOf</span></code> can also be used as a language chain, causing all <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">above</span></code>, <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">below</span></code>, <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">least</span></code>, <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">most</span></code>, and <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">within</span></code> assertions that follow in the chain to use the target’s <code class="language-js highlighter-rouge"><span class="nx">length</span></code> property as the target. However, it’s often best to assert that the target’s <code class="language-js highlighter-rouge"><span class="nx">length</span></code> property is equal to its expected length, rather than asserting that its <code class="language-js highlighter-rouge"><span class="nx">length</span></code> property falls within some range of values.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">// Recommended
expect([1, 2, 3]).to.have.lengthOf(3);

// Not recommended
expect([1, 2, 3]).to.have.lengthOf.above(2);
expect([1, 2, 3]).to.have.lengthOf.below(4);
expect([1, 2, 3]).to.have.lengthOf.at.least(3);
expect([1, 2, 3]).to.have.lengthOf.at.most(3);
expect([1, 2, 3]).to.have.lengthOf.within(2,4);
</pre></div></div> <p>Due to a compatibility issue, the alias <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">length</span></code> can’t be chained directly off of an uninvoked method such as <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">a</span></code>. Therefore, <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">length</span></code> can’t be used interchangeably with <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">lengthOf</span></code> in every situation. It’s recommended to always use <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">lengthOf</span></code> instead of <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">length</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect([1, 2, 3]).to.have.a.length(3); // incompatible; throws error
expect([1, 2, 3]).to.have.a.lengthOf(3);  // passes as expected
</pre></div></div> </div> <div id="method_match" class="api_method_wrapper"> <h3 id="matchre-msg">.match(re[, msg])</h3> <ul class="tags"> <li class="tag">
<span class="type">@param</span> <span class="types">{ RegExp }</span> <span class="name">re</span> 
</li> <li class="tag">
<span class="type">@param</span> <span class="types">{ String }</span> <span class="name">msg</span> <span class="desc">_optional_</span>
</li> </ul> <p>Asserts that the target matches the given regular expression <code class="language-js highlighter-rouge"><span class="nx">re</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect('foobar').to.match(/^foo/);
</pre></div></div> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">not</span></code> earlier in the chain to negate <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">match</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect('foobar').to.not.match(/taco/);
</pre></div></div> <p><code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">match</span></code> accepts an optional <code class="language-js highlighter-rouge"><span class="nx">msg</span></code> argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to <code class="language-js highlighter-rouge"><span class="nx">expect</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect('foobar').to.match(/taco/, 'nooo why fail??');
expect('foobar', 'nooo why fail??').to.match(/taco/);
</pre></div></div> <p>The alias <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">matches</span></code> can be used interchangeably with <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">match</span></code>.</p> </div> <div id="method_string" class="api_method_wrapper"> <h3 id="stringstr-msg">.string(str[, msg])</h3> <ul class="tags"> <li class="tag">
<span class="type">@param</span> <span class="types">{ String }</span> <span class="name">str</span> 
</li> <li class="tag">
<span class="type">@param</span> <span class="types">{ String }</span> <span class="name">msg</span> <span class="desc">_optional_</span>
</li> </ul> <p>Asserts that the target string contains the given substring <code class="language-js highlighter-rouge"><span class="nx">str</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect('foobar').to.have.string('bar');
</pre></div></div> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">not</span></code> earlier in the chain to negate <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">string</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect('foobar').to.not.have.string('taco');
</pre></div></div> <p><code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">string</span></code> accepts an optional <code class="language-js highlighter-rouge"><span class="nx">msg</span></code> argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to <code class="language-js highlighter-rouge"><span class="nx">expect</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect('foobar').to.have.string('taco', 'nooo why fail??');
expect('foobar', 'nooo why fail??').to.have.string('taco');
</pre></div></div> </div> <div id="method_keys" class="api_method_wrapper"> <h3 id="keyskey1-key2-">.keys(key1[, key2[, …]])</h3> <ul class="tags"> <li class="tag">
<span class="type">@param</span> <span class="types">{ String | Array | Object }</span> <span class="name">keys</span> 
</li> </ul> <p>Asserts that the target object, array, map, or set has the given keys. Only the target’s own inherited properties are included in the search.</p> <p>When the target is an object or array, keys can be provided as one or more string arguments, a single array argument, or a single object argument. In the latter case, only the keys in the given object matter; the values are ignored.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
expect(['x', 'y']).to.have.all.keys(0, 1);

expect({a: 1, b: 2}).to.have.all.keys(['a', 'b']);
expect(['x', 'y']).to.have.all.keys([0, 1]);

expect({a: 1, b: 2}).to.have.all.keys({a: 4, b: 5}); // ignore 4 and 5
expect(['x', 'y']).to.have.all.keys({0: 4, 1: 5}); // ignore 4 and 5
</pre></div></div> <p>When the target is a map or set, each key must be provided as a separate argument.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(new Map([['a', 1], ['b', 2]])).to.have.all.keys('a', 'b');
expect(new Set(['a', 'b'])).to.have.all.keys('a', 'b');
</pre></div></div> <p>Because <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">keys</span></code> does different things based on the target’s type, it’s important to check the target’s type before using <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">keys</span></code>. See the <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">a</span></code> doc for info on testing a target’s type.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect({a: 1, b: 2}).to.be.an('object').that.has.all.keys('a', 'b');
</pre></div></div> <p>By default, strict (<code class="language-js highlighter-rouge"><span class="o">===</span></code>) equality is used to compare keys of maps and sets. Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">deep</span></code> earlier in the chain to use deep equality instead. See the <code class="language-js highlighter-rouge"><span class="nx">deep</span><span class="o">-</span><span class="nx">eql</span></code> project page for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">// Target set deeply (but not strictly) has key `{a: 1}`
expect(new Set([{a: 1}])).to.have.all.deep.keys([{a: 1}]);
expect(new Set([{a: 1}])).to.not.have.all.keys([{a: 1}]);
</pre></div></div> <p>By default, the target must have all of the given keys and no more. Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">any</span></code> earlier in the chain to only require that the target have at least one of the given keys. Also, add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">not</span></code> earlier in the chain to negate <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">keys</span></code>. It’s often best to add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">any</span></code> when negating <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">keys</span></code>, and to use <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">all</span></code> when asserting <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">keys</span></code> without negation.</p> <p>When negating <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">keys</span></code>, <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">any</span></code> is preferred because <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">not</span><span class="p">.</span><span class="nx">any</span><span class="p">.</span><span class="nx">keys</span></code> asserts exactly what’s expected of the output, whereas <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">not</span><span class="p">.</span><span class="nx">all</span><span class="p">.</span><span class="nx">keys</span></code> creates uncertain expectations.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">// Recommended; asserts that target doesn't have any of the given keys
expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');

// Not recommended; asserts that target doesn't have all of the given
// keys but may or may not have some of them
expect({a: 1, b: 2}).to.not.have.all.keys('c', 'd');
</pre></div></div> <p>When asserting <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">keys</span></code> without negation, <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">all</span></code> is preferred because <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">all</span><span class="p">.</span><span class="nx">keys</span></code> asserts exactly what’s expected of the output, whereas <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">any</span><span class="p">.</span><span class="nx">keys</span></code> creates uncertain expectations.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">// Recommended; asserts that target has all the given keys
expect({a: 1, b: 2}).to.have.all.keys('a', 'b');

// Not recommended; asserts that target has at least one of the given
// keys but may or may not have more of them
expect({a: 1, b: 2}).to.have.any.keys('a', 'b');
</pre></div></div> <p>Note that <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">all</span></code> is used by default when neither <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">all</span></code> nor <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">any</span></code> appear earlier in the chain. However, it’s often best to add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">all</span></code> anyway because it improves readability.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">// Both assertions are identical
expect({a: 1, b: 2}).to.have.all.keys('a', 'b'); // Recommended
expect({a: 1, b: 2}).to.have.keys('a', 'b'); // Not recommended
</pre></div></div> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">include</span></code> earlier in the chain to require that the target’s keys be a superset of the expected keys, rather than identical sets.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">// Target object's keys are a superset of ['a', 'b'] but not identical
expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');
expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');
</pre></div></div> <p>However, if <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">any</span></code> and <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">include</span></code> are combined, only the <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">any</span></code> takes effect. The <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">include</span></code> is ignored in this case.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">// Both assertions are identical
expect({a: 1}).to.have.any.keys('a', 'b');
expect({a: 1}).to.include.any.keys('a', 'b');
</pre></div></div> <p>A custom error message can be given as the second argument to <code class="language-js highlighter-rouge"><span class="nx">expect</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect({a: 1}, 'nooo why fail??').to.have.key('b');
</pre></div></div> <p>The alias <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">key</span></code> can be used interchangeably with <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">keys</span></code>.</p> </div> <div id="method_throw" class="api_method_wrapper"> <h3 id="throwerrorlike-errmsgmatcher-msg">.throw([errorLike], [errMsgMatcher], [msg])</h3> <ul class="tags"> <li class="tag">
<span class="type">@param</span> <span class="types">{ Error | ErrorConstructor }</span> <span class="name">errorLike</span> 
</li> <li class="tag">
<span class="type">@param</span> <span class="types">{ String | RegExp }</span> <span class="name">errMsgMatcher</span> <span class="desc">error message</span>
</li> <li class="tag">
<span class="type">@param</span> <span class="types">{ String }</span> <span class="name">msg</span> <span class="desc">_optional_</span>
</li> <li class="tag">
<span class="type">@see</span> <span class="type"><a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types" target="_blank">https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types</a></span>
</li> </ul> <p>When no arguments are provided, <code class="language-js highlighter-rouge"><span class="p">.</span><span class="k">throw</span></code> invokes the target function and asserts that an error is thrown.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">var badFn = function () { throw new TypeError('Illegal salmon!'); };

expect(badFn).to.throw();
</pre></div></div> <p>When one argument is provided, and it’s an error constructor, <code class="language-js highlighter-rouge"><span class="p">.</span><span class="k">throw</span></code> invokes the target function and asserts that an error is thrown that’s an instance of that error constructor.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">var badFn = function () { throw new TypeError('Illegal salmon!'); };

expect(badFn).to.throw(TypeError);
</pre></div></div> <p>When one argument is provided, and it’s an error instance, <code class="language-js highlighter-rouge"><span class="p">.</span><span class="k">throw</span></code> invokes the target function and asserts that an error is thrown that’s strictly (<code class="language-js highlighter-rouge"><span class="o">===</span></code>) equal to that error instance.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">var err = new TypeError('Illegal salmon!');
var badFn = function () { throw err; };

expect(badFn).to.throw(err);
</pre></div></div> <p>When one argument is provided, and it’s a string, <code class="language-js highlighter-rouge"><span class="p">.</span><span class="k">throw</span></code> invokes the target function and asserts that an error is thrown with a message that contains that string.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">var badFn = function () { throw new TypeError('Illegal salmon!'); };

expect(badFn).to.throw('salmon');
</pre></div></div> <p>When one argument is provided, and it’s a regular expression, <code class="language-js highlighter-rouge"><span class="p">.</span><span class="k">throw</span></code> invokes the target function and asserts that an error is thrown with a message that matches that regular expression.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">var badFn = function () { throw new TypeError('Illegal salmon!'); };

expect(badFn).to.throw(/salmon/);
</pre></div></div> <p>When two arguments are provided, and the first is an error instance or constructor, and the second is a string or regular expression, <code class="language-js highlighter-rouge"><span class="p">.</span><span class="k">throw</span></code> invokes the function and asserts that an error is thrown that fulfills both conditions as described above.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">var err = new TypeError('Illegal salmon!');
var badFn = function () { throw err; };

expect(badFn).to.throw(TypeError, 'salmon');
expect(badFn).to.throw(TypeError, /salmon/);
expect(badFn).to.throw(err, 'salmon');
expect(badFn).to.throw(err, /salmon/);
</pre></div></div> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">not</span></code> earlier in the chain to negate <code class="language-js highlighter-rouge"><span class="p">.</span><span class="k">throw</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">var goodFn = function () {};

expect(goodFn).to.not.throw();
</pre></div></div> <p>However, it’s dangerous to negate <code class="language-js highlighter-rouge"><span class="p">.</span><span class="k">throw</span></code> when providing any arguments. The problem is that it creates uncertain expectations by asserting that the target either doesn’t throw an error, or that it throws an error but of a different type than the given type, or that it throws an error of the given type but with a message that doesn’t include the given string. It’s often best to identify the exact output that’s expected, and then write an assertion that only accepts that exact output.</p> <p>When the target isn’t expected to throw an error, it’s often best to assert exactly that.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">var goodFn = function () {};

expect(goodFn).to.not.throw(); // Recommended
expect(goodFn).to.not.throw(ReferenceError, 'x'); // Not recommended
</pre></div></div> <p>When the target is expected to throw an error, it’s often best to assert that the error is of its expected type, and has a message that includes an expected string, rather than asserting that it doesn’t have one of many unexpected types, and doesn’t have a message that includes some string.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">var badFn = function () { throw new TypeError('Illegal salmon!'); };

expect(badFn).to.throw(TypeError, 'salmon'); // Recommended
expect(badFn).to.not.throw(ReferenceError, 'x'); // Not recommended
</pre></div></div> <p><code class="language-js highlighter-rouge"><span class="p">.</span><span class="k">throw</span></code> changes the target of any assertions that follow in the chain to be the error object that’s thrown.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">var err = new TypeError('Illegal salmon!');
err.code = 42;
var badFn = function () { throw err; };

expect(badFn).to.throw(TypeError).with.property('code', 42);
</pre></div></div> <p><code class="language-js highlighter-rouge"><span class="p">.</span><span class="k">throw</span></code> accepts an optional <code class="language-js highlighter-rouge"><span class="nx">msg</span></code> argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to <code class="language-js highlighter-rouge"><span class="nx">expect</span></code>. When not providing two arguments, always use the second form.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">var goodFn = function () {};

expect(goodFn).to.throw(TypeError, 'x', 'nooo why fail??');
expect(goodFn, 'nooo why fail??').to.throw();
</pre></div></div> <p>Due to limitations in ES5, <code class="language-js highlighter-rouge"><span class="p">.</span><span class="k">throw</span></code> may not always work as expected when using a transpiler such as Babel or TypeScript. In particular, it may produce unexpected results when subclassing the built-in <code class="language-js highlighter-rouge"><span class="nb">Error</span></code> object and then passing the subclassed constructor to <code class="language-js highlighter-rouge"><span class="p">.</span><span class="k">throw</span></code>. See your transpiler’s docs for details:</p> <ul> <li>(<a href="https://babeljs.io/docs/usage/caveats/#classes">Babel</a>)</li> <li>(<a href="https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work">TypeScript</a>)</li> </ul> <p>Beware of some common mistakes when using the <code class="language-js highlighter-rouge"><span class="k">throw</span></code> assertion. One common mistake is to accidentally invoke the function yourself instead of letting the <code class="language-js highlighter-rouge"><span class="k">throw</span></code> assertion invoke the function for you. For example, when testing if a function named <code class="language-js highlighter-rouge"><span class="nx">fn</span></code> throws, provide <code class="language-js highlighter-rouge"><span class="nx">fn</span></code> instead of <code class="language-js highlighter-rouge"><span class="nx">fn</span><span class="p">()</span></code> as the target for the assertion.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(fn).to.throw();     // Good! Tests `fn` as desired
expect(fn()).to.throw();   // Bad! Tests result of `fn()`, not `fn`
</pre></div></div> <p>If you need to assert that your function <code class="language-js highlighter-rouge"><span class="nx">fn</span></code> throws when passed certain arguments, then wrap a call to <code class="language-js highlighter-rouge"><span class="nx">fn</span></code> inside of another function.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(function () { fn(42); }).to.throw();  // Function expression
expect(() =&gt; fn(42)).to.throw();             // ES6 arrow function
</pre></div></div> <p>Another common mistake is to provide an object method (or any stand-alone function that relies on <code class="language-js highlighter-rouge"><span class="k">this</span></code>) as the target of the assertion. Doing so is problematic because the <code class="language-js highlighter-rouge"><span class="k">this</span></code> context will be lost when the function is invoked by <code class="language-js highlighter-rouge"><span class="p">.</span><span class="k">throw</span></code>; there’s no way for it to know what <code class="language-js highlighter-rouge"><span class="k">this</span></code> is supposed to be. There are two ways around this problem. One solution is to wrap the method or function call inside of another function. Another solution is to use <code class="language-js highlighter-rouge"><span class="nx">bind</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(function () { cat.meow(); }).to.throw();  // Function expression
expect(() =&gt; cat.meow()).to.throw();             // ES6 arrow function
expect(cat.meow.bind(cat)).to.throw();           // Bind
</pre></div></div> <p>Finally, it’s worth mentioning that it’s a best practice in JavaScript to only throw <code class="language-js highlighter-rouge"><span class="nb">Error</span></code> and derivatives of <code class="language-js highlighter-rouge"><span class="nb">Error</span></code> such as <code class="language-js highlighter-rouge"><span class="nx">ReferenceError</span></code>, <code class="language-js highlighter-rouge"><span class="nx">TypeError</span></code>, and user-defined objects that extend <code class="language-js highlighter-rouge"><span class="nb">Error</span></code>. No other type of value will generate a stack trace when initialized. With that said, the <code class="language-js highlighter-rouge"><span class="k">throw</span></code> assertion does technically support any type of value being thrown, not just <code class="language-js highlighter-rouge"><span class="nb">Error</span></code> and its derivatives.</p> <p>The aliases <code class="language-js highlighter-rouge"><span class="p">.</span><span class="kr">throws</span></code> and <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">Throw</span></code> can be used interchangeably with <code class="language-js highlighter-rouge"><span class="p">.</span><span class="k">throw</span></code>.</p> </div> <div id="method_respondto" class="api_method_wrapper"> <h3 id="respondtomethod-msg">.respondTo(method[, msg])</h3> <ul class="tags"> <li class="tag">
<span class="type">@param</span> <span class="types">{ String }</span> <span class="name">method</span> 
</li> <li class="tag">
<span class="type">@param</span> <span class="types">{ String }</span> <span class="name">msg</span> <span class="desc">_optional_</span>
</li> </ul> <p>When the target is a non-function object, <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">respondTo</span></code> asserts that the target has a method with the given name <code class="language-js highlighter-rouge"><span class="nx">method</span></code>. The method can be own or inherited, and it can be enumerable or non-enumerable.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">function Cat () {}
Cat.prototype.meow = function () {};

expect(new Cat()).to.respondTo('meow');
</pre></div></div> <p>When the target is a function, <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">respondTo</span></code> asserts that the target’s <code class="language-js highlighter-rouge"><span class="nx">prototype</span></code> property has a method with the given name <code class="language-js highlighter-rouge"><span class="nx">method</span></code>. Again, the method can be own or inherited, and it can be enumerable or non-enumerable.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">function Cat () {}
Cat.prototype.meow = function () {};

expect(Cat).to.respondTo('meow');
</pre></div></div> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">itself</span></code> earlier in the chain to force <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">respondTo</span></code> to treat the target as a non-function object, even if it’s a function. Thus, it asserts that the target has a method with the given name <code class="language-js highlighter-rouge"><span class="nx">method</span></code>, rather than asserting that the target’s <code class="language-js highlighter-rouge"><span class="nx">prototype</span></code> property has a method with the given name <code class="language-js highlighter-rouge"><span class="nx">method</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">function Cat () {}
Cat.prototype.meow = function () {};
Cat.hiss = function () {};

expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');
</pre></div></div> <p>When not adding <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">itself</span></code>, it’s important to check the target’s type before using <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">respondTo</span></code>. See the <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">a</span></code> doc for info on checking a target’s type.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">function Cat () {}
Cat.prototype.meow = function () {};

expect(new Cat()).to.be.an('object').that.respondsTo('meow');
</pre></div></div> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">not</span></code> earlier in the chain to negate <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">respondTo</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">function Dog () {}
Dog.prototype.bark = function () {};

expect(new Dog()).to.not.respondTo('meow');
</pre></div></div> <p><code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">respondTo</span></code> accepts an optional <code class="language-js highlighter-rouge"><span class="nx">msg</span></code> argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to <code class="language-js highlighter-rouge"><span class="nx">expect</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect({}).to.respondTo('meow', 'nooo why fail??');
expect({}, 'nooo why fail??').to.respondTo('meow');
</pre></div></div> <p>The alias <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">respondsTo</span></code> can be used interchangeably with <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">respondTo</span></code>.</p> </div> <div id="method_itself" class="api_method_wrapper"> <h3 id="itself">.itself</h3>  <p>Forces all <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">respondTo</span></code> assertions that follow in the chain to behave as if the target is a non-function object, even if it’s a function. Thus, it causes <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">respondTo</span></code> to assert that the target has a method with the given name, rather than asserting that the target’s <code class="language-js highlighter-rouge"><span class="nx">prototype</span></code> property has a method with the given name.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">function Cat () {}
Cat.prototype.meow = function () {};
Cat.hiss = function () {};

expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');
</pre></div></div> </div> <div id="method_satisfy" class="api_method_wrapper"> <h3 id="satisfymatcher-msg">.satisfy(matcher[, msg])</h3> <ul class="tags"> <li class="tag">
<span class="type">@param</span> <span class="types">{ Function }</span> <span class="name">matcher</span> 
</li> <li class="tag">
<span class="type">@param</span> <span class="types">{ String }</span> <span class="name">msg</span> <span class="desc">_optional_</span>
</li> </ul> <p>Invokes the given <code class="language-js highlighter-rouge"><span class="nx">matcher</span></code> function with the target being passed as the first argument, and asserts that the value returned is truthy.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(1).to.satisfy(function(num) {
  return num &gt; 0;
});
</pre></div></div> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">not</span></code> earlier in the chain to negate <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">satisfy</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(1).to.not.satisfy(function(num) {
  return num &gt; 2;
});
</pre></div></div> <p><code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">satisfy</span></code> accepts an optional <code class="language-js highlighter-rouge"><span class="nx">msg</span></code> argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to <code class="language-js highlighter-rouge"><span class="nx">expect</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(1).to.satisfy(function(num) {
  return num &gt; 2;
}, 'nooo why fail??');

expect(1, 'nooo why fail??').to.satisfy(function(num) {
  return num &gt; 2;
});
</pre></div></div> <p>The alias <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">satisfies</span></code> can be used interchangeably with <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">satisfy</span></code>.</p> </div> <div id="method_closeto" class="api_method_wrapper"> <h3 id="closetoexpected-delta-msg">.closeTo(expected, delta[, msg])</h3> <ul class="tags"> <li class="tag">
<span class="type">@param</span> <span class="types">{ Number }</span> <span class="name">expected</span> 
</li> <li class="tag">
<span class="type">@param</span> <span class="types">{ Number }</span> <span class="name">delta</span> 
</li> <li class="tag">
<span class="type">@param</span> <span class="types">{ String }</span> <span class="name">msg</span> <span class="desc">_optional_</span>
</li> </ul> <p>Asserts that the target is a number that’s within a given +/- <code class="language-js highlighter-rouge"><span class="nx">delta</span></code> range of the given number <code class="language-js highlighter-rouge"><span class="nx">expected</span></code>. However, it’s often best to assert that the target is equal to its expected value.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">// Recommended
expect(1.5).to.equal(1.5);

// Not recommended
expect(1.5).to.be.closeTo(1, 0.5);
expect(1.5).to.be.closeTo(2, 0.5);
expect(1.5).to.be.closeTo(1, 1);
</pre></div></div> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">not</span></code> earlier in the chain to negate <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">closeTo</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(1.5).to.equal(1.5); // Recommended
expect(1.5).to.not.be.closeTo(3, 1); // Not recommended
</pre></div></div> <p><code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">closeTo</span></code> accepts an optional <code class="language-js highlighter-rouge"><span class="nx">msg</span></code> argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to <code class="language-js highlighter-rouge"><span class="nx">expect</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(1.5).to.be.closeTo(3, 1, 'nooo why fail??');
expect(1.5, 'nooo why fail??').to.be.closeTo(3, 1);
</pre></div></div> <p>The alias <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">approximately</span></code> can be used interchangeably with <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">closeTo</span></code>.</p> </div> <div id="method_members" class="api_method_wrapper"> <h3 id="membersset-msg">.members(set[, msg])</h3> <ul class="tags"> <li class="tag">
<span class="type">@param</span> <span class="types">{ Array }</span> <span class="name">set</span> 
</li> <li class="tag">
<span class="type">@param</span> <span class="types">{ String }</span> <span class="name">msg</span> <span class="desc">_optional_</span>
</li> </ul> <p>Asserts that the target array has the same members as the given array <code class="language-js highlighter-rouge"><span class="kd">set</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect([1, 2, 3]).to.have.members([2, 1, 3]);
expect([1, 2, 2]).to.have.members([2, 1, 2]);
</pre></div></div> <p>By default, members are compared using strict (<code class="language-js highlighter-rouge"><span class="o">===</span></code>) equality. Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">deep</span></code> earlier in the chain to use deep equality instead. See the <code class="language-js highlighter-rouge"><span class="nx">deep</span><span class="o">-</span><span class="nx">eql</span></code> project page for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">// Target array deeply (but not strictly) has member `{a: 1}`
expect([{a: 1}]).to.have.deep.members([{a: 1}]);
expect([{a: 1}]).to.not.have.members([{a: 1}]);
</pre></div></div> <p>By default, order doesn’t matter. Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">ordered</span></code> earlier in the chain to require that members appear in the same order.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect([1, 2, 3]).to.have.ordered.members([1, 2, 3]);
expect([1, 2, 3]).to.have.members([2, 1, 3])
  .but.not.ordered.members([2, 1, 3]);
</pre></div></div> <p>By default, both arrays must be the same size. Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">include</span></code> earlier in the chain to require that the target’s members be a superset of the expected members. Note that duplicates are ignored in the subset when <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">include</span></code> is added.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">// Target array is a superset of [1, 2] but not identical
expect([1, 2, 3]).to.include.members([1, 2]);
expect([1, 2, 3]).to.not.have.members([1, 2]);

// Duplicates in the subset are ignored
expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);
</pre></div></div> <p><code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">deep</span></code>, <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">ordered</span></code>, and <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">include</span></code> can all be combined. However, if <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">include</span></code> and <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">ordered</span></code> are combined, the ordering begins at the start of both arrays.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect([{a: 1}, {b: 2}, {c: 3}])
  .to.include.deep.ordered.members([{a: 1}, {b: 2}])
  .but.not.include.deep.ordered.members([{b: 2}, {c: 3}]);
</pre></div></div> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">not</span></code> earlier in the chain to negate <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">members</span></code>. However, it’s dangerous to do so. The problem is that it creates uncertain expectations by asserting that the target array doesn’t have all of the same members as the given array <code class="language-js highlighter-rouge"><span class="kd">set</span></code> but may or may not have some of them. It’s often best to identify the exact output that’s expected, and then write an assertion that only accepts that exact output.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect([1, 2]).to.not.include(3).and.not.include(4); // Recommended
expect([1, 2]).to.not.have.members([3, 4]); // Not recommended
</pre></div></div> <p><code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">members</span></code> accepts an optional <code class="language-js highlighter-rouge"><span class="nx">msg</span></code> argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to <code class="language-js highlighter-rouge"><span class="nx">expect</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect([1, 2]).to.have.members([1, 2, 3], 'nooo why fail??');
expect([1, 2], 'nooo why fail??').to.have.members([1, 2, 3]);
</pre></div></div> </div> <div id="method_oneof" class="api_method_wrapper"> <h3 id="oneoflist-msg">.oneOf(list[, msg])</h3> <ul class="tags"> <li class="tag">
<span class="type">@param</span> <span class="types">{ Array. }</span> <span class="name">list</span> 
</li> <li class="tag">
<span class="type">@param</span> <span class="types">{ String }</span> <span class="name">msg</span> <span class="desc">_optional_</span>
</li> </ul> <p>Asserts that the target is a member of the given array <code class="language-js highlighter-rouge"><span class="nx">list</span></code>. However, it’s often best to assert that the target is equal to its expected value.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(1).to.equal(1); // Recommended
expect(1).to.be.oneOf([1, 2, 3]); // Not recommended
</pre></div></div> <p>Comparisons are performed using strict (<code class="language-js highlighter-rouge"><span class="o">===</span></code>) equality.</p> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">not</span></code> earlier in the chain to negate <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">oneOf</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(1).to.equal(1); // Recommended
expect(1).to.not.be.oneOf([2, 3, 4]); // Not recommended
</pre></div></div> <p><code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">oneOf</span></code> accepts an optional <code class="language-js highlighter-rouge"><span class="nx">msg</span></code> argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to <code class="language-js highlighter-rouge"><span class="nx">expect</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(1).to.be.oneOf([2, 3, 4], 'nooo why fail??');
expect(1, 'nooo why fail??').to.be.oneOf([2, 3, 4]);
</pre></div></div> </div> <div id="method_change" class="api_method_wrapper"> <h3 id="changesubject-prop-msg">.change(subject[, prop[, msg]])</h3> <ul class="tags"> <li class="tag">
<span class="type">@param</span> <span class="types">{ String }</span> <span class="name">subject</span> 
</li> <li class="tag">
<span class="type">@param</span> <span class="types">{ String }</span> <span class="name">prop</span> <span class="desc">name _optional_</span>
</li> <li class="tag">
<span class="type">@param</span> <span class="types">{ String }</span> <span class="name">msg</span> <span class="desc">_optional_</span>
</li> </ul> <p>When one argument is provided, <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">change</span></code> asserts that the given function <code class="language-js highlighter-rouge"><span class="nx">subject</span></code> returns a different value when it’s invoked before the target function compared to when it’s invoked afterward. However, it’s often best to assert that <code class="language-js highlighter-rouge"><span class="nx">subject</span></code> is equal to its expected value.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">var dots = ''
  , addDot = function () { dots += '.'; }
  , getDots = function () { return dots; };

// Recommended
expect(getDots()).to.equal('');
addDot();
expect(getDots()).to.equal('.');

// Not recommended
expect(addDot).to.change(getDots);
</pre></div></div> <p>When two arguments are provided, <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">change</span></code> asserts that the value of the given object <code class="language-js highlighter-rouge"><span class="nx">subject</span></code>’s <code class="language-js highlighter-rouge"><span class="nx">prop</span></code> property is different before invoking the target function compared to afterward.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">var myObj = {dots: ''}
  , addDot = function () { myObj.dots += '.'; };

// Recommended
expect(myObj).to.have.property('dots', '');
addDot();
expect(myObj).to.have.property('dots', '.');

// Not recommended
expect(addDot).to.change(myObj, 'dots');
</pre></div></div> <p>Strict (<code class="language-js highlighter-rouge"><span class="o">===</span></code>) equality is used to compare before and after values.</p> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">not</span></code> earlier in the chain to negate <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">change</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">var dots = ''
  , noop = function () {}
  , getDots = function () { return dots; };

expect(noop).to.not.change(getDots);

var myObj = {dots: ''}
  , noop = function () {};

expect(noop).to.not.change(myObj, 'dots');
</pre></div></div> <p><code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">change</span></code> accepts an optional <code class="language-js highlighter-rouge"><span class="nx">msg</span></code> argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to <code class="language-js highlighter-rouge"><span class="nx">expect</span></code>. When not providing two arguments, always use the second form.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">var myObj = {dots: ''}
  , addDot = function () { myObj.dots += '.'; };

expect(addDot).to.not.change(myObj, 'dots', 'nooo why fail??');

var dots = ''
  , addDot = function () { dots += '.'; }
  , getDots = function () { return dots; };

expect(addDot, 'nooo why fail??').to.not.change(getDots);
</pre></div></div> <p><code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">change</span></code> also causes all <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">by</span></code> assertions that follow in the chain to assert how much a numeric subject was increased or decreased by. However, it’s dangerous to use <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">change</span><span class="p">.</span><span class="nx">by</span></code>. The problem is that it creates uncertain expectations by asserting that the subject either increases by the given delta, or that it decreases by the given delta. It’s often best to identify the exact output that’s expected, and then write an assertion that only accepts that exact output.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">var myObj = {val: 1}
  , addTwo = function () { myObj.val += 2; }
  , subtractTwo = function () { myObj.val -= 2; };

expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended

expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended
</pre></div></div> <p>The alias <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">changes</span></code> can be used interchangeably with <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">change</span></code>.</p> </div> <div id="method_increase" class="api_method_wrapper"> <h3 id="increasesubject-prop-msg">.increase(subject[, prop[, msg]])</h3> <ul class="tags"> <li class="tag">
<span class="type">@param</span> <span class="types">{ String | Function }</span> <span class="name">subject</span> 
</li> <li class="tag">
<span class="type">@param</span> <span class="types">{ String }</span> <span class="name">prop</span> <span class="desc">name _optional_</span>
</li> <li class="tag">
<span class="type">@param</span> <span class="types">{ String }</span> <span class="name">msg</span> <span class="desc">_optional_</span>
</li> </ul> <p>When one argument is provided, <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">increase</span></code> asserts that the given function <code class="language-js highlighter-rouge"><span class="nx">subject</span></code> returns a greater number when it’s invoked after invoking the target function compared to when it’s invoked beforehand. <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">increase</span></code> also causes all <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">by</span></code> assertions that follow in the chain to assert how much greater of a number is returned. It’s often best to assert that the return value increased by the expected amount, rather than asserting it increased by any amount.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">var val = 1
  , addTwo = function () { val += 2; }
  , getVal = function () { return val; };

expect(addTwo).to.increase(getVal).by(2); // Recommended
expect(addTwo).to.increase(getVal); // Not recommended
</pre></div></div> <p>When two arguments are provided, <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">increase</span></code> asserts that the value of the given object <code class="language-js highlighter-rouge"><span class="nx">subject</span></code>’s <code class="language-js highlighter-rouge"><span class="nx">prop</span></code> property is greater after invoking the target function compared to beforehand.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">var myObj = {val: 1}
  , addTwo = function () { myObj.val += 2; };

expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
expect(addTwo).to.increase(myObj, 'val'); // Not recommended
</pre></div></div> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">not</span></code> earlier in the chain to negate <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">increase</span></code>. However, it’s dangerous to do so. The problem is that it creates uncertain expectations by asserting that the subject either decreases, or that it stays the same. It’s often best to identify the exact output that’s expected, and then write an assertion that only accepts that exact output.</p> <p>When the subject is expected to decrease, it’s often best to assert that it decreased by the expected amount.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">var myObj = {val: 1}
  , subtractTwo = function () { myObj.val -= 2; };

expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
expect(subtractTwo).to.not.increase(myObj, 'val'); // Not recommended
</pre></div></div> <p>When the subject is expected to stay the same, it’s often best to assert exactly that.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">var myObj = {val: 1}
  , noop = function () {};

expect(noop).to.not.change(myObj, 'val'); // Recommended
expect(noop).to.not.increase(myObj, 'val'); // Not recommended
</pre></div></div> <p><code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">increase</span></code> accepts an optional <code class="language-js highlighter-rouge"><span class="nx">msg</span></code> argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to <code class="language-js highlighter-rouge"><span class="nx">expect</span></code>. When not providing two arguments, always use the second form.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">var myObj = {val: 1}
  , noop = function () {};

expect(noop).to.increase(myObj, 'val', 'nooo why fail??');

var val = 1
  , noop = function () {}
  , getVal = function () { return val; };

expect(noop, 'nooo why fail??').to.increase(getVal);
</pre></div></div> <p>The alias <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">increases</span></code> can be used interchangeably with <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">increase</span></code>.</p> </div> <div id="method_decrease" class="api_method_wrapper"> <h3 id="decreasesubject-prop-msg">.decrease(subject[, prop[, msg]])</h3> <ul class="tags"> <li class="tag">
<span class="type">@param</span> <span class="types">{ String | Function }</span> <span class="name">subject</span> 
</li> <li class="tag">
<span class="type">@param</span> <span class="types">{ String }</span> <span class="name">prop</span> <span class="desc">name _optional_</span>
</li> <li class="tag">
<span class="type">@param</span> <span class="types">{ String }</span> <span class="name">msg</span> <span class="desc">_optional_</span>
</li> </ul> <p>When one argument is provided, <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">decrease</span></code> asserts that the given function <code class="language-js highlighter-rouge"><span class="nx">subject</span></code> returns a lesser number when it’s invoked after invoking the target function compared to when it’s invoked beforehand. <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">decrease</span></code> also causes all <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">by</span></code> assertions that follow in the chain to assert how much lesser of a number is returned. It’s often best to assert that the return value decreased by the expected amount, rather than asserting it decreased by any amount.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">var val = 1
  , subtractTwo = function () { val -= 2; }
  , getVal = function () { return val; };

expect(subtractTwo).to.decrease(getVal).by(2); // Recommended
expect(subtractTwo).to.decrease(getVal); // Not recommended
</pre></div></div> <p>When two arguments are provided, <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">decrease</span></code> asserts that the value of the given object <code class="language-js highlighter-rouge"><span class="nx">subject</span></code>’s <code class="language-js highlighter-rouge"><span class="nx">prop</span></code> property is lesser after invoking the target function compared to beforehand.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">var myObj = {val: 1}
  , subtractTwo = function () { myObj.val -= 2; };

expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
expect(subtractTwo).to.decrease(myObj, 'val'); // Not recommended
</pre></div></div> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">not</span></code> earlier in the chain to negate <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">decrease</span></code>. However, it’s dangerous to do so. The problem is that it creates uncertain expectations by asserting that the subject either increases, or that it stays the same. It’s often best to identify the exact output that’s expected, and then write an assertion that only accepts that exact output.</p> <p>When the subject is expected to increase, it’s often best to assert that it increased by the expected amount.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">var myObj = {val: 1}
  , addTwo = function () { myObj.val += 2; };

expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
expect(addTwo).to.not.decrease(myObj, 'val'); // Not recommended
</pre></div></div> <p>When the subject is expected to stay the same, it’s often best to assert exactly that.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">var myObj = {val: 1}
  , noop = function () {};

expect(noop).to.not.change(myObj, 'val'); // Recommended
expect(noop).to.not.decrease(myObj, 'val'); // Not recommended
</pre></div></div> <p><code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">decrease</span></code> accepts an optional <code class="language-js highlighter-rouge"><span class="nx">msg</span></code> argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to <code class="language-js highlighter-rouge"><span class="nx">expect</span></code>. When not providing two arguments, always use the second form.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">var myObj = {val: 1}
  , noop = function () {};

expect(noop).to.decrease(myObj, 'val', 'nooo why fail??');

var val = 1
  , noop = function () {}
  , getVal = function () { return val; };

expect(noop, 'nooo why fail??').to.decrease(getVal);
</pre></div></div> <p>The alias <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">decreases</span></code> can be used interchangeably with <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">decrease</span></code>.</p> </div> <div id="method_by" class="api_method_wrapper"> <h3 id="bydelta-msg">.by(delta[, msg])</h3> <ul class="tags"> <li class="tag">
<span class="type">@param</span> <span class="types">{ Number }</span> <span class="name">delta</span> 
</li> <li class="tag">
<span class="type">@param</span> <span class="types">{ String }</span> <span class="name">msg</span> <span class="desc">_optional_</span>
</li> </ul> <p>When following an <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">increase</span></code> assertion in the chain, <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">by</span></code> asserts that the subject of the <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">increase</span></code> assertion increased by the given <code class="language-js highlighter-rouge"><span class="nx">delta</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">var myObj = {val: 1}
  , addTwo = function () { myObj.val += 2; };

expect(addTwo).to.increase(myObj, 'val').by(2);
</pre></div></div> <p>When following a <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">decrease</span></code> assertion in the chain, <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">by</span></code> asserts that the subject of the <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">decrease</span></code> assertion decreased by the given <code class="language-js highlighter-rouge"><span class="nx">delta</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">var myObj = {val: 1}
  , subtractTwo = function () { myObj.val -= 2; };

expect(subtractTwo).to.decrease(myObj, 'val').by(2);
</pre></div></div> <p>When following a <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">change</span></code> assertion in the chain, <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">by</span></code> asserts that the subject of the <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">change</span></code> assertion either increased or decreased by the given <code class="language-js highlighter-rouge"><span class="nx">delta</span></code>. However, it’s dangerous to use <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">change</span><span class="p">.</span><span class="nx">by</span></code>. The problem is that it creates uncertain expectations. It’s often best to identify the exact output that’s expected, and then write an assertion that only accepts that exact output.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">var myObj = {val: 1}
  , addTwo = function () { myObj.val += 2; }
  , subtractTwo = function () { myObj.val -= 2; };

expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended

expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended
</pre></div></div> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">not</span></code> earlier in the chain to negate <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">by</span></code>. However, it’s often best to assert that the subject changed by its expected delta, rather than asserting that it didn’t change by one of countless unexpected deltas.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">var myObj = {val: 1}
  , addTwo = function () { myObj.val += 2; };

// Recommended
expect(addTwo).to.increase(myObj, 'val').by(2);

// Not recommended
expect(addTwo).to.increase(myObj, 'val').but.not.by(3);
</pre></div></div> <p><code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">by</span></code> accepts an optional <code class="language-js highlighter-rouge"><span class="nx">msg</span></code> argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to <code class="language-js highlighter-rouge"><span class="nx">expect</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">var myObj = {val: 1}
  , addTwo = function () { myObj.val += 2; };

expect(addTwo).to.increase(myObj, 'val').by(3, 'nooo why fail??');
expect(addTwo, 'nooo why fail??').to.increase(myObj, 'val').by(3);
</pre></div></div> </div> <div id="method_extensible" class="api_method_wrapper"> <h3 id="extensible">.extensible</h3>  <p>Asserts that the target is extensible, which means that new properties can be added to it. Primitives are never extensible.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect({a: 1}).to.be.extensible;
</pre></div></div> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">not</span></code> earlier in the chain to negate <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">extensible</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">var nonExtensibleObject = Object.preventExtensions({})
  , sealedObject = Object.seal({})
  , frozenObject = Object.freeze({});

expect(nonExtensibleObject).to.not.be.extensible;
expect(sealedObject).to.not.be.extensible;
expect(frozenObject).to.not.be.extensible;
expect(1).to.not.be.extensible;
</pre></div></div> <p>A custom error message can be given as the second argument to <code class="language-js highlighter-rouge"><span class="nx">expect</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(1, 'nooo why fail??').to.be.extensible;
</pre></div></div> </div> <div id="method_sealed" class="api_method_wrapper"> <h3 id="sealed">.sealed</h3>  <p>Asserts that the target is sealed, which means that new properties can’t be added to it, and its existing properties can’t be reconfigured or deleted. However, it’s possible that its existing properties can still be reassigned to different values. Primitives are always sealed.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">var sealedObject = Object.seal({});
var frozenObject = Object.freeze({});

expect(sealedObject).to.be.sealed;
expect(frozenObject).to.be.sealed;
expect(1).to.be.sealed;
</pre></div></div> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">not</span></code> earlier in the chain to negate <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">sealed</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect({a: 1}).to.not.be.sealed;
</pre></div></div> <p>A custom error message can be given as the second argument to <code class="language-js highlighter-rouge"><span class="nx">expect</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect({a: 1}, 'nooo why fail??').to.be.sealed;
</pre></div></div> </div> <div id="method_frozen" class="api_method_wrapper"> <h3 id="frozen">.frozen</h3>  <p>Asserts that the target is frozen, which means that new properties can’t be added to it, and its existing properties can’t be reassigned to different values, reconfigured, or deleted. Primitives are always frozen.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">var frozenObject = Object.freeze({});

expect(frozenObject).to.be.frozen;
expect(1).to.be.frozen;
</pre></div></div> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">not</span></code> earlier in the chain to negate <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">frozen</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect({a: 1}).to.not.be.frozen;
</pre></div></div> <p>A custom error message can be given as the second argument to <code class="language-js highlighter-rouge"><span class="nx">expect</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect({a: 1}, 'nooo why fail??').to.be.frozen;
</pre></div></div> </div> <div id="method_finite" class="api_method_wrapper"> <h3 id="finite">.finite</h3>  <p>Asserts that the target is a number, and isn’t <code class="language-js highlighter-rouge"><span class="kc">NaN</span></code> or positive/negative <code class="language-js highlighter-rouge"><span class="kc">Infinity</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(1).to.be.finite;
</pre></div></div> <p>Add <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">not</span></code> earlier in the chain to negate <code class="language-js highlighter-rouge"><span class="p">.</span><span class="nx">finite</span></code>. However, it’s dangerous to do so. The problem is that it creates uncertain expectations by asserting that the subject either isn’t a number, or that it’s <code class="language-js highlighter-rouge"><span class="kc">NaN</span></code>, or that it’s positive <code class="language-js highlighter-rouge"><span class="kc">Infinity</span></code>, or that it’s negative <code class="language-js highlighter-rouge"><span class="kc">Infinity</span></code>. It’s often best to identify the exact output that’s expected, and then write an assertion that only accepts that exact output.</p> <p>When the target isn’t expected to be a number, it’s often best to assert that it’s the expected type, rather than asserting that it isn’t one of many unexpected types.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect('foo').to.be.a('string'); // Recommended
expect('foo').to.not.be.finite; // Not recommended
</pre></div></div> <p>When the target is expected to be <code class="language-js highlighter-rouge"><span class="kc">NaN</span></code>, it’s often best to assert exactly that.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(NaN).to.be.NaN; // Recommended
expect(NaN).to.not.be.finite; // Not recommended
</pre></div></div> <p>When the target is expected to be positive infinity, it’s often best to assert exactly that.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(Infinity).to.equal(Infinity); // Recommended
expect(Infinity).to.not.be.finite; // Not recommended
</pre></div></div> <p>When the target is expected to be negative infinity, it’s often best to assert exactly that.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect(-Infinity).to.equal(-Infinity); // Recommended
expect(-Infinity).to.not.be.finite; // Not recommended
</pre></div></div> <p>A custom error message can be given as the second argument to <code class="language-js highlighter-rouge"><span class="nx">expect</span></code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect('foo', 'nooo why fail??').to.be.finite;
</pre></div></div> </div> <div id="method_fail" class="api_method_wrapper"> <h3 id="failmessage">.fail([message])</h3> <h3 id="failactual-expected-message-operator">.fail(actual, expected, [message], [operator])</h3> <ul class="tags"> <li class="tag">
<span class="type">@param</span> <span class="types">{ Mixed }</span> <span class="name">actual</span> 
</li> <li class="tag">
<span class="type">@param</span> <span class="types">{ Mixed }</span> <span class="name">expected</span> 
</li> <li class="tag">
<span class="type">@param</span> <span class="types">{ String }</span> <span class="name">message</span> 
</li> <li class="tag">
<span class="type">@param</span> <span class="types">{ String }</span> <span class="name">operator</span> 
</li> </ul> <p>Throw a failure.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">expect.fail();
expect.fail("custom error message");
expect.fail(1, 2);
expect.fail(1, 2, "custom error message");
expect.fail(1, 2, "custom error message", "&gt;");
expect.fail(1, 2, undefined, "&gt;");
</pre></div></div> </div> <div id="method_fail" class="api_method_wrapper"> <h3 id="failmessage">.fail([message])</h3> <h3 id="failactual-expected-message-operator">.fail(actual, expected, [message], [operator])</h3> <ul class="tags"> <li class="tag">
<span class="type">@param</span> <span class="types">{ Mixed }</span> <span class="name">actual</span> 
</li> <li class="tag">
<span class="type">@param</span> <span class="types">{ Mixed }</span> <span class="name">expected</span> 
</li> <li class="tag">
<span class="type">@param</span> <span class="types">{ String }</span> <span class="name">message</span> 
</li> <li class="tag">
<span class="type">@param</span> <span class="types">{ String }</span> <span class="name">operator</span> 
</li> </ul> <p>Throw a failure.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">should.fail();
should.fail("custom error message");
should.fail(1, 2);
should.fail(1, 2, "custom error message");
should.fail(1, 2, "custom error message", "&gt;");
should.fail(1, 2, undefined, "&gt;");
</pre></div></div> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2017 Chai.js Assertion Library<br>Licensed under the MIT License.<br>
    <a href="https://www.chaijs.com/api/bdd/" class="_attribution-link">https://www.chaijs.com/api/bdd/</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
