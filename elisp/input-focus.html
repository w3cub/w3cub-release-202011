
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Input Focus - Elisp - W3cubDocs</title>
  
  <meta name="description" content=" At any time, one frame in Emacs is the selected frame. The selected window always resides on the selected frame. ">
  <meta name="keywords" content="input, focus, elisp">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/elisp/input-focus.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/elisp.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/elisp/" class="_nav-link" title="" style="margin-left:0;">Elisp</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _elisp">
				
				
<h3 class="section">Input Focus</h3>   <p>At any time, one frame in Emacs is the <em>selected frame</em>. The selected window always resides on the selected frame. </p> <p>When Emacs displays its frames on several terminals (see <a href="multiple-terminals#Multiple-Terminals">Multiple Terminals</a>), each terminal has its own selected frame. But only one of these is <em>the</em> selected frame: it’s the frame that belongs to the terminal from which the most recent input came. That is, when Emacs runs a command that came from a certain terminal, the selected frame is the one of that terminal. Since Emacs runs only a single command at any given time, it needs to consider only one selected frame at a time; this frame is what we call <em>the selected frame</em> in this manual. The display on which the selected frame is shown is the <em>selected frame’s display</em>. </p> <dl> <dt id="selected-frame">
Function: <strong>selected-frame</strong>
</dt> <dd><p>This function returns the selected frame. </p></dd>
</dl> <p>Some window systems and window managers direct keyboard input to the window object that the mouse is in; others require explicit clicks or commands to <em>shift the focus</em> to various window objects. Either way, Emacs automatically keeps track of which frames have focus. To explicitly switch to a different frame from a Lisp function, call <code>select-frame-set-input-focus</code>. </p> <p>The plural “frames” in the previous paragraph is deliberate: while Emacs itself has only one selected frame, Emacs can have frames on many different terminals (recall that a connection to a window system counts as a terminal), and each terminal has its own idea of which frame has input focus. When you set the input focus to a frame, you set the focus for that frame’s terminal, but frames on other terminals may still remain focused. </p> <p>Lisp programs can switch frames temporarily by calling the function <code>select-frame</code>. This does not alter the window system’s concept of focus; rather, it escapes from the window manager’s control until that control is somehow reasserted. </p> <p>When using a text terminal, only one frame can be displayed at a time on the terminal, so after a call to <code>select-frame</code>, the next redisplay actually displays the newly selected frame. This frame remains selected until a subsequent call to <code>select-frame</code>. Each frame on a text terminal has a number which appears in the mode line before the buffer name (see <a href="mode-line-variables#Mode-Line-Variables">Mode Line Variables</a>). </p> <dl> <dt id="select-frame-set-input-focus">
Function: <strong>select-frame-set-input-focus</strong> <em>frame &amp;optional norecord</em>
</dt> <dd><p>This function selects <var>frame</var>, raises it (should it happen to be obscured by other frames) and tries to give it the window system’s focus. On a text terminal, the next redisplay displays the new frame on the entire terminal screen. The optional argument <var>norecord</var> has the same meaning as for <code>select-frame</code> (see below). The return value of this function is not significant. </p></dd>
</dl> <p>Ideally, the function described next should focus a frame without also raising it above other frames. Unfortunately, many window-systems or window managers may refuse to comply. </p> <dl> <dt id="x-focus-frame">
Function: <strong>x-focus-frame</strong> <em>frame &amp;optional noactivate</em>
</dt> <dd>
<p>This function gives <var>frame</var> the focus of the X server without necessarily raising it. <var>frame</var> <code>nil</code> means use the selected frame. Under X, the optional argument <var>noactivate</var>, if non-<code>nil</code>, means to avoid making <var>frame</var>’s window-system window the “active” window which should insist a bit more on avoiding to raise <var>frame</var> above other frames. </p> <p>On MS-Windows the <var>noactivate</var> argument has no effect. However, if <var>frame</var> is a child frame (see <a href="child-frames#Child-Frames">Child Frames</a>), this function usually focuses <var>frame</var> without raising it above other child frames. </p> <p>If there is no window system support, this function does nothing. </p>
</dd>
</dl> <dl> <dt id="select-frame">
Command: <strong>select-frame</strong> <em>frame &amp;optional norecord</em>
</dt> <dd>
<p>This function selects frame <var>frame</var>, temporarily disregarding the focus of the X server if any. The selection of <var>frame</var> lasts until the next time the user does something to select a different frame, or until the next time this function is called. (If you are using a window system, the previously selected frame may be restored as the selected frame after return to the command loop, because it still may have the window system’s input focus.) </p> <p>The specified <var>frame</var> becomes the selected frame, and its terminal becomes the selected terminal. This function then calls <code>select-window</code> as a subroutine, passing the window selected within <var>frame</var> as its first argument and <var>norecord</var> as its second argument (hence, if <var>norecord</var> is non-<code>nil</code>, this avoids changing the order of recently selected windows and the buffer list). See <a href="selecting-windows#Selecting-Windows">Selecting Windows</a>. </p> <p>This function returns <var>frame</var>, or <code>nil</code> if <var>frame</var> has been deleted. </p> <p>In general, you should never use <code>select-frame</code> in a way that could switch to a different terminal without switching back when you’re done. </p>
</dd>
</dl>  <p>Emacs cooperates with the window system by arranging to select frames as the server and window manager request. When a window system informs Emacs that one of its frames has been selected, Emacs internally generates a <em>focus-in</em> event. When an Emacs frame is displayed on a text-terminal emulator, such as <code>xterm</code>, which supports reporting of focus-change notification, the focus-in and focus-out events are available even for text-mode frames. Focus events are normally handled by <code>handle-focus-in</code>. </p> <dl> <dt id="handle-focus-in">
Command: <strong>handle-focus-in</strong> <em>event</em>
</dt> <dd><p>This function handles focus-in events from window systems and terminals that support explicit focus notifications. It updates the per-frame focus flags that <code>frame-focus-state</code> queries and calls <code>after-focus-change-function</code>. In addition, it generates a <code>switch-frame</code> event in order to switch the Emacs notion of the selected frame to the frame most recently focused in some terminal. It’s important to note that this switching of the Emacs selected frame to the most recently focused frame does not mean that other frames do not continue to have the focus in their respective terminals. Do not invoke this function yourself: instead, attach logic to <code>after-focus-change-function</code>. </p></dd>
</dl> <dl> <dt id="handle-switch-frame">
Command: <strong>handle-switch-frame</strong> <em>frame</em>
</dt> <dd><p>This function handles a switch-frame event, which Emacs generates for itself upon focus notification or under various other circumstances involving an input event arriving at a different frame from the last event. Do not invoke this function yourself. </p></dd>
</dl> <dl> <dt id="redirect-frame-focus">
Function: <strong>redirect-frame-focus</strong> <em>frame &amp;optional focus-frame</em>
</dt> <dd>
<p>This function redirects focus from <var>frame</var> to <var>focus-frame</var>. This means that <var>focus-frame</var> will receive subsequent keystrokes and events intended for <var>frame</var>. After such an event, the value of <code>last-event-frame</code> will be <var>focus-frame</var>. Also, switch-frame events specifying <var>frame</var> will instead select <var>focus-frame</var>. </p> <p>If <var>focus-frame</var> is omitted or <code>nil</code>, that cancels any existing redirection for <var>frame</var>, which therefore once again receives its own events. </p> <p>One use of focus redirection is for frames that don’t have minibuffers. These frames use minibuffers on other frames. Activating a minibuffer on another frame redirects focus to that frame. This puts the focus on the minibuffer’s frame, where it belongs, even though the mouse remains in the frame that activated the minibuffer. </p> <p>Selecting a frame can also change focus redirections. Selecting frame <code>bar</code>, when <code>foo</code> had been selected, changes any redirections pointing to <code>foo</code> so that they point to <code>bar</code> instead. This allows focus redirection to work properly when the user switches from one frame to another using <code>select-window</code>. </p> <p>This means that a frame whose focus is redirected to itself is treated differently from a frame whose focus is not redirected. <code>select-frame</code> affects the former but not the latter. </p> <p>The redirection lasts until <code>redirect-frame-focus</code> is called to change it. </p>
</dd>
</dl> <dl> <dt id="frame-focus-state">
Function: <strong>frame-focus-state</strong> <em>frame</em>
</dt> <dd>
<p>This function retrieves the last known focus state of <var>frame</var>. </p> <p>It returns <code>nil</code> if the frame is known not to be focused, <code>t</code> if the frame is known to be focused, or <code>unknown</code> if Emacs does not know the focus state of the frame. (You may see this last state in TTY frames running on terminals that do not support explicit focus notifications.) </p>
</dd>
</dl> <dl> <dt id="after-focus-change-function">
Variable: <strong>after-focus-change-function</strong>
</dt> <dd>
<p>This function is an extension point that code can use to receive a notification that focus has changed. </p> <p>This function is called with no arguments when Emacs notices that the set of focused frames may have changed. Code wanting to do something when frame focus changes should use <code>add-function</code> to add a function to this one, and in this added function, re-scan the set of focused frames, calling <code>frame-focus-state</code> to retrieve the last known focus state of each frame. Focus events are delivered asynchronously, and frame input focus according to an external system may not correspond to the notion of the Emacs selected frame. Multiple frames may appear to have input focus simultaneously due to focus event delivery differences, the presence of multiple Emacs terminals, and other factors, and code should be robust in the face of this situation. </p> <p>Depending on window system, focus events may also be delivered repeatedly and with different focus states before settling to the expected values. Code relying on focus notifications should “debounce” any user-visible updates arising from focus changes, perhaps by deferring work until redisplay. </p> <p>This function may be called in arbitrary contexts, including from inside <code>read-event</code>, so take the same care as you might when writing a process filter. </p>
</dd>
</dl> <dl> <dt id="focus-follows-mouse">
User Option: <strong>focus-follows-mouse</strong>
</dt> <dd>
<p>This option informs Emacs whether and how the window manager transfers focus when you move the mouse pointer into a frame. It can have three meaningful values: </p> <dl compact> <dt><code>nil</code></dt> <dd>
<p>The default value <code>nil</code> should be used when your window manager follows a “click-to-focus” policy where you have to click the mouse inside of a frame in order for that frame to gain focus. </p> </dd> <dt><code>t</code></dt> <dd>
<p>The value <code>t</code> should be used when your window manager has the focus automatically follow the position of the mouse pointer but a frame that gains focus is not raised automatically and may even remain occluded by other window-system windows. </p> </dd> <dt><code>auto-raise</code></dt> <dd><p>The value <code>auto-raise</code> should be used when your window manager has the focus automatically follow the position of the mouse pointer and a frame that gains focus is raised automatically. </p></dd> </dl> <p>If this option is non-<code>nil</code>, Emacs moves the mouse pointer to the frame selected by <code>select-frame-set-input-focus</code>. That function is used by a number of commands like, for example, <code>other-frame</code> and <code>pop-to-buffer</code>. </p> <p>The distinction between the values <code>t</code> and <code>auto-raise</code> is not needed for “normal” frames because the window manager usually takes care of raising them. It is useful to automatically raise child frames via <code>mouse-autoselect-window</code> (see <a href="mouse-window-auto_002dselection#Mouse-Window-Auto_002dselection">Mouse Window Auto-selection</a>). </p> <p>Note that this option does not distinguish “sloppy” focus (where the frame that previously had focus retains focus as long as the mouse pointer does not move into another window manager window) from “strict” focus (where a frame immediately loses focus when it’s left by the mouse pointer). Neither does it recognize whether your window manager supports delayed focusing or auto-raising where you can explicitly specify the time until a new frame gets focus or is auto-raised. </p> <p>You can supply a “focus follows mouse” policy for individual Emacs windows by customizing the variable <code>mouse-autoselect-window</code> (see <a href="mouse-window-auto_002dselection#Mouse-Window-Auto_002dselection">Mouse Window Auto-selection</a>). </p>
</dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    Copyright © 1990-1996, 1998-2019 Free Software Foundation, Inc. <br>Licensed under the GNU GPL license.<br>
    <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Input-Focus.html" class="_attribution-link">https://www.gnu.org/software/emacs/manual/html_node/elisp/Input-Focus.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
