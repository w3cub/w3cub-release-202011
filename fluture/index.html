
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Fluture Documentation - W3cubDocs</title>
  
  <meta name="description" content=" Fluture documentation ">
  <meta name="keywords" content="fluture, documentation">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/fluture/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-9b6ce6139b8492a0447e9396e58206baee4973e9a8a1d9126d4ab69e244811034e5265efcc9da8b9550a8e365367ee3ea1d2c5757f9a5fc1720dc94cd4df775b.css">
  <script type="text/javascript" src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js"></script>
  <script src="/json/fluture.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/fluture/" class="_nav-link" title="" style="margin-left:0;">Fluture</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _fluture">
				
				
<h1 tabindex="-1" dir="auto" id="">Fluture</h1>  <p dir="auto">Fluture offers a control structure similar to Promises, Tasks, Deferreds, and what-have-you. Let's call them Futures.</p> <p dir="auto">Much like Promises, Futures represent the value arising from the success or failure of an asynchronous operation (I/O). Though unlike Promises, Futures are <em>lazy</em> and adhere to .</p> <p dir="auto">Some of the features provided by Fluture include:</p> <ul dir="auto"> <li>
<a href="#cancellation">Cancellation</a>.</li> <li>
<a href="#resource-management">Resource management utilities</a>.</li> <li>
<a href="#stack-safety">Stack safe composition and recursion</a>.</li> <li>
<a href="#sanctuary">Integration</a> with <a href="https://sanctuary.js.org/" rel="nofollow">Sanctuary</a>.</li> <li>
<a href="#debugging">A pleasant debugging experience</a>.</li> </ul> <p dir="auto">For more information:</p> <ul dir="auto"> <li><a href="#documentation">API documentation</a></li> <li><a href="https://dev.to/avaq/fluture-a-functional-alternative-to-promises-21b" rel="nofollow">Article: Introduction to Fluture - A Functional Alternative to Promises</a></li> <li><a href="https://github.com/fluture-js/Fluture/wiki/Comparison-to-Promises">Wiki: Compare Futures to Promises</a></li> <li><a href="https://github.com/fluture-js/Fluture/wiki/Comparison-of-Future-Implementations">Wiki: Compare Fluture to similar libraries</a></li> <li><a href="https://vimeo.com/106008027" rel="nofollow">Video: Monad a Day - Futures by @DrBoolean</a></li> </ul> <h2 tabindex="-1" dir="auto" id="installation">Installation</h2> <h2 tabindex="-1" dir="auto" id="with-npm">With NPM</h2> <pre data-language="">$ npm install --save fluture</pre> <h2 tabindex="-1" dir="auto" id="bundled-from-a-cdn">Bundled from a CDN</h2> <p dir="auto">To load Fluture directly into a browser, a code pen, or , use one of the following downloads from the JSDelivr content delivery network. These are single files that come with all of Fluture's dependencies pre-bundled.</p> <ul dir="auto"> <li>
<a href="https://cdn.jsdelivr.net/gh/fluture-js/Fluture@14.0.0/dist/bundle.js" rel="nofollow">Fluture Script</a>: A JavaScript file that adds <code>Fluture</code> to the global scope. Ideal for older browsers and code pens.</li> <li>
<a href="https://cdn.jsdelivr.net/gh/fluture-js/Fluture@14.0.0/dist/bundle.min.js" rel="nofollow">Fluture Script Minified</a>: The same as above, but minified.</li> <li>
<a href="https://cdn.jsdelivr.net/gh/fluture-js/Fluture@14.0.0/dist/module.js" rel="nofollow">Fluture Module</a>: An EcmaScript module with named exports. Ideal for Deno or modern browsers.</li> <li>
<a href="https://cdn.jsdelivr.net/gh/fluture-js/Fluture@14.0.0/dist/module.min.js" rel="nofollow">Fluture Module Minified</a>: A minified EcmaScript module without TypeScript typings. Not recommended for Deno.</li> </ul> <h2 tabindex="-1" dir="auto" id="usage">Usage</h2> <h2 tabindex="-1" dir="auto" id="ecmascript-module">EcmaScript Module</h2> <p dir="auto">Fluture is written as modular JavaScript.</p> <ul dir="auto"> <li>On Node 14 and up, Fluture can be loaded directly with <code>import 'fluture'</code>.</li> <li>On Node 13 and lower, Fluture can be loaded directly with <code>import 'fluture/index.js'</code>.</li> <li>On Node 12, the <code>--experimental-modules</code> flag must be provided in addition.</li> <li>On Node versions below 12, the <a href="https://github.com/standard-things/esm">esm loader</a> can be used. Alternatively, there is a <a href="#commonjs-module">CommonJS Module</a> available.</li> <li>Modern browsers can run Fluture directly. If you'd like to try this out, I recommend installing Fluture with <a href="https://www.pikapkg.com/" rel="nofollow">Pika</a> or <a href="https://www.snowpack.dev/" rel="nofollow">Snowpack</a>. You can also try the <a href="#bundled-from-a-cdn">bundled module</a> to avoid a package manager.</li> <li>For older browsers, use a bundler such as <a href="https://rollupjs.org/" rel="nofollow">Rollup</a> or WebPack. Besides the module system, Fluture uses purely ES5-compatible syntax, so the source does not have to be transpiled after bundling. Alternatively, there is a <a href="#commonjs-module">CommonJS Module</a> available.</li> </ul> <pre data-language="js">import {readFile} from 'fs'
import {node, encase, chain, map, fork} from 'fluture'

const getPackageName = file =&gt; (
  node (done =&gt; { readFile (file, 'utf8', done) })
  .pipe (chain (encase (JSON.parse)))
  .pipe (map (x =&gt; x.name))
)

getPackageName ('package.json')
.pipe (fork (console.error) (console.log))</pre> <h2 tabindex="-1" dir="auto" id="commonjs-module">CommonJS Module</h2> <p dir="auto">Although the Fluture source uses the EcmaScript module system, the <code>main</code> file points to a CommonJS version of Fluture.</p> <p dir="auto">On older environments one or more of the following functions may need to be polyfilled: ,  and .</p> <pre data-language="js">const fs = require ('fs')
const Future = require ('fluture')

const getPackageName = function (file) {
  return Future.node (function (done) { fs.readFile (file, 'utf8', done) })
  .pipe (Future.chain (Future.encase (JSON.parse)))
  .pipe (Future.map (function (x) { return x.name }))
}

getPackageName ('package.json')
.pipe (Future.fork (console.error) (console.log))</pre> <h2 tabindex="-1" dir="auto" id="documentation">Documentation</h2> <h2 tabindex="-1" dir="auto" id="table-of-contents">Table of contents</h2> <details open=""><summary>General</summary> <ul dir="auto"> <li><a href="#installation">Installation instructions</a></li> <li><a href="#usage">Usage instructions</a></li> <li><a href="#butterfly">About the Fluture project</a></li> <li><a href="#interoperability">On interoperability with other libraries</a></li> <li><a href="#type-signatures">How to read the type signatures</a></li> <li><a href="#cancellation">How cancellation works</a></li> <li><a href="#stack-safety">On stack safety</a></li> <li><a href="#debugging">Debugging with Fluture</a></li> <li><a href="#casting-futures-to-string">Casting Futures to String</a></li> <li><a href="#sanctuary">Usage with Sanctuary</a></li> <li><a href="#incompatible-fluture-versions">Using multiple versions of Fluture alongside each other</a></li> </ul> </details> <details><summary>Creating new Futures</summary> <ul dir="auto"> <li><a href="#future"><code>Future</code>: Create a possibly cancellable Future</a></li> <li><a href="#resolve"><code>resolve</code>: Create a resolved Future</a></li> <li><a href="#reject"><code>reject</code>: Create a rejected Future</a></li> <li><a href="#after"><code>after</code>: Create a Future that resolves after a timeout</a></li> <li><a href="#rejectafter"><code>rejectAfter</code>: Create a Future that rejects after a timeout</a></li> <li><a href="#go"><code>go</code>: Create a "coroutine" using a generator function</a></li> <li><a href="#attempt"><code>attempt</code>: Create a Future using a possibly throwing function</a></li> <li><a href="#attemptp"><code>attemptP</code>: Create a Future using a Promise-returning function</a></li> <li><a href="#node"><code>node</code>: Create a Future using a Node-style callback</a></li> <li><a href="#encase"><code>encase</code>: Convert a possibly throwing function to a Future function</a></li> <li><a href="#encasep"><code>encaseP</code>: Convert a Promise-returning function to a Future function</a></li> </ul> </details> <details><summary>Converting between Nodeback APIs and Futures</summary> <ul dir="auto"> <li><a href="#node"><code>node</code>: Create a Future using a Node-style callback</a></li> <li><a href="#done"><code>done</code>: Consume a Future by providing a Nodeback</a></li> </ul> </details> <details><summary>Converting between Promises and Futures</summary> <ul dir="auto"> <li><a href="#attemptp"><code>attemptP</code>: Create a Future using a Promise-returning function</a></li> <li><a href="#encasep"><code>encaseP</code>: Convert a Promise-returning function to a Future function</a></li> <li><a href="#promise"><code>promise</code>: Convert a Future to a Promise</a></li> </ul> </details> <details><summary>Transforming and combining Futures</summary> <ul dir="auto"> <li><a href="#pipe"><code>pipe</code>: Apply a function to a Future in a fluent method chain</a></li> <li><a href="#map"><code>map</code>: Synchronously process the success value in a Future</a></li> <li><a href="#bimap"><code>bimap</code>: Synchronously process the success or failure value in a Future</a></li> <li><a href="#chain"><code>chain</code>: Asynchronously process the success value in a Future</a></li> <li><a href="#bichain"><code>bichain</code>: Asynchronously process the success or failure value in a Future</a></li> <li><a href="#swap"><code>swap</code>: Swap the success with the failure value</a></li> <li><a href="#maprej"><code>mapRej</code>: Synchronously process the failure value in a Future</a></li> <li><a href="#chainrej"><code>chainRej</code>: Asynchronously process the failure value in a Future</a></li> <li><a href="#coalesce"><code>coalesce</code>: Coerce success and failure values into the same success value</a></li> <li><a href="#ap"><code>ap</code>: Combine the success values of multiple Futures using a function</a></li> <li><a href="#pap"><code>pap</code>: Combine the success values of multiple Futures in parallel using a function</a></li> <li><a href="#and"><code>and</code>: Logical <em>and</em> for Futures</a></li> <li><a href="#alt"><code>alt</code>: Logical <em>or</em> for Futures</a></li> <li><a href="#lastly"><code>lastly</code>: Run a Future after the previous settles</a></li> <li><a href="#race"><code>race</code>: Race two Futures against each other</a></li> <li><a href="#both"><code>both</code>: Await both success values from two Futures</a></li> <li><a href="#parallel"><code>parallel</code>: Await all success values from many Futures</a></li> </ul> </details> <details><summary>Consuming/forking Futures</summary> <ul dir="auto"> <li><a href="#fork"><code>fork</code>: Standard way to run a Future and get at its result</a></li> <li><a href="#forkcatch"><code>forkCatch</code>: Fork with exception recovery</a></li> <li><a href="#value"><code>value</code>: Shorter variant of <code>fork</code> for Futures sure to succeed</a></li> <li><a href="#done"><code>done</code>: Nodeback style <code>fork</code></a></li> <li><a href="#promise"><code>promise</code>: Convert a Future to a Promise</a></li> </ul> </details> <details><summary>Concurrency related utilities and data structures</summary> <ul dir="auto"> <li><a href="#pap"><code>pap</code>: Combine the success values of multiple Futures in parallel using a function</a></li> <li><a href="#race"><code>race</code>: Race two Futures against each other</a></li> <li><a href="#both"><code>both</code>: Await both success values from two Futures</a></li> <li><a href="#parallel"><code>parallel</code>: Await all success values from many Futures</a></li> <li><a href="#concurrentfuture"><code>ConcurrentFuture</code>: A separate data-type for doing algebraic concurrency</a></li> <li><a href="#alt"><code>alt</code>: Behaves like <code>race</code> on <code>ConcurrentFuture</code> instances</a></li> </ul> </details> <details><summary>Resource management</summary> <ul dir="auto"> <li><a href="#hook"><code>hook</code>: Safely create and dispose resources</a></li> <li><a href="#lastly"><code>lastly</code>: Run a Future after the previous settles</a></li> </ul> </details> <details><summary>Other utilities</summary> <ul dir="auto"> <li><a href="#pipe"><code>pipe</code>: Apply a function to a Future in a fluent method chain</a></li> <li><a href="#cache"><code>cache</code>: Cache a Future so that it can be forked multiple times</a></li> <li><a href="#isfuture"><code>isFuture</code>: Determine whether a value is a Fluture compatible Future</a></li> <li><a href="#never"><code>never</code>: A Future that never settles</a></li> <li><a href="#debugmode"><code>debugMode</code>: Configure Fluture's debug mode</a></li> <li><a href="#context"><code>context</code>: The debugging context of a Future instance</a></li> </ul> </details> <h2 tabindex="-1" dir="auto" id="butterfly">Butterfly</h2> <p dir="auto">The name "Fluture" is a conjunction of "FL" (the acronym to ) and "future". Fluture means butterfly in Romanian: A creature one might expect to see in Fantasy Land.</p> <p dir="auto">Credit goes to Erik Fuente for styling the logo, and  for sponsoring the project.</p> <h2 tabindex="-1" dir="auto" id="interoperability">Interoperability</h2>  <ul dir="auto"> <li>
<code>Future</code> implements <a href="https://github.com/fantasyland/fantasy-land">Fantasy Land</a> 1.0+ -compatible <code>Alt</code>, <code>Bifunctor</code>, <code>Monad</code>, and <code>ChainRec</code> (<code>of</code>, <code>ap</code>, <code>alt</code>, <code>map</code>, <code>bimap</code>, <code>chain</code>, <code>chainRec</code>).</li> <li>
<code>Future.Par</code> implements <a href="https://github.com/fantasyland/fantasy-land">Fantasy Land 3</a> -compatible <code>Alternative</code> (<code>of</code>, <code>zero</code>, <code>map</code>, <code>ap</code>, <code>alt</code>).</li> <li>The Future and ConcurrentFuture representatives contain <code>@@type</code> properties for <a href="https://github.com/sanctuary-js/sanctuary-type-identifiers">Sanctuary Type Identifiers</a>.</li> <li>The Future and ConcurrentFuture instances contain <code>@@show</code> properties for <a href="https://github.com/sanctuary-js/sanctuary-show">Sanctuary Show</a>.</li> </ul> <h2 tabindex="-1" dir="auto" id="type-signatures">Type signatures</h2> <p dir="auto">The various function signatures are provided in a small language referred to as Hindley-Milner notation.</p> <p dir="auto">In summary, the syntax is as follows: <code>InputType -&gt; OutputType</code>. Now, because functions in Fluture are , the "output" of a function is often <em>another function</em>. In Hindley-Milner that's simply written as <code>InputputType -&gt; InputToSecondFunction -&gt; OutputType</code> and so forth.</p> <p dir="auto">By convention, types starting with an upper-case letter are . When they start with a lower-case letter they're <em>type variables</em>. You can think of these type variables as generic types. So <code>a -&gt; b</code> denotes a function from generic type <code>a</code> to generic type <code>b</code>.</p> <p dir="auto">Finally, through so-called , type variables can be forced to conform to an "interface" (or <em>Type Class</em> in functional jargon). For example, <code>MyInterface a =&gt; a -&gt; b</code>, denotes a function from generic type <code>a</code> to generic type <code>b</code>, <em>where <code>a</code> must implement <code>MyInterface</code></em>.</p> <p dir="auto">You can read in depth about  here.</p> <h3 tabindex="-1" dir="auto" id="types">Types</h3> <p dir="auto">The concrete types you will encounter throughout this documentation:</p> <ul dir="auto"> <li>
<strong>Future</strong> - Instances of Future provided by <a href="#incompatible-fluture-versions">compatible versions</a> of Fluture.</li> <li>
<strong>ConcurrentFuture</strong> - Futures wrapped with (<a href="#concurrentfuture"><code>Future.Par</code></a>).</li> <li>
<strong>Promise a b</strong> - Values which conform to the <a href="https://promisesaplus.com/" rel="nofollow">Promises/A+ specification</a> and have a rejection reason of type <code>a</code> and a resolution value of type <code>b</code>.</li> <li>
<strong>Nodeback a b</strong> - A Node-style callback; A function of signature <code>(a | Nil, b) -&gt; x</code>.</li> <li>
<strong>Pair a b</strong> - An array with exactly two elements: <code>[a, b]</code>.</li> <li>
<strong>Iterator</strong> - Objects with <code>next</code>-methods which conform to the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterator" rel="nofollow">Iterator protocol</a>.</li> <li>
<strong>Cancel</strong> - The nullary <a href="#cancellation">cancellation</a> functions returned from computations.</li> <li>
<strong>Throwing e a b</strong> - A function from <code>a</code> to <code>b</code> that may throw an exception <code>e</code>.</li> <li>
<strong>List</strong> - Fluture's internal linked-list structure: <code>{ head :: Any, tail :: List }</code>.</li> <li>
<strong>Context</strong> - Fluture's internal debugging context object: <code>{ tag :: String, name :: String, stack :: String }</code>.</li> </ul> <h3 tabindex="-1" dir="auto" id="type-classes">Type classes</h3> <p dir="auto">Some signatures contain . Generally, these constraints express that some value must conform to a -specified interface.</p> <ul dir="auto"> <li>
<strong>Functor</strong> - <a href="https://github.com/fantasyland/fantasy-land#functor">Fantasy Land Functor</a> conformant values.</li> <li>
<strong>Bifunctor</strong> - <a href="https://github.com/fantasyland/fantasy-land#bifunctor">Fantasy Land Bifunctor</a> conformant values.</li> <li>
<strong>Chain</strong> - <a href="https://github.com/fantasyland/fantasy-land#chain">Fantasy Land Chain</a> conformant values.</li> <li>
<strong>Apply</strong> - <a href="https://github.com/fantasyland/fantasy-land#apply">Fantasy Land Apply</a> conformant values.</li> <li>
<strong>Alt</strong> - <a href="https://github.com/fantasyland/fantasy-land#alt">Fantasy Land Alt</a> conformant values.</li> </ul> <h2 tabindex="-1" dir="auto" id="cancellation">Cancellation</h2> <p dir="auto">Cancellation is a system whereby running Futures get an opportunity to stop what they're doing and release resources that they were holding, when the consumer indicates it is no longer interested in the result.</p> <p dir="auto">To cancel a Future, it must be unsubscribed from. Most of the  return an <code>unsubscribe</code> function. Calling it signals that we are no longer interested in the result. After calling <code>unsubscribe</code>, Fluture guarantees that our callbacks will not be called; but more importantly: a cancellation signal is sent upstream.</p> <p dir="auto">The cancellation signal travels all the way back to the source (with the exception of cached Futures - see ), allowing all parties along the way to clean up.</p> <p dir="auto">With the , we can provide a custom cancellation handler by returning it from the computation. Let's see what this looks like:</p> <pre data-language="js">// We use the Future constructor to create a Future instance.
const eventualAnswer = Future (function computeTheAnswer (rej, res) {

  // We give the computer time to think about the answer, which is 42.
  const timeoutId = setTimeout (res, 60000, 42)

  // Here is how we handle cancellation. This signal is received when nobody
  // is interested in the answer any more.
  return function onCancel () {
    // Clearing the timeout releases the resources we were holding.
    clearTimeout (timeoutId)
  }

})

// Now, let's fork our computation and wait for an answer. Forking gives us
// the unsubscribe function.
const unsubscribe = fork (log ('rejection')) (log ('resolution')) (eventualAnswer)

// After some time passes, we might not care about the answer any more.
// Calling unsubscribe will send a cancellation signal back to the source,
// and trigger the onCancel function.
unsubscribe ()</pre> <p dir="auto">Many natural sources in Fluture have cancellation handlers of their own. , for example, does exactly what we've done just now: calling <code>clearTimeout</code>.</p> <p dir="auto">Finally, Fluture unsubscribes from Futures that it forks <em>for us</em>, when it no longer needs the result. For example, both Futures passed into  are forked, but once one of them produces a result, the other is unsubscribed from, triggering cancellation. This means that generally, unsubscription and cancellation is fully managed for us behind the scenes.</p> <h2 tabindex="-1" dir="auto" id="stack-safety">Stack safety</h2> <p dir="auto">Fluture interprets our transformations in a stack safe way. This means that none of the following operations result in a <code>RangeError: Maximum call stack size exceeded</code>:</p> <pre data-language="js">&gt; const add1 = x =&gt; x + 1

&gt; let m = resolve (1)

&gt; for (let i = 0; i &lt; 100000; i++) {
.   m = map (add1) (m)
. }

&gt; fork (log ('rejection')) (log ('resolution')) (m)
[resolution]: 100001</pre> <pre data-language="js">&gt; const m = (function recur (x) {
.   const mx = resolve (x + 1)
.   return x &lt; 100000 ? chain (recur) (mx) : mx
. }(1))

&gt; fork (log ('rejection')) (log ('resolution')) (m)
[resolution]: 100001</pre> <p dir="auto">To learn more about memory and stack usage under different types of recursion, see (or execute) .</p> <h2 tabindex="-1" dir="auto" id="debugging">Debugging</h2> <p dir="auto">First and foremost, Fluture type-checks all of its input and throws TypeErrors when incorrect input is provided. The messages they carry are designed to provide enough insight to figure out what went wrong.</p> <p dir="auto">Secondly, Fluture catches exceptions that are thrown asynchronously, and exposes them to you in one of two ways:</p> <ol dir="auto"> <li>By throwing an Error when it happens.</li> <li>By calling your <a href="#forkcatch">exception handler</a> with an Error.</li> </ol> <p dir="auto">The original exception isn't used because it might have been any value. Instead, a regular JavaScript Error instance whose properties are based on the original exception is created. Its properties are as follows:</p> <ul dir="auto"> <li>
<code>name</code>: Always just <code>"Error"</code>.</li> <li>
<code>message</code>: The original error message, or a message describing the value.</li> <li>
<code>reason</code>: The original value that was caught by Fluture.</li> <li>
<code>context</code>: A linked list of "context" objects. This is used to create the <code>stack</code> property, and you generally don't need to look at it. If debug mode is not enabled, the list is always empty.</li> <li>
<code>stack</code>: The stack trace of the original exception if it had one, or the Error's own stack trace otherwise. If debug mode (see below) is enabled, additional stack traces from the steps leading up to the crash are included.</li> <li>
<code>future</code>: The instance of <a href="#future"><code>Future</code></a> that was being <a href="#consuming-futures">consumed</a> when the exception happened. Often <a href="#casting-futures-to-string">printing it as a String</a> can yield useful information. You can also try to consume it in isolation to better identify what's going wrong.</li> </ul> <p dir="auto">Finally, as mentioned, Fluture has a  wherein additional contextual information across multiple JavaScript ticks is collected, included as an extended "async stack trace" on Errors, and .</p> <p dir="auto">Debug mode can have a significant impact on performance, and uses up memory, so I would advise against using it in production.</p> <h2 tabindex="-1" dir="auto" id="casting-futures-to-string">Casting Futures to String</h2> <p dir="auto">There are multiple ways to print a Future to String. Let's take a simple computation as an example:</p> <pre data-language="js">const add = a =&gt; b =&gt; a + b;
const eventualAnswer = ap (resolve (22)) (map (add) (resolve (20)));</pre> <ol dir="auto"> <li> <p dir="auto">Casting it to String directly by calling <code>String(eventualAnswer)</code> or <code>eventualAnswer.toString()</code> will yield an approximation of the code that was used to create the Future. In this case:</p> <pre data-language="js">"ap (resolve (22)) (map (a =&gt; b =&gt; a + b) (resolve (20)))"</pre> </li> <li> <p dir="auto">Casting it to String using <code>JSON.stringify(eventualAnswer, null, 2)</code> will yield a kind of abstract syntax tree.</p> <pre data-language="json">{
  "$": "fluture/Future@5",
  "kind": "interpreter",
  "type": "transform",
  "args": [
    {
      "$": "fluture/Future@5",
      "kind": "interpreter",
      "type": "resolve",
      "args": [
        20
      ]
    },
    [
      {
        "$": "fluture/Future@5",
        "kind": "transformation",
        "type": "ap",
        "args": [
          {
            "$": "fluture/Future@5",
            "kind": "interpreter",
            "type": "resolve",
            "args": [
              22
            ]
          }
        ]
      },
      {
        "$": "fluture/Future@5",
        "kind": "transformation",
        "type": "map",
        "args": [
          null
        ]
      }
    ]
  ]
}</pre> </li> </ol> <h2 tabindex="-1" dir="auto" id="sanctuary">Sanctuary</h2> <p dir="auto">When using this module with  (and  by extension) one might run into the following issue:</p> <pre data-language="js">&gt; import S from 'sanctuary'

&gt; import {resolve} from 'fluture'

&gt; S.I (resolve (1))
! TypeError: Since there is no type of which all the above values are members,
. the type-variable constraint has been violated.</pre> <p dir="auto">This happens because Sanctuary Def needs to know about the types created by Fluture to determine whether the type-variables are consistent.</p> <p dir="auto">To let Sanctuary know about these types, we can obtain the type definitions from  and pass them to :</p> <pre data-language="js">&gt; import sanctuary from 'sanctuary'

&gt; import {env as flutureEnv} from 'fluture-sanctuary-types'

&gt; import {resolve} from 'fluture'

&gt; const S = sanctuary.create ({checkTypes: true, env: sanctuary.env.concat (flutureEnv)})

&gt; fork (log ('rejection'))
.      (log ('resolution'))
.      (S.I (resolve (42)))
[resolution]: 42</pre> <h2 tabindex="-1" dir="auto" id="incompatible-fluture-versions">Incompatible Fluture Versions</h2> <p dir="auto">Most versions of Fluture understand how to consume instances from most other versions, even across Fluture's major releases. This allows for different packages that depend on Fluture to interact.</p> <p dir="auto">However, sometimes it's unavoidable that a newer version of Fluture is released that can no longer understand older versions, and vice-versa. This only ever happens on a major release, and will be mentioned in the breaking change log. When two incompatible versions of Fluture meet instances, they do their best to issue a clear error message about it.</p> <p dir="auto">When this happens, you need to manually convert the older instance to a newer instance of Future. When  returns <code>false</code>, a conversion is necessary. You can also apply this trick if the Future comes from another library similar to Fluture.</p> <pre data-language="js">const NoFuture = require ('incompatible-future')

const incompatible = NoFuture.of ('Hello')

const compatible = Future ((rej, res) =&gt; {
  return NoFuture.fork (rej) (res) (incompatible)
})

both (compatible) (resolve ('world'))</pre> <h2 tabindex="-1" dir="auto" id="creating-futures">Creating Futures</h2> <h3 tabindex="-1" dir="auto" id="future">Future</h3> <pre data-language="haskell">Future :: ((a -&gt; Undefined, b -&gt; Undefined) -&gt; Cancel) -&gt; Future a b</pre> <p dir="auto">Creates a Future with the given computation. A computation is a function which takes two callbacks. Both are continuations for the computation. The first is <code>reject</code>, commonly abbreviated to <code>rej</code>; The second is <code>resolve</code>, or <code>res</code>. When the computation is finished (possibly asynchronously) it may call the appropriate continuation with a failure or success value.</p> <p dir="auto">Additionally, the computation must return a nullary function containing cancellation logic. See .</p> <p dir="auto">If you find that there is no way to cancel your computation, you can return a <code>noop</code> function as a cancellation function. However, at this point there is usually a more fitting way to  (like for example via ).</p> <pre data-language="js">&gt; fork (log ('rejection'))
.      (log ('resolution'))
.      (Future (function computation (reject, resolve) {
.        const t = setTimeout (resolve, 20, 42)
.        return () =&gt; clearTimeout (t)
.      }))
[resolution]: 42</pre> <h3 tabindex="-1" dir="auto" id="resolve">resolve</h3> <pre data-language="haskell">resolve :: b -&gt; Future a b</pre> <p dir="auto">Creates a Future which immediately resolves with the given value.</p> <pre data-language="js">&gt; fork (log ('rejection'))
.      (log ('resolution'))
.      (resolve (42))
[answer]: 42</pre> <h3 tabindex="-1" dir="auto" id="reject">reject</h3> <pre data-language="haskell">reject :: a -&gt; Future a b</pre> <p dir="auto">Creates a Future which immediately rejects with the given value.</p> <pre data-language="js">&gt; fork (log ('rejection'))
.      (log ('resolution'))
.      (reject ('It broke!'))
[rejection]: "It broke!"</pre> <h3 tabindex="-1" dir="auto" id="after">after</h3> <pre data-language="haskell">after :: Number -&gt; b -&gt; Future a b</pre> <p dir="auto">Creates a Future which resolves with the given value after the given number of milliseconds.</p> <pre data-language="js">&gt; fork (log ('rejection'))
.      (log ('resolution'))
.      (after (20) (42))
[resolution]: 42</pre> <h3 tabindex="-1" dir="auto" id="rejectafter">rejectAfter</h3> <pre data-language="haskell">rejectAfter :: Number -&gt; a -&gt; Future a b</pre> <p dir="auto">Creates a Future which rejects with the given reason after the given number of milliseconds.</p> <pre data-language="js">&gt; fork (log ('rejection'))
.      (log ('resolution'))
.      (rejectAfter (20) ('It broke!'))
[rejection]: "It broke!"</pre> <h3 tabindex="-1" dir="auto" id="go">go</h3> <pre data-language="haskell">go :: (() -&gt; Iterator) -&gt; Future a b</pre> <p dir="auto">A way to do <code>async</code>/<code>await</code> with Futures, similar to Promise Coroutines or Haskell Do-notation.</p> <p dir="auto">Takes a function which returns an , commonly a generator-function, and chains every produced Future over the previous.</p> <pre data-language="js">&gt; fork (log ('rejection')) (log ('resolution')) (go (function*() {
.   const thing = yield after (20) ('world')
.   const message = yield after (20) ('Hello ' + thing)
.   return message + '!'
. }))
[resolution]: "Hello world!"</pre> <p dir="auto">A rejected Future short-circuits the whole coroutine.</p> <pre data-language="js">&gt; fork (log ('rejection')) (log ('resolution')) (go (function*() {
.   const thing = yield reject ('It broke!')
.   const message = yield after (20) ('Hello ' + thing)
.   return message + '!'
. }))
[rejection]: "It broke!"</pre> <p dir="auto">To handle rejections <em>inside</em> the coroutine, we need to  the error into our control domain.</p> <p dir="auto">I recommend using coalesce with an .</p> <pre data-language="js">&gt; const control = coalesce (S.Left) (S.Right)

&gt; fork (log ('rejection')) (log ('resolution')) (go (function*() {
.   const thing = yield control (reject ('It broke!'))
.   return S.either (x =&gt; `Oh no! ${x}`)
.                   (x =&gt; `Yippee! ${x}`)
.                   (thing)
. }))
[resolution]: "Oh no! It broke!"</pre> <h3 tabindex="-1" dir="auto" id="attempt">attempt</h3> <pre data-language="haskell">attempt :: Throwing e Undefined r -&gt; Future e r</pre> <p dir="auto">Creates a Future which resolves with the result of calling the given function, or rejects with the error thrown by the given function.</p> <p dir="auto">Short for .</p> <pre data-language="js">&gt; const data = {foo: 'bar'}

&gt; fork (log ('rejection'))
.      (log ('resolution'))
.      (attempt (() =&gt; data.foo.bar.baz))
[rejection]: new TypeError ("Cannot read property 'baz' of undefined")</pre> <h3 tabindex="-1" dir="auto" id="attemptp">attemptP</h3> <pre data-language="haskell">attemptP :: (Undefined -&gt; Promise a b) -&gt; Future a b</pre> <p dir="auto">Create a Future which when forked spawns a Promise using the given function and resolves with its resolution value, or rejects with its rejection reason.</p> <p dir="auto">Short for .</p> <pre data-language="js">&gt; fork (log ('rejection'))
.      (log ('resolution'))
.      (attemptP (() =&gt; Promise.resolve (42)))
[resolution]: 42</pre> <h3 tabindex="-1" dir="auto" id="node">node</h3> <pre data-language="haskell">node :: (Nodeback e r -&gt; x) -&gt; Future e r</pre> <p dir="auto">Creates a Future which rejects with the first argument given to the function, or resolves with the second if the first is not present.</p> <p dir="auto">Note that this function <strong>does not support cancellation</strong>.</p> <pre data-language="js">&gt; fork (log ('rejection'))
.      (log ('resolution'))
.      (node (done =&gt; done (null, 42)))
[resolution]: 42</pre> <h3 tabindex="-1" dir="auto" id="encase">encase</h3> <pre data-language="haskell">encase :: Throwing e a r -&gt; a -&gt; Future e r</pre> <p dir="auto">Takes a function and a value, and returns a Future which when forked calls the function with the value and resolves with the result. If the function throws an exception, it is caught and the Future will reject with the exception.</p> <p dir="auto">Applying <code>encase</code> with a function <code>f</code> creates a "safe" version of <code>f</code>. Instead of throwing exceptions, the encased version always returns a Future.</p> <pre data-language="js">&gt; fork (log ('rejection'))
.      (log ('resolution'))
.      (encase (JSON.parse) ('{"foo" = "bar"}'))
[rejection]: new SyntaxError ('Unexpected token =')</pre> <h3 tabindex="-1" dir="auto" id="encasep">encaseP</h3> <pre data-language="haskell">encaseP :: (a -&gt; Promise e r) -&gt; a -&gt; Future e r</pre> <p dir="auto">Turns Promise-returning functions into Future-returning functions.</p> <p dir="auto">Takes a function which returns a Promise, and a value, and returns a Future. When forked, the Future calls the function with the value to produce the Promise, and resolves with its resolution value, or rejects with its rejection reason.</p> <pre data-language="js">&gt; encaseP (fetch) ('https://api.github.com/users/Avaq')
. .pipe (chain (encaseP (res =&gt; res.json ())))
. .pipe (map (user =&gt; user.name))
. .pipe (fork (log ('rejection')) (log ('resolution')))
[resolution]: "Aldwin Vlasblom"</pre> <h2 tabindex="-1" dir="auto" id="transforming-futures">Transforming Futures</h2> <h3 tabindex="-1" dir="auto" id="map">map</h3> <pre data-language="haskell">map :: Functor m =&gt; (a -&gt; b) -&gt; m a -&gt; m b</pre> <p dir="auto">Transforms the resolution value inside the Future or , and returns a Future or Functor with the new value. The transformation is only applied to the resolution branch: if the Future is rejected, the transformation is ignored.</p> <p dir="auto">See also  and .</p> <pre data-language="js">&gt; fork (log ('rejection'))
.      (log ('resolution'))
.      (map (x =&gt; x + 1) (resolve (41)))
[resolution]: 42</pre> <p dir="auto">For comparison, an approximation with Promises is:</p> <pre data-language="js">&gt; Promise.resolve (41)
. .then (x =&gt; x + 1)
. .then (log ('resolution'), log ('rejection'))
[resolution]: 42</pre> <h3 tabindex="-1" dir="auto" id="bimap">bimap</h3> <pre data-language="haskell">bimap :: Bifunctor m =&gt; (a -&gt; c) -&gt; (b -&gt; d) -&gt; m a b -&gt; m c d</pre> <p dir="auto">Maps the left function over the rejection reason, or the right function over the resolution value, depending on which is present. Can be used on any .</p> <pre data-language="js">&gt; fork (log ('rejection'))
.      (log ('resolution'))
.      (bimap (x =&gt; x + '!') (x =&gt; x + 1) (resolve (41)))
[resolution]: 42

&gt; fork (log ('rejection'))
.      (log ('resolution'))
.      (bimap (x =&gt; x + '!') (x =&gt; x + 1) (reject ('It broke!')))
[rejection]: "It broke!!"</pre> <p dir="auto">For comparison, an approximation with Promises is:</p> <pre data-language="js">&gt; Promise.resolve (41)
. .then (x =&gt; x + 1, x =&gt; Promise.reject (x + '!'))
. .then (log ('resolution'), log ('rejection'))
[resolution]: 42

&gt; Promise.reject ('It broke!')
. .then (x =&gt; x + 1, x =&gt; Promise.reject (x + '!'))
. .then (log ('resolution'), log ('rejection'))
[rejection]: "It broke!!"</pre> <h3 tabindex="-1" dir="auto" id="chain">chain</h3> <pre data-language="haskell">chain :: Chain m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b</pre> <p dir="auto">Sequence a new Future or  using the resolution value from another. Similarly to , <code>chain</code> expects a function. But instead of returning the new <em>value</em>, chain expects a Future (or instance of the same Chain) to be returned.</p> <p dir="auto">The transformation is only applied to the resolution branch: if the Future is rejected, the transformation is ignored.</p> <p dir="auto">See also .</p> <pre data-language="js">&gt; fork (log ('rejection'))
.      (log ('resolution'))
.      (chain (x =&gt; resolve (x + 1)) (resolve (41)))
[resolution]: 42</pre> <p dir="auto">For comparison, an approximation with Promises is:</p> <pre data-language="js">&gt; Promise.resolve (41)
. .then (x =&gt; Promise.resolve (x + 1))
. .then (log ('resolution'), log ('rejection'))
[resolution]: 42</pre> <h3 tabindex="-1" dir="auto" id="bichain">bichain</h3> <pre data-language="haskell">bichain :: (a -&gt; Future c d) -&gt; (b -&gt; Future c d) -&gt; Future a b -&gt; Future c d</pre> <p dir="auto">Sequence a new Future using either the resolution or the rejection value from another. Similarly to , <code>bichain</code> expects two functions. But instead of returning the new <em>value</em>, bichain expects Futures to be returned.</p> <pre data-language="js">&gt; fork (log ('rejection'))
.      (log ('resolution'))
.      (bichain (resolve) (x =&gt; resolve (x + 1)) (resolve (41)))
[resolution]: 42

&gt; fork (log ('rejection'))
.      (log ('resolution'))
.      (bichain (x =&gt; resolve (x + 1)) (resolve) (reject (41)))
[resolution]: 42</pre> <p dir="auto">For comparison, an approximation with Promises is:</p> <pre data-language="js">&gt; Promise.resolve (41)
. .then (x =&gt; Promise.resolve (x + 1), Promise.resolve)
. .then (log ('resolution'), log ('rejection'))
[resolution]: 42

&gt; Promise.reject (41)
. .then (Promise.resolve, x =&gt; Promise.resolve (x + 1))
. .then (log ('resolution'), log ('rejection'))
[resolution]: 42</pre> <h3 tabindex="-1" dir="auto" id="swap">swap</h3> <pre data-language="haskell">swap :: Future a b -&gt; Future b a</pre> <p dir="auto">Swap the rejection and resolution branches.</p> <pre data-language="js">&gt; fork (log ('rejection'))
.      (log ('resolution'))
.      (swap (resolve (42)))
[rejection]: 42

&gt; fork (log ('rejection'))
.      (log ('resolution'))
.      (swap (reject (42)))
[resolution]: 42</pre> <h3 tabindex="-1" dir="auto" id="maprej">mapRej</h3> <pre data-language="haskell">mapRej :: (a -&gt; c) -&gt; Future a b -&gt; Future c b</pre> <p dir="auto">Map over the <strong>rejection</strong> reason of the Future. This is like , but for the rejection branch.</p> <pre data-language="js">&gt; fork (log ('rejection'))
.      (log ('resolution'))
.      (mapRej (s =&gt; `Oh no! ${s}`) (reject ('It broke!')))
[rejection]: "Oh no! It broke!"</pre> <p dir="auto">For comparison, an approximation with Promises is:</p> <pre data-language="js">&gt; Promise.reject ('It broke!')
. .then (null, s =&gt; Promise.reject (`Oh no! ${s}`))
. .then (log ('resolution'), log ('rejection'))
[rejection]: "Oh no! It broke!"</pre> <h3 tabindex="-1" dir="auto" id="chainrej">chainRej</h3> <pre data-language="haskell">chainRej :: (a -&gt; Future c b) -&gt; Future a b -&gt; Future c b</pre> <p dir="auto">Chain over the <strong>rejection</strong> reason of the Future. This is like , but for the rejection branch.</p> <pre data-language="js">&gt; fork (log ('rejection'))
.      (log ('resolution'))
.      (chainRej (s =&gt; resolve (`${s} But it's all good.`)) (reject ('It broke!')))
[resolution]: "It broke! But it's all good."</pre> <p dir="auto">For comparison, an approximation with Promises is:</p> <pre data-language="js">&gt; Promise.reject ('It broke!')
. .then (null, s =&gt; `${s} But it's all good.`)
. .then (log ('resolution'), log ('rejection'))
[resolution]: "It broke! But it's all good."</pre> <h3 tabindex="-1" dir="auto" id="coalesce">coalesce</h3> <pre data-language="haskell">coalesce :: (a -&gt; c) -&gt; (b -&gt; c) -&gt; Future a b -&gt; Future d c</pre> <p dir="auto">Applies the left function to the rejection value, or the right function to the resolution value, depending on which is present, and resolves with the result.</p> <p dir="auto">This provides a convenient means to ensure a Future is always resolved. It can be used with other type constructors, like , to maintain a representation of failure.</p> <pre data-language="js">&gt; fork (log ('rejection'))
.      (log ('resolution'))
.      (coalesce (S.Left) (S.Right) (resolve ('hello'))
[resolution]: Right ("hello")

&gt; fork (log ('rejection'))
.      (log ('resolution'))
.      (coalesce (S.Left) (S.Right) (reject ('It broke!'))
[resolution]: Left ("It broke!")</pre> <p dir="auto">For comparison, an approximation with Promises is:</p> <pre data-language="js">&gt; Promise.resolve ('hello')
. .then (S.Right, S.Left)
. .then (log ('resolution'), log ('rejection'))
[resolution]: Right ("hello")

&gt; Promise.reject ('It broke!')
. .then (S.Right, S.Left)
. .then (log ('resolution'), log ('rejection'))
[resolution]: Left ("It broke!")</pre> <h2 tabindex="-1" dir="auto" id="combining-futures">Combining Futures</h2> <h3 tabindex="-1" dir="auto" id="ap">ap</h3> <pre data-language="haskell">ap :: Apply m =&gt; m a -&gt; m (a -&gt; b) -&gt; m b</pre> <p dir="auto">Applies the function contained in the right-hand Future or  to the value contained in the left-hand Future or Apply. This process can be repeated to gradually fill out multiple function arguments of a curried function, as shown below.</p> <p dir="auto">Note that the Futures will be executed in sequence - not in parallel* - because of the Monadic nature of Futures. The execution order is, as specified by Fantasy Land, <code>m (a -&gt; b)</code> first followed by <code>m a</code>. So that's <em>right before left</em>.</p> <p dir="auto">* Have a look at  for an <code>ap</code> function that runs its arguments in parallel. If you must use <code>ap</code> (because you're creating a generalized function), but still want Futures passed into it to run in parallel, then you could use  instead.</p> <pre data-language="js">&gt; fork (log ('rejection'))
.      (log ('resolution'))
.      (ap (resolve (7)) (ap (resolve (49)) (resolve (x =&gt; y =&gt; x - y))))
[resolution]: 42</pre> <h3 tabindex="-1" dir="auto" id="pap">pap</h3> <pre data-language="haskell">pap :: Future a b -&gt; Future a (b -&gt; c) -&gt; Future a c</pre> <p dir="auto">Has the same signature and function as , but runs the two Futures given to it in parallel. See also  for a more general way to achieve this.</p> <pre data-language="js">&gt; fork (log ('rejection'))
.      (log ('resolution'))
.      (pap (resolve (7)) (pap (resolve (49)) (resolve (x =&gt; y =&gt; x - y))))
[resolution]: 42</pre> <h3 tabindex="-1" dir="auto" id="alt">alt</h3> <pre data-language="haskell">alt :: Alt f =&gt; f a -&gt; f a -&gt; f a</pre> <p dir="auto">Select one of two .</p> <p dir="auto">Behaves like logical <em>or</em> on  instances, returning a new Future which either resolves with the first resolution value, or rejects with the last rejection reason. We can use it if we want a computation to run only if another has failed.</p> <p dir="auto">Note that the Futures will be executed in sequence - not in parallel* - because of the Monadic nature of Futures. The <em>right</em> Future is evaluated before the <em>left</em> Future.</p> <p dir="auto">See also  and .</p> <p dir="auto">* If you'd like to use a parallel implementation of <code>alt</code>, you could simply use . Alternatively you could wrap your Future instances with  before passing them to <code>alt</code>.</p> <pre data-language="js">&gt; fork (log ('rejection'))
.      (log ('resolution'))
.      (alt (resolve ('left')) (resolve ('right')))
[resolution]: "right"

&gt; fork (log ('rejection'))
.      (log ('resolution'))
.      (alt (resolve ('left')) (reject ('It broke!')))
[resolution]: "left"</pre> <h3 tabindex="-1" dir="auto" id="and">and</h3> <pre data-language="haskell">and :: Future a c -&gt; Future a b -&gt; Future a c</pre> <p dir="auto">Logical <em>and</em> for Futures.</p> <p dir="auto">Returns a new Future which either rejects with the first rejection reason, or resolves with the last resolution value once and if both Futures resolve. We can use it if we want a computation to run only after another has succeeded. The <em>right</em> Future is evaluated before the <em>left</em> Future.</p> <p dir="auto">See also  and .</p> <pre data-language="js">&gt; fork (log ('rejection'))
.      (log ('resolution'))
.      (and (resolve ('left')) (resolve ('right')))
[resolution]: "left"

&gt; fork (log ('rejection'))
.      (log ('resolution'))
.      (and (resolve ('left')) (reject ('It broke!')))
[rejection]: "It broke!"</pre> <h3 tabindex="-1" dir="auto" id="lastly">lastly</h3> <pre data-language="haskell">lastly :: Future a c -&gt; Future a b -&gt; Future a b</pre> <p dir="auto">Run a second Future after the first settles (successfully or unsuccessfully). Rejects with the rejection reason from the first or second Future, or resolves with the resolution value from the first Future. This can be used to run a computation after another settles, successfully or unsuccessfully.</p> <p dir="auto">If you're looking to clean up resources after running a computation which acquires them, you should use , which has many more fail-safes in place.</p> <p dir="auto">See also  and .</p> <pre data-language="js">&gt; fork (log ('rejection'))
.      (log ('resolution'))
.      (lastly (encase (log ('lastly')) ('All done!')) (resolve (42)))
[lastly]: "All done!"
[resolution]: 42</pre> <h2 tabindex="-1" dir="auto" id="consuming-futures">Consuming Futures</h2> <h3 tabindex="-1" dir="auto" id="fork">fork</h3> <pre data-language="haskell">fork :: (a -&gt; Any) -&gt; (b -&gt; Any) -&gt; Future a b -&gt; Cancel</pre> <p dir="auto">Execute the computation represented by a Future, passing <code>reject</code> and <code>resolve</code> callbacks to continue once there is a result.</p> <p dir="auto">This function is called <code>fork</code> because it literally represents a fork in our program: a point where a single code-path splits in two. It is recommended to keep the number of calls to <code>fork</code> at a minimum for this reason. The more forks, the higher the code complexity.</p> <p dir="auto">Generally, one only needs to call <code>fork</code> in a single place in the entire program.</p> <p dir="auto">After we <code>fork</code> a Future, the computation will start running. If the program decides halfway through that it's no longer interested in the result of the computation, it can call the <code>unsubscribe</code> function returned by <code>fork</code>. See .</p> <p dir="auto">If an exception was encountered during the computation, it will be re-thrown by <code>fork</code> and likely not be catchable. You can handle it using <code>process.on('uncaughtException')</code> in Node, or use .</p> <p dir="auto">Almost all code examples in Fluture use <code>fork</code> to run the computation. There are some variations on <code>fork</code> that serve different purposes below.</p> <h3 tabindex="-1" dir="auto" id="forkcatch">forkCatch</h3> <pre data-language="haskell">forkCatch :: (Error -&gt; Any) -&gt; (a -&gt; Any) -&gt; (b -&gt; Any) -&gt; Future a b -&gt; Cancel</pre> <p dir="auto">An advanced version of  that allows us to react to a fatal error in a custom way. Fatal errors occur when unexpected exceptions are thrown, when the Fluture API is used incorrectly, or when resources couldn't be disposed.</p> <p dir="auto">The exception handler will always be called with an instance of <code>Error</code>, independent of what caused the crash.</p> <p dir="auto"><strong>Using this function is a trade-off;</strong></p> <p dir="auto">Generally it's best to let a program crash and restart when an a fatal error occurs. Restarting is the surest way to restore the memory that was allocated by the program to an expected state.</p> <p dir="auto">By using <code>forkCatch</code>, we can keep our program alive after a fatal error, which can be very beneficial when the program is being used by multiple clients. However, since fatal errors might indicate that something, somewhere has entered an invalid state, it's probably still best to restart our program upon encountering one.</p> <p dir="auto">See  for information about the Error object that is passed to your exception handler.</p> <pre data-language="js">&gt; forkCatch (log ('fatal error'))
.           (log ('rejection'))
.           (log ('resolution'))
.           (map (x =&gt; x.foo) (resolve (null)))
[fatal error]: new Error ("Cannot read property 'foo' of null")</pre> <h3 tabindex="-1" dir="auto" id="value">value</h3> <pre data-language="haskell">value :: (b -&gt; Any) -&gt; Future a b -&gt; Cancel</pre> <p dir="auto">Like  but for the resolution branch only. Only use this function if you are sure the Future is going to be resolved, for example; after using . If the Future rejects, <code>value</code> will throw an Error.</p> <p dir="auto">As with , <code>value</code> returns an <code>unsubscribe</code> function. See .</p> <pre data-language="js">&gt; value (log ('resolution')) (resolve (42))
[resolution]: 42</pre> <h3 tabindex="-1" dir="auto" id="done">done</h3> <pre data-language="haskell">done :: Nodeback a b -&gt; Future a b -&gt; Cancel</pre> <p dir="auto">Run the Future using a  as the continuation.</p> <p dir="auto">This is like , but instead of taking two unary functions, it takes a single binary function.</p> <p dir="auto">As with , <code>done</code> returns an <code>unsubscribe</code> function. See .</p> <pre data-language="js">&gt; done ((err, val) =&gt; log ('resolution') (val)) (resolve (42))
[resolution]: 42</pre> <h3 tabindex="-1" dir="auto" id="promise">promise</h3> <pre data-language="haskell">promise :: Future Error a -&gt; Promise Error a</pre> <p dir="auto">Run the Future and get a Promise to represent its continuation.</p> <p dir="auto">Returns a Promise which resolves with the resolution value, or rejects with the rejection reason of the Future.</p> <p dir="auto">If an exception was encountered during the computation, the promise will reject with it. I recommend using  before <code>promise</code> to ensure that exceptions and rejections are not mixed into the Promise rejection branch.</p> <p dir="auto">Cancellation capabilities are lost when using <code>promise</code> to consume the Future.</p> <pre data-language="js">&gt; promise (resolve (42)) .then (log ('resolution'))
[resolution]: 42

&gt; promise (reject ('failure')) .then (log ('resolution'), log ('rejection'))
[rejection]: "failure"</pre> <h2 tabindex="-1" dir="auto" id="parallelism">Parallelism</h2> <h3 tabindex="-1" dir="auto" id="race">race</h3> <pre data-language="haskell">race :: Future a b -&gt; Future a b -&gt; Future a b</pre> <p dir="auto">Race two Futures against each other. Creates a new Future which resolves or rejects with the resolution or rejection value of the first Future to settle.</p> <p dir="auto">When one Future settles, the other gets cancelled automatically.</p> <pre data-language="js">&gt; fork (log ('rejection'))
.      (log ('resolution'))
.      (race (after (15) ('left')) (after (30) ('right')))
[resolution]: "left"</pre> <h3 tabindex="-1" dir="auto" id="both">both</h3> <pre data-language="haskell">both :: Future a b -&gt; Future a c -&gt; Future a (Pair b c)</pre> <p dir="auto">Run two Futures in parallel and get a  of the results. When either Future rejects, the other Future will be cancelled and the resulting Future will reject.</p> <pre data-language="js">&gt; fork (log ('rejection'))
.      (log ('resolution'))
.      (both (after (15) ('left')) (after (30) ('right')))
[resolution]: ["left", "right"]</pre> <h3 tabindex="-1" dir="auto" id="parallel">parallel</h3> <pre data-language="haskell">parallel :: PositiveInteger -&gt; Array (Future a b) -&gt; Future a (Array b)</pre> <p dir="auto">Creates a Future which when forked runs all Futures in the given Array in parallel, ensuring no more than <code>limit</code> Futures are running at once.</p> <p dir="auto">In the following example, we're running up to 5 Futures in parallel. Every Future takes about 20ms to settle, which means the result should appear after about 40ms.</p> <p dir="auto">If we use <code>1</code> for the limit, the Futures would run in sequence, causing the result to appear only after 200ms.</p> <p dir="auto">We can also use <code>Infinity</code> as the limit. This would create a function similar to <code>Promise.all</code>, which always runs all Futures in parallel. This can easily cause the computation to consume too many resources, however, so I would advise using a number roughly equal to maximum size of Array you think your program should handle.</p> <pre data-language="js">&gt; fork (log ('rejection'))
.      (log ('resolution'))
.      (parallel (5) (Array.from (Array (10) .keys ()) .map (after (20))))
[resolution]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</pre> <p dir="auto">When one Future rejects, all currently running Futures will be cancelled and the resulting Future will reject. If you want to settle all Futures, even if some may fail, you can use <code>parallel</code> in combination with .</p> <pre data-language="js">&gt; fork (log ('rejection'))
.      (log ('resolution'))
.      (parallel (2) ([resolve (42), reject ('It broke!')]
.                     .map (coalesce (S.Left) (S.Right))))
[resolution]: [Right (42), Left ("It broke!")]</pre> <h3 tabindex="-1" dir="auto" id="concurrentfuture">ConcurrentFuture</h3> <p dir="auto">The <code>ConcurrentFuture</code> type is very similar to the <code>Future</code> type, except that it has <em>parallel</em> semantics where <code>Future</code> has <em>sequential</em> semantics.</p> <p dir="auto">These sematics are most notable in the implementation of Applicative for <code>ConcurrentFuture</code>. When using  on two ConcurrentFutures, they run parallely, whereas regular <code>Future</code> instances would've run sequentially. This means that <code>ConcurrentFuture</code> cannot be a Monad, which is why we have it as a separate type.</p> <p dir="auto">The implementation of Alternative on <code>ConcurrentFuture</code> has parallel semantics as well. Whereas  on regular Futures uses the failure effect to determine a winner, on ConcurrentFutures <em>timing</em> is used, and the winner will be whichever ConcurrentFuture settled first.</p> <p dir="auto">The idea is that we can switch back and forth between <code>Future</code> and <code>ConcurrentFuture</code>, using  and , to get sequential or concurrent behaviour respectively. It's a useful type to pass to abstractions that don't know about Future-specific functions like  or , but <em>do</em> know how to operate on Apply and Alternative.</p> <pre data-language="js">//Some dummy values
const x = 41;
const f = a =&gt; a + 1;

//The following two are equal ways to construct a ConcurrentFuture
const parx = S.of (Par) (x)
const parf = Par (S.of (Future) (f))

//We can make use of parallel apply
value (log ('resolution')) (seq (ap (parx) (parf)))
[resolution]: 42

//Concurrent sequencing
value (log ('resolution')) (seq (S.sequence (Par) ([parx, parx, parx])))
[resolution]: [41, 41, 41]

//And concurrent alt
value (log ('resolution')) (alt (after (15) ('left')) (after (30) ('right')))
[resolution]: "left"</pre> <h5 tabindex="-1" dir="auto" id="par">Par</h5> <pre data-language="haskell">Par :: Future a b -&gt; ConcurrentFuture a b</pre> <p dir="auto">Converts a Future to a ConcurrentFuture.</p> <h5 tabindex="-1" dir="auto" id="seq">seq</h5> <p dir="auto">Converts a ConcurrentFuture to a Future.</p> <pre data-language="haskell">seq :: ConcurrentFuture a b -&gt; Future a b</pre> <h2 tabindex="-1" dir="auto" id="resource-management">Resource management</h2> <p dir="auto">Functions listed under this category allow for more fine-grained control over the flow of acquired values.</p> <h3 tabindex="-1" dir="auto" id="hook">hook</h3> <pre data-language="haskell">hook :: Future a b -&gt; (b -&gt; Future c d) -&gt; (b -&gt; Future a e) -&gt; Future a e</pre> <p dir="auto">Combines resource acquisition, consumption, and disposal in such a way that you can be sure that a resource will always be disposed if it was acquired, even if an exception is thrown during consumption; Sometimes referred to as bracketing.</p> <p dir="auto">The signature is like <code>hook (acquire, dispose, consume)</code>, where:</p> <ul dir="auto"> <li>
<code>acquire</code> is a Future which might create connections, open files, etc.</li> <li>
<code>dispose</code> is a function that takes the result from <code>acquire</code> and should be used to clean up (close connections etc). The Future it returns must resolve, and its resolution value is ignored. If it rejects, a fatal error is raised which can only be handled with <a href="#forkcatch"><code>forkCatch</code></a>.</li> <li>
<code>consume</code> is another Function takes the result from <code>acquire</code>, and may be used to perform any arbitrary computations using the resource.</li> </ul> <p dir="auto">Typically, you'd want to partially apply this function with the first two arguments (acquisition and disposal), as shown in the example.</p> <pre data-language="js">&gt; import {open, read, close} from 'fs'

&gt; const withFile = hook (node (done =&gt; open ('package.json', 'r', done)))
.                       (fd =&gt; node (done =&gt; close (fd, done)))

&gt; fork (log ('rejection'))
.      (log ('resolution'))
.      (withFile (fd =&gt; node (done =&gt; (
.        read (fd, Buffer.alloc (1), 0, 1, null, (e, _, x) =&gt; done (e, x)))
.      )))
[resolution]: &lt;Buffer 7b&gt;</pre> <p dir="auto">When a hooked Future is cancelled while acquiring its resource, nothing else will happen. When it's cancelled after acquistion completes, however, the disposal will still run, and if it fails, an exception will be thrown.</p> <p dir="auto">If you have multiple resources that you'd like to consume all at once, you can use  to combine multiple hooks into one.</p> <h2 tabindex="-1" dir="auto" id="utility-functions">Utility functions</h2> <h3 tabindex="-1" dir="auto" id="pipe">pipe</h3> <pre data-language="haskell">Future.prototype.pipe :: Future a b ~&gt; (Future a b -&gt; c) -&gt; c</pre> <p dir="auto">A method available on all Futures to allow arbitrary functions over Futures to be included in a fluent-style method chain.</p> <p dir="auto">You can think of this as a fallback for the .</p> <pre data-language="js">&gt; resolve (x =&gt; y =&gt; x * y)
. .pipe (ap (after (20) (Math.PI)))
. .pipe (ap (after (20) (13.37)))
. .pipe (map (Math.round))
. .pipe (fork (log ('rejection')) (log ('resolution')))
[resolution]: 42</pre> <h3 tabindex="-1" dir="auto" id="cache">cache</h3> <pre data-language="haskell">cache :: Future a b -&gt; Future a b</pre> <p dir="auto">Returns a Future which caches the resolution value or rejection reason of the given Future so that whenever it's forked, it can load the value from cache rather than re-executing the underlying computation.</p> <p dir="auto">This essentially turns a unicast Future into a multicast Future, allowing multiple consumers to subscribe to the same result. The underlying computation is never  unless <em>all</em> consumers unsubscribe before it completes.</p> <p dir="auto"><strong>There is a glaring drawback to using <code>cache</code></strong>, which is that returned Futures are no longer referentially transparent, making reasoning about them more difficult and refactoring code that uses them harder.</p> <pre data-language="js">&gt; import {readFile} from 'fs'

&gt; const eventualPackageName = (
.   node (done =&gt; readFile ('package.json', 'utf8', done))
.   .pipe (chain (encase (JSON.parse)))
.   .pipe (chain (encase (x =&gt; x.name)))
.   .pipe (map (data =&gt; {
.      log ('debug') ('Read, parsed, and traversed the package data')
.      return data
.    }))
. )

&gt; fork (log ('rejection')) (log ('resolution')) (eventualPackageName)
[debug]: "Read, parsed, and traversed the package data"
[resolution]: "Fluture"

&gt; fork (log ('rejection')) (log ('resolution')) (eventualPackageName)
[debug]: "Read, parsed, and traversed the package data"
[resolution]: "Fluture"

&gt; const eventualCachedPackageName = cache (eventualPackageName)

&gt; fork (log ('rejection')) (log ('resolution')) (eventualCachedPackageName)
[debug]: "Read, parsed, and traversed the package data"
[resolution]: "Fluture"

&gt; fork (log ('rejection')) (log ('resolution')) (eventualCachedPackageName)
[resolution]: "Fluture"</pre> <h3 tabindex="-1" dir="auto" id="isfuture">isFuture</h3> <pre data-language="haskell">isFuture :: a -&gt; Boolean</pre> <p dir="auto">Returns true for  and false for everything else. This function (and ) also return <code>true</code> for instances of Future that were created within other contexts. It is therefore recommended to use this over <code>instanceof</code>, unless your intent is to explicitly check for Futures created using the exact <code>Future</code> constructor you're testing against.</p> <pre data-language="js">&gt; isFuture (resolve (42))
true

&gt; isFuture (42)
false</pre> <h3 tabindex="-1" dir="auto" id="never">never</h3> <pre data-language="haskell">never :: Future a b</pre> <p dir="auto">A Future that never settles. Can be useful as an initial value when reducing with , for example.</p> <h3 tabindex="-1" dir="auto" id="isnever">isNever</h3> <pre data-language="haskell">isNever :: a -&gt; Boolean</pre> <p dir="auto">Returns <code>true</code> if the given input is a <code>never</code>.</p> <h3 tabindex="-1" dir="auto" id="extractleft">extractLeft</h3> <pre data-language="haskell">extractLeft :: Future a b -&gt; Array a</pre> <p dir="auto">Returns an array whose only element is the rejection reason of the Future. In many cases it will be impossible to extract this value; In those cases, the array will be empty. This function is meant to be used for type introspection: it is <strong>not</strong> the correct way to .</p> <h3 tabindex="-1" dir="auto" id="extractright">extractRight</h3> <pre data-language="haskell">extractRight :: Future a b -&gt; Array b</pre> <p dir="auto">Returns an array whose only element is the resolution value of the Future. In many cases it will be impossible to extract this value; In those cases, the array will be empty. This function is meant to be used for type introspection: it is <strong>not</strong> the correct way to .</p> <h3 tabindex="-1" dir="auto" id="debugmode">debugMode</h3> <pre data-language="haskell">debugMode :: Boolean -&gt; Undefined</pre> <p dir="auto">Enable or disable Fluture's debug mode. Debug mode is disabled by default. Pass <code>true</code> to enable, or <code>false</code> to disable.</p> <pre data-language="js">debugMode (true)</pre> <p dir="auto">For more information, see  and .</p> <h3 tabindex="-1" dir="auto" id="context">context</h3> <pre data-language="haskell">Future.prototype.context :: Future a b ~&gt; List Context</pre> <p dir="auto">A linked list of debugging contexts made available on every instance of <code>Future</code>. When  is disabled, the list is always empty.</p> <p dir="auto">The context objects have <code>stack</code> properties which contain snapshots of the stacktraces leading up to the creation of the <code>Future</code> instance. They are used by Fluture to generate contextual stack traces.</p> <h2 tabindex="-1" dir="auto" id="license">License</h2> <div class="_attribution">
  <p class="_attribution-p">
     2020 Aldwin Vlasblom<br>Licensed under the MIT License.<br>
    <a href="https://github.com/fluture-js/Fluture/blob/14.0.0/README.md" class="_attribution-link">https://github.com/fluture-js/Fluture/blob/14.0.0/README.md</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
