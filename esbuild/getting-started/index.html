
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Getting Started - Esbuild - W3cubDocs</title>
  
  <meta name="description" content=" First, download and install the esbuild command locally. A prebuilt native executable can be installed using npm&#58; ">
  <meta name="keywords" content="getting, started, esbuild">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/esbuild/getting-started/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-c2f2e7d1236e299f399a2d9bf4342fa70a8839fbe6eb79130546d6bf383b99636ffdf29c557090085d7c4ac34eeb5426851b42d2f4ec63cf218916cbd19aa876.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/esbuild.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/esbuild/" class="_nav-link" title="" style="margin-left:0;">esbuild</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _simple">
				
				
<h1>Getting Started</h1>
<h2 id="install-esbuild">Install esbuild</h2>
<p>First, download and install the esbuild command locally. A prebuilt native executable can be installed using npm:</p>
<pre data-language="javascript" class="">npm install esbuild</pre>
<p>This should have installed esbuild in your local <code>node_modules</code> folder. You can run the esbuild executable to verify that everything is working correctly:</p> <pre class="" data-language="javascript">./node_modules/.bin/esbuild --version</pre> <pre class="" data-language="javascript">.\node_modules\.bin\esbuild --version</pre>
<p>The recommended way to install esbuild is to install the native executable using npm. But if you don't want to do that, there are also some <a href="#other-ways-to-install">other ways to install</a>.</p>
<h2 id="your-first-bundle">Your first bundle</h2>
<p>This is a quick real-world example of what esbuild is capable of and how to use it. First, install the <code>react</code> and <code>react-dom</code> packages:</p>
<pre data-language="javascript" class="">npm install react react-dom</pre>
<p>Then create a file called <code>app.jsx</code> containing the following code:</p>
<pre data-language="javascript" class="">import * as React from 'react'
import * as Server from 'react-dom/server'

let Greet = () =&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt;
console.log(Server.renderToString(&lt;Greet /&gt;))</pre>
<p>Finally, tell esbuild to bundle the file:</p> <pre class="" data-language="javascript">./node_modules/.bin/esbuild app.jsx --bundle --outfile=out.js</pre> <pre class="" data-language="javascript">.\node_modules\.bin\esbuild app.jsx --bundle --outfile=out.js</pre>
<p>This should have created a file called <code>out.js</code> containing your code and the React library bundled together. The code is completely self-contained and no longer depends on your <code>node_modules</code> directory. If you run the code using <code>node out.js</code>, you should see something like this:</p>
<pre data-language="javascript" class="">&lt;h1 data-reactroot=""&gt;Hello, world!&lt;/h1&gt;</pre>
<p>Notice that esbuild also converted JSX syntax to JavaScript without any configuration other than the <code>.jsx</code> extension. While esbuild can be configured, it attempts to have reasonable defaults so that many common situations work automatically. If you would like to use JSX syntax in <code>.js</code> files instead, you can tell esbuild to allow this using the <code>--loader:.js=jsx</code> flag. You can read more about the available configuration options in the <a href="../api/index">API documentation</a>.</p>
<h2 id="build-scripts">Build scripts</h2>
<p>Your build command is something you will be running repeatedly, so you will want to automate it. A natural way of doing this is to add a build script to your <code>package.json</code> file like this:</p>
<pre data-language="javascript" class="">{
  "scripts": {
    "build": "esbuild app.jsx --bundle --outfile=out.js"
  }
}</pre>
<p>Notice that this uses the <code>esbuild</code> command directly without a relative path. This works because everything in the <code>scripts</code> section is run with the <code>esbuild</code> command already in the path (as long as you have <a href="#install-esbuild">installed the package</a>).</p>
<p>The build script can be invoked like this:</p>
<pre data-language="javascript" class="">npm run build</pre>
<p>However, using the command-line interface can become unwieldy if you need to pass many options to esbuild. For more sophisticated uses you will likely want to write a build script in JavaScript using esbuild's JavaScript API. That might look something like this:</p>
<pre class="" data-language="javascript">require('esbuild').build({
  entryPoints: ['app.jsx'],
  bundle: true,
  outfile: 'out.js',
}).catch(() =&gt; process.exit(1))</pre>
<p>The <code>build</code> function runs the esbuild executable in a child process and returns a promise that resolves when the build is complete. The code above doesn't print out the captured exception because any error messages in the exception will also be printed to the console by default (although you can change the <a href="../api/index#log-level">log level</a> to turn that off if you'd like).</p>
<p>Although there is also a <code>buildSync</code> API that is not asynchronous, the asynchronous API is better for build scripts because <a href="../plugins/index">plugins</a> only work with the asynchronous API. You can read more about the configuration options for the build API in the <a href="../api/index#build-api">API documentation</a>.</p>
<h2 id="bundling-for-the-browser">Bundling for the browser</h2>
<p>The bundler outputs code for the browser by default, so no additional configuration is necessary to get started. For development builds you probably want to enable source maps with <code>--sourcemap</code>, and for production builds you probably want to enable minification with <code>--minify</code>. You probably also want to configure the target environment for the browsers you support. All of that might looks something like this:</p> <pre class="" data-language="sh">esbuild app.jsx --bundle --minify --sourcemap --target=chrome58,firefox57,safari11,edge16</pre> <pre class="" data-language="javascript">require('esbuild').buildSync({
  entryPoints: ['app.jsx'],
  bundle: true,
  minify: true,
  sourcemap: true,
  target: ['chrome58', 'firefox57', 'safari11', 'edge16'],
  outfile: 'out.js',
})</pre> <pre class="" data-language="go">package main

import "github.com/evanw/esbuild/pkg/api"
import "os"

func main() {
  result := api.Build(api.BuildOptions{
    EntryPoints:       []string{"app.jsx"},
    Bundle:            true,
    MinifyWhitespace:  true,
    MinifyIdentifiers: true,
    MinifySyntax:      true,
    Engines: []api.Engine{
      {api.EngineChrome, "58"},
      {api.EngineFirefox, "57"},
      {api.EngineSafari, "11"},
      {api.EngineEdge, "16"},
    },
    Write: true,
  })

  if len(result.Errors) &gt; 0 {
    os.Exit(1)
  }
}</pre>
<p>Sometimes a package you want to use may import another package that is only available on node, such as the built-in <code>path</code> package. When that happens you can substitute the package for a browser-friendly alternative by using the <a href="https://github.com/defunctzombie/package-browser-field-spec">browser field</a> in your <code>package.json</code> file like this:</p>
<pre data-language="javascript" class="">{
  "browser": {
    "path": "path-browserify"
  }
}</pre>
<p>Some npm packages you want to use may not be designed to be run in the browser. Sometimes you can use esbuild's configuration options to work around certain issues and successfully bundle the package anyway. Undefined globals can be replaced with either the <a href="../api/index#define">define</a> feature in simple cases or the <a href="../api/index#inject">inject</a> feature in more complex cases.</p>
<h2 id="bundling-for-node">Bundling for node</h2>
<p>Even though a bundler is not necessary when using node, sometimes it can still be beneficial to process your code with esbuild before running it in node. Bundling can automatically strip TypeScript types, convert ECMAScript module syntax to CommonJS, and transform newer JavaScript syntax into older syntax for a specific version of node. And it may be beneficial to bundle your package before publishing it so that it's a smaller download and so it spends less time reading from the file system when being loaded.</p>
<p>If you are bundling code that will be run in node, you should configure the <a href="../api/index#platform">platform</a> setting by passing <code>--platform=<wbr>node</wbr></code> to esbuild. This simultaneously changes a few different settings to node-friendly default values. For example, all packages that are built-in to node such as <code>fs</code> are automatically marked as external so esbuild doesn't try to bundle them. This setting also disables the interpretation of the browser field in <code>package.json</code>.</p>
<p>If your code uses newer JavaScript syntax that doesn't work in your version of node, you will want to configure the target version of node:</p> <pre class="" data-language="sh">esbuild app.js --bundle --platform=node --target=node10.4</pre> <pre class="" data-language="javascript">require('esbuild').buildSync({
  entryPoints: ['app.js'],
  bundle: true,
  platform: 'node',
  target: ['node10.4'],
  outfile: 'out.js',
})</pre> <pre class="" data-language="go">package main

import "github.com/evanw/esbuild/pkg/api"
import "os"

func main() {
  result := api.Build(api.BuildOptions{
    EntryPoints: []string{"app.js"},
    Bundle:      true,
    Platform:    api.PlatformNode,
    Engines: []api.Engine{
      {api.EngineNode, "10.4"},
    },
    Write: true,
  })

  if len(result.Errors) &gt; 0 {
    os.Exit(1)
  }
}</pre>
<p>Sometimes the packages you want to use contain code that can't be bundled for some reason. An example of this is a package with native extensions such as <code>fsevents</code>. Or, you may want to exclude a package from the bundle for other reasons. This can be done by marking the package as <a href="../api/index#external">external</a>:</p> <pre class="" data-language="sh">esbuild app.jsx --bundle --platform=node --external:fsevents</pre> <pre class="" data-language="javascript">require('esbuild').buildSync({
  entryPoints: ['app.jsx'],
  bundle: true,
  platform: 'node',
  external: ['fsevents'],
  outfile: 'out.js',
})</pre> <pre class="" data-language="go">package main

import "github.com/evanw/esbuild/pkg/api"
import "os"

func main() {
  result := api.Build(api.BuildOptions{
    EntryPoints: []string{"app.jsx"},
    Bundle:      true,
    Platform:    api.PlatformNode,
    External:    []string{"fsevents"},
    Write:       true,
  })

  if len(result.Errors) &gt; 0 {
    os.Exit(1)
  }
}</pre>
<h2 id="other-ways-to-install">Other ways to install</h2>
<p>The recommended way to install esbuild is to <a href="#install-esbuild">install the native executable using npm</a>. But you can also install esbuild in these ways:</p>
<h3 id="wasm">Install the WASM version</h3>
<p>In addition to the <code>esbuild</code> npm package, there is also an <code>esbuild-wasm</code> package that functions similarly but that uses WebAssembly instead of native code. Installing it will also install an executable called <code>esbuild</code>:</p>
<pre data-language="javascript" class="">npm install esbuild-wasm</pre>
<p><strong>Why this is not recommended:</strong> The WebAssembly version is much, much slower than the native version. In many cases it is an order of magnitude (i.e. 10x) slower. This is for various reasons including a) node re-compiles the WebAssembly code from scratch on every run, b) Go's WebAssembly compilation approach is single-threaded, and c) node has WebAssembly bugs that can delay the exiting of the process by many seconds. The WebAssembly version also excludes some features such as the local file server. You should only use the WebAssembly package like this if there is no other option, such as when you want to use esbuild on an unsupported platform. The WebAssembly package is primarily intended to only be used <a href="../api/index#running-in-the-browser">in the browser</a>.</p>
<h3 id="deno">Use Deno instead of node</h3>
<p>There is also basic support for the <a href="https://deno.land">Deno</a> JavaScript environment if you'd like to use esbuild with that instead. The package is hosted at <a href="https://deno.land/x/esbuild">https://deno.land/x/esbuild</a> and uses the native esbuild executable. The executable will be downloaded and cached from npm at run-time so your computer will need network access to registry.npmjs.org to make use of this package. Using the package looks like this:</p>
<pre data-language="javascript" class="">import * as esbuild from 'https://deno.land/x/esbuild@v0.14.1/mod.js'
const ts = 'let test: boolean = true'
const result = await esbuild.transform(ts, { loader: 'ts' })
console.log('result:', result)
esbuild.stop()</pre>
<p>It has basically the same API as esbuild's npm package with one addition: you need to call <code>stop()</code> when you're done because unlike node, Deno doesn't provide the necessary APIs to allow Deno to exit while esbuild's internal child process is still running.</p>
<p><strong>Why this is not recommended:</strong> Deno is newer than node, less widely used, and supports fewer platforms than node, so node is recommended as the primary way to run esbuild. Deno also uses the internet as a package system instead of existing JavaScript package ecosystems, and esbuild is designed around and optimized for npm-style package management. You should still be able to use esbuild with Deno, but you will need a plugin if you would like to be able to bundle HTTP URLs.</p>
<h3 id="build-from-source">Build from source</h3>
<p>To build esbuild from source:</p>
<ol>
<li>Install the Go compiler: <p><a href="https://golang.org/dl/">https://golang.org/dl/</a></p>
</li>
<li>Download the source code for esbuild: <pre data-language="javascript" class="">
git clone --depth 1 --branch v0.14.1 https://github.com/evanw/esbuild.git
cd esbuild
</pre>
</li>
<li>Build the <code>esbuild</code> executable (it will be <code>esbuild.exe</code> on Windows): <pre data-language="javascript" class="">go build ./cmd/esbuild</pre>
</li>
</ol>
<p>If you want to build for other platforms, you can just prefix the build command with the platform information. For example, you can build the 32-bit Linux version using this command:</p>
<pre data-language="javascript" class="">GOOS=linux GOARCH=386 go build ./cmd/esbuild</pre>
<p><strong>Why this is not recommended:</strong> The native version can only be used via the command-line interface, which can be unergonomic for complex use cases and which does not support <a href="../plugins/index">plugins</a>. You will need to write JavaScript or Go code and use <a href="../api/index">esbuild's API</a> to use plugins.</p>
<h3 id="download-a-build">Download a build</h3>
<p>Although the precompiled native executables are hosted using npm, you don't actually need npm installed to download them. The npm package registry is a normal HTTP server and packages are normal gzipped tar files.</p>
<p>Here is an example of downloading a binary executable directly:</p>
<pre class="" data-language="sh">curl -O https://registry.npmjs.org/esbuild-darwin-64/-/esbuild-darwin-64-0.14.1.tgztar xf ./esbuild-darwin-64-0.14.1.tgz./package/bin/esbuildUsage:
  esbuild [options] [entry points]

...</pre>
<p>The native executable in the <code>esbuild-darwin-64</code> package is for the macOS operating system and the x86-64 architecture. As of writing, this is the full list of native executable packages for the platforms esbuild supports:</p>
<table> <thead> <tr> <th>Package name</th> <th>OS</th> <th>Architecture</th> </tr> </thead> <tbody> <tr> <td><code>esbuild-android-arm64</code></td> <td><code>android</code></td> <td><code>arm64</code></td> </tr> <tr> <td><code>esbuild-darwin-64</code></td> <td><code>darwin</code></td> <td><code>x64</code></td> </tr> <tr> <td><code>esbuild-darwin-arm64</code></td> <td><code>darwin</code></td> <td><code>arm64</code></td> </tr> <tr> <td><code>esbuild-freebsd-64</code></td> <td><code>freebsd</code></td> <td><code>x64</code></td> </tr> <tr> <td><code>esbuild-freebsd-arm64</code></td> <td><code>freebsd</code></td> <td><code>arm64</code></td> </tr> <tr> <td><code>esbuild-linux-32</code></td> <td><code>linux</code></td> <td><code>ia32</code></td> </tr> <tr> <td><code>esbuild-linux-64</code></td> <td><code>linux</code></td> <td><code>x64</code></td> </tr> <tr> <td><code>esbuild-linux-arm</code></td> <td><code>linux</code></td> <td><code>arm</code></td> </tr> <tr> <td><code>esbuild-linux-arm64</code></td> <td><code>linux</code></td> <td><code>arm64</code></td> </tr> <tr> <td><code>esbuild-linux-mips64le</code></td> <td><code>linux</code></td> <td><code>mips64el</code></td> </tr> <tr> <td><code>esbuild-linux-ppc64le</code></td> <td><code>linux</code></td> <td><code>ppc64</code></td> </tr> <tr> <td><code>esbuild-netbsd-64</code></td> <td><code>netbsd</code></td> <td><code>x64</code></td> </tr> <tr> <td><code>esbuild-openbsd-64</code></td> <td><code>openbsd</code></td> <td><code>x64</code></td> </tr> <tr> <td><code>esbuild-sunos-64</code></td> <td><code>sunos</code></td> <td><code>x64</code></td> </tr> <tr> <td><code>esbuild-windows-32</code></td> <td><code>win32</code></td> <td><code>ia32</code></td> </tr> <tr> <td><code>esbuild-windows-64</code></td> <td><code>win32</code></td> <td><code>x64</code></td> </tr> <tr> <td><code>esbuild-windows-arm64</code></td> <td><code>win32</code></td> <td><code>arm64</code></td> </tr> </tbody> </table>
<p><strong>Why this is not recommended:</strong> This relies on internal implementation details of esbuild's native executable installer. These details may change at some point, in which case this approach will no longer work for new esbuild versions. This is only a minor drawback though since the approach should still work forever for existing esbuild versions since packages published to npm are immutable. An additional drawback is that you cannot use <a href="../plugins/index">plugins</a> with the native version.</p>
<div class="_attribution">
  <p class="_attribution-p">
    Â© 2020 Evan Wallace<br>Licensed under the MIT License.<br>
    <a href="https://esbuild.github.io/getting-started/" class="_attribution-link">https://esbuild.github.io/getting-started/</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
