
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>QVulkanWindow (Class) - Qt 5.15 - W3cubDocs</title>
  
  <meta name="description" content=" The QVulkanWindow class is a convenience subclass of QWindow to perform Vulkan rendering. More... ">
  <meta name="keywords" content="qvulkanwindow, class, qt, qt~5.15">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/qt~5.15/qvulkanwindow.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/qt~5.15.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/qt~5.15/" class="_nav-link" title="" style="margin-left:0;">Qt 5.15</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _qt">
				
				
<h1 class="title">QVulkanWindow Class</h1>  <p>The QVulkanWindow class is a convenience subclass of <a href="qwindow">QWindow</a> to perform Vulkan rendering. <a href="#details">More...</a></p>  <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> Header:</td>
<td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QVulkanWindow&gt;</span> </td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> qmake:</td>
<td class="memItemRight bottomAlign"> QT += gui</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Since:</td>
<td class="memItemRight bottomAlign"> Qt 5.10</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Inherits:</td>
<td class="memItemRight bottomAlign"> <a href="qwindow">QWindow</a>
</td>
</tr>
</table>
<p>This class was introduced in Qt 5.10.</p> <ul> <li><a href="https://doc.qt.io/qt-5.15/qvulkanwindow-members.html">List of all members, including inherited members</a></li> </ul>  <h2 id="public-types">Public Types
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> enum </td>
<td class="memItemRight bottomAlign">
<b><a href="qvulkanwindow#Flag-enum">Flag</a></b> { PersistentResources }</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> flags </td>
<td class="memItemRight bottomAlign"><b><a href="qvulkanwindow#Flag-enum">Flags</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> typedef </td>
<td class="memItemRight bottomAlign"><b><a href="qvulkanwindow#QueueCreateInfoModifier-typedef">QueueCreateInfoModifier</a></b></td>
</tr> </table>  <h2 id="public-functions">Public Functions
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qvulkanwindow#QVulkanWindow">QVulkanWindow</a></b>(QWindow *<i>parent</i> = nullptr)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual </td>
<td class="memItemRight bottomAlign">
<b><a href="qvulkanwindow#dtor.QVulkanWindow">~QVulkanWindow</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QVector&lt;VkPhysicalDeviceProperties&gt; </td>
<td class="memItemRight bottomAlign">
<b><a href="qvulkanwindow#availablePhysicalDevices">availablePhysicalDevices</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QMatrix4x4 </td>
<td class="memItemRight bottomAlign">
<b><a href="qvulkanwindow#clipCorrectionMatrix">clipCorrectionMatrix</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> VkFormat </td>
<td class="memItemRight bottomAlign">
<b><a href="qvulkanwindow#colorFormat">colorFormat</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> int </td>
<td class="memItemRight bottomAlign">
<b><a href="qvulkanwindow#concurrentFrameCount">concurrentFrameCount</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual QVulkanWindowRenderer *</td>
<td class="memItemRight bottomAlign">
<b><a href="qvulkanwindow#createRenderer">createRenderer</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> VkCommandBuffer </td>
<td class="memItemRight bottomAlign">
<b><a href="qvulkanwindow#currentCommandBuffer">currentCommandBuffer</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> int </td>
<td class="memItemRight bottomAlign">
<b><a href="qvulkanwindow#currentFrame">currentFrame</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> VkFramebuffer </td>
<td class="memItemRight bottomAlign">
<b><a href="qvulkanwindow#currentFramebuffer">currentFramebuffer</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> int </td>
<td class="memItemRight bottomAlign">
<b><a href="qvulkanwindow#currentSwapChainImageIndex">currentSwapChainImageIndex</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> VkRenderPass </td>
<td class="memItemRight bottomAlign">
<b><a href="qvulkanwindow#defaultRenderPass">defaultRenderPass</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> VkFormat </td>
<td class="memItemRight bottomAlign">
<b><a href="qvulkanwindow#depthStencilFormat">depthStencilFormat</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> VkImage </td>
<td class="memItemRight bottomAlign">
<b><a href="qvulkanwindow#depthStencilImage">depthStencilImage</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> VkImageView </td>
<td class="memItemRight bottomAlign">
<b><a href="qvulkanwindow#depthStencilImageView">depthStencilImageView</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> VkDevice </td>
<td class="memItemRight bottomAlign">
<b><a href="qvulkanwindow#device">device</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> uint32_t </td>
<td class="memItemRight bottomAlign">
<b><a href="qvulkanwindow#deviceLocalMemoryIndex">deviceLocalMemoryIndex</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QVulkanWindow::Flags </td>
<td class="memItemRight bottomAlign">
<b><a href="qvulkanwindow#flags">flags</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qvulkanwindow#frameReady">frameReady</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QImage </td>
<td class="memItemRight bottomAlign">
<b><a href="qvulkanwindow#grab">grab</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> VkCommandPool </td>
<td class="memItemRight bottomAlign">
<b><a href="qvulkanwindow#graphicsCommandPool">graphicsCommandPool</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> VkQueue </td>
<td class="memItemRight bottomAlign">
<b><a href="qvulkanwindow#graphicsQueue">graphicsQueue</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> uint32_t </td>
<td class="memItemRight bottomAlign">
<b><a href="qvulkanwindow#graphicsQueueFamilyIndex">graphicsQueueFamilyIndex</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> uint32_t </td>
<td class="memItemRight bottomAlign">
<b><a href="qvulkanwindow#hostVisibleMemoryIndex">hostVisibleMemoryIndex</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qvulkanwindow#isValid">isValid</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> VkImage </td>
<td class="memItemRight bottomAlign">
<b><a href="qvulkanwindow#msaaColorImage">msaaColorImage</a></b>(int <i>idx</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> VkImageView </td>
<td class="memItemRight bottomAlign">
<b><a href="qvulkanwindow#msaaColorImageView">msaaColorImageView</a></b>(int <i>idx</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> VkPhysicalDevice </td>
<td class="memItemRight bottomAlign">
<b><a href="qvulkanwindow#physicalDevice">physicalDevice</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> const VkPhysicalDeviceProperties *</td>
<td class="memItemRight bottomAlign">
<b><a href="qvulkanwindow#physicalDeviceProperties">physicalDeviceProperties</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> VkSampleCountFlagBits </td>
<td class="memItemRight bottomAlign">
<b><a href="qvulkanwindow#sampleCountFlagBits">sampleCountFlagBits</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qvulkanwindow#setDeviceExtensions">setDeviceExtensions</a></b>(const QByteArrayList &amp;<i>extensions</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qvulkanwindow#setFlags">setFlags</a></b>(QVulkanWindow::Flags <i>flags</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qvulkanwindow#setPhysicalDeviceIndex">setPhysicalDeviceIndex</a></b>(int <i>idx</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qvulkanwindow#setPreferredColorFormats">setPreferredColorFormats</a></b>(const QVector&lt;VkFormat&gt; &amp;<i>formats</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qvulkanwindow#setQueueCreateInfoModifier">setQueueCreateInfoModifier</a></b>(const QVulkanWindow::QueueCreateInfoModifier &amp;<i>modifier</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qvulkanwindow#setSampleCount">setSampleCount</a></b>(int <i>sampleCount</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QVulkanInfoVector&lt;QVulkanExtension&gt; </td>
<td class="memItemRight bottomAlign">
<b><a href="qvulkanwindow#supportedDeviceExtensions">supportedDeviceExtensions</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QVector&lt;int&gt; </td>
<td class="memItemRight bottomAlign">
<b><a href="qvulkanwindow#supportedSampleCounts">supportedSampleCounts</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qvulkanwindow#supportsGrab">supportsGrab</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> VkImage </td>
<td class="memItemRight bottomAlign">
<b><a href="qvulkanwindow#swapChainImage">swapChainImage</a></b>(int <i>idx</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> int </td>
<td class="memItemRight bottomAlign">
<b><a href="qvulkanwindow#swapChainImageCount">swapChainImageCount</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QSize </td>
<td class="memItemRight bottomAlign">
<b><a href="qvulkanwindow#swapChainImageSize">swapChainImageSize</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> VkImageView </td>
<td class="memItemRight bottomAlign">
<b><a href="qvulkanwindow#swapChainImageView">swapChainImageView</a></b>(int <i>idx</i>) const</td>
</tr> </table>  <h2 id="static-public-members">Static Public Members
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> const int </td>
<td class="memItemRight bottomAlign"><b><a href="qvulkanwindow#MAX_CONCURRENT_FRAME_COUNT-var">MAX_CONCURRENT_FRAME_COUNT</a></b></td>
</tr> </table>    <h2 id="details">Detailed Description
</h2> <p>QVulkanWindow is a Vulkan-capable <a href="qwindow">QWindow</a> that manages a Vulkan device, a graphics queue, a command pool and buffer, a depth-stencil image and a double-buffered FIFO swapchain, while taking care of correct behavior when it comes to events like resize, special situations like not having a device queue supporting both graphics and presentation, device lost scenarios, and additional functionality like reading the rendered content back. Conceptually it is the counterpart of <a href="qopenglwindow">QOpenGLWindow</a> in the Vulkan world.</p> <p><b>Note: </b>QVulkanWindow does not always eliminate the need to implement a fully custom <a href="qwindow">QWindow</a> subclass as it will not necessarily be sufficient in advanced use cases.</p> <p>QVulkanWindow can be embedded into <a href="qwidget">QWidget</a>-based user interfaces via <a href="qwidget#createWindowContainer">QWidget::createWindowContainer</a>(). This approach has a number of limitations, however. Make sure to study the <a href="qwidget#createWindowContainer">documentation</a> first.</p> <p>A typical application using QVulkanWindow may look like the following:</p> <pre data-language="cpp">  class VulkanRenderer : public QVulkanWindowRenderer
  {
  public:
      VulkanRenderer(QVulkanWindow *w) : m_window(w) { }

      void initResources() override
      {
          m_devFuncs = m_window-&gt;vulkanInstance()-&gt;deviceFunctions(m_window-&gt;device());
          ...
      }
      void initSwapChainResources() override { ... }
      void releaseSwapChainResources() override { ... }
      void releaseResources() override { ... }

      void startNextFrame() override
      {
          VkCommandBuffer cmdBuf = m_window-&gt;currentCommandBuffer();
          ...
          m_devFuncs-&gt;vkCmdBeginRenderPass(...);
          ...
          m_window-&gt;frameReady();
      }

  private:
      QVulkanWindow *m_window;
      QVulkanDeviceFunctions *m_devFuncs;
  };

  class VulkanWindow : public QVulkanWindow
  {
  public:
      QVulkanWindowRenderer *createRenderer() override {
          return new VulkanRenderer(this);
      }
  };

  int main(int argc, char *argv[])
  {
      QGuiApplication app(argc, argv);

      QVulkanInstance inst;
      // enable the standard validation layers, when available
      inst.setLayers(QByteArrayList() &lt;&lt; "VK_LAYER_LUNARG_standard_validation");
      if (!inst.create())
          qFatal("Failed to create Vulkan instance: %d", inst.errorCode());

      VulkanWindow w;
      w.setVulkanInstance(&amp;inst);
      w.showMaximized();

      return app.exec();
  }</pre> <p>As it can be seen in the example, the main patterns in QVulkanWindow usage are:</p> <ul> <li>The <a href="qvulkaninstance">QVulkanInstance</a> is associated via <a href="qwindow#setVulkanInstance">QWindow::setVulkanInstance</a>(). It is then retrievable via <a href="qwindow#vulkanInstance">QWindow::vulkanInstance</a>() from everywhere, on any thread.</li> <li>Similarly to <a href="qvulkaninstance">QVulkanInstance</a>, device extensions can be queried via <a href="qvulkanwindow#supportedDeviceExtensions">supportedDeviceExtensions</a>() before the actual initialization. Requesting an extension to be enabled is done via <a href="qvulkanwindow#setDeviceExtensions">setDeviceExtensions</a>(). Such calls must be made before the window becomes visible, that is, before calling <a href="qwindow#show">show</a>() or similar functions. Unsupported extension requests are gracefully ignored.</li> <li>The renderer is implemented in a <a href="qvulkanwindowrenderer">QVulkanWindowRenderer</a> subclass, an instance of which is created in the <a href="qvulkanwindow#createRenderer">createRenderer</a>() factory function.</li> <li>The core Vulkan commands are exposed via the <a href="qvulkanfunctions">QVulkanFunctions</a> object, retrievable by calling <a href="qvulkaninstance#functions">QVulkanInstance::functions</a>(). Device level functions are available after creating a VkDevice by calling <a href="qvulkaninstance#deviceFunctions">QVulkanInstance::deviceFunctions</a>().</li> <li>The building of the draw calls for the next frame happens in QVulkanWindowRenderer::startNextFrame(). The implementation is expected to add commands to the command buffer returned from <a href="qvulkanwindow#currentCommandBuffer">currentCommandBuffer</a>(). Returning from the function does not indicate that the commands are ready for submission. Rather, an explicit call to <a href="qvulkanwindow#frameReady">frameReady</a>() is required. This allows asynchronous generation of commands, possibly on multiple threads. Simple implementations will simply call <a href="qvulkanwindow#frameReady">frameReady</a>() at the end of their QVulkanWindowRenderer::startNextFrame().</li> <li>The basic Vulkan resources (physical device, graphics queue, a command pool, the window's main command buffer, image formats, etc.) are exposed on the QVulkanWindow via lightweight getter functions. Some of these are for convenience only, and applications are always free to query, create and manage additional resources directly via the Vulkan API.</li> <li>The renderer lives in the gui/main thread, like the window itself. This thread is then throttled to the presentation rate, similarly to how OpenGL with a swap interval of 1 would behave. However, the renderer implementation is free to utilize multiple threads in any way it sees fit. The accessors like <a href="qwindow#vulkanInstance">vulkanInstance</a>(), <a href="qvulkanwindow#currentCommandBuffer">currentCommandBuffer</a>(), etc. can be called from any thread. The submission of the main command buffer, the queueing of present, and the building of the next frame do not start until <a href="qvulkanwindow#frameReady">frameReady</a>() is invoked on the gui/main thread.</li> <li>When the window is made visible, the content is updated automatically. Further updates can be requested by calling <a href="qwindow#requestUpdate">QWindow::requestUpdate</a>(). To render continuously, call <a href="qwindow#requestUpdate">requestUpdate</a>() after <a href="qvulkanwindow#frameReady">frameReady</a>().</li> </ul> <p>For troubleshooting, enable the logging category <code>qt.vulkan</code>. Critical errors are printed via <a href="qtglobal#qWarning">qWarning</a>() automatically.</p>  <h3 id="coordinate-system-differences-between-opengl-and-vulkan">Coordinate system differences between OpenGL and Vulkan
</h3> <p>There are two notable differences to be aware of: First, with Vulkan Y points down the screen in clip space, while OpenGL uses an upwards pointing Y axis. Second, the standard OpenGL projection matrix assume a near and far plane values of -1 and 1, while Vulkan prefers 0 and 1.</p> <p>In order to help applications migrate from OpenGL-based code without having to flip Y coordinates in the vertex data, and to allow using <a href="qmatrix4x4">QMatrix4x4</a> functions like <a href="qmatrix4x4#perspective">QMatrix4x4::perspective</a>() while keeping the Vulkan viewport's minDepth and maxDepth set to 0 and 1, QVulkanWindow provides a correction matrix retrievable by calling <a href="qvulkanwindow#clipCorrectionMatrix">clipCorrectionMatrix</a>().</p>  <h3 id="multisampling">Multisampling
</h3> <p>While disabled by default, multisample antialiasing is fully supported by QVulkanWindow. Additional color buffers and resolving into the swapchain's non-multisample buffers are all managed automatically.</p> <p>To query the supported sample counts, call <a href="qvulkanwindow#supportedSampleCounts">supportedSampleCounts</a>(). When the returned set contains 4, 8, ..., passing one of those values to <a href="qvulkanwindow#setSampleCount">setSampleCount</a>() requests multisample rendering.</p> <p><b>Note: </b>unlike <a href="qsurfaceformat#setSamples">QSurfaceFormat::setSamples</a>(), the list of supported sample counts are exposed to the applications in advance and there is no automatic falling back to lower sample counts in <a href="qvulkanwindow#setSampleCount">setSampleCount</a>(). If the requested value is not supported, a warning is shown and a no multisampling will be used.</p>  <h3 id="reading-images-back">Reading images back
</h3> <p>When <a href="qvulkanwindow#supportsGrab">supportsGrab</a>() returns true, QVulkanWindow can perform readbacks from the color buffer into a <a href="qimage">QImage</a>. <a href="qvulkanwindow#grab">grab</a>() is a slow and inefficient operation, so frequent usage should be avoided. It is nonetheless valuable since it allows applications to take screenshots, or tools and tests to process and verify the output of the GPU rendering.</p>  <h3 id="srgb-support">sRGB support
</h3> <p>While many applications will be fine with the default behavior of QVulkanWindow when it comes to swapchain image formats, <a href="qvulkanwindow#setPreferredColorFormats">setPreferredColorFormats</a>() allows requesting a pre-defined format. This is useful most notably when working in the sRGB color space. Passing a format like <code>VK_FORMAT_B8G8R8A8_SRGB</code> results in choosing an sRGB format, when available.</p>  <h3 id="validation-layers">Validation layers
</h3> <p>During application development it can be extremely valuable to have the Vulkan validation layers enabled. As shown in the example code above, calling <a href="qvulkaninstance#setLayers">QVulkanInstance::setLayers</a>() on the <a href="qvulkaninstance">QVulkanInstance</a> before <a href="qvulkaninstance#create">QVulkanInstance::create</a>() enables validation, assuming the Vulkan driver stack in the system contains the necessary layers.</p> <p><b>Note: </b>Be aware of platform-specific differences. On desktop platforms installing the <a href="https://www.lunarg.com/vulkan-sdk/">Vulkan SDK</a> is typically sufficient. However, Android for example requires deploying additional shared libraries together with the application, and also mandates a different list of validation layer names. See <a href="https://developer.android.com/ndk/guides/graphics/validation-layer.html">the Android Vulkan development pages</a> for more information.</p> <p><b>Note: </b>QVulkanWindow does not expose device layers since this functionality has been deprecated since version 1.0.13 of the Vulkan API.</p>  <p><b>See also </b><a href="qvulkaninstance">QVulkanInstance</a> and <a href="qwindow">QWindow</a>.</p>   <h2>Member Type Documentation</h2>  <h3 class="flags" id="Flag-enum">
enum QVulkanWindow::<span class="name">Flag</span>flags QVulkanWindow::<span class="name">Flags</span>
</h3> <p>This enum describes the flags that can be passed to <a href="qvulkanwindow#setFlags">setFlags</a>().</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QVulkanWindow::PersistentResources</code></td>
<td class="topAlign tblval"><code>0x01</code></td>
<td class="topAlign">Ensures no graphics resources are released when the window becomes unexposed. The default behavior is to release everything, and reinitialize later when becoming visible again.</td>
</tr> </table> <p>The Flags type is a typedef for <a href="qflags">QFlags</a>&lt;Flag&gt;. It stores an OR combination of Flag values.</p>   <h3 class="fn" id="QueueCreateInfoModifier-typedef">
typedef QVulkanWindow::<span class="name">QueueCreateInfoModifier</span>
</h3> <p>A function function that is called during graphics initialization to add additAional queues that should be created.</p> <p>Set if the renderer needs additional queues besides the default graphics queue (e.g. a transfer queue). The provided queue family properties can be used to select the indices for the additional queues. The renderer can subsequently request the actual queue in initResources().</p> <p>Note when requesting additional graphics queues: Qt itself always requests a graphics queue, you'll need to search queueCreateInfo for the appropriate entry and manipulate it to obtain the additional queue.</p> <p><b>See also </b><a href="qvulkanwindow#setQueueCreateInfoModifier">setQueueCreateInfoModifier</a>().</p>    <h2>Member Function Documentation</h2>  <h3 class="fn" id="QVulkanWindow">
QVulkanWindow::<span class="name">QVulkanWindow</span>(<span class="type"><a href="qwindow#QWindow">QWindow</a></span> *<i>parent</i> = nullptr)
</h3> <p>Constructs a new QVulkanWindow with the given <i>parent</i>.</p> <p>The surface type is set to <a href="qsurface#SurfaceType-enum">QSurface::VulkanSurface</a>.</p>   <h3 class="fn" id="dtor.QVulkanWindow">
<code>[virtual] </code>QVulkanWindow::<span class="name">~QVulkanWindow</span>()
</h3> <p>Destructor.</p>   <h3 class="fn" id="availablePhysicalDevices">
<span class="type"><a href="qvector">QVector</a></span>&lt;<span class="type">VkPhysicalDeviceProperties</span>&gt; QVulkanWindow::<span class="name">availablePhysicalDevices</span>()
</h3> <p>Returns the list of properties for the supported physical devices in the system.</p> <p><b>Note: </b>This function can be called before making the window visible.</p>   <h3 class="fn" id="clipCorrectionMatrix">
<span class="type"><a href="qmatrix4x4">QMatrix4x4</a></span> QVulkanWindow::<span class="name">clipCorrectionMatrix</span>()
</h3> <p>Returns a <a href="qmatrix4x4">QMatrix4x4</a> that can be used to correct for coordinate system differences between OpenGL and Vulkan.</p> <p>By pre-multiplying the projection matrix with this matrix, applications can continue to assume that Y is pointing upwards, and can set minDepth and maxDepth in the viewport to 0 and 1, respectively, without having to do any further corrections to the vertex Z positions. Geometry from OpenGL applications can then be used as-is, assuming a rasterization state matching the OpenGL culling and front face settings.</p>   <h3 class="fn" id="colorFormat">
<span class="type">VkFormat</span> QVulkanWindow::<span class="name">colorFormat</span>() const
</h3> <p>Returns the color buffer format used by the swapchain.</p> <p><b>Note: </b>Calling this function is only valid from the invocation of <a href="qvulkanwindowrenderer#initResources">QVulkanWindowRenderer::initResources</a>() up until <a href="qvulkanwindowrenderer#releaseResources">QVulkanWindowRenderer::releaseResources</a>().</p> <p><b>See also </b><a href="qvulkanwindow#setPreferredColorFormats">setPreferredColorFormats</a>().</p>   <h3 class="fn" id="concurrentFrameCount">
<span class="type">int</span> QVulkanWindow::<span class="name">concurrentFrameCount</span>() const
</h3> <p>Returns the number of frames that can be potentially active at the same time.</p> <p><b>Note: </b>The value is constant for the entire lifetime of the <a href="qvulkanwindow">QVulkanWindow</a>.</p> <pre data-language="cpp">    class Renderer {
        ...
        VkDescriptorBufferInfo m_uniformBufInfo[QVulkanWindow::MAX_CONCURRENT_FRAME_COUNT];
    };

    void Renderer::startNextFrame()
    {
        const int count = m_window-&gt;concurrentFrameCount();
        for (int i = 0; i &lt; count; ++i)
            m_uniformBufInfo[i] = ...
        ...
    }</pre> <p><b>See also </b><a href="qvulkanwindow#currentFrame">currentFrame</a>().</p>   <h3 class="fn" id="createRenderer">
<code>[virtual] </code><span class="type"><a href="qvulkanwindowrenderer">QVulkanWindowRenderer</a></span> *QVulkanWindow::<span class="name">createRenderer</span>()
</h3> <p>Returns a new instance of <a href="qvulkanwindowrenderer">QVulkanWindowRenderer</a>.</p> <p>This virtual function is called once during the lifetime of the window, at some point after making it visible for the first time.</p> <p>The default implementation returns null and so no rendering will be performed apart from clearing the buffers.</p> <p>The window takes ownership of the returned renderer object.</p>   <h3 class="fn" id="currentCommandBuffer">
<span class="type">VkCommandBuffer</span> QVulkanWindow::<span class="name">currentCommandBuffer</span>() const
</h3> <p>Returns The active command buffer for the current swap chain image. Implementations of QVulkanWindowRenderer::startNextFrame() are expected to add commands to this command buffer.</p> <p><b>Note: </b>This function must only be called from within startNextFrame() and, in case of asynchronous command generation, up until the call to <a href="qvulkanwindow#frameReady">frameReady</a>().</p>   <h3 class="fn" id="currentFrame">
<span class="type">int</span> QVulkanWindow::<span class="name">currentFrame</span>() const
</h3> <p>Returns the current frame index in the range [0, <a href="qvulkanwindow#concurrentFrameCount">concurrentFrameCount</a>() - 1].</p> <p>Renderer implementations will have to ensure that uniform data and other dynamic resources exist in multiple copies, in order to prevent frame N altering the data used by the still-active frames N - 1, N - 2, ... N - <a href="qvulkanwindow#concurrentFrameCount">concurrentFrameCount</a>() + 1.</p> <p>To avoid relying on dynamic array sizes, applications can use <a href="qvulkanwindow#MAX_CONCURRENT_FRAME_COUNT-var">MAX_CONCURRENT_FRAME_COUNT</a> when declaring arrays. This is guaranteed to be always equal to or greater than the value returned from <a href="qvulkanwindow#concurrentFrameCount">concurrentFrameCount</a>(). Such arrays can then be indexed by the value returned from this function.</p> <pre data-language="cpp">    class Renderer {
        ...
        VkDescriptorBufferInfo m_uniformBufInfo[QVulkanWindow::MAX_CONCURRENT_FRAME_COUNT];
    };

    void Renderer::startNextFrame()
    {
        VkDescriptorBufferInfo &amp;uniformBufInfo(m_uniformBufInfo[m_window-&gt;currentFrame()]);
        ...
    }</pre> <p><b>Note: </b>This function must only be called from within startNextFrame() and, in case of asynchronous command generation, up until the call to <a href="qvulkanwindow#frameReady">frameReady</a>().</p> <p><b>See also </b><a href="qvulkanwindow#concurrentFrameCount">concurrentFrameCount</a>().</p>   <h3 class="fn" id="currentFramebuffer">
<span class="type">VkFramebuffer</span> QVulkanWindow::<span class="name">currentFramebuffer</span>() const
</h3> <p>Returns a VkFramebuffer for the current swapchain image using the default render pass.</p> <p>The framebuffer has two attachments (color, depth-stencil) when multisampling is not in use, and three (color resolve, depth-stencil, multisample color) when <a href="qvulkanwindow#sampleCountFlagBits">sampleCountFlagBits</a>() is greater than <code>VK_SAMPLE_COUNT_1_BIT</code>. Renderers must take this into account, for example when providing clear values.</p> <p><b>Note: </b>Applications are not required to use this framebuffer in case they provide their own render pass instead of using the one returned from <a href="qvulkanwindow#defaultRenderPass">defaultRenderPass</a>().</p> <p><b>Note: </b>This function must only be called from within startNextFrame() and, in case of asynchronous command generation, up until the call to <a href="qvulkanwindow#frameReady">frameReady</a>().</p> <p><b>See also </b><a href="qvulkanwindow#defaultRenderPass">defaultRenderPass</a>().</p>   <h3 class="fn" id="currentSwapChainImageIndex">
<span class="type">int</span> QVulkanWindow::<span class="name">currentSwapChainImageIndex</span>() const
</h3> <p>Returns the current swap chain image index in the range [0, <a href="qvulkanwindow#swapChainImageCount">swapChainImageCount</a>() - 1].</p> <p><b>Note: </b>This function must only be called from within startNextFrame() and, in case of asynchronous command generation, up until the call to <a href="qvulkanwindow#frameReady">frameReady</a>().</p>   <h3 class="fn" id="defaultRenderPass">
<span class="type">VkRenderPass</span> QVulkanWindow::<span class="name">defaultRenderPass</span>() const
</h3> <p>Returns a typical render pass with one sub-pass.</p> <p><b>Note: </b>Applications are not required to use this render pass. However, they are then responsible for ensuring the current swap chain and depth-stencil images get transitioned from <code>VK_IMAGE_LAYOUT_UNDEFINED</code> to <code>VK_IMAGE_LAYOUT_PRESENT_SRC_KHR</code> and <code>VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL</code> either via the application's custom render pass or by other means.</p> <p><b>Note: </b>Stencil read/write is not enabled in this render pass.</p> <p><b>Note: </b>Calling this function is only valid from the invocation of <a href="qvulkanwindowrenderer#initResources">QVulkanWindowRenderer::initResources</a>() up until <a href="qvulkanwindowrenderer#releaseResources">QVulkanWindowRenderer::releaseResources</a>().</p> <p><b>See also </b><a href="qvulkanwindow#currentFramebuffer">currentFramebuffer</a>().</p>   <h3 class="fn" id="depthStencilFormat">
<span class="type">VkFormat</span> QVulkanWindow::<span class="name">depthStencilFormat</span>() const
</h3> <p>Returns the format used by the depth-stencil buffer(s).</p> <p><b>Note: </b>Calling this function is only valid from the invocation of <a href="qvulkanwindowrenderer#initResources">QVulkanWindowRenderer::initResources</a>() up until <a href="qvulkanwindowrenderer#releaseResources">QVulkanWindowRenderer::releaseResources</a>().</p>   <h3 class="fn" id="depthStencilImage">
<span class="type">VkImage</span> QVulkanWindow::<span class="name">depthStencilImage</span>() const
</h3> <p>Returns the depth-stencil image.</p> <p><b>Note: </b>Calling this function is only valid from the invocation of <a href="qvulkanwindowrenderer#initSwapChainResources">QVulkanWindowRenderer::initSwapChainResources</a>() up until <a href="qvulkanwindowrenderer#releaseSwapChainResources">QVulkanWindowRenderer::releaseSwapChainResources</a>().</p>   <h3 class="fn" id="depthStencilImageView">
<span class="type">VkImageView</span> QVulkanWindow::<span class="name">depthStencilImageView</span>() const
</h3> <p>Returns the depth-stencil image view.</p> <p><b>Note: </b>Calling this function is only valid from the invocation of <a href="qvulkanwindowrenderer#initSwapChainResources">QVulkanWindowRenderer::initSwapChainResources</a>() up until <a href="qvulkanwindowrenderer#releaseSwapChainResources">QVulkanWindowRenderer::releaseSwapChainResources</a>().</p>   <h3 class="fn" id="device">
<span class="type">VkDevice</span> QVulkanWindow::<span class="name">device</span>() const
</h3> <p>Returns the active logical device.</p> <p><b>Note: </b>Calling this function is only valid from the invocation of <a href="qvulkanwindowrenderer#initResources">QVulkanWindowRenderer::initResources</a>() up until <a href="qvulkanwindowrenderer#releaseResources">QVulkanWindowRenderer::releaseResources</a>().</p>   <h3 class="fn" id="deviceLocalMemoryIndex">
<span class="type">uint32_t</span> QVulkanWindow::<span class="name">deviceLocalMemoryIndex</span>() const
</h3> <p>Returns a device local memory type index suitable for general use.</p> <p><b>Note: </b>Calling this function is only valid from the invocation of <a href="qvulkanwindowrenderer#initResources">QVulkanWindowRenderer::initResources</a>() up until <a href="qvulkanwindowrenderer#releaseResources">QVulkanWindowRenderer::releaseResources</a>().</p> <p><b>Note: </b>It is not guaranteed that this memory type is always suitable. The correct, cross-implementation solution - especially for device local images - is to manually pick a memory type after checking the mask returned from <code>vkGetImageMemoryRequirements</code>.</p>   <h3 class="fn" id="flags">
<span class="type"><a href="qvulkanwindow#Flag-enum">QVulkanWindow::Flags</a></span> QVulkanWindow::<span class="name">flags</span>() const
</h3> <p>Return the requested flags.</p> <p><b>See also </b><a href="qvulkanwindow#setFlags">setFlags</a>().</p>   <h3 class="fn" id="frameReady">
<span class="type">void</span> QVulkanWindow::<span class="name">frameReady</span>()
</h3> <p>This function must be called exactly once in response to each invocation of the QVulkanWindowRenderer::startNextFrame() implementation. At the time of this call, the main command buffer, exposed via <a href="qvulkanwindow#currentCommandBuffer">currentCommandBuffer</a>(), must have all necessary rendering commands added to it since this function will trigger submitting the commands and queuing the present command.</p> <p><b>Note: </b>This function must only be called from the gui/main thread, which is where <a href="qvulkanwindowrenderer">QVulkanWindowRenderer</a>'s functions are invoked and where the <a href="qvulkanwindow">QVulkanWindow</a> instance lives.</p> <p><b>See also </b>QVulkanWindowRenderer::startNextFrame().</p>   <h3 class="fn" id="grab">
<span class="type"><a href="qimage">QImage</a></span> QVulkanWindow::<span class="name">grab</span>()
</h3> <p>Builds and renders the next frame without presenting it, then performs a blocking readback of the image content.</p> <p>Returns the image if the renderer's startNextFrame() implementation calls back <a href="qvulkanwindow#frameReady">frameReady</a>() directly. Otherwise, returns an incomplete image, that has the correct size but not the content yet. The content will be delivered via the frameGrabbed() signal in the latter case.</p> <p><b>Note: </b>This function should not be called when a frame is in progress (that is, <a href="qvulkanwindow#frameReady">frameReady</a>() has not yet been called back by the application).</p> <p><b>Note: </b>This function is potentially expensive due to the additional, blocking readback.</p> <p><b>Note: </b>This function currently requires that the swapchain supports usage as a transfer source (<code>VK_IMAGE_USAGE_TRANSFER_SRC_BIT</code>), and will fail otherwise.</p>   <h3 class="fn" id="graphicsCommandPool">
<span class="type">VkCommandPool</span> QVulkanWindow::<span class="name">graphicsCommandPool</span>() const
</h3> <p>Returns the active graphics command pool.</p> <p><b>Note: </b>Calling this function is only valid from the invocation of <a href="qvulkanwindowrenderer#initResources">QVulkanWindowRenderer::initResources</a>() up until <a href="qvulkanwindowrenderer#releaseResources">QVulkanWindowRenderer::releaseResources</a>().</p>   <h3 class="fn" id="graphicsQueue">
<span class="type">VkQueue</span> QVulkanWindow::<span class="name">graphicsQueue</span>() const
</h3> <p>Returns the active graphics queue.</p> <p><b>Note: </b>Calling this function is only valid from the invocation of <a href="qvulkanwindowrenderer#initResources">QVulkanWindowRenderer::initResources</a>() up until <a href="qvulkanwindowrenderer#releaseResources">QVulkanWindowRenderer::releaseResources</a>().</p>   <h3 class="fn" id="graphicsQueueFamilyIndex">
<span class="type">uint32_t</span> QVulkanWindow::<span class="name">graphicsQueueFamilyIndex</span>() const
</h3> <p>Returns the family index of the active graphics queue.</p> <p><b>Note: </b>Calling this function is only valid from the invocation of <a href="qvulkanwindowrenderer#initResources">QVulkanWindowRenderer::initResources</a>() up until <a href="qvulkanwindowrenderer#releaseResources">QVulkanWindowRenderer::releaseResources</a>(). Implementations of QVulkanWindowRenderer::updateQueueCreateInfo() can also call this function.</p> <p>This function was introduced in Qt 5.15.</p>   <h3 class="fn" id="hostVisibleMemoryIndex">
<span class="type">uint32_t</span> QVulkanWindow::<span class="name">hostVisibleMemoryIndex</span>() const
</h3> <p>Returns a host visible memory type index suitable for general use.</p> <p>The returned memory type will be both host visible and coherent. In addition, it will also be cached, if possible.</p> <p><b>Note: </b>Calling this function is only valid from the invocation of <a href="qvulkanwindowrenderer#initResources">QVulkanWindowRenderer::initResources</a>() up until <a href="qvulkanwindowrenderer#releaseResources">QVulkanWindowRenderer::releaseResources</a>().</p>   <h3 class="fn" id="isValid">
<span class="type">bool</span> QVulkanWindow::<span class="name">isValid</span>() const
</h3> <p>Returns true if this window has successfully initialized all Vulkan resources, including the swapchain.</p> <p><b>Note: </b>Initialization happens on the first expose event after the window is made visible.</p>   <h3 class="fn" id="msaaColorImage">
<span class="type">VkImage</span> QVulkanWindow::<span class="name">msaaColorImage</span>(<span class="type">int</span> <i>idx</i>) const
</h3> <p>Returns the specified multisample color image, or <code>VK_NULL_HANDLE</code> if multisampling is not in use.</p> <p><i>idx</i> must be in the range [0, <a href="qvulkanwindow#swapChainImageCount">swapChainImageCount</a>() - 1].</p> <p><b>Note: </b>Calling this function is only valid from the invocation of <a href="qvulkanwindowrenderer#initSwapChainResources">QVulkanWindowRenderer::initSwapChainResources</a>() up until <a href="qvulkanwindowrenderer#releaseSwapChainResources">QVulkanWindowRenderer::releaseSwapChainResources</a>().</p>   <h3 class="fn" id="msaaColorImageView">
<span class="type">VkImageView</span> QVulkanWindow::<span class="name">msaaColorImageView</span>(<span class="type">int</span> <i>idx</i>) const
</h3> <p>Returns the specified multisample color image view, or <code>VK_NULL_HANDLE</code> if multisampling is not in use.</p> <p><i>idx</i> must be in the range [0, <a href="qvulkanwindow#swapChainImageCount">swapChainImageCount</a>() - 1].</p> <p><b>Note: </b>Calling this function is only valid from the invocation of <a href="qvulkanwindowrenderer#initSwapChainResources">QVulkanWindowRenderer::initSwapChainResources</a>() up until <a href="qvulkanwindowrenderer#releaseSwapChainResources">QVulkanWindowRenderer::releaseSwapChainResources</a>().</p>   <h3 class="fn" id="physicalDevice">
<span class="type">VkPhysicalDevice</span> QVulkanWindow::<span class="name">physicalDevice</span>() const
</h3> <p>Returns the active physical device.</p> <p><b>Note: </b>Calling this function is only valid from the invocation of <a href="qvulkanwindowrenderer#preInitResources">QVulkanWindowRenderer::preInitResources</a>() up until <a href="qvulkanwindowrenderer#releaseResources">QVulkanWindowRenderer::releaseResources</a>().</p>   <h3 class="fn" id="physicalDeviceProperties">
const <span class="type">VkPhysicalDeviceProperties</span> *QVulkanWindow::<span class="name">physicalDeviceProperties</span>() const
</h3> <p>Returns a pointer to the properties for the active physical device.</p> <p><b>Note: </b>Calling this function is only valid from the invocation of <a href="qvulkanwindowrenderer#preInitResources">QVulkanWindowRenderer::preInitResources</a>() up until <a href="qvulkanwindowrenderer#releaseResources">QVulkanWindowRenderer::releaseResources</a>().</p>   <h3 class="fn" id="sampleCountFlagBits">
<span class="type">VkSampleCountFlagBits</span> QVulkanWindow::<span class="name">sampleCountFlagBits</span>() const
</h3> <p>Returns the current sample count as a <code>VkSampleCountFlagBits</code> value.</p> <p>When targeting the default render target, the <code>rasterizationSamples</code> field of <code>VkPipelineMultisampleStateCreateInfo</code> must be set to this value.</p> <p><b>See also </b><a href="qvulkanwindow#setSampleCount">setSampleCount</a>() and <a href="qvulkanwindow#supportedSampleCounts">supportedSampleCounts</a>().</p>   <h3 class="fn" id="setDeviceExtensions">
<span class="type">void</span> QVulkanWindow::<span class="name">setDeviceExtensions</span>(const <span class="type"><a href="qbytearraylist">QByteArrayList</a></span> &amp;<i>extensions</i>)
</h3> <p>Sets the list of device <i>extensions</i> to be enabled.</p> <p>Unsupported extensions are ignored.</p> <p>The swapchain extension will always be added automatically, no need to include it in this list.</p> <p><b>Note: </b>This function must be called before the window is made visible or at latest in <a href="qvulkanwindowrenderer#preInitResources">QVulkanWindowRenderer::preInitResources</a>(), and has no effect if called afterwards.</p>   <h3 class="fn" id="setFlags">
<span class="type">void</span> QVulkanWindow::<span class="name">setFlags</span>(<span class="type"><a href="qvulkanwindow#Flag-enum">QVulkanWindow::Flags</a></span> <i>flags</i>)
</h3> <p>Configures the behavior based on the provided <i>flags</i>.</p> <p><b>Note: </b>This function must be called before the window is made visible or at latest in <a href="qvulkanwindowrenderer#preInitResources">QVulkanWindowRenderer::preInitResources</a>(), and has no effect if called afterwards.</p> <p><b>See also </b><a href="qvulkanwindow#flags">flags</a>().</p>   <h3 class="fn" id="setPhysicalDeviceIndex">
<span class="type">void</span> QVulkanWindow::<span class="name">setPhysicalDeviceIndex</span>(<span class="type">int</span> <i>idx</i>)
</h3> <p>Requests the usage of the physical device with index <i>idx</i>. The index corresponds to the list returned from <a href="qvulkanwindow#availablePhysicalDevices">availablePhysicalDevices</a>().</p> <p>By default the first physical device is used.</p> <p><b>Note: </b>This function must be called before the window is made visible or at latest in <a href="qvulkanwindowrenderer#preInitResources">QVulkanWindowRenderer::preInitResources</a>(), and has no effect if called afterwards.</p>   <h3 class="fn" id="setPreferredColorFormats">
<span class="type">void</span> QVulkanWindow::<span class="name">setPreferredColorFormats</span>(const <span class="type"><a href="qvector">QVector</a></span>&lt;<span class="type">VkFormat</span>&gt; &amp;<i>formats</i>)
</h3> <p>Sets the preferred <i>formats</i> of the swapchain.</p> <p>By default no application-preferred format is set. In this case the surface's preferred format will be used or, in absence of that, <code>VK_FORMAT_B8G8R8A8_UNORM</code>.</p> <p>The list in <i>formats</i> is ordered. If the first format is not supported, the second will be considered, and so on. When no formats in the list are supported, the behavior is the same as in the default case.</p> <p>To query the actual format after initialization, call <a href="qvulkanwindow#colorFormat">colorFormat</a>().</p> <p><b>Note: </b>This function must be called before the window is made visible or at latest in <a href="qvulkanwindowrenderer#preInitResources">QVulkanWindowRenderer::preInitResources</a>(), and has no effect if called afterwards.</p> <p><b>Note: </b>Reimplementing <a href="qvulkanwindowrenderer#preInitResources">QVulkanWindowRenderer::preInitResources</a>() allows dynamically examining the list of supported formats, should that be desired. There the surface is retrievable via QVulkanInstace::surfaceForWindow(), while this function can still safely be called to affect the later stages of initialization.</p> <p><b>See also </b><a href="qvulkanwindow#colorFormat">colorFormat</a>().</p>   <h3 class="fn" id="setQueueCreateInfoModifier">
<span class="type">void</span> QVulkanWindow::<span class="name">setQueueCreateInfoModifier</span>(const <span class="type"><a href="qvulkanwindow#QueueCreateInfoModifier-typedef">QVulkanWindow::QueueCreateInfoModifier</a></span> &amp;<i>modifier</i>)
</h3> <p>Set a queue create info modification function.</p> <p>This function was introduced in Qt 5.15.</p> <p><b>See also </b>queueCreateInfoModifier().</p>   <h3 class="fn" id="setSampleCount">
<span class="type">void</span> QVulkanWindow::<span class="name">setSampleCount</span>(<span class="type">int</span> <i>sampleCount</i>)
</h3> <p>Requests multisample antialiasing with the given <i>sampleCount</i>. The valid values are 1, 2, 4, 8, ... up until the maximum value supported by the physical device.</p> <p>When the sample count is greater than 1, <a href="qvulkanwindow">QVulkanWindow</a> will create a multisample color buffer instead of simply targeting the swapchain's images. The rendering in the multisample buffer will get resolved into the non-multisample buffers at the end of each frame.</p> <p>To examine the list of supported sample counts, call <a href="qvulkanwindow#supportedSampleCounts">supportedSampleCounts</a>().</p> <p>When setting up the rendering pipeline, call <a href="qvulkanwindow#sampleCountFlagBits">sampleCountFlagBits</a>() to query the active sample count as a <code>VkSampleCountFlagBits</code> value.</p> <p><b>Note: </b>This function must be called before the window is made visible or at latest in <a href="qvulkanwindowrenderer#preInitResources">QVulkanWindowRenderer::preInitResources</a>(), and has no effect if called afterwards.</p> <p><b>See also </b><a href="qvulkanwindow#supportedSampleCounts">supportedSampleCounts</a>() and <a href="qvulkanwindow#sampleCountFlagBits">sampleCountFlagBits</a>().</p>   <h3 class="fn" id="supportedDeviceExtensions">
<span class="type"><a href="qvulkaninfovector">QVulkanInfoVector</a></span>&lt;<span class="type"><a href="qvulkanextension">QVulkanExtension</a></span>&gt; QVulkanWindow::<span class="name">supportedDeviceExtensions</span>()
</h3> <p>Returns the list of the extensions that are supported by logical devices created from the physical device selected by <a href="qvulkanwindow#setPhysicalDeviceIndex">setPhysicalDeviceIndex</a>().</p> <p><b>Note: </b>This function can be called before making the window visible.</p>   <h3 class="fn" id="supportedSampleCounts">
<span class="type"><a href="qvector">QVector</a></span>&lt;<span class="type">int</span>&gt; QVulkanWindow::<span class="name">supportedSampleCounts</span>()
</h3> <p>Returns the set of supported sample counts when using the physical device selected by <a href="qvulkanwindow#setPhysicalDeviceIndex">setPhysicalDeviceIndex</a>(), as a sorted vector.</p> <p>By default <a href="qvulkanwindow">QVulkanWindow</a> uses a sample count of 1. By calling <a href="qvulkanwindow#setSampleCount">setSampleCount</a>() with a different value (2, 4, 8, ...) from the set returned by this function, multisample anti-aliasing can be requested.</p> <p><b>Note: </b>This function can be called before making the window visible.</p> <p><b>See also </b><a href="qvulkanwindow#setSampleCount">setSampleCount</a>().</p>   <h3 class="fn" id="supportsGrab">
<span class="type">bool</span> QVulkanWindow::<span class="name">supportsGrab</span>() const
</h3> <p>Returns true if the swapchain supports usage as transfer source, meaning <a href="qvulkanwindow#grab">grab</a>() is functional.</p> <p><b>Note: </b>Calling this function is only valid from the invocation of <a href="qvulkanwindowrenderer#initSwapChainResources">QVulkanWindowRenderer::initSwapChainResources</a>() up until <a href="qvulkanwindowrenderer#releaseSwapChainResources">QVulkanWindowRenderer::releaseSwapChainResources</a>().</p>   <h3 class="fn" id="swapChainImage">
<span class="type">VkImage</span> QVulkanWindow::<span class="name">swapChainImage</span>(<span class="type">int</span> <i>idx</i>) const
</h3> <p>Returns the specified swap chain image.</p> <p><i>idx</i> must be in the range [0, <a href="qvulkanwindow#swapChainImageCount">swapChainImageCount</a>() - 1].</p> <p><b>Note: </b>Calling this function is only valid from the invocation of <a href="qvulkanwindowrenderer#initSwapChainResources">QVulkanWindowRenderer::initSwapChainResources</a>() up until <a href="qvulkanwindowrenderer#releaseSwapChainResources">QVulkanWindowRenderer::releaseSwapChainResources</a>().</p>   <h3 class="fn" id="swapChainImageCount">
<span class="type">int</span> QVulkanWindow::<span class="name">swapChainImageCount</span>() const
</h3> <p>Returns the number of images in the swap chain.</p> <p><b>Note: </b>Accessing this is necessary when providing a custom render pass and framebuffer. The framebuffer is specific to the current swapchain image and hence the application must provide multiple framebuffers.</p> <p><b>Note: </b>Calling this function is only valid from the invocation of <a href="qvulkanwindowrenderer#initSwapChainResources">QVulkanWindowRenderer::initSwapChainResources</a>() up until <a href="qvulkanwindowrenderer#releaseSwapChainResources">QVulkanWindowRenderer::releaseSwapChainResources</a>().</p>   <h3 class="fn" id="swapChainImageSize">
<span class="type"><a href="qsize">QSize</a></span> QVulkanWindow::<span class="name">swapChainImageSize</span>() const
</h3> <p>Returns the image size of the swapchain.</p> <p>This usually matches the size of the window, but may also differ in case <code>vkGetPhysicalDeviceSurfaceCapabilitiesKHR</code> reports a fixed size.</p> <p><b>Note: </b>Calling this function is only valid from the invocation of <a href="qvulkanwindowrenderer#initSwapChainResources">QVulkanWindowRenderer::initSwapChainResources</a>() up until <a href="qvulkanwindowrenderer#releaseSwapChainResources">QVulkanWindowRenderer::releaseSwapChainResources</a>().</p>   <h3 class="fn" id="swapChainImageView">
<span class="type">VkImageView</span> QVulkanWindow::<span class="name">swapChainImageView</span>(<span class="type">int</span> <i>idx</i>) const
</h3> <p>Returns the specified swap chain image view.</p> <p><i>idx</i> must be in the range [0, <a href="qvulkanwindow#swapChainImageCount">swapChainImageCount</a>() - 1].</p> <p><b>Note: </b>Calling this function is only valid from the invocation of <a href="qvulkanwindowrenderer#initSwapChainResources">QVulkanWindowRenderer::initSwapChainResources</a>() up until <a href="qvulkanwindowrenderer#releaseSwapChainResources">QVulkanWindowRenderer::releaseSwapChainResources</a>().</p>   <div class="vars"> <h2>Member Variable Documentation</h2>  <h3 class="fn" id="MAX_CONCURRENT_FRAME_COUNT-var">
const <span class="type">int</span> QVulkanWindow::<span class="name">MAX_CONCURRENT_FRAME_COUNT</span>
</h3> <p>This variable holds a constant value that is always equal to or greater than the maximum value of <a href="qvulkanwindow#concurrentFrameCount">concurrentFrameCount</a>().</p>  </div>
<div class="_attribution">
  <p class="_attribution-p">
     The Qt Company Ltd<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://doc.qt.io/qt-5.15/qvulkanwindow.html" class="_attribution-link">https://doc.qt.io/qt-5.15/qvulkanwindow.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
