
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Collections - Meteor 1.5 - W3cubDocs</title>
  
  <meta name="description" content=" Meteor stores data in collections. To get started, declare a collection with new Mongo.Collection. ">
  <meta name="keywords" content="collections, meteor, meteor~1.5">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/meteor~1.5/api/collections.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/meteor~1.5.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/meteor~1.5/" class="_nav-link" title="" style="margin-left:0;">Meteor 1.5</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _meteor">
				
				
<h1 class="title-page">Collections</h1> <div class="subtitle-page">Documentation on how to use Meteor's database collections.</div>    <p>Meteor stores data in <em>collections</em>. To get started, declare a collection with <code>new Mongo.Collection</code>.</p>  <h2 class="api-heading" id="Mongo-Collection"> <div class="locus"> Anywhere </div> <code>new Mongo.Collection(name, [options])</code> <div class="subtext-api"> <code>import { Mongo } from 'meteor/mongo'</code> <a class="src-code link secondary" href="https://github.com/meteor/meteor/blob/master/packages/mongo/collection.js#L27" target="_blank"> (mongo/collection.js, line 27) </a> </div> </h2>   <p>Constructor for a Collection</p>  <h4 class="subheading">Arguments</h4> <dl class="args"> <dt> <code>name</code> <span class="type">String</span> </dt> <dd> <p>The name of the collection. If null, creates an unmanaged (unsynchronized) local collection.</p> </dd> </dl> <h4 class="subheading">Options</h4> <dl class="args"> <dt> <code>connection</code> <span class="type">Object</span> </dt> <dd> <p>The server connection that will manage this collection. Uses the default connection if not specified. Pass the return value of calling <a href="#ddp_connect"><code>DDP.connect</code></a> to specify a different server. Pass <code>null</code> to specify no connection. Unmanaged (<code>name</code> is null) collections cannot specify a connection.</p> </dd> <dt> <code>idGeneration</code> <span class="type">String</span> </dt> <dd> <p>The method of generating the <code>_id</code> fields of new documents in this collection. Possible values:</p> <ul> <li>
<strong><code>'STRING'</code></strong>: random strings</li> <li>
<strong><code>'MONGO'</code></strong>: random <a href="#mongo_object_id"><code>Mongo.ObjectID</code></a> values</li> </ul> <p>The default id generation technique is <code>'STRING'</code>.</p> </dd> <dt> <code>transform</code> <span class="type">Function</span> </dt> <dd> <p>An optional transformation function. Documents will be passed through this function before being returned from <code>fetch</code> or <code>findOne</code>, and before being passed to callbacks of <code>observe</code>, <code>map</code>, <code>forEach</code>, <code>allow</code>, and <code>deny</code>. Transforms are <em>not</em> applied for the callbacks of <code>observeChanges</code> or to cursors returned from publish functions.</p> </dd> <dt> <code>defineMutationMethods</code> <span class="type">Boolean</span> </dt> <dd> <p>Set to <code>false</code> to skip setting up the mutation methods that enable insert/update/remove from client code. Default <code>true</code>.</p> </dd> </dl>   <p>Calling this function is analogous to declaring a model in a traditional ORM (Object-Relation Mapper)-centric framework. It sets up a <em>collection</em> (a storage space for records, or “documents”) that can be used to store a particular type of information, like users, posts, scores, todo items, or whatever matters to your application. Each document is a EJSON object. It includes an <code>_id</code> property whose value is unique in the collection, which Meteor will set when you first create the document.</p> <pre class="highlight js" data-language="js">// Common code on client and server declares a DDP-managed Mongo collection.

const Chatrooms = new Mongo.Collection('chatrooms');

const Messages = new Mongo.Collection('messages');</pre> <p>The function returns an object with methods to <a href="#insert"><code>insert</code></a> documents in the collection, <a href="#update"><code>update</code></a> their properties, and <a href="#remove"><code>remove</code></a> them, and to <a href="#find"><code>find</code></a> the documents in the collection that match arbitrary criteria. The way these methods work is compatible with the popular Mongo database API. The same database API works on both the client and the server (see below).</p> <pre class="highlight js" data-language="js">// Return an array of my messages.

const myMessages = Messages.find({ userId: Meteor.userId() }).fetch();

// Create a new message.
Messages.insert({ text: 'Hello, world!' });

// Mark my first message as important.
Messages.update(myMessages[0]._id, { $set: { important: true } });</pre> <p>If you pass a <code>name</code> when you create the collection, then you are declaring a persistent collection — one that is stored on the server and seen by all users. Client code and server code can both access the same collection using the same API.</p> <p>Specifically, when you pass a <code>name</code>, here’s what happens:</p> <ul> <li>
<p>On the server (if you do not specify a <code>connection</code>), a collection with that name is created on a backend Mongo server. When you call methods on that collection on the server, they translate directly into normal Mongo operations (after checking that they match your <a href="#allow">access control rules</a>).</p> </li> <li>
<p>On the client (and on the server if you specify a <code>connection</code>), a Minimongo instance is created. Minimongo is essentially an in-memory, non-persistent implementation of Mongo in pure JavaScript. It serves as a local cache that stores just the subset of the database that this client is working with. Queries (<a href="#find"><code>find</code></a>) on these collections are served directly out of this cache, without talking to the server.</p> </li> <li>
<p>When you write to the database on the client (<a href="#insert"><code>insert</code></a>, <a href="#update"><code>update</code></a>, <a href="#remove"><code>remove</code></a>), the command is executed locally immediately, and, simultaneously, it’s sent to the server and executed there too. This happens via <a href="#meteor_methods">stubs</a>, because writes are implemented as methods.</p> </li> </ul> <blockquote> <p>When, on the server, you write to a collection which has a specified <code>connection</code> to another server, it sends the corresponding method to the other server and receives the changed values back from it over DDP. Unlike on the client, it does not execute the write locally first.</p> </blockquote> <p>If you pass <code>null</code> as the <code>name</code>, then you’re creating a local collection. It’s not synchronized anywhere; it’s just a local scratchpad that supports Mongo-style <a href="#find"><code>find</code></a>, <a href="#insert"><code>insert</code></a>, <a href="#update"><code>update</code></a>, and <a href="#remove"><code>remove</code></a> operations. (On both the client and the server, this scratchpad is implemented using Minimongo.)</p> <p>By default, Meteor automatically publishes every document in your collection to each connected client. To turn this behavior off, remove the <code>autopublish</code> package, in your terminal:</p> <pre class="highlight bash" data-language="bash">meteor remove autopublish</pre> <p>and instead call <a href="#meteor_publish"><code>Meteor.publish</code></a> to specify which parts of your collection should be published to which users.</p> <pre class="highlight js" data-language="js">// Create a collection called `Posts` and put a document in it. The document
// will be immediately visible in the local copy of the collection. It will be
// written to the server-side database a fraction of a second later, and a
// fraction of a second after that, it will be synchronized down to any other
// clients that are subscribed to a query that includes it (see
// `Meteor.subscribe` and `autopublish`).

const Posts = new Mongo.Collection('posts');
Posts.insert({ title: 'Hello world', body: 'First post' });

// Changes are visible immediately—no waiting for a round trip to the server.
assert(Posts.find().count() === 1);

// Create a temporary, local collection. It works just like any other collection
// but it doesn't send changes to the server, and it can't receive any data from
// subscriptions.

const Scratchpad = new Mongo.Collection;


for (let i = 0; i &lt; 10; i += 1) {
  Scratchpad.insert({ number: i * 2 });
}

assert(Scratchpad.find({ number: { $lt: 9 } }).count() === 5);</pre> <p>Generally, you’ll assign <code>Mongo.Collection</code> objects in your app to global variables. You can only create one <code>Mongo.Collection</code> object for each underlying Mongo collection.</p> <p>If you specify a <code>transform</code> option to the <code>Collection</code> or any of its retrieval methods, documents are passed through the <code>transform</code> function before being returned or passed to callbacks. This allows you to add methods or otherwise modify the contents of your collection from their database representation. You can also specify <code>transform</code> on a particular <code>find</code>, <code>findOne</code>, <code>allow</code>, or <code>deny</code> call. Transform functions must return an object and they may not change the value of the document’s <code>_id</code> field (though it’s OK to leave it out).</p> <pre class="highlight js" data-language="js">// An animal class that takes a document in its constructor.

class Animal {
  constructor(doc) {
    _.extend(this, doc);
  }

  makeNoise() {
    console.log(this.sound);
  }
}

// Define a collection that uses `Animal` as its document.

const Animals = new Mongo.Collection('animals', {
  transform: (doc) =&gt; new Animal(doc)
});

// Create an animal and call its `makeNoise` method.
Animals.insert({ name: 'raptor', sound: 'roar' });
Animals.findOne({ name: 'raptor' }).makeNoise(); // Prints 'roar'
</pre> <p><code>transform</code> functions are not called reactively. If you want to add a dynamically changing attribute to an object, do it with a function that computes the value at the time it’s called, not by computing the attribute at <code>transform</code> time.</p> <blockquote class="pullquote warning">
<p>In this release, Minimongo has some limitations:</p> <ul> <li>
<code>$pull</code> in modifiers can only accept certain kinds of selectors.</li> <li>
<code>findAndModify</code>, aggregate functions, and map/reduce aren’t supported.</li> </ul> <p>All of these will be addressed in a future release. For full Minimongo release notes, see packages/minimongo/NOTES in the repository.</p> </blockquote> <blockquote class="pullquote warning">
<p>Minimongo doesn’t currently have indexes. It’s rare for this to be an issue, since it’s unusual for a client to have enough data that an index is worthwhile.</p> </blockquote> <p>Read more about collections and how to use them in the <a href="http://guide.meteor.com/collections.html" target="_blank" rel="external">Collections</a> article in the Meteor Guide.</p>  <h3 class="api-heading" id="Mongo-Collection-find"> <div class="locus"> Anywhere </div> <code>Mongo.Collection#find([selector], [options])</code> <div class="subtext-api"> <a class="src-code link secondary" href="https://github.com/meteor/meteor/blob/master/packages/mongo/collection.js#L285" target="_blank"> (mongo/collection.js, line 285) </a> </div> </h3>   <p>Find the documents in a collection that match the selector.</p>  <h4 class="subheading">Arguments</h4> <dl class="args"> <dt> <code>selector</code> <span class="type"><a href="#selectors">Mongo Selector</a>, <a href="#mongo_object_id">Object ID</a>, or String</span> </dt> <dd> <p>A query describing the documents to find</p> </dd> </dl> <h4 class="subheading">Options</h4> <dl class="args"> <dt> <code>sort</code> <span class="type"><a href="#sortspecifiers">Mongo Sort Specifier</a></span> </dt> <dd> <p>Sort order (default: natural order)</p> </dd> <dt> <code>skip</code> <span class="type">Number</span> </dt> <dd> <p>Number of results to skip at the beginning</p> </dd> <dt> <code>limit</code> <span class="type">Number</span> </dt> <dd> <p>Maximum number of results to return</p> </dd> <dt> <code>fields</code> <span class="type"><a href="#fieldspecifiers">Mongo Field Specifier</a></span> </dt> <dd> <p>Dictionary of fields to return or exclude.</p> </dd> <dt> <code>reactive</code> <span class="type">Boolean</span> </dt> <dd> <p>(Client only) Default <code>true</code>; pass <code>false</code> to disable reactivity</p> </dd> <dt> <code>transform</code> <span class="type">Function</span> </dt> <dd> <p>Overrides <code>transform</code> on the <a href="#collections"><code>Collection</code></a> for this cursor. Pass <code>null</code> to disable transformation.</p> </dd> <dt> <code>disableOplog</code> <span class="type">Boolean</span> </dt> <dd> <p>(Server only) Pass true to disable oplog-tailing on this query. This affects the way server processes calls to <code>observe</code> on this query. Disabling the oplog can be useful when working with data that updates in large batches.</p> </dd> <dt> <code>pollingIntervalMs</code> <span class="type">Number</span> </dt> <dd> <p>(Server only) When oplog is disabled (through the use of <code>disableOplog</code> or when otherwise not available), the frequency (in milliseconds) of how often to poll this query when observing on the server. Defaults to 10000ms (10 seconds).</p> </dd> <dt> <code>pollingThrottleMs</code> <span class="type">Number</span> </dt> <dd> <p>(Server only) When oplog is disabled (through the use of <code>disableOplog</code> or when otherwise not available), the minimum time (in milliseconds) to allow between re-polling when observing on the server. Increasing this will save CPU and mongo load at the expense of slower updates to users. Decreasing this is not recommended. Defaults to 50ms.</p> </dd> <dt> <code>maxTimeMs</code> <span class="type">Number</span> </dt> <dd> <p>(Server only) If set, instructs MongoDB to set a time limit for this cursor's operations. If the operation reaches the specified time limit (in milliseconds) without the having been completed, an exception will be thrown. Useful to prevent an (accidental or malicious) unoptimized query from causing a full collection scan that would disrupt other database users, at the expense of needing to handle the resulting error.</p> </dd> <dt> <code>hint</code> <span class="type">String or Object</span> </dt> <dd> <p>(Server only) Overrides MongoDB's default index selection and query optimization process. Specify an index to force its use, either by its name or index specification. You can also specify <code>{ $natural : 1 }</code> to force a forwards collection scan, or <code>{ $natural : -1 }</code> for a reverse collection scan. Setting this is only recommended for advanced users.</p> </dd> </dl>   <p><code>find</code> returns a cursor. It does not immediately access the database or return documents. Cursors provide <code>fetch</code> to return all matching documents, <code>map</code> and <code>forEach</code> to iterate over all matching documents, and <code>observe</code> and <code>observeChanges</code> to register callbacks when the set of matching documents changes.</p> <blockquote class="pullquote warning">
<p>Collection cursors are not query snapshots. If the database changes between calling <code>Collection.find</code> and fetching the results of the cursor, or while fetching results from the cursor, those changes may or may not appear in the result set.</p> </blockquote> <p>Cursors are a reactive data source. On the client, the first time you retrieve a cursor’s documents with <code>fetch</code>, <code>map</code>, or <code>forEach</code> inside a reactive computation (eg, a template or <a href="#tracker_autorun"><code>autorun</code></a>), Meteor will register a dependency on the underlying data. Any change to the collection that changes the documents in a cursor will trigger a recomputation. To disable this behavior, pass <code>{reactive: false}</code> as an option to <code>find</code>.</p> <p>Note that when <code>fields</code> are specified, only changes to the included fields will trigger callbacks in <code>observe</code>, <code>observeChanges</code> and invalidations in reactive computations using this cursor. Careful use of <code>fields</code> allows for more fine-grained reactivity for computations that don’t depend on an entire document.</p> <p>On the client, there will be a period of time between when the page loads and when the published data arrives from the server during which your client-side collections will be empty.</p>  <h3 class="api-heading" id="Mongo-Collection-findOne"> <div class="locus"> Anywhere </div> <code>Mongo.Collection#findOne([selector], [options])</code> <div class="subtext-api"> <a class="src-code link secondary" href="https://github.com/meteor/meteor/blob/master/packages/mongo/collection.js#L316" target="_blank"> (mongo/collection.js, line 316) </a> </div> </h3>   <p>Finds the first document that matches the selector, as ordered by sort and skip options. Returns <code>undefined</code> if no matching document is found.</p>  <h4 class="subheading">Arguments</h4> <dl class="args"> <dt> <code>selector</code> <span class="type"><a href="#selectors">Mongo Selector</a>, <a href="#mongo_object_id">Object ID</a>, or String</span> </dt> <dd> <p>A query describing the documents to find</p> </dd> </dl> <h4 class="subheading">Options</h4> <dl class="args"> <dt> <code>sort</code> <span class="type"><a href="#sortspecifiers">Mongo Sort Specifier</a></span> </dt> <dd> <p>Sort order (default: natural order)</p> </dd> <dt> <code>skip</code> <span class="type">Number</span> </dt> <dd> <p>Number of results to skip at the beginning</p> </dd> <dt> <code>fields</code> <span class="type"><a href="#fieldspecifiers">Mongo Field Specifier</a></span> </dt> <dd> <p>Dictionary of fields to return or exclude.</p> </dd> <dt> <code>reactive</code> <span class="type">Boolean</span> </dt> <dd> <p>(Client only) Default true; pass false to disable reactivity</p> </dd> <dt> <code>transform</code> <span class="type">Function</span> </dt> <dd> <p>Overrides <code>transform</code> on the <a href="#collections"><code>Collection</code></a> for this cursor. Pass <code>null</code> to disable transformation.</p> </dd> </dl>   <p>Equivalent to <a href="#find"><code>find</code></a><code>(selector, options).</code><a href="#fetch"><code>fetch</code></a><code>()[0]</code> with <code>options.limit = 1</code>.</p>  <h3 class="api-heading" id="Mongo-Collection-insert"> <div class="locus"> Anywhere </div> <code>Mongo.Collection#insert(doc, [callback])</code> <div class="subtext-api"> <a class="src-code link secondary" href="https://github.com/meteor/meteor/blob/master/packages/mongo/collection.js#L417" target="_blank"> (mongo/collection.js, line 417) </a> </div> </h3>   <p>Insert a document in the collection. Returns its unique _id.</p>  <h4 class="subheading">Arguments</h4> <dl class="args"> <dt> <code>doc</code> <span class="type">Object</span> </dt> <dd> <p>The document to insert. May not yet have an _id attribute, in which case Meteor will generate one for you.</p> </dd> <dt> <code>callback</code> <span class="type">Function</span> </dt> <dd> <p>Optional. If present, called with an error object as the first argument and, if no error, the _id as the second.</p> </dd> </dl>   <p>Add a document to the collection. A document is just an object, and its fields can contain any combination of EJSON-compatible datatypes (arrays, objects, numbers, strings, <code>null</code>, true, and false).</p> <p><code>insert</code> will generate a unique ID for the object you pass, insert it in the database, and return the ID. When <code>insert</code> is called from untrusted client code, it will be allowed only if passes any applicable <a href="#allow"><code>allow</code></a> and <a href="#deny"><code>deny</code></a> rules.</p> <p>On the server, if you don’t provide a callback, then <code>insert</code> blocks until the database acknowledges the write, or throws an exception if something went wrong. If you do provide a callback, <code>insert</code> still returns the ID immediately. Once the insert completes (or fails), the callback is called with error and result arguments. In an error case, <code>result</code> is undefined. If the insert is successful, <code>error</code> is undefined and <code>result</code> is the new document ID.</p> <p>On the client, <code>insert</code> never blocks. If you do not provide a callback and the insert fails on the server, then Meteor will log a warning to the console. If you provide a callback, Meteor will call that function with <code>error</code> and <code>result</code> arguments. In an error case, <code>result</code> is undefined. If the insert is successful, <code>error</code> is undefined and <code>result</code> is the new document ID.</p> <p>Example:</p> <pre class="highlight js" data-language="js">
const groceriesId = Lists.insert({ name: 'Groceries' });

Items.insert({ list: groceriesId, name: 'Watercress' });
Items.insert({ list: groceriesId, name: 'Persimmons' });</pre>  <h3 class="api-heading" id="Mongo-Collection-update"> <div class="locus"> Anywhere </div> <code>Mongo.Collection#update(selector, modifier, [options], [callback])</code> <div class="subtext-api"> <a class="src-code link secondary" href="https://github.com/meteor/meteor/blob/master/packages/mongo/collection.js#L496" target="_blank"> (mongo/collection.js, line 496) </a> </div> </h3>   <p>Modify one or more documents in the collection. Returns the number of matched documents.</p>  <h4 class="subheading">Arguments</h4> <dl class="args"> <dt> <code>selector</code> <span class="type"><a href="#selectors">Mongo Selector</a>, <a href="#mongo_object_id">Object ID</a>, or String</span> </dt> <dd> <p>Specifies which documents to modify</p> </dd> <dt> <code>modifier</code> <span class="type"><a href="#modifiers">Mongo Modifier</a></span> </dt> <dd> <p>Specifies how to modify the documents</p> </dd> <dt> <code>callback</code> <span class="type">Function</span> </dt> <dd> <p>Optional. If present, called with an error object as the first argument and, if no error, the number of affected documents as the second.</p> </dd> </dl> <h4 class="subheading">Options</h4> <dl class="args"> <dt> <code>multi</code> <span class="type">Boolean</span> </dt> <dd> <p>True to modify all matching documents; false to only modify one of the matching documents (the default).</p> </dd> <dt> <code>upsert</code> <span class="type">Boolean</span> </dt> <dd> <p>True to insert a document if no matching documents are found.</p> </dd> </dl>   <p>Modify documents that match <code>selector</code> according to <code>modifier</code> (see <a href="#modifiers">modifier documentation</a>).</p> <p>The behavior of <code>update</code> differs depending on whether it is called by trusted or untrusted code. Trusted code includes server code and method code. Untrusted code includes client-side code such as event handlers and a browser’s JavaScript console.</p> <ul> <li>
<p>Trusted code can modify multiple documents at once by setting <code>multi</code> to true, and can use an arbitrary <a href="#selectors">Mongo selector</a> to find the documents to modify. It bypasses any access control rules set up by <a href="#allow"><code>allow</code></a> and <a href="#deny"><code>deny</code></a>. The number of affected documents will be returned from the <code>update</code> call if you don’t pass a callback.</p> </li> <li>
<p>Untrusted code can only modify a single document at once, specified by its <code>_id</code>. The modification is allowed only after checking any applicable <a href="#allow"><code>allow</code></a> and <a href="#deny"><code>deny</code></a> rules. The number of affected documents will be returned to the callback. Untrusted code cannot perform upserts, except in insecure mode.</p> </li> </ul> <p>On the server, if you don’t provide a callback, then <code>update</code> blocks until the database acknowledges the write, or throws an exception if something went wrong. If you do provide a callback, <code>update</code> returns immediately. Once the update completes, the callback is called with a single error argument in the case of failure, or a second argument indicating the number of affected documents if the update was successful.</p> <p>On the client, <code>update</code> never blocks. If you do not provide a callback and the update fails on the server, then Meteor will log a warning to the console. If you provide a callback, Meteor will call that function with an error argument if there was an error, or a second argument indicating the number of affected documents if the update was successful.</p> <p>Client example:</p> <pre class="highlight js" data-language="js">// When the 'give points' button in the admin dashboard is pressed, give 5
// points to the current player. The new score will be immediately visible on
// everyone's screens.
Template.adminDashboard.events({
  'click .give-points'() {
    Players.update(Session.get('currentPlayer'), {
      $inc: { score: 5 }
    });
  }
});</pre> <p>Server example:</p> <pre class="highlight js" data-language="js">// Give the 'Winner' badge to each user with a score greater than 10. If they
// are logged in and their badge list is visible on the screen, it will update
// automatically as they watch.
Meteor.methods({
  declareWinners() {
    Players.update({ score: { $gt: 10 } }, {
      $addToSet: { badges: 'Winner' }
    }, { multi: true });
  }
});</pre> <p>You can use <code>update</code> to perform a Mongo upsert by setting the <code>upsert</code> option to true. You can also use the <a href="#upsert"><code>upsert</code></a> method to perform an upsert that returns the <code>_id</code> of the document that was inserted (if there was one) in addition to the number of affected documents.</p>  <h3 class="api-heading" id="Mongo-Collection-upsert"> <div class="locus"> Anywhere </div> <code>Mongo.Collection#upsert(selector, modifier, [options], [callback])</code> <div class="subtext-api"> <a class="src-code link secondary" href="https://github.com/meteor/meteor/blob/master/packages/mongo/collection.js#L625" target="_blank"> (mongo/collection.js, line 625) </a> </div> </h3>   <p>Modify one or more documents in the collection, or insert one if no matching documents were found. Returns an object with keys <code>numberAffected</code> (the number of documents modified) and <code>insertedId</code> (the unique _id of the document that was inserted, if any).</p>  <h4 class="subheading">Arguments</h4> <dl class="args"> <dt> <code>selector</code> <span class="type"><a href="#selectors">Mongo Selector</a>, <a href="#mongo_object_id">Object ID</a>, or String</span> </dt> <dd> <p>Specifies which documents to modify</p> </dd> <dt> <code>modifier</code> <span class="type"><a href="#modifiers">Mongo Modifier</a></span> </dt> <dd> <p>Specifies how to modify the documents</p> </dd> <dt> <code>callback</code> <span class="type">Function</span> </dt> <dd> <p>Optional. If present, called with an error object as the first argument and, if no error, the number of affected documents as the second.</p> </dd> </dl> <h4 class="subheading">Options</h4> <dl class="args"> <dt> <code>multi</code> <span class="type">Boolean</span> </dt> <dd> <p>True to modify all matching documents; false to only modify one of the matching documents (the default).</p> </dd> </dl>   <p>Modify documents that match <code>selector</code> according to <code>modifier</code>, or insert a document if no documents were modified. <code>upsert</code> is the same as calling <code>update</code> with the <code>upsert</code> option set to true, except that the return value of <code>upsert</code> is an object that contain the keys <code>numberAffected</code> and <code>insertedId</code>. (<code>update</code> returns only the number of affected documents.)</p>  <h3 class="api-heading" id="Mongo-Collection-remove"> <div class="locus"> Anywhere </div> <code>Mongo.Collection#remove(selector, [callback])</code> <div class="subtext-api"> <a class="src-code link secondary" href="https://github.com/meteor/meteor/blob/master/packages/mongo/collection.js#L561" target="_blank"> (mongo/collection.js, line 561) </a> </div> </h3>   <p>Remove documents from the collection</p>  <h4 class="subheading">Arguments</h4> <dl class="args"> <dt> <code>selector</code> <span class="type"><a href="#selectors">Mongo Selector</a>, <a href="#mongo_object_id">Object ID</a>, or String</span> </dt> <dd> <p>Specifies which documents to remove</p> </dd> <dt> <code>callback</code> <span class="type">Function</span> </dt> <dd> <p>Optional. If present, called with an error object as its argument.</p> </dd> </dl>   <p>Find all of the documents that match <code>selector</code> and delete them from the collection.</p> <p>The behavior of <code>remove</code> differs depending on whether it is called by trusted or untrusted code. Trusted code includes server code and method code. Untrusted code includes client-side code such as event handlers and a browser’s JavaScript console.</p> <ul> <li>
<p>Trusted code can use an arbitrary <a href="#selectors">Mongo selector</a> to find the documents to remove, and can remove more than one document at once by passing a selector that matches multiple documents. It bypasses any access control rules set up by <a href="#allow"><code>allow</code></a> and <a href="#deny"><code>deny</code></a>. The number of removed documents will be returned from <code>remove</code> if you don’t pass a callback.</p> <p>As a safety measure, if <code>selector</code> is omitted (or is <code>undefined</code>), no documents will be removed. Set <code>selector</code> to <code>{}</code> if you really want to remove all documents from your collection.</p> </li> <li>
<p>Untrusted code can only remove a single document at a time, specified by its <code>_id</code>. The document is removed only after checking any applicable <a href="#allow"><code>allow</code></a> and <a href="#deny"><code>deny</code></a> rules. The number of removed documents will be returned to the callback.</p> </li> </ul> <p>On the server, if you don’t provide a callback, then <code>remove</code> blocks until the database acknowledges the write and then returns the number of removed documents, or throws an exception if something went wrong. If you do provide a callback, <code>remove</code> returns immediately. Once the remove completes, the callback is called with a single error argument in the case of failure, or a second argument indicating the number of removed documents if the remove was successful.</p> <p>On the client, <code>remove</code> never blocks. If you do not provide a callback and the remove fails on the server, then Meteor will log a warning to the console. If you provide a callback, Meteor will call that function with an error argument if there was an error, or a second argument indicating the number of removed documents if the remove was successful.</p> <p>Example (client):</p> <pre class="highlight js" data-language="js">// When the 'remove' button is clicked on a chat message, delete that message.
Template.chat.events({
  'click .remove'() {
    Messages.remove(this._id);
  }
});</pre> <p>Example (server):</p> <pre class="highlight js" data-language="js">// When the server starts, clear the log and delete all players with a karma of
// less than -2.
Meteor.startup(() =&gt; {
  if (Meteor.isServer) {
    Logs.remove({});
    Players.remove({ karma: { $lt: -2 } });
  }
});</pre>  <h3 class="api-heading" id="Mongo-Collection-allow"> <div class="locus"> Server </div> <code>Mongo.Collection#allow(options)</code> <div class="subtext-api"> <a class="src-code link secondary" href="https://github.com/meteor/meteor/blob/master/packages/allow-deny/allow-deny.js#L45" target="_blank"> (allow-deny/allow-deny.js, line 45) </a> </div> </h3>   <p>Allow users to write directly to this collection from client code, subject to limitations you define.</p>  <h4 class="subheading">Options</h4> <dl class="args"> <dt> <code>insert, update, remove</code> <span class="type">Function</span> </dt> <dd> <p>Functions that look at a proposed modification to the database and return true if it should be allowed.</p> </dd> <dt> <code>fetch</code> <span class="type">Array of Strings</span> </dt> <dd> <p>Optional performance enhancement. Limits the fields that will be fetched from the database for inspection by your <code>update</code> and <code>remove</code> functions.</p> </dd> <dt> <code>transform</code> <span class="type">Function</span> </dt> <dd> <p>Overrides <code>transform</code> on the <a href="#collections"><code>Collection</code></a>. Pass <code>null</code> to disable transformation.</p> </dd> </dl>   <blockquote class="pullquote warning">
<p>While <code>allow</code> and <code>deny</code> make it easy to get started building an app, it’s harder than it seems to write secure <code>allow</code> and <code>deny</code> rules. We recommend that developers avoid <code>allow</code> and <code>deny</code>, and switch directly to custom methods once they are ready to remove <code>insecure</code> mode from their app. See <a href="https://guide.meteor.com/security.html#allow-deny" target="_blank" rel="external">the Meteor Guide on security</a> for more details.</p> </blockquote> <p>When a client calls <code>insert</code>, <code>update</code>, or <code>remove</code> on a collection, the collection’s <code>allow</code> and <a href="#deny"><code>deny</code></a> callbacks are called on the server to determine if the write should be allowed. If at least one <code>allow</code> callback allows the write, and no <code>deny</code> callbacks deny the write, then the write is allowed to proceed.</p> <p>These checks are run only when a client tries to write to the database directly, for example by calling <code>update</code> from inside an event handler. Server code is trusted and isn’t subject to <code>allow</code> and <code>deny</code> restrictions. That includes methods that are called with <code>Meteor.call</code> — they are expected to do their own access checking rather than relying on <code>allow</code> and <code>deny</code>.</p> <p>You can call <code>allow</code> as many times as you like, and each call can include any combination of <code>insert</code>, <code>update</code>, and <code>remove</code> functions. The functions should return <code>true</code> if they think the operation should be allowed. Otherwise they should return <code>false</code>, or nothing at all (<code>undefined</code>). In that case Meteor will continue searching through any other <code>allow</code> rules on the collection.</p> <p>The available callbacks are:</p> <dl class="callbacks"> <dt><span class="name">insert(userId, doc)</span></dt>
<dd>
<p>The user <code>userId</code> wants to insert the document <code>doc</code> into the collection. Return <code>true</code> if this should be allowed.</p> <p><code>doc</code> will contain the <code>_id</code> field if one was explicitly set by the client, or if there is an active <code>transform</code>. You can use this to prevent users from specifying arbitrary <code>_id</code> fields.</p> </dd> <dt><span class="name">update(userId, doc, fieldNames, modifier)</span></dt>
<dd>
<p>The user <code>userId</code> wants to update a document <code>doc</code>. (<code>doc</code> is the current version of the document from the database, without the proposed update.) Return <code>true</code> to permit the change.</p> <p><code>fieldNames</code> is an array of the (top-level) fields in <code>doc</code> that the client wants to modify, for example <code>['name', 'score']</code>.</p> <p><code>modifier</code> is the raw Mongo modifier that the client wants to execute; for example, <code>{ $set: { 'name.first': 'Alice' }, $inc: { score: 1 } }</code>.</p> <p>Only Mongo modifiers are supported (operations like <code>$set</code> and <code>$push</code>). If the user tries to replace the entire document rather than use $-modifiers, the request will be denied without checking the <code>allow</code> functions.</p> </dd> <dt><span class="name">remove(userId, doc)</span></dt>
<dd>
<p>The user <code>userId</code> wants to remove <code>doc</code> from the database. Return <code>true</code> to permit this.</p> </dd> </dl> <p>When calling <code>update</code> or <code>remove</code> Meteor will by default fetch the entire document <code>doc</code> from the database. If you have large documents you may wish to fetch only the fields that are actually used by your functions. Accomplish this by setting <code>fetch</code> to an array of field names to retrieve.</p> <p>Example:</p> <pre class="highlight js" data-language="js">// Create a collection where users can only modify documents that they own.
// Ownership is tracked by an `owner` field on each document. All documents must
// be owned by the user that created them and ownership can't be changed. Only a
// document's owner is allowed to delete it, and the `locked` attribute can be
// set on a document to prevent its accidental deletion.

const Posts = new Mongo.Collection('posts');

Posts.allow({
  insert(userId, doc) {
    // The user must be logged in and the document must be owned by the user.

    return userId &amp;&amp; doc.owner === userId;
  },

  update(userId, doc, fields, modifier) {
    // Can only change your own documents.

    return doc.owner === userId;
  },

  remove(userId, doc) {
    // Can only remove your own documents.

    return doc.owner === userId;
  },

  fetch: ['owner']
});

Posts.deny({
  update(userId, doc, fields, modifier) {
    // Can't change owners.

    return _.contains(fields, 'owner');
  },

  remove(userId, doc) {
    // Can't remove locked documents.

    return doc.locked;
  },

  fetch: ['locked'] // No need to fetch `owner`

});</pre> <p>If you never set up any <code>allow</code> rules on a collection then all client writes to the collection will be denied, and it will only be possible to write to the collection from server-side code. In this case you will have to create a method for each possible write that clients are allowed to do. You’ll then call these methods with <code>Meteor.call</code> rather than having the clients call <code>insert</code>, <code>update</code>, and <code>remove</code> directly on the collection.</p> <p>Meteor also has a special “insecure mode” for quickly prototyping new applications. In insecure mode, if you haven’t set up any <code>allow</code> or <code>deny</code> rules on a collection, then all users have full write access to the collection. This is the only effect of insecure mode. If you call <code>allow</code> or <code>deny</code> at all on a collection, even <code>Posts.allow({})</code>, then access is checked just like normal on that collection. <strong>New Meteor projects start in insecure mode by default.</strong> To turn it off just run in your terminal:</p> <pre class="highlight bash" data-language="bash">meteor remove insecure</pre>  <h3 class="api-heading" id="Mongo-Collection-deny"> <div class="locus"> Server </div> <code>Mongo.Collection#deny(options)</code> <div class="subtext-api"> <a class="src-code link secondary" href="https://github.com/meteor/meteor/blob/master/packages/allow-deny/allow-deny.js#L60" target="_blank"> (allow-deny/allow-deny.js, line 60) </a> </div> </h3>   <p>Override <code>allow</code> rules.</p>  <h4 class="subheading">Options</h4> <dl class="args"> <dt> <code>insert, update, remove</code> <span class="type">Function</span> </dt> <dd> <p>Functions that look at a proposed modification to the database and return true if it should be denied, even if an <a href="#allow">allow</a> rule says otherwise.</p> </dd> <dt> <code>fetch</code> <span class="type">Array of Strings</span> </dt> <dd> <p>Optional performance enhancement. Limits the fields that will be fetched from the database for inspection by your <code>update</code> and <code>remove</code> functions.</p> </dd> <dt> <code>transform</code> <span class="type">Function</span> </dt> <dd> <p>Overrides <code>transform</code> on the <a href="#collections"><code>Collection</code></a>. Pass <code>null</code> to disable transformation.</p> </dd> </dl>   <blockquote class="pullquote warning">
<p>While <code>allow</code> and <code>deny</code> make it easy to get started building an app, it’s harder than it seems to write secure <code>allow</code> and <code>deny</code> rules. We recommend that developers avoid <code>allow</code> and <code>deny</code>, and switch directly to custom methods once they are ready to remove <code>insecure</code> mode from their app. See <a href="https://guide.meteor.com/security.html#allow-deny" target="_blank" rel="external">the Meteor Guide on security</a> for more details.</p> </blockquote> <p>This works just like <a href="#allow"><code>allow</code></a>, except it lets you make sure that certain writes are definitely denied, even if there is an <code>allow</code> rule that says that they should be permitted.</p> <p>When a client tries to write to a collection, the Meteor server first checks the collection’s <code>deny</code> rules. If none of them return true then it checks the collection’s <code>allow</code> rules. Meteor allows the write only if no <code>deny</code> rules return <code>true</code> and at least one <code>allow</code> rule returns <code>true</code>.</p>  <h3 class="api-heading" id="Mongo-Collection-rawCollection"> <div class="locus"> Server </div> <code>Mongo.Collection#rawCollection()</code> <div class="subtext-api"> <a class="src-code link secondary" href="https://github.com/meteor/meteor/blob/master/packages/mongo/collection.js#L671" target="_blank"> (mongo/collection.js, line 671) </a> </div> </h3>   <p>Returns the <a href="http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html" target="_blank" rel="external"><code>Collection</code></a> object corresponding to this collection from the <a href="https://www.npmjs.com/package/mongodb" target="_blank" rel="external">npm <code>mongodb</code> driver module</a> which is wrapped by <code>Mongo.Collection</code>.</p>     <h3 class="api-heading" id="Mongo-Collection-rawDatabase"> <div class="locus"> Server </div> <code>Mongo.Collection#rawDatabase()</code> <div class="subtext-api"> <a class="src-code link secondary" href="https://github.com/meteor/meteor/blob/master/packages/mongo/collection.js#L683" target="_blank"> (mongo/collection.js, line 683) </a> </div> </h3>   <p>Returns the <a href="http://mongodb.github.io/node-mongodb-native/2.2/api/Db.html" target="_blank" rel="external"><code>Db</code></a> object corresponding to this collection's database connection from the <a href="https://www.npmjs.com/package/mongodb" target="_blank" rel="external">npm <code>mongodb</code> driver module</a> which is wrapped by <code>Mongo.Collection</code>.</p>    <h2 id="mongo_cursor">Cursors</h2> <p>To create a cursor, use <a href="#find"><code>find</code></a>. To access the documents in a cursor, use <a href="#foreach"><code>forEach</code></a>, <a href="#map"><code>map</code></a>, or <a href="#fetch"><code>fetch</code></a>.</p>  <h3 class="api-heading" id="Mongo-Cursor-forEach"> <div class="locus"> Anywhere </div> <code>Mongo.Cursor#forEach(callback, [thisArg])</code> <div class="subtext-api"> <a class="src-code link secondary" href="https://github.com/meteor/meteor/blob/master/packages/minimongo/cursor.js#L112" target="_blank"> (minimongo/cursor.js, line 112) </a> </div> </h3>   <p>Call <code>callback</code> once for each matching document, sequentially and synchronously.</p>  <h4 class="subheading">Arguments</h4> <dl class="args"> <dt> <code>callback</code> <span class="type">Function</span> </dt> <dd> <p>Function to call. It will be called with three arguments: the document, a 0-based index, and <em>cursor</em> itself.</p> </dd> <dt> <code>thisArg</code> <span class="type">Any</span> </dt> <dd> <p>An object which will be the value of <code>this</code> inside <code>callback</code>.</p> </dd> </dl>   <p>This interface is compatible with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" target="_blank" rel="external">Array.forEach</a>.</p> <p>When called from a reactive computation, <code>forEach</code> registers dependencies on the matching documents.</p> <p>Examples:</p> <pre class="highlight js" data-language="js">// Print the titles of the five top-scoring posts.

const topPosts = Posts.find({}, { sort: { score: -1 }, limit: 5 });

let count = 0;

topPosts.forEach((post) =&gt; {
  console.log(`Title of post ${count}: ${post.title}`);
  count += 1;
});</pre>  <h3 class="api-heading" id="Mongo-Cursor-map"> <div class="locus"> Anywhere </div> <code>Mongo.Cursor#map(callback, [thisArg])</code> <div class="subtext-api"> <a class="src-code link secondary" href="https://github.com/meteor/meteor/blob/master/packages/minimongo/cursor.js#L151" target="_blank"> (minimongo/cursor.js, line 151) </a> </div> </h3>   <p>Map callback over all matching documents. Returns an Array.</p>  <h4 class="subheading">Arguments</h4> <dl class="args"> <dt> <code>callback</code> <span class="type">Function</span> </dt> <dd> <p>Function to call. It will be called with three arguments: the document, a 0-based index, and <em>cursor</em> itself.</p> </dd> <dt> <code>thisArg</code> <span class="type">Any</span> </dt> <dd> <p>An object which will be the value of <code>this</code> inside <code>callback</code>.</p> </dd> </dl>   <p>This interface is compatible with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="external">Array.map</a>.</p> <p>When called from a reactive computation, <code>map</code> registers dependencies on the matching documents.</p>  <p>On the server, if <code>callback</code> yields, other calls to <code>callback</code> may occur while the first call is waiting. If strict sequential execution is necessary, use <code>forEach</code> instead.</p>  <h3 class="api-heading" id="Mongo-Cursor-fetch"> <div class="locus"> Anywhere </div> <code>Mongo.Cursor#fetch()</code> <div class="subtext-api"> <a class="src-code link secondary" href="https://github.com/meteor/meteor/blob/master/packages/minimongo/cursor.js#L60" target="_blank"> (minimongo/cursor.js, line 60) </a> </div> </h3>   <p>Return all matching documents as an Array.</p>    <p>When called from a reactive computation, <code>fetch</code> registers dependencies on the matching documents.</p>  <h3 class="api-heading" id="Mongo-Cursor-count"> <div class="locus"> Anywhere </div> <code>Mongo.Cursor#count()</code> <div class="subtext-api"> <a class="src-code link secondary" href="https://github.com/meteor/meteor/blob/master/packages/minimongo/cursor.js#L43" target="_blank"> (minimongo/cursor.js, line 43) </a> </div> </h3>   <p>Returns the number of documents that match a query.</p>    <p>Unlike the other functions, <code>count</code> registers a dependency only on the number of matching documents. (Updates that just change or reorder the documents in the result set will not trigger a recomputation.)</p>  <h3 class="api-heading" id="Mongo-Cursor-observe"> <div class="locus"> Anywhere </div> <code>Mongo.Cursor#observe(callbacks)</code> <div class="subtext-api"> <a class="src-code link secondary" href="https://github.com/meteor/meteor/blob/master/packages/minimongo/cursor.js#L203" target="_blank"> (minimongo/cursor.js, line 203) </a> </div> </h3>   <p>Watch a query. Receive callbacks as the result set changes.</p>  <h4 class="subheading">Arguments</h4> <dl class="args"> <dt> <code>callbacks</code> <span class="type">Object</span> </dt> <dd> <p>Functions to call to deliver the result set as it changes</p> </dd> </dl>   <p>Establishes a <em>live query</em> that invokes callbacks when the result of the query changes. The callbacks receive the entire contents of the document that was affected, as well as its old contents, if applicable. If you only need to receive the fields that changed, see <a href="#observe_changes"><code>observeChanges</code></a>.</p> <p><code>callbacks</code> may have the following functions as properties:</p> <dl class="callbacks"> <dt>
<span class="name">added(document)</span> <span class="or">or</span>
</dt> <dt><span class="name">addedAt(document, atIndex, before)</span></dt> <dd> A new document <code>document</code> entered the result set. The new document appears at position <code>atIndex</code>. It is immediately before the document whose <code>_id</code> is <code>before</code>. <code>before</code> will be <code>null</code> if the new document is at the end of the results. </dd> <dt><span class="name">changed(newDocument, oldDocument) <span class="or">or</span></span></dt> <dt><span class="name">changedAt(newDocument, oldDocument, atIndex)</span></dt> <dd> The contents of a document were previously <code>oldDocument</code> and are now <code>newDocument</code>. The position of the changed document is <code>atIndex</code>. </dd> <dt>
<span class="name">removed(oldDocument)</span> <span class="or">or</span>
</dt> <dt><span class="name">removedAt(oldDocument, atIndex)</span></dt> <dd> The document <code>oldDocument</code> is no longer in the result set. It used to be at position <code>atIndex</code>. </dd> <dt><span class="name">movedTo(document, fromIndex, toIndex, before)</span></dt>
<dd>
<p>A document changed its position in the result set, from <code>fromIndex</code> to <code>toIndex</code> (which is before the document with id <code>before</code>). Its current contents is <code>document</code>.</p> </dd> </dl> <p>Use <code>added</code>, <code>changed</code>, and <code>removed</code> when you don’t care about the order of the documents in the result set. They are more efficient than <code>addedAt</code>, <code>changedAt</code>, and <code>removedAt</code>.</p> <p>Before <code>observe</code> returns, <code>added</code> (or <code>addedAt</code>) will be called zero or more times to deliver the initial results of the query.</p> <p><code>observe</code> returns a live query handle, which is an object with a <code>stop</code> method. Call <code>stop</code> with no arguments to stop calling the callback functions and tear down the query. <strong>The query will run forever until you call this.</strong> If <code>observe</code> is called from a <code>Tracker.autorun</code> computation, it is automatically stopped when the computation is rerun or stopped. (If the cursor was created with the option <code>reactive</code> set to false, it will only deliver the initial results and will not call any further callbacks; it is not necessary to call <code>stop</code> on the handle.)</p>  <h3 class="api-heading" id="Mongo-Cursor-observeChanges"> <div class="locus"> Anywhere </div> <code>Mongo.Cursor#observeChanges(callbacks)</code> <div class="subtext-api"> <a class="src-code link secondary" href="https://github.com/meteor/meteor/blob/master/packages/minimongo/cursor.js#L217" target="_blank"> (minimongo/cursor.js, line 217) </a> </div> </h3>   <p>Watch a query. Receive callbacks as the result set changes. Only the differences between the old and new documents are passed to the callbacks.</p>  <h4 class="subheading">Arguments</h4> <dl class="args"> <dt> <code>callbacks</code> <span class="type">Object</span> </dt> <dd> <p>Functions to call to deliver the result set as it changes</p> </dd> </dl>   <p>Establishes a <em>live query</em> that invokes callbacks when the result of the query changes. In contrast to <a href="#observe"><code>observe</code></a>, <code>observeChanges</code> provides only the difference between the old and new result set, not the entire contents of the document that changed.</p> <p><code>callbacks</code> may have the following functions as properties:</p> <dl class="callbacks"> <dt>
<span class="name">added(id, fields)</span> <span class="or">or</span>
</dt> <dt><span class="name">addedBefore(id, fields, before)</span></dt> <dd> A new document entered the result set. It has the <code>id</code> and <code>fields</code> specified. <code>fields</code> contains all fields of the document excluding the <code>_id</code> field. The new document is before the document identified by <code>before</code>, or at the end if <code>before</code> is <code>null</code>. </dd> <dt><span class="name">changed(id, fields)</span></dt>
<dd>
<p>The document identified by <code>id</code> has changed. <code>fields</code> contains the changed fields with their new values. If a field was removed from the document then it will be present in <code>fields</code> with a value of <code>undefined</code>.</p> </dd> <dt><span class="name">movedBefore(id, before)</span></dt>
<dd>
<p>The document identified by <code>id</code> changed its position in the ordered result set, and now appears before the document identified by <code>before</code>.</p> </dd> <dt><span class="name">removed(id)</span></dt>
<dd>
<p>The document identified by <code>id</code> was removed from the result set.</p> </dd> </dl> <p><code>observeChanges</code> is significantly more efficient if you do not use <code>addedBefore</code> or <code>movedBefore</code>.</p> <p>Before <code>observeChanges</code> returns, <code>added</code> (or <code>addedBefore</code>) will be called zero or more times to deliver the initial results of the query.</p> <p><code>observeChanges</code> returns a live query handle, which is an object with a <code>stop</code> method. Call <code>stop</code> with no arguments to stop calling the callback functions and tear down the query. <strong>The query will run forever until you call this.</strong> If <code>observeChanges</code> is called from a <code>Tracker.autorun</code> computation, it is automatically stopped when the computation is rerun or stopped. (If the cursor was created with the option <code>reactive</code> set to false, it will only deliver the initial results and will not call any further callbacks; it is not necessary to call <code>stop</code> on the handle.)</p> <blockquote> <p>Unlike <code>observe</code>, <code>observeChanges</code> does not provide absolute position information (that is, <code>atIndex</code> positions rather than <code>before</code> positions.) This is for efficiency.</p> </blockquote> <p>Example:</p> <pre class="highlight js" data-language="js">// Keep track of how many administrators are online.

let count = 0;

const cursor = Users.find({ admin: true, onlineNow: true });


const handle = cursor.observeChanges({
  added(id, user) {
    count += 1;
    console.log(`${user.name} brings the total to ${count} admins.`);
  },

  removed() {
    count -= 1;
    console.log(`Lost one. We're now down to ${count} admins.`);
  }
});

// After five seconds, stop keeping the count.
setTimeout(() =&gt; handle.stop(), 5000);</pre>  <h2 class="api-heading" id="Mongo-ObjectID"> <div class="locus"> Anywhere </div> <code>new Mongo.ObjectID([hexString])</code> <div class="subtext-api"> <code>import { Mongo } from 'meteor/mongo'</code> <a class="src-code link secondary" href="https://github.com/meteor/meteor/blob/master/packages/mongo/collection.js#L698" target="_blank"> (mongo/collection.js, line 698) </a> </div> </h2>   <p>Create a Mongo-style <code>ObjectID</code>. If you don't specify a <code>hexString</code>, the <code>ObjectID</code> will generated randomly (not using MongoDB's ID construction rules).</p>  <h4 class="subheading">Arguments</h4> <dl class="args"> <dt> <code>hexString</code> <span class="type">String</span> </dt> <dd> <p>Optional. The 24-character hexadecimal contents of the ObjectID to create</p> </dd> </dl>   <p><code>Mongo.ObjectID</code> follows the same API as the <a href="http://mongodb.github.io/node-mongodb-native/2.2/api/ObjectID.html" target="_blank" rel="external">Node MongoDB driver <code>ObjectID</code></a> class. Note that you must use the <code>equals</code> method (or <a href="#ejson_equals"><code>EJSON.equals</code></a>) to compare them; the <code>===</code> operator will not work. If you are writing generic code that needs to deal with <code>_id</code> fields that may be either strings or <code>ObjectID</code>s, use <a href="#ejson_equals"><code>EJSON.equals</code></a> instead of <code>===</code> to compare them.</p> <blockquote> <p> <code>ObjectID</code> values created by Meteor will not have meaningful answers to their <code>getTimestamp</code> method, since Meteor currently constructs them fully randomly.</p> </blockquote> <h2 id="selectors">Mongo-Style Selectors</h2> <p>The simplest selectors are just a string or <a href="#mongo_object_id"><code>Mongo.ObjectID</code></a>. These selectors match the document with that value in its <code>_id</code> field.</p> <p>A slightly more complex form of selector is an object containing a set of keys that must match in a document:</p> <pre class="highlight js" data-language="js">// Matches all documents where `deleted` is false.
{ deleted: false }

// Matches all documents where the `name` and `cognomen` are as given.
{ name: 'Rhialto', cognomen: 'the Marvelous' }

// Matches every document.
{}</pre> <p>But they can also contain more complicated tests:</p> <pre class="highlight js" data-language="js">// Matches documents where `age` is greater than 18.
{ age: { $gt: 18 } }

// Matches documents where `tags` is an array containing 'popular'.
{ tags: 'popular' }

// Matches documents where `fruit` is one of three possibilities.
{ fruit: { $in: ['peach', 'plum', 'pear'] } }</pre> <p>See the <a href="http://docs.mongodb.org/manual/reference/operator/" target="_blank" rel="external">complete documentation</a>.</p> <h2 id="modifiers">Mongo-Style Modifiers</h2> <p>A modifier is an object that describes how to update a document in place by changing some of its fields. Some examples:</p> <pre class="highlight js" data-language="js">// Set the `admin` property on the document to true.
{ $set: { admin: true } }

// Add 2 to the `votes` property and add 'Traz' to the end of the `supporters`
// array.
{ $inc: { votes: 2 }, $push: { supporters: 'Traz' } }</pre> <p>But if a modifier doesn’t contain any $-operators, then it is instead interpreted as a literal document, and completely replaces whatever was previously in the database. (Literal document modifiers are not currently supported by <a href="#allow">validated updates</a>.)</p> <pre class="highlight js" data-language="js">// Find the document with ID '123' and completely replace it.
Users.update({ _id: '123' }, { name: 'Alice', friends: ['Bob'] });</pre> <p>See the <a href="http://docs.mongodb.org/manual/reference/operator/update/" target="_blank" rel="external">full list of modifiers</a>.</p> <h2 id="sortspecifiers">Sort Specifiers</h2> <p>Sorts may be specified using your choice of several syntaxes:</p> <pre class="highlight js" data-language="js">// All of these do the same thing (sort in ascending order by key `a`, breaking
// ties in descending order of key `b`).
[['a', 'asc'], ['b', 'desc']]
['a', ['b', 'desc']]
{ a: 1, b: -1 }

// Sorted by `createdAt` descending.
Users.find({}, { sort: { createdAt: -1 } });

// Sorted by `createdAt` descending and by `name` ascending.
Users.find({}, { sort: [['createdAt', 'desc'], ['name', 'asc']] });</pre> <p>The last form will only work if your JavaScript implementation preserves the order of keys in objects. Most do, most of the time, but it’s up to you to be sure.</p> <p>For local collections you can pass a comparator function which receives two document objects, and returns -1 if the first document comes first in order, 1 if the second document comes first, or 0 if neither document comes before the other. This is a Minimongo extension to MongoDB.</p> <h2 id="fieldspecifiers">Field Specifiers</h2> <p>Queries can specify a particular set of fields to include or exclude from the result object.</p> <p>To exclude specific fields from the result objects, the field specifier is a dictionary whose keys are field names and whose values are <code>0</code>. All unspecified fields are included.</p> <pre class="highlight js" data-language="js">Users.find({}, { fields: { password: 0, hash: 0 } });</pre> <p>To include only specific fields in the result documents, use <code>1</code> as the value. The <code>_id</code> field is still included in the result.</p> <pre class="highlight js" data-language="js">Users.find({}, { fields: { firstname: 1, lastname: 1 } });</pre> <p>With one exception, it is not possible to mix inclusion and exclusion styles: the keys must either be all 1 or all 0. The exception is that you may specify <code>_id: 0</code> in an inclusion specifier, which will leave <code>_id</code> out of the result object as well. However, such field specifiers can not be used with <a href="#observe_changes"><code>observeChanges</code></a>, <a href="#observe"><code>observe</code></a>, cursors returned from a <a href="#meteor_publish">publish function</a>, or cursors used in <code>{{#each}}</code> in a template. They may be used with <a href="#fetch"><code>fetch</code></a>, <a href="#findone"><code>findOne</code></a>, <a href="#foreach"><code>forEach</code></a>, and <a href="#map"><code>map</code></a>.</p> <p><a href="http://docs.mongodb.org/manual/reference/operator/projection/" target="_blank" rel="external">Field operators</a> such as <code>$</code> and <code>$elemMatch</code> are not available on the client side yet.</p> <p>A more advanced example:</p> <pre class="highlight js" data-language="js">Users.insert({
  alterEgos: [
    { name: 'Kira', alliance: 'murderer' },
    { name: 'L', alliance: 'police' }
  ],
  name: 'Yagami Light'

});

Users.findOne({}, { fields: { 'alterEgos.name': 1, _id: 0 } });
// Returns { alterEgos: [{ name: 'Kira' }, { name: 'L' }] }</pre> <p>See <a href="http://docs.mongodb.org/manual/tutorial/project-fields-from-query-results/#projection" target="_blank" rel="external"> the MongoDB docs</a> for details of the nested field rules and array behavior.</p> <h2 id="mongo_url">Connecting to your database</h2> <p>When developing your application, Meteor starts a local MongoDB instance and automatically connects to it. In production, you must specify a <code>MONGO_URL</code> environment variable pointing at your database in <a href="https://docs.mongodb.com/manual/reference/connection-string" target="_blank" rel="external">the standard mongo connection string format</a>.</p> <blockquote> <p>You can also set <code>MONGO_URL</code> in development if you want to connect to a different MongoDB instance.</p> </blockquote> <p>If you want to use oplog tailing for livequeries, you should also set <code>MONGO_OPLOG_URL</code> (generally you’ll need a special user with oplog access, but the detail can differ depending on how you host your MongoDB. Read more <a href="https://github.com/meteor/docs/blob/master/long-form/oplog-observe-driver.md" target="_blank" rel="external">here</a>).</p> <blockquote> <p>As of Meteor 1.4, you must ensure you set the <code>replicaSet</code> parameter on your <code>METEOR_OPLOG_URL</code></p> </blockquote>
<div class="_attribution">
  <p class="_attribution-p">
    © 2011–2017 Meteor Development Group, Inc.<br>Licensed under the MIT License.<br>
    <a href="https://docs.meteor.com/api/collections.html" class="_attribution-link">https://docs.meteor.com/api/collections.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
