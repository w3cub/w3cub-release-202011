
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Control.Concurrent - Haskell 8 - W3cubDocs</title>
  
  <meta name="description" content=" A common interface to a collection of useful concurrency abstractions. ">
  <meta name="keywords" content="control, concurrent, haskell, haskell~8">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/haskell~8/libraries/base-4.13.0.0/control-concurrent.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/haskell~8.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/haskell~8/" class="_nav-link" title="" style="margin-left:0;">Haskell 8</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _haskell">
				
				
<h1 class="caption">Control.Concurrent</h1>
<div class="_haskell-api">
<table class="info">
<tr>
<th valign="top">Copyright</th>
<td>(c) The University of Glasgow 2001</td>
</tr>
<tr>
<th>License</th>
<td>BSD-style (see the file libraries/base/LICENSE)</td>
</tr>
<tr>
<th>Maintainer</th>
<td>libraries@haskell.org</td>
</tr>
<tr>
<th>Stability</th>
<td>experimental</td>
</tr>
<tr>
<th>Portability</th>
<td>non-portable (concurrency)</td>
</tr>
<tr>
<th>Safe Haskell</th>
<td>Trustworthy</td>
</tr>
<tr>
<th>Language</th>
<td>Haskell2010</td>
</tr>
</table>
<div id="table-of-contents"><div id="contents-list">
<h4 class="caption" onclick="window.scrollTo(0,0)">Contents</h4>
<ul>
<li><a href="#g:1">Concurrent Haskell</a></li>
<li>
<a href="#g:2">Basic concurrency operations</a><ul><li><a href="#g:3">Threads with affinity</a></li></ul>
</li>
<li>
<a href="#g:4">Scheduling</a><ul>
<li><a href="#g:5">Blocking</a></li>
<li><a href="#g:6">Waiting</a></li>
</ul>
</li>
<li><a href="#g:7">Communication abstractions</a></li>
<li><a href="#g:8">Bound Threads</a></li>
<li><a href="#g:9">Weak references to ThreadIds</a></li>
<li>
<a href="#g:10">GHC's implementation of concurrency</a><ul>
<li><a href="#g:11">Haskell threads and Operating System threads</a></li>
<li><a href="#g:12">Terminating the program</a></li>
<li><a href="#g:13">Pre-emption</a></li>
<li><a href="#g:14">Deadlock</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="description">
<h4 class="caption">Description</h4>
<p>A common interface to a collection of useful concurrency abstractions.</p>
</div>
<a href="#g:1" id="g:1"><h2>Concurrent Haskell</h2></a><p>The concurrency extension for Haskell is described in the paper <em>Concurrent Haskell</em> <a href="http://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz">http://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz</a>.</p>
<p>Concurrency is "lightweight", which means that both thread creation and context switching overheads are extremely low. Scheduling of Haskell threads is done internally in the Haskell runtime system, and doesn't make use of any operating system-supplied thread packages.</p>
<p>However, if you want to interact with a foreign library that expects your program to use the operating system-supplied thread package, you can do so by using <code><a href="control-concurrent#v:forkOS" title="Control.Concurrent">forkOS</a></code> instead of <code><a href="control-concurrent#v:forkIO" title="Control.Concurrent">forkIO</a></code>.</p>
<p>Haskell threads can communicate via <code><a href="control-concurrent-mvar#t:MVar" title="Control.Concurrent.MVar">MVar</a></code>s, a kind of synchronised mutable variable (see <a href="control-concurrent-mvar">Control.Concurrent.MVar</a>). Several common concurrency abstractions can be built from <code><a href="control-concurrent-mvar#t:MVar" title="Control.Concurrent.MVar">MVar</a></code>s, and these are provided by the <a href="control-concurrent">Control.Concurrent</a> library. In GHC, threads may also communicate via exceptions.</p>
<a href="#g:2" id="g:2"><h2>Basic concurrency operations</h2></a><p class="src">data <a id="t:ThreadId" class="def">ThreadId</a> <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/GHC-Conc-Sync.html#ThreadId" class="link">Source</a> </p>
<p>A <code><a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a></code> is an abstract type representing a handle to a thread. <code><a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a></code> is an instance of <code><a href="data-eq#t:Eq" title="Data.Eq">Eq</a></code>, <code><a href="data-ord#t:Ord" title="Data.Ord">Ord</a></code> and <code><a href="text-show#t:Show" title="Text.Show">Show</a></code>, where the <code><a href="data-ord#t:Ord" title="Data.Ord">Ord</a></code> instance implements an arbitrary total ordering over <code><a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a></code>s. The <code><a href="text-show#t:Show" title="Text.Show">Show</a></code> instance lets you convert an arbitrary-valued <code><a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a></code> to string form; showing a <code><a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a></code> value is occasionally useful when debugging or diagnosing the behaviour of a concurrent program.</p>
<p><em>Note</em>: in GHC, if you have a <code><a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a></code>, you essentially have a pointer to the thread itself. This means the thread itself can't be garbage collected until you drop the <code><a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a></code>. This misfeature will hopefully be corrected at a later date.</p>
<div class="subs instances">
<h5 class="instances details-toggle-control details-toggle" data-details-id="i:ThreadId">Instances</h5>
<details id="i:ThreadId" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table>
<tr>
<td class="src clearfix">
 <a href="data-eq#t:Eq" title="Data.Eq">Eq</a> <a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a> </td>
<td class="doc"><p><span class="version">Since: base-4.2.0.0</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:ThreadId:Eq:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="ghc-conc-sync">GHC.Conc.Sync</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:-61--61-">(==)</a> :: <a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a> -&gt; <a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a> -&gt; <a href="data-bool#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/src/GHC-Classes.html#%3D%3D" class="link">Source</a> </p>
<p class="src"><a href="#v:-47--61-">(/=)</a> :: <a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a> -&gt; <a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a> -&gt; <a href="data-bool#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/src/GHC-Classes.html#%2F%3D" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="data-ord#t:Ord" title="Data.Ord">Ord</a> <a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a> </td>
<td class="doc"><p><span class="version">Since: base-4.2.0.0</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:ThreadId:Ord:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="ghc-conc-sync">GHC.Conc.Sync</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:compare">compare</a> :: <a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a> -&gt; <a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a> -&gt; <a href="data-ord#t:Ordering" title="Data.Ord">Ordering</a> <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/src/GHC-Classes.html#compare" class="link">Source</a> </p>
<p class="src"><a href="#v:-60-">(&lt;)</a> :: <a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a> -&gt; <a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a> -&gt; <a href="data-bool#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/src/GHC-Classes.html#%3C" class="link">Source</a> </p>
<p class="src"><a href="#v:-60--61-">(&lt;=)</a> :: <a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a> -&gt; <a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a> -&gt; <a href="data-bool#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/src/GHC-Classes.html#%3C%3D" class="link">Source</a> </p>
<p class="src"><a href="#v:-62-">(&gt;)</a> :: <a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a> -&gt; <a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a> -&gt; <a href="data-bool#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/src/GHC-Classes.html#%3E" class="link">Source</a> </p>
<p class="src"><a href="#v:-62--61-">(&gt;=)</a> :: <a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a> -&gt; <a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a> -&gt; <a href="data-bool#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/src/GHC-Classes.html#%3E%3D" class="link">Source</a> </p>
<p class="src"><a href="#v:max">max</a> :: <a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a> -&gt; <a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a> -&gt; <a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a> <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/src/GHC-Classes.html#max" class="link">Source</a> </p>
<p class="src"><a href="#v:min">min</a> :: <a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a> -&gt; <a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a> -&gt; <a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a> <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/src/GHC-Classes.html#min" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="text-show#t:Show" title="Text.Show">Show</a> <a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a> </td>
<td class="doc"><p><span class="version">Since: base-4.2.0.0</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:ThreadId:Show:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="ghc-conc-sync">GHC.Conc.Sync</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:showsPrec">showsPrec</a> :: <a href="data-int#t:Int" title="Data.Int">Int</a> -&gt; <a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a> -&gt; <a href="text-show#t:ShowS" title="Text.Show">ShowS</a> <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/GHC-Show.html#showsPrec" class="link">Source</a> </p>
<p class="src"><a href="#v:show">show</a> :: <a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a> -&gt; <a href="data-string#t:String" title="Data.String">String</a> <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/GHC-Show.html#show" class="link">Source</a> </p>
<p class="src"><a href="#v:showList">showList</a> :: [<a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a>] -&gt; <a href="text-show#t:ShowS" title="Text.Show">ShowS</a> <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/GHC-Show.html#showList" class="link">Source</a> </p>
</div></details></td></tr>
</table></details>
</div>
<p class="src"><a id="v:myThreadId" class="def">myThreadId</a> :: <a href="system-io#t:IO" title="System.IO">IO</a> <a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a> <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/GHC-Conc-Sync.html#myThreadId" class="link">Source</a> </p>
<p>Returns the <code><a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a></code> of the calling thread (GHC only).</p>
<p class="src"><a id="v:forkIO" class="def">forkIO</a> :: <a href="system-io#t:IO" title="System.IO">IO</a> () -&gt; <a href="system-io#t:IO" title="System.IO">IO</a> <a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a> <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/GHC-Conc-Sync.html#forkIO" class="link">Source</a> </p>
<p>Creates a new thread to run the <code><a href="system-io#t:IO" title="System.IO">IO</a></code> computation passed as the first argument, and returns the <code><a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a></code> of the newly created thread.</p>
<p>The new thread will be a lightweight, <em>unbound</em> thread. Foreign calls made by this thread are not guaranteed to be made by any particular OS thread; if you need foreign calls to be made by a particular OS thread, then use <code><a href="control-concurrent#v:forkOS" title="Control.Concurrent">forkOS</a></code> instead.</p>
<p>The new thread inherits the <em>masked</em> state of the parent (see <code><a href="control-exception#v:mask" title="Control.Exception">mask</a></code>).</p>
<p>The newly created thread has an exception handler that discards the exceptions <code><a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar" title="Control.Exception.Base">BlockedIndefinitelyOnMVar</a></code>, <code><a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM" title="Control.Exception.Base">BlockedIndefinitelyOnSTM</a></code>, and <code><a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:ThreadKilled" title="Control.Exception.Base">ThreadKilled</a></code>, and passes all other exceptions to the uncaught exception handler.</p>
<p class="src"><a id="v:forkFinally" class="def">forkFinally</a> :: <a href="system-io#t:IO" title="System.IO">IO</a> a -&gt; (<a href="data-either#t:Either" title="Data.Either">Either</a> <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:SomeException" title="Control.Exception.Base">SomeException</a> a -&gt; <a href="system-io#t:IO" title="System.IO">IO</a> ()) -&gt; <a href="system-io#t:IO" title="System.IO">IO</a> <a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a> <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/Control-Concurrent.html#forkFinally" class="link">Source</a> </p>
<p>Fork a thread and call the supplied function when the thread is about to terminate, with an exception or a returned value. The function is called with asynchronous exceptions masked.</p>
<pre>forkFinally action and_then =
  mask $ \restore -&gt;
    forkIO $ try (restore action) &gt;&gt;= and_then</pre>
<p>This function is useful for informing the parent when a child terminates, for example.</p>
<p><span class="version">Since: base-4.6.0.0</span></p>
<p class="src"><a id="v:forkIOWithUnmask" class="def">forkIOWithUnmask</a> :: ((forall a. <a href="system-io#t:IO" title="System.IO">IO</a> a -&gt; <a href="system-io#t:IO" title="System.IO">IO</a> a) -&gt; <a href="system-io#t:IO" title="System.IO">IO</a> ()) -&gt; <a href="system-io#t:IO" title="System.IO">IO</a> <a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a> <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/GHC-Conc-Sync.html#forkIOWithUnmask" class="link">Source</a> </p>
<p>Like <code><a href="control-concurrent#v:forkIO" title="Control.Concurrent">forkIO</a></code>, but the child thread is passed a function that can be used to unmask asynchronous exceptions. This function is typically used in the following way</p>
<pre> ... mask_ $ forkIOWithUnmask $ \unmask -&gt;
                catch (unmask ...) handler</pre>
<p>so that the exception handler in the child thread is established with asynchronous exceptions masked, meanwhile the main body of the child thread is executed in the unmasked state.</p>
<p>Note that the unmask function passed to the child thread should only be used in that thread; the behaviour is undefined if it is invoked in a different thread.</p>
<p><span class="version">Since: base-4.4.0.0</span></p>
<p class="src"><a id="v:killThread" class="def">killThread</a> :: <a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a> -&gt; <a href="system-io#t:IO" title="System.IO">IO</a> () <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/GHC-Conc-Sync.html#killThread" class="link">Source</a> </p>
<p><code><a href="control-concurrent#v:killThread" title="Control.Concurrent">killThread</a></code> raises the <code><a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:ThreadKilled" title="Control.Exception.Base">ThreadKilled</a></code> exception in the given thread (GHC only).</p>
<pre>killThread tid = throwTo tid ThreadKilled</pre>
<p class="src"><a id="v:throwTo" class="def">throwTo</a> :: <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:Exception" title="Control.Exception.Base">Exception</a> e =&gt; <a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a> -&gt; e -&gt; <a href="system-io#t:IO" title="System.IO">IO</a> () <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/GHC-Conc-Sync.html#throwTo" class="link">Source</a> </p>
<p><code><a href="control-concurrent#v:throwTo" title="Control.Concurrent">throwTo</a></code> raises an arbitrary exception in the target thread (GHC only).</p>
<p>Exception delivery synchronizes between the source and target thread: <code><a href="control-concurrent#v:throwTo" title="Control.Concurrent">throwTo</a></code> does not return until the exception has been raised in the target thread. The calling thread can thus be certain that the target thread has received the exception. Exception delivery is also atomic with respect to other exceptions. Atomicity is a useful property to have when dealing with race conditions: e.g. if there are two threads that can kill each other, it is guaranteed that only one of the threads will get to kill the other.</p>
<p>Whatever work the target thread was doing when the exception was raised is not lost: the computation is suspended until required by another thread.</p>
<p>If the target thread is currently making a foreign call, then the exception will not be raised (and hence <code><a href="control-concurrent#v:throwTo" title="Control.Concurrent">throwTo</a></code> will not return) until the call has completed. This is the case regardless of whether the call is inside a <code><a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask" title="Control.Exception.Base">mask</a></code> or not. However, in GHC a foreign call can be annotated as <code>interruptible</code>, in which case a <code><a href="control-concurrent#v:throwTo" title="Control.Concurrent">throwTo</a></code> will cause the RTS to attempt to cause the call to return; see the GHC documentation for more details.</p>
<p>Important note: the behaviour of <code><a href="control-concurrent#v:throwTo" title="Control.Concurrent">throwTo</a></code> differs from that described in the paper "Asynchronous exceptions in Haskell" (<a href="http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm">http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm</a>). In the paper, <code><a href="control-concurrent#v:throwTo" title="Control.Concurrent">throwTo</a></code> is non-blocking; but the library implementation adopts a more synchronous design in which <code><a href="control-concurrent#v:throwTo" title="Control.Concurrent">throwTo</a></code> does not return until the exception is received by the target thread. The trade-off is discussed in Section 9 of the paper. Like any blocking operation, <code><a href="control-concurrent#v:throwTo" title="Control.Concurrent">throwTo</a></code> is therefore interruptible (see Section 5.3 of the paper). Unlike other interruptible operations, however, <code><a href="control-concurrent#v:throwTo" title="Control.Concurrent">throwTo</a></code> is <em>always</em> interruptible, even if it does not actually block.</p>
<p>There is no guarantee that the exception will be delivered promptly, although the runtime will endeavour to ensure that arbitrary delays don't occur. In GHC, an exception can only be raised when a thread reaches a <em>safe point</em>, where a safe point is where memory allocation occurs. Some loops do not perform any memory allocation inside the loop and therefore cannot be interrupted by a <code><a href="control-concurrent#v:throwTo" title="Control.Concurrent">throwTo</a></code>.</p>
<p>If the target of <code><a href="control-concurrent#v:throwTo" title="Control.Concurrent">throwTo</a></code> is the calling thread, then the behaviour is the same as <code><a href="control-exception#v:throwIO" title="Control.Exception">throwIO</a></code>, except that the exception is thrown as an asynchronous exception. This means that if there is an enclosing pure computation, which would be the case if the current IO operation is inside <code><a href="system-io-unsafe#v:unsafePerformIO" title="System.IO.Unsafe">unsafePerformIO</a></code> or <code><a href="system-io-unsafe#v:unsafeInterleaveIO" title="System.IO.Unsafe">unsafeInterleaveIO</a></code>, that computation is not permanently replaced by the exception, but is suspended as if it had received an asynchronous exception.</p>
<p>Note that if <code><a href="control-concurrent#v:throwTo" title="Control.Concurrent">throwTo</a></code> is called with the current thread as the target, the exception will be thrown even if the thread is currently inside <code><a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask" title="Control.Exception.Base">mask</a></code> or <code><a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:uninterruptibleMask" title="Control.Exception.Base">uninterruptibleMask</a></code>.</p>
<a href="#g:3" id="g:3"><h3>Threads with affinity</h3></a><p class="src"><a id="v:forkOn" class="def">forkOn</a> :: <a href="data-int#t:Int" title="Data.Int">Int</a> -&gt; <a href="system-io#t:IO" title="System.IO">IO</a> () -&gt; <a href="system-io#t:IO" title="System.IO">IO</a> <a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a> <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/GHC-Conc-Sync.html#forkOn" class="link">Source</a> </p>
<p>Like <code><a href="control-concurrent#v:forkIO" title="Control.Concurrent">forkIO</a></code>, but lets you specify on which capability the thread should run. Unlike a <code><a href="control-concurrent#v:forkIO" title="Control.Concurrent">forkIO</a></code> thread, a thread created by <code><a href="control-concurrent#v:forkOn" title="Control.Concurrent">forkOn</a></code> will stay on the same capability for its entire lifetime (<code><a href="control-concurrent#v:forkIO" title="Control.Concurrent">forkIO</a></code> threads can migrate between capabilities according to the scheduling policy). <code><a href="control-concurrent#v:forkOn" title="Control.Concurrent">forkOn</a></code> is useful for overriding the scheduling policy when you know in advance how best to distribute the threads.</p>
<p>The <code><a href="data-int#t:Int" title="Data.Int">Int</a></code> argument specifies a <em>capability number</em> (see <code><a href="control-concurrent#v:getNumCapabilities" title="Control.Concurrent">getNumCapabilities</a></code>). Typically capabilities correspond to physical processors, but the exact behaviour is implementation-dependent. The value passed to <code><a href="control-concurrent#v:forkOn" title="Control.Concurrent">forkOn</a></code> is interpreted modulo the total number of capabilities as returned by <code><a href="control-concurrent#v:getNumCapabilities" title="Control.Concurrent">getNumCapabilities</a></code>.</p>
<p>GHC note: the number of capabilities is specified by the <code>+RTS -N</code> option when the program is started. Capabilities can be fixed to actual processor cores with <code>+RTS -qa</code> if the underlying operating system supports that, although in practice this is usually unnecessary (and may actually degrade performance in some cases - experimentation is recommended).</p>
<p><span class="version">Since: base-4.4.0.0</span></p>
<p class="src"><a id="v:forkOnWithUnmask" class="def">forkOnWithUnmask</a> :: <a href="data-int#t:Int" title="Data.Int">Int</a> -&gt; ((forall a. <a href="system-io#t:IO" title="System.IO">IO</a> a -&gt; <a href="system-io#t:IO" title="System.IO">IO</a> a) -&gt; <a href="system-io#t:IO" title="System.IO">IO</a> ()) -&gt; <a href="system-io#t:IO" title="System.IO">IO</a> <a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a> <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/GHC-Conc-Sync.html#forkOnWithUnmask" class="link">Source</a> </p>
<p>Like <code><a href="control-concurrent#v:forkIOWithUnmask" title="Control.Concurrent">forkIOWithUnmask</a></code>, but the child thread is pinned to the given CPU, as with <code><a href="control-concurrent#v:forkOn" title="Control.Concurrent">forkOn</a></code>.</p>
<p><span class="version">Since: base-4.4.0.0</span></p>
<p class="src"><a id="v:getNumCapabilities" class="def">getNumCapabilities</a> :: <a href="system-io#t:IO" title="System.IO">IO</a> <a href="data-int#t:Int" title="Data.Int">Int</a> <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/GHC-Conc-Sync.html#getNumCapabilities" class="link">Source</a> </p>
<p>Returns the number of Haskell threads that can run truly simultaneously (on separate physical processors) at any given time. To change this value, use <code><a href="control-concurrent#v:setNumCapabilities" title="Control.Concurrent">setNumCapabilities</a></code>.</p>
<p><span class="version">Since: base-4.4.0.0</span></p>
<p class="src"><a id="v:setNumCapabilities" class="def">setNumCapabilities</a> :: <a href="data-int#t:Int" title="Data.Int">Int</a> -&gt; <a href="system-io#t:IO" title="System.IO">IO</a> () <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/GHC-Conc-Sync.html#setNumCapabilities" class="link">Source</a> </p>
<p>Set the number of Haskell threads that can run truly simultaneously (on separate physical processors) at any given time. The number passed to <code><a href="control-concurrent#v:forkOn" title="Control.Concurrent">forkOn</a></code> is interpreted modulo this value. The initial value is given by the <code>+RTS -N</code> runtime flag.</p>
<p>This is also the number of threads that will participate in parallel garbage collection. It is strongly recommended that the number of capabilities is not set larger than the number of physical processor cores, and it may often be beneficial to leave one or more cores free to avoid contention with other processes in the machine.</p>
<p><span class="version">Since: base-4.5.0.0</span></p>
<p class="src"><a id="v:threadCapability" class="def">threadCapability</a> :: <a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a> -&gt; <a href="system-io#t:IO" title="System.IO">IO</a> (<a href="data-int#t:Int" title="Data.Int">Int</a>, <a href="data-bool#t:Bool" title="Data.Bool">Bool</a>) <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/GHC-Conc-Sync.html#threadCapability" class="link">Source</a> </p>
<p>Returns the number of the capability on which the thread is currently running, and a boolean indicating whether the thread is locked to that capability or not. A thread is locked to a capability if it was created with <code>forkOn</code>.</p>
<p><span class="version">Since: base-4.4.0.0</span></p>
<a href="#g:4" id="g:4"><h2>Scheduling</h2></a><p>Scheduling may be either pre-emptive or co-operative, depending on the implementation of Concurrent Haskell (see below for information related to specific compilers). In a co-operative system, context switches only occur when you use one of the primitives defined in this module. This means that programs such as:</p>
<pre>  main = forkIO (write 'a') &gt;&gt; write 'b'
    where write c = putChar c &gt;&gt; write c</pre>
<p>will print either <code>aaaaaaaaaaaaaa...</code> or <code>bbbbbbbbbbbb...</code>, instead of some random interleaving of <code>a</code>s and <code>b</code>s. In practice, cooperative multitasking is sufficient for writing simple graphical user interfaces.</p>
<p class="src"><a id="v:yield" class="def">yield</a> :: <a href="system-io#t:IO" title="System.IO">IO</a> () <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/GHC-Conc-Sync.html#yield" class="link">Source</a> </p>
<p>The <code><a href="control-concurrent#v:yield" title="Control.Concurrent">yield</a></code> action allows (forces, in a co-operative multitasking implementation) a context-switch to any other currently runnable threads (if any), and is occasionally useful when implementing concurrency abstractions.</p>
<a href="#g:5" id="g:5"><h3>Blocking</h3></a><p>Different Haskell implementations have different characteristics with regard to which operations block <em>all</em> threads.</p>
<p>Using GHC without the <code>-threaded</code> option, all foreign calls will block all other Haskell threads in the system, although I/O operations will not. With the <code>-threaded</code> option, only foreign calls with the <code>unsafe</code> attribute will block all other threads.</p>
<a href="#g:6" id="g:6"><h3>Waiting</h3></a><p class="src"><a id="v:threadDelay" class="def">threadDelay</a> :: <a href="data-int#t:Int" title="Data.Int">Int</a> -&gt; <a href="system-io#t:IO" title="System.IO">IO</a> () <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/GHC-Conc-IO.html#threadDelay" class="link">Source</a> </p>
<p>Suspends the current thread for a given number of microseconds (GHC only).</p>
<p>There is no guarantee that the thread will be rescheduled promptly when the delay has expired, but the thread will never continue to run <em>earlier</em> than specified.</p>
<p class="src"><a id="v:threadWaitRead" class="def">threadWaitRead</a> :: <a href="system-posix-types#t:Fd" title="System.Posix.Types">Fd</a> -&gt; <a href="system-io#t:IO" title="System.IO">IO</a> () <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/Control-Concurrent.html#threadWaitRead" class="link">Source</a> </p>
<p>Block the current thread until data is available to read on the given file descriptor (GHC only).</p>
<p>This will throw an <code><a href="system-io-error#t:IOError" title="System.IO.Error">IOError</a></code> if the file descriptor was closed while this thread was blocked. To safely close a file descriptor that has been used with <code><a href="control-concurrent#v:threadWaitRead" title="Control.Concurrent">threadWaitRead</a></code>, use <code><a href="ghc-conc#v:closeFdWith" title="GHC.Conc">closeFdWith</a></code>.</p>
<p class="src"><a id="v:threadWaitWrite" class="def">threadWaitWrite</a> :: <a href="system-posix-types#t:Fd" title="System.Posix.Types">Fd</a> -&gt; <a href="system-io#t:IO" title="System.IO">IO</a> () <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/Control-Concurrent.html#threadWaitWrite" class="link">Source</a> </p>
<p>Block the current thread until data can be written to the given file descriptor (GHC only).</p>
<p>This will throw an <code><a href="system-io-error#t:IOError" title="System.IO.Error">IOError</a></code> if the file descriptor was closed while this thread was blocked. To safely close a file descriptor that has been used with <code><a href="control-concurrent#v:threadWaitWrite" title="Control.Concurrent">threadWaitWrite</a></code>, use <code><a href="ghc-conc#v:closeFdWith" title="GHC.Conc">closeFdWith</a></code>.</p>
<p class="src"><a id="v:threadWaitReadSTM" class="def">threadWaitReadSTM</a> :: <a href="system-posix-types#t:Fd" title="System.Posix.Types">Fd</a> -&gt; <a href="system-io#t:IO" title="System.IO">IO</a> (<a href="ghc-conc#t:STM" title="GHC.Conc">STM</a> (), <a href="system-io#t:IO" title="System.IO">IO</a> ()) <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/Control-Concurrent.html#threadWaitReadSTM" class="link">Source</a> </p>
<p>Returns an STM action that can be used to wait for data to read from a file descriptor. The second returned value is an IO action that can be used to deregister interest in the file descriptor.</p>
<p><span class="version">Since: base-4.7.0.0</span></p>
<p class="src"><a id="v:threadWaitWriteSTM" class="def">threadWaitWriteSTM</a> :: <a href="system-posix-types#t:Fd" title="System.Posix.Types">Fd</a> -&gt; <a href="system-io#t:IO" title="System.IO">IO</a> (<a href="ghc-conc#t:STM" title="GHC.Conc">STM</a> (), <a href="system-io#t:IO" title="System.IO">IO</a> ()) <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/Control-Concurrent.html#threadWaitWriteSTM" class="link">Source</a> </p>
<p>Returns an STM action that can be used to wait until data can be written to a file descriptor. The second returned value is an IO action that can be used to deregister interest in the file descriptor.</p>
<p><span class="version">Since: base-4.7.0.0</span></p>
<a href="#g:7" id="g:7"><h2>Communication abstractions</h2></a><p class="src">module <a href="control-concurrent-mvar">Control.Concurrent.MVar</a></p>
<p class="src">module <a href="control-concurrent-chan">Control.Concurrent.Chan</a></p>
<p class="src">module <a href="control-concurrent-qsem">Control.Concurrent.QSem</a></p>
<p class="src">module <a href="control-concurrent-qsemn">Control.Concurrent.QSemN</a></p>
<a href="#g:8" id="g:8"><h2>Bound Threads</h2></a>
<p>Support for multiple operating system threads and bound threads as described below is currently only available in the GHC runtime system if you use the <em>-threaded</em> option when linking.</p>
<p>Other Haskell systems do not currently support multiple operating system threads.</p>
<p>A bound thread is a haskell thread that is <em>bound</em> to an operating system thread. While the bound thread is still scheduled by the Haskell run-time system, the operating system thread takes care of all the foreign calls made by the bound thread.</p>
<p>To a foreign library, the bound thread will look exactly like an ordinary operating system thread created using OS functions like <code>pthread_create</code> or <code>CreateThread</code>.</p>
<p>Bound threads can be created using the <code><a href="control-concurrent#v:forkOS" title="Control.Concurrent">forkOS</a></code> function below. All foreign exported functions are run in a bound thread (bound to the OS thread that called the function). Also, the <code>main</code> action of every Haskell program is run in a bound thread.</p>
<p>Why do we need this? Because if a foreign library is called from a thread created using <code><a href="control-concurrent#v:forkIO" title="Control.Concurrent">forkIO</a></code>, it won't have access to any <em>thread-local state</em> - state variables that have specific values for each OS thread (see POSIX's <code>pthread_key_create</code> or Win32's <code>TlsAlloc</code>). Therefore, some libraries (OpenGL, for example) will not work from a thread created using <code><a href="control-concurrent#v:forkIO" title="Control.Concurrent">forkIO</a></code>. They work fine in threads created using <code><a href="control-concurrent#v:forkOS" title="Control.Concurrent">forkOS</a></code> or when called from <code>main</code> or from a <code>foreign export</code>.</p>
<p>In terms of performance, <code><a href="control-concurrent#v:forkOS" title="Control.Concurrent">forkOS</a></code> (aka bound) threads are much more expensive than <code><a href="control-concurrent#v:forkIO" title="Control.Concurrent">forkIO</a></code> (aka unbound) threads, because a <code><a href="control-concurrent#v:forkOS" title="Control.Concurrent">forkOS</a></code> thread is tied to a particular OS thread, whereas a <code><a href="control-concurrent#v:forkIO" title="Control.Concurrent">forkIO</a></code> thread can be run by any OS thread. Context-switching between a <code><a href="control-concurrent#v:forkOS" title="Control.Concurrent">forkOS</a></code> thread and a <code><a href="control-concurrent#v:forkIO" title="Control.Concurrent">forkIO</a></code> thread is many times more expensive than between two <code><a href="control-concurrent#v:forkIO" title="Control.Concurrent">forkIO</a></code> threads.</p>
<p>Note in particular that the main program thread (the thread running <code>Main.main</code>) is always a bound thread, so for good concurrency performance you should ensure that the main thread is not doing repeated communication with other threads in the system. Typically this means forking subthreads to do the work using <code><a href="control-concurrent#v:forkIO" title="Control.Concurrent">forkIO</a></code>, and waiting for the results in the main thread.</p>
<p class="src"><a id="v:rtsSupportsBoundThreads" class="def">rtsSupportsBoundThreads</a> :: <a href="data-bool#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/Control-Concurrent.html#rtsSupportsBoundThreads" class="link">Source</a> </p>
<p><code><a href="data-bool#v:True" title="Data.Bool">True</a></code> if bound threads are supported. If <code>rtsSupportsBoundThreads</code> is <code><a href="data-bool#v:False" title="Data.Bool">False</a></code>, <code><a href="control-concurrent#v:isCurrentThreadBound" title="Control.Concurrent">isCurrentThreadBound</a></code> will always return <code><a href="data-bool#v:False" title="Data.Bool">False</a></code> and both <code><a href="control-concurrent#v:forkOS" title="Control.Concurrent">forkOS</a></code> and <code><a href="control-concurrent#v:runInBoundThread" title="Control.Concurrent">runInBoundThread</a></code> will fail.</p>
<p class="src"><a id="v:forkOS" class="def">forkOS</a> :: <a href="system-io#t:IO" title="System.IO">IO</a> () -&gt; <a href="system-io#t:IO" title="System.IO">IO</a> <a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a> <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/Control-Concurrent.html#forkOS" class="link">Source</a> </p>
<p>Like <code><a href="control-concurrent#v:forkIO" title="Control.Concurrent">forkIO</a></code>, this sparks off a new thread to run the <code><a href="system-io#t:IO" title="System.IO">IO</a></code> computation passed as the first argument, and returns the <code><a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a></code> of the newly created thread.</p>
<p>However, <code><a href="control-concurrent#v:forkOS" title="Control.Concurrent">forkOS</a></code> creates a <em>bound</em> thread, which is necessary if you need to call foreign (non-Haskell) libraries that make use of thread-local state, such as OpenGL (see <a href="control-concurrent#boundthreads">Control.Concurrent</a>).</p>
<p>Using <code><a href="control-concurrent#v:forkOS" title="Control.Concurrent">forkOS</a></code> instead of <code><a href="control-concurrent#v:forkIO" title="Control.Concurrent">forkIO</a></code> makes no difference at all to the scheduling behaviour of the Haskell runtime system. It is a common misconception that you need to use <code><a href="control-concurrent#v:forkOS" title="Control.Concurrent">forkOS</a></code> instead of <code><a href="control-concurrent#v:forkIO" title="Control.Concurrent">forkIO</a></code> to avoid blocking all the Haskell threads when making a foreign call; this isn't the case. To allow foreign calls to be made without blocking all the Haskell threads (with GHC), it is only necessary to use the <code>-threaded</code> option when linking your program, and to make sure the foreign import is not marked <code>unsafe</code>.</p>
<p class="src"><a id="v:forkOSWithUnmask" class="def">forkOSWithUnmask</a> :: ((forall a. <a href="system-io#t:IO" title="System.IO">IO</a> a -&gt; <a href="system-io#t:IO" title="System.IO">IO</a> a) -&gt; <a href="system-io#t:IO" title="System.IO">IO</a> ()) -&gt; <a href="system-io#t:IO" title="System.IO">IO</a> <a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a> <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/Control-Concurrent.html#forkOSWithUnmask" class="link">Source</a> </p>
<p>Like <code><a href="control-concurrent#v:forkIOWithUnmask" title="Control.Concurrent">forkIOWithUnmask</a></code>, but the child thread is a bound thread, as with <code><a href="control-concurrent#v:forkOS" title="Control.Concurrent">forkOS</a></code>.</p>
<p class="src"><a id="v:isCurrentThreadBound" class="def">isCurrentThreadBound</a> :: <a href="system-io#t:IO" title="System.IO">IO</a> <a href="data-bool#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/Control-Concurrent.html#isCurrentThreadBound" class="link">Source</a> </p>
<p>Returns <code><a href="data-bool#v:True" title="Data.Bool">True</a></code> if the calling thread is <em>bound</em>, that is, if it is safe to use foreign libraries that rely on thread-local state from the calling thread.</p>
<p class="src"><a id="v:runInBoundThread" class="def">runInBoundThread</a> :: <a href="system-io#t:IO" title="System.IO">IO</a> a -&gt; <a href="system-io#t:IO" title="System.IO">IO</a> a <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/Control-Concurrent.html#runInBoundThread" class="link">Source</a> </p>
<p>Run the <code><a href="system-io#t:IO" title="System.IO">IO</a></code> computation passed as the first argument. If the calling thread is not <em>bound</em>, a bound thread is created temporarily. <code>runInBoundThread</code> doesn't finish until the <code><a href="system-io#t:IO" title="System.IO">IO</a></code> computation finishes.</p>
<p>You can wrap a series of foreign function calls that rely on thread-local state with <code>runInBoundThread</code> so that you can use them without knowing whether the current thread is <em>bound</em>.</p>
<p class="src"><a id="v:runInUnboundThread" class="def">runInUnboundThread</a> :: <a href="system-io#t:IO" title="System.IO">IO</a> a -&gt; <a href="system-io#t:IO" title="System.IO">IO</a> a <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/Control-Concurrent.html#runInUnboundThread" class="link">Source</a> </p>
<p>Run the <code><a href="system-io#t:IO" title="System.IO">IO</a></code> computation passed as the first argument. If the calling thread is <em>bound</em>, an unbound thread is created temporarily using <code><a href="control-concurrent#v:forkIO" title="Control.Concurrent">forkIO</a></code>. <code>runInBoundThread</code> doesn't finish until the <code><a href="system-io#t:IO" title="System.IO">IO</a></code> computation finishes.</p>
<p>Use this function <em>only</em> in the rare case that you have actually observed a performance loss due to the use of bound threads. A program that doesn't need its main thread to be bound and makes <em>heavy</em> use of concurrency (e.g. a web server), might want to wrap its <code>main</code> action in <code>runInUnboundThread</code>.</p>
<p>Note that exceptions which are thrown to the current thread are thrown in turn to the thread that is executing the given computation. This ensures there's always a way of killing the forked thread.</p>
<a href="#g:9" id="g:9"><h2>Weak references to ThreadIds</h2></a><p class="src"><a id="v:mkWeakThreadId" class="def">mkWeakThreadId</a> :: <a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a> -&gt; <a href="system-io#t:IO" title="System.IO">IO</a> (<a href="system-mem-weak#t:Weak" title="System.Mem.Weak">Weak</a> <a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a>) <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/GHC-Conc-Sync.html#mkWeakThreadId" class="link">Source</a> </p>
<p>Make a weak pointer to a <code><a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a></code>. It can be important to do this if you want to hold a reference to a <code><a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a></code> while still allowing the thread to receive the <code>BlockedIndefinitely</code> family of exceptions (e.g. <code><a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar" title="Control.Exception.Base">BlockedIndefinitelyOnMVar</a></code>). Holding a normal <code><a href="control-concurrent#t:ThreadId" title="Control.Concurrent">ThreadId</a></code> reference will prevent the delivery of <code>BlockedIndefinitely</code> exceptions because the reference could be used as the target of <code><a href="control-concurrent#v:throwTo" title="Control.Concurrent">throwTo</a></code> at any time, which would unblock the thread.</p>
<p>Holding a <code>Weak ThreadId</code>, on the other hand, will not prevent the thread from receiving <code>BlockedIndefinitely</code> exceptions. It is still possible to throw an exception to a <code>Weak ThreadId</code>, but the caller must use <code>deRefWeak</code> first to determine whether the thread still exists.</p>
<p><span class="version">Since: base-4.6.0.0</span></p>
<a href="#g:10" id="g:10"><h2>GHC's implementation of concurrency</h2></a><p>This section describes features specific to GHC's implementation of Concurrent Haskell.</p>
<a href="#g:11" id="g:11"><h3>Haskell threads and Operating System threads</h3></a><p> In GHC, threads created by <code><a href="control-concurrent#v:forkIO" title="Control.Concurrent">forkIO</a></code> are lightweight threads, and are managed entirely by the GHC runtime. Typically Haskell threads are an order of magnitude or two more efficient (in terms of both time and space) than operating system threads.</p>
<p>The downside of having lightweight threads is that only one can run at a time, so if one thread blocks in a foreign call, for example, the other threads cannot continue. The GHC runtime works around this by making use of full OS threads where necessary. When the program is built with the <code>-threaded</code> option (to link against the multithreaded version of the runtime), a thread making a <code>safe</code> foreign call will not block the other threads in the system; another OS thread will take over running Haskell threads until the original call returns. The runtime maintains a pool of these <em>worker</em> threads so that multiple Haskell threads can be involved in external calls simultaneously.</p>
<p>The <a href="system-io">System.IO</a> library manages multiplexing in its own way. On Windows systems it uses <code>safe</code> foreign calls to ensure that threads doing I/O operations don't block the whole runtime, whereas on Unix systems all the currently blocked I/O requests are managed by a single thread (the <em>IO manager thread</em>) using a mechanism such as <code>epoll</code> or <code>kqueue</code>, depending on what is provided by the host operating system.</p>
<p>The runtime will run a Haskell thread using any of the available worker OS threads. If you need control over which particular OS thread is used to run a given Haskell thread, perhaps because you need to call a foreign library that uses OS-thread-local state, then you need bound threads (see <a href="control-concurrent#boundthreads">Control.Concurrent</a>).</p>
<p>If you don't use the <code>-threaded</code> option, then the runtime does not make use of multiple OS threads. Foreign calls will block all other running Haskell threads until the call returns. The <a href="system-io">System.IO</a> library still does multiplexing, so there can be multiple threads doing I/O, and this is handled internally by the runtime using <code>select</code>.</p>
<a href="#g:12" id="g:12"><h3>Terminating the program</h3></a><p>In a standalone GHC program, only the main thread is required to terminate in order for the process to terminate. Thus all other forked threads will simply terminate at the same time as the main thread (the terminology for this kind of behaviour is "daemonic threads").</p>
<p>If you want the program to wait for child threads to finish before exiting, you need to program this yourself. A simple mechanism is to have each child thread write to an <code><a href="control-concurrent-mvar#t:MVar" title="Control.Concurrent.MVar">MVar</a></code> when it completes, and have the main thread wait on all the <code><a href="control-concurrent-mvar#t:MVar" title="Control.Concurrent.MVar">MVar</a></code>s before exiting:</p>
<pre>  myForkIO :: IO () -&gt; IO (MVar ())
  myForkIO io = do
    mvar &lt;- newEmptyMVar
    forkFinally io (\_ -&gt; putMVar mvar ())
    return mvar</pre>
<p>Note that we use <code><a href="control-concurrent#v:forkFinally" title="Control.Concurrent">forkFinally</a></code> to make sure that the <code><a href="control-concurrent-mvar#t:MVar" title="Control.Concurrent.MVar">MVar</a></code> is written to even if the thread dies or is killed for some reason.</p>
<p>A better method is to keep a global list of all child threads which we should wait for at the end of the program:</p>
<pre>   children :: MVar [MVar ()]
   children = unsafePerformIO (newMVar [])

   waitForChildren :: IO ()
   waitForChildren = do
     cs &lt;- takeMVar children
     case cs of
       []   -&gt; return ()
       m:ms -&gt; do
          putMVar children ms
          takeMVar m
          waitForChildren

   forkChild :: IO () -&gt; IO ThreadId
   forkChild io = do
       mvar &lt;- newEmptyMVar
       childs &lt;- takeMVar children
       putMVar children (mvar:childs)
       forkFinally io (\_ -&gt; putMVar mvar ())

    main =
      later waitForChildren $
      ...</pre>
<p>The main thread principle also applies to calls to Haskell from outside, using <code>foreign export</code>. When the <code>foreign export</code>ed function is invoked, it starts a new main thread, and it returns when this main thread terminates. If the call causes new threads to be forked, they may remain in the system after the <code>foreign export</code>ed function has returned.</p>
<a href="#g:13" id="g:13"><h3>Pre-emption</h3></a><p>GHC implements pre-emptive multitasking: the execution of threads are interleaved in a random fashion. More specifically, a thread may be pre-empted whenever it allocates some memory, which unfortunately means that tight loops which do no allocation tend to lock out other threads (this only seems to happen with pathological benchmark-style code, however).</p>
<p>The rescheduling timer runs on a 20ms granularity by default, but this may be altered using the <code>-i&lt;n&gt;</code> RTS option. After a rescheduling "tick" the running thread is pre-empted as soon as possible.</p>
<p>One final note: the <code>aaaa</code> <code>bbbb</code> example may not work too well on GHC (see Scheduling, above), due to the locking on a <code><a href="system-io#v:Handle" title="System.IO">Handle</a></code>. Only one thread may hold the lock on a <code><a href="system-io#v:Handle" title="System.IO">Handle</a></code> at any one time, so if a reschedule happens while a thread is holding the lock, the other thread won't be able to run. The upshot is that the switch from <code>aaaa</code> to <code>bbbbb</code> happens infrequently. It can be improved by lowering the reschedule tick period. We also have a patch that causes a reschedule whenever a thread waiting on a lock is woken up, but haven't found it to be useful for anything other than this example :-)</p>
<a href="#g:14" id="g:14"><h3>Deadlock</h3></a><p>GHC attempts to detect when threads are deadlocked using the garbage collector. A thread that is not reachable (cannot be found by following pointers from live objects) must be deadlocked, and in this case the thread is sent an exception. The exception is either <code><a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar" title="Control.Exception.Base">BlockedIndefinitelyOnMVar</a></code>, <code><a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM" title="Control.Exception.Base">BlockedIndefinitelyOnSTM</a></code>, <code><a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:NonTermination" title="Control.Exception.Base">NonTermination</a></code>, or <code><a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:Deadlock" title="Control.Exception.Base">Deadlock</a></code>, depending on the way in which the thread is deadlocked.</p>
<p>Note that this feature is intended for debugging, and should not be relied on for the correct operation of your program. There is no guarantee that the garbage collector will be accurate enough to detect your deadlock, and no guarantee that the garbage collector will run in a timely enough manner. Basically, the same caveats as for finalizers apply to deadlock detection.</p>
<p>There is a subtle interaction between deadlock detection and finalizers (as created by <code><a href="foreign-concurrent#v:newForeignPtr" title="Foreign.Concurrent">newForeignPtr</a></code> or the functions in <a href="system-mem-weak">System.Mem.Weak</a>): if a thread is blocked waiting for a finalizer to run, then the thread will be considered deadlocked and sent an exception. So preferably don't do this, but if you have no alternative then it is possible to prevent the thread from being considered deadlocked by making a <code><a href="foreign-stableptr#t:StablePtr" title="Foreign.StablePtr">StablePtr</a></code> pointing to it. Don't forget to release the <code><a href="foreign-stableptr#t:StablePtr" title="Foreign.StablePtr">StablePtr</a></code> later with <code><a href="foreign-stableptr#v:freeStablePtr" title="Foreign.StablePtr">freeStablePtr</a></code>.</p>
</div>
<div class="_attribution">
  <p class="_attribution-p">
     The University of Glasgow and others<br>Licensed under a BSD-style license (see top of the page).<br>
    <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Concurrent.html" class="_attribution-link">https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Concurrent.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
