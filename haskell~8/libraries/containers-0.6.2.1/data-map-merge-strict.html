
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Data.Map.Merge.Strict - Haskell 8 - W3cubDocs</title>
  
  <meta name="description" content="This module defines an API for writing functions that merge two maps. The key functions are merge and mergeA. Each of these can be used with several &hellip;">
  <meta name="keywords" content="data, map, merge, strict, haskell, haskell~8">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/haskell~8/libraries/containers-0.6.2.1/data-map-merge-strict.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/haskell~8.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/haskell~8/" class="_nav-link" title="" style="margin-left:0;">Haskell 8</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _haskell">
				
				
<h1 class="caption">Data.Map.Merge.Strict</h1>
<div class="_haskell-api">
<table class="info">
<tr>
<th valign="top">Copyright</th>
<td>(c) David Feuer 2016</td>
</tr>
<tr>
<th>License</th>
<td>BSD-style</td>
</tr>
<tr>
<th>Maintainer</th>
<td>libraries@haskell.org</td>
</tr>
<tr>
<th>Portability</th>
<td>portable</td>
</tr>
<tr>
<th>Safe Haskell</th>
<td>Safe</td>
</tr>
<tr>
<th>Language</th>
<td>Haskell98</td>
</tr>
</table>
<div id="table-of-contents"><div id="contents-list">
<h4 class="caption" onclick="window.scrollTo(0,0)">Contents</h4>
<ul>
<li><a href="#g:1">Simple merge tactic types</a></li>
<li>
<a href="#g:2">General combining function</a><ul>
<li><a href="#g:3"><code>WhenMatched</code> tactics</a></li>
<li><a href="#g:4"><code>WhenMissing</code> tactics</a></li>
</ul>
</li>
<li><a href="#g:5">Applicative merge tactic types</a></li>
<li>
<a href="#g:6">Applicative general combining function</a><ul>
<li><a href="#g:7"><code>WhenMatched</code> tactics</a></li>
<li><a href="#g:8"><code>WhenMissing</code> tactics</a></li>
</ul>
</li>
<li><a href="#g:9">Covariant maps for tactics</a></li>
<li><a href="#g:10">Miscellaneous functions on tactics</a></li>
</ul>
</div></div>
<div id="description">
<h4 class="caption">Description</h4>
<p>This module defines an API for writing functions that merge two maps. The key functions are <code><a href="data-map-merge-strict#v:merge" title="Data.Map.Merge.Strict">merge</a></code> and <code><a href="data-map-merge-strict#v:mergeA" title="Data.Map.Merge.Strict">mergeA</a></code>. Each of these can be used with several different "merge tactics".</p>
<p>The <code><a href="data-map-merge-strict#v:merge" title="Data.Map.Merge.Strict">merge</a></code> and <code><a href="data-map-merge-strict#v:mergeA" title="Data.Map.Merge.Strict">mergeA</a></code> functions are shared by the lazy and strict modules. Only the choice of merge tactics determines strictness. If you use <code><a href="data-map-merge-strict#v:mapMissing" title="Data.Map.Merge.Strict">mapMissing</a></code> from this module then the results will be forced before they are inserted. If you use <code><a href="data-map-merge-lazy#v:mapMissing" title="Data.Map.Merge.Lazy">mapMissing</a></code> from <a href="data-map-merge-lazy">Data.Map.Merge.Lazy</a> then they will not.</p>
<h3>
<code><a href="data-map-merge-strict#v:preserveMissing" title="Data.Map.Merge.Strict">preserveMissing</a></code> inconsistency</h3>
<p>For historical reasons, the preserved values are /<em>not</em>/ forced. To force them, use <code><a href="data-map-merge-strict#v:preserveMissing-39-" title="Data.Map.Merge.Strict">preserveMissing'</a></code>.</p>
<h3>Efficiency note</h3>
<p>The <code><a href="../base-4.13.0.0/control-category#v:Category" title="Control.Category">Category</a></code>, <code><a href="../base-4.13.0.0/control-applicative#t:Applicative" title="Control.Applicative">Applicative</a></code>, and <code><a href="../base-4.13.0.0/control-monad#t:Monad" title="Control.Monad">Monad</a></code> instances for <code><a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a></code> tactics are included because they are valid. However, they are inefficient in many cases and should usually be avoided. The instances for <code><a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a></code> tactics should not pose any major efficiency problems.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
</div>
<a href="#g:1" id="g:1"><h3>Simple merge tactic types</h3></a><p class="src">type <a id="t:SimpleWhenMissing" class="def">SimpleWhenMissing</a> = <a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity" title="Data.Map.Internal">Identity</a> <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/src/Data-Map-Internal.html#SimpleWhenMissing" class="link">Source</a> </p>
<p>A tactic for dealing with keys present in one map but not the other in <code><a href="data-map-merge-strict#v:merge" title="Data.Map.Merge.Strict">merge</a></code>.</p>
<p>A tactic of type <code> SimpleWhenMissing k x z </code> is an abstract representation of a function of type <code> k -&gt; x -&gt; Maybe z </code>.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
<p class="src">type <a id="t:SimpleWhenMatched" class="def">SimpleWhenMatched</a> = <a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity" title="Data.Map.Internal">Identity</a> <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/src/Data-Map-Internal.html#SimpleWhenMatched" class="link">Source</a> </p>
<p>A tactic for dealing with keys present in both maps in <code><a href="data-map-merge-strict#v:merge" title="Data.Map.Merge.Strict">merge</a></code>.</p>
<p>A tactic of type <code> SimpleWhenMatched k x y z </code> is an abstract representation of a function of type <code> k -&gt; x -&gt; y -&gt; Maybe z </code>.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
<a href="#g:2" id="g:2"><h3>General combining function</h3></a><p class="src"><a id="v:merge" class="def">merge</a> <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/src/Data-Map-Internal.html#merge" class="link">Source</a> </p>
<div class="subs arguments">
<h4 class="caption">Arguments</h4>
<table>
<tr>
<td class="src">:: <a href="../base-4.13.0.0/data-ord#t:Ord" title="Data.Ord">Ord</a> k</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src">=&gt; <a href="data-map-merge-strict#t:SimpleWhenMissing" title="Data.Map.Merge.Strict">SimpleWhenMissing</a> k a c</td>
<td class="doc"><p>What to do with keys in <code>m1</code> but not <code>m2</code></p></td>
</tr>
<tr>
<td class="src">-&gt; <a href="data-map-merge-strict#t:SimpleWhenMissing" title="Data.Map.Merge.Strict">SimpleWhenMissing</a> k b c</td>
<td class="doc"><p>What to do with keys in <code>m2</code> but not <code>m1</code></p></td>
</tr>
<tr>
<td class="src">-&gt; <a href="data-map-merge-strict#t:SimpleWhenMatched" title="Data.Map.Merge.Strict">SimpleWhenMatched</a> k a b c</td>
<td class="doc"><p>What to do with keys in both <code>m1</code> and <code>m2</code></p></td>
</tr>
<tr>
<td class="src">-&gt; <a href="data-map-strict#t:Map" title="Data.Map.Strict">Map</a> k a</td>
<td class="doc"><p>Map <code>m1</code></p></td>
</tr>
<tr>
<td class="src">-&gt; <a href="data-map-strict#t:Map" title="Data.Map.Strict">Map</a> k b</td>
<td class="doc"><p>Map <code>m2</code></p></td>
</tr>
<tr>
<td class="src">-&gt; <a href="data-map-strict#t:Map" title="Data.Map.Strict">Map</a> k c</td>
<td class="doc empty"> </td>
</tr>
</table>
</div>
<p>Merge two maps.</p>
<p><code><a href="data-map-merge-strict#v:merge" title="Data.Map.Merge.Strict">merge</a></code> takes two <code><a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a></code> tactics, a <code><a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a></code> tactic and two maps. It uses the tactics to merge the maps. Its behavior is best understood via its fundamental tactics, <code><a href="data-map-merge-lazy#v:mapMaybeMissing" title="Data.Map.Merge.Lazy">mapMaybeMissing</a></code> and <code><a href="data-map-merge-lazy#v:zipWithMaybeMatched" title="Data.Map.Merge.Lazy">zipWithMaybeMatched</a></code>.</p>
<p>Consider</p>
<pre>merge (mapMaybeMissing g1)
             (mapMaybeMissing g2)
             (zipWithMaybeMatched f)
             m1 m2
</pre>
<p>Take, for example,</p>
<pre>m1 = [(0, 'a'), (1, 'b'), (3, 'c'), (4, 'd')]
m2 = [(1, "one"), (2, "two"), (4, "three")]
</pre>
<p><code><a href="data-map-merge-strict#v:merge" title="Data.Map.Merge.Strict">merge</a></code> will first "align" these maps by key:</p>
<pre>m1 = [(0, 'a'), (1, 'b'),               (3, 'c'), (4, 'd')]
m2 =           [(1, "one"), (2, "two"),           (4, "three")]
</pre>
<p>It will then pass the individual entries and pairs of entries to <code>g1</code>, <code>g2</code>, or <code>f</code> as appropriate:</p>
<pre>maybes = [g1 0 'a', f 1 'b' "one", g2 2 "two", g1 3 'c', f 4 'd' "three"]
</pre>
<p>This produces a <code><a href="../base-4.13.0.0/data-maybe#t:Maybe" title="Data.Maybe">Maybe</a></code> for each key:</p>
<pre>keys =     0        1          2           3        4
results = [Nothing, Just True, Just False, Nothing, Just True]
</pre>
<p>Finally, the <code>Just</code> results are collected into a map:</p>
<pre>return value = [(1, True), (2, False), (4, True)]
</pre>
<p>The other tactics below are optimizations or simplifications of <code><a href="data-map-merge-lazy#v:mapMaybeMissing" title="Data.Map.Merge.Lazy">mapMaybeMissing</a></code> for special cases. Most importantly,</p>
<ul>
<li>
<code><a href="data-map-merge-strict#v:dropMissing" title="Data.Map.Merge.Strict">dropMissing</a></code> drops all the keys.</li>
<li>
<code><a href="data-map-merge-strict#v:preserveMissing" title="Data.Map.Merge.Strict">preserveMissing</a></code> leaves all the entries alone.</li>
</ul>
<p>When <code><a href="data-map-merge-strict#v:merge" title="Data.Map.Merge.Strict">merge</a></code> is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should typically use <code><a href="data-map-merge-strict#v:merge" title="Data.Map.Merge.Strict">merge</a></code> to define your custom combining functions.</p>
<p>Examples:</p>
<pre>unionWithKey f = merge preserveMissing preserveMissing (zipWithMatched f)</pre>
<pre>intersectionWithKey f = merge dropMissing dropMissing (zipWithMatched f)</pre>
<pre>differenceWith f = merge preserveMissing dropMissing (zipWithMatched f)</pre>
<pre>symmetricDifference = merge preserveMissing preserveMissing (zipWithMaybeMatched $ \ _ _ _ -&gt; Nothing)</pre>
<pre>mapEachPiece f g h = merge (mapMissing f) (mapMissing g) (zipWithMatched h)</pre>
<p><span class="version">Since: containers-0.5.9</span></p>
<a href="#g:3" id="g:3"><h4>
<code>WhenMatched</code> tactics</h4></a><p class="src"><a id="v:zipWithMaybeMatched" class="def">zipWithMaybeMatched</a> :: <a href="../base-4.13.0.0/control-applicative#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (k -&gt; x -&gt; y -&gt; <a href="../base-4.13.0.0/data-maybe#t:Maybe" title="Data.Maybe">Maybe</a> z) -&gt; <a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y z <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/src/Data-Map-Strict-Internal.html#zipWithMaybeMatched" class="link">Source</a> </p>
<p>When a key is found in both maps, apply a function to the key and values and maybe use the result in the merged map.</p>
<pre>zipWithMaybeMatched :: (k -&gt; x -&gt; y -&gt; Maybe z)
                    -&gt; SimpleWhenMatched k x y z
</pre>
<p class="src"><a id="v:zipWithMatched" class="def">zipWithMatched</a> :: <a href="../base-4.13.0.0/control-applicative#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (k -&gt; x -&gt; y -&gt; z) -&gt; <a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y z <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/src/Data-Map-Strict-Internal.html#zipWithMatched" class="link">Source</a> </p>
<p>When a key is found in both maps, apply a function to the key and values and use the result in the merged map.</p>
<pre>zipWithMatched :: (k -&gt; x -&gt; y -&gt; z)
               -&gt; SimpleWhenMatched k x y z
</pre>
<a href="#g:4" id="g:4"><h4>
<code>WhenMissing</code> tactics</h4></a><p class="src"><a id="v:mapMaybeMissing" class="def">mapMaybeMissing</a> :: <a href="../base-4.13.0.0/control-applicative#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (k -&gt; x -&gt; <a href="../base-4.13.0.0/data-maybe#t:Maybe" title="Data.Maybe">Maybe</a> y) -&gt; <a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x y <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/src/Data-Map-Strict-Internal.html#mapMaybeMissing" class="link">Source</a> </p>
<p>Map over the entries whose keys are missing from the other map, optionally removing some. This is the most powerful <code><a href="data-map-merge-strict#t:SimpleWhenMissing" title="Data.Map.Merge.Strict">SimpleWhenMissing</a></code> tactic, but others are usually more efficient.</p>
<pre>mapMaybeMissing :: (k -&gt; x -&gt; Maybe y) -&gt; SimpleWhenMissing k x y
</pre>
<pre>mapMaybeMissing f = traverseMaybeMissing (\k x -&gt; pure (f k x))</pre>
<p>but <code>mapMaybeMissing</code> uses fewer unnecessary <code><a href="../base-4.13.0.0/control-applicative#t:Applicative" title="Control.Applicative">Applicative</a></code> operations.</p>
<p class="src"><a id="v:dropMissing" class="def">dropMissing</a> :: <a href="../base-4.13.0.0/control-applicative#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; <a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x y <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/src/Data-Map-Internal.html#dropMissing" class="link">Source</a> </p>
<p>Drop all the entries whose keys are missing from the other map.</p>
<pre>dropMissing :: SimpleWhenMissing k x y
</pre>
<pre>dropMissing = mapMaybeMissing (\_ _ -&gt; Nothing)</pre>
<p>but <code>dropMissing</code> is much faster.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
<p class="src"><a id="v:preserveMissing" class="def">preserveMissing</a> :: <a href="../base-4.13.0.0/control-applicative#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; <a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x x <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/src/Data-Map-Internal.html#preserveMissing" class="link">Source</a> </p>
<p>Preserve, unchanged, the entries whose keys are missing from the other map.</p>
<pre>preserveMissing :: SimpleWhenMissing k x x
</pre>
<pre>preserveMissing = Merge.Lazy.mapMaybeMissing (\_ x -&gt; Just x)</pre>
<p>but <code>preserveMissing</code> is much faster.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
<p class="src"><a id="v:preserveMissing-39-" class="def">preserveMissing'</a> :: <a href="../base-4.13.0.0/control-applicative#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; <a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x x <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/src/Data-Map-Internal.html#preserveMissing%27" class="link">Source</a> </p>
<p>Force the entries whose keys are missing from the other map and otherwise preserve them unchanged.</p>
<pre>preserveMissing' :: SimpleWhenMissing k x x
</pre>
<pre>preserveMissing' = Merge.Lazy.mapMaybeMissing (\_ x -&gt; Just $! x)</pre>
<p>but <code>preserveMissing'</code> is quite a bit faster.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
<p class="src"><a id="v:mapMissing" class="def">mapMissing</a> :: <a href="../base-4.13.0.0/control-applicative#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (k -&gt; x -&gt; y) -&gt; <a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x y <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/src/Data-Map-Strict-Internal.html#mapMissing" class="link">Source</a> </p>
<p>Map over the entries whose keys are missing from the other map.</p>
<pre>mapMissing :: (k -&gt; x -&gt; y) -&gt; SimpleWhenMissing k x y
</pre>
<pre>mapMissing f = mapMaybeMissing (\k x -&gt; Just $ f k x)</pre>
<p>but <code>mapMissing</code> is somewhat faster.</p>
<p class="src"><a id="v:filterMissing" class="def">filterMissing</a> :: <a href="../base-4.13.0.0/control-applicative#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (k -&gt; x -&gt; <a href="../base-4.13.0.0/data-bool#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x x <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/src/Data-Map-Internal.html#filterMissing" class="link">Source</a> </p>
<p>Filter the entries whose keys are missing from the other map.</p>
<pre>filterMissing :: (k -&gt; x -&gt; Bool) -&gt; SimpleWhenMissing k x x
</pre>
<pre>filterMissing f = Merge.Lazy.mapMaybeMissing $ \k x -&gt; guard (f k x) *&gt; Just x</pre>
<p>but this should be a little faster.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
<a href="#g:5" id="g:5"><h3>Applicative merge tactic types</h3></a><p class="src">data <a id="t:WhenMissing" class="def">WhenMissing</a> f k x y <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/src/Data-Map-Internal.html#WhenMissing" class="link">Source</a> </p>
<p>A tactic for dealing with keys present in one map but not the other in <code><a href="data-map-merge-strict#v:merge" title="Data.Map.Merge.Strict">merge</a></code> or <code><a href="data-map-merge-strict#v:mergeA" title="Data.Map.Merge.Strict">mergeA</a></code>.</p>
<p>A tactic of type <code> WhenMissing f k x z </code> is an abstract representation of a function of type <code> k -&gt; x -&gt; f (Maybe z) </code>.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
<div class="subs instances">
<h5 class="instances details-toggle-control details-toggle" data-details-id="i:WhenMissing">Instances</h5>
<details id="i:WhenMissing" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table>
<tr>
<td class="src clearfix">
 (<a href="../base-4.13.0.0/control-applicative#t:Applicative" title="Control.Applicative">Applicative</a> f, <a href="../base-4.13.0.0/control-monad#t:Monad" title="Control.Monad">Monad</a> f) =&gt; <a href="../base-4.13.0.0/control-category#t:Category" title="Control.Category">Category</a> (<a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k :: <a href="../base-4.13.0.0/data-kind#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.13.0.0/data-kind#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.13.0.0/data-kind#t:Type" title="Data.Kind">Type</a>) </td>
<td class="doc"><p><span class="version">Since: containers-0.5.9</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:WhenMissing:Category:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:id">id</a> :: forall (a :: k0). <a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k a a <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/Control-Category.html#id" class="link">Source</a> </p>
<p class="src"><a href="#v:.">(.)</a> :: forall (b :: k0) (c :: k0) (a :: k0). <a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k b c -&gt; <a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k a b -&gt; <a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k a c <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/Control-Category.html#." class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 (<a href="../base-4.13.0.0/control-applicative#t:Applicative" title="Control.Applicative">Applicative</a> f, <a href="../base-4.13.0.0/control-monad#t:Monad" title="Control.Monad">Monad</a> f) =&gt; <a href="../base-4.13.0.0/control-monad#t:Monad" title="Control.Monad">Monad</a> (<a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x) </td>
<td class="doc">
<p>Equivalent to <code> ReaderT k (ReaderT x (MaybeT f)) </code>.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
</td>
</tr>
<tr><td colspan="2"><details id="i:id:WhenMissing:Monad:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:-62--62--61-">(&gt;&gt;=)</a> :: <a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x a -&gt; (a -&gt; <a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x b) -&gt; <a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x b <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/GHC-Base.html#%3E%3E%3D" class="link">Source</a> </p>
<p class="src"><a href="#v:-62--62-">(&gt;&gt;)</a> :: <a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x a -&gt; <a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x b -&gt; <a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x b <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/GHC-Base.html#%3E%3E" class="link">Source</a> </p>
<p class="src"><a href="#v:return">return</a> :: a -&gt; <a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x a <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/GHC-Base.html#return" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 (<a href="../base-4.13.0.0/control-applicative#t:Applicative" title="Control.Applicative">Applicative</a> f, <a href="../base-4.13.0.0/control-monad#t:Monad" title="Control.Monad">Monad</a> f) =&gt; <a href="../base-4.13.0.0/data-functor#t:Functor" title="Data.Functor">Functor</a> (<a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x) </td>
<td class="doc"><p><span class="version">Since: containers-0.5.9</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:WhenMissing:Functor:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:fmap">fmap</a> :: (a -&gt; b) -&gt; <a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x a -&gt; <a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x b <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/GHC-Base.html#fmap" class="link">Source</a> </p>
<p class="src"><a href="#v:-60--36-">(&lt;$)</a> :: a -&gt; <a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x b -&gt; <a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x a <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/GHC-Base.html#%3C%24" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 (<a href="../base-4.13.0.0/control-applicative#t:Applicative" title="Control.Applicative">Applicative</a> f, <a href="../base-4.13.0.0/control-monad#t:Monad" title="Control.Monad">Monad</a> f) =&gt; <a href="../base-4.13.0.0/control-applicative#t:Applicative" title="Control.Applicative">Applicative</a> (<a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x) </td>
<td class="doc">
<p>Equivalent to <code> ReaderT k (ReaderT x (MaybeT f)) </code>.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
</td>
</tr>
<tr><td colspan="2"><details id="i:id:WhenMissing:Applicative:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:pure">pure</a> :: a -&gt; <a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x a <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/GHC-Base.html#pure" class="link">Source</a> </p>
<p class="src"><a href="#v:-60--42--62-">(&lt;*&gt;)</a> :: <a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x (a -&gt; b) -&gt; <a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x a -&gt; <a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x b <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/GHC-Base.html#%3C%2A%3E" class="link">Source</a> </p>
<p class="src"><a href="#v:liftA2">liftA2</a> :: (a -&gt; b -&gt; c) -&gt; <a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x a -&gt; <a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x b -&gt; <a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x c <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/GHC-Base.html#liftA2" class="link">Source</a> </p>
<p class="src"><a href="#v:-42--62-">(*&gt;)</a> :: <a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x a -&gt; <a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x b -&gt; <a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x b <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/GHC-Base.html#%2A%3E" class="link">Source</a> </p>
<p class="src"><a href="#v:-60--42-">(&lt;*)</a> :: <a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x a -&gt; <a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x b -&gt; <a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x a <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/GHC-Base.html#%3C%2A" class="link">Source</a> </p>
</div></details></td></tr>
</table></details>
</div>
<p class="src">data <a id="t:WhenMatched" class="def">WhenMatched</a> f k x y z <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/src/Data-Map-Internal.html#WhenMatched" class="link">Source</a> </p>
<p>A tactic for dealing with keys present in both maps in <code><a href="data-map-merge-strict#v:merge" title="Data.Map.Merge.Strict">merge</a></code> or <code><a href="data-map-merge-strict#v:mergeA" title="Data.Map.Merge.Strict">mergeA</a></code>.</p>
<p>A tactic of type <code> WhenMatched f k x y z </code> is an abstract representation of a function of type <code> k -&gt; x -&gt; y -&gt; f (Maybe z) </code>.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
<div class="subs instances">
<h5 class="instances details-toggle-control details-toggle" data-details-id="i:WhenMatched">Instances</h5>
<details id="i:WhenMatched" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table>
<tr>
<td class="src clearfix">
 (<a href="../base-4.13.0.0/control-monad#t:Monad" title="Control.Monad">Monad</a> f, <a href="../base-4.13.0.0/control-applicative#t:Applicative" title="Control.Applicative">Applicative</a> f) =&gt; <a href="../base-4.13.0.0/control-category#t:Category" title="Control.Category">Category</a> (<a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x :: <a href="../base-4.13.0.0/data-kind#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.13.0.0/data-kind#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.13.0.0/data-kind#t:Type" title="Data.Kind">Type</a>) </td>
<td class="doc"><p><span class="version">Since: containers-0.5.9</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:WhenMatched:Category:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:id">id</a> :: forall (a :: k0). <a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x a a <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/Control-Category.html#id" class="link">Source</a> </p>
<p class="src"><a href="#v:.">(.)</a> :: forall (b :: k0) (c :: k0) (a :: k0). <a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x b c -&gt; <a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x a b -&gt; <a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x a c <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/Control-Category.html#." class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 (<a href="../base-4.13.0.0/control-monad#t:Monad" title="Control.Monad">Monad</a> f, <a href="../base-4.13.0.0/control-applicative#t:Applicative" title="Control.Applicative">Applicative</a> f) =&gt; <a href="../base-4.13.0.0/control-monad#t:Monad" title="Control.Monad">Monad</a> (<a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y) </td>
<td class="doc">
<p>Equivalent to <code> ReaderT k (ReaderT x (ReaderT y (MaybeT f))) </code></p>
<p><span class="version">Since: containers-0.5.9</span></p>
</td>
</tr>
<tr><td colspan="2"><details id="i:id:WhenMatched:Monad:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:-62--62--61-">(&gt;&gt;=)</a> :: <a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y a -&gt; (a -&gt; <a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y b) -&gt; <a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y b <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/GHC-Base.html#%3E%3E%3D" class="link">Source</a> </p>
<p class="src"><a href="#v:-62--62-">(&gt;&gt;)</a> :: <a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y a -&gt; <a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y b -&gt; <a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y b <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/GHC-Base.html#%3E%3E" class="link">Source</a> </p>
<p class="src"><a href="#v:return">return</a> :: a -&gt; <a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y a <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/GHC-Base.html#return" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 <a href="../base-4.13.0.0/data-functor#t:Functor" title="Data.Functor">Functor</a> f =&gt; <a href="../base-4.13.0.0/data-functor#t:Functor" title="Data.Functor">Functor</a> (<a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y) </td>
<td class="doc"><p><span class="version">Since: containers-0.5.9</span></p></td>
</tr>
<tr><td colspan="2"><details id="i:id:WhenMatched:Functor:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:fmap">fmap</a> :: (a -&gt; b) -&gt; <a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y a -&gt; <a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y b <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/GHC-Base.html#fmap" class="link">Source</a> </p>
<p class="src"><a href="#v:-60--36-">(&lt;$)</a> :: a -&gt; <a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y b -&gt; <a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y a <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/GHC-Base.html#%3C%24" class="link">Source</a> </p>
</div></details></td></tr>
<tr>
<td class="src clearfix">
 (<a href="../base-4.13.0.0/control-monad#t:Monad" title="Control.Monad">Monad</a> f, <a href="../base-4.13.0.0/control-applicative#t:Applicative" title="Control.Applicative">Applicative</a> f) =&gt; <a href="../base-4.13.0.0/control-applicative#t:Applicative" title="Control.Applicative">Applicative</a> (<a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y) </td>
<td class="doc">
<p>Equivalent to <code> ReaderT k (ReaderT x (ReaderT y (MaybeT f))) </code></p>
<p><span class="version">Since: containers-0.5.9</span></p>
</td>
</tr>
<tr><td colspan="2"><details id="i:id:WhenMatched:Applicative:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a href="#v:pure">pure</a> :: a -&gt; <a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y a <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/GHC-Base.html#pure" class="link">Source</a> </p>
<p class="src"><a href="#v:-60--42--62-">(&lt;*&gt;)</a> :: <a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y (a -&gt; b) -&gt; <a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y a -&gt; <a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y b <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/GHC-Base.html#%3C%2A%3E" class="link">Source</a> </p>
<p class="src"><a href="#v:liftA2">liftA2</a> :: (a -&gt; b -&gt; c) -&gt; <a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y a -&gt; <a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y b -&gt; <a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y c <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/GHC-Base.html#liftA2" class="link">Source</a> </p>
<p class="src"><a href="#v:-42--62-">(*&gt;)</a> :: <a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y a -&gt; <a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y b -&gt; <a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y b <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/GHC-Base.html#%2A%3E" class="link">Source</a> </p>
<p class="src"><a href="#v:-60--42-">(&lt;*)</a> :: <a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y a -&gt; <a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y b -&gt; <a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y a <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/src/GHC-Base.html#%3C%2A" class="link">Source</a> </p>
</div></details></td></tr>
</table></details>
</div>
<a href="#g:6" id="g:6"><h3>Applicative general combining function</h3></a><p class="src"><a id="v:mergeA" class="def">mergeA</a> <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/src/Data-Map-Internal.html#mergeA" class="link">Source</a> </p>
<div class="subs arguments">
<h4 class="caption">Arguments</h4>
<table>
<tr>
<td class="src">:: (<a href="../base-4.13.0.0/control-applicative#t:Applicative" title="Control.Applicative">Applicative</a> f, <a href="../base-4.13.0.0/data-ord#t:Ord" title="Data.Ord">Ord</a> k)</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src">=&gt; <a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k a c</td>
<td class="doc"><p>What to do with keys in <code>m1</code> but not <code>m2</code></p></td>
</tr>
<tr>
<td class="src">-&gt; <a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k b c</td>
<td class="doc"><p>What to do with keys in <code>m2</code> but not <code>m1</code></p></td>
</tr>
<tr>
<td class="src">-&gt; <a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k a b c</td>
<td class="doc"><p>What to do with keys in both <code>m1</code> and <code>m2</code></p></td>
</tr>
<tr>
<td class="src">-&gt; <a href="data-map-strict#t:Map" title="Data.Map.Strict">Map</a> k a</td>
<td class="doc"><p>Map <code>m1</code></p></td>
</tr>
<tr>
<td class="src">-&gt; <a href="data-map-strict#t:Map" title="Data.Map.Strict">Map</a> k b</td>
<td class="doc"><p>Map <code>m2</code></p></td>
</tr>
<tr>
<td class="src">-&gt; f (<a href="data-map-strict#t:Map" title="Data.Map.Strict">Map</a> k c)</td>
<td class="doc empty"> </td>
</tr>
</table>
</div>
<p>An applicative version of <code><a href="data-map-merge-strict#v:merge" title="Data.Map.Merge.Strict">merge</a></code>.</p>
<p><code><a href="data-map-merge-strict#v:mergeA" title="Data.Map.Merge.Strict">mergeA</a></code> takes two <code><a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a></code> tactics, a <code><a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a></code> tactic and two maps. It uses the tactics to merge the maps. Its behavior is best understood via its fundamental tactics, <code><a href="data-map-merge-lazy#v:traverseMaybeMissing" title="Data.Map.Merge.Lazy">traverseMaybeMissing</a></code> and <code><a href="data-map-merge-lazy#v:zipWithMaybeAMatched" title="Data.Map.Merge.Lazy">zipWithMaybeAMatched</a></code>.</p>
<p>Consider</p>
<pre>mergeA (traverseMaybeMissing g1)
              (traverseMaybeMissing g2)
              (zipWithMaybeAMatched f)
              m1 m2
</pre>
<p>Take, for example,</p>
<pre>m1 = [(0, 'a'), (1, 'b'), (3, 'c'), (4, 'd')]
m2 = [(1, "one"), (2, "two"), (4, "three")]
</pre>
<p><code>mergeA</code> will first "align" these maps by key:</p>
<pre>m1 = [(0, 'a'), (1, 'b'),               (3, 'c'), (4, 'd')]
m2 =           [(1, "one"), (2, "two"),           (4, "three")]
</pre>
<p>It will then pass the individual entries and pairs of entries to <code>g1</code>, <code>g2</code>, or <code>f</code> as appropriate:</p>
<pre>actions = [g1 0 'a', f 1 'b' "one", g2 2 "two", g1 3 'c', f 4 'd' "three"]
</pre>
<p>Next, it will perform the actions in the <code>actions</code> list in order from left to right.</p>
<pre>keys =     0        1          2           3        4
results = [Nothing, Just True, Just False, Nothing, Just True]
</pre>
<p>Finally, the <code>Just</code> results are collected into a map:</p>
<pre>return value = [(1, True), (2, False), (4, True)]
</pre>
<p>The other tactics below are optimizations or simplifications of <code><a href="data-map-merge-lazy#v:traverseMaybeMissing" title="Data.Map.Merge.Lazy">traverseMaybeMissing</a></code> for special cases. Most importantly,</p>
<ul>
<li>
<code><a href="data-map-merge-strict#v:dropMissing" title="Data.Map.Merge.Strict">dropMissing</a></code> drops all the keys.</li>
<li>
<code><a href="data-map-merge-strict#v:preserveMissing" title="Data.Map.Merge.Strict">preserveMissing</a></code> leaves all the entries alone.</li>
<li>
<code><a href="data-map-merge-lazy#v:mapMaybeMissing" title="Data.Map.Merge.Lazy">mapMaybeMissing</a></code> does not use the <code><a href="../base-4.13.0.0/control-applicative#t:Applicative" title="Control.Applicative">Applicative</a></code> context.</li>
</ul>
<p>When <code><a href="data-map-merge-strict#v:mergeA" title="Data.Map.Merge.Strict">mergeA</a></code> is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should generally only use <code><a href="data-map-merge-strict#v:mergeA" title="Data.Map.Merge.Strict">mergeA</a></code> to define custom combining functions.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
<a href="#g:7" id="g:7"><h4>
<code>WhenMatched</code> tactics</h4></a><p>The tactics described for <code><a href="data-map-merge-strict#v:merge" title="Data.Map.Merge.Strict">merge</a></code> work for <code><a href="data-map-merge-strict#v:mergeA" title="Data.Map.Merge.Strict">mergeA</a></code> as well. Furthermore, the following are available.</p>
<p class="src"><a id="v:zipWithMaybeAMatched" class="def">zipWithMaybeAMatched</a> :: <a href="../base-4.13.0.0/control-applicative#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (k -&gt; x -&gt; y -&gt; f (<a href="../base-4.13.0.0/data-maybe#t:Maybe" title="Data.Maybe">Maybe</a> z)) -&gt; <a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y z <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/src/Data-Map-Strict-Internal.html#zipWithMaybeAMatched" class="link">Source</a> </p>
<p>When a key is found in both maps, apply a function to the key and values, perform the resulting action, and maybe use the result in the merged map.</p>
<p>This is the fundamental <code><a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a></code> tactic.</p>
<p class="src"><a id="v:zipWithAMatched" class="def">zipWithAMatched</a> :: <a href="../base-4.13.0.0/control-applicative#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (k -&gt; x -&gt; y -&gt; f z) -&gt; <a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y z <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/src/Data-Map-Strict-Internal.html#zipWithAMatched" class="link">Source</a> </p>
<p>When a key is found in both maps, apply a function to the key and values to produce an action and use its result in the merged map.</p>
<a href="#g:8" id="g:8"><h4>
<code>WhenMissing</code> tactics</h4></a><p>The tactics described for <code><a href="data-map-merge-strict#v:merge" title="Data.Map.Merge.Strict">merge</a></code> work for <code><a href="data-map-merge-strict#v:mergeA" title="Data.Map.Merge.Strict">mergeA</a></code> as well. Furthermore, the following are available.</p>
<p class="src"><a id="v:traverseMaybeMissing" class="def">traverseMaybeMissing</a> :: <a href="../base-4.13.0.0/control-applicative#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (k -&gt; x -&gt; f (<a href="../base-4.13.0.0/data-maybe#t:Maybe" title="Data.Maybe">Maybe</a> y)) -&gt; <a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x y <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/src/Data-Map-Strict-Internal.html#traverseMaybeMissing" class="link">Source</a> </p>
<p>Traverse over the entries whose keys are missing from the other map, optionally producing values to put in the result. This is the most powerful <code><a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a></code> tactic, but others are usually more efficient.</p>
<p class="src"><a id="v:traverseMissing" class="def">traverseMissing</a> :: <a href="../base-4.13.0.0/control-applicative#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (k -&gt; x -&gt; f y) -&gt; <a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x y <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/src/Data-Map-Strict-Internal.html#traverseMissing" class="link">Source</a> </p>
<p>Traverse over the entries whose keys are missing from the other map.</p>
<p class="src"><a id="v:filterAMissing" class="def">filterAMissing</a> :: <a href="../base-4.13.0.0/control-applicative#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (k -&gt; x -&gt; f <a href="../base-4.13.0.0/data-bool#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x x <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/src/Data-Map-Internal.html#filterAMissing" class="link">Source</a> </p>
<p>Filter the entries whose keys are missing from the other map using some <code><a href="../base-4.13.0.0/control-applicative#t:Applicative" title="Control.Applicative">Applicative</a></code> action.</p>
<pre>filterAMissing f = Merge.Lazy.traverseMaybeMissing $
  k x -&gt; (b -&gt; guard b *&gt; Just x) <a href="%24">$</a> f k x
</pre>
<p>but this should be a little faster.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
<a href="#g:9" id="g:9"><h3>Covariant maps for tactics</h3></a><p class="src"><a id="v:mapWhenMissing" class="def">mapWhenMissing</a> :: <a href="../base-4.13.0.0/data-functor#t:Functor" title="Data.Functor">Functor</a> f =&gt; (a -&gt; b) -&gt; <a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x a -&gt; <a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x b <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/src/Data-Map-Strict-Internal.html#mapWhenMissing" class="link">Source</a> </p>
<p>Map covariantly over a <code><a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x</code>.</p>
<p class="src"><a id="v:mapWhenMatched" class="def">mapWhenMatched</a> :: <a href="../base-4.13.0.0/data-functor#t:Functor" title="Data.Functor">Functor</a> f =&gt; (a -&gt; b) -&gt; <a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y a -&gt; <a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y b <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/src/Data-Map-Strict-Internal.html#mapWhenMatched" class="link">Source</a> </p>
<p>Map covariantly over a <code><a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y</code>.</p>
<a href="#g:10" id="g:10"><h3>Miscellaneous functions on tactics</h3></a><p class="src"><a id="v:runWhenMatched" class="def">runWhenMatched</a> :: <a href="data-map-merge-strict#t:WhenMatched" title="Data.Map.Merge.Strict">WhenMatched</a> f k x y z -&gt; k -&gt; x -&gt; y -&gt; f (<a href="../base-4.13.0.0/data-maybe#t:Maybe" title="Data.Maybe">Maybe</a> z) <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/src/Data-Map-Internal.html#runWhenMatched" class="link">Source</a> </p>
<p>Along with zipWithMaybeAMatched, witnesses the isomorphism between <code>WhenMatched f k x y z</code> and <code>k -&gt; x -&gt; y -&gt; f (Maybe z)</code>.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
<p class="src"><a id="v:runWhenMissing" class="def">runWhenMissing</a> :: <a href="data-map-merge-strict#t:WhenMissing" title="Data.Map.Merge.Strict">WhenMissing</a> f k x y -&gt; k -&gt; x -&gt; f (<a href="../base-4.13.0.0/data-maybe#t:Maybe" title="Data.Maybe">Maybe</a> y) <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/src/Data-Map-Internal.html#runWhenMissing" class="link">Source</a> </p>
<p>Along with traverseMaybeMissing, witnesses the isomorphism between <code>WhenMissing f k x y</code> and <code>k -&gt; x -&gt; f (Maybe y)</code>.</p>
<p><span class="version">Since: containers-0.5.9</span></p>
</div>
<div class="_attribution">
  <p class="_attribution-p">
     The University of Glasgow and others<br>Licensed under a BSD-style license (see top of the page).<br>
    <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Merge-Strict.html" class="_attribution-link">https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Merge-Strict.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
