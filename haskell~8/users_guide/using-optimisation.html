
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>8.3. Optimisation (Code Improvement) - Haskell 8 - W3cubDocs</title>
  
  <meta name="description" content="The -O&#42; options specify convenient “packages” of optimisation flags; the -f&#42; options described later on specify individual optimisations to &hellip;">
  <meta name="keywords" content="optimisation, code, improvement, haskell, haskell~8">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/haskell~8/users_guide/using-optimisation.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/haskell~8.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/haskell~8/" class="_nav-link" title="" style="margin-left:0;">Haskell 8</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _haskell">
				
				
<h1 id="options-optimise">8.3. Optimisation (code improvement)</h1>
<div class="_sphinx">   <p id="optimisation-code-improvement">The <code>-O*</code> options specify convenient “packages” of optimisation flags; the <code>-f*</code> options described later on specify <em>individual</em> optimisations to be turned on/off; the <code>-m*</code> options specify <em>machine-specific</em> optimisations to be turned on/off.</p> <p>Most of these options are boolean and have options to turn them both “on” and “off” (beginning with the prefix <code>no-</code>). For instance, while <code>-fspecialise</code> enables specialisation, <code>-fno-specialise</code> disables it. When multiple flags for the same option appear in the command-line they are evaluated from left to right. For instance, <code>-fno-specialise -fspecialise</code> will enable specialisation.</p> <p>It is important to note that the <code>-O*</code> flags are roughly equivalent to combinations of <code>-f*</code> flags. For this reason, the effect of the <code>-O*</code> and <code>-f*</code> flags is dependent upon the order in which they occur on the command line.</p> <p>For instance, take the example of <code>-fno-specialise -O1</code>. Despite the <code>-fno-specialise</code> appearing in the command line, specialisation will still be enabled. This is the case as <code>-O1</code> implies <code>-fspecialise</code>, overriding the previous flag. By contrast, <code>-O1 -fno-specialise</code> will compile without specialisation, as one would expect.</p>  <h2 id="optimise-pkgs">8.3.1. <code>-O*</code>: convenient “packages” of optimisation flags.</h2> <p id="o-convenient-packages-of-optimisation-flags">There are <em>many</em> options that affect the quality of code produced by GHC. Most people only have a general goal, something like “Compile quickly” or “Make my program run like greased lightning.” The following “packages” of optimisations (or lack thereof) should suffice.</p> <p>Note that higher optimisation levels cause more cross-module optimisation to be performed, which can have an impact on how much of your program needs to be recompiled when you change something. This is one reason to stick to no-optimisation when developing code.</p> <p><strong>No ``-O*``-type option specified:</strong> This is taken to mean “Please compile quickly; I’m not over-bothered about compiled-code quality.” So, for example, <code>ghc -c Foo.hs</code></p> <dl class="ghc-flag"> <dt id="ghc-flag--O0">
<code>-O0</code> </dt> <dd>
<p>Means “turn off all optimisation”, reverting to the same settings as if no <code>-O</code> options had been specified. Saying <code>-O0</code> can be useful if e.g. <code>make</code> has inserted a <code>-O</code> on the command line already.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--O">
<code>-O</code> </dt> <dt id="ghc-flag--O1">
<code>-O1</code> </dt> <dd>
<p id="index-1">Means: “Generate good-quality code without taking too long about it.” Thus, for example: <code>ghc -c -O Main.lhs</code></p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--O2">
<code>-O2</code> </dt> <dd>
<p id="index-2">Means: “Apply every non-dangerous optimisation, even if it means significantly longer compile times.”</p> <p>The avoided “dangerous” optimisations are those that can make runtime or space <em>worse</em> if you’re unlucky. They are normally turned on or off individually.</p> </dd>
</dl> <p>We don’t use a <code>-O*</code> flag for day-to-day work. We use <code>-O</code> to get respectable speed; e.g., when we want to measure something. When we want to go for broke, we tend to use <code>-O2</code> (and we go for lots of coffee breaks).</p> <p>The easiest way to see what <code>-O</code> (etc.) “really mean” is to run with <a class="reference internal" href="using#ghc-flag--v"><code>-v</code></a>, then stand back in amazement.</p>   <h2 id="options-f">8.3.2. <code>-f*</code>: platform-independent flags</h2> <p id="f-platform-independent-flags">These flags turn on and off individual optimisations. Flags marked as on by default are enabled by <code>-O</code>, and as such you shouldn’t need to set any of them explicitly. A flag <code>-fwombat</code> can be negated by saying <code>-fno-wombat</code>.</p> <dl class="ghc-flag"> <dt id="ghc-flag--fcase-merge">
<code>-fcase-merge</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">on</td> </tr>  </table> <p>Merge immediately-nested case expressions that scrutinise the same variable. For example,</p> <pre data-language="haskell">case x of
   Red -&gt; e1
   _   -&gt; case x of
            Blue -&gt; e2
            Green -&gt; e3
</pre> <p>Is transformed to,</p> <pre data-language="haskell">case x of
   Red -&gt; e1
   Blue -&gt; e2
   Green -&gt; e2
</pre> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fcase-folding">
<code>-fcase-folding</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">on</td> </tr>  </table> <p>Allow constant folding in case expressions that scrutinise some primops: For example,</p> <pre data-language="haskell">case x `minusWord#` 10## of
   10## -&gt; e1
   20## -&gt; e2
   v    -&gt; e3
</pre> <p>Is transformed to,</p> <pre data-language="haskell">case x of
   20## -&gt; e1
   30## -&gt; e2
   _    -&gt; let v = x `minusWord#` 10## in e3
</pre> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fcall-arity">
<code>-fcall-arity</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">on</td> </tr>  </table> <p>Enable call-arity analysis.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fexitification">
<code>-fexitification</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">on</td> </tr>  </table> <p>Enables the floating of exit paths out of recursive functions.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fcmm-elim-common-blocks">
<code>-fcmm-elim-common-blocks</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">on</td> </tr>  </table> <p>Enables the common block elimination optimisation in the code generator. This optimisation attempts to find identical Cmm blocks and eliminate the duplicates.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fcmm-sink">
<code>-fcmm-sink</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">on</td> </tr>  </table> <p>Enables the sinking pass in the code generator. This optimisation attempts to find identical Cmm blocks and eliminate the duplicates attempts to move variable bindings closer to their usage sites. It also inlines simple expressions like literals or registers.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fasm-shortcutting">
<code>-fasm-shortcutting</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">off</td> </tr>  </table> <p>This enables shortcutting at the assembly stage of the code generator. In simpler terms shortcutting means if a block of instructions A only consists of a unconditionally jump, we replace all jumps to A by jumps to the successor of A.</p> <p>This is mostly done during Cmm passes. However this can miss corner cases. So at -O2 we run the pass again at the asm stage to catch these.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fblock-layout-cfg">
<code>-fblock-layout-cfg</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">off but enabled with <a class="reference internal" href="#ghc-flag--O"><code>-O</code></a>.</td> </tr>  </table> <p>The new algorithm considers all outgoing edges of a basic blocks for code layout instead of only the last jump instruction. It also builds a control flow graph for functions, tries to find hot code paths and place them sequentially leading to better cache utilization and performance.</p> <p>This is expected to improve performance on average, but actual performance difference can vary.</p> <p>If you find cases of significant performance regressions, which can be traced back to obviously bad code layout please open a ticket.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fblock-layout-weights">
<code>-fblock-layout-weights</code> </dt> <dd>
<p>This flag is hacker territory. The main purpose of this flag is to make it easy to debug and tune the new code layout algorithm. There is no guarantee that values giving better results now won’t be worse with the next release.</p> <p>If you feel your code warrants modifying these settings please consult the source code for default values and documentation. But I strongly advise against this.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fblock-layout-weightless">
<code>-fblock-layout-weightless</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">off</td> </tr>  </table> <p>When not using the cfg based blocklayout layout is determined either by the last jump in a basic block or the heaviest outgoing edge of the block in the cfg.</p> <p>With this flag enabled we use the last jump instruction in blocks. Without this flags the old algorithm also uses the heaviest outgoing edge.</p> <p>When this flag is enabled and <a class="reference internal" href="#ghc-flag--fblock-layout-cfg"><code>-fblock-layout-cfg</code></a> is disabled block layout behaves the same as in 8.6 and earlier.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fcpr-anal">
<code>-fcpr-anal</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">on</td> </tr>  </table> <p>Turn on CPR analysis in the demand analyser.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fcse">
<code>-fcse</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">on</td> </tr>  </table> <p>Enables the common-sub-expression elimination optimisation. Switching this off can be useful if you have some <code>unsafePerformIO</code> expressions that you don’t want commoned-up.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fstg-cse">
<code>-fstg-cse</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">on</td> </tr>  </table> <p>Enables the common-sub-expression elimination optimisation on the STG intermediate language, where it is able to common up some subexpressions that differ in their types, but not their represetation.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fdicts-cheap">
<code>-fdicts-cheap</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">off</td> </tr>  </table> <p>A very experimental flag that makes dictionary-valued expressions seem cheap to the optimiser.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fdicts-strict">
<code>-fdicts-strict</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">off</td> </tr>  </table> <p>Make dictionaries strict.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fdmd-tx-dict-sel">
<code>-fdmd-tx-dict-sel</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">on</td> </tr>  </table> <p>Use a special demand transformer for dictionary selectors.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fdo-eta-reduction">
<code>-fdo-eta-reduction</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">on</td> </tr>  </table> <p>Eta-reduce lambda expressions, if doing so gets rid of a whole group of lambdas.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fdo-lambda-eta-expansion">
<code>-fdo-lambda-eta-expansion</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">on</td> </tr>  </table> <p>Eta-expand let-bindings to increase their arity.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--feager-blackholing">
<code>-feager-blackholing</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">off</td> </tr>  </table> <p>Usually GHC black-holes a thunk only when it switches threads. This flag makes it do so as soon as the thunk is entered. See <a class="reference external" href="http://community.haskell.org/~simonmar/papers/multiproc.pdf">Haskell on a shared-memory multiprocessor</a>.</p> <p>See <a class="reference internal" href="using-concurrent#parallel-compile-options"><span class="std std-ref">Compile-time options for SMP parallelism</span></a> for a dicussion on its use.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fexcess-precision">
<code>-fexcess-precision</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">off</td> </tr>  </table> <p>When this option is given, intermediate floating point values can have a <em>greater</em> precision/range than the final type. Generally this is a good thing, but some programs may rely on the exact precision/range of <code>Float</code>/<code>Double</code> values and should not use this option for their compilation.</p> <p>Note that the 32-bit x86 native code generator only supports excess-precision mode, so neither <code>-fexcess-precision</code> nor <code>-fno-excess-precision</code> has any effect. This is a known bug, see <a class="reference internal" href="bugs#bugs-ghc"><span class="std std-ref">Bugs in GHC</span></a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fexpose-all-unfoldings">
<code>-fexpose-all-unfoldings</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">off</td> </tr>  </table> <p>An experimental flag to expose all unfoldings, even for very large or recursive functions. This allows for all functions to be inlined while usually GHC would avoid inlining larger functions.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--ffloat-in">
<code>-ffloat-in</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">on</td> </tr>  </table> <p>Float let-bindings inwards, nearer their binding site. See <a class="reference external" href="http://research.microsoft.com/en-us/um/people/simonpj/papers/float.ps.gz">Let-floating: moving bindings to give faster programs (ICFP‘96)</a>.</p> <p>This optimisation moves let bindings closer to their use site. The benefit here is that this may avoid unnecessary allocation if the branch the let is now on is never executed. It also enables other optimisation passes to work more effectively as they have more information locally.</p> <p>This optimisation isn’t always beneficial though (so GHC applies some heuristics to decide when to apply it). The details get complicated but a simple example is that it is often beneficial to move let bindings outwards so that multiple let bindings can be grouped into a larger single let binding, effectively batching their allocation and helping the garbage collector and allocator.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--ffull-laziness">
<code>-ffull-laziness</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">on</td> </tr>  </table> <p>Run the full laziness optimisation (also known as let-floating), which floats let-bindings outside enclosing lambdas, in the hope they will be thereby be computed less often. See <a class="reference external" href="http://research.microsoft.com/en-us/um/people/simonpj/papers/float.ps.gz">Let-floating: moving bindings to give faster programs (ICFP‘96)</a>. Full laziness increases sharing, which can lead to increased memory residency.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">GHC doesn’t implement complete full-laziness. When optimisation in on, and <code>-fno-full-laziness</code> is not given, some transformations that increase sharing are performed, such as extracting repeated computations from a loop. These are the same transformations that a fully lazy implementation would do, the difference is that GHC doesn’t consistently apply full-laziness, so don’t rely on it.</p> </div> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--ffun-to-thunk">
<code>-ffun-to-thunk</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">off</td> </tr>  </table> <p>Worker-wrapper removes unused arguments, but usually we do not remove them all, lest it turn a function closure into a thunk, thereby perhaps creating a space leak and/or disrupting inlining. This flag allows worker/wrapper to remove <em>all</em> value lambdas.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fignore-asserts">
<code>-fignore-asserts</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">on</td> </tr>  </table> <p>Causes GHC to ignore uses of the function <code>Exception.assert</code> in source code (in other words, rewriting <code>Exception.assert p e</code> to <code>e</code> (see <a class="reference internal" href="glasgow_exts#assertions"><span class="std std-ref">Assertions</span></a>).</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fignore-interface-pragmas">
<code>-fignore-interface-pragmas</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">off</td> </tr>  </table> <p>Tells GHC to ignore all inessential information when reading interface files. That is, even if <code>M.hi</code> contains unfolding or strictness information for a function, GHC will ignore that information.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--flate-dmd-anal">
<code>-flate-dmd-anal</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">off</td> </tr>  </table> <p>Run demand analysis again, at the end of the simplification pipeline. We found some opportunities for discovering strictness that were not visible earlier; and optimisations like <a class="reference internal" href="#ghc-flag--fspec-constr"><code>-fspec-constr</code></a> can create functions with unused arguments which are eliminated by late demand analysis. Improvements are modest, but so is the cost. See notes on the <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/wikis/LateDmd">Trac wiki page</a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fliberate-case">
<code>-fliberate-case</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">off but enabled with <a class="reference internal" href="#ghc-flag--O2"><code>-O2</code></a>.</td> </tr>  </table> <p>Turn on the liberate-case transformation. This unrolls recursive function once in its own RHS, to avoid repeated case analysis of free variables. It’s a bit like the call-pattern specialiser (<a class="reference internal" href="#ghc-flag--fspec-constr"><code>-fspec-constr</code></a>) but for free variables rather than arguments.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fliberate-case-threshold=⟨n⟩">
<code>-fliberate-case-threshold=⟨n⟩</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">2000</td> </tr>  </table> <p>Set the size threshold for the liberate-case transformation.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--floopification">
<code>-floopification</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">on</td> </tr>  </table> <p>When this optimisation is enabled the code generator will turn all self-recursive saturated tail calls into local jumps rather than function calls.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fllvm-pass-vectors-in-regs">
<code>-fllvm-pass-vectors-in-regs</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">on</td> </tr>  </table> <p>Instructs GHC to use the platform’s native vector registers to pass vector arguments during function calls. As with all vector support, this requires <a class="reference internal" href="phases#ghc-flag--fllvm"><code>-fllvm</code></a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fmax-inline-alloc-size=⟨n⟩">
<code>-fmax-inline-alloc-size=⟨n⟩</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">128</td> </tr>  </table> <p>Set the maximum size of inline array allocations to n bytes. GHC will allocate non-pinned arrays of statically known size in the current nursery block if they’re no bigger than n bytes, ignoring GC overheap. This value should be quite a bit smaller than the block size (typically: 4096).</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fmax-inline-memcpy-insns=⟨n⟩">
<code>-fmax-inline-memcpy-insns=⟨n⟩</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">32</td> </tr>  </table> <p>Inline <code>memcpy</code> calls if they would generate no more than ⟨n⟩ pseudo-instructions.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fmax-inline-memset-insns=⟨n⟩">
<code>-fmax-inline-memset-insns=⟨n⟩</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">32</td> </tr>  </table> <p>Inline <code>memset</code> calls if they would generate no more than n pseudo instructions.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fmax-relevant-binds=⟨n⟩">
<code>-fmax-relevant-binds=⟨n⟩</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">6</td> </tr>  </table> <p>The type checker sometimes displays a fragment of the type environment in error messages, but only up to some maximum number, set by this flag. Turning it off with <code>-fno-max-relevant-bindings</code> gives an unlimited number. Syntactically top-level bindings are also usually excluded (since they may be numerous), but <code>-fno-max-relevant-bindings</code> includes them too.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fmax-uncovered-patterns=⟨n⟩">
<code>-fmax-uncovered-patterns=⟨n⟩</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">4</td> </tr>  </table> <p>Maximum number of unmatched patterns to be shown in warnings generated by <a class="reference internal" href="using-warnings#ghc-flag--Wincomplete-patterns"><code>-Wincomplete-patterns</code></a> and <a class="reference internal" href="using-warnings#ghc-flag--Wincomplete-uni-patterns"><code>-Wincomplete-uni-patterns</code></a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fmax-simplifier-iterations=⟨n⟩">
<code>-fmax-simplifier-iterations=⟨n⟩</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">4</td> </tr>  </table> <p>Sets the maximal number of iterations for the simplifier.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fmax-worker-args=⟨n⟩">
<code>-fmax-worker-args=⟨n⟩</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">10</td> </tr>  </table> <p>If a worker has that many arguments, none will be unpacked anymore.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fno-opt-coercion">
<code>-fno-opt-coercion</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">coercion optimisation enabled.</td> </tr>  </table> <p>Turn off the coercion optimiser.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fno-pre-inlining">
<code>-fno-pre-inlining</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">pre-inlining enabled</td> </tr>  </table> <p>Turn off pre-inlining.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fno-state-hack">
<code>-fno-state-hack</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">state hack is enabled</td> </tr>  </table> <p>Turn off the “state hack” whereby any lambda with a <code>State#</code> token as argument is considered to be single-entry, hence it is considered okay to inline things inside it. This can improve performance of IO and ST monad code, but it runs the risk of reducing sharing.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fomit-interface-pragmas">
<code>-fomit-interface-pragmas</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">Implied by <a class="reference internal" href="#ghc-flag--O0"><code>-O0</code></a>, otherwise off.</td> </tr>  </table> <p>Tells GHC to omit all inessential information from the interface file generated for the module being compiled (say M). This means that a module importing M will see only the <em>types</em> of the functions that M exports, but not their unfoldings, strictness info, etc. Hence, for example, no function exported by M will be inlined into an importing module. The benefit is that modules that import M will need to be recompiled less often (only when M’s exports change their type, not when they change their implementation).</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fomit-yields">
<code>-fomit-yields</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">yield points enabled</td> </tr>  </table> <p>Tells GHC to omit heap checks when no allocation is being performed. While this improves binary sizes by about 5%, it also means that threads run in tight non-allocating loops will not get preempted in a timely fashion. If it is important to always be able to interrupt such threads, you should turn this optimization off. Consider also recompiling all libraries with this optimization turned off, if you need to guarantee interruptibility.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fpedantic-bottoms">
<code>-fpedantic-bottoms</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">off</td> </tr>  </table> <p>Make GHC be more precise about its treatment of bottom (but see also <a class="reference internal" href="#ghc-flag--fno-state-hack"><code>-fno-state-hack</code></a>). In particular, stop GHC eta-expanding through a case expression, which is good for performance, but bad if you are using <code>seq</code> on partial applications.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fregs-graph">
<code>-fregs-graph</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">off due to a performance regression bug (<a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/7679">Issue #7679</a>)</td> </tr>  </table> <p><em>Only applies in combination with the native code generator.</em> Use the graph colouring register allocator for register allocation in the native code generator. By default, GHC uses a simpler, faster linear register allocator. The downside being that the linear register allocator usually generates worse code.</p> <p>Note that the graph colouring allocator is a bit experimental and may fail when faced with code with high register pressure <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/8657">Issue #8657</a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fregs-iterative">
<code>-fregs-iterative</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">off</td> </tr>  </table> <p><em>Only applies in combination with the native code generator.</em> Use the iterative coalescing graph colouring register allocator for register allocation in the native code generator. This is the same register allocator as the <a class="reference internal" href="#ghc-flag--fregs-graph"><code>-fregs-graph</code></a> one but also enables iterative coalescing during register allocation.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fsimplifier-phases=⟨n⟩">
<code>-fsimplifier-phases=⟨n⟩</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">2</td> </tr>  </table> <p>Set the number of phases for the simplifier. Ignored with <code>-O0</code>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fsimpl-tick-factor=⟨n⟩">
<code>-fsimpl-tick-factor=⟨n⟩</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">100</td> </tr>  </table> <p>GHC’s optimiser can diverge if you write rewrite rules (<a class="reference internal" href="glasgow_exts#rewrite-rules"><span class="std std-ref">Rewrite rules</span></a>) that don’t terminate, or (less satisfactorily) if you code up recursion through data types (<a class="reference internal" href="bugs#bugs-ghc"><span class="std std-ref">Bugs in GHC</span></a>). To avoid making the compiler fall into an infinite loop, the optimiser carries a “tick count” and stops inlining and applying rewrite rules when this count is exceeded. The limit is set as a multiple of the program size, so bigger programs get more ticks. The <code>-fsimpl-tick-factor</code> flag lets you change the multiplier. The default is 100; numbers larger than 100 give more ticks, and numbers smaller than 100 give fewer.</p> <p>If the tick-count expires, GHC summarises what simplifier steps it has done; you can use <code>-fddump-simpl-stats</code> to generate a much more detailed list. Usually that identifies the loop quite accurately, because some numbers are very large.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fspec-constr">
<code>-fspec-constr</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">off but enabled by <a class="reference internal" href="#ghc-flag--O2"><code>-O2</code></a>.</td> </tr>  </table> <p>Turn on call-pattern specialisation; see <a class="reference external" href="https://www.microsoft.com/en-us/research/publication/system-f-with-type-equality-coercions-2/">Call-pattern specialisation for Haskell programs</a>.</p> <p>This optimisation specializes recursive functions according to their argument “shapes”. This is best explained by example so consider:</p> <pre data-language="haskell">last :: [a] -&gt; a
last [] = error "last"
last (x : []) = x
last (x : xs) = last xs
</pre> <p>In this code, once we pass the initial check for an empty list we know that in the recursive case this pattern match is redundant. As such <code>-fspec-constr</code> will transform the above code to:</p> <pre data-language="haskell">last :: [a] -&gt; a
last []       = error "last"
last (x : xs) = last' x xs
    where
      last' x []       = x
      last' x (y : ys) = last' y ys
</pre> <p>As well avoid unnecessary pattern matching it also helps avoid unnecessary allocation. This applies when a argument is strict in the recursive call to itself but not on the initial entry. As strict recursive branch of the function is created similar to the above example.</p> <p>It is also possible for library writers to instruct GHC to perform call-pattern specialisation extremely aggressively. This is necessary for some highly optimized libraries, where we may want to specialize regardless of the number of specialisations, or the size of the code. As an example, consider a simplified use-case from the <code>vector</code> library:</p> <pre data-language="haskell">import GHC.Types (SPEC(..))

foldl :: (a -&gt; b -&gt; a) -&gt; a -&gt; Stream b -&gt; a
{-# INLINE foldl #-}
foldl f z (Stream step s _) = foldl_loop SPEC z s
  where
    foldl_loop !sPEC z s = case step s of
                            Yield x s' -&gt; foldl_loop sPEC (f z x) s'
                            Skip       -&gt; foldl_loop sPEC z s'
                            Done       -&gt; z
</pre> <p>Here, after GHC inlines the body of <code>foldl</code> to a call site, it will perform call-pattern specialisation very aggressively on <code>foldl_loop</code> due to the use of <code>SPEC</code> in the argument of the loop body. <code>SPEC</code> from <code>GHC.Types</code> is specifically recognised by the compiler.</p> <p>(NB: it is extremely important you use <code>seq</code> or a bang pattern on the <code>SPEC</code> argument!)</p> <p>In particular, after inlining this will expose <code>f</code> to the loop body directly, allowing heavy specialisation over the recursive cases.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fspec-constr-keen">
<code>-fspec-constr-keen</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">off</td> </tr>  </table> <p>If this flag is on, call-pattern specialisation will specialise a call <code>(f (Just x))</code> with an explicit constructor argument, even if the argument is not scrutinised in the body of the function. This is sometimes beneficial; e.g. the argument might be given to some other function that can itself be specialised.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fspec-constr-count=⟨n⟩">
<code>-fspec-constr-count=⟨n⟩</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">3</td> </tr>  </table> <p>Set the maximum number of specialisations that will be created for any one function by the SpecConstr transformation.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fspec-constr-threshold=⟨n⟩">
<code>-fspec-constr-threshold=⟨n⟩</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">2000</td> </tr>  </table> <p>Set the size threshold for the SpecConstr transformation.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fspecialise">
<code>-fspecialise</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">on</td> </tr>  </table> <p>Specialise each type-class-overloaded function defined in this module for the types at which it is called in this module. If <a class="reference internal" href="#ghc-flag--fcross-module-specialise"><code>-fcross-module-specialise</code></a> is set imported functions that have an INLINABLE pragma (<a class="reference internal" href="glasgow_exts#inlinable-pragma"><span class="std std-ref">INLINABLE pragma</span></a>) will be specialised as well.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fspecialise-aggressively">
<code>-fspecialise-aggressively</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">off</td> </tr>  </table> <p>By default only type class methods and methods marked <code>INLINABLE</code> or <code>INLINE</code> are specialised. This flag will specialise any overloaded function regardless of size if its unfolding is available. This flag is not included in any optimisation level as it can massively increase code size. It can be used in conjunction with <a class="reference internal" href="#ghc-flag--fexpose-all-unfoldings"><code>-fexpose-all-unfoldings</code></a> if you want to ensure all calls are specialised.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fcross-module-specialise">
<code>-fcross-module-specialise</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">on</td> </tr>  </table> <p>Specialise <code>INLINABLE</code> (<a class="reference internal" href="glasgow_exts#inlinable-pragma"><span class="std std-ref">INLINABLE pragma</span></a>) type-class-overloaded functions imported from other modules for the types at which they are called in this module. Note that specialisation must be enabled (by <code>-fspecialise</code>) for this to have any effect.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--flate-specialise">
<code>-flate-specialise</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">off</td> </tr>  </table> <p>Runs another specialisation pass towards the end of the optimisation pipeline. This can catch specialisation opportunities which arose from the previous specialisation pass or other inlining.</p> <p>You might want to use this if you are you have a type class method which returns a constrained type. For example, a type class where one of the methods implements a traversal.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fsolve-constant-dicts">
<code>-fsolve-constant-dicts</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">on</td> </tr>  </table> <p>When solving constraints, try to eagerly solve super classes using available dictionaries.</p> <p>For example:</p> <pre data-language="haskell">class M a b where m :: a -&gt; b

type C a b = (Num a, M a b)

f :: C Int b =&gt; b -&gt; Int -&gt; Int
f _ x = x + 1
</pre> <p>The body of <code>f</code> requires a <code>Num Int</code> instance. We could solve this constraint from the context because we have <code>C Int b</code> and that provides us a solution for <code>Num Int</code>. However, we can often produce much better code by directly solving for an available <code>Num Int</code> dictionary we might have at hand. This removes potentially many layers of indirection and crucially allows other optimisations to fire as the dictionary will be statically known and selector functions can be inlined.</p> <p>The optimisation also works for GADTs which bind dictionaries. If we statically know which class dictionary we need then we will solve it directly rather than indirectly using the one passed in at run time.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fstatic-argument-transformation">
<code>-fstatic-argument-transformation</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">off</td> </tr>  </table> <p>Turn on the static argument transformation, which turns a recursive function into a non-recursive one with a local recursive loop. See Chapter 7 of <a class="reference external" href="https://www.microsoft.com/en-us/research/publication/compilation-transformation-non-strict-functional-languages/">Andre Santos’s PhD thesis</a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fstg-lift-lams">
<code>-fstg-lift-lams</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">on</td> </tr>  </table> <p>Enables the late lambda lifting optimisation on the STG intermediate language. This selectively lifts local functions to top-level by converting free variables into function parameters.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fstg-lift-lams-known">
<code>-fstg-lift-lams-known</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">off</td> </tr>  </table> <p>Allow turning known into unknown calls while performing late lambda lifting. This is deemed non-beneficial, so it’s off by default.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fstg-lift-lams-non-rec-args">
<code>-fstg-lift-lams-non-rec-args</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">5</td> </tr>  </table> <p>Create top-level non-recursive functions with at most &lt;n&gt; parameters while performing late lambda lifting. The default is 5, the number of available parameter registers on x86_64.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fstg-lift-lams-rec-args">
<code>-fstg-lift-lams-rec-args</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">5</td> </tr>  </table> <p>Create top-level recursive functions with at most &lt;n&gt; parameters while performing late lambda lifting. The default is 5, the number of available parameter registers on x86_64.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fstrictness">
<code>-fstrictness</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">on</td> </tr>  </table> <p>Switch on the strictness analyser. The implementation is described in the paper <a class="reference external" href="https://www.microsoft.com/en-us/research/wp-content/uploads/2017/03/demand-jfp-draft.pdf">Theory and Practice of Demand Analysis in Haskell</a>.</p> <p>The strictness analyser figures out when arguments and variables in a function can be treated ‘strictly’ (that is they are always evaluated in the function at some point). This allow GHC to apply certain optimisations such as unboxing that otherwise don’t apply as they change the semantics of the program when applied to lazy arguments.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fstrictness-before=⟨n⟩">
<code>-fstrictness-before=⟨n⟩</code> </dt> <dd>
<p>Run an additional strictness analysis before simplifier phase ⟨n⟩.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--funbox-small-strict-fields">
<code>-funbox-small-strict-fields</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">on</td> </tr>  </table> <p id="index-4">This option causes all constructor fields which are marked strict (i.e. “!”) and which representation is smaller or equal to the size of a pointer to be unpacked, if possible. It is equivalent to adding an <code>UNPACK</code> pragma (see <a class="reference internal" href="glasgow_exts#unpack-pragma"><span class="std std-ref">UNPACK pragma</span></a>) to every strict constructor field that fulfils the size restriction.</p> <p>For example, the constructor fields in the following data types</p> <pre data-language="haskell">data A = A !Int
data B = B !A
newtype C = C B
data D = D !C
</pre> <p>would all be represented by a single <code>Int#</code> (see <a class="reference internal" href="glasgow_exts#primitives"><span class="std std-ref">Unboxed types and primitive operations</span></a>) value with <code>-funbox-small-strict-fields</code> enabled.</p> <p>This option is less of a sledgehammer than <code>-funbox-strict-fields</code>: it should rarely make things worse. If you use <code>-funbox-small-strict-fields</code> to turn on unboxing by default you can disable it for certain constructor fields using the <code>NOUNPACK</code> pragma (see <a class="reference internal" href="glasgow_exts#nounpack-pragma"><span class="std std-ref">NOUNPACK pragma</span></a>).</p> <p>Note that for consistency <code>Double</code>, <code>Word64</code>, and <code>Int64</code> constructor fields are unpacked on 32-bit platforms, even though they are technically larger than a pointer on those platforms.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--funbox-strict-fields">
<code>-funbox-strict-fields</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">off</td> </tr>  </table> <p id="index-5">This option causes all constructor fields which are marked strict (i.e. <code>!</code>) to be unpacked if possible. It is equivalent to adding an <code>UNPACK</code> pragma to every strict constructor field (see <a class="reference internal" href="glasgow_exts#unpack-pragma"><span class="std std-ref">UNPACK pragma</span></a>).</p> <p>This option is a bit of a sledgehammer: it might sometimes make things worse. Selectively unboxing fields by using <code>UNPACK</code> pragmas might be better. An alternative is to use <code>-funbox-strict-fields</code> to turn on unboxing by default but disable it for certain constructor fields using the <code>NOUNPACK</code> pragma (see <a class="reference internal" href="glasgow_exts#nounpack-pragma"><span class="std std-ref">NOUNPACK pragma</span></a>).</p> <p>Alternatively you can use <a class="reference internal" href="#ghc-flag--funbox-small-strict-fields"><code>-funbox-small-strict-fields</code></a> to only unbox strict fields which are “small”.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--funfolding-creation-threshold=⟨n⟩">
<code>-funfolding-creation-threshold=⟨n⟩</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">750</td> </tr>  </table> <p id="index-6">Governs the maximum size that GHC will allow a function unfolding to be. (An unfolding has a “size” that reflects the cost in terms of “code bloat” of expanding (aka inlining) that unfolding at a call site. A bigger function would be assigned a bigger cost.)</p> <p>Consequences:</p> <ol class="loweralpha simple"> <li>nothing larger than this will be inlined (unless it has an <code>INLINE</code> pragma)</li> <li>nothing larger than this will be spewed into an interface file.</li> </ol> <p>Increasing this figure is more likely to result in longer compile times than faster code. The <a class="reference internal" href="#ghc-flag--funfolding-use-threshold=%E2%9F%A8n%E2%9F%A9"><code>-funfolding-use-threshold=⟨n⟩</code></a> is more useful.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--funfolding-dict-discount=⟨n⟩">
<code>-funfolding-dict-discount=⟨n⟩</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">30</td> </tr>  </table> <p id="index-7">How eager should the compiler be to inline dictionaries?</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--funfolding-fun-discount=⟨n⟩">
<code>-funfolding-fun-discount=⟨n⟩</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">60</td> </tr>  </table> <p id="index-8">How eager should the compiler be to inline functions?</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--funfolding-keeness-factor=⟨n⟩">
<code>-funfolding-keeness-factor=⟨n⟩</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">1.5</td> </tr>  </table> <p id="index-9">How eager should the compiler be to inline functions?</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--funfolding-use-threshold=⟨n⟩">
<code>-funfolding-use-threshold=⟨n⟩</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">60</td> </tr>  </table> <p id="index-10">This is the magic cut-off figure for unfolding (aka inlining): below this size, a function definition will be unfolded at the call-site, any bigger and it won’t. The size computed for a function depends on two things: the actual size of the expression minus any discounts that apply depending on the context into which the expression is to be inlined.</p> <p>The difference between this and <a class="reference internal" href="#ghc-flag--funfolding-creation-threshold=%E2%9F%A8n%E2%9F%A9"><code>-funfolding-creation-threshold=⟨n⟩</code></a> is that this one determines if a function definition will be inlined <em>at a call site</em>. The other option determines if a function definition will be kept around at all for potential inlining.</p> </dd>
</dl>   </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2002–2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/users_guide/using-optimisation.html" class="_attribution-link">https://downloads.haskell.org/~ghc/8.8.3/docs/html/users_guide/using-optimisation.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
