
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>6. Using GHCi - Haskell 8 - W3cubDocs</title>
  
  <meta name="description" content="GHCi [1] is GHC’s interactive environment, in which Haskell expressions can be interactively evaluated and programs can be interpreted. If you’re &hellip;">
  <meta name="keywords" content="using, ghci, haskell, haskell~8">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/haskell~8/users_guide/ghci.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/haskell~8.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/haskell~8/" class="_nav-link" title="" style="margin-left:0;">Haskell 8</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _haskell">
				
				
<h1 id="ghci">6. Using GHCi</h1>
<div class="_sphinx">   <p id="using-ghci">GHCi <a class="footnote-reference" href="#id3" id="id1">[1]</a> is GHC’s interactive environment, in which Haskell expressions can be interactively evaluated and programs can be interpreted. If you’re familiar with <a class="reference external" href="http://www.haskell.org/hugs/">Hugs</a>, then you’ll be right at home with GHCi. However, GHCi also has support for interactively loading compiled code, as well as supporting all <a class="footnote-reference" href="#id4" id="id2">[2]</a> the language extensions that GHC provides. GHCi also includes an interactive debugger (see <a class="reference internal" href="#ghci-debugger"><span class="std std-ref">The GHCi Debugger</span></a>).</p> <table class="docutils footnote" frame="void" id="id3" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id1">[1]</a></td>
<td>The “i” stands for “Interactive”</td>
</tr>  </table> <table class="docutils footnote" frame="void" id="id4" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id2">[2]</a></td>
<td>except <code>foreign export</code>, at the moment</td>
</tr>  </table>  <h2 id="ghci-introduction">6.1. Introduction to GHCi</h2> <p id="introduction-to-ghci">Let’s start with an example GHCi session. You can fire up GHCi with the command <code>ghci</code>:</p> <pre data-language="none">$ ghci
GHCi, version 8.y.z: https://www.haskell.org/ghc/  :? for help
Prelude&gt;
</pre> <p>There may be a short pause while GHCi loads the prelude and standard libraries, after which the prompt is shown. As the banner says, you can type <a class="reference internal" href="#ghci-cmd-:?"><code>:?</code></a> to see the list of commands available, and a half line description of each of them. We’ll explain most of these commands as we go along, and there is complete documentation for all the commands in <a class="reference internal" href="#ghci-commands"><span class="std std-ref">GHCi commands</span></a>.</p> <p>Haskell expressions can be typed at the prompt:</p> <pre data-language="none">Prelude&gt; 1+2
3
Prelude&gt; let x = 42 in x / 9
4.666666666666667
Prelude&gt;
</pre> <p>GHCi interprets the whole line as an expression to evaluate. The expression may not span several lines - as soon as you press enter, GHCi will attempt to evaluate it.</p> <p>In Haskell, a <code>let</code> expression is followed by <code>in</code>. However, in GHCi, since the expression can also be interpreted in the <code>IO</code> monad, a <code>let</code> binding with no accompanying <code>in</code> statement can be signalled by an empty line, as in the above example.</p> <p>Since GHC 8.0.1, you can bind values and functions to names without <code>let</code> statement:</p> <pre data-language="none">Prelude&gt; x = 42
Prelude&gt; x
42
Prelude&gt;
</pre>   <h2 id="id5">6.2. Loading source files</h2> <p id="loading-source-files">Suppose we have the following Haskell source code, which we place in a file <code>Main.hs</code>:</p> <pre data-language="haskell">main = print (fac 20)

fac 0 = 1
fac n = n * fac (n-1)
</pre> <p>You can save <code>Main.hs</code> anywhere you like, but if you save it somewhere other than the current directory <a class="footnote-reference" href="#id7" id="id6">[3]</a> then we will need to change to the right directory in GHCi:</p> <pre data-language="none">Prelude&gt; :cd dir
</pre> <p>where ⟨dir⟩ is the directory (or folder) in which you saved <code>Main.hs</code>.</p> <p>To load a Haskell source file into GHCi, use the <a class="reference internal" href="#ghci-cmd-:load"><code>:load</code></a> command:</p> <pre data-language="none">Prelude&gt; :load Main
Compiling Main             ( Main.hs, interpreted )
Ok, modules loaded: Main.
*Main&gt;
</pre> <p>GHCi has loaded the <code>Main</code> module, and the prompt has changed to <code>*Main&gt;</code> to indicate that the current context for expressions typed at the prompt is the <code>Main</code> module we just loaded (we’ll explain what the <code>*</code> means later in <a class="reference internal" href="#ghci-scope"><span class="std std-ref">What’s really in scope at the prompt?</span></a>). So we can now type expressions involving the functions from <code>Main.hs</code>:</p> <pre data-language="none">*Main&gt; fac 17
355687428096000
</pre> <p>Loading a multi-module program is just as straightforward; just give the name of the “topmost” module to the <a class="reference internal" href="#ghci-cmd-:load"><code>:load</code></a> command (hint: <a class="reference internal" href="#ghci-cmd-:load"><code>:load</code></a> can be abbreviated to <code>:l</code>). The topmost module will normally be <code>Main</code>, but it doesn’t have to be. GHCi will discover which modules are required, directly or indirectly, by the topmost module, and load them all in dependency order.</p> <table class="docutils footnote" frame="void" id="id7" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id6">[3]</a></td>
<td>If you started up GHCi from the command line then GHCi’s current directory is the same as the current directory of the shell from which it was started. If you started GHCi from the “Start” menu in Windows, then the current directory is probably something like <code>C:\Documents and Settings\user name</code>.</td>
</tr>  </table> <dl class="ghc-flag"> <dt id="ghc-flag--fshow-loaded-modules">
<code>-fshow-loaded-modules</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">off</td> </tr> <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.2.2</td> </tr>  </table> <p>Typically GHCi will show only the number of modules that it loaded after a <a class="reference internal" href="#ghci-cmd-:load"><code>:load</code></a> command. With this flag, GHC will also list the loaded modules’ names. This was the default behavior prior to GHC 8.2.1 and can be useful for some tooling users.</p> </dd>
</dl>  <h3 id="ghci-modules-filenames">6.2.1. Modules vs. filenames</h3> <p id="modules-vs-filenames">Question: How does GHC find the filename which contains module ⟨M⟩? Answer: it looks for the file <code>M.hs</code>, or <code>M.lhs</code>. This means that for most modules, the module name must match the filename. If it doesn’t, GHCi won’t be able to find it.</p> <p>There is one exception to this general rule: when you load a program with <a class="reference internal" href="#ghci-cmd-:load"><code>:load</code></a>, or specify it when you invoke <code>ghci</code>, you can give a filename rather than a module name. This filename is loaded if it exists, and it may contain any module you like. This is particularly convenient if you have several <code>Main</code> modules in the same directory and you can’t call them all <code>Main.hs</code>.</p> <p>The search path for finding source files is specified with the <a class="reference internal" href="separate_compilation#ghc-flag--i"><code>-i</code></a> option on the GHCi command line, like so:</p> <pre data-language="none">ghci -idir1:...:dirn
</pre> <p>or it can be set using the <a class="reference internal" href="#ghci-cmd-:set"><code>:set</code></a> command from within GHCi (see <a class="reference internal" href="#ghci-cmd-line-options"><span class="std std-ref">Setting GHC command-line options in GHCi</span></a>) <a class="footnote-reference" href="#id9" id="id8">[4]</a></p> <p>One consequence of the way that GHCi follows dependencies to find modules to load is that every module must have a source file. The only exception to the rule is modules that come from a package, including the <code>Prelude</code> and standard libraries such as <code>IO</code> and <code>Complex</code>. If you attempt to load a module for which GHCi can’t find a source file, even if there are object and interface files for the module, you’ll get an error message.</p> <table class="docutils footnote" frame="void" id="id9" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id8">[4]</a></td>
<td>Note that in GHCi, and <a class="reference internal" href="using#ghc-flag---make"><code>--make</code></a> mode, the <a class="reference internal" href="separate_compilation#ghc-flag--i"><code>-i</code></a> option is used to specify the search path for <em>source</em> files, whereas in standard batch-compilation mode the <a class="reference internal" href="separate_compilation#ghc-flag--i"><code>-i</code></a> option is used to specify the search path for interface files, see <a class="reference internal" href="separate_compilation#search-path"><span class="std std-ref">The search path</span></a>.</td>
</tr>  </table>   <h3 id="making-changes-and-recompilation">6.2.2. Making changes and recompilation</h3> <p id="index-4">If you make some changes to the source code and want GHCi to recompile the program, give the <a class="reference internal" href="#ghci-cmd-:reload"><code>:reload</code></a> command. The program will be recompiled as necessary, with GHCi doing its best to avoid actually recompiling modules if their external dependencies haven’t changed. This is the same mechanism we use to avoid re-compiling modules in the batch compilation setting (see <a class="reference internal" href="separate_compilation#recomp"><span class="std std-ref">The recompilation checker</span></a>).</p>    <h2 id="ghci-compiled">6.3. Loading compiled code</h2> <p id="loading-compiled-code">When you load a Haskell source module into GHCi, it is normally converted to byte-code and run using the interpreter. However, interpreted code can also run alongside compiled code in GHCi; indeed, normally when GHCi starts, it loads up a compiled copy of the <code>base</code> package, which contains the <code>Prelude</code>.</p> <p>Why should we want to run compiled code? Well, compiled code is roughly 10x faster than interpreted code, but takes about 2x longer to produce (perhaps longer if optimisation is on). So it pays to compile the parts of a program that aren’t changing very often, and use the interpreter for the code being actively developed.</p> <p>When loading up source modules with <a class="reference internal" href="#ghci-cmd-:load"><code>:load</code></a>, GHCi normally looks for any corresponding compiled object files, and will use one in preference to interpreting the source if possible. For example, suppose we have a 4-module program consisting of modules <code>A</code>, <code>B</code>, <code>C</code>, and <code>D</code>. Modules <code>B</code> and <code>C</code> both import <code>D</code> only, and <code>A</code> imports both <code>B</code> and <code>C</code>:</p> <pre data-language="none">  A
 / \
B   C
 \ /
  D
</pre> <p>We can compile <code>D</code>, then load the whole program, like this:</p> <pre data-language="none">Prelude&gt; :! ghc -c -dynamic D.hs
Prelude&gt; :load A
Compiling B                ( B.hs, interpreted )
Compiling C                ( C.hs, interpreted )
Compiling A                ( A.hs, interpreted )
Ok, modules loaded: A, B, C, D (D.o).
*Main&gt;
</pre> <p>In the messages from the compiler, we see that there is no line for <code>D</code>. This is because it isn’t necessary to compile <code>D</code>, because the source and everything it depends on is unchanged since the last compilation.</p> <p>Note the <a class="reference internal" href="phases#ghc-flag--dynamic"><code>-dynamic</code></a> flag to GHC: GHCi uses dynamically-linked object code (if you are on a platform that supports it), and so in order to use compiled code with GHCi it must be compiled for dynamic linking.</p> <p>At any time you can use the command <a class="reference internal" href="#ghci-cmd-:show%20modules"><code>:show modules</code></a> to get a list of the modules currently loaded into GHCi:</p> <pre data-language="none">*Main&gt; :show modules
D                ( D.hs, D.o )
C                ( C.hs, interpreted )
B                ( B.hs, interpreted )
A                ( A.hs, interpreted )
*Main&gt;
</pre> <p>If we now modify the source of <code>D</code> (or pretend to: using the Unix command <code>touch</code> on the source file is handy for this), the compiler will no longer be able to use the object file, because it might be out of date:</p> <pre data-language="none">*Main&gt; :! touch D.hs
*Main&gt; :reload
Compiling D                ( D.hs, interpreted )
Ok, modules loaded: A, B, C, D.
*Main&gt;
</pre> <p>Note that module <code>D</code> was compiled, but in this instance because its source hadn’t really changed, its interface remained the same, and the recompilation checker determined that <code>A</code>, <code>B</code> and <code>C</code> didn’t need to be recompiled.</p> <p>So let’s try compiling one of the other modules:</p> <pre data-language="none">*Main&gt; :! ghc -c C.hs
*Main&gt; :load A
Compiling D                ( D.hs, interpreted )
Compiling B                ( B.hs, interpreted )
Compiling C                ( C.hs, interpreted )
Compiling A                ( A.hs, interpreted )
Ok, modules loaded: A, B, C, D.
</pre> <p>We didn’t get the compiled version of <code>C</code>! What happened? Well, in GHCi a compiled module may only depend on other compiled modules, and in this case <code>C</code> depends on <code>D</code>, which doesn’t have an object file, so GHCi also rejected <code>C</code>‘s object file. Ok, so let’s also compile <code>D</code>:</p> <pre data-language="none">*Main&gt; :! ghc -c D.hs
*Main&gt; :reload
Ok, modules loaded: A, B, C, D.
</pre> <p>Nothing happened! Here’s another lesson: newly compiled modules aren’t picked up by <a class="reference internal" href="#ghci-cmd-:reload"><code>:reload</code></a>, only <a class="reference internal" href="#ghci-cmd-:load"><code>:load</code></a>:</p> <pre data-language="none">*Main&gt; :load A
Compiling B                ( B.hs, interpreted )
Compiling A                ( A.hs, interpreted )
Ok, modules loaded: A, B, C (C.o), D (D.o).
</pre> <p>The automatic loading of object files can sometimes lead to confusion, because non-exported top-level definitions of a module are only available for use in expressions at the prompt when the module is interpreted (see <a class="reference internal" href="#ghci-scope"><span class="std std-ref">What’s really in scope at the prompt?</span></a>). For this reason, you might sometimes want to force GHCi to load a module using the interpreter. This can be done by prefixing a <code>*</code> to the module name or filename when using <a class="reference internal" href="#ghci-cmd-:load"><code>:load</code></a>, for example</p> <pre data-language="none">Prelude&gt; :load *A
Compiling A                ( A.hs, interpreted )
*A&gt;
</pre> <p>When the <code>*</code> is used, GHCi ignores any pre-compiled object code and interprets the module. If you have already loaded a number of modules as object code and decide that you wanted to interpret one of them, instead of re-loading the whole set you can use <code>:add *M</code> to specify that you want <code>M</code> to be interpreted (note that this might cause other modules to be interpreted too, because compiled modules cannot depend on interpreted ones).</p> <p>To always compile everything to object code and never use the interpreter, use the <a class="reference internal" href="phases#ghc-flag--fobject-code"><code>-fobject-code</code></a> option (see <a class="reference internal" href="#ghci-obj"><span class="std std-ref">Compiling to object code inside GHCi</span></a>).</p> <div class="admonition hint"> <p class="first admonition-title">Hint</p> <p class="last">Since GHCi will only use a compiled object file if it can be sure that the compiled version is up-to-date, a good technique when working on a large program is to occasionally run <code>ghc --make</code> to compile the whole project (say before you go for lunch :-), then continue working in the interpreter. As you modify code, the changed modules will be interpreted, but the rest of the project will remain compiled.</p> </div>   <h2 id="interactive-evaluation">6.4. Interactive evaluation at the prompt</h2> <p id="interactive-evaluation-at-the-prompt">When you type an expression at the prompt, GHCi immediately evaluates and prints the result:</p> <pre data-language="none">Prelude&gt; reverse "hello"
"olleh"
Prelude&gt; 5+5
10
</pre>  <h3 id="actions-at-prompt">6.4.1. I/O actions at the prompt</h3> <p id="i-o-actions-at-the-prompt">GHCi does more than simple expression evaluation at the prompt. If you enter an expression of type <code>IO a</code> for some <code>a</code>, then GHCi <em>executes</em> it as an IO-computation.</p> <pre data-language="none">Prelude&gt; "hello"
"hello"
Prelude&gt; putStrLn "hello"
hello
</pre> <p>This works even if the type of the expression is more general, provided it can be <em>instantiated</em> to <code>IO a</code>. For example</p> <pre data-language="none">Prelude&gt; return True
True
</pre> <p>Furthermore, GHCi will print the result of the I/O action if (and only if):</p> <ul class="simple"> <li>The result type is an instance of <code>Show</code>.</li> <li>The result type is not <code>()</code>.</li> </ul> <p>For example, remembering that <code>putStrLn :: String -&gt; IO ()</code>:</p> <pre data-language="none">Prelude&gt; putStrLn "hello"
hello
Prelude&gt; do { putStrLn "hello"; return "yes" }
hello
"yes"
</pre>   <h3 id="ghci-stmts">6.4.2. Using <code>do</code> notation at the prompt</h3> <p id="using-do-notation-at-the-prompt">GHCi actually accepts statements rather than just expressions at the prompt. This means you can bind values and functions to names, and use them in future expressions or statements.</p> <p>The syntax of a statement accepted at the GHCi prompt is exactly the same as the syntax of a statement in a Haskell <code>do</code> expression. However, there’s no monad overloading here: statements typed at the prompt must be in the <code>IO</code> monad.</p> <pre data-language="none">Prelude&gt; x &lt;- return 42
Prelude&gt; print x
42
Prelude&gt;
</pre> <p>The statement <code>x &lt;- return 42</code> means “execute <code>return 42</code> in the <code>IO</code> monad, and bind the result to <code>x</code>”. We can then use <code>x</code> in future statements, for example to print it as we did above.</p> <dl class="ghc-flag"> <dt id="ghc-flag--fprint-bind-result">
<code>-fprint-bind-result</code> </dt> <dd>
<p>If <a class="reference internal" href="#ghc-flag--fprint-bind-result"><code>-fprint-bind-result</code></a> is set then GHCi will print the result of a statement if and only if:</p> <ul class="simple"> <li>The statement is not a binding, or it is a monadic binding (<code>p &lt;- e</code>) that binds exactly one variable.</li> <li>The variable’s type is not polymorphic, is not <code>()</code>, and is an instance of <code>Show</code>.</li> </ul> </dd>
</dl> <p>Of course, you can also bind normal non-IO expressions using the <code>let</code>-statement:</p> <pre data-language="none">Prelude&gt; let x = 42
Prelude&gt; x
42
Prelude&gt;
</pre> <p>Another important difference between the two types of binding is that the monadic bind (<code>p &lt;- e</code>) is <em>strict</em> (it evaluates <code>e</code>), whereas with the <code>let</code> form, the expression isn’t evaluated immediately:</p> <pre data-language="none">Prelude&gt; let x = error "help!"
Prelude&gt; print x
*** Exception: help!
Prelude&gt;
</pre> <p>Note that <code>let</code> bindings do not automatically print the value bound, unlike monadic bindings.</p> <p>You can also define functions at the prompt:</p> <pre data-language="none">Prelude&gt; add a b = a + b
Prelude&gt; add 1 2
3
Prelude&gt;
</pre> <p>However, this quickly gets tedious when defining functions with multiple clauses, or groups of mutually recursive functions, because the complete definition has to be given on a single line, using explicit semicolons instead of layout:</p> <pre data-language="none">Prelude&gt; f op n [] = n ; f op n (h:t) = h `op` f op n t
Prelude&gt; f (+) 0 [1..3]
6
Prelude&gt;
</pre> <dl class="ghci-cmd"> <dt id="ghci-cmd-:{">
<code>:{</code> </dt> <dt id="ghci-cmd-:}">
<code>:}</code> </dt> <dd>
<p>Begin or end a multi-line GHCi command block.</p> </dd>
</dl> <p>To alleviate this issue, GHCi commands can be split over multiple lines, by wrapping them in <code>:{</code> and <code>:}</code> (each on a single line of its own):</p> <pre data-language="none">Prelude&gt; :{
Prelude| g op n [] = n
Prelude| g op n (h:t) = h `op` g op n t
Prelude| :}
Prelude&gt; g (*) 1 [1..3]
6
</pre> <p>Such multiline commands can be used with any GHCi command, and note that the layout rule is in effect. The main purpose of multiline commands is not to replace module loading but to make definitions in .ghci-files (see <a class="reference internal" href="#ghci-dot-files"><span class="std std-ref">The .ghci and .haskeline files</span></a>) more readable and maintainable.</p> <p>Any exceptions raised during the evaluation or execution of the statement are caught and printed by the GHCi command line interface (for more information on exceptions, see the module <a class="reference external" href="../libraries/base-4.13.0.0/control-exception">Control.Exception</a> in the libraries documentation.</p> <p>Every new binding shadows any existing bindings of the same name, including entities that are in scope in the current module context.</p> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">Temporary bindings introduced at the prompt only last until the next <a class="reference internal" href="#ghci-cmd-:load"><code>:load</code></a> or <a class="reference internal" href="#ghci-cmd-:reload"><code>:reload</code></a> command, at which time they will be simply lost. However, they do survive a change of context with <a class="reference internal" href="#ghci-cmd-:module"><code>:module</code></a>: the temporary bindings just move to the new location.</p> </div> <div class="admonition hint"> <p class="first admonition-title">Hint</p> <p>To get a list of the bindings currently in scope, use the <a class="reference internal" href="#ghci-cmd-:show%20bindings"><code>:show bindings</code></a> command:</p> <pre data-language="none">Prelude&gt; :show bindings
x :: Int
Prelude&gt;
</pre> </div> <div class="admonition hint"> <p class="first admonition-title">Hint</p> <p>If you turn on the <code>+t</code> option, GHCi will show the type of each variable bound by a statement. For example:</p> <pre data-language="none">Prelude&gt; :set +t
Prelude&gt; let (x:xs) = [1..]
x :: Integer
xs :: [Integer]
</pre> </div>   <h3 id="index-7">6.4.3. Multiline input</h3> <p id="multiline-input">Apart from the <code>:{ ... :}</code> syntax for multi-line input mentioned above, GHCi also has a multiline mode, enabled by <code>:set +m</code>, <code>:set +m</code> in which GHCi detects automatically when the current statement is unfinished and allows further lines to be added. A multi-line input is terminated with an empty line. For example:</p> <pre data-language="none">Prelude&gt; :set +m
Prelude&gt; let x = 42
Prelude|
</pre> <p>Further bindings can be added to this <code>let</code> statement, so GHCi indicates that the next line continues the previous one by changing the prompt. Note that layout is in effect, so to add more bindings to this <code>let</code> we have to line them up:</p> <pre data-language="none">Prelude&gt; :set +m
Prelude&gt; let x = 42
Prelude|     y = 3
Prelude|
Prelude&gt;
</pre> <p>Explicit braces and semicolons can be used instead of layout:</p> <pre data-language="none">Prelude&gt; do {
Prelude| putStrLn "hello"
Prelude| ;putStrLn "world"
Prelude| }
hello
world
Prelude&gt;
</pre> <p>Note that after the closing brace, GHCi knows that the current statement is finished, so no empty line is required.</p> <p>Multiline mode is useful when entering monadic <code>do</code> statements:</p> <pre data-language="none">Control.Monad.State&gt; flip evalStateT 0 $ do
Control.Monad.State| i &lt;- get
Control.Monad.State| lift $ do
Control.Monad.State|   putStrLn "Hello World!"
Control.Monad.State|   print i
Control.Monad.State|
"Hello World!"
0
Control.Monad.State&gt;
</pre> <p>During a multiline interaction, the user can interrupt and return to the top-level prompt.</p> <pre data-language="none">Prelude&gt; do
Prelude| putStrLn "Hello, World!"
Prelude| ^C
Prelude&gt;
</pre>   <h3 id="ghci-decls">6.4.4. Type, class and other declarations</h3> <p id="type-class-and-other-declarations">At the GHCi prompt you can also enter any top-level Haskell declaration, including <code>data</code>, <code>type</code>, <code>newtype</code>, <code>class</code>, <code>instance</code>, <code>deriving</code>, and <code>foreign</code> declarations. For example:</p> <pre data-language="none">Prelude&gt; data T = A | B | C deriving (Eq, Ord, Show, Enum)
Prelude&gt; [A ..]
[A,B,C]
Prelude&gt; :i T
data T = A | B | C      -- Defined at &lt;interactive&gt;:2:6
instance Enum T -- Defined at &lt;interactive&gt;:2:45
instance Eq T -- Defined at &lt;interactive&gt;:2:30
instance Ord T -- Defined at &lt;interactive&gt;:2:34
instance Show T -- Defined at &lt;interactive&gt;:2:39
</pre> <p>As with ordinary variable bindings, later definitions shadow earlier ones, so you can re-enter a declaration to fix a problem with it or extend it. But there’s a gotcha: when a new type declaration shadows an older one, there might be other declarations that refer to the old type. The thing to remember is that the old type still exists, and these other declarations still refer to the old type. However, while the old and the new type have the same name, GHCi will treat them as distinct. For example:</p> <pre data-language="none">Prelude&gt; data T = A | B
Prelude&gt; let f A = True; f B = False
Prelude&gt; data T = A | B | C
Prelude&gt; f A

&lt;interactive&gt;:2:3:
    Couldn't match expected type `main::Interactive.T'
                with actual type `T'
    In the first argument of `f', namely `A'
    In the expression: f A
    In an equation for `it': it = f A
Prelude&gt;
</pre> <p>The old, shadowed, version of <code>T</code> is displayed as <code>main::Interactive.T</code> by GHCi in an attempt to distinguish it from the new <code>T</code>, which is displayed as simply <code>T</code>.</p> <p>Class and type-family instance declarations are simply added to the list of available instances, with one exception. Since you might want to re-define one, a class instance <em>replaces</em> any earlier instance with an identical head. You aren’t allowed to re-define a type family instance, since it might not be type safe to do so. Instead, re-define the whole type-family. (See <a class="reference internal" href="glasgow_exts#type-families"><span class="std std-ref">Type families</span></a>.) For example:</p> <pre data-language="none">Prelude&gt; type family T a b
Prelude&gt; type instance T a b = a
Prelude&gt; let uc :: a -&gt; T a b; uc = id

Prelude&gt; type instance T a b = b

&lt;interactive&gt;:3:15: error:
    Conflicting family instance declarations:
      T a b = a -- Defined at &lt;interactive&gt;:3:15
      T a b = b -- Defined at &lt;interactive&gt;:5:15

-- Darn! We have to re-declare T.

Prelude&gt; type family T a b
-- This is a brand-new T, unrelated to the old one
Prelude&gt; type instance T a b = b
Prelude&gt; uc 'a' :: Int

&lt;interactive&gt;:8:1: error:
    • Couldn't match type ‘Char’ with ‘Int’
      Expected type: Int
        Actual type: Ghci1.T Char b0
    • In the expression: uc 'a' :: Int
      In an equation for ‘it’: it = uc 'a' :: Int
</pre>   <h3 id="ghci-scope">6.4.5. What’s really in scope at the prompt?</h3> <p id="what-s-really-in-scope-at-the-prompt">When you type an expression at the prompt, what identifiers and types are in scope? GHCi provides a flexible way to control exactly how the context for an expression is constructed:</p> <ul class="simple"> <li>The <a class="reference internal" href="#ghci-cmd-:load"><code>:load</code></a>, <a class="reference internal" href="#ghci-cmd-:add"><code>:add</code></a>, and <a class="reference internal" href="#ghci-cmd-:reload"><code>:reload</code></a> commands (<a class="reference internal" href="#ghci-load-scope"><span class="std std-ref">The effect of :load on what is in scope</span></a>).</li> <li>The <code>import</code> declaration (<a class="reference internal" href="#ghci-import-decl"><span class="std std-ref">Controlling what is in scope with import</span></a>).</li> <li>The <a class="reference internal" href="#ghci-cmd-:module"><code>:module</code></a> command (<a class="reference internal" href="#ghci-module-cmd"><span class="std std-ref">Controlling what is in scope with the :module command</span></a>).</li> </ul> <p>The command <a class="reference internal" href="#ghci-cmd-:show%20imports"><code>:show imports</code></a> will show a summary of which modules contribute to the top-level scope.</p> <div class="admonition hint"> <p class="first admonition-title">Hint</p> <p class="last">GHCi will tab-complete names that are in scope; for example, if you run GHCi and type <code>J&lt;tab&gt;</code> then GHCi will expand it to <code>Just</code>.</p> </div>  <h4 id="ghci-load-scope">6.4.5.1. The effect of <code>:load</code> on what is in scope</h4> <p id="the-effect-of-load-on-what-is-in-scope">The <a class="reference internal" href="#ghci-cmd-:load"><code>:load</code></a>, <a class="reference internal" href="#ghci-cmd-:add"><code>:add</code></a>, and <a class="reference internal" href="#ghci-cmd-:reload"><code>:reload</code></a> commands (<a class="reference internal" href="#loading-source-files"><span class="std std-ref">Loading source files</span></a> and <a class="reference internal" href="#ghci-compiled"><span class="std std-ref">Loading compiled code</span></a>) affect the top-level scope. Let’s start with the simple cases; when you start GHCi the prompt looks like this:</p> <pre data-language="none">Prelude&gt;
</pre> <p>which indicates that everything from the module <code>Prelude</code> is currently in scope; the visible identifiers are exactly those that would be visible in a Haskell source file with no <code>import</code> declarations.</p> <p>If we now load a file into GHCi, the prompt will change:</p> <pre data-language="none">Prelude&gt; :load Main.hs
Compiling Main             ( Main.hs, interpreted )
*Main&gt;
</pre> <p>The new prompt is <code>*Main</code>, which indicates that we are typing expressions in the context of the top-level of the <code>Main</code> module. Everything that is in scope at the top-level in the module <code>Main</code> we just loaded is also in scope at the prompt (probably including <code>Prelude</code>, as long as <code>Main</code> doesn’t explicitly hide it).</p> <p>The syntax in the prompt <code>*module</code> indicates that it is the full top-level scope of ⟨module⟩ that is contributing to the scope for expressions typed at the prompt. Without the <code>*</code>, just the exports of the module are visible.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">For technical reasons, GHCi can only support the <code>*</code>-form for modules that are interpreted. Compiled modules and package modules can only contribute their exports to the current scope. To ensure that GHCi loads the interpreted version of a module, add the <code>*</code> when loading the module, e.g. <code>:load *M</code>.</p> </div> <p>In general, after a <a class="reference internal" href="#ghci-cmd-:load"><code>:load</code></a> command, an automatic import is added to the scope for the most recently loaded “target” module, in a <code>*</code>-form if possible. For example, if you say <code>:load foo.hs bar.hs</code> and <code>bar.hs</code> contains module <code>Bar</code>, then the scope will be set to <code>*Bar</code> if <code>Bar</code> is interpreted, or if <code>Bar</code> is compiled it will be set to <code>Prelude Bar</code> (GHCi automatically adds <code>Prelude</code> if it isn’t present and there aren’t any <code>*</code>-form modules). These automatically-added imports can be seen with <a class="reference internal" href="#ghci-cmd-:show%20imports"><code>:show imports</code></a>:</p> <pre data-language="none">Prelude&gt; :load hello.hs
[1 of 1] Compiling Main             ( hello.hs, interpreted )
Ok, modules loaded: Main.
*Main&gt; :show imports
:module +*Main -- added automatically
*Main&gt;
</pre> <p>and the automatically-added import is replaced the next time you use <a class="reference internal" href="#ghci-cmd-:load"><code>:load</code></a>, <a class="reference internal" href="#ghci-cmd-:add"><code>:add</code></a>, or <a class="reference internal" href="#ghci-cmd-:reload"><code>:reload</code></a>. It can also be removed by <a class="reference internal" href="#ghci-cmd-:module"><code>:module</code></a> as with normal imports.</p>   <h4 id="ghci-import-decl">6.4.5.2. Controlling what is in scope with <code>import</code>
</h4> <p id="controlling-what-is-in-scope-with-import">We are not limited to a single module: GHCi can combine scopes from multiple modules, in any mixture of <code>*</code> and non-<code>*</code> forms. GHCi combines the scopes from all of these modules to form the scope that is in effect at the prompt.</p> <p>To add modules to the scope, use ordinary Haskell <code>import</code> syntax:</p> <pre data-language="none">Prelude&gt; import System.IO
Prelude System.IO&gt; hPutStrLn stdout "hello\n"
hello
Prelude System.IO&gt;
</pre> <p>The full Haskell import syntax is supported, including <code>hiding</code> and <code>as</code> clauses. The prompt shows the modules that are currently imported, but it omits details about <code>hiding</code>, <code>as</code>, and so on. To see the full story, use <a class="reference internal" href="#ghci-cmd-:show%20imports"><code>:show imports</code></a>:</p> <pre data-language="none">Prelude&gt; import System.IO
Prelude System.IO&gt; import Data.Map as Map
Prelude System.IO Map&gt; :show imports
import Prelude -- implicit
import System.IO
import Data.Map as Map
Prelude System.IO Map&gt;
</pre> <p>Note that the <code>Prelude</code> import is marked as implicit. It can be overridden with an explicit <code>Prelude</code> import, just like in a Haskell module.</p> <p>With multiple modules in scope, especially multiple <code>*</code>-form modules, it is likely that name clashes will occur. Haskell specifies that name clashes are only reported when an ambiguous identifier is used, and GHCi behaves in the same way for expressions typed at the prompt.</p>   <h4 id="ghci-module-cmd">6.4.5.3. Controlling what is in scope with the <code>:module</code> command</h4> <p id="controlling-what-is-in-scope-with-the-module-command">Another way to manipulate the scope is to use the <a class="reference internal" href="#ghci-cmd-:module"><code>:module</code></a> command, whose syntax is this:</p> <pre data-language="none">:module +|- *mod1 ... *modn
</pre> <p>Using the <code>+</code> form of the <code>module</code> commands adds modules to the current scope, and <code>-</code> removes them. Without either <code>+</code> or <code>-</code>, the current scope is replaced by the set of modules specified. Note that if you use this form and leave out <code>Prelude</code>, an implicit <code>Prelude</code> import will be added automatically.</p> <p>The <a class="reference internal" href="#ghci-cmd-:module"><code>:module</code></a> command provides a way to do two things that cannot be done with ordinary <code>import</code> declarations:</p> <ul class="simple"> <li>
<a class="reference internal" href="#ghci-cmd-:module"><code>:module</code></a> supports the <code>*</code> modifier on modules, which opens the full top-level scope of a module, rather than just its exports.</li> <li>Imports can be <em>removed</em> from the context, using the syntax <code>:module -M</code>. The <code>import</code> syntax is cumulative (as in a Haskell module), so this is the only way to subtract from the scope.</li> </ul>   <h4 id="ghci-import-qualified">6.4.5.4. Qualified names</h4> <p id="qualified-names">To make life slightly easier, the GHCi prompt also behaves as if there is an implicit <code>import qualified</code> declaration for every module in every package, and every module currently loaded into GHCi. This behaviour can be disabled with the <code>-fno-implicit-import-qualified</code> flag.</p>   <h4 id="index-8">6.4.5.5. <code>:module</code> and <code>:load</code>
</h4> <p id="module-and-load">It might seem that <a class="reference internal" href="#ghci-cmd-:module"><code>:module</code></a>/<code>import</code> and <a class="reference internal" href="#ghci-cmd-:load"><code>:load</code></a>/<a class="reference internal" href="#ghci-cmd-:add"><code>:add</code></a>/<a class="reference internal" href="#ghci-cmd-:reload"><code>:reload</code></a> do similar things: you can use both to bring a module into scope. However, there is a very important difference. GHCi is concerned with two sets of modules:</p> <ul class="simple"> <li>The set of modules that are currently <em>loaded</em>. This set is modified by <a class="reference internal" href="#ghci-cmd-:load"><code>:load</code></a>, <a class="reference internal" href="#ghci-cmd-:add"><code>:add</code></a> and <a class="reference internal" href="#ghci-cmd-:reload"><code>:reload</code></a>, and can be shown with <a class="reference internal" href="#ghci-cmd-:show%20modules"><code>:show modules</code></a>.</li> <li>The set of modules that are currently <em>in scope</em> at the prompt. This set is modified by <code>import</code> and <a class="reference internal" href="#ghci-cmd-:module"><code>:module</code></a>, and it is also modified automatically after <a class="reference internal" href="#ghci-cmd-:load"><code>:load</code></a>, <a class="reference internal" href="#ghci-cmd-:add"><code>:add</code></a>, and <a class="reference internal" href="#ghci-cmd-:reload"><code>:reload</code></a>, as described above. The set of modules in scope can be shown with <a class="reference internal" href="#ghci-cmd-:show%20imports"><code>:show imports</code></a>.</li> </ul> <p>You can add a module to the scope (via <a class="reference internal" href="#ghci-cmd-:module"><code>:module</code></a> or <code>import</code>) only if either (a) it is loaded, or (b) it is a module from a package that GHCi knows about. Using <a class="reference internal" href="#ghci-cmd-:module"><code>:module</code></a> or <code>import</code> to try bring into scope a non-loaded module may result in the message <code>module M is not loaded</code>.</p>    <h3 id="the-main-and-run-commands">6.4.6. The <code>:main</code> and <code>:run</code> commands</h3> <p>When a program is compiled and executed, it can use the <code>getArgs</code> function to access the command-line arguments. However, we cannot simply pass the arguments to the <code>main</code> function while we are testing in ghci, as the <code>main</code> function doesn’t take its directly.</p> <p>Instead, we can use the <a class="reference internal" href="#ghci-cmd-:main"><code>:main</code></a> command. This runs whatever <code>main</code> is in scope, with any arguments being treated the same as command-line arguments, e.g.:</p> <pre data-language="none">Prelude&gt; main = System.Environment.getArgs &gt;&gt;= print
Prelude&gt; :main foo bar
["foo","bar"]
</pre> <p>We can also quote arguments which contains characters like spaces, and they are treated like Haskell strings, or we can just use Haskell list syntax:</p> <pre data-language="none">Prelude&gt; :main foo "bar baz"
["foo","bar baz"]
Prelude&gt; :main ["foo", "bar baz"]
["foo","bar baz"]
</pre> <p>Finally, other functions can be called, either with the <code>-main-is</code> flag or the <a class="reference internal" href="#ghci-cmd-:run"><code>:run</code></a> command:</p> <pre data-language="none">Prelude&gt; foo = putStrLn "foo" &gt;&gt; System.Environment.getArgs &gt;&gt;= print
Prelude&gt; bar = putStrLn "bar" &gt;&gt; System.Environment.getArgs &gt;&gt;= print
Prelude&gt; :set -main-is foo
Prelude&gt; :main foo "bar baz"
foo
["foo","bar baz"]
Prelude&gt; :run bar ["foo", "bar baz"]
bar
["foo","bar baz"]
</pre>   <h3 id="the-it-variable">6.4.7. The <code>it</code> variable</h3> <p id="index-9">Whenever an expression (or a non-binding statement, to be precise) is typed at the prompt, GHCi implicitly binds its value to the variable <code>it</code>. For example:</p> <pre data-language="none">Prelude&gt; 1+2
3
Prelude&gt; it * 2
6
</pre> <p>What actually happens is that GHCi typechecks the expression, and if it doesn’t have an <code>IO</code> type, then it transforms it as follows: an expression <code>e</code> turns into</p> <pre data-language="none">let it = e;
print it
</pre> <p>which is then run as an IO-action.</p> <p>Hence, the original expression must have a type which is an instance of the <code>Show</code> class, or GHCi will complain:</p> <pre data-language="none">Prelude&gt; id

&lt;interactive&gt;:1:0:
    No instance for (Show (a -&gt; a))
      arising from use of `print' at &lt;interactive&gt;:1:0-1
    Possible fix: add an instance declaration for (Show (a -&gt; a))
    In the expression: print it
    In a 'do' expression: print it
</pre> <p>The error message contains some clues as to the transformation happening internally.</p> <p>If the expression was instead of type <code>IO a</code> for some <code>a</code>, then <code>it</code> will be bound to the result of the <code>IO</code> computation, which is of type <code>a</code>. eg.:</p> <pre data-language="none">Prelude&gt; Data.Time.getZonedTime
2017-04-10 12:34:56.93213581 UTC
Prelude&gt; print it
2017-04-10 12:34:56.93213581 UTC
</pre> <p>The corresponding translation for an IO-typed <code>e</code> is</p> <pre data-language="none">it &lt;- e
</pre> <p>Note that <code>it</code> is shadowed by the new value each time you evaluate a new expression, and the old value of <code>it</code> is lost.</p> <p>In order to stop the value <code>it</code> being bound on each command, the flag <a class="reference internal" href="#ghc-flag--fno-it"><code>-fno-it</code></a> can be set. The <code>it</code> variable can be the source of space leaks due to how shadowed declarations are handled by GHCi (see <a class="reference internal" href="#ghci-decls"><span class="std std-ref">Type, class and other declarations</span></a>).</p> <dl class="ghc-flag"> <dt id="ghc-flag--fno-it">
<code>-fno-it</code> </dt> <dd>
<p>When this flag is set, the variable <code>it</code> will no longer be set to the result of the previously evaluated expression.</p> </dd>
</dl>   <h3 id="extended-default-rules">6.4.8. Type defaulting in GHCi</h3> <dl class="extension" id="type-defaulting-in-ghci"> <dt id="extension-ExtendedDefaultRules">
<code>ExtendedDefaultRules</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> <p>Allow defaulting to take place for more than just numeric classes.</p> </dd>
</dl> <p>Consider this GHCi session:</p> <pre data-language="none">ghci&gt; reverse []
</pre> <p>What should GHCi do? Strictly speaking, the program is ambiguous. <code>show (reverse [])</code> (which is what GHCi computes here) has type <code>Show a =&gt; String</code> and how that displays depends on the type <code>a</code>. For example:</p> <pre data-language="none">ghci&gt; reverse ([] :: String)
""
ghci&gt; reverse ([] :: [Int])
[]
</pre> <p>However, it is tiresome for the user to have to specify the type, so GHCi extends Haskell’s type-defaulting rules (Section 4.3.4 of the Haskell 2010 Report) as follows. The standard rules take each group of constraints <code>(C1 a, C2 a, ..., Cn a)</code> for each type variable <code>a</code>, and defaults the type variable if</p> <ol class="arabic simple"> <li>The type variable <code>a</code> appears in no other constraints</li> <li>All the classes <code>Ci</code> are standard.</li> <li>At least one of the classes <code>Ci</code> is numeric.</li> </ol> <p>At the GHCi prompt, or with GHC if the <a class="reference internal" href="#extension-ExtendedDefaultRules"><code>ExtendedDefaultRules</code></a> flag is given, the types are instead resolved with the following method:</p> <p>Find all the unsolved constraints. Then:</p> <ul class="simple"> <li>Find those that are of form <code>(C a)</code> where <code>a</code> is a type variable, and partition those constraints into groups that share a common type variable <code>a</code>.</li> <li>Keep only the groups in which at least one of the classes is an <strong>interactive class</strong> (defined below).</li> <li>Now, for each remaining group G, try each type <code>ty</code> from the default-type list in turn; if setting <code>a = ty</code> would allow the constraints in G to be completely solved. If so, default <code>a</code> to <code>ty</code>.</li> <li>The unit type <code>()</code> and the list type <code>[]</code> are added to the start of the standard list of types which are tried when doing type defaulting.</li> </ul> <p>Note that any multi-parameter constraints <code>(D a b)</code> or <code>(D [a] Int)</code> do not participate in the process (either to help or to hinder); but they must of course be soluble once the defaulting process is complete.</p> <p>The last point means that, for example, this program:</p> <pre data-language="haskell">main :: IO ()
main = print def

instance Num ()

def :: (Num a, Enum a) =&gt; a
def = toEnum 0
</pre> <p>prints <code>()</code> rather than <code>0</code> as the type is defaulted to <code>()</code> rather than <code>Integer</code>.</p> <p>The motivation for the change is that it means <code>IO a</code> actions default to <code>IO ()</code>, which in turn means that ghci won’t try to print a result when running them. This is particularly important for <code>printf</code>, which has an instance that returns <code>IO a</code>. However, it is only able to return <code>undefined</code> (the reason for the instance having this type is so that printf doesn’t require extensions to the class system), so if the type defaults to <code>Integer</code> then ghci gives an error when running a printf.</p> <p>See also <a class="reference internal" href="#actions-at-prompt"><span class="std std-ref">I/O actions at the prompt</span></a> for how the monad of a computational expression defaults to <code>IO</code> if possible.</p>  <h4 id="interactive-classes">6.4.8.1. Interactive classes</h4> <p id="index-11">The interactive classes (only relevant when <a class="reference internal" href="#extension-ExtendedDefaultRules"><code>ExtendedDefaultRules</code></a> is in effect) are: any numeric class, <code>Show</code>, <code>Eq</code>, <code>Ord</code>, <code>Foldable</code> or <code>Traversable</code>.</p> <p>As long as a type variable is constrained by one of these classes, defaulting will occur, as outlined above.</p>   <h4 id="extended-rules-around-default-declarations">6.4.8.2. Extended rules around <code>default</code> declarations</h4> <p id="index-12">Since the rules for defaulting are relaxed under <a class="reference internal" href="#extension-ExtendedDefaultRules"><code>ExtendedDefaultRules</code></a>, the rules for <code>default</code> declarations are also relaxed. According to Section 4.3.4 of the Haskell 2010 Report, a <code>default</code> declaration looks like <code>default (t1, ..., tn)</code> where, for each <code>ti</code>, <code>Num ti</code> must hold. This is relaxed to say that for each <code>ti</code>, there must exist an interactive class <code>C</code> such that <code>C ti</code> holds. This means that type <em>constructors</em> can be allowed in these lists. For example, the following works if you wish your <code>Foldable</code> constraints to default to <code>Maybe</code> but your <code>Num</code> constraints to still default to <code>Integer</code> or <code>Double</code>:</p> <pre data-language="haskell">default (Maybe, Integer, Double)
</pre>    <h3 id="ghci-interactive-print">6.4.9. Using a custom interactive printing function</h3> <p id="using-a-custom-interactive-printing-function">Since GHC 7.6.1, GHCi prints the result of expressions typed at the prompt using the function <code>System.IO.print</code>. Its type signature is <code>Show a =&gt; a -&gt;
IO ()</code>, and it works by converting the value to <code>String</code> using <code>show</code>.</p> <p>This is not ideal in certain cases, like when the output is long, or contains strings with non-ascii characters.</p> <p>The <a class="reference internal" href="#ghc-flag--interactive-print%20%E2%9F%A8expr%E2%9F%A9"><code>-interactive-print ⟨expr⟩</code></a> flag allows to specify any function of type <code>C a =&gt; a -&gt; IO ()</code>, for some constraint <code>C</code>, as the function for printing evaluated expressions. The function can reside in any loaded module or any registered package, but only when it resides in a registered package will it survive a <a class="reference internal" href="#ghci-cmd-:cd"><code>:cd</code></a>, <a class="reference internal" href="#ghci-cmd-:add"><code>:add</code></a>, <a class="reference internal" href="#ghci-cmd-:load"><code>:load</code></a>, <a class="reference internal" href="#ghci-cmd-:reload"><code>:reload</code></a> or, <a class="reference internal" href="#ghci-cmd-:set"><code>:set</code></a>.</p> <dl class="ghc-flag"> <dt id="ghc-flag--interactive-print ⟨expr⟩">
<code>-interactive-print ⟨expr⟩</code> </dt> <dd>
<p>Set the function used by GHCi to print evaluation results. Expression must be of type <code>C a =&gt; a -&gt; IO ()</code>.</p> </dd>
</dl> <p>As an example, suppose we have following special printing module:</p> <pre data-language="haskell">module SpecPrinter where
import System.IO

sprint a = putStrLn $ show a ++ "!"
</pre> <p>The <code>sprint</code> function adds an exclamation mark at the end of any printed value. Running GHCi with the command:</p> <pre data-language="none">ghci -interactive-print=SpecPrinter.sprint SpecPrinter
</pre> <p>will start an interactive session where values with be printed using <code>sprint</code>:</p> <pre data-language="none">*SpecPrinter&gt; [1,2,3]
[1,2,3]!
*SpecPrinter&gt; 42
42!
</pre> <p>A custom pretty printing function can be used, for example, to format tree-like and nested structures in a more readable way.</p> <p>The <a class="reference internal" href="#ghc-flag--interactive-print%20%E2%9F%A8expr%E2%9F%A9"><code>-interactive-print ⟨expr⟩</code></a> flag can also be used when running GHC in <code>-e mode</code>:</p> <pre data-language="none">% ghc -e "[1,2,3]" -interactive-print=SpecPrinter.sprint SpecPrinter
[1,2,3]!
</pre>   <h3 id="ghci-stack-traces">6.4.10. Stack Traces in GHCi</h3> <p id="stack-traces-in-ghci">[ This is an experimental feature enabled by the new <code>-fexternal-interpreter</code> flag that was introduced in GHC 8.0.1. It is currently not supported on Windows.]</p> <p>GHCi can use the profiling system to collect stack trace information when running interpreted code. To gain access to stack traces, start GHCi like this:</p> <pre data-language="none">ghci -fexternal-interpreter -prof
</pre> <p>This runs the interpreted code in a separate process (see <a class="reference internal" href="#external-interpreter"><span class="std std-ref">Running the interpreter in a separate process</span></a>) and runs it in profiling mode to collect call stack information. Note that because we’re running the interpreted code in profiling mode, all packages that you use must be compiled for profiling. The <code>-prof</code> flag to GHCi only works in conjunction with <code>-fexternal-interpreter</code>.</p> <p>There are three ways to get access to the current call stack.</p> <ul class="simple"> <li>
<code>error</code> and <code>undefined</code> automatically attach the current stack to the error message. This often complements the <code>HasCallStack</code> stack (see <a class="reference internal" href="glasgow_exts#hascallstack"><span class="std std-ref">HasCallStack</span></a>), so both call stacks are shown.</li> <li>
<code>Debug.Trace.traceStack</code> is a version of <code>Debug.Trace.trace</code> that also prints the current call stack.</li> <li>Functions in the module <code>GHC.Stack</code> can be used to get the current stack and render it.</li> </ul> <p>You don’t need to use <code>-fprof-auto</code> for interpreted modules, annotations are automatically added at a granularity fine enough to distinguish individual call sites. However, you won’t see any call stack information for compiled code unless it was compiled with <code>-fprof-auto</code> or has explicit <code>SCC</code> annotations (see <a class="reference internal" href="profiling#scc-pragma"><span class="std std-ref">Inserting cost centres by hand</span></a>).</p>    <h2 id="ghci-debugger">6.5. The GHCi Debugger</h2> <p id="the-ghci-debugger">GHCi contains a simple imperative-style debugger in which you can stop a running computation in order to examine the values of variables. The debugger is integrated into GHCi, and is turned on by default: no flags are required to enable the debugging facilities. There is one major restriction: breakpoints and single-stepping are only available in interpreted modules; compiled code is invisible to the debugger <a class="footnote-reference" href="#id16" id="id10">[5]</a>.</p> <p>The debugger provides the following:</p> <ul class="simple"> <li>The ability to set a breakpoint on a function definition or expression in the program. When the function is called, or the expression evaluated, GHCi suspends execution and returns to the prompt, where you can inspect the values of local variables before continuing with the execution.</li> <li>Execution can be single-stepped: the evaluator will suspend execution approximately after every reduction, allowing local variables to be inspected. This is equivalent to setting a breakpoint at every point in the program.</li> <li>Execution can take place in tracing mode, in which the evaluator remembers each evaluation step as it happens, but doesn’t suspend execution until an actual breakpoint is reached. When this happens, the history of evaluation steps can be inspected.</li> <li>Exceptions (e.g. pattern matching failure and <code>error</code>) can be treated as breakpoints, to help locate the source of an exception in the program.</li> </ul> <p>There is currently no support for obtaining a “stack trace”, but the tracing and history features provide a useful second-best, which will often be enough to establish the context of an error. For instance, it is possible to break automatically when an exception is thrown, even if it is thrown from within compiled code (see <a class="reference internal" href="#ghci-debugger-exceptions"><span class="std std-ref">Debugging exceptions</span></a>).</p>  <h3 id="breakpoints">6.5.1. Breakpoints and inspecting variables</h3> <p id="breakpoints-and-inspecting-variables">Let’s use quicksort as a running example. Here’s the code:</p> <pre data-language="haskell">qsort [] = []
qsort (a:as) = qsort left ++ [a] ++ qsort right
  where (left,right) = (filter (&lt;=a) as, filter (&gt;a) as)

main = print (qsort [8, 4, 0, 3, 1, 23, 11, 18])
</pre> <p>First, load the module into GHCi:</p> <pre data-language="none">Prelude&gt; :l qsort.hs
[1 of 1] Compiling Main             ( qsort.hs, interpreted )
Ok, modules loaded: Main.
*Main&gt;
</pre> <p>Now, let’s set a breakpoint on the right-hand-side of the second equation of qsort:</p> <pre data-language="none">*Main&gt; :break 2
Breakpoint 0 activated at qsort.hs:2:15-46
*Main&gt;
</pre> <p>The command <code>:break 2</code> sets a breakpoint on line 2 of the most recently-loaded module, in this case <code>qsort.hs</code>. Specifically, it picks the leftmost complete subexpression on that line on which to set the breakpoint, which in this case is the expression <code>(qsort left ++ [a] ++ qsort right)</code>.</p> <p>Now, we run the program:</p> <pre data-language="none">*Main&gt; main
Stopped at qsort.hs:2:15-46
_result :: [a]
a :: a
left :: [a]
right :: [a]
[qsort.hs:2:15-46] *Main&gt;
</pre> <p>Execution has stopped at the breakpoint. The prompt has changed to indicate that we are currently stopped at a breakpoint, and the location: <code>[qsort.hs:2:15-46]</code>. To further clarify the location, we can use the <a class="reference internal" href="#ghci-cmd-:list"><code>:list</code></a> command:</p> <pre data-language="none">[qsort.hs:2:15-46] *Main&gt; :list
1  qsort [] = []
2  qsort (a:as) = qsort left ++ [a] ++ qsort right
3    where (left,right) = (filter (&lt;=a) as, filter (&gt;a) as)
</pre> <p>The <a class="reference internal" href="#ghci-cmd-:list"><code>:list</code></a> command lists the source code around the current breakpoint. If your output device supports it, then GHCi will highlight the active subexpression in bold.</p> <p>GHCi has provided bindings for the free variables <a class="footnote-reference" href="#id17" id="id11">[6]</a> of the expression on which the breakpoint was placed (<code>a</code>, <code>left</code>, <code>right</code>), and additionally a binding for the result of the expression (<code>_result</code>). These variables are just like other variables that you might define in GHCi; you can use them in expressions that you type at the prompt, you can ask for their types with <a class="reference internal" href="#ghci-cmd-:type"><code>:type</code></a>, and so on. There is one important difference though: these variables may only have partial types. For example, if we try to display the value of <code>left</code>:</p> <pre data-language="none">[qsort.hs:2:15-46] *Main&gt; left

&lt;interactive&gt;:1:0:
    Ambiguous type variable `a' in the constraint:
      `Show a' arising from a use of `print' at &lt;interactive&gt;:1:0-3
    Cannot resolve unknown runtime types: a
    Use :print or :force to determine these types
</pre> <p>This is because <code>qsort</code> is a polymorphic function, and because GHCi does not carry type information at runtime, it cannot determine the runtime types of free variables that involve type variables. Hence, when you ask to display <code>left</code> at the prompt, GHCi can’t figure out which instance of <code>Show</code> to use, so it emits the type error above.</p> <p>Fortunately, the debugger includes a generic printing command, <a class="reference internal" href="#ghci-cmd-:print"><code>:print</code></a>, which can inspect the actual runtime value of a variable and attempt to reconstruct its type. If we try it on <code>left</code>:</p> <pre data-language="none">[qsort.hs:2:15-46] *Main&gt; :set -fprint-evld-with-show
[qsort.hs:2:15-46] *Main&gt; :print left
left = (_t1::[a])
</pre> <p>This isn’t particularly enlightening. What happened is that <code>left</code> is bound to an unevaluated computation (a suspension, or thunk), and <a class="reference internal" href="#ghci-cmd-:print"><code>:print</code></a> does not force any evaluation. The idea is that <a class="reference internal" href="#ghci-cmd-:print"><code>:print</code></a> can be used to inspect values at a breakpoint without any unfortunate side effects. It won’t force any evaluation, which could cause the program to give a different answer than it would normally, and hence it won’t cause any exceptions to be raised, infinite loops, or further breakpoints to be triggered (see <a class="reference internal" href="#nested-breakpoints"><span class="std std-ref">Nested breakpoints</span></a>). Rather than forcing thunks, <a class="reference internal" href="#ghci-cmd-:print"><code>:print</code></a> binds each thunk to a fresh variable beginning with an underscore, in this case <code>_t1</code>.</p> <p>The flag <code>-fprint-evld-with-show</code> instructs <a class="reference internal" href="#ghci-cmd-:print"><code>:print</code></a> to reuse available <code>Show</code> instances when possible. This happens only when the contents of the variable being inspected are completely evaluated.</p> <p>If we aren’t concerned about preserving the evaluatedness of a variable, we can use <a class="reference internal" href="#ghci-cmd-:force"><code>:force</code></a> instead of <a class="reference internal" href="#ghci-cmd-:print"><code>:print</code></a>. The <a class="reference internal" href="#ghci-cmd-:force"><code>:force</code></a> command behaves exactly like <a class="reference internal" href="#ghci-cmd-:print"><code>:print</code></a>, except that it forces the evaluation of any thunks it encounters:</p> <pre data-language="none">[qsort.hs:2:15-46] *Main&gt; :force left
left = [4,0,3,1]
</pre> <p>Now, since <a class="reference internal" href="#ghci-cmd-:force"><code>:force</code></a> has inspected the runtime value of <code>left</code>, it has reconstructed its type. We can see the results of this type reconstruction:</p> <pre data-language="none">[qsort.hs:2:15-46] *Main&gt; :show bindings
_result :: [Integer]
a :: Integer
left :: [Integer]
right :: [Integer]
_t1 :: [Integer]
</pre> <p>Not only do we now know the type of <code>left</code>, but all the other partial types have also been resolved. So we can ask for the value of <code>a</code>, for example:</p> <pre data-language="none">[qsort.hs:2:15-46] *Main&gt; a
8
</pre> <p>You might find it useful to use Haskell’s <code>seq</code> function to evaluate individual thunks rather than evaluating the whole expression with <a class="reference internal" href="#ghci-cmd-:force"><code>:force</code></a>. For example:</p> <pre data-language="none">[qsort.hs:2:15-46] *Main&gt; :print right
right = (_t1::[Integer])
[qsort.hs:2:15-46] *Main&gt; seq _t1 ()
()
[qsort.hs:2:15-46] *Main&gt; :print right
right = 23 : (_t2::[Integer])
</pre> <p>We evaluated only the <code>_t1</code> thunk, revealing the head of the list, and the tail is another thunk now bound to <code>_t2</code>. The <code>seq</code> function is a little inconvenient to use here, so you might want to use <a class="reference internal" href="#ghci-cmd-:def"><code>:def</code></a> to make a nicer interface (left as an exercise for the reader!).</p> <p>Finally, we can continue the current execution:</p> <pre data-language="none">[qsort.hs:2:15-46] *Main&gt; :continue
Stopped at qsort.hs:2:15-46
_result :: [a]
a :: a
left :: [a]
right :: [a]
[qsort.hs:2:15-46] *Main&gt;
</pre> <p>The execution continued at the point it previously stopped, and has now stopped at the breakpoint for a second time.</p>  <h4 id="id12">6.5.1.1. Setting breakpoints</h4> <p id="setting-breakpoints">Breakpoints can be set in various ways. Perhaps the easiest way to set a breakpoint is to name a top-level function:</p> <pre data-language="none">:break identifier
</pre> <p>Where ⟨identifier⟩ names any top-level function in an interpreted module currently loaded into GHCi (qualified names may be used). The breakpoint will be set on the body of the function, when it is fully applied but before any pattern matching has taken place.</p> <p>Breakpoints can also be set by line (and optionally column) number:</p> <pre data-language="none">:break line
:break line column
:break module line
:break module line column
</pre> <p>When a breakpoint is set on a particular line, GHCi sets the breakpoint on the leftmost subexpression that begins and ends on that line. If two complete subexpressions start at the same column, the longest one is picked. If there is no complete subexpression on the line, then the leftmost expression starting on the line is picked, and failing that the rightmost expression that partially or completely covers the line.</p> <p>When a breakpoint is set on a particular line and column, GHCi picks the smallest subexpression that encloses that location on which to set the breakpoint. Note: GHC considers the TAB character to have a width of 1, wherever it occurs; in other words it counts characters, rather than columns. This matches what some editors do, and doesn’t match others. The best advice is to avoid tab characters in your source code altogether (see <a class="reference internal" href="using-warnings#ghc-flag--Wtabs"><code>-Wtabs</code></a> in <a class="reference internal" href="using-warnings#options-sanity"><span class="std std-ref">Warnings and sanity-checking</span></a>).</p> <p>If the module is omitted, then the most recently-loaded module is used.</p> <p>Not all subexpressions are potential breakpoint locations. Single variables are typically not considered to be breakpoint locations (unless the variable is the right-hand-side of a function definition, lambda, or case alternative). The rule of thumb is that all redexes are breakpoint locations, together with the bodies of functions, lambdas, case alternatives and binding statements. There is normally no breakpoint on a let expression, but there will always be a breakpoint on its body, because we are usually interested in inspecting the values of the variables bound by the let.</p>   <h4 id="listing-and-deleting-breakpoints">6.5.1.2. Listing and deleting breakpoints</h4> <p>The list of breakpoints currently enabled can be displayed using <a class="reference internal" href="#ghci-cmd-:show%20breaks"><code>:show breaks</code></a>:</p> <pre data-language="none">*Main&gt; :show breaks
[0] Main qsort.hs:1:11-12
[1] Main qsort.hs:2:15-46
</pre> <p>To delete a breakpoint, use the <a class="reference internal" href="#ghci-cmd-:delete"><code>:delete</code></a> command with the number given in the output from <a class="reference internal" href="#ghci-cmd-:show%20breaks"><code>:show breaks</code></a>:</p> <pre data-language="none">*Main&gt; :delete 0
*Main&gt; :show breaks
[1] Main qsort.hs:2:15-46
</pre> <p>To delete all breakpoints at once, use <code>:delete *</code>.</p>    <h3 id="id13">6.5.2. Single-stepping</h3> <p id="single-stepping">Single-stepping is a great way to visualise the execution of your program, and it is also a useful tool for identifying the source of a bug. GHCi offers two variants of stepping. Use <a class="reference internal" href="#ghci-cmd-:step"><code>:step</code></a> to enable all the breakpoints in the program, and execute until the next breakpoint is reached. Use <a class="reference internal" href="#ghci-cmd-:steplocal"><code>:steplocal</code></a> to limit the set of enabled breakpoints to those in the current top level function. Similarly, use <a class="reference internal" href="#ghci-cmd-:stepmodule"><code>:stepmodule</code></a> to single step only on breakpoints contained in the current module. For example:</p> <pre data-language="none">*Main&gt; :step main
Stopped at qsort.hs:5:7-47
_result :: IO ()
</pre> <p>The command <a class="reference internal" href="#ghci-cmd-:step"><code>:step expr</code></a> begins the evaluation of ⟨expr⟩ in single-stepping mode. If ⟨expr⟩ is omitted, then it single-steps from the current breakpoint. <a class="reference internal" href="#ghci-cmd-:steplocal"><code>:steplocal</code></a> and <a class="reference internal" href="#ghci-cmd-:stepmodule"><code>:stepmodule</code></a> commands work similarly.</p> <p>The <a class="reference internal" href="#ghci-cmd-:list"><code>:list</code></a> command is particularly useful when single-stepping, to see where you currently are:</p> <pre data-language="none">[qsort.hs:5:7-47] *Main&gt; :list
4
5  main = print (qsort [8, 4, 0, 3, 1, 23, 11, 18])
6
[qsort.hs:5:7-47] *Main&gt;
</pre> <p>In fact, GHCi provides a way to run a command when a breakpoint is hit, so we can make it automatically do <a class="reference internal" href="#ghci-cmd-:list"><code>:list</code></a>:</p> <pre data-language="none">[qsort.hs:5:7-47] *Main&gt; :set stop :list
[qsort.hs:5:7-47] *Main&gt; :step
Stopped at qsort.hs:5:14-46
_result :: [Integer]
4
5  main = print (qsort [8, 4, 0, 3, 1, 23, 11, 18])
6
[qsort.hs:5:14-46] *Main&gt;
</pre>   <h3 id="id14">6.5.3. Nested breakpoints</h3> <p id="nested-breakpoints">When GHCi is stopped at a breakpoint, and an expression entered at the prompt triggers a second breakpoint, the new breakpoint becomes the “current” one, and the old one is saved on a stack. An arbitrary number of breakpoint contexts can be built up in this way. For example:</p> <pre data-language="none">[qsort.hs:2:15-46] *Main&gt; :st qsort [1,3]
Stopped at qsort.hs:(1,0)-(3,55)
_result :: [a]
... [qsort.hs:(1,0)-(3,55)] *Main&gt;
</pre> <p>While stopped at the breakpoint on line 2 that we set earlier, we started a new evaluation with <code>:step qsort [1,3]</code>. This new evaluation stopped after one step (at the definition of <code>qsort</code>). The prompt has changed, now prefixed with <code>...</code>, to indicate that there are saved breakpoints beyond the current one. To see the stack of contexts, use <a class="reference internal" href="#ghci-cmd-:show%20context"><code>:show context</code></a>:</p> <pre data-language="none">... [qsort.hs:(1,0)-(3,55)] *Main&gt; :show context
--&gt; main
  Stopped at qsort.hs:2:15-46
--&gt; qsort [1,3]
  Stopped at qsort.hs:(1,0)-(3,55)
... [qsort.hs:(1,0)-(3,55)] *Main&gt;
</pre> <p>To abandon the current evaluation, use <a class="reference internal" href="#ghci-cmd-:abandon"><code>:abandon</code></a>:</p> <pre data-language="none">... [qsort.hs:(1,0)-(3,55)] *Main&gt; :abandon
[qsort.hs:2:15-46] *Main&gt; :abandon
*Main&gt;
</pre>   <h3 id="ghci-debugger-result">6.5.4. The <code>_result</code> variable</h3> <p id="the-result-variable">When stopped at a breakpoint or single-step, GHCi binds the variable <code>_result</code> to the value of the currently active expression. The value of <code>_result</code> is presumably not available yet, because we stopped its evaluation, but it can be forced: if the type is known and showable, then just entering <code>_result</code> at the prompt will show it. However, there’s one caveat to doing this: evaluating <code>_result</code> will be likely to trigger further breakpoints, starting with the breakpoint we are currently stopped at (if we stopped at a real breakpoint, rather than due to <a class="reference internal" href="#ghci-cmd-:step"><code>:step</code></a>). So it will probably be necessary to issue a <a class="reference internal" href="#ghci-cmd-:continue"><code>:continue</code></a> immediately when evaluating <code>_result</code>. Alternatively, you can use <a class="reference internal" href="#ghci-cmd-:force"><code>:force</code></a> which ignores breakpoints.</p>   <h3 id="tracing">6.5.5. Tracing and history</h3> <p id="tracing-and-history">A question that we often want to ask when debugging a program is “how did I get here?”. Traditional imperative debuggers usually provide some kind of stack-tracing feature that lets you see the stack of active function calls (sometimes called the “lexical call stack”), describing a path through the code to the current location. Unfortunately this is hard to provide in Haskell, because execution proceeds on a demand-driven basis, rather than a depth-first basis as in strict languages. The “stack“ in GHC’s execution engine bears little resemblance to the lexical call stack. Ideally GHCi would maintain a separate lexical call stack in addition to the dynamic call stack, and in fact this is exactly what our profiling system does (<a class="reference internal" href="profiling#profiling"><span class="std std-ref">Profiling</span></a>), and what some other Haskell debuggers do. For the time being, however, GHCi doesn’t maintain a lexical call stack (there are some technical challenges to be overcome). Instead, we provide a way to backtrack from a breakpoint to previous evaluation steps: essentially this is like single-stepping backwards, and should in many cases provide enough information to answer the “how did I get here?” question.</p> <p>To use tracing, evaluate an expression with the <a class="reference internal" href="#ghci-cmd-:trace"><code>:trace</code></a> command. For example, if we set a breakpoint on the base case of <code>qsort</code>:</p> <pre data-language="none">*Main&gt; :list qsort
1  qsort [] = []
2  qsort (a:as) = qsort left ++ [a] ++ qsort right
3    where (left,right) = (filter (&lt;=a) as, filter (&gt;a) as)
4
*Main&gt; :b 1
Breakpoint 1 activated at qsort.hs:1:11-12
*Main&gt;
</pre> <p>and then run a small <code>qsort</code> with tracing:</p> <pre data-language="none">*Main&gt; :trace qsort [3,2,1]
Stopped at qsort.hs:1:11-12
_result :: [a]
[qsort.hs:1:11-12] *Main&gt;
</pre> <p>We can now inspect the history of evaluation steps:</p> <pre data-language="none">[qsort.hs:1:11-12] *Main&gt; :hist
-1  : qsort.hs:3:24-38
-2  : qsort.hs:3:23-55
-3  : qsort.hs:(1,0)-(3,55)
-4  : qsort.hs:2:15-24
-5  : qsort.hs:2:15-46
-6  : qsort.hs:3:24-38
-7  : qsort.hs:3:23-55
-8  : qsort.hs:(1,0)-(3,55)
-9  : qsort.hs:2:15-24
-10 : qsort.hs:2:15-46
-11 : qsort.hs:3:24-38
-12 : qsort.hs:3:23-55
-13 : qsort.hs:(1,0)-(3,55)
-14 : qsort.hs:2:15-24
-15 : qsort.hs:2:15-46
-16 : qsort.hs:(1,0)-(3,55)
&lt;end of history&gt;
</pre> <p>To examine one of the steps in the history, use <a class="reference internal" href="#ghci-cmd-:back"><code>:back</code></a>:</p> <pre data-language="none">[qsort.hs:1:11-12] *Main&gt; :back
Logged breakpoint at qsort.hs:3:24-38
_result :: [a]
as :: [a]
a :: a
[-1: qsort.hs:3:24-38] *Main&gt;
</pre> <p>Note that the local variables at each step in the history have been preserved, and can be examined as usual. Also note that the prompt has changed to indicate that we’re currently examining the first step in the history: <code>-1</code>. The command <a class="reference internal" href="#ghci-cmd-:forward"><code>:forward</code></a> can be used to traverse forward in the history.</p> <p>The <a class="reference internal" href="#ghci-cmd-:trace"><code>:trace</code></a> command can be used with or without an expression. When used without an expression, tracing begins from the current breakpoint, just like <a class="reference internal" href="#ghci-cmd-:step"><code>:step</code></a>.</p> <p>The history is only available when using <a class="reference internal" href="#ghci-cmd-:trace"><code>:trace</code></a>; the reason for this is we found that logging each breakpoint in the history cuts performance by a factor of 2 or more.</p> <dl class="ghc-flag"> <dt id="ghc-flag--fghci-hist-size=⟨n⟩">
<code>-fghci-hist-size=⟨n⟩</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">50</td> </tr>  </table> <p>Modify the depth of the evaluation history tracked by GHCi.</p> </dd>
</dl>   <h3 id="ghci-debugger-exceptions">6.5.6. Debugging exceptions</h3> <p id="debugging-exceptions">Another common question that comes up when debugging is “where did this exception come from?”. Exceptions such as those raised by <code>error</code> or <code>head []</code> have no context information attached to them. Finding which particular call to <code>head</code> in your program resulted in the error can be a painstaking process, usually involving <code>Debug.Trace.trace</code>, or compiling with profiling and using <code>Debug.Trace.traceStack</code> or <code>+RTS -xc</code> (see <a class="reference internal" href="runtime_control#rts-flag--xc"><code>-xc</code></a>).</p> <p>The GHCi debugger offers a way to hopefully shed some light on these errors quickly and without modifying or recompiling the source code. One way would be to set a breakpoint on the location in the source code that throws the exception, and then use <a class="reference internal" href="#ghci-cmd-:trace"><code>:trace</code></a> and <a class="reference internal" href="#ghci-cmd-:history"><code>:history</code></a> to establish the context. However, <code>head</code> is in a library and we can’t set a breakpoint on it directly. For this reason, GHCi provides the flags <a class="reference internal" href="#ghc-flag--fbreak-on-exception"><code>-fbreak-on-exception</code></a> which causes the evaluator to stop when an exception is thrown, and <a class="reference internal" href="#ghc-flag--fbreak-on-error"><code>-fbreak-on-error</code></a>, which works similarly but stops only on uncaught exceptions. When stopping at an exception, GHCi will act just as it does when a breakpoint is hit, with the deviation that it will not show you any source code location. Due to this, these commands are only really useful in conjunction with <a class="reference internal" href="#ghci-cmd-:trace"><code>:trace</code></a>, in order to log the steps leading up to the exception. For example:</p> <pre data-language="none">*Main&gt; :set -fbreak-on-exception
*Main&gt; :trace qsort ("abc" ++ undefined)
“Stopped at &lt;exception thrown&gt;
_exception :: e
[&lt;exception thrown&gt;] *Main&gt; :hist
-1  : qsort.hs:3:24-38
-2  : qsort.hs:3:23-55
-3  : qsort.hs:(1,0)-(3,55)
-4  : qsort.hs:2:15-24
-5  : qsort.hs:2:15-46
-6  : qsort.hs:(1,0)-(3,55)
&lt;end of history&gt;
[&lt;exception thrown&gt;] *Main&gt; :back
Logged breakpoint at qsort.hs:3:24-38
_result :: [a]
as :: [a]
a :: a
[-1: qsort.hs:3:24-38] *Main&gt; :force as
*** Exception: Prelude.undefined
[-1: qsort.hs:3:24-38] *Main&gt; :print as
as = 'b' : 'c' : (_t1::[Char])
</pre> <p>The exception itself is bound to a new variable, <code>_exception</code>.</p> <p>Breaking on exceptions is particularly useful for finding out what your program was doing when it was in an infinite loop. Just hit Control-C, and examine the history to find out what was going on.</p> <dl class="ghc-flag"> <dt id="ghc-flag--fbreak-on-exception">
<code>-fbreak-on-exception</code> </dt> <dd>
<p>Causes GHCi to halt evaluation and return to the interactive prompt in the event of an exception. <a class="reference internal" href="#ghc-flag--fbreak-on-exception"><code>-fbreak-on-exception</code></a> breaks on all exceptions.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fbreak-on-error">
<code>-fbreak-on-error</code> </dt> <dd>
<p>Causes GHCi to halt evaluation and return to the interactive prompt in the event of an exception. <a class="reference internal" href="#ghc-flag--fbreak-on-error"><code>-fbreak-on-error</code></a> breaks on only those exceptions which would otherwise be uncaught.</p> </dd>
</dl>   <h3 id="example-inspecting-functions">6.5.7. Example: inspecting functions</h3> <p>It is possible to use the debugger to examine function values. When we are at a breakpoint and a function is in scope, the debugger cannot show you the source code for it; however, it is possible to get some information by applying it to some arguments and observing the result.</p> <p>The process is slightly complicated when the binding is polymorphic. We show the process by means of an example. To keep things simple, we will use the well known <code>map</code> function:</p> <pre data-language="haskell">import Prelude hiding (map)

map :: (a-&gt;b) -&gt; [a] -&gt; [b]
map f [] = []
map f (x:xs) = f x : map f xs
</pre> <p>We set a breakpoint on <code>map</code>, and call it.</p> <pre data-language="none">*Main&gt; :break 5
Breakpoint 0 activated at  map.hs:5:15-28
*Main&gt; map Just [1..5]
Stopped at map.hs:(4,0)-(5,12)
_result :: [b]
x :: a
f :: a -&gt; b
xs :: [a]
</pre> <p>GHCi tells us that, among other bindings, <code>f</code> is in scope. However, its type is not fully known yet, and thus it is not possible to apply it to any arguments. Nevertheless, observe that the type of its first argument is the same as the type of <code>x</code>, and its result type is shared with <code>_result</code>.</p> <p>As we demonstrated earlier (<a class="reference internal" href="#breakpoints"><span class="std std-ref">Breakpoints and inspecting variables</span></a>), the debugger has some intelligence built-in to update the type of <code>f</code> whenever the types of <code>x</code> or <code>_result</code> are discovered. So what we do in this scenario is force <code>x</code> a bit, in order to recover both its type and the argument part of <code>f</code>.</p> <pre data-language="none">*Main&gt; seq x ()
*Main&gt; :print x
x = 1
</pre> <p>We can check now that as expected, the type of <code>x</code> has been reconstructed, and with it the type of <code>f</code> has been too:</p> <pre data-language="none">*Main&gt; :t x
x :: Integer
*Main&gt; :t f
f :: Integer -&gt; b
</pre> <p>From here, we can apply f to any argument of type Integer and observe the results.</p> <pre data-language="none">*Main&gt; let b = f 10
*Main&gt; :t b
b :: b
*Main&gt; b
&lt;interactive&gt;:1:0:
    Ambiguous type variable `b' in the constraint:
      `Show b' arising from a use of `print' at &lt;interactive&gt;:1:0
*Main&gt; :p b
b = (_t2::a)
*Main&gt; seq b ()
()
*Main&gt; :t b
b :: a
*Main&gt; :p b
b = Just 10
*Main&gt; :t b
b :: Maybe Integer
*Main&gt; :t f
f :: Integer -&gt; Maybe Integer
*Main&gt; f 20
Just 20
*Main&gt; map f [1..5]
[Just 1, Just 2, Just 3, Just 4, Just 5]
</pre> <p>In the first application of <code>f</code>, we had to do some more type reconstruction in order to recover the result type of <code>f</code>. But after that, we are free to use <code>f</code> normally.</p>   <h3 id="limitations">6.5.8. Limitations</h3> <ul> <li>
<p class="first">When stopped at a breakpoint, if you try to evaluate a variable that is already under evaluation, the second evaluation will hang. The reason is that GHC knows the variable is under evaluation, so the new evaluation just waits for the result before continuing, but of course this isn’t going to happen because the first evaluation is stopped at a breakpoint. Control-C can interrupt the hung evaluation and return to the prompt.</p> <p>The most common way this can happen is when you’re evaluating a CAF (e.g. main), stop at a breakpoint, and ask for the value of the CAF at the prompt again.</p> </li> <li>Implicit parameters (see <a class="reference internal" href="glasgow_exts#implicit-parameters"><span class="std std-ref">Implicit parameters</span></a>) are only available at the scope of a breakpoint if there is an explicit type signature. </li> </ul>    <h2 id="ghci-invocation">6.6. Invoking GHCi</h2> <p id="invoking-ghci">GHCi is invoked with the command <code>ghci</code> or <code>ghc --interactive</code>. One or more modules or filenames can also be specified on the command line; this instructs GHCi to load the specified modules or filenames (and all the modules they depend on), just as if you had said <code>:load modules</code> at the GHCi prompt (see <a class="reference internal" href="#ghci-commands"><span class="std std-ref">GHCi commands</span></a>). For example, to start GHCi and load the program whose topmost module is in the file <code>Main.hs</code>, we could say:</p> <pre data-language="none">$ ghci Main.hs
</pre> <p>Most of the command-line options accepted by GHC (see <a class="reference internal" href="using#using-ghc"><span class="std std-ref">Using GHC</span></a>) also make sense in interactive mode. The ones that don’t make sense are mostly obvious.</p> <dl class="ghc-flag"> <dt id="ghc-flag--flocal-ghci-history">
<code>-flocal-ghci-history</code> </dt> <dd>
<p>By default, GHCi keeps global history in <code>~/.ghc/ghci_history</code> or <code>%APPDATA%/&lt;app&gt;/ghci_history</code>, but you can use current directory, e.g.:</p> <pre data-language="none">$ ghci -flocal-ghci-history
</pre> <p>It will create <code>.ghci-history</code> in current folder where GHCi is launched.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fghci-leak-check">
<code>-fghci-leak-check</code> </dt> <dd>
<p>(Debugging only) When loading new modules with <code>:load</code>, check that any previously loaded modules have been correctly garbage collected. Emits messages if a leak is detected.</p> </dd>
</dl>  <h3 id="packages">6.6.1. Packages</h3> <p id="index-17">Most packages (see <a class="reference internal" href="packages#using-packages"><span class="std std-ref">Using Packages</span></a>) are available without needing to specify any extra flags at all: they will be automatically loaded the first time they are needed.</p> <p>For hidden packages, however, you need to request the package be loaded by using the <a class="reference internal" href="#"><code>-package ⟨pkg⟩</code></a> flag:</p> <pre data-language="none">$ ghci -package readline
GHCi, version 8.y.z: https://www.haskell.org/ghc/  :? for help
Loading package base ... linking ... done.
Loading package readline-1.0 ... linking ... done.
Prelude&gt;
</pre> <p>The following command works to load new packages into a running GHCi:</p> <pre data-language="none">Prelude&gt; :set -package name
</pre> <p>But note that doing this will cause all currently loaded modules to be unloaded, and you’ll be dumped back into the <code>Prelude</code>.</p>   <h3 id="extra-libraries">6.6.2. Extra libraries</h3> <p id="index-18">Extra libraries may be specified on the command line using the normal <code>-llib</code> option. (The term <em>library</em> here refers to libraries of foreign object code; for using libraries of Haskell source code, see <a class="reference internal" href="#ghci-modules-filenames"><span class="std std-ref">Modules vs. filenames</span></a>.) For example, to load the “m” library:</p> <pre data-language="none">$ ghci -lm
</pre> <p>On systems with <code>.so</code>-style shared libraries, the actual library loaded will the <code>liblib.so</code>. GHCi searches the following places for libraries, in this order:</p> <ul class="simple"> <li>Paths specified using the <a class="reference internal" href="#"><code>-L ⟨dir⟩</code></a> command-line option,</li> <li>The standard library search path for your system loader, which on some systems may be overridden by setting the <code id="index-19">LD_LIBRARY_PATH</code> environment variable.</li> <li>The linker standard library search can also be overriden on some systems using the <code id="index-20">LIBRARY_PATH</code> environment variable. Because of some implementation detail on Windows, setting <code>LIBRARY_PATH</code> will also extend the system loader path for any library it finds. So often setting <code id="index-21">LIBRARY_PATH</code> is enough.</li> </ul> <p>On systems with <code>.dll</code>-style shared libraries, the actual library loaded will be <code>lib.dll</code>, <code>liblib.dll</code>. GHCi also has full support for import libraries, either Microsoft style <code>.lib</code>, or GNU GCC style <code>.a</code> and <code>.dll.a</code> libraries. If you have an import library it is advisable to always specify the import libary instead of the <code>.dll</code>. e.g. use <code>-lgcc` instead of
``-llibgcc_s_seh-1</code>. Again, GHCi will signal an error if it can’t find the library.</p> <p>GHCi can also load plain object files (<code>.o</code> or <code>.obj</code> depending on your platform) or static archives (<code>.a</code>) from the command-line. Just add the name the object file or library to the command line. On Windows GHCi also supports the <code>big-obj</code> format.</p> <p>Ordering of <code>-l</code> options matters: a library should be mentioned <em>before</em> the libraries it depends on (see <a class="reference internal" href="phases#options-linker"><span class="std std-ref">Options affecting linking</span></a>).</p>    <h2 id="id15">6.7. GHCi commands</h2> <p id="ghci-commands">GHCi commands all begin with “<code>:</code>” and consist of a single command name followed by zero or more parameters. The command name may be abbreviated, with ambiguities being resolved in favour of the more commonly used commands.</p> <dl class="ghci-cmd"> <dt id="ghci-cmd-:abandon">
<code>:abandon</code> </dt> <dd>
<p>Abandons the current evaluation (only available when stopped at a breakpoint).</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:add">
<code>:add[*] ⟨module⟩</code> </dt> <dd>
<p>Add ⟨module⟩(s) to the current target set, and perform a reload. Normally pre-compiled code for the module will be loaded if available, or otherwise the module will be compiled to byte-code. Using the <code>*</code> prefix forces the module to be loaded as byte-code.</p> <p>⟨module⟩ may be a file path. A “<code>~</code>” symbol at the beginning of ⟨module⟩ will be replaced by the contents of the environment variable <code id="index-22">HOME</code>.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:all-types">
<code>:all-types</code> </dt> <dd>
<p>List all types collected for expressions and (local) bindings currently loaded (while <a class="reference internal" href="#ghci-cmd-:set%20+c"><code>:set +c</code></a> was active) with their respective source-code span, e.g.</p> <pre data-language="haskell">GhciTypes&gt; :all-types
GhciTypes.hs:(38,13)-(38,24): Maybe Id
GhciTypes.hs:(45,10)-(45,29): Outputable SpanInfo
GhciTypes.hs:(45,10)-(45,29): (Rational -&gt; SpanInfo -&gt; SDoc) -&gt; Outputable SpanInfo
</pre> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:back">
<code>:back ⟨n⟩</code> </dt> <dd>
<p>Travel back ⟨n⟩ steps in the history. ⟨n⟩ is one if omitted. See <a class="reference internal" href="#tracing"><span class="std std-ref">Tracing and history</span></a> for more about GHCi’s debugging facilities. See also: <a class="reference internal" href="#ghci-cmd-:trace"><code>:trace</code></a>, <a class="reference internal" href="#ghci-cmd-:history"><code>:history</code></a>, <a class="reference internal" href="#ghci-cmd-:forward"><code>:forward</code></a>.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:break">
<code>:break [⟨identifier⟩ | [⟨module⟩] ⟨line⟩ [⟨column⟩]]</code> </dt> <dd>
<p>Set a breakpoint on the specified function or line and column. See <a class="reference internal" href="#setting-breakpoints"><span class="std std-ref">Setting breakpoints</span></a>.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:browse">
<code>:browse[!] [[*] ⟨module⟩]</code> </dt> <dd>
<p>Displays the identifiers exported by the module ⟨module⟩, which must be either loaded into GHCi or be a member of a package. If ⟨module⟩ is omitted, the most recently-loaded module is used.</p> <p>Like all other GHCi commands, the output is always displayed in the current GHCi scope (<a class="reference internal" href="#ghci-scope"><span class="std std-ref">What’s really in scope at the prompt?</span></a>).</p> <p>There are two variants of the browse command:</p> <ul> <li>
<p class="first">If the <code>*</code> symbol is placed before the module name, then <em>all</em> the identifiers in scope in ⟨module⟩ (rather that just its exports) are shown.</p> <p>The <code>*</code>-form is only available for modules which are interpreted; for compiled modules (including modules from packages) only the non-<code>*</code> form of <a class="reference internal" href="#ghci-cmd-:browse"><code>:browse</code></a> is available.</p> </li> <li>
<p class="first">Data constructors and class methods are usually displayed in the context of their data type or class declaration. However, if the <code>!</code> symbol is appended to the command, thus <code>:browse!</code>, they are listed individually. The <code>!</code>-form also annotates the listing with comments giving possible imports for each group of entries. Here is an example:</p> <pre data-language="haskell">Prelude&gt; :browse! Data.Maybe
-- not currently imported
Data.Maybe.catMaybes :: [Maybe a] -&gt; [a]
Data.Maybe.fromJust :: Maybe a -&gt; a
Data.Maybe.fromMaybe :: a -&gt; Maybe a -&gt; a
Data.Maybe.isJust :: Maybe a -&gt; Bool
Data.Maybe.isNothing :: Maybe a -&gt; Bool
Data.Maybe.listToMaybe :: [a] -&gt; Maybe a
Data.Maybe.mapMaybe :: (a -&gt; Maybe b) -&gt; [a] -&gt; [b]
Data.Maybe.maybeToList :: Maybe a -&gt; [a]
-- imported via Prelude
Just :: a -&gt; Maybe a
data Maybe a = Nothing | Just a
Nothing :: Maybe a
maybe :: b -&gt; (a -&gt; b) -&gt; Maybe a -&gt; b
</pre> <p>This output shows that, in the context of the current session (ie in the scope of <code>Prelude</code>), the first group of items from <code>Data.Maybe</code> are not in scope (althought they are available in fully qualified form in the GHCi session - see <a class="reference internal" href="#ghci-scope"><span class="std std-ref">What’s really in scope at the prompt?</span></a>), whereas the second group of items are in scope (via <code>Prelude</code>) and are therefore available either unqualified, or with a <code>Prelude.</code> qualifier.</p> </li> </ul> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:cd">
<code>:cd ⟨dir⟩</code> </dt> <dd>
<p>Changes the current working directory to ⟨dir⟩. A “<code>~</code>” symbol at the beginning of ⟨dir⟩ will be replaced by the contents of the environment variable <code id="index-23">HOME</code>. See also the <a class="reference internal" href="#ghci-cmd-:show%20paths"><code>:show paths</code></a> command for showing the current working directory.</p> <p>Note: changing directories causes all currently loaded modules to be unloaded. This is because the search path is usually expressed using relative directories, and changing the search path in the middle of a session is not supported.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:cmd">
<code>:cmd ⟨expr⟩</code> </dt> <dd>
<p>Executes ⟨expr⟩ as a computation of type <code>IO String</code>, and then executes the resulting string as a list of GHCi commands. Multiple commands are separated by newlines. The <a class="reference internal" href="#ghci-cmd-:cmd"><code>:cmd</code></a> command is useful with <a class="reference internal" href="#ghci-cmd-:def"><code>:def</code></a> and <a class="reference internal" href="#ghci-cmd-:set%20stop"><code>:set stop</code></a>.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:complete">
<code>:complete ⟨type⟩ [⟨n⟩-][⟨m⟩] ⟨string-literal⟩</code> </dt> <dd>
<p>This command allows to request command completions from GHCi even when interacting over a pipe instead of a proper terminal and is designed for integrating GHCi’s completion with text editors and IDEs.</p> <p>When called, <a class="reference internal" href="#ghci-cmd-:complete"><code>:complete</code></a> prints the ⟨n⟩<sup>th</sup> to ⟨m⟩<sup>th</sup> completion candidates for the partial input ⟨string-literal⟩ for the completion domain denoted by ⟨type⟩. Currently, only the <code>repl</code> domain is supported which denotes the kind of completion that would be provided interactively by GHCi at the input prompt.</p> <p>If omitted, ⟨n⟩ and ⟨m⟩ default to the first or last available completion candidate respectively. If there are less candidates than requested via the range argument, ⟨n⟩ and ⟨m⟩ are implicitly capped to the number of available completion candidates.</p> <p>The output of <a class="reference internal" href="#ghci-cmd-:complete"><code>:complete</code></a> begins with a header line containing three space-delimited fields:</p> <ul class="simple"> <li>An integer denoting the number <code>l</code> of printed completions,</li> <li>an integer denoting the total number of completions available, and finally</li> <li>a string literal denoting a common prefix to be added to the returned completion candidates.</li> </ul> <p>The header line is followed by ⟨l⟩ lines each containing one completion candidate encoded as (quoted) string literal. Here are some example invocations showing the various cases:</p> <pre data-language="none">Prelude&gt; :complete repl 0 ""
0 470 ""
Prelude&gt; :complete repl 5 "import For"
5 21 "import "
"Foreign"
"Foreign.C"
"Foreign.C.Error"
"Foreign.C.String"
"Foreign.C.Types"
Prelude&gt; :complete repl 5-10 "import For"
6 21 "import "
"Foreign.C.Types"
"Foreign.Concurrent"
"Foreign.ForeignPtr"
"Foreign.ForeignPtr.Safe"
"Foreign.ForeignPtr.Unsafe"
"Foreign.Marshal"
Prelude&gt; :complete repl 20- "import For"
2 21 "import "
"Foreign.StablePtr"
"Foreign.Storable"
Prelude&gt; :complete repl "map"
3 3 ""
"map"
"mapM"
"mapM_"
Prelude&gt; :complete repl 5-10 "map"
0 3 ""
</pre> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:continue">
<code>:continue</code> </dt> <dd>
<p>Continue the current evaluation, when stopped at a breakpoint.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:ctags">
<code>:ctags [⟨filename⟩]</code> </dt> <dd>
<p>Generates a “tags” file for Vi-style editors (<a class="reference internal" href="#ghci-cmd-:ctags"><code>:ctags</code></a>) or Emacs-style editors (<a class="reference internal" href="#ghci-cmd-:etags"><code>:etags</code></a>). If no filename is specified, the default <code>tags</code> or <code>TAGS</code> is used, respectively. Tags for all the functions, constructors and types in the currently loaded modules are created. All modules must be interpreted for these commands to work.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:def">
<code>:def[!] ⟨name⟩ ⟨expr⟩</code> </dt> <dd>
<p><a class="reference internal" href="#ghci-cmd-:def"><code>:def</code></a> is used to define new commands, or macros, in GHCi. The command <code>:def ⟨name⟩ ⟨expr⟩</code> defines a new GHCi command <code>:name</code>, implemented by the Haskell expression ⟨expr⟩, which must have type <code>String -&gt; IO String</code>. When <code>:name args</code> is typed at the prompt, GHCi will run the expression <code>(name args)</code>, take the resulting <code>String</code>, and feed it back into GHCi as a new sequence of commands. Separate commands in the result must be separated by “<code>\n</code>”.</p> <p>That’s all a little confusing, so here’s a few examples. To start with, here’s a new GHCi command which doesn’t take any arguments or produce any results, it just outputs the current date and time:</p> <pre data-language="none">Prelude&gt; let date _ = Data.Time.getZonedTime &gt;&gt;= print &gt;&gt; return ""
Prelude&gt; :def date date
Prelude&gt; :date
2017-04-10 12:34:56.93213581 UTC
</pre> <p>Here’s an example of a command that takes an argument. It’s a re-implementation of <a class="reference internal" href="#ghci-cmd-:cd"><code>:cd</code></a>:</p> <pre data-language="none">Prelude&gt; let mycd d = System.Directory.setCurrentDirectory d &gt;&gt; return ""
Prelude&gt; :def mycd mycd
Prelude&gt; :mycd ..
</pre> <p>Or I could define a simple way to invoke “<code>ghc --make Main</code>” in the current directory:</p> <pre data-language="none">Prelude&gt; :def make (\_ -&gt; return ":! ghc --make Main")
</pre> <p>We can define a command that reads GHCi input from a file. This might be useful for creating a set of bindings that we want to repeatedly load into the GHCi session:</p> <pre data-language="none">Prelude&gt; :def . readFile
Prelude&gt; :. cmds.ghci
</pre> <p>Notice that we named the command <code>:.</code>, by analogy with the “<code>.</code>” Unix shell command that does the same thing.</p> <p>Typing <code>:def</code> on its own lists the currently-defined macros. Attempting to redefine an existing command name results in an error unless the <code>:def!</code> form is used, in which case the old command with that name is silently overwritten.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:delete">
<code>:delete * | ⟨num⟩ ...</code> </dt> <dd>
<p>Delete one or more breakpoints by number (use <a class="reference internal" href="#ghci-cmd-:show%20breaks"><code>:show breaks</code></a> to see the number of each breakpoint). The <code>*</code> form deletes all the breakpoints.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:doc">
<code>:doc ⟨name⟩</code> </dt> <dd>
<p>(Experimental: This command will likely change significantly in GHC 8.8.)</p> <p>Displays the documentation for the given name. Currently the command is restricted to displaying the documentation directly on the declaration in question, ignoring documentation for arguments, constructors etc.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:edit">
<code>:edit ⟨file⟩</code> </dt> <dd>
<p>Opens an editor to edit the file ⟨file⟩, or the most recently loaded module if ⟨file⟩ is omitted. If there were errors during the last loading, the cursor will be positioned at the line of the first error. The editor to invoke is taken from the <code id="index-24">EDITOR</code> environment variable, or a default editor on your system if <code id="index-25">EDITOR</code> is not set. You can change the editor using <a class="reference internal" href="#ghci-cmd-:set%20editor"><code>:set editor</code></a>.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:etags">
<code>:etags</code> </dt> <dd>
<p>See <a class="reference internal" href="#ghci-cmd-:ctags"><code>:ctags</code></a>.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:force">
<code>:force ⟨identifier⟩ ...</code> </dt> <dd>
<p>Prints the value of ⟨identifier⟩ in the same way as <a class="reference internal" href="#ghci-cmd-:print"><code>:print</code></a>. Unlike <a class="reference internal" href="#ghci-cmd-:print"><code>:print</code></a>, <a class="reference internal" href="#ghci-cmd-:force"><code>:force</code></a> evaluates each thunk that it encounters while traversing the value. This may cause exceptions or infinite loops, or further breakpoints (which are ignored, but displayed).</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:forward">
<code>:forward ⟨n⟩</code> </dt> <dd>
<p>Move forward ⟨n⟩ steps in the history. ⟨n⟩ is one if omitted. See <a class="reference internal" href="#tracing"><span class="std std-ref">Tracing and history</span></a> for more about GHCi’s debugging facilities. See also: <a class="reference internal" href="#ghci-cmd-:trace"><code>:trace</code></a>, <a class="reference internal" href="#ghci-cmd-:history"><code>:history</code></a>, <a class="reference internal" href="#ghci-cmd-:back"><code>:back</code></a>.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:help">
<code>:help</code> </dt> <dt id="ghci-cmd-:?">
<code>:?</code> </dt> <dd>
<p>Displays a list of the available commands.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:">
<code>:</code> </dt> <dd>
<p id="index-26">Repeat the previous command.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:history">
<code>:history [num]</code> </dt> <dd>
<p>Display the history of evaluation steps. With a number, displays that many steps (default: 20). For use with <a class="reference internal" href="#ghci-cmd-:trace"><code>:trace</code></a>; see <a class="reference internal" href="#tracing"><span class="std std-ref">Tracing and history</span></a>. To set the number of history entries stored by GHCi, use the <a class="reference internal" href="#ghc-flag--fghci-hist-size=%E2%9F%A8n%E2%9F%A9"><code>-fghci-hist-size=⟨n⟩</code></a> flag.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:info">
<code>:info[!] ⟨name⟩</code> </dt> <dd>
<p>Displays information about the given name(s). For example, if ⟨name⟩ is a class, then the class methods and their types will be printed; if ⟨name⟩ is a type constructor, then its definition will be printed; if ⟨name⟩ is a function, then its type will be printed. If ⟨name⟩ has been loaded from a source file, then GHCi will also display the location of its definition in the source.</p> <p>For types and classes, GHCi also summarises instances that mention them. To avoid showing irrelevant information, an instance is shown only if (a) its head mentions ⟨name⟩, and (b) all the other things mentioned in the instance are in scope (either qualified or otherwise) as a result of a <a class="reference internal" href="#ghci-cmd-:load"><code>:load</code></a> or <a class="reference internal" href="#ghci-cmd-:module"><code>:module</code></a> commands.</p> <p>The command <code>:info!</code> works in a similar fashion but it removes restriction (b), showing all instances that are in scope and mention ⟨name⟩ in their head.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:issafe">
<code>:issafe [⟨module⟩]</code> </dt> <dd>
<p>Displays Safe Haskell information about the given module (or the current module if omitted). This includes the trust type of the module and its containing package.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:kind">
<code>:kind[!] ⟨type⟩</code> </dt> <dd>
<p>Infers and prints the kind of ⟨type⟩. The latter can be an arbitrary type expression, including a partial application of a type constructor, such as <code>Either Int</code>. In fact, <a class="reference internal" href="#ghci-cmd-:kind"><code>:kind</code></a> even allows you to write a partial application of a type synonym (usually disallowed), so that this works:</p> <pre data-language="none">ghci&gt; type T a b = (a,b,a)
ghci&gt; :k T Int Bool
T Int Bool :: *
ghci&gt; :k T
T :: * -&gt; * -&gt; *
ghci&gt; :k T Int
T Int :: * -&gt; *
</pre> <p>If you specify the optional “<code>!</code>”, GHC will in addition normalise the type by expanding out type synonyms and evaluating type-function applications, and display the normalised result.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:list">
<code>:list ⟨identifier⟩</code> </dt> <dd>
<p>Lists the source code around the definition of ⟨identifier⟩ or the current breakpoint if not given. This requires that the identifier be defined in an interpreted module. If your output device supports it, then GHCi will highlight the active subexpression in bold.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:list [⟨module⟩]">
<code>:list [⟨module⟩] ⟨line⟩</code> </dt> <dd>
<p>Lists the source code around the given line number of ⟨module⟩. This requires that the module be interpreted. If your output device supports it, then GHCi will highlight the active subexpression in bold.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:load">
<code>:load[!] [*]⟨module⟩</code> </dt> <dd>
<p>Recursively loads the specified ⟨module⟩s, and all the modules they depend on. Here, each ⟨module⟩ must be a module name or filename, but may not be the name of a module in a package.</p> <p>All previously loaded modules, except package modules, are forgotten. The new set of modules is known as the target set. Note that <a class="reference internal" href="#ghci-cmd-:load"><code>:load</code></a> can be used without any arguments to unload all the currently loaded modules and bindings.</p> <p>Normally pre-compiled code for a module will be loaded if available, or otherwise the module will be compiled to byte-code. Using the <code>*</code> prefix forces a module to be loaded as byte-code.</p> <p>Adding the optional “<code>!</code>” turns type errors into warnings while loading. This allows to use the portions of the module that are correct, even if there are type errors in some definitions. Effectively, the “-fdefer-type-errors” flag is set before loading and unset after loading if the flag has not already been set before. See <a class="reference internal" href="glasgow_exts#defer-type-errors"><span class="std std-ref">Deferring type errors to runtime</span></a> for further motivation and details.</p> <p>After a <a class="reference internal" href="#ghci-cmd-:load"><code>:load</code></a> command, the current context is set to:</p> <ul class="simple"> <li>⟨module⟩, if it was loaded successfully, or</li> <li>the most recently successfully loaded module, if any other modules were loaded as a result of the current <a class="reference internal" href="#ghci-cmd-:load"><code>:load</code></a>, or</li> <li>
<code>Prelude</code> otherwise.</li> </ul> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:loc-at">
<code>:loc-at ⟨module⟩ ⟨line⟩ ⟨col⟩ ⟨end-line⟩ ⟨end-col⟩ [⟨name⟩]</code> </dt> <dd>
<p>Tries to find the definition site of the name at the given source-code span, e.g.:</p> <pre data-language="none">X&gt; :loc-at X.hs 6 14 6 16 mu
X.hs:(8,7)-(8,9)
</pre> <p>This command is useful when integrating GHCi with text editors and IDEs for providing a goto-definition facility.</p> <p>The <code>:loc-at</code> command requires <a class="reference internal" href="#ghci-cmd-:set%20+c"><code>:set +c</code></a> to be set.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:main">
<code>:main ⟨arg1⟩ ... ⟨argn⟩</code> </dt> <dd>
<p>When a program is compiled and executed, it can use the <code>getArgs</code> function to access the command-line arguments. However, we cannot simply pass the arguments to the <code>main</code> function while we are testing in ghci, as the <code>main</code> function doesn’t take its arguments directly.</p> <p>Instead, we can use the <a class="reference internal" href="#ghci-cmd-:main"><code>:main</code></a> command. This runs whatever <code>main</code> is in scope, with any arguments being treated the same as command-line arguments, e.g.:</p> <pre data-language="none">Prelude&gt; main = System.Environment.getArgs &gt;&gt;= print
Prelude&gt; :main foo bar
["foo","bar"]
</pre> <p>We can also quote arguments which contains characters like spaces, and they are treated like Haskell strings, or we can just use Haskell list syntax:</p> <pre data-language="none">Prelude&gt; :main foo "bar baz"
["foo","bar baz"]
Prelude&gt; :main ["foo", "bar baz"]
["foo","bar baz"]
</pre> <p>Finally, other functions can be called, either with the <code>-main-is</code> flag or the <a class="reference internal" href="#ghci-cmd-:run"><code>:run</code></a> command:</p> <pre data-language="none">Prelude&gt; foo = putStrLn "foo" &gt;&gt; System.Environment.getArgs &gt;&gt;= print
Prelude&gt; bar = putStrLn "bar" &gt;&gt; System.Environment.getArgs &gt;&gt;= print
Prelude&gt; :set -main-is foo
Prelude&gt; :main foo "bar baz"
foo
["foo","bar baz"]
Prelude&gt; :run bar ["foo", "bar baz"]
bar
["foo","bar baz"]
</pre> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:module">
<code>:module +|- [*]⟨mod1⟩ ...</code> </dt> 
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-import">
<code>import ⟨mod⟩</code> </dt> <dd>
<p>Sets or modifies the current context for statements typed at the prompt. The form <code>import mod</code> is equivalent to <code>:module +mod</code>. See <a class="reference internal" href="#ghci-scope"><span class="std std-ref">What’s really in scope at the prompt?</span></a> for more details.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:print">
<code>:print ⟨names⟩</code> </dt> <dd>
<p>Prints a value without forcing its evaluation. <a class="reference internal" href="#ghci-cmd-:print"><code>:print</code></a> may be used on values whose types are unknown or partially known, which might be the case for local variables with polymorphic types at a breakpoint. While inspecting the runtime value, <a class="reference internal" href="#ghci-cmd-:print"><code>:print</code></a> attempts to reconstruct the type of the value, and will elaborate the type in GHCi’s environment if possible. If any unevaluated components (thunks) are encountered, then <a class="reference internal" href="#ghci-cmd-:print"><code>:print</code></a> binds a fresh variable with a name beginning with <code>_t</code> to each thunk. See <a class="reference internal" href="#breakpoints"><span class="std std-ref">Breakpoints and inspecting variables</span></a> for more information. See also the <a class="reference internal" href="#ghci-cmd-:sprint"><code>:sprint</code></a> command, which works like <a class="reference internal" href="#ghci-cmd-:print"><code>:print</code></a> but does not bind new variables.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:quit">
<code>:quit</code> </dt> <dd>
<p>Quits GHCi. You can also quit by typing <code>Control-D</code> at the prompt.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:reload">
<code>:reload[!]</code> </dt> <dd>
<p>Attempts to reload the current target set (see <a class="reference internal" href="#ghci-cmd-:load"><code>:load</code></a>) if any of the modules in the set, or any dependent module, has changed. Note that this may entail loading new modules, or dropping modules which are no longer indirectly required by the target.</p> <p>Adding the optional “<code>!</code>” turns type errors into warnings while loading. This allows to use the portions of the module that are correct, even if there are type errors in some definitions. Effectively, the “-fdefer-type-errors” flag is set before loading and unset after loading if the flag has not already been set before. See <a class="reference internal" href="glasgow_exts#defer-type-errors"><span class="std std-ref">Deferring type errors to runtime</span></a> for further motivation and details.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:run">
<code>:run</code> </dt> <dd>
<p>See <a class="reference internal" href="#ghci-cmd-:main"><code>:main</code></a>.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:script">
<code>:script [⟨n⟩] ⟨filename⟩</code> </dt> <dd>
<p>Executes the lines of a file as a series of GHCi commands. This command is compatible with multiline statements as set by <a class="reference internal" href="#ghci-cmd-:set%20+m"><code>:set +m</code></a></p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:set">
<code>:set [⟨option⟩ ...]</code> </dt> <dd>
<p>Sets various options. See <a class="reference internal" href="#ghci-set"><span class="std std-ref">The :set and :seti commands</span></a> for a list of available options and <a class="reference internal" href="flags#interactive-mode-options"><span class="std std-ref">Interactive-mode options</span></a> for a list of GHCi-specific flags. The <a class="reference internal" href="#ghci-cmd-:set"><code>:set</code></a> command by itself shows which options are currently set. It also lists the current dynamic flag settings, with GHCi-specific flags listed separately.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:set args">
<code>:set args ⟨arg⟩</code> </dt> <dd>
<p id="index-27">Sets the list of arguments which are returned when the program calls <code>System.getArgs</code>.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:set editor">
<code>:set editor ⟨cmd⟩</code> </dt> <dd>
<p>Sets the command used by <a class="reference internal" href="#ghci-cmd-:edit"><code>:edit</code></a> to ⟨cmd⟩.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:set prog">
<code>:set prog ⟨prog⟩</code> </dt> <dd>
<p id="index-28">Sets the string to be returned when the program calls <code>System.getProgName</code>.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:set prompt">
<code>:set prompt ⟨prompt⟩</code> </dt> <dd>
<p id="index-29">Sets the string to be used as the prompt in GHCi. Inside ⟨prompt⟩, the next sequences are replaced:</p> <ul class="simple"> <li>
<code>%s</code> by the names of the modules currently in scope.</li> <li>
<code>%l</code> by the line number (as referenced in compiler messages) of the current prompt.</li> <li>
<code>%d</code> by the date in “Weekday Month Date” format (e.g., “Tue May 26”) .</li> <li>
<code>%t</code> by the current time in 24-hour HH:MM:SS format.</li> <li>
<code>%T</code> by the current time in 12-hour HH:MM:SS format.</li> <li>
<code>%@</code> by the current time in 12-hour am/pm format.</li> <li>
<code>%A</code> by the current time in 24-hour HH:MM format.</li> <li>
<code>%u</code> by the username of the current user.</li> <li>
<code>%w</code> by the current working directory.</li> <li>
<code>%o</code> by the operating system.</li> <li>
<code>%a</code> by the machine architecture.</li> <li>
<code>%N</code> by the compiler name.</li> <li>
<code>%V</code> by the compiler version.</li> <li>
<code>%call(cmd [args])</code> by the result of calling <code>cmd args</code>.</li> <li>
<code>%%</code> by <code>%</code>.</li> </ul> <p>If ⟨prompt⟩ starts with <code>"</code> then it is parsed as a Haskell String; otherwise it is treated as a literal string.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:set prompt-cont">
<code>:set prompt-cont ⟨prompt⟩</code> </dt> <dd>
<p>Sets the string to be used as the continuation prompt (used when using the <a class="reference internal" href="#ghci-cmd-:%7B"><code>:{</code></a> command) in GHCi.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:set prompt-function">
<code>:set prompt-function ⟨prompt-function⟩</code> </dt> <dd>
<p id="index-30">Sets the function to be used for the prompt displaying in GHCi. The function should be of the type <code>[String] -&gt; Int -&gt; IO String</code>. This function is called each time the prompt is being made. The first argument stands for the names of the modules currently in scope(the name of the “topmost” module will begin with a <code>*</code>; see <a class="reference internal" href="#ghci-scope"><span class="std std-ref">What’s really in scope at the prompt?</span></a> for more information). The second arguments is the line number (as referenced in compiler messages) of the current prompt.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:set prompt-cont-function">
<code>:set prompt-cont-function ⟨prompt-function⟩</code> </dt> <dd>
<p>Sets the function to be used for the continuation prompt (used when using the <a class="reference internal" href="#ghci-cmd-:%7B"><code>:{</code></a> command) displaying in GHCi.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:set stop">
<code>:set stop ⟨num⟩ ⟨cmd⟩</code> </dt> <dd>
<p>Set a command to be executed when a breakpoint is hit, or a new item in the history is selected. The most common use of <a class="reference internal" href="#ghci-cmd-:set%20stop"><code>:set stop</code></a> is to display the source code at the current location, e.g. <code>:set stop :list</code>.</p> <p>If a number is given before the command, then the commands are run when the specified breakpoint (only) is hit. This can be quite useful: for example, <code>:set stop 1 :continue</code> effectively disables breakpoint 1, by running <a class="reference internal" href="#ghci-cmd-:continue"><code>:continue</code></a> whenever it is hit (although GHCi will still emit a message to say the breakpoint was hit). What’s more, with cunning use of <a class="reference internal" href="#ghci-cmd-:def"><code>:def</code></a> and <a class="reference internal" href="#ghci-cmd-:cmd"><code>:cmd</code></a> you can use <a class="reference internal" href="#ghci-cmd-:set%20stop"><code>:set stop</code></a> to implement conditional breakpoints:</p> <pre data-language="none">*Main&gt; :def cond \expr -&gt; return (":cmd if (" ++ expr ++ ") then return \"\" else return \":continue\"")
*Main&gt; :set stop 0 :cond (x &lt; 3)
</pre> <p>Ignoring breakpoints for a specified number of iterations is also possible using similar techniques.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:seti">
<code>:seti [⟨option⟩ ...]</code> </dt> <dd>
<p>Like <a class="reference internal" href="#ghci-cmd-:set"><code>:set</code></a>, but options set with <a class="reference internal" href="#ghci-cmd-:seti"><code>:seti</code></a> affect only expressions and commands typed at the prompt, and not modules loaded with <a class="reference internal" href="#ghci-cmd-:load"><code>:load</code></a> (in contrast, options set with <a class="reference internal" href="#ghci-cmd-:set"><code>:set</code></a> apply everywhere). See <a class="reference internal" href="#ghci-interactive-options"><span class="std std-ref">Setting options for interactive evaluation only</span></a>.</p> <p>Without any arguments, displays the current set of options that are applied to expressions and commands typed at the prompt.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:show bindings">
<code>:show bindings</code> </dt> <dd>
<p>Show the bindings made at the prompt and their types.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:show breaks">
<code>:show breaks</code> </dt> <dd>
<p>List the active breakpoints.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:show context">
<code>:show context</code> </dt> <dd>
<p>List the active evaluations that are stopped at breakpoints.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:show imports">
<code>:show imports</code> </dt> <dd>
<p>Show the imports that are currently in force, as created by <code>import</code> and <a class="reference internal" href="#ghci-cmd-:module"><code>:module</code></a> commands.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:show modules">
<code>:show modules</code> </dt> <dd>
<p>Show the list of modules currently loaded.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:show packages">
<code>:show packages</code> </dt> <dd>
<p>Show the currently active package flags, as well as the list of packages currently loaded.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:show paths">
<code>:show paths</code> </dt> <dd>
<p>Show the current working directory (as set via <a class="reference internal" href="#ghci-cmd-:cd"><code>:cd</code></a> command), as well as the list of directories searched for source files (as set by the <code>-i</code> option).</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:show language">
<code>:show language</code> </dt> <dd>
<p>Show the currently active language flags for source files.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:showi language">
<code>:showi language</code> </dt> <dd>
<p>Show the currently active language flags for expressions typed at the prompt (see also <a class="reference internal" href="#ghci-cmd-:seti"><code>:seti</code></a>).</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:show">
<code>:show [args|prog|prompt|editor|stop]</code> </dt> <dd>
<p>Displays the specified setting (see <a class="reference internal" href="#ghci-cmd-:set"><code>:set</code></a>).</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:sprint">
<code>:sprint ⟨expr⟩</code> </dt> <dd>
<p>Prints a value without forcing its evaluation. <a class="reference internal" href="#ghci-cmd-:sprint"><code>:sprint</code></a> is similar to <a class="reference internal" href="#ghci-cmd-:print"><code>:print</code></a>, with the difference that unevaluated subterms are not bound to new variables, they are simply denoted by <code>_</code>.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:step">
<code>:step [⟨expr⟩]</code> </dt> <dd>
<p>Enable all breakpoints and begin evaluating an expression in single-stepping mode. In this mode evaluation will be stopped after every reduction, allowing local variables to be inspected. If ⟨expr⟩ is not given, evaluation will resume at the last breakpoint. See <a class="reference internal" href="#single-stepping"><span class="std std-ref">Single-stepping</span></a>.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:steplocal">
<code>:steplocal</code> </dt> <dd>
<p>Enable only breakpoints in the current top-level binding and resume evaluation at the last breakpoint. Continuation with <a class="reference internal" href="#ghci-cmd-:steplocal"><code>:steplocal</code></a> is not possible if this last breakpoint was hit by an error (<a class="reference internal" href="#ghc-flag--fbreak-on-error"><code>-fbreak-on-error</code></a>) or an exception (<a class="reference internal" href="#ghc-flag--fbreak-on-exception"><code>-fbreak-on-exception</code></a>).</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:stepmodule">
<code>:stepmodule</code> </dt> <dd>
<p>Enable only breakpoints in the current module and resume evaluation at the last breakpoint.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:trace">
<code>:trace ⟨expr⟩</code> </dt> <dd>
<p>Evaluates the given expression (or from the last breakpoint if no expression is given), and additionally logs the evaluation steps for later inspection using <a class="reference internal" href="#ghci-cmd-:history"><code>:history</code></a>. See <a class="reference internal" href="#tracing"><span class="std std-ref">Tracing and history</span></a>.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:type">
<code>:type ⟨expression⟩</code> </dt> <dd>
<p>Infers and prints the type of ⟨expression⟩, including explicit forall quantifiers for polymorphic types. The type reported is the type that would be inferred for a variable assigned to the expression, but without the monomorphism restriction applied.</p> <pre data-language="none">*X&gt; :type length
length :: Foldable t =&gt; t a -&gt; Int
</pre> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:type +v">
<code>:type +v ⟨expression⟩</code> </dt> <dd>
<p>Infers and prints the type of ⟨expression⟩, but without fiddling with type variables or class constraints. This is useful when you are using <a class="reference internal" href="glasgow_exts#extension-TypeApplications"><code>TypeApplications</code></a> and care about the distinction between specified type variables (available for type application) and inferred type variables (not available). This mode sometimes prints constraints (such as <code>Show Int</code>) that could readily be solved, but solving these constraints may affect the type variables, so GHC refrains.</p> <pre data-language="none">*X&gt; :set -fprint-explicit-foralls
*X&gt; :type +v length
length :: forall (t :: * -&gt; *). Foldable t =&gt; forall a. t a -&gt; Int
</pre> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:type +d">
<code>:type +d ⟨expression⟩</code> </dt> <dd>
<p>Infers and prints the type of ⟨expression⟩, defaulting type variables if possible. In this mode, if the inferred type is constrained by any interactive class (<code>Num</code>, <code>Show</code>, <code>Eq</code>, <code>Ord</code>, <code>Foldable</code>, or <code>Traversable</code>), the constrained type variable(s) are defaulted according to the rules described under <a class="reference internal" href="#extension-ExtendedDefaultRules"><code>ExtendedDefaultRules</code></a>. This mode is quite useful when the inferred type is quite general (such as for <code>foldr</code>) and it may be helpful to see a more concrete instantiation.</p> <pre data-language="none">*X&gt; :type +d length
length :: [a] -&gt; Int
</pre> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:type-at">
<code>:type-at ⟨module⟩ ⟨line⟩ ⟨col⟩ ⟨end-line⟩ ⟨end-col⟩ [⟨name⟩]</code> </dt> <dd>
<p>Reports the inferred type at the given span/position in the module, e.g.:</p> <pre data-language="none">*X&gt; :type-at X.hs 6 6 6 7 f
Int -&gt; Int
</pre> <p>This command is useful when integrating GHCi with text editors and IDEs for providing a show-type-under-point facility.</p> <p>The last string parameter is useful for when the span is out of date, i.e. the file changed and the code has moved. In which case <a class="reference internal" href="#ghci-cmd-:type-at"><code>:type-at</code></a> falls back to a general <a class="reference internal" href="#ghci-cmd-:type"><code>:type</code></a> like lookup.</p> <p>The <a class="reference internal" href="#ghci-cmd-:type-at"><code>:type-at</code></a> command requires <a class="reference internal" href="#ghci-cmd-:set%20+c"><code>:set +c</code></a> to be set.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:undef">
<code>:undef ⟨name⟩</code> </dt> <dd>
<p>Undefines the user-defined command ⟨name⟩ (see <a class="reference internal" href="#ghci-cmd-:def"><code>:def</code></a> above).</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:unset">
<code>:unset ⟨option⟩</code> </dt> <dd>
<p>Unsets certain options. See <a class="reference internal" href="#ghci-set"><span class="std std-ref">The :set and :seti commands</span></a> for a list of available options.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:uses">
<code>:uses ⟨module⟩ ⟨line⟩ ⟨col⟩ ⟨end-line⟩ ⟨end-col⟩ [⟨name⟩]</code> </dt> <dd>
<p>Reports all module-local uses of the thing at the given position in the module, e.g.:</p> <pre data-language="none">:uses GhciFind.hs 53 66 53 70 name
GhciFind.hs:(46,25)-(46,29)
GhciFind.hs:(47,37)-(47,41)
GhciFind.hs:(53,66)-(53,70)
GhciFind.hs:(57,62)-(57,66)
</pre> <p>This command is useful for highlighting and navigating all uses of an identifier in editors and IDEs.</p> <p>The <a class="reference internal" href="#ghci-cmd-:uses"><code>:uses</code></a> command requires <a class="reference internal" href="#ghci-cmd-:set%20+c"><code>:set +c</code></a> to be set.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:! ⟨command⟩">
<code>:! ⟨command⟩</code> </dt> <dd>
<p id="index-31">Executes the shell command ⟨command⟩.</p> </dd>
</dl>   <h2 id="ghci-set">6.8. The <code>:set</code> and <code>:seti</code> commands</h2> <p id="the-set-and-seti-commands">The <a class="reference internal" href="#ghci-cmd-:set"><code>:set</code></a> command sets two types of options: GHCi options, which begin with “<code>+</code>”, and “command-line” options, which begin with “<code>-</code>”.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">At the moment, the <a class="reference internal" href="#ghci-cmd-:set"><code>:set</code></a> command doesn’t support any kind of quoting in its arguments: quotes will not be removed and cannot be used to group words together. For example, <code>:set -DFOO='BAR BAZ'</code> will not do what you expect.</p> </div>  <h3 id="ghci-options">6.8.1. GHCi options</h3> <p id="index-33">GHCi options may be set using <a class="reference internal" href="#ghci-cmd-:set"><code>:set</code></a> and unset using <a class="reference internal" href="#ghci-cmd-:unset"><code>:unset</code></a>.</p> <p>The available GHCi options are:</p> <dl class="ghci-cmd"> <dt id="ghci-cmd-:set +c">
<code>:set +c</code> </dt> <dd>
<p>Collect type and location information after loading modules. The commands <a class="reference internal" href="#ghci-cmd-:all-types"><code>:all-types</code></a>, <a class="reference internal" href="#ghci-cmd-:loc-at"><code>:loc-at</code></a>, <a class="reference internal" href="#ghci-cmd-:type-at"><code>:type-at</code></a>, and <a class="reference internal" href="#ghci-cmd-:uses"><code>:uses</code></a> require <code>+c</code> to be active.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:set +m">
<code>:set +m</code> </dt> <dd>
<p id="index-34">Enable parsing of multiline commands. A multiline command is prompted for when the current input line contains open layout contexts (see <a class="reference internal" href="#ghci-multiline"><span class="std std-ref">Multiline input</span></a>).</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:set +r">
<code>:set +r</code> </dt> <dd>
<p id="index-35">Normally, any evaluation of top-level expressions (otherwise known as CAFs or Constant Applicative Forms) in loaded modules is retained between evaluations. Turning on <code>+r</code> causes all evaluation of top-level expressions to be discarded after each evaluation (they are still retained <em>during</em> a single evaluation).</p> <p>This option may help if the evaluated top-level expressions are consuming large amounts of space, or if you need repeatable performance measurements.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:set +s">
<code>:set +s</code> </dt> <dd>
<p>Display some stats after evaluating each expression, including the elapsed time and number of bytes allocated. NOTE: the allocation figure is only accurate to the size of the storage manager’s allocation area, because it is calculated at every GC. Hence, you might see values of zero if no GC has occurred.</p> </dd>
</dl> <dl class="ghci-cmd"> <dt id="ghci-cmd-:set +t">
<code>:set +t</code> </dt> <dd>
<p id="index-36">Display the type of each variable bound after a statement is entered at the prompt. If the statement is a single expression, then the only variable binding will be for the variable <code>it</code>.</p> </dd>
</dl>   <h3 id="ghci-cmd-line-options">6.8.2. Setting GHC command-line options in GHCi</h3> <p id="setting-ghc-command-line-options-in-ghci">Normal GHC command-line options may also be set using <a class="reference internal" href="#ghci-cmd-:set"><code>:set</code></a>. For example, to turn on <a class="reference internal" href="using-warnings#ghc-flag--Wmissing-signatures"><code>-Wmissing-signatures</code></a>, you would say:</p> <pre data-language="none">Prelude&gt; :set -Wmissing-signatures
</pre> <p>Any GHC command-line option that is designated as dynamic (see the table in <a class="reference internal" href="flags#flag-reference"><span class="std std-ref">Flag reference</span></a>), may be set using <a class="reference internal" href="#ghci-cmd-:set"><code>:set</code></a>. To unset an option, you can set the reverse option:</p> <pre data-language="none">Prelude&gt; :set -Wno-incomplete-patterns -XNoMultiParamTypeClasses
</pre> <p><a class="reference internal" href="flags#flag-reference"><span class="std std-ref">Flag reference</span></a> lists the reverse for each option where applicable.</p> <p>Certain static options (<a class="reference internal" href="#"><code>-package ⟨pkg⟩</code></a>, <a class="reference internal" href="#"><code>-I⟨dir⟩</code></a>, <a class="reference internal" href="#"><code>-i⟨dir⟩[:⟨dir⟩]*</code></a>, and <a class="reference internal" href="#"><code>-l ⟨lib⟩</code></a> in particular) will also work, but some may not take effect until the next reload.</p>   <h3 id="index-38">6.8.3. Setting options for interactive evaluation only</h3> <p id="setting-options-for-interactive-evaluation-only">GHCi actually maintains <em>two</em> sets of options:</p> <ul class="simple"> <li>The <em>loading options</em> apply when loading modules</li> <li>The <em>interactive options</em> apply when evaluating expressions and commands typed at the GHCi prompt.</li> </ul> <p>The <a class="reference internal" href="#ghci-cmd-:set"><code>:set</code></a> command modifies both, but there is also a <a class="reference internal" href="#ghci-cmd-:seti"><code>:seti</code></a> command (for “set interactive”) that affects only the interactive options set.</p> <p>It is often useful to change the interactive options, without having that option apply to loaded modules too. For example</p> <pre data-language="none">:seti -XMonoLocalBinds
</pre> <p>It would be undesirable if <a class="reference internal" href="glasgow_exts#extension-MonoLocalBinds"><code>MonoLocalBinds</code></a> were to apply to loaded modules too: that might cause a compilation error, but more commonly it will cause extra recompilation, because GHC will think that it needs to recompile the module because the flags have changed.</p> <p>If you are setting language options in your <code>.ghci</code> file, it is good practice to use <a class="reference internal" href="#ghci-cmd-:seti"><code>:seti</code></a> rather than <a class="reference internal" href="#ghci-cmd-:set"><code>:set</code></a>, unless you really do want them to apply to all modules you load in GHCi.</p> <p>The two sets of options can be inspected using the <a class="reference internal" href="#ghci-cmd-:set"><code>:set</code></a> and <a class="reference internal" href="#ghci-cmd-:seti"><code>:seti</code></a> commands respectively, with no arguments. For example, in a clean GHCi session we might see something like this:</p> <pre data-language="none">Prelude&gt; :seti
base language is: Haskell2010
with the following modifiers:
  -XNoMonomorphismRestriction
  -XNoDatatypeContexts
  -XNondecreasingIndentation
  -XExtendedDefaultRules
GHCi-specific dynamic flag settings:
other dynamic, non-language, flag settings:
  -fimplicit-import-qualified
warning settings:
</pre> <p>The two sets of options are initialised as follows. First, both sets of options are initialised as described in <a class="reference internal" href="#ghci-dot-files"><span class="std std-ref">The .ghci and .haskeline files</span></a>. Then the interactive options are modified as follows:</p> <ul class="simple"> <li>The option <code>-XExtendedDefaultRules</code> is enabled, in order to apply special defaulting rules to expressions typed at the prompt (see <a class="reference internal" href="#extended-default-rules"><span class="std std-ref">Type defaulting in GHCi</span></a>).</li> <li>The Monomorphism Restriction is disabled (see <a class="reference internal" href="glasgow_exts#monomorphism"><span class="std std-ref">Switching off the dreaded Monomorphism Restriction</span></a>).</li> </ul>    <h2 id="ghci-dot-files">6.9. The <code>.ghci</code> and <code>.haskeline</code> files</h2>  <h3 id="dot-ghci-files">6.9.1. The <code>.ghci</code> files</h3> <p id="the-ghci-and-haskeline-files">When it starts, unless the <a class="reference internal" href="#ghc-flag--ignore-dot-ghci"><code>-ignore-dot-ghci</code></a> flag is given, GHCi reads and executes commands from the following files, in this order, if they exist:</p> <ol class="arabic simple"> <li><code>./.ghci</code></li> <li>
<code><em>appdata</em>/ghc/ghci.conf</code>, where ⟨appdata⟩ depends on your system, but is usually something like <code>C:/Documents and Settings/user/Application Data</code>
</li> <li>On Unix: <code>$HOME/.ghc/ghci.conf</code>
</li> <li><code>$HOME/.ghci</code></li> </ol> <p>The <code>ghci.conf</code> file is most useful for turning on favourite options (e.g. <code>:set +s</code>), and defining useful macros.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">When setting language options in this file it is usually desirable to use <a class="reference internal" href="#ghci-cmd-:seti"><code>:seti</code></a> rather than <a class="reference internal" href="#ghci-cmd-:set"><code>:set</code></a> (see <a class="reference internal" href="#ghci-interactive-options"><span class="std std-ref">Setting options for interactive evaluation only</span></a>).</p> </div> <p>Placing a <code>.ghci</code> file in a directory with a Haskell project is a useful way to set certain project-wide options so you don’t have to type them every time you start GHCi: eg. if your project uses multi-parameter type classes, scoped type variables, and CPP, and has source files in three subdirectories A, B and C, you might put the following lines in <code>.ghci</code>:</p> <pre data-language="none">:set -XMultiParamTypeClasses -XScopedTypeVariables -cpp
:set -iA:B:C
</pre> <p>(Note that strictly speaking the <a class="reference internal" href="separate_compilation#ghc-flag--i"><code>-i</code></a> flag is a static one, but in fact it works to set it using <a class="reference internal" href="#ghci-cmd-:set"><code>:set</code></a> like this. The changes won’t take effect until the next <a class="reference internal" href="#ghci-cmd-:load"><code>:load</code></a>, though.)</p> <p>Once you have a library of GHCi macros, you may want to source them from separate files, or you may want to source your <code>.ghci</code> file into your running GHCi session while debugging it</p> <pre data-language="none">:def source readFile
</pre> <p>With this macro defined in your <code>.ghci</code> file, you can use <code>:source file</code> to read GHCi commands from <code>file</code>. You can find (and contribute!-) other suggestions for <code>.ghci</code> files on this Haskell wiki page: <a class="reference external" href="http://haskell.org/haskellwiki/GHC/GHCi">GHC/GHCi</a></p> <p>Additionally, any files specified with <a class="reference internal" href="#ghc-flag--ghci-script"><code>-ghci-script</code></a> flags will be read after the standard files, allowing the use of custom .ghci files.</p> <p>Two command-line options control whether the startup files files are read:</p> <dl class="ghc-flag"> <dt id="ghc-flag--ignore-dot-ghci">
<code>-ignore-dot-ghci</code> </dt> <dd>
<p>Don’t read either <code>./.ghci</code> or the other startup files when starting up.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--ghci-script">
<code>-ghci-script</code> </dt> <dd>
<p>Read a specific file after the usual startup files. Maybe be specified repeatedly for multiple inputs.</p> </dd>
</dl> <p>When defining GHCi macros, there is some important behavior you should be aware of when names may conflict with built-in commands, especially regarding tab completion.</p> <p>For example, consider if you had a macro named <code>:time</code> and in the shell, typed <code>:t 3</code> — what should happen? The current algorithm we use for completing commands is:</p> <ol class="arabic simple"> <li>First, look up an exact match on the name from the defined macros.</li> <li>Look for the exact match on the name in the built-in command list.</li> <li>Do a prefix lookup on the list of built-in commands - if a built-in command matches, but a macro is defined with the same name as the built-in defined, pick the macro.</li> <li>Do a prefix lookup on the list of built-in commands.</li> <li>Do a prefix lookup on the list of defined macros.</li> </ol> <p>Here are some examples:</p> <ol class="arabic"> <li>
<p class="first">You have a macro <code>:time</code> and enter <code>:t 3</code></p> <p>You get <code>:type 3</code></p> </li> <li>
<p class="first">You have a macro <code>:type</code> and enter <code>:t 3</code></p> <p>You get <code>:type 3</code> with your defined macro, not the builtin.</p> </li> <li>
<p class="first">You have a macro <code>:time</code> and a macro <code>:type</code>, and enter <code>:t 3</code></p> <p>You get <code>:type 3</code> with your defined macro.</p> </li> </ol>   <h3 id="dot-haskeline-file">6.9.2. The <code>.haskeline</code> file</h3> <p id="the-haskeline-file">GHCi uses <a class="reference external" href="https://hackage.haskell.org/package/haskeline">Haskeline</a> under the hood. You can configure it to, among other things, prune duplicates from GHCi history. See: <a class="reference external" href="https://github.com/judah/haskeline/wiki/UserPreferences">Haskeline user preferences</a>.</p>    <h2 id="ghci-obj">6.10. Compiling to object code inside GHCi</h2> <p id="compiling-to-object-code-inside-ghci">By default, GHCi compiles Haskell source code into byte-code that is interpreted by the runtime system. GHCi can also compile Haskell code to object code: to turn on this feature, use the <a class="reference internal" href="phases#ghc-flag--fobject-code"><code>-fobject-code</code></a> flag either on the command line or with <a class="reference internal" href="#ghci-cmd-:set"><code>:set</code></a> (the option <a class="reference internal" href="phases#ghc-flag--fbyte-code"><code>-fbyte-code</code></a> restores byte-code compilation again). Compiling to object code takes longer, but typically the code will execute 10-20 times faster than byte-code.</p> <p>Compiling to object code inside GHCi is particularly useful if you are developing a compiled application, because the <a class="reference internal" href="#ghci-cmd-:reload"><code>:reload</code></a> command typically runs much faster than restarting GHC with <a class="reference internal" href="using#ghc-flag---make"><code>--make</code></a> from the command-line, because all the interface files are already cached in memory.</p> <p>There are disadvantages to compiling to object-code: you can’t set breakpoints in object-code modules, for example. Only the exports of an object-code module will be visible in GHCi, rather than all top-level bindings as in interpreted modules.</p>   <h2 id="external-interpreter">6.11. Running the interpreter in a separate process</h2> <p id="running-the-interpreter-in-a-separate-process">Normally GHCi runs the interpreted code in the same process as GHC itself, on top of the same RTS and sharing the same heap. However, if the flag <a class="reference internal" href="#ghc-flag--fexternal-interpreter"><code>-fexternal-interpreter</code></a> is given, then GHC will spawn a separate process for running interpreted code, and communicate with it using messages over a pipe.</p> <dl class="ghc-flag"> <dt id="ghc-flag--fexternal-interpreter">
<code>-fexternal-interpreter</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0.1</td> </tr>  </table> <p>Run interpreted code (for GHCi, Template Haskell, Quasi-quoting, or Annotations) in a separate process. The interpreter will run in profiling mode if <a class="reference internal" href="profiling#ghc-flag--prof"><code>-prof</code></a> is in effect, and in dynamically-linked mode if <a class="reference internal" href="phases#ghc-flag--dynamic"><code>-dynamic</code></a> is in effect.</p> <p>There are a couple of caveats that will hopefully be removed in the future: this option is currently not implemented on Windows (it is a no-op), and the external interpreter does not support the GHCi debugger, so breakpoints and single-stepping don’t work with <a class="reference internal" href="#ghc-flag--fexternal-interpreter"><code>-fexternal-interpreter</code></a>.</p> <p>See also the <a class="reference internal" href="#"><code>-pgmi ⟨cmd⟩</code></a> (<a class="reference internal" href="phases#replacing-phases"><span class="std std-ref">Replacing the program for one or more phases</span></a>) and <a class="reference internal" href="#"><code>-opti ⟨option⟩</code></a> (<a class="reference internal" href="phases#forcing-options-through"><span class="std std-ref">Forcing options to a particular phase</span></a>) flags.</p> </dd>
</dl> <p>Why might we want to do this? The main reason is that the RTS running the interpreted code can be a different flavour (profiling or dynamically-linked) from GHC itself. So for example:</p> <ul class="simple"> <li>We can use the profiler to collect stack traces when using GHCi (see <a class="reference internal" href="#ghci-stack-traces"><span class="std std-ref">Stack Traces in GHCi</span></a>).</li> <li>When compiling Template Haskell code with <a class="reference internal" href="profiling#ghc-flag--prof"><code>-prof</code></a> we don’t need to compile the modules without <a class="reference internal" href="profiling#ghc-flag--prof"><code>-prof</code></a> first (see <a class="reference internal" href="glasgow_exts#th-profiling"><span class="std std-ref">Using Template Haskell with Profiling</span></a>) because we can run the profiled object code in the interpreter.</li> </ul> <p>This feature is experimental in GHC 8.0.x, but it may become the default in future releases.</p>   <h2 id="ghci-faq">6.12. FAQ and Things To Watch Out For</h2> <dl class="docutils" id="faq-and-things-to-watch-out-for"> <dt>The interpreter can’t load modules with foreign export declarations!</dt> <dd>Unfortunately not. We haven’t implemented it yet. Please compile any offending modules by hand before loading them into GHCi.</dd> </dl> <p><a class="reference internal" href="using-optimisation#ghc-flag--O"><code>-O</code></a> doesn’t work with GHCi!</p>  <p id="index-41">For technical reasons, the bytecode compiler doesn’t interact well with one of the optimisation passes, so we have disabled optimisation when using the interpreter. This isn’t a great loss: you’ll get a much bigger win by compiling the bits of your code that need to go fast, rather than interpreting them with optimisation turned on.</p>  <dl class="docutils"> <dt>
<code>Modules using unboxed tuples will automatically enable -fobject-code</code> </dt> <dd>
<p class="first">The interpreter doesn’t support unboxed tuples, so GHCi will automatically compile these modules, and all modules they depend on, to object code instead of bytecode.</p> <p class="last">Incidentally, the previous point, that <a class="reference internal" href="using-optimisation#ghc-flag--O"><code>-O</code></a> is incompatible with GHCi, is because the bytecode compiler can’t deal with unboxed tuples.</p> </dd> <dt>Concurrent threads don’t carry on running when GHCi is waiting for input.</dt> <dd>This should work, as long as your GHCi was built with the <a class="reference internal" href="phases#ghc-flag--threaded"><code>-threaded</code></a> switch, which is the default. Consult whoever supplied your GHCi installation.</dd> <dt>
<code>After using getContents, I can’t use stdin, until I do :load or :reload</code> </dt> <dd>
<p class="first">This is the defined behaviour of <code>getContents</code>: it puts the stdin Handle in a state known as semi-closed, wherein any further I/O operations on it are forbidden. Because I/O state is retained between computations, the semi-closed state persists until the next <a class="reference internal" href="#ghci-cmd-:load"><code>:load</code></a> or <a class="reference internal" href="#ghci-cmd-:reload"><code>:reload</code></a> command.</p> <p class="last">You can make <code>stdin</code> reset itself after every evaluation by giving GHCi the command <code>:set +r</code>. This works because <code>stdin</code> is just a top-level expression that can be reverted to its unevaluated state in the same way as any other top-level expression (CAF).</p> </dd> <dt>
<code>I can’t use Control-C to interrupt computations in GHCi on Windows.</code> </dt> <dd>See <a class="reference internal" href="win32-dlls#ghci-windows"><span class="std std-ref">Running GHCi on Windows</span></a>.</dd> <dt>The default buffering mode is different in GHCi to GHC.</dt> <dd>
<p class="first">In GHC, the stdout handle is line-buffered by default. However, in GHCi we turn off the buffering on stdout, because this is normally what you want in an interpreter: output appears as it is generated.</p> <p>If you want line-buffered behaviour, as in GHC, you can start your program thus:</p> <pre data-language="haskell">main = do { hSetBuffering stdout LineBuffering; ... }
</pre> </dd> </dl> <table class="docutils footnote" frame="void" id="id16" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id10">[5]</a></td>
<td>Note that packages only contain compiled code, so debugging a package requires finding its source and loading that directly.</td>
</tr>  </table> <table class="docutils footnote" frame="void" id="id17" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id11">[6]</a></td>
<td>We originally provided bindings for all variables in scope, rather than just the free variables of the expression, but found that this affected performance considerably, hence the current restriction to just the free variables.</td>
</tr>  </table>   </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2002–2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/users_guide/ghci.html" class="_attribution-link">https://downloads.haskell.org/~ghc/8.8.3/docs/html/users_guide/ghci.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
