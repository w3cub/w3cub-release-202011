
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>8.9. Packages - Haskell 8 - W3cubDocs</title>
  
  <meta name="description" content="A package is a library of Haskell modules known to the compiler. GHC comes with several packages&#58; see the accompanying library documentation. &hellip;">
  <meta name="keywords" content="packages, haskell, haskell~8">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/haskell~8/users_guide/packages.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/haskell~8.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/haskell~8/" class="_nav-link" title="" style="margin-left:0;">Haskell 8</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _haskell">
				
				
<h1 id="id1">8.9. Packages</h1>
<div class="_sphinx">   <p id="packages">A package is a library of Haskell modules known to the compiler. GHC comes with several packages: see the accompanying <a class="reference external" href="../libraries/index">library documentation</a>. More packages to install can be obtained from <a class="reference external" href="http://hackage.haskell.org/packages/hackage.html">HackageDB</a>.</p> <p>Using a package couldn’t be simpler: if you’re using <code>--make</code> or GHCi, then most of the installed packages will be automatically available to your program without any further options. The exceptions to this rule are covered below in <a class="reference internal" href="#using-packages"><span class="std std-ref">Using Packages</span></a>.</p> <p>Building your own packages is also quite straightforward: we provide the <a class="reference external" href="http://www.haskell.org/cabal/">Cabal</a> infrastructure which automates the process of configuring, building, installing and distributing a package. All you need to do is write a simple configuration file, put a few files in the right places, and you have a package. See the <a class="reference external" href="http://www.haskell.org/cabal/users-guide/">Cabal documentation</a> for details, and also the Cabal libraries (<a class="reference external" href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/Cabal-3.0.1.0/Distribution-Simple.html">Distribution.Simple</a>, for example).</p>  <h2 id="id2">8.9.1. Using Packages</h2> <p id="using-packages">GHC only knows about packages that are <em>installed</em>. Installed packages live in package databases. For details on package databases and how to control which package databases or specific set of packages are visible to GHC, see <a class="reference internal" href="#package-databases"><span class="std std-ref">Package Databases</span></a>.</p> <p>To see which packages are currently available, use the <code>ghc-pkg list</code> command:</p> <pre data-language="none">$ ghc-pkg list
/usr/lib/ghc-6.12.1/package.conf.d:
    Cabal-1.7.4
    array-0.2.0.1
    base-3.0.3.0
    base-4.2.0.0
    bin-package-db-0.0.0.0
    binary-0.5.0.1
    bytestring-0.9.1.4
    containers-0.2.0.1
    directory-1.0.0.2
    (dph-base-0.4.0)
    (dph-par-0.4.0)
    (dph-prim-interface-0.4.0)
    (dph-prim-par-0.4.0)
    (dph-prim-seq-0.4.0)
    (dph-seq-0.4.0)
    extensible-exceptions-0.1.1.0
    ffi-1.0
    filepath-1.1.0.1
    (ghc-6.12.1)
    ghc-prim-0.1.0.0
    haskeline-0.6.2
    haskell98-1.0.1.0
    hpc-0.5.0.2
    integer-gmp-0.1.0.0
    mtl-1.1.0.2
    old-locale-1.0.0.1
    old-time-1.0.0.1
    pretty-1.0.1.0
    process-1.0.1.1
    random-1.0.0.1
    rts-1.0
    syb-0.1.0.0
    template-haskell-2.4.0.0
    terminfo-0.3.1
    time-1.1.4
    unix-2.3.1.0
    utf8-string-0.3.4
</pre> <p>An installed package is either <em>exposed</em> or <em>hidden</em> by default. Packages hidden by default are listed in parentheses (e.g. <code>(lang-1.0)</code>), or possibly in blue if your terminal supports colour, in the output of <code>ghc-pkg list</code>. Command-line flags, described below, allow you to expose a hidden package or hide an exposed one. Only modules from exposed packages may be imported by your Haskell code; if you try to import a module from a hidden package, GHC will emit an error message. It should be noted that a hidden package might still get linked with your program as a dependency of an exposed package, it is only restricted from direct imports.</p> <p>If there are multiple exposed versions of a package, GHC will prefer the latest one. Additionally, some packages may be broken: that is, they are missing from the package database, or one of their dependencies are broken; in this case; these packages are excluded from the default set of packages.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">If you’re using Cabal, then the exposed or hidden status of a package is irrelevant: the available packages are instead determined by the dependencies listed in your <code>.cabal</code> specification. The exposed/hidden status of packages is only relevant when using <code>ghc</code> or <code>ghci</code> directly.</p> </div> <p>Similar to a package’s hidden status is a package’s trusted status. A package can be either trusted or not trusted (distrusted). By default packages are distrusted. This property of a package only plays a role when compiling code using GHC’s Safe Haskell feature (see <a class="reference internal" href="safe_haskell#safe-haskell"><span class="std std-ref">Safe Haskell</span></a>) with the <code>-fpackage-trust</code> flag enabled.</p> <p>To see which modules are provided by a package use the <code>ghc-pkg</code> command (see <a class="reference internal" href="#package-management"><span class="std std-ref">Package management (the ghc-pkg command)</span></a>):</p> <pre data-language="none">$ ghc-pkg field network exposed-modules
exposed-modules: Network.BSD,
                 Network.CGI,
                 Network.Socket,
                 Network.URI,
                 Network
</pre> <p>The GHC command line options that control packages are:</p> <dl class="ghc-flag"> <dt id="ghc-flag--package ⟨pkg⟩">
<code>-package ⟨pkg⟩</code> </dt> <dd>
<p>This option causes the installed package ⟨pkg⟩ to be exposed. The package ⟨pkg⟩ can be specified in full with its version number (e.g. <code>network-1.0</code>) or the version number can be omitted in which case GHC will automatically expose the latest non-broken version from the installed versions of the package.</p> <p>By default (when <a class="reference internal" href="#ghc-flag--hide-all-packages"><code>-hide-all-packages</code></a> is not specified), GHC exposes only one version of a package, all other versions become hidden. If <code>-package</code> option is specified multiple times for the same package the last one overrides the previous ones. On the other hand, if <a class="reference internal" href="#ghc-flag--hide-all-packages"><code>-hide-all-packages</code></a> is used, GHC allows you to expose multiple versions of a package by using the <code>-package</code> option multiple times with different versions of the same package.</p> <p><code>-package</code> supports thinning and renaming described in <a class="reference internal" href="#package-thinning-and-renaming"><span class="std std-ref">Thinning and renaming modules</span></a>.</p> <p>The <code>-package ⟨pkg⟩</code> option also causes package ⟨pkg⟩ to be linked into the resulting executable or shared object. Whether a packages’ library is linked statically or dynamically is controlled by the flag pair <a class="reference internal" href="phases#ghc-flag--static"><code>-static</code></a>/ <a class="reference internal" href="phases#ghc-flag--dynamic"><code>-dynamic</code></a>.</p> <p>In <a class="reference internal" href="using#ghc-flag---make"><code>--make</code></a> mode and <a class="reference internal" href="using#ghc-flag---interactive"><code>--interactive</code></a> mode (see <a class="reference internal" href="using#modes"><span class="std std-ref">Modes of operation</span></a>), the compiler normally determines which packages are required by the current Haskell modules, and links only those. In batch mode however, the dependency information isn’t available, and explicit <code>-package</code> options must be given when linking. The one other time you might need to use <code>-package</code> to force linking a package is when the package does not contain any Haskell modules (it might contain a C library only, for example). In that case, GHC will never discover a dependency on it, so it has to be mentioned explicitly.</p> <p>For example, to link a program consisting of objects <code>Foo.o</code> and <code>Main.o</code>, where we made use of the <code>network</code> package, we need to give GHC the <code>-package</code> flag thus:</p> <pre data-language="sh">$ ghc -o myprog Foo.o Main.o -package network
</pre> <p>The same flag is necessary even if we compiled the modules from source, because GHC still reckons it’s in batch mode:</p> <pre data-language="sh">$ ghc -o myprog Foo.hs Main.hs -package network
</pre> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--package-id ⟨unit-id⟩">
<code>-package-id ⟨unit-id⟩</code> </dt> <dd>
<p>Exposes a package like <a class="reference internal" href="#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9"><code>-package ⟨pkg⟩</code></a>, but the package is named by its unit ID (i.e. the value of <code>id</code> in its entry in the installed package database, also previously known as an installed package ID) rather than by name. This is a more robust way to name packages, and can be used to select packages that would otherwise be shadowed. Cabal passes <code>-package-id</code> flags to GHC. <code>-package-id</code> supports thinning and renaming described in <a class="reference internal" href="#package-thinning-and-renaming"><span class="std std-ref">Thinning and renaming modules</span></a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--hide-all-packages">
<code>-hide-all-packages</code> </dt> <dd>
<p>Ignore the exposed flag on installed packages, and hide them all by default. If you use this flag, then any packages you require (including <code>base</code>) need to be explicitly exposed using <a class="reference internal" href="#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9"><code>-package ⟨pkg⟩</code></a> options.</p> <p>This is a good way to insulate your program from differences in the globally exposed packages, and being explicit about package dependencies is a Good Thing. Cabal always passes the <code>-hide-all-packages</code> flag to GHC, for exactly this reason.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--hide-package ⟨pkg⟩">
<code>-hide-package ⟨pkg⟩</code> </dt> <dd>
<p>This option does the opposite of <a class="reference internal" href="#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9"><code>-package ⟨pkg⟩</code></a>: it causes the specified package to be hidden, which means that none of its modules will be available for import by Haskell <code>import</code> directives.</p> <p>Note that the package might still end up being linked into the final program, if it is a dependency (direct or indirect) of another exposed package.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--ignore-package ⟨pkg⟩">
<code>-ignore-package ⟨pkg⟩</code> </dt> <dd>
<p>Causes the compiler to behave as if package ⟨pkg⟩, and any packages that depend on ⟨pkg⟩, are not installed at all.</p> <p>Saying <code>-ignore-package ⟨pkg⟩</code> is the same as giving <a class="reference internal" href="#ghc-flag--hide-package%20%E2%9F%A8pkg%E2%9F%A9"><code>-hide-package ⟨pkg⟩</code></a> flags for ⟨pkg⟩ and all the packages that depend on ⟨pkg⟩. Sometimes we don’t know ahead of time which packages will be installed that depend on ⟨pkg⟩, which is when the <a class="reference internal" href="#ghc-flag--ignore-package%20%E2%9F%A8pkg%E2%9F%A9"><code>-ignore-package ⟨pkg⟩</code></a> flag can be useful.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--no-auto-link-packages">
<code>-no-auto-link-packages</code> </dt> <dd>
<p>By default, GHC will automatically link in the <code>base</code> and <code>rts</code> packages. This flag disables that behaviour.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--this-unit-id ⟨unit-id⟩">
<code>-this-unit-id ⟨unit-id⟩</code> </dt> <dd>
<p>Tells GHC that the module being compiled forms part of unit ID ⟨unit-id⟩; internally, these keys are used to determine type equality and linker symbols. As of GHC 8.0, unit IDs must consist solely of alphanumeric characters, dashes, underscores and periods. GHC reserves the right to interpret other characters in a special way in later releases.</p> </dd>
</dl> <dl class="ghc-flag"> <dt>
<code>-trust ⟨pkg⟩</code> </dt> <dd>
<p>This option causes the install package ⟨pkg⟩ to be both exposed and trusted by GHC. This command functions in a very similar way to the <a class="reference internal" href="#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9"><code>-package ⟨pkg⟩</code></a> command but in addition sets the selected packages to be trusted by GHC, regardless of the contents of the package database. (see <a class="reference internal" href="safe_haskell#safe-haskell"><span class="std std-ref">Safe Haskell</span></a>).</p> </dd>
</dl> <dl class="ghc-flag"> <dt>
<code>-distrust ⟨pkg⟩</code> </dt> <dd>
<p>This option causes the install package ⟨pkg⟩ to be both exposed and distrusted by GHC. This command functions in a very similar way to the <a class="reference internal" href="#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9"><code>-package ⟨pkg⟩</code></a> command but in addition sets the selected packages to be distrusted by GHC, regardless of the contents of the package database. (see <a class="reference internal" href="safe_haskell#safe-haskell"><span class="std std-ref">Safe Haskell</span></a>).</p> </dd>
</dl> <dl class="ghc-flag"> <dt>
<code>-distrust-all-packages</code> </dt> <dd>
<p>Ignore the trusted flag on installed packages, and distrust them by default. If you use this flag and Safe Haskell then any packages you require to be trusted (including <code>base</code>) need to be explicitly trusted using <a class="reference internal" href="#"><code>-trust ⟨pkg⟩</code></a> options. This option does not change the exposed/hidden status of a package, so it isn’t equivalent to applying <a class="reference internal" href="#"><code>-distrust ⟨pkg⟩</code></a> to all packages on the system. (see <a class="reference internal" href="safe_haskell#safe-haskell"><span class="std std-ref">Safe Haskell</span></a>).</p> </dd>
</dl>   <h2 id="package-main">8.9.2. The <code>main</code> package</h2> <p id="the-main-package">Every complete Haskell program must define <code>main</code> in module <code>Main</code> in package <code>main</code>. Omitting the <a class="reference internal" href="#ghc-flag--this-unit-id%20%E2%9F%A8unit-id%E2%9F%A9"><code>-this-unit-id ⟨unit-id⟩</code></a> flag compiles code for package <code>main</code>. Failure to do so leads to a somewhat obscure link-time error of the form:</p> <pre data-language="none">/usr/bin/ld: Undefined symbols:
_ZCMain_main_closure
</pre>   <h2 id="package-overlaps">8.9.3. Consequences of packages for the Haskell language</h2> <p id="consequences-of-packages-for-the-haskell-language">It is possible that by using packages you might end up with a program that contains two modules with the same name: perhaps you used a package <code>P</code> that has a <em>hidden</em> module <code>M</code>, and there is also a module <code>M</code> in your program. Or perhaps the dependencies of packages that you used contain some overlapping modules. Perhaps the program even contains multiple versions of a certain package, due to dependencies from other packages.</p> <p>None of these scenarios gives rise to an error on its own <a class="footnote-reference" href="#id6" id="id3">[1]</a>, but they may have some interesting consequences. For instance, if you have a type <code>M.T</code> from version 1 of package <code>P</code>, then this is <em>not</em> the same as the type <code>M.T</code> from version 2 of package <code>P</code>, and GHC will report an error if you try to use one where the other is expected.</p> <p>Formally speaking, in Haskell 98, an entity (function, type or class) in a program is uniquely identified by the pair of the module name in which it is defined and its name. In GHC, an entity is uniquely defined by a triple: package, module, and name.</p>   <h2 id="package-thinning-and-renaming">8.9.4. Thinning and renaming modules</h2> <p id="thinning-and-renaming-modules">When incorporating packages from multiple sources, you may end up in a situation where multiple packages publish modules with the same name. Previously, the only way to distinguish between these modules was to use <a class="reference internal" href="glasgow_exts#package-qualified-imports"><span class="std std-ref">Package-qualified imports</span></a>. However, since GHC 7.10, the <a class="reference internal" href="#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9"><code>-package ⟨pkg⟩</code></a> flags (and their variants) have been extended to allow a user to explicitly control what modules a package brings into scope, by analogy to the import lists that users can attach to module imports.</p> <p>The basic syntax is that instead of specifying a package name P to the package flag <code>-package</code>, instead we specify both a package name and a parenthesized, comma-separated list of module names to import. For example, <code>-package "base (Data.List, Data.Bool)"</code> makes only <code>Data.List</code> and <code>Data.Bool</code> visible from package <code>base</code>. We also support renaming of modules, in case you need to refer to both modules simultaneously; this is supporting by writing <code>OldModName as NewModName</code>, e.g. <code>-package "base (Data.Bool as Bool)</code>. You can also write <code>-package "base with (Data.Bool as Bool)</code> to include all of the original bindings (e.g. the renaming is strictly additive). It’s important to specify quotes so that your shell passes the package name and thinning/renaming list as a single argument to GHC.</p> <p>Package imports with thinning/renaming do not hide other versions of the package: e.g. if containers-0.9 is already exposed, <code>-package "containers-0.8 (Data.List as ListV8)"</code> will only add an additional binding to the environment. Similarly, <code>-package "base (Data.Bool as Bool)" -package "base (Data.List as List)"</code> is equivalent to <code>-package "base (Data.Bool as Bool, Data.List as List)"</code>. Literal names must refer to modules defined by the original package, so for example <code>-package "base (Data.Bool as Bool, Bool as Baz)"</code> is invalid unless there was a <code>Bool</code> module defined in the original package. Hiding a package also clears all of its renamings.</p> <p>You can use renaming to provide an alternate prelude, e.g. <code>-hide-all-packages -package "basic-prelude (BasicPrelude as Prelude)"</code>, in lieu of the <a class="reference internal" href="glasgow_exts#rebindable-syntax"><span class="std std-ref">Rebindable syntax and the implicit Prelude import</span></a> extension.</p>   <h2 id="id4">8.9.5. Package Databases</h2> <p id="package-databases">A package database is where the details about installed packages are stored. It is a directory, usually called <code>package.conf.d</code>, that contains a file for each package, together with a binary cache of the package data in the file <code>package.cache</code>. Normally you won’t need to look at or modify the contents of a package database directly; all management of package databases can be done through the <strong class="command">ghc-pkg</strong> tool (see <a class="reference internal" href="#package-management"><span class="std std-ref">Package management (the ghc-pkg command)</span></a>).</p> <p>GHC knows about two package databases in particular:</p> <ul class="simple"> <li>The <em>global package database</em>, which comes with your GHC installation, e.g. <code>/usr/lib/ghc-6.12.1/package.conf.d</code>.</li> <li>The <em>user package database</em> private to each user. On Unix systems this will be <code>$HOME/.ghc/arch-os-version/package.conf.d</code>, and on Windows it will be something like <code>C:\Documents And Settings\user\ghc\package.conf.d</code>. The <code>ghc-pkg</code> tool knows where this file should be located, and will create it if it doesn’t exist (see <a class="reference internal" href="#package-management"><span class="std std-ref">Package management (the ghc-pkg command)</span></a>).</li> </ul> <p><em>Package database stack:</em> Package databases are arranged in a stack structure. When GHC starts up it adds the global and the user package databases to the stack, in that order, unless <a class="reference internal" href="#envvar-GHC_PACKAGE_PATH" id="index-2"><code>GHC_PACKAGE_PATH</code></a> is specified. When <code>GHC_PACKAGE_PATH</code> is specified then it will determine the initial database stack. Several command line options described below can further manipulate this initial stack. You can see GHC’s effective package database stack by running GHC with the <a class="reference internal" href="using#ghc-flag--v"><code>-v</code></a> flag.</p> <p>This stack structure means that the order of <a class="reference internal" href="#ghc-flag--package-db%20%E2%9F%A8file%E2%9F%A9"><code>-package-db ⟨file⟩</code></a> flags or <a class="reference internal" href="#envvar-GHC_PACKAGE_PATH" id="index-3"><code>GHC_PACKAGE_PATH</code></a> is important. Each substack of the stack must be well formed (packages in databases on top of the stack can refer to packages below, but not vice versa).</p> <p><em>Package shadowing:</em> When multiple package databases are in use it is possible, though rarely, that the same installed package id is present in more than one database. In that case, packages closer to the top of the stack will override (<em>shadow</em>) those below them. If the conflicting packages are found to be equivalent (by ABI hash comparison) then one of them replaces all references to the other, otherwise the overridden package and all those depending on it will be removed.</p> <p><em>Package version selection:</em> When selecting a package, GHC will search for packages in all available databases. If multiple versions of the same package are available the latest non-broken version will be chosen.</p> <p><em>Version conflict resolution:</em> If multiple instances of a package version chosen by GHC are available then GHC will choose an unspecified instance.</p> <p>You can control GHC’s package database stack using the following options:</p> <dl class="ghc-flag"> <dt id="ghc-flag--package-db ⟨file⟩">
<code>-package-db ⟨file⟩</code> </dt> <dd>
<p>Add the package database ⟨file⟩ on top of the current stack.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--no-global-package-db">
<code>-no-global-package-db</code> </dt> <dd>
<p>Remove the global package database from the package database stack.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--no-user-package-db">
<code>-no-user-package-db</code> </dt> <dd>
<p>Prevent loading of the user’s local package database in the initial stack.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--clear-package-db">
<code>-clear-package-db</code> </dt> <dd>
<p>Reset the current package database stack. This option removes every previously specified package database (including those read from the <a class="reference internal" href="#envvar-GHC_PACKAGE_PATH" id="index-4"><code>GHC_PACKAGE_PATH</code></a> environment variable) from the package database stack.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--global-package-db">
<code>-global-package-db</code> </dt> <dd>
<p>Add the global package database on top of the current stack. This option can be used after <a class="reference internal" href="#ghc-flag--no-global-package-db"><code>-no-global-package-db</code></a> to specify the position in the stack where the global package database should be loaded.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--user-package-db">
<code>-user-package-db</code> </dt> <dd>
<p>Add the user’s package database on top of the current stack. This option can be used after <a class="reference internal" href="#ghc-flag--no-user-package-db"><code>-no-user-package-db</code></a> to specify the position in the stack where the user’s package database should be loaded.</p> </dd>
</dl>  <h3 id="ghc-package-path">8.9.5.1. The <code>GHC_PACKAGE_PATH</code> environment variable</h3> <dl class="envvar" id="the-ghc-package-path-environment-variable"> <dt id="envvar-GHC_PACKAGE_PATH">
<code>GHC_PACKAGE_PATH</code> </dt> <dd>
<p>The <code>GHC_PACKAGE_PATH</code> environment variable may be set to a <code>:</code>-separated (<code>;</code>-separated on Windows) list of files containing package databases. This list of package databases, used by GHC and ghc-pkg, specifies a stack of package databases from top to bottom. This order was chosen to match the behaviour of the <code id="index-5">PATH</code> environment variable where entries earlier in the PATH override ones that come later. See <a class="reference internal" href="#package-databases"><span class="std std-ref">Package Databases</span></a> for details on how the package database stack is used.</p> <p>Normally <code>GHC_PACKAGE_PATH</code> replaces the default package stack. For example, all of the following commands are equivalent, creating a stack with db1 at the top followed by db2 (use <code>;</code> instead of <code>:</code> on Windows):</p> <pre data-language="none">$ ghc -clear-package-db -package-db db2.conf -package-db db1.conf
$ env GHC_PACKAGE_PATH=db1.conf:db2.conf ghc
$ env GHC_PACKAGE_PATH=db2.conf ghc -package-db db1.conf
</pre> <p>However, if <code>GHC_PACKAGE_PATH</code> ends in a separator, the default databases (i.e. the user and global package databases, in that order) are appended to the path. For example, to augment the usual set of packages with a database of your own, you could say (on Unix):</p> <pre data-language="none">$ export GHC_PACKAGE_PATH=$HOME/.my-ghc-packages.conf:
</pre> <p>To check whether your <code>GHC_PACKAGE_PATH</code> setting is doing the right thing, <code>ghc-pkg list</code> will list all the databases in use, in the reverse order they are searched.</p> </dd>
</dl>   <h3 id="id5">8.9.5.2. Package environments</h3> <p id="package-environments">A <em>package environment file</em> is a file that tells <code>ghc</code> precisely which packages should be visible. It can be used to create environments for <code>ghc</code> or <code>ghci</code> that are local to a shell session or to some file system location. They are intended to be managed by build/package tools, to enable <code>ghc</code> and <code>ghci</code> to automatically use an environment created by the tool.</p> <p>The file contains package IDs and optionally package databases, one directive per line:</p> <pre data-language="none">clear-package-db
global-package-db
user-package-db
package-db db.d/
package-id id_1
package-id id_2
...
package-id id_n
</pre> <p>If such a package environment is found, it is equivalent to passing these command line arguments to <code>ghc</code>:</p> <pre data-language="none">-hide-all-packages
-clear-package-db
-global-package-db
-user-package-db
-package-db db.d/
-package-id id_1
-package-id id_2
...
-package-id id_n
</pre> <p>Note the implicit <a class="reference internal" href="#ghc-flag--hide-all-packages"><code>-hide-all-packages</code></a> and the fact that it is <a class="reference internal" href="#ghc-flag--package-id%20%E2%9F%A8unit-id%E2%9F%A9"><code>-package-id ⟨unit-id⟩</code></a>, not <a class="reference internal" href="#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9"><code>-package ⟨pkg⟩</code></a>. This is because the environment specifies precisely which packages should be visible.</p> <p>Note that for the <code>package-db</code> directive, if a relative path is given it must be relative to the location of the package environment file.</p> <dl class="ghc-flag"> <dt id="ghc-flag--package-env ⟨file⟩|⟨name⟩">
<code>-package-env ⟨file⟩|⟨name⟩</code> </dt> <dd>
<p>Use the package environment in ⟨file⟩, or in <code>$HOME/.ghc/arch-os-version/environments/⟨name⟩</code> If set to <code>-</code> no package environment is read.</p> </dd>
</dl> <dl class="envvar"> <dt id="envvar-GHC_ENVIRONMENT">
<code>GHC_ENVIRONMENT</code> </dt> <dd>
<p>Specifies the path to the package environment file to be used by GHC. Overridden by the <a class="reference internal" href="#ghc-flag--package-env%20%E2%9F%A8file%E2%9F%A9%7C%E2%9F%A8name%E2%9F%A9"><code>-package-env ⟨file⟩|⟨name⟩</code></a> flag if set.</p> </dd>
</dl> <p>In order, <code>ghc</code> will look for the package environment in the following locations:</p> <ul class="simple"> <li>File ⟨file⟩ if you pass the option <a class="reference internal" href="#ghc-flag--package-env%20%E2%9F%A8file%E2%9F%A9%7C%E2%9F%A8name%E2%9F%A9"><code>-package-env ⟨file⟩|⟨name⟩</code></a>.</li> <li>File <code>$HOME/.ghc/arch-os-version/environments/name</code> if you pass the option <code>-package-env ⟨name⟩</code>.</li> <li>File ⟨file⟩ if the environment variable <a class="reference internal" href="#envvar-GHC_ENVIRONMENT" id="index-7"><code>GHC_ENVIRONMENT</code></a> is set to ⟨file⟩.</li> <li>File <code>$HOME/.ghc/arch-os-version/environments/name</code> if the environment variable <a class="reference internal" href="#envvar-GHC_ENVIRONMENT" id="index-8"><code>GHC_ENVIRONMENT</code></a> is set to ⟨name⟩.</li> </ul> <p>Additionally, unless <code>-hide-all-packages</code> is specified <code>ghc</code> will also look for the package environment in the following locations:</p> <ul class="simple"> <li>File <code>.ghc.environment.arch-os-version</code> if it exists in the current directory or any parent directory (but not the user’s home directory).</li> <li>File <code>$HOME/.ghc/arch-os-version/environments/default</code> if it exists.</li> </ul> <p>Package environments can be modified by further command line arguments; for example, if you specify <code>-package foo</code> on the command line, then package ⟨foo⟩ will be visible even if it’s not listed in the currently active package environment.</p>    <h2 id="package-ids">8.9.6. Installed package IDs, dependencies, and broken packages</h2> <p id="installed-package-ids-dependencies-and-broken-packages">Each installed package has a unique identifier (the “installed package ID”), which distinguishes it from all other installed packages on the system. To see the installed package IDs associated with each installed package, use <code>ghc-pkg list -v</code>:</p> <pre data-language="none">$ ghc-pkg list -v
using cache: /usr/lib/ghc-6.12.1/package.conf.d/package.cache
/usr/lib/ghc-6.12.1/package.conf.d
   Cabal-1.7.4 (Cabal-1.7.4-48f5247e06853af93593883240e11238)
   array-0.2.0.1 (array-0.2.0.1-9cbf76a576b6ee9c1f880cf171a0928d)
   base-3.0.3.0 (base-3.0.3.0-6cbb157b9ae852096266e113b8fac4a2)
   base-4.2.0.0 (base-4.2.0.0-247bb20cde37c3ef4093ee124e04bc1c)
   ...
</pre> <p>The string in parentheses after the package name is the installed package ID: it normally begins with the package name and version, and ends in a hash string derived from the compiled package. Dependencies between packages are expressed in terms of installed package IDs, rather than just packages and versions. For example, take a look at the dependencies of the <code>haskell98</code> package:</p> <pre data-language="none">$ ghc-pkg field haskell98 depends
depends: array-0.2.0.1-9cbf76a576b6ee9c1f880cf171a0928d
         base-4.2.0.0-247bb20cde37c3ef4093ee124e04bc1c
         directory-1.0.0.2-f51711bc872c35ce4a453aa19c799008
         old-locale-1.0.0.1-d17c9777c8ee53a0d459734e27f2b8e9
         old-time-1.0.0.1-1c0d8ea38056e5087ef1e75cb0d139d1
         process-1.0.1.1-d8fc6d3baf44678a29b9d59ca0ad5780
         random-1.0.0.1-423d08c90f004795fd10e60384ce6561
</pre> <p>The purpose of the installed package ID is to detect problems caused by re-installing a package without also recompiling the packages that depend on it. Recompiling dependencies is necessary, because the newly compiled package may have a different ABI (Application Binary Interface) than the previous version, even if both packages were built from the same source code using the same compiler. With installed package IDs, a recompiled package will have a different installed package ID from the previous version, so packages that depended on the previous version are now orphaned - one of their dependencies is not satisfied. Packages that are broken in this way are shown in the <code>ghc-pkg list</code> output either in red (if possible) or otherwise surrounded by braces. In the following example, we have recompiled and reinstalled the <code>filepath</code> package, and this has caused various dependencies including <code>Cabal</code> to break:</p> <pre data-language="none">$ ghc-pkg list
WARNING: there are broken packages.  Run 'ghc-pkg check' for more details.
/usr/lib/ghc-6.12.1/package.conf.d:
    {Cabal-1.7.4}
    array-0.2.0.1
    base-3.0.3.0
    ... etc ...
</pre> <p>Additionally, <code>ghc-pkg list</code> reminds you that there are broken packages and suggests <code>ghc-pkg check</code>, which displays more information about the nature of the failure:</p> <pre data-language="none">$ ghc-pkg check
There are problems in package ghc-6.12.1:
  dependency "filepath-1.1.0.1-87511764eb0af2bce4db05e702750e63" doesn't exist
There are problems in package haskeline-0.6.2:
  dependency "filepath-1.1.0.1-87511764eb0af2bce4db05e702750e63" doesn't exist
There are problems in package Cabal-1.7.4:
  dependency "filepath-1.1.0.1-87511764eb0af2bce4db05e702750e63" doesn't exist
There are problems in package process-1.0.1.1:
  dependency "filepath-1.1.0.1-87511764eb0af2bce4db05e702750e63" doesn't exist
There are problems in package directory-1.0.0.2:
  dependency "filepath-1.1.0.1-87511764eb0af2bce4db05e702750e63" doesn't exist

The following packages are broken, either because they have a problem
listed above, or because they depend on a broken package.
ghc-6.12.1
haskeline-0.6.2
Cabal-1.7.4
process-1.0.1.1
directory-1.0.0.2
bin-package-db-0.0.0.0
hpc-0.5.0.2
haskell98-1.0.1.0
</pre> <p>To fix the problem, you need to recompile the broken packages against the new dependencies. The easiest way to do this is to use <code>cabal-install</code>, or download the packages from <a class="reference external" href="http://hackage.haskell.org/packages/hackage.html">HackageDB</a> and build and install them as normal.</p> <p>Be careful not to recompile any packages that GHC itself depends on, as this may render the <code>ghc</code> package itself broken, and <code>ghc</code> cannot be simply recompiled. The only way to recover from this would be to re-install GHC.</p>   <h2 id="package-management">8.9.7. Package management (the <code>ghc-pkg</code> command)</h2> <p id="package-management-the-ghc-pkg-command">The <strong class="command">ghc-pkg</strong> tool is for querying and modifying package databases. To see what package databases are in use, use <code>ghc-pkg list</code>. The stack of databases that <strong class="command">ghc-pkg</strong> knows about can be modified using the <a class="reference internal" href="#envvar-GHC_PACKAGE_PATH" id="index-10"><code>GHC_PACKAGE_PATH</code></a> environment variable (see <a class="reference internal" href="#ghc-package-path"><span class="std std-ref">The GHC_PACKAGE_PATH environment variable</span></a>, and using <a class="reference internal" href="#ghc-flag--package-db%20%E2%9F%A8file%E2%9F%A9"><code>-package-db ⟨file⟩</code></a> options on the <strong class="command">ghc-pkg</strong> command line.</p> <p>When asked to modify a database, <code>ghc-pkg</code> modifies the global database by default. Specifying <code>--user</code> causes it to act on the user database, or <code>--package-db</code> can be used to act on another database entirely. When multiple of these options are given, the rightmost one is used as the database to act upon.</p> <p>Commands that query the package database (list, latest, describe, field, dot) operate on the list of databases specified by the flags <code>--user</code>, <code>--global</code>, and <code>--package-db</code>. If none of these flags are given, the default is <code>--global --user</code>.</p> <p>If the environment variable <a class="reference internal" href="#envvar-GHC_PACKAGE_PATH" id="index-11"><code>GHC_PACKAGE_PATH</code></a> is set, and its value does not end in a separator (<code>:</code> on Unix, <code>;</code> on Windows), then the last database is considered to be the global database, and will be modified by default by <code>ghc-pkg</code>. The intention here is that <code>GHC_PACKAGE_PATH</code> can be used to create a virtual package environment into which Cabal packages can be installed without setting anything other than <code>GHC_PACKAGE_PATH</code>.</p> <p>The <code>ghc-pkg</code> program may be run in the ways listed below. Where a package name is required, the package can be named in full including the version number (e.g. <code>network-1.0</code>), or without the version number. Naming a package without the version number matches all versions of the package; the specified action will be applied to all the matching packages. A package specifier that matches all version of the package can also be written <code>⟨pkg⟩ -*</code>, to make it clearer that multiple packages are being matched. To match against the installed package ID instead of just package name and version, pass the <code>--ipid</code> flag.</p> <dl class="docutils"> <dt>
<code>ghc-pkg init path</code> </dt> <dd>Creates a new, empty, package database at ⟨path⟩, which must not already exist.</dd> <dt>
<code>ghc-pkg register ⟨file⟩</code> </dt> <dd>
<p class="first">Reads a package specification from ⟨file⟩ (which may be “<code>-</code>” to indicate standard input), and adds it to the database of installed packages. The syntax of ⟨file⟩ is given in <a class="reference internal" href="#installed-pkg-info"><span class="std std-ref">InstalledPackageInfo: a package specification</span></a>.</p> <p class="last">The package specification must be a package that isn’t already installed.</p> </dd> <dt>
<code>ghc-pkg update ⟨file⟩</code> </dt> <dd>The same as <code>register</code>, except that if a package of the same name is already installed, it is replaced by the new one.</dd> <dt>
<code>ghc-pkg unregister ⟨P⟩</code> </dt> <dd>Remove the specified package from the database.</dd> <dt>
<code>ghc-pkg check</code> </dt> <dd>Check consistency of dependencies in the package database, and report packages that have missing dependencies.</dd> <dt>
<code>ghc-pkg expose ⟨P⟩</code> </dt> <dd>Sets the <code>exposed</code> flag for package ⟨P⟩ to <code>True</code>.</dd> <dt>
<code>ghc-pkg hide ⟨P⟩</code> </dt> <dd>Sets the <code>exposed</code> flag for package ⟨P⟩ to <code>False</code>.</dd> <dt>
<code>ghc-pkg trust ⟨P⟩</code> </dt> <dd>Sets the <code>trusted</code> flag for package ⟨P⟩ to <code>True</code>.</dd> <dt>
<code>ghc-pkg distrust ⟨P⟩</code> </dt> <dd>Sets the <code>trusted</code> flag for package ⟨P⟩ to <code>False</code>.</dd> <dt>
<code>ghc-pkg list [⟨P⟩] [--simple-output]</code> </dt> <dd>
<p class="first">This option displays the currently installed packages, for each of the databases known to <code>ghc-pkg</code>. That includes the global database, the user’s local database, and any further files specified using the <code>-f</code> option on the command line.</p> <p>Hidden packages (those for which the <code>exposed</code> flag is <code>False</code>) are shown in parentheses in the list of packages.</p> <p>If an optional package identifier ⟨P⟩ is given, then only packages matching that identifier are shown.</p> <p class="last">If the option <code>--simple-output</code> is given, then the packages are listed on a single line separated by spaces, and the database names are not included. This is intended to make it easier to parse the output of <code>ghc-pkg list</code> using a script.</p> </dd> <dt>
<code>ghc-pkg find-module ⟨M⟩ [--simple-output]</code> </dt> <dd>
<p class="first">This option lists registered packages exposing module ⟨M⟩. Examples:</p> <pre data-language="haskell">$ ghc-pkg find-module Var
c:/fptools/validate/ghc/driver/package.conf.inplace:
    (ghc-6.9.20080428)

$ ghc-pkg find-module Data.Sequence
c:/fptools/validate/ghc/driver/package.conf.inplace:
    containers-0.1
</pre> <p class="last">Otherwise, it behaves like <code>ghc-pkg list</code>, including options.</p> </dd> <dt>
<code>ghc-pkg latest ⟨P⟩</code> </dt> <dd>Prints the latest available version of package ⟨P⟩.</dd> <dt>
<code>ghc-pkg describe ⟨P⟩</code> </dt> <dd>
<p class="first">Emit the full description of the specified package. The description is in the form of an <code>InstalledPackageInfo</code>, the same as the input file format for <code>ghc-pkg register</code>. See <a class="reference internal" href="#installed-pkg-info"><span class="std std-ref">InstalledPackageInfo: a package specification</span></a> for details.</p> <p class="last">If the pattern matches multiple packages, the description for each package is emitted, separated by the string <code>---</code> on a line by itself.</p> </dd> <dt>
<code>ghc-pkg field ⟨P⟩ ⟨field⟩[,⟨field⟩]*</code> </dt> <dd>Show just a single field of the installed package description for <code>P</code>. Multiple fields can be selected by separating them with commas</dd> <dt>
<code>ghc-pkg dot</code> </dt> <dd>
<p class="first">Generate a graph of the package dependencies in a form suitable for input for the <a class="reference external" href="http://www.graphviz.org/">graphviz</a> tools. For example, to generate a PDF of the dependency graph:</p> <pre data-language="haskell">ghc-pkg dot | tred | dot -Tpdf &gt;pkgs.pdf
</pre> </dd> <dt>
<code>ghc-pkg dump</code> </dt> <dd>
<p class="first">Emit the full description of every package, in the form of an <code>InstalledPackageInfo</code>. Multiple package descriptions are separated by the string <code>---</code> on a line by itself.</p> <p class="last">This is almost the same as <code>ghc-pkg describe '*'</code>, except that <code>ghc-pkg dump</code> is intended for use by tools that parse the results, so for example where <code>ghc-pkg describe '*'</code> will emit an error if it can’t find any packages that match the pattern, <code>ghc-pkg dump</code> will simply emit nothing.</p> </dd> <dt>
<code>ghc-pkg recache</code> </dt> <dd>
<p class="first">Re-creates the binary cache file <code>package.cache</code> for the selected database. This may be necessary if the cache has somehow become out-of-sync with the contents of the database (<code>ghc-pkg</code> will warn you if this might be the case).</p> <p class="last">The other time when <code>ghc-pkg recache</code> is useful is for registering packages manually: it is possible to register a package by simply putting the appropriate file in the package database directory and invoking <code>ghc-pkg recache</code> to update the cache. This method of registering packages may be more convenient for automated packaging systems.</p> </dd> </dl> <p>Substring matching is supported for ⟨M⟩ in <code>find-module</code> and for ⟨P⟩ in <code>list</code>, <code>describe</code>, and <code>field</code>, where a <code>'*'</code> indicates open substring ends (<code>prefix*</code>, <code>*suffix</code>, <code>*infix*</code>). Examples (output omitted):</p> <pre data-language="none">-- list all regex-related packages
ghc-pkg list '*regex*' --ignore-case
-- list all string-related packages
ghc-pkg list '*string*' --ignore-case
-- list OpenGL-related packages
ghc-pkg list '*gl*' --ignore-case
-- list packages exporting modules in the Data hierarchy
ghc-pkg find-module 'Data.*'
-- list packages exporting Monad modules
ghc-pkg find-module '*Monad*'
-- list names and maintainers for all packages
ghc-pkg field '*' name,maintainer
-- list location of haddock htmls for all packages
ghc-pkg field '*' haddock-html
-- dump the whole database
ghc-pkg describe '*'
</pre> <p>Additionally, the following flags are accepted by <code>ghc-pkg</code>:</p> <dl class="docutils"> <dt>
<code>-f ⟨file⟩, -package-db ⟨file⟩</code> </dt> <dd>
<p class="first last" id="index-12">Adds ⟨file⟩ to the stack of package databases. Additionally, ⟨file⟩ will also be the database modified by a <code>register</code>, <code>unregister</code>, <code>expose</code> or <code>hide</code> command, unless it is overridden by a later <code>--package-db</code>, <code>--user</code> or <code>--global</code> option.</p> </dd> <dt>
<code>--force</code> </dt> <dd>
<p class="first last" id="index-13">Causes <code>ghc-pkg</code> to ignore missing dependencies, directories and libraries when registering a package, and just go ahead and add it anyway. This might be useful if your package installation system needs to add the package to GHC before building and installing the files.</p> </dd> <dt>
<code>--global</code> </dt> <dd>
<p class="first last" id="index-14">Operate on the global package database (this is the default). This flag affects the <code>register</code>, <code>update</code>, <code>unregister</code>, <code>expose</code>, and <code>hide</code> commands.</p> </dd> <dt>
<code>--help, -?</code> </dt> <dd>
<p class="first last" id="index-15">Outputs the command-line syntax.</p> </dd> <dt>
<code>--user</code> </dt> <dd>
<p class="first last" id="index-16">Operate on the current user’s local package database. This flag affects the <code>register</code>, <code>update</code>, <code>unregister</code>, <code>expose</code>, and <code>hide</code> commands.</p> </dd> <dt>
<code>-v [⟨n⟩], --verbose [=⟨n⟩]</code> </dt> <dd>
<p class="first last" id="index-17">Control verbosity. Verbosity levels range from 0-2, where the default is 1, and <code>-v</code> alone selects level 2.</p> </dd> <dt>
<code>-V; --version</code> </dt> <dd>
<p class="first last" id="index-18">Output the <code>ghc-pkg</code> version number.</p> </dd> <dt>
<code>--ipid</code> </dt> <dd>
<p class="first last" id="index-19">Causes <code>ghc-pkg</code> to interpret arguments as installed package IDs (e.g., an identifier like <code>unix-2.3.1.0-de7803f1a8cd88d2161b29b083c94240</code>). This is useful if providing just the package name and version are ambiguous (in old versions of GHC, this was guaranteed to be unique, but this invariant no longer necessarily holds).</p> </dd> <dt>
<code>--package-key</code> </dt> <dd>
<p class="first last" id="index-20">Causes <code>ghc-pkg</code> to interpret arguments as unit IDs (e.g., an identifier like <code>I5BErHzyOm07EBNpKBEeUv</code>). Package keys are used to prefix symbol names GHC produces (e.g., <code>6VWy06pWzzJq9evDvK2d4w6_DataziByteStringziInternal_unsafePackLenChars_info</code>), so if you need to figure out what package a symbol belongs to, use <code>ghc-pkg</code> with this flag.</p> </dd> </dl>   <h2 id="building-packages">8.9.8. Building a package from Haskell source</h2> <p id="building-a-package-from-haskell-source">We don’t recommend building packages the hard way. Instead, use the <a class="reference external" href="http://www.haskell.org/cabal/users-guide/">Cabal</a> infrastructure if possible. If your package is particularly complicated or requires a lot of configuration, then you might have to fall back to the low-level mechanisms, so a few hints for those brave souls follow.</p> <p>You need to build an “installed package info” file for passing to <code>ghc-pkg</code> when installing your package. The contents of this file are described in <a class="reference internal" href="#installed-pkg-info"><span class="std std-ref">InstalledPackageInfo: a package specification</span></a>.</p> <p>The Haskell code in a package may be built into one or more archive libraries (e.g. <code>libHSfoo.a</code>), or a single shared object (e.g. <code>libHSfoo.dll/.so/.dylib</code>). The restriction to a single shared object is because the package system is used to tell the compiler when it should make an inter-shared-object call rather than an intra-shared-object-call call (inter-shared-object calls require an extra indirection).</p> <ul> <li>
<p class="first">Building a static library is done by using the <strong class="command">ar</strong> tool, like so:</p> <pre data-language="sh">ar cqs libHSfoo-1.0.a A.o B.o C.o ...
</pre> <p>where <code>A.o</code>, <code>B.o</code> and so on are the compiled Haskell modules, and <code>libHSfoo.a</code> is the library you wish to create. The syntax may differ slightly on your system, so check the documentation if you run into difficulties.</p> </li> <li>
<p class="first">To load a package <code>foo</code>, GHCi can load its <code>libHSfoo.a</code> library directly, but it can also load a package in the form of a single <code>HSfoo.o</code> file that has been pre-linked. Loading the <code>.o</code> file is slightly quicker, but at the expense of having another copy of the compiled package. The rule of thumb is that if the modules of the package were compiled with <a class="reference internal" href="phases#ghc-flag--split-objs"><code>-split-objs</code></a> then building the <code>HSfoo.o</code> is worthwhile because it saves time when loading the package into GHCi. Without <a class="reference internal" href="phases#ghc-flag--split-objs"><code>-split-objs</code></a>, there is not much difference in load time between the <code>.o</code> and <code>.a</code> libraries, so it is better to save the disk space and only keep the <code>.a</code> around. In a GHC distribution we provide <code>.o</code> files for most packages except the GHC package itself.</p> <p>The <code>HSfoo.o</code> file is built by Cabal automatically; use <code>--disable-library-for-ghci</code> to disable it. To build one manually, the following GNU <code>ld</code> command can be used:</p> <pre data-language="sh">ld -r --whole-archive -o HSfoo.o libHSfoo.a
</pre> <p>(replace <code>--whole-archive</code> with <code>-all_load</code> on MacOS X)</p> </li> <li>
<p class="first">When building the package as shared library, GHC can be used to perform the link step. This hides some of the details out the underlying linker and provides a common interface to all shared object variants that are supported by GHC (DLLs, ELF DSOs, and Mac OS dylibs). The shared object must be named in specific way for two reasons: (1) the name must contain the GHC compiler version, so that two library variants don’t collide that are compiled by different versions of GHC and that therefore are most likely incompatible with respect to calling conventions, (2) it must be different from the static name otherwise we would not be able to control the linker as precisely as necessary to make the <a class="reference internal" href="phases#ghc-flag--static"><code>-static</code></a>/<a class="reference internal" href="phases#ghc-flag--dynamic"><code>-dynamic</code></a> flags work, see <a class="reference internal" href="phases#options-linker"><span class="std std-ref">Options affecting linking</span></a>.</p> <pre data-language="sh">ghc -shared -dynamic -o libHSfoo-1.0-ghcGHCVersion.so A.o B.o C.o
</pre> <p>Using GHC’s version number in the shared object name allows different library versions compiled by different GHC versions to be installed in standard system locations, e.g. under *nix <code>/usr/lib</code>. To obtain the version number of GHC invoke <code>ghc --numeric-version</code> and use its output in place of ⟨GHCVersion⟩. See also <a class="reference internal" href="phases#options-codegen"><span class="std std-ref">Options affecting code generation</span></a> on how object files must be prepared for shared object linking.</p> </li> </ul> <p>To compile a module which is to be part of a new package, use the <code>-package-name</code> (to identify the name of the package) and <code>-library-name</code> (to identify the version and the version hashes of its identities.) options (<a class="reference internal" href="#using-packages"><span class="std std-ref">Using Packages</span></a>). Failure to use these options when compiling a package will probably result in disaster, but you will only discover later when you attempt to import modules from the package. At this point GHC will complain that the package name it was expecting the module to come from is not the same as the package name stored in the <code>.hi</code> file.</p> <p>It is worth noting with shared objects, when each package is built as a single shared object file, since a reference to a shared object costs an extra indirection, intra-package references are cheaper than inter-package references. Of course, this applies to the <code>main</code> package as well.</p>   <h2 id="installed-pkg-info">8.9.9. <code>InstalledPackageInfo</code>: a package specification</h2> <p id="installedpackageinfo-a-package-specification">A package specification is a Haskell record; in particular, it is the record <a class="reference external" href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/Cabal-3.0.1.0/Distribution-InstalledPackageInfo.html#t:InstalledPackageInfo">Distribution.InstalledPackageInfo.InstalledPackageInfo</a> in the module Distribution.InstalledPackageInfo, which is part of the Cabal package distributed with GHC.</p> <p>An <code>InstalledPackageInfo</code> has a human readable/writable syntax. The functions <code>parseInstalledPackageInfo</code> and <code>showInstalledPackageInfo</code> read and write this syntax respectively. Here’s an example of the <code>InstalledPackageInfo</code> for the <code>unix</code> package:</p> <pre data-language="none">$ ghc-pkg describe unix
name: unix
version: 2.3.1.0
id: unix-2.3.1.0-de7803f1a8cd88d2161b29b083c94240
license: BSD3
copyright:
maintainer: libraries@haskell.org
stability:
homepage:
package-url:
description: This package gives you access to the set of operating system
             services standardised by POSIX 1003.1b (or the IEEE Portable
             Operating System Interface for Computing Environments -
             IEEE Std. 1003.1).
             .
             The package is not supported under Windows (except under Cygwin).
category: System
author:
exposed: True
exposed-modules: System.Posix System.Posix.DynamicLinker.Module
                 System.Posix.DynamicLinker.Prim System.Posix.Directory
                 System.Posix.DynamicLinker System.Posix.Env System.Posix.Error
                 System.Posix.Files System.Posix.IO System.Posix.Process
                 System.Posix.Process.Internals System.Posix.Resource
                 System.Posix.Temp System.Posix.Terminal System.Posix.Time
                 System.Posix.Unistd System.Posix.User System.Posix.Signals
                 System.Posix.Signals.Exts System.Posix.Semaphore
                 System.Posix.SharedMem
hidden-modules:
trusted: False
import-dirs: /usr/lib/ghc-6.12.1/unix-2.3.1.0
library-dirs: /usr/lib/ghc-6.12.1/unix-2.3.1.0
hs-libraries: HSunix-2.3.1.0
extra-libraries: rt util dl
extra-ghci-libraries:
include-dirs: /usr/lib/ghc-6.12.1/unix-2.3.1.0/include
includes: HsUnix.h execvpe.h
depends: base-4.2.0.0-247bb20cde37c3ef4093ee124e04bc1c
hugs-options:
cc-options:
ld-options:
framework-dirs:
frameworks:
haddock-interfaces: /usr/share/doc/ghc/html/libraries/unix/unix.haddock
haddock-html: /usr/share/doc/ghc/html/libraries/unix
</pre> <p>Here is a brief description of the syntax of this file:</p> <p>A package description consists of a number of field/value pairs. A field starts with the field name in the left-hand column followed by a “<code>:</code>”, and the value continues until the next line that begins in the left-hand column, or the end of file.</p> <p>The syntax of the value depends on the field. The various field types are:</p> <dl class="docutils"> <dt>freeform</dt> <dd>Any arbitrary string, no interpretation or parsing is done.</dd> <dt>string</dt> <dd>A sequence of non-space characters, or a sequence of arbitrary characters surrounded by quotes <code>"...."</code>.</dd> <dt>string list</dt> <dd>A sequence of strings, separated by commas. The sequence may be empty.</dd> </dl> <p>In addition, there are some fields with special syntax (e.g. package names, version, dependencies).</p> <p>The allowed fields, with their types, are:</p> <dl class="docutils"> <dt>
<code>name</code> </dt> <dd>
<p class="first last" id="index-22">(string) The package’s name (without the version).</p> </dd> <dt>
<code>id</code> </dt> <dd>
<p class="first last" id="index-23">(string) The installed package ID. It is up to you to choose a suitable one.</p> </dd> <dt>
<code>version</code> </dt> <dd>
<p class="first last" id="index-24">(string) The package’s version, usually in the form <code>A.B</code> (any number of components are allowed).</p> </dd> <dt>
<code>license</code> </dt> <dd>
<p class="first last" id="index-25">(string) The type of license under which this package is distributed. This field is a value of the <a class="reference external" href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/Cabal-3.0.1.0/Distribution-License.html#t:License">Distribution.License.License</a> type.</p> </dd> <dt>
<code>license-file</code> </dt> <dd>
<p class="first last" id="index-26">(optional string) The name of a file giving detailed license information for this package.</p> </dd> <dt>
<code>copyright</code> </dt> <dd>
<p class="first last" id="index-27">(optional freeform) The copyright string.</p> </dd> <dt>
<code>maintainer</code> </dt> <dd>
<p class="first last" id="index-28">(optional freeform) The email address of the package’s maintainer.</p> </dd> <dt>
<code>stability</code> </dt> <dd>
<p class="first last" id="index-29">(optional freeform) A string describing the stability of the package (e.g. stable, provisional or experimental).</p> </dd> <dt>
<code>homepage</code> </dt> <dd>
<p class="first last" id="index-30">(optional freeform) URL of the package’s home page.</p> </dd> <dt>
<code>package-url</code> </dt> <dd>
<p class="first last" id="index-31">(optional freeform) URL of a downloadable distribution for this package. The distribution should be a Cabal package.</p> </dd> <dt>
<code>description</code> </dt> <dd>
<p class="first last" id="index-32">(optional freeform) Description of the package.</p> </dd> <dt>
<code>category</code> </dt> <dd>
<p class="first last" id="index-33">(optional freeform) Which category the package belongs to. This field is for use in conjunction with a future centralised package distribution framework, tentatively titled Hackage.</p> </dd> <dt>
<code>author</code> </dt> <dd>
<p class="first last" id="index-34">(optional freeform) Author of the package.</p> </dd> <dt>
<code>exposed</code> </dt> <dd>
<p class="first last" id="index-35">(bool) Whether the package is exposed or not.</p> </dd> <dt>
<code>exposed-modules</code> </dt> <dd>
<p class="first last" id="index-36">(string list) modules exposed by this package.</p> </dd> <dt>
<code>hidden-modules</code> </dt> <dd>
<p class="first last" id="index-37">(string list) modules provided by this package, but not exposed to the programmer. These modules cannot be imported, but they are still subject to the overlapping constraint: no other package in the same program may provide a module of the same name.</p> </dd> <dt>
<code>reexported-modules</code> </dt> <dd>
<p class="first last" id="index-38">Modules reexported by this package. This list takes the form of <code>pkg:OldName as NewName (A@orig-pkg-0.1-HASH)</code>: the first portion of the string is the user-written reexport specification (possibly omitting the package qualifier and the renaming), while the parenthetical is the original package which exposed the module under are particular name. Reexported modules have a relaxed overlap constraint: it’s permissible for two packages to reexport the same module as the same name if the reexported moduleis identical.</p> </dd> <dt>
<code>trusted</code> </dt> <dd>
<p class="first last" id="index-39">(bool) Whether the package is trusted or not.</p> </dd> <dt>
<code>import-dirs</code> </dt> <dd>
<p class="first" id="index-40">(string list) A list of directories containing interface files (<code>.hi</code> files) for this package.</p> <p class="last">If the package contains profiling libraries, then the interface files for those library modules should have the suffix <code>.p_hi</code>. So the package can contain both normal and profiling versions of the same library without conflict (see also <code>library_dirs</code> below).</p> </dd> <dt>
<code>library-dirs</code> </dt> <dd>
<p class="first last" id="index-41">(string list) A list of directories containing libraries for this package.</p> </dd> <dt>
<code>hs-libraries</code> </dt> <dd>
<p class="first" id="index-42">(string list) A list of libraries containing Haskell code for this package, with the <code>.a</code> or <code>.dll</code> suffix omitted. When packages are built as libraries, the <code>lib</code> prefix is also omitted.</p> <p>For use with GHCi, each library should have an object file too. The name of the object file does <em>not</em> have a <code>lib</code> prefix, and has the normal object suffix for your platform.</p> <p>For example, if we specify a Haskell library as <code>HSfoo</code> in the package spec, then the various flavours of library that GHC actually uses will be called:</p> <dl class="last docutils"> <dt>
<code>libHSfoo.a</code> </dt> <dd>The name of the library on Unix and Windows (mingw) systems. Note that we don’t support building dynamic libraries of Haskell code on Unix systems.</dd> <dt>
<code>HSfoo.dll</code> </dt> <dd>The name of the dynamic library on Windows systems (optional).</dd> <dt>
<code>HSfoo.o; HSfoo.obj</code> </dt> <dd>The object version of the library used by GHCi.</dd> </dl> </dd> <dt>
<code>extra-libraries</code> </dt> <dd>
<p class="first" id="index-43">(string list) A list of extra libraries for this package. The difference between <code>hs-libraries</code> and <code>extra-libraries</code> is that <code>hs-libraries</code> normally have several versions, to support profiling, parallel and other build options. The various versions are given different suffixes to distinguish them, for example the profiling version of the standard prelude library is named <code>libHSbase_p.a</code>, with the <code>_p</code> indicating that this is a profiling version. The suffix is added automatically by GHC for <code>hs-libraries</code> only, no suffix is added for libraries in <code>extra-libraries</code>.</p> <p>The libraries listed in <code>extra-libraries</code> may be any libraries supported by your system’s linker, including dynamic libraries (<code>.so</code> on Unix, <code>.DLL</code> on Windows).</p> <p class="last">Also, <code>extra-libraries</code> are placed on the linker command line after the <code>hs-libraries</code> for the same package. If your package has dependencies in the other direction (i.e. <code>extra-libraries</code> depends on <code>hs-libraries</code>), and the libraries are static, you might need to make two separate packages.</p> </dd> <dt>
<code>include-dirs</code> </dt> <dd>
<p class="first last" id="index-44">(string list) A list of directories containing C includes for this package.</p> </dd> <dt>
<code>includes</code> </dt> <dd>
<p class="first last" id="index-45">(string list) A list of files to include for via-C compilations using this package. Typically the include file(s) will contain function prototypes for any C functions used in the package, in case they end up being called as a result of Haskell functions from the package being inlined.</p> </dd> <dt>
<code>depends</code> </dt> <dd>
<p class="first last" id="index-46">(package id list) Packages on which this package depends.</p> </dd> <dt>
<code>hugs-options</code> </dt> <dd>
<p class="first last" id="index-47">(string list) Options to pass to Hugs for this package.</p> </dd> <dt>
<code>cc-options</code> </dt> <dd>
<p class="first last" id="index-48">(string list) Extra arguments to be added to the gcc command line when this package is being used (only for via-C compilations).</p> </dd> <dt>
<code>ld-options</code> </dt> <dd>
<p class="first last" id="index-49">(string list) Extra arguments to be added to the <code>gcc</code> command line (for linking) when this package is being used.</p> </dd> <dt>
<code>framework-dirs</code> </dt> <dd>
<p class="first last" id="index-50">(string list) On Darwin/MacOS X, a list of directories containing frameworks for this package. This corresponds to the <code>-framework-path</code> option. It is ignored on all other platforms.</p> </dd> <dt>
<code>frameworks</code> </dt> <dd>
<p class="first last" id="index-51">(string list) On Darwin/MacOS X, a list of frameworks to link to. This corresponds to the <code>-framework</code> option. Take a look at Apple’s developer documentation to find out what frameworks actually are. This entry is ignored on all other platforms.</p> </dd> <dt>
<code>haddock-interfaces</code> </dt> <dd>
<p class="first last" id="index-52">(string list) A list of filenames containing <a class="reference external" href="http://www.haskell.org/haddock/">Haddock</a> interface files (<code>.haddock</code> files) for this package.</p> </dd> <dt>
<code>haddock-html</code> </dt> <dd>
<p class="first last" id="index-53">(optional string) The directory containing the Haddock-generated HTML for this package.</p> </dd> </dl> <table class="docutils footnote" frame="void" id="id6" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id3">[1]</a></td>
<td>it used to in GHC 6.4, but not since 6.6</td>
</tr>  </table>   </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2002–2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/users_guide/packages.html" class="_attribution-link">https://downloads.haskell.org/~ghc/8.8.3/docs/html/users_guide/packages.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
