
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>8.8. Filenames and Separate Compilation - Haskell 8 - W3cubDocs</title>
  
  <meta name="description" content=" This section describes what files GHC expects to find, what files it creates, where these files are stored, and what options affect this behaviour. ">
  <meta name="keywords" content="filenames, and, separate, compilation, haskell, haskell~8">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/haskell~8/users_guide/separate_compilation.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/haskell~8.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/haskell~8/" class="_nav-link" title="" style="margin-left:0;">Haskell 8</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _haskell">
				
				
<h1 id="separate-compilation">8.8. Filenames and separate compilation</h1>
<div class="_sphinx">   <p id="filenames-and-separate-compilation">This section describes what files GHC expects to find, what files it creates, where these files are stored, and what options affect this behaviour.</p> <p>Pathname conventions vary from system to system. In particular, the directory separator is “<code>/</code>” on Unix systems and “<code>\</code>” on Windows systems. In the sections that follow, we shall consistently use “<code>/</code>” as the directory separator; substitute this for the appropriate character for your system.</p>  <h2 id="source-files">8.8.1. Haskell source files</h2> <p id="haskell-source-files">Each Haskell source module should be placed in a file on its own.</p> <p>Usually, the file should be named after the module name, replacing dots in the module name by directory separators. For example, on a Unix system, the module <code>A.B.C</code> should be placed in the file <code>A/B/C.hs</code>, relative to some base directory. If the module is not going to be imported by another module (<code>Main</code>, for example), then you are free to use any filename for it.</p> <p id="index-2">GHC assumes that source files are ASCII or UTF-8 only, other encoding are not recognised. However, invalid UTF-8 sequences will be ignored in comments, so it is possible to use other encodings such as Latin-1, as long as the non-comment source code is ASCII only.</p>   <h2 id="id1">8.8.2. Output files</h2> <p id="output-files">When asked to compile a source file, GHC normally generates two files: an object file, and an interface file.</p> <p>The object file, which normally ends in a <code>.o</code> suffix, contains the compiled code for the module.</p> <p>The interface file, which normally ends in a <code>.hi</code> suffix, contains the information that GHC needs in order to compile further modules that depend on this module. It contains things like the types of exported functions, definitions of data types, and so on. It is stored in a binary format, so don’t try to read one; use the <a class="reference internal" href="#"><code>--show-iface ⟨file⟩</code></a> option instead (see <a class="reference internal" href="#hi-options"><span class="std std-ref">Other options related to interface files</span></a>).</p> <p>You should think of the object file and the interface file as a pair, since the interface file is in a sense a compiler-readable description of the contents of the object file. If the interface file and object file get out of sync for any reason, then the compiler may end up making assumptions about the object file that aren’t true; trouble will almost certainly follow. For this reason, we recommend keeping object files and interface files in the same place (GHC does this by default, but it is possible to override the defaults as we’ll explain shortly).</p> <p>Every module has a <em>module name</em> defined in its source code (<code>module A.B.C where ...</code>).</p> <p>The name of the object file generated by GHC is derived according to the following rules, where ⟨osuf⟩ is the object-file suffix (this can be changed with the <code>-osuf</code> option).</p> <ul class="simple"> <li>If there is no <code>-odir</code> option (the default), then the object filename is derived from the source filename (ignoring the module name) by replacing the suffix with ⟨osuf⟩.</li> <li>If <code>-odir ⟨dir⟩</code> has been specified, then the object filename is ⟨dir⟩/⟨mod⟩.⟨osuf⟩, where ⟨mod⟩ is the module name with dots replaced by slashes. GHC will silently create the necessary directory structure underneath ⟨dir⟩, if it does not already exist.</li> </ul> <p>The name of the interface file is derived using the same rules, except that the suffix is ⟨hisuf⟩ (<code>.hi</code> by default) instead of ⟨osuf⟩, and the relevant options are <a class="reference internal" href="#ghc-flag--hidir%20%E2%9F%A8dir%E2%9F%A9"><code>-hidir ⟨dir⟩</code></a> and <a class="reference internal" href="#ghc-flag--hisuf%20%E2%9F%A8suffix%E2%9F%A9"><code>-hisuf ⟨suffix⟩</code></a> instead of <a class="reference internal" href="#ghc-flag--odir%20%E2%9F%A8dir%E2%9F%A9"><code>-odir ⟨dir⟩</code></a> and <a class="reference internal" href="#ghc-flag--osuf%20%E2%9F%A8suffix%E2%9F%A9"><code>-osuf ⟨suffix⟩</code></a> respectively.</p> <p>For example, if GHC compiles the module <code>A.B.C</code> in the file <code>src/A/B/C.hs</code>, with no <code>-odir</code> or <code>-hidir</code> flags, the interface file will be put in <code>src/A/B/C.hi</code> and the object file in <code>src/A/B/C.o</code>.</p> <p>For any module that is imported, GHC requires that the name of the module in the import statement exactly matches the name of the module in the interface file (or source file) found using the strategy specified in <a class="reference internal" href="#search-path"><span class="std std-ref">The search path</span></a>. This means that for most modules, the source file name should match the module name.</p> <p>However, note that it is reasonable to have a module <code>Main</code> in a file named <code>foo.hs</code>, but this only works because GHC never needs to search for the interface for module <code>Main</code> (because it is never imported). It is therefore possible to have several <code>Main</code> modules in separate source files in the same directory, and GHC will not get confused.</p> <p>In batch compilation mode, the name of the object file can also be overridden using the <a class="reference internal" href="#ghc-flag--o%20%E2%9F%A8file%E2%9F%A9"><code>-o ⟨file⟩</code></a> option, and the name of the interface file can be specified directly using the <a class="reference internal" href="#ghc-flag--ohi%20%E2%9F%A8file%E2%9F%A9"><code>-ohi ⟨file⟩</code></a> option.</p>   <h2 id="search-path">8.8.3. The search path</h2> <p id="the-search-path">In your program, you import a module <code>Foo</code> by saying <code>import Foo</code>. In <a class="reference internal" href="using#ghc-flag---make"><code>--make</code></a> mode or GHCi, GHC will look for a source file for <code>Foo</code> and arrange to compile it first. Without <a class="reference internal" href="using#ghc-flag---make"><code>--make</code></a>, GHC will look for the interface file for <code>Foo</code>, which should have been created by an earlier compilation of <code>Foo</code>. GHC uses the same strategy in each of these cases for finding the appropriate file.</p> <p>This strategy is as follows: GHC keeps a list of directories called the search path. For each of these directories, it tries appending <code>⟨basename⟩.⟨extension⟩</code> to the directory, and checks whether the file exists. The value of ⟨basename⟩ is the module name with dots replaced by the directory separator (“<code>/</code>” or “<code>\\"</code>, depending on the system), and ⟨extension⟩ is a source extension (<code>hs</code>, <code>lhs</code>) if we are in <a class="reference internal" href="using#ghc-flag---make"><code>--make</code></a> mode or GHCi, or ⟨hisuf⟩ otherwise.</p> <p>For example, suppose the search path contains directories <code>d1</code>, <code>d2</code>, and <code>d3</code>, and we are in <a class="reference internal" href="using#ghc-flag---make"><code>--make</code></a> mode looking for the source file for a module <code>A.B.C</code>. GHC will look in <code>d1/A/B/C.hs</code>, <code>d1/A/B/C.lhs</code>, <code>d2/A/B/C.hs</code>, and so on.</p> <p>The search path by default contains a single directory: “<code>.</code>” (i.e. the current directory). The following options can be used to add to or change the contents of the search path:</p> <dl class="ghc-flag"> <dt id="ghc-flag--i⟨dir⟩[:⟨dir⟩]*">
<code>-i⟨dir⟩[:⟨dir⟩]*</code> </dt> <dd>
<p id="index-5">This flag appends a colon-separated list of <code>dirs</code> to the search path.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--i">
<code>-i</code> </dt> <dd>
<p>resets the search path back to nothing.</p> </dd>
</dl> <p>This isn’t the whole story: GHC also looks for modules in pre-compiled libraries, known as packages. See the section on packages (<a class="reference internal" href="packages#packages"><span class="std std-ref">Packages</span></a>) for details.</p>   <h2 id="options-output">8.8.4. Redirecting the compilation output(s)</h2> <dl class="ghc-flag" id="redirecting-the-compilation-output-s"> <dt id="ghc-flag--o ⟨file⟩">
<code>-o ⟨file⟩</code> </dt> <dd>
<p>GHC’s compiled output normally goes into a <code>.hc</code>, <code>.o</code>, etc., file, depending on the last-run compilation phase. The option <code>-o file</code> re-directs the output of that last-run phase to ⟨file⟩.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">This “feature” can be counterintuitive: <code>ghc -C -o foo.o foo.hs</code> will put the intermediate C code in the file <code>foo.o</code>, name notwithstanding!</p> </div> <p>This option is most often used when creating an executable file, to set the filename of the executable. For example:</p> <pre data-language="none">ghc -o prog --make Main
</pre> <p>will compile the program starting with module <code>Main</code> and put the executable in the file <code>prog</code>.</p> <p>Note: on Windows, if the result is an executable file, the extension “<code>.exe</code>” is added if the specified filename does not already have an extension. Thus</p> <pre data-language="none">ghc -o foo Main.hs
</pre> <p>will compile and link the module <code>Main.hs</code>, and put the resulting executable in <code>foo.exe</code> (not <code>foo</code>).</p> <p>If you use <code>ghc --make</code> and you don’t use the <code>-o</code>, the name GHC will choose for the executable will be based on the name of the file containing the module <code>Main</code>. Note that with GHC the <code>Main</code> module doesn’t have to be put in file <code>Main.hs</code>. Thus both</p> <pre data-language="none">ghc --make Prog
</pre> <p>and</p> <pre data-language="none">ghc --make Prog.hs
</pre> <p>will produce <code>Prog</code> (or <code>Prog.exe</code> if you are on Windows).</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--odir ⟨dir⟩">
<code>-odir ⟨dir⟩</code> </dt> <dd>
<p>Redirects object files to directory ⟨dir⟩. For example:</p> <pre data-language="none">$ ghc -c parse/Foo.hs parse/Bar.hs gurgle/Bumble.hs -odir `uname -m`
</pre> <p>The object files, <code>Foo.o</code>, <code>Bar.o</code>, and <code>Bumble.o</code> would be put into a subdirectory named after the architecture of the executing machine (<code>x86</code>, <code>mips</code>, etc).</p> <p>Note that the <code>-odir</code> option does <em>not</em> affect where the interface files are put; use the <code>-hidir</code> option for that. In the above example, they would still be put in <code>parse/Foo.hi</code>, <code>parse/Bar.hi</code>, and <code>gurgle/Bumble.hi</code>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--ohi ⟨file⟩">
<code>-ohi ⟨file⟩</code> </dt> <dd>
<p>The interface output may be directed to another file <code>bar2/Wurble.iface</code> with the option <code>-ohi bar2/Wurble.iface</code> (not recommended).</p> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">If you redirect the interface file somewhere that GHC can’t find it, then the recompilation checker may get confused (at the least, you won’t get any recompilation avoidance). We recommend using a combination of <code>-hidir</code> and <code>-hisuf</code> options instead, if possible.</p> </div> <p>To avoid generating an interface at all, you could use this option to redirect the interface into the bit bucket: <code>-ohi /dev/null</code>, for example.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--hidir ⟨dir⟩">
<code>-hidir ⟨dir⟩</code> </dt> <dd>
<p>Redirects all generated interface files into ⟨dir⟩, instead of the default.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--hiedir ⟨dir⟩">
<code>-hiedir ⟨dir⟩</code> </dt> <dd>
<p>Redirects all generated extended interface files into ⟨dir⟩, instead of the default.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--stubdir ⟨dir⟩">
<code>-stubdir ⟨dir⟩</code> </dt> <dd>
<p>Redirects all generated FFI stub files into ⟨dir⟩. Stub files are generated when the Haskell source contains a <code>foreign export</code> or <code>foreign import "&amp;wrapper"</code> declaration (see <a class="reference internal" href="ffi-chap#foreign-export-ghc"><span class="std std-ref">Using foreign export and foreign import ccall “wrapper” with GHC</span></a>). The <code>-stubdir</code> option behaves in exactly the same way as <code>-odir</code> and <code>-hidir</code> with respect to hierarchical modules.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--dumpdir ⟨dir⟩">
<code>-dumpdir ⟨dir⟩</code> </dt> <dd>
<p>Redirects all dump files into ⟨dir⟩. Dump files are generated when <code>-ddump-to-file</code> is used with other <code>-ddump-*</code> flags.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--outputdir ⟨dir⟩">
<code>-outputdir ⟨dir⟩</code> </dt> <dd>
<p>The <code>-outputdir</code> option is shorthand for the combination of <a class="reference internal" href="#ghc-flag--odir%20%E2%9F%A8dir%E2%9F%A9"><code>-odir ⟨dir⟩</code></a>, <a class="reference internal" href="#ghc-flag--hidir%20%E2%9F%A8dir%E2%9F%A9"><code>-hidir ⟨dir⟩</code></a>, <a class="reference internal" href="#ghc-flag--stubdir%20%E2%9F%A8dir%E2%9F%A9"><code>-stubdir
⟨dir⟩</code></a> and <a class="reference internal" href="#ghc-flag--dumpdir%20%E2%9F%A8dir%E2%9F%A9"><code>-dumpdir ⟨dir⟩</code></a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--osuf ⟨suffix⟩">
<code>-osuf ⟨suffix⟩</code> </dt> <dd>
<p>The <code>-osuf</code> ⟨suffix⟩ will change the <code>.o</code> file suffix for object files to whatever you specify. We use this when compiling libraries, so that objects for the profiling versions of the libraries don’t clobber the normal ones.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--hisuf ⟨suffix⟩">
<code>-hisuf ⟨suffix⟩</code> </dt> <dd>
<p>Similarly, the <code>-hisuf</code> ⟨suffix⟩ will change the <code>.hi</code> file suffix for non-system interface files (see <a class="reference internal" href="#hi-options"><span class="std std-ref">Other options related to interface files</span></a>).</p> <p>The <code>-hisuf</code>/<code>-osuf</code> game is particularly useful if you want to compile a program both with and without profiling, in the same directory. You can say:</p> <pre data-language="none">ghc ...
</pre> <p>to get the ordinary version, and</p> <pre data-language="none">ghc ... -osuf prof.o -hisuf prof.hi -prof -fprof-auto
</pre> <p>to get the profiled version.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--hiesuf ⟨suffix⟩">
<code>-hiesuf ⟨suffix⟩</code> </dt> <dd>
<p>The <code>-hiesuf</code> ⟨suffix⟩ will change the <code>.hie</code> file suffix for extended interface files to whatever you specify.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--hcsuf ⟨suffix⟩">
<code>-hcsuf ⟨suffix⟩</code> </dt> <dd>
<p>Finally, the option <code>-hcsuf</code> ⟨suffix⟩ will change the <code>.hc</code> file suffix for compiler-generated intermediate C files.</p> </dd>
</dl>   <h2 id="keeping-intermediates">8.8.5. Keeping Intermediate Files</h2> <p id="keeping-intermediate-files">The following options are useful for keeping (or not keeping) certain intermediate files around, when normally GHC would throw these away after compilation:</p> <dl class="ghc-flag"> <dt id="ghc-flag--keep-hc-file">
<code>-keep-hc-file</code> </dt> <dt id="ghc-flag--keep-hc-files">
<code>-keep-hc-files</code> </dt> <dd>
<p>Keep intermediate <code>.hc</code> files when doing <code>.hs</code>-to-<code>.o</code> compilations via <a class="reference internal" href="codegens#c-code-gen"><span class="std std-ref">C</span></a> (Note: <code>.hc</code> files are only generated by <a class="reference internal" href="codegens#unreg"><span class="std std-ref">unregisterised</span></a> compilers).</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--keep-hi-files">
<code>-keep-hi-files</code> </dt> <dd>
<p id="index-8">Keep intermediate <code>.hi</code> files. This is the default. You may use <code>-no-keep-hi-files</code> if you are not interested in the <code>.hi</code> files.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--keep-hscpp-file">
<code>-keep-hscpp-file</code> </dt> <dt id="ghc-flag--keep-hscpp-files">
<code>-keep-hscpp-files</code> </dt> <dd>
<p id="index-9">Keep the output of the <code>CPP</code> pre-processor phase as <code>.hscpp</code> files. A <code>.hscpp</code> file is only created, if a module gets compiled and uses the C pre-processor.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--keep-llvm-file">
<code>-keep-llvm-file</code> </dt> <dt id="ghc-flag--keep-llvm-files">
<code>-keep-llvm-files</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Implies:</th>
<td class="field-body"><a class="reference internal" href="phases#ghc-flag--fllvm"><code>-fllvm</code></a></td> </tr>  </table> <p>Keep intermediate <code>.ll</code> files when doing <code>.hs</code>-to-<code>.o</code> compilations via <a class="reference internal" href="codegens#llvm-code-gen"><span class="std std-ref">LLVM</span></a> (Note: <code>.ll</code> files aren’t generated when using the native code generator, you may need to use <a class="reference internal" href="phases#ghc-flag--fllvm"><code>-fllvm</code></a> to force them to be produced).</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--keep-o-files">
<code>-keep-o-files</code> </dt> <dd>
<p id="index-10">Keep intermediate <code>.o</code> files. This is the default. You may use <code>-no-keep-o-files</code> if you are not interested in the <code>.o</code> files.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--keep-s-file">
<code>-keep-s-file</code> </dt> <dt id="ghc-flag--keep-s-files">
<code>-keep-s-files</code> </dt> <dd>
<p>Keep intermediate <code>.s</code> files.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--keep-tmp-files">
<code>-keep-tmp-files</code> </dt> <dd>
<p id="index-11">Instructs the GHC driver not to delete any of its temporary files, which it normally keeps in <code>/tmp</code> (or possibly elsewhere; see <a class="reference internal" href="#temp-files"><span class="std std-ref">Redirecting temporary files</span></a>). Running GHC with <code>-v</code> will show you what temporary files were generated along the way.</p> </dd>
</dl>   <h2 id="temp-files">8.8.6. Redirecting temporary files</h2> <dl class="ghc-flag" id="redirecting-temporary-files"> <dt id="ghc-flag--tmpdir ⟨dir⟩">
<code>-tmpdir ⟨dir⟩</code> </dt> <dd>
<p>If you have trouble because of running out of space in <code>/tmp</code> (or wherever your installation thinks temporary files should go), you may use the <a class="reference internal" href="#ghc-flag--tmpdir%20%E2%9F%A8dir%E2%9F%A9"><code>-tmpdir ⟨dir⟩</code></a> option option to specify an alternate directory. For example, <code>-tmpdir .</code> says to put temporary files in the current working directory.</p> <p id="index-13">Alternatively, use your <code id="index-14">TMPDIR</code> environment variable. Set it to the name of the directory where temporary files should be put. GCC and other programs will honour the <code id="index-15">TMPDIR</code> variable as well.</p> </dd>
</dl>   <h2 id="hi-options">8.8.7. Other options related to interface files</h2> <dl class="ghc-flag" id="other-options-related-to-interface-files"> <dt id="ghc-flag--ddump-hi">
<code>-ddump-hi</code> </dt> <dd>
<p>Dumps the new interface to standard output.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--ddump-hi-diffs">
<code>-ddump-hi-diffs</code> </dt> <dd>
<p>The compiler does not overwrite an existing <code>.hi</code> interface file if the new one is the same as the old one; this is friendly to <strong class="command">make</strong>. When an interface does change, it is often enlightening to be informed. The <a class="reference internal" href="#ghc-flag--ddump-hi-diffs"><code>-ddump-hi-diffs</code></a> option will make GHC report the differences between the old and new <code>.hi</code> files.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--ddump-minimal-imports">
<code>-ddump-minimal-imports</code> </dt> <dd>
<p>Dump to the file <code><em>M</em>.imports</code> (where ⟨M⟩ is the name of the module being compiled) a “minimal” set of import declarations. The directory where the <code>.imports</code> files are created can be controlled via the <a class="reference internal" href="#ghc-flag--dumpdir%20%E2%9F%A8dir%E2%9F%A9"><code>-dumpdir ⟨dir⟩</code></a> option.</p> <p>You can safely replace all the import declarations in <code><em>M</em>.hs</code> with those found in its respective <code>.imports</code> file. Why would you want to do that? Because the “minimal” imports (a) import everything explicitly, by name, and (b) import nothing that is not required. It can be quite painful to maintain this property by hand, so this flag is intended to reduce the labour.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag---show-iface ⟨file⟩">
<code>--show-iface ⟨file⟩</code> </dt> <dd>
<p>where ⟨file⟩ is the name of an interface file, dumps the contents of that interface in a human-readable format. See <a class="reference internal" href="using#modes"><span class="std std-ref">Modes of operation</span></a>.</p> </dd>
</dl>   <h2 id="hie-options">8.8.8. Options related to extended interface files</h2> <p id="options-related-to-extended-interface-files">GHC builds up a wealth of information about a Haskell source file as it compiles it. Extended interface files are a way of persisting some of this information to disk so that external tools, such as IDE’s, can avoid parsing, typechecking, and renaming all over again. These files contain</p>  <ul> <li>
<p class="first">a simplified AST</p>  <ul class="simple"> <li>nodes are annotated with source positions and types</li> <li>identifiers are annotated with scope information</li> </ul>  </li> <li>the raw bytes of the initial Haskell source </li> </ul>  <p>The GHC API exposes functions for reading and writing these files.</p> <dl class="ghc-flag"> <dt id="ghc-flag--fwrite-ide-info">
<code>-fwrite-ide-info</code> </dt> <dd>
<p>Writes out extended interface files alongisde regular enterface files. Just like regular interface files, GHC has a recompilation check to detect out of date or missing extended interface files.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fvalidate-ide-info">
<code>-fvalidate-ide-info</code> </dt> <dd>
<p>Runs a series of sanity checks and lints on the extended interface files that are being written out. These include testing things properties such as variables not occuring outside of their expected scopes.</p> </dd>
</dl> <p>The format in which GHC currently stores its typechecked AST, makes it costly to collect the types for some expressions nodes. For the sake of performance, GHC currently chooses to skip over these, so not all expression nodes should be expected to have type information on them. See <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/16233">Issue #16233</a> for more.</p>   <h2 id="recomp">8.8.9. The recompilation checker</h2> <dl class="ghc-flag" id="the-recompilation-checker"> <dt id="ghc-flag--fforce-recomp">
<code>-fforce-recomp</code> </dt> <dd>
<p>Turn off recompilation checking (which is on by default). Recompilation checking normally stops compilation early, leaving an existing <code>.o</code> file in place, if it can be determined that the module does not need to be recompiled.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fignore-optim-changes">
<code>-fignore-optim-changes</code> </dt> 
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fignore-hpc-changes">
<code>-fignore-hpc-changes</code> </dt> 
</dl> <p>In the olden days, GHC compared the newly-generated <code>.hi</code> file with the previous version; if they were identical, it left the old one alone and didn’t change its modification date. In consequence, importers of a module with an unchanged output <code>.hi</code> file were not recompiled.</p> <p>This doesn’t work any more. Suppose module <code>C</code> imports module <code>B</code>, and <code>B</code> imports module <code>A</code>. So changes to module <code>A</code> might require module <code>C</code> to be recompiled, and hence when <code>A.hi</code> changes we should check whether <code>C</code> should be recompiled. However, the dependencies of <code>C</code> will only list <code>B.hi</code>, not <code>A.hi</code>, and some changes to <code>A</code> (changing the definition of a function that appears in an inlining of a function exported by <code>B</code>, say) may conceivably not change <code>B.hi</code> one jot. So now…</p> <p>GHC calculates a fingerprint (in fact an MD5 hash) of each interface file, and of each declaration within the interface file. It also keeps in every interface file a list of the fingerprints of everything it used when it last compiled the file. If the source file’s modification date is earlier than the <code>.o</code> file’s date (i.e. the source hasn’t changed since the file was last compiled), and the recompilation checking is on, GHC will be clever. It compares the fingerprints on the things it needs this time with the fingerprints on the things it needed last time (gleaned from the interface file of the module being compiled); if they are all the same it stops compiling early in the process saying “Compilation IS NOT required”. What a beautiful sight!</p> <p>You can read about <a class="reference external" href="http://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/RecompilationAvoidance">how all this works</a> in the GHC commentary.</p>   <h2 id="mutual-recursion">8.8.10. How to compile mutually recursive modules</h2> <p id="how-to-compile-mutually-recursive-modules">GHC supports the compilation of mutually recursive modules. This section explains how.</p> <p>Every cycle in the module import graph must be broken by a <code>hs-boot</code> file. Suppose that modules <code>A.hs</code> and <code>B.hs</code> are Haskell source files, thus:</p> <pre data-language="haskell">module A where
    import B( TB(..) )

    newtype TA = MkTA Int

    f :: TB -&gt; TA
    f (MkTB x) = MkTA x

module B where
    import {-# SOURCE #-} A( TA(..) )

    data TB = MkTB !Int

    g :: TA -&gt; TB
    g (MkTA x) = MkTB x
</pre> <p id="index-20">Here <code>A</code> imports <code>B</code>, but <code>B</code> imports <code>A</code> with a <code>{-# SOURCE #-}</code> pragma, which breaks the circular dependency. Every loop in the module import graph must be broken by a <code>{-# SOURCE #-}</code> import; or, equivalently, the module import graph must be acyclic if <code>{-# SOURCE #-}</code> imports are ignored.</p> <p>For every module <code>A.hs</code> that is <code>{-# SOURCE #-}</code>-imported in this way there must exist a source file <code>A.hs-boot</code>. This file contains an abbreviated version of <code>A.hs</code>, thus:</p> <pre data-language="haskell">module A where
    newtype TA = MkTA Int
</pre> <p>To compile these three files, issue the following commands:</p> <pre data-language="none">ghc -c A.hs-boot    -- Produces A.hi-boot, A.o-boot
ghc -c B.hs         -- Consumes A.hi-boot, produces B.hi, B.o
ghc -c A.hs         -- Consumes B.hi, produces A.hi, A.o
ghc -o foo A.o B.o  -- Linking the program
</pre> <p>There are several points to note here:</p> <ul> <li>The file <code>A.hs-boot</code> is a programmer-written source file. It must live in the same directory as its parent source file <code>A.hs</code>. Currently, if you use a literate source file <code>A.lhs</code> you must also use a literate boot file, <code>A.lhs-boot</code>; and vice versa. </li> <li>
<p class="first">A <code>hs-boot</code> file is compiled by GHC, just like a <code>hs</code> file:</p> <pre data-language="none">ghc -c A.hs-boot
</pre> <p>When a hs-boot file <code>A.hs-boot</code> is compiled, it is checked for scope and type errors. When its parent module <code>A.hs</code> is compiled, the two are compared, and an error is reported if the two are inconsistent.</p> </li> <li>
<p class="first">Just as compiling <code>A.hs</code> produces an interface file <code>A.hi</code>, and an object file <code>A.o</code>, so compiling <code>A.hs-boot</code> produces an interface file <code>A.hi-boot</code>, and a pseudo-object file <code>A.o-boot</code>:</p> <ul class="simple"> <li>The pseudo-object file <code>A.o-boot</code> is empty (don’t link it!), but it is very useful when using a Makefile, to record when the <code>A.hi-boot</code> was last brought up to date (see <a class="reference internal" href="#using-make"><span class="std std-ref">Using make</span></a>).</li> <li>The <code>hi-boot</code> generated by compiling a <code>hs-boot</code> file is in the same machine-generated binary format as any other GHC-generated interface file (e.g. <code>B.hi</code>). You can display its contents with <code>ghc --show-iface</code>. If you specify a directory for interface files, the <code>-ohidir</code> flag, then that affects <code>hi-boot</code> files too.</li> </ul> </li> <li>If hs-boot files are considered distinct from their parent source files, and if a <code>{-# SOURCE #-}</code> import is considered to refer to the hs-boot file, then the module import graph must have no cycles. The command <code>ghc -M</code> will report an error if a cycle is found. </li> <li>A module <code>M</code> that is <code>{-# SOURCE #-}</code>-imported in a program will usually also be ordinarily imported elsewhere. If not, <code>ghc --make</code> automatically adds <code>M</code> to the set of modules it tries to compile and link, to ensure that <code>M</code>‘s implementation is included in the final program. </li> </ul> <p>A hs-boot file need only contain the bare minimum of information needed to get the bootstrapping process started. For example, it doesn’t need to contain declarations for <em>everything</em> that module <code>A</code> exports, only the things required by the module(s) that import <code>A</code> recursively.</p> <p>A hs-boot file is written in a subset of Haskell:</p> <ul> <li>The module header (including the export list), and import statements, are exactly as in Haskell, and so are the scoping rules. Hence, to mention a non-Prelude type or class, you must import it. </li> <li>
<p class="first">There must be no value declarations, but there can be type signatures for values. For example:</p> <pre data-language="haskell">double :: Int -&gt; Int
</pre> </li> <li>Fixity declarations are exactly as in Haskell. </li> <li>Vanilla type synonym declarations are exactly as in Haskell. </li> <li>Open type and data family declarations are exactly as in Haskell. </li> <li>
<p class="first">A closed type family may optionally omit its equations, as in the following example:</p> <pre data-language="haskell">type family ClosedFam a where ..
</pre> <p>The <code>..</code> is meant literally – you should write two dots in your file. Note that the <code>where</code> clause is still necessary to distinguish closed families from open ones. If you give any equations of a closed family, you must give all of them, in the same order as they appear in the accompanying Haskell file.</p> </li> <li>
<p class="first">A data type declaration can either be given in full, exactly as in Haskell, or it can be given abstractly, by omitting the ‘=’ sign and everything that follows. For example:</p> <pre data-language="haskell">data T a b
</pre> <p>In a <em>source</em> program this would declare TA to have no constructors (a GHC extension: see <a class="reference internal" href="glasgow_exts#nullary-types"><span class="std std-ref">Data types with no constructors</span></a>), but in an hi-boot file it means “I don’t know or care what the constructors are”. This is the most common form of data type declaration, because it’s easy to get right. You <em>can</em> also write out the constructors but, if you do so, you must write it out precisely as in its real definition.</p> <p>If you do not write out the constructors, you may need to give a kind annotation (<a class="reference internal" href="glasgow_exts#kinding"><span class="std std-ref">Explicitly-kinded quantification</span></a>), to tell GHC the kind of the type variable, if it is not “*”. (In source files, this is worked out from the way the type variable is used in the constructors.) For example:</p> <pre data-language="haskell">data R (x :: * -&gt; *) y
</pre> <p>You cannot use <code>deriving</code> on a data type declaration; write an <code>instance</code> declaration instead.</p> </li> <li>Class declarations is exactly as in Haskell, except that you may not put default method declarations. You can also omit all the superclasses and class methods entirely; but you must either omit them all or put them all in. </li> <li>You can include instance declarations just as in Haskell; but omit the “where” part. </li> <li>The default role for abstract datatype parameters is now representational. (An abstract datatype is one with no constructors listed.) To get another role, use a role annotation. (See <a class="reference internal" href="glasgow_exts#roles"><span class="std std-ref">Roles</span></a>.) </li> </ul>   <h2 id="id2">8.8.11. Module signatures</h2> <p id="module-signatures">GHC 8.2 supports module signatures (<code>hsig</code> files), which allow you to write a signature in place of a module implementation, deferring the choice of implementation until a later point in time. This feature is not intended to be used without <a class="reference external" href="http://www.haskell.org/cabal/">Cabal</a>; this manual entry will focus on the syntax and semantics of signatures.</p> <p>To start with an example, suppose you had a module <code>A</code> which made use of some string operations. Using normal module imports, you would only be able to pick a particular implementation of strings:</p> <pre data-language="haskell">module Str where
    type Str = String

    empty :: Str
    empty = ""

    toString :: Str -&gt; String
    toString s = s

module A where
    import Str
    z = toString empty
</pre> <p>By replacing <code>Str.hs</code> with a signature <code>Str.hsig</code>, <code>A</code> (and any other modules in this package) are now parametrized by a string implementation:</p> <pre data-language="haskell">signature Str where
    data Str
    empty :: Str
    toString :: Str -&gt; String
</pre> <p>We can typecheck <code>A</code> against this signature, or we can instantiate <code>Str</code> with a module that provides the following declarations. Refer to Cabal’s documentation for a more in-depth discussion on how to instantiate signatures.</p> <p>Module signatures actually consist of two closely related features:</p> <ul class="simple"> <li>The ability to define an <code>hsig</code> file, containing type definitions and type signature for values which can be used by modules that import the signature, and must be provided by the eventual implementing module, and</li> <li>The ability to <em>inherit</em> required signatures from packages we depend upon, combining the signatures into a single merged signature which reflects the requirements of any locally defined signature, as well as the requirements of our dependencies.</li> </ul> <p>A signature file is denoted by an <code>hsig</code> file; every required signature must have an <code>hsig</code> file (even if it is an empty one), including required signatures inherited from dependencies. Signatures can be imported using an ordinary <code>import Sig</code> declaration.</p> <p><code>hsig</code> files are written in a variant of Haskell similar to <code>hs-boot</code> files, but with some slight changes:</p> <ul> <li>The header of a signature is <code>signature A where ...</code> (instead of the usual <code>module A where ...</code>). </li> <li>Import statements and scoping rules are exactly as in Haskell. To mention a non-Prelude type or class, you must import it. </li> <li>
<p class="first">Unlike regular modules, the defined entities of a signature include not only those written in the local <code>hsig</code> file, but also those from inherited signatures (as inferred from the <a class="reference internal" href="#"><code>-package-id ⟨unit-id⟩</code></a> flags). These entities are not considered in scope when typechecking the local <code>hsig</code> file, but are available for import by any module or signature which imports the signature. The one exception to this rule is the export list, described below.</p> <p>If a declaration occurs in multiple inherited signatures, they will be <em>merged</em> together. For values, we require that the types from both signatures match exactly; however, other declarations may merge in more interesting ways. The merging operation in these cases has the effect of textually replacing all occurrences of the old name with a reference to the new, merged declaration. For example, if we have the following two signatures:</p> <pre data-language="haskell">signature A where
    data T
    f :: T -&gt; T

signature A where
    data T = MkT
    g :: T
</pre> <p>the resulting merged signature would be:</p> <pre data-language="haskell">signature A where
    data T = MkT
    f :: T -&gt; T
    g :: T
</pre> </li> <li>
<p class="first">If no export list is provided for a signature, the exports of a signature are all of its defined entities merged with the exports of all inherited signatures.</p> <p>If you want to reexport an entity from a signature, you must also include a <code>module SigName</code> export, so that all of the entities defined in the signature are exported. For example, the following module exports both <code>f</code> and <code>Int</code> from <code>Prelude</code>:</p> <pre data-language="haskell">signature A(module A, Int) where
    import Prelude (Int)
    f :: Int
</pre> <p>Reexports merge with local declarations; thus, the signature above would successfully merge with:</p> <pre data-language="haskell">signature A where
    data Int
</pre> <p>The only permissible implementation of such a signature is a module which reexports precisely the same entity:</p> <pre data-language="haskell">module A (f, Int) where
    import Prelude (Int)
    f = 2 :: Int
</pre> <p>Conversely, any entity requested by a signature can be provided by a reexport from the implementing module. This is different from <code>hs-boot</code> files, which require every entity to be defined locally in the implementing module.</p> </li> <li>
<p class="first">GHC has experimental support for <em>signature thinning</em>, which is used when a signature has an explicit export list without a module export of the signature itself. In this case, the export list applies to the final export list <em>after</em> merging, in particular, you may refer to entities which are not declared in the body of the local <code>hsig</code> file.</p> <p>The semantics in this case is that the set of required entities is defined exclusively by its exports; if an entity is not mentioned in the export list, it is not required. The motivation behind this feature is to allow a library author to provide an omnibus signature containing the type of every function someone might want to use, while a client thins down the exports to the ones they actually require. For example, supposing that you have inherited a signature for strings, you might write a local signature of this form, listing only the entities that you need:</p> <pre data-language="haskell">signature Str (Str, empty, append, concat) where
    -- empty
</pre> <p>A few caveats apply here. First, it is illegal to export an entity which refers to a locally defined type which itself is not exported (GHC will report an error in this case). Second, signatures which come from dependencies which expose modules cannot be thinned in this way (after all, the dependency itself may need the entity); these requirements are unconditionally exported. Finally, any module reexports must refer to modules imported by the local signature (even if an inherited signature exported the module).</p> <p>We may change the syntax and semantics of this feature in the future.</p> </li> <li>
<p class="first">The declarations and types from signatures of dependencies that will be merged in are not in scope when type checking an <code>hsig</code> file. To refer to any such type, you must declare it yourself:</p> <pre data-language="haskell">-- OK, assuming we inherited an A that defines T
signature A (T) where
    -- empty

-- Not OK
signature A (T, f) where
    f :: T -&gt; T

-- OK
signature A (T, f) where
    data T
    f :: T -&gt; T
</pre> </li> <li>
<p class="first">There must be no value declarations, but there can be type signatures for values. For example, we might define the signature:</p> <pre data-language="haskell">signature A where
    double :: Int -&gt; Int
</pre> <p>A module implementing <code>A</code> would have to export the function <code>double</code> with a type definitionally equal to the signature. Note that this means you can’t implement <code>double</code> using a polymorphic function <code>double :: Num a =&gt; a -&gt; a</code>.</p> <p>Note that signature matching does check if <em>fixity</em> matches, so be sure specify fixity of ordinary identifiers if you intend to use them with backticks.</p> </li> <li>Fixity, type synonym, open type/data family declarations are permitted as in normal Haskell. </li> <li>
<p class="first">Closed type family declarations are permitted as in normal Haskell. They can also be given abstractly, as in the following example:</p> <pre data-language="haskell">type family ClosedFam a where ..
</pre> <p>The <code>..</code> is meant literally – you should write two dots in your file. The <code>where</code> clause distinguishes closed families from open ones.</p> </li> <li>
<p class="first">A data type declaration can either be given in full, exactly as in Haskell, or it can be given abstractly, by omitting the ‘=’ sign and everything that follows. For example:</p> <pre data-language="haskell">signature A where
    data T a b
</pre> <p>Abstract data types can be implemented not only with data declarations, but also newtypes and type synonyms (with the restriction that a type synonym must be fully eta-reduced, e.g., <code>type T = ...</code> to be accepted.) For example, the following are all valid implementations of the T above:</p> <pre data-language="haskell">-- Algebraic data type
data T a b = MkT a b

-- Newtype
newtype T a b = MkT (a, b)

-- Type synonym
data T2 a b = MkT2 a a b b
type T = T2
</pre> <p>Data type declarations merge only with other data type declarations which match exactly, except abstract data, which can merge with <code>data</code>, <code>newtype</code> or <code>type</code> declarations. Merges with type synonyms are especially useful: suppose you are using a package of strings which has left the type of characters in the string unspecified:</p> <pre data-language="haskell">signature Str where
    data Str
    data Elem
    head :: Str -&gt; Elem
</pre> <p>If you locally define a signature which specifies <code>type Elem = Char</code>, you can now use <code>head</code> from the inherited signature as if it returned a <code>Char</code>.</p> <p>If you do not write out the constructors, you may need to give a kind to tell GHC what the kinds of the type variables are, if they are not the default <code>*</code>. Unlike regular data type declarations, the return kind of an abstract data declaration can be anything (in which case it probably will be implemented using a type synonym.) This can be used to allow compile-time representation polymorphism (as opposed to <a class="reference external" href="#runtime-rep">run-time representation polymorphism</a>), as in this example:</p> <pre data-language="haskell">signature Number where
    import GHC.Types
    data Rep :: RuntimeRep
    data Number :: TYPE Rep
    plus :: Number -&gt; Number -&gt; Number
</pre> <p>Roles of type parameters are subject to the subtyping relation <code>phantom &lt; representational &lt; nominal</code>: for example, an abstract type with a nominal type parameter can be implemented using a concrete type with a representational type parameter. Merging respects this subtyping relation (e.g., <code>nominal</code> merged with <code>representational</code> is <code>representational</code>.) Roles in signatures default to <code>nominal</code>, which gives maximum flexibility on the implementor’s side. You should only need to give an explicit role annotation if a client of the signature would like to coerce the abstract type in a type parameter (in which case you should specify <code>representational</code> explicitly.) Unlike regular data types, we do <em>not</em> assume that abstract data types are representationally injective: if we have <code>Coercible (T a) (T b)</code>, and <code>T</code> has role <code>nominal</code>, this does not imply that <code>a ~ b</code>.</p> </li> <li>
<p class="first">A class declarations can either be abstract or concrete. An abstract class is one with no superclasses or class methods:</p> <pre data-language="haskell">signature A where
    class Key k
</pre> <p>It can be implemented in any way, with any set of superclasses and methods; however, modules depending on an abstract class are not permitted to define instances (as of GHC 8.2, this restriction is not checked, see <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/13086">Issue #13086</a>.) These declarations can be implemented by type synonyms of kind <code>Constraint</code>; this can be useful if you want to parametrize over a constraint in functions. For example, with the <code>ConstraintKinds</code> extension, this type synonym is a valid implementation of the signature above:</p> <pre data-language="haskell">module A where
    type Key = Eq
</pre> <p>A concrete class specifies its superclasses, methods, default method signatures (but not their implementations) and a <code>MINIMAL</code> pragma. Unlike regular Haskell classes, you don’t have to explicitly declare a default for a method to make it optional vis-a-vis the <code>MINIMAL</code> pragma.</p> <p>When merging class declarations, we require that the superclasses and methods match exactly; however, <code>MINIMAL</code> pragmas are logically ORed together, and a method with a default signature will merge successfully against one that does not.</p> </li> <li>
<p class="first">You can include instance declarations as in Haskell; just omit the “where” part. An instance declaration need not be implemented directly; if an instance can be derived based on instances in the environment, it is considered implemented. For example, the following signature:</p> <pre data-language="haskell">signature A where
    data Str
    instance Eq Str
</pre> <p>is considered implemented by the following module, since there are instances of <code>Eq</code> for <code>[]</code> and <code>Char</code> which can be combined to form an instance <code>Eq [Char]</code>:</p> <pre data-language="haskell">module A where
    type Str = [Char]
</pre> <p>Unlike other declarations, for which only the entities declared in a signature file are brought into scope, instances from the implementation are always brought into scope, even if they were not declared in the signature file. This means that a module may typecheck against a signature, but not against a matching implementation. You can avoid situations like this by never defining orphan instances inside a package that has signatures.</p> <p>Instance declarations are only merged if their heads are exactly the same, so it is possible to get into a situation where GHC thinks that instances in a signature are overlapping, even if they are implemented in a non-overlapping way. If this is giving you problems give us a shout.</p> </li> <li>Any orphan instances which are brought into scope by an import from a signature are unconditionally considered in scope, even if the eventual implementing module doesn’t actually import the same orphans. </li> </ul> <p>Known limitations:</p> <ul class="simple"> <li>Pattern synonyms are not supported.</li> <li>Algebraic data types specified in a signature cannot be implemented using pattern synonyms. See <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/12717">Issue #12717</a>
</li> </ul>   <h2 id="id3">8.8.12. Using <code>make</code>
</h2> <p id="using-make">It is reasonably straightforward to set up a <code>Makefile</code> to use with GHC, assuming you name your source files the same as your modules. Thus:</p> <pre data-language="makefile">HC      = ghc
HC_OPTS = -cpp $(EXTRA_HC_OPTS)

SRCS = Main.lhs Foo.lhs Bar.lhs
OBJS = Main.o   Foo.o   Bar.o

.SUFFIXES : .o .hs .hi .lhs .hc .s

cool_pgm : $(OBJS)
        rm -f $@
        $(HC) -o $@ $(HC_OPTS) $(OBJS)

# Standard suffix rules
.o.hi:
        @:

.lhs.o:
        $(HC) -c $&lt; $(HC_OPTS)

.hs.o:
        $(HC) -c $&lt; $(HC_OPTS)

.o-boot.hi-boot:
        @:

.lhs-boot.o-boot:
        $(HC) -c $&lt; $(HC_OPTS)

.hs-boot.o-boot:
        $(HC) -c $&lt; $(HC_OPTS)

# Inter-module dependencies
Foo.o Foo.hc Foo.s    : Baz.hi          # Foo imports Baz
Main.o Main.hc Main.s : Foo.hi Baz.hi   # Main imports Foo and Baz
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p>Sophisticated <strong class="command">make</strong> variants may achieve some of the above more elegantly. Notably, <strong class="command">gmake</strong>‘s pattern rules let you write the more comprehensible:</p> <pre data-language="make">%.o : %.lhs
        $(HC) -c $&lt; $(HC_OPTS)
</pre> <p class="last">What we’ve shown should work with any <code>make</code>.</p> </div> <p>Note the cheesy <code>.o.hi</code> rule: It records the dependency of the interface (<code>.hi</code>) file on the source. The rule says a <code>.hi</code> file can be made from a <code>.o</code> file by doing…nothing. Which is true.</p> <p>Note that the suffix rules are all repeated twice, once for normal Haskell source files, and once for <code>hs-boot</code> files (see <a class="reference internal" href="#mutual-recursion"><span class="std std-ref">How to compile mutually recursive modules</span></a>).</p> <p>Note also the inter-module dependencies at the end of the Makefile, which take the form</p> <pre data-language="make">Foo.o Foo.hc Foo.s    : Baz.hi          # Foo imports Baz
</pre> <p>They tell <code>make</code> that if any of <code>Foo.o</code>, <code>Foo.hc</code> or <code>Foo.s</code> have an earlier modification date than <code>Baz.hi</code>, then the out-of-date file must be brought up to date. To bring it up to date, <code>make</code> looks for a rule to do so; one of the preceding suffix rules does the job nicely. These dependencies can be generated automatically by <code>ghc</code>; see <a class="reference internal" href="#makefile-dependencies"><span class="std std-ref">Dependency generation</span></a></p>   <h2 id="makefile-dependencies">8.8.13. Dependency generation</h2> <p id="dependency-generation">Putting inter-dependencies of the form <code>Foo.o : Bar.hi</code> into your <code>Makefile</code> by hand is rather error-prone. Don’t worry, GHC has support for automatically generating the required dependencies. Add the following to your <code>Makefile</code>:</p> <pre data-language="make">depend :
        ghc -dep-suffix '' -M $(HC_OPTS) $(SRCS)
</pre> <p>Now, before you start compiling, and any time you change the <code>imports</code> in your program, do <code>make depend</code> before you do <code>make cool_pgm</code>. The command <code>ghc -M</code> will append the needed dependencies to your <code>Makefile</code>.</p> <p>In general, <code>ghc -M Foo</code> does the following. For each module <code>M</code> in the set <code>Foo</code> plus all its imports (transitively), it adds to the Makefile:</p> <ul> <li>
<p class="first">A line recording the dependence of the object file on the source file.</p> <pre data-language="make">M.o : M.hs
</pre> <p>(or <code>M.lhs</code> if that is the filename you used).</p> </li> <li>
<p class="first">For each import declaration <code>import X</code> in <code>M</code>, a line recording the dependence of <code>M</code> on <code>X</code>:</p> <pre data-language="make">M.o : X.hi
</pre> </li> <li>
<p class="first">For each import declaration <code>import {-# SOURCE #-} X</code> in <code>M</code>, a line recording the dependence of <code>M</code> on <code>X</code>:</p> <pre data-language="make">M.o : X.hi-boot
</pre> <p>(See <a class="reference internal" href="#mutual-recursion"><span class="std std-ref">How to compile mutually recursive modules</span></a> for details of <code>hi-boot</code> style interface files.)</p> </li> </ul> <p>If <code>M</code> imports multiple modules, then there will be multiple lines with <code>M.o</code> as the target.</p> <p>There is no need to list all of the source files as arguments to the <code>ghc -M</code> command; <code>ghc</code> traces the dependencies, just like <code>ghc --make</code> (a new feature in GHC 6.4).</p> <p>Note that <code>ghc -M</code> needs to find a <em>source file</em> for each module in the dependency graph, so that it can parse the import declarations and follow dependencies. Any pre-compiled modules without source files must therefore belong to a package <a class="footnote-reference" href="#id5" id="id4">[1]</a>.</p> <p>By default, <code>ghc -M</code> generates all the dependencies, and then concatenates them onto the end of <code>makefile</code> (or <code>Makefile</code> if <code>makefile</code> doesn’t exist) bracketed by the lines “<code># DO NOT DELETE: Beginning of Haskell dependencies</code>” and “<code># DO NOT DELETE: End of Haskell dependencies</code>”. If these lines already exist in the <code>makefile</code>, then the old dependencies are deleted first.</p> <p>Don’t forget to use the same <code>-package</code> options on the <code>ghc -M</code> command line as you would when compiling; this enables the dependency generator to locate any imported modules that come from packages. The package modules won’t be included in the dependencies generated, though (but see the <code>-include-pkg-deps</code> option below).</p> <p>The dependency generation phase of GHC can take some additional options, which you may find useful. The options which affect dependency generation are:</p> <dl class="ghc-flag"> <dt id="ghc-flag--ddump-mod-cycles">
<code>-ddump-mod-cycles</code> </dt> <dd>
<p>Display a list of the cycles in the module graph. This is useful when trying to eliminate such cycles.</p> </dd>
</dl> <dl class="ghc-flag"> <dt>
<code>-v2</code> </dt> <dd>
<p>Print a full list of the module dependencies to stdout. (This is the standard verbosity flag, so the list will also be displayed with <code>-v3</code> and <code>-v4</code>; see <a class="reference internal" href="using#options-help"><span class="std std-ref">Verbosity options</span></a>.)</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--dep-makefile ⟨file⟩">
<code>-dep-makefile ⟨file⟩</code> </dt> <dd>
<p>Use ⟨file⟩ as the makefile, rather than <code>makefile</code> or <code>Makefile</code>. If ⟨file⟩ doesn’t exist, <code>mkdependHS</code> creates it. We often use <code>-dep-makefile .depend</code> to put the dependencies in <code>.depend</code> and then <code>include</code> the file <code>.depend</code> into <code>Makefile</code>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--dep-suffix ⟨suffix⟩">
<code>-dep-suffix ⟨suffix⟩</code> </dt> <dd>
<p>Make dependencies that declare that files with suffix <code>.⟨suf⟩⟨osuf⟩</code> depend on interface files with suffix <code>.⟨suf⟩hi</code>, or (for <code>{-# SOURCE #-}</code> imports) on <code>.hi-boot</code>. Multiple <code>-dep-suffix</code> flags are permitted. For example, <code>-dep-suffix a_ -dep-suffix b_</code> will make dependencies for <code>.hs</code> on <code>.hi</code>, <code>.a_hs</code> on <code>.a_hi</code>, and <code>.b_hs</code> on <code>.b_hi</code>. Note that you must provide at least one suffix; if you do not want a suffix then pass <code>-dep-suffix ''</code>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag---exclude-module=⟨file⟩">
<code>--exclude-module=⟨file⟩</code> </dt> <dd>
<p>Regard <code>⟨file⟩</code> as “stable”; i.e., exclude it from having dependencies on it.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--include-pkg-deps">
<code>-include-pkg-deps</code> </dt> <dd>
<p>Regard modules imported from packages as unstable, i.e., generate dependencies on any imported package modules (including <code>Prelude</code>, and all other standard Haskell libraries). Dependencies are not traced recursively into packages; dependencies are only generated for home-package modules on external-package modules directly imported by the home package module. This option is normally only used by the various system libraries.</p> </dd>
</dl>   <h2 id="orphan-modules">8.8.14. Orphan modules and instance declarations</h2> <p id="orphan-modules-and-instance-declarations">Haskell specifies that when compiling module <code>M</code>, any instance declaration in any module “below” <code>M</code> is visible. (Module <code>A</code> is “below” <code>M</code> if <code>A</code> is imported directly by <code>M</code>, or if <code>A</code> is below a module that <code>M</code> imports directly.) In principle, GHC must therefore read the interface files of every module below <code>M</code>, just in case they contain an instance declaration that matters to <code>M</code>. This would be a disaster in practice, so GHC tries to be clever.</p> <p>In particular, if an instance declaration is in the same module as the definition of any type or class mentioned in the <em>head</em> of the instance declaration (the part after the “<code>=&gt;</code>”; see <a class="reference internal" href="glasgow_exts#instance-rules"><span class="std std-ref">Relaxed rules for instance contexts</span></a>), then GHC has to visit that interface file anyway. Example:</p> <pre data-language="haskell">module A where
  instance C a =&gt; D (T a) where ...
  data T a = ...
</pre> <p>The instance declaration is only relevant if the type <code>T</code> is in use, and if so, GHC will have visited <code>A</code>‘s interface file to find <code>T</code>‘s definition.</p> <p>The only problem comes when a module contains an instance declaration and GHC has no other reason for visiting the module. Example:</p> <pre data-language="haskell">module Orphan where
  instance C a =&gt; D (T a) where ...
  class C a where ...
</pre> <p>Here, neither <code>D</code> nor <code>T</code> is declared in module <code>Orphan</code>. We call such modules “orphan modules”. GHC identifies orphan modules, and visits the interface file of every orphan module below the module being compiled. This is usually wasted work, but there is no avoiding it. You should therefore do your best to have as few orphan modules as possible.</p> <p>Functional dependencies complicate matters. Suppose we have:</p> <pre data-language="haskell">module B where
  instance E T Int where ...
  data T = ...
</pre> <p>Is this an orphan module? Apparently not, because <code>T</code> is declared in the same module. But suppose class <code>E</code> had a functional dependency:</p> <pre data-language="haskell">module Lib where
  class E x y | y -&gt; x where ...
</pre> <p>Then in some importing module <code>M</code>, the constraint <code>(E a Int)</code> should be “improved” by setting <code>a = T</code>, <em>even though there is no explicit mention</em> of <code>T</code> in <code>M</code>.</p> <p>These considerations lead to the following definition of an orphan module:</p> <ul> <li>An <em>orphan module</em> orphan module contains at least one <em>orphan instance</em> or at least one <em>orphan rule</em>. </li> <li>
<p class="first">An instance declaration in a module <code>M</code> is an <em>orphan instance</em> if orphan instance</p> <ul class="simple"> <li>The class of the instance declaration is not declared in <code>M</code>, and</li> <li>
<em>Either</em> the class has no functional dependencies, and none of the type constructors in the instance head is declared in <code>M</code>; <em>or</em> there is a functional dependency for which none of the type constructors mentioned in the <em>non-determined</em> part of the instance head is defined in <code>M</code>.</li> </ul> <p>Only the instance head counts. In the example above, it is not good enough for <code>C</code>‘s declaration to be in module <code>A</code>; it must be the declaration of <code>D</code> or <code>T</code>.</p> </li> <li>A rewrite rule in a module <code>M</code> is an <em>orphan rule</em> orphan rule if none of the variables, type constructors, or classes that are free in the left hand side of the rule are declared in <code>M</code>. </li> </ul> <p>If you use the flag <a class="reference internal" href="using-warnings#ghc-flag--Worphans"><code>-Worphans</code></a>, GHC will warn you if you are creating an orphan module. Like any warning, you can switch the warning off with <a class="reference internal" href="using-warnings#ghc-flag--Worphans"><code>-Wno-orphans</code></a>, and <a class="reference internal" href="using-warnings#ghc-flag--Werror"><code>-Werror</code></a> will make the compilation fail if the warning is issued.</p> <p>You can identify an orphan module by looking in its interface file, <code>M.hi</code>, using the <a class="reference internal" href="#"><code>--show-iface ⟨file⟩</code></a> <a class="reference internal" href="using#modes"><span class="std std-ref">mode</span></a>. If there is a <code>[orphan module]</code> on the first line, GHC considers it an orphan module.</p> <table class="docutils footnote" frame="void" id="id5" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id4">[1]</a></td>
<td>This is a change in behaviour relative to 6.2 and earlier.</td>
</tr>  </table>   </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2002–2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/users_guide/separate_compilation.html" class="_attribution-link">https://downloads.haskell.org/~ghc/8.8.3/docs/html/users_guide/separate_compilation.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
