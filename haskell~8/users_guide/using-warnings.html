
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>8.2. Warnings and Sanity-checking - Haskell 8 - W3cubDocs</title>
  
  <meta name="description" content="GHC has a number of options that select which types of non-fatal error messages, otherwise known as warnings, can be generated during compilation. &hellip;">
  <meta name="keywords" content="warnings, and, sanity-checking, haskell, haskell~8">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/haskell~8/users_guide/using-warnings.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/haskell~8.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/haskell~8/" class="_nav-link" title="" style="margin-left:0;">Haskell 8</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _haskell">
				
				
<h1 id="options-sanity">8.2. Warnings and sanity-checking</h1>
<div class="_sphinx">   <p id="warnings-and-sanity-checking">GHC has a number of options that select which types of non-fatal error messages, otherwise known as warnings, can be generated during compilation. Some options control individual warnings and others control collections of warnings. To turn off an individual warning <code>-W&lt;wflag&gt;</code>, use <code>-Wno-&lt;wflag&gt;</code>. To reverse``-Werror``, which makes all warnings into errors, use <code>-Wwarn</code>.</p> <p>By default, you get a standard set of warnings which are generally likely to indicate bugs in your program. These are:</p> <table class="hlist"><tr>
<td>
<ul class="simple"> <li><a class="reference internal" href="#ghc-flag--Woverlapping-patterns"><code>-Woverlapping-patterns</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wwarnings-deprecations"><code>-Wwarnings-deprecations</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wdeprecations"><code>-Wdeprecations</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wdeprecated-flags"><code>-Wdeprecated-flags</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wunrecognised-pragmas"><code>-Wunrecognised-pragmas</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wduplicate-exports"><code>-Wduplicate-exports</code></a></li> <li><a class="reference internal" href="#ghc-flag--Woverflowed-literals"><code>-Woverflowed-literals</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wempty-enumerations"><code>-Wempty-enumerations</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wmissing-fields"><code>-Wmissing-fields</code></a></li> </ul> </td>
<td>
<ul class="simple"> <li><a class="reference internal" href="#ghc-flag--Wmissing-methods"><code>-Wmissing-methods</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wwrong-do-bind"><code>-Wwrong-do-bind</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wsimplifiable-class-constraints"><code>-Wsimplifiable-class-constraints</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wtyped-holes"><code>-Wtyped-holes</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wdeferred-type-errors"><code>-Wdeferred-type-errors</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wpartial-type-signatures"><code>-Wpartial-type-signatures</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wunsupported-calling-conventions"><code>-Wunsupported-calling-conventions</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wdodgy-foreign-imports"><code>-Wdodgy-foreign-imports</code></a></li> <li><a class="reference internal" href="#ghc-flag--Winline-rule-shadowing"><code>-Winline-rule-shadowing</code></a></li> </ul> </td>
<td>
<ul class="simple"> <li><a class="reference internal" href="#ghc-flag--Wunsupported-llvm-version"><code>-Wunsupported-llvm-version</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wmissed-extra-shared-lib"><code>-Wmissed-extra-shared-lib</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wtabs"><code>-Wtabs</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wunrecognised-warning-flags"><code>-Wunrecognised-warning-flags</code></a></li> <li><a class="reference internal" href="#ghc-flag--Winaccessible-code"><code>-Winaccessible-code</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wstar-is-type"><code>-Wstar-is-type</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wstar-binder"><code>-Wstar-binder</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wspace-after-bang"><code>-Wspace-after-bang</code></a></li> </ul> </td>
</tr></table> <p>The following flags are simple ways to select standard “packages” of warnings:</p> <dl class="ghc-flag"> <dt id="ghc-flag--W">
<code>-W</code> </dt> <dd>
<p>Provides the standard warnings plus</p> <table class="hlist"><tr>
<td>
<ul class="simple"> <li><a class="reference internal" href="#ghc-flag--Wunused-binds"><code>-Wunused-binds</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wunused-matches"><code>-Wunused-matches</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wunused-foralls"><code>-Wunused-foralls</code></a></li> </ul> </td>
<td>
<ul class="simple"> <li><a class="reference internal" href="#ghc-flag--Wunused-imports"><code>-Wunused-imports</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wincomplete-patterns"><code>-Wincomplete-patterns</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wdodgy-exports"><code>-Wdodgy-exports</code></a></li> </ul> </td>
<td>
<ul class="simple"> <li><a class="reference internal" href="#ghc-flag--Wdodgy-imports"><code>-Wdodgy-imports</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wunbanged-strict-patterns"><code>-Wunbanged-strict-patterns</code></a></li> </ul> </td>
</tr></table> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wall">
<code>-Wall</code> </dt> <dd>
<p>Turns on all warning options that indicate potentially suspicious code. The warnings that are <em>not</em> enabled by <a class="reference internal" href="#ghc-flag--Wall"><code>-Wall</code></a> are</p> <table class="hlist"><tr>
<td>
<ul class="simple"> <li><a class="reference internal" href="#ghc-flag--Wincomplete-uni-patterns"><code>-Wincomplete-uni-patterns</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wincomplete-record-updates"><code>-Wincomplete-record-updates</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wmonomorphism-restriction"><code>-Wmonomorphism-restriction</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wimplicit-prelude"><code>-Wimplicit-prelude</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wmissing-local-signatures"><code>-Wmissing-local-signatures</code></a></li> </ul> </td>
<td>
<ul class="simple"> <li><a class="reference internal" href="#ghc-flag--Wmissing-exported-signatures"><code>-Wmissing-exported-signatures</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wmissing-export-lists"><code>-Wmissing-export-lists</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wmissing-import-lists"><code>-Wmissing-import-lists</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wmissing-home-modules"><code>-Wmissing-home-modules</code></a></li> <li><a class="reference internal" href="#ghc-flag--Widentities"><code>-Widentities</code></a></li> </ul> </td>
<td>
<ul class="simple"> <li><a class="reference internal" href="#ghc-flag--Wredundant-constraints"><code>-Wredundant-constraints</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wpartial-fields"><code>-Wpartial-fields</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wmissed-specialisations"><code>-Wmissed-specialisations</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wall-missed-specialisations"><code>-Wall-missed-specialisations</code></a></li> </ul> </td>
</tr></table> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Weverything">
<code>-Weverything</code> </dt> <dd>
<p>Turns on every single warning supported by the compiler.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wcompat">
<code>-Wcompat</code> </dt> <dd>
<p>Turns on warnings that will be enabled by default in the future, but remain off in normal compilations for the time being. This allows library authors eager to make their code future compatible to adapt to new features before they even generate warnings.</p> <p>This currently enables</p> <table class="hlist"><tr>
<td>
<ul class="simple"> <li><a class="reference internal" href="#ghc-flag--Wmissing-monadfail-instances"><code>-Wmissing-monadfail-instances</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wsemigroup"><code>-Wsemigroup</code></a></li> </ul> </td>
<td>
<ul class="simple"> <li><a class="reference internal" href="#ghc-flag--Wnoncanonical-monoid-instances"><code>-Wnoncanonical-monoid-instances</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wimplicit-kind-vars"><code>-Wimplicit-kind-vars</code></a></li> </ul> </td>
<td>
<ul class="simple"> <li><a class="reference internal" href="#ghc-flag--Wstar-is-type"><code>-Wstar-is-type</code></a></li> </ul> </td>
</tr></table> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wno-compat">
<code>-Wno-compat</code> </dt> <dd>
<p>Disables all warnings enabled by <a class="reference internal" href="#ghc-flag--Wcompat"><code>-Wcompat</code></a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--w">
<code>-w</code> </dt> <dd>
<p>Turns off all warnings, including the standard ones and those that <a class="reference internal" href="#ghc-flag--Wall"><code>-Wall</code></a> doesn’t enable.</p> </dd>
</dl> <p>These options control which warnings are considered fatal and cause compilation to abort.</p> <dl class="ghc-flag"> <dt id="ghc-flag--Werror">
<code>-Werror</code> </dt> <dd>
<p>Makes any warning into a fatal error. Useful so that you don’t miss warnings when doing batch compilation. To reverse <code>-Werror</code> and stop treating any warnings as errors use <code>-Wwarn</code>, or use <code>-Wwarn=&lt;wflag&gt;</code> to stop treating specific warnings as errors.</p> </dd>
</dl> <dl class="ghc-flag"> <dt>
<code>-Werror=⟨wflag⟩</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Implies:</th>
<td class="field-body"><code>-W&lt;wflag&gt;</code></td> </tr>  </table> <p>Makes a specific warning into a fatal error. The warning will be enabled if it hasn’t been enabled yet. Can be reversed with <code>-Wwarn=&lt;wflag&gt;</code>.</p> <p><code>-Werror=compat</code> has the same effect as <code>-Werror=...</code> for each warning flag in the <a class="reference internal" href="#ghc-flag--Wcompat"><code>-Wcompat</code></a> option group.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wwarn">
<code>-Wwarn</code> </dt> <dd>
<p>Warnings are treated only as warnings, not as errors. This is the default, but can be useful to negate a <a class="reference internal" href="#ghc-flag--Werror"><code>-Werror</code></a> flag.</p> </dd>
</dl> <dl class="ghc-flag"> <dt>
<code>-Wwarn=⟨wflag⟩</code> </dt> <dd>
<p>Causes a specific warning to be treated as normal warning, not fatal error.</p> <p>Note that it doesn’t fully negate the effects of <code>-Werror=&lt;wflag&gt;</code> - the warning will still be enabled.</p> <p><code>-Wwarn=compat</code> has the same effect as <code>-Wwarn=...</code> for each warning flag in the <a class="reference internal" href="#ghc-flag--Wcompat"><code>-Wcompat</code></a> option group.</p> </dd>
</dl> <p>When a warning is emitted, the specific warning flag which controls it is shown.</p> <dl class="ghc-flag"> <dt id="ghc-flag--fshow-warning-groups">
<code>-fshow-warning-groups</code> </dt> <dd>
<p>When showing which flag controls a warning, also show the respective warning group flag(s) that warning is contained in.</p> <p>This option is off by default.</p> </dd>
</dl> <p>The full set of warning options is described below. To turn off any warning, simply give the corresponding <code>-Wno-...</code> option on the command line. For backwards compatibility with GHC versions prior to 8.0, all these warnings can still be controlled with <code>-f(no-)warn-*</code> instead of <code>-W(no-)*</code>.</p> <dl class="ghc-flag"> <dt id="ghc-flag--Wunrecognised-warning-flags">
<code>-Wunrecognised-warning-flags</code> </dt> <dd>
<p>Enables warnings when the compiler encounters a <code>-W...</code> flag that is not recognised.</p> <p>This warning is on by default.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wtyped-holes">
<code>-Wtyped-holes</code> </dt> <dd>
<p>Determines whether the compiler reports typed holes warnings. Has no effect unless typed holes errors are deferred until runtime. See <a class="reference internal" href="glasgow_exts#typed-holes"><span class="std std-ref">Typed Holes</span></a> and <a class="reference internal" href="glasgow_exts#defer-type-errors"><span class="std std-ref">Deferring type errors to runtime</span></a></p> <p>This warning is on by default.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wdeferred-type-errors">
<code>-Wdeferred-type-errors</code> </dt> <dd>
<p>Causes a warning to be reported when a type error is deferred until runtime. See <a class="reference internal" href="glasgow_exts#defer-type-errors"><span class="std std-ref">Deferring type errors to runtime</span></a></p> <p>This warning is on by default.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fdefer-type-errors">
<code>-fdefer-type-errors</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Implies:</th>
<td class="field-body">
<a class="reference internal" href="#ghc-flag--fdefer-typed-holes"><code>-fdefer-typed-holes</code></a>, <a class="reference internal" href="#ghc-flag--fdefer-out-of-scope-variables"><code>-fdefer-out-of-scope-variables</code></a>
</td> </tr>  </table> <p>Defer as many type errors as possible until runtime. At compile time you get a warning (instead of an error). At runtime, if you use a value that depends on a type error, you get a runtime error; but you can run any type-correct parts of your code just fine. See <a class="reference internal" href="glasgow_exts#defer-type-errors"><span class="std std-ref">Deferring type errors to runtime</span></a></p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fdefer-typed-holes">
<code>-fdefer-typed-holes</code> </dt> <dd>
<p>Defer typed holes errors (errors about names with a leading underscore (e.g., “_”, “_foo”, “_bar”)) until runtime. This will turn the errors produced by <a class="reference internal" href="glasgow_exts#typed-holes"><span class="std std-ref">typed holes</span></a> into warnings. Using a value that depends on a typed hole produces a runtime error, the same as <a class="reference internal" href="#ghc-flag--fdefer-type-errors"><code>-fdefer-type-errors</code></a> (which implies this option). See <a class="reference internal" href="glasgow_exts#typed-holes"><span class="std std-ref">Typed Holes</span></a> and <a class="reference internal" href="glasgow_exts#defer-type-errors"><span class="std std-ref">Deferring type errors to runtime</span></a>.</p> <p>Implied by <a class="reference internal" href="#ghc-flag--fdefer-type-errors"><code>-fdefer-type-errors</code></a>. See also <a class="reference internal" href="#ghc-flag--Wtyped-holes"><code>-Wtyped-holes</code></a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fdefer-out-of-scope-variables">
<code>-fdefer-out-of-scope-variables</code> </dt> <dd>
<p>Defer variable out-of-scope errors (errors about names without a leading underscore) until runtime. This will turn variable-out-of-scope errors into warnings. Using a value that depends on an out-of-scope variable produces a runtime error, the same as <a class="reference internal" href="#ghc-flag--fdefer-type-errors"><code>-fdefer-type-errors</code></a> (which implies this option). See <a class="reference internal" href="glasgow_exts#typed-holes"><span class="std std-ref">Typed Holes</span></a> and <a class="reference internal" href="glasgow_exts#defer-type-errors"><span class="std std-ref">Deferring type errors to runtime</span></a>.</p> <p>Implied by <a class="reference internal" href="#ghc-flag--fdefer-type-errors"><code>-fdefer-type-errors</code></a>. See also <a class="reference internal" href="#ghc-flag--Wdeferred-out-of-scope-variables"><code>-Wdeferred-out-of-scope-variables</code></a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wdeferred-out-of-scope-variables">
<code>-Wdeferred-out-of-scope-variables</code> </dt> <dd>
<p>Warn when a deferred out-of-scope variable is encountered.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wpartial-type-signatures">
<code>-Wpartial-type-signatures</code> </dt> <dd>
<p>Determines whether the compiler reports holes in partial type signatures as warnings. Has no effect unless <a class="reference internal" href="glasgow_exts#extension-PartialTypeSignatures"><code>-XPartialTypeSignatures</code></a> is enabled, which controls whether errors should be generated for holes in types or not. See <a class="reference internal" href="glasgow_exts#partial-type-signatures"><span class="std std-ref">Partial Type Signatures</span></a>.</p> <p>This warning is on by default.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fhelpful-errors">
<code>-fhelpful-errors</code> </dt> <dd>
<p>When a name or package is not found in scope, make suggestions for the name or package you might have meant instead.</p> <p>This option is on by default.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wunrecognised-pragmas">
<code>-Wunrecognised-pragmas</code> </dt> <dd>
<p>Causes a warning to be emitted when a pragma that GHC doesn’t recognise is used. As well as pragmas that GHC itself uses, GHC also recognises pragmas known to be used by other tools, e.g. <code>OPTIONS_HUGS</code> and <code>DERIVE</code>.</p> <p>This option is on by default.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wmissed-specialisations">
<code>-Wmissed-specialisations</code> </dt> <dd>
<p>Emits a warning if GHC cannot specialise an overloaded function, usually because the function needs an <code>INLINABLE</code> pragma. Reports when the situation arises during specialisation of an imported function.</p> <p>This form is intended to catch cases where an imported function that is marked as <code>INLINABLE</code> (presumably to enable specialisation) cannot be specialised as it calls other functions that are themselves not specialised.</p> <p>Note that this warning will not throw errors if used with <a class="reference internal" href="#ghc-flag--Werror"><code>-Werror</code></a>.</p> <p>This option is off by default.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wall-missed-specialisations">
<code>-Wall-missed-specialisations</code> </dt> <dd>
<p>Emits a warning if GHC cannot specialise an overloaded function, usually because the function needs an <code>INLINABLE</code> pragma. Reports all such situations.</p> <p>Note that this warning will not throw errors if used with <a class="reference internal" href="#ghc-flag--Werror"><code>-Werror</code></a>.</p> <p>This option is off by default.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wwarnings-deprecations">
<code>-Wwarnings-deprecations</code> </dt> <dd>
<p id="index-1">Causes a warning to be emitted when a module, function or type with a <code>WARNING</code> or <code>DEPRECATED pragma</code> is used. See <a class="reference internal" href="glasgow_exts#warning-deprecated-pragma"><span class="std std-ref">WARNING and DEPRECATED pragmas</span></a> for more details on the pragmas.</p> <p>This option is on by default.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wdeprecations">
<code>-Wdeprecations</code> </dt> <dd>
<p id="index-2">Causes a warning to be emitted when a module, function or type with a <code>WARNING</code> or <code>DEPRECATED pragma</code> is used. See <a class="reference internal" href="glasgow_exts#warning-deprecated-pragma"><span class="std std-ref">WARNING and DEPRECATED pragmas</span></a> for more details on the pragmas. An alias for <a class="reference internal" href="#ghc-flag--Wwarnings-deprecations"><code>-Wwarnings-deprecations</code></a>.</p> <p>This option is on by default.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wnoncanonical-monad-instances">
<code>-Wnoncanonical-monad-instances</code> </dt> <dd>
<p>Warn if noncanonical <code>Applicative</code> or <code>Monad</code> instances declarations are detected.</p> <p>When this warning is enabled, the following conditions are verified:</p> <p>In <code>Monad</code> instances declarations warn if any of the following conditions does not hold:</p>  <ul class="simple"> <li>If <code>return</code> is defined it must be canonical (i.e. <code>return = pure</code>).</li> <li>If <code>(&gt;&gt;)</code> is defined it must be canonical (i.e. <code>(&gt;&gt;) = (*&gt;)</code>).</li> </ul>  <p>Moreover, in <code>Applicative</code> instance declarations:</p>  <ul class="simple"> <li>Warn if <code>pure</code> is defined backwards (i.e. <code>pure = return</code>).</li> <li>Warn if <code>(*&gt;)</code> is defined backwards (i.e. <code>(*&gt;) = (&gt;&gt;)</code>).</li> </ul>  <p>This option is off by default.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wnoncanonical-monadfail-instances">
<code>-Wnoncanonical-monadfail-instances</code> </dt> <dd>
<p>Warn if noncanonical <code>Monad</code> or <code>MonadFail</code> instances declarations are detected.</p> <p>When this warning is enabled, the following conditions are verified:</p> <p>In <code>Monad</code> instances declarations warn if any of the following conditions does not hold:</p>  <ul class="simple"> <li>If <code>fail</code> is defined it must be canonical (i.e. <code>fail = Control.Monad.Fail.fail</code>).</li> </ul>  <p>Moreover, in <code>MonadFail</code> instance declarations:</p>  <ul class="simple"> <li>Warn if <code>fail</code> is defined backwards (i.e. <code>fail = Control.Monad.fail</code>).</li> </ul>  <p>See also <a class="reference internal" href="#ghc-flag--Wmissing-monadfail-instances"><code>-Wmissing-monadfail-instances</code></a>.</p> <p>This option is off by default.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wnoncanonical-monoid-instances">
<code>-Wnoncanonical-monoid-instances</code> </dt> <dd>
<p>Warn if noncanonical <code>Semigroup</code> or <code>Monoid</code> instances declarations are detected.</p> <p>When this warning is enabled, the following conditions are verified:</p> <p>In <code>Monoid</code> instances declarations warn if any of the following conditions does not hold:</p>  <ul class="simple"> <li>If <code>mappend</code> is defined it must be canonical (i.e. <code>mappend = (Data.Semigroup.&lt;&gt;)</code>).</li> </ul>  <p>Moreover, in <code>Semigroup</code> instance declarations:</p>  <ul class="simple"> <li>Warn if <code>(&lt;&gt;)</code> is defined backwards (i.e. <code>(&lt;&gt;) = mappend</code>).</li> </ul>  <p>This warning is off by default. However, it is part of the <a class="reference internal" href="#ghc-flag--Wcompat"><code>-Wcompat</code></a> option group.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wmissing-monadfail-instances">
<code>-Wmissing-monadfail-instances</code> </dt> <dd>
<p id="index-3">Warn when a failable pattern is used in a do-block that does not have a <code>MonadFail</code> instance.</p> <p>See also <a class="reference internal" href="#ghc-flag--Wnoncanonical-monadfail-instances"><code>-Wnoncanonical-monadfail-instances</code></a>.</p> <p>Being part of the <a class="reference internal" href="#ghc-flag--Wcompat"><code>-Wcompat</code></a> option group, this warning is off by default, but will be switched on in a future GHC release, as part of the <a class="reference external" href="https://prime.haskell.org/wiki/Libraries/Proposals/MonadFail">MonadFail Proposal (MFP)</a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wsemigroup">
<code>-Wsemigroup</code> </dt> <dd>
<p id="index-4">Warn when definitions are in conflict with the future inclusion of <code>Semigroup</code> into the standard typeclasses.</p>  <ol class="arabic simple"> <li>Instances of <code>Monoid</code> should also be instances of <code>Semigroup</code>
</li> <li>The <code>Semigroup</code> operator <code>(&lt;&gt;)</code> will be in <code>Prelude</code>, which clashes with custom local definitions of such an operator</li> </ol>  <p>Being part of the <a class="reference internal" href="#ghc-flag--Wcompat"><code>-Wcompat</code></a> option group, this warning is off by default, but will be switched on in a future GHC release.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wdeprecated-flags">
<code>-Wdeprecated-flags</code> </dt> <dd>
<p id="index-5">Causes a warning to be emitted when a deprecated command-line flag is used.</p> <p>This option is on by default.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wunsupported-calling-conventions">
<code>-Wunsupported-calling-conventions</code> </dt> <dd>
<p>Causes a warning to be emitted for foreign declarations that use unsupported calling conventions. In particular, if the <code>stdcall</code> calling convention is used on an architecture other than i386 then it will be treated as <code>ccall</code>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wdodgy-foreign-imports">
<code>-Wdodgy-foreign-imports</code> </dt> <dd>
<p>Causes a warning to be emitted for foreign imports of the following form:</p> <pre data-language="haskell">foreign import "f" f :: FunPtr t
</pre> <p>on the grounds that it probably should be</p> <pre data-language="haskell">foreign import "&amp;f" f :: FunPtr t
</pre> <p>The first form declares that <code>f</code> is a (pure) C function that takes no arguments and returns a pointer to a C function with type <code>t</code>, whereas the second form declares that <code>f</code> itself is a C function with type <code>t</code>. The first declaration is usually a mistake, and one that is hard to debug because it results in a crash, hence this warning.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wdodgy-exports">
<code>-Wdodgy-exports</code> </dt> <dd>
<p>Causes a warning to be emitted when a datatype <code>T</code> is exported with all constructors, i.e. <code>T(..)</code>, but is it just a type synonym.</p> <p>Also causes a warning to be emitted when a module is re-exported, but that module exports nothing.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wdodgy-imports">
<code>-Wdodgy-imports</code> </dt> <dd>
<p>Causes a warning to be emitted in the following cases:</p> <ul class="simple"> <li>When a datatype <code>T</code> is imported with all constructors, i.e. <code>T(..)</code>, but has been exported abstractly, i.e. <code>T</code>.</li> <li>When an <code>import</code> statement hides an entity that is not exported.</li> </ul> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Woverflowed-literals">
<code>-Woverflowed-literals</code> </dt> <dd>
<p>Causes a warning to be emitted if a literal will overflow, e.g. <code>300 :: Word8</code>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wempty-enumerations">
<code>-Wempty-enumerations</code> </dt> <dd>
<p>Causes a warning to be emitted if an enumeration is empty, e.g. <code>[5 .. 3]</code>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wduplicate-constraints">
<code>-Wduplicate-constraints</code> </dt> <dd>
<p id="index-6">Have the compiler warn about duplicate constraints in a type signature. For example</p> <pre data-language="haskell">f :: (Eq a, Show a, Eq a) =&gt; a -&gt; a
</pre> <p>The warning will indicate the duplicated <code>Eq a</code> constraint.</p> <p>This option is now deprecated in favour of <a class="reference internal" href="#ghc-flag--Wredundant-constraints"><code>-Wredundant-constraints</code></a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wredundant-constraints">
<code>-Wredundant-constraints</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0</td> </tr>  </table> <p id="index-7">Have the compiler warn about redundant constraints in a type signature. In particular:</p> <ul> <li>
<p class="first">A redundant constraint within the type signature itself:</p> <pre data-language="haskell">f :: (Eq a, Ord a) =&gt; a -&gt; a
</pre> <p>The warning will indicate the redundant <code>Eq a</code> constraint: it is subsumed by the <code>Ord a</code> constraint.</p> </li> <li>
<p class="first">A constraint in the type signature is not used in the code it covers:</p> <pre data-language="haskell">f :: Eq a =&gt; a -&gt; a -&gt; Bool
f x y = True
</pre> <p>The warning will indicate the redundant <code>Eq a</code> constraint: : it is not used by the definition of <code>f</code>.)</p> </li> </ul> <p>Similar warnings are given for a redundant constraint in an instance declaration.</p> <p>When turning on, you can suppress it on a per-module basis with <a class="reference internal" href="#ghc-flag--Wredundant-constraints"><code>-Wno-redundant-constraints</code></a>. Occasionally you may specifically want a function to have a more constrained signature than necessary, perhaps to leave yourself wiggle-room for changing the implementation without changing the API. In that case, you can suppress the warning on a per-function basis, using a call in a dead binding. For example:</p> <pre data-language="haskell">f :: Eq a =&gt; a -&gt; a -&gt; Bool
f x y = True
where
    _ = x == x  -- Suppress the redundant-constraint warning for (Eq a)
</pre> <p>Here the call to <code>(==)</code> makes GHC think that the <code>(Eq a)</code> constraint is needed, so no warning is issued.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wduplicate-exports">
<code>-Wduplicate-exports</code> </dt> <dd>
<p id="index-8">Have the compiler warn about duplicate entries in export lists. This is useful information if you maintain large export lists, and want to avoid the continued export of a definition after you’ve deleted (one) mention of it in the export list.</p> <p>This option is on by default.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Whi-shadowing">
<code>-Whi-shadowing</code> </dt> <dd>
<p id="index-9">Causes the compiler to emit a warning when a module or interface file in the current directory is shadowing one with the same module name in a library or other directory.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Widentities">
<code>-Widentities</code> </dt> <dd>
<p>Causes the compiler to emit a warning when a Prelude numeric conversion converts a type <code>T</code> to the same type <code>T</code>; such calls are probably no-ops and can be omitted. The functions checked for are: <code>toInteger</code>, <code>toRational</code>, <code>fromIntegral</code>, and <code>realToFrac</code>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wimplicit-prelude">
<code>-Wimplicit-prelude</code> </dt> <dd>
<p id="index-10">Have the compiler warn if the Prelude is implicitly imported. This happens unless either the Prelude module is explicitly imported with an <code>import
... Prelude ...</code> line, or this implicit import is disabled (either by <a class="reference internal" href="glasgow_exts#extension-NoImplicitPrelude"><code>-XNoImplicitPrelude</code></a> or a <code>LANGUAGE NoImplicitPrelude</code> pragma).</p> <p>Note that no warning is given for syntax that implicitly refers to the Prelude, even if <a class="reference internal" href="glasgow_exts#extension-NoImplicitPrelude"><code>-XNoImplicitPrelude</code></a> would change whether it refers to the Prelude. For example, no warning is given when <code>368</code> means <code>Prelude.fromInteger (368::Prelude.Integer)</code> (where <code>Prelude</code> refers to the actual Prelude module, regardless of the imports of the module being compiled).</p> <p>This warning is off by default.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wimplicit-kind-vars">
<code>-Wimplicit-kind-vars</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.6</td> </tr>  </table> <p><a class="reference external" href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0024-no-kind-vars.rst">GHC proposal #24</a> prescribes to treat kind variables and type variables identically in <code>forall</code>, removing the legacy distinction between them.</p> <p>Consider the following examples:</p> <pre data-language="haskell">f :: Proxy a -&gt; Proxy b -&gt; ()
g :: forall a b. Proxy a -&gt; Proxy b -&gt; ()
</pre> <p><code>f</code> does not use an explicit <code>forall</code>, so type variables <code>a</code> and <code>b</code> are brought into scope implicitly. <code>g</code> quantifies both <code>a</code> and <code>b</code> explicitly. Both <code>f</code> and <code>g</code> work today and will continue to work in the future because they adhere to the “forall-or-nothing” rule: either all type variables in a function definition are introduced explicitly or implicitly, there is no middle ground.</p> <p>A violation of the “forall-or-nothing” rule looks like this:</p> <pre data-language="haskell">m :: forall a. Proxy a -&gt; Proxy b -&gt; ()
</pre> <p><code>m</code> does not introduce one of the variables, <code>b</code>, and thus is rejected.</p> <p>However, consider the following example:</p> <pre data-language="haskell">n :: forall a. Proxy (a :: k) -&gt; ()
</pre> <p>While <code>n</code> uses <code>k</code> without introducing it and thus violates the rule, it is currently accepted. This is because <code>k</code> in <code>n</code> is considered a kind variable, as it occurs in a kind signature. In reality, the line between type variables and kind variables is blurry, as the following example demonstrates:</p> <pre data-language="haskell">kindOf :: forall a. Proxy (a :: k) -&gt; Proxy k
</pre> <p>In <code>kindOf</code>, the <code>k</code> variable is used both in a kind position and a type position. Currently, <code>kindOf</code> happens to be accepted as well.</p> <p>In a future release of GHC, both <code>n</code> and <code>kindOf</code> will be rejected per the “forall-or-nothing” rule. This warning, being part of the <a class="reference internal" href="#ghc-flag--Wcompat"><code>-Wcompat</code></a> option group, allows to detect this before the actual breaking change takes place.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wincomplete-patterns">
<code>-Wincomplete-patterns</code> </dt> <dd>
<p id="index-11">The option <a class="reference internal" href="#ghc-flag--Wincomplete-patterns"><code>-Wincomplete-patterns</code></a> warns about places where a pattern-match might fail at runtime. The function <code>g</code> below will fail when applied to non-empty lists, so the compiler will emit a warning about this when <a class="reference internal" href="#ghc-flag--Wincomplete-patterns"><code>-Wincomplete-patterns</code></a> is enabled.</p> <pre data-language="haskell">g [] = 2
</pre> <p>This option isn’t enabled by default because it can be a bit noisy, and it doesn’t always indicate a bug in the program. However, it’s generally considered good practice to cover all the cases in your functions, and it is switched on by <a class="reference internal" href="#ghc-flag--W"><code>-W</code></a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wincomplete-uni-patterns">
<code>-Wincomplete-uni-patterns</code> </dt> <dd>
<p>The flag <a class="reference internal" href="#ghc-flag--Wincomplete-uni-patterns"><code>-Wincomplete-uni-patterns</code></a> is similar to <a class="reference internal" href="#ghc-flag--Wincomplete-patterns"><code>-Wincomplete-patterns</code></a>, except that it applies only to lambda-expressions and pattern bindings, constructs that only allow a single pattern:</p> <pre data-language="haskell">h = \[] -&gt; 2
Just k = f y
</pre> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fmax-pmcheck-iterations=⟨n⟩">
<code>-fmax-pmcheck-iterations=⟨n⟩</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">2000000</td> </tr>  </table> <p>Sets how many iterations of the pattern-match checker will perform before giving up. This limit is to catch cases where pattern-match checking might be excessively costly (due to the exponential complexity of coverage checking in the general case). It typically shouldn’t be necessary to set this unless GHC informs you that it has exceeded the pattern match checker’s iteration limit (in which case you may want to consider refactoring your pattern match, for the sake of future readers of your code.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wincomplete-record-updates">
<code>-Wincomplete-record-updates</code> </dt> <dd>
<p id="index-12">The function <code>f</code> below will fail when applied to <code>Bar</code>, so the compiler will emit a warning about this when <a class="reference internal" href="#ghc-flag--Wincomplete-record-updates"><code>-Wincomplete-record-updates</code></a> is enabled.</p> <pre data-language="haskell">data Foo = Foo { x :: Int }
         | Bar

f :: Foo -&gt; Foo
f foo = foo { x = 6 }
</pre> <p>This option isn’t enabled by default because it can be very noisy, and it often doesn’t indicate a bug in the program.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wmissing-deriving-strategies">
<code>-Wmissing-deriving-strategies</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.8.1</td> </tr>  </table> <p>The datatype below derives the <code>Eq</code> typeclass, but doesn’t specify a strategy. When <a class="reference internal" href="#ghc-flag--Wmissing-deriving-strategies"><code>-Wmissing-deriving-strategies</code></a> is enabled, the compiler will emit a warning about this.</p> <pre data-language="haskell">data Foo a = Foo a
  deriving (Eq)
</pre> <p>The compiler will warn here that the deriving clause doesn’t specify a strategy. If the warning is enabled, but <a class="reference internal" href="glasgow_exts#extension-DerivingStrategies"><code>DerivingStrategies</code></a> is not enabled, the compiler will suggest turning on the <a class="reference internal" href="glasgow_exts#extension-DerivingStrategies"><code>DerivingStrategies</code></a> extension. This option is not on by default, having to be turned on manually or with <a class="reference internal" href="#ghc-flag--Weverything"><code>-Weverything</code></a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wmissing-fields">
<code>-Wmissing-fields</code> </dt> <dd>
<p id="index-13">This option is on by default, and warns you whenever the construction of a labelled field constructor isn’t complete, missing initialisers for one or more fields. While not an error (the missing fields are initialised with bottoms), it is often an indication of a programmer error.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wmissing-export-lists">
<code>-Wmissing-export-lists</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.4.1</td> </tr>  </table> <p id="index-14">This flag warns if you declare a module without declaring an explicit export list. For example</p> <pre data-language="haskell">module M where

  p x = x
</pre> <p>The <a class="reference internal" href="#ghc-flag--Wmissing-export-lists"><code>-Wmissing-export-lists</code></a> flag will warn that <code>M</code> does not declare an export list. Declaring an explicit export list for <code>M</code> enables GHC dead code analysis, prevents accidental export of names and can ease optimizations like inlining.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wmissing-import-lists">
<code>-Wmissing-import-lists</code> </dt> <dd>
<p id="index-15">This flag warns if you use an unqualified <code>import</code> declaration that does not explicitly list the entities brought into scope. For example</p> <pre data-language="haskell">module M where
  import X( f )
  import Y
  import qualified Z
  p x = f x x
</pre> <p>The <a class="reference internal" href="#ghc-flag--Wmissing-import-lists"><code>-Wmissing-import-lists</code></a> flag will warn about the import of <code>Y</code> but not <code>X</code> If module <code>Y</code> is later changed to export (say) <code>f</code>, then the reference to <code>f</code> in <code>M</code> will become ambiguous. No warning is produced for the import of <code>Z</code> because extending <code>Z</code>‘s exports would be unlikely to produce ambiguity in <code>M</code>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wmissing-methods">
<code>-Wmissing-methods</code> </dt> <dd>
<p id="index-16">This option is on by default, and warns you whenever an instance declaration is missing one or more methods, and the corresponding class declaration has no default declaration for them.</p> <p>The <code>MINIMAL</code> pragma can be used to change which combination of methods will be required for instances of a particular class. See <a class="reference internal" href="glasgow_exts#minimal-pragma"><span class="std std-ref">MINIMAL pragma</span></a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wmissing-signatures">
<code>-Wmissing-signatures</code> </dt> <dd>
<p id="index-17">If you would like GHC to check that every top-level function/value has a type signature, use the <a class="reference internal" href="#ghc-flag--Wmissing-signatures"><code>-Wmissing-signatures</code></a> option. As part of the warning GHC also reports the inferred type. The option is off by default.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wmissing-exported-sigs">
<code>-Wmissing-exported-sigs</code> </dt> <dd>
<p id="index-18">This option is now deprecated in favour of <a class="reference internal" href="#ghc-flag--Wmissing-exported-signatures"><code>-Wmissing-exported-signatures</code></a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wmissing-exported-signatures">
<code>-Wmissing-exported-signatures</code> </dt> <dd>
<p id="index-19">If you would like GHC to check that every exported top-level function/value has a type signature, but not check unexported values, use the <a class="reference internal" href="#ghc-flag--Wmissing-exported-signatures"><code>-Wmissing-exported-signatures</code></a> option. This option takes precedence over <a class="reference internal" href="#ghc-flag--Wmissing-signatures"><code>-Wmissing-signatures</code></a>. As part of the warning GHC also reports the inferred type. The option is off by default.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wmissing-local-sigs">
<code>-Wmissing-local-sigs</code> </dt> <dd>
<p id="index-20">This option is now deprecated in favour of <a class="reference internal" href="#ghc-flag--Wmissing-local-signatures"><code>-Wmissing-local-signatures</code></a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wmissing-local-signatures">
<code>-Wmissing-local-signatures</code> </dt> <dd>
<p id="index-21">If you use the <a class="reference internal" href="#ghc-flag--Wmissing-local-signatures"><code>-Wmissing-local-signatures</code></a> flag GHC will warn you about any polymorphic local bindings. As part of the warning GHC also reports the inferred type. The option is off by default.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wmissing-pattern-synonym-signatures">
<code>-Wmissing-pattern-synonym-signatures</code> </dt> <dd>
<p id="index-22">If you would like GHC to check that every pattern synonym has a type signature, use the <a class="reference internal" href="#ghc-flag--Wmissing-pattern-synonym-signatures"><code>-Wmissing-pattern-synonym-signatures</code></a> option. If this option is used in conjunction with <a class="reference internal" href="#ghc-flag--Wmissing-exported-signatures"><code>-Wmissing-exported-signatures</code></a> then only exported pattern synonyms must have a type signature. GHC also reports the inferred type. This option is off by default.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wname-shadowing">
<code>-Wname-shadowing</code> </dt> <dd>
<p id="index-23">This option causes a warning to be emitted whenever an inner-scope value has the same name as an outer-scope value, i.e. the inner value shadows the outer one. This can catch typographical errors that turn into hard-to-find bugs, e.g., in the inadvertent capture of what would be a recursive call in <code>f = ... let f = id in ... f ...</code>.</p> <p>The warning is suppressed for names beginning with an underscore. For example</p> <pre data-language="haskell">f x = do { _ignore &lt;- this; _ignore &lt;- that; return (the other) }
</pre> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Worphans">
<code>-Worphans</code> </dt> <dd>
<p id="index-24">These flags cause a warning to be emitted whenever the module contains an “orphan” instance declaration or rewrite rule. An instance declaration is an orphan if it appears in a module in which neither the class nor the type being instanced are declared in the same module. A rule is an orphan if it is a rule for a function declared in another module. A module containing any orphans is called an orphan module.</p> <p>The trouble with orphans is that GHC must pro-actively read the interface files for all orphan modules, just in case their instances or rules play a role, whether or not the module’s interface would otherwise be of any use. See <a class="reference internal" href="separate_compilation#orphan-modules"><span class="std std-ref">Orphan modules and instance declarations</span></a> for details.</p> <p>The flag <a class="reference internal" href="#ghc-flag--Worphans"><code>-Worphans</code></a> warns about user-written orphan rules or instances.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Woverlapping-patterns">
<code>-Woverlapping-patterns</code> </dt> <dd>
<p id="index-25">By default, the compiler will warn you if a set of patterns are overlapping, e.g.,</p> <pre data-language="haskell">f :: String -&gt; Int
f []     = 0
f (_:xs) = 1
f "2"    = 2
</pre> <p>where the last pattern match in <code>f</code> won’t ever be reached, as the second pattern overlaps it. More often than not, redundant patterns is a programmer mistake/error, so this option is enabled by default.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Winaccessible-code">
<code>-Winaccessible-code</code> </dt> <dd>
<p id="index-26">By default, the compiler will warn you if types make a branch inaccessible. This generally requires GADTs or similar extensions.</p> <p>Take, for example, the following program</p> <pre data-language="haskell">{-# LANGUAGE GADTs #-}

data Foo a where
 Foo1 :: Foo Char
 Foo2 :: Foo Int

data TyEquality a b where
        Refl :: TyEquality a a

checkTEQ :: Foo t -&gt; Foo u -&gt; Maybe (TyEquality t u)
checkTEQ x y = error "unimportant"

step2 :: Bool
step2 = case checkTEQ Foo1 Foo2 of
         Just Refl -&gt; True -- Inaccessible code
         Nothing -&gt; False
</pre> <p>The <code>Just Refl</code> case in <code>step2</code> is inaccessible, because in order for <code>checkTEQ</code> to be able to produce a <code>Just</code>, <code>t ~ u</code> must hold, but since we’re passing <code>Foo1</code> and <code>Foo2</code> here, it follows that <code>t ~
Char</code>, and <code>u ~ Int</code>, and thus <code>t ~ u</code> cannot hold.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wstar-is-type">
<code>-Wstar-is-type</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.6</td> </tr>  </table> <p>The use of <code>*</code> to denote the kind of inhabited types relies on the <a class="reference internal" href="glasgow_exts#extension-StarIsType"><code>StarIsType</code></a> extension, which in a future release will be turned off by default and then possibly removed. The reasons for this and the deprecation schedule are described in <a class="reference external" href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0030-remove-star-kind.rst">GHC proposal #30</a>.</p> <p>This warning allows to detect such uses of <code>*</code> before the actual breaking change takes place. The recommended fix is to replace <code>*</code> with <code>Type</code> imported from <code>Data.Kind</code>.</p> <p>Being part of the <a class="reference internal" href="#ghc-flag--Wcompat"><code>-Wcompat</code></a> option group, this warning is off by default, but will be switched on in a future GHC release.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wstar-binder">
<code>-Wstar-binder</code> </dt> <dd>
<p>Under <a class="reference internal" href="glasgow_exts#extension-StarIsType"><code>-XStarIsType</code></a>, a <code>*</code> in types is not an operator nor even a name, it is special syntax that stands for <code>Data.Kind.Type</code>. This means that an expression like <code>Either * Char</code> is parsed as <code>Either (*)
Char</code> and not <code>(*) Either Char</code>.</p> <p>In binding positions, we have similar parsing rules. Consider the following example</p> <pre data-language="haskell">{-# LANGUAGE TypeOperators, TypeFamilies, StarIsType #-}

type family a + b
type family a * b
</pre> <p>While <code>a + b</code> is parsed as <code>(+) a b</code> and becomes a binding position for the <code>(+)</code> type operator, <code>a * b</code> is parsed as <code>a (*) b</code> and is rejected.</p> <p>As a workaround, we allow to bind <code>(*)</code> in prefix form:</p> <pre data-language="haskell">type family (*) a b
</pre> <p>This is a rather fragile arrangement, as generally a programmer expects <code>(*) a b</code> to be equivalent to <code>a * b</code>. With <a class="reference internal" href="#ghc-flag--Wstar-binder"><code>-Wstar-binder</code></a> we warn when this special treatment of <code>(*)</code> takes place.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wsimplifiable-class-constraints">
<code>-Wsimplifiable-class-constraints</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.2</td> </tr>  </table> <p id="index-27">Warn about class constraints in a type signature that can be simplified using a top-level instance declaration. For example:</p> <pre data-language="haskell">f :: Eq [a] =&gt; a -&gt; a
</pre> <p>Here the <code>Eq [a]</code> in the signature overlaps with the top-level instance for <code>Eq [a]</code>. GHC goes to some efforts to use the former, but if it should use the latter, it would then have an insoluble <code>Eq a</code> constraint. Best avoided by instead writing:</p> <pre data-language="haskell">f :: Eq a =&gt; a -&gt; a
</pre> <p>This option is on by default. As usual you can suppress it on a per-module basis with <a class="reference internal" href="#ghc-flag--Wsimplifiable-class-constraints"><code>-Wno-simplifiable-class-constraints</code></a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wspace-after-bang">
<code>-Wspace-after-bang</code> </dt> 
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wtabs">
<code>-Wtabs</code> </dt> <dd>
<p id="index-28">Have the compiler warn if there are tabs in your source file.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wtype-defaults">
<code>-Wtype-defaults</code> </dt> <dd>
<p id="index-29">Have the compiler warn/inform you where in your source the Haskell defaulting mechanism for numeric types kicks in. This is useful information when converting code from a context that assumed one default into one with another, e.g., the ‘default default’ for Haskell 1.4 caused the otherwise unconstrained value <code>1</code> to be given the type <code>Int</code>, whereas Haskell 98 and later defaults it to <code>Integer</code>. This may lead to differences in performance and behaviour, hence the usefulness of being non-silent about this.</p> <p>This warning is off by default.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wmonomorphism-restriction">
<code>-Wmonomorphism-restriction</code> </dt> <dd>
<p id="index-30">Have the compiler warn/inform you where in your source the Haskell Monomorphism Restriction is applied. If applied silently the MR can give rise to unexpected behaviour, so it can be helpful to have an explicit warning that it is being applied.</p> <p>This warning is off by default.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wunsupported-llvm-version">
<code>-Wunsupported-llvm-version</code> </dt> <dd>
<p>Warn when using <a class="reference internal" href="phases#ghc-flag--fllvm"><code>-fllvm</code></a> with an unsupported version of LLVM.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wmissed-extra-shared-lib">
<code>-Wmissed-extra-shared-lib</code> </dt> <dd>
<p>Warn when GHCi can’t load a shared lib it deduced it should load when loading a package and analyzing the extra-libraries stanza of the target package description.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wunticked-promoted-constructors">
<code>-Wunticked-promoted-constructors</code> </dt> <dd>
<p id="index-31">Warn if a promoted data constructor is used without a tick preceding its name.</p> <p>For example:</p> <pre data-language="haskell">data Nat = Succ Nat | Zero

data Vec n s where
  Nil  :: Vec Zero a
  Cons :: a -&gt; Vec n a -&gt; Vec (Succ n) a
</pre> <p>Will raise two warnings because <code>Zero</code> and <code>Succ</code> are not written as <code>'Zero</code> and <code>'Succ</code>.</p> <p>This warning is enabled by default in <a class="reference internal" href="#ghc-flag--Wall"><code>-Wall</code></a> mode.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wunused-binds">
<code>-Wunused-binds</code> </dt> <dd>
<p id="index-32">Report any function definitions (and local bindings) which are unused. An alias for</p> <ul class="simple"> <li><a class="reference internal" href="#ghc-flag--Wunused-top-binds"><code>-Wunused-top-binds</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wunused-local-binds"><code>-Wunused-local-binds</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wunused-pattern-binds"><code>-Wunused-pattern-binds</code></a></li> </ul> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wunused-top-binds">
<code>-Wunused-top-binds</code> </dt> <dd>
<p id="index-33">Report any function definitions which are unused.</p> <p>More precisely, warn if a binding brings into scope a variable that is not used, except if the variable’s name starts with an underscore. The “starts-with-underscore” condition provides a way to selectively disable the warning.</p> <p>A variable is regarded as “used” if</p> <ul class="simple"> <li>It is exported, or</li> <li>It appears in the right hand side of a binding that binds at least one used variable that is used</li> </ul> <p>For example:</p> <pre data-language="haskell">module A (f) where
f = let (p,q) = rhs1 in t p  -- No warning: q is unused, but is locally bound
t = rhs3                     -- No warning: f is used, and hence so is t
g = h x                      -- Warning: g unused
h = rhs2                     -- Warning: h is only used in the
                             -- right-hand side of another unused binding
_w = True                    -- No warning: _w starts with an underscore
</pre> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wunused-local-binds">
<code>-Wunused-local-binds</code> </dt> <dd>
<p id="index-34">Report any local definitions which are unused. For example:</p> <pre data-language="haskell">module A (f) where
f = let (p,q) = rhs1 in t p  -- Warning: q is unused
g = h x                      -- No warning: g is unused, but is a top-level binding
</pre> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wunused-pattern-binds">
<code>-Wunused-pattern-binds</code> </dt> <dd>
<p id="index-35">Warn if a pattern binding binds no variables at all, unless it is a lone wild-card pattern, or a banged pattern. For example:</p> <pre data-language="haskell">Just _ = rhs3    -- Warning: unused pattern binding
(_, _) = rhs4    -- Warning: unused pattern binding
_  = rhs3        -- No warning: lone wild-card pattern
!() = rhs4       -- No warning: banged pattern; behaves like seq
</pre> <p>In general a lazy pattern binding <code>p = e</code> is a no-op if <code>p</code> does not bind any variables. The motivation for allowing lone wild-card patterns is they are not very different from <code>_v = rhs3</code>, which elicits no warning; and they can be useful to add a type constraint, e.g. <code>_ = x::Int</code>. A banged pattern (see <a class="reference internal" href="glasgow_exts#bang-patterns"><span class="std std-ref">Bang patterns and Strict Haskell</span></a>) is <em>not</em> a no-op, because it forces evaluation, and is useful as an alternative to <code>seq</code>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wunused-imports">
<code>-Wunused-imports</code> </dt> <dd>
<p id="index-36">Report any modules that are explicitly imported but never used. However, the form <code>import M()</code> is never reported as an unused import, because it is a useful idiom for importing instance declarations, which are anonymous in Haskell.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wunused-matches">
<code>-Wunused-matches</code> </dt> <dd>
<p id="index-37">Report all unused variables which arise from term-level pattern matches, including patterns consisting of a single variable. For instance <code>f x y = []</code> would report <code>x</code> and <code>y</code> as unused. The warning is suppressed if the variable name begins with an underscore, thus:</p> <pre data-language="haskell">f _x = True
</pre> <p>Note that <a class="reference internal" href="#ghc-flag--Wunused-matches"><code>-Wunused-matches</code></a> does not warn about variables which arise from type-level patterns, as found in type family and data family instances. This must be enabled separately through the <a class="reference internal" href="#ghc-flag--Wunused-type-patterns"><code>-Wunused-type-patterns</code></a> flag.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wunused-do-bind">
<code>-Wunused-do-bind</code> </dt> <dd>
<p id="index-38">Report expressions occurring in <code>do</code> and <code>mdo</code> blocks that appear to silently throw information away. For instance <code>do { mapM popInt xs ; return 10 }</code> would report the first statement in the <code>do</code> block as suspicious, as it has the type <code>StackM [Int]</code> and not <code>StackM ()</code>, but that <code>[Int]</code> value is not bound to anything. The warning is suppressed by explicitly mentioning in the source code that your program is throwing something away:</p> <pre data-language="haskell">do { _ &lt;- mapM popInt xs ; return 10 }
</pre> <p>Of course, in this particular situation you can do even better:</p> <pre data-language="haskell">do { mapM_ popInt xs ; return 10 }
</pre> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wunused-type-patterns">
<code>-Wunused-type-patterns</code> </dt> <dd>
<p id="index-39">Report all unused implicitly bound type variables which arise from patterns in type family and data family instances. For instance:</p> <pre data-language="haskell">type instance F x y = []
</pre> <p>would report <code>x</code> and <code>y</code> as unused on the right hand side. The warning is suppressed if the type variable name begins with an underscore, like so:</p> <pre data-language="haskell">type instance F _x _y = []
</pre> <p>When <a class="reference internal" href="glasgow_exts#extension-ExplicitForAll"><code>ExplicitForAll</code></a> is enabled, explicitly quantified type variables may also be identified as unused. For instance:</p> <pre data-language="haskell">type instance forall x y. F x y = []
</pre> <p>would still report <code>x</code> and <code>y</code> as unused on the right hand side</p> <p>Unlike <a class="reference internal" href="#ghc-flag--Wunused-matches"><code>-Wunused-matches</code></a>, <a class="reference internal" href="#ghc-flag--Wunused-type-patterns"><code>-Wunused-type-patterns</code></a> is not implied by <a class="reference internal" href="#ghc-flag--Wall"><code>-Wall</code></a>. The rationale for this decision is that unlike term-level pattern names, type names are often chosen expressly for documentation purposes, so using underscores in type names can make the documentation harder to read.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wunused-foralls">
<code>-Wunused-foralls</code> </dt> <dd>
<p id="index-40">Report all unused type variables which arise from explicit, user-written <code>forall</code> statements. For instance:</p> <pre data-language="haskell">g :: forall a b c. (b -&gt; b)
</pre> <p>would report <code>a</code> and <code>c</code> as unused.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wwrong-do-bind">
<code>-Wwrong-do-bind</code> </dt> <dd>
<p id="index-41">Report expressions occurring in <code>do</code> and <code>mdo</code> blocks that appear to lack a binding. For instance <code>do { return (popInt 10) ; return 10 }</code> would report the first statement in the <code>do</code> block as suspicious, as it has the type <code>StackM (StackM Int)</code> (which consists of two nested applications of the same monad constructor), but which is not then “unpacked” by binding the result. The warning is suppressed by explicitly mentioning in the source code that your program is throwing something away:</p> <pre data-language="haskell">do { _ &lt;- return (popInt 10) ; return 10 }
</pre> <p>For almost all sensible programs this will indicate a bug, and you probably intended to write:</p> <pre data-language="haskell">do { popInt 10 ; return 10 }
</pre> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Winline-rule-shadowing">
<code>-Winline-rule-shadowing</code> </dt> <dd>
<p>Warn if a rewrite RULE might fail to fire because the function might be inlined before the rule has a chance to fire. See <a class="reference internal" href="glasgow_exts#rules-inline"><span class="std std-ref">How rules interact with INLINE/NOINLINE pragmas</span></a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wcpp-undef">
<code>-Wcpp-undef</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.2</td> </tr>  </table> <p>This flag passes <code>-Wundef</code> to the C pre-processor (if its being used) which causes the pre-processor to warn on uses of the <code>#if</code> directive on undefined identifiers.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wunbanged-strict-patterns">
<code>-Wunbanged-strict-patterns</code> </dt> <dd>
<p>This flag warns whenever you write a pattern that binds a variable whose type is unlifted, and yet the pattern is not a bang pattern nor a bare variable. See <a class="reference internal" href="glasgow_exts#glasgow-unboxed"><span class="std std-ref">Unboxed types</span></a> for information about unlifted types.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wmissing-home-modules">
<code>-Wmissing-home-modules</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.2</td> </tr>  </table> <p>When a module provided by the package currently being compiled (i.e. the “home” package) is imported, but not explicitly listed in command line as a target. Useful for Cabal to ensure GHC won’t pick up modules, not listed neither in <code>exposed-modules</code>, nor in <code>other-modules</code>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wpartial-fields">
<code>-Wpartial-fields</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.4</td> </tr>  </table> <p>The option <a class="reference internal" href="#ghc-flag--Wpartial-fields"><code>-Wpartial-fields</code></a> warns about record fields that could fail when accessed via a lacking constructor. The function <code>f</code> below will fail when applied to <code>Bar</code>, so the compiler will emit a warning at its definition when <a class="reference internal" href="#ghc-flag--Wpartial-fields"><code>-Wpartial-fields</code></a> is enabled.</p> <p>The warning is suppressed if the field name begins with an underscore.</p> <pre data-language="haskell">data Foo = Foo { f :: Int } | Bar
</pre> </dd>
</dl> <p>If you’re feeling really paranoid, the <a class="reference internal" href="debugging#ghc-flag--dcore-lint"><code>-dcore-lint</code></a> option is a good choice. It turns on heavyweight intra-pass sanity-checking within GHC. (It checks GHC’s sanity, not yours.)</p>  </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2002–2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/users_guide/using-warnings.html" class="_attribution-link">https://downloads.haskell.org/~ghc/8.8.3/docs/html/users_guide/using-warnings.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
