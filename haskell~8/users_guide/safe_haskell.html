
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>11.40. Safe Haskell - Haskell 8 - W3cubDocs</title>
  
  <meta name="description" content="Safe Haskell is an extension to the Haskell language that is implemented in GHC as of version 7.2. It allows for unsafe code to be securely included &hellip;">
  <meta name="keywords" content="safe, haskell, haskell~8">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/haskell~8/users_guide/safe_haskell.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/haskell~8.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/haskell~8/" class="_nav-link" title="" style="margin-left:0;">Haskell 8</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _haskell">
				
				
<h1 id="id1">11.40. Safe Haskell</h1>
<div class="_sphinx">   <p id="safe-haskell">Safe Haskell is an extension to the Haskell language that is implemented in GHC as of version 7.2. It allows for unsafe code to be securely included in a trusted code base by restricting the features of GHC Haskell the code is allowed to use. Put simply, it makes the types of programs trustable.</p> <p>While a primary use case of Safe Haskell is running untrusted code, Safe Haskell doesn’t provide this directly. Instead, Safe Haskell provides strict type safety. Without Safe Haskell, GHC allows many exceptions to the type system which can subvert any abstractions. By providing strict type safety, Safe Haskell enables developers to build their own library level sandbox mechanisms to run untrusted code.</p> <p>While Safe Haskell is an extension, it actually runs in the background for every compilation with GHC. It does this to track the type violations of modules to infer their safety, even when they aren’t explicitly using Safe Haskell. Please refer to section <a class="reference internal" href="#safe-inference"><span class="std std-ref">Safe Haskell Inference</span></a> for more details of this.</p> <p>The design of Safe Haskell covers the following aspects:</p> <ul class="simple"> <li>A <a class="reference internal" href="#safe-language"><span class="std std-ref">safe language</span></a> dialect of Haskell that provides stricter guarantees about the code. It allows types and module boundaries to be trusted.</li> <li>A <em>safe import</em> extension that specifies that the module being imported must be trusted.</li> <li>A definition of <em>trust</em> (or safety) and how it operates, along with ways of defining and changing the trust of modules and packages.</li> </ul> <p>Safe Haskell, however, <em>does not offer</em> compilation safety. During compilation time it is possible for arbitrary processes to be launched, using for example the <a class="reference internal" href="phases#pre-processor"><span class="std std-ref">custom pre-processor</span></a> flag. This can be manipulated to either compromise a user’s system at compilation time, or to modify the source code just before compilation to try to alter Safe Haskell flags. This is discussed further in section <a class="reference internal" href="#safe-compilation"><span class="std std-ref">Safe Compilation</span></a>.</p>  <h2 id="safe-use-cases">11.40.1. Uses of Safe Haskell</h2> <p id="uses-of-safe-haskell">Safe Haskell has been designed with two use cases in mind:</p> <ul class="simple"> <li>Enforcing strict type safety at compile time</li> <li>Compiling and executing untrusted code</li> </ul>  <h3 id="strict-type-safety-good-style">11.40.1.1. Strict type-safety (good style)</h3> <p>Haskell offers a powerful type system and separation of pure and effectual functions through the <code>IO</code> monad. However, there are several loop holes in the type system, the most obvious being the <code>unsafePerformIO :: IO a -&gt; a</code> function. The safe language dialect of Safe Haskell disallows the use of such functions. This can be useful restriction as it makes Haskell code easier to analyse and reason about. It also codifies the existing culture in the Haskell community of trying to avoid unsafe functions unless absolutely necessary. As such, using the safe language (through the <code>-XSafe</code> flag) can be thought of as a way of enforcing good style, similar to the function of <code>-Wall</code>.</p>   <h3 id="building-secure-systems-restricted-io-monads">11.40.1.2. Building secure systems (restricted IO Monads)</h3> <p id="index-2">Systems such as information flow control security, capability based security systems and DSLs for working with encrypted data.. etc can be built in the Haskell language as a library. However they require guarantees about the properties of Haskell that aren’t true in general due to the presence of functions like <code>unsafePerformIO</code>. Safe Haskell gives users enough guarantees about the type system to allow them to build such secure systems.</p> <p>As an example, let’s define an interface for a plugin system where the plugin authors are untrusted, possibly malicious third-parties. We do this by restricting the plugin interface to pure functions or to a restricted <code>IO</code> monad that we have defined. The restricted <code>IO</code> monad will only allow a safe subset of <code>IO</code> actions to be executed. We define the plugin interface so that it requires the plugin module, <code>Danger</code>, to export a single computation, <code>Danger.runMe</code>, of type <code>RIO ()</code>, where <code>RIO</code> is a monad defined as follows:</p> <pre data-language="haskell">-- While we use `Safe', the `Trustworthy' pragma would also be
-- fine. We simply want to ensure that:
-- 1) The module exports an interface that untrusted code can't
--    abuse.
-- 2) Untrusted code can import this module.
--
{-# LANGUAGE Safe #-}

module RIO (RIO(), runRIO, rioReadFile, rioWriteFile) where

-- Notice that symbol UnsafeRIO is not exported from this module!
newtype RIO a = UnsafeRIO { runRIO :: IO a }

instance Monad RIO where
    return = UnsafeRIO . return
    (UnsafeRIO m) &gt;&gt;= k = UnsafeRIO $ m &gt;&gt;= runRIO . k

-- Returns True iff access is allowed to file name
pathOK :: FilePath -&gt; IO Bool
pathOK file = {- Implement some policy based on file name -}

rioReadFile :: FilePath -&gt; RIO String
rioReadFile file = UnsafeRIO $ do
    ok &lt;- pathOK file
    if ok then readFile file else return ""

rioWriteFile :: FilePath -&gt; String -&gt; RIO ()
rioWriteFile file contents = UnsafeRIO $ do
    ok &lt;- pathOK file
    if ok then writeFile file contents else return ()
</pre> <p>We then compile the <code>Danger</code> plugin using the new Safe Haskell <code>-XSafe</code> flag:</p> <pre data-language="haskell">{-# LANGUAGE Safe #-}
module Danger ( runMe ) where

runMe :: RIO ()
runMe = ...
</pre> <p>Before going into the Safe Haskell details, let’s point out some of the reasons this security mechanism would fail without Safe Haskell:</p> <ul class="simple"> <li>The design attempts to restrict the operations that <code>Danger</code> can perform by using types, specifically the <code>RIO</code> type wrapper around <code>IO</code> . The author of <code>Danger</code> can subvert this though by simply writing arbitrary <code>IO</code> actions and using <code>unsafePerformIO :: IO a -&gt; a</code> to execute them as pure functions.</li> <li>The design also relies on <code>Danger</code> not being able to access the <code>UnsafeRIO</code> constructor. Unfortunately Template Haskell can be used to subvert module boundaries and so could be used to gain access to this constructor.</li> <li>There is no way to place restrictions on the modules that <code>Danger</code> can import. This gives the author of <code>Danger</code> a very large attack surface, essentially any package currently installed on the system. Should any of these packages have a vulnerability, then the <code>Danger</code> module can exploit it.</li> </ul> <p>Safe Haskell prevents all these attacks. This is done by compiling the RIO module with the <a class="reference internal" href="#extension-Safe"><code>Safe</code></a> or <a class="reference internal" href="#extension-Trustworthy"><code>Trustworthy</code></a> flag and compiling <code>Danger</code> with the <a class="reference internal" href="#extension-Safe"><code>Safe</code></a> flag. We explain each below.</p> <p>The use of <a class="reference internal" href="#extension-Safe"><code>Safe</code></a> to compile <code>Danger</code> restricts the features of Haskell that can be used to a <a class="reference external" href="#safe-language">safe subset</a>. This includes disallowing <code>unsafePerformIO</code>, Template Haskell, pure FFI functions, RULES and restricting the operation of Overlapping Instances. The <a class="reference internal" href="#extension-Safe"><code>Safe</code></a> flag also restricts the modules can be imported by <code>Danger</code> to only those that are considered trusted. Trusted modules are those compiled with <a class="reference internal" href="#extension-Safe"><code>Safe</code></a>, where GHC provides a mechanical guarantee that the code is safe. Or those modules compiled with <a class="reference internal" href="#extension-Trustworthy"><code>Trustworthy</code></a>, where the module author claims that the module is Safe.</p> <p>This is why the RIO module is compiled with <a class="reference internal" href="#extension-Safe"><code>Safe</code></a> or <a class="reference internal" href="#extension-Trustworthy"><code>Trustworthy</code></a>&gt;, to allow the <code>Danger</code> module to import it. The <a class="reference internal" href="#extension-Trustworthy"><code>Trustworthy</code></a> flag doesn’t place any restrictions on the module like <a class="reference internal" href="#extension-Safe"><code>Safe</code></a> does (expect to restrict overlapping instances to <a class="reference external" href="#safe-overlapping-instances">safe overlapping instances</a>). Instead the module author claims that while code may use unsafe features internally, it only exposes an API that can used in a safe manner.</p> <p>However, the unrestricted use of <a class="reference internal" href="#extension-Trustworthy"><code>Trustworthy</code></a> is a problem as an arbitrary module can use it to mark themselves as trusted, yet <a class="reference internal" href="#extension-Trustworthy"><code>Trustworthy</code></a> doesn’t offer any guarantees about the module, unlike <a class="reference internal" href="#extension-Safe"><code>Safe</code></a>. To control the use of trustworthy modules it is recommended to use the <a class="reference internal" href="#ghc-flag--fpackage-trust"><code>-fpackage-trust</code></a> flag. This flag adds an extra requirement to the trust check for trustworthy modules. It requires that for a trustworthy modules to be considered trusted, and allowed to be used in <a class="reference internal" href="#extension-Safe"><code>Safe</code></a> compiled code, the client C compiling the code must tell GHC that they trust the package the trustworthy module resides in. This is essentially a way of for C to say, while this package contains trustworthy modules that can be used by untrusted modules compiled with <a class="reference internal" href="#extension-Safe"><code>Safe</code></a>, I trust the author(s) of this package and trust the modules only expose a safe API. The trust of a package can be changed at any time, so if a vulnerability found in a package, C can declare that package untrusted so that any future compilation against that package would fail. For a more detailed overview of this mechanism see <a class="reference internal" href="#safe-trust"><span class="std std-ref">Trust and Safe Haskell Modes</span></a>.</p> <p>In the example, <code>Danger</code> can import module <code>RIO</code> because <code>RIO</code> is compiled with <a class="reference internal" href="#extension-Safe"><code>Safe</code></a>. Thus, <code>Danger</code> can make use of the <code>rioReadFile</code> and <code>rioWriteFile</code> functions to access permitted file names. The main application then imports both <code>RIO</code> and <code>Danger</code>. To run the plugin, it calls <code>RIO.runRIO Danger.runMe</code> within the <code>IO</code> monad. The application is safe in the knowledge that the only <code>IO</code> to ensue will be to files whose paths were approved by the <code>pathOK</code> test.</p> <p>The Safe Haskell checks can be disabled for a module by passing the <a class="reference internal" href="#ghc-flag--fno-safe-haskell"><code>-fno-safe-haskell</code></a> flag. This is useful in particular when compiling with source plugins as running a plugin marks the module as unsafe and can then cause downstream modules to fail the safety checks.</p>    <h2 id="id2">11.40.2. Safe Language</h2> <p id="safe-language">The Safe Haskell <em>safe language</em> (enabled by <code>-XSafe</code>) guarantees the following properties:</p> <ul class="simple"> <li>
<em>Referential transparency</em> — The types can be trusted. Any pure function, is guaranteed to be pure. Evaluating them is deterministic and won’t cause any side effects. Functions in the <code>IO</code> monad are still allowed and behave as usual. So, for example, the <code>unsafePerformIO :: IO a -&gt; a</code> function is disallowed in the safe language to enforce this property.</li> <li>
<em>Module boundary control</em> — Only symbols that are publicly available through other module export lists can be accessed in the safe language. Values using data constructors not exported by the defining module, cannot be examined or created. As such, if a module <code>M</code> establishes some invariants through careful use of its export list, then code written in the safe language that imports <code>M</code> is guaranteed to respect those invariants.</li> <li>
<em>Semantic consistency</em> — For any module that imports a module written in the safe language, expressions that compile both with and without the safe import have the same meaning in both cases. That is, importing a module written in the safe language cannot change the meaning of existing code that isn’t dependent on that module. So, for example, there are some restrictions placed on the use of <a class="reference internal" href="glasgow_exts#instance-overlap"><span class="std std-ref">OverlappingInstances</span></a>, as these can violate this property.</li> <li>
<em>Strict subset</em> — The safe language is strictly a subset of Haskell as implemented by GHC. Any expression that compiles in the safe language has the same meaning as it does when compiled in normal Haskell.</li> </ul> <p>These four properties guarantee that in the safe language you can trust the types, can trust that module export lists are respected, and can trust that code that successfully compiles has the same meaning as it normally would.</p> <p>To achieve these properties, in the safe language dialect we disable completely the following features:</p> <ul class="simple"> <li>
<code>TemplateHaskell</code> — Can be used to gain access to constructors and abstract data types that weren’t exported by a module, subverting module boundaries.</li> </ul> <p>Furthermore, we restrict the following features:</p> <ul> <li>
<code>ForeignFunctionInterface</code> — Foreign import declarations that import a function with a non-<code>IO</code> type are disallowed. </li> <li>
<code>RULES</code> — Rewrite rules defined in a module M compiled with <a class="reference internal" href="#extension-Safe"><code>Safe</code></a> are dropped. Rules defined in Trustworthy modules that <code>M</code> imports are still valid and will fire as usual. </li> <li>
<code>OverlappingInstances</code> — There is no restriction on the creation of overlapping instances, but we do restrict their use at a particular call site. This is a detailed restriction, please refer to <a class="reference internal" href="#safe-overlapping-instances"><span class="std std-ref">Safe Overlapping Instances</span></a> for details. </li> <li>
<code>GeneralisedNewtypeDeriving</code> — GND is not allowed in the safe language. This is due to the ability of it to violate module boundaries when module authors forget to put nominal role annotations on their types as appropriate. For this reason, the <code>Data.Coerce</code> module is also considered unsafe. We are hoping to find a better solution here in the future. </li> <li>
<p class="first"><code>GHC.Generics</code> — Hand crafted instances of the <code>Generic</code> type class are not allowed in Safe Haskell. Such instances aren’t strictly unsafe, but there is an important invariant that a <code>Generic</code> instance should adhere to the structure of the data type for which the instance is defined, and allowing manually implemented <code>Generic</code> instances would break that invariant. Derived instances (through the <a class="reference internal" href="glasgow_exts#extension-DeriveGeneric"><code>DeriveGeneric</code></a> extension) are still allowed. Note that the only allowed <a class="reference internal" href="glasgow_exts#deriving-strategies"><span class="std std-ref">deriving strategy</span></a> for deriving <code>Generic</code> under Safe Haskell is <code>stock</code>, as another strategy (e.g., <code>anyclass</code>) would produce an instance that violates the invariant.</p> <p>Refer to the <a class="reference internal" href="glasgow_exts#generic-programming"><span class="std std-ref">generic programming</span></a> section for more details.</p> </li> </ul>  <h3 id="id3">11.40.2.1. Safe Overlapping Instances</h3> <p id="safe-overlapping-instances">Due to the semantic consistency guarantee of Safe Haskell, we must restrict the function of overlapping instances. We don’t restrict their ability to be defined, as this is a global property and not something we can determine by looking at a single module. Instead, when a module calls a function belonging to a type-class, we check that the instance resolution done is considered ‘safe’. This check is enforced for modules compiled with both <code>-XSafe</code> and <code>-XTrustworthy</code>.</p> <p>More specifically, consider the following modules:</p> <pre data-language="haskell">{-# LANGUAGE Safe #-}
module Class (TC(..)) where
  class TC a where { op :: a -&gt; String }

{-# LANGUAGE Safe #-}
module Dangerous (TC(..)) where
  import Class

  instance
    {-# OVERLAPS #-}
    TC [Int] where { op _ = "[Int]" }

{-# LANGUAGE Safe #-}
module TCB_Runner where
  import Class
  import Dangerous

  instance
    TC [a] where { op _ = "[a]" }

  f :: String
  f = op ([1,2,3,4] :: [Int])
</pre> <p>Both module <code>Class</code> and module <code>Dangerous</code> will compile under <a class="reference internal" href="#extension-Safe"><code>Safe</code></a> without issue. However, in module <code>TCB_Runner</code>, we must check if the call to <code>op</code> in function <code>f</code> is safe.</p> <p>What does it mean to be Safe? That importing a module compiled with <a class="reference internal" href="#extension-Safe"><code>Safe</code></a> shouldn’t change the meaning of code that compiles fine without importing the module. This is the Safe Haskell property known as <em>semantic consistency</em>.</p> <p>In our situation, module <code>TCB_Runner</code> compiles fine without importing module <code>Dangerous</code>. So when deciding which instance to use for the call to <code>op</code>, if we determine the instance <code>TC [Int]</code> from module Dangerous is the most specific, this is unsafe. This prevents code written by third-parties we don’t trust (which is compiled using <code>-XSafe</code> in Safe Haskell) from changing the behaviour of our existing code.</p> <p>Specifically, we apply the following rule to determine if a type-class method call is <em>unsafe</em> when overlapping instances are involved:</p> <ul class="simple"> <li>Most specific instance, <code>Ix</code>, defined in an <code>-XSafe</code> compiled module.</li> <li>
<code>Ix</code> is an orphan instance or a multi-parameter-type-class.</li> <li>At least one overlapped instance, <code>Iy</code>, is both:<ul> <li>From a different module than <code>Ix</code>
</li> <li>
<code>Iy</code> is not marked <code>OVERLAPPABLE</code>
</li> </ul> </li> </ul> <p>This is a slightly involved heuristic, but captures the situation of an imported module <code>N</code> changing the behaviour of existing code. For example, if the second condition isn’t violated, then the module author <code>M</code> must depend either on a type-class or type defined in <code>N</code>.</p> <p>When a particular type-class method call is considered unsafe due to overlapping instances, and the module being compiled is using <a class="reference internal" href="#extension-Safe"><code>Safe</code></a> or <a class="reference internal" href="#extension-Trustworthy"><code>Trustworthy</code></a>, then compilation will fail. For <a class="reference internal" href="#extension-Unsafe"><code>Unsafe</code></a>, no restriction is applied, and for modules using safe inference, they will be inferred unsafe.</p>    <h2 id="id4">11.40.3. Safe Imports</h2> <p id="safe-imports">Safe Haskell enables a small extension to the usual import syntax of Haskell, adding a <code>safe</code> keyword:</p> <pre data-language="none">impdecl -&gt; import [safe] [qualified] modid [as modid] [impspec]
</pre> <p>When used, the module being imported with the safe keyword must be a trusted module, otherwise a compilation error will occur. The safe import extension is enabled by either of the <code>-XSafe</code> , <code>-XTrustworthy</code> , or <code>-XUnsafe</code> flags. When the <code>-XSafe</code> flag is used, the <code>safe</code> keyword is allowed but meaningless, as every import is treated as a safe import.</p>   <h2 id="safe-trust">11.40.4. Trust and Safe Haskell Modes</h2> <p id="trust-and-safe-haskell-modes">Safe Haskell introduces the following three language flags:</p> <ul class="simple"> <li>
<a class="reference internal" href="#extension-Safe"><code>Safe</code></a> — Enables the safe language dialect, asking GHC to guarantee trust. The safe language dialect requires that all imports be trusted or a compilation error will occur. Safe Haskell will also infer this safety type for modules automatically when possible. Please refer to section <a class="reference internal" href="#safe-inference"><span class="std std-ref">Safe Haskell Inference</span></a> for more details of this.</li> <li>
<a class="reference internal" href="#extension-Trustworthy"><code>Trustworthy</code></a> — Means that while this module may invoke unsafe functions internally, the module’s author claims that it exports an API that can’t be used in an unsafe way. This doesn’t enable the safe language. It does however restrict the resolution of overlapping instances to only allow <a class="reference internal" href="#safe-overlapping-instances"><span class="std std-ref">safe overlapping instances</span></a>. The trust guarantee is provided by the module author, not GHC. An import statement with the <code>safe</code> keyword results in a compilation error if the imported module is not trusted. An import statement without the keyword behaves as usual and can import any module whether trusted or not.</li> <li>
<a class="reference internal" href="#extension-Unsafe"><code>Unsafe</code></a> — Marks the module being compiled as unsafe so that modules compiled using <a class="reference internal" href="#extension-Safe"><code>Safe</code></a> can’t import it. You may want to explicitly mark a module unsafe when it exports internal constructors that can be used to violate invariants.</li> </ul> <p>While these are flags, they also correspond to Safe Haskell module types that a module can have. You can think of using these as declaring an explicit contract (or type) that a module must have. If it is invalid, then compilation will fail. GHC will also infer the correct type for Safe Haskell, please refer to section <a class="reference internal" href="#safe-inference"><span class="std std-ref">Safe Haskell Inference</span></a> for more details.</p> <p>The procedure to check if a module is trusted or not depends on if the <a class="reference internal" href="#ghc-flag--fpackage-trust"><code>-fpackage-trust</code></a> flag is present. The check is similar in both cases with the <a class="reference internal" href="#ghc-flag--fpackage-trust"><code>-fpackage-trust</code></a> flag enabling an extra requirement for trustworthy modules to be regarded as trusted.</p>  <h3 id="trust-check-fpackage-trust-disabled">11.40.4.1. Trust check (<code>-fpackage-trust</code> disabled)</h3> <p id="index-6">A module <code>M</code> in a package <code>P</code> is trusted by a client C if and only if:</p> <ul> <li>
<p class="first">Both of these hold:</p>  <ul class="simple"> <li>The module was compiled with <a class="reference internal" href="#extension-Safe"><code>Safe</code></a>
</li> <li>All of M’s direct imports are trusted by C</li> </ul>  </li> <li>
<p class="first"><em>or</em> all of these hold:</p>  <ul class="simple"> <li>The module was compiled with <a class="reference internal" href="#extension-Trustworthy"><code>Trustworthy</code></a>
</li> <li>All of <code>M</code>‘s direct <em>safe imports</em> are trusted by C</li> </ul>  </li> </ul> <p>The above definition of trust has an issue. Any module can be compiled with <a class="reference internal" href="#extension-Trustworthy"><code>Trustworthy</code></a> and it will be trusted. To control this, there is an additional definition of package trust (enabled with the <a class="reference internal" href="#ghc-flag--fpackage-trust"><code>-fpackage-trust</code></a> flag). The point of package trust is to require that the client C explicitly say which packages are allowed to contain trustworthy modules. Trustworthy packages are only trusted if they reside in a package trusted by C.</p>   <h3 id="trust-check-fpackage-trust-enabled">11.40.4.2. Trust check (<code>-fpackage-trust</code> enabled)</h3> <p id="index-7">When the <a class="reference internal" href="#ghc-flag--fpackage-trust"><code>-fpackage-trust</code></a> flag is enabled, whether or not a module is trusted depends on if certain packages are trusted. Package trust is determined by the client C invoking GHC (i.e. you).</p> <p>Specifically, a package <em>P is trusted</em> when one of these hold:</p> <ul class="simple"> <li>C’s package database records that <code>P</code> is trusted (and no command-line arguments override this)</li> <li>C’s command-line flags say to trust <code>P</code> regardless of what is recorded in the package database.</li> </ul> <p>In either case, C is the only authority on package trust. It is up to the client to decide which <a class="reference external" href="#safe-package-trust">packages they trust</a>.</p> <p>When the <a class="reference internal" href="#ghc-flag--fpackage-trust"><code>-fpackage-trust</code></a> flag is used a <em>module M from package P is trusted by a client C</em> if and only if:</p> <ul class="simple"> <li>Both of these hold:<ul> <li>The module was compiled with <a class="reference internal" href="#extension-Safe"><code>Safe</code></a>
</li> <li>All of <code>M</code>‘s direct imports are trusted by C</li> </ul> </li> <li>
<em>or</em> all of these hold:<ul> <li>The module was compiled with <a class="reference internal" href="#extension-Trustworthy"><code>Trustworthy</code></a>
</li> <li>All of <code>M</code>‘s direct safe imports are trusted by C</li> <li>Package <code>P</code> is trusted by C</li> </ul> </li> </ul> <p>For the first trust definition the trust guarantee is provided by GHC through the restrictions imposed by the safe language. For the second definition of trust, the guarantee is provided initially by the module author. The client C then establishes that they trust the module author by indicating they trust the package the module resides in. This trust chain is required as GHC provides no guarantee for <a class="reference internal" href="#extension-Trustworthy"><code>Trustworthy</code></a> compiled modules.</p> <p>The reason there are two modes of checking trust is that the extra requirement enabled by <a class="reference internal" href="#ghc-flag--fpackage-trust"><code>-fpackage-trust</code></a> causes the design of Safe Haskell to be invasive. Packages using Safe Haskell when the flag is enabled may or may not compile depending on the state of trusted packages on a user’s machine. This is both fragile, and causes compilation failures for everyone, even if they aren’t trying to use any of the guarantees provided by Safe Haskell. Disabling <a class="reference internal" href="#ghc-flag--fpackage-trust"><code>-fpackage-trust</code></a> by default and turning it into a flag makes Safe Haskell an opt-in extension rather than an always on feature.</p>   <h3 id="safe-trust-example">11.40.4.3. Example</h3> <pre data-language="haskell" id="example">Package Wuggle:
    {-# LANGUAGE Safe #-}
    module Buggle where
        import Prelude
        f x = ...blah...

Package P:
    {-# LANGUAGE Trustworthy #-}
    module M where
        import System.IO.Unsafe
        import safe Buggle
</pre> <p>Suppose a client C decides to trust package <code>P</code> and package <code>base</code>. Then does C trust module <code>M</code>? Well <code>M</code> is marked <a class="reference internal" href="#extension-Trustworthy"><code>Trustworthy</code></a>, so we don’t restrict the language. However, we still must check <code>M</code>‘s imports:</p> <ul class="simple"> <li>First, <code>M</code> imports <code>System.IO.Unsafe</code>. This is an unsafe module, however <code>M</code> was compiled with <a class="reference internal" href="#extension-Trustworthy"><code>Trustworthy</code></a> , so <code>P</code>‘s author takes responsibility for that import. <code>C</code> trusts <code>P</code>‘s author, so this import is fine.</li> <li>Second, <code>M</code> safe imports <code>Buggle</code>. For this import <code>P</code>‘s author takes no responsibility for the safety, instead asking GHC to check whether <code>Buggle</code> is trusted by <code>C</code>. Is it?</li> <li>
<code>Buggle</code>, is compiled with <code>-XSafe</code>, so the code is machine-checked to be OK, but again under the assumption that all of <code>Buggle</code>‘s imports are trusted by <code>C</code>. We must recursively check all imports!</li> <li>Buggle only imports <code>Prelude</code>, which is compiled with <a class="reference internal" href="#extension-Trustworthy"><code>Trustworthy</code></a>. <code>Prelude</code> resides in the <code>base</code> package, which <code>C</code> trusts, and (we’ll assume) all of <code>Prelude</code>‘s imports are trusted. So <code>C</code> trusts <code>Prelude</code>, and so <code>C</code> also trusts Buggle. (While <code>Prelude</code> is typically imported implicitly, it still obeys the same rules outlined here).</li> </ul> <p>Notice that C didn’t need to trust package Wuggle; the machine checking is enough. C only needs to trust packages that contain <a class="reference internal" href="#extension-Trustworthy"><code>Trustworthy</code></a> modules.</p>   <h3 id="trustworthy-guarantees">11.40.4.4. Trustworthy Requirements</h3> <p id="trustworthy-requirements">Module authors using the <a class="reference internal" href="#extension-Trustworthy"><code>Trustworthy</code></a> language extension for a module <code>M</code> should ensure that <code>M</code>‘s public API (the symbols exposed by its export list) can’t be used in an unsafe manner. This mean that symbols exported should respect type safety and referential transparency.</p>   <h3 id="safe-package-trust">11.40.4.5. Package Trust</h3> <p id="package-trust">Safe Haskell gives packages a new Boolean property, that of trust. Several new options are available at the GHC command-line to specify the trust property of packages:</p> <dl class="ghc-flag"> <dt id="ghc-flag--trust ⟨pkg⟩">
<code>-trust ⟨pkg⟩</code> </dt> <dd>
<p>Exposes package ⟨pkg⟩ if it was hidden and considers it a trusted package regardless of the package database.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--distrust ⟨pkg⟩">
<code>-distrust ⟨pkg⟩</code> </dt> <dd>
<p>Exposes package ⟨pkg⟩ if it was hidden and considers it an untrusted package regardless of the package database.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--distrust-all-packages">
<code>-distrust-all-packages</code> </dt> <dd>
<p>Considers all packages distrusted unless they are explicitly set to be trusted by subsequent command-line options.</p> </dd>
</dl> <p>To set a package’s trust property in the package database please refer to <a class="reference internal" href="packages#packages"><span class="std std-ref">Packages</span></a>.</p>    <h2 id="safe-inference">11.40.5. Safe Haskell Inference</h2> <p id="safe-haskell-inference">In the case where a module is compiled without one of <a class="reference internal" href="#extension-Safe"><code>Safe</code></a>, <a class="reference internal" href="#extension-Trustworthy"><code>Trustworthy</code></a> or <a class="reference internal" href="#extension-Unsafe"><code>Unsafe</code></a> being used, GHC will try to figure out itself if the module can be considered safe. This safety inference will never mark a module as trustworthy, only as either unsafe or as safe. GHC uses a simple method to determine this for a module M: If M would compile without error under the <a class="reference internal" href="#extension-Safe"><code>Safe</code></a> flag, then M is marked as safe. Otherwise, it is marked as unsafe.</p> <p>When should you use Safe Haskell inference and when should you use an explicit <a class="reference internal" href="#extension-Safe"><code>Safe</code></a> flag? The later case should be used when you have a hard requirement that the module be safe. This is most useful for the <a class="reference internal" href="#safe-use-cases"><span class="std std-ref">Uses of Safe Haskell</span></a> of Safe Haskell: running untrusted code. Safe inference is meant to be used by ordinary Haskell programmers. Users who probably don’t care about Safe Haskell.</p> <p>Haskell library authors have a choice. Most should just use Safe inference. Assuming you avoid any unsafe features of the language then your modules will be marked safe. Inferred vs. Explicit has the following trade-offs:</p> <ul class="simple"> <li>
<em>Inferred</em> — This works well and adds no dependencies on the Safe Haskell type of any modules in other packages. It does mean that the Safe Haskell type of your own modules could change without warning if a dependency changes. One way to deal with this is through the use of <a class="reference internal" href="#safe-flag-summary"><span class="std std-ref">Safe Haskell warning flags</span></a> that will warn if GHC infers a Safe Haskell type different from expected.</li> <li>
<em>Explicit</em> — This gives your library a stable Safe Haskell type that others can depend on. However, it will increase the chance of compilation failure when your package dependencies change.</li> </ul>   <h2 id="safe-flag-summary">11.40.6. Safe Haskell Flag Summary</h2> <p id="safe-haskell-flag-summary">In summary, Safe Haskell consists of the following three language flags:</p> <dl class="extension"> <dt id="extension-Safe">
<code>Safe</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.2.1</td> </tr>  </table> <p>Restricts the module to the safe language. All of the module’s direct imports must be trusted, but the module itself need not reside in a trusted package, because the compiler vouches for its trustworthiness. The “safe” keyword is allowed but meaningless in import statements, as regardless, every import is required to be safe.</p> <ul class="simple"> <li>
<em>Module Trusted</em> — Yes</li> <li>
<em>Haskell Language</em> — Restricted to Safe Language</li> <li>
<em>Imported Modules</em> — All forced to be safe imports, all must be trusted.</li> </ul> </dd>
</dl> <dl class="extension"> <dt id="extension-Trustworthy">
<code>Trustworthy</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.2.1</td> </tr>  </table> <p>This establishes that the module is trusted, but the guarantee is provided by the module’s author. A client of this module then specifies that they trust the module author by specifying they trust the package containing the module. <a class="reference internal" href="#extension-Trustworthy"><code>Trustworthy</code></a> doesn’t restrict the module to the safe language. It does however restrict the resolution of overlapping instances to only allow <a class="reference internal" href="#safe-overlapping-instances"><span class="std std-ref">safe overlapping instances</span></a>. It also allows the use of the safe import keyword.</p> <ul class="simple"> <li>
<em>Module Trusted</em> — Yes.</li> <li>
<em>Module Trusted</em> (<a class="reference internal" href="#ghc-flag--fpackage-trust"><code>-fpackage-trust</code></a> enabled) — Yes but only if the package the module resides in is also trusted.</li> <li>
<em>Haskell Language</em> — Unrestricted, except only safe overlapping instances allowed.</li> <li>
<em>Imported Modules</em> — Under control of module author which ones must be trusted.</li> </ul> </dd>
</dl> <dl class="extension"> <dt id="extension-Unsafe">
<code>Unsafe</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.4.1</td> </tr>  </table> <p>Mark a module as unsafe so that it can’t be imported by code compiled with <a class="reference internal" href="#extension-Safe"><code>Safe</code></a>. Also enable the Safe Import extension so that a module can require a dependency to be trusted.</p> <ul class="simple"> <li>
<em>Module Trusted</em> — No</li> <li>
<em>Haskell Language</em> — Unrestricted</li> <li>
<em>Imported Modules</em> — Under control of module author which ones must be trusted.</li> </ul> </dd>
</dl> <p>A flag to disable Safe Haskell checks:</p> <dl class="ghc-flag"> <dt id="ghc-flag--fno-safe-haskell">
<code>-fno-safe-haskell</code> </dt> <dd>
<p>This flag can be enabled to override any declared safety property of the module (Safe, Unsafe, Trustworthy) so compilation proceeds as if none of these flags were specified. This is particularly useful when compiling using plugins, which usually results in the compiled modules being marked as unsafe.</p> </dd>
</dl> <p>And one general flag:</p> <dl class="ghc-flag"> <dt id="ghc-flag--fpackage-trust">
<code>-fpackage-trust</code> </dt> <dd>
<p>When enabled, turn on an extra check for a trustworthy module <code>M</code>, requiring the package that <code>M</code> resides in be considered trusted, for <code>M</code> to be considered trusted.</p> </dd>
</dl> <p>And three warning flags:</p> <dl class="ghc-flag"> <dt id="ghc-flag--Wunsafe">
<code>-Wunsafe</code> </dt> <dd>
<p>Issue a warning if the module being compiled is regarded to be unsafe. Should be used to check the safety type of modules when using safe inference.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wsafe">
<code>-Wsafe</code> </dt> <dd>
<p>Issue a warning if the module being compiled is regarded to be safe. Should be used to check the safety type of modules when using safe inference.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wtrustworthy-safe">
<code>-Wtrustworthy-safe</code> </dt> <dd>
<p>Issue a warning if the module being compiled is marked as -XTrustworthy but it could instead be marked as -XSafe , a more informative bound. Can be used to detect once a Safe Haskell bound can be improved as dependencies are updated.</p> </dd>
</dl>   <h2 id="id5">11.40.7. Safe Compilation</h2> <p id="safe-compilation">GHC includes a variety of flags that allow arbitrary processes to be run at compilation time. One such example is the <a class="reference internal" href="phases#pre-processor"><span class="std std-ref">custom pre-processor</span></a> flag. Another is the ability of Template Haskell to execute Haskell code at compilation time, including IO actions. Safe Haskell <em>does not address this danger</em> (although, Template Haskell is a disallowed feature).</p> <p>Due to this, it is suggested that when compiling untrusted source code that has had no manual inspection done, the following precautions be taken:</p> <ul class="simple"> <li>Compile in a sandbox, such as a chroot or similar container technology. Or simply as a user with very reduced system access.</li> <li>Compile untrusted code with the <code>-XSafe</code> flag being specified on the command line. This will ensure that modifications to the source being compiled can’t disable the use of the Safe Language as the command line flag takes precedence over a source level pragma.</li> <li>Ensure that all untrusted code is imported as a <a class="reference internal" href="#safe-imports"><span class="std std-ref">safe import</span></a> and that the <a class="reference internal" href="#ghc-flag--fpackage-trust"><code>-fpackage-trust</code></a> flag (see <a class="reference internal" href="#safe-package-trust"><span class="std std-ref">flag</span></a>) is used with packages from untrusted sources being marked as untrusted.</li> </ul> <p>There is a more detailed discussion of the issues involved in compilation safety and some potential solutions on the <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/wikis/SafeHaskell/SafeCompilation">GHC Wiki</a>.</p> <p>Additionally, the use of <a class="reference internal" href="extending_ghc#annotation-pragmas"><span class="std std-ref">annotations</span></a> is forbidden, as that would allow bypassing Safe Haskell restrictions. See <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/10826">Issue #10826</a> for details.</p>   </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2002–2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/users_guide/safe_haskell.html" class="_attribution-link">https://downloads.haskell.org/~ghc/8.8.3/docs/html/users_guide/safe_haskell.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
