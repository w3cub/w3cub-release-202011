
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Chan - Tcl&#47;Tk - W3cubDocs</title>
  
  <meta name="description" content="As part of closing the channel, all buffered output is flushed to the channel&#39;s output device (only if the channel is ceasing to be writable), &hellip;">
  <meta name="keywords" content="chan, tcl, tk, tcl_tk">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/tcl_tk/tclcmd/chan.htm.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/tcl_tk.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/tcl_tk/" class="_nav-link" title="" style="margin-left:0;">Tcl/Tk</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _tcl_tk">
				
				
<h1>chan</h1>  <dl> <dd id="L137">
<a href="chan.htm#M2" name="L137">NAME</a> <dl><dd>chan — Read, write and manipulate channels</dd></dl> <dd id="L138">
<a href="chan.htm#M3" name="L138">SYNOPSIS</a>  <dd id="L139">
<a href="chan.htm#M4" name="L139">DESCRIPTION</a> <dl class="description"> <dd id="L140">
<a href="chan.htm#M5" name="L140"><b>chan blocked </b><i>channelId</i></a> <dd id="L141">
<a href="chan.htm#M6" name="L141"><b>chan close </b><i>channelId</i> ?<i>direction</i>?</a> <dd id="L142">
<a href="chan.htm#M7" name="L142"><b>chan configure </b><i>channelId</i> ?<i>optionName</i>? ?<i>value</i>? ?<i>optionName value</i>?...</a> <dl class="description"> <dd id="L143">
<a href="chan.htm#M8" name="L143"><b>-blocking</b> <i>boolean</i></a> <dd id="L144">
<a href="chan.htm#M9" name="L144"><b>-buffering</b> <i>newValue</i></a> <dd id="L145">
<a href="chan.htm#M10" name="L145"><b>-buffersize</b> <i>newSize</i></a> <dd id="L146">
<a href="chan.htm#M11" name="L146"><b>-encoding</b> <i>name</i></a> <dd id="L147">
<a href="chan.htm#M12" name="L147"><b>-eofchar</b> <i>char</i></a> <dd id="L148">
<a href="chan.htm#M13" name="L148"><b>-eofchar</b> <b>{</b><i>inChar outChar</i><b>}</b></a> <dd id="L149">
<a href="chan.htm#M14" name="L149"><b>-translation</b> <i>mode</i></a> <dd id="L150">
<a href="chan.htm#M15" name="L150"><b>-translation</b> <b>{</b><i>inMode outMode</i><b>}</b></a> <dl class="description"> <dd id="L151">
<a href="chan.htm#M16" name="L151"><b>auto</b></a> <dd id="L152">
<a href="chan.htm#M17" name="L152"><b>binary</b></a> <dd id="L153">
<a href="chan.htm#M18" name="L153"><b>cr</b></a> <dd id="L154">
<a href="chan.htm#M19" name="L154"><b>crlf</b></a> <dd id="L155">
<a href="chan.htm#M20" name="L155"><b>lf</b></a> </dd>
</dd>
</dd>
</dd>
</dd>
</dl> </dd>
</dd>
</dd>
</dd>
</dd>
</dd>
</dd>
</dd>
</dl> <dd id="L156">
<a href="chan.htm#M21" name="L156"><b>chan copy </b><i>inputChan outputChan</i> ?<b>-size </b><i>size</i>? ?<b>-command </b><i>callback</i>?</a> <dd id="L157">
<a href="chan.htm#M22" name="L157"><b>chan create </b><i>mode cmdPrefix</i></a> <dd id="L158">
<a href="chan.htm#M23" name="L158"><b>chan eof </b><i>channelId</i></a> <dd id="L159">
<a href="chan.htm#M24" name="L159"><b>chan event </b><i>channelId event</i> ?<i>script</i>?</a> <dd id="L160">
<a href="chan.htm#M25" name="L160"><b>chan flush </b><i>channelId</i></a> <dd id="L161">
<a href="chan.htm#M26" name="L161"><b>chan gets </b><i>channelId</i> ?<i>varName</i>?</a> <dd id="L162">
<a href="chan.htm#M27" name="L162"><b>chan names</b> ?<i>pattern</i>?</a> <dd id="L163">
<a href="chan.htm#M28" name="L163"><b>chan pending </b><i>mode channelId</i></a> <dd id="L164">
<a href="chan.htm#M29" name="L164"><b>chan pipe</b></a> <dd id="L165">
<a href="chan.htm#M30" name="L165"><b>chan pop </b><i>channelId</i></a> <dd id="L166">
<a href="chan.htm#M31" name="L166"><b>chan postevent </b><i>channelId eventSpec</i></a> <dd id="L167">
<a href="chan.htm#M32" name="L167"><b>chan push </b><i>channelId cmdPrefix</i></a> <dd id="L168">
<a href="chan.htm#M33" name="L168"><b>chan puts</b> ?<b>-nonewline</b>? ?<i>channelId</i>? <i>string</i></a> <dd id="L169">
<a href="chan.htm#M34" name="L169"><b>chan read </b><i>channelId</i> ?<i>numChars</i>?</a> <dd id="L170">
<a href="chan.htm#M35" name="L170"><b>chan read </b>?<b>-nonewline</b>? <i>channelId</i></a> <dl class="description"> <dd id="L171">
<a href="chan.htm#M36" name="L171"><b>chan read </b><i>channelId numChars</i></a> <dd id="L172">
<a href="chan.htm#M37" name="L172"><b>chan read </b><i>channelId</i></a> </dd>
</dd>
</dl> <dd id="L173">
<a href="chan.htm#M38" name="L173"><b>chan seek </b><i>channelId offset</i> ?<i>origin</i>?</a> <dl class="description"> <dd id="L174">
<a href="chan.htm#M39" name="L174"><b>start</b></a> <dd id="L175">
<a href="chan.htm#M40" name="L175"><b>current</b></a> <dd id="L176">
<a href="chan.htm#M41" name="L176"><b>end</b></a> </dd>
</dd>
</dd>
</dl> <dd id="L177">
<a href="chan.htm#M42" name="L177"><b>chan tell </b><i>channelId</i></a> <dd id="L178">
<a href="chan.htm#M43" name="L178"><b>chan truncate </b><i>channelId</i> ?<i>length</i>?</a> </dd>
</dd>
</dd>
</dd>
</dd>
</dd>
</dd>
</dd>
</dd>
</dd>
</dd>
</dd>
</dd>
</dd>
</dd>
</dd>
</dd>
</dd>
</dd>
</dd>
</dd>
</dl> <dd id="L179">
<a href="chan.htm#M44" name="L179">EXAMPLES</a> <dd id="L180">
<a href="chan.htm#M45" name="L180">SEE ALSO</a> <dd id="L181">
<a href="chan.htm#M46" name="L181">KEYWORDS</a> </dd>
</dd>
</dd>
</dd>
</dd>
</dd>
</dl> <h2 id="M2">Name</h2> chan — Read, write and manipulate channels <h2 id="M3">Synopsis</h2> <b>chan </b><i>option</i> ?<i>arg arg ...</i>?<br> <h2 id="M4">Description</h2> This command provides several operations for reading from, writing to and otherwise manipulating open channels (such as have been created with the <b><a href="open.htm">open</a></b> and <b><a href="socket.htm">socket</a></b> commands, or the default named channels <b><a href="https://www.tcl.tk/man/tcl/TclLib/GetStdChan.htm">stdin</a></b>, <b><a href="https://www.tcl.tk/man/tcl/TclLib/GetStdChan.htm">stdout</a></b> or <b><a href="https://www.tcl.tk/man/tcl/TclLib/GetStdChan.htm">stderr</a></b> which correspond to the process's standard input, output and error streams respectively). <i>Option</i> indicates what to do with the channel; any unique abbreviation for <i>option</i> is acceptable. Valid options are: 
<dl class="description"> <dt id="M5">
<b>chan blocked </b><i>channelId</i>
</dt>
<dd> This tests whether the last input operation on the channel called <i>channelId</i> failed because it would have otherwise caused the process to block, and returns 1 if that was the case. It returns 0 otherwise. Note that this only ever returns 1 when the channel has been configured to be non-blocking; all Tcl channels have blocking turned on by default. 
</dd>
<dt id="M6">
<b>chan close </b><i>channelId</i> ?<i>direction</i>?</dt>
<dd> Close and destroy the channel called <i>channelId</i>. Note that this deletes all existing file-events registered on the channel. If the <i>direction</i> argument (which must be <b><a href="read.htm">read</a></b> or <b>write</b> or any unique abbreviation of them) is present, the channel will only be half-closed, so that it can go from being read-write to write-only or read-only respectively. If a read-only channel is closed for reading, it is the same as if the channel is fully closed, and respectively similar for write-only channels. Without the <i>direction</i> argument, the channel is closed for both reading and writing (but only if those directions are currently open). It is an error to close a read-only channel for writing, or a write-only channel for reading. <p> As part of closing the channel, all buffered output is flushed to the channel's output device (only if the channel is ceasing to be writable), any buffered input is discarded (only if the channel is ceasing to be readable), the underlying operating system resource is closed and <i>channelId</i> becomes unavailable for future use (both only if the channel is being completely closed). </p>
<p> If the channel is blocking and the channel is ceasing to be writable, the command does not return until all output is flushed. If the channel is non-blocking and there is unflushed output, the channel remains open and the command returns immediately; output will be flushed in the background and the channel will be closed when all the flushing is complete. </p>
<p> If <i>channelId</i> is a blocking channel for a command pipeline then <b>chan close</b> waits for the child processes to complete. </p>
<p> If the channel is shared between interpreters, then <b>chan close</b> makes <i>channelId</i> unavailable in the invoking interpreter but has no other effect until all of the sharing interpreters have closed the channel. When the last interpreter in which the channel is registered invokes <b>chan close</b> (or <b><a href="close.htm">close</a></b>), the cleanup actions described above occur. With half-closing, the half-close of the channel only applies to the current interpreter's view of the channel until all channels have closed it in that direction (or completely). See the <b><a href="interp.htm">interp</a></b> command for a description of channel sharing. </p>
<p> Channels are automatically fully closed when an interpreter is destroyed and when the process exits. Channels are switched to blocking mode, to ensure that all output is correctly flushed before the process exits. </p>
<p> The command returns an empty string, and may generate an error if an error occurs while flushing output. If a command in a command pipeline created with <b><a href="open.htm">open</a></b> returns an error, <b>chan close</b> generates an error (similar to the <b><a href="exec.htm">exec</a></b> command.) </p>
<p>Note that half-closes of sockets and command pipelines can have important side effects because they result in a shutdown() or close() of the underlying system resource, which can change how other processes or systems respond to the Tcl program. </p>

</dd>
<dt id="M7">
<b>chan configure </b><i>channelId</i> ?<i>optionName</i>? ?<i>value</i>? ?<i>optionName value</i>?...</dt>
<dd> Query or set the configuration options of the channel named <i>channelId</i>. <p> If no <i>optionName</i> or <i>value</i> arguments are supplied, the command returns a list containing alternating option names and values for the channel. If <i>optionName</i> is supplied but no <i>value</i> then the command returns the current value of the given option. If one or more pairs of <i>optionName</i> and <i>value</i> are supplied, the command sets each of the named options to the corresponding <i>value</i>; in this case the return value is an empty string. </p>
<p> The options described below are supported for all channels. In addition, each channel type may add options that only it supports. See the manual entry for the command that creates each type of channel for the options supported by that specific type of channel. For example, see the manual entry for the <b><a href="socket.htm">socket</a></b> command for additional options for sockets, and the <b><a href="open.htm">open</a></b> command for additional options for serial devices. </p>

<dl class="description"> <dt id="M8">
<b>-blocking</b> <i>boolean</i>
</dt>
<dd> The <b>-blocking</b> option determines whether I/O operations on the channel can cause the process to block indefinitely. The value of the option must be a proper boolean value. Channels are normally in blocking mode; if a channel is placed into non-blocking mode it will affect the operation of the <b>chan gets</b>, <b>chan read</b>, <b>chan puts</b>, <b>chan flush</b>, and <b>chan close</b> commands; see the documentation for those commands for details. For non-blocking mode to work correctly, the application must be using the Tcl event loop (e.g. by calling <b><a href="https://www.tcl.tk/man/tcl/TclLib/DoOneEvent.htm">Tcl_DoOneEvent</a></b> or invoking the <b><a href="vwait.htm">vwait</a></b> command). 
</dd>
<dt id="M9">
<b>-buffering</b> <i>newValue</i>
</dt>
<dd> If <i>newValue</i> is <b>full</b> then the I/O system will buffer output until its internal buffer is full or until the <b>chan flush</b> command is invoked. If <i>newValue</i> is <b>line</b>, then the I/O system will automatically flush output for the channel whenever a newline character is output. If <i>newValue</i> is <b>none</b>, the I/O system will flush automatically after every output operation. The default is for <b>-buffering</b> to be set to <b>full</b> except for channels that connect to terminal-like devices; for these channels the initial setting is <b>line</b>. Additionally, <b><a href="https://www.tcl.tk/man/tcl/TclLib/GetStdChan.htm">stdin</a></b> and <b><a href="https://www.tcl.tk/man/tcl/TclLib/GetStdChan.htm">stdout</a></b> are initially set to <b>line</b>, and <b><a href="https://www.tcl.tk/man/tcl/TclLib/GetStdChan.htm">stderr</a></b> is set to <b>none</b>. 
</dd>
<dt id="M10">
<b>-buffersize</b> <i>newSize</i>
</dt>
<dd> <i>Newvalue</i> must be an integer; its value is used to set the size of buffers, in bytes, subsequently allocated for this channel to store input or output. <i>Newvalue</i> must be a number of no more than one million, allowing buffers of up to one million bytes in size. 
</dd>
<dt id="M11">
<b>-encoding</b> <i>name</i>
</dt>
<dd> This option is used to specify the encoding of the channel as one of the named encodings returned by <b><a href="encoding.htm">encoding names</a></b> or the special value <b><a href="binary.htm">binary</a></b>, so that the data can be converted to and from Unicode for use in Tcl. For instance, in order for Tcl to read characters from a Japanese file in <b>shiftjis</b> and properly process and display the contents, the encoding would be set to <b>shiftjis</b>. Thereafter, when reading from the channel, the bytes in the Japanese file would be converted to Unicode as they are read. Writing is also supported - as Tcl strings are written to the channel they will automatically be converted to the specified encoding on output. <p> If a file contains pure binary data (for instance, a JPEG image), the encoding for the channel should be configured to be <b><a href="binary.htm">binary</a></b>. Tcl will then assign no interpretation to the data in the file and simply read or write raw bytes. The Tcl <b><a href="binary.htm">binary</a></b> command can be used to manipulate this byte-oriented data. It is usually better to set the <b>-translation</b> option to <b><a href="binary.htm">binary</a></b> when you want to transfer binary data, as this turns off the other automatic interpretations of the bytes in the stream as well. </p>
<p>The default encoding for newly opened channels is the same platform- and locale-dependent system encoding used for interfacing with the operating system, as returned by <b><a href="encoding.htm">encoding system</a></b>. </p>

</dd>
<dt id="M12">
<b>-eofchar</b> <i>char</i>
</dt>

<dt id="M13">
<b>-eofchar</b> <b>{</b><i>inChar outChar</i><b>}</b>
</dt>
<dd> This option supports DOS file systems that use Control-z (\x1a) as an end of file marker. If <i>char</i> is not an empty string, then this character signals end-of-file when it is encountered during input. For output, the end-of-file character is output when the channel is closed. If <i>char</i> is the empty string, then there is no special end of file character marker. For read-write channels, a two-element list specifies the end of file marker for input and output, respectively. As a convenience, when setting the end-of-file character for a read-write channel you can specify a single value that will apply to both reading and writing. When querying the end-of-file character of a read-write channel, a two-element list will always be returned. The default value for <b>-eofchar</b> is the empty string in all cases except for files under Windows. In that case the <b>-eofchar</b> is Control-z (\x1a) for reading and the empty string for writing. The acceptable range for <b>-eofchar</b> values is \x01 - \x7f; attempting to set <b>-eofchar</b> to a value outside of this range will generate an error. 
</dd>
<dt id="M14">
<b>-translation</b> <i>mode</i>
</dt>

<dt id="M15">
<b>-translation</b> <b>{</b><i>inMode outMode</i><b>}</b>
</dt>
<dd> In Tcl scripts the end of a line is always represented using a single newline character (\n). However, in actual files and devices the end of a line may be represented differently on different platforms, or even for different devices on the same platform. For example, under UNIX newlines are used in files, whereas carriage-return-linefeed sequences are normally used in network connections. On input (i.e., with <b>chan gets</b> and <b>chan read</b>) the Tcl I/O system automatically translates the external end-of-line representation into newline characters. Upon output (i.e., with <b>chan puts</b>), the I/O system translates newlines to the external end-of-line representation. The default translation mode, <b>auto</b>, handles all the common cases automatically, but the <b>-translation</b> option provides explicit control over the end of line translations. <p> The value associated with <b>-translation</b> is a single item for read-only and write-only channels. The value is a two-element list for read-write channels; the read translation mode is the first element of the list, and the write translation mode is the second element. As a convenience, when setting the translation mode for a read-write channel you can specify a single value that will apply to both reading and writing. When querying the translation mode of a read-write channel, a two-element list will always be returned. The following values are currently supported: </p>

<dl class="description"> <dt id="M16"><b>auto</b></dt>
<dd> As the input translation mode, <b>auto</b> treats any of newline (<b>lf</b>), carriage return (<b>cr</b>), or carriage return followed by a newline (<b>crlf</b>) as the end of line representation. The end of line representation can even change from line-to-line, and all cases are translated to a newline. As the output translation mode, <b>auto</b> chooses a platform specific representation; for sockets on all platforms Tcl chooses <b>crlf</b>, for all Unix flavors, it chooses <b>lf</b>, and for the various flavors of Windows it chooses <b>crlf</b>. The default setting for <b>-translation</b> is <b>auto</b> for both input and output. 
</dd>
<dt id="M17"><b>binary</b></dt>
<dd> No end-of-line translations are performed. This is nearly identical to <b>lf</b> mode, except that in addition <b><a href="binary.htm">binary</a></b> mode also sets the end-of-file character to the empty string (which disables it) and sets the encoding to <b><a href="binary.htm">binary</a></b> (which disables encoding filtering). See the description of <b>-eofchar</b> and <b>-encoding</b> for more information. 
</dd>
<dt id="M18"><b>cr</b></dt>
<dd> The end of a line in the underlying file or device is represented by a single carriage return character. As the input translation mode, <b>cr</b> mode converts carriage returns to newline characters. As the output translation mode, <b>cr</b> mode translates newline characters to carriage returns. 
</dd>
<dt id="M19"><b>crlf</b></dt>
<dd> The end of a line in the underlying file or device is represented by a carriage return character followed by a linefeed character. As the input translation mode, <b>crlf</b> mode converts carriage-return-linefeed sequences to newline characters. As the output translation mode, <b>crlf</b> mode translates newline characters to carriage-return-linefeed sequences. This mode is typically used on Windows platforms and for network connections. 
</dd>
<dt id="M20"><b>lf</b></dt>
<dd> The end of a line in the underlying file or device is represented by a single newline (linefeed) character. In this mode no translations occur during either input or output. This mode is typically used on UNIX platforms. 
</dd>
</dl> 
</dd>
</dl> 
</dd>
<dt id="M21">
<b>chan copy </b><i>inputChan outputChan</i> ?<b>-size </b><i>size</i>? ?<b>-command </b><i>callback</i>?</dt>
<dd> Copy data from the channel <i>inputChan</i>, which must have been opened for reading, to the channel <i>outputChan</i>, which must have been opened for writing. The <b>chan copy</b> command leverages the buffering in the Tcl I/O system to avoid extra copies and to avoid buffering too much data in main memory when copying large files to slow destinations like network sockets. <p> The <b>chan copy</b> command transfers data from <i>inputChan</i> until end of file or <i>size</i> bytes or characters have been transferred; <i>size</i> is in bytes if the two channels are using the same encoding, and is in characters otherwise. If no <b>-size</b> argument is given, then the copy goes until end of file. All the data read from <i>inputChan</i> is copied to <i>outputChan</i>. Without the <b>-command</b> option, <b>chan copy</b> blocks until the copy is complete and returns the number of bytes or characters (using the same rules as for the <b>-size</b> option) written to <i>outputChan</i>. </p>
<p> The <b>-command</b> argument makes <b>chan copy</b> work in the background. In this case it returns immediately and the <i>callback</i> is invoked later when the copy completes. The <i>callback</i> is called with one or two additional arguments that indicates how many bytes were written to <i>outputChan</i>. If an error occurred during the background copy, the second argument is the error string associated with the error. With a background copy, it is not necessary to put <i>inputChan</i> or <i>outputChan</i> into non-blocking mode; the <b>chan copy</b> command takes care of that automatically. However, it is necessary to enter the event loop by using the <b><a href="vwait.htm">vwait</a></b> command or by using Tk. </p>
<p> You are not allowed to do other I/O operations with <i>inputChan</i> or <i>outputChan</i> during a background <b>chan copy</b>. If either <i>inputChan</i> or <i>outputChan</i> get closed while the copy is in progress, the current copy is stopped and the command callback is <i>not</i> made. If <i>inputChan</i> is closed, then all data already queued for <i>outputChan</i> is written out. </p>
<p> Note that <i>inputChan</i> can become readable during a background copy. You should turn off any <b>chan event</b> or <b><a href="fileevent.htm">fileevent</a></b> handlers during a background copy so those handlers do not interfere with the copy. Any I/O attempted by a <b>chan event</b> or <b><a href="fileevent.htm">fileevent</a></b> handler will get a “channel busy” error. </p>
<p> <b>Chan copy</b> translates end-of-line sequences in <i>inputChan</i> and <i>outputChan</i> according to the <b>-translation</b> option for these channels (see <b>chan configure</b> above). The translations mean that the number of bytes read from <i>inputChan</i> can be different than the number of bytes written to <i>outputChan</i>. Only the number of bytes written to <i>outputChan</i> is reported, either as the return value of a synchronous <b>chan copy</b> or as the argument to the callback for an asynchronous <b>chan copy</b>. </p>
<p><b>Chan copy</b> obeys the encodings and character translations configured for the channels. This means that the incoming characters are converted internally first UTF-8 and then into the encoding of the channel <b>chan copy</b> writes to (see <b>chan configure</b> above for details on the <b>-encoding</b> and <b>-translation</b> options). No conversion is done if both channels are set to encoding <b><a href="binary.htm">binary</a></b> and have matching translations. If only the output channel is set to encoding <b><a href="binary.htm">binary</a></b> the system will write the internal UTF-8 representation of the incoming characters. If only the input channel is set to encoding <b><a href="binary.htm">binary</a></b> the system will assume that the incoming bytes are valid UTF-8 characters and convert them according to the output encoding. The behaviour of the system for bytes which are not valid UTF-8 characters is undefined in this case. </p>

</dd>
<dt id="M22">
<b>chan create </b><i>mode cmdPrefix</i>
</dt>
<dd> This subcommand creates a new script level channel using the command prefix <i>cmdPrefix</i> as its handler. Any such channel is called a <b>reflected</b> channel. The specified command prefix, <b>cmdPrefix</b>, must be a non-empty list, and should provide the API described in the <b><a href="refchan.htm">refchan</a></b> manual page. The handle of the new channel is returned as the result of the <b>chan create</b> command, and the channel is open. Use either <b><a href="close.htm">close</a></b> or <b>chan close</b> to remove the channel. <p> The argument <i>mode</i> specifies if the new channel is opened for reading, writing, or both. It has to be a list containing any of the strings “<b><a href="read.htm">read</a></b>” or “<b>write</b>”. The list must have at least one element, as a channel you can neither write to nor read from makes no sense. The handler command for the new channel must support the chosen mode, or an error is thrown. </p>
<p> The command prefix is executed in the global namespace, at the top of call stack, following the appending of arguments as described in the <b><a href="refchan.htm">refchan</a></b> manual page. Command resolution happens at the time of the call. Renaming the command, or destroying it means that the next call of a handler method may fail, causing the channel command invoking the handler to fail as well. Depending on the subcommand being invoked, the error message may not be able to explain the reason for that failure. </p>
<p> Every channel created with this subcommand knows which interpreter it was created in, and only ever executes its handler command in that interpreter, even if the channel was shared with and/or was moved into a different interpreter. Each reflected channel also knows the thread it was created in, and executes its handler command only in that thread, even if the channel was moved into a different thread. To this end all invocations of the handler are forwarded to the original thread by posting special events to it. This means that the original thread (i.e. the thread that executed the <b>chan create</b> command) must have an active event loop, i.e. it must be able to process such events. Otherwise the thread sending them will <i>block indefinitely</i>. Deadlock may occur. </p>
<p> Note that this permits the creation of a channel whose two endpoints live in two different threads, providing a stream-oriented bridge between these threads. In other words, we can provide a way for regular stream communication between threads instead of having to send commands. </p>
<p> When a thread or interpreter is deleted, all channels created with this subcommand and using this thread/interpreter as their computing base are deleted as well, in all interpreters they have been shared with or moved into, and in whatever thread they have been transferred to. While this pulls the rug out under the other thread(s) and/or interpreter(s), this cannot be avoided. Trying to use such a channel will cause the generation of a regular error about unknown channel handles. </p>
<p>This subcommand is <b><a href="safe.htm">safe</a></b> and made accessible to safe interpreters. While it arranges for the execution of arbitrary Tcl code the system also makes sure that the code is always executed within the safe interpreter. </p>

</dd>
<dt id="M23">
<b>chan eof </b><i>channelId</i>
</dt>
<dd> Test whether the last input operation on the channel called <i>channelId</i> failed because the end of the data stream was reached, returning 1 if end-of-file was reached, and 0 otherwise. 
</dd>
<dt id="M24">
<b>chan event </b><i>channelId event</i> ?<i>script</i>?</dt>
<dd> Arrange for the Tcl script <i>script</i> to be installed as a <i>file event handler</i> to be called whenever the channel called <i>channelId</i> enters the state described by <i>event</i> (which must be either <b>readable</b> or <b>writable</b>); only one such handler may be installed per event per channel at a time. If <i>script</i> is the empty string, the current handler is deleted (this also happens if the channel is closed or the interpreter deleted). If <i>script</i> is omitted, the currently installed script is returned (or an empty string if no such handler is installed). The callback is only performed if the event loop is being serviced (e.g. via <b><a href="vwait.htm">vwait</a></b> or <b><a href="update.htm">update</a></b>). <p> A file event handler is a binding between a channel and a script, such that the script is evaluated whenever the channel becomes readable or writable. File event handlers are most commonly used to allow data to be received from another process on an event-driven basis, so that the receiver can continue to interact with the user or with other channels while waiting for the data to arrive. If an application invokes <b>chan gets</b> or <b>chan read</b> on a blocking channel when there is no input data available, the process will block; until the input data arrives, it will not be able to service other events, so it will appear to the user to “freeze up”. With <b>chan event</b>, the process can tell when data is present and only invoke <b>chan gets</b> or <b>chan read</b> when they will not block. </p>
<p> A channel is considered to be readable if there is unread data available on the underlying device. A channel is also considered to be readable if there is unread data in an input buffer, except in the special case where the most recent attempt to read from the channel was a <b>chan gets</b> call that could not find a complete line in the input buffer. This feature allows a file to be read a line at a time in non-blocking mode using events. A channel is also considered to be readable if an end of file or error condition is present on the underlying file or device. It is important for <i>script</i> to check for these conditions and handle them appropriately; for example, if there is no special check for end of file, an infinite loop may occur where <i>script</i> reads no data, returns, and is immediately invoked again. </p>
<p> A channel is considered to be writable if at least one byte of data can be written to the underlying file or device without blocking, or if an error condition is present on the underlying file or device. Note that client sockets opened in asynchronous mode become writable when they become connected or if the connection fails. </p>
<p> Event-driven I/O works best for channels that have been placed into non-blocking mode with the <b>chan configure</b> command. In blocking mode, a <b>chan puts</b> command may block if you give it more data than the underlying file or device can accept, and a <b>chan gets</b> or <b>chan read</b> command will block if you attempt to read more data than is ready; no events will be processed while the commands block. In non-blocking mode <b>chan puts</b>, <b>chan read</b>, and <b>chan gets</b> never block. </p>
<p>The script for a file event is executed at global level (outside the context of any Tcl procedure) in the interpreter in which the <b>chan event</b> command was invoked. If an error occurs while executing the script then the command registered with <b><a href="interp.htm">interp bgerror</a></b> is used to report the error. In addition, the file event handler is deleted if it ever returns an error; this is done in order to prevent infinite loops due to buggy handlers. </p>

</dd>
<dt id="M25">
<b>chan flush </b><i>channelId</i>
</dt>
<dd> Ensures that all pending output for the channel called <i>channelId</i> is written. <p> If the channel is in blocking mode the command does not return until all the buffered output has been flushed to the channel. If the channel is in non-blocking mode, the command may return before all buffered output has been flushed; the remainder will be flushed in the background as fast as the underlying file or device is able to absorb it. </p>

</dd>
<dt id="M26">
<b>chan gets </b><i>channelId</i> ?<i>varName</i>?</dt>
<dd> Reads the next line from the channel called <i>channelId</i>. If <i>varName</i> is not specified, the result of the command will be the line that has been read (without a trailing newline character) or an empty string upon end-of-file or, in non-blocking mode, if the data available is exhausted. If <i>varName</i> is specified, the line that has been read will be written to the variable called <i>varName</i> and result will be the number of characters that have been read or -1 if end-of-file was reached or, in non-blocking mode, if the data available is exhausted. <p> If an end-of-file occurs while part way through reading a line, the partial line will be returned (or written into <i>varName</i>). When <i>varName</i> is not specified, the end-of-file case can be distinguished from an empty line using the <b>chan eof</b> command, and the partial-line-but-non-blocking case can be distinguished with the <b>chan blocked</b> command. </p>

</dd>
<dt id="M27">
<b>chan names</b> ?<i>pattern</i>?</dt>
<dd> Produces a list of all channel names. If <i>pattern</i> is specified, only those channel names that match it (according to the rules of <b><a href="string.htm">string match</a></b>) will be returned. 
</dd>
<dt id="M28">
<b>chan pending </b><i>mode channelId</i>
</dt>
<dd> Depending on whether <i>mode</i> is <b>input</b> or <b>output</b>, returns the number of bytes of input or output (respectively) currently buffered internally for <i>channelId</i> (especially useful in a readable event callback to impose application-specific limits on input line lengths to avoid a potential denial-of-service attack where a hostile user crafts an extremely long line that exceeds the available memory to buffer it). Returns -1 if the channel was not opened for the mode in question. 
</dd>
<dt id="M29"><b>chan pipe</b></dt>
<dd> Creates a standalone pipe whose read- and write-side channels are returned as a 2-element list, the first element being the read side and the second the write side. Can be useful e.g. to redirect separately <b><a href="https://www.tcl.tk/man/tcl/TclLib/GetStdChan.htm">stderr</a></b> and <b><a href="https://www.tcl.tk/man/tcl/TclLib/GetStdChan.htm">stdout</a></b> from a subprocess. To do this, spawn with "2&gt;@" or "&gt;@" redirection operators onto the write side of a pipe, and then immediately close it in the parent. This is necessary to get an EOF on the read side once the child has exited or otherwise closed its output. <p> Note that the pipe buffering semantics can vary at the operating system level substantially; it is not safe to assume that a write performed on the output side of the pipe will appear instantly to the input side. This is a fundamental difference and Tcl cannot conceal it. The overall stream semantics <i>are</i> compatible, so blocking reads and writes will not see most of the differences, but the details of what exactly gets written when are not. This is most likely to show up when using pipelines for testing; care should be taken to ensure that deadlocks do not occur and that potential short reads are allowed for. </p>

</dd>
<dt id="M30">
<b>chan pop </b><i>channelId</i>
</dt>
<dd> Removes the topmost transformation from the channel <i>channelId</i>, if there is any. If there are no transformations added to <i>channelId</i>, this is equivalent to <b>chan close</b> of that channel. The result is normally the empty string, but can be an error in some situations (i.e. where the underlying system stream is closed and that results in an error). 
</dd>
<dt id="M31">
<b>chan postevent </b><i>channelId eventSpec</i>
</dt>
<dd> This subcommand is used by command handlers specified with <b>chan create</b>. It notifies the channel represented by the handle <i>channelId</i> that the event(s) listed in the <i>eventSpec</i> have occurred. The argument has to be a list containing any of the strings <b><a href="read.htm">read</a></b> and <b>write</b>. The list must contain at least one element as it does not make sense to invoke the command if there are no events to post. <p> Note that this subcommand can only be used with channel handles that were created/opened by <b>chan create</b>. All other channels will cause this subcommand to report an error. </p>
<p> As only the Tcl level of a channel, i.e. its command handler, should post events to it we also restrict the usage of this command to the interpreter that created the channel. In other words, posting events to a reflected channel from an interpreter that does not contain it's implementation is not allowed. Attempting to post an event from any other interpreter will cause this subcommand to report an error. </p>
<p> Another restriction is that it is not possible to post events that the I/O core has not registered an interest in. Trying to do so will cause the method to throw an error. See the command handler method <b>watch</b> described in <b><a href="refchan.htm">refchan</a></b>, the document specifying the API of command handlers for reflected channels. </p>
<p>This command is <b><a href="safe.htm">safe</a></b> and made accessible to safe interpreters. It can trigger the execution of <b>chan event</b> handlers, whether in the current interpreter or in other interpreters or other threads, even where the event is posted from a safe interpreter and listened for by a trusted interpreter. <b>Chan event</b> handlers are <i>always</i> executed in the interpreter that set them up. </p>

</dd>
<dt id="M32">
<b>chan push </b><i>channelId cmdPrefix</i>
</dt>
<dd> Adds a new transformation on top of the channel <i>channelId</i>. The <i>cmdPrefix</i> argument describes a list of one or more words which represent a handler that will be used to implement the transformation. The command prefix must provide the API described in the <b><a href="transchan.htm">transchan</a></b> manual page. The result of this subcommand is a handle to the transformation. Note that it is important to make sure that the transformation is capable of supporting the channel mode that it is used with or this can make the channel neither readable nor writable. 
</dd>
<dt id="M33">
<b>chan puts</b> ?<b>-nonewline</b>? ?<i>channelId</i>? <i>string</i>
</dt>
<dd> Writes <i>string</i> to the channel named <i>channelId</i> followed by a newline character. A trailing newline character is written unless the optional flag <b>-nonewline</b> is given. If <i>channelId</i> is omitted, the string is written to the standard output channel, <b><a href="https://www.tcl.tk/man/tcl/TclLib/GetStdChan.htm">stdout</a></b>. <p> Newline characters in the output are translated by <b>chan puts</b> to platform-specific end-of-line sequences according to the currently configured value of the <b>-translation</b> option for the channel (for example, on PCs newlines are normally replaced with carriage-return-linefeed sequences; see <b>chan configure</b> above for details). </p>
<p> Tcl buffers output internally, so characters written with <b>chan puts</b> may not appear immediately on the output file or device; Tcl will normally delay output until the buffer is full or the channel is closed. You can force output to appear immediately with the <b>chan flush</b> command. </p>
<p>When the output buffer fills up, the <b>chan puts</b> command will normally block until all the buffered data has been accepted for output by the operating system. If <i>channelId</i> is in non-blocking mode then the <b>chan puts</b> command will not block even if the operating system cannot accept the data. Instead, Tcl continues to buffer the data and writes it in the background as fast as the underlying file or device can accept it. The application must use the Tcl event loop for non-blocking output to work; otherwise Tcl never finds out that the file or device is ready for more output data. It is possible for an arbitrarily large amount of data to be buffered for a channel in non-blocking mode, which could consume a large amount of memory. To avoid wasting memory, non-blocking I/O should normally be used in an event-driven fashion with the <b>chan event</b> command (do not invoke <b>chan puts</b> unless you have recently been notified via a file event that the channel is ready for more output data). </p>

</dd>
<dt id="M34">
<b>chan read </b><i>channelId</i> ?<i>numChars</i>?</dt>

<dt id="M35">
<b>chan read </b>?<b>-nonewline</b>? <i>channelId</i>
</dt>
<dd> In the first form, the result will be the next <i>numChars</i> characters read from the channel named <i>channelId</i>; if <i>numChars</i> is omitted, all characters up to the point when the channel would signal a failure (whether an end-of-file, blocked or other error condition) are read. In the second form (i.e. when <i>numChars</i> has been omitted) the flag <b>-nonewline</b> may be given to indicate that any trailing newline in the string that has been read should be trimmed. <p> If <i>channelId</i> is in non-blocking mode, <b>chan read</b> may not read as many characters as requested: once all available input has been read, the command will return the data that is available rather than blocking for more input. If the channel is configured to use a multi-byte encoding, then there may actually be some bytes remaining in the internal buffers that do not form a complete character. These bytes will not be returned until a complete character is available or end-of-file is reached. The <b>-nonewline</b> switch is ignored if the command returns before reaching the end of the file. </p>
<p> <b>Chan read</b> translates end-of-line sequences in the input into newline characters according to the <b>-translation</b> option for the channel (see <b>chan configure</b> above for a discussion on the ways in which <b>chan configure</b> will alter input). </p>
<p> When reading from a serial port, most applications should configure the serial port channel to be non-blocking, like this: </p>

<pre><b>chan configure </b><i>channelId </i><b>-blocking </b><i>0</i>.</pre> <p> Then <b>chan read</b> behaves much like described above. Note that most serial ports are comparatively slow; it is entirely possible to get a <b>readable</b> event for each character read from them. Care must be taken when using <b>chan read</b> on blocking serial ports: </p>

<dl class="description"> <dt id="M36">
<b>chan read </b><i>channelId numChars</i>
</dt>
<dd> In this form <b>chan read</b> blocks until <i>numChars</i> have been received from the serial port. 
</dd>
<dt id="M37">
<b>chan read </b><i>channelId</i>
</dt>
<dd> In this form <b>chan read</b> blocks until the reception of the end-of-file character, see <b>chan configure -eofchar</b>. If there no end-of-file character has been configured for the channel, then <b>chan read</b> will block forever. 
</dd>
</dl> 
</dd>
<dt id="M38">
<b>chan seek </b><i>channelId offset</i> ?<i>origin</i>?</dt>
<dd> Sets the current access position within the underlying data stream for the channel named <i>channelId</i> to be <i>offset</i> bytes relative to <i>origin</i>. <i>Offset</i> must be an integer (which may be negative) and <i>origin</i> must be one of the following: 
<dl class="description"> <dt id="M39"><b>start</b></dt>
<dd> The new access position will be <i>offset</i> bytes from the start of the underlying file or device. 
</dd>
<dt id="M40"><b>current</b></dt>
<dd> The new access position will be <i>offset</i> bytes from the current access position; a negative <i>offset</i> moves the access position backwards in the underlying file or device. 
</dd>
<dt id="M41"><b>end</b></dt>
<dd> The new access position will be <i>offset</i> bytes from the end of the file or device. A negative <i>offset</i> places the access position before the end of file, and a positive <i>offset</i> places the access position after the end of file. 
</dd>
</dl> <dl><dd> <p> The <i>origin</i> argument defaults to <b>start</b>. </p>
<p> <b>Chan seek</b> flushes all buffered output for the channel before the command returns, even if the channel is in non-blocking mode. It also discards any buffered and unread input. This command returns an empty string. An error occurs if this command is applied to channels whose underlying file or device does not support seeking. </p>
<p> Note that <i>offset</i> values are byte offsets, not character offsets. Both <b>chan seek</b> and <b>chan tell</b> operate in terms of bytes, not characters, unlike <b>chan read</b>. </p>
</dd></dl> 
</dd>
<dt id="M42">
<b>chan tell </b><i>channelId</i>
</dt>
<dd> Returns a number giving the current access position within the underlying data stream for the channel named <i>channelId</i>. This value returned is a byte offset that can be passed to <b>chan seek</b> in order to set the channel to a particular position. Note that this value is in terms of bytes, not characters like <b>chan read</b>. The value returned is -1 for channels that do not support seeking. 
</dd>
<dt id="M43">
<b>chan truncate </b><i>channelId</i> ?<i>length</i>?</dt>
<dd> Sets the byte length of the underlying data stream for the channel named <i>channelId</i> to be <i>length</i> (or to the current byte offset within the underlying data stream if <i>length</i> is omitted). The channel is flushed before truncation. 
</dd>
</dl> <h2 id="M44">Examples</h2> This opens a file using a known encoding (CP1252, a very common encoding on Windows), searches for a string, rewrites that part, and truncates the file after a further two lines. 
<pre>set f [open somefile.txt r+]
<b>chan configure</b> $f -encoding cp1252
set offset 0

<i># Search for string "FOOBAR" in the file</i>
while {[<b>chan gets</b> $f line] &gt;= 0} {
    set idx [string first FOOBAR $line]
    if {$idx &gt; -1} {
        <i># Found it; rewrite line</i>

        <b>chan seek</b> $f [expr {$offset + $idx}]
        <b>chan puts</b> -nonewline $f BARFOO

        <i># Skip to end of following line, and truncate</i>
        <b>chan gets</b> $f
        <b>chan gets</b> $f
        <b>chan truncate</b> $f

        <i># Stop searching the file now</i>
        break
    }

    <i># Save offset of start of next line for later</i>
    set offset [<b>chan tell</b> $f]
}
<b>chan close</b> $f</pre> <p> A network server that does echoing of its input line-by-line without preventing servicing of other connections at the same time. </p>

<pre># This is a very simple logger...
proc log {message} {
    <b>chan puts</b> stdout $message
}

# This is called whenever a new client connects to the server
proc connect {chan host port} {
    set clientName [format &lt;%s:%d&gt; $host $port]
    log "connection from $clientName"
    <b>chan configure</b> $chan -blocking 0 -buffering line
    <b>chan event</b> $chan readable [list echoLine $chan $clientName]
}

# This is called whenever either at least one byte of input
# data is available, or the channel was closed by the client.
proc echoLine {chan clientName} {
    <b>chan gets</b> $chan line
    if {[<b>chan eof</b> $chan]} {
        log "finishing connection from $clientName"
        <b>chan close</b> $chan
    } elseif {![<b>chan blocked</b> $chan]} {
        # Didn't block waiting for end-of-line
        log "$clientName - $line"
        <b>chan puts</b> $chan $line
    }
}

# Create the server socket and enter the event-loop to wait
# for incoming connections...
socket -server connect 12345
vwait forever</pre> <h2 id="M45">See also</h2> <b><a href="close.htm">close</a></b>, <b><a href="eof.htm">eof</a></b>, <b><a href="fblocked.htm">fblocked</a></b>, <b><a href="fconfigure.htm">fconfigure</a></b>, <b><a href="fcopy.htm">fcopy</a></b>, <b><a href="file.htm">file</a></b>, <b><a href="fileevent.htm">fileevent</a></b>, <b><a href="flush.htm">flush</a></b>, <b><a href="gets.htm">gets</a></b>, <b><a href="open.htm">open</a></b>, <b><a href="puts.htm">puts</a></b>, <b><a href="read.htm">read</a></b>, <b><a href="seek.htm">seek</a></b>, <b><a href="socket.htm">socket</a></b>, <b><a href="tell.htm">tell</a></b>, <b><a href="refchan.htm">refchan</a></b>, <b><a href="transchan.htm">transchan</a></b>   <div class="_attribution"><p class="_attribution-p">Copyright © 2005-2006 Donal K. Fellows </p></div>
<div class="_attribution">
  <p class="_attribution-p">
    Licensed under <a href="http://tcl.tk/software/tcltk/license.html">Tcl/Tk terms</a><br>
    <a href="https://www.tcl.tk/man/tcl/TclCmd/chan.htm" class="_attribution-link">https://www.tcl.tk/man/tcl/TclCmd/chan.htm</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
