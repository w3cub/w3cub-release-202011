
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Packages - CMake 3.19 - W3cubDocs</title>
  
  <meta name="description" content=" Using Packages ">
  <meta name="keywords" content="cmake-packages, packages, cmake, cmake~3.19">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cmake~3.19/manual/cmake-packages.7.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/cmake~3.19.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cmake~3.19/" class="_nav-link" title="" style="margin-left:0;">CMake 3.19</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _sphinx_simple">
				
				
<h1 id="cmake-packages-7">cmake-packages(7)</h1>   <ul> <li><a class="reference internal" href="#introduction" id="id9">Introduction</a></li> <li>
<p><a class="reference internal" href="#using-packages" id="id10">Using Packages</a></p> <ul> <li><a class="reference internal" href="#config-file-packages" id="id11">Config-file Packages</a></li> <li><a class="reference internal" href="#find-module-packages" id="id12">Find-module Packages</a></li> </ul> </li> <li>
<p><a class="reference internal" href="#package-layout" id="id13">Package Layout</a></p> <ul> <li><a class="reference internal" href="#package-configuration-file" id="id14">Package Configuration File</a></li> <li><a class="reference internal" href="#package-version-file" id="id15">Package Version File</a></li> </ul> </li> <li>
<p><a class="reference internal" href="#creating-packages" id="id16">Creating Packages</a></p> <ul> <li>
<p><a class="reference internal" href="#creating-a-package-configuration-file" id="id17">Creating a Package Configuration File</a></p> <ul> <li><a class="reference internal" href="#creating-a-package-configuration-file-for-the-build-tree" id="id18">Creating a Package Configuration File for the Build Tree</a></li> </ul> </li> <li><a class="reference internal" href="#creating-relocatable-packages" id="id19">Creating Relocatable Packages</a></li> </ul> </li> <li>
<p><a class="reference internal" href="#package-registry" id="id20">Package Registry</a></p> <ul> <li><a class="reference internal" href="#user-package-registry" id="id21">User Package Registry</a></li> <li><a class="reference internal" href="#system-package-registry" id="id22">System Package Registry</a></li> <li><a class="reference internal" href="#disabling-the-package-registry" id="id23">Disabling the Package Registry</a></li> <li><a class="reference internal" href="#package-registry-example" id="id24">Package Registry Example</a></li> <li><a class="reference internal" href="#package-registry-ownership" id="id25">Package Registry Ownership</a></li> </ul> </li> </ul>
   <h2 id="introduction">Introduction</h2> <p>Packages provide dependency information to CMake based buildsystems. Packages are found with the <a class="reference internal" href="../command/find_package#command:find_package" title="find_package" id="index-0-command:find_package"><code>find_package()</code></a> command. The result of using <a class="reference internal" href="../command/find_package#command:find_package" title="find_package" id="index-1-command:find_package"><code>find_package()</code></a> is either a set of <a class="reference internal" href="../prop_tgt/imported#prop_tgt:IMPORTED" title="IMPORTED" id="index-0-prop_tgt:IMPORTED"><code>IMPORTED</code></a> targets, or a set of variables corresponding to build-relevant information.</p>   <h2 id="using-packages">Using Packages</h2> <p>CMake provides direct support for two forms of packages, <a class="reference internal" href="#id1">Config-file Packages</a> and <a class="reference internal" href="#find-module-packages">Find-module Packages</a>. Indirect support for <code>pkg-config</code> packages is also provided via the <a class="reference internal" href="../module/findpkgconfig#module:FindPkgConfig" title="FindPkgConfig" id="index-0-module:FindPkgConfig"><code>FindPkgConfig</code></a> module. In all cases, the basic form of <a class="reference internal" href="../command/find_package#command:find_package" title="find_package" id="index-2-command:find_package"><code>find_package()</code></a> calls is the same:</p> <pre data-language="cmake">find_package(Qt4 4.7.0 REQUIRED) # CMake provides a Qt4 find-module
find_package(Qt5Core 5.1.0 REQUIRED) # Qt provides a Qt5 package config file.
find_package(LibXml2 REQUIRED) # Use pkg-config via the LibXml2 find-module
</pre> <p>In cases where it is known that a package configuration file is provided by upstream, and only that should be used, the <code>CONFIG</code> keyword may be passed to <a class="reference internal" href="../command/find_package#command:find_package" title="find_package" id="index-3-command:find_package"><code>find_package()</code></a>:</p> <pre data-language="cmake">find_package(Qt5Core 5.1.0 CONFIG REQUIRED)
find_package(Qt5Gui 5.1.0 CONFIG)
</pre> <p>Similarly, the <code>MODULE</code> keyword says to use only a find-module:</p> <pre data-language="cmake">find_package(Qt4 4.7.0 MODULE REQUIRED)
</pre> <p>Specifying the type of package explicitly improves the error message shown to the user if it is not found.</p> <p>Both types of packages also support specifying components of a package, either after the <code>REQUIRED</code> keyword:</p> <pre data-language="cmake">find_package(Qt5 5.1.0 CONFIG REQUIRED Widgets Xml Sql)
</pre> <p>or as a separate <code>COMPONENTS</code> list:</p> <pre data-language="cmake">find_package(Qt5 5.1.0 COMPONENTS Widgets Xml Sql)
</pre> <p>or as a separate <code>OPTIONAL_COMPONENTS</code> list:</p> <pre data-language="cmake">find_package(Qt5 5.1.0 COMPONENTS Widgets
                       OPTIONAL_COMPONENTS Xml Sql
)
</pre> <p>Handling of <code>COMPONENTS</code> and <code>OPTIONAL_COMPONENTS</code> is defined by the package.</p> <p>By setting the <a class="reference internal" href="#" title="CMAKE_DISABLE_FIND_PACKAGE_&lt;PackageName&gt;" id="index-0-variable:CMAKE_DISABLE_FIND_PACKAGE_&lt;PackageName&gt;"><code>CMAKE_DISABLE_FIND_PACKAGE_&lt;PackageName&gt;</code></a> variable to <code>TRUE</code>, the <code>&lt;PackageName&gt;</code> package will not be searched, and will always be <code>NOTFOUND</code>.</p>  <h3 id="id1">Config-file Packages</h3> <p id="config-file-packages">A config-file package is a set of files provided by upstreams for downstreams to use. CMake searches in a number of locations for package configuration files, as described in the <a class="reference internal" href="../command/find_package#command:find_package" title="find_package" id="index-4-command:find_package"><code>find_package()</code></a> documentation. The most simple way for a CMake user to tell <a class="reference internal" href="cmake.1#manual:cmake(1)" title="cmake(1)" id="index-0-manual:cmake(1)"><code>cmake(1)</code></a> to search in a non-standard prefix for a package is to set the <code>CMAKE_PREFIX_PATH</code> cache variable.</p> <p>Config-file packages are provided by upstream vendors as part of development packages, that is, they belong with the header files and any other files provided to assist downstreams in using the package.</p> <p>A set of variables which provide package status information are also set automatically when using a config-file package. The <code>&lt;PackageName&gt;_FOUND</code> variable is set to true or false, depending on whether the package was found. The <code>&lt;PackageName&gt;_DIR</code> cache variable is set to the location of the package configuration file.</p>   <h3 id="find-module-packages">Find-module Packages</h3> <p>A find module is a file with a set of rules for finding the required pieces of a dependency, primarily header files and libraries. Typically, a find module is needed when the upstream is not built with CMake, or is not CMake-aware enough to otherwise provide a package configuration file. Unlike a package configuration file, it is not shipped with upstream, but is used by downstream to find the files by guessing locations of files with platform-specific hints.</p> <p>Unlike the case of an upstream-provided package configuration file, no single point of reference identifies the package as being found, so the <code>&lt;PackageName&gt;_FOUND</code> variable is not automatically set by the <a class="reference internal" href="../command/find_package#command:find_package" title="find_package" id="index-5-command:find_package"><code>find_package()</code></a> command. It can still be expected to be set by convention however and should be set by the author of the Find-module. Similarly there is no <code>&lt;PackageName&gt;_DIR</code> variable, but each of the artifacts such as library locations and header file locations provide a separate cache variable.</p> <p>See the <a class="reference internal" href="cmake-developer.7#manual:cmake-developer(7)" title="cmake-developer(7)" id="index-0-manual:cmake-developer(7)"><code>cmake-developer(7)</code></a> manual for more information about creating Find-module files.</p>    <h2 id="package-layout">Package Layout</h2> <p>A config-file package consists of a <a class="reference internal" href="#package-configuration-file">Package Configuration File</a> and optionally a <a class="reference internal" href="#package-version-file">Package Version File</a> provided with the project distribution.</p>  <h3 id="package-configuration-file">Package Configuration File</h3> <p>Consider a project <code>Foo</code> that installs the following files:</p> <pre data-language="none">&lt;prefix&gt;/include/foo-1.2/foo.h
&lt;prefix&gt;/lib/foo-1.2/libfoo.a
</pre> <p>It may also provide a CMake package configuration file:</p> <pre data-language="none">&lt;prefix&gt;/lib/cmake/foo-1.2/FooConfig.cmake
</pre> <p>with content defining <a class="reference internal" href="../prop_tgt/imported#prop_tgt:IMPORTED" title="IMPORTED" id="index-1-prop_tgt:IMPORTED"><code>IMPORTED</code></a> targets, or defining variables, such as:</p> <pre data-language="cmake"># ...
# (compute PREFIX relative to file location)
# ...
set(Foo_INCLUDE_DIRS ${PREFIX}/include/foo-1.2)
set(Foo_LIBRARIES ${PREFIX}/lib/foo-1.2/libfoo.a)
</pre> <p>If another project wishes to use <code>Foo</code> it need only to locate the <code>FooConfig.cmake</code> file and load it to get all the information it needs about package content locations. Since the package configuration file is provided by the package installation it already knows all the file locations.</p> <p>The <a class="reference internal" href="../command/find_package#command:find_package" title="find_package" id="index-6-command:find_package"><code>find_package()</code></a> command may be used to search for the package configuration file. This command constructs a set of installation prefixes and searches under each prefix in several locations. Given the name <code>Foo</code>, it looks for a file called <code>FooConfig.cmake</code> or <code>foo-config.cmake</code>. The full set of locations is specified in the <a class="reference internal" href="../command/find_package#command:find_package" title="find_package" id="index-7-command:find_package"><code>find_package()</code></a> command documentation. One place it looks is:</p> <pre data-language="none">&lt;prefix&gt;/lib/cmake/Foo*/
</pre> <p>where <code>Foo*</code> is a case-insensitive globbing expression. In our example the globbing expression will match <code>&lt;prefix&gt;/lib/cmake/foo-1.2</code> and the package configuration file will be found.</p> <p>Once found, a package configuration file is immediately loaded. It, together with a package version file, contains all the information the project needs to use the package.</p>   <h3 id="package-version-file">Package Version File</h3> <p>When the <a class="reference internal" href="../command/find_package#command:find_package" title="find_package" id="index-8-command:find_package"><code>find_package()</code></a> command finds a candidate package configuration file it looks next to it for a version file. The version file is loaded to test whether the package version is an acceptable match for the version requested. If the version file claims compatibility the configuration file is accepted. Otherwise it is ignored.</p> <p>The name of the package version file must match that of the package configuration file but has either <code>-version</code> or <code>Version</code> appended to the name before the <code>.cmake</code> extension. For example, the files:</p> <pre data-language="none">&lt;prefix&gt;/lib/cmake/foo-1.3/foo-config.cmake
&lt;prefix&gt;/lib/cmake/foo-1.3/foo-config-version.cmake
</pre> <p>and:</p> <pre data-language="none">&lt;prefix&gt;/lib/cmake/bar-4.2/BarConfig.cmake
&lt;prefix&gt;/lib/cmake/bar-4.2/BarConfigVersion.cmake
</pre> <p>are each pairs of package configuration files and corresponding package version files.</p> <p>When the <a class="reference internal" href="../command/find_package#command:find_package" title="find_package" id="index-9-command:find_package"><code>find_package()</code></a> command loads a version file it first sets the following variables:</p> <dl class="simple"> <dt>
<code>PACKAGE_FIND_NAME</code> </dt>
<dd>
<p>The <code>&lt;PackageName&gt;</code></p> </dd> <dt>
<code>PACKAGE_FIND_VERSION</code> </dt>
<dd>
<p>Full requested version string</p> </dd> <dt>
<code>PACKAGE_FIND_VERSION_MAJOR</code> </dt>
<dd>
<p>Major version if requested, else 0</p> </dd> <dt>
<code>PACKAGE_FIND_VERSION_MINOR</code> </dt>
<dd>
<p>Minor version if requested, else 0</p> </dd> <dt>
<code>PACKAGE_FIND_VERSION_PATCH</code> </dt>
<dd>
<p>Patch version if requested, else 0</p> </dd> <dt>
<code>PACKAGE_FIND_VERSION_TWEAK</code> </dt>
<dd>
<p>Tweak version if requested, else 0</p> </dd> <dt>
<code>PACKAGE_FIND_VERSION_COUNT</code> </dt>
<dd>
<p>Number of version components, 0 to 4</p> </dd> </dl> <p>The version file must use these variables to check whether it is compatible or an exact match for the requested version and set the following variables with results:</p> <dl class="simple"> <dt>
<code>PACKAGE_VERSION</code> </dt>
<dd>
<p>Full provided version string</p> </dd> <dt>
<code>PACKAGE_VERSION_EXACT</code> </dt>
<dd>
<p>True if version is exact match</p> </dd> <dt>
<code>PACKAGE_VERSION_COMPATIBLE</code> </dt>
<dd>
<p>True if version is compatible</p> </dd> <dt>
<code>PACKAGE_VERSION_UNSUITABLE</code> </dt>
<dd>
<p>True if unsuitable as any version</p> </dd> </dl> <p>Version files are loaded in a nested scope so they are free to set any variables they wish as part of their computation. The find_package command wipes out the scope when the version file has completed and it has checked the output variables. When the version file claims to be an acceptable match for the requested version the find_package command sets the following variables for use by the project:</p> <dl class="simple"> <dt>
<code>&lt;PackageName&gt;_VERSION</code> </dt>
<dd>
<p>Full provided version string</p> </dd> <dt>
<code>&lt;PackageName&gt;_VERSION_MAJOR</code> </dt>
<dd>
<p>Major version if provided, else 0</p> </dd> <dt>
<code>&lt;PackageName&gt;_VERSION_MINOR</code> </dt>
<dd>
<p>Minor version if provided, else 0</p> </dd> <dt>
<code>&lt;PackageName&gt;_VERSION_PATCH</code> </dt>
<dd>
<p>Patch version if provided, else 0</p> </dd> <dt>
<code>&lt;PackageName&gt;_VERSION_TWEAK</code> </dt>
<dd>
<p>Tweak version if provided, else 0</p> </dd> <dt>
<code>&lt;PackageName&gt;_VERSION_COUNT</code> </dt>
<dd>
<p>Number of version components, 0 to 4</p> </dd> </dl> <p>The variables report the version of the package that was actually found. The <code>&lt;PackageName&gt;</code> part of their name matches the argument given to the <a class="reference internal" href="../command/find_package#command:find_package" title="find_package" id="index-10-command:find_package"><code>find_package()</code></a> command.</p>    <h2 id="id2">Creating Packages</h2> <p id="creating-packages">Usually, the upstream depends on CMake itself and can use some CMake facilities for creating the package files. Consider an upstream which provides a single shared library:</p> <pre data-language="cmake">project(UpstreamLib)

set(CMAKE_INCLUDE_CURRENT_DIR ON)
set(CMAKE_INCLUDE_CURRENT_DIR_IN_INTERFACE ON)

set(Upstream_VERSION 3.4.1)

include(GenerateExportHeader)

add_library(ClimbingStats SHARED climbingstats.cpp)
generate_export_header(ClimbingStats)
set_property(TARGET ClimbingStats PROPERTY VERSION ${Upstream_VERSION})
set_property(TARGET ClimbingStats PROPERTY SOVERSION 3)
set_property(TARGET ClimbingStats PROPERTY
  INTERFACE_ClimbingStats_MAJOR_VERSION 3)
set_property(TARGET ClimbingStats APPEND PROPERTY
  COMPATIBLE_INTERFACE_STRING ClimbingStats_MAJOR_VERSION
)

install(TARGETS ClimbingStats EXPORT ClimbingStatsTargets
  LIBRARY DESTINATION lib
  ARCHIVE DESTINATION lib
  RUNTIME DESTINATION bin
  INCLUDES DESTINATION include
)
install(
  FILES
    climbingstats.h
    "${CMAKE_CURRENT_BINARY_DIR}/climbingstats_export.h"
  DESTINATION
    include
  COMPONENT
    Devel
)

include(CMakePackageConfigHelpers)
write_basic_package_version_file(
  "${CMAKE_CURRENT_BINARY_DIR}/ClimbingStats/ClimbingStatsConfigVersion.cmake"
  VERSION ${Upstream_VERSION}
  COMPATIBILITY AnyNewerVersion
)

export(EXPORT ClimbingStatsTargets
  FILE "${CMAKE_CURRENT_BINARY_DIR}/ClimbingStats/ClimbingStatsTargets.cmake"
  NAMESPACE Upstream::
)
configure_file(cmake/ClimbingStatsConfig.cmake
  "${CMAKE_CURRENT_BINARY_DIR}/ClimbingStats/ClimbingStatsConfig.cmake"
  COPYONLY
)

set(ConfigPackageLocation lib/cmake/ClimbingStats)
install(EXPORT ClimbingStatsTargets
  FILE
    ClimbingStatsTargets.cmake
  NAMESPACE
    Upstream::
  DESTINATION
    ${ConfigPackageLocation}
)
install(
  FILES
    cmake/ClimbingStatsConfig.cmake
    "${CMAKE_CURRENT_BINARY_DIR}/ClimbingStats/ClimbingStatsConfigVersion.cmake"
  DESTINATION
    ${ConfigPackageLocation}
  COMPONENT
    Devel
)
</pre> <p>The <a class="reference internal" href="../module/cmakepackageconfighelpers#module:CMakePackageConfigHelpers" title="CMakePackageConfigHelpers" id="index-0-module:CMakePackageConfigHelpers"><code>CMakePackageConfigHelpers</code></a> module provides a macro for creating a simple <code>ConfigVersion.cmake</code> file. This file sets the version of the package. It is read by CMake when <a class="reference internal" href="../command/find_package#command:find_package" title="find_package" id="index-11-command:find_package"><code>find_package()</code></a> is called to determine the compatibility with the requested version, and to set some version-specific variables <code>&lt;PackageName&gt;_VERSION</code>, <code>&lt;PackageName&gt;_VERSION_MAJOR</code>, <code>&lt;PackageName&gt;_VERSION_MINOR</code> etc. The <a class="reference internal" href="../command/install#command:install" title="install" id="index-0-command:install"><code>install(EXPORT)</code></a> command is used to export the targets in the <code>ClimbingStatsTargets</code> export-set, defined previously by the <a class="reference internal" href="../command/install#command:install" title="install" id="index-1-command:install"><code>install(TARGETS)</code></a> command. This command generates the <code>ClimbingStatsTargets.cmake</code> file to contain <a class="reference internal" href="../prop_tgt/imported#prop_tgt:IMPORTED" title="IMPORTED" id="index-2-prop_tgt:IMPORTED"><code>IMPORTED</code></a> targets, suitable for use by downstreams and arranges to install it to <code>lib/cmake/ClimbingStats</code>. The generated <code>ClimbingStatsConfigVersion.cmake</code> and a <code>cmake/ClimbingStatsConfig.cmake</code> are installed to the same location, completing the package.</p> <p>The generated <a class="reference internal" href="../prop_tgt/imported#prop_tgt:IMPORTED" title="IMPORTED" id="index-3-prop_tgt:IMPORTED"><code>IMPORTED</code></a> targets have appropriate properties set to define their <a class="reference internal" href="cmake-buildsystem.7#target-usage-requirements"><span class="std std-ref">usage requirements</span></a>, such as <a class="reference internal" href="../prop_tgt/interface_include_directories#prop_tgt:INTERFACE_INCLUDE_DIRECTORIES" title="INTERFACE_INCLUDE_DIRECTORIES" id="index-0-prop_tgt:INTERFACE_INCLUDE_DIRECTORIES"><code>INTERFACE_INCLUDE_DIRECTORIES</code></a>, <a class="reference internal" href="../prop_tgt/interface_compile_definitions#prop_tgt:INTERFACE_COMPILE_DEFINITIONS" title="INTERFACE_COMPILE_DEFINITIONS" id="index-0-prop_tgt:INTERFACE_COMPILE_DEFINITIONS"><code>INTERFACE_COMPILE_DEFINITIONS</code></a> and other relevant built-in <code>INTERFACE_</code> properties. The <code>INTERFACE</code> variant of user-defined properties listed in <a class="reference internal" href="../prop_tgt/compatible_interface_string#prop_tgt:COMPATIBLE_INTERFACE_STRING" title="COMPATIBLE_INTERFACE_STRING" id="index-0-prop_tgt:COMPATIBLE_INTERFACE_STRING"><code>COMPATIBLE_INTERFACE_STRING</code></a> and other <a class="reference internal" href="cmake-buildsystem.7#compatible-interface-properties"><span class="std std-ref">Compatible Interface Properties</span></a> are also propagated to the generated <a class="reference internal" href="../prop_tgt/imported#prop_tgt:IMPORTED" title="IMPORTED" id="index-4-prop_tgt:IMPORTED"><code>IMPORTED</code></a> targets. In the above case, <code>ClimbingStats_MAJOR_VERSION</code> is defined as a string which must be compatible among the dependencies of any depender. By setting this custom defined user property in this version and in the next version of <code>ClimbingStats</code>, <a class="reference internal" href="cmake.1#manual:cmake(1)" title="cmake(1)" id="index-1-manual:cmake(1)"><code>cmake(1)</code></a> will issue a diagnostic if there is an attempt to use version 3 together with version 4. Packages can choose to employ such a pattern if different major versions of the package are designed to be incompatible.</p> <p>A <code>NAMESPACE</code> with double-colons is specified when exporting the targets for installation. This convention of double-colons gives CMake a hint that the name is an <a class="reference internal" href="../prop_tgt/imported#prop_tgt:IMPORTED" title="IMPORTED" id="index-5-prop_tgt:IMPORTED"><code>IMPORTED</code></a> target when it is used by downstreams with the <a class="reference internal" href="../command/target_link_libraries#command:target_link_libraries" title="target_link_libraries" id="index-0-command:target_link_libraries"><code>target_link_libraries()</code></a> command. This way, CMake can issue a diagnostic if the package providing it has not yet been found.</p> <p>In this case, when using <a class="reference internal" href="../command/install#command:install" title="install" id="index-2-command:install"><code>install(TARGETS)</code></a> the <code>INCLUDES DESTINATION</code> was specified. This causes the <code>IMPORTED</code> targets to have their <a class="reference internal" href="../prop_tgt/interface_include_directories#prop_tgt:INTERFACE_INCLUDE_DIRECTORIES" title="INTERFACE_INCLUDE_DIRECTORIES" id="index-1-prop_tgt:INTERFACE_INCLUDE_DIRECTORIES"><code>INTERFACE_INCLUDE_DIRECTORIES</code></a> populated with the <code>include</code> directory in the <a class="reference internal" href="../variable/cmake_install_prefix#variable:CMAKE_INSTALL_PREFIX" title="CMAKE_INSTALL_PREFIX" id="index-0-variable:CMAKE_INSTALL_PREFIX"><code>CMAKE_INSTALL_PREFIX</code></a>. When the <code>IMPORTED</code> target is used by downstream, it automatically consumes the entries from that property.</p>  <h3 id="creating-a-package-configuration-file">Creating a Package Configuration File</h3> <p>In this case, the <code>ClimbingStatsConfig.cmake</code> file could be as simple as:</p> <pre data-language="cmake">include("${CMAKE_CURRENT_LIST_DIR}/ClimbingStatsTargets.cmake")
</pre> <p>As this allows downstreams to use the <code>IMPORTED</code> targets. If any macros should be provided by the <code>ClimbingStats</code> package, they should be in a separate file which is installed to the same location as the <code>ClimbingStatsConfig.cmake</code> file, and included from there.</p> <p>This can also be extended to cover dependencies:</p> <pre data-language="cmake"># ...
add_library(ClimbingStats SHARED climbingstats.cpp)
generate_export_header(ClimbingStats)

find_package(Stats 2.6.4 REQUIRED)
target_link_libraries(ClimbingStats PUBLIC Stats::Types)
</pre> <p>As the <code>Stats::Types</code> target is a <code>PUBLIC</code> dependency of <code>ClimbingStats</code>, downstreams must also find the <code>Stats</code> package and link to the <code>Stats::Types</code> library. The <code>Stats</code> package should be found in the <code>ClimbingStatsConfig.cmake</code> file to ensure this. The <code>find_dependency</code> macro from the <a class="reference internal" href="../module/cmakefinddependencymacro#module:CMakeFindDependencyMacro" title="CMakeFindDependencyMacro" id="index-0-module:CMakeFindDependencyMacro"><code>CMakeFindDependencyMacro</code></a> helps with this by propagating whether the package is <code>REQUIRED</code>, or <code>QUIET</code> etc. All <code>REQUIRED</code> dependencies of a package should be found in the <code>Config.cmake</code> file:</p> <pre data-language="cmake">include(CMakeFindDependencyMacro)
find_dependency(Stats 2.6.4)

include("${CMAKE_CURRENT_LIST_DIR}/ClimbingStatsTargets.cmake")
include("${CMAKE_CURRENT_LIST_DIR}/ClimbingStatsMacros.cmake")
</pre> <p>The <code>find_dependency</code> macro also sets <code>ClimbingStats_FOUND</code> to <code>False</code> if the dependency is not found, along with a diagnostic that the <code>ClimbingStats</code> package can not be used without the <code>Stats</code> package.</p> <p>If <code>COMPONENTS</code> are specified when the downstream uses <a class="reference internal" href="../command/find_package#command:find_package" title="find_package" id="index-12-command:find_package"><code>find_package()</code></a>, they are listed in the <code>&lt;PackageName&gt;_FIND_COMPONENTS</code> variable. If a particular component is non-optional, then the <code>&lt;PackageName&gt;_FIND_REQUIRED_&lt;comp&gt;</code> will be true. This can be tested with logic in the package configuration file:</p> <pre data-language="cmake">include(CMakeFindDependencyMacro)
find_dependency(Stats 2.6.4)

include("${CMAKE_CURRENT_LIST_DIR}/ClimbingStatsTargets.cmake")
include("${CMAKE_CURRENT_LIST_DIR}/ClimbingStatsMacros.cmake")

set(_supported_components Plot Table)

foreach(_comp ${ClimbingStats_FIND_COMPONENTS})
  if (NOT ";${_supported_components};" MATCHES _comp)
    set(ClimbingStats_FOUND False)
    set(ClimbingStats_NOT_FOUND_MESSAGE "Unsupported component: ${_comp}")
  endif()
  include("${CMAKE_CURRENT_LIST_DIR}/ClimbingStats${_comp}Targets.cmake")
endforeach()
</pre> <p>Here, the <code>ClimbingStats_NOT_FOUND_MESSAGE</code> is set to a diagnosis that the package could not be found because an invalid component was specified. This message variable can be set for any case where the <code>_FOUND</code> variable is set to <code>False</code>, and will be displayed to the user.</p>  <h4 id="creating-a-package-configuration-file-for-the-build-tree">Creating a Package Configuration File for the Build Tree</h4> <p>The <a class="reference internal" href="../command/export#command:export" title="export" id="index-0-command:export"><code>export(EXPORT)</code></a> command creates an <a class="reference internal" href="../prop_tgt/imported#prop_tgt:IMPORTED" title="IMPORTED" id="index-6-prop_tgt:IMPORTED"><code>IMPORTED</code></a> targets definition file which is specific to the build-tree, and is not relocatable. This can similarly be used with a suitable package configuration file and package version file to define a package for the build tree which may be used without installation. Consumers of the build tree can simply ensure that the <a class="reference internal" href="../variable/cmake_prefix_path#variable:CMAKE_PREFIX_PATH" title="CMAKE_PREFIX_PATH" id="index-0-variable:CMAKE_PREFIX_PATH"><code>CMAKE_PREFIX_PATH</code></a> contains the build directory, or set the <code>ClimbingStats_DIR</code> to <code>&lt;build_dir&gt;/ClimbingStats</code> in the cache.</p>    <h3 id="id3">Creating Relocatable Packages</h3> <p id="creating-relocatable-packages">A relocatable package must not reference absolute paths of files on the machine where the package is built that will not exist on the machines where the package may be installed.</p> <p>Packages created by <a class="reference internal" href="../command/install#command:install" title="install" id="index-3-command:install"><code>install(EXPORT)</code></a> are designed to be relocatable, using paths relative to the location of the package itself. When defining the interface of a target for <code>EXPORT</code>, keep in mind that the include directories should be specified as relative paths which are relative to the <a class="reference internal" href="../variable/cmake_install_prefix#variable:CMAKE_INSTALL_PREFIX" title="CMAKE_INSTALL_PREFIX" id="index-1-variable:CMAKE_INSTALL_PREFIX"><code>CMAKE_INSTALL_PREFIX</code></a>:</p> <pre data-language="cmake">target_include_directories(tgt INTERFACE
  # Wrong, not relocatable:
  $&lt;INSTALL_INTERFACE:${CMAKE_INSTALL_PREFIX}/include/TgtName&gt;
)

target_include_directories(tgt INTERFACE
  # Ok, relocatable:
  $&lt;INSTALL_INTERFACE:include/TgtName&gt;
)
</pre> <p>The <code>$&lt;INSTALL_PREFIX&gt;</code> <a class="reference internal" href="cmake-generator-expressions.7#manual:cmake-generator-expressions(7)" title="cmake-generator-expressions(7)" id="index-0-manual:cmake-generator-expressions(7)"><code>generator expression</code></a> may be used as a placeholder for the install prefix without resulting in a non-relocatable package. This is necessary if complex generator expressions are used:</p> <pre data-language="cmake">target_include_directories(tgt INTERFACE
  # Ok, relocatable:
  $&lt;INSTALL_INTERFACE:$&lt;$&lt;CONFIG:Debug&gt;:$&lt;INSTALL_PREFIX&gt;/include/TgtName&gt;&gt;
)
</pre> <p>This also applies to paths referencing external dependencies. It is not advisable to populate any properties which may contain paths, such as <a class="reference internal" href="../prop_tgt/interface_include_directories#prop_tgt:INTERFACE_INCLUDE_DIRECTORIES" title="INTERFACE_INCLUDE_DIRECTORIES" id="index-2-prop_tgt:INTERFACE_INCLUDE_DIRECTORIES"><code>INTERFACE_INCLUDE_DIRECTORIES</code></a> and <a class="reference internal" href="../prop_tgt/interface_link_libraries#prop_tgt:INTERFACE_LINK_LIBRARIES" title="INTERFACE_LINK_LIBRARIES" id="index-0-prop_tgt:INTERFACE_LINK_LIBRARIES"><code>INTERFACE_LINK_LIBRARIES</code></a>, with paths relevant to dependencies. For example, this code may not work well for a relocatable package:</p> <pre data-language="cmake">target_link_libraries(ClimbingStats INTERFACE
  ${Foo_LIBRARIES} ${Bar_LIBRARIES}
  )
target_include_directories(ClimbingStats INTERFACE
  "$&lt;INSTALL_INTERFACE:${Foo_INCLUDE_DIRS};${Bar_INCLUDE_DIRS}&gt;"
  )
</pre> <p>The referenced variables may contain the absolute paths to libraries and include directories <strong>as found on the machine the package was made on</strong>. This would create a package with hard-coded paths to dependencies and not suitable for relocation.</p> <p>Ideally such dependencies should be used through their own <a class="reference internal" href="cmake-buildsystem.7#imported-targets"><span class="std std-ref">IMPORTED targets</span></a> that have their own <a class="reference internal" href="../prop_tgt/imported_location#prop_tgt:IMPORTED_LOCATION" title="IMPORTED_LOCATION" id="index-0-prop_tgt:IMPORTED_LOCATION"><code>IMPORTED_LOCATION</code></a> and usage requirement properties such as <a class="reference internal" href="../prop_tgt/interface_include_directories#prop_tgt:INTERFACE_INCLUDE_DIRECTORIES" title="INTERFACE_INCLUDE_DIRECTORIES" id="index-3-prop_tgt:INTERFACE_INCLUDE_DIRECTORIES"><code>INTERFACE_INCLUDE_DIRECTORIES</code></a> populated appropriately. Those imported targets may then be used with the <a class="reference internal" href="../command/target_link_libraries#command:target_link_libraries" title="target_link_libraries" id="index-1-command:target_link_libraries"><code>target_link_libraries()</code></a> command for <code>ClimbingStats</code>:</p> <pre data-language="cmake">target_link_libraries(ClimbingStats INTERFACE Foo::Foo Bar::Bar)
</pre> <p>With this approach the package references its external dependencies only through the names of <a class="reference internal" href="cmake-buildsystem.7#imported-targets"><span class="std std-ref">IMPORTED targets</span></a>. When a consumer uses the installed package, the consumer will run the appropriate <a class="reference internal" href="../command/find_package#command:find_package" title="find_package" id="index-13-command:find_package"><code>find_package()</code></a> commands (via the <code>find_dependency</code> macro described above) to find the dependencies and populate the imported targets with appropriate paths on their own machine.</p> <p>Unfortunately many <a class="reference internal" href="cmake-modules.7#manual:cmake-modules(7)" title="cmake-modules(7)" id="index-0-manual:cmake-modules(7)"><code>modules</code></a> shipped with CMake do not yet provide <a class="reference internal" href="cmake-buildsystem.7#imported-targets"><span class="std std-ref">IMPORTED targets</span></a> because their development pre-dated this approach. This may improve incrementally over time. Workarounds to create relocatable packages using such modules include:</p> <ul class="simple"> <li>When building the package, specify each <code>Foo_LIBRARY</code> cache entry as just a library name, e.g. <code>-DFoo_LIBRARY=foo</code>. This tells the corresponding find module to populate the <code>Foo_LIBRARIES</code> with just <code>foo</code> to ask the linker to search for the library instead of hard-coding a path.</li> <li>Or, after installing the package content but before creating the package installation binary for redistribution, manually replace the absolute paths with placeholders for substitution by the installation tool when the package is installed.</li> </ul>    <h2 id="id4">Package Registry</h2> <p id="package-registry">CMake provides two central locations to register packages that have been built or installed anywhere on a system:</p> <ul class="simple"> <li><a class="reference internal" href="#user-package-registry">User Package Registry</a></li> <li><a class="reference internal" href="#system-package-registry">System Package Registry</a></li> </ul> <p>The registries are especially useful to help projects find packages in non-standard install locations or directly in their own build trees. A project may populate either the user or system registry (using its own means, see below) to refer to its location. In either case the package should store at the registered location a <a class="reference internal" href="#package-configuration-file">Package Configuration File</a> (<code>&lt;PackageName&gt;Config.cmake</code>) and optionally a <a class="reference internal" href="#package-version-file">Package Version File</a> (<code>&lt;PackageName&gt;ConfigVersion.cmake</code>).</p> <p>The <a class="reference internal" href="../command/find_package#command:find_package" title="find_package" id="index-14-command:find_package"><code>find_package()</code></a> command searches the two package registries as two of the search steps specified in its documentation. If it has sufficient permissions it also removes stale package registry entries that refer to directories that do not exist or do not contain a matching package configuration file.</p>  <h3 id="id5">User Package Registry</h3> <p id="user-package-registry">The User Package Registry is stored in a per-user location. The <a class="reference internal" href="../command/export#command:export" title="export" id="index-1-command:export"><code>export(PACKAGE)</code></a> command may be used to register a project build tree in the user package registry. CMake currently provides no interface to add install trees to the user package registry. Installers must be manually taught to register their packages if desired.</p> <p>On Windows the user package registry is stored in the Windows registry under a key in <code>HKEY_CURRENT_USER</code>.</p> <p>A <code>&lt;PackageName&gt;</code> may appear under registry key:</p> <pre data-language="none">HKEY_CURRENT_USER\Software\Kitware\CMake\Packages\&lt;PackageName&gt;
</pre> <p>as a <code>REG_SZ</code> value, with arbitrary name, that specifies the directory containing the package configuration file.</p> <p>On UNIX platforms the user package registry is stored in the user home directory under <code>~/.cmake/packages</code>. A <code>&lt;PackageName&gt;</code> may appear under the directory:</p> <pre data-language="none">~/.cmake/packages/&lt;PackageName&gt;
</pre> <p>as a file, with arbitrary name, whose content specifies the directory containing the package configuration file.</p>   <h3 id="id6">System Package Registry</h3> <p id="system-package-registry">The System Package Registry is stored in a system-wide location. CMake currently provides no interface to add to the system package registry. Installers must be manually taught to register their packages if desired.</p> <p>On Windows the system package registry is stored in the Windows registry under a key in <code>HKEY_LOCAL_MACHINE</code>. A <code>&lt;PackageName&gt;</code> may appear under registry key:</p> <pre data-language="none">HKEY_LOCAL_MACHINE\Software\Kitware\CMake\Packages\&lt;PackageName&gt;
</pre> <p>as a <code>REG_SZ</code> value, with arbitrary name, that specifies the directory containing the package configuration file.</p> <p>There is no system package registry on non-Windows platforms.</p>   <h3 id="id7">Disabling the Package Registry</h3> <p id="disabling-the-package-registry">In some cases using the Package Registries is not desirable. CMake allows one to disable them using the following variables:</p> <ul class="simple"> <li>The <a class="reference internal" href="../command/export#command:export" title="export" id="index-2-command:export"><code>export(PACKAGE)</code></a> command does not populate the user package registry when <a class="reference internal" href="../policy/cmp0090#policy:CMP0090" title="CMP0090" id="index-0-policy:CMP0090"><code>CMP0090</code></a> is set to <code>NEW</code> unless the <a class="reference internal" href="../variable/cmake_export_package_registry#variable:CMAKE_EXPORT_PACKAGE_REGISTRY" title="CMAKE_EXPORT_PACKAGE_REGISTRY" id="index-0-variable:CMAKE_EXPORT_PACKAGE_REGISTRY"><code>CMAKE_EXPORT_PACKAGE_REGISTRY</code></a> variable explicitly enables it. When <a class="reference internal" href="../policy/cmp0090#policy:CMP0090" title="CMP0090" id="index-1-policy:CMP0090"><code>CMP0090</code></a> is <em>not</em> set to <code>NEW</code> then <a class="reference internal" href="../command/export#command:export" title="export" id="index-3-command:export"><code>export(PACKAGE)</code></a> populates the user package registry unless the <a class="reference internal" href="../variable/cmake_export_no_package_registry#variable:CMAKE_EXPORT_NO_PACKAGE_REGISTRY" title="CMAKE_EXPORT_NO_PACKAGE_REGISTRY" id="index-0-variable:CMAKE_EXPORT_NO_PACKAGE_REGISTRY"><code>CMAKE_EXPORT_NO_PACKAGE_REGISTRY</code></a> variable explicitly disables it.</li> <li>
<a class="reference internal" href="../variable/cmake_find_use_package_registry#variable:CMAKE_FIND_USE_PACKAGE_REGISTRY" title="CMAKE_FIND_USE_PACKAGE_REGISTRY" id="index-0-variable:CMAKE_FIND_USE_PACKAGE_REGISTRY"><code>CMAKE_FIND_USE_PACKAGE_REGISTRY</code></a> disables the User Package Registry in all the <a class="reference internal" href="../command/find_package#command:find_package" title="find_package" id="index-15-command:find_package"><code>find_package()</code></a> calls when set to <code>FALSE</code>.</li> <li>Deprecated <a class="reference internal" href="../variable/cmake_find_package_no_package_registry#variable:CMAKE_FIND_PACKAGE_NO_PACKAGE_REGISTRY" title="CMAKE_FIND_PACKAGE_NO_PACKAGE_REGISTRY" id="index-0-variable:CMAKE_FIND_PACKAGE_NO_PACKAGE_REGISTRY"><code>CMAKE_FIND_PACKAGE_NO_PACKAGE_REGISTRY</code></a> disables the User Package Registry in all the <a class="reference internal" href="../command/find_package#command:find_package" title="find_package" id="index-16-command:find_package"><code>find_package()</code></a> calls when set to <code>TRUE</code>. This variable is ignored when <a class="reference internal" href="../variable/cmake_find_use_package_registry#variable:CMAKE_FIND_USE_PACKAGE_REGISTRY" title="CMAKE_FIND_USE_PACKAGE_REGISTRY" id="index-1-variable:CMAKE_FIND_USE_PACKAGE_REGISTRY"><code>CMAKE_FIND_USE_PACKAGE_REGISTRY</code></a> has been set.</li> <li>
<a class="reference internal" href="../variable/cmake_find_package_no_system_package_registry#variable:CMAKE_FIND_PACKAGE_NO_SYSTEM_PACKAGE_REGISTRY" title="CMAKE_FIND_PACKAGE_NO_SYSTEM_PACKAGE_REGISTRY" id="index-0-variable:CMAKE_FIND_PACKAGE_NO_SYSTEM_PACKAGE_REGISTRY"><code>CMAKE_FIND_PACKAGE_NO_SYSTEM_PACKAGE_REGISTRY</code></a> disables the System Package Registry in all the <a class="reference internal" href="../command/find_package#command:find_package" title="find_package" id="index-17-command:find_package"><code>find_package()</code></a> calls.</li> </ul>   <h3 id="package-registry-example">Package Registry Example</h3> <p>A simple convention for naming package registry entries is to use content hashes. They are deterministic and unlikely to collide (<a class="reference internal" href="../command/export#command:export" title="export" id="index-4-command:export"><code>export(PACKAGE)</code></a> uses this approach). The name of an entry referencing a specific directory is simply the content hash of the directory path itself.</p> <p>If a project arranges for package registry entries to exist, such as:</p> <pre data-language="none">&gt; reg query HKCU\Software\Kitware\CMake\Packages\MyPackage
HKEY_CURRENT_USER\Software\Kitware\CMake\Packages\MyPackage
 45e7d55f13b87179bb12f907c8de6fc4 REG_SZ c:/Users/Me/Work/lib/cmake/MyPackage
 7b4a9844f681c80ce93190d4e3185db9 REG_SZ c:/Users/Me/Work/MyPackage-build
</pre> <p>or:</p> <pre data-language="none">$ cat ~/.cmake/packages/MyPackage/7d1fb77e07ce59a81bed093bbee945bd
/home/me/work/lib/cmake/MyPackage
$ cat ~/.cmake/packages/MyPackage/f92c1db873a1937f3100706657c63e07
/home/me/work/MyPackage-build
</pre> <p>then the <code>CMakeLists.txt</code> code:</p> <pre data-language="cmake">find_package(MyPackage)
</pre> <p>will search the registered locations for package configuration files (<code>MyPackageConfig.cmake</code>). The search order among package registry entries for a single package is unspecified and the entry names (hashes in this example) have no meaning. Registered locations may contain package version files (<code>MyPackageConfigVersion.cmake</code>) to tell <a class="reference internal" href="../command/find_package#command:find_package" title="find_package" id="index-18-command:find_package"><code>find_package()</code></a> whether a specific location is suitable for the version requested.</p>   <h3 id="package-registry-ownership">Package Registry Ownership</h3> <p>Package registry entries are individually owned by the project installations that they reference. A package installer is responsible for adding its own entry and the corresponding uninstaller is responsible for removing it.</p> <p>The <a class="reference internal" href="../command/export#command:export" title="export" id="index-5-command:export"><code>export(PACKAGE)</code></a> command populates the user package registry with the location of a project build tree. Build trees tend to be deleted by developers and have no “uninstall” event that could trigger removal of their entries. In order to keep the registries clean the <a class="reference internal" href="../command/find_package#command:find_package" title="find_package" id="index-19-command:find_package"><code>find_package()</code></a> command automatically removes stale entries it encounters if it has sufficient permissions. CMake provides no interface to remove an entry referencing an existing build tree once <a class="reference internal" href="../command/export#command:export" title="export" id="index-6-command:export"><code>export(PACKAGE)</code></a> has been invoked. However, if the project removes its package configuration file from the build tree then the entry referencing the location will be considered stale.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2000–2020 Kitware, Inc. and Contributors<br>Licensed under the BSD 3-clause License.<br>
    <a href="https://cmake.org/cmake/help/v3.19/manual/cmake-packages.7.html" class="_attribution-link">https://cmake.org/cmake/help/v3.19/manual/cmake-packages.7.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
