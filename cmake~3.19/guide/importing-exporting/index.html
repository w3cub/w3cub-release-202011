
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Importing-exporting - CMake 3.19 - W3cubDocs</title>
  
  <meta name="description" content=" Importing Targets ">
  <meta name="keywords" content="importing, and, exporting, guide, importing-exporting, cmake, cmake~3.19">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cmake~3.19/guide/importing-exporting/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/cmake~3.19.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cmake~3.19/" class="_nav-link" title="" style="margin-left:0;">CMake 3.19</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _sphinx_simple">
				
				
<h1 id="guide:Importing and Exporting Guide">Importing and Exporting Guide</h1>   <ul id="importing-and-exporting-guide"> <li><a class="reference internal" href="#introduction" id="id2">Introduction</a></li> <li>
<p><a class="reference internal" href="#importing-targets" id="id3">Importing Targets</a></p> <ul> <li><a class="reference internal" href="#importing-executables" id="id4">Importing Executables</a></li> <li><a class="reference internal" href="#importing-libraries" id="id5">Importing Libraries</a></li> </ul> </li> <li>
<p><a class="reference internal" href="#exporting-targets" id="id6">Exporting Targets</a></p> <ul> <li>
<p><a class="reference internal" href="#creating-packages" id="id7">Creating Packages</a></p> <ul> <li><a class="reference internal" href="#creating-a-package-configuration-file" id="id8">Creating a Package Configuration File</a></li> <li><a class="reference internal" href="#creating-a-package-version-file" id="id9">Creating a Package Version File</a></li> </ul> </li> <li><a class="reference internal" href="#exporting-targets-from-the-build-tree" id="id10">Exporting Targets from the Build Tree</a></li> <li><a class="reference internal" href="#building-and-installing-a-package" id="id11">Building and Installing a Package</a></li> </ul> </li> <li><a class="reference internal" href="#creating-relocatable-packages" id="id12">Creating Relocatable Packages</a></li> <li><a class="reference internal" href="#using-the-package-configuration-file" id="id13">Using the Package Configuration File</a></li> <li><a class="reference internal" href="#adding-components" id="id14">Adding Components</a></li> </ul>
   <h2 id="introduction">Introduction</h2> <p>In this guide, we will present the concept of <a class="reference internal" href="../../prop_tgt/imported#prop_tgt:IMPORTED" title="IMPORTED" id="index-0-prop_tgt:IMPORTED"><code>IMPORTED</code></a> targets and demonstrate how to import existing executable or library files from disk into a CMake project. We will then show how CMake supports exporting targets from one CMake-based project and importing them into another. Finally, we will demonstrate how to package a project with a configuration file to allow for easy integration into other CMake projects. This guide and the complete example source code can be found in the <code>Help/guide/importing-exporting</code> directory of the CMake source code tree.</p>   <h2 id="importing-targets">Importing Targets</h2> <p><a class="reference internal" href="../../prop_tgt/imported#prop_tgt:IMPORTED" title="IMPORTED" id="index-1-prop_tgt:IMPORTED"><code>IMPORTED</code></a> targets are used to convert files outside of a CMake project into logical targets inside of the project. <a class="reference internal" href="../../prop_tgt/imported#prop_tgt:IMPORTED" title="IMPORTED" id="index-2-prop_tgt:IMPORTED"><code>IMPORTED</code></a> targets are created using the <code>IMPORTED</code> option of the <a class="reference internal" href="../../command/add_executable#command:add_executable" title="add_executable" id="index-0-command:add_executable"><code>add_executable()</code></a> and <a class="reference internal" href="../../command/add_library#command:add_library" title="add_library" id="index-0-command:add_library"><code>add_library()</code></a> commands. No build files are generated for <a class="reference internal" href="../../prop_tgt/imported#prop_tgt:IMPORTED" title="IMPORTED" id="index-3-prop_tgt:IMPORTED"><code>IMPORTED</code></a> targets. Once imported, <a class="reference internal" href="../../prop_tgt/imported#prop_tgt:IMPORTED" title="IMPORTED" id="index-4-prop_tgt:IMPORTED"><code>IMPORTED</code></a> targets may be referenced like any other target within the project and provide a convenient, flexible reference to outside executables and libraries.</p> <p>By default, the <a class="reference internal" href="../../prop_tgt/imported#prop_tgt:IMPORTED" title="IMPORTED" id="index-5-prop_tgt:IMPORTED"><code>IMPORTED</code></a> target name has scope in the directory in which it is created and below. We can use the <code>GLOBAL</code> option to extended visibility so that the target is accessible globally in the build system.</p> <p>Details about the <a class="reference internal" href="../../prop_tgt/imported#prop_tgt:IMPORTED" title="IMPORTED" id="index-6-prop_tgt:IMPORTED"><code>IMPORTED</code></a> target are specified by setting properties whose names begin in <code>IMPORTED_</code> and <code>INTERFACE_</code>. For example, <a class="reference internal" href="../../prop_tgt/imported_location#prop_tgt:IMPORTED_LOCATION" title="IMPORTED_LOCATION" id="index-0-prop_tgt:IMPORTED_LOCATION"><code>IMPORTED_LOCATION</code></a> contains the full path to the target on disk.</p>  <h3 id="importing-executables">Importing Executables</h3> <p>To start, we will walk through a simple example that creates an <a class="reference internal" href="../../prop_tgt/imported#prop_tgt:IMPORTED" title="IMPORTED" id="index-7-prop_tgt:IMPORTED"><code>IMPORTED</code></a> executable target and then references it from the <a class="reference internal" href="../../command/add_custom_command#command:add_custom_command" title="add_custom_command" id="index-0-command:add_custom_command"><code>add_custom_command()</code></a> command.</p> <p>We’ll need to do some setup to get started. We want to create an executable that when run creates a basic <code>main.cc</code> file in the current directory. The details of this project are not important. Navigate to <code>Help/guide/importing-exporting/MyExe</code>, create a build directory, run <a class="reference internal" href="../../manual/cmake.1#manual:cmake(1)" title="cmake(1)" id="index-0-manual:cmake(1)"><code>cmake</code></a> and build and install the project.</p> <pre data-language="console">$ cd Help/guide/importing-exporting/MyExe
$ mkdir build
$ cd build
$ cmake ..
$ cmake --build .
$ cmake --install . --prefix &lt;install location&gt;
$ &lt;install location&gt;/myexe
$ ls
[...] main.cc [...]
</pre> <p>Now we can import this executable into another CMake project. The source code for this section is available in <code>Help/guide/importing-exporting/Importing</code>. In the CMakeLists file, use the <a class="reference internal" href="../../command/add_executable#command:add_executable" title="add_executable" id="index-1-command:add_executable"><code>add_executable()</code></a> command to create a new target called <code>myexe</code>. Use the <code>IMPORTED</code> option to tell CMake that this target references an executable file located outside of the project. No rules will be generated to build it and the <a class="reference internal" href="../../prop_tgt/imported#prop_tgt:IMPORTED" title="IMPORTED" id="index-8-prop_tgt:IMPORTED"><code>IMPORTED</code></a> target property will be set to <code>true</code>.</p> <pre data-language="cmake">add_executable(myexe IMPORTED)
</pre> <p>Next, set the <a class="reference internal" href="../../prop_tgt/imported_location#prop_tgt:IMPORTED_LOCATION" title="IMPORTED_LOCATION" id="index-1-prop_tgt:IMPORTED_LOCATION"><code>IMPORTED_LOCATION</code></a> property of the target using the <a class="reference internal" href="../../command/set_property#command:set_property" title="set_property" id="index-0-command:set_property"><code>set_property()</code></a> command. This will tell CMake the location of the target on disk. The location may need to be adjusted to the <code>&lt;install location&gt;</code> specified in the previous step.</p> <pre data-language="cmake">set_property(TARGET myexe PROPERTY
             IMPORTED_LOCATION "../InstallMyExe/bin/myexe")
</pre> <p>We can now reference this <a class="reference internal" href="../../prop_tgt/imported#prop_tgt:IMPORTED" title="IMPORTED" id="index-9-prop_tgt:IMPORTED"><code>IMPORTED</code></a> target just like any target built within the project. In this instance, let’s imagine that we want to use the generated source file in our project. Use the <a class="reference internal" href="../../prop_tgt/imported#prop_tgt:IMPORTED" title="IMPORTED" id="index-10-prop_tgt:IMPORTED"><code>IMPORTED</code></a> target in the <a class="reference internal" href="../../command/add_custom_command#command:add_custom_command" title="add_custom_command" id="index-1-command:add_custom_command"><code>add_custom_command()</code></a> command:</p> <pre data-language="cmake">add_custom_command(OUTPUT main.cc COMMAND myexe)
</pre> <p>As <code>COMMAND</code> specifies an executable target name, it will automatically be replaced by the location of the executable given by the <a class="reference internal" href="../../prop_tgt/imported_location#prop_tgt:IMPORTED_LOCATION" title="IMPORTED_LOCATION" id="index-2-prop_tgt:IMPORTED_LOCATION"><code>IMPORTED_LOCATION</code></a> property above.</p> <p>Finally, use the output from <a class="reference internal" href="../../command/add_custom_command#command:add_custom_command" title="add_custom_command" id="index-2-command:add_custom_command"><code>add_custom_command()</code></a>:</p> <pre data-language="cmake">add_executable(mynewexe main.cc)
</pre>   <h3 id="importing-libraries">Importing Libraries</h3> <p>In a similar manner, libraries from other projects may be accessed through <a class="reference internal" href="../../prop_tgt/imported#prop_tgt:IMPORTED" title="IMPORTED" id="index-11-prop_tgt:IMPORTED"><code>IMPORTED</code></a> targets.</p> <p>Note: The full source code for the examples in this section is not provided and is left as an exercise for the reader.</p> <p>In the CMakeLists file, add an <a class="reference internal" href="../../prop_tgt/imported#prop_tgt:IMPORTED" title="IMPORTED" id="index-12-prop_tgt:IMPORTED"><code>IMPORTED</code></a> library and specify its location on disk:</p> <pre data-language="cmake">add_library(foo STATIC IMPORTED)
set_property(TARGET foo PROPERTY
             IMPORTED_LOCATION "/path/to/libfoo.a")
</pre> <p>Then use the <a class="reference internal" href="../../prop_tgt/imported#prop_tgt:IMPORTED" title="IMPORTED" id="index-13-prop_tgt:IMPORTED"><code>IMPORTED</code></a> library inside of our project:</p> <pre data-language="cmake">add_executable(myexe src1.c src2.c)
target_link_libraries(myexe PRIVATE foo)
</pre> <p>On Windows, a .dll and its .lib import library may be imported together:</p> <pre data-language="cmake">add_library(bar SHARED IMPORTED)
set_property(TARGET bar PROPERTY
             IMPORTED_LOCATION "c:/path/to/bar.dll")
set_property(TARGET bar PROPERTY
             IMPORTED_IMPLIB "c:/path/to/bar.lib")
add_executable(myexe src1.c src2.c)
target_link_libraries(myexe PRIVATE bar)
</pre> <p>A library with multiple configurations may be imported with a single target:</p> <pre data-language="cmake">find_library(math_REL NAMES m)
find_library(math_DBG NAMES md)
add_library(math STATIC IMPORTED GLOBAL)
set_target_properties(math PROPERTIES
  IMPORTED_LOCATION "${math_REL}"
  IMPORTED_LOCATION_DEBUG "${math_DBG}"
  IMPORTED_CONFIGURATIONS "RELEASE;DEBUG"
)
add_executable(myexe src1.c src2.c)
target_link_libraries(myexe PRIVATE math)
</pre> <p>The generated build system will link <code>myexe</code> to <code>m.lib</code> when built in the release configuration, and <code>md.lib</code> when built in the debug configuration.</p>    <h2 id="exporting-targets">Exporting Targets</h2> <p>While <a class="reference internal" href="../../prop_tgt/imported#prop_tgt:IMPORTED" title="IMPORTED" id="index-14-prop_tgt:IMPORTED"><code>IMPORTED</code></a> targets on their own are useful, they still require that the project that imports them knows the locations of the target files on disk. The real power of <a class="reference internal" href="../../prop_tgt/imported#prop_tgt:IMPORTED" title="IMPORTED" id="index-15-prop_tgt:IMPORTED"><code>IMPORTED</code></a> targets is when the project providing the target files also provides a CMake file to help import them. A project can be setup to produce the necessary information so that it can easily be used by other CMake projects be it from a build directory, a local install or when packaged.</p> <p>In the remaining sections, we will walk through a set of example projects step-by-step. The first project will create and install a library and corresponding CMake configuration and package files. The second project will use the generated package.</p> <p>Let’s start by looking at the <code>MathFunctions</code> project in the <code>Help/guide/importing-exporting/MathFunctions</code> directory. Here we have a header file <code>MathFunctions.h</code> that declares a <code>sqrt</code> function:</p> <pre data-language="c">#pragma once

namespace MathFunctions {
double sqrt(double x);
}
</pre> <p>And a corresponding source file <code>MathFunctions.cxx</code>:</p> <pre data-language="c">#include "MathFunctions.h"

#include &lt;cmath&gt;

namespace MathFunctions {
double sqrt(double x)
{
  return std::sqrt(x);
}
}
</pre> <p>Don’t worry too much about the specifics of the C++ files, they are just meant to be a simple example that will compile and run on many build systems.</p> <p>Now we can create a <code>CMakeLists.txt</code> file for the <code>MathFunctions</code> project. Start by specifying the <a class="reference internal" href="../../command/cmake_minimum_required#command:cmake_minimum_required" title="cmake_minimum_required" id="index-0-command:cmake_minimum_required"><code>cmake_minimum_required()</code></a> version and <a class="reference internal" href="../../command/project#command:project" title="project" id="index-0-command:project"><code>project()</code></a> name:</p> <pre data-language="cmake">cmake_minimum_required(VERSION 3.15)
project(MathFunctions)

# specify the C++ standard
set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD_REQUIRED True)
</pre> <p>Create a library called <code>MathFunctions</code> with the <a class="reference internal" href="../../command/add_library#command:add_library" title="add_library" id="index-1-command:add_library"><code>add_library()</code></a> command:</p> <pre data-language="cmake">add_library(MathFunctions STATIC MathFunctions.cxx)
</pre> <p>And then use the <a class="reference internal" href="../../command/target_include_directories#command:target_include_directories" title="target_include_directories" id="index-0-command:target_include_directories"><code>target_include_directories()</code></a> command to specify the include directories for the target:</p> <pre data-language="cmake">target_include_directories(MathFunctions
                           PUBLIC
                           "$&lt;BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}&gt;"
                           "$&lt;INSTALL_INTERFACE:include&gt;"
)
</pre> <p>We need to tell CMake that we want to use different include directories depending on if we’re building the library or using it from an installed location. If we don’t do this, when CMake creates the export information it will export a path that is specific to the current build directory and will not be valid for other projects. We can use <a class="reference internal" href="../../manual/cmake-generator-expressions.7#manual:cmake-generator-expressions(7)" title="cmake-generator-expressions(7)" id="index-0-manual:cmake-generator-expressions(7)"><code>generator expressions</code></a> to specify that if we’re building the library include the current source directory. Otherwise, when installed, include the <code>include</code> directory. See the <a class="reference internal" href="#creating-relocatable-packages">Creating Relocatable Packages</a> section for more details.</p> <p>The <a class="reference internal" href="../../command/install#command:install" title="install" id="index-0-command:install"><code>install(TARGETS)</code></a> and <a class="reference internal" href="../../command/install#command:install" title="install" id="index-1-command:install"><code>install(EXPORT)</code></a> commands work together to install both targets (a library in our case) and a CMake file designed to make it easy to import the targets into another CMake project.</p> <p>First, in the <a class="reference internal" href="../../command/install#command:install" title="install" id="index-2-command:install"><code>install(TARGETS)</code></a> command we will specify the target, the <code>EXPORT</code> name and the destinations that tell CMake where to install the targets.</p> <pre data-language="cmake">install(TARGETS MathFunctions
        EXPORT MathFunctionsTargets
        LIBRARY DESTINATION lib
        ARCHIVE DESTINATION lib
        RUNTIME DESTINATION bin
        INCLUDES DESTINATION include
)
</pre> <p>Here, the <code>EXPORT</code> option tells CMake to create an export called <code>MathFunctionsTargets</code>. The generated <a class="reference internal" href="../../prop_tgt/imported#prop_tgt:IMPORTED" title="IMPORTED" id="index-16-prop_tgt:IMPORTED"><code>IMPORTED</code></a> targets have appropriate properties set to define their <a class="reference internal" href="../../manual/cmake-buildsystem.7#target-usage-requirements"><span class="std std-ref">usage requirements</span></a>, such as <a class="reference internal" href="../../prop_tgt/interface_include_directories#prop_tgt:INTERFACE_INCLUDE_DIRECTORIES" title="INTERFACE_INCLUDE_DIRECTORIES" id="index-0-prop_tgt:INTERFACE_INCLUDE_DIRECTORIES"><code>INTERFACE_INCLUDE_DIRECTORIES</code></a>, <a class="reference internal" href="../../prop_tgt/interface_compile_definitions#prop_tgt:INTERFACE_COMPILE_DEFINITIONS" title="INTERFACE_COMPILE_DEFINITIONS" id="index-0-prop_tgt:INTERFACE_COMPILE_DEFINITIONS"><code>INTERFACE_COMPILE_DEFINITIONS</code></a> and other relevant built-in <code>INTERFACE_</code> properties. The <code>INTERFACE</code> variant of user-defined properties listed in <a class="reference internal" href="../../prop_tgt/compatible_interface_string#prop_tgt:COMPATIBLE_INTERFACE_STRING" title="COMPATIBLE_INTERFACE_STRING" id="index-0-prop_tgt:COMPATIBLE_INTERFACE_STRING"><code>COMPATIBLE_INTERFACE_STRING</code></a> and other <a class="reference internal" href="../../manual/cmake-buildsystem.7#compatible-interface-properties"><span class="std std-ref">Compatible Interface Properties</span></a> are also propagated to the generated <a class="reference internal" href="../../prop_tgt/imported#prop_tgt:IMPORTED" title="IMPORTED" id="index-17-prop_tgt:IMPORTED"><code>IMPORTED</code></a> targets. For example, in this case, the <a class="reference internal" href="../../prop_tgt/imported#prop_tgt:IMPORTED" title="IMPORTED" id="index-18-prop_tgt:IMPORTED"><code>IMPORTED</code></a> target will have its <a class="reference internal" href="../../prop_tgt/interface_include_directories#prop_tgt:INTERFACE_INCLUDE_DIRECTORIES" title="INTERFACE_INCLUDE_DIRECTORIES" id="index-1-prop_tgt:INTERFACE_INCLUDE_DIRECTORIES"><code>INTERFACE_INCLUDE_DIRECTORIES</code></a> property populated with the directory specified by the <code>INCLUDES DESTINATION</code> property. As a relative path was given, it is treated as relative to the <a class="reference internal" href="../../variable/cmake_install_prefix#variable:CMAKE_INSTALL_PREFIX" title="CMAKE_INSTALL_PREFIX" id="index-0-variable:CMAKE_INSTALL_PREFIX"><code>CMAKE_INSTALL_PREFIX</code></a>.</p> <p>Note, we have <em>not</em> asked CMake to install the export yet.</p> <p>We don’t want to forget to install the <code>MathFunctions.h</code> header file with the <a class="reference internal" href="../../command/install#command:install" title="install" id="index-3-command:install"><code>install(FILES)</code></a> command. The header file should be installed to the <code>include</code> directory, as specified by the <a class="reference internal" href="../../command/target_include_directories#command:target_include_directories" title="target_include_directories" id="index-1-command:target_include_directories"><code>target_include_directories()</code></a> command above.</p> <pre data-language="cmake">install(FILES MathFunctions.h DESTINATION include)
</pre> <p>Now that the <code>MathFunctions</code> library and header file are installed, we also need to explicitly install the <code>MathFunctionsTargets</code> export details. Use the <a class="reference internal" href="../../command/install#command:install" title="install" id="index-4-command:install"><code>install(EXPORT)</code></a> command to export the targets in <code>MathFunctionsTargets</code>, as defined by the <a class="reference internal" href="../../command/install#command:install" title="install" id="index-5-command:install"><code>install(TARGETS)</code></a> command.</p> <pre data-language="cmake">install(EXPORT MathFunctionsTargets
        FILE MathFunctionsTargets.cmake
        NAMESPACE MathFunctions::
        DESTINATION lib/cmake
)
</pre> <p>This command generates the <code>MathFunctionsTargets.cmake</code> file and arranges to install it to <code>lib/cmake</code>. The file contains code suitable for use by downstreams to import all targets listed in the install command from the installation tree.</p> <p>The <code>NAMESPACE</code> option will prepend <code>MathFunctions::</code> to the target names as they are written to the export file. This convention of double-colons gives CMake a hint that the name is an <a class="reference internal" href="../../prop_tgt/imported#prop_tgt:IMPORTED" title="IMPORTED" id="index-19-prop_tgt:IMPORTED"><code>IMPORTED</code></a> target when it is used by downstream projects. This way, CMake can issue a diagnostic message if the package providing it was not found.</p> <p>The generated export file contains code that creates an <a class="reference internal" href="../../prop_tgt/imported#prop_tgt:IMPORTED" title="IMPORTED" id="index-20-prop_tgt:IMPORTED"><code>IMPORTED</code></a> library.</p> <pre data-language="cmake"># Create imported target MathFunctions::MathFunctions
add_library(MathFunctions::MathFunctions STATIC IMPORTED)

set_target_properties(MathFunctions::MathFunctions PROPERTIES
  INTERFACE_INCLUDE_DIRECTORIES "${_IMPORT_PREFIX}/include"
)
</pre> <p>This code is very similar to the example we created by hand in the <a class="reference internal" href="#importing-libraries">Importing Libraries</a> section. Note that <code>${_IMPORT_PREFIX}</code> is computed relative to the file location.</p> <p>An outside project may load this file with the <a class="reference internal" href="../../command/include#command:include" title="include" id="index-0-command:include"><code>include()</code></a> command and reference the <code>MathFunctions</code> library from the installation tree as if it were built in its own tree. For example:</p> <pre data-language="cmake">1
2
3</pre> <p>Line 1 loads the target CMake file. Although we only exported a single target, this file may import any number of targets. Their locations are computed relative to the file location so that the install tree may be easily moved. Line 3 references the imported <code>MathFunctions</code> library. The resulting build system will link to the library from its installed location.</p> <p>Executables may also be exported and imported using the same process.</p> <p>Any number of target installations may be associated with the same export name. Export names are considered global so any directory may contribute a target installation. The <a class="reference internal" href="../../command/install#command:install" title="install" id="index-6-command:install"><code>install(EXPORT)</code></a> command only needs to be called once to install a file that references all targets. Below is an example of how multiple exports may be combined into a single export file, even if they are in different subdirectories of the project.</p> <pre data-language="cmake"># A/CMakeLists.txt
add_executable(myexe src1.c)
install(TARGETS myexe DESTINATION lib/myproj
        EXPORT myproj-targets)

# B/CMakeLists.txt
add_library(foo STATIC foo1.c)
install(TARGETS foo DESTINATION lib EXPORTS myproj-targets)

# Top CMakeLists.txt
add_subdirectory (A)
add_subdirectory (B)
install(EXPORT myproj-targets DESTINATION lib/myproj)
</pre>  <h3 id="creating-packages">Creating Packages</h3> <p>At this point, the <code>MathFunctions</code> project is exporting the target information required to be used by other projects. We can make this project even easier for other projects to use by generating a configuration file so that the CMake <a class="reference internal" href="../../command/find_package#command:find_package" title="find_package" id="index-0-command:find_package"><code>find_package()</code></a> command can find our project.</p> <p>To start, we will need to make a few additions to the <code>CMakeLists.txt</code> file. First, include the <a class="reference internal" href="../../module/cmakepackageconfighelpers#module:CMakePackageConfigHelpers" title="CMakePackageConfigHelpers" id="index-0-module:CMakePackageConfigHelpers"><code>CMakePackageConfigHelpers</code></a> module to get access to some helper functions for creating config files.</p> <pre data-language="cmake">include(CMakePackageConfigHelpers)
</pre> <p>Then we will create a package configuration file and a package version file.</p>  <h4 id="creating-a-package-configuration-file">Creating a Package Configuration File</h4> <p>Use the <a class="reference internal" href="../../module/cmakepackageconfighelpers#command:configure_package_config_file" title="configure_package_config_file" id="index-0-command:configure_package_config_file"><code>configure_package_config_file()</code></a> command provided by the <a class="reference internal" href="../../module/cmakepackageconfighelpers#module:CMakePackageConfigHelpers" title="CMakePackageConfigHelpers" id="index-1-module:CMakePackageConfigHelpers"><code>CMakePackageConfigHelpers</code></a> to generate the package configuration file. Note that this command should be used instead of the plain <a class="reference internal" href="../../command/configure_file#command:configure_file" title="configure_file" id="index-0-command:configure_file"><code>configure_file()</code></a> command. It helps to ensure that the resulting package is relocatable by avoiding hardcoded paths in the installed configuration file. The path given to <code>INSTALL_DESTINATION</code> must be the destination where the <code>MathFunctionsConfig.cmake</code> file will be installed. We will examine the contents of the package configuration file in the next section.</p> <pre data-language="cmake">configure_package_config_file(${CMAKE_CURRENT_SOURCE_DIR}/Config.cmake.in
  "${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfig.cmake"
  INSTALL_DESTINATION lib/cmake
)
</pre> <p>Install the generated configuration files with the <a class="reference internal" href="../../command/install#command:install" title="install" id="index-7-command:install"><code>INSTALL(files)</code></a> command. Both <code>MathFunctionsConfigVersion.cmake</code> and <code>MathFunctionsConfig.cmake</code> are installed to the same location, completing the package.</p> <pre data-language="cmake">install(FILES
          "${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfig.cmake"
          "${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfigVersion.cmake"
        DESTINATION lib/cmake
)
</pre> <p>Now we need to create the package configuration file itself. In this case, the <code>Config.cmake.in</code> file is very simple but sufficient to allow downstreams to use the <a class="reference internal" href="../../prop_tgt/imported#prop_tgt:IMPORTED" title="IMPORTED" id="index-21-prop_tgt:IMPORTED"><code>IMPORTED</code></a> targets.</p> <pre data-language="none">@PACKAGE_INIT@

include("${CMAKE_CURRENT_LIST_DIR}/MathFunctionsTargets.cmake")

check_required_components(MathFunctions)
</pre> <p>The first line of the file contains only the string <code>@PACKAGE_INIT@</code>. This expands when the file is configured and allows the use of relocatable paths prefixed with <code>PACKAGE_</code>. It also provides the <code>set_and_check()</code> and <code>check_required_components()</code> macros.</p> <p>The <code>check_required_components</code> helper macro ensures that all requested, non-optional components have been found by checking the <code>&lt;Package&gt;_&lt;Component&gt;_FOUND</code> variables for all required components. This macro should be called at the end of the package configuration file even if the package does not have any components. This way, CMake can make sure that the downstream project hasn’t specified any non-existent components. If <code>check_required_components</code> fails, the <code>&lt;Package&gt;_FOUND</code> variable is set to FALSE, and the package is considered to be not found.</p> <p>The <code>set_and_check()</code> macro should be used in configuration files instead of the normal <code>set()</code> command for setting directories and file locations. If a referenced file or directory does not exist, the macro will fail.</p> <p>If any macros should be provided by the <code>MathFunctions</code> package, they should be in a separate file which is installed to the same location as the <code>MathFunctionsConfig.cmake</code> file, and included from there.</p> <p><strong>All required dependencies of a package must also be found in the package configuration file.</strong> Let’s imagine that we require the <code>Stats</code> library in our project. In the CMakeLists file, we would add:</p> <pre data-language="cmake">find_package(Stats 2.6.4 REQUIRED)
target_link_libraries(MathFunctions PUBLIC Stats::Types)
</pre> <p>As the <code>Stats::Types</code> target is a <code>PUBLIC</code> dependency of <code>MathFunctions</code>, downstreams must also find the <code>Stats</code> package and link to the <code>Stats::Types</code> library. The <code>Stats</code> package should be found in the configuration file to ensure this.</p> <pre data-language="cmake">include(CMakeFindDependencyMacro)
find_dependency(Stats 2.6.4)
</pre> <p>The <code>find_dependency</code> macro from the <a class="reference internal" href="../../module/cmakefinddependencymacro#module:CMakeFindDependencyMacro" title="CMakeFindDependencyMacro" id="index-0-module:CMakeFindDependencyMacro"><code>CMakeFindDependencyMacro</code></a> module helps by propagating whether the package is <code>REQUIRED</code>, or <code>QUIET</code>, etc. The <code>find_dependency</code> macro also sets <code>MathFunctions_FOUND</code> to <code>False</code> if the dependency is not found, along with a diagnostic that the <code>MathFunctions</code> package cannot be used without the <code>Stats</code> package.</p> <p><strong>Exercise:</strong> Add a required library to the <code>MathFunctions</code> project.</p>   <h4 id="creating-a-package-version-file">Creating a Package Version File</h4> <p>The <a class="reference internal" href="../../module/cmakepackageconfighelpers#module:CMakePackageConfigHelpers" title="CMakePackageConfigHelpers" id="index-2-module:CMakePackageConfigHelpers"><code>CMakePackageConfigHelpers</code></a> module provides the <a class="reference internal" href="../../module/cmakepackageconfighelpers#command:write_basic_package_version_file" title="write_basic_package_version_file" id="index-0-command:write_basic_package_version_file"><code>write_basic_package_version_file()</code></a> command for creating a simple package version file. This file is read by CMake when <a class="reference internal" href="../../command/find_package#command:find_package" title="find_package" id="index-1-command:find_package"><code>find_package()</code></a> is called to determine the compatibility with the requested version, and to set some version-specific variables such as <code>&lt;PackageName&gt;_VERSION</code>, <code>&lt;PackageName&gt;_VERSION_MAJOR</code>, <code>&lt;PackageName&gt;_VERSION_MINOR</code>, etc. See <a class="reference internal" href="../../manual/cmake-packages.7#manual:cmake-packages(7)" title="cmake-packages(7)" id="index-0-manual:cmake-packages(7)"><code>cmake-packages</code></a> documentation for more details.</p> <pre data-language="cmake">set(version 3.4.1)

set_property(TARGET MathFunctions PROPERTY VERSION ${version})
set_property(TARGET MathFunctions PROPERTY SOVERSION 3)
set_property(TARGET MathFunctions PROPERTY
  INTERFACE_MathFunctions_MAJOR_VERSION 3)
set_property(TARGET MathFunctions APPEND PROPERTY
  COMPATIBLE_INTERFACE_STRING MathFunctions_MAJOR_VERSION
)

# generate the version file for the config file
write_basic_package_version_file(
  "${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfigVersion.cmake"
  VERSION "${version}"
  COMPATIBILITY AnyNewerVersion
)
</pre> <p>In our example, <code>MathFunctions_MAJOR_VERSION</code> is defined as a <a class="reference internal" href="../../prop_tgt/compatible_interface_string#prop_tgt:COMPATIBLE_INTERFACE_STRING" title="COMPATIBLE_INTERFACE_STRING" id="index-1-prop_tgt:COMPATIBLE_INTERFACE_STRING"><code>COMPATIBLE_INTERFACE_STRING</code></a> which means that it must be compatible among the dependencies of any depender. By setting this custom defined user property in this version and in the next version of <code>MathFunctions</code>, <a class="reference internal" href="../../manual/cmake.1#manual:cmake(1)" title="cmake(1)" id="index-1-manual:cmake(1)"><code>cmake</code></a> will issue a diagnostic if there is an attempt to use version 3 together with version 4. Packages can choose to employ such a pattern if different major versions of the package are designed to be incompatible.</p>    <h3 id="exporting-targets-from-the-build-tree">Exporting Targets from the Build Tree</h3> <p>Typically, projects are built and installed before being used by an outside project. However, in some cases, it is desirable to export targets directly from a build tree. The targets may then be used by an outside project that references the build tree with no installation involved. The <a class="reference internal" href="../../command/export#command:export" title="export" id="index-0-command:export"><code>export()</code></a> command is used to generate a file exporting targets from a project build tree.</p> <p>If we want our example project to also be used from a build directory we only have to add the following to <code>CMakeLists.txt</code>:</p> <pre data-language="cmake">export(EXPORT MathFunctionsTargets
       FILE "${CMAKE_CURRENT_BINARY_DIR}/cmake/MathFunctionsTargets.cmake"
       NAMESPACE MathFunctions::
)
</pre> <p>Here we use the <a class="reference internal" href="../../command/export#command:export" title="export" id="index-1-command:export"><code>export()</code></a> command to generate the export targets for the build tree. In this case, we’ll create a file called <code>MathFunctionsTargets.cmake</code> in the <code>cmake</code> subdirectory of the build directory. The generated file contains the required code to import the target and may be loaded by an outside project that is aware of the project build tree. This file is specific to the build-tree, and <strong>is not relocatable</strong>.</p> <p>It is possible to create a suitable package configuration file and package version file to define a package for the build tree which may be used without installation. Consumers of the build tree can simply ensure that the <a class="reference internal" href="../../variable/cmake_prefix_path#variable:CMAKE_PREFIX_PATH" title="CMAKE_PREFIX_PATH" id="index-0-variable:CMAKE_PREFIX_PATH"><code>CMAKE_PREFIX_PATH</code></a> contains the build directory, or set the <code>MathFunctions_DIR</code> to <code>&lt;build_dir&gt;/MathFunctions</code> in the cache.</p> <p>An example application of this feature is for building an executable on a host platform when cross-compiling. The project containing the executable may be built on the host platform and then the project that is being cross-compiled for another platform may load it.</p>   <h3 id="building-and-installing-a-package">Building and Installing a Package</h3> <p>At this point, we have generated a relocatable CMake configuration for our project that can be used after the project has been installed. Let’s try to build the <code>MathFunctions</code> project:</p> <pre data-language="console">mkdir MathFunctions_build
cd MathFunctions_build
cmake ../MathFunctions
cmake --build .
</pre> <p>In the build directory, notice that the file <code>MathFunctionsTargets.cmake</code> has been created in the <code>cmake</code> subdirectory.</p> <p>Now install the project:</p> <pre data-language="console">$ cmake --install . --prefix "/home/myuser/installdir"
</pre>    <h2 id="creating-relocatable-packages">Creating Relocatable Packages</h2> <p>Packages created by <a class="reference internal" href="../../command/install#command:install" title="install" id="index-8-command:install"><code>install(EXPORT)</code></a> are designed to be relocatable, using paths relative to the location of the package itself. They must not reference absolute paths of files on the machine where the package is built that will not exist on the machines where the package may be installed.</p> <p>When defining the interface of a target for <code>EXPORT</code>, keep in mind that the include directories should be specified as relative paths to the <a class="reference internal" href="../../variable/cmake_install_prefix#variable:CMAKE_INSTALL_PREFIX" title="CMAKE_INSTALL_PREFIX" id="index-1-variable:CMAKE_INSTALL_PREFIX"><code>CMAKE_INSTALL_PREFIX</code></a> but should not explicitly include the <a class="reference internal" href="../../variable/cmake_install_prefix#variable:CMAKE_INSTALL_PREFIX" title="CMAKE_INSTALL_PREFIX" id="index-2-variable:CMAKE_INSTALL_PREFIX"><code>CMAKE_INSTALL_PREFIX</code></a>:</p> <pre data-language="cmake">target_include_directories(tgt INTERFACE
  # Wrong, not relocatable:
  $&lt;INSTALL_INTERFACE:${CMAKE_INSTALL_PREFIX}/include/TgtName&gt;
)

target_include_directories(tgt INTERFACE
  # Ok, relocatable:
  $&lt;INSTALL_INTERFACE:include/TgtName&gt;
)
</pre> <p>The <code>$&lt;INSTALL_PREFIX&gt;</code> <a class="reference internal" href="../../manual/cmake-generator-expressions.7#manual:cmake-generator-expressions(7)" title="cmake-generator-expressions(7)" id="index-1-manual:cmake-generator-expressions(7)"><code>generator expression</code></a> may be used as a placeholder for the install prefix without resulting in a non-relocatable package. This is necessary if complex generator expressions are used:</p> <pre data-language="cmake">target_include_directories(tgt INTERFACE
  # Ok, relocatable:
  $&lt;INSTALL_INTERFACE:$&lt;INSTALL_PREFIX&gt;/include/TgtName&gt;
)
</pre> <p>This also applies to paths referencing external dependencies. It is not advisable to populate any properties which may contain paths, such as <a class="reference internal" href="../../prop_tgt/interface_include_directories#prop_tgt:INTERFACE_INCLUDE_DIRECTORIES" title="INTERFACE_INCLUDE_DIRECTORIES" id="index-2-prop_tgt:INTERFACE_INCLUDE_DIRECTORIES"><code>INTERFACE_INCLUDE_DIRECTORIES</code></a> or <a class="reference internal" href="../../prop_tgt/interface_link_libraries#prop_tgt:INTERFACE_LINK_LIBRARIES" title="INTERFACE_LINK_LIBRARIES" id="index-0-prop_tgt:INTERFACE_LINK_LIBRARIES"><code>INTERFACE_LINK_LIBRARIES</code></a>, with paths relevant to dependencies. For example, this code may not work well for a relocatable package:</p> <pre data-language="cmake">target_link_libraries(MathFunctions INTERFACE
  ${Foo_LIBRARIES} ${Bar_LIBRARIES}
  )
target_include_directories(MathFunctions INTERFACE
  "$&lt;INSTALL_INTERFACE:${Foo_INCLUDE_DIRS};${Bar_INCLUDE_DIRS}&gt;"
  )
</pre> <p>The referenced variables may contain the absolute paths to libraries and include directories <strong>as found on the machine the package was made on</strong>. This would create a package with hard-coded paths to dependencies not suitable for relocation.</p> <p>Ideally such dependencies should be used through their own <a class="reference internal" href="../../manual/cmake-buildsystem.7#imported-targets"><span class="std std-ref">IMPORTED targets</span></a> that have their own <a class="reference internal" href="../../prop_tgt/imported_location#prop_tgt:IMPORTED_LOCATION" title="IMPORTED_LOCATION" id="index-3-prop_tgt:IMPORTED_LOCATION"><code>IMPORTED_LOCATION</code></a> and usage requirement properties such as <a class="reference internal" href="../../prop_tgt/interface_include_directories#prop_tgt:INTERFACE_INCLUDE_DIRECTORIES" title="INTERFACE_INCLUDE_DIRECTORIES" id="index-3-prop_tgt:INTERFACE_INCLUDE_DIRECTORIES"><code>INTERFACE_INCLUDE_DIRECTORIES</code></a> populated appropriately. Those imported targets may then be used with the <a class="reference internal" href="../../command/target_link_libraries#command:target_link_libraries" title="target_link_libraries" id="index-0-command:target_link_libraries"><code>target_link_libraries()</code></a> command for <code>MathFunctions</code>:</p> <pre data-language="cmake">target_link_libraries(MathFunctions INTERFACE Foo::Foo Bar::Bar)
</pre> <p>With this approach the package references its external dependencies only through the names of <a class="reference internal" href="../../manual/cmake-buildsystem.7#imported-targets"><span class="std std-ref">IMPORTED targets</span></a>. When a consumer uses the installed package, the consumer will run the appropriate <a class="reference internal" href="../../command/find_package#command:find_package" title="find_package" id="index-2-command:find_package"><code>find_package()</code></a> commands (via the <code>find_dependency</code> macro described above) to find the dependencies and populate the imported targets with appropriate paths on their own machine.</p>   <h2 id="using-the-package-configuration-file">Using the Package Configuration File</h2> <p>Now we’re ready to create a project to use the installed <code>MathFunctions</code> library. In this section we will be using source code from <code>Help\guide\importing-exporting\Downstream</code>. In this directory, there is a source file called <code>main.cc</code> that uses the <code>MathFunctions</code> library to calculate the square root of a given number and then prints the results:</p> <pre data-language="c">// A simple program that outputs the square root of a number
#include &lt;iostream&gt;
#include &lt;string&gt;

#include "MathFunctions.h"

int main(int argc, char* argv[])
{
  if (argc &lt; 2) {
    std::cout &lt;&lt; "Usage: " &lt;&lt; argv[0] &lt;&lt; " number" &lt;&lt; std::endl;
    return 1;
  }

  // convert input to double
  const double inputValue = std::stod(argv[1]);

  // calculate square root
  const double sqrt = MathFunctions::sqrt(inputValue);
  std::cout &lt;&lt; "The square root of " &lt;&lt; inputValue &lt;&lt; " is " &lt;&lt; sqrt
            &lt;&lt; std::endl;

  return 0;
}
</pre> <p>As before, we’ll start with the <a class="reference internal" href="../../command/cmake_minimum_required#command:cmake_minimum_required" title="cmake_minimum_required" id="index-1-command:cmake_minimum_required"><code>cmake_minimum_required()</code></a> and <a class="reference internal" href="../../command/project#command:project" title="project" id="index-1-command:project"><code>project()</code></a> commands in the <code>CMakeLists.txt</code> file. For this project, we’ll also specify the C++ standard.</p> <pre data-language="cmake">cmake_minimum_required(VERSION 3.15)
project(Downstream)

# specify the C++ standard
set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD_REQUIRED True)
</pre> <p>We can use the <a class="reference internal" href="../../command/find_package#command:find_package" title="find_package" id="index-3-command:find_package"><code>find_package()</code></a> command:</p> <pre data-language="cmake">find_package(MathFunctions 3.4.1 EXACT)
</pre> <p>Create an exectuable:</p> <pre data-language="cmake">add_executable(myexe main.cc)
</pre> <p>And link to the <code>MathFunctions</code> library:</p> <pre data-language="cmake">target_link_libraries(myexe PRIVATE MathFunctions::MathFunctions)
</pre> <p>That’s it! Now let’s try to build the <code>Downstream</code> project.</p> <pre data-language="console">mkdir Downstream_build
cd Downstream_build
cmake ../Downstream
cmake --build .
</pre> <p>A warning may have appeared during CMake configuration:</p> <pre data-language="console">CMake Warning at CMakeLists.txt:4 (find_package):
  By not providing "FindMathFunctions.cmake" in CMAKE_MODULE_PATH this
  project has asked CMake to find a package configuration file provided by
  "MathFunctions", but CMake did not find one.

  Could not find a package configuration file provided by "MathFunctions"
  with any of the following names:

    MathFunctionsConfig.cmake
    mathfunctions-config.cmake

  Add the installation prefix of "MathFunctions" to CMAKE_PREFIX_PATH or set
  "MathFunctions_DIR" to a directory containing one of the above files.  If
  "MathFunctions" provides a separate development package or SDK, be sure it
  has been installed.
</pre> <p>Set the <code>CMAKE_PREFIX_PATH</code> to where MathFunctions was installed previously and try again. Ensure that the newly created executable runs as expected.</p>   <h2 id="adding-components">Adding Components</h2> <p>Let’s edit the <code>MathFunctions</code> project to use components. The source code for this section can be found in <code>Help\guide\importing-exporting\MathFunctionsComponents</code>. The CMakeLists file for this project adds two subdirectories: <code>Addition</code> and <code>SquareRoot</code>.</p> <pre data-language="cmake">cmake_minimum_required(VERSION 3.15)
project(MathFunctionsComponents)

# specify the C++ standard
set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD_REQUIRED True)

add_subdirectory(Addition)
add_subdirectory(SquareRoot)
</pre> <p>Generate and install the package configuration and package version files:</p> <pre data-language="cmake">include(CMakePackageConfigHelpers)

# set version
set(version 3.4.1)

# generate the version file for the config file
write_basic_package_version_file(
  "${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfigVersion.cmake"
  VERSION "${version}"
  COMPATIBILITY AnyNewerVersion
)

# create config file
configure_package_config_file(${CMAKE_CURRENT_SOURCE_DIR}/Config.cmake.in
  "${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfig.cmake"
  INSTALL_DESTINATION lib/cmake
  NO_CHECK_REQUIRED_COMPONENTS_MACRO
)

# install config files
install(FILES
          "${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfig.cmake"
          "${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfigVersion.cmake"
        DESTINATION lib/cmake
)
</pre> <p>If <code>COMPONENTS</code> are specified when the downstream uses <a class="reference internal" href="../../command/find_package#command:find_package" title="find_package" id="index-4-command:find_package"><code>find_package()</code></a>, they are listed in the <code>&lt;PackageName&gt;_FIND_COMPONENTS</code> variable. We can use this variable to verify that all necessary component targets are included in <code>Config.cmake.in</code>. At the same time, this function will act as a custom <code>check_required_components</code> macro to ensure that the downstream only attempts to use supported components.</p> <pre data-language="none">@PACKAGE_INIT@

set(_supported_components Addition SquareRoot)

foreach(_comp ${MathFunctions_FIND_COMPONENTS})
  if (NOT _comp IN_LIST _supported_components)
    set(MathFunctions_FOUND False)
    set(MathFunctions_NOT_FOUND_MESSAGE "Unsupported component: ${_comp}")
  endif()
  include("${CMAKE_CURRENT_LIST_DIR}/MathFunctions${_comp}Targets.cmake")
endforeach()
</pre> <p>Here, the <code>MathFunctions_NOT_FOUND_MESSAGE</code> is set to a diagnosis that the package could not be found because an invalid component was specified. This message variable can be set for any case where the <code>_FOUND</code> variable is set to <code>False</code>, and will be displayed to the user.</p> <p>The <code>Addition</code> and <code>SquareRoot</code> directories are similar. Let’s look at one of the CMakeLists files:</p> <pre data-language="cmake"># create library
add_library(SquareRoot STATIC SquareRoot.cxx)

add_library(MathFunctions::SquareRoot ALIAS SquareRoot)

# add include directories
target_include_directories(SquareRoot
                           PUBLIC
                           "$&lt;BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}&gt;"
                           "$&lt;INSTALL_INTERFACE:include&gt;"
)

# install the target and create export-set
install(TARGETS SquareRoot
        EXPORT SquareRootTargets
        LIBRARY DESTINATION lib
        ARCHIVE DESTINATION lib
        RUNTIME DESTINATION bin
        INCLUDES DESTINATION include
)

# install header file
install(FILES SquareRoot.h DESTINATION include)

# generate and install export file
install(EXPORT SquareRootTargets
        FILE MathFunctionsSquareRootTargets.cmake
        NAMESPACE MathFunctions::
        DESTINATION lib/cmake
)
</pre> <p>Now we can build the project as described in earlier sections. To test using this package, we can use the project in <code>Help\guide\importing-exporting\DownstreamComponents</code>. There’s two differences from the previous <code>Downstream</code> project. First, we need to find the package components. Change the <code>find_package</code> line from:</p> <pre data-language="cmake">find_package(MathFunctions 3.4.1 EXACT)
</pre> <p>To:</p> <pre data-language="cmake">find_package(MathFunctions 3.4 COMPONENTS Addition SquareRoot)
</pre> <p>and the <code>target_link_libraries</code> line from:</p> <pre data-language="cmake">target_link_libraries(myexe PRIVATE MathFunctions::MathFunctions)
</pre> <p>To:</p> <pre data-language="cmake">target_link_libraries(myexe PRIVATE MathFunctions::Addition MathFunctions::SquareRoot)
</pre> <p>In <code>main.cc</code>, replace <code>#include MathFunctions.h</code> with:</p> <pre data-language="c">
#include "Addition.h"
#include "SquareRoot.h"

</pre> <p>Finally, use the <code>Addition</code> library:</p> <pre data-language="c">  const double sum = MathFunctions::add(inputValue, inputValue);
  std::cout &lt;&lt; inputValue &lt;&lt; " + " &lt;&lt; inputValue &lt;&lt; " = " &lt;&lt; sum &lt;&lt; std::endl;

</pre> <p>Build the <code>Downstream</code> project and confirm that it can find and use the package components.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2000–2020 Kitware, Inc. and Contributors<br>Licensed under the BSD 3-clause License.<br>
    <a href="https://cmake.org/cmake/help/v3.19/guide/importing-exporting/index.html" class="_attribution-link">https://cmake.org/cmake/help/v3.19/guide/importing-exporting/index.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
