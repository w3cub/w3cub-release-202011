
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Session - Electron - W3cubDocs</title>
  
  <meta name="description" content=" Manage browser sessions, cookies, cache, proxy settings, etc. ">
  <meta name="keywords" content="session, electron">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/electron/api/session.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/electron.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/electron/" class="_nav-link" title="" style="margin-left:0;">Electron</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _simple">
				
				
<h1 id="session">session</h1> <blockquote> <p>Manage browser sessions, cookies, cache, proxy settings, etc.</p> </blockquote> <p>Process: <a href="../glossary#main-process">Main</a></p> <p>The <code>session</code> module can be used to create new <code>Session</code> objects.</p> <p>You can also access the <code>session</code> of existing pages by using the <code>session</code> property of <a href="web-contents"><code>WebContents</code></a>, or from the <code>session</code> module.</p> <pre data-language="javascript">const { BrowserWindow } = require('electron')

const win = new BrowserWindow({ width: 800, height: 600 })
win.loadURL('http://github.com')

const ses = win.webContents.session
console.log(ses.getUserAgent())
</pre>   <h2 id="methods">Methods</h2> <p>The <code>session</code> module has the following methods:</p>   <h3 id="sessionfrompartitionpartition-options"><code>session.fromPartition(partition[, options])</code></h3> <ul> <li>
<code>partition</code> String</li> <li>
<code>options</code> Object (optional)<ul> <li>
<code>cache</code> Boolean - Whether to enable cache.</li> </ul>
</li> </ul> <p>Returns <code>Session</code> - A session instance from <code>partition</code> string. When there is an existing <code>Session</code> with the same <code>partition</code>, it will be returned; otherwise a new <code>Session</code> instance will be created with <code>options</code>.</p> <p>If <code>partition</code> starts with <code>persist:</code>, the page will use a persistent session available to all pages in the app with the same <code>partition</code>. if there is no <code>persist:</code> prefix, the page will use an in-memory session. If the <code>partition</code> is empty then default session of the app will be returned.</p> <p>To create a <code>Session</code> with <code>options</code>, you have to ensure the <code>Session</code> with the <code>partition</code> has never been used before. There is no way to change the <code>options</code> of an existing <code>Session</code> object.</p>   <h2 id="properties">Properties</h2> <p>The <code>session</code> module has the following properties:</p>   <h3 id="sessiondefaultsession"><code>session.defaultSession</code></h3> <p>A <code>Session</code> object, the default session object of the app.</p>   <h2 id="class-session">Class: Session</h2> <blockquote> <p>Get and set properties of a session.</p> </blockquote> <p>Process: <a href="../glossary#main-process">Main</a></p> <p>You can create a <code>Session</code> object in the <code>session</code> module:</p> <pre data-language="javascript">const { session } = require('electron')
const ses = session.fromPartition('persist:name')
console.log(ses.getUserAgent())
</pre>   <h3 id="instance-events">Instance Events</h3> <p>The following events are available on instances of <code>Session</code>:</p>   <h4 id="event-will-download">Event: 'will-download'</h4> <p>Returns:</p> <ul> <li>
<code>event</code> Event</li> <li>
<code>item</code> <a href="download-item">DownloadItem</a>
</li> <li>
<code>webContents</code> <a href="web-contents">WebContents</a>
</li> </ul> <p>Emitted when Electron is about to download <code>item</code> in <code>webContents</code>.</p> <p>Calling <code>event.preventDefault()</code> will cancel the download and <code>item</code> will not be available from next tick of the process.</p> <pre data-language="javascript">const { session } = require('electron')
session.defaultSession.on('will-download', (event, item, webContents) =&gt; {
  event.preventDefault()
  require('request')(item.getURL(), (data) =&gt; {
    require('fs').writeFileSync('/somewhere', data)
  })
})
</pre>   <h4 id="event-preconnect">Event: 'preconnect'</h4> <p>Returns:</p> <ul> <li>
<code>event</code> Event</li> <li>
<code>preconnectUrl</code> String - The URL being requested for preconnection by the renderer.</li> <li>
<code>allowCredentials</code> Boolean - True if the renderer is requesting that the connection include credentials (see the <a href="https://w3c.github.io/resource-hints/#preconnect">spec</a> for more details.)</li> </ul> <p>Emitted when a render process requests preconnection to a URL, generally due to a <a href="https://w3c.github.io/resource-hints/">resource hint</a>.</p>   <h4 id="event-spellcheck-dictionary-initialized">Event: 'spellcheck-dictionary-initialized'</h4> <p>Returns:</p> <ul> <li>
<code>event</code> Event</li> <li>
<code>languageCode</code> String - The language code of the dictionary file</li> </ul> <p>Emitted when a hunspell dictionary file has been successfully initialized. This occurs after the file has been downloaded.</p>   <h4 id="event-spellcheck-dictionary-download-begin">Event: 'spellcheck-dictionary-download-begin'</h4> <p>Returns:</p> <ul> <li>
<code>event</code> Event</li> <li>
<code>languageCode</code> String - The language code of the dictionary file</li> </ul> <p>Emitted when a hunspell dictionary file starts downloading</p>   <h4 id="event-spellcheck-dictionary-download-success">Event: 'spellcheck-dictionary-download-success'</h4> <p>Returns:</p> <ul> <li>
<code>event</code> Event</li> <li>
<code>languageCode</code> String - The language code of the dictionary file</li> </ul> <p>Emitted when a hunspell dictionary file has been successfully downloaded</p>   <h4 id="event-spellcheck-dictionary-download-failure">Event: 'spellcheck-dictionary-download-failure'</h4> <p>Returns:</p> <ul> <li>
<code>event</code> Event</li> <li>
<code>languageCode</code> String - The language code of the dictionary file</li> </ul> <p>Emitted when a hunspell dictionary file download fails. For details on the failure you should collect a netlog and inspect the download request.</p>   <h3 id="instance-methods">Instance Methods</h3> <p>The following methods are available on instances of <code>Session</code>:</p>   <h4 id="sesgetcachesize"><code>ses.getCacheSize()</code></h4> <p>Returns <code>Promise&lt;Integer&gt;</code> - the session's current cache size, in bytes.</p>   <h4 id="sesclearcache"><code>ses.clearCache()</code></h4> <p>Returns <code>Promise&lt;void&gt;</code> - resolves when the cache clear operation is complete.</p> <p>Clears the session’s HTTP cache.</p>   <h4 id="sesclearstoragedataoptions"><code>ses.clearStorageData([options])</code></h4> <ul> <li>
<code>options</code> Object (optional)<ul> <li>
<code>origin</code> String (optional) - Should follow <code>window.location.origin</code>’s representation <code>scheme://host:port</code>.</li> <li>
<code>storages</code> String[] (optional) - The types of storages to clear, can contain: <code>appcache</code>, <code>cookies</code>, <code>filesystem</code>, <code>indexdb</code>, <code>localstorage</code>, <code>shadercache</code>, <code>websql</code>, <code>serviceworkers</code>, <code>cachestorage</code>. If not specified, clear all storage types.</li> <li>
<code>quotas</code> String[] (optional) - The types of quotas to clear, can contain: <code>temporary</code>, <code>persistent</code>, <code>syncable</code>. If not specified, clear all quotas.</li> </ul>
</li> </ul> <p>Returns <code>Promise&lt;void&gt;</code> - resolves when the storage data has been cleared.</p>   <h4 id="sesflushstoragedata"><code>ses.flushStorageData()</code></h4> <p>Writes any unwritten DOMStorage data to disk.</p>   <h4 id="sessetproxyconfig"><code>ses.setProxy(config)</code></h4> <ul> <li>
<code>config</code> Object<ul> <li>
<code>pacScript</code> String (optional) - The URL associated with the PAC file.</li> <li>
<code>proxyRules</code> String (optional) - Rules indicating which proxies to use.</li> <li>
<code>proxyBypassRules</code> String (optional) - Rules indicating which URLs should bypass the proxy settings.</li> </ul>
</li> </ul> <p>Returns <code>Promise&lt;void&gt;</code> - Resolves when the proxy setting process is complete.</p> <p>Sets the proxy settings.</p> <p>When <code>pacScript</code> and <code>proxyRules</code> are provided together, the <code>proxyRules</code> option is ignored and <code>pacScript</code> configuration is applied.</p> <p>The <code>proxyRules</code> has to follow the rules below:</p> <pre data-language="sh">proxyRules = schemeProxies[";"&lt;schemeProxies&gt;]
schemeProxies = [&lt;urlScheme&gt;"="]&lt;proxyURIList&gt;
urlScheme = "http" | "https" | "ftp" | "socks"
proxyURIList = &lt;proxyURL&gt;[","&lt;proxyURIList&gt;]
proxyURL = [&lt;proxyScheme&gt;"://"]&lt;proxyHost&gt;[":"&lt;proxyPort&gt;]
</pre> <p>For example:</p> <ul> <li>
<code>http=foopy:80;ftp=foopy2</code> - Use HTTP proxy <code>foopy:80</code> for <code>http://</code> URLs, and HTTP proxy <code>foopy2:80</code> for <code>ftp://</code> URLs.</li> <li>
<code>foopy:80</code> - Use HTTP proxy <code>foopy:80</code> for all URLs.</li> <li>
<code>foopy:80,bar,direct://</code> - Use HTTP proxy <code>foopy:80</code> for all URLs, failing over to <code>bar</code> if <code>foopy:80</code> is unavailable, and after that using no proxy.</li> <li>
<code>socks4://foopy</code> - Use SOCKS v4 proxy <code>foopy:1080</code> for all URLs.</li> <li>
<code>http=foopy,socks5://bar.com</code> - Use HTTP proxy <code>foopy</code> for http URLs, and fail over to the SOCKS5 proxy <code>bar.com</code> if <code>foopy</code> is unavailable.</li> <li>
<code>http=foopy,direct://</code> - Use HTTP proxy <code>foopy</code> for http URLs, and use no proxy if <code>foopy</code> is unavailable.</li> <li>
<code>http=foopy;socks=foopy2</code> - Use HTTP proxy <code>foopy</code> for http URLs, and use <code>socks4://foopy2</code> for all other URLs.</li> </ul> <p>The <code>proxyBypassRules</code> is a comma separated list of rules described below:</p> <ul> <li> <p><code>[ URL_SCHEME "://" ] HOSTNAME_PATTERN [ ":" &lt;port&gt; ]</code></p> <p> Match all hostnames that match the pattern HOSTNAME_PATTERN.</p> <p> Examples: "foobar.com", "<em>foobar.com", "</em>.foobar.com", "<em>foobar.com:99", "https://x.</em>.y.com:99"</p> </li> <li> <p><code>"." HOSTNAME_SUFFIX_PATTERN [ ":" PORT ]</code></p> <p>Match a particular domain suffix.</p> <p>Examples: ".google.com", ".com", "http://.google.com"</p> </li> <li> <p><code>[ SCHEME "://" ] IP_LITERAL [ ":" PORT ]</code></p> <p> Match URLs which are IP address literals.</p> <p> Examples: "127.0.1", "[0:0::1]", "[::1]", "http://[::1]:99"</p> </li> <li> <p><code>IP_LITERAL "/" PREFIX_LENGTH_IN_BITS</code></p> <p> Match any URL that is to an IP literal that falls between the given range. IP range is specified using CIDR notation.</p> <p> Examples: "192.168.1.1/16", "fefe:13::abc/33".</p> </li> <li> <p><code>&lt;local&gt;</code></p> <p> Match local addresses. The meaning of <code>&lt;local&gt;</code> is whether the host matches one of: "127.0.0.1", "::1", "localhost".</p> </li> </ul>   <h4 id="sesresolveproxyurl"><code>ses.resolveProxy(url)</code></h4> <ul> <li>
<code>url</code> URL</li> </ul> <p>Returns <code>Promise&lt;String&gt;</code> - Resolves with the proxy information for <code>url</code>.</p>   <h4 id="sessetdownloadpathpath"><code>ses.setDownloadPath(path)</code></h4> <ul> <li>
<code>path</code> String - The download location.</li> </ul> <p>Sets download saving directory. By default, the download directory will be the <code>Downloads</code> under the respective app folder.</p>   <h4 id="sesenablenetworkemulationoptions"><code>ses.enableNetworkEmulation(options)</code></h4> <ul> <li>
<code>options</code> Object<ul> <li>
<code>offline</code> Boolean (optional) - Whether to emulate network outage. Defaults to false.</li> <li>
<code>latency</code> Double (optional) - RTT in ms. Defaults to 0 which will disable latency throttling.</li> <li>
<code>downloadThroughput</code> Double (optional) - Download rate in Bps. Defaults to 0 which will disable download throttling.</li> <li>
<code>uploadThroughput</code> Double (optional) - Upload rate in Bps. Defaults to 0 which will disable upload throttling.</li> </ul>
</li> </ul> <p>Emulates network with the given configuration for the <code>session</code>.</p> <pre data-language="javascript">// To emulate a GPRS connection with 50kbps throughput and 500 ms latency.
window.webContents.session.enableNetworkEmulation({
  latency: 500,
  downloadThroughput: 6400,
  uploadThroughput: 6400
})

// To emulate a network outage.
window.webContents.session.enableNetworkEmulation({ offline: true })
</pre>   <h4 id="sespreconnectoptions"><code>ses.preconnect(options)</code></h4> <ul> <li>
<code>options</code> Object<ul> <li>
<code>url</code> String - URL for preconnect. Only the origin is relevant for opening the socket.</li> <li>
<code>numSockets</code> Number (optional) - number of sockets to preconnect. Must be between 1 and 6. Defaults to 1.</li> </ul>
</li> </ul> <p>Preconnects the given number of sockets to an origin.</p>   <h4 id="sesdisablenetworkemulation"><code>ses.disableNetworkEmulation()</code></h4> <p>Disables any network emulation already active for the <code>session</code>. Resets to the original network configuration.</p>   <h4 id="sessetcertificateverifyprocproc"><code>ses.setCertificateVerifyProc(proc)</code></h4> <ul> <li>
<code>proc</code> Function | null<ul> <li>
<code>request</code> Object<ul> <li>
<code>hostname</code> String</li> <li>
<code>certificate</code> <a href="structures/certificate">Certificate</a>
</li> <li>
<code>validatedCertificate</code> <a href="structures/certificate">Certificate</a>
</li> <li>
<code>verificationResult</code> String - Verification result from chromium.</li> <li>
<code>errorCode</code> Integer - Error code.</li> </ul>
</li> <li>
<code>callback</code> Function<ul> <li>
<code>verificationResult</code> Integer - Value can be one of certificate error codes from <a href="https://code.google.com/p/chromium/codesearch#chromium/src/net/base/net_error_list.h">here</a>. Apart from the certificate error codes, the following special codes can be used.<ul> <li>
<code>0</code> - Indicates success and disables Certificate Transparency verification.</li> <li>
<code>-2</code> - Indicates failure.</li> <li>
<code>-3</code> - Uses the verification result from chromium.</li> </ul>
</li> </ul>
</li> </ul>
</li> </ul> <p>Sets the certificate verify proc for <code>session</code>, the <code>proc</code> will be called with <code>proc(request, callback)</code> whenever a server certificate verification is requested. Calling <code>callback(0)</code> accepts the certificate, calling <code>callback(-2)</code> rejects it.</p> <p>Calling <code>setCertificateVerifyProc(null)</code> will revert back to default certificate verify proc.</p> <pre data-language="javascript">const { BrowserWindow } = require('electron')
const win = new BrowserWindow()

win.webContents.session.setCertificateVerifyProc((request, callback) =&gt; {
  const { hostname } = request
  if (hostname === 'github.com') {
    callback(0)
  } else {
    callback(-2)
  }
})
</pre>   <h4 id="sessetpermissionrequesthandlerhandler"><code>ses.setPermissionRequestHandler(handler)</code></h4> <ul> <li>
<code>handler</code> Function | null<ul> <li>
<code>webContents</code> <a href="web-contents">WebContents</a> - WebContents requesting the permission. Please note that if the request comes from a subframe you should use <code>requestingUrl</code> to check the request origin.</li> <li>
<code>permission</code> String - The type of requested permission.<ul> <li>
<code>clipboard-read</code> - Request access to read from the clipboard.</li> <li>
<code>media</code> - Request access to media devices such as camera, microphone and speakers.</li> <li>
<code>mediaKeySystem</code> - Request access to DRM protected content.</li> <li>
<code>geolocation</code> - Request access to user's current location.</li> <li>
<code>notifications</code> - Request notification creation and the ability to display them in the user's system tray.</li> <li>
<code>midi</code> - Request MIDI access in the <code>webmidi</code> API.</li> <li>
<code>midiSysex</code> - Request the use of system exclusive messages in the <code>webmidi</code> API.</li> <li>
<code>pointerLock</code> - Request to directly interpret mouse movements as an input method. Click <a href="https://developer.mozilla.org/en-US/docs/Web/API/Pointer_Lock_API">here</a> to know more.</li> <li>
<code>fullscreen</code> - Request for the app to enter fullscreen mode.</li> <li>
<code>openExternal</code> - Request to open links in external applications.</li> </ul>
</li> <li>
<code>callback</code> Function<ul> <li>
<code>permissionGranted</code> Boolean - Allow or deny the permission.</li> </ul>
</li> <li>
<code>details</code> Object - Some properties are only available on certain permission types.<ul> <li>
<code>externalURL</code> String (optional) - The url of the <code>openExternal</code> request.</li> <li>
<code>mediaTypes</code> String[] (optional) - The types of media access being requested, elements can be <code>video</code> or <code>audio</code>
</li> <li>
<code>requestingUrl</code> String - The last URL the requesting frame loaded</li> <li>
<code>isMainFrame</code> Boolean - Whether the frame making the request is the main frame</li> </ul>
</li> </ul>
</li> </ul> <p>Sets the handler which can be used to respond to permission requests for the <code>session</code>. Calling <code>callback(true)</code> will allow the permission and <code>callback(false)</code> will reject it. To clear the handler, call <code>setPermissionRequestHandler(null)</code>.</p> <pre data-language="javascript">const { session } = require('electron')
session.fromPartition('some-partition').setPermissionRequestHandler((webContents, permission, callback) =&gt; {
  if (webContents.getURL() === 'some-host' &amp;&amp; permission === 'notifications') {
    return callback(false) // denied.
  }

  callback(true)
})
</pre>   <h4 id="sessetpermissioncheckhandlerhandler"><code>ses.setPermissionCheckHandler(handler)</code></h4> <ul> <li>
<code>handler</code> Function\<boolean> | null<ul> <li>
<code>webContents</code> <a href="web-contents">WebContents</a> - WebContents checking the permission. Please note that if the request comes from a subframe you should use <code>requestingUrl</code> to check the request origin.</li> <li>
<code>permission</code> String - Enum of 'media'.</li> <li>
<code>requestingOrigin</code> String - The origin URL of the permission check</li> <li>
<code>details</code> Object - Some properties are only available on certain permission types.<ul> <li>
<code>securityOrigin</code> String - The security origin of the <code>media</code> check.</li> <li>
<code>mediaType</code> String - The type of media access being requested, can be <code>video</code>, <code>audio</code> or <code>unknown</code>
</li> <li>
<code>requestingUrl</code> String - The last URL the requesting frame loaded</li> <li>
<code>isMainFrame</code> Boolean - Whether the frame making the request is the main frame</li> </ul>
</li> </ul></boolean>
</li> </ul> <p>Sets the handler which can be used to respond to permission checks for the <code>session</code>. Returning <code>true</code> will allow the permission and <code>false</code> will reject it. To clear the handler, call <code>setPermissionCheckHandler(null)</code>.</p> <pre data-language="javascript">const { session } = require('electron')
session.fromPartition('some-partition').setPermissionCheckHandler((webContents, permission) =&gt; {
  if (webContents.getURL() === 'some-host' &amp;&amp; permission === 'notifications') {
    return false // denied
  }

  return true
})
</pre>   <h4 id="sesclearhostresolvercache"><code>ses.clearHostResolverCache()</code></h4> <p>Returns <code>Promise&lt;void&gt;</code> - Resolves when the operation is complete.</p> <p>Clears the host resolver cache.</p>   <h4 id="sesallowntlmcredentialsfordomainsdomains"><code>ses.allowNTLMCredentialsForDomains(domains)</code></h4> <ul> <li>
<code>domains</code> String - A comma-separated list of servers for which integrated authentication is enabled.</li> </ul> <p>Dynamically sets whether to always send credentials for HTTP NTLM or Negotiate authentication.</p> <pre data-language="javascript">const { session } = require('electron')
// consider any url ending with `example.com`, `foobar.com`, `baz`
// for integrated authentication.
session.defaultSession.allowNTLMCredentialsForDomains('*example.com, *foobar.com, *baz')

// consider all urls for integrated authentication.
session.defaultSession.allowNTLMCredentialsForDomains('*')
</pre>   <h4 id="sessetuseragentuseragent-acceptlanguages"><code>ses.setUserAgent(userAgent[, acceptLanguages])</code></h4> <ul> <li>
<code>userAgent</code> String</li> <li>
<code>acceptLanguages</code> String (optional)</li> </ul> <p>Overrides the <code>userAgent</code> and <code>acceptLanguages</code> for this session.</p> <p>The <code>acceptLanguages</code> must a comma separated ordered list of language codes, for example <code>"en-US,fr,de,ko,zh-CN,ja"</code>.</p> <p>This doesn't affect existing <code>WebContents</code>, and each <code>WebContents</code> can use <code>webContents.setUserAgent</code> to override the session-wide user agent.</p>   <h4 id="sesispersistent"><code>ses.isPersistent()</code></h4> <p>Returns <code>Boolean</code> - Whether or not this session is a persistent one. The default <code>webContents</code> session of a <code>BrowserWindow</code> is persistent. When creating a session from a partition, session prefixed with <code>persist:</code> will be persistent, while others will be temporary.</p>   <h4 id="sesgetuseragent"><code>ses.getUserAgent()</code></h4> <p>Returns <code>String</code> - The user agent for this session.</p>   <h4 id="sesgetblobdataidentifier"><code>ses.getBlobData(identifier)</code></h4> <ul> <li>
<code>identifier</code> String - Valid UUID.</li> </ul> <p>Returns <code>Promise&lt;Buffer&gt;</code> - resolves with blob data.</p>   <h4 id="sesdownloadurlurl"><code>ses.downloadURL(url)</code></h4> <ul> <li>
<code>url</code> String</li> </ul> <p>Initiates a download of the resource at <code>url</code>. The API will generate a <a href="download-item">DownloadItem</a> that can be accessed with the <a href="#event-will-download">will-download</a> event.</p> <p><strong>Note:</strong> This does not perform any security checks that relate to a page's origin, unlike <a href="web-contents#contentsdownloadurlurl"><code>webContents.downloadURL</code></a>.</p>   <h4 id="sescreateinterrupteddownloadoptions"><code>ses.createInterruptedDownload(options)</code></h4> <ul> <li>
<code>options</code> Object<ul> <li>
<code>path</code> String - Absolute path of the download.</li> <li>
<code>urlChain</code> String[] - Complete URL chain for the download.</li> <li>
<code>mimeType</code> String (optional)</li> <li>
<code>offset</code> Integer - Start range for the download.</li> <li>
<code>length</code> Integer - Total length of the download.</li> <li>
<code>lastModified</code> String (optional) - Last-Modified header value.</li> <li>
<code>eTag</code> String (optional) - ETag header value.</li> <li>
<code>startTime</code> Double (optional) - Time when download was started in number of seconds since UNIX epoch.</li> </ul>
</li> </ul> <p>Allows resuming <code>cancelled</code> or <code>interrupted</code> downloads from previous <code>Session</code>. The API will generate a <a href="download-item">DownloadItem</a> that can be accessed with the <a href="#event-will-download">will-download</a> event. The <a href="download-item">DownloadItem</a> will not have any <code>WebContents</code> associated with it and the initial state will be <code>interrupted</code>. The download will start only when the <code>resume</code> API is called on the <a href="download-item">DownloadItem</a>.</p>   <h4 id="sesclearauthcache"><code>ses.clearAuthCache()</code></h4> <p>Returns <code>Promise&lt;void&gt;</code> - resolves when the session’s HTTP authentication cache has been cleared.</p>   <h4 id="sessetpreloadspreloads"><code>ses.setPreloads(preloads)</code></h4> <ul> <li>
<code>preloads</code> String[] - An array of absolute path to preload scripts</li> </ul> <p>Adds scripts that will be executed on ALL web contents that are associated with this session just before normal <code>preload</code> scripts run.</p>   <h4 id="sesgetpreloads"><code>ses.getPreloads()</code></h4> <p>Returns <code>String[]</code> an array of paths to preload scripts that have been registered.</p>   <h4 id="sessetspellcheckerlanguageslanguages"><code>ses.setSpellCheckerLanguages(languages)</code></h4> <ul> <li>
<code>languages</code> String[] - An array of language codes to enable the spellchecker for.</li> </ul> <p>The built in spellchecker does not automatically detect what language a user is typing in. In order for the spell checker to correctly check their words you must call this API with an array of language codes. You can get the list of supported language codes with the <code>ses.availableSpellCheckerLanguages</code> property.</p> <p><strong>Note:</strong> On macOS the OS spellchecker is used and will detect your language automatically. This API is a no-op on macOS.</p>   <h4 id="sesgetspellcheckerlanguages"><code>ses.getSpellCheckerLanguages()</code></h4> <p>Returns <code>String[]</code> - An array of language codes the spellchecker is enabled for. If this list is empty the spellchecker will fallback to using <code>en-US</code>. By default on launch if this setting is an empty list Electron will try to populate this setting with the current OS locale. This setting is persisted across restarts.</p> <p><strong>Note:</strong> On macOS the OS spellchecker is used and has its own list of languages. This API is a no-op on macOS.</p>   <h4 id="sessetspellcheckerdictionarydownloadurlurl"><code>ses.setSpellCheckerDictionaryDownloadURL(url)</code></h4> <ul> <li>
<code>url</code> String - A base URL for Electron to download hunspell dictionaries from.</li> </ul> <p>By default Electron will download hunspell dictionaries from the Chromium CDN. If you want to override this behavior you can use this API to point the dictionary downloader at your own hosted version of the hunspell dictionaries. We publish a <code>hunspell_dictionaries.zip</code> file with each release which contains the files you need to host here, the file server must be <strong>case insensitive</strong> you must upload each file twice, once with the case it has in the ZIP file and once with the filename as all lower case.</p> <p>If the files present in <code>hunspell_dictionaries.zip</code> are available at <code>https://example.com/dictionaries/language-code.bdic</code> then you should call this api with <code>ses.setSpellCheckerDictionaryDownloadURL('https://example.com/dictionaries/')</code>. Please note the trailing slash. The URL to the dictionaries is formed as <code>${url}${filename}</code>.</p> <p><strong>Note:</strong> On macOS the OS spellchecker is used and therefore we do not download any dictionary files. This API is a no-op on macOS.</p>   <h4 id="seslistwordsinspellcheckerdictionary"><code>ses.listWordsInSpellCheckerDictionary()</code></h4> <p>Returns <code>Promise&lt;String[]&gt;</code> - An array of all words in app's custom dictionary. Resolves when the full dictionary is loaded from disk.</p>   <h4 id="sesaddwordtospellcheckerdictionaryword"><code>ses.addWordToSpellCheckerDictionary(word)</code></h4> <ul> <li>
<code>word</code> String - The word you want to add to the dictionary</li> </ul> <p>Returns <code>Boolean</code> - Whether the word was successfully written to the custom dictionary. This API will not work on non-persistent (in-memory) sessions.</p> <p><strong>Note:</strong> On macOS and Windows 10 this word will be written to the OS custom dictionary as well</p>   <h4 id="sesremovewordfromspellcheckerdictionaryword"><code>ses.removeWordFromSpellCheckerDictionary(word)</code></h4> <ul> <li>
<code>word</code> String - The word you want to remove from the dictionary</li> </ul> <p>Returns <code>Boolean</code> - Whether the word was successfully removed from the custom dictionary. This API will not work on non-persistent (in-memory) sessions.</p> <p><strong>Note:</strong> On macOS and Windows 10 this word will be removed from the OS custom dictionary as well</p>   <h4 id="sesloadextensionpath"><code>ses.loadExtension(path)</code></h4> <ul> <li>
<code>path</code> String - Path to a directory containing an unpacked Chrome extension</li> </ul> <p>Returns <code>Promise&lt;Extension&gt;</code> - resolves when the extension is loaded.</p> <p>This method will raise an exception if the extension could not be loaded. If there are warnings when installing the extension (e.g. if the extension requests an API that Electron does not support) then they will be logged to the console.</p> <p>Note that Electron does not support the full range of Chrome extensions APIs. See <a href="extensions#supported-extensions-apis">Supported Extensions APIs</a> for more details on what is supported.</p> <p>Note that in previous versions of Electron, extensions that were loaded would be remembered for future runs of the application. This is no longer the case: <code>loadExtension</code> must be called on every boot of your app if you want the extension to be loaded.</p> <pre data-language="js">const { app, session } = require('electron')
const path = require('path')

app.on('ready', async () =&gt; {
  await session.defaultSession.loadExtension(path.join(__dirname, 'react-devtools'))
  // Note that in order to use the React DevTools extension, you'll need to
  // download and unzip a copy of the extension.
})
</pre> <p>This API does not support loading packed (.crx) extensions.</p> <p><strong>Note:</strong> This API cannot be called before the <code>ready</code> event of the <code>app</code> module is emitted.</p> <p><strong>Note:</strong> Loading extensions into in-memory (non-persistent) sessions is not supported and will throw an error.</p>   <h4 id="sesremoveextensionextensionid"><code>ses.removeExtension(extensionId)</code></h4> <ul> <li>
<code>extensionId</code> String - ID of extension to remove</li> </ul> <p>Unloads an extension.</p> <p><strong>Note:</strong> This API cannot be called before the <code>ready</code> event of the <code>app</code> module is emitted.</p>   <h4 id="sesgetextensionextensionid"><code>ses.getExtension(extensionId)</code></h4> <ul> <li>
<code>extensionId</code> String - ID of extension to query</li> </ul> <p>Returns <code>Extension</code> | <code>null</code> - The loaded extension with the given ID.</p> <p><strong>Note:</strong> This API cannot be called before the <code>ready</code> event of the <code>app</code> module is emitted.</p>   <h4 id="sesgetallextensions"><code>ses.getAllExtensions()</code></h4> <p>Returns <code>Extension[]</code> - A list of all loaded extensions.</p> <p><strong>Note:</strong> This API cannot be called before the <code>ready</code> event of the <code>app</code> module is emitted.</p>   <h3 id="instance-properties">Instance Properties</h3> <p>The following properties are available on instances of <code>Session</code>:</p>   <h4 id="sesavailablespellcheckerlanguages-readonly">
<code>ses.availableSpellCheckerLanguages</code> <em>Readonly</em>
</h4> <p>A <code>String[]</code> array which consists of all the known available spell checker languages. Providing a language code to the <code>setSpellCheckerLanaguages</code> API that isn't in this array will result in an error.</p>   <h4 id="sescookies-readonly">
<code>ses.cookies</code> <em>Readonly</em>
</h4> <p>A <a href="cookies"><code>Cookies</code></a> object for this session.</p>   <h4 id="sesserviceworkers-readonly">
<code>ses.serviceWorkers</code> <em>Readonly</em>
</h4> <p>A <a href="service-workers"><code>ServiceWorkers</code></a> object for this session.</p>   <h4 id="seswebrequest-readonly">
<code>ses.webRequest</code> <em>Readonly</em>
</h4> <p>A <a href="web-request"><code>WebRequest</code></a> object for this session.</p>   <h4 id="sesprotocol-readonly">
<code>ses.protocol</code> <em>Readonly</em>
</h4> <p>A <a href="protocol"><code>Protocol</code></a> object for this session.</p> <pre data-language="javascript">const { app, session } = require('electron')
const path = require('path')

app.whenReady().then(() =&gt; {
  const protocol = session.fromPartition('some-partition').protocol
  protocol.registerFileProtocol('atom', (request, callback) =&gt; {
    const url = request.url.substr(7)
    callback({ path: path.normalize(`${__dirname}/${url}`) })
  }, (error) =&gt; {
    if (error) console.error('Failed to register protocol')
  })
})
</pre>   <h4 id="sesnetlog-readonly">
<code>ses.netLog</code> <em>Readonly</em>
</h4> <p>A <a href="net-log"><code>NetLog</code></a> object for this session.</p> <pre data-language="javascript">const { app, session } = require('electron')

app.whenReady().then(async () =&gt; {
  const netLog = session.fromPartition('some-partition').netLog
  netLog.startLogging('/path/to/net-log')
  // After some network events
  const path = await netLog.stopLogging()
  console.log('Net-logs written to', path)
})
</pre>
<div class="_attribution">
  <p class="_attribution-p">
    © GitHub Inc.<br>Licensed under the MIT license.<br>
    <a href="https://www.electronjs.org/docs/api/session" class="_attribution-link">https://www.electronjs.org/docs/api/session</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
