
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Active Record - Yii 2.0 - W3cubDocs</title>
  
  <meta name="description" content="Active Record provides an object-oriented interface for accessing and manipulating data stored in databases. An Active Record class is associated &hellip;">
  <meta name="keywords" content="active, record, yii, yii~2.0">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/yii~2.0/guide-db-active-record.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/yii~2.0.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/yii~2.0/" class="_nav-link" title="" style="margin-left:0;">Yii 2.0</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _yii">
				
				
<h1>Active Record 
</h1> <div class="toc"><ol>
<li><a href="#declaring-ar-classes">Declaring Active Record Classes</a></li> <li><a href="#db-connection">Connecting to Databases</a></li> <li><a href="#querying-data">Querying Data</a></li> <li><a href="#accessing-data">Accessing Data</a></li> <li><a href="#inserting-updating-data">Saving Data</a></li> <li><a href="#deleting-data">Deleting Data</a></li> <li><a href="#ar-life-cycles">Active Record Life Cycles</a></li> <li><a href="#transactional-operations">Working with Transactions</a></li> <li><a href="#optimistic-locks">Optimistic Locks</a></li> <li><a href="#relational-data">Working with Relational Data</a></li> <li><a href="#saving-relations">Saving Relations</a></li> <li><a href="#cross-database-relations">Cross-Database Relations</a></li> <li><a href="#customizing-query-classes">Customizing Query Classes</a></li> <li><a href="#selecting-extra-fields">Selecting extra fields</a></li>
</ol></div> <p><a href="http://en.wikipedia.org/wiki/Active_record_pattern">Active Record</a> provides an object-oriented interface for accessing and manipulating data stored in databases. An Active Record class is associated with a database table, an Active Record instance corresponds to a row of that table, and an <em>attribute</em> of an Active Record instance represents the value of a particular column in that row. Instead of writing raw SQL statements, you would access Active Record attributes and call Active Record methods to access and manipulate the data stored in database tables.</p> <p>For example, assume <code>Customer</code> is an Active Record class which is associated with the <code>customer</code> table and <code>name</code> is a column of the <code>customer</code> table. You can write the following code to insert a new row into the <code>customer</code> table:</p> <pre data-language="php">$customer = new Customer();
$customer-&gt;name = 'Qiang';
$customer-&gt;save();
</pre> <p>The above code is equivalent to using the following raw SQL statement for MySQL, which is less intuitive, more error prone, and may even have compatibility problems if you are using a different kind of database:</p> <pre data-language="php">$db-&gt;createCommand('INSERT INTO `customer` (`name`) VALUES (:name)', [
    ':name' =&gt; 'Qiang',
])-&gt;execute();
</pre> <p>Yii provides the Active Record support for the following relational databases:</p> <ul> <li>MySQL 4.1 or later: via <a href="yii-db-activerecord">yii\db\ActiveRecord</a>
</li> <li>PostgreSQL 7.3 or later: via <a href="yii-db-activerecord">yii\db\ActiveRecord</a>
</li> <li>SQLite 2 and 3: via <a href="yii-db-activerecord">yii\db\ActiveRecord</a>
</li> <li>Microsoft SQL Server 2008 or later: via <a href="yii-db-activerecord">yii\db\ActiveRecord</a>
</li> <li>Oracle: via <a href="yii-db-activerecord">yii\db\ActiveRecord</a>
</li> <li>CUBRID 9.3 or later: via <a href="yii-db-activerecord">yii\db\ActiveRecord</a> (Note that due to a <a href="http://jira.cubrid.org/browse/APIS-658">bug</a> in the cubrid PDO extension, quoting of values will not work, so you need CUBRID 9.3 as the client as well as the server)</li> <li>Sphinx: via <a href="yii-sphinx-activerecord">yii\sphinx\ActiveRecord</a>, requires the <code>yii2-sphinx</code> extension</li> <li>ElasticSearch: via <a href="yii-elasticsearch-activerecord">yii\elasticsearch\ActiveRecord</a>, requires the <code>yii2-elasticsearch</code> extension</li> </ul> <p>Additionally, Yii also supports using Active Record with the following NoSQL databases:</p> <ul> <li>Redis 2.6.12 or later: via <a href="yii-redis-activerecord">yii\redis\ActiveRecord</a>, requires the <code>yii2-redis</code> extension</li> <li>MongoDB 1.3.0 or later: via <a href="yii-mongodb-activerecord">yii\mongodb\ActiveRecord</a>, requires the <code>yii2-mongodb</code> extension</li> </ul> <p>In this tutorial, we will mainly describe the usage of Active Record for relational databases. However, most content described here are also applicable to Active Record for NoSQL databases.</p> <h2>Declaring Active Record Classes 
</h2>
<p>To get started, declare an Active Record class by extending <a href="yii-db-activerecord">yii\db\ActiveRecord</a>. </p> <h3>Setting a table name 
</h3>
<p>By default each Active Record class is associated with its database table. The <a href="yii-db-activerecord#tableName()-detail">tableName()</a> method returns the table name by converting the class name via <a href="yii-helpers-baseinflector#camel2id()-detail">yii\helpers\Inflector::camel2id()</a>. You may override this method if the table is not named after this convention.</p> <p>Also a default <a href="yii-db-connection#%24tablePrefix-detail">tablePrefix</a> can be applied. For example if <a href="yii-db-connection#%24tablePrefix-detail">tablePrefix</a> is <code>tbl_</code>, <code>Customer</code> becomes <code>tbl_customer</code> and <code>OrderItem</code> becomes <code>tbl_order_item</code>. </p> <p>If a table name is given as <code>{{%TableName}}</code>, then the percentage character <code>%</code> will be replaced with the table prefix. For example, <code>{{%post}}</code> becomes <code>{{tbl_post}}</code>. The brackets around the table name are used for <a href="guide-db-dao#quoting-table-and-column-names">quoting in an SQL query</a>.</p> <p>In the following example, we declare an Active Record class named <code>Customer</code> for the <code>customer</code> database table.</p> <pre data-language="php">namespace app\models;

use yii\db\ActiveRecord;

class Customer extends ActiveRecord
{
    const STATUS_INACTIVE = 0;
    const STATUS_ACTIVE = 1;
    
    /**
     * @return string the name of the table associated with this ActiveRecord class.
     */
    public static function tableName()
    {
        return '{{customer}}';
    }
}
</pre> <h3>Active records are called "models" 
</h3>
<p>Active Record instances are considered as <a href="guide-structure-models">models</a>. For this reason, we usually put Active Record classes under the <code>app\models</code> namespace (or other namespaces for keeping model classes). </p> <p>Because <a href="yii-db-activerecord">yii\db\ActiveRecord</a> extends from <a href="yii-base-model">yii\base\Model</a>, it inherits <em>all</em> <a href="guide-structure-models">model</a> features, such as attributes, validation rules, data serialization, etc.</p> <h2>Connecting to Databases 
</h2>
<p>By default, Active Record uses the <code>db</code> <a href="guide-structure-application-components">application component</a> as the <a href="yii-db-connection">DB connection</a> to access and manipulate the database data. As explained in <a href="guide-db-dao">Database Access Objects</a>, you can configure the <code>db</code> component in the application configuration like shown below,</p> <pre data-language="php">return [
    'components' =&gt; [
        'db' =&gt; [
            'class' =&gt; 'yii\db\Connection',
            'dsn' =&gt; 'mysql:host=localhost;dbname=testdb',
            'username' =&gt; 'demo',
            'password' =&gt; 'demo',
        ],
    ],
];
</pre> <p>If you want to use a different database connection other than the <code>db</code> component, you should override the <a href="yii-db-activerecord#getDb()-detail">getDb()</a> method:</p> <pre data-language="php">class Customer extends ActiveRecord
{
    // ...

    public static function getDb()
    {
        // use the "db2" application component
        return \Yii::$app-&gt;db2;  
    }
}
</pre> <h2>Querying Data 
</h2>
<p>After declaring an Active Record class, you can use it to query data from the corresponding database table. The process usually takes the following three steps:</p> <ol> <li>Create a new query object by calling the <a href="yii-db-activerecord#find()-detail">yii\db\ActiveRecord::find()</a> method;</li> <li>Build the query object by calling <a href="guide-db-query-builder#building-queries">query building methods</a>;</li> <li>Call a <a href="guide-db-query-builder#query-methods">query method</a> to retrieve data in terms of Active Record instances.</li> </ol> <p>As you can see, this is very similar to the procedure with <a href="guide-db-query-builder">query builder</a>. The only difference is that instead of using the <code>new</code> operator to create a query object, you call <a href="yii-db-activerecord#find()-detail">yii\db\ActiveRecord::find()</a> to return a new query object which is of class <a href="yii-db-activequery">yii\db\ActiveQuery</a>.</p> <p>Below are some examples showing how to use Active Query to query data:</p> <pre data-language="php">// return a single customer whose ID is 123
// SELECT * FROM `customer` WHERE `id` = 123
$customer = Customer::find()
    -&gt;where(['id' =&gt; 123])
    -&gt;one();

// return all active customers and order them by their IDs
// SELECT * FROM `customer` WHERE `status` = 1 ORDER BY `id`
$customers = Customer::find()
    -&gt;where(['status' =&gt; Customer::STATUS_ACTIVE])
    -&gt;orderBy('id')
    -&gt;all();

// return the number of active customers
// SELECT COUNT(*) FROM `customer` WHERE `status` = 1
$count = Customer::find()
    -&gt;where(['status' =&gt; Customer::STATUS_ACTIVE])
    -&gt;count();

// return all customers in an array indexed by customer IDs
// SELECT * FROM `customer`
$customers = Customer::find()
    -&gt;indexBy('id')
    -&gt;all();
</pre> <p>In the above, <code>$customer</code> is a <code>Customer</code> object while <code>$customers</code> is an array of <code>Customer</code> objects. They are all populated with the data retrieved from the <code>customer</code> table.</p> <blockquote class="info">
<p><strong>Info: </strong>Because <a href="yii-db-activequery">yii\db\ActiveQuery</a> extends from <a href="yii-db-query">yii\db\Query</a>, you can use <em>all</em> query building methods and query methods as described in the Section <a href="guide-db-query-builder">Query Builder</a>.</p> </blockquote> <p>Because it is a common task to query by primary key values or a set of column values, Yii provides two shortcut methods for this purpose:</p> <ul> <li>
<a href="yii-db-baseactiverecord#findOne()-detail">yii\db\ActiveRecord::findOne()</a>: returns a single Active Record instance populated with the first row of the query result.</li> <li>
<a href="yii-db-baseactiverecord#findAll()-detail">yii\db\ActiveRecord::findAll()</a>: returns an array of Active Record instances populated with <em>all</em> query result.</li> </ul> <p>Both methods can take one of the following parameter formats:</p> <ul> <li>a scalar value: the value is treated as the desired primary key value to be looked for. Yii will determine automatically which column is the primary key column by reading database schema information.</li> <li>an array of scalar values: the array is treated as the desired primary key values to be looked for.</li> <li>an associative array: the keys are column names and the values are the corresponding desired column values to be looked for. Please refer to <a href="guide-db-query-builder#hash-format">Hash Format</a> for more details.</li> </ul> <p>The following code shows how these methods can be used:</p> <pre data-language="php">// returns a single customer whose ID is 123
// SELECT * FROM `customer` WHERE `id` = 123
$customer = Customer::findOne(123);

// returns customers whose ID is 100, 101, 123 or 124
// SELECT * FROM `customer` WHERE `id` IN (100, 101, 123, 124)
$customers = Customer::findAll([100, 101, 123, 124]);

// returns an active customer whose ID is 123
// SELECT * FROM `customer` WHERE `id` = 123 AND `status` = 1
$customer = Customer::findOne([
    'id' =&gt; 123,
    'status' =&gt; Customer::STATUS_ACTIVE,
]);

// returns all inactive customers
// SELECT * FROM `customer` WHERE `status` = 0
$customers = Customer::findAll([
    'status' =&gt; Customer::STATUS_INACTIVE,
]);
</pre> <blockquote class="note">
<p><strong>Note: </strong>Neither <a href="yii-db-baseactiverecord#findOne()-detail">yii\db\ActiveRecord::findOne()</a> nor <a href="yii-db-activequery#one()-detail">yii\db\ActiveQuery::one()</a> will add <code>LIMIT 1</code> to the generated SQL statement. If your query may return many rows of data, you should call <code>limit(1)</code> explicitly to improve the performance, e.g., <code>Customer::find()-&gt;limit(1)-&gt;one()</code>.</p> </blockquote> <p>Besides using query building methods, you can also write raw SQLs to query data and populate the results into Active Record objects. You can do so by calling the <a href="yii-db-activerecord#findBySql()-detail">yii\db\ActiveRecord::findBySql()</a> method:</p> <pre data-language="php">// returns all inactive customers
$sql = 'SELECT * FROM customer WHERE status=:status';
$customers = Customer::findBySql($sql, [':status' =&gt; Customer::STATUS_INACTIVE])-&gt;all();
</pre> <p>Do not call extra query building methods after calling <a href="yii-db-activerecord#findBySql()-detail">findBySql()</a> as they will be ignored.</p> <h2>Accessing Data 
</h2>
<p>As aforementioned, the data brought back from the database are populated into Active Record instances, and each row of the query result corresponds to a single Active Record instance. You can access the column values by accessing the attributes of the Active Record instances, for example,</p> <pre data-language="php">// "id" and "email" are the names of columns in the "customer" table
$customer = Customer::findOne(123);
$id = $customer-&gt;id;
$email = $customer-&gt;email;
</pre> <blockquote class="note">
<p><strong>Note: </strong>The Active Record attributes are named after the associated table columns in a case-sensitive manner. Yii automatically defines an attribute in Active Record for every column of the associated table. You should NOT redeclare any of the attributes. </p> </blockquote> <p>Because Active Record attributes are named after table columns, you may find you are writing PHP code like <code>$customer-&gt;first_name</code>, which uses underscores to separate words in attribute names if your table columns are named in this way. If you are concerned about code style consistency, you should rename your table columns accordingly (to use camelCase, for example).</p> <h3>Data Transformation 
</h3>
<p>It often happens that the data being entered and/or displayed are in a format which is different from the one used in storing the data in a database. For example, in the database you are storing customers' birthdays as UNIX timestamps (which is not a good design, though), while in most cases you would like to manipulate birthdays as strings in the format of <code>'YYYY/MM/DD'</code>. To achieve this goal, you can define <em>data transformation</em> methods in the <code>Customer</code> Active Record class like the following:</p> <pre data-language="php">class Customer extends ActiveRecord
{
    // ...

    public function getBirthdayText()
    {
        return date('Y/m/d', $this-&gt;birthday);
    }
    
    public function setBirthdayText($value)
    {
        $this-&gt;birthday = strtotime($value);
    }
}
</pre> <p>Now in your PHP code, instead of accessing <code>$customer-&gt;birthday</code>, you would access <code>$customer-&gt;birthdayText</code>, which will allow you to input and display customer birthdays in the format of <code>'YYYY/MM/DD'</code>.</p> <blockquote class="tip">
<p><strong>Tip: </strong>The above example shows a generic way of transforming data in different formats. If you are working with date values, you may use <a href="guide-tutorial-core-validators#date">DateValidator</a> and <a href="yii-jui-datepicker">DatePicker</a>, which is easier to use and more powerful.</p> </blockquote> <h3>Retrieving Data in Arrays 
</h3>
<p>While retrieving data in terms of Active Record objects is convenient and flexible, it is not always desirable when you have to bring back a large amount of data due to the big memory footprint. In this case, you can retrieve data using PHP arrays by calling <a href="yii-db-activequerytrait#asArray()-detail">asArray()</a> before executing a query method:</p> <pre data-language="php">// return all customers
// each customer is returned as an associative array
$customers = Customer::find()
    -&gt;asArray()
    -&gt;all();
</pre> <blockquote class="note">
<p><strong>Note: </strong>While this method saves memory and improves performance, it is closer to the lower DB abstraction layer and you will lose most of the Active Record features. A very important distinction lies in the data type of the column values. When you return data in Active Record instances, column values will be automatically typecast according to the actual column types; on the other hand when you return data in arrays, column values will be strings (since they are the result of PDO without any processing), regardless their actual column types.</p> </blockquote> <h3>Retrieving Data in Batches 
</h3>
<p>In <a href="guide-db-query-builder">Query Builder</a>, we have explained that you may use <em>batch query</em> to minimize your memory usage when querying a large amount of data from the database. You may use the same technique in Active Record. For example,</p> <pre data-language="php">// fetch 10 customers at a time
foreach (Customer::find()-&gt;batch(10) as $customers) {
    // $customers is an array of 10 or fewer Customer objects
}

// fetch 10 customers at a time and iterate them one by one
foreach (Customer::find()-&gt;each(10) as $customer) {
    // $customer is a Customer object
}

// batch query with eager loading
foreach (Customer::find()-&gt;with('orders')-&gt;each() as $customer) {
    // $customer is a Customer object with the 'orders' relation populated
}
</pre> <h2>Saving Data 
</h2>
<p>Using Active Record, you can easily save data to the database by taking the following steps:</p> <ol> <li>Prepare an Active Record instance</li> <li>Assign new values to Active Record attributes</li> <li>Call <a href="yii-db-baseactiverecord#save()-detail">yii\db\ActiveRecord::save()</a> to save the data into database.</li> </ol> <p>For example,</p> <pre data-language="php">// insert a new row of data
$customer = new Customer();
$customer-&gt;name = 'James';
$customer-&gt;email = 'james@example.com';
$customer-&gt;save();

// update an existing row of data
$customer = Customer::findOne(123);
$customer-&gt;email = 'james@newexample.com';
$customer-&gt;save();
</pre> <p>The <a href="yii-db-baseactiverecord#save()-detail">save()</a> method can either insert or update a row of data, depending on the state of the Active Record instance. If the instance is newly created via the <code>new</code> operator, calling <a href="yii-db-baseactiverecord#save()-detail">save()</a> will cause insertion of a new row; If the instance is the result of a query method, calling <a href="yii-db-baseactiverecord#save()-detail">save()</a> will update the row associated with the instance. </p> <p>You can differentiate the two states of an Active Record instance by checking its <a href="yii-db-baseactiverecord#%24isNewRecord-detail">isNewRecord</a> property value. This property is also used by <a href="yii-db-baseactiverecord#save()-detail">save()</a> internally as follows:</p> <pre data-language="php">public function save($runValidation = true, $attributeNames = null)
{
    if ($this-&gt;getIsNewRecord()) {
        return $this-&gt;insert($runValidation, $attributeNames);
    } else {
        return $this-&gt;update($runValidation, $attributeNames) !== false;
    }
}
</pre> <blockquote class="tip">
<p><strong>Tip: </strong>You can call <a href="yii-db-activerecord#insert()-detail">insert()</a> or <a href="yii-db-activerecord#update()-detail">update()</a> directly to insert or update a row.</p> </blockquote> <h3>Data Validation 
</h3>
<p>Because <a href="yii-db-activerecord">yii\db\ActiveRecord</a> extends from <a href="yii-base-model">yii\base\Model</a>, it shares the same <a href="guide-input-validation">data validation</a> feature. You can declare validation rules by overriding the <a href="yii-base-model#rules()-detail">rules()</a> method and perform data validation by calling the <a href="yii-base-model#validate()-detail">validate()</a> method.</p> <p>When you call <a href="yii-db-baseactiverecord#save()-detail">save()</a>, by default it will call <a href="yii-base-model#validate()-detail">validate()</a> automatically. Only when the validation passes, will it actually save the data; otherwise it will simply return <code>false</code>, and you can check the <a href="yii-base-model#%24errors-detail">errors</a> property to retrieve the validation error messages. </p> <blockquote class="tip">
<p><strong>Tip: </strong>If you are certain that your data do not need validation (e.g., the data comes from trustable sources), you can call <code>save(false)</code> to skip the validation.</p> </blockquote> <h3>Massive Assignment 
</h3>
<p>Like normal <a href="guide-structure-models">models</a>, Active Record instances also enjoy the <a href="guide-structure-models#massive-assignment">massive assignment feature</a>. Using this feature, you can assign values to multiple attributes of an Active Record instance in a single PHP statement, like shown below. Do remember that only <a href="guide-structure-models#safe-attributes">safe attributes</a> can be massively assigned, though.</p> <pre data-language="php">$values = [
    'name' =&gt; 'James',
    'email' =&gt; 'james@example.com',
];

$customer = new Customer();

$customer-&gt;attributes = $values;
$customer-&gt;save();
</pre> <h3>Updating Counters 
</h3>
<p>It is a common task to increment or decrement a column in a database table. We call these columns "counter columns". You can use <a href="yii-db-baseactiverecord#updateCounters()-detail">updateCounters()</a> to update one or multiple counter columns. For example,</p> <pre data-language="php">$post = Post::findOne(100);

// UPDATE `post` SET `view_count` = `view_count` + 1 WHERE `id` = 100
$post-&gt;updateCounters(['view_count' =&gt; 1]);
</pre> <blockquote class="note">
<p><strong>Note: </strong>If you use <a href="yii-db-baseactiverecord#save()-detail">yii\db\ActiveRecord::save()</a> to update a counter column, you may end up with inaccurate result, because it is likely the same counter is being saved by multiple requests which read and write the same counter value.</p> </blockquote> <h3>Dirty Attributes 
</h3>
<p>When you call <a href="yii-db-baseactiverecord#save()-detail">save()</a> to save an Active Record instance, only <em>dirty attributes</em> are being saved. An attribute is considered <em>dirty</em> if its value has been modified since it was loaded from DB or saved to DB most recently. Note that data validation will be performed regardless if the Active Record instance has dirty attributes or not.</p> <p>Active Record automatically maintains the list of dirty attributes. It does so by maintaining an older version of the attribute values and comparing them with the latest one. You can call <a href="yii-db-baseactiverecord#getDirtyAttributes()-detail">yii\db\ActiveRecord::getDirtyAttributes()</a> to get the attributes that are currently dirty. You can also call <a href="yii-db-baseactiverecord#markAttributeDirty()-detail">yii\db\ActiveRecord::markAttributeDirty()</a> to explicitly mark an attribute as dirty.</p> <p>If you are interested in the attribute values prior to their most recent modification, you may call <a href="yii-db-baseactiverecord#getOldAttributes()-detail">getOldAttributes()</a> or <a href="yii-db-baseactiverecord#getOldAttribute()-detail">getOldAttribute()</a>.</p> <blockquote class="note">
<p><strong>Note: </strong>The comparison of old and new values will be done using the <code>===</code> operator so a value will be considered dirty even if it has the same value but a different type. This is often the case when the model receives user input from HTML forms where every value is represented as a string. To ensure the correct type for e.g. integer values you may apply a <a href="guide-input-validation#data-filtering">validation filter</a>: <code>['attributeName', 'filter', 'filter' =&gt; 'intval']</code>. This works with all the typecasting functions of PHP like <a href="http://php.net/manual/en/function.intval.php">intval()</a>, <a href="http://php.net/manual/en/function.floatval.php">floatval()</a>, <a href="http://php.net/manual/en/function.boolval.php">boolval</a>, etc...</p> </blockquote> <h3>Default Attribute Values 
</h3>
<p>Some of your table columns may have default values defined in the database. Sometimes, you may want to pre-populate your Web form for an Active Record instance with these default values. To avoid writing the same default values again, you can call <a href="yii-db-activerecord#loadDefaultValues()-detail">loadDefaultValues()</a> to populate the DB-defined default values into the corresponding Active Record attributes:</p> <pre data-language="php">$customer = new Customer();
$customer-&gt;loadDefaultValues();
// $customer-&gt;xyz will be assigned the default value declared when defining the "xyz" column
</pre> <h3>Attributes Typecasting 
</h3>
<p>Being populated by query results <a href="yii-db-activerecord">yii\db\ActiveRecord</a> performs automatic typecast for its attribute values, using information from <a href="guide-db-dao#database-schema">database table schema</a>. This allows data retrieved from table column declared as integer to be populated in ActiveRecord instance with PHP integer, boolean with boolean and so on. However, typecasting mechanism has several limitations:</p> <ul> <li>Float values are not be converted and will be represented as strings, otherwise they may loose precision.</li> <li>Conversion of the integer values depends on the integer capacity of the operation system you use. In particular: values of column declared as 'unsigned integer' or 'big integer' will be converted to PHP integer only at 64-bit operation system, while on 32-bit ones - they will be represented as strings.</li> </ul> <p>Note that attribute typecast is performed only during populating ActiveRecord instance from query result. There is no automatic conversion for the values loaded from HTTP request or set directly via property access. The table schema will also be used while preparing SQL statements for the ActiveRecord data saving, ensuring values are bound to the query with correct type. However, ActiveRecord instance attribute values will not be converted during saving process.</p> <blockquote class="tip">
<p><strong>Tip: </strong>you may use <a href="yii-behaviors-attributetypecastbehavior">yii\behaviors\AttributeTypecastBehavior</a> to facilitate attribute values typecasting on ActiveRecord validation or saving.</p> </blockquote> <h3>Updating Multiple Rows 
</h3>
<p>The methods described above all work on individual Active Record instances, causing inserting or updating of individual table rows. To update multiple rows simultaneously, you should call <a href="yii-db-activerecord#updateAll()-detail">updateAll()</a>, instead, which is a static method.</p> <pre data-language="php">// UPDATE `customer` SET `status` = 1 WHERE `email` LIKE `%@example.com%`
Customer::updateAll(['status' =&gt; Customer::STATUS_ACTIVE], ['like', 'email', '@example.com']);
</pre> <p>Similarly, you can call <a href="yii-db-activerecord#updateAllCounters()-detail">updateAllCounters()</a> to update counter columns of multiple rows at the same time.</p> <pre data-language="php">// UPDATE `customer` SET `age` = `age` + 1
Customer::updateAllCounters(['age' =&gt; 1]);
</pre> <h2>Deleting Data 
</h2>
<p>To delete a single row of data, first retrieve the Active Record instance corresponding to that row and then call the <a href="yii-db-activerecord#delete()-detail">yii\db\ActiveRecord::delete()</a> method.</p> <pre data-language="php">$customer = Customer::findOne(123);
$customer-&gt;delete();
</pre> <p>You can call <a href="yii-db-activerecord#deleteAll()-detail">yii\db\ActiveRecord::deleteAll()</a> to delete multiple or all rows of data. For example,</p> <pre data-language="php">Customer::deleteAll(['status' =&gt; Customer::STATUS_INACTIVE]);
</pre> <blockquote class="note">
<p><strong>Note: </strong>Be very careful when calling <a href="yii-db-activerecord#deleteAll()-detail">deleteAll()</a> because it may totally erase all data from your table if you make a mistake in specifying the condition.</p> </blockquote> <h2>Active Record Life Cycles 
</h2>
<p>It is important to understand the life cycles of Active Record when it is used for different purposes. During each life cycle, a certain sequence of methods will be invoked, and you can override these methods to get a chance to customize the life cycle. You can also respond to certain Active Record events triggered during a life cycle to inject your custom code. These events are especially useful when you are developing Active Record <a href="guide-concept-behaviors">behaviors</a> which need to customize Active Record life cycles.</p> <p>In the following, we will summarize the various Active Record life cycles and the methods/events that are involved in the life cycles.</p> <h3>New Instance Life Cycle 
</h3>
<p>When creating a new Active Record instance via the <code>new</code> operator, the following life cycle will happen:</p> <ol> <li>Class constructor.</li> <li>
<a href="yii-db-baseactiverecord#init()-detail">init()</a>: triggers an <a href="yii-db-baseactiverecord#EVENT_INIT-detail">EVENT_INIT</a> event.</li> </ol> <h3>Querying Data Life Cycle 
</h3>
<p>When querying data through one of the <a href="#querying-data">querying methods</a>, each newly populated Active Record will undergo the following life cycle:</p> <ol> <li>Class constructor.</li> <li>
<a href="yii-db-baseactiverecord#init()-detail">init()</a>: triggers an <a href="yii-db-baseactiverecord#EVENT_INIT-detail">EVENT_INIT</a> event.</li> <li>
<a href="yii-db-baseactiverecord#afterFind()-detail">afterFind()</a>: triggers an <a href="yii-db-baseactiverecord#EVENT_AFTER_FIND-detail">EVENT_AFTER_FIND</a> event.</li> </ol> <h3>Saving Data Life Cycle 
</h3>
<p>When calling <a href="yii-db-baseactiverecord#save()-detail">save()</a> to insert or update an Active Record instance, the following life cycle will happen:</p> <ol> <li>
<p>an <a href="yii-base-model#EVENT_BEFORE_VALIDATE-detail">EVENT_BEFORE_VALIDATE</a> event. If the method returns <code>false</code> or <a href="yii-base-modelevent#%24isValid-detail">yii\base\ModelEvent::$isValid</a> is <code>false</code>, the rest of the steps will be skipped.</p> </li> <li>Performs data validation. If data validation fails, the steps after Step 3 will be skipped. </li> <li>
<p>an <a href="yii-base-model#EVENT_AFTER_VALIDATE-detail">EVENT_AFTER_VALIDATE</a> event.</p> </li> <li>
<p>an <a href="yii-db-baseactiverecord#EVENT_BEFORE_INSERT-detail">EVENT_BEFORE_INSERT</a> or <a href="yii-db-baseactiverecord#EVENT_BEFORE_UPDATE-detail">EVENT_BEFORE_UPDATE</a> event. If the method returns <code>false</code> or <a href="yii-base-modelevent#%24isValid-detail">yii\base\ModelEvent::$isValid</a> is <code>false</code>, the rest of the steps will be skipped.</p> </li> <li>Performs the actual data insertion or updating.</li> <li>
<p>an <a href="yii-db-baseactiverecord#EVENT_AFTER_INSERT-detail">EVENT_AFTER_INSERT</a> or <a href="yii-db-baseactiverecord#EVENT_AFTER_UPDATE-detail">EVENT_AFTER_UPDATE</a> event.</p> </li> </ol> <h3>Deleting Data Life Cycle 
</h3>
<p>When calling <a href="yii-db-activerecord#delete()-detail">delete()</a> to delete an Active Record instance, the following life cycle will happen:</p> <ol> <li>
<p>an <a href="yii-db-baseactiverecord#EVENT_BEFORE_DELETE-detail">EVENT_BEFORE_DELETE</a> event. If the method returns <code>false</code> or <a href="yii-base-modelevent#%24isValid-detail">yii\base\ModelEvent::$isValid</a> is <code>false</code>, the rest of the steps will be skipped.</p> </li> <li>Performs the actual data deletion.</li> <li>
<p>an <a href="yii-db-baseactiverecord#EVENT_AFTER_DELETE-detail">EVENT_AFTER_DELETE</a> event.</p> </li> </ol> <blockquote class="note">
<p><strong>Note: </strong>Calling any of the following methods will NOT initiate any of the above life cycles because they work on the database directly and not on a record basis:</p> <ul> <li>
<a href="yii-db-activerecord#updateAll()-detail">yii\db\ActiveRecord::updateAll()</a> </li> <li><a href="yii-db-activerecord#deleteAll()-detail">yii\db\ActiveRecord::deleteAll()</a></li> <li>
<a href="yii-db-baseactiverecord#updateCounters()-detail">yii\db\ActiveRecord::updateCounters()</a> </li> <li>
<a href="yii-db-activerecord#updateAllCounters()-detail">yii\db\ActiveRecord::updateAllCounters()</a> </li> </ul> </blockquote> <h3>Refreshing Data Life Cycle 
</h3>
<p>When calling <a href="yii-db-baseactiverecord#refresh()-detail">refresh()</a> to refresh an Active Record instance, the <a href="yii-db-baseactiverecord#EVENT_AFTER_REFRESH-detail">EVENT_AFTER_REFRESH</a> event is triggered if refresh is successful and the method returns <code>true</code>.</p> <h2>Working with Transactions 
</h2>
<p>There are two ways of using <a href="guide-db-dao#performing-transactions">transactions</a> while working with Active Record. </p> <p>The first way is to explicitly enclose Active Record method calls in a transactional block, like shown below,</p> <pre data-language="php">$customer = Customer::findOne(123);

Customer::getDb()-&gt;transaction(function($db) use ($customer) {
    $customer-&gt;id = 200;
    $customer-&gt;save();
    // ...other DB operations...
});

// or alternatively

$transaction = Customer::getDb()-&gt;beginTransaction();
try {
    $customer-&gt;id = 200;
    $customer-&gt;save();
    // ...other DB operations...
    $transaction-&gt;commit();
} catch(\Exception $e) {
    $transaction-&gt;rollBack();
    throw $e;
} catch(\Throwable $e) {
    $transaction-&gt;rollBack();
    throw $e;
}
</pre> <blockquote class="note">
<p><strong>Note: </strong>in the above code we have two catch-blocks for compatibility with PHP 5.x and PHP 7.x. <code>\Exception</code> implements the <a href="http://php.net/manual/en/class.throwable.php"><code>\Throwable</code> interface</a> since PHP 7.0, so you can skip the part with <code>\Exception</code> if your app uses only PHP 7.0 and higher.</p> </blockquote> <p>The second way is to list the DB operations that require transactional support in the <a href="yii-db-activerecord#transactions()-detail">yii\db\ActiveRecord::transactions()</a> method. For example,</p> <pre data-language="php">class Customer extends ActiveRecord
{
    public function transactions()
    {
        return [
            'admin' =&gt; self::OP_INSERT,
            'api' =&gt; self::OP_INSERT | self::OP_UPDATE | self::OP_DELETE,
            // the above is equivalent to the following:
            // 'api' =&gt; self::OP_ALL,
        ];
    }
}
</pre> <p>The <a href="yii-db-activerecord#transactions()-detail">yii\db\ActiveRecord::transactions()</a> method should return an array whose keys are <a href="guide-structure-models#scenarios">scenario</a> names and values are the corresponding operations that should be enclosed within transactions. You should use the following constants to refer to different DB operations:</p> <ul> <li>
<a href="yii-db-activerecord#OP_INSERT-detail">OP_INSERT</a>: insertion operation performed by <a href="yii-db-activerecord#insert()-detail">insert()</a>;</li> <li>
<a href="yii-db-activerecord#OP_UPDATE-detail">OP_UPDATE</a>: update operation performed by <a href="yii-db-activerecord#update()-detail">update()</a>;</li> <li>
<a href="yii-db-activerecord#OP_DELETE-detail">OP_DELETE</a>: deletion operation performed by <a href="yii-db-activerecord#delete()-detail">delete()</a>.</li> </ul> <p>Use the <code>|</code> operators to concatenate the above constants to indicate multiple operations. You may also use the shortcut constant <a href="yii-db-activerecord#OP_ALL-detail">OP_ALL</a> to refer to all three operations above.</p> <p>Transactions that are created using this method will be started before calling <a href="yii-db-baseactiverecord#beforeSave()-detail">beforeSave()</a> and will be committed after <a href="yii-db-baseactiverecord#afterSave()-detail">afterSave()</a> has run.</p> <h2>Optimistic Locks 
</h2>
<p>Optimistic locking is a way to prevent conflicts that may occur when a single row of data is being updated by multiple users. For example, both user A and user B are editing the same wiki article at the same time. After user A saves his edits, user B clicks on the "Save" button in an attempt to save his edits as well. Because user B was actually working on an outdated version of the article, it would be desirable to have a way to prevent him from saving the article and show him some hint message.</p> <p>Optimistic locking solves the above problem by using a column to record the version number of each row. When a row is being saved with an outdated version number, a <a href="yii-db-staleobjectexception">yii\db\StaleObjectException</a> exception will be thrown, which prevents the row from being saved. Optimistic locking is only supported when you update or delete an existing row of data using <a href="yii-db-activerecord#update()-detail">yii\db\ActiveRecord::update()</a> or <a href="yii-db-activerecord#delete()-detail">yii\db\ActiveRecord::delete()</a>, respectively.</p> <p>To use optimistic locking,</p> <ol> <li>Create a column in the DB table associated with the Active Record class to store the version number of each row. The column should be of big integer type (in MySQL it would be <code>BIGINT DEFAULT 0</code>).</li> <li>Override the <a href="yii-db-baseactiverecord#optimisticLock()-detail">yii\db\ActiveRecord::optimisticLock()</a> method to return the name of this column.</li> <li>In the Web form that takes user inputs, add a hidden field to store the current version number of the row being updated. Be sure your version attribute has input validation rules and validates successfully.</li> <li>In the controller action that updates the row using Active Record, try and catch the <a href="yii-db-staleobjectexception">yii\db\StaleObjectException</a> exception. Implement necessary business logic (e.g. merging the changes, prompting staled data) to resolve the conflict.</li> </ol> <p>For example, assume the version column is named as <code>version</code>. You can implement optimistic locking with the code like the following.</p> <pre data-language="php">// ------ view code -------

use yii\helpers\Html;

// ...other input fields
echo Html::activeHiddenInput($model, 'version');


// ------ controller code -------

use yii\db\StaleObjectException;

public function actionUpdate($id)
{
    $model = $this-&gt;findModel($id);

    try {
        if ($model-&gt;load(Yii::$app-&gt;request-&gt;post()) &amp;&amp; $model-&gt;save()) {
            return $this-&gt;redirect(['view', 'id' =&gt; $model-&gt;id]);
        } else {
            return $this-&gt;render('update', [
                'model' =&gt; $model,
            ]);
        }
    } catch (StaleObjectException $e) {
        // logic to resolve the conflict
    }
}
</pre> <h2>Working with Relational Data 
</h2>
<p>Besides working with individual database tables, Active Record is also capable of bringing together related data, making them readily accessible through the primary data. For example, the customer data is related with the order data because one customer may have placed one or multiple orders. With appropriate declaration of this relation, you'll be able to access a customer's order information using the expression <code>$customer-&gt;orders</code> which gives back the customer's order information in terms of an array of <code>Order</code> Active Record instances.</p> <h3>Declaring Relations 
</h3>
<p>To work with relational data using Active Record, you first need to declare relations in Active Record classes. The task is as simple as declaring a <em>relation method</em> for every interested relation, like the following,</p> <pre data-language="php">class Customer extends ActiveRecord
{
    // ...

    public function getOrders()
    {
        return $this-&gt;hasMany(Order::className(), ['customer_id' =&gt; 'id']);
    }
}

class Order extends ActiveRecord
{
    // ...

    public function getCustomer()
    {
        return $this-&gt;hasOne(Customer::className(), ['id' =&gt; 'customer_id']);
    }
}
</pre> <p>In the above code, we have declared an <code>orders</code> relation for the <code>Customer</code> class, and a <code>customer</code> relation for the <code>Order</code> class. </p> <p>Each relation method must be named as <code>getXyz</code>. We call <code>xyz</code> (the first letter is in lower case) the <em>relation name</em>. Note that relation names are <em>case sensitive</em>.</p> <p>While declaring a relation, you should specify the following information:</p> <ul> <li>the multiplicity of the relation: specified by calling either <a href="yii-db-baseactiverecord#hasMany()-detail">hasMany()</a> or <a href="yii-db-baseactiverecord#hasOne()-detail">hasOne()</a>. In the above example you may easily read in the relation declarations that a customer has many orders while an order only has one customer.</li> <li>the name of the related Active Record class: specified as the first parameter to either <a href="yii-db-baseactiverecord#hasMany()-detail">hasMany()</a> or <a href="yii-db-baseactiverecord#hasOne()-detail">hasOne()</a>. A recommended practice is to call <code>Xyz::className()</code> to get the class name string so that you can receive IDE auto-completion support as well as error detection at compiling stage. </li> <li>
<p>the link between the two types of data: specifies the column(s) through which the two types of data are related. The array values are the columns of the primary data (represented by the Active Record class that you are declaring relations), while the array keys are the columns of the related data.</p> <p>An easy rule to remember this is, as you see in the example above, you write the column that belongs to the related Active Record directly next to it. You see there that <code>customer_id</code> is a property of <code>Order</code> and <code>id</code> is a property of <code>Customer</code>.</p> </li> </ul> <h3>Accessing Relational Data 
</h3>
<p>After declaring relations, you can access relational data through relation names. This is just like accessing an object <a href="guide-concept-properties">property</a> defined by the relation method. For this reason, we call it <em>relation property</em>. For example,</p> <pre data-language="php">// SELECT * FROM `customer` WHERE `id` = 123
$customer = Customer::findOne(123);

// SELECT * FROM `order` WHERE `customer_id` = 123
// $orders is an array of Order objects
$orders = $customer-&gt;orders;
</pre> <blockquote class="info">
<p><strong>Info: </strong>When you declare a relation named <code>xyz</code> via a getter method <code>getXyz()</code>, you will be able to access <code>xyz</code> like an <a href="guide-concept-properties">object property</a>. Note that the name is case sensitive.</p> </blockquote> <p>If a relation is declared with <a href="yii-db-baseactiverecord#hasMany()-detail">hasMany()</a>, accessing this relation property will return an array of the related Active Record instances; if a relation is declared with <a href="yii-db-baseactiverecord#hasOne()-detail">hasOne()</a>, accessing the relation property will return the related Active Record instance or <code>null</code> if no related data is found.</p> <p>When you access a relation property for the first time, a SQL statement will be executed, like shown in the above example. If the same property is accessed again, the previous result will be returned without re-executing the SQL statement. To force re-executing the SQL statement, you should unset the relation property first: <code>unset($customer-&gt;orders)</code>.</p> <blockquote class="note">
<p><strong>Note: </strong>While this concept looks similar to the <a href="guide-concept-properties">object property</a> feature, there is an important difference. For normal object properties the property value is of the same type as the defining getter method. A relation method however returns an <a href="yii-db-activequery">yii\db\ActiveQuery</a> instance, while accessing a relation property will either return a <a href="yii-db-activerecord">yii\db\ActiveRecord</a> instance or an array of these.</p> <pre data-language="php">$customer-&gt;orders; // is an array of `Order` objects
$customer-&gt;getOrders(); // returns an ActiveQuery instance
</pre> <p>This is useful for creating customized queries, which is described in the next section.</p> </blockquote> <h3>Dynamic Relational Query 
</h3>
<p>Because a relation method returns an instance of <a href="yii-db-activequery">yii\db\ActiveQuery</a>, you can further build this query using query building methods before performing DB query. For example,</p> <pre data-language="php">$customer = Customer::findOne(123);

// SELECT * FROM `order` WHERE `customer_id` = 123 AND `subtotal` &gt; 200 ORDER BY `id`
$orders = $customer-&gt;getOrders()
    -&gt;where(['&gt;', 'subtotal', 200])
    -&gt;orderBy('id')
    -&gt;all();
</pre> <p>Unlike accessing a relation property, each time you perform a dynamic relational query via a relation method, a SQL statement will be executed, even if the same dynamic relational query was performed before.</p> <p>Sometimes you may even want to parametrize a relation declaration so that you can more easily perform dynamic relational query. For example, you may declare a <code>bigOrders</code> relation as follows, </p> <pre data-language="php">class Customer extends ActiveRecord
{
    public function getBigOrders($threshold = 100)
    {
        return $this-&gt;hasMany(Order::className(), ['customer_id' =&gt; 'id'])
            -&gt;where('subtotal &gt; :threshold', [':threshold' =&gt; $threshold])
            -&gt;orderBy('id');
    }
}
</pre> <p>Then you will be able to perform the following relational queries:</p> <pre data-language="php">// SELECT * FROM `order` WHERE `customer_id` = 123 AND `subtotal` &gt; 200 ORDER BY `id`
$orders = $customer-&gt;getBigOrders(200)-&gt;all();

// SELECT * FROM `order` WHERE `customer_id` = 123 AND `subtotal` &gt; 100 ORDER BY `id`
$orders = $customer-&gt;bigOrders;
</pre> <h3>Relations via a Junction Table 
</h3>
<p>In database modelling, when the multiplicity between two related tables is many-to-many, a <a href="https://en.wikipedia.org/wiki/Junction_table">junction table</a> is usually introduced. For example, the <code>order</code> table and the <code>item</code> table may be related via a junction table named <code>order_item</code>. One order will then correspond to multiple order items, while one product item will also correspond to multiple order items.</p> <p>When declaring such relations, you would call either <a href="yii-db-activerelationtrait#via()-detail">via()</a> or <a href="yii-db-activequery#viaTable()-detail">viaTable()</a> to specify the junction table. The difference between <a href="yii-db-activerelationtrait#via()-detail">via()</a> and <a href="yii-db-activequery#viaTable()-detail">viaTable()</a> is that the former specifies the junction table in terms of an existing relation name while the latter directly uses the junction table. For example,</p> <pre data-language="php">class Order extends ActiveRecord
{
    public function getItems()
    {
        return $this-&gt;hasMany(Item::className(), ['id' =&gt; 'item_id'])
            -&gt;viaTable('order_item', ['order_id' =&gt; 'id']);
    }
}
</pre> <p>or alternatively,</p> <pre data-language="php">class Order extends ActiveRecord
{
    public function getOrderItems()
    {
        return $this-&gt;hasMany(OrderItem::className(), ['order_id' =&gt; 'id']);
    }

    public function getItems()
    {
        return $this-&gt;hasMany(Item::className(), ['id' =&gt; 'item_id'])
            -&gt;via('orderItems');
    }
}
</pre> <p>The usage of relations declared with a junction table is the same as that of normal relations. For example,</p> <pre data-language="php">// SELECT * FROM `order` WHERE `id` = 100
$order = Order::findOne(100);

// SELECT * FROM `order_item` WHERE `order_id` = 100
// SELECT * FROM `item` WHERE `item_id` IN (...)
// returns an array of Item objects
$items = $order-&gt;items;
</pre> <h3>Lazy Loading and Eager Loading 
</h3>
<p>In <a href="#accessing-relational-data">Accessing Relational Data</a>, we explained that you can access a relation property of an Active Record instance like accessing a normal object property. A SQL statement will be executed only when you access the relation property the first time. We call such relational data accessing method <em>lazy loading</em>. For example,</p> <pre data-language="php">// SELECT * FROM `customer` WHERE `id` = 123
$customer = Customer::findOne(123);

// SELECT * FROM `order` WHERE `customer_id` = 123
$orders = $customer-&gt;orders;

// no SQL executed
$orders2 = $customer-&gt;orders;
</pre> <p>Lazy loading is very convenient to use. However, it may suffer from a performance issue when you need to access the same relation property of multiple Active Record instances. Consider the following code example. How many SQL statements will be executed?</p> <pre data-language="php">// SELECT * FROM `customer` LIMIT 100
$customers = Customer::find()-&gt;limit(100)-&gt;all();

foreach ($customers as $customer) {
    // SELECT * FROM `order` WHERE `customer_id` = ...
    $orders = $customer-&gt;orders;
}
</pre> <p>As you can see from the code comment above, there are 101 SQL statements being executed! This is because each time you access the <code>orders</code> relation property of a different <code>Customer</code> object in the for-loop, a SQL statement will be executed.</p> <p>To solve this performance problem, you can use the so-called <em>eager loading</em> approach as shown below,</p> <pre data-language="php">// SELECT * FROM `customer` LIMIT 100;
// SELECT * FROM `orders` WHERE `customer_id` IN (...)
$customers = Customer::find()
    -&gt;with('orders')
    -&gt;limit(100)
    -&gt;all();

foreach ($customers as $customer) {
    // no SQL executed
    $orders = $customer-&gt;orders;
}
</pre> <p>By calling <a href="yii-db-activequerytrait#with()-detail">yii\db\ActiveQuery::with()</a>, you instruct Active Record to bring back the orders for the first 100 customers in one single SQL statement. As a result, you reduce the number of the executed SQL statements from 101 to 2!</p> <p>You can eagerly load one or multiple relations. You can even eagerly load <em>nested relations</em>. A nested relation is a relation that is declared within a related Active Record class. For example, <code>Customer</code> is related with <code>Order</code> through the <code>orders</code> relation, and <code>Order</code> is related with <code>Item</code> through the <code>items</code> relation. When querying for <code>Customer</code>, you can eagerly load <code>items</code> using the nested relation notation <code>orders.items</code>. </p> <p>The following code shows different usage of <a href="yii-db-activequerytrait#with()-detail">with()</a>. We assume the <code>Customer</code> class has two relations <code>orders</code> and <code>country</code>, while the <code>Order</code> class has one relation <code>items</code>.</p> <pre data-language="php">// eager loading both "orders" and "country"
$customers = Customer::find()-&gt;with('orders', 'country')-&gt;all();
// equivalent to the array syntax below
$customers = Customer::find()-&gt;with(['orders', 'country'])-&gt;all();
// no SQL executed 
$orders= $customers[0]-&gt;orders;
// no SQL executed 
$country = $customers[0]-&gt;country;

// eager loading "orders" and the nested relation "orders.items"
$customers = Customer::find()-&gt;with('orders.items')-&gt;all();
// access the items of the first order of the first customer
// no SQL executed
$items = $customers[0]-&gt;orders[0]-&gt;items;
</pre> <p>You can eagerly load deeply nested relations, such as <code>a.b.c.d</code>. All parent relations will be eagerly loaded. That is, when you call <a href="yii-db-activequerytrait#with()-detail">with()</a> using <code>a.b.c.d</code>, you will eagerly load <code>a</code>, <code>a.b</code>, <code>a.b.c</code> and <code>a.b.c.d</code>. </p> <blockquote class="info">
<p><strong>Info: </strong>In general, when eagerly loading <code>N</code> relations among which <code>M</code> relations are defined with a <a href="#junction-table">junction table</a>, a total number of <code>N+M+1</code> SQL statements will be executed. Note that a nested relation <code>a.b.c.d</code> counts as 4 relations.</p> </blockquote> <p>When eagerly loading a relation, you can customize the corresponding relational query using an anonymous function. For example,</p> <pre data-language="php">// find customers and bring back together their country and active orders
// SELECT * FROM `customer`
// SELECT * FROM `country` WHERE `id` IN (...)
// SELECT * FROM `order` WHERE `customer_id` IN (...) AND `status` = 1
$customers = Customer::find()-&gt;with([
    'country',
    'orders' =&gt; function ($query) {
        $query-&gt;andWhere(['status' =&gt; Order::STATUS_ACTIVE]);
    },
])-&gt;all();
</pre> <p>When customizing the relational query for a relation, you should specify the relation name as an array key and use an anonymous function as the corresponding array value. The anonymous function will receive a <code>$query</code> parameter which represents the <a href="yii-db-activequery">yii\db\ActiveQuery</a> object used to perform the relational query for the relation. In the code example above, we are modifying the relational query by appending an additional condition about order status.</p> <blockquote class="note">
<p><strong>Note: </strong>If you call <a href="yii-db-query#select()-detail">select()</a> while eagerly loading relations, you have to make sure the columns referenced in the relation declarations are being selected. Otherwise, the related models may not be loaded properly. For example,</p> <pre data-language="php">$orders = Order::find()-&gt;select(['id', 'amount'])-&gt;with('customer')-&gt;all();
// $orders[0]-&gt;customer is always `null`. To fix the problem, you should do the following:
$orders = Order::find()-&gt;select(['id', 'amount', 'customer_id'])-&gt;with('customer')-&gt;all();
</pre> </blockquote> <h3>Joining with Relations 
</h3>
<blockquote class="note">
<p><strong>Note: </strong>The content described in this subsection is only applicable to relational databases, such as MySQL, PostgreSQL, etc.</p> </blockquote> <p>The relational queries that we have described so far only reference the primary table columns when querying for the primary data. In reality we often need to reference columns in the related tables. For example, we may want to bring back the customers who have at least one active order. To solve this problem, we can build a join query like the following:</p> <pre data-language="php">// SELECT `customer`.* FROM `customer`
// LEFT JOIN `order` ON `order`.`customer_id` = `customer`.`id`
// WHERE `order`.`status` = 1
// 
// SELECT * FROM `order` WHERE `customer_id` IN (...)
$customers = Customer::find()
    -&gt;select('customer.*')
    -&gt;leftJoin('order', '`order`.`customer_id` = `customer`.`id`')
    -&gt;where(['order.status' =&gt; Order::STATUS_ACTIVE])
    -&gt;with('orders')
    -&gt;all();
</pre> <blockquote class="note">
<p><strong>Note: </strong>It is important to disambiguate column names when building relational queries involving JOIN SQL statements. A common practice is to prefix column names with their corresponding table names.</p> </blockquote> <p>However, a better approach is to exploit the existing relation declarations by calling <a href="yii-db-activequery#joinWith()-detail">yii\db\ActiveQuery::joinWith()</a>:</p> <pre data-language="php">$customers = Customer::find()
    -&gt;joinWith('orders')
    -&gt;where(['order.status' =&gt; Order::STATUS_ACTIVE])
    -&gt;all();
</pre> <p>Both approaches execute the same set of SQL statements. The latter approach is much cleaner and drier, though. </p> <p>By default, <a href="yii-db-activequery#joinWith()-detail">joinWith()</a> will use <code>LEFT JOIN</code> to join the primary table with the related table. You can specify a different join type (e.g. <code>RIGHT JOIN</code>) via its third parameter <code>$joinType</code>. If the join type you want is <code>INNER JOIN</code>, you can simply call <a href="yii-db-activequery#innerJoinWith()-detail">innerJoinWith()</a>, instead.</p> <p>Calling <a href="yii-db-activequery#joinWith()-detail">joinWith()</a> will <a href="#lazy-eager-loading">eagerly load</a> the related data by default. If you do not want to bring in the related data, you can specify its second parameter <code>$eagerLoading</code> as <code>false</code>. </p> <p>Like <a href="yii-db-activequerytrait#with()-detail">with()</a>, you can join with one or multiple relations; you may customize the relation queries on-the-fly; you may join with nested relations; and you may mix the use of <a href="yii-db-activequerytrait#with()-detail">with()</a> and <a href="yii-db-activequery#joinWith()-detail">joinWith()</a>. For example,</p> <pre data-language="php">$customers = Customer::find()-&gt;joinWith([
    'orders' =&gt; function ($query) {
        $query-&gt;andWhere(['&gt;', 'subtotal', 100]);
    },
])-&gt;with('country')
    -&gt;all();
</pre> <p>Sometimes when joining two tables, you may need to specify some extra conditions in the <code>ON</code> part of the JOIN query. This can be done by calling the <a href="yii-db-activequery#onCondition()-detail">yii\db\ActiveQuery::onCondition()</a> method like the following:</p> <pre data-language="php">// SELECT `customer`.* FROM `customer`
// LEFT JOIN `order` ON `order`.`customer_id` = `customer`.`id` AND `order`.`status` = 1 
// 
// SELECT * FROM `order` WHERE `customer_id` IN (...)
$customers = Customer::find()-&gt;joinWith([
    'orders' =&gt; function ($query) {
        $query-&gt;onCondition(['order.status' =&gt; Order::STATUS_ACTIVE]);
    },
])-&gt;all();
</pre> <p>This above query brings back <em>all</em> customers, and for each customer it brings back all active orders. Note that this differs from our earlier example which only brings back customers who have at least one active order.</p> <blockquote class="info">
<p><strong>Info: </strong>When <a href="yii-db-activequery">yii\db\ActiveQuery</a> is specified with a condition via <a href="yii-db-activequery#onCondition()-detail">onCondition()</a>, the condition will be put in the <code>ON</code> part if the query involves a JOIN query. If the query does not involve JOIN, the on-condition will be automatically appended to the <code>WHERE</code> part of the query. Thus it may only contain conditions including columns of the related table.</p> </blockquote> <h4>Relation table aliases 
</h4>
<p>As noted before, when using JOIN in a query, we need to disambiguate column names. Therefor often an alias is defined for a table. Setting an alias for the relational query would be possible by customizing the relation query in the following way:</p> <pre data-language="php">$query-&gt;joinWith([
    'orders' =&gt; function ($q) {
        $q-&gt;from(['o' =&gt; Order::tableName()]);
    },
])
</pre> <p>This however looks very complicated and involves either hardcoding the related objects table name or calling <code>Order::tableName()</code>. Since version 2.0.7, Yii provides a shortcut for this. You may now define and use the alias for the relation table like the following:</p> <pre data-language="php">// join the orders relation and sort the result by orders.id
$query-&gt;joinWith(['orders o'])-&gt;orderBy('o.id');
</pre> <p>The above syntax works for simple relations. If you need an alias for an intermediate table when joining over nested relations, e.g. <code>$query-&gt;joinWith(['orders.product'])</code>, you need to nest the joinWith calls like in the following example:</p> <pre data-language="php">$query-&gt;joinWith(['orders o' =&gt; function($q) {
        $q-&gt;joinWith('product p');
    }])
    -&gt;where('o.amount &gt; 100');
</pre> <h3>Inverse Relations 
</h3>
<p>Relation declarations are often reciprocal between two Active Record classes. For example, <code>Customer</code> is related to <code>Order</code> via the <code>orders</code> relation, and <code>Order</code> is related back to <code>Customer</code> via the <code>customer</code> relation.</p> <pre data-language="php">class Customer extends ActiveRecord
{
    public function getOrders()
    {
        return $this-&gt;hasMany(Order::className(), ['customer_id' =&gt; 'id']);
    }
}

class Order extends ActiveRecord
{
    public function getCustomer()
    {
        return $this-&gt;hasOne(Customer::className(), ['id' =&gt; 'customer_id']);
    }
}
</pre> <p>Now consider the following piece of code:</p> <pre data-language="php">// SELECT * FROM `customer` WHERE `id` = 123
$customer = Customer::findOne(123);

// SELECT * FROM `order` WHERE `customer_id` = 123
$order = $customer-&gt;orders[0];

// SELECT * FROM `customer` WHERE `id` = 123
$customer2 = $order-&gt;customer;

// displays "not the same"
echo $customer2 === $customer ? 'same' : 'not the same';
</pre> <p>We would think <code>$customer</code> and <code>$customer2</code> are the same, but they are not! Actually they do contain the same customer data, but they are different objects. When accessing <code>$order-&gt;customer</code>, an extra SQL statement is executed to populate a new object <code>$customer2</code>.</p> <p>To avoid the redundant execution of the last SQL statement in the above example, we should tell Yii that <code>customer</code> is an <em>inverse relation</em> of <code>orders</code> by calling the <a href="yii-db-activerelationtrait#inverseOf()-detail">inverseOf()</a> method like shown below:</p> <pre data-language="php">class Customer extends ActiveRecord
{
    public function getOrders()
    {
        return $this-&gt;hasMany(Order::className(), ['customer_id' =&gt; 'id'])-&gt;inverseOf('customer');
    }
}
</pre> <p>With this modified relation declaration, we will have:</p> <pre data-language="php">// SELECT * FROM `customer` WHERE `id` = 123
$customer = Customer::findOne(123);

// SELECT * FROM `order` WHERE `customer_id` = 123
$order = $customer-&gt;orders[0];

// No SQL will be executed
$customer2 = $order-&gt;customer;

// displays "same"
echo $customer2 === $customer ? 'same' : 'not the same';
</pre> <blockquote class="note">
<p><strong>Note: </strong>Inverse relations cannot be defined for relations involving a <a href="#junction-table">junction table</a>. That is, if a relation is defined with <a href="yii-db-activerelationtrait#via()-detail">via()</a> or <a href="yii-db-activequery#viaTable()-detail">viaTable()</a>, you should not call <a href="yii-db-activerelationtrait#inverseOf()-detail">inverseOf()</a> further.</p> </blockquote> <h2>Saving Relations 
</h2>
<p>When working with relational data, you often need to establish relationships between different data or destroy existing relationships. This requires setting proper values for the columns that define the relations. Using Active Record, you may end up writing the code like the following:</p> <pre data-language="php">$customer = Customer::findOne(123);
$order = new Order();
$order-&gt;subtotal = 100;
// ...

// setting the attribute that defines the "customer" relation in Order
$order-&gt;customer_id = $customer-&gt;id;
$order-&gt;save();
</pre> <p>Active Record provides the <a href="yii-db-baseactiverecord#link()-detail">link()</a> method that allows you to accomplish this task more nicely:</p> <pre data-language="php">$customer = Customer::findOne(123);
$order = new Order();
$order-&gt;subtotal = 100;
// ...

$order-&gt;link('customer', $customer);
</pre> <p>The <a href="yii-db-baseactiverecord#link()-detail">link()</a> method requires you to specify the relation name and the target Active Record instance that the relationship should be established with. The method will modify the values of the attributes that link two Active Record instances and save them to the database. In the above example, it will set the <code>customer_id</code> attribute of the <code>Order</code> instance to be the value of the <code>id</code> attribute of the <code>Customer</code> instance and then save it to the database.</p> <blockquote class="note">
<p><strong>Note: </strong>You cannot link two newly created Active Record instances.</p> </blockquote> <p>The benefit of using <a href="yii-db-baseactiverecord#link()-detail">link()</a> is even more obvious when a relation is defined via a <a href="#junction-table">junction table</a>. For example, you may use the following code to link an <code>Order</code> instance with an <code>Item</code> instance:</p> <pre data-language="php">$order-&gt;link('items', $item);
</pre> <p>The above code will automatically insert a row in the <code>order_item</code> junction table to relate the order with the item.</p> <blockquote class="info">
<p><strong>Info: </strong>The <a href="yii-db-baseactiverecord#link()-detail">link()</a> method will NOT perform any data validation while saving the affected Active Record instance. It is your responsibility to validate any input data before calling this method.</p> </blockquote> <p>The opposite operation to <a href="yii-db-baseactiverecord#link()-detail">link()</a> is <a href="yii-db-baseactiverecord#unlink()-detail">unlink()</a> which breaks an existing relationship between two Active Record instances. For example,</p> <pre data-language="php">$customer = Customer::find()-&gt;with('orders')-&gt;where(['id' =&gt; 123])-&gt;one();
$customer-&gt;unlink('orders', $customer-&gt;orders[0]);
</pre> <p>By default, the <a href="yii-db-baseactiverecord#unlink()-detail">unlink()</a> method will set the foreign key value(s) that specify the existing relationship to be <code>null</code>. You may, however, choose to delete the table row that contains the foreign key value by passing the <code>$delete</code> parameter as <code>true</code> to the method.</p> <p>When a junction table is involved in a relation, calling <a href="yii-db-baseactiverecord#unlink()-detail">unlink()</a> will cause the foreign keys in the junction table to be cleared, or the deletion of the corresponding row in the junction table if <code>$delete</code> is <code>true</code>.</p> <h2>Cross-Database Relations 
</h2>
<p>Active Record allows you to declare relations between Active Record classes that are powered by different databases. The databases can be of different types (e.g. MySQL and PostgreSQL, or MS SQL and MongoDB), and they can run on different servers. You can use the same syntax to perform relational queries. For example,</p> <pre data-language="php">// Customer is associated with the "customer" table in a relational database (e.g. MySQL)
class Customer extends \yii\db\ActiveRecord
{
    public static function tableName()
    {
        return 'customer';
    }

    public function getComments()
    {
        // a customer has many comments
        return $this-&gt;hasMany(Comment::className(), ['customer_id' =&gt; 'id']);
    }
}

// Comment is associated with the "comment" collection in a MongoDB database
class Comment extends \yii\mongodb\ActiveRecord
{
    public static function collectionName()
    {
        return 'comment';
    }

    public function getCustomer()
    {
        // a comment has one customer
        return $this-&gt;hasOne(Customer::className(), ['id' =&gt; 'customer_id']);
    }
}

$customers = Customer::find()-&gt;with('comments')-&gt;all();
</pre> <p>You can use most of the relational query features that have been described in this section. </p> <blockquote class="note">
<p><strong>Note: </strong>Usage of <a href="yii-db-activequery#joinWith()-detail">joinWith()</a> is limited to databases that allow cross-database JOIN queries. For this reason, you cannot use this method in the above example because MongoDB does not support JOIN.</p> </blockquote> <h2>Customizing Query Classes 
</h2>
<p>By default, all Active Record queries are supported by <a href="yii-db-activequery">yii\db\ActiveQuery</a>. To use a customized query class in an Active Record class, you should override the <a href="yii-db-activerecord#find()-detail">yii\db\ActiveRecord::find()</a> method and return an instance of your customized query class. For example,</p> <pre data-language="php">// file Comment.php
namespace app\models;

use yii\db\ActiveRecord;

class Comment extends ActiveRecord
{
    public static function find()
    {
        return new CommentQuery(get_called_class());
    }
}
</pre> <p>Now whenever you are performing a query (e.g. <code>find()</code>, <code>findOne()</code>) or defining a relation (e.g. <code>hasOne()</code>) with <code>Comment</code>, you will be calling an instance of <code>CommentQuery</code> instead of <code>ActiveQuery</code>.</p> <p>You now have to define the <code>CommentQuery</code> class, which can be customized in many creative ways to improve your query building experience. For example,</p> <pre data-language="php">// file CommentQuery.php
namespace app\models;

use yii\db\ActiveQuery;

class CommentQuery extends ActiveQuery
{
    // conditions appended by default (can be skipped)
    public function init()
    {
        $this-&gt;andOnCondition(['deleted' =&gt; false]);
        parent::init();
    }

    // ... add customized query methods here ...

    public function active($state = true)
    {
        return $this-&gt;andOnCondition(['active' =&gt; $state]);
    }
}
</pre> <blockquote class="note">
<p><strong>Note: </strong>Instead of calling <a href="yii-db-activequery#onCondition()-detail">onCondition()</a>, you usually should call <a href="yii-db-activequery#andOnCondition()-detail">andOnCondition()</a> or <a href="yii-db-activequery#orOnCondition()-detail">orOnCondition()</a> to append additional conditions when defining new query building methods so that any existing conditions are not overwritten.</p> </blockquote> <p>This allows you to write query building code like the following:</p> <pre data-language="php">$comments = Comment::find()-&gt;active()-&gt;all();
$inactiveComments = Comment::find()-&gt;active(false)-&gt;all();
</pre> <blockquote class="tip">
<p><strong>Tip: </strong>In big projects, it is recommended that you use customized query classes to hold most query-related code so that the Active Record classes can be kept clean.</p> </blockquote> <p>You can also use the new query building methods when defining relations about <code>Comment</code> or performing relational query:</p> <pre data-language="php">class Customer extends \yii\db\ActiveRecord
{
    public function getActiveComments()
    {
        return $this-&gt;hasMany(Comment::className(), ['customer_id' =&gt; 'id'])-&gt;active();
    }
}

$customers = Customer::find()-&gt;joinWith('activeComments')-&gt;all();

// or alternatively
class Customer extends \yii\db\ActiveRecord
{
    public function getComments()
    {
        return $this-&gt;hasMany(Comment::className(), ['customer_id' =&gt; 'id']);
    }
}

$customers = Customer::find()-&gt;joinWith([
    'comments' =&gt; function($q) {
        $q-&gt;active();
    }
])-&gt;all();
</pre> <blockquote class="info">
<p><strong>Info: </strong>In Yii 1.1, there is a concept called <em>scope</em>. Scope is no longer directly supported in Yii 2.0, and you should use customized query classes and query methods to achieve the same goal.</p> </blockquote> <h2>Selecting extra fields 
</h2>
<p>When Active Record instance is populated from query results, its attributes are filled up by corresponding column values from received data set.</p> <p>You are able to fetch additional columns or values from query and store it inside the Active Record. For example, assume we have a table named <code>room</code>, which contains information about rooms available in the hotel. Each room stores information about its geometrical size using fields <code>length</code>, <code>width</code>, <code>height</code>. Imagine we need to retrieve list of all available rooms with their volume in descendant order. So you can not calculate volume using PHP, because we need to sort the records by its value, but you also want <code>volume</code> to be displayed in the list. To achieve the goal, you need to declare an extra field in your <code>Room</code> Active Record class, which will store <code>volume</code> value:</p> <pre data-language="php">class Room extends \yii\db\ActiveRecord
{
    public $volume;

    // ...
}
</pre> <p>Then you need to compose a query, which calculates volume of the room and performs the sort:</p> <pre data-language="php">$rooms = Room::find()
    -&gt;select([
        '{{room}}.*', // select all columns
        '([[length]] * [[width]] * [[height]]) AS volume', // calculate a volume
    ])
    -&gt;orderBy('volume DESC') // apply sort
    -&gt;all();

foreach ($rooms as $room) {
    echo $room-&gt;volume; // contains value calculated by SQL
}
</pre> <p>Ability to select extra fields can be exceptionally useful for aggregation queries. Assume you need to display a list of customers with the count of orders they have made. First of all, you need to declare a <code>Customer</code> class with <code>orders</code> relation and extra field for count storage:</p> <pre data-language="php">class Customer extends \yii\db\ActiveRecord
{
    public $ordersCount;

    // ...

    public function getOrders()
    {
        return $this-&gt;hasMany(Order::className(), ['customer_id' =&gt; 'id']);
    }
}
</pre> <p>Then you can compose a query, which joins the orders and calculates their count:</p> <pre data-language="php">$customers = Customer::find()
    -&gt;select([
        '{{customer}}.*', // select all customer fields
        'COUNT({{order}}.id) AS ordersCount' // calculate orders count
    ])
    -&gt;joinWith('orders') // ensure table junction
    -&gt;groupBy('{{customer}}.id') // group the result to ensure aggregation function works
    -&gt;all();
</pre> <p>A disadvantage of using this method would be that, if the information isn't loaded on the SQL query - it has to be calculated separately. Thus, if you have found particular record via regular query without extra select statements, it will be unable to return actual value for the extra field. Same will happen for the newly saved record.</p> <pre data-language="php">$room = new Room();
$room-&gt;length = 100;
$room-&gt;width = 50;
$room-&gt;height = 2;

$room-&gt;volume; // this value will be `null`, since it was not declared yet
</pre> <p>Using the <a href="yii-db-baseactiverecord#__get()-detail">__get()</a> and <a href="yii-db-baseactiverecord#__set()-detail">__set()</a> magic methods we can emulate the behavior of a property:</p> <pre data-language="php">class Room extends \yii\db\ActiveRecord
{
    private $_volume;
    
    public function setVolume($volume)
    {
        $this-&gt;_volume = (float) $volume;
    }
    
    public function getVolume()
    {
        if (empty($this-&gt;length) || empty($this-&gt;width) || empty($this-&gt;height)) {
            return null;
        }
        
        if ($this-&gt;_volume === null) {
            $this-&gt;setVolume(
                $this-&gt;length * $this-&gt;width * $this-&gt;height
            );
        }
        
        return $this-&gt;_volume;
    }

    // ...
}
</pre> <p>When the select query doesn't provide the volume, the model will be able to calculate it automatically using the attributes of the model.</p> <p>You can calculate the aggregation fields as well using defined relations:</p> <pre data-language="php">class Customer extends \yii\db\ActiveRecord
{
    private $_ordersCount;

    public function setOrdersCount($count)
    {
        $this-&gt;_ordersCount = (int) $count;
    }

    public function getOrdersCount()
    {
        if ($this-&gt;isNewRecord) {
            return null; // this avoid calling a query searching for null primary keys
        }

        if ($this-&gt;_ordersCount === null) {
            $this-&gt;setOrdersCount($this-&gt;getOrders()-&gt;count()); // calculate aggregation on demand from relation
        }

        return $this-&gt;_ordersCount;
    }

    // ...

    public function getOrders()
    {
        return $this-&gt;hasMany(Order::className(), ['customer_id' =&gt; 'id']);
    }
}
</pre> <p>With this code, in case 'ordersCount' is present in 'select' statement - <code>Customer::ordersCount</code> will be populated by query results, otherwise it will be calculated on demand using <code>Customer::orders</code> relation.</p> <p>This approach can be as well used for creation of the shortcuts for some relational data, especially for the aggregation. For example:</p> <pre data-language="php">class Customer extends \yii\db\ActiveRecord
{
    /**
     * Defines read-only virtual property for aggregation data.
     */
    public function getOrdersCount()
    {
        if ($this-&gt;isNewRecord) {
            return null; // this avoid calling a query searching for null primary keys
        }
        
        return empty($this-&gt;ordersAggregation) ? 0 : $this-&gt;ordersAggregation[0]['counted'];
    }

    /**
     * Declares normal 'orders' relation.
     */
    public function getOrders()
    {
        return $this-&gt;hasMany(Order::className(), ['customer_id' =&gt; 'id']);
    }

    /**
     * Declares new relation based on 'orders', which provides aggregation.
     */
    public function getOrdersAggregation()
    {
        return $this-&gt;getOrders()
            -&gt;select(['customer_id', 'counted' =&gt; 'count(*)'])
            -&gt;groupBy('customer_id')
            -&gt;asArray(true);
    }

    // ...
}

foreach (Customer::find()-&gt;with('ordersAggregation')-&gt;all() as $customer) {
    echo $customer-&gt;ordersCount; // outputs aggregation data from relation without extra query due to eager loading
}

$customer = Customer::findOne($pk);
$customer-&gt;ordersCount; // output aggregation data from lazy loaded relation
</pre> <div class="_attribution">
  <p class="_attribution-p">
     20082017 by Yii Software LLC<br>Licensed under the three clause BSD license.<br>
    <a href="http://www.yiiframework.com/doc-2.0/guide-db-active-record.html" class="_attribution-link">http://www.yiiframework.com/doc-2.0/guide-db-active-record.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
