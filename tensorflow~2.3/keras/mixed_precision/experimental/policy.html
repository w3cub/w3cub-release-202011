
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>tf.keras.mixed_precision.experimental.Policy - TensorFlow 2.3 - W3cubDocs</title>
  
  <meta name="description" content=" A dtype policy for a Keras layer. ">
  <meta name="keywords" content="tf, keras, mixed, precision, experimental, policy, tensorflow, tensorflow~2.3">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/tensorflow~2.3/keras/mixed_precision/experimental/policy.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/tensorflow~2.3.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/tensorflow~2.3/" class="_nav-link" title="" style="margin-left:0;">TensorFlow 2.3</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _tensorflow">
				
				
<h1 class="devsite-page-title">tf.keras.mixed_precision.experimental.Policy</h1>      <table class="tfo-notebook-buttons tfo-api" align="left">  <td> <a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v2.3.0/tensorflow/python/keras/mixed_precision/experimental/policy.py#L41-L478">  View source on GitHub </a> </td> </table> <p>A dtype policy for a Keras layer.</p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
tf.keras.mixed_precision.experimental.Policy(
    name, loss_scale=USE_DEFAULT
)
</pre>  <p>A dtype policy determines dtype-related aspects of a layer, such as its computation and variable dtypes. Each layer has a policy. Policies can be passed to the <code translate="no" dir="ltr">dtype</code> argument of layer constructors, or a global policy can be set with <a href="set_policy"><code translate="no" dir="ltr">tf.keras.mixed_precision.experimental.set_policy</code></a>. A layer will default to the global policy if no policy is passed to it's constructor.</p> <p>For many models, each layer's policy will have the same compute dtype and variable dtype, which will typically be float32. In this case, we refer to the singular dtype as the layer's dtype, which can be queried by the property <a href="../../layers/layer#dtype"><code translate="no" dir="ltr">tf.keras.layers.Layer.dtype</code></a>.</p> <p>When mixed precision training is used, most layers will instead have a float16 or bfloat16 compute dtype and a float32 variable dtype, and so the layer does not have a single dtype. When the variable dtype does not match the compute dtype, variables will be automatically casted to the compute dtype to avoid type errors. In this case, <a href="../../layers/layer#dtype"><code translate="no" dir="ltr">tf.keras.layers.Layer.dtype</code></a> refers to the variable dtype, not the compute dtype. See <a href="https://www.tensorflow.org/guide/keras/mixed_precision">the mixed precision guide</a> for more information on how to use mixed precision.</p> <p>Certain policies also have a <a href="../../../mixed_precision/experimental/lossscale"><code translate="no" dir="ltr">tf.mixed_precision.experimental.LossScale</code></a> instance, which is used by <a href="../../model"><code translate="no" dir="ltr">tf.keras.Model</code></a>s to performance loss scaling. Loss scaling is a technique used with mixed precision to avoid numerical underflow in float16 gradients. Loss scaling is only done by Models in <a href="../../model#fit"><code translate="no" dir="ltr">Model.fit</code></a>, <a href="../../model#train_on_batch"><code translate="no" dir="ltr">Model.train_on_batch</code></a>, and similar methods. Layers which are not Models ignore the loss scale.</p> <p>Policies are constructed by passing a string to the constructor, e.g. <code translate="no" dir="ltr">tf.keras.mixed_precision.experimental.Policy('float32')</code>. The string determines the compute and variable dtypes. It can be one of the following:</p> <ul> <li>Any dtype name, such as 'float32' or 'float64'. Both the variable and compute dtypes will be that dtype. No loss scaling is done by default.</li> <li>'mixed_float16' or 'mixed_bfloat16': The compute dtype is float16 or bfloat16, while the variable dtype is float32. These policies are used for mixed precision training. With 'mixed_float16', a dynamic loss scale is used by default. 'mixed_bfloat16' does no loss scaling by default, as loss scaling is unnecessary with bfloat16.</li> </ul> <h3 id="how_to_use_mixed_precision_in_a_keras_model" data-text="How to use mixed precision in a Keras model" tabindex="0">How to use mixed precision in a Keras model</h3> <p>To use mixed precision in a Keras model, the <code translate="no" dir="ltr">'mixed_float16'</code> or <code translate="no" dir="ltr">'mixed_bfloat16'</code> policy can be used. <a href="set_policy"><code translate="no" dir="ltr">tf.keras.mixed_precision.experimental.set_policy</code></a> can be used to set the default policy for layers if no policy is passed to them. For example:</p> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
tf.keras.mixed_precision.experimental.set_policy('mixed_float16')
model = tf.keras.models.Sequential([
    tf.keras.layers.Input((100,)),
    # Dense layers use global policy of 'mixed_float16', which does
    # computations in float16 while keeping variables in float32.
    tf.keras.layers.Dense(10),
    tf.keras.layers.Dense(10),
    # Softmax should be done in float32 for numeric stability. We pass
    # dtype='float32' to use float32 instead of the global policy.
    tf.keras.layers.Activation('softmax', dtype='float32')
])
</pre> <p>Alternatively, the policy can be passed to individual layers instead of setting the global policy with <code translate="no" dir="ltr">set_policy</code>:</p> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
policy = tf.keras.mixed_precision.experimental.Policy('mixed_float16')
model = tf.keras.models.Sequential([
    tf.keras.layers.Input((100,)),
    tf.keras.layers.Dense(10, dtype=policy),
    tf.keras.layers.Dense(10, dtype=policy),
    # Softmax should be done in float32 for numeric stability.
    tf.keras.layers.Activation('softmax', dtype='float32')
])
</pre> <p>Note the <code translate="no" dir="ltr">'mixed_float16'</code> policy will apply loss scaling by default in <a href="../../model#fit"><code translate="no" dir="ltr">Model.fit</code></a>, <a href="../../model#train_on_batch"><code translate="no" dir="ltr">Model.train_on_batch</code></a>, and other training methods. If no such method is used (e.g., a custom training loop is used) and <code translate="no" dir="ltr">'mixed_float16'</code> is used, the loss scale must be manually applied. See <a href="lossscaleoptimizer"><code translate="no" dir="ltr">tf.keras.mixed_precision.experimental.LossScaleOptimizer</code></a> for details. For <code translate="no" dir="ltr">'mixed_bfloat16'</code>, no loss scaling is done and loss scaling never needs to be manually applied.</p> <p>See <a href="https://www.tensorflow.org/guide/keras/mixed_precision">the mixed precision guide</a> for more information on using mixed precision</p> <h3 id="how_to_use_float64_in_a_keras_model" data-text="How to use float64 in a Keras model" tabindex="0">How to use float64 in a Keras model</h3> <p>Using float64 is similar to mixed precision. Either the global policy can be set to float64, or <code translate="no" dir="ltr">dtype='float64'</code> can be passed to individual layers. For example, to set the global policy:</p> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
tf.keras.mixed_precision.experimental.set_policy('float64')
model = tf.keras.models.Sequential([
    tf.keras.layers.Input((100,)),
    # All layers use global policy of 'float64', which does computations
    # and creates variables in float64.
    tf.keras.layers.Dense(10),
    tf.keras.layers.Dense(10),
    tf.keras.layers.Activation('softmax')
])
# Optionaly set policy back to float32 if any other models use float32
tf.keras.mixed_precision.experimental.set_policy('float32')
</pre> <h3 id="how_a_layer_uses_its_policys_compute_dtype" data-text="How a layer uses its policy's compute dtype" tabindex="0">How a layer uses its policy's compute dtype</h3> <p>A layer will cast its inputs to its compute dtype in TensorFlow 2. For example:</p> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
x = tf.ones((4, 4, 4, 4), dtype='float64')
# `layer`'s policy defaults to float32.
layer = tf.keras.layers.Conv2D(filters=4, kernel_size=2)
# `layer` casts it's inputs to its compute dtype, which is float32, and
# does computations in float32.
y = layer(x)
y.dtype
tf.float32
</pre> <p>Note that the base <a href="../../layers/layer"><code translate="no" dir="ltr">tf.keras.layers.Layer</code></a> class inserts the casts. If subclassing your own layer, you do not have to insert any casts.</p> <p>Currently, only tensors in the first argument to the layer's <code translate="no" dir="ltr">call</code> method are casted. For example:</p> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
class MyLayer(tf.keras.layers.Layer):
  # Bug! `b` will not be casted.
  def call(self, a, b):
    return a + 1., b + 1.
a = tf.constant(1., dtype="float32")
b = tf.constant(1., dtype="float32")
layer = MyLayer(dtype="float64")
x, y = layer(a, b)
x.dtype
tf.float64
y.dtype
tf.float32
</pre> <p>If writing your own layer, it is recommended to accept tensors only in the first argument. This way, all tensors are casted to the layer's compute dtype. <code translate="no" dir="ltr">MyLayer</code> should therefore be written as:</p> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
class MyLayer(tf.keras.layers.Layer):
  # Now, all tensor inputs will be casted.
  def call(self, inputs):
    a, b = inputs
    return a + 1., b + 1.
a = tf.constant(1., dtype="float32")
b = tf.constant(1., dtype="float32")
layer = MyLayer(dtype="float64")
x, y = layer((a, b))
x.dtype
tf.float64
y.dtype
tf.float64
</pre> <p>Other arguments are not automatically casted for technical reasons, but this may change in a future minor release.</p> <p>The casting only occurs in TensorFlow 2, but can be enabled if <a href="../../../compat/v1/disable_v2_behavior"><code translate="no" dir="ltr">tf.compat.v1.disable_v2_behavior()</code></a> has been called with <a href="../../../compat/v1/keras/layers/enable_v2_dtype_behavior"><code translate="no" dir="ltr">tf.compat.v1.keras.layers.enable_v2_dtype_behavior()</code></a>.</p> <p>A layer subclass can prevent its inputs from being autocasted by passing <code translate="no" dir="ltr">autocast=False</code> to the layer constructor. For example:</p> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
class NonAutoCastingLayer(tf.keras.layers.Layer):
  def __init__(self, **kwargs):
    kwargs['autocast'] = False
    super(NonAutoCastingLayer, self).__init__(**kwargs)
  def call(self, inp):
    return inp
x = tf.ones((4, 4, 4, 4), dtype='float32')
layer = NonAutoCastingLayer(dtype='float64')
y = layer(x)  # Will not cast inputs to it's compute dtype of float64
y.dtype
tf.float32
</pre> <h3 id="how_a_layer_uses_its_policys_variable_dtype" data-text="How a layer uses its policy's variable dtype" tabindex="0">How a layer uses its policy's variable dtype</h3> <p>The default dtype of variables created by <a href="../../layers/layer#add_weight"><code translate="no" dir="ltr">tf.keras.layers.Layer.add_weight</code></a> is the layer's policy's variable dtype.</p> <p>If a layer's compute and variable dtypes differ, <code translate="no" dir="ltr">add_weight</code> will wrap floating-point variables with a special wrapper called an <code translate="no" dir="ltr">AutoCastVariable</code>. This wrapper is identical to the original variable except it casts itself to the layer's compute dtype when used within <a href="../../layers/layer#call"><code translate="no" dir="ltr">Layer.call</code></a>. Outside <a href="../../layers/layer#call"><code translate="no" dir="ltr">Layer.call</code></a>, the variable is not casted.</p> <p>A layer author can prevent a variable from being wrapped with an <code translate="no" dir="ltr">AutoCastVariable</code> by passing <code translate="no" dir="ltr">experimental_autocast=False</code> to <code translate="no" dir="ltr">add_weight</code>:</p> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
class MyLayer(tf.keras.layers.Layer):
 def build(self, input_shape):
   self.x = self.add_weight('x')
   self.y = self.add_weight('y', experimental_autocast=False)
policy = tf.keras.mixed_precision.experimental.Policy('mixed_float16')
layer = MyLayer(dtype=policy)
layer.build((2, 2))
layer.x
&lt;AutoCastVariable 'x:0' shape=() dtype=float32 true_dtype=float32, numpy=...&gt;
layer.y
&lt;tf.Variable 'y:0' shape=() dtype=float32, numpy=...&gt;
</pre> <p>Passing <code translate="no" dir="ltr">experimental_autocast=False</code> is useful for layers which may internally do some math in the variable dtype instead of the compute dtype. For example, you may wish to compute variable statistics, such as mean and variance, in the variable dtype.</p> <h3 id="how_to_write_a_layer_that_supports_mixed_precision_and_float64" data-text="How to write a layer that supports mixed precision and float64." tabindex="0">How to write a layer that supports mixed precision and float64.</h3> <p>For the most part, layers will automatically support mixed precision and float64 without any additional work, due to the fact the base layer automatically casts inputs, creates variables of the correct type, and in the case of mixed precision, wraps variables with <code translate="no" dir="ltr">AutoCastVariables</code>.</p> <p>For example, this simple dense layer does not require any additional work to support mixed precision or float64. Keras automatically casts the inputs and variable to the appropriate dtype.</p> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
class MyDense(tf.keras.layers.Layer):
  def build(self, input_shape):
    self.kernel = self.add_weight('kernel', (input_shape[-1], 10))
  def call(self, inputs):
    return tf.matmul(inputs, self.kernel)
</pre> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
policy = tf.keras.mixed_precision.experimental.Policy('mixed_float16')
layer = MyDense(dtype=policy)
x = np.random.rand(10, 10)
y = layer(x)
y.dtype
tf.float16
</pre> <p>The primary case where you need extra work to support mixed precision or float64 is when you create a new tensor, such as with <a href="../../../ones"><code translate="no" dir="ltr">tf.ones</code></a> or <a href="../../../constant"><code translate="no" dir="ltr">tf.constant</code></a>. In such cases, you must create the tensor of the correct dtype. For example, suppose you modify the <code translate="no" dir="ltr">MyDense</code> layer to add a random number to the output using <a href="../../../random/normal"><code translate="no" dir="ltr">tf.random.normal</code></a>. You must pass the input dtype to <a href="../../../random/normal"><code translate="no" dir="ltr">tf.random.normal</code></a> to ensure the dtypes match.</p> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
class MyDense(tf.keras.layers.Layer):
  def build(self, input_shape):
    self.kernel = self.add_weight('kernel', (input_shape[-1], 10))
  def call(self, inputs):
    rand = tf.random.normal(shape=inputs.shape, dtype=inputs.dtype)
    return tf.matmul(inputs, self.kernel) + rand

layer = MyDense(dtype=policy)
y = layer(x)
y.dtype
tf.float16
</pre> <p>If you did not pass <code translate="no" dir="ltr">dtype=inputs.dtype</code> to <a href="../../../random/normal"><code translate="no" dir="ltr">tf.random.normal</code></a>, a <code translate="no" dir="ltr">TypeError</code> would have occurred. This is because the dtype defaults to <code translate="no" dir="ltr">"float32"</code>, so the layer would only work if the inputs were float32.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A string. Can be one of the following values: <ul> <li>Any dtype name, such as 'float32' or 'float64'. Both the variable and compute dtypes will be that dtype.</li> <li>'mixed_float16' or 'mixed_bfloat16': The compute dtype is float16 or bfloat16, while the variable dtype is float32. With 'mixed_float16', a dynamic loss scale is used. These policies are used for mixed precision training. </li>
</ul>
</td> </tr>
<tr> <td> <code translate="no" dir="ltr">loss_scale</code> </td> <td> A <a href="../../../mixed_precision/experimental/lossscale"><code translate="no" dir="ltr">tf.mixed_precision.experimental.LossScale</code></a>, an int (which uses a <code translate="no" dir="ltr">FixedLossScale</code>), or the string "dynamic" (which uses a <code translate="no" dir="ltr">DynamicLossScale</code>). Defaults to using no loss scaling unless <code translate="no" dir="ltr">name</code> is "mixed_float16", in which case this defaults to "dynamic". Only <a href="../../model"><code translate="no" dir="ltr">tf.keras.Model</code></a>s, not layers, use the loss scale, and it is only used during <a href="../../model#fit"><code translate="no" dir="ltr">Model.fit</code></a>, <a href="../../model#train_on_batch"><code translate="no" dir="ltr">Model.train_on_batch</code></a>, and other similar methods. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Attributes</th></tr> 
<tr> <td> <code translate="no" dir="ltr">compute_dtype</code> </td> <td> The compute dtype of this policy. <p>This is the dtype layers will do their computations in.</p> <p>Note that even if the compute dtype is float16 or bfloat16, hardware devices may not do individual adds, multiplies, and other fundamental operations in [b]float16, but instead may do some of them in float32 for numeric stability. The compute dtype is the dtype of the inputs and outputs of the TensorFlow ops that the layer executes. Internally, many TensorFlow ops will do certain internal calculations in float32, or some other device-internal intermediate format with higher precision than [b]float16, to increase numeric stability.</p> <p>For example, a <a href="../../layers/dense"><code translate="no" dir="ltr">tf.keras.layers.Dense</code></a> layer, when run on a GPU with a float16 compute dtype, will pass float16 inputs to tf.matmul. But, tf.matmul will do use float32 intermediate math. The performance benefit of float16 is still apparent, due to increased memory bandwidth and the fact modern GPUs have specialized hardware for computing matmuls on float16 while still keeping intermediate computations in float32. </p>
</td> </tr>
<tr> <td> <code translate="no" dir="ltr">loss_scale</code> </td> <td> Returns the loss scale of this Policy. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> Returns the name of this policy. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">should_cast_variables</code> </td> <td> Returns True if variables should be casted. <p>This is true if the variable dtype is not the same as the compute dtype. </p>
</td> </tr>
<tr> <td> <code translate="no" dir="ltr">variable_dtype</code> </td> <td> The variable dtype of this policy. <p>This is the dtype layers will create their variables in, unless a layer explicitly chooses a different dtype. If this is different than <a href="policy#compute_dtype"><code translate="no" dir="ltr">Policy.compute_dtype</code></a>, Layers will cast variables to the compute dtype to avoid type errors. </p>
</td> </tr> </table> <h2 id="methods" data-text="Methods" tabindex="0">Methods</h2> <h3 id="from_config" data-text="from_config" tabindex="0"><code translate="no" dir="ltr">from_config</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v2.3.0/tensorflow/python/keras/mixed_precision/experimental/policy.py#L472-L478">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
@classmethod
from_config(
    config, custom_objects=None
)
</pre> <h3 id="get_config" data-text="get_config" tabindex="0"><code translate="no" dir="ltr">get_config</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v2.3.0/tensorflow/python/keras/mixed_precision/experimental/policy.py#L461-L470">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
get_config()
</pre>  <devsite-page-rating position="footer" selected-rating="0" hover-rating-star="0"> </devsite-page-rating><div class="_attribution">
  <p class="_attribution-p">
    Â© 2020 The TensorFlow Authors. All rights reserved.<br>Licensed under the Creative Commons Attribution License 3.0.<br>Code samples licensed under the Apache 2.0 License.<br>
    <a href="https://www.tensorflow.org/versions/r2.3/api_docs/python/tf/keras/mixed_precision/experimental/Policy" class="_attribution-link">https://www.tensorflow.org/versions/r2.3/api_docs/python/tf/keras/mixed_precision/experimental/Policy</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
