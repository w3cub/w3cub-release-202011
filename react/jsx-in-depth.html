
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>JSX in Depth - React - W3cubDocs</title>
  
  <meta name="description" content=" Fundamentally, JSX just provides syntactic sugar for the React.createElement(component, props, ...children) function. The JSX code&#58; ">
  <meta name="keywords" content="jsx, depth, react">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/react/jsx-in-depth.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/react.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/react/" class="_nav-link" title="" style="margin-left:0;">React</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _simple">
				
				
<h1>JSX In Depth</h1>
<p>Fundamentally, JSX just provides syntactic sugar for the <code class="gatsby-code-text">React.createElement(component, props, ...children)</code> function. The JSX code:</p> <pre data-language="jsx">&lt;MyButton color="blue" shadowSize={2}&gt;
  Click Me
&lt;/MyButton&gt;</pre> <p>compiles into:</p> <pre data-language="jsx">React.createElement(
  MyButton,
  {color: 'blue', shadowSize: 2},
  'Click Me'
)</pre> <p>You can also use the self-closing form of the tag if there are no children. So:</p> <pre data-language="jsx">&lt;div className="sidebar" /&gt;</pre> <p>compiles into:</p> <pre data-language="jsx">React.createElement(
  'div',
  {className: 'sidebar'}
)</pre> <p>If you want to test out how some specific JSX is converted into JavaScript, you can try out <a href="https://babeljs.io/repl/#?presets=react&amp;code_lz=GYVwdgxgLglg9mABACwKYBt1wBQEpEDeAUIogE6pQhlIA8AJjAG4B8AEhlogO5xnr0AhLQD0jVgG4iAXyJA">the online Babel compiler</a>.</p> <h2 id="specifying-the-react-element-type">Specifying The React Element Type </h2> <p>The first part of a JSX tag determines the type of the React element.</p> <p>Capitalized types indicate that the JSX tag is referring to a React component. These tags get compiled into a direct reference to the named variable, so if you use the JSX <code class="gatsby-code-text">&lt;Foo /&gt;</code> expression, <code class="gatsby-code-text">Foo</code> must be in scope.</p> <h3 id="react-must-be-in-scope">React Must Be in Scope </h3> <p>Since JSX compiles into calls to <code class="gatsby-code-text">React.createElement</code>, the <code class="gatsby-code-text">React</code> library must also always be in scope from your JSX code.</p> <p>For example, both of the imports are necessary in this code, even though <code class="gatsby-code-text">React</code> and <code class="gatsby-code-text">CustomButton</code> are not directly referenced from JavaScript:</p> <pre data-language="jsx">import React from 'react';import CustomButton from './CustomButton';
function WarningButton() {
  // return React.createElement(CustomButton, {color: 'red'}, null);  return &lt;CustomButton color="red" /&gt;;
}</pre> <p>If you don’t use a JavaScript bundler and loaded React from a <code class="gatsby-code-text">&lt;script&gt;</code> tag, it is already in scope as the <code class="gatsby-code-text">React</code> global.</p> <h3 id="using-dot-notation-for-jsx-type">Using Dot Notation for JSX Type </h3> <p>You can also refer to a React component using dot-notation from within JSX. This is convenient if you have a single module that exports many React components. For example, if <code class="gatsby-code-text">MyComponents.DatePicker</code> is a component, you can use it directly from JSX with:</p> <pre data-language="jsx">import React from 'react';

const MyComponents = {
  DatePicker: function DatePicker(props) {
    return &lt;div&gt;Imagine a {props.color} datepicker here.&lt;/div&gt;;
  }
}

function BlueDatePicker() {
  return &lt;MyComponents.DatePicker color="blue" /&gt;;}</pre> <h3 id="user-defined-components-must-be-capitalized">User-Defined Components Must Be Capitalized </h3> <p>When an element type starts with a lowercase letter, it refers to a built-in component like <code class="gatsby-code-text">&lt;div&gt;</code> or <code class="gatsby-code-text">&lt;span&gt;</code> and results in a string <code class="gatsby-code-text">'div'</code> or <code class="gatsby-code-text">'span'</code> passed to <code class="gatsby-code-text">React.createElement</code>. Types that start with a capital letter like <code class="gatsby-code-text">&lt;Foo /&gt;</code> compile to <code class="gatsby-code-text">React.createElement(Foo)</code> and correspond to a component defined or imported in your JavaScript file.</p> <p>We recommend naming components with a capital letter. If you do have a component that starts with a lowercase letter, assign it to a capitalized variable before using it in JSX.</p> <p>For example, this code will not run as expected:</p> <pre data-language="jsx">import React from 'react';

// Wrong! This is a component and should have been capitalized:function hello(props) {  // Correct! This use of &lt;div&gt; is legitimate because div is a valid HTML tag:
  return &lt;div&gt;Hello {props.toWhat}&lt;/div&gt;;
}

function HelloWorld() {
  // Wrong! React thinks &lt;hello /&gt; is an HTML tag because it's not capitalized:  return &lt;hello toWhat="World" /&gt;;}</pre> <p>To fix this, we will rename <code class="gatsby-code-text">hello</code> to <code class="gatsby-code-text">Hello</code> and use <code class="gatsby-code-text">&lt;Hello /&gt;</code> when referring to it:</p> <pre data-language="jsx">import React from 'react';

// Correct! This is a component and should be capitalized:function Hello(props) {  // Correct! This use of &lt;div&gt; is legitimate because div is a valid HTML tag:
  return &lt;div&gt;Hello {props.toWhat}&lt;/div&gt;;
}

function HelloWorld() {
  // Correct! React knows &lt;Hello /&gt; is a component because it's capitalized.  return &lt;Hello toWhat="World" /&gt;;}</pre> <h3 id="choosing-the-type-at-runtime">Choosing the Type at Runtime </h3> <p>You cannot use a general expression as the React element type. If you do want to use a general expression to indicate the type of the element, just assign it to a capitalized variable first. This often comes up when you want to render a different component based on a prop:</p> <pre data-language="jsx">import React from 'react';
import { PhotoStory, VideoStory } from './stories';

const components = {
  photo: PhotoStory,
  video: VideoStory
};

function Story(props) {
  // Wrong! JSX type can't be an expression.  return &lt;components[props.storyType] story={props.story} /&gt;;}</pre> <p>To fix this, we will assign the type to a capitalized variable first:</p> <pre data-language="jsx">import React from 'react';
import { PhotoStory, VideoStory } from './stories';

const components = {
  photo: PhotoStory,
  video: VideoStory
};

function Story(props) {
  // Correct! JSX type can be a capitalized variable.  const SpecificStory = components[props.storyType];  return &lt;SpecificStory story={props.story} /&gt;;}</pre> <h2 id="props-in-jsx">Props in JSX </h2> <p>There are several different ways to specify props in JSX.</p> <h3 id="javascript-expressions-as-props">JavaScript Expressions as Props </h3> <p>You can pass any JavaScript expression as a prop, by surrounding it with <code class="gatsby-code-text">{}</code>. For example, in this JSX:</p> <pre data-language="jsx">&lt;MyComponent foo={1 + 2 + 3 + 4} /&gt;</pre> <p>For <code class="gatsby-code-text">MyComponent</code>, the value of <code class="gatsby-code-text">props.foo</code> will be <code class="gatsby-code-text">10</code> because the expression <code class="gatsby-code-text">1 + 2 + 3 + 4</code> gets evaluated.</p> <p><code class="gatsby-code-text">if</code> statements and <code class="gatsby-code-text">for</code> loops are not expressions in JavaScript, so they can’t be used in JSX directly. Instead, you can put these in the surrounding code. For example:</p> <pre data-language="jsx">function NumberDescriber(props) {
  let description;
  if (props.number % 2 == 0) {    description = &lt;strong&gt;even&lt;/strong&gt;;  } else {    description = &lt;i&gt;odd&lt;/i&gt;;  }  return &lt;div&gt;{props.number} is an {description} number&lt;/div&gt;;
}</pre> <p>You can learn more about <a href="conditional-rendering">conditional rendering</a> and <a href="lists-and-keys">loops</a> in the corresponding sections.</p> <h3 id="string-literals">String Literals </h3> <p>You can pass a string literal as a prop. These two JSX expressions are equivalent:</p> <pre data-language="jsx">&lt;MyComponent message="hello world" /&gt;

&lt;MyComponent message={'hello world'} /&gt;</pre> <p>When you pass a string literal, its value is HTML-unescaped. So these two JSX expressions are equivalent:</p> <pre data-language="jsx">&lt;MyComponent message="&amp;lt;3" /&gt;

&lt;MyComponent message={'&lt;3'} /&gt;</pre> <p>This behavior is usually not relevant. It’s only mentioned here for completeness.</p> <h3 id="props-default-to-true">Props Default to “True” </h3> <p>If you pass no value for a prop, it defaults to <code class="gatsby-code-text">true</code>. These two JSX expressions are equivalent:</p> <pre data-language="jsx">&lt;MyTextBox autocomplete /&gt;

&lt;MyTextBox autocomplete={true} /&gt;</pre> <p>In general, we don’t recommend <em>not</em> passing a value for a prop, because it can be confused with the <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Object_initializer#New_notations_in_ECMAScript_2015">ES6 object shorthand</a> <code class="gatsby-code-text">{foo}</code> which is short for <code class="gatsby-code-text">{foo: foo}</code> rather than <code class="gatsby-code-text">{foo: true}</code>. This behavior is just there so that it matches the behavior of HTML.</p> <h3 id="spread-attributes">Spread Attributes </h3> <p>If you already have <code class="gatsby-code-text">props</code> as an object, and you want to pass it in JSX, you can use <code class="gatsby-code-text">...</code> as a “spread” operator to pass the whole props object. These two components are equivalent:</p> <pre data-language="jsx">function App1() {
  return &lt;Greeting firstName="Ben" lastName="Hector" /&gt;;
}

function App2() {
  const props = {firstName: 'Ben', lastName: 'Hector'};
  return &lt;Greeting {...props} /&gt;;}</pre> <p>You can also pick specific props that your component will consume while passing all other props using the spread operator.</p> <pre data-language="jsx">const Button = props =&gt; {
  const { kind, ...other } = props;  const className = kind === "primary" ? "PrimaryButton" : "SecondaryButton";
  return &lt;button className={className} {...other} /&gt;;
};

const App = () =&gt; {
  return (
    &lt;div&gt;
      &lt;Button kind="primary" onClick={() =&gt; console.log("clicked!")}&gt;
        Hello World!
      &lt;/Button&gt;
    &lt;/div&gt;
  );
};</pre> <p>In the example above, the <code class="gatsby-code-text">kind</code> prop is safely consumed and <em>is not</em> passed on to the <code class="gatsby-code-text">&lt;button&gt;</code> element in the DOM. All other props are passed via the <code class="gatsby-code-text">...other</code> object making this component really flexible. You can see that it passes an <code class="gatsby-code-text">onClick</code> and <code class="gatsby-code-text">children</code> props.</p> <p>Spread attributes can be useful but they also make it easy to pass unnecessary props to components that don’t care about them or to pass invalid HTML attributes to the DOM. We recommend using this syntax sparingly. </p> <h2 id="children-in-jsx">Children in JSX </h2> <p>In JSX expressions that contain both an opening tag and a closing tag, the content between those tags is passed as a special prop: <code class="gatsby-code-text">props.children</code>. There are several different ways to pass children:</p> <h3 id="string-literals-1">String Literals </h3> <p>You can put a string between the opening and closing tags and <code class="gatsby-code-text">props.children</code> will just be that string. This is useful for many of the built-in HTML elements. For example:</p> <pre data-language="jsx">&lt;MyComponent&gt;Hello world!&lt;/MyComponent&gt;</pre> <p>This is valid JSX, and <code class="gatsby-code-text">props.children</code> in <code class="gatsby-code-text">MyComponent</code> will simply be the string <code class="gatsby-code-text">"Hello world!"</code>. HTML is unescaped, so you can generally write JSX just like you would write HTML in this way:</p> <pre data-language="html">&lt;div&gt;This is valid HTML &amp;amp; JSX at the same time.&lt;/div&gt;</pre> <p>JSX removes whitespace at the beginning and ending of a line. It also removes blank lines. New lines adjacent to tags are removed; new lines that occur in the middle of string literals are condensed into a single space. So these all render to the same thing:</p> <pre data-language="jsx">&lt;div&gt;Hello World&lt;/div&gt;

&lt;div&gt;
  Hello World
&lt;/div&gt;

&lt;div&gt;
  Hello
  World
&lt;/div&gt;

&lt;div&gt;

  Hello World
&lt;/div&gt;</pre> <h3 id="jsx-children">JSX Children </h3> <p>You can provide more JSX elements as the children. This is useful for displaying nested components:</p> <pre data-language="jsx">&lt;MyContainer&gt;
  &lt;MyFirstComponent /&gt;
  &lt;MySecondComponent /&gt;
&lt;/MyContainer&gt;</pre> <p>You can mix together different types of children, so you can use string literals together with JSX children. This is another way in which JSX is like HTML, so that this is both valid JSX and valid HTML:</p> <pre data-language="html">&lt;div&gt;
  Here is a list:
  &lt;ul&gt;
    &lt;li&gt;Item 1&lt;/li&gt;
    &lt;li&gt;Item 2&lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;</pre> <p>A React component can also return an array of elements:</p> <pre data-language="jsx">render() {
  // No need to wrap list items in an extra element!
  return [
    // Don't forget the keys :)
    &lt;li key="A"&gt;First item&lt;/li&gt;,
    &lt;li key="B"&gt;Second item&lt;/li&gt;,
    &lt;li key="C"&gt;Third item&lt;/li&gt;,
  ];
}</pre> <h3 id="javascript-expressions-as-children">JavaScript Expressions as Children </h3> <p>You can pass any JavaScript expression as children, by enclosing it within <code class="gatsby-code-text">{}</code>. For example, these expressions are equivalent:</p> <pre data-language="jsx">&lt;MyComponent&gt;foo&lt;/MyComponent&gt;

&lt;MyComponent&gt;{'foo'}&lt;/MyComponent&gt;</pre> <p>This is often useful for rendering a list of JSX expressions of arbitrary length. For example, this renders an HTML list:</p> <pre data-language="jsx">function Item(props) {
  return &lt;li&gt;{props.message}&lt;/li&gt;;}

function TodoList() {
  const todos = ['finish doc', 'submit pr', 'nag dan to review'];
  return (
    &lt;ul&gt;
      {todos.map((message) =&gt; &lt;Item key={message} message={message} /&gt;)}    &lt;/ul&gt;
  );
}</pre> <p>JavaScript expressions can be mixed with other types of children. This is often useful in lieu of string templates:</p> <pre data-language="jsx">function Hello(props) {
  return &lt;div&gt;Hello {props.addressee}!&lt;/div&gt;;}</pre> <h3 id="functions-as-children">Functions as Children </h3> <p>Normally, JavaScript expressions inserted in JSX will evaluate to a string, a React element, or a list of those things. However, <code class="gatsby-code-text">props.children</code> works just like any other prop in that it can pass any sort of data, not just the sorts that React knows how to render. For example, if you have a custom component, you could have it take a callback as <code class="gatsby-code-text">props.children</code>:</p> <pre data-language="jsx">// Calls the children callback numTimes to produce a repeated component
function Repeat(props) {
  let items = [];
  for (let i = 0; i &lt; props.numTimes; i++) {    items.push(props.children(i));
  }
  return &lt;div&gt;{items}&lt;/div&gt;;
}

function ListOfTenThings() {
  return (
    &lt;Repeat numTimes={10}&gt;
      {(index) =&gt; &lt;div key={index}&gt;This is item {index} in the list&lt;/div&gt;}    &lt;/Repeat&gt;
  );
}</pre> <p>Children passed to a custom component can be anything, as long as that component transforms them into something React can understand before rendering. This usage is not common, but it works if you want to stretch what JSX is capable of.</p> <h3 id="booleans-null-and-undefined-are-ignored">Booleans, Null, and Undefined Are Ignored </h3> <p><code class="gatsby-code-text">false</code>, <code class="gatsby-code-text">null</code>, <code class="gatsby-code-text">undefined</code>, and <code class="gatsby-code-text">true</code> are valid children. They simply don’t render. These JSX expressions will all render to the same thing:</p> <pre data-language="jsx">&lt;div /&gt;

&lt;div&gt;&lt;/div&gt;

&lt;div&gt;{false}&lt;/div&gt;

&lt;div&gt;{null}&lt;/div&gt;

&lt;div&gt;{undefined}&lt;/div&gt;

&lt;div&gt;{true}&lt;/div&gt;</pre> <p>This can be useful to conditionally render React elements. This JSX renders the <code class="gatsby-code-text">&lt;Header /&gt;</code> component only if <code class="gatsby-code-text">showHeader</code> is <code class="gatsby-code-text">true</code>:</p> <pre data-language="jsx">&lt;div&gt;
  {showHeader &amp;&amp; &lt;Header /&gt;}  &lt;Content /&gt;
&lt;/div&gt;</pre> <p>One caveat is that some <a href="https://developer.mozilla.org/en-US/docs/Glossary/Falsy">“falsy” values</a>, such as the <code class="gatsby-code-text">0</code> number, are still rendered by React. For example, this code will not behave as you might expect because <code class="gatsby-code-text">0</code> will be printed when <code class="gatsby-code-text">props.messages</code> is an empty array:</p> <pre data-language="jsx">&lt;div&gt;
  {props.messages.length &amp;&amp;    &lt;MessageList messages={props.messages} /&gt;
  }
&lt;/div&gt;</pre> <p>To fix this, make sure that the expression before <code class="gatsby-code-text">&amp;&amp;</code> is always boolean:</p> <pre data-language="jsx">&lt;div&gt;
  {props.messages.length &gt; 0 &amp;&amp;    &lt;MessageList messages={props.messages} /&gt;
  }
&lt;/div&gt;</pre> <p>Conversely, if you want a value like <code class="gatsby-code-text">false</code>, <code class="gatsby-code-text">true</code>, <code class="gatsby-code-text">null</code>, or <code class="gatsby-code-text">undefined</code> to appear in the output, you have to <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#String_conversion">convert it to a string</a> first:</p> <pre data-language="jsx">&lt;div&gt;
  My JavaScript variable is {String(myVariable)}.&lt;/div&gt;</pre>
<span><span>Is this page useful?</span></span><div class="_attribution">
  <p class="_attribution-p">
    © 2013–present Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>
    <a href="https://reactjs.org/docs/jsx-in-depth.html" class="_attribution-link">https://reactjs.org/docs/jsx-in-depth.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
