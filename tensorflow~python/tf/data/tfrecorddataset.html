
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>tf.data.TFRecordDataset - TensorFlow Python - W3cubDocs</title>
  
  <meta name="description" content=" Inherits From&#58; Dataset ">
  <meta name="keywords" content="tf, data, tfrecorddataset, tensorflow, python, tensorflow~python">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/tensorflow~python/tf/data/tfrecorddataset.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/tensorflow~python.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/tensorflow~python/" class="_nav-link" title="" style="margin-left:0;">TensorFlow Python</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _tensorflow">
				
				
<h1 itemprop="name" class="devsite-page-title"> tf.data.TFRecordDataset </h1>     <div itemscope itemtype="http://developers.google.com/ReferenceObject"> <meta itemprop="name" content="tf.data.TFRecordDataset"> <meta itemprop="path" content="r1.8"> <meta itemprop="property" content="output_classes"> <meta itemprop="property" content="output_shapes"> <meta itemprop="property" content="output_types"> <meta itemprop="property" content="__init__"> <meta itemprop="property" content="__iter__"> <meta itemprop="property" content="apply"> <meta itemprop="property" content="batch"> <meta itemprop="property" content="cache"> <meta itemprop="property" content="concatenate"> <meta itemprop="property" content="filter"> <meta itemprop="property" content="flat_map"> <meta itemprop="property" content="from_generator"> <meta itemprop="property" content="from_sparse_tensor_slices"> <meta itemprop="property" content="from_tensor_slices"> <meta itemprop="property" content="from_tensors"> <meta itemprop="property" content="interleave"> <meta itemprop="property" content="list_files"> <meta itemprop="property" content="make_initializable_iterator"> <meta itemprop="property" content="make_one_shot_iterator"> <meta itemprop="property" content="map"> <meta itemprop="property" content="padded_batch"> <meta itemprop="property" content="prefetch"> <meta itemprop="property" content="range"> <meta itemprop="property" content="repeat"> <meta itemprop="property" content="shard"> <meta itemprop="property" content="shuffle"> <meta itemprop="property" content="skip"> <meta itemprop="property" content="take"> <meta itemprop="property" content="zip"> </div> <h2 id="class_tfrecorddataset">Class <code>TFRecordDataset</code>
</h2> <p>Inherits From: <a href="dataset"><code>Dataset</code></a></p> <p>Defined in <a href="https://www.github.com/tensorflow/tensorflow/blob/r1.8/tensorflow/python/data/ops/readers.py"><code>tensorflow/python/data/ops/readers.py</code></a>.</p> <p>See the guides: <a href="https://www.tensorflow.org/api_guides/python/input_dataset#Reader_classes">Dataset Input Pipeline &gt; Reader classes</a>, <a href="https://www.tensorflow.org/api_guides/python/reading_data#_QueueRunner_">Reading data &gt; <code>QueueRunner</code></a></p> <p>A <code>Dataset</code> comprising records from one or more TFRecord files.</p> <h2 id="properties">Properties</h2> <h3 id="output_classes"><code>output_classes</code></h3> <p>Returns the class of each component of an element of this dataset.</p> <p>The expected values are <a href="../tensor"><code>tf.Tensor</code></a> and <a href="../sparsetensor"><code>tf.SparseTensor</code></a>.</p> <h4 id="returns">Returns:</h4> <p>A nested structure of Python <code>type</code> objects corresponding to each component of an element of this dataset.</p> <h3 id="output_shapes"><code>output_shapes</code></h3> <p>Returns the shape of each component of an element of this dataset.</p> <h4 id="returns_1">Returns:</h4> <p>A nested structure of <a href="../tensorshape"><code>tf.TensorShape</code></a> objects corresponding to each component of an element of this dataset.</p> <h3 id="output_types"><code>output_types</code></h3> <p>Returns the type of each component of an element of this dataset.</p> <h4 id="returns_2">Returns:</h4> <p>A nested structure of <a href="../dtype"><code>tf.DType</code></a> objects corresponding to each component of an element of this dataset.</p> <h2 id="methods">Methods</h2> <h3 id="__init__"><code>__init__</code></h3> <pre class="prettyprint lang-python" data-language="python">__init__(
    filenames,
    compression_type=None,
    buffer_size=None,
    num_parallel_reads=None
)
</pre> <p>Creates a <code>TFRecordDataset</code> to read for one or more TFRecord files.</p> <p>NOTE: The <code>num_parallel_reads</code> argument can be used to improve performance when reading from a remote filesystem.</p> <h4 id="args">Args:</h4> <ul> <li>
<b><code>filenames</code></b>: A <a href="../string"><code>tf.string</code></a> tensor or <a href="dataset"><code>tf.data.Dataset</code></a> containing one or more filenames.</li> <li>
<b><code>compression_type</code></b>: (Optional.) A <a href="../string"><code>tf.string</code></a> scalar evaluating to one of <code>""</code> (no compression), <code>"ZLIB"</code>, or <code>"GZIP"</code>.</li> <li>
<b><code>buffer_size</code></b>: (Optional.) A <a href="../int64"><code>tf.int64</code></a> scalar representing the number of bytes in the read buffer. 0 means no buffering.</li> <li>
<b><code>num_parallel_reads</code></b>: (Optional.) A <a href="../int64"><code>tf.int64</code></a> scalar representing the number of files to read in parallel. Defaults to reading files sequentially.</li> </ul> <h4 id="raises">Raises:</h4> <ul> <li>
<b><code>TypeError</code></b>: If any argument does not have the expected type.</li> <li>
<b><code>ValueError</code></b>: If any argument does not have the expected shape.</li> </ul> <h3 id="__iter__"><code>__iter__</code></h3> <pre class="prettyprint lang-python" data-language="python">__iter__()
</pre> <p>Creates an <code>Iterator</code> for enumerating the elements of this dataset.</p> <p>The returned iterator implements the Python iterator protocol and therefore can only be used in eager mode.</p> <h4 id="returns_3">Returns:</h4> <p>An <code>Iterator</code> over the elements of this dataset.</p> <h4 id="raises_1">Raises:</h4> <ul> <li>
<b><code>RuntimeError</code></b>: If eager execution is not enabled.</li> </ul> <h3 id="apply"><code>apply</code></h3> <pre class="prettyprint lang-python" data-language="python">apply(transformation_func)
</pre> <p>Apply a transformation function to this dataset.</p> <p><code>apply</code> enables chaining of custom <code>Dataset</code> transformations, which are represented as functions that take one <code>Dataset</code> argument and return a transformed <code>Dataset</code>.</p> <p>For example:</p> <pre class="prettyprint" data-language="python">dataset = (dataset.map(lambda x: x ** 2)
           .apply(group_by_window(key_func, reduce_func, window_size))
           .map(lambda x: x ** 3))
</pre> <h4 id="args_1">Args:</h4> <ul> <li>
<b><code>transformation_func</code></b>: A function that takes one <code>Dataset</code> argument and returns a <code>Dataset</code>.</li> </ul> <h4 id="returns_4">Returns:</h4> <ul> <li>
<b><code>Dataset</code></b>: The <code>Dataset</code> returned by applying <code>transformation_func</code> to this dataset.</li> </ul> <h3 id="batch"><code>batch</code></h3> <pre class="prettyprint lang-python" data-language="python">batch(batch_size)
</pre> <p>Combines consecutive elements of this dataset into batches.</p> <p>NOTE: If the number of elements (<code>N</code>) in this dataset is not an exact multiple of <code>batch_size</code>, the final batch contain smaller tensors with shape <code>N % batch_size</code> in the batch dimension. If your program depends on the batches having the same shape, consider using the <a href="../contrib/data/batch_and_drop_remainder"><code>tf.contrib.data.batch_and_drop_remainder</code></a> transformation instead.</p> <h4 id="args_2">Args:</h4> <ul> <li>
<b><code>batch_size</code></b>: A <a href="../int64"><code>tf.int64</code></a> scalar <a href="../tensor"><code>tf.Tensor</code></a>, representing the number of consecutive elements of this dataset to combine in a single batch.</li> </ul> <h4 id="returns_5">Returns:</h4> <ul> <li>
<b><code>Dataset</code></b>: A <code>Dataset</code>.</li> </ul> <h3 id="cache"><code>cache</code></h3> <pre class="prettyprint lang-python" data-language="python">cache(filename='')
</pre> <p>Caches the elements in this dataset.</p> <h4 id="args_3">Args:</h4> <ul> <li>
<b><code>filename</code></b>: A <a href="../string"><code>tf.string</code></a> scalar <a href="../tensor"><code>tf.Tensor</code></a>, representing the name of a directory on the filesystem to use for caching tensors in this Dataset. If a filename is not provided, the dataset will be cached in memory.</li> </ul> <h4 id="returns_6">Returns:</h4> <ul> <li>
<b><code>Dataset</code></b>: A <code>Dataset</code>.</li> </ul> <h3 id="concatenate"><code>concatenate</code></h3> <pre class="prettyprint lang-python" data-language="python">concatenate(dataset)
</pre> <p>Creates a <code>Dataset</code> by concatenating given dataset with this dataset.</p> <pre class="prettyprint lang-python" data-language="python"># NOTE: The following examples use `{ ... }` to represent the
# contents of a dataset.
a = { 1, 2, 3 }
b = { 4, 5, 6, 7 }

# Input dataset and dataset to be concatenated should have same
# nested structures and output types.
# c = { (8, 9), (10, 11), (12, 13) }
# d = { 14.0, 15.0, 16.0 }
# a.concatenate(c) and a.concatenate(d) would result in error.

a.concatenate(b) == { 1, 2, 3, 4, 5, 6, 7 }
</pre> <h4 id="args_4">Args:</h4> <ul> <li>
<b><code>dataset</code></b>: <code>Dataset</code> to be concatenated.</li> </ul> <h4 id="returns_7">Returns:</h4> <ul> <li>
<b><code>Dataset</code></b>: A <code>Dataset</code>.</li> </ul> <h3 id="filter"><code>filter</code></h3> <pre class="prettyprint lang-python" data-language="python">filter(predicate)
</pre> <p>Filters this dataset according to <code>predicate</code>.</p> <h4 id="args_5">Args:</h4> <ul> <li>
<b><code>predicate</code></b>: A function mapping a nested structure of tensors (having shapes and types defined by <code>self.output_shapes</code> and <code>self.output_types</code>) to a scalar <a href="../bool"><code>tf.bool</code></a> tensor.</li> </ul> <h4 id="returns_8">Returns:</h4> <ul> <li>
<b><code>Dataset</code></b>: A <code>Dataset</code>.</li> </ul> <h3 id="flat_map"><code>flat_map</code></h3> <pre class="prettyprint lang-python" data-language="python">flat_map(map_func)
</pre> <p>Maps <code>map_func</code> across this dataset and flattens the result.</p> <h4 id="args_6">Args:</h4> <ul> <li>
<b><code>map_func</code></b>: A function mapping a nested structure of tensors (having shapes and types defined by <code>self.output_shapes</code> and <code>self.output_types</code>) to a <code>Dataset</code>.</li> </ul> <h4 id="returns_9">Returns:</h4> <ul> <li>
<b><code>Dataset</code></b>: A <code>Dataset</code>.</li> </ul> <h3 id="from_generator"><code>from_generator</code></h3> <pre class="prettyprint lang-python" data-language="python">from_generator(
    generator,
    output_types,
    output_shapes=None
)
</pre> <p>Creates a <code>Dataset</code> whose elements are generated by <code>generator</code>.</p> <p>The <code>generator</code> argument must be a callable object that returns an object that support the <code>iter()</code> protocol (e.g. a generator function). The elements generated by <code>generator</code> must be compatible with the given <code>output_types</code> and (optional) <code>output_shapes</code> arguments.</p> <p>For example:</p> <pre class="prettyprint lang-python" data-language="python">import itertools

def gen():
  for i in itertools.count(1):
    yield (i, [1] * i)

ds = Dataset.from_generator(
    gen, (tf.int64, tf.int64), (tf.TensorShape([]), tf.TensorShape([None])))
value = ds.make_one_shot_iterator().get_next()

sess.run(value)  # (1, array([1]))
sess.run(value)  # (2, array([1, 1]))
</pre> <p>NOTE: The current implementation of <code>Dataset.from_generator()</code> uses <a href="../py_func"><code>tf.py_func</code></a> and inherits the same constraints. In particular, it requires the <code>Dataset</code>- and <code>Iterator</code>-related operations to be placed on a device in the same process as the Python program that called <code>Dataset.from_generator()</code>. The body of <code>generator</code> will not be serialized in a <code>GraphDef</code>, and you should not use this method if you need to serialize your model and restore it in a different environment.</p> <p>NOTE: If <code>generator</code> depends on mutable global variables or other external state, be aware that the runtime may invoke <code>generator</code> multiple times (in order to support repeating the <code>Dataset</code>) and at any time between the call to <code>Dataset.from_generator()</code> and the production of the first element from the generator. Mutating global variables or external state can cause undefined behavior, and we recommend that you explicitly cache any external state in <code>generator</code> before calling <code>Dataset.from_generator()</code>.</p> <h4 id="args_7">Args:</h4> <ul> <li>
<b><code>generator</code></b>: A callable object that takes no arguments and returns an object that supports the <code>iter()</code> protocol.</li> <li>
<b><code>output_types</code></b>: A nested structure of <a href="../dtype"><code>tf.DType</code></a> objects corresponding to each component of an element yielded by <code>generator</code>.</li> <li>
<b><code>output_shapes</code></b>: (Optional.) A nested structure of <a href="../tensorshape"><code>tf.TensorShape</code></a> objects corresponding to each component of an element yielded by <code>generator</code>.</li> </ul> <h4 id="returns_10">Returns:</h4> <ul> <li>
<b><code>Dataset</code></b>: A <code>Dataset</code>.</li> </ul> <h3 id="from_sparse_tensor_slices"><code>from_sparse_tensor_slices</code></h3> <pre class="prettyprint lang-python" data-language="python">from_sparse_tensor_slices(sparse_tensor)
</pre> <p>Splits each rank-N <a href="../sparsetensor"><code>tf.SparseTensor</code></a> in this dataset row-wise. (deprecated)</p> <p>THIS FUNCTION IS DEPRECATED. It will be removed in a future version. Instructions for updating: Use <code>tf.data.Dataset.from_tensor_slices()</code>.</p> <h4 id="args_8">Args:</h4> <ul> <li>
<b><code>sparse_tensor</code></b>: A <a href="../sparsetensor"><code>tf.SparseTensor</code></a>.</li> </ul> <h4 id="returns_11">Returns:</h4> <ul> <li>
<b><code>Dataset</code></b>: A <code>Dataset</code> of rank-(N-1) sparse tensors.</li> </ul> <h3 id="from_tensor_slices"><code>from_tensor_slices</code></h3> <pre class="prettyprint lang-python" data-language="python">from_tensor_slices(tensors)
</pre> <p>Creates a <code>Dataset</code> whose elements are slices of the given tensors.</p> <h4 id="args_9">Args:</h4> <ul> <li>
<b><code>tensors</code></b>: A nested structure of tensors, each having the same size in the 0th dimension.</li> </ul> <h4 id="returns_12">Returns:</h4> <ul> <li>
<b><code>Dataset</code></b>: A <code>Dataset</code>.</li> </ul> <h3 id="from_tensors"><code>from_tensors</code></h3> <pre class="prettyprint lang-python" data-language="python">from_tensors(tensors)
</pre> <p>Creates a <code>Dataset</code> with a single element, comprising the given tensors.</p> <h4 id="args_10">Args:</h4> <ul> <li>
<b><code>tensors</code></b>: A nested structure of tensors.</li> </ul> <h4 id="returns_13">Returns:</h4> <ul> <li>
<b><code>Dataset</code></b>: A <code>Dataset</code>.</li> </ul> <h3 id="interleave"><code>interleave</code></h3> <pre class="prettyprint lang-python" data-language="python">interleave(
    map_func,
    cycle_length,
    block_length=1
)
</pre> <p>Maps <code>map_func</code> across this dataset, and interleaves the results.</p> <p>For example, you can use <code>Dataset.interleave()</code> to process many input files concurrently:</p> <pre class="prettyprint lang-python" data-language="python"># Preprocess 4 files concurrently, and interleave blocks of 16 records from
# each file.
filenames = ["/var/data/file1.txt", "/var/data/file2.txt", ...]
dataset = (Dataset.from_tensor_slices(filenames)
           .interleave(lambda x:
               TextLineDataset(x).map(parse_fn, num_parallel_calls=1),
               cycle_length=4, block_length=16))
</pre> <p>The <code>cycle_length</code> and <code>block_length</code> arguments control the order in which elements are produced. <code>cycle_length</code> controls the number of input elements that are processed concurrently. If you set <code>cycle_length</code> to 1, this transformation will handle one input element at a time, and will produce identical results = to <a href="dataset#flat_map"><code>tf.data.Dataset.flat_map</code></a>. In general, this transformation will apply <code>map_func</code> to <code>cycle_length</code> input elements, open iterators on the returned <code>Dataset</code> objects, and cycle through them producing <code>block_length</code> consecutive elements from each iterator, and consuming the next input element each time it reaches the end of an iterator.</p> <p>For example:</p> <pre class="prettyprint lang-python" data-language="python"># NOTE: The following examples use `{ ... }` to represent the
# contents of a dataset.
a = { 1, 2, 3, 4, 5 }

# NOTE: New lines indicate "block" boundaries.
a.interleave(lambda x: Dataset.from_tensors(x).repeat(6),
             cycle_length=2, block_length=4) == {
    1, 1, 1, 1,
    2, 2, 2, 2,
    1, 1,
    2, 2,
    3, 3, 3, 3,
    4, 4, 4, 4,
    3, 3,
    4, 4,
    5, 5, 5, 5,
    5, 5,
}
</pre> <p>NOTE: The order of elements yielded by this transformation is deterministic, as long as <code>map_func</code> is a pure function. If <code>map_func</code> contains any stateful operations, the order in which that state is accessed is undefined.</p> <h4 id="args_11">Args:</h4> <ul> <li>
<b><code>map_func</code></b>: A function mapping a nested structure of tensors (having shapes and types defined by <code>self.output_shapes</code> and <code>self.output_types</code>) to a <code>Dataset</code>.</li> <li>
<b><code>cycle_length</code></b>: The number of elements from this dataset that will be processed concurrently.</li> <li>
<b><code>block_length</code></b>: The number of consecutive elements to produce from each input element before cycling to another input element.</li> </ul> <h4 id="returns_14">Returns:</h4> <ul> <li>
<b><code>Dataset</code></b>: A <code>Dataset</code>.</li> </ul> <h3 id="list_files"><code>list_files</code></h3> <pre class="prettyprint lang-python" data-language="python">list_files(
    file_pattern,
    shuffle=None
)
</pre> <p>A dataset of all files matching a pattern.</p> <p>Example: If we had the following files on our filesystem: - /path/to/dir/a.txt - /path/to/dir/b.py - /path/to/dir/c.py If we pass "/path/to/dir/*.py" as the directory, the dataset would produce: - /path/to/dir/b.py - /path/to/dir/c.py</p> <p>NOTE: The order of the file names returned can be non-deterministic even when <code>shuffle</code> is <code>False</code>.</p> <h4 id="args_12">Args:</h4> <ul> <li>
<b><code>file_pattern</code></b>: A string or scalar string <a href="../tensor"><code>tf.Tensor</code></a>, representing the filename pattern that will be matched.</li> <li>
<b><code>shuffle</code></b>: (Optional.) If <code>True</code>, the file names will be shuffled randomly. Defaults to <code>True</code>.</li> </ul> <h4 id="returns_15">Returns:</h4> <p>Dataset: A <code>Dataset</code> of strings corresponding to file names.</p> <h3 id="make_initializable_iterator"><code>make_initializable_iterator</code></h3> <pre class="prettyprint lang-python" data-language="python">make_initializable_iterator(shared_name=None)
</pre> <p>Creates an <code>Iterator</code> for enumerating the elements of this dataset.</p> <blockquote class="note">
<strong>Note:</strong><span> The returned iterator will be in an uninitialized state, and you must run the <code>iterator.initializer</code> operation before using it:</span>
</blockquote> <pre class="prettyprint lang-python" data-language="python">dataset = ...
iterator = dataset.make_initializable_iterator()
# ...
sess.run(iterator.initializer)
</pre> <h4 id="args_13">Args:</h4> <ul> <li>
<b><code>shared_name</code></b>: (Optional.) If non-empty, the returned iterator will be shared under the given name across multiple sessions that share the same devices (e.g. when using a remote server).</li> </ul> <h4 id="returns_16">Returns:</h4> <p>An <code>Iterator</code> over the elements of this dataset.</p> <h4 id="raises_2">Raises:</h4> <ul> <li>
<b><code>RuntimeError</code></b>: If eager execution is enabled.</li> </ul> <h3 id="make_one_shot_iterator"><code>make_one_shot_iterator</code></h3> <pre class="prettyprint lang-python" data-language="python">make_one_shot_iterator()
</pre> <p>Creates an <code>Iterator</code> for enumerating the elements of this dataset.</p> <blockquote class="note">
<strong>Note:</strong><span> The returned iterator will be initialized automatically. A "one-shot" iterator does not currently support re-initialization.</span>
</blockquote> <h4 id="returns_17">Returns:</h4> <p>An <code>Iterator</code> over the elements of this dataset.</p> <h3 id="map"><code>map</code></h3> <pre class="prettyprint lang-python" data-language="python">map(
    map_func,
    num_parallel_calls=None
)
</pre> <p>Maps <code>map_func</code> across this dataset.</p> <h4 id="args_14">Args:</h4> <ul> <li>
<b><code>map_func</code></b>: A function mapping a nested structure of tensors (having shapes and types defined by <code>self.output_shapes</code> and <code>self.output_types</code>) to another nested structure of tensors.</li> <li>
<b><code>num_parallel_calls</code></b>: (Optional.) A <a href="../int32"><code>tf.int32</code></a> scalar <a href="../tensor"><code>tf.Tensor</code></a>, representing the number elements to process in parallel. If not specified, elements will be processed sequentially.</li> </ul> <h4 id="returns_18">Returns:</h4> <ul> <li>
<b><code>Dataset</code></b>: A <code>Dataset</code>.</li> </ul> <h3 id="padded_batch"><code>padded_batch</code></h3> <pre class="prettyprint lang-python" data-language="python">padded_batch(
    batch_size,
    padded_shapes,
    padding_values=None
)
</pre> <p>Combines consecutive elements of this dataset into padded batches.</p> <p>This transformation combines multiple consecutive elements of the input dataset into a single element. Like <a href="dataset#batch"><code>tf.data.Dataset.batch</code></a>, the tensors in the resulting element have an additional outer dimension, which will be <code>batch_size</code> for all but the last element, and <code>N % batch_size</code> for the last element (where <code>N</code> is the number of elements in this dataset). Unlike <a href="dataset#batch"><code>tf.data.Dataset.batch</code></a>, the elements may have different shapes for some of their components, and this transformation will pad each component to the respective shape in <code>padding_shapes</code>. The <code>padding_shapes</code> argument determines the resulting shape for each dimension of each component in an output element:</p> <ul> <li>If the dimension is a constant (e.g. <code>tf.Dimension(37)</code>), the component will be padded out to that length in that dimension.</li> <li>If the dimension is unknown (e.g. <code>tf.Dimension(None)</code>), the component will be padded out to the maximum length of all elements in that dimension.</li> </ul> <p>NOTE: If the number of elements (<code>N</code>) in this dataset is not an exact multiple of <code>batch_size</code>, the final batch contain smaller tensors with shape <code>N % batch_size</code> in the batch dimension. If your program depends on the batches having the same shape, consider using the <a href="../contrib/data/padded_batch_and_drop_remainder"><code>tf.contrib.data.padded_batch_and_drop_remainder</code></a> transformation instead.</p> <p>See also <a href="../contrib/data/dense_to_sparse_batch"><code>tf.contrib.data.dense_to_sparse_batch</code></a>, which combines elements that may have different shapes into a <a href="../sparsetensor"><code>tf.SparseTensor</code></a>.</p> <h4 id="args_15">Args:</h4> <ul> <li>
<b><code>batch_size</code></b>: A <a href="../int64"><code>tf.int64</code></a> scalar <a href="../tensor"><code>tf.Tensor</code></a>, representing the number of consecutive elements of this dataset to combine in a single batch.</li> <li>
<b><code>padded_shapes</code></b>: A nested structure of <a href="../tensorshape"><code>tf.TensorShape</code></a> or <a href="../int64"><code>tf.int64</code></a> vector tensor-like objects representing the shape to which the respective component of each input element should be padded prior to batching. Any unknown dimensions (e.g. <code>tf.Dimension(None)</code> in a <a href="../tensorshape"><code>tf.TensorShape</code></a> or <code>-1</code> in a tensor-like object) will be padded to the maximum size of that dimension in each batch.</li> <li>
<b><code>padding_values</code></b>: (Optional.) A nested structure of scalar-shaped <a href="../tensor"><code>tf.Tensor</code></a>, representing the padding values to use for the respective components. Defaults are <code>0</code> for numeric types and the empty string for string types.</li> </ul> <h4 id="returns_19">Returns:</h4> <ul> <li>
<b><code>Dataset</code></b>: A <code>Dataset</code>.</li> </ul> <h3 id="prefetch"><code>prefetch</code></h3> <pre class="prettyprint lang-python" data-language="python">prefetch(buffer_size)
</pre> <p>Creates a <code>Dataset</code> that prefetches elements from this dataset.</p> <h4 id="args_16">Args:</h4> <ul> <li>
<b><code>buffer_size</code></b>: A <a href="../int64"><code>tf.int64</code></a> scalar <a href="../tensor"><code>tf.Tensor</code></a>, representing the maximum number of elements that will be buffered when prefetching.</li> </ul> <h4 id="returns_20">Returns:</h4> <ul> <li>
<b><code>Dataset</code></b>: A <code>Dataset</code>.</li> </ul> <h3 id="range"><code>range</code></h3> <pre class="prettyprint lang-python" data-language="python">range(*args)
</pre> <p>Creates a <code>Dataset</code> of a step-separated range of values.</p> <p>For example:</p> <pre class="prettyprint lang-python" data-language="python">Dataset.range(5) == [0, 1, 2, 3, 4]
Dataset.range(2, 5) == [2, 3, 4]
Dataset.range(1, 5, 2) == [1, 3]
Dataset.range(1, 5, -2) == []
Dataset.range(5, 1) == []
Dataset.range(5, 1, -2) == [5, 3]
</pre> <h4 id="args_17">Args:</h4> <ul> <li>
<b><code>*args</code></b>: follow same semantics as python's xrange. len(args) == 1 -&gt; start = 0, stop = args[0], step = 1 len(args) == 2 -&gt; start = args[0], stop = args[1], step = 1 len(args) == 3 -&gt; start = args[0], stop = args[1, stop = args[2]</li> </ul> <h4 id="returns_21">Returns:</h4> <ul> <li>
<b><code>Dataset</code></b>: A <code>RangeDataset</code>.</li> </ul> <h4 id="raises_3">Raises:</h4> <ul> <li>
<b><code>ValueError</code></b>: if len(args) == 0.</li> </ul> <h3 id="repeat"><code>repeat</code></h3> <pre class="prettyprint lang-python" data-language="python">repeat(count=None)
</pre> <p>Repeats this dataset <code>count</code> times.</p> <p>NOTE: If this dataset is a function of global state (e.g. a random number generator), then different repetitions may produce different elements.</p> <h4 id="args_18">Args:</h4> <ul> <li>
<b><code>count</code></b>: (Optional.) A <a href="../int64"><code>tf.int64</code></a> scalar <a href="../tensor"><code>tf.Tensor</code></a>, representing the number of times the dataset should be repeated. The default behavior (if <code>count</code> is <code>None</code> or <code>-1</code>) is for the dataset be repeated indefinitely.</li> </ul> <h4 id="returns_22">Returns:</h4> <ul> <li>
<b><code>Dataset</code></b>: A <code>Dataset</code>.</li> </ul> <h3 id="shard"><code>shard</code></h3> <pre class="prettyprint lang-python" data-language="python">shard(
    num_shards,
    index
)
</pre> <p>Creates a <code>Dataset</code> that includes only 1/<code>num_shards</code> of this dataset.</p> <p>This dataset operator is very useful when running distributed training, as it allows each worker to read a unique subset.</p> <p>When reading a single input file, you can skip elements as follows:</p> <pre class="prettyprint lang-python" data-language="python">d = tf.data.TFRecordDataset(FLAGS.input_file)
d = d.shard(FLAGS.num_workers, FLAGS.worker_index)
d = d.repeat(FLAGS.num_epochs)
d = d.shuffle(FLAGS.shuffle_buffer_size)
d = d.map(parser_fn, num_parallel_calls=FLAGS.num_map_threads)
</pre> <p>Important caveats:</p> <ul> <li>Be sure to shard before you use any randomizing operator (such as shuffle).</li> <li>Generally it is best if the shard operator is used early in the dataset pipeline. For example, when reading from a set of TFRecord files, shard before converting the dataset to input samples. This avoids reading every file on every worker. The following is an example of an efficient sharding strategy within a complete pipeline:</li> </ul> <pre class="prettyprint lang-python" data-language="python">d = Dataset.list_files(FLAGS.pattern)
d = d.shard(FLAGS.num_workers, FLAGS.worker_index)
d = d.repeat(FLAGS.num_epochs)
d = d.shuffle(FLAGS.shuffle_buffer_size)
d = d.repeat()
d = d.interleave(tf.data.TFRecordDataset,
                 cycle_length=FLAGS.num_readers, block_length=1)
d = d.map(parser_fn, num_parallel_calls=FLAGS.num_map_threads)
</pre> <h4 id="args_19">Args:</h4> <ul> <li>
<b><code>num_shards</code></b>: A <a href="../int64"><code>tf.int64</code></a> scalar <a href="../tensor"><code>tf.Tensor</code></a>, representing the number of shards operating in parallel.</li> <li>
<b><code>index</code></b>: A <a href="../int64"><code>tf.int64</code></a> scalar <a href="../tensor"><code>tf.Tensor</code></a>, representing the worker index.</li> </ul> <h4 id="returns_23">Returns:</h4> <ul> <li>
<b><code>Dataset</code></b>: A <code>Dataset</code>.</li> </ul> <h4 id="raises_4">Raises:</h4> <ul> <li>
<b><code>ValueError</code></b>: if <code>num_shards</code> or <code>index</code> are illegal values. Note: error checking is done on a best-effort basis, and aren't guaranteed to be caught upon dataset creation. (e.g. providing in a placeholder tensor bypasses the early checking, and will instead result in an error during a session.run call.)</li> </ul> <h3 id="shuffle"><code>shuffle</code></h3> <pre class="prettyprint lang-python" data-language="python">shuffle(
    buffer_size,
    seed=None,
    reshuffle_each_iteration=None
)
</pre> <p>Randomly shuffles the elements of this dataset.</p> <h4 id="args_20">Args:</h4> <ul> <li>
<b><code>buffer_size</code></b>: A <a href="../int64"><code>tf.int64</code></a> scalar <a href="../tensor"><code>tf.Tensor</code></a>, representing the number of elements from this dataset from which the new dataset will sample.</li> <li>
<b><code>seed</code></b>: (Optional.) A <a href="../int64"><code>tf.int64</code></a> scalar <a href="../tensor"><code>tf.Tensor</code></a>, representing the random seed that will be used to create the distribution. See <a href="../set_random_seed"><code>tf.set_random_seed</code></a> for behavior.</li> <li>
<b><code>reshuffle_each_iteration</code></b>: (Optional.) A boolean, which if true indicates that the dataset should be pseudorandomly reshuffled each time it is iterated over. (Defaults to <code>True</code>.)</li> </ul> <h4 id="returns_24">Returns:</h4> <ul> <li>
<b><code>Dataset</code></b>: A <code>Dataset</code>.</li> </ul> <h3 id="skip"><code>skip</code></h3> <pre class="prettyprint lang-python" data-language="python">skip(count)
</pre> <p>Creates a <code>Dataset</code> that skips <code>count</code> elements from this dataset.</p> <h4 id="args_21">Args:</h4> <ul> <li>
<b><code>count</code></b>: A <a href="../int64"><code>tf.int64</code></a> scalar <a href="../tensor"><code>tf.Tensor</code></a>, representing the number of elements of this dataset that should be skipped to form the new dataset. If <code>count</code> is greater than the size of this dataset, the new dataset will contain no elements. If <code>count</code> is -1, skips the entire dataset.</li> </ul> <h4 id="returns_25">Returns:</h4> <ul> <li>
<b><code>Dataset</code></b>: A <code>Dataset</code>.</li> </ul> <h3 id="take"><code>take</code></h3> <pre class="prettyprint lang-python" data-language="python">take(count)
</pre> <p>Creates a <code>Dataset</code> with at most <code>count</code> elements from this dataset.</p> <h4 id="args_22">Args:</h4> <ul> <li>
<b><code>count</code></b>: A <a href="../int64"><code>tf.int64</code></a> scalar <a href="../tensor"><code>tf.Tensor</code></a>, representing the number of elements of this dataset that should be taken to form the new dataset. If <code>count</code> is -1, or if <code>count</code> is greater than the size of this dataset, the new dataset will contain all elements of this dataset.</li> </ul> <h4 id="returns_26">Returns:</h4> <ul> <li>
<b><code>Dataset</code></b>: A <code>Dataset</code>.</li> </ul> <h3 id="zip"><code>zip</code></h3> <pre class="prettyprint lang-python" data-language="python">zip(datasets)
</pre> <p>Creates a <code>Dataset</code> by zipping together the given datasets.</p> <p>This method has similar semantics to the built-in <code>zip()</code> function in Python, with the main difference being that the <code>datasets</code> argument can be an arbitrary nested structure of <code>Dataset</code> objects. For example:</p> <pre class="prettyprint lang-python" data-language="python"># NOTE: The following examples use `{ ... }` to represent the
# contents of a dataset.
a = { 1, 2, 3 }
b = { 4, 5, 6 }
c = { (7, 8), (9, 10), (11, 12) }
d = { 13, 14 }

# The nested structure of the `datasets` argument determines the
# structure of elements in the resulting dataset.
Dataset.zip((a, b)) == { (1, 4), (2, 5), (3, 6) }
Dataset.zip((b, a)) == { (4, 1), (5, 2), (6, 3) }

# The `datasets` argument may contain an arbitrary number of
# datasets.
Dataset.zip((a, b, c)) == { (1, 4, (7, 8)),
                            (2, 5, (9, 10)),
                            (3, 6, (11, 12)) }

# The number of elements in the resulting dataset is the same as
# the size of the smallest dataset in `datasets`.
Dataset.zip((a, d)) == { (1, 13), (2, 14) }
</pre> <h4 id="args_23">Args:</h4> <ul> <li>
<b><code>datasets</code></b>: A nested structure of datasets.</li> </ul> <h4 id="returns_27">Returns:</h4> <ul> <li>
<b><code>Dataset</code></b>: A <code>Dataset</code>.</li> </ul>
<div class="_attribution">
  <p class="_attribution-p">
    Â© 2018 The TensorFlow Authors. All rights reserved.<br>Licensed under the Creative Commons Attribution License 3.0.<br>Code samples licensed under the Apache 2.0 License.<br>
    <a href="https://www.tensorflow.org/api_docs/python/tf/data/TFRecordDataset" class="_attribution-link">https://www.tensorflow.org/api_docs/python/tf/data/TFRecordDataset</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
