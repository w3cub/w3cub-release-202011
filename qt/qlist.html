
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>QList (Class) - Qt - W3cubDocs</title>
  
  <meta name="description" content=" The QList class is a template class that provides a dynamic array. More... ">
  <meta name="keywords" content="qlist, class, qt">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/qt/qlist.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/qt.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/qt/" class="_nav-link" title="" style="margin-left:0;">Qt</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _qt">
				
				
<h1 class="title">QList Class</h1> <span class="small-subtitle">template &lt;typename T&gt; class QList</span>  <p>The QList class is a template class that provides a dynamic array. <a href="#details">More...</a></p>  <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> Header:</td>
<td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QList&gt;</span> </td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> CMake:</td>
<td class="memItemRight bottomAlign"> find_package(Qt6 COMPONENTS Core REQUIRED)  target_link_libraries(mytarget PRIVATE Qt6::Core)</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> qmake:</td>
<td class="memItemRight bottomAlign"> QT += core</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Inherited By:</td>
<td class="memItemRight bottomAlign"> <p><a href="qbluetoothserviceinfo-alternative">QBluetoothServiceInfo::Alternative</a>, <a href="qbluetoothserviceinfo-sequence">QBluetoothServiceInfo::Sequence</a>, <a href="qbytearraylist">QByteArrayList</a>, <a href="qitemselection">QItemSelection</a>, <a href="qmqttuserproperties">QMqttUserProperties</a>, <a href="qndefmessage">QNdefMessage</a>, <a href="qpolygon">QPolygon</a>, <a href="qpolygonf">QPolygonF</a>, <a href="qqueue">QQueue</a>, <a href="qsignalspy">QSignalSpy</a>, <a href="qstack">QStack</a>, <a href="qstringlist">QStringList</a>, <a href="qtesteventlist">QTestEventList</a>, <a href="qvector">QVector</a>, <a href="qvulkaninfovector">QVulkanInfoVector</a>, and <a href="qxmlstreamattributes">QXmlStreamAttributes</a></p> </td>
</tr>
</table> <ul> <li><a href="https://doc.qt.io/qt-6.2/qlist-members.html">List of all members, including inherited members</a></li> <li><a href="https://doc.qt.io/qt-6.2/qlist-obsolete.html">Deprecated members</a></li> </ul> <p><b>Note:</b> All functions in this class are <a href="17-qdoc-commands-thread#reentrant">reentrant</a>.</p> <h2 id="public-types">Public Types
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> class </td>
<td class="memItemRight bottomAlign"><b><a href="qlist-const-iterator">const_iterator</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> class </td>
<td class="memItemRight bottomAlign"><b><a href="qlist-iterator">iterator</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign"><b><a href="qlist#ConstIterator-typedef">ConstIterator</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign"><b><a href="qlist#Iterator-typedef">Iterator</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign"><b><a href="qlist#const_pointer-typedef">const_pointer</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign"><b><a href="qlist#const_reference-typedef">const_reference</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign"><b><a href="qlist#const_reverse_iterator-typedef">const_reverse_iterator</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign"><b><a href="qlist#difference_type-typedef">difference_type</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign"><b><a href="qlist#parameter_type-typedef">parameter_type</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign"><b><a href="qlist#pointer-typedef">pointer</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign"><b><a href="qlist#reference-typedef">reference</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign"><b><a href="qlist#reverse_iterator-typedef">reverse_iterator</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign"><b><a href="qlist#rvalue_ref-typedef">rvalue_ref</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign"><b><a href="qlist#size_type-typedef">size_type</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign"><b><a href="qlist#value_type-typedef">value_type</a></b></td>
</tr> </table> <h2 id="public-functions">Public Functions
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#QList-8">QList</a></b>(const QList&lt;T&gt; &amp;<i>other</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#QList-7">QList</a></b>(QList&lt;T&gt; &amp;&amp;<i>other</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#QList-5">QList</a></b>(InputIterator <i>first</i>, InputIterator <i>last</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#QList-4">QList</a></b>(std::initializer_list&lt;T&gt; <i>args</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#QList-3">QList</a></b>(qsizetype <i>size</i>, QList::parameter_type <i>value</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#QList-2">QList</a></b>(qsizetype <i>size</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#QList-1">QList</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; &amp;</td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#operator-eq-2">operator=</a></b>(QList&lt;T&gt; &amp;&amp;<i>other</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; &amp;</td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#operator-eq-1">operator=</a></b>(const QList&lt;T&gt; &amp;<i>other</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#dtor.QList">~QList</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#append">append</a></b>(QList::parameter_type <i>value</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#append-2">append</a></b>(QList::rvalue_ref <i>value</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#append-3">append</a></b>(const QList&lt;T&gt; &amp;<i>value</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#append-4">append</a></b>(QList&lt;T&gt; &amp;&amp;<i>value</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList::const_reference </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#at">at</a></b>(qsizetype <i>i</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList::reference </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#back">back</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList::const_reference </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#back-1">back</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList::iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#begin">begin</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList::const_iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#begin-1">begin</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> qsizetype </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#capacity">capacity</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList::const_iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#cbegin">cbegin</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList::const_iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#cend">cend</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#clear">clear</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList::const_iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#constBegin">constBegin</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList::const_pointer </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#constData">constData</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList::const_iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#constEnd">constEnd</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> const T &amp;</td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#constFirst">constFirst</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> const T &amp;</td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#constLast">constLast</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#contains">contains</a></b>(const AT &amp;<i>value</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> qsizetype </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#count">count</a></b>(const AT &amp;<i>value</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> qsizetype </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#count-1">count</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList::const_reverse_iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#crbegin">crbegin</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList::const_reverse_iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#crend">crend</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList::pointer </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#data">data</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList::const_pointer </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#data-1">data</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList::iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#emplace">emplace</a></b>(qsizetype <i>i</i>, Args &amp;&amp;... <i>args</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList::iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#emplace-1">emplace</a></b>(QList::const_iterator <i>before</i>, Args &amp;&amp;... <i>args</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList::reference </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#emplaceBack">emplaceBack</a></b>(Args &amp;&amp;... <i>args</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList::reference </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#emplace_back">emplace_back</a></b>(Args &amp;&amp;... <i>args</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#empty">empty</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList::iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#end">end</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList::const_iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#end-1">end</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#endsWith">endsWith</a></b>(QList::parameter_type <i>value</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList::iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#erase">erase</a></b>(QList::const_iterator <i>pos</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList::iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#erase-1">erase</a></b>(QList::const_iterator <i>begin</i>, QList::const_iterator <i>end</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; &amp;</td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#fill">fill</a></b>(QList::parameter_type <i>value</i>, qsizetype <i>size</i> = -1)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> T &amp;</td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#first">first</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> const T &amp;</td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#first-1">first</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#first-2">first</a></b>(qsizetype <i>n</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList::reference </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#front">front</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList::const_reference </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#front-1">front</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> qsizetype </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#indexOf">indexOf</a></b>(const AT &amp;<i>value</i>, qsizetype <i>from</i> = 0) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList::iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#insert">insert</a></b>(qsizetype <i>i</i>, QList::parameter_type <i>value</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList::iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#insert-1">insert</a></b>(qsizetype <i>i</i>, qsizetype <i>count</i>, QList::parameter_type <i>value</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList::iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#insert-2">insert</a></b>(QList::const_iterator <i>before</i>, QList::parameter_type <i>value</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList::iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#insert-3">insert</a></b>(QList::const_iterator <i>before</i>, qsizetype <i>count</i>, QList::parameter_type <i>value</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList::iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#insert-4">insert</a></b>(QList::const_iterator <i>before</i>, QList::rvalue_ref <i>value</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList::iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#insert-5">insert</a></b>(qsizetype <i>i</i>, QList::rvalue_ref <i>value</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#isEmpty">isEmpty</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> T &amp;</td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#last">last</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> const T &amp;</td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#last-1">last</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#last-2">last</a></b>(qsizetype <i>n</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> qsizetype </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#lastIndexOf">lastIndexOf</a></b>(const AT &amp;<i>value</i>, qsizetype <i>from</i> = -1) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> qsizetype </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#length">length</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#mid">mid</a></b>(qsizetype <i>pos</i>, qsizetype <i>length</i> = -1) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#move">move</a></b>(qsizetype <i>from</i>, qsizetype <i>to</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#pop_back">pop_back</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#pop_front">pop_front</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#prepend">prepend</a></b>(QList::rvalue_ref <i>value</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#prepend-1">prepend</a></b>(QList::parameter_type <i>value</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#push_back">push_back</a></b>(QList::parameter_type <i>value</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#push_back-1">push_back</a></b>(QList::rvalue_ref <i>value</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#push_front">push_front</a></b>(QList::rvalue_ref <i>value</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#push_front-1">push_front</a></b>(QList::parameter_type <i>value</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList::reverse_iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#rbegin">rbegin</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList::const_reverse_iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#rbegin-1">rbegin</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#remove">remove</a></b>(qsizetype <i>i</i>, qsizetype <i>n</i> = 1)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> qsizetype </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#removeAll">removeAll</a></b>(const AT &amp;<i>t</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#removeAt">removeAt</a></b>(qsizetype <i>i</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#removeFirst">removeFirst</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> qsizetype </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#removeIf">removeIf</a></b>(Predicate <i>pred</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#removeLast">removeLast</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#removeOne">removeOne</a></b>(const AT &amp;<i>t</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList::reverse_iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#rend">rend</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList::const_reverse_iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#rend-1">rend</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#replace">replace</a></b>(qsizetype <i>i</i>, QList::parameter_type <i>value</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#replace-1">replace</a></b>(qsizetype <i>i</i>, QList::rvalue_ref <i>value</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#reserve">reserve</a></b>(qsizetype <i>size</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#resize">resize</a></b>(qsizetype <i>size</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#shrink_to_fit">shrink_to_fit</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> qsizetype </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#size">size</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#sliced">sliced</a></b>(qsizetype <i>pos</i>, qsizetype <i>n</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#sliced-1">sliced</a></b>(qsizetype <i>pos</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#squeeze">squeeze</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#startsWith">startsWith</a></b>(QList::parameter_type <i>value</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#swap">swap</a></b>(QList&lt;T&gt; &amp;<i>other</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#swapItemsAt">swapItemsAt</a></b>(qsizetype <i>i</i>, qsizetype <i>j</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> T </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#takeAt">takeAt</a></b>(qsizetype <i>i</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList::value_type </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#takeFirst">takeFirst</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList::value_type </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#takeLast">takeLast</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> T </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#value">value</a></b>(qsizetype <i>i</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> T </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#value-1">value</a></b>(qsizetype <i>i</i>, QList::parameter_type <i>defaultValue</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#operator-not-eq">operator!=</a></b>(const QList&lt;T&gt; &amp;<i>other</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#operator-2b">operator+</a></b>(const QList&lt;T&gt; &amp;<i>other</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#operator-2b-1">operator+</a></b>(QList&lt;T&gt; &amp;&amp;<i>other</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; &amp;</td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#operator-2b-eq">operator+=</a></b>(const QList&lt;T&gt; &amp;<i>other</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; &amp;</td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#operator-2b-eq-1">operator+=</a></b>(QList&lt;T&gt; &amp;&amp;<i>other</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; &amp;</td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#operator-2b-eq-2">operator+=</a></b>(QList::parameter_type <i>value</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; &amp;</td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#operator-2b-eq-3">operator+=</a></b>(QList::rvalue_ref <i>value</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#operator-lt">operator&lt;</a></b>(const QList&lt;T&gt; &amp;<i>other</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; &amp;</td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#operator-lt-lt">operator&lt;&lt;</a></b>(QList::parameter_type <i>value</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; &amp;</td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#operator-lt-lt-1">operator&lt;&lt;</a></b>(const QList&lt;T&gt; &amp;<i>other</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; &amp;</td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#operator-lt-lt-2">operator&lt;&lt;</a></b>(QList&lt;T&gt; &amp;&amp;<i>other</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; &amp;</td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#operator-lt-lt-3">operator&lt;&lt;</a></b>(QList::rvalue_ref <i>value</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#operator-lt-eq">operator&lt;=</a></b>(const QList&lt;T&gt; &amp;<i>other</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; &amp;</td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#operator-eq">operator=</a></b>(std::initializer_list&lt;T&gt; <i>args</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#operator-eq-eq">operator==</a></b>(const QList&lt;T&gt; &amp;<i>other</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#operator-gt">operator&gt;</a></b>(const QList&lt;T&gt; &amp;<i>other</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#operator-gt-eq">operator&gt;=</a></b>(const QList&lt;T&gt; &amp;<i>other</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList::reference </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#operator-5b-5d">operator[]</a></b>(qsizetype <i>i</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList::const_reference </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#operator-5b-5d-1">operator[]</a></b>(qsizetype <i>i</i>) const</td>
</tr> </table> <h2 id="related-non-members">Related Non-Members
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> qsizetype </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#erase-2">erase</a></b>(QList&lt;T&gt; &amp;<i>list</i>, const AT &amp;<i>t</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> qsizetype </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#erase_if">erase_if</a></b>(QList&lt;T&gt; &amp;<i>list</i>, Predicate <i>pred</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> size_t </td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#qHash">qHash</a></b>(const QList&lt;T&gt; &amp;<i>key</i>, size_t <i>seed</i> = 0)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QDataStream &amp;</td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#operator-lt-lt-4">operator&lt;&lt;</a></b>(QDataStream &amp;<i>out</i>, const QList&lt;T&gt; &amp;<i>list</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QDataStream &amp;</td>
<td class="memItemRight bottomAlign">
<b><a href="qlist#operator-gt-gt">operator&gt;&gt;</a></b>(QDataStream &amp;<i>in</i>, QList&lt;T&gt; &amp;<i>list</i>)</td>
</tr> </table>   <h2 id="details">Detailed Description
</h2> <p>QList&lt;T&gt; is one of Qt's generic <a href="containers">container classes</a>. It stores its items in adjacent memory locations and provides fast index-based access. <a href="qvector">QVector</a>&lt;T&gt; used to be a different class in Qt 5, but is now a simple alias to QList.</p> <p>QList&lt;T&gt; and <a href="qvarlengtharray">QVarLengthArray</a>&lt;T&gt; provide similar APIs and functionality. They are often interchangeable, but there are performance consequences. Here is an overview of use cases:</p> <ul> <li>QList should be your default first choice.</li> <li>
<a href="qvarlengtharray">QVarLengthArray</a> provides an array that reserves space on the stack, but can dynamically grow onto the heap if required. It's good to use for short lived containers that are usually small.</li> <li>If you need a real linked list, which guarantees <a href="containers#algorithmic-complexity">constant time</a> insertions mid-list and uses iterators to items rather than indexes, use std::list.</li> </ul> <div class="admonition note"> <p><b>Note: </b>QList and <a href="qvarlengtharray">QVarLengthArray</a> both guarantee C-compatible array layout.</p> </div> <div class="admonition note"> <p><b>Note: </b>QList in Qt 5 did not always have a C-compatible array layout and we often recommended to use <a href="qvector">QVector</a> instead for more predictable performance. This is not the case in Qt 6 anymore, where both classes now share an implementation and can be used interchangeably.</p> </div> <p>Here's an example of a QList that stores integers and a QList that stores <a href="qstring">QString</a> values:</p> <pre data-language="cpp">QList&lt;int&gt; integerList;
QList&lt;QString&gt; stringList;</pre> <p>QList stores its items in an array of continuous memory. Typically, lists are created with an initial size. For example, the following code constructs a QList with 200 elements:</p> <pre data-language="cpp">QList&lt;QString&gt; list(200);</pre> <p>The elements are automatically initialized with a <a href="containers#default-constructed-value">default-constructed value</a>. If you want to initialize the list with a different value, pass that value as the second argument to the constructor:</p> <pre data-language="cpp">QList&lt;QString&gt; list(200, "Pass");</pre> <p>You can also call <a href="qlist#fill">fill</a>() at any time to fill the list with a value.</p> <p>QList uses 0-based indexes, just like C++ arrays. To access the item at a particular index position, you can use operator[](). On non-const lists, operator[]() returns a reference to the item that can be used on the left side of an assignment:</p> <pre data-language="cpp">if (list[0] == "Liz")
    list[0] = "Elizabeth";</pre> <p>For read-only access, an alternative syntax is to use <a href="qlist#at">at</a>():</p> <pre data-language="cpp">for (qsizetype i = 0; i &lt; list.size(); ++i) {
    if (list.at(i) == "Alfonso")
        cout &lt;&lt; "Found Alfonso at position " &lt;&lt; i &lt;&lt; Qt::endl;
}</pre> <p><a href="qlist#at">at</a>() can be faster than operator[](), because it never causes a <a href="implicit-sharing#deep-copy">deep copy</a> to occur.</p> <p>Another way to access the data stored in a QList is to call <a href="qlist#data">data</a>(). The function returns a pointer to the first item in the list. You can use the pointer to directly access and modify the elements stored in the list. The pointer is also useful if you need to pass a QList to a function that accepts a plain C++ array.</p> <p>If you want to find all occurrences of a particular value in a list, use <a href="qlist#indexOf">indexOf</a>() or <a href="qlist#lastIndexOf">lastIndexOf</a>(). The former searches forward starting from a given index position, the latter searches backward. Both return the index of the matching item if they found one; otherwise, they return -1. For example:</p> <pre data-language="cpp">qsizetype i = list.indexOf("Harumi");
if (i != -1)
    cout &lt;&lt; "First occurrence of Harumi is at position " &lt;&lt; i &lt;&lt; Qt::endl;</pre> <p>If you simply want to check whether a list contains a particular value, use <a href="qlist#contains">contains</a>(). If you want to find out how many times a particular value occurs in the list, use <a href="qlist#count-1">count</a>().</p> <p>QList provides these basic functions to add, move, and remove items: <a href="qlist#insert">insert</a>(), <a href="qlist#replace">replace</a>(), <a href="qlist#remove">remove</a>(), <a href="qlist#prepend">prepend</a>(), <a href="qlist#append">append</a>(). With the exception of <a href="qlist#append">append</a>(), <a href="qlist#prepend">prepend</a>() and <a href="qlist#replace">replace</a>(), these functions can be slow (<a href="containers#linear-time">linear time</a>) for large lists, because they require moving many items in the list by one position in memory. If you want a container class that provides fast insertion/removal in the middle, use std::list instead.</p> <p>Unlike plain C++ arrays, QLists can be resized at any time by calling <a href="qlist#resize">resize</a>(). If the new size is larger than the old size, QList might need to reallocate the whole list. QList tries to reduce the number of reallocations by preallocating up to twice as much memory as the actual data needs.</p> <p>If you're building a QList gradually and know in advance approximately how many elements it will contain, you can call <a href="qlist#reserve">reserve</a>(), asking QList to preallocate a certain amount of memory. You can also call <a href="qlist#capacity">capacity</a>() to find out how much memory the QList actually has allocated.</p> <p>Note that using non-const operators and functions can cause QList to do a deep copy of the data, due to <a href="implicit-sharing">implicit sharing</a>.</p> <p>QList's value type must be an <a href="containers#assignable-data-type">assignable data type</a>. This covers most data types that are commonly used, but the compiler won't let you, for example, store a <a href="qwidget">QWidget</a> as a value; instead, store a <a href="qwidget">QWidget</a> *. A few functions have additional requirements; for example, <a href="qlist#indexOf">indexOf</a>() and <a href="qlist#lastIndexOf">lastIndexOf</a>() expect the value type to support <code>operator==()</code>. These requirements are documented on a per-function basis.</p> <p>Like the other container classes, QList provides <a href="java-style-iterators#java-style-iterators">Java-style iterators</a> (<a href="qlistiterator">QListIterator</a> and <a href="qmutablelistiterator">QMutableListIterator</a>) and <a href="containers#stl-style-iterators">STL-style iterators</a> (<a href="qlist-const-iterator">QList::const_iterator</a> and <a href="qlist-iterator">QList::iterator</a>). In practice, iterators are handy when working with generic algorithms provided by <a href="qtalgorithms">Qt</a> and the C++ standard library. <a href="java-style-iterators#java-style-iterators">Java-style iterators</a> are provided for backwards compatibility, prefer <a href="containers#stl-style-iterators">STL-style iterators</a> when writing C++ code.</p> <div class="admonition note"> <p><b>Note: </b>Iterators over a QList, and references to individual elements within one, cannot be relied on to remain valid when any non-const method of the QList is called. Accessing such an iterator or reference after the call to a non-const method leads to undefined behavior. When stability for iterator-like functionality is required, you should use indexes instead of iterators as they are not tied to QList's internal state and thus do not get invalidated.</p> </div> <p>In addition to QList, Qt also provides <a href="qvarlengtharray">QVarLengthArray</a>, a very low-level class with little functionality that is optimized for speed.</p> <h4 id="more-information-on-using-qt-containers">More Information on Using Qt Containers
</h4> <p>For a detailed discussion comparing Qt containers with each other and with STL containers, see <a href="https://marcmutz.wordpress.com/effective-qt/containers/">Understand the Qt Containers</a>.</p> <h3 id="maximum-size-and-out-of-memory-conditions">Maximum size and out-of-memory conditions
</h3> <p>The maximum size of QList depends on the architecture. Most 64-bit systems can allocate more than 2 GB of memory, with a typical limit of 2^63 bytes. The actual value also depends on the overhead required for managing the data block. As a result, you can expect the maximum size of 2 GB minus overhead on 32-bit platforms, and 2^63 bytes minus overhead on 64-bit platforms. The number of elements that can be stored in a QList is this maximum size divided by the size of a stored element.</p> <p>When memory allocation fails, QList uses the <a href="qtglobal#Q_CHECK_PTR">Q_CHECK_PTR</a> macro, which throws a <code>std::bad_alloc</code> exception if the application is being compiled with exception support. If exceptions are disabled, then running out of memory is undefined behavior.</p> <p>Note that the operating system may impose further limits on applications holding a lot of allocated memory, especially large, contiguous blocks. Such considerations, the configuration of such behavior or any mitigation are outside the scope of the Qt API.</p>    <h2>Member Type Documentation</h2>  <h3 class="fn" id="ConstIterator-typedef">
<code>[alias] </code>QList::<span class="name">ConstIterator</span>
</h3> <p>Qt-style synonym for <a href="qlist-const-iterator">QList::const_iterator</a>.</p>   <h3 class="fn" id="Iterator-typedef">
<code>[alias] </code>QList::<span class="name">Iterator</span>
</h3> <p>Qt-style synonym for <a href="qlist-iterator">QList::iterator</a>.</p>   <h3 class="fn" id="const_pointer-typedef">
<code>[alias] </code>QList::<span class="name">const_pointer</span>
</h3> <p>Provided for STL compatibility.</p>   <h3 class="fn" id="const_reference-typedef">
<code>[alias] </code>QList::<span class="name">const_reference</span>
</h3> <p>Provided for STL compatibility.</p>   <h3 class="fn" id="const_reverse_iterator-typedef">
<code>[alias, since 5.6] </code>QList::<span class="name">const_reverse_iterator</span>
</h3> <p>The QList::const_reverse_iterator typedef provides an STL-style const reverse iterator for <a href="qlist">QList</a>.</p> <div class="admonition warning"> <p><b>Warning: </b>Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read <a href="containers#implicit-sharing-iterator-problem">Implicit sharing iterator problem</a>.</p> </div> <div class="admonition warning"> <p><b>Warning: </b>Iterators are invalidated when <a href="qlist">QList</a> is modified. Consider that all iterators are invalidated by default. Exceptions to this rule are explicitly documented.</p> </div> <p>This typedef was introduced in Qt 5.6.</p> <p><b>See also </b><a href="qlist#rbegin">QList::rbegin</a>(), <a href="qlist#rend">QList::rend</a>(), <a href="qlist#reverse_iterator-typedef">QList::reverse_iterator</a>, and <a href="qlist-const-iterator">QList::const_iterator</a>.</p>   <h3 class="fn" id="difference_type-typedef">
<code>[alias] </code>QList::<span class="name">difference_type</span>
</h3> <p>Provided for STL compatibility.</p>   <h3 class="fn" id="parameter_type-typedef">
<code>[alias] </code>QList::<span class="name">parameter_type</span>
</h3>   <h3 class="fn" id="pointer-typedef">
<code>[alias] </code>QList::<span class="name">pointer</span>
</h3> <p>Provided for STL compatibility.</p>   <h3 class="fn" id="reference-typedef">
<code>[alias] </code>QList::<span class="name">reference</span>
</h3> <p>Provided for STL compatibility.</p>   <h3 class="fn" id="reverse_iterator-typedef">
<code>[alias, since 5.6] </code>QList::<span class="name">reverse_iterator</span>
</h3> <p>The QList::reverse_iterator typedef provides an STL-style non-const reverse iterator for <a href="qlist">QList</a>.</p> <div class="admonition warning"> <p><b>Warning: </b>Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read <a href="containers#implicit-sharing-iterator-problem">Implicit sharing iterator problem</a>.</p> </div> <div class="admonition warning"> <p><b>Warning: </b>Iterators are invalidated when <a href="qlist">QList</a> is modified. Consider that all iterators are invalidated by default. Exceptions to this rule are explicitly documented.</p> </div> <p>This typedef was introduced in Qt 5.6.</p> <p><b>See also </b><a href="qlist#rbegin">QList::rbegin</a>(), <a href="qlist#rend">QList::rend</a>(), <a href="qlist#const_reverse_iterator-typedef">QList::const_reverse_iterator</a>, and <a href="qlist-iterator">QList::iterator</a>.</p>   <h3 class="fn" id="rvalue_ref-typedef">
<code>[alias] </code>QList::<span class="name">rvalue_ref</span>
</h3>   <h3 class="fn" id="size_type-typedef">
<code>[alias] </code>QList::<span class="name">size_type</span>
</h3> <p>Provided for STL compatibility.</p>   <h3 class="fn" id="value_type-typedef">
<code>[alias] </code>QList::<span class="name">value_type</span>
</h3> <p>Provided for STL compatibility.</p>    <h2>Member Function Documentation</h2>  <div class="fngroup"> <h3 class="fn fngroupitem" id="push_front-1">
<span class="type">void</span> QList::<span class="name">push_front</span>(<span class="type">QList::parameter_type</span> <i>value</i>)
</h3>
<h3 class="fn fngroupitem" id="push_front">
<span class="type">void</span> QList::<span class="name">push_front</span>(<span class="type">QList::rvalue_ref</span> <i>value</i>)
</h3>
</div> <p>This function is provided for STL compatibility. It is equivalent to prepend(<i>value</i>).</p>   <div class="fngroup"> <h3 class="fn fngroupitem" id="replace">
<span class="type">void</span> QList::<span class="name">replace</span>(<span class="type">qsizetype</span> <i>i</i>, <span class="type">QList::parameter_type</span> <i>value</i>)
</h3>
<h3 class="fn fngroupitem" id="replace-1">
<span class="type">void</span> QList::<span class="name">replace</span>(<span class="type">qsizetype</span> <i>i</i>, <span class="type">QList::rvalue_ref</span> <i>value</i>)
</h3>
</div> <p>Replaces the item at index position <i>i</i> with <i>value</i>.</p> <p><i>i</i> must be a valid index position in the list (i.e., 0 &lt;= <i>i</i> &lt; <a href="qlist#size">size</a>()).</p> <p><b>See also </b><a href="qlist#operator-5b-5d">operator[]</a>() and <a href="qlist#remove">remove</a>().</p>   <div class="fngroup"> <h3 class="fn fngroupitem" id="insert-2">
<span class="type"><a href="qlist-iterator">QList::iterator</a></span> QList::<span class="name">insert</span>(<span class="type"><a href="qlist-const-iterator">QList::const_iterator</a></span> <i>before</i>, <span class="type">QList::parameter_type</span> <i>value</i>)
</h3>
<h3 class="fn fngroupitem" id="insert-4">
<span class="type"><a href="qlist-iterator">QList::iterator</a></span> QList::<span class="name">insert</span>(<span class="type"><a href="qlist-const-iterator">QList::const_iterator</a></span> <i>before</i>, <span class="type">QList::rvalue_ref</span> <i>value</i>)
</h3>
</div> <p>This is an overloaded function.</p> <p>Inserts <i>value</i> in front of the item pointed to by the iterator <i>before</i>. Returns an iterator pointing at the inserted item.</p>   <div class="fngroup"> <h3 class="fn fngroupitem" id="insert">
<span class="type"><a href="qlist-iterator">QList::iterator</a></span> QList::<span class="name">insert</span>(<span class="type">qsizetype</span> <i>i</i>, <span class="type">QList::parameter_type</span> <i>value</i>)
</h3>
<h3 class="fn fngroupitem" id="insert-5">
<span class="type"><a href="qlist-iterator">QList::iterator</a></span> QList::<span class="name">insert</span>(<span class="type">qsizetype</span> <i>i</i>, <span class="type">QList::rvalue_ref</span> <i>value</i>)
</h3>
</div> <p>Inserts <i>value</i> at index position <i>i</i> in the list. If <i>i</i> is 0, the value is prepended to the list. If <i>i</i> is <a href="qlist#size">size</a>(), the value is appended to the list.</p> <p>Example:</p> <pre data-language="cpp">QList&lt;QString&gt; list;
list &lt;&lt; "alpha" &lt;&lt; "beta" &lt;&lt; "delta";
list.insert(2, "gamma");
// list: ["alpha", "beta", "gamma", "delta"]</pre> <p>For large lists, this operation can be slow (<a href="containers#linear-time">linear time</a>), because it requires moving all the items at indexes <i>i</i> and above by one position further in memory. If you want a container class that provides a fast <a href="qlist#insert">insert</a>() function, use std::list instead.</p> <p><b>See also </b><a href="qlist#append">append</a>(), <a href="qlist#prepend">prepend</a>(), and <a href="qlist#remove">remove</a>().</p>   <div class="fngroup"> <h3 class="fn fngroupitem" id="emplaceBack">template &lt;typename Args&gt; <span class="type">QList::reference</span> QList::<span class="name">emplaceBack</span>(<span class="type">Args</span> &amp;&amp;... <i>args</i>)
</h3>
<h3 class="fn fngroupitem" id="emplace_back">template &lt;typename Args&gt; <span class="type">QList::reference</span> QList::<span class="name">emplace_back</span>(<span class="type">Args</span> &amp;&amp;... <i>args</i>)
</h3>
</div> <p>Adds a new element to the end for the container. This new element is constructed in-place using <i>args</i> as the arguments for its construction.</p> <p>Returns a reference to the new element.</p> <p>Example:</p> <pre data-language="cpp">QList&lt;QString&gt; list{"one", "two"};
list.emplaceBack(3, 'a');
qDebug() &lt;&lt; list;
// list: ["one", "two", "aaa"]</pre> <p>It is also possible to access a newly created object by using returned reference:</p> <pre data-language="cpp">QList&lt;QString&gt; list;
auto &amp;ref = list.emplaceBack();
ref = "one";
// list: ["one"]</pre> <p>This is the same as list.emplace(list.<a href="qlist#size">size</a>(), <i>args</i>).</p> <p><b>See also </b><a href="qlist#emplace">emplace</a>.</p>   <div class="fngroup"> <h3 class="fn fngroupitem" id="prepend-1">
<span class="type">void</span> QList::<span class="name">prepend</span>(<span class="type">QList::parameter_type</span> <i>value</i>)
</h3>
<h3 class="fn fngroupitem" id="prepend">
<span class="type">void</span> QList::<span class="name">prepend</span>(<span class="type">QList::rvalue_ref</span> <i>value</i>)
</h3>
</div> <p>Inserts <i>value</i> at the beginning of the list.</p> <p>Example:</p> <pre data-language="cpp">QList&lt;QString&gt; list;
list.prepend("one");
list.prepend("two");
list.prepend("three");
// list: ["three", "two", "one"]</pre> <p>This is the same as list.insert(0, <i>value</i>).</p> <p>Normally this operation is relatively fast (amortized <a href="containers#constant-time">constant time</a>). <a href="qlist">QList</a> is able to allocate extra memory at the beginning of the list data and grow in that direction without reallocating or moving the data on each operation. However if you want a container class with a guarantee of <a href="containers#constant-time">constant time</a> prepend, use std::list instead, but prefer <a href="qlist">QList</a> otherwise.</p> <p><b>See also </b><a href="qlist#append">append</a>() and <a href="qlist#insert">insert</a>().</p>   <h3 class="fn" id="QList-8">
<code>[default] </code>QList::<span class="name">QList</span>(const <span class="type">QList</span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)
</h3> <p>Constructs a copy of <i>other</i>.</p> <p>This operation takes <a href="containers#algorithmic-complexity">constant time</a>, because QList is <a href="implicit-sharing">implicitly shared</a>. This makes returning a QList from a function very fast. If a shared instance is modified, it will be copied (copy-on-write), and that takes <a href="containers#algorithmic-complexity">linear time</a>.</p> <p><b>See also </b><a href="qlist#operator-eq">operator=</a>().</p>   <h3 class="fn" id="QList-7">
<code>[default, since 5.2] </code>QList::<span class="name">QList</span>(<span class="type">QList</span>&lt;<span class="type">T</span>&gt; &amp;&amp;<i>other</i>)
</h3> <p>Move-constructs a QList instance, making it point at the same object that <i>other</i> was pointing to.</p> <p>This function was introduced in Qt 5.2.</p>   <h3 class="fn" id="QList-5">
<code>[since 5.14] </code>template &lt;typename InputIterator&gt; QList::<span class="name">QList</span>(<span class="type">InputIterator</span> <i>first</i>, <span class="type">InputIterator</span> <i>last</i>)
</h3> <p>Constructs a list with the contents in the iterator range [<i>first</i>, <i>last</i>).</p> <p>The value type of <code>InputIterator</code> must be convertible to <code>T</code>.</p> <p>This function was introduced in Qt 5.14.</p>   <h3 class="fn" id="QList-4">QList::<span class="name">QList</span>(<span class="type">std::initializer_list</span>&lt;<span class="type">T</span>&gt; <i>args</i>)
</h3> <p>Constructs a list from the std::initializer_list given by <i>args</i>.</p>   <h3 class="fn" id="QList-3">QList::<span class="name">QList</span>(<span class="type">qsizetype</span> <i>size</i>, <span class="type">QList::parameter_type</span> <i>value</i>)
</h3> <p>Constructs a list with an initial size of <i>size</i> elements. Each element is initialized with <i>value</i>.</p> <p><b>See also </b><a href="qlist#resize">resize</a>() and <a href="qlist#fill">fill</a>().</p>   <h3 class="fn" id="QList-2">QList::<span class="name">QList</span>(<span class="type">qsizetype</span> <i>size</i>)
</h3> <p>Constructs a list with an initial size of <i>size</i> elements.</p> <p>The elements are initialized with a <a href="containers#default-constructed-value">default-constructed value</a>.</p> <p><b>See also </b><a href="qlist#resize">resize</a>().</p>   <h3 class="fn" id="QList-1">QList::<span class="name">QList</span>()
</h3> <p>Constructs an empty list.</p> <p><b>See also </b><a href="qlist#resize">resize</a>().</p>   <h3 class="fn" id="operator-eq-2">
<code>[default, since 5.2] </code><span class="type">QList</span>&lt;<span class="type">T</span>&gt; &amp;QList::<span class="name">operator=</span>(<span class="type">QList</span>&lt;<span class="type">T</span>&gt; &amp;&amp;<i>other</i>)
</h3> <p>Move-assigns <i>other</i> to this <a href="qlist">QList</a> instance.</p> <p>This function was introduced in Qt 5.2.</p>   <h3 class="fn" id="operator-eq-1">
<code>[default] </code><span class="type">QList</span>&lt;<span class="type">T</span>&gt; &amp;QList::<span class="name">operator=</span>(const <span class="type">QList</span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)
</h3> <p>Assigns <i>other</i> to this list and returns a reference to this list.</p>   <h3 class="fn" id="dtor.QList">
<code>[default] </code>QList::<span class="name">~QList</span>()
</h3> <p>Destroys the list.</p>   <h3 class="fn" id="append">
<span class="type">void</span> QList::<span class="name">append</span>(<span class="type">QList::parameter_type</span> <i>value</i>)
</h3> <p>Inserts <i>value</i> at the end of the list.</p> <p>Example:</p> <pre data-language="cpp">QList&lt;QString&gt; list;
list.append("one");
list.append("two");
QString three = "three";
list.append(three);
// list: ["one", "two", "three"]
// three: "three"</pre> <p>This is the same as calling resize(<a href="qlist#size">size</a>() + 1) and assigning <i>value</i> to the new last element in the list.</p> <p>This operation is relatively fast, because <a href="qlist">QList</a> typically allocates more memory than necessary, so it can grow without reallocating the entire list each time.</p> <p><b>See also </b><a href="qlist#operator-lt-lt">operator&lt;&lt;</a>(), <a href="qlist#prepend">prepend</a>(), and <a href="qlist#insert">insert</a>().</p>   <h3 class="fn" id="append-2">
<code>[since 5.6] </code><span class="type">void</span> QList::<span class="name">append</span>(<span class="type">QList::rvalue_ref</span> <i>value</i>)
</h3> <p>This is an overloaded function.</p> <p>Example:</p> <pre data-language="cpp">QList&lt;QString&gt; list;
list.append("one");
list.append("two");
QString three = "three";
list.append(std::move(three));
// list: ["one", "two", "three"]
// three: ""</pre> <p>This function was introduced in Qt 5.6.</p>   <h3 class="fn" id="append-3">
<code>[since 5.5] </code><span class="type">void</span> QList::<span class="name">append</span>(const <span class="type">QList</span>&lt;<span class="type">T</span>&gt; &amp;<i>value</i>)
</h3> <p>This is an overloaded function.</p> <p>Appends the items of the <i>value</i> list to this list.</p> <p>This function was introduced in Qt 5.5.</p> <p><b>See also </b><a href="qlist#operator-lt-lt">operator&lt;&lt;</a>() and <a href="qlist#operator-2b-eq">operator+=</a>().</p>   <h3 class="fn" id="append-4">
<code>[since 6.0] </code><span class="type">void</span> QList::<span class="name">append</span>(<span class="type">QList</span>&lt;<span class="type">T</span>&gt; &amp;&amp;<i>value</i>)
</h3> <p>This is an overloaded function.</p> <p>Moves the items of the <i>value</i> list to the end of this list.</p> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="qlist#operator-lt-lt">operator&lt;&lt;</a>() and <a href="qlist#operator-2b-eq">operator+=</a>().</p>   <h3 class="fn" id="at">
<span class="type">QList::const_reference</span> QList::<span class="name">at</span>(<span class="type">qsizetype</span> <i>i</i>) const
</h3> <p>Returns the item at index position <i>i</i> in the list.</p> <p><i>i</i> must be a valid index position in the list (i.e., 0 &lt;= <i>i</i> &lt; <a href="qlist#size">size</a>()).</p> <p><b>See also </b><a href="qlist#value">value</a>() and <a href="qlist#operator-5b-5d">operator[]</a>().</p>   <h3 class="fn" id="back">
<span class="type">QList::reference</span> QList::<span class="name">back</span>()
</h3> <p>This function is provided for STL compatibility. It is equivalent to <a href="qlist#last">last</a>().</p>   <h3 class="fn" id="back-1">
<span class="type">QList::const_reference</span> QList::<span class="name">back</span>() const
</h3> <p>This is an overloaded function.</p>   <h3 class="fn" id="begin">
<span class="type"><a href="qlist-iterator">QList::iterator</a></span> QList::<span class="name">begin</span>()
</h3> <p>Returns an <a href="containers#stl-style-iterators">STL-style iterator</a> pointing to the first item in the list.</p> <div class="admonition warning"> <p><b>Warning: </b>The returned iterator is invalidated on detachment or when the <a href="qlist">QList</a> is modified.</p> </div> <p><b>See also </b><a href="qlist#constBegin">constBegin</a>() and <a href="qlist#end">end</a>().</p>   <h3 class="fn" id="begin-1">
<span class="type"><a href="qlist-const-iterator">QList::const_iterator</a></span> QList::<span class="name">begin</span>() const
</h3> <p>This is an overloaded function.</p>   <h3 class="fn" id="capacity">
<span class="type">qsizetype</span> QList::<span class="name">capacity</span>() const
</h3> <p>Returns the maximum number of items that can be stored in the list without forcing a reallocation.</p> <p>The sole purpose of this function is to provide a means of fine tuning <a href="qlist">QList</a>'s memory usage. In general, you will rarely ever need to call this function. If you want to know how many items are in the list, call <a href="qlist#size">size</a>().</p> <div class="admonition note"> <p><b>Note: </b>a statically allocated list will report a capacity of 0, even if it's not empty.</p> </div> <div class="admonition warning"> <p><b>Warning: </b>The free space position in the allocated memory block is undefined. In other words, you should not assume that the free memory is always located at the end of the list. You can call <a href="qlist#reserve">reserve</a>() to ensure that there is enough space at the end.</p> </div> <p><b>See also </b><a href="qlist#reserve">reserve</a>() and <a href="qlist#squeeze">squeeze</a>().</p>   <h3 class="fn" id="cbegin">
<code>[since 5.0] </code><span class="type"><a href="qlist-const-iterator">QList::const_iterator</a></span> QList::<span class="name">cbegin</span>() const
</h3> <p>Returns a const <a href="containers#stl-style-iterators">STL-style iterator</a> pointing to the first item in the list.</p> <div class="admonition warning"> <p><b>Warning: </b>The returned iterator is invalidated on detachment or when the <a href="qlist">QList</a> is modified.</p> </div> <p>This function was introduced in Qt 5.0.</p> <p><b>See also </b><a href="qlist#begin">begin</a>() and <a href="qlist#cend">cend</a>().</p>   <h3 class="fn" id="cend">
<code>[since 5.0] </code><span class="type"><a href="qlist-const-iterator">QList::const_iterator</a></span> QList::<span class="name">cend</span>() const
</h3> <p>Returns a const <a href="containers#stl-style-iterators">STL-style iterator</a> pointing just after the last item in the list.</p> <div class="admonition warning"> <p><b>Warning: </b>The returned iterator is invalidated on detachment or when the <a href="qlist">QList</a> is modified.</p> </div> <p>This function was introduced in Qt 5.0.</p> <p><b>See also </b><a href="qlist#cbegin">cbegin</a>() and <a href="qlist#end">end</a>().</p>   <h3 class="fn" id="clear">
<span class="type">void</span> QList::<span class="name">clear</span>()
</h3> <p>Removes all the elements from the list.</p> <div class="admonition note"> <p><b>Note: </b>Until Qt 5.6, this also released the memory used by the list. From Qt 5.7, the capacity is preserved. To shed all capacity, swap with a default-constructed list:</p> </div> <pre data-language="cpp">QList&lt;T&gt; l ...;
QList&lt;T&gt;().swap(l);
Q_ASSERT(l.capacity() == 0);</pre> <p>or call <a href="qlist#squeeze">squeeze</a>().</p> <p><b>See also </b><a href="qlist#squeeze">squeeze</a>().</p>   <h3 class="fn" id="constBegin">
<span class="type"><a href="qlist-const-iterator">QList::const_iterator</a></span> QList::<span class="name">constBegin</span>() const
</h3> <p>Returns a const <a href="containers#stl-style-iterators">STL-style iterator</a> pointing to the first item in the list.</p> <div class="admonition warning"> <p><b>Warning: </b>The returned iterator is invalidated on detachment or when the <a href="qlist">QList</a> is modified.</p> </div> <p><b>See also </b><a href="qlist#begin">begin</a>() and <a href="qlist#constEnd">constEnd</a>().</p>   <h3 class="fn" id="constData">
<span class="type">QList::const_pointer</span> QList::<span class="name">constData</span>() const
</h3> <p>Returns a const pointer to the data stored in the list. The pointer can be used to access the items in the list.</p> <div class="admonition warning"> <p><b>Warning: </b>The pointer is invalidated on detachment or when the <a href="qlist">QList</a> is modified.</p> </div> <p>This function is mostly useful to pass a list to a function that accepts a plain C++ array.</p> <p><b>See also </b><a href="qlist#data">data</a>() and <a href="qlist#operator-5b-5d">operator[]</a>().</p>   <h3 class="fn" id="constEnd">
<span class="type"><a href="qlist-const-iterator">QList::const_iterator</a></span> QList::<span class="name">constEnd</span>() const
</h3> <p>Returns a const <a href="containers#stl-style-iterators">STL-style iterator</a> pointing just after the last item in the list.</p> <div class="admonition warning"> <p><b>Warning: </b>The returned iterator is invalidated on detachment or when the <a href="qlist">QList</a> is modified.</p> </div> <p><b>See also </b><a href="qlist#constBegin">constBegin</a>() and <a href="qlist#end">end</a>().</p>   <h3 class="fn" id="constFirst">
<code>[since 5.6] </code>const <span class="type">T</span> &amp;QList::<span class="name">constFirst</span>() const
</h3> <p>Returns a const reference to the first item in the list. This function assumes that the list isn't empty.</p> <p>This function was introduced in Qt 5.6.</p> <p><b>See also </b><a href="qlist#constLast">constLast</a>(), <a href="qlist#isEmpty">isEmpty</a>(), and <a href="qlist#first">first</a>().</p>   <h3 class="fn" id="constLast">
<code>[since 5.6] </code>const <span class="type">T</span> &amp;QList::<span class="name">constLast</span>() const
</h3> <p>Returns a const reference to the last item in the list. This function assumes that the list isn't empty.</p> <p>This function was introduced in Qt 5.6.</p> <p><b>See also </b><a href="qlist#constFirst">constFirst</a>(), <a href="qlist#isEmpty">isEmpty</a>(), and <a href="qlist#last">last</a>().</p>   <h3 class="fn" id="contains">template &lt;typename AT&gt; <span class="type">bool</span> QList::<span class="name">contains</span>(const <span class="type">AT</span> &amp;<i>value</i>) const
</h3> <p>Returns <code>true</code> if the list contains an occurrence of <i>value</i>; otherwise returns <code>false</code>.</p> <p>This function requires the value type to have an implementation of <code>operator==()</code>.</p> <p><b>See also </b><a href="qlist#indexOf">indexOf</a>() and <a href="qlist#count-1">count</a>().</p>   <h3 class="fn" id="count">template &lt;typename AT&gt; <span class="type">qsizetype</span> QList::<span class="name">count</span>(const <span class="type">AT</span> &amp;<i>value</i>) const
</h3> <p>Returns the number of occurrences of <i>value</i> in the list.</p> <p>This function requires the value type to have an implementation of <code>operator==()</code>.</p> <p><b>See also </b><a href="qlist#contains">contains</a>() and <a href="qlist#indexOf">indexOf</a>().</p>   <h3 class="fn" id="count-1">
<span class="type">qsizetype</span> QList::<span class="name">count</span>() const
</h3> <p>This is an overloaded function.</p> <p>Same as <a href="qlist#size">size</a>().</p>   <h3 class="fn" id="crbegin">
<code>[since 5.6] </code><span class="type">QList::const_reverse_iterator</span> QList::<span class="name">crbegin</span>() const
</h3> <p>Returns a const <a href="containers#stl-style-iterators">STL-style</a> reverse iterator pointing to the first item in the list, in reverse order.</p> <div class="admonition warning"> <p><b>Warning: </b>The returned iterator is invalidated on detachment or when the <a href="qlist">QList</a> is modified.</p> </div> <p>This function was introduced in Qt 5.6.</p> <p><b>See also </b><a href="qlist#begin">begin</a>(), <a href="qlist#rbegin">rbegin</a>(), and <a href="qlist#rend">rend</a>().</p>   <h3 class="fn" id="crend">
<code>[since 5.6] </code><span class="type">QList::const_reverse_iterator</span> QList::<span class="name">crend</span>() const
</h3> <p>Returns a const <a href="containers#stl-style-iterators">STL-style</a> reverse iterator pointing just after the last item in the list, in reverse order.</p> <div class="admonition warning"> <p><b>Warning: </b>The returned iterator is invalidated on detachment or when the <a href="qlist">QList</a> is modified.</p> </div> <p>This function was introduced in Qt 5.6.</p> <p><b>See also </b><a href="qlist#end">end</a>(), <a href="qlist#rend">rend</a>(), and <a href="qlist#rbegin">rbegin</a>().</p>   <h3 class="fn" id="data">
<span class="type">QList::pointer</span> QList::<span class="name">data</span>()
</h3> <p>Returns a pointer to the data stored in the list. The pointer can be used to access and modify the items in the list.</p> <p>Example:</p> <pre data-language="cpp">QList&lt;int&gt; list(10);
int *data = list.data();
for (qsizetype i = 0; i &lt; 10; ++i)
    data[i] = 2 * i;</pre> <div class="admonition warning"> <p><b>Warning: </b>The pointer is invalidated on detachment or when the <a href="qlist">QList</a> is modified.</p> </div> <p>This function is mostly useful to pass a list to a function that accepts a plain C++ array.</p> <p><b>See also </b><a href="qlist#constData">constData</a>() and <a href="qlist#operator-5b-5d">operator[]</a>().</p>   <h3 class="fn" id="data-1">
<span class="type">QList::const_pointer</span> QList::<span class="name">data</span>() const
</h3> <p>This is an overloaded function.</p>   <h3 class="fn" id="emplace">template &lt;typename Args&gt; <span class="type"><a href="qlist-iterator">QList::iterator</a></span> QList::<span class="name">emplace</span>(<span class="type">qsizetype</span> <i>i</i>, <span class="type">Args</span> &amp;&amp;... <i>args</i>)
</h3> <p>Extends the container by inserting a new element at position <i>i</i>. This new element is constructed in-place using <i>args</i> as the arguments for its construction.</p> <p>Returns an iterator to the new element.</p> <p>Example:</p> <pre data-language="cpp">QList&lt;QString&gt; list{"a", "ccc"};
list.emplace(1, 2, 'b');
// list: ["a", "bb", "ccc"]</pre> <div class="admonition note"> <p><b>Note: </b>It is guaranteed that the element will be created in place at the beginning, but after that it might be copied or moved to the right position.</p> </div> <p><b>See also </b><a href="qlist#emplaceBack">emplaceBack</a>.</p>   <h3 class="fn" id="emplace-1">template &lt;typename Args&gt; <span class="type"><a href="qlist-iterator">QList::iterator</a></span> QList::<span class="name">emplace</span>(<span class="type"><a href="qlist-const-iterator">QList::const_iterator</a></span> <i>before</i>, <span class="type">Args</span> &amp;&amp;... <i>args</i>)
</h3> <p>This is an overloaded function.</p> <p>Creates a new element in front of the item pointed to by the iterator <i>before</i>. This new element is constructed in-place using <i>args</i> as the arguments for its construction.</p> <p>Returns an iterator to the new element.</p>   <h3 class="fn" id="empty">
<span class="type">bool</span> QList::<span class="name">empty</span>() const
</h3> <p>This function is provided for STL compatibility. It is equivalent to <a href="qlist#isEmpty">isEmpty</a>(), returning <code>true</code> if the list is empty; otherwise returns <code>false</code>.</p>   <h3 class="fn" id="end">
<span class="type"><a href="qlist-iterator">QList::iterator</a></span> QList::<span class="name">end</span>()
</h3> <p>Returns an <a href="containers#stl-style-iterators">STL-style iterator</a> pointing just after the last item in the list.</p> <div class="admonition warning"> <p><b>Warning: </b>The returned iterator is invalidated on detachment or when the <a href="qlist">QList</a> is modified.</p> </div> <p><b>See also </b><a href="qlist#begin">begin</a>() and <a href="qlist#constEnd">constEnd</a>().</p>   <h3 class="fn" id="end-1">
<span class="type"><a href="qlist-const-iterator">QList::const_iterator</a></span> QList::<span class="name">end</span>() const
</h3> <p>This is an overloaded function.</p>   <h3 class="fn" id="endsWith">
<span class="type">bool</span> QList::<span class="name">endsWith</span>(<span class="type">QList::parameter_type</span> <i>value</i>) const
</h3> <p>Returns <code>true</code> if this list is not empty and its last item is equal to <i>value</i>; otherwise returns <code>false</code>.</p> <p><b>See also </b><a href="qlist#isEmpty">isEmpty</a>() and <a href="qlist#last">last</a>().</p>   <h3 class="fn" id="erase">
<span class="type"><a href="qlist-iterator">QList::iterator</a></span> QList::<span class="name">erase</span>(<span class="type"><a href="qlist-const-iterator">QList::const_iterator</a></span> <i>pos</i>)
</h3> <p>Removes the item pointed to by the iterator <i>pos</i> from the list, and returns an iterator to the next item in the list (which may be <a href="qlist#end">end</a>()).</p> <p>Element removal will preserve the list's capacity and not reduce the amount of allocated memory. To shed extra capacity and free as much memory as possible, call <a href="qlist#squeeze">squeeze</a>().</p> <div class="admonition note"> <p><b>Note: </b>When <a href="qlist">QList</a> is not <a href="implicit-sharing">implicitly shared</a>, this function only invalidates iterators at or after the specified position.</p> </div> <p><b>See also </b><a href="qlist#insert">insert</a>() and <a href="qlist#remove">remove</a>().</p>   <h3 class="fn" id="erase-1">
<span class="type"><a href="qlist-iterator">QList::iterator</a></span> QList::<span class="name">erase</span>(<span class="type"><a href="qlist-const-iterator">QList::const_iterator</a></span> <i>begin</i>, <span class="type"><a href="qlist-const-iterator">QList::const_iterator</a></span> <i>end</i>)
</h3> <p>This is an overloaded function.</p> <p>Removes all the items from <i>begin</i> up to (but not including) <i>end</i>. Returns an iterator to the same item that <i>end</i> referred to before the call.</p> <p>Element removal will preserve the list's capacity and not reduce the amount of allocated memory. To shed extra capacity and free as much memory as possible, call <a href="qlist#squeeze">squeeze</a>().</p> <div class="admonition note"> <p><b>Note: </b>When <a href="qlist">QList</a> is not <a href="implicit-sharing">implicitly shared</a>, this function only invalidates iterators at or after the specified position.</p> </div>   <h3 class="fn" id="fill">
<span class="type">QList</span>&lt;<span class="type">T</span>&gt; &amp;QList::<span class="name">fill</span>(<span class="type">QList::parameter_type</span> <i>value</i>, <span class="type">qsizetype</span> <i>size</i> = -1)
</h3> <p>Assigns <i>value</i> to all items in the list. If <i>size</i> is different from -1 (the default), the list is resized to <i>size</i> beforehand.</p> <p>Example:</p> <pre data-language="cpp">QList&lt;QString&gt; list(3);
list.fill("Yes");
// list: ["Yes", "Yes", "Yes"]

list.fill("oh", 5);
// list: ["oh", "oh", "oh", "oh", "oh"]</pre> <p><b>See also </b><a href="qlist#resize">resize</a>().</p>   <h3 class="fn" id="first">
<span class="type">T</span> &amp;QList::<span class="name">first</span>()
</h3> <p>Returns a reference to the first item in the list. This function assumes that the list isn't empty.</p> <p><b>See also </b><a href="qlist#last">last</a>(), <a href="qlist#isEmpty">isEmpty</a>(), and <a href="qlist#constFirst">constFirst</a>().</p>   <h3 class="fn" id="first-1">const <span class="type">T</span> &amp;QList::<span class="name">first</span>() const
</h3> <p>This is an overloaded function.</p>   <h3 class="fn" id="first-2">
<code>[since 6.0] </code><span class="type">QList</span>&lt;<span class="type">T</span>&gt; QList::<span class="name">first</span>(<span class="type">qsizetype</span> <i>n</i>) const
</h3> <p>Returns a sub-list that contains the first <i>n</i> elements of this list.</p> <div class="admonition note"> <p><b>Note: </b>The behavior is undefined when <i>n</i> &lt; 0 or <i>n</i> &gt; <a href="qlist#size">size</a>().</p> </div> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="qlist#last">last</a>() and <a href="qlist#sliced">sliced</a>().</p>   <h3 class="fn" id="front">
<span class="type">QList::reference</span> QList::<span class="name">front</span>()
</h3> <p>This function is provided for STL compatibility. It is equivalent to <a href="qlist#first">first</a>().</p>   <h3 class="fn" id="front-1">
<span class="type">QList::const_reference</span> QList::<span class="name">front</span>() const
</h3> <p>This is an overloaded function.</p>   <h3 class="fn" id="indexOf">template &lt;typename AT&gt; <span class="type">qsizetype</span> QList::<span class="name">indexOf</span>(const <span class="type">AT</span> &amp;<i>value</i>, <span class="type">qsizetype</span> <i>from</i> = 0) const
</h3> <p>Returns the index position of the first occurrence of <i>value</i> in the list, searching forward from index position <i>from</i>. Returns -1 if no item matched.</p> <p>Example:</p> <pre data-language="cpp">QList&lt;QString&gt; list;
list &lt;&lt; "A" &lt;&lt; "B" &lt;&lt; "C" &lt;&lt; "B" &lt;&lt; "A";
list.indexOf("B");            // returns 1
list.indexOf("B", 1);         // returns 1
list.indexOf("B", 2);         // returns 3
list.indexOf("X");            // returns -1</pre> <p>This function requires the value type to have an implementation of <code>operator==()</code>.</p> <p><b>See also </b><a href="qlist#lastIndexOf">lastIndexOf</a>() and <a href="qlist#contains">contains</a>().</p>   <h3 class="fn" id="insert-1">
<span class="type"><a href="qlist-iterator">QList::iterator</a></span> QList::<span class="name">insert</span>(<span class="type">qsizetype</span> <i>i</i>, <span class="type">qsizetype</span> <i>count</i>, <span class="type">QList::parameter_type</span> <i>value</i>)
</h3> <p>This is an overloaded function.</p> <p>Inserts <i>count</i> copies of <i>value</i> at index position <i>i</i> in the list.</p> <p>Example:</p> <pre data-language="cpp">QList&lt;double&gt; list;
list &lt;&lt; 2.718 &lt;&lt; 1.442 &lt;&lt; 0.4342;
list.insert(1, 3, 9.9);
// list: [2.718, 9.9, 9.9, 9.9, 1.442, 0.4342]</pre>   <h3 class="fn" id="insert-3">
<span class="type"><a href="qlist-iterator">QList::iterator</a></span> QList::<span class="name">insert</span>(<span class="type"><a href="qlist-const-iterator">QList::const_iterator</a></span> <i>before</i>, <span class="type">qsizetype</span> <i>count</i>, <span class="type">QList::parameter_type</span> <i>value</i>)
</h3> <p>Inserts <i>count</i> copies of <i>value</i> in front of the item pointed to by the iterator <i>before</i>. Returns an iterator pointing at the first of the inserted items.</p>   <h3 class="fn" id="isEmpty">
<span class="type">bool</span> QList::<span class="name">isEmpty</span>() const
</h3> <p>Returns <code>true</code> if the list has size 0; otherwise returns <code>false</code>.</p> <p><b>See also </b><a href="qlist#size">size</a>() and <a href="qlist#resize">resize</a>().</p>   <h3 class="fn" id="last">
<span class="type">T</span> &amp;QList::<span class="name">last</span>()
</h3> <p>Returns a reference to the last item in the list. This function assumes that the list isn't empty.</p> <p><b>See also </b><a href="qlist#first">first</a>(), <a href="qlist#isEmpty">isEmpty</a>(), and <a href="qlist#constLast">constLast</a>().</p>   <h3 class="fn" id="last-1">const <span class="type">T</span> &amp;QList::<span class="name">last</span>() const
</h3> <p>This is an overloaded function.</p>   <h3 class="fn" id="last-2">
<code>[since 6.0] </code><span class="type">QList</span>&lt;<span class="type">T</span>&gt; QList::<span class="name">last</span>(<span class="type">qsizetype</span> <i>n</i>) const
</h3> <p>Returns a sub-list that contains the last <i>n</i> elements of this list.</p> <div class="admonition note"> <p><b>Note: </b>The behavior is undefined when <i>n</i> &lt; 0 or <i>n</i> &gt; <a href="qlist#size">size</a>().</p> </div> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="qlist#first">first</a>() and <a href="qlist#sliced">sliced</a>().</p>   <h3 class="fn" id="lastIndexOf">template &lt;typename AT&gt; <span class="type">qsizetype</span> QList::<span class="name">lastIndexOf</span>(const <span class="type">AT</span> &amp;<i>value</i>, <span class="type">qsizetype</span> <i>from</i> = -1) const
</h3> <p>Returns the index position of the last occurrence of the value <i>value</i> in the list, searching backward from index position <i>from</i>. If <i>from</i> is -1 (the default), the search starts at the last item. Returns -1 if no item matched.</p> <p>Example:</p> <pre data-language="cpp">QList&lt;QString&gt; list;
list &lt;&lt; "A" &lt;&lt; "B" &lt;&lt; "C" &lt;&lt; "B" &lt;&lt; "A";
list.lastIndexOf("B");        // returns 3
list.lastIndexOf("B", 3);     // returns 3
list.lastIndexOf("B", 2);     // returns 1
list.lastIndexOf("X");        // returns -1</pre> <p>This function requires the value type to have an implementation of <code>operator==()</code>.</p> <p><b>See also </b><a href="qlist#indexOf">indexOf</a>().</p>   <h3 class="fn" id="length">
<code>[since 5.2] </code><span class="type">qsizetype</span> QList::<span class="name">length</span>() const
</h3> <p>Same as <a href="qlist#size">size</a>() and <a href="qlist#count-1">count</a>().</p> <p>This function was introduced in Qt 5.2.</p> <p><b>See also </b><a href="qlist#size">size</a>() and <a href="qlist#count-1">count</a>().</p>   <h3 class="fn" id="mid">
<span class="type">QList</span>&lt;<span class="type">T</span>&gt; QList::<span class="name">mid</span>(<span class="type">qsizetype</span> <i>pos</i>, <span class="type">qsizetype</span> <i>length</i> = -1) const
</h3> <p>Returns a sub-list which contains elements from this list, starting at position <i>pos</i>. If <i>length</i> is -1 (the default), all elements after <i>pos</i> are included; otherwise <i>length</i> elements (or all remaining elements if there are less than <i>length</i> elements) are included.</p>   <h3 class="fn" id="move">
<code>[since 5.6] </code><span class="type">void</span> QList::<span class="name">move</span>(<span class="type">qsizetype</span> <i>from</i>, <span class="type">qsizetype</span> <i>to</i>)
</h3> <p>Moves the item at index position <i>from</i> to index position <i>to</i>.</p> <p>This function was introduced in Qt 5.6.</p>   <h3 class="fn" id="pop_back">
<span class="type">void</span> QList::<span class="name">pop_back</span>()
</h3> <p>This function is provided for STL compatibility. It is equivalent to <a href="qlist#removeLast">removeLast</a>().</p>   <h3 class="fn" id="pop_front">
<span class="type">void</span> QList::<span class="name">pop_front</span>()
</h3> <p>This function is provided for STL compatibility. It is equivalent to <a href="qlist#removeFirst">removeFirst</a>().</p>   <h3 class="fn" id="push_back">
<span class="type">void</span> QList::<span class="name">push_back</span>(<span class="type">QList::parameter_type</span> <i>value</i>)
</h3> <p>This function is provided for STL compatibility. It is equivalent to append(<i>value</i>).</p>   <h3 class="fn" id="push_back-1">
<code>[since 5.6] </code><span class="type">void</span> QList::<span class="name">push_back</span>(<span class="type">QList::rvalue_ref</span> <i>value</i>)
</h3> <p>This is an overloaded function.</p> <p>This function was introduced in Qt 5.6.</p>   <h3 class="fn" id="rbegin">
<code>[since 5.6] </code><span class="type">QList::reverse_iterator</span> QList::<span class="name">rbegin</span>()
</h3> <p>Returns a <a href="containers#stl-style-iterators">STL-style</a> reverse iterator pointing to the first item in the list, in reverse order.</p> <div class="admonition warning"> <p><b>Warning: </b>The returned iterator is invalidated on detachment or when the <a href="qlist">QList</a> is modified.</p> </div> <p>This function was introduced in Qt 5.6.</p> <p><b>See also </b><a href="qlist#begin">begin</a>(), <a href="qlist#crbegin">crbegin</a>(), and <a href="qlist#rend">rend</a>().</p>   <h3 class="fn" id="rbegin-1">
<code>[since 5.6] </code><span class="type">QList::const_reverse_iterator</span> QList::<span class="name">rbegin</span>() const
</h3> <p>This is an overloaded function.</p> <p>This function was introduced in Qt 5.6.</p>   <h3 class="fn" id="remove">
<span class="type">void</span> QList::<span class="name">remove</span>(<span class="type">qsizetype</span> <i>i</i>, <span class="type">qsizetype</span> <i>n</i> = 1)
</h3> <p>Removes <i>n</i> elements from the list, starting at index position <i>i</i>.</p> <p>Element removal will preserve the list's capacity and not reduce the amount of allocated memory. To shed extra capacity and free as much memory as possible, call <a href="qlist#squeeze">squeeze</a>().</p> <div class="admonition note"> <p><b>Note: </b>When <a href="qlist">QList</a> is not <a href="implicit-sharing">implicitly shared</a>, this function only invalidates iterators at or after the specified position.</p> </div> <p><b>See also </b><a href="qlist#insert">insert</a>(), <a href="qlist#replace">replace</a>(), and <a href="qlist#fill">fill</a>().</p>   <h3 class="fn" id="removeAll">
<code>[since 5.4] </code>template &lt;typename AT&gt; <span class="type">qsizetype</span> QList::<span class="name">removeAll</span>(const <span class="type">AT</span> &amp;<i>t</i>)
</h3> <p>Removes all elements that compare equal to <i>t</i> from the list. Returns the number of elements removed, if any.</p> <p>Element removal will preserve the list's capacity and not reduce the amount of allocated memory. To shed extra capacity and free as much memory as possible, call <a href="qlist#squeeze">squeeze</a>().</p> <p>This function was introduced in Qt 5.4.</p> <p><b>See also </b><a href="qlist#removeOne">removeOne</a>().</p>   <h3 class="fn" id="removeAt">
<code>[since 5.2] </code><span class="type">void</span> QList::<span class="name">removeAt</span>(<span class="type">qsizetype</span> <i>i</i>)
</h3> <p>Removes the element at index position <i>i</i>. Equivalent to</p> <pre data-language="cpp">remove(i);</pre> <p>Element removal will preserve the list's capacity and not reduce the amount of allocated memory. To shed extra capacity and free as much memory as possible, call <a href="qlist#squeeze">squeeze</a>().</p> <div class="admonition note"> <p><b>Note: </b>When <a href="qlist">QList</a> is not <a href="implicit-sharing">implicitly shared</a>, this function only invalidates iterators at or after the specified position.</p> </div> <p>This function was introduced in Qt 5.2.</p> <p><b>See also </b><a href="qlist#remove">remove</a>().</p>   <h3 class="fn" id="removeFirst">
<code>[since 5.1] </code><span class="type">void</span> QList::<span class="name">removeFirst</span>()
</h3> <p>Removes the first item in the list. Calling this function is equivalent to calling remove(0). The list must not be empty. If the list can be empty, call <a href="qlist#isEmpty">isEmpty</a>() before calling this function.</p> <p>Element removal will preserve the list's capacity and not reduce the amount of allocated memory. To shed extra capacity and free as much memory as possible, call <a href="qlist#squeeze">squeeze</a>().</p> <p>This function was introduced in Qt 5.1.</p> <p><b>See also </b><a href="qlist#remove">remove</a>(), <a href="qlist#takeFirst">takeFirst</a>(), and <a href="qlist#isEmpty">isEmpty</a>().</p>   <h3 class="fn" id="removeIf">
<code>[since 6.1] </code>template &lt;typename Predicate&gt; <span class="type">qsizetype</span> QList::<span class="name">removeIf</span>(<span class="type">Predicate</span> <i>pred</i>)
</h3> <p>Removes all elements for which the predicate <i>pred</i> returns true from the list. Returns the number of elements removed, if any.</p> <p>This function was introduced in Qt 6.1.</p> <p><b>See also </b><a href="qlist#removeAll">removeAll</a>().</p>   <h3 class="fn" id="removeLast">
<code>[since 5.1] </code><span class="type">void</span> QList::<span class="name">removeLast</span>()
</h3> <p>Removes the last item in the list. Calling this function is equivalent to calling remove(<a href="qlist#size">size</a>() - 1). The list must not be empty. If the list can be empty, call <a href="qlist#isEmpty">isEmpty</a>() before calling this function.</p> <p>Element removal will preserve the list's capacity and not reduce the amount of allocated memory. To shed extra capacity and free as much memory as possible, call <a href="qlist#squeeze">squeeze</a>().</p> <p>This function was introduced in Qt 5.1.</p> <p><b>See also </b><a href="qlist#remove">remove</a>(), <a href="qlist#takeLast">takeLast</a>(), <a href="qlist#removeFirst">removeFirst</a>(), and <a href="qlist#isEmpty">isEmpty</a>().</p>   <h3 class="fn" id="removeOne">
<code>[since 5.4] </code>template &lt;typename AT&gt; <span class="type">bool</span> QList::<span class="name">removeOne</span>(const <span class="type">AT</span> &amp;<i>t</i>)
</h3> <p>Removes the first element that compares equal to <i>t</i> from the list. Returns whether an element was, in fact, removed.</p> <p>Element removal will preserve the list's capacity and not reduce the amount of allocated memory. To shed extra capacity and free as much memory as possible, call <a href="qlist#squeeze">squeeze</a>().</p> <p>This function was introduced in Qt 5.4.</p> <p><b>See also </b><a href="qlist#removeAll">removeAll</a>().</p>   <h3 class="fn" id="rend">
<code>[since 5.6] </code><span class="type">QList::reverse_iterator</span> QList::<span class="name">rend</span>()
</h3> <p>Returns a <a href="containers#stl-style-iterators">STL-style</a> reverse iterator pointing just after the last item in the list, in reverse order.</p> <div class="admonition warning"> <p><b>Warning: </b>The returned iterator is invalidated on detachment or when the <a href="qlist">QList</a> is modified.</p> </div> <p>This function was introduced in Qt 5.6.</p> <p><b>See also </b><a href="qlist#end">end</a>(), <a href="qlist#crend">crend</a>(), and <a href="qlist#rbegin">rbegin</a>().</p>   <h3 class="fn" id="rend-1">
<code>[since 5.6] </code><span class="type">QList::const_reverse_iterator</span> QList::<span class="name">rend</span>() const
</h3> <p>This is an overloaded function.</p> <p>This function was introduced in Qt 5.6.</p>   <h3 class="fn" id="reserve">
<span class="type">void</span> QList::<span class="name">reserve</span>(<span class="type">qsizetype</span> <i>size</i>)
</h3> <p>Attempts to allocate memory for at least <i>size</i> elements.</p> <p>If you know in advance how large the list will be, you should call this function to prevent reallocations and memory fragmentation. If you resize the list often, you are also likely to get better performance.</p> <p>If in doubt about how much space shall be needed, it is usually better to use an upper bound as <i>size</i>, or a high estimate of the most likely size, if a strict upper bound would be much bigger than this. If <i>size</i> is an underestimate, the list will grow as needed once the reserved size is exceeded, which may lead to a larger allocation than your best overestimate would have and will slow the operation that triggers it.</p> <div class="admonition warning"> <p><b>Warning: </b>reserve() reserves memory but does not change the size of the list. Accessing data beyond the current end of the list is undefined behavior. If you need to access memory beyond the current end of the list, use <a href="qlist#resize">resize</a>().</p> </div> <p><b>See also </b><a href="qlist#squeeze">squeeze</a>(), <a href="qlist#capacity">capacity</a>(), and <a href="qlist#resize">resize</a>().</p>   <h3 class="fn" id="resize">
<span class="type">void</span> QList::<span class="name">resize</span>(<span class="type">qsizetype</span> <i>size</i>)
</h3> <p>Sets the size of the list to <i>size</i>. If <i>size</i> is greater than the current size, elements are added to the end; the new elements are initialized with a <a href="containers#default-constructed-value">default-constructed value</a>. If <i>size</i> is less than the current size, elements are removed from the end.</p> <p>Since Qt 5.6, resize() doesn't shrink the capacity anymore. To shed excess capacity, use <a href="qlist#squeeze">squeeze</a>().</p> <p><b>See also </b><a href="qlist#size">size</a>().</p>   <h3 class="fn" id="shrink_to_fit">
<code>[since 5.10] </code><span class="type">void</span> QList::<span class="name">shrink_to_fit</span>()
</h3> <p>This function is provided for STL compatibility. It is equivalent to <a href="qlist#squeeze">squeeze</a>().</p> <p>This function was introduced in Qt 5.10.</p>   <h3 class="fn" id="size">
<span class="type">qsizetype</span> QList::<span class="name">size</span>() const
</h3> <p>Returns the number of items in the list.</p> <p><b>See also </b><a href="qlist#isEmpty">isEmpty</a>() and <a href="qlist#resize">resize</a>().</p>   <h3 class="fn" id="sliced">
<code>[since 6.0] </code><span class="type">QList</span>&lt;<span class="type">T</span>&gt; QList::<span class="name">sliced</span>(<span class="type">qsizetype</span> <i>pos</i>, <span class="type">qsizetype</span> <i>n</i>) const
</h3> <p>Returns a sub-list that contains <i>n</i> elements of this list, starting at position <i>pos</i>.</p> <div class="admonition note"> <p><b>Note: </b>The behavior is undefined when <i>pos</i> &lt; 0, <i>n</i> &lt; 0, or <i>pos</i> + <i>n</i> &gt; <a href="qlist#size">size</a>().</p> </div> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="qlist#first">first</a>() and <a href="qlist#last">last</a>().</p>   <h3 class="fn" id="sliced-1">
<code>[since 6.0] </code><span class="type">QList</span>&lt;<span class="type">T</span>&gt; QList::<span class="name">sliced</span>(<span class="type">qsizetype</span> <i>pos</i>) const
</h3> <p>This is an overloaded function.</p> <p>Returns a sub-list that contains the elements of this list starting at position <i>pos</i> and extending to its end.</p> <div class="admonition note"> <p><b>Note: </b>The behavior is undefined when <i>pos</i> &lt; 0 or <i>pos</i> &gt; <a href="qlist#size">size</a>().</p> </div> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="qlist#first">first</a>() and <a href="qlist#last">last</a>().</p>   <h3 class="fn" id="squeeze">
<span class="type">void</span> QList::<span class="name">squeeze</span>()
</h3> <p>Releases any memory not required to store the items.</p> <p>The sole purpose of this function is to provide a means of fine tuning <a href="qlist">QList</a>'s memory usage. In general, you will rarely ever need to call this function.</p> <p><b>See also </b><a href="qlist#reserve">reserve</a>() and <a href="qlist#capacity">capacity</a>().</p>   <h3 class="fn" id="startsWith">
<span class="type">bool</span> QList::<span class="name">startsWith</span>(<span class="type">QList::parameter_type</span> <i>value</i>) const
</h3> <p>Returns <code>true</code> if this list is not empty and its first item is equal to <i>value</i>; otherwise returns <code>false</code>.</p> <p><b>See also </b><a href="qlist#isEmpty">isEmpty</a>() and <a href="qlist#first">first</a>().</p>   <h3 class="fn" id="swap">
<span class="type">void</span> QList::<span class="name">swap</span>(<span class="type">QList</span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)
</h3> <p>Swaps list <i>other</i> with this list. This operation is very fast and never fails.</p>   <h3 class="fn" id="swapItemsAt">
<span class="type">void</span> QList::<span class="name">swapItemsAt</span>(<span class="type">qsizetype</span> <i>i</i>, <span class="type">qsizetype</span> <i>j</i>)
</h3> <p>Exchange the item at index position <i>i</i> with the item at index position <i>j</i>. This function assumes that both <i>i</i> and <i>j</i> are at least 0 but less than <a href="qlist#size">size</a>(). To avoid failure, test that both <i>i</i> and <i>j</i> are at least 0 and less than <a href="qlist#size">size</a>().</p>   <h3 class="fn" id="takeAt">
<code>[since 5.2] </code><span class="type">T</span> QList::<span class="name">takeAt</span>(<span class="type">qsizetype</span> <i>i</i>)
</h3> <p>Removes the element at index position <i>i</i> and returns it.</p> <p>Equivalent to</p> <pre data-language="cpp">T t = at(i);
remove(i);
return t;</pre> <div class="admonition note"> <p><b>Note: </b>When <a href="qlist">QList</a> is not <a href="implicit-sharing">implicitly shared</a>, this function only invalidates iterators at or after the specified position.</p> </div> <p>This function was introduced in Qt 5.2.</p> <p><b>See also </b><a href="qlist#takeFirst">takeFirst</a>() and <a href="qlist#takeLast">takeLast</a>().</p>   <h3 class="fn" id="takeFirst">
<code>[since 5.1] </code><span class="type">QList::value_type</span> QList::<span class="name">takeFirst</span>()
</h3> <p>Removes the first item in the list and returns it. This function assumes the list is not empty. To avoid failure, call <a href="qlist#isEmpty">isEmpty</a>() before calling this function.</p> <p>This function was introduced in Qt 5.1.</p> <p><b>See also </b><a href="qlist#takeLast">takeLast</a>() and <a href="qlist#removeFirst">removeFirst</a>().</p>   <h3 class="fn" id="takeLast">
<code>[since 5.1] </code><span class="type">QList::value_type</span> QList::<span class="name">takeLast</span>()
</h3> <p>Removes the last item in the list and returns it. This function assumes the list is not empty. To avoid failure, call <a href="qlist#isEmpty">isEmpty</a>() before calling this function.</p> <p>If you don't use the return value, <a href="qlist#removeLast">removeLast</a>() is more efficient.</p> <p>This function was introduced in Qt 5.1.</p> <p><b>See also </b><a href="qlist#takeFirst">takeFirst</a>() and <a href="qlist#removeLast">removeLast</a>().</p>   <h3 class="fn" id="value">
<span class="type">T</span> QList::<span class="name">value</span>(<span class="type">qsizetype</span> <i>i</i>) const
</h3> <p>Returns the value at index position <i>i</i> in the list.</p> <p>If the index <i>i</i> is out of bounds, the function returns a <a href="containers#default-constructed-value">default-constructed value</a>. If you are certain that <i>i</i> is within bounds, you can use <a href="qlist#at">at</a>() instead, which is slightly faster.</p> <p><b>See also </b><a href="qlist#at">at</a>() and <a href="qlist#operator-5b-5d">operator[]</a>().</p>   <h3 class="fn" id="value-1">
<span class="type">T</span> QList::<span class="name">value</span>(<span class="type">qsizetype</span> <i>i</i>, <span class="type">QList::parameter_type</span> <i>defaultValue</i>) const
</h3> <p>This is an overloaded function.</p> <p>If the index <i>i</i> is out of bounds, the function returns <i>defaultValue</i>.</p>   <h3 class="fn" id="operator-not-eq">
<span class="type">bool</span> QList::<span class="name">operator!=</span>(const <span class="type">QList</span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>) const
</h3> <p>Returns <code>true</code> if <i>other</i> is not equal to this list; otherwise returns <code>false</code>.</p> <p>Two lists are considered equal if they contain the same values in the same order.</p> <p>This function requires the value type to have an implementation of <code>operator==()</code>.</p> <p><b>See also </b><a href="qlist#operator-eq-eq">operator==</a>().</p>   <h3 class="fn" id="operator-2b">
<span class="type">QList</span>&lt;<span class="type">T</span>&gt; QList::<span class="name">operator+</span>(const <span class="type">QList</span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>) const
</h3> <p>Returns a list that contains all the items in this list followed by all the items in the <i>other</i> list.</p> <p><b>See also </b><a href="qlist#operator-2b-eq">operator+=</a>().</p>   <h3 class="fn" id="operator-2b-1">
<code>[since 6.0] </code><span class="type">QList</span>&lt;<span class="type">T</span>&gt; QList::<span class="name">operator+</span>(<span class="type">QList</span>&lt;<span class="type">T</span>&gt; &amp;&amp;<i>other</i>) const
</h3> <p>This is an overloaded function.</p> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="qlist#operator-2b-eq">operator+=</a>().</p>   <h3 class="fn" id="operator-2b-eq">
<span class="type">QList</span>&lt;<span class="type">T</span>&gt; &amp;QList::<span class="name">operator+=</span>(const <span class="type">QList</span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)
</h3> <p>Appends the items of the <i>other</i> list to this list and returns a reference to this list.</p> <p><b>See also </b><a href="qlist#operator-2b">operator+</a>() and <a href="qlist#append">append</a>().</p>   <h3 class="fn" id="operator-2b-eq-1">
<code>[since 6.0] </code><span class="type">QList</span>&lt;<span class="type">T</span>&gt; &amp;QList::<span class="name">operator+=</span>(<span class="type">QList</span>&lt;<span class="type">T</span>&gt; &amp;&amp;<i>other</i>)
</h3> <p>This is an overloaded function.</p> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="qlist#operator-2b">operator+</a>() and <a href="qlist#append">append</a>().</p>   <h3 class="fn" id="operator-2b-eq-2">
<span class="type">QList</span>&lt;<span class="type">T</span>&gt; &amp;QList::<span class="name">operator+=</span>(<span class="type">QList::parameter_type</span> <i>value</i>)
</h3> <p>This is an overloaded function.</p> <p>Appends <i>value</i> to the list.</p> <p><b>See also </b><a href="qlist#append">append</a>() and <a href="qlist#operator-lt-lt">operator&lt;&lt;</a>().</p>   <h3 class="fn" id="operator-2b-eq-3">
<code>[since 5.11] </code><span class="type">QList</span>&lt;<span class="type">T</span>&gt; &amp;QList::<span class="name">operator+=</span>(<span class="type">QList::rvalue_ref</span> <i>value</i>)
</h3> <p>This is an overloaded function.</p> <p>This function was introduced in Qt 5.11.</p> <p><b>See also </b><a href="qlist#append">append</a>() and <a href="qlist#operator-lt-lt">operator&lt;&lt;</a>().</p>   <h3 class="fn" id="operator-lt">
<code>[since 5.6] </code><span class="type">bool</span> QList::<span class="name">operator&lt;</span>(const <span class="type">QList</span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>) const
</h3> <p>Returns <code>true</code> if this list is <a href="http://en.cppreference.com/w/cpp/algorithm/lexicographical_compare">lexically less than</a> <i>other</i>; otherwise returns <code>false</code>.</p> <p>This function requires the value type to have an implementation of <code>operator&lt;()</code>.</p> <p>This function was introduced in Qt 5.6.</p>   <h3 class="fn" id="operator-lt-lt">
<span class="type">QList</span>&lt;<span class="type">T</span>&gt; &amp;QList::<span class="name">operator&lt;&lt;</span>(<span class="type">QList::parameter_type</span> <i>value</i>)
</h3> <p>Appends <i>value</i> to the list and returns a reference to this list.</p> <p><b>See also </b><a href="qlist#append">append</a>() and <a href="qlist#operator-2b-eq">operator+=</a>().</p>   <h3 class="fn" id="operator-lt-lt-1">
<span class="type">QList</span>&lt;<span class="type">T</span>&gt; &amp;QList::<span class="name">operator&lt;&lt;</span>(const <span class="type">QList</span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)
</h3> <p>Appends <i>other</i> to the list and returns a reference to the list.</p>   <h3 class="fn" id="operator-lt-lt-2">
<code>[since 6.0] </code><span class="type">QList</span>&lt;<span class="type">T</span>&gt; &amp;QList::<span class="name">operator&lt;&lt;</span>(<span class="type">QList</span>&lt;<span class="type">T</span>&gt; &amp;&amp;<i>other</i>)
</h3> <p>This is an overloaded function.</p> <p>This function was introduced in Qt 6.0.</p>   <h3 class="fn" id="operator-lt-lt-3">
<code>[since 5.11] </code><span class="type">QList</span>&lt;<span class="type">T</span>&gt; &amp;QList::<span class="name">operator&lt;&lt;</span>(<span class="type">QList::rvalue_ref</span> <i>value</i>)
</h3> <p>This is an overloaded function.</p> <p>This function was introduced in Qt 5.11.</p> <p><b>See also </b><a href="qlist#append">append</a>() and <a href="qlist#operator-2b-eq">operator+=</a>().</p>   <h3 class="fn" id="operator-lt-eq">
<code>[since 5.6] </code><span class="type">bool</span> QList::<span class="name">operator&lt;=</span>(const <span class="type">QList</span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>) const
</h3> <p>Returns <code>true</code> if this list is <a href="http://en.cppreference.com/w/cpp/algorithm/lexicographical_compare">lexically less than or equal to</a> <i>other</i>; otherwise returns <code>false</code>.</p> <p>This function requires the value type to have an implementation of <code>operator&lt;()</code>.</p> <p>This function was introduced in Qt 5.6.</p>   <h3 class="fn" id="operator-eq">
<code>[since 5.14] </code><span class="type">QList</span>&lt;<span class="type">T</span>&gt; &amp;QList::<span class="name">operator=</span>(<span class="type">std::initializer_list</span>&lt;<span class="type">T</span>&gt; <i>args</i>)
</h3> <p>Assigns the collection of values in <i>args</i> to this <a href="qlist">QList</a> instance.</p> <p>This function was introduced in Qt 5.14.</p>   <h3 class="fn" id="operator-eq-eq">
<span class="type">bool</span> QList::<span class="name">operator==</span>(const <span class="type">QList</span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>) const
</h3> <p>Returns <code>true</code> if <i>other</i> is equal to this list; otherwise returns <code>false</code>.</p> <p>Two lists are considered equal if they contain the same values in the same order.</p> <p>This function requires the value type to have an implementation of <code>operator==()</code>.</p> <p><b>See also </b><a href="qlist#operator-not-eq">operator!=</a>().</p>   <h3 class="fn" id="operator-gt">
<code>[since 5.6] </code><span class="type">bool</span> QList::<span class="name">operator&gt;</span>(const <span class="type">QList</span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>) const
</h3> <p>Returns <code>true</code> if this list is <a href="http://en.cppreference.com/w/cpp/algorithm/lexicographical_compare">lexically greater than</a> <i>other</i>; otherwise returns <code>false</code>.</p> <p>This function requires the value type to have an implementation of <code>operator&lt;()</code>.</p> <p>This function was introduced in Qt 5.6.</p>   <h3 class="fn" id="operator-gt-eq">
<code>[since 5.6] </code><span class="type">bool</span> QList::<span class="name">operator&gt;=</span>(const <span class="type">QList</span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>) const
</h3> <p>Returns <code>true</code> if this list is <a href="http://en.cppreference.com/w/cpp/algorithm/lexicographical_compare">lexically greater than or equal to</a> <i>other</i>; otherwise returns <code>false</code>.</p> <p>This function requires the value type to have an implementation of <code>operator&lt;()</code>.</p> <p>This function was introduced in Qt 5.6.</p>   <h3 class="fn" id="operator-5b-5d">
<span class="type">QList::reference</span> QList::<span class="name">operator[]</span>(<span class="type">qsizetype</span> <i>i</i>)
</h3> <p>Returns the item at index position <i>i</i> as a modifiable reference.</p> <p><i>i</i> must be a valid index position in the list (i.e., 0 &lt;= <i>i</i> &lt; <a href="qlist#size">size</a>()).</p> <p>Note that using non-const operators can cause <a href="qlist">QList</a> to do a deep copy.</p> <p><b>See also </b><a href="qlist#at">at</a>() and <a href="qlist#value">value</a>().</p>   <h3 class="fn" id="operator-5b-5d-1">
<span class="type">QList::const_reference</span> QList::<span class="name">operator[]</span>(<span class="type">qsizetype</span> <i>i</i>) const
</h3> <p>This is an overloaded function.</p> <p>Same as at(<i>i</i>).</p>   <div class="relnonmem"> <h2>Related Non-Members</h2>  <h3 class="fn" id="erase-2">
<code>[since 6.1] </code>template &lt;typename T, typename AT&gt; <span class="type">qsizetype</span> <span class="name">erase</span>(<span class="type">QList</span>&lt;<span class="type">T</span>&gt; &amp;<i>list</i>, const <span class="type">AT</span> &amp;<i>t</i>)
</h3> <p>Removes all elements that compare equal to <i>t</i> from the list <i>list</i>. Returns the number of elements removed, if any.</p> <div class="admonition note"> <p><b>Note: </b>Unlike <a href="qlist#removeAll">QList::removeAll</a>, <i>t</i> is not allowed to be a reference to an element inside <i>list</i>. If you cannot be sure that this is not the case, take a copy of <i>t</i> and call this function with the copy.</p> </div> <p>This function was introduced in Qt 6.1.</p> <p><b>See also </b><a href="qlist#removeAll">QList::removeAll</a>() and <a href="qlist#erase_if">erase_if</a>.</p>   <h3 class="fn" id="erase_if">
<code>[since 6.1] </code>template &lt;typename T, typename Predicate&gt; <span class="type">qsizetype</span> <span class="name">erase_if</span>(<span class="type">QList</span>&lt;<span class="type">T</span>&gt; &amp;<i>list</i>, <span class="type">Predicate</span> <i>pred</i>)
</h3> <p>Removes all elements for which the predicate <i>pred</i> returns true from the list <i>list</i>. Returns the number of elements removed, if any.</p> <p>This function was introduced in Qt 6.1.</p> <p><b>See also </b><a href="qlist#erase">erase</a>.</p>   <h3 class="fn" id="qHash">
<code>[since 5.6] </code>template &lt;typename T&gt; <span class="type">size_t</span> <span class="name">qHash</span>(const <span class="type">QList</span>&lt;<span class="type">T</span>&gt; &amp;<i>key</i>, <span class="type">size_t</span> <i>seed</i> = 0)
</h3> <p>Returns the hash value for <i>key</i>, using <i>seed</i> to seed the calculation.</p> <p>This function requires qHash() to be overloaded for the value type <code>T</code>.</p> <p>This function was introduced in Qt 5.6.</p>   <h3 class="fn" id="operator-lt-lt-4">template &lt;typename T&gt; <span class="type"><a href="qdatastream">QDataStream</a></span> &amp;<span class="name">operator&lt;&lt;</span>(<span class="type"><a href="qdatastream">QDataStream</a></span> &amp;<i>out</i>, const <span class="type">QList</span>&lt;<span class="type">T</span>&gt; &amp;<i>list</i>)
</h3> <p>Writes the list <i>list</i> to stream <i>out</i>.</p> <p>This function requires the value type to implement <code>operator&lt;&lt;()</code>.</p> <p><b>See also </b><a href="datastreamformat">Format of the QDataStream operators</a>.</p>   <h3 class="fn" id="operator-gt-gt">template &lt;typename T&gt; <span class="type"><a href="qdatastream">QDataStream</a></span> &amp;<span class="name">operator&gt;&gt;</span>(<span class="type"><a href="qdatastream">QDataStream</a></span> &amp;<i>in</i>, <span class="type">QList</span>&lt;<span class="type">T</span>&gt; &amp;<i>list</i>)
</h3> <p>Reads a list from stream <i>in</i> into <i>list</i>.</p> <p>This function requires the value type to implement <code>operator&gt;&gt;()</code>.</p> <p><b>See also </b><a href="datastreamformat">Format of the QDataStream operators</a>.</p>  </div>
<div class="_attribution">
  <p class="_attribution-p">
     The Qt Company Ltd<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://doc.qt.io/qt-6.2/qlist.html" class="_attribution-link">https://doc.qt.io/qt-6.2/qlist.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
