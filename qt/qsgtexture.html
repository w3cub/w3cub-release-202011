
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>QSGTexture (Class) - Qt - W3cubDocs</title>
  
  <meta name="description" content=" The QSGTexture class is the base class for textures used in the scene graph. More... ">
  <meta name="keywords" content="qsgtexture, class, qt">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/qt/qsgtexture.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/qt.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/qt/" class="_nav-link" title="" style="margin-left:0;">Qt</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _qt">
				
				
<h1 class="title">QSGTexture Class</h1>  <p>The QSGTexture class is the base class for textures used in the scene graph. <a href="#details">More...</a></p>  <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> Header:</td>
<td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QSGTexture&gt;</span> </td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> CMake:</td>
<td class="memItemRight bottomAlign"> find_package(Qt6 COMPONENTS Quick REQUIRED)  target_link_libraries(mytarget PRIVATE Qt6::Quick)</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> qmake:</td>
<td class="memItemRight bottomAlign"> QT += quick</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Inherits:</td>
<td class="memItemRight bottomAlign"> <a href="qobject">QObject</a>
</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Inherited By:</td>
<td class="memItemRight bottomAlign"> <p><a href="qsgdynamictexture">QSGDynamicTexture</a></p> </td>
</tr>
</table> <ul> <li><a href="https://doc.qt.io/qt-6.2/qsgtexture-members.html">List of all members, including inherited members</a></li> </ul> <h2 id="public-types">Public Types
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> enum </td>
<td class="memItemRight bottomAlign">
<b><a href="qsgtexture#AnisotropyLevel-enum">AnisotropyLevel</a></b> { AnisotropyNone, Anisotropy2x, Anisotropy4x, Anisotropy8x, Anisotropy16x }</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> enum </td>
<td class="memItemRight bottomAlign">
<b><a href="qsgtexture#Filtering-enum">Filtering</a></b> { None, Nearest, Linear }</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> enum </td>
<td class="memItemRight bottomAlign">
<b><a href="qsgtexture#WrapMode-enum">WrapMode</a></b> { Repeat, ClampToEdge, MirroredRepeat }</td>
</tr> </table> <h2 id="public-functions">Public Functions
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qsgtexture#QSGTexture">QSGTexture</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual </td>
<td class="memItemRight bottomAlign">
<b><a href="qsgtexture#dtor.QSGTexture">~QSGTexture</a></b>() override</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QSGTexture::AnisotropyLevel </td>
<td class="memItemRight bottomAlign">
<b><a href="qsgtexture#anisotropyLevel">anisotropyLevel</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual qint64 </td>
<td class="memItemRight bottomAlign">
<b><a href="qsgtexture#comparisonKey">comparisonKey</a></b>() const = 0</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QRectF </td>
<td class="memItemRight bottomAlign">
<b><a href="qsgtexture#convertToNormalizedSourceRect">convertToNormalizedSourceRect</a></b>(const QRectF &amp;<i>rect</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QSGTexture::Filtering </td>
<td class="memItemRight bottomAlign">
<b><a href="qsgtexture#filtering">filtering</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qsgtexture#hasAlphaChannel">hasAlphaChannel</a></b>() const = 0</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qsgtexture#hasMipmaps">hasMipmaps</a></b>() const = 0</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QSGTexture::WrapMode </td>
<td class="memItemRight bottomAlign">
<b><a href="qsgtexture#horizontalWrapMode">horizontalWrapMode</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qsgtexture#isAtlasTexture">isAtlasTexture</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QSGTexture::Filtering </td>
<td class="memItemRight bottomAlign">
<b><a href="qsgtexture#mipmapFiltering">mipmapFiltering</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QNativeInterface *</td>
<td class="memItemRight bottomAlign">
<b><a href="qsgtexture#nativeInterface">nativeInterface</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual QRectF </td>
<td class="memItemRight bottomAlign">
<b><a href="qsgtexture#normalizedTextureSubRect">normalizedTextureSubRect</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual QSGTexture *</td>
<td class="memItemRight bottomAlign">
<b><a href="qsgtexture#removedFromAtlas">removedFromAtlas</a></b>(QRhiResourceUpdateBatch *<i>resourceUpdates</i> = nullptr) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qsgtexture#setAnisotropyLevel">setAnisotropyLevel</a></b>(QSGTexture::AnisotropyLevel <i>level</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qsgtexture#setFiltering">setFiltering</a></b>(QSGTexture::Filtering <i>filter</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qsgtexture#setHorizontalWrapMode">setHorizontalWrapMode</a></b>(QSGTexture::WrapMode <i>hwrap</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qsgtexture#setMipmapFiltering">setMipmapFiltering</a></b>(QSGTexture::Filtering <i>filter</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qsgtexture#setVerticalWrapMode">setVerticalWrapMode</a></b>(QSGTexture::WrapMode <i>vwrap</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual QSize </td>
<td class="memItemRight bottomAlign">
<b><a href="qsgtexture#textureSize">textureSize</a></b>() const = 0</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QSGTexture::WrapMode </td>
<td class="memItemRight bottomAlign">
<b><a href="qsgtexture#verticalWrapMode">verticalWrapMode</a></b>() const</td>
</tr> </table>   <h2 id="details">Detailed Description
</h2> <p>Users can freely implement their own texture classes to support arbitrary input textures, such as YUV video frames or 8 bit alpha masks. The scene graph provides a default implementation for RGBA textures.The default implementation is not instantiated directly, rather they are constructed via factory functions, such as <a href="qquickwindow#createTextureFromImage">QQuickWindow::createTextureFromImage</a>().</p> <p>With the default implementation, each QSGTexture is backed by a QRhiTexture, which in turn contains a native texture object, such as an OpenGL texture or a Vulkan image.</p> <p>The size in pixels is given by <a href="qsgtexture#textureSize">textureSize</a>(). <a href="qsgtexture#hasAlphaChannel">hasAlphaChannel</a>() reports if the texture contains opacity values and <a href="qsgtexture#hasMipmaps">hasMipmaps</a>() reports if the texture contains mipmap levels.</p> <p><a href="qsgmaterial">Materials</a> that work with textures reimplement <a href="qsgmaterialshader#updateSampledImage">updateSampledImage</a>() to provide logic that decides which QSGTexture's underlying native texture should be exposed at a given shader resource binding point.</p> <p>QSGTexture does not separate image (texture) and sampler objects. The parameters for filtering and wrapping can be specified with <a href="qsgtexture#setMipmapFiltering">setMipmapFiltering</a>(), <a href="qsgtexture#setFiltering">setFiltering</a>(), <a href="qsgtexture#setHorizontalWrapMode">setHorizontalWrapMode</a>() and <a href="qsgtexture#setVerticalWrapMode">setVerticalWrapMode</a>(). The scene graph and Qt's graphics abstraction takes care of creating separate sampler objects, when applicable.</p> <h3 id="texture-atlases">Texture Atlases
</h3> <p>Some scene graph backends use texture atlasses, grouping multiple small textures into one large texture. If this is the case, the function <a href="qsgtexture#isAtlasTexture">isAtlasTexture</a>() will return true. Atlases are used to aid the rendering algorithm to do better sorting which increases performance. Atlases are also essential for batching (merging together geometry to reduce the number of draw calls), because two instances of the same material using two different QSGTextures are not batchable, whereas if both QSGTextures refer to the same atlas, batching can happen, assuming the materials are otherwise compatible.</p> <p>The location of the texture inside the atlas is given with the <a href="qsgtexture#normalizedTextureSubRect">normalizedTextureSubRect</a>() function.</p> <p>If the texture is used in such a way that atlas is not preferable, the function <a href="qsgtexture#removedFromAtlas">removedFromAtlas</a>() can be used to extract a non-atlased copy.</p> <div class="admonition note"> <p><b>Note: </b>All classes with QSG prefix should be used solely on the scene graph's rendering thread. See <a href="qtquick-visualcanvas-scenegraph#scene-graph-and-rendering">Scene Graph and Rendering</a> for more information.</p> </div>  <p><b>See also </b><a href="https://doc.qt.io/qt-6.2/qtquick-scenegraph-fboitem-example.html">Scene Graph - Rendering FBOs</a>.</p>   <h2>Member Type Documentation</h2>  <h3 class="fn" id="AnisotropyLevel-enum">
<code>[since 5.9] </code>enum QSGTexture::<span class="name">AnisotropyLevel</span>
</h3> <p>Specifies the anisotropic filtering level to be used when the texture is not screen aligned.</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QSGTexture::AnisotropyNone</code></td>
<td class="topAlign tblval"><code>0</code></td>
<td class="topAlign">No anisotropic filtering.</td>
</tr> <tr>
<td class="topAlign"><code>QSGTexture::Anisotropy2x</code></td>
<td class="topAlign tblval"><code>1</code></td>
<td class="topAlign">2x anisotropic filtering.</td>
</tr> <tr>
<td class="topAlign"><code>QSGTexture::Anisotropy4x</code></td>
<td class="topAlign tblval"><code>2</code></td>
<td class="topAlign">4x anisotropic filtering.</td>
</tr> <tr>
<td class="topAlign"><code>QSGTexture::Anisotropy8x</code></td>
<td class="topAlign tblval"><code>3</code></td>
<td class="topAlign">8x anisotropic filtering.</td>
</tr> <tr>
<td class="topAlign"><code>QSGTexture::Anisotropy16x</code></td>
<td class="topAlign tblval"><code>4</code></td>
<td class="topAlign">16x anisotropic filtering.</td>
</tr> </table> <p>This enum was introduced or modified in Qt 5.9.</p>   <h3 class="fn" id="Filtering-enum">enum QSGTexture::<span class="name">Filtering</span>
</h3> <p>Specifies how sampling of texels should filter when texture coordinates are not pixel aligned.</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QSGTexture::None</code></td>
<td class="topAlign tblval"><code>0</code></td>
<td class="topAlign">No filtering should occur. This value is only used together with <a href="qsgtexture#setMipmapFiltering">setMipmapFiltering</a>().</td>
</tr> <tr>
<td class="topAlign"><code>QSGTexture::Nearest</code></td>
<td class="topAlign tblval"><code>1</code></td>
<td class="topAlign">Sampling returns the nearest texel.</td>
</tr> <tr>
<td class="topAlign"><code>QSGTexture::Linear</code></td>
<td class="topAlign tblval"><code>2</code></td>
<td class="topAlign">Sampling returns a linear interpolation of the neighboring texels.</td>
</tr> </table>   <h3 class="fn" id="WrapMode-enum">enum QSGTexture::<span class="name">WrapMode</span>
</h3> <p>Specifies how the sampler should treat texture coordinates.</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QSGTexture::Repeat</code></td>
<td class="topAlign tblval"><code>0</code></td>
<td class="topAlign">Only the fractional part of the texture coordinate is used, causing values above 1 and below 0 to repeat.</td>
</tr> <tr>
<td class="topAlign"><code>QSGTexture::ClampToEdge</code></td>
<td class="topAlign tblval"><code>1</code></td>
<td class="topAlign">Values above 1 are clamped to 1 and values below 0 are clamped to 0.</td>
</tr> <tr>
<td class="topAlign"><code>QSGTexture::MirroredRepeat</code></td>
<td class="topAlign tblval"><code>2</code></td>
<td class="topAlign">When the texture coordinate is even, only the fractional part is used. When odd, the texture coordinate is set to <code>1 - fractional part</code>. This value has been introduced in Qt 5.10.</td>
</tr> </table>    <h2>Member Function Documentation</h2>  <h3 class="fn" id="QSGTexture">QSGTexture::<span class="name">QSGTexture</span>()
</h3> <p>Constructs the QSGTexture base class.</p>   <h3 class="fn" id="dtor.QSGTexture">
<code>[override virtual] </code>QSGTexture::<span class="name">~QSGTexture</span>()
</h3> <p>Destroys the <a href="qsgtexture">QSGTexture</a>.</p>   <h3 class="fn" id="anisotropyLevel">
<code>[since 5.9] </code><span class="type"><a href="qsgtexture#AnisotropyLevel-enum">QSGTexture::AnisotropyLevel</a></span> QSGTexture::<span class="name">anisotropyLevel</span>() const
</h3> <p>Returns the anisotropy level in use for filtering this texture.</p> <p>This function was introduced in Qt 5.9.</p> <p><b>See also </b><a href="qsgtexture#setAnisotropyLevel">setAnisotropyLevel</a>().</p>   <h3 class="fn" id="comparisonKey">
<code>[pure virtual, since 5.14] </code><span class="type"><a href="qtglobal#qint64-typedef">qint64</a></span> QSGTexture::<span class="name">comparisonKey</span>() const
</h3> <p>Returns a key suitable for comparing textures. Typically used in <a href="qsgmaterial#compare">QSGMaterial::compare</a>() implementations.</p> <p>Just comparing <a href="qsgtexture">QSGTexture</a> pointers is not always sufficient because two <a href="qsgtexture">QSGTexture</a> instances that refer to the same native texture object underneath should also be considered equal. Hence the need for this function.</p> <p>Implementations of this function are not expected to, and should not create any graphics resources (native texture objects) in case there are none yet.</p> <p>A <a href="qsgtexture">QSGTexture</a> that does not have a native texture object underneath is typically <b>not</b> equal to any other <a href="qsgtexture">QSGTexture</a>, so the return value has to be crafted accordingly. There are exceptions to this, in particular when atlasing is used (where multiple textures share the same atlas texture under the hood), that is then up to the subclass implementations to deal with as appropriate.</p> <div class="admonition warning"> <p><b>Warning: </b>This function can only be called from the rendering thread.</p> </div> <p>This function was introduced in Qt 5.14.</p>   <h3 class="fn" id="convertToNormalizedSourceRect">
<span class="type"><a href="qrectf">QRectF</a></span> QSGTexture::<span class="name">convertToNormalizedSourceRect</span>(const <span class="type"><a href="qrectf">QRectF</a></span> &amp;<i>rect</i>) const
</h3> <p>Returns <i>rect</i> converted to normalized coordinates.</p> <p><b>See also </b><a href="qsgtexture#normalizedTextureSubRect">normalizedTextureSubRect</a>().</p>   <h3 class="fn" id="filtering">
<span class="type"><a href="qsgtexture#Filtering-enum">QSGTexture::Filtering</a></span> QSGTexture::<span class="name">filtering</span>() const
</h3> <p>Returns the sampling mode to be used for this texture.</p> <p><b>See also </b><a href="qsgtexture#setFiltering">setFiltering</a>().</p>   <h3 class="fn" id="hasAlphaChannel">
<code>[pure virtual] </code><span class="type">bool</span> QSGTexture::<span class="name">hasAlphaChannel</span>() const
</h3> <p>Returns true if the texture data contains an alpha channel.</p>   <h3 class="fn" id="hasMipmaps">
<code>[pure virtual] </code><span class="type">bool</span> QSGTexture::<span class="name">hasMipmaps</span>() const
</h3> <p>Returns true if the texture data contains mipmap levels.</p>   <h3 class="fn" id="horizontalWrapMode">
<span class="type"><a href="qsgtexture#WrapMode-enum">QSGTexture::WrapMode</a></span> QSGTexture::<span class="name">horizontalWrapMode</span>() const
</h3> <p>Returns the horizontal wrap mode to be used for this texture.</p> <p><b>See also </b><a href="qsgtexture#setHorizontalWrapMode">setHorizontalWrapMode</a>().</p>   <h3 class="fn" id="isAtlasTexture">
<code>[virtual] </code><span class="type">bool</span> QSGTexture::<span class="name">isAtlasTexture</span>() const
</h3> <p>Returns whether this texture is part of an atlas or not.</p> <p>The default implementation returns false.</p>   <h3 class="fn" id="mipmapFiltering">
<span class="type"><a href="qsgtexture#Filtering-enum">QSGTexture::Filtering</a></span> QSGTexture::<span class="name">mipmapFiltering</span>() const
</h3> <p>Returns whether mipmapping should be used when sampling from this texture.</p> <p><b>See also </b><a href="qsgtexture#setMipmapFiltering">setMipmapFiltering</a>().</p>   <h3 class="fn" id="nativeInterface">template &lt;typename QNativeInterface&gt; <span class="type">QNativeInterface</span> *QSGTexture::<span class="name">nativeInterface</span>() const
</h3> <p>Returns a native interface of the given type for the texture.</p> <p>This function provides access to platform specific functionality of <a href="qsgtexture">QSGTexture</a>, as declared in the <a href="qnativeinterface-sub-qtquick">QNativeInterface</a> namespace:</p> <table class="annotated"> <tr class="odd topAlign">
<td class="tblName"><p><a href="qnativeinterface-qsgd3d11texture">QNativeInterface::QSGD3D11Texture</a></p></td>
<td class="tblDescr"><p>Provides access to and enables adopting Direct3D 11 texture objects</p></td>
</tr> <tr class="even topAlign">
<td class="tblName"><p><a href="qnativeinterface-qsgmetaltexture">QNativeInterface::QSGMetalTexture</a></p></td>
<td class="tblDescr"><p>Provides access to and enables adopting Metal texture objects</p></td>
</tr> <tr class="odd topAlign">
<td class="tblName"><p><a href="qnativeinterface-qsgopengltexture">QNativeInterface::QSGOpenGLTexture</a></p></td>
<td class="tblDescr"><p>Provides access to and enables adopting OpenGL texture objects</p></td>
</tr> <tr class="even topAlign">
<td class="tblName"><p><a href="qnativeinterface-qsgvulkantexture">QNativeInterface::QSGVulkanTexture</a></p></td>
<td class="tblDescr"><p>Provides access to and enables adopting Vulkan image objects</p></td>
</tr> </table> <p>This allows accessing the underlying native texture object, such as, the <code>GLuint</code> texture ID with OpenGL, or the <code>VkImage</code> handle with Vulkan.</p> <p>If the requested interface is not available a <code>nullptr</code> is returned.</p>   <h3 class="fn" id="normalizedTextureSubRect">
<code>[virtual] </code><span class="type"><a href="qrectf">QRectF</a></span> QSGTexture::<span class="name">normalizedTextureSubRect</span>() const
</h3> <p>Returns the rectangle inside <a href="qsgtexture#textureSize">textureSize</a>() that this texture represents in normalized coordinates.</p> <p>The default implementation returns a rect at position (0, 0) with width and height of 1.</p>   <h3 class="fn" id="removedFromAtlas">
<code>[virtual] </code><span class="type"><a href="qsgtexture#QSGTexture">QSGTexture</a></span> *QSGTexture::<span class="name">removedFromAtlas</span>(<span class="type">QRhiResourceUpdateBatch</span> *<i>resourceUpdates</i> = nullptr) const
</h3> <p>This function returns a copy of the current texture which is removed from its atlas.</p> <p>The current texture remains unchanged, so texture coordinates do not need to be updated.</p> <p>Removing a texture from an atlas is primarily useful when passing it to a shader that operates on the texture coordinates 0-1 instead of the texture subrect inside the atlas.</p> <p>If the texture is not part of a texture atlas, this function returns 0.</p> <p>Implementations of this function are recommended to return the same instance for multiple calls to limit memory usage.</p> <p><i>resourceUpdates</i> is an optional resource update batch, on which texture operations, if any, are enqueued. Materials can retrieve an instance from <a href="qsgmaterialshader-renderstate">QSGMaterialShader::RenderState</a>. When null, the removedFromAtlas() implementation creates its own batch and submit it right away. However, when a valid instance is specified, this function will not submit the update batch.</p> <div class="admonition warning"> <p><b>Warning: </b>This function can only be called from the rendering thread.</p> </div>   <h3 class="fn" id="setAnisotropyLevel">
<code>[since 5.9] </code><span class="type">void</span> QSGTexture::<span class="name">setAnisotropyLevel</span>(<span class="type"><a href="qsgtexture#AnisotropyLevel-enum">QSGTexture::AnisotropyLevel</a></span> <i>level</i>)
</h3> <p>Sets the level of anisotropic filtering to <i>level</i>. The default value is <a href="qsgtexture#AnisotropyLevel-enum">QSGTexture::AnisotropyNone</a>, which means no anisotropic filtering is enabled.</p> <div class="admonition note"> <p><b>Note: </b>The request may be ignored depending on the graphics API in use. There is no guarantee anisotropic filtering is supported at run time.</p> </div> <p>This function was introduced in Qt 5.9.</p> <p><b>See also </b><a href="qsgtexture#anisotropyLevel">anisotropyLevel</a>().</p>   <h3 class="fn" id="setFiltering">
<span class="type">void</span> QSGTexture::<span class="name">setFiltering</span>(<span class="type"><a href="qsgtexture#Filtering-enum">QSGTexture::Filtering</a></span> <i>filter</i>)
</h3> <p>Sets the sampling mode to <i>filter</i>.</p> <p><b>See also </b><a href="qsgtexture#filtering">filtering</a>().</p>   <h3 class="fn" id="setHorizontalWrapMode">
<span class="type">void</span> QSGTexture::<span class="name">setHorizontalWrapMode</span>(<span class="type"><a href="qsgtexture#WrapMode-enum">QSGTexture::WrapMode</a></span> <i>hwrap</i>)
</h3> <p>Sets the horizontal wrap mode to <i>hwrap</i></p> <p><b>See also </b><a href="qsgtexture#horizontalWrapMode">horizontalWrapMode</a>().</p>   <h3 class="fn" id="setMipmapFiltering">
<span class="type">void</span> QSGTexture::<span class="name">setMipmapFiltering</span>(<span class="type"><a href="qsgtexture#Filtering-enum">QSGTexture::Filtering</a></span> <i>filter</i>)
</h3> <p>Sets the mipmap sampling mode to <i>filter</i>.</p> <p>Setting the mipmap filtering has no effect it the texture does not have mipmaps.</p> <p><b>See also </b><a href="qsgtexture#mipmapFiltering">mipmapFiltering</a>() and <a href="qsgtexture#hasMipmaps">hasMipmaps</a>().</p>   <h3 class="fn" id="setVerticalWrapMode">
<span class="type">void</span> QSGTexture::<span class="name">setVerticalWrapMode</span>(<span class="type"><a href="qsgtexture#WrapMode-enum">QSGTexture::WrapMode</a></span> <i>vwrap</i>)
</h3> <p>Sets the vertical wrap mode to <i>vwrap</i></p> <p><b>See also </b><a href="qsgtexture#verticalWrapMode">verticalWrapMode</a>().</p>   <h3 class="fn" id="textureSize">
<code>[pure virtual] </code><span class="type"><a href="qsize">QSize</a></span> QSGTexture::<span class="name">textureSize</span>() const
</h3> <p>Returns the size of the texture.</p>   <h3 class="fn" id="verticalWrapMode">
<span class="type"><a href="qsgtexture#WrapMode-enum">QSGTexture::WrapMode</a></span> QSGTexture::<span class="name">verticalWrapMode</span>() const
</h3> <p>Returns the vertical wrap mode to be used for this texture.</p> <p><b>See also </b><a href="qsgtexture#setVerticalWrapMode">setVerticalWrapMode</a>().</p>
<div class="_attribution">
  <p class="_attribution-p">
    Â© The Qt Company Ltd<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://doc.qt.io/qt-6.2/qsgtexture.html" class="_attribution-link">https://doc.qt.io/qt-6.2/qsgtexture.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
