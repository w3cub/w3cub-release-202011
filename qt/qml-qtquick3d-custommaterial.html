
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>CustomMaterial (QML Type) - Qt - W3cubDocs</title>
  
  <meta name="description" content=" Base component for creating custom materials used to shade models. More... ">
  <meta name="keywords" content="custommaterial, qml, type, qt">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/qt/qml-qtquick3d-custommaterial.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/qt.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/qt/" class="_nav-link" title="" style="margin-left:0;">Qt</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _qt">
				
				
<h1 class="title">CustomMaterial QML Type</h1>  <p>Base component for creating custom materials used to shade models. <a href="#details">More...</a></p>  <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> Import Statement:</td>
<td class="memItemRight bottomAlign"> import QtQuick3D</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Inherits:</td>
<td class="memItemRight bottomAlign"> <p><a href="qml-qtquick3d-material">Material</a></p> </td>
</tr>
</table>
<ul> <li><a href="https://doc.qt.io/qt-6.2/qml-qtquick3d-custommaterial-members.html">List of all members, including inherited members</a></li> </ul> <h2 id="properties">Properties
</h2> <ul> <li class="fn">
<b><a href="qml-qtquick3d-custommaterial#alwaysDirty-prop">alwaysDirty</a></b> : bool</li> <li class="fn">
<b><a href="qml-qtquick3d-custommaterial#destinationBlend-prop">destinationBlend</a></b> : enumeration</li> <li class="fn">
<b><a href="qml-qtquick3d-custommaterial#fragmentShader-prop">fragmentShader</a></b> : url</li> <li class="fn">
<b><a href="qml-qtquick3d-custommaterial#lineWidth-prop">lineWidth</a></b> : real</li> <li class="fn">
<b><a href="qml-qtquick3d-custommaterial#shadingMode-prop">shadingMode</a></b> : enumeration</li> <li class="fn">
<b><a href="qml-qtquick3d-custommaterial#sourceBlend-prop">sourceBlend</a></b> : enumeration</li> <li class="fn">
<b><a href="qml-qtquick3d-custommaterial#vertexShader-prop">vertexShader</a></b> : url</li> </ul>  <h2 id="details">Detailed Description
</h2> <p>The custom material allows using custom shader code for a material, enabling programmability on graphics shader level. A vertex, fragment, or both shaders can be provided. The <a href="qml-qtquick3d-custommaterial#vertexShader-prop">vertexShader</a> and <a href="qml-qtquick3d-custommaterial#fragmentShader-prop">fragmentShader</a> properties are URLs, referencing files containing shader snippets, and work very similarly to <a href="qml-qtquick-shadereffect">ShaderEffect</a> or <a href="qml-qtquick-image#source-prop">Image.source</a>. Only the <code>file</code> and <code>qrc</code> schemes are supported with custom materials. It is also possible to omit the <code>file</code> scheme, allowing to specify a relative path in a convenient way. Such a path is resolved relative to the component's (the <code>.qml</code> file's) location.</p> <p>For a getting started guide to custom materials, see the page <a href="qtquick3d-custom">Programmable Materials, Effects, Geometry, and Texture data</a>.</p> <h2 id="introduction">Introduction
</h2> <p>Consider the following versions of the same scene. On the left, the cylinder is using a built-in, non-programmable material. Such materials are configurable through a wide range of properties, but there is no further control given over the shaders that are generated under the hood. On the right, the same cylinder is now associated with a CustomMaterial referencing application-provided vertex and fragment shader snippets. This allows inserting custom, application-specific logic into the vertex shader to transform the geometry, and to determine certain color properties in a custom manner in the fragment shader. As this is a <a href="qml-qtquick3d-custommaterial#shadingMode-prop">shaded</a> custom material, the cylinder still participates in the scene lighting normally.</p> <table class="generic" width="70%"> <tr class="odd" valign="top">
<td>
<pre data-language="qml">View3D {
    anchors.fill: parent
    PerspectiveCamera {
        id: camera
        position: Qt.vector3d(0, 0, 600)
    }
    camera: camera
    DirectionalLight {
        position: Qt.vector3d(-500, 500, -100)
        color: Qt.rgba(0.2, 0.2, 0.2, 1.0)
        ambientColor: Qt.rgba(0.1, 0.1, 0.1, 1.0)
    }
    Model {
        source: "#Cylinder"
        eulerRotation: Qt.vector3d(30, 30, 0)
        scale: Qt.vector3d(1.5, 1.5, 1.5)
        materials: [
            DefaultMaterial {
                diffuseColor: Qt.rgba(0, 1, 0, 1)
            }
        ]
    }
}</pre> </td>
<td>
<pre data-language="qml">View3D {
    anchors.fill: parent
    PerspectiveCamera {
        id: camera
        position: Qt.vector3d(0, 0, 600)
    }
    camera: camera
    DirectionalLight {
        position: Qt.vector3d(-500, 500, -100)
        color: Qt.rgba(0.2, 0.2, 0.2, 1.0)
        ambientColor: Qt.rgba(0.1, 0.1, 0.1, 1.0)
    }
    Model {
        source: "#Cylinder"
        eulerRotation: Qt.vector3d(30, 30, 0)
        scale: Qt.vector3d(1.5, 1.5, 1.5)
        materials: [
            CustomMaterial {
                vertexShader: "material.vert"
                fragmentShader: "material.frag"
                property real uTime
                property real uAmplitude: 50
                NumberAnimation on uTime { from: 0; to: 100; duration: 10000; loops: -1 }
            }
        ]
    }
}</pre> </td>
</tr> </table> <p>Let's assume that the shader snippets in <code>material.vert</code> and <code>material.frag</code> are the following:</p> <table class="generic" width="70%"> <tr class="odd" valign="top">
<td>
<pre data-language="cpp">void MAIN()
{
    VERTEX.x += sin(uTime + VERTEX.y) * uAmplitude;
}</pre> </td>
<td>
<pre data-language="cpp">void MAIN()
{
    BASE_COLOR = vec4(0.0, 1.0, 0.0, 1.0);
}</pre> </td>
</tr> </table> <p>Notice how <code>uTime</code> and <code>uAmplitude</code> are properties of the CustomMaterial element. They can change values and get animated normally, the values will be exposed to the shaders automatically without any further action from the developer.</p> <p>The result is a cylinder that animates its vertices:</p> <p class="centerAlign"><img alt="" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN0AAADHBAMAAABvp0vUAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAeUExURQB4AACQAP///wCNAACKAACFAAB/AABvAABaAABlAJFHRKwAAAWoSURBVHja7dtBj5s4FAdwlANob43mC6RkZpveGtEPUG3hvloB52ikePcYzQVx7aXMdS6ZfNu1nw02xgbbMXMy9/an//N7djBtlH7os4uCF7zgBS94wQte8IIXvOAFL3jBC17wghe84AXP7omGZ/MB3i4aPZuVPYmzEZ28SPFsPtgzFF28XaR5PtoziOjXW47o24tW8L7MeQs19e/Ng07exR1cw5sDXbxrFDmDbl7sDDp6J1fQ0UOuJXXxGuwtBoz8evXfbqCrhyq3irp656pyCniHV7oEdPMQ9sryh0NAB+/rJTqhqqry/Id9QDcPQT2XQX8e5Mt/frMNeEe+AnvZN8uAd+bLsmx17zf2zmfwMJcdV/a63zwfeNtPFgto6x263isGb7tdzes66tFxAG9Lnk+r1PNAuO56Ids13l8ETxfxLg+07oaP2xhJ+TRicodHw73eiIdq3i/brV5s3T0WDj/0+JvmU6yjszeEu12b5gL5SjruY+8h4zsOOiUvjt6Bh8PPkE/pZRkOjsuNUOTqDeGAo8dtybzjxPsOXo296M3FG4drcKViNn9ar8RejfO5eJ3EJczLl/Ml9ucfbxTQEsLR7bNQeRn1CuKdosbaG8Jdr7gxG3gximN9Pu5V2PvD0hOmoO01km4+Xw4ewl5r5/GVg2yXCECEpwEJx5/CK5j3YuWJI465BDgEj3DcbrX5VOOn9w5jLknYntFzhcoTxr2283ijNLSW0Ck0Hdms1fl6r6Tj8Gbq8XBtS8cA+hLC1ZQrdd53vp2Z/r4WRvxKdxQejtSScNJxO91elOOn9MbbJe6TC3AxryVUczafZtxV3nj/ShThcLMU+Uw+tr20Rh5Zu/eeo0MX03Dnnish3ez2ohm/qUe4V1zMdjIFfS2xVhb5zLgT76w8bRVev13yMTjxoYNaFsWQbm57iYy8A52CRtguYyTUsmS1ZJw6HxuHNxPvxneUBMLFwtCxvmS1nPE0p9/Uk3aUId2oL/tw8u7JtzM43c08YbuMx0Mn11LmDMZP9r6yHw0XxdCRvpyp5Xh70YzDxBtxbOhqRV+qOGHcyelucr/0hW5giqFbqqXoFWTcN4YebRRp6Bb6UvFr6dnovo5cFfNjfNidJ32p5MTxeza7/9yxoetPurNxLYVxKKra9D55xxtFGDqpLzVcNnAotfCmh8FiX464qnq2+B4wDB0a+rI0riXMev1s871jWsvcpJYPQ2vWdt+P5F8NRn0pLF1t+b3qT+EwKMvSqJbC0iHr73HutVzoFJ3X19K0L4WlW+am3pOuL+9eOs3vM6ta2iydxntitSwXt2fLpdP93iVcabV0udHS6bwnw/3Sdum07w9Fbsmh9C7v0a6WNpz6fexxOZx9p8y9b5rV0njIF73H+VqKndJ1Hrx0v7h0bMjx680vD17602jp/oN3Ux9eOl9LunSUswqo9R6X9+fb7b2zDai/X9ovLV3b3l6tA87cZ+1nl+7fprk5BJy7rzvqlg5zp6QB0Dbg7H3kUbt0J/yzH0DbgLPeXrl0hMMeDohX8ObTE0Fxf0b0nzMIFf3lx+MVFZYOv5uTu/6EBXz16Q0gqyV516rOOB9iAfuK+vL20rvWAJKOufCZ8OWNQHIXAHe3NVtCGvDdoqDL3zuO45dluA2AgKd+CV+9etISFlDRPmDSB/ToSRWF6zhS0Zj0aMJmwqM3BWlFyVBECdtlfHq6oYhj2NVgl/HqqcCaBWQ96tfTVZQP4ZtXbwClHo2HIfTsyRUd9WjTXL17Pajp0Tb17aXSEpajHn3x7+3VPUpO3mgNL/3MQalHkyZdwetLKi4h69HNOl46rSh81rf4Oyz/vc1nASzhnppUNF3No6DUo+mKHhUfxB5N1/VA5B/C/klX9+B1DSr6l/WfC/8fKHjBC17wghe84AUveMELXvCCFzwH738KxsmMb3fBTwAAAABJRU5ErkJggg=="></p>
<h2 id="two-flavors-of-custom-materials">Two flavors of custom materials
</h2> <p>There are two main types of custom materials. This is specified by the <a href="qml-qtquick3d-custommaterial#shadingMode-prop">shadingMode</a> property. In <a href="qml-qtquick3d-custommaterial#shadingMode-prop">unshaded</a> custom materials the fragment shader outputs a single <code>vec4</code> color, ignoring lights, light probes, shadowing in the scene. In <a href="qml-qtquick3d-custommaterial#shadingMode-prop">shaded</a> materials the shader is expected to implement certain functions and work with built-in variables to take lighting and shadow contribution into account.</p> <p>The default choice is typically a shaded material, this is reflected in the default value of the <a href="qml-qtquick3d-custommaterial#shadingMode-prop">shadingMode</a> property. This fits materials that needs to transform vertices or other incoming data from the geometry, or determine values like <code>BASE_COLOR</code> or <code>EMISSIVE_COLOR</code> in a custom manner, perhaps by sampling <code>SCREEN_TEXTURE</code> or <code>DEPTH_TEXTURE</code>, while still reciving light and shadow contributions from the scene. Additionally, such materials can also override and reimplement the equations used to calculate the contributions from directional, point, and other lights. The application-provided shader snippets are heavily amended by the Qt Quick 3D engine under the hood, in order to provide the features, such as lighting, the standard materials have.</p> <p>Unshaded materials are useful when the object's appearance is determined completely by the custom shader code. The shaders for such materials receive minimal additions by the engine, and therefore it is completely up to the shader to determine the final fragment color. This gives more freedom, but also limits possiblities to integrate with other elements of the scene, such as lights.</p> <div class="admonition note"> <p><b>Note: </b>Shader code is always provided using Vulkan-style GLSL, regardless of the graphics API used by Qt at run time.</p> </div> <div class="admonition note"> <p><b>Note: </b>The vertex and fragment shader code provided by the material are not full, complete GLSL shaders on their own. Rather, they provide a set of functions, which are then amended with further shader code by the engine.</p> </div> <h2 id="exposing-data-to-the-shaders">Exposing data to the shaders
</h2> <p>The dynamic properties of the CustomMaterial can be changed and animated using QML and Qt Quick facilities, and the values are exposed to the shaders automatically. This in practice is very similar <a href="qml-qtquick-shadereffect">ShaderEffect</a>. The following list shows how properties are mapped:</p> <ul> <li>bool, int, real -&gt; bool, int, float</li> <li>
<a href="qcolor">QColor</a>, <a href="qml-qtqml-qt#rgba-method">color</a> -&gt; vec4, and the color gets converted to linear, assuming sRGB space for the color value specified in QML. The built-in Qt colors, such as <code>"green"</code> are in sRGB color space as well, and the same conversion is performed for all color properties of <a href="qml-qtquick3d-defaultmaterial">DefaultMaterial</a> and <a href="qml-qtquick3d-principledmaterial">PrincipledMaterial</a>, so this behavior of CustomMaterial matches those. Unlike Qt Quick, for Qt Quick 3D linearizing is essential as there will typically be tonemapping performed on the 3D scene.</li> <li>
<a href="qrect">QRect</a>, <a href="qrectf">QRectF</a>, <a href="qml-qtqml-qt#rect-method">rect</a> -&gt; vec4</li> <li>
<a href="qpoint">QPoint</a>, <a href="qpointf">QPointF</a>, <a href="qml-qtqml-qt#point-method">point</a>, <a href="qsize">QSize</a>, <a href="qsizef">QSizeF</a>, <a href="qml-qtqml-qt#size-method">size</a> -&gt; vec2</li> <li>
<a href="qvector2d">QVector2D</a>, <a href="qml-qtqml-qt#vector2d-method">vector2d</a> -&gt; vec2</li> <li>
<a href="qvector3d">QVector3D</a>, <a href="qml-qtqml-qt#vector3d-method">vector3d</a> -&gt; vec3</li> <li>
<a href="qvector4d">QVector4D</a>, <a href="qml-qtqml-qt#vector4d-method">vector4d</a> -&gt; vec4</li> <li>
<a href="qmatrix4x4">QMatrix4x4</a>, <a href="qml-qtqml-qt#matrix4x4-method">matrix4x4</a> -&gt; mat4</li> <li>
<a href="qquaternion">QQuaternion</a>, <a href="qml-qtqml-qt#quaternion-method">quaternion</a> -&gt; vec4, scalar value is <code>w</code>
</li> <li>
<a href="qml-qtquick3d-textureinput">TextureInput</a> -&gt; sampler2D - Textures referencing <a href="qml-qtquick3d-texture#source-prop">image files</a> and <a href="qml-qtquick3d-texture#sourceItem-prop">Qt Quick item layers</a> are both supported. Setting the <a href="qml-qtquick3d-textureinput#enabled-prop">enabled</a> property to false leads to exposing a dummy texture to the shader, meaning the shaders are still functional but will sample a texture with opaque black image content. Pay attention to the fact that properties for samplers must always reference a <a href="qml-qtquick3d-textureinput">TextureInput</a> object, not a <a href="qml-qtquick3d-texture">Texture</a> directly. When it comes to the <a href="qml-qtquick3d-texture">Texture</a> properties, the source, tiling, and filtering related ones are the only ones that are taken into account implicitly with custom materials, as the rest (such as, UV transformations) is up to the custom shaders to implement as they see fit.</li> </ul> <div class="admonition note"> <p><b>Note: </b>When a uniform referenced in the shader code does not have a corresponding property, it will cause a shader compilation error when processing the material at run time. There are some exceptions to this, such as, sampler uniforms, that get a dummy texture bound when no corresponding QML property is present, but as a general rule, all uniforms and samplers must have a corresponding property declared in the CustomMaterial object.</p> </div> <h2 id="unshaded-custom-materials">Unshaded custom materials
</h2> <p>The following is an example of an <a href="qml-qtquick3d-custommaterial#shadingMode-prop">unshaded</a> custom material.</p> <pre data-language="qml">CustomMaterial {
    // These properties are automatically exposed to the shaders
    property real time: 0.0
    property real amplitude: 5.0
    property real alpha: 1.0
    property TextureInput tex: TextureInput {
        enabled: true
        texture: Texture { source: "image.png" }
    }

    shadingMode: CustomMaterial.Unshaded
    sourceBlend: alpha &lt; 1.0 ? CustomMaterial.SrcAlpha : CustomMaterial.NoBlend
    destinationBlend: alpha &lt; 1.0 ? CustomMaterial.OneMinusSrcAlpha : CustomMaterial.NoBlend
    cullMode: CustomMaterial.BackFaceCulling

    vertexShader: "customshader.vert"
    fragmentShader: "customshader.frag"
}</pre> <p>With the above example, the <a href="qml-qtquick3d-custommaterial#shadingMode-prop">unshaded</a> vertex and fragment shaders snippets could look like the following. Note how the shaders do not, and must not, declare uniforms or vertex inputs as that is taken care of by Qt when assembling the final shader code.</p> <pre data-language="cpp">VARYING vec3 pos;
VARYING vec2 texcoord;

void MAIN()
{
    pos = VERTEX;
    pos.x += sin(time * 4.0 + pos.y) * amplitude;
    texcoord = UV0;
    POSITION = MODELVIEWPROJECTION_MATRIX * vec4(pos, 1.0);
}</pre> <pre data-language="cpp">VARYING vec3 pos;
VARYING vec2 texcoord;

void MAIN()
{
    vec4 c = texture(tex, texcoord);
    FRAGCOLOR = vec4(pos.x * 0.02, pos.y * 0.02, pos.z * 0.02, alpha) * c;
}</pre> <p>The following special, uppercase keywords are available:</p> <ul> <li>MAIN -&gt; the name of the entry point in the vertex or fragment shader snippet must always be <code>MAIN</code>. Providing this function is mandatory in shader snippets for unshaded custom materials.</li> <li>VARYING -&gt; declares an output from the vertex shader or an input to the fragment shader</li> <li>POSITION -&gt; vec4, the output from the vertex shader</li> <li>FRAGCOLOR -&gt; vec4, the output from the fragment shader. Available only for unshaded custom materials.</li> <li>VERTEX -&gt; vec3, the vertex position in the vertex shader.</li> <li>NORMAL -&gt; vec3, the vertex normal in the vertex shader. When the mesh for the associated model does not provide normals, the value is vec3(0.0).</li> <li>UV0 -&gt; vec2, the first set of texture coordinates in the vertex shader. When the mesh for the associated model does not provide texture coordinates, the value is vec2(0.0).</li> <li>UV1 -&gt; vec2, the second set of texture coordinates in the vertex shader. When the mesh for the associated model does not provide a second set of texture coordinates, the value is vec2(0.0).</li> <li>COLOR -&gt; vec4, the vertex color in the vertex shader. When the mesh for the associated model does not provide per-vertex colors, the value is vec4(1.0).</li> <li>TANGENT -&gt; vec3, tangent in the vertex shader. When the mesh for the associated model does not provide tangent data, the value is vec3(0.0).</li> <li>BINORMAL -&gt; vec3, binormal in the vertex shader. When the mesh for the associated model does not provide binormal data, the value is vec3(0.0).</li> <li>JOINTS -&gt; ivec4, joint indexes in the vertex shader. When the mesh for the associated model does not provide joint indexes data, the value is ivec4(0).</li> <li>WEIGHTS -&gt; vec4, joint weights in the vertex shader. When the mesh for the associated model does not provide joint weights data, the value is vec4(0.0).</li> <li>MORPH_POSITION<i>n</i> -&gt; vec3, the <i>n</i>th morph target position in the vertex shader. <i>n</i>'s range is from 0 to 7. The associated model should provide proper data. For safety, the user can check <b>defined(QT_MORPH_IN_POSITION<i>n</i>)</b> before use it.</li> <li>MORPH_NORMAL<i>n</i> -&gt; vec3, the <i>n</i>th morph target normal in the vertex shader. <i>n</i>'s range is from 0 to 4. The associated model should provide proper data. For safety, the user can check <b>defined(QT_MORPH_IN_NORMAL<i>n</i>)</b> before use it.</li> <li>MORPH_TANGENT<i>n</i> -&gt; vec3, the <i>n</i>th morph target tangent in the vertex shader. <i>n</i>'s range is from 0 to 1. The associated model should provide proper data. For safety, the user can check <b>defined(QT_MORPH_IN_TANGENT<i>n</i>)</b> before use it.</li> <li>MORPH_BINORMAL<i>n</i> -&gt; vec3, the <i>n</i>th morph target binormal in the vertex shader. <i>n</i>'s range is from 0 to 1. The associated model should provide proper data. For safety, the user can check <b>defined(QT_MORPH_IN_BINORMAL<i>n</i>)</b> before use it.</li> <li>MODELVIEWPROJECTION_MATRIX -&gt; mat4, the model-view-projection matrix. Projection matrices always follow OpenGL conventions, with a baked-in transformation for the Y axis direction and clip depth, depending on the graphics API used at run time.</li> <li>VIEWPROJECTION_MATRIX -&gt; mat4, the view-projection matrix</li> <li>PROJECTION_MATRIX -&gt; mat4, the projection matrix</li> <li>INVERSE_PROJECTION_MATRIX -&gt; mat4, the inverse projection matrix</li> <li>VIEW_MATRIX -&gt; mat4, the view (camera) matrix</li> <li>MODEL_MATRIX -&gt; mat4, the model (world) matrix</li> <li>NORMAL_MATRIX -&gt; mat3, the normal matrix (the transpose of the inverse of the top-left 3x3 part of the model matrix)</li> <li>BONE_TRANSFORMS -&gt; mat4[], the array of the model's bone matrixes</li> <li>BONE_NORMAL_TRANSFORMS -&gt; mat3[], the array of the model's bone normal matrixes (the transpose of the inverse of the top-left 3x3 part of the each bone matrixes)</li> <li>MORPH_WEIGHTS -&gt; float[], the array of the morph weights. The associated model should provide proper data. For safety, <b>QT_MORPH_MAX_COUNT</b> is defined to the size of this array.</li> <li>CAMERA_POSITION -&gt; vec3, the camera position in world space</li> <li>CAMERA_DIRECTION -&gt; vec3, the camera direction vector</li> <li>CAMERA_PROPERTIES -&gt; vec2, the near and far clip values for the camera</li> <li>POINT_SIZE -&gt; float, writable in the vertex shader only. When rendering geometry with a topology of points, the custom vertex shader must set this to either 1.0 or another value, both in shaded and unshaded custom materials. See <a href="qml-qtquick3d-principledmaterial#pointSize-prop">PrincipledMaterial::pointSize</a> for further notes on support for sizes other than 1.</li> </ul> <h2 id="shaded-custom-materials">Shaded custom materials
</h2> <p>A <a href="qml-qtquick3d-custommaterial#shadingMode-prop">shaded</a> material <code>augments</code> the shader code that would be generated by a <a href="qml-qtquick3d-principledmaterial">PrincipledMaterial</a>. Unlike unshaded materials, that provide almost all logic for the vertex and fragment shader main functions on their own, preventing adding generated code for lighting, shadowing, global illumination, etc., shaded materials let shader generation happen normally, as if the CustomMaterial was a <a href="qml-qtquick3d-principledmaterial">PrincipledMaterial</a>. The vertex and fragment shader snippets are expected to provide optional functions that are then invoked at certain points, giving them the possibility to customize the colors and other values that are then used for calculating lighting and the final fragment color.</p> <p>Rather than implementing just a <code>MAIN</code> function, the fragment shader for a shaded custom material can implement multiple functions. All functions, including <code>MAIN</code>, are optional to implement in shaded custom materials. An empty shader snippet, or, even, not specifying the <a href="qml-qtquick3d-custommaterial#vertexShader-prop">vertexShader</a> or <a href="qml-qtquick3d-custommaterial#fragmentShader-prop">fragmentShader</a> properties at all can be perfectly valid too.</p> <h3 id="vertex-shader-snippets-in-a-shaded-custom-material">Vertex shader snippets in a shaded custom material
</h3> <p>The following functions can be implemented in a vertex shader snippet:</p> <ul> <li>
<code>void MAIN()</code> When present, this function is called in order to set the value of <code>POSITION</code>, the vec4 output from the vertex shader, and, optionally, to modify the values of <code>VERTEX</code>, <code>COLOR</code>, <code>NORMAL</code>, <code>UV0</code>, <code>UV1</code>, <code>TANGENT</code>, <code>BINORMAL</code>, <code>JOINTS</code>, and <code>WEIGHTS</code>. Unlike in unshaded materials, writing to these makes sense because the modified values are then taken into account in the rest of the generated shader code (whereas for unshaded materials there is no additional shader code generated). For example, if the custom vertex shader displaces the vertices or the normals, it will want to store the modified values to <code>VERTEX</code> or <code>NORMAL</code>, to achieve correct lighting calculations afterwards. Additionally, the function can write to variables defined with <code>VARYING</code> in order to pass interpolated data to the fragment shader. When this function or a redefinition of <code>POSITION</code> is not present, <code>POSITION</code> is calculated based on <code>VERTEX</code> and <code>MODELVIEWPROJECTION_MATRIX</code>, just like a <a href="qml-qtquick3d-principledmaterial">PrincipledMaterial</a> would do.<p>Example, with relying both on QML properties exposed as uniforms, and also passing data to the fragment shader:</p> <pre data-language="cpp">VARYING vec3 vNormal;
VARYING vec3 vViewVec;

void MAIN()
{
    VERTEX.x += sin(uTime * 4.0 + VERTEX.y) * uAmplitude;
    vNormal = normalize(NORMAL_MATRIX * NORMAL);
    vViewVec = CAMERA_POSITION - (MODEL_MATRIX * vec4(VERTEX, 1.0)).xyz;
    POSITION = MODELVIEWPROJECTION_MATRIX * vec4(VERTEX, 1.0);
}</pre> <div class="admonition note"> <p><b>Note: </b>In the above example, assigning a value to <code>POSITION</code> is optional as the usage in this case is identical to the default behavior.</p> </div> </li> </ul> <h3 id="fragment-shader-snippets-in-a-shaded-custom-material">Fragment shader snippets in a shaded custom material
</h3> <p>The following functions can be implemented in a fragment shader snippet:</p> <ul> <li>
<code>void MAIN()</code> When present, this function is called to set the values of the special writable variables <code>BASE_COLOR</code>, <code>METALNESS</code>, <code>ROUGHNESS</code>, <code>SPECULAR_AMOUNT</code>, NORMAL, and <code>FRESNEL_POWER</code>.<p>One common use case is to set the value of <code>BASE_COLOR</code> based on sampling a texture, be it a base color map, <code>SCREEN_TEXTURE</code>, or some other kind of source. This can be relevant and convenient especially when no custom light processor functions are implemented. Setting <code>BASE_COLOR.a</code> to something other than the default 1.0 allows affecting the final alpha value of the fragment. (note that this will often require also enabling alpha blending in <a href="qml-qtquick3d-custommaterial#sourceBlend-prop">sourceBlend</a> and <a href="qml-qtquick3d-custommaterial#destinationBlend-prop">destinationBlend</a>)</p> <p>Another scenario is when there is no custom <code>SPECULAR_LIGHT</code> function provided, or when there is a light probe set in the <a href="qml-qtquick3d-sceneenvironment">SceneEnvironment</a>. The metalness, roughness, and other values that affect the specular contribution calculation can be set in <code>MAIN</code> to their desired custom values.</p> <p>The function can write to the following special variables. The values written to these will typically be either hardcoded or be calculated based on QML properties mapped to uniforms. The semantics are identical to <a href="qml-qtquick3d-principledmaterial">PrincipledMaterial</a>.</p> <ul> <li>vec4 <code>BASE_COLOR</code> - The base color and material alpha value. Corresponds to the <a href="qml-qtquick3d-principledmaterial#baseColor-prop">built-in materials' color property</a>. When light processor functions are not implemented, it can be convenient to set a custom base color in <code>MAIN</code> because that is then taken into account in the default lighting calculations. The default value is <code>vec4(1.0)</code>, meaning white with an alpha of 1.0. The alpha value effects the final alpha of the fragment. The final alpha value is the object (model) opacity multiplied by the base color alpha. When specifying the value directly in shader code, not relying on uniform values exposed from <b>color</b> properties in QML, be aware that it is up to the shader to perform the sRGB to linear conversion, if needed. For example, assuming a <code>vec3 color</code> and <code>float alpha</code> this can be achieved like the following:<pre data-language="cpp">float C1 = 0.305306011;
vec3 C2 = vec3(0.682171111, 0.682171111, 0.682171111);
vec3 C3 = vec3(0.012522878, 0.012522878, 0.012522878);
BASE_COLOR = vec4(rgb * (rgb * (rgb * C1 + C2) + C3), alpha);</pre> </li> <li>vec3 <code>EMISSIVE_COLOR</code> - The color of self-illumination. Corresponds to the built-in materials' emissive color which is combined by <a href="qml-qtquick3d-principledmaterial#emissiveFactor-prop">built-in materials's emissiveFactor property</a> and <a href="qml-qtquick3d-principledmaterial#emissiveMap-prop">built-in materials's emissiveMap property</a>. The default value is <code>vec3(0.0)</code>. When specifying the value directly in shader code, not relying on uniform values exposed from <b>color</b> properties in QML, be aware that it is up to the shader to perform the sRGB to linear conversion, if needed.</li> <li>float <code>METALNESS</code> Metalness amount in range 0.0 - 1.0. The default value is 0. Must be set to a non-zero value to have effect.</li> <li>float <code>ROUGHNESS</code> Roughness value in range 0.0 - 1.0. The default value is 0.</li> <li>float <code>FRESNEL_POWER</code> Specifies the fresnel power. A typical value, and also the default, is <code>5.0</code> as that is what a <a href="qml-qtquick3d-principledmaterial">PrincipledMaterial</a> would use.</li> <li>float <code>SPECULAR_AMOUNT</code> Specular amount in range 0.0 - 1.0. The default value is <code>0.5</code>, matching <a href="qml-qtquick3d-principledmaterial#specularAmount-prop">PrincipledMaterial::specularAmount</a>. Must be set to a non-zero value to have effect.</li> <li>vec3 <code>NORMAL</code> - The normal that comes from the vertex shader in world space. While this property has the same initial value as <code>VAR_WORLD_NORMAL</code>, only changing the value of <code>NORMAL</code> will have an effect on lighting.</li> <li>vec3 <code>TANGENT</code> - The tanget that comes from the vertex shader in world space. This value is potentially adjusted for double-sidedness.</li> <li>vec3 <code>BINORMAL</code> - The binormal that comes from the vertex shader in world space. This value is potentially adjusted for double-sidedness.</li> <li>vec2 <code>UV0</code> - The first set of texture coordinates from the vertex shader. This property is readonly in the fragment shader.</li> <li>vec2 <code>UV1</code> - The second set of texture coordinates from the vertex shader. This property is readonly in the fragment shader.</li> </ul> <div class="admonition note"> <p><b>Note: </b>Unlike with unshaded materials, the fragment <code>MAIN</code> for a shaded material has no direct control over <code>FRAGCOLOR</code>. Rather, it is the <code>DIFFUSE</code> and <code>SPECULAR</code> values written in the light processor functions that decide what the final fragment color is. When a light processor function is not implemented, the relevant default shading calculations are performed as with a <a href="qml-qtquick3d-principledmaterial">PrincipledMaterial</a>, taking <code>BASE_COLOR</code> and other values from the list above into account.</p> </div> <p>An example of a simple, metallic custom material shader could be the following:</p> <pre data-language="cpp">void MAIN()
{
    METALNESS = 1.0;
    ROUGHNESS = 0.5;
    FRESNEL_POWER = 5.0;
}</pre> <p>Another example, where the base color and alpha are set by sampling a texture:</p> <pre data-language="cpp">VARYING vec2 texcoord;
void MAIN()
{
    BASE_COLOR = texture(uColorMap, texcoord);
}</pre> </li> <li>
<code>void AMBIENT_LIGHT()</code> When present, this function is called once for each fragment. The task of the function is to add the total ambient contribution to a writable special variable <code>DIFFUSE</code>. It can of course choose to calculate a different value, or not touch <code>DIFFUSE</code> at all (to ignore ambient lighting completely). When this function is not present at all, the ambient contribution is calculated normally, like a <a href="qml-qtquick3d-principledmaterial">PrincipledMaterial</a> would do.<p>The function can write to the following special variables:</p> <ul> <li>vec3 <code>DIFFUSE</code> Accumulates the diffuse light contributions, per fragment. The light processor functions will typically add (<code>+=</code>) to it, since overwriting the value would lose the contribution from other lights.</li> </ul> <p>The function can read the following special variables, in addition to the matrix (such as, <code>MODEL_MATRIX</code>) and vector (such as, <code>CAMERA_POSITION</code>) uniforms from the table above:</p> <ul> <li>vec3 <code>TOTAL_AMBIENT_COLOR</code> The total ambient contribution in the scene.</li> </ul> <p>Example:</p> <pre data-language="cpp">void AMBIENT_LIGHT()
{
    DIFFUSE += TOTAL_AMBIENT_COLOR;
}</pre> </li> <li>
<code>void DIRECTIONAL_LIGHT()</code> When present, this function is called for each active directional light in the scene for each fragment. The task of the function is to add the diffuse contribution to a writable special variable <code>DIFFUSE</code>. The function can also choose to do nothing, in which case diffuse contributions from directional lights are ignored. When the function is not present at all, the diffuse contributions from directional lights are accumulated normally, like a <a href="qml-qtquick3d-principledmaterial">PrincipledMaterial</a> would do.<p>The function can write to the following special variables:</p> <ul> <li>vec3 <code>DIFFUSE</code> Accumulates the diffuse light contributions, per fragment. The light processor functions will typically add (<code>+=</code>) to it, since overwriting the value would lose the contribution from other lights.</li> </ul> <p>The function can read the following special variables, in addition to the matrix (such as, <code>MODEL_MATRIX</code>) and vector (such as, <code>CAMERA_POSITION</code>) uniforms from the table above:</p> <ul> <li>vec3 <code>LIGHT_COLOR</code> Diffuse light color.</li> <li>float <code>SHADOW_CONTRIB</code> Shadow contribution, or 1.0 if not shadowed at all or not reciving shadows.</li> <li>vec3 <code>TO_LIGHT_DIR</code> Vector pointing towards the light source.</li> <li>vec3 <code>NORMAL</code> The normal vector in world space.</li> <li>vec4 <code>BASE_COLOR</code> The base color and material alpha value.</li> <li>float <code>METALNESS</code> The Metalness amount.</li> <li>float <code>ROUGHNESS</code> The Roughness amount.</li> </ul> <p>Example:</p> <pre data-language="cpp">void DIRECTIONAL_LIGHT()
{
    DIFFUSE += LIGHT_COLOR * SHADOW_CONTRIB * vec3(max(0.0, dot(normalize(VAR_WORLD_NORMAL), TO_LIGHT_DIR)));
}</pre> </li> <li>
<code>void POINT_LIGHT()</code> When present, this function is called for each active point light in the scene for each fragment. The task of the function is to add the diffuse contribution to a writable special variable <code>DIFFUSE</code>. The function can also choose to do nothing, in which case diffuse contributions from point lights are ignored. When the function is not present at all, the diffuse contributions from point lights are accumulated normally, like a <a href="qml-qtquick3d-principledmaterial">PrincipledMaterial</a> would do.<p>The function can write to the following special variables:</p> <ul> <li>vec3 <code>DIFFUSE</code> Accumulates the diffuse light contributions, per fragment.</li> </ul> <p>The function can read the following special variables, in addition to the matrix (such as, <code>MODEL_MATRIX</code>) and vector (such as, <code>CAMERA_POSITION</code>) uniforms from the table above:</p> <ul> <li>vec3 <code>LIGHT_COLOR</code> Diffuse light color.</li> <li>float <code>LIGHT_ATTENUATION</code> Light attenuation.</li> <li>float <code>SHADOW_CONTRIB</code> Shadow contribution, or 1.0 if not shadowed at all or not reciving shadows.</li> <li>vec3 <code>TO_LIGHT_DIR</code> Vector pointing towards the light source.</li> <li>vec3 <code>NORMAL</code> The normal vector in world space.</li> <li>vec4 <code>BASE_COLOR</code> The base color and material alpha value.</li> <li>float <code>METALNESS</code> The Metalness amount.</li> <li>float <code>ROUGHNESS</code> The Roughness amount.</li> </ul> <p>Example:</p> <pre data-language="cpp">void POINT_LIGHT()
{
    DIFFUSE += LIGHT_COLOR * LIGHT_ATTENUATION * SHADOW_CONTRIB * vec3(max(0.0, dot(normalize(VAR_WORLD_NORMAL), TO_LIGHT_DIR)));
}</pre> </li> <li>
<code>void SPOT_LIGHT()</code> When present, this function is called for each active spot light in the scene for each fragment. The task of the function is to add the diffuse contribution to a writable special variable <code>DIFFUSE</code>. The function can also choose to do nothing, in which case diffuse contributions from spot lights are ignored. When the function is not present at all, the diffuse contributions from spot lights are accumulated normally, like a <a href="qml-qtquick3d-principledmaterial">PrincipledMaterial</a> would do.<p>The function can write to the following special variables:</p> <ul> <li>vec3 <code>DIFFUSE</code> Accumulates the diffuse light contributions, per fragment.</li> </ul> <p>The function can read the following special variables, in addition to the matrix (such as, <code>MODEL_MATRIX</code>) and vector (such as, <code>CAMERA_POSITION</code>) uniforms from the table above:</p> <ul> <li>vec3 <code>LIGHT_COLOR</code> Diffuse light color.</li> <li>float <code>LIGHT_ATTENUATION</code> Light attenuation.</li> <li>float <code>SHADOW_CONTRIB</code> Shadow contribution, or 1.0 if not shadowed at all or not reciving shadows.</li> <li>vec3 <code>TO_LIGHT_DIR</code> Vector pointing towards the light source.</li> <li>float <code>SPOT_FACTOR</code> Spot light factor.</li> <li>vec3 <code>NORMAL</code> The normal vector in world space.</li> <li>vec4 <code>BASE_COLOR</code> The base color and material alpha value.</li> <li>float <code>METALNESS</code> The Metalness amount.</li> <li>float <code>ROUGHNESS</code> The Roughness amount.</li> </ul> <p>Example:</p> <pre data-language="cpp">void SPOT_LIGHT()
{
    DIFFUSE += LIGHT_COLOR * LIGHT_ATTENUATION * SPOT_FACTOR * SHADOW_CONTRIB * vec3(max(0.0, dot(normalize(VAR_WORLD_NORMAL), TO_LIGHT_DIR)));
}</pre> </li> <li>
<code>void SPECULAR_LIGHT()</code> When present, this function is called for each active light in the scene for each fragment. The task of the function is to add the specular contribution to a writable special variable <code>SPECULAR</code>. The function can also choose to do nothing, in which case specular contributions from lights are ignored. When the function is not present at all, the specular contributions from lights are accumulated normally, like a <a href="qml-qtquick3d-principledmaterial">PrincipledMaterial</a> would do.<p>The function can write to the following special variables:</p> <ul> <li>vec3 <code>SPECULAR</code> Accumulates the specular light contributions, per frament. The light processor functions will typically add (<code>+=</code>) to it, since overwriting the value would lose the contribution from other lights.</li> </ul> <p>The function can read the following special variables, in addition to the matrix (such as, <code>MODEL_MATRIX</code>) and vector (such as, <code>CAMERA_POSITION</code>) uniforms from the table above:</p> <ul> <li>vec3 <code>LIGHT_COLOR</code> Specular light color.</li> <li>float <code>LIGHT_ATTENUATION</code> Light attenuation. For directional lights the value is 1.0. For spot lights the value is the same as <code>LIGHT_ATTENUATION * SPOT_FACTOR</code> of <code>void SPOT_LIGHT()</code>.</li> <li>float <code>SHADOW_CONTRIB</code> Shadow contribution, or 1.0 if not shadowed at all or not reciving shadows.</li> <li>vec3 <code>FRESNEL_CONTRIB</code> Fresnel contribution from built in Fresnel calculation.</li> <li>vec3 <code>TO_LIGHT_DIR</code> Vector pointing towards the light source.</li> <li>vec3 <code>NORMAL</code> The normal vector in world space.</li> <li>vec4 <code>BASE_COLOR</code> The base color and material alpha value.</li> <li>float <code>METALNESS</code> The Metalness amount.</li> <li>float <code>ROUGHNESS</code> The Roughness amount.</li> <li>float <code>SPECULAR_AMOUNT</code> The specular amount. This value will be between 0.0 and 1.0 will be the same value set in the custom <code>MAIN</code> function. This value will useful for calculating Fresnel contributions when not using the built-in Fresnel contribution provided by <code>FRESNEL_CONTRIB</code>.</li> </ul> <pre data-language="cpp">void SPECULAR_LIGHT()
{
    vec3 H = normalize(VIEW_VECTOR + TO_LIGHT_DIR);
    float cosAlpha = max(0.0, dot(H, normalize(NORMAL)));
    float shine = pow(cosAlpha, exp2(15.0 * (1.0 - ROUGHNESS) + 1.0) * 0.25);
    SPECULAR += shine * LIGHT_COLOR * FRESNEL_CONTRIB * SHADOW_CONTRIB * LIGHT_ATTENUATION;
}</pre> </li> <li>
<code>void POST_PROCESS()</code> When present, this function is called at the end of the fragment pipeline. The task of the function is to finalize <code>COLOR_SUM</code> with final diffuse, specular and emissive terms. Unlike <code>FRAGCOLOR</code> for a unshaded material, <code>COLOR_SUM</code> will be automatically tonemapped before written to the framebuffer. For debugging purposes it is sometimes useful to output a value that should not be treated as a color. To avoid the tonemapping distorting this value it can be disabled by setting the <a href="qml-qtquick3d-sceneenvironment#tonemapMode-prop">tonemapMode</a> property to <code>TonemapModeNone</code><p>The function can write to the following special variables:</p> <ul> <li>vec4 <code>COLOR_SUM</code> the output from the fragment shader. The default value is vec4(DIFFUSE.rgb + SPECULAR + EMISSIVE, DIFFUSE.a)</li> </ul> <p>The function can read the following special variables.</p> <ul> <li>vec4 <code>DIFFUSE</code> The final diffuse term of the fragment pipeline.</li> <li>vec3 <code>SPECULAR</code> The final specular term of the fragment pipeline.</li> <li>vec3 <code>EMISSIVE</code> The final emissive term of the fragment pipeline.</li> <li>vec2 <code>UV0</code> - The first set of texture coordinates from the vertex shader.</li> <li>vec2 <code>UV1</code> - The second set of texture coordinates from the vertex shader.</li> </ul> <pre data-language="cpp">void POST_PROCESS()
{
    float center_x = textureSize(SCREEN_TEXTURE, 0).x * 0.5;
    if (gl_FragCoord.x &gt; center_x)
        COLOR_SUM = DIFFUSE;
    else
        COLOR_SUM = vec4(EMISSIVE, DIFFUSE.a);
}</pre> </li> </ul> <h3 id="custom-variables-between-functions">Custom variables between functions
</h3> <p>Additional variables can be delivered from the MAIN function to the others. The <code>SHARED_VARS</code> keyword can be used for defining new custom variables. These user-defined variables can be accessed with SHARED.&lt;variable name&gt;.</p> <p>For example, a shaded custom material can fetch a shared value in the MAIN and use it in other functions.</p> <pre data-language="cpp">SHARED_VARS {
    vec3 colorThreshold;
};
void MAIN()
{
    BASE_COLOR = texture(baseColorMap, UV0);
    SHARED.colorThreshold = texture(thresholdMap, UV0).rgb;
}
void DIRECTIONAL_LIGHT()
{
    if (DIFFUSE &gt;= SHARED.colorThreshold) {
        DIFFUSE = SHARED.colorThreshold;
        return;
    }
    DIFFUSE += LIGHT_COLOR * SHADOW_CONTRIB;
}</pre> <div class="admonition note"> <p><b>Note: </b>SHARED can be written on all the functions without POST_PROCESS but it is safe to write it on MAIN and read on the other functions.</p> </div> <div class="admonition note"> <p><b>Note: </b>A recommended use case to write SHARED on LIGHT functions is reseting it on MAIN first and then accumulating it on each LIGHT functions.</p> </div> <pre data-language="cpp">SHARED_VARS {
    float sheenIntensity;
    float sheenRoughness;
    vec3 sheenColor;
    vec3 outSheenColor;
};
void MAIN()
{
    ...
    vec4 tex = texture(uSheenMap, UV0);
    SHARED.sheenColor = tex.rgb;
    SHARED.sheenIntensity = tex.a;
    SHARED.sheenRoughness = uSheenRoughness;
    SHARED.outSheenColor = vec3(0.0);
}
void SPECULAR_LIGHT()
{
    SHARED.outSheenColor += ...;
}
void POST_PROCESS()
{
    COLOR_SUM = DIFFUSE + SPECULAR + EMISSIVE + SHARED.outSheenColor;
}</pre> <div class="admonition note"> <p><b>Note: </b>MAIN is called before others, and POST_PROCESS after all others, but that there is no guarantee for any other ordering for light processors.</p> </div> <h3 id="additional-special-keywords">Additional special keywords
</h3> <p>The custom fragment shader code can freely access uniforms (such as, <code>CAMERA_DIRECTION</code> or <code>CAMERA_POSITION</code>), and varyings passed on from the custom vertex shader. Additionally, there are a number of built-in varyings available as special keywords. Some of these are optional in the sense that a vertex <code>MAIN</code> could calculate and pass on these on its own, but to reduce duplicated data fragment shaders can also rely on these built-ins instead. These built-ins are available in light processor functions and in the fragment MAIN.</p> <ul> <li>vec3 <code>VAR_WORLD_NORMAL</code> - Interpolated normal transformed by <code>NORMAL_MATRIX</code>.</li> <li>vec3 <code>VAR_WORLD_TANGENT</code> - Interpolated tangent transformed by <code>MODEL_MATRIX</code>.</li> <li>vec3 <code>VAR_WORLD_BINORMAL</code> - Interpolated binormal transformed by <code>MODEL_MATRIX</code>
</li> <li>vec3 <code>NORMAL</code> - Unlike <code>VAR_WORLD_NORMAL</code>, which is the interpolated normal as-is, this value is potentially adjusted for double-sidedness: when rendering with culling disabled, the normal will get inverted as necessary. Therefore lighting and other calculations are recommended to use <code>NORMAL</code> instead of <code>VAR_WORLD_NORMAL</code> in order behave correctly with all culling modes.</li> <li>vec3 <code>TANGENT</code> - Like <code>NORMAL</code>, this value is potentially adjusted for double-sidedness: when rendering with culling disabled, the tangent will get inverted as necessary.</li> <li>vec3 <code>BINORMAL</code> - Like <code>NORMAL</code>, this value is potentially adjusted for double-sidedness: when rendering with culling disabled, the binormal will get inverted as necessary.</li> <li>vec3 <code>VAR_WORLD_POSITION</code> - Interpolated world space vertex position (<code>(MODEL_MATRIX * vec4(VERTEX, 1.0)).xyz</code>)</li> <li>vec4 <code>VAR_COLOR</code> - The interpolated vertex color when colors are provided in the mesh. <code>vec4(1.0)</code> otherwise.</li> <li>vec3 <code>VIEW_VECTOR</code> - Points towards the camera. This is effectively the <code>CAMERA_POSITION - VAR_WORLD_POSITION</code> vector normalized.</li> <li>vec4 <code>FRAGCOORD</code> - Contains the window-relative coordinates of the current fragment.</li> <li>float <code>FRAMEBUFFER_Y_UP</code> - The value is <code>1</code> when the Y axis points up in the coordinate system for framebuffers (textures), meaning <code>(0, 0)</code> is the bottom-left corner. The value is <code>-1</code> when the Y axis points down, <code>(0, 0)</code> being the top-left corner. Such differences in the underlying graphics APIs do not concern most custom materials. One notable exception is sampling <code>SCREEN_TEXTURE</code> with texture coordinates <b>not</b> based on <code>FRAGCOORD</code>. As the orientation of <code>SCREEN_TEXTURE</code> is tied to the underlying graphics API by nature, using texture coordinates from a mesh may need appropriate adjustments to the Y coordinate.<p>For example, the following fragment shader, suitable for Rectangle or Cube meshes, will display the opaque objects from the scene on the model:</p> <pre data-language="cpp">VARYING vec2 texcoord;
void MAIN()
{
    vec2 screencoord = texcoord;
    if (FRAMEBUFFER_Y_UP &lt; 0.0) // effectively: if not OpenGL
        screencoord.y = 1.0 - screencoord.y;
    BASE_COLOR = texture(SCREEN_TEXTURE, screencoord);
}</pre> <p>When sampling textures other than <code>SCREEN_TEXTURE</code> and <code>DEPTH_TEXTURE</code>, or when <code>FRAGCOORD</code> is used to calculate the texture coordinate (which would be the typical use case for accessing the screen and depth textures), such an adjustment is not necessary.</p> </li> <li>float <code>NDC_Y_UP</code> - The value is <code>1</code> when the Y axis points up in normalized device coordinate space, and <code>-1</code> when the Y axis points down. Y pointing down is the case when rendering happens with Vulkan. Most materials do not need to be concerned by this, but being able to branch based on this can become useful in certain advanced use cases.</li> <li>float <code>NEAR_CLIP_VALUE</code> - The value is <code>-1</code> for when the clipping plane range's starts at <code>-1</code> and goes to <code>1</code>. This is true when using OpenGL for rendering. For other rendering backends the value of this property will be <code>0</code> meaning the clipping plane range is <code>0</code> to <code>1</code>. This value is useful with certain techniques involving the <code>DEPTH_TEXTURE</code><p>For example, the following fragment shader demonstrates a technique for reconstructing the position of a value from the depth buffer to determine the distance from the current position being rendered. When used in combination with <code>INVERSE_PROJECTION_MATRIX</code> the value of depth needs to be in normalized device coordinates so it is important to make sure that the range of depth value reflects that. When the <code>NEAR_CLIP_VALUE</code> is <code>-1</code> then the depth value gets scaled to be between <code>-1</code> and <code>1</code>.</p> <pre data-language="cpp">void MAIN() {
    vec2 screen_uv = FRAGCOORD.xy / vec2(textureSize(SCREEN_TEXTURE, 0));
    float depth = texture(DEPTH_TEXTURE, screen_uv).r;

    if (NEAR_CLIP_VALUE &lt; 0.0) // effectively: if opengl
        depth = depth * 2.0 - 1.0;

    vec4 unproject = INVERSE_PROJECTION_MATRIX * vec4(screen_uv, depth, 1.0);
    depth = (unproject.xyz / unproject.w).z;
    float viewVectorZ = (VIEW_MATRIX * vec4(VAR_WORLD_POSITION, 1.0)).z;
    depth = viewVectorZ - depth;

    BASE_COLOR = vec4(depth, depth, depth, 1.0);
}</pre> </li> </ul> <h3 id="instancing">Instancing
</h3> <p>When doing instanced rendering, some of the keywords above do not apply. The following keywords are only available with instancing:</p> <ul> <li>
<code>INSTANCE_MODEL_MATRIX</code> -&gt; mat4, replacement for <code>MODEL_MATRIX</code>, including the instancing transformation.</li> <li>
<code>INSTANCE_MODELVIEWPROJECTION_MATRIX</code> -&gt; mat4, replacement for <code>MODELVIEWPROJECTION_MATRIX</code>, including the instancing transformation.</li> <li>
<code>INSTANCE_COLOR</code> -&gt; vec4, the instance color: to be combined with <code>COLOR</code>.</li> <li>
<code>INSTANCE_DATA</code> -&gt; vec4, instance custom data.</li> <li>
<code>INSTANCE_INDEX</code> -&gt; int, the instance number, and index into the instancing table.</li> </ul> <h2 id="screen-depth-and-other-textures">Screen, depth, and other textures
</h2> <p>The rendering pipeline can expose a number of textures to the custom material shaders with content from special render passes. This applies both to shaded and unshaded custom materials.</p> <p>For example, a shader may want access to a depth texture that contains the depth buffer contents for the opaque objects in the scene. This is achieved by sampling <code>DEPTH_TEXTURE</code>. Such a texture is not normally generated, unless there is a real need for it. Therefore, the presence of the following keywords in the vertex or fragment shader also acts as a toggle for opting in to the - potentially expensive - passes for generating the texture in question. (of course, it could be that some of these become already enabled due to other settings, such as the ambient occlusion parameters in <a href="qml-qtquick3d-sceneenvironment">SceneEnvironment</a> or due to a post-processing effect relying on the depth texture, in which case the textures in question are generated regardless of the custom material and so sampling these special textures in the material comes at no extra cost apart from the texture access itself)</p> <ul> <li>
<code>SCREEN_TEXTURE</code> - When present, a texture (sampler2D) with the color buffer from a rendering pass containing the opaque objects in the scene is exposed to the shader under this name. This also implies that any object with a custom material where the shaders sample <code>SCREEN_TEXTURE</code> will be treated as if it had semi-transparency enabled on it, even when the object opacity is 1.0 and blending was not enabled on the CustomMaterial. This is because such an object cannot be part of the opaque rendering lists, because it itself depends on the rendering results of those objects and thus cannot be rendered in line together with those. Pixels that are not covered by opaque objects will be set to transparent (<code>vec4(0.0)</code>) in the texture. For example, a fragment shader could contain the following:<pre data-language="cpp">vec2 uv = FRAGCOORD.xy / vec2(textureSize(SCREEN_TEXTURE, 0));
vec2 displace = vec2(0.1);
vec4 c = texture(SCREEN_TEXTURE, uv + displace);</pre> <p>Be aware that using <code>SCREEN_TEXTURE</code> requires appropriate, conscious design of the scene. Objects using such materials have to be positioned carefully, typically above all other objects that are expected to be visible in the texture. Objects that employ semi-transparency in some form are never part of the <code>SCREEN_TEXTURE</code>. Often <code>SCREEN_TEXTURE</code> will be used in combination with <code>BASE_COLOR</code> in <code>MAIN</code>. For example, the following custom fragment shader applies an emboss effect, while keeping fragments not touched by opaque objects transparent. This assumes that the object with the material is placed in the front, and that it has blending enabled.</p> <pre data-language="cpp">void MAIN()
{
    vec2 size = vec2(textureSize(SCREEN_TEXTURE, 0));
    vec2 uv = FRAGCOORD.xy / size;

    // basic emboss effect
    vec2 d = vec2(1.0 / size.x, 1.0 / size.y);
    vec4 diff = texture(SCREEN_TEXTURE, uv + d) - texture(SCREEN_TEXTURE, uv - d);
    float c = (diff.x + diff.y + diff.z) + 0.5;

    float alpha = texture(SCREEN_TEXTURE, uv).a;
    BASE_COLOR = vec4(vec3(c), alpha);
}</pre> </li> <li>
<code>SCREEN_MIP_TEXTURE</code> - Identical to <code>SCREEN_TEXTURE</code> in most ways, the difference being that this texture has mipmaps generated. This can be an expensive feature performance-wise, depending on the screen size, and due to having to generate the mipmaps every time the scene is rendered. Therefore, prefer using <code>SCREEN_TEXTURE</code> always, unless a technique relying on the texture mip levels (e.g. using <code>textureLod</code> in the shader) is implemented by the custom material.</li> <li>
<code>DEPTH_TEXTURE</code> - When present, a texture (sampler2D) with the (non-linearized) depth buffer contents is exposed to the shader under this name. Only opaque objects are included. For example, a fragment shader could contain the following:<pre data-language="cpp">ivec2 dtSize = textureSize(DEPTH_TEXTURE, 0);
vec2 dtUV = (FRAGCOORD.xy) / vec2(dtSize);
vec4 depthSample = texture(DEPTH_TEXTURE, dtUV);
float zNear = CAMERA_PROPERTIES.x;
float zFar = CAMERA_PROPERTIES.y;
float zRange = zFar - zNear;
float z_n = 2.0 * depthSample.r - 1.0;
float d = 2.0 * zNear * zFar / (zFar + zNear - z_n * zRange);
d /= zFar;</pre> </li> <li>
<code>AO_TEXTURE</code> - When present and screen space ambient occlusion is enabled (meaning when the AO strength and distance are both non-zero) in <a href="qml-qtquick3d-sceneenvironment">SceneEnvironment</a>, the SSAO texture (sampler2D) is exposed to the shader under this name. Sampling this texture can be useful in unshaded materials. Shaded materials have ambient occlusion support built in. This means that the ambient occlusion factor is taken into account automatically. Whereas in a fragment shader for an unshaded material one could write the following to achieve the same:<pre data-language="cpp">ivec2 aoSize = textureSize(AO_TEXTURE, 0);
vec2 aoUV = (FRAGCOORD.xy) / vec2(aoSize);
float aoFactor = texture(AO_TEXTURE, aoUV).x;</pre> </li> </ul> <p><b>See also </b><a href="qml-qtquick3d-sceneenvironment#tonemapMode-prop">SceneEnvironment::tonemapMode</a>, <a href="https://doc.qt.io/qt-6.2/qtquick3d-customshaders-example.html">Qt Quick 3D - Custom Shaders Example</a>, <a href="https://doc.qt.io/qt-6.2/qtquick3d-custommaterial-example.html">Qt Quick 3D - Custom Materials Example</a>, and <a href="qtquick3d-custom">Programmable Materials, Effects, Geometry, and Texture data</a>.</p>  <h2>Property Documentation</h2>  <h3 class="qmlproto" id="alwaysDirty-prop"></h3>
<p> <span class="name">alwaysDirty</span> : <span class="type"><a href="qml-bool">bool</a></span></p> <p>Specifies that the material state is always dirty, which indicates that the material needs to be refreshed every time it is used by the <a href="https://doc.qt.io/qt-6.2/qtquick3d-qmlmodule.html">QtQuick3D</a>.</p>    <h3 class="qmlproto" id="destinationBlend-prop"></h3>
<p> <span class="name">destinationBlend</span> : <span class="type"><a href="qml-enumeration">enumeration</a></span></p> <p>Specifies the destination blend factor. The default value is <code>CustomMaterial.NoBlend</code>.</p> <table class="valuelist">
<tr>
<th class="tblConst">Constant</th>
<th class="tblVal">Value</th>
</tr> <tr><td class="topAlign"><code>CustomMaterial.NoBlend</code></td></tr> <tr><td class="topAlign"><code>CustomMaterial.Zero</code></td></tr> <tr><td class="topAlign"><code>CustomMaterial.One</code></td></tr> <tr><td class="topAlign"><code>CustomMaterial.SrcColor</code></td></tr> <tr><td class="topAlign"><code>CustomMaterial.OneMinusSrcColor</code></td></tr> <tr><td class="topAlign"><code>CustomMaterial.DstColor</code></td></tr> <tr><td class="topAlign"><code>CustomMaterial.OneMinusDstColor</code></td></tr> <tr><td class="topAlign"><code>CustomMaterial.SrcAlpha</code></td></tr> <tr><td class="topAlign"><code>CustomMaterial.OneMinusSrcAlpha</code></td></tr> <tr><td class="topAlign"><code>CustomMaterial.DstAlpha</code></td></tr> <tr><td class="topAlign"><code>CustomMaterial.OneMinusDstAlpha</code></td></tr> <tr><td class="topAlign"><code>CustomMaterial.ConstantColor</code></td></tr> <tr><td class="topAlign"><code>CustomMaterial.OneMinusConstantColor</code></td></tr> <tr><td class="topAlign"><code>CustomMaterial.ConstantAlpha</code></td></tr> <tr><td class="topAlign"><code>CustomMaterial.OneMinusConstantAlpha</code></td></tr> <tr><td class="topAlign"><code>CustomMaterial.SrcAlphaSaturate</code></td></tr> </table>    <h3 class="qmlproto" id="fragmentShader-prop"></h3>
<p> <span class="name">fragmentShader</span> : <span class="type"><a href="qml-url">url</a></span></p> <p>Specfies the file with the snippet of custom fragment shader code.</p> <p>The value is a URL and must either be a local file or use the qrc scheme to access files embedded via the Qt resource system. Relative file paths (without a scheme) are also accepted, in which case the file is treated as relative to the component (the <code>.qml</code> file).</p> <p><b>See also </b><a href="qml-qtquick3d-custommaterial#vertexShader-prop">vertexShader</a>.</p>    <h3 class="qmlproto" id="lineWidth-prop"></h3>
<p> <span class="name">lineWidth</span> : <span class="type"><a href="qml-real">real</a></span></p> <p>This property determines the width of the lines rendered, when the geometry is using a primitive type of lines or line strips. The default value is 1.0. This property is not relevant when rendering other types of geometry, such as, triangle meshes.</p> <div class="admonition warning"> <p><b>Warning: </b>Line widths other than 1 may not be suported at run time, depending on the underlying graphics API. When that is the case, the request to change the width is ignored. For example, none of the following can be expected to support wide lines: Direct3D, Metal, OpenGL with core profile contexts.</p> </div> <div class="admonition note"> <p><b>Note: </b>Unlike the line width, the value of which is part of the graphics pipeline object, the point size for geometries with a topology of points is controlled by the vertex shader (when supported), and has therefore no corresponding QML property.</p> </div>    <h3 class="qmlproto" id="shadingMode-prop"></h3>
<p> <span class="name">shadingMode</span> : <span class="type"><a href="qml-enumeration">enumeration</a></span></p> <p>Specifies the type of the material. The default value is Shaded.</p> <table class="valuelist">
<tr>
<th class="tblConst">Constant</th>
<th class="tblVal">Value</th>
</tr> <tr><td class="topAlign"><code>CustomMaterial.Unshaded</code></td></tr> <tr><td class="topAlign"><code>CustomMaterial.Shaded</code></td></tr> </table>    <h3 class="qmlproto" id="sourceBlend-prop"></h3>
<p> <span class="name">sourceBlend</span> : <span class="type"><a href="qml-enumeration">enumeration</a></span></p> <p>Specifies the source blend factor. The default value is <code>CustomMaterial.NoBlend</code>.</p> <table class="valuelist">
<tr>
<th class="tblConst">Constant</th>
<th class="tblVal">Value</th>
</tr> <tr><td class="topAlign"><code>CustomMaterial.NoBlend</code></td></tr> <tr><td class="topAlign"><code>CustomMaterial.Zero</code></td></tr> <tr><td class="topAlign"><code>CustomMaterial.One</code></td></tr> <tr><td class="topAlign"><code>CustomMaterial.SrcColor</code></td></tr> <tr><td class="topAlign"><code>CustomMaterial.OneMinusSrcColor</code></td></tr> <tr><td class="topAlign"><code>CustomMaterial.DstColor</code></td></tr> <tr><td class="topAlign"><code>CustomMaterial.OneMinusDstColor</code></td></tr> <tr><td class="topAlign"><code>CustomMaterial.SrcAlpha</code></td></tr> <tr><td class="topAlign"><code>CustomMaterial.OneMinusSrcAlpha</code></td></tr> <tr><td class="topAlign"><code>CustomMaterial.DstAlpha</code></td></tr> <tr><td class="topAlign"><code>CustomMaterial.OneMinusDstAlpha</code></td></tr> <tr><td class="topAlign"><code>CustomMaterial.ConstantColor</code></td></tr> <tr><td class="topAlign"><code>CustomMaterial.OneMinusConstantColor</code></td></tr> <tr><td class="topAlign"><code>CustomMaterial.ConstantAlpha</code></td></tr> <tr><td class="topAlign"><code>CustomMaterial.OneMinusConstantAlpha</code></td></tr> <tr><td class="topAlign"><code>CustomMaterial.SrcAlphaSaturate</code></td></tr> </table>    <h3 class="qmlproto" id="vertexShader-prop"></h3>
<p> <span class="name">vertexShader</span> : <span class="type"><a href="qml-url">url</a></span></p> <p>Specfies the file with the snippet of custom vertex shader code.</p> <p>The value is a URL and must either be a local file or use the qrc scheme to access files embedded via the Qt resource system. Relative file paths (without a scheme) are also accepted, in which case the file is treated as relative to the component (the <code>.qml</code> file).</p> <p><b>See also </b><a href="qml-qtquick3d-custommaterial#fragmentShader-prop">fragmentShader</a>.</p>
<div class="_attribution">
  <p class="_attribution-p">
     The Qt Company Ltd<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://doc.qt.io/qt-6.2/qml-qtquick3d-custommaterial.html" class="_attribution-link">https://doc.qt.io/qt-6.2/qml-qtquick3d-custommaterial.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
