
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Changes to Qt Core - Qt - W3cubDocs</title>
  
  <meta name="description" content=" Qt 6 is a result of the conscious effort to make the framework more efficient and easy to use. ">
  <meta name="keywords" content="changes, qt, core">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/qt/qtcore-changes-qt6.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/qt.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/qt/" class="_nav-link" title="" style="margin-left:0;">Qt</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _qt">
				
				
<h1 class="title">Changes to Qt Core</h1>   <p>Qt 6 is a result of the conscious effort to make the framework more efficient and easy to use.</p> <p>We try to maintain binary and source compatibility for all the public APIs in each release. But some changes were inevitable in an effort to make Qt a better framework.</p> <p>In this topic we summarize those changes in Qt Core, and provide guidance to handle them.</p> <h2 id="container-classes">Container Classes
</h2> <h3 id="qhash-qmultihash-qset">QHash, QMultiHash, QSet
</h3> <h4 id="qhash-signature">qHash() Signature
</h4> <p>For custom types, <a href="qhash#qhash">QHash</a> and <a href="qmultihash">QMultiHash</a> rely on you providing a <a href="qhash#qhash">custom qHash() function</a> in the same namespace. In Qt 4 and Qt 5, the return value and optional second argument of a <code>qHash</code> function was of type <code>uint</code>. In Qt 6, it is <code>size_t</code>.</p> <p>That is, you need to change</p> <pre data-language="cpp">uint qHash(MyType x, uint seed);</pre> <p>to</p> <pre data-language="cpp">size_t qHash(MyType x, size_t seed);</pre> <p>This allows <a href="qhash#qhash">QHash</a>, <a href="qmultihash">QMultiHash</a> and <a href="qset">QSet</a> to hold more than 2^32 items on 64 bit platforms.</p> <h4 id="stability-of-references">Stability of References
</h4> <p>The implementation of <a href="qhash#qhash">QHash</a>, <a href="qmultihash">QMultiHash</a> and <a href="qset">QSet</a> in Qt 6 got changed from a node based approach to a two stage lookup table. This design allows to keep the memory overhead of a hash instance very small, while at the same time giving good performance.</p> <p>One behavioral change to note is that the new implementation will not provide stable references to elements in the hash when the table needs to grow, or when entries are removed. Applications that rely on such stability might now run into undefined behavior.</p> <h4 id="removal-of-qhash-insertmulti">Removal of QHash::insertMulti
</h4> <p>In Qt 5, <a href="qhash#qhash">QHash</a> could be used to create multi-valued hashes by using QHash::insertMulti, and <a href="qmultihash">QMultiHash</a> was deriving vom <a href="qhash#qhash">QHash</a>.</p> <p>In Qt 6, both types and use cases are distinct, and QHash::insertMulti got removed.</p> <h3 id="qvector-qlist">QVector, QList
</h3> <p>Prior to Qt 6, <a href="qvector">QVector</a> and <a href="qlist">QList</a> were separate classes. In Qt 6, they are unified: Qt 5 <a href="qlist">QList</a> implementation is gone and both classes use updated <a href="qvector">QVector</a> implementation instead. <a href="qlist">QList</a> is the class with the actual implementation and <a href="qvector">QVector</a> is an alias (typedef) to <a href="qlist">QList</a>.</p> <p><a href="qlist">QList</a>'s fromVector() and toVector(), and <a href="qvector">QVector</a>'s fromList() and toList(), no longer involve data copying in Qt 6. They now return the object that they were called for.</p> <h4 id="api-changes">API Changes
</h4> <p><a href="qlist">QList</a>'s (and hence <a href="qvector">QVector</a>'s) size type is changed from <code>int</code> to <code>qsizetype</code>. Together with the size type, all relevant methods' signatures are updated to use <code>qsizetype</code>. This allows <a href="qlist">QList</a> to hold more than 2^31 items on 64 bit platforms.</p> <p>When upgrading the code base to Qt 6, this API change would most likely result in compiler warnings about narrowing type conversions. Having the following example code:</p> <pre data-language="cpp">void myFunction(QList&lt;MyType&gt; &amp;data) {
    int size = data.size();
    // ...
    const int pos = getInsertPosition(size);
    data.insert(pos, MyType());
    // ...
}</pre> <p>you would need to update it to use either <code>qsizetype</code> or an auto keyword:</p> <pre data-language="cpp">void myFunction(QList&lt;MyType&gt; &amp;data) {
    auto size = data.size();
    // ...
    const auto pos = getInsertPosition(size);
    data.insert(pos, MyType());
    // ...
}</pre> <p>Alternatively, you may use type casting and cast everything to <code>int</code> or to <code>qsizetype</code>.</p> <div class="admonition note"> <p><b>Note: </b>If you want to build against both Qt 5 and Qt 6, the auto keyword is a good solution to cover signature differences between the versions.</p> </div> <h4 id="memory-layout">Memory Layout
</h4> <p><a href="qlist">QList</a> received multiple changes related to the memory layout in Qt 6.</p> <p>In Qt 5, <code>sizeof(QList&lt;T&gt;)</code> was equal to a size of a pointer. Now, the extra pointer indirection is removed and <a href="qlist">QList</a> data members are directly stored in the object. By default, expect <code>sizeof(QList&lt;T&gt;)</code> to be equal to the size of 3 pointers.</p> <p>At the same time, memory layout of the elements is also updated. <a href="qlist">QList</a> now always stores its elements directly in the allocated memory region as opposed to Qt 5, where certain objects were separately allocated on the heap and pointers to the objects were placed into the <a href="qlist">QList</a> instead.</p> <p>Note that the latter, in particular, affects large objects. To have Qt 5 behavior, you could wrap your objects into smart pointers and store these smart pointers in <a href="qlist">QList</a> directly. In this case, the type of your <a href="qlist">QList</a> would be <code>QList&lt;MySmartPointer&lt;MyLargeObject&gt;&gt;</code> as opposed to <code>QList&lt;MyLargeObject&gt;</code> in Qt 5.</p> <h4 id="stability-of-references">Stability of References
</h4> <p>There are several changes made to the <a href="qvector">QVector</a>/<a href="qlist">QList</a> implementation. The <a href="qvector">QVector</a> related one is: insertion at the beginning is optimized (similarly to <a href="qlist">QList</a> in Qt 5). The <a href="qlist">QList</a> related one is: memory layout for the elements is simplified.</p> <div class="admonition important"> <p><b>Important: </b>These changes impact the stability of references. In Qt 6, you should consider any size or capacity modifying method to invalidate all references, even when <a href="qlist">QList</a> is not <a href="implicit-sharing">implicitly shared</a>. Exceptions to this rule are documented explicitly.</p> </div> <p>Applications that rely on certain reference stability might run into undefined behavior when upgraded to use Qt 6. You should pay extra attention to cases where <a href="qvector">QVector</a> or <a href="qlist">QList</a> with a non C-compatible array layout were used originally.</p> <h2 id="view-classes-in-qt6">View classes in Qt6
</h2> <h3 id="general-overview">General Overview
</h3> <p>There are several new <code>View</code> classes coming with Qt6. There is the already existing <a href="qstringview">QStringView</a>, now accompanied by <a href="qbytearrayview">QByteArrayView</a> and followed by a specialized <a href="qutf8stringview">QUtf8StringView</a> and a more universal <a href="qanystringview">QAnyStringView</a>.</p> <h3 id="introduction-to-view-classes-on-the-example-of-qstringview">Introduction to view classes on the example of QStringView
</h3> <p>The <a href="qstringview">QStringView</a> class provides a unified view on UTF-16 strings with a read-only subset of the <a href="qstring">QString</a> API. Unlike <a href="qstring">QString</a>, which keeps its own copy of the string (possibly ref-counted), <a href="qstringview">QStringView</a> provides a view of a string that is stored elsewhere.</p> <pre data-language="cpp">char hello[]{ "Hello." };   // narrow multi-byte string literal
QString str{hello};         // needs to make a copy of the string literal
QString strToStr(str);      // atomic increment involved to not create a copy of hello again

// The above code can be re-written to avoid copying and atomic increment.

QStringView view{ u"Hello." };  // view to UTF-16 encoded string literal
QStringView viewToView{ view }; // view of the same UTF-16 encoded string literal</pre> <p>The string <code>"Hello."</code> is stored in the binary and is not allocated at run-time. <code>view</code> is only a view onto the string <code>"Hello."</code>, therefore no copy has to be created. When we copy a <a href="qstringview">QStringView</a>, the <code>viewToView</code> observes the same string as the copied-from <code>view</code> is observing. This means that <code>viewToView</code> does not need to create a copy or an atomic increment. They are views onto the existing string <code>"Hello."</code>.</p> <h3 id="views-as-function-argument">Views as function argument
</h3> <p>Views should be passed by value, not by reference-to-const.</p> <pre data-language="cpp">void myfun1(QStringView sv);        // preferred
void myfun2(const QStringView &amp;sv); // compiles and works, but slower</pre> <h3 id="view-manipulation-functions">View manipulation functions
</h3> <p><a href="qstringview">QStringView</a> supports functions that let us manipulate the view of the string. This allows us to change the view without creating a partial copy of the viewed string.</p> <pre data-language="cpp">QString pineapple = "Pineapple";
QString pine = pineapple.left(4);

// The above code can be re-written to avoid creating a partial copy.

QStringView pineappleView{ pineapple };
QStringView pineView = pineappleView.left(4);</pre> <h3 id="non-null-terminated-strings-and-strings-containing-char-0-char">Non null-terminated strings and strings containing <code>'\0'</code>
</h3> <p><a href="qstringview">QStringView</a> supports both null-terminated and non null-terminated strings. The difference comes from the way you initialize the <a href="qstringview">QStringView</a>:</p> <pre data-language="cpp">QChar aToE[]{ 'a', 'b', 'c', 'd', 'e' };

QStringView nonNull{ aToE, std::size(aToE) }; // with length given
QStringView nonNull{ aToE }; // automatically determines the length

QChar fToJ[]{ 'f', 'g', 'h', '\0', 'j' };

// uses given length, doesn't search for '\0', so '\0' at position 3
// is considered to be a part of the string similarly to 'h' and 'j
QStringView nonNull{ fToJ, std::size(fToJ) };
QStringView part{ fToJ }; //stops on the first encounter of '\0'</pre> <h3 id="ownership-model-of-views">Ownership model of views
</h3> <p>As <code>views</code> do not own the memory they reference, care must be taken to ensure that the referenced data (for example, owned by a <a href="qstring">QString</a>) outlives the <code>view</code> on all code paths.</p> <pre data-language="cpp">QStringView sayHello()
{
    QString hello("Hello.");
    return QStringView{ hello }; // hello gets out of scope and destroyed
}

void main()
{
    QStringView hello{ sayHello() };
    qDebug() &lt;&lt; hello; // undefined behavior
}</pre> <h3 id="converting-an-qstringview-to-qstring">Converting an QStringView to QString
</h3> <p><a href="qstringview">QStringView</a> will not implicitly or explicitly convert to a <a href="qstring">QString</a>, but can create a deep copy of its data:</p> <pre data-language="cpp">void print(const QString &amp;s) { qDebug() &lt;&lt; s; }

void main()
{
    QStringView string{ u"string"};

    // print(string); // invalid, no implicit conversion
    // QString str{ string }; // invalid, no explicit conversion

    print(string.toString());
    QString str = string.toString(); // create QString from view
}</pre> <h3 id="important-notes">Important notes
</h3> <p>By leveraging the new view classes, one can achieve a lot of performance boost in many use cases. However, it is important to know that there might be some caveats. Therefore it is important to remember:</p> <ul> <li>Views should be passed by value, not by reference-to-const.</li> <li>Constructing a view with a negative length is undefined behavior.</li> <li>Care must be taken to ensure that the referenced data (for example, owned by a <a href="qstring">QString</a>) outlives the view on all code paths.</li> </ul> <h2 id="string-related-classes">String related classes
</h2> <h3 id="the-qstringview-class">The QStringView class
</h3> <p>Starting with Qt6 it is generally recommended to use <a href="qstringview">QStringView</a> over <code>QStringRef</code>. <a href="qstringview">QStringView</a> references a contiguous portion of a UTF-16 string it does not own. It acts as an interface type to all kinds of UTF-16 strings, without the need to construct a <a href="qstring">QString</a> first. The <a href="qstringview">QStringView</a> class exposes almost all read-only methods of <a href="qstring">QString</a> and the previously existing <code>QStringRef</code> class.</p> <div class="admonition note"> <p><b>Note: </b>Care must be taken to ensure that the referenced string data (for example, owned by a <a href="qstring">QString</a>) outlives the <a href="qstringview">QStringView</a> on all code paths.</p> </div> <div class="admonition note"> <p><b>Note: </b>If a <a href="qstringview">QStringView</a> wraps a <a href="qstring">QString</a>, care needs to be taken since unlike <code>QStringRef</code> <a href="qstringview">QStringView</a> will not update the internal data pointer once the <a href="qstring">QString</a> data relocates.</p> </div> <pre data-language="cpp">QString string = ...;
QStringView view{string};

// Appending something very long might cause a relocation and will
// ultimately result in a garbled QStringView.
string += ...;</pre> <h3 id="the-qstringref-class">The QStringRef class
</h3> <p>In Qt6 <a href="qstringref">QStringRef</a> got removed from Qt Core. To ease porting of existing applications without touching the whole code-base, the <code>QStringRef</code> class did not vanish completely and instead it got moved into the Qt5Compat module.</p> <p>If you want to use <code>QStringRef</code> further, you need to link against the new Qt5Compat module and add this line to your <a href="resources#qmake">qmake</a> <code>.pro</code> file:</p> <pre data-language="cpp">QT += core5compat</pre> <p>In case you already ported your application or library to the <a href="cmake-manual">cmake</a> build system, add the following to your <code>CMakeList.txt</code>:</p> <pre data-language="cpp">PUBLIC_LIBRARIES
    Qt::Core5Compat</pre> <p>Unfortunately, some methods exposed by <a href="qstring">QString</a> returning a <code>QStringRef</code>, could not be moved to Qt5Compat. Therefore some manually porting may be needed. If your code uses one or more of the following functions you need to port them to use <a href="qstringview">QStringView</a> or <a href="qstringtokenizer">QStringTokenizer</a>. It is also recommended to use <a href="qstringview#tokenize">QStringView::tokenize</a> over <a href="qstringview#split">QStringView::split</a> for performance critical code.</p> <p>Change code using <code>QStringRef</code>:</p> <pre data-language="cpp">QString string = ...;
QStringRef left = string.leftRef(n);
QStringRef mid = string.midRef(n);
QStringRef right = string.rightRef(n);

QString value = ...;
const QVector&lt;QStringRef&gt; refs = string.splitRef(' ');
if (refs.contains(value))
    return true;</pre> <p>to:</p> <pre data-language="cpp">QString string = ...;
QStringView left = QStringView{string}.left(n);
QStringView mid = QStringView{string}.mid(n);
QStringView right = QStringView{string}.right(n);

QString value = ...;
const QList&lt;QStringView&gt; refs = QStringView{string}.split(u' ');
if (refs.contains(QStringView{value}))
    return true;
// or
const auto refs = QStringView{string}.tokenize(u' ');
for (auto ref : refs) {
    if (ref == value)
        return true;
}</pre> <h2 id="qmutex-and-related-classes">QMutex and Related Classes
</h2> <p>In Qt 6, <a href="qrecursivemutex">QRecursiveMutex</a> does not inherit from <a href="qmutex">QMutex</a> anymore. This change was done to improve the performance of both <a href="qmutex">QMutex</a> and <a href="qrecursivemutex">QRecursiveMutex</a>.</p> <p>Due to those changes, the QMutex::RecursionMode enum has been removed, and <a href="qmutexlocker">QMutexLocker</a> is now a templated class that can operate on both <a href="qmutex">QMutex</a> and <a href="qrecursivemutex">QRecursiveMutex</a>.</p> <h2 id="qfuture-and-related-classes">QFuture and Related Classes
</h2> <h3 id="the-qfuture-class">The QFuture class
</h3> <p>To avoid unintended usage of <a href="qfuture">QFuture</a>, there were some changes to <a href="qfuture">QFuture</a> API in Qt 6, which may introduce source compatibility breaks.</p> <h4 id="implicit-conversions-between-qfuture-and-other-types">Implicit conversions between QFuture and other types
</h4> <p>Conversion of <code>QFuture&lt;T&gt;</code> to <code>T</code> has been disabled. The casting operator was calling <a href="qfuture#result">QFuture::result</a>(), which may lead to undefined behavior if the user has moved the results from <a href="qfuture">QFuture</a> via <a href="qfuture#takeResult">QFuture::takeResult</a>() before trying to do the conversion. Use <a href="qfuture#result">QFuture::result</a>() or <a href="qfuture#takeResult">QFuture::takeResult</a>() methods explicitly, where you need to convert <code>QFuture&lt;T&gt;</code> to <code>T</code>.</p> <p>The implicit conversion from <code>QFuture&lt;T&gt;</code> to <code>QFuture&lt;void&gt;</code> has been also disabled. If you really intend to do the conversion, use the explicit <code>QFuture&lt;void&gt;(const QFuture&lt;T&gt; &amp;)</code> constructor:</p> <pre data-language="cpp">QFuture&lt;int&gt; future = ...
QFuture&lt;void&gt; voidFuture = QFuture&lt;void&gt;(future);</pre> <h4 id="equality-operators">Equality operators
</h4> <p>The equality operators of <a href="qfuture">QFuture</a> have been removed. They were comparing the underlying d-pointers instead of comparing the results, which is not what users might expect. If you need to compare <a href="qfuture">QFuture</a> objects, use <code>QFuture::result()</code> or <code>QFuture::takeResult()</code> methods. For example:</p> <pre data-language="cpp">QFuture&lt;int&gt; future1 = ...;
QFuture&lt;int&gt; future2 = ...;
if (future1.result() == future2.result())
    // ...</pre> <h3 id="behavioral-changes-to-qfuture-and-qfuturewatcher">Behavioral Changes to QFuture and QFutureWatcher
</h3> <p>In Qt 6, there were some improvements to <a href="qfuture">QFuture</a> and <a href="qfuturewatcher">QFutureWatcher</a> which caused the following behavioral changes:</p> <ul> <li>After pausing <a href="qfuture">QFuture</a> or <a href="qfuturewatcher">QFutureWatcher</a> (by calling <code>pause()</code> or <code>setPaused(true)</code>), <a href="qfuturewatcher">QFutureWatcher</a> will not immediately stop delivering progress and result ready signals. At the moment of pausing there may be still computations that are in progress and cannot be stopped. Signals for such computations may be still delivered after pause, instead of being postponed and reported only after next resume. To get notified when pause actually took effect, <a href="qfuturewatcher#suspended">QFutureWatcher::suspended</a>() signal can be used. In addition, there are new <code>isSuspending()</code> and <code>isSuspended()</code> methods, to check if the <a href="qfuture">QFuture</a> is in the process of suspending or it's already in the suspended state. Note that for consistency reasons, for both <a href="qfuture">QFuture</a> and <a href="qfuturewatcher">QFutureWatcher</a> the pause-related APIs were deprecated and replaced by similar methods having "suspend" in the name instead.</li> <li>
<a href="qfuture#waitForFinished">QFuture::waitForFinished</a>() will now wait until <a href="qfuture">QFuture</a> is actually in the finished state, instead of exiting as soon as it is not in the running state. This prevents <code>waitForFinished()</code> from exiting immediately, if at the moment of calling it the future is not started yet. The same applies to <a href="qfuturewatcher#waitForFinished">QFutureWatcher::waitForFinished</a>(). This change won't affect the behavior of code that was using <a href="qfuture">QFuture</a> with <a href="https://doc.qt.io/qt-6.2/qtconcurrent-module.html">QtConcurrent</a>. Only the code that was using it with the undocumented <code>QFutureInterface</code> may be affected.</li> <li>
<a href="qfuturewatcher#isFinished">QFutureWatcher::isFinished</a>() now reflects the finished-state of the <a href="qfuture">QFuture</a> rather than returning false until <a href="qfuturewatcher#finished">QFutureWatcher::finished</a>() has been emitted.</li> </ul> <h3 id="the-qpromise-class">The QPromise class
</h3> <p>In Qt 6, the new <a href="qpromise">QPromise</a> class should be used instead of unofficial QFutureInterface as a "setter" counterpart of <a href="qfuture">QFuture</a>.</p> <h2 id="io-classes">IO Classes
</h2> <h3 id="the-qprocess-class">The QProcess class
</h3> <p>In Qt 6, the <a href="qprocess#start">QProcess::start</a>() overload that interprets a single command string by splitting it into program name and arguments is renamed to <a href="qprocess#startCommand">QProcess::startCommand</a>(). However, a <a href="qprocess#start">QProcess::start</a>() overload that takes a single string, as well as a <a href="qstringlist">QStringList</a> for arguments exists. Since the <a href="qstringlist">QStringList</a> parameter defaults to the empty list, existing code only passing a string will still compile, but will fail to execute the process if it is a complete command string that includes arguments.</p> <p>Qt 5.15 introduced deprecation warnings for the respective overload to make it easy to discover and update existing code:</p> <pre data-language="cpp">QProcess process;

// compiles with warnings in 5.15, compiles but fails with Qt 6
process.start("dir \"My Documents\"");

// works with both Qt 5 and Qt 6; also see QProcess::splitCommand()
process.start("dir", QStringList({"My Documents"});

// works with Qt 6
process.startCommand("dir \"My Documents\"");</pre> <p>QProcess::pid() and the Q_PID type have been removed; use <a href="qprocess#processId">QProcess::processId</a>() instead to get the native process identifier. Code using native Win32 APIs to access the data in the Q_PID as a Win32 <code>PROCESS_INFORMATION</code> struct is no longer supported.</p> <h2 id="meta-type-system">Meta-Type system
</h2> <h3 id="the-qvariant-class">The QVariant class
</h3> <p><code>QVariant</code> has been rewritten to use <code>QMetaType</code> for all of its operations. This implies behavior changes in a few methods:</p> <ul> <li>
<code>QVariant::isNull()</code> now only returns <code>true</code> if the <code>QVariant</code> is empty or contains a <code>nullptr</code>. In Qt 5, it also returned true for classes in qtbase which had an <code>isNull</code> method themselves if that one returned true. Code relying on the old behavior needs to check whether the contained value returns isNull – however such code is unlikely to occur in practice, as <code>isNull()</code> is rarely the property one is interested in (compare <code>QString::isEmpty()</code> / <code>isNull()</code> and <code>QTime::isValid</code> / <code>isNull</code>).</li> <li>
<code>QVariant::operator==</code> uses <code>QMetaType::equals</code> in Qt 6. Therefore, some graphical types like <code>QPixmap</code>, <code>QImage</code> and <code>QIcon</code> will never compare equal. Moreover, floating point numbers stored in <code>QVariant</code> are no longer compared with <code>qFuzzyCompare</code>, but instead use exact comparisons.</li> </ul> <p>Furthermore, QVariant::operator&lt;, QVariant::operator&lt;=, QVariant::operator&gt; and QVariant::operator&gt;= were removed, because different variants are not always orderable. This also means that <a href="qvariant">QVariant</a> cannot be used anymore as a key in a <a href="qmap">QMap</a>.</p> <h3 id="the-qmetatype-class">The QMetaType class
</h3> <p>In Qt 6, registration of comparators, and cQDebug and QDataStream streaming operators is done automatically. Consequently, <code>QMetaType::registerEqualsComparator()</code>, <code>QMetaType::registerComparators()</code>, <code>qRegisterMetaTypeStreamOperators()</code> and <code>QMetaType::registerDebugStreamOperator()</code> do no longer exist. Calls to those methods have to be removed when porting to Qt 6.</p> <h3 id="type-registration">Type registration
</h3> <p>Types used in <code>Q_PROPERTY</code> have their meta-type stored in the class' <code>QMetaObject</code>. This requires the types to be complete when moc sees them, which can lead to compilation errors in code that worked in Qt 5. There are three ways to fix this issue:</p> <ul> <li>Include the header which defines the type.</li> <li>Instead of using an include, use the <code>Q_MOC_INCLUDE</code> macro. This helps if including the header would cause a cyclic dependency, or when it would slow down compilation.</li> <li>If the header is present in the cpp file which implements the class, it is also possible to include the moc generated file there.</li> </ul> <h2 id="regular-expression-classes">Regular expression classes
</h2> <h3 id="the-qregularexpression-class">The QRegularExpression class
</h3> <p>In Qt6, all methods taking the <code>QRegExp</code> got removed from our code-base. Therefore it is very likely that you will have to port your application or library to <a href="qregularexpression">QRegularExpression</a>.</p> <p><a href="qregularexpression">QRegularExpression</a> implements Perl-compatible regular expressions. It fully supports Unicode. For an overview of the regular expression syntax supported by <a href="qregularexpression">QRegularExpression</a>, please refer to the aforementioned pcrepattern(3) man page. A regular expression is made up of two things: a pattern string and a set of pattern options that change the meaning of the pattern string.</p> <p>There are some subtle differences between <a href="qregularexpression">QRegularExpression</a> and <code>QRegExp</code> that will be explained by this document to ease the porting effort.</p> <p><a href="qregularexpression">QRegularExpression</a> is more strict when it comes to the syntax of the regular expression. Therefore it is always good to check the expression for <a href="qregularexpression#isValid">validity</a>.</p> <p><a href="qregularexpression">QRegularExpression</a> can almost always be declared const (except when the pattern changes), while <code>QRegExp</code> almost never could be.</p> <p>There is no replacement for the <a href="qregexp#CaretMode-enum">CaretMode</a> enumeration. The <a href="qregularexpression#MatchOption-enum">QRegularExpression::AnchoredMatchOption</a> match option can be used to emulate the <a href="qregexp#CaretMode-enum">QRegExp::CaretAtOffset</a> behavior. There is no equivalent for the other <a href="qregexp#CaretMode-enum">QRegExp::CaretMode</a> modes.</p> <p><a href="qregularexpression">QRegularExpression</a> supports only Perl-compatible regular expressions. Still, it does not support all the features available in Perl-compatible regular expressions. The most notable one is the fact that duplicated names for capturing groups are not supported, and using them can lead to undefined behavior. This may change in a future version of Qt.</p> <h4 id="wildcard-matching">Wildcard matching
</h4> <p>There is no direct way to do wildcard matching in <a href="qregularexpression">QRegularExpression</a>. However, the <a href="qregularexpression#wildcardToRegularExpression">QRegularExpression::wildcardToRegularExpression</a> method is provided to translate glob patterns into a Perl-compatible regular expression that can be used for that purpose.</p> <p>For example, if you have code like</p> <pre data-language="cpp">QRegExp wildcard("*.txt");
wildcard.setPatternSyntax(QRegExp::Wildcard);</pre> <p>you can rewrite it as</p> <pre data-language="cpp">auto wildcard = QRegularExpression(QRegularExpression::wildcardToRegularExpression("*.txt"));</pre> <p>Please note though that not all shell like wildcard pattern might be translated in a way you would expect it. The following example code will silently break if simply converted using the above mentioned function:</p> <pre data-language="cpp">const QString fp1("C:/Users/dummy/files/content.txt");
const QString fp2("/home/dummy/files/content.txt");

QRegExp re1("*/files/*");
re1.setPatternSyntax(QRegExp::Wildcard);
... = re1.exactMatch(fp1);  // returns true
... = re1.exactMatch(fp2);  // returns true

// but converted with QRegularExpression::wildcardToRegularExpression()

QRegularExpression re2(QRegularExpression::wildcardToRegularExpression("*/files/*"));
... = re2.match(fp1).hasMatch();    // returns false
... = re2.match(fp2).hasMatch();    // returns false</pre> <h4 id="searching-forward">Searching forward
</h4> <p>Forward searching inside a string was usually implemented with a loop using <code>QRegExp::indexIn</code> and a growing offset, but can now be easily implemented with <a href="qregularexpressionmatchiterator">QRegularExpressionMatchIterator</a> or <a href="qstring#indexOf">QString::indexOf</a>.</p> <p>For example, if you have code like</p> <pre data-language="cpp">QString subject("the quick fox");

int offset = 0;
QRegExp re("(\\w+)");
while ((offset = re.indexIn(subject, offset)) != -1) {
    offset += re.matchedLength();
    // ...
}</pre> <p>you can rewrite it as</p> <pre data-language="cpp">QRegularExpression re("(\\w+)");
QString subject("the quick fox");

QRegularExpressionMatchIterator i = re.globalMatch(subject);
while (i.hasNext()) {
    QRegularExpressionMatch match = i.next();
    // ...
}

 // or alternatively using QString::indexOf

qsizetype from = 0;
QRegularExpressionMatch match;
while ((from = subject.indexOf(re, from, &amp;match)) != -1) {
    from += match.capturedLength();
    // ...
}</pre> <h4 id="searching-backwards">Searching backwards
</h4> <p>Backwards searching inside a string was usually often implemented as a loop over <code>QRegExp::lastIndexIn</code>, but can now be easily implemented using <a href="qstring#lastIndexOf">QString::lastIndexOf</a> and <a href="qregularexpressionmatch">QRegularExpressionMatch</a>.</p> <div class="admonition note"> <p><b>Note: </b><a href="qregularexpressionmatchiterator">QRegularExpressionMatchIterator</a> is not capable of performing a backwards search.</p> </div> <p>For example, if you have code like</p> <pre data-language="cpp">int offset = -1;
QString subject("Lorem ipsum dolor sit amet, consetetur sadipscing.");

QRegExp re("\\s+([ids]\\w+)");
while ((offset = re.lastIndexIn(subject, offset)) != -1) {
    --offset;
    // ...
}</pre> <p>you can rewrite it as</p> <pre data-language="cpp">qsizetype from = -1;
QString subject("Lorem ipsum dolor sit amet, consetetur sadipscing.");

QRegularExpressionMatch match;
QRegularExpression re("\\s+([ids]\\w+)");
while ((from = subject.lastIndexOf(re, from, &amp;match)) != -1) {
    --from;
    // ...
}</pre> <h4 id="exactmatch-vs-match-hasmatch">exactMatch vs. match.hasMatch
</h4> <p><code>QRegExp::exactMatch</code> served two purposes: it exactly matched a regular expression against a subject string, and it implemented partial matching. Exact matching indicates whether the regular expression matches the entire subject string. For example:</p> <pre data-language="cpp">QString source("abc123");

QRegExp("\\d+").exactMatch(source);         // returns false
QRegExp("[a-z]+\\d+").exactMatch(source);   // returns true

QRegularExpression("\\d+").match(source).hasMatch();        // returns true
QRegularExpression("[a-z]+\\d+").match(source).hasMatch();  // returns true</pre> <p>Exact matching is not reflected in <a href="qregularexpression">QRegularExpression</a>. If you want to be sure that the subject string matches the regular expression exactly, you can wrap the pattern using the <a href="qregularexpression#anchoredPattern">QRegularExpression::anchoredPattern</a> function:</p> <pre data-language="cpp">QString source("abc123");

QString pattern("\\d+");
QRegularExpression(pattern).match(source).hasMatch();  // returns true

pattern = QRegularExpression::anchoredPattern(pattern);
QRegularExpression(pattern).match(source).hasMatch();  // returns false</pre> <h4 id="minimal-matching">Minimal matching
</h4> <p><code>QRegExp::setMinimal()</code> implemented minimal matching by simply reversing the greediness of the quantifiers (<code>QRegExp</code> did not support lazy quantifiers, like *?, +?, etc.). <a href="qregularexpression">QRegularExpression</a> instead does support greedy, lazy and possessive quantifiers. The <a href="qregularexpression#PatternOption-enum">QRegularExpression::InvertedGreedinessOption</a> pattern option can be useful to emulate the effects of <code>QRegExp::setMinimal()</code>: if enabled, it inverts the greediness of quantifiers (greedy ones become lazy and vice versa).</p> <h4 id="different-pattern-syntax">Different pattern syntax
</h4> <p>Porting a regular expression from <code>QRegExp</code> to <a href="qregularexpression">QRegularExpression</a> may require changes to the pattern itself. Therefore it is recommended to check the pattern used with the <a href="qregularexpression#isValid">QRegularExpression::isValid</a> method. This is especially important for user provided pattern or pattern not controlled by the developer.</p> <p>In other cases, a pattern ported from <code>QRegExp</code> to <a href="qregularexpression">QRegularExpression</a> may silently change semantics. Therefore, it is necessary to review the patterns used. The most notable cases of silent incompatibility are:</p> <ul> <li>Curly braces are needed in order to use a hexadecimal escape like <code>\xHHHH</code> with more than 2 digits. A pattern like <code>\x2022</code> needs to be ported to <code>\x{2022}</code>, or it will match a space <code>(0x20)</code> followed by the string <code>"22"</code>. In general, it is highly recommended to always use curly braces with the <code>\x</code> escape, no matter the amount of digits specified.</li> <li>A <code>0-to-n</code> quantification like <code>{,n}</code> needs to be ported to <code>{0,n}</code> to preserve semantics. Otherwise, a pattern such as <code>\d{,3}</code> would actually match a digit followed by the exact string <code>"{,3}"</code>.</li> </ul> <h4 id="partial-matching">Partial Matching
</h4> <p>When using <code>QRegExp::exactMatch()</code>, if an exact match was not found, one could still find out how much of the subject string was matched by the regular expression by calling <code>QRegExp::matchedLength()</code>. If the returned length was equal to the subject string's length, then one could conclude that a partial match was found. <a href="qregularexpression">QRegularExpression</a> supports partial matching explicitly by means of the appropriate <a href="qregularexpression#MatchType-enum">QRegularExpression::MatchType</a>.</p> <h4 id="global-matching">Global matching
</h4> <p>Due to limitations of the <code>QRegExp</code> API it was impossible to implement global matching correctly (that is, like Perl does). In particular, patterns that can match zero characters (like "a*") are problematic. <a href="qregularexpression#wildcardToRegularExpression">QRegularExpression::wildcardToRegularExpression</a> implements Perl global match correctly, and the returned iterator can be used to examine each result.</p> <h4 id="unicode-properties-support">Unicode properties support
</h4> <p>When using <code>QRegExp</code>, character classes such as <code>\w</code>, <code>\d</code>, etc. match characters with the corresponding Unicode property: for instance, <code>\d</code> matches any character with the Unicode Nd (decimal digit) property. Those character classes only match ASCII characters by default. When using <a href="qregularexpression">QRegularExpression</a>: for instance, <code>\d</code> matches exactly a character in the 0-9 ASCII range. It is possible to change this behavior by using the <a href="qregularexpression#PatternOption-enum">QRegularExpression::UseUnicodePropertiesOption</a> pattern option.</p> <h3 id="the-qregexp-class">The QRegExp class
</h3> <p>In Qt6 <a href="qregexp">QRegExp</a> got removed from Qt Core. If your application cannot be ported right now, <code>QRegExp</code> still exists in Qt5Compat to keep these code-bases working. If you want to use <code>QRegExp</code> further, you need to link against the new Qt5Compat module and add this line to your <a href="resources#qmake">qmake</a> <code>.pro</code> file:</p> <pre data-language="cpp">QT += core5compat</pre> <p>In case you already ported your application or library to the <a href="cmake-manual">cmake</a> build system, add the following to your <code>CMakeList.txt</code>:</p> <pre data-language="cpp">PUBLIC_LIBRARIES
    Qt::Core5Compat</pre> <h3 id="qevent-and-subclasses">QEvent and subclasses
</h3> <p>The <a href="qevent">QEvent</a> class defined a copy constructor and an assignment operator, in spite of being a polymorphic class. Copying classes with virtual methods can result in slicing when assigning objects from different classes to each other. Since copying and assigning often happens implicilty, this could lead to hard-to-debug problems.</p> <p>In Qt 6, the copy constructor and assignment operator for <a href="qevent">QEvent</a> subclasses have been made protected to prevent implicit copying. If you need to copy events, use the <a href="qevent#clone">clone</a> method, which will return a heap-allocated copy of the <a href="qevent">QEvent</a> object. Make sure you delete the clone, perhaps using std::unique_ptr, unless you post it (in which case Qt will delete it once it has been delivered).</p> <p>In your <a href="qevent">QEvent</a> subclasses, override clone(), and declare the protected and default-implemented copy constructor and assignment operator like this:</p> <pre data-language="cpp">class MyEvent : public QEvent
{
public:
    // ...

    MyEvent *clone() const override { return new MyEvent(*this); }

protected:
    MyEvent(const MyEvent &amp;other) = default;
    MyEvent &amp;operator=(const MyEvent &amp;other) = default;
    MyEvent(MyEvent &amp;&amp;) = delete;
    MyEvent &amp;operator=(MyEvent &amp;&amp;) = delete;
    // member data
};</pre> <p>Note that if your MyEvent class allocates memory (e.g. through a pointer-to-implementation pattern), then you will have to implement custom copy semantics.</p> <h2 id="other-classes">Other classes
</h2> <p>In Qt 5, <a href="qcoreapplication#quit">QCoreApplication::quit</a>() was equivalent to calling <a href="qcoreapplication#exit">QCoreApplication::exit</a>(). This just exited the main event loop.</p> <p>In Qt 6, the method will instead try to close all top-level windows by posting a close event. The windows are free to cancel the shutdown process by ignoring the event.</p> <p>Call <a href="qcoreapplication#exit">QCoreApplication::exit</a>() to keep the non-conditional behavior.</p> <p>QLibraryInfo::location() and QLibraryInfo::Location were deprecated due to inconsistent naming. Use the new API <a href="qlibraryinfo#path">QLibraryInfo::path</a>() and <a href="qlibraryinfo#LibraryPath-enum">QLibraryInfo::LibraryPath</a> instead.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © The Qt Company Ltd<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://doc.qt.io/qt-6.2/qtcore-changes-qt6.html" class="_attribution-link">https://doc.qt.io/qt-6.2/qtcore-changes-qt6.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
