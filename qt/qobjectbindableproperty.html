
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>QObjectBindableProperty (Class) - Qt - W3cubDocs</title>
  
  <meta name="description" content="The QObjectBindableProperty class is a template class that enables automatic property bindings for property data stored in QObject derived classes. &hellip;">
  <meta name="keywords" content="qobjectbindableproperty, class, qt">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/qt/qobjectbindableproperty.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/qt.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/qt/" class="_nav-link" title="" style="margin-left:0;">Qt</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _qt">
				
				
<h1 class="title">QObjectBindableProperty Class</h1> <span class="small-subtitle">template &lt;typename Class, typename T, auto Offset, auto Signal&gt; class QObjectBindableProperty</span>  <p>The QObjectBindableProperty class is a template class that enables automatic property bindings for property data stored in <a href="qobject">QObject</a> derived classes. <a href="#details">More...</a></p>  <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> Header:</td>
<td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QObjectBindableProperty&gt;</span> </td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> CMake:</td>
<td class="memItemRight bottomAlign"> find_package(Qt6 COMPONENTS Core REQUIRED)  target_link_libraries(mytarget PRIVATE Qt6::Core)</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> qmake:</td>
<td class="memItemRight bottomAlign"> QT += core</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Since:</td>
<td class="memItemRight bottomAlign"> Qt 6.0</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Inherits:</td>
<td class="memItemRight bottomAlign"> <a href="qpropertydata">QPropertyData</a>
</td>
</tr>
</table> <ul> <li><a href="https://doc.qt.io/qt-6.2/qobjectbindableproperty-members.html">List of all members, including inherited members</a></li> </ul> <h2 id="public-functions">Public Functions
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qobjectbindableproperty#QObjectBindableProperty-6">QObjectBindableProperty</a></b>(Class *<i>owner</i>, QPropertyBinding&lt;T&gt; &amp;&amp;<i>binding</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qobjectbindableproperty#QObjectBindableProperty-5">QObjectBindableProperty</a></b>(Class *<i>owner</i>, const QPropertyBinding&lt;T&gt; &amp;<i>binding</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qobjectbindableproperty#QObjectBindableProperty-4">QObjectBindableProperty</a></b>(Functor &amp;&amp;<i>f</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qobjectbindableproperty#QObjectBindableProperty-2">QObjectBindableProperty</a></b>(T &amp;&amp;<i>initialValue</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qobjectbindableproperty#QObjectBindableProperty-1">QObjectBindableProperty</a></b>(const T &amp;<i>initialValue</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qobjectbindableproperty#QObjectBindableProperty">QObjectBindableProperty</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qobjectbindableproperty#dtor.QObjectBindableProperty">~QObjectBindableProperty</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QPropertyNotifier </td>
<td class="memItemRight bottomAlign">
<b><a href="qobjectbindableproperty#addNotifier">addNotifier</a></b>(Functor <i>f</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QPropertyBinding&lt;T&gt; </td>
<td class="memItemRight bottomAlign">
<b><a href="qobjectbindableproperty#binding">binding</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qobjectbindableproperty#hasBinding">hasBinding</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qobjectbindableproperty#notify">notify</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QPropertyChangeHandler&lt;Functor&gt; </td>
<td class="memItemRight bottomAlign">
<b><a href="qobjectbindableproperty#onValueChanged">onValueChanged</a></b>(Functor <i>f</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QPropertyBinding&lt;T&gt; </td>
<td class="memItemRight bottomAlign">
<b><a href="qobjectbindableproperty#setBinding">setBinding</a></b>(const QPropertyBinding&lt;T&gt; &amp;<i>newBinding</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qobjectbindableproperty#setBinding-1">setBinding</a></b>(const QUntypedPropertyBinding &amp;<i>newBinding</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QPropertyBinding&lt;T&gt; </td>
<td class="memItemRight bottomAlign">
<b><a href="qobjectbindableproperty#setBinding-2">setBinding</a></b>(Functor <i>f</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qobjectbindableproperty#setValue">setValue</a></b>(QObjectBindableProperty::parameter_type <i>newValue</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qobjectbindableproperty#setValue-1">setValue</a></b>(QObjectBindableProperty::rvalue_ref <i>newValue</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QPropertyChangeHandler&lt;Functor&gt; </td>
<td class="memItemRight bottomAlign">
<b><a href="qobjectbindableproperty#subscribe">subscribe</a></b>(Functor <i>f</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QPropertyBinding&lt;T&gt; </td>
<td class="memItemRight bottomAlign">
<b><a href="qobjectbindableproperty#takeBinding">takeBinding</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QObjectBindableProperty::parameter_type </td>
<td class="memItemRight bottomAlign">
<b><a href="qobjectbindableproperty#value">value</a></b>() const</td>
</tr> </table> <h2 id="macros">Macros
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qobjectbindableproperty#Q_OBJECT_BINDABLE_PROPERTY">Q_OBJECT_BINDABLE_PROPERTY</a></b>(<i>containingClass</i>, <i>type</i>, <i>name</i>, <i>signal</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qobjectbindableproperty#Q_OBJECT_BINDABLE_PROPERTY_WITH_ARGS">Q_OBJECT_BINDABLE_PROPERTY_WITH_ARGS</a></b>(<i>containingClass</i>, <i>type</i>, <i>name</i>, <i>initialvalue</i>, <i>signal</i>)</td>
</tr> </table>   <h2 id="details">Detailed Description
</h2> <p>QObjectBindableProperty is a generic container that holds an instance of T and behaves mostly like <a href="qproperty">QProperty</a>. It is one of the classes implementing <a href="bindableproperties">Qt Bindable Properties</a>. Unlike <a href="qproperty">QProperty</a>, it stores its management data structure in the surrounding <a href="qobject">QObject</a>. The extra template parameters are used to identify the surrounding class and a member function of that class acting as a change handler.</p> <p>You can use QObjectBindableProperty to add binding support to code that uses <a href="qobject#Q_PROPERTY">Q_PROPERTY</a>. The getter and setter methods must be adapted carefully according to the rules described in <a href="bindableproperties#bindable-property-getters-and-setters">Bindable Property Getters and Setters</a>.</p> <p>In order to invoke the change signal on property changes, use QObjectBindableProperty and pass the change signal as a callback.</p> <p>A simple example is given in the following.</p> <pre data-language="cpp">#include &lt;QObject&gt;
#include &lt;QProperty&gt;
#include &lt;QDebug&gt;

class Foo : public QObject
{
    Q_OBJECT
    Q_PROPERTY(int myVal READ myVal WRITE setMyVal BINDABLE bindableMyVal)
public:
    int myVal() { return myValMember.value(); }
    void setMyVal(int newvalue) { myValMember = newvalue; }
    QBindable&lt;int&gt; bindableMyVal() { return &amp;myValMember; }
signals:
    void myValChanged();

private:
    Q_OBJECT_BINDABLE_PROPERTY(Foo, int, myValMember, &amp;Foo::myValChanged);
};

int main()
{
    bool debugout(true); // enable debug log
    Foo myfoo;
    QProperty&lt;int&gt; prop(42);
    QObject::connect(&amp;myfoo, &amp;Foo::myValChanged, [&amp;]() {
        if (debugout)
            qDebug() &lt;&lt; myfoo.myVal();
    });
    myfoo.bindableMyVal().setBinding([&amp;]() { return prop.value(); }); // prints "42"

    prop = 5; // prints "5"
    debugout = false;
    prop = 6; // prints nothing
    debugout = true;
    prop = 7; // prints "7"
}

#include "main.moc"</pre> <p>QObjectBindableProperty is usually not used directly, instead an instance of it is created by using the <a href="qobjectbindableproperty#Q_OBJECT_BINDABLE_PROPERTY">Q_OBJECT_BINDABLE_PROPERTY</a> macro.</p> <p>Use the <a href="qobjectbindableproperty#Q_OBJECT_BINDABLE_PROPERTY">Q_OBJECT_BINDABLE_PROPERTY</a> macro in the class declaration to declare the property as bindable.</p> <pre data-language="cpp">class MyClass : public QObject
{
    Q_OBJECT
    Q_PROPERTY(int x READ x WRITE setX NOTIFY xChanged BINDABLE bindableX)
public:
    int x() const { return xProp; }
    void setX(int x) { xProp = x; }
    QBindable&lt;int&gt; bindableX() { return QBindable&lt;int&gt;(&amp;xProp); }

signals:
    void xChanged();

private:
    // Declare the instance of the bindable property data.
    Q_OBJECT_BINDABLE_PROPERTY(MyClass, int, xProp, &amp;MyClass::xChanged)
};</pre> <p>If you need to directly initialize the property with some non-default value, you can use the <a href="qobjectbindableproperty#Q_OBJECT_BINDABLE_PROPERTY_WITH_ARGS">Q_OBJECT_BINDABLE_PROPERTY_WITH_ARGS</a> macro. It accepts a value for the initialization as one of its parameters.</p> <pre data-language="cpp">class MyClass : public QObject
{
    Q_OBJECT
    Q_PROPERTY(int x READ x WRITE setX NOTIFY xChanged BINDABLE bindableX)
public:
    int x() const { return xProp; }
    void setX(int x) { xProp = x; }
    QBindable&lt;int&gt; bindableX() { return QBindable&lt;int&gt;(&amp;xProp); }

signals:
    void xChanged();

private:
    // Declare the instance of int bindable property data and
    // initialize it with the value 5.
    // This is similar to declaring
    // int xProp = 5;
    // without using the new QObjectBindableProperty class.
    Q_OBJECT_BINDABLE_PROPERTY_WITH_ARGS(MyClass, int, xProp, 5, &amp;MyClass::xChanged)
};</pre> <p><a href="qobjectbindableproperty#Q_OBJECT_BINDABLE_PROPERTY_WITH_ARGS">Q_OBJECT_BINDABLE_PROPERTY_WITH_ARGS</a> does not support multiple arguments directly. If your property requires multiple arguments for initialization, please explicitly call the specific constructor.</p> <pre data-language="cpp">class CustomType
{
public:
    CustomType(int val, int otherVal) : value(val), anotherValue(otherVal) { }

private:
    int value = 0;
    int anotherValue = 0;
};

// later when using CustomType as a property
Q_OBJECT_BINDABLE_PROPERTY_WITH_ARGS(MyClass, CustomType xProp, CustomType(5, 10),
                                     &amp;MyClass::xChanged)</pre> <p>The change handler can optionally accept one argument, of the same type as the property, in which case it is passed the new value of the property. Otherwise, it should take no arguments.</p> <p>If the property does not need a changed notification, you can leave out the "NOTIFY xChanged" in the <a href="qobject#Q_PROPERTY">Q_PROPERTY</a> macro as well as the last argument of the <a href="qobjectbindableproperty#Q_OBJECT_BINDABLE_PROPERTY">Q_OBJECT_BINDABLE_PROPERTY</a> and <a href="qobjectbindableproperty#Q_OBJECT_BINDABLE_PROPERTY_WITH_ARGS">Q_OBJECT_BINDABLE_PROPERTY_WITH_ARGS</a> macros.</p>  <p><b>See also </b><a href="qobjectbindableproperty#Q_OBJECT_BINDABLE_PROPERTY">Q_OBJECT_BINDABLE_PROPERTY</a>, <a href="qobjectbindableproperty#Q_OBJECT_BINDABLE_PROPERTY_WITH_ARGS">Q_OBJECT_BINDABLE_PROPERTY_WITH_ARGS</a>, <a href="qproperty">QProperty</a>, <a href="qobjectcomputedproperty">QObjectComputedProperty</a>, <a href="properties">Qt's Property System</a>, and <a href="bindableproperties">Qt Bindable Properties</a>.</p>   <h2>Member Function Documentation</h2>  <div class="fngroup"> <h3 class="fn fngroupitem" id="setValue">
<span class="type">void</span> QObjectBindableProperty::<span class="name">setValue</span>(<span class="type">QObjectBindableProperty::parameter_type</span> <i>newValue</i>)
</h3>
<h3 class="fn fngroupitem" id="setValue-1">
<span class="type">void</span> QObjectBindableProperty::<span class="name">setValue</span>(<span class="type">QObjectBindableProperty::rvalue_ref</span> <i>newValue</i>)
</h3>
</div> <p>Assigns <i>newValue</i> to this property and removes the property's associated binding, if present. If the property value changes as a result, calls the Callback function on <i>owner</i>.</p>   <h3 class="fn" id="QObjectBindableProperty-6">
<code>[default] </code>QObjectBindableProperty::<span class="name">QObjectBindableProperty</span>(<span class="type">Class</span> *<i>owner</i>, <span class="type">QPropertyBinding</span>&lt;<span class="type">T</span>&gt; &amp;&amp;<i>binding</i>)
</h3> <p>Constructs a property that is tied to the provided <i>binding</i> expression. The first time the property value is read, the binding is evaluated. Whenever a dependency of the binding changes, the binding will be re-evaluated the next time the value of this property is read. When the property value changes <i>owner</i> is notified via the Callback function.</p>   <h3 class="fn" id="QObjectBindableProperty-5">
<code>[default] </code>QObjectBindableProperty::<span class="name">QObjectBindableProperty</span>(<span class="type">Class</span> *<i>owner</i>, const <span class="type">QPropertyBinding</span>&lt;<span class="type">T</span>&gt; &amp;<i>binding</i>)
</h3> <p>Constructs a property that is tied to the provided <i>binding</i> expression. The first time the property value is read, the binding is evaluated. Whenever a dependency of the binding changes, the binding will be re-evaluated the next time the value of this property is read. When the property value changes <i>owner</i> is notified via the Callback function.</p>   <h3 class="fn" id="QObjectBindableProperty-4">template &lt;typename Functor&gt; QObjectBindableProperty::<span class="name">QObjectBindableProperty</span>(<span class="type">Functor</span> &amp;&amp;<i>f</i>)
</h3> <p>Constructs a property that is tied to the provided binding expression <i>f</i>. The first time the property value is read, the binding is evaluated. Whenever a dependency of the binding changes, the binding will be re-evaluated the next time the value of this property is read.</p>   <h3 class="fn" id="QObjectBindableProperty-2">QObjectBindableProperty::<span class="name">QObjectBindableProperty</span>(<span class="type">T</span> &amp;&amp;<i>initialValue</i>)
</h3> <p>Move-Constructs a property with the provided <i>initialValue</i>.</p>   <h3 class="fn" id="QObjectBindableProperty-1">QObjectBindableProperty::<span class="name">QObjectBindableProperty</span>(const <span class="type">T</span> &amp;<i>initialValue</i>)
</h3> <p>Constructs a property with the provided <i>initialValue</i>.</p>   <h3 class="fn" id="QObjectBindableProperty">QObjectBindableProperty::<span class="name">QObjectBindableProperty</span>()
</h3> <p>Constructs a property with a default constructed instance of T.</p>   <h3 class="fn" id="dtor.QObjectBindableProperty">
<code>[default] </code>QObjectBindableProperty::<span class="name">~QObjectBindableProperty</span>()
</h3> <p>Destroys the property.</p>   <h3 class="fn" id="addNotifier">template &lt;typename Functor&gt; <span class="type"><a href="qpropertynotifier">QPropertyNotifier</a></span> QObjectBindableProperty::<span class="name">addNotifier</span>(<span class="type">Functor</span> <i>f</i>)
</h3> <p>Subscribes the given functor <i>f</i> as a callback that is called whenever the value of the property changes.</p> <p>The callback <i>f</i> is expected to be a type that has a plain call operator () without any parameters. This means that you can provide a C++ lambda expression, a std::function or even a custom struct with a call operator.</p> <p>The returned property change handler object keeps track of the subscription. When it goes out of scope, the callback is unsubscribed.</p> <p>This method is in some cases easier to use than <a href="qobjectbindableproperty#onValueChanged">onValueChanged</a>(), as the returned object is not a template. It can therefore more easily be stored, e.g. as a member in a class.</p> <p><b>See also </b><a href="qobjectbindableproperty#onValueChanged">onValueChanged</a>() and <a href="qobjectbindableproperty#subscribe">subscribe</a>().</p>   <h3 class="fn" id="binding">
<span class="type">QPropertyBinding</span>&lt;<span class="type">T</span>&gt; QObjectBindableProperty::<span class="name">binding</span>() const
</h3> <p>Returns the binding expression that is associated with this property. A default constructed QPropertyBinding&lt;T&gt; will be returned if no such association exists.</p> <p><b>See also </b><a href="qobjectbindableproperty#setBinding">setBinding</a>().</p>   <h3 class="fn" id="hasBinding">
<span class="type">bool</span> QObjectBindableProperty::<span class="name">hasBinding</span>() const
</h3> <p>Returns true if the property is associated with a binding; false otherwise.</p>   <h3 class="fn" id="notify">
<span class="type">void</span> QObjectBindableProperty::<span class="name">notify</span>()
</h3> <p>Programmatically signals a change of the property. Any binding which depend on it will be notified, and if the property has a signal, it will be emitted.</p> <p>This can be useful in combination with setValueBypassingBindings to defer signalling the change until a class invariant has been restored.</p> <div class="admonition note"> <p><b>Note: </b>If this property has a binding (i.e. <a href="qobjectbindableproperty#hasBinding">hasBinding</a>() returns true), that binding is not reevaluated when notify() is called. Any binding depending on this property is still reevaluated as usual.</p> </div> <p><b>See also </b><a href="qproperty#beginPropertyUpdateGroup">Qt::beginPropertyUpdateGroup</a>() and <a href="qpropertydata#setValueBypassingBindings">setValueBypassingBindings</a>().</p>   <h3 class="fn" id="onValueChanged">template &lt;typename Functor&gt; <span class="type"><a href="qpropertychangehandler">QPropertyChangeHandler</a></span>&lt;<span class="type">Functor</span>&gt; QObjectBindableProperty::<span class="name">onValueChanged</span>(<span class="type">Functor</span> <i>f</i>)
</h3> <p>Registers the given functor <i>f</i> as a callback that shall be called whenever the value of the property changes. On each value change, the handler is either called immediately, or deferred, depending on the context.</p> <p>The callback <i>f</i> is expected to be a type that has a plain call operator () without any parameters. This means that you can provide a C++ lambda expression, a std::function or even a custom struct with a call operator.</p> <p>The returned property change handler object keeps track of the registration. When it goes out of scope, the callback is de-registered.</p>   <h3 class="fn" id="setBinding">
<span class="type">QPropertyBinding</span>&lt;<span class="type">T</span>&gt; QObjectBindableProperty::<span class="name">setBinding</span>(const <span class="type">QPropertyBinding</span>&lt;<span class="type">T</span>&gt; &amp;<i>newBinding</i>)
</h3> <p>Associates the value of this property with the provided <i>newBinding</i> expression and returns the previously associated binding. The first time the property value is read, the binding is evaluated. Whenever a dependency of the binding changes, the binding will be re-evaluated the next time the value of this property is read. When the property value changes, the owner is notified via the Callback function.</p> <p><b>See also </b><a href="qobjectbindableproperty#binding">binding</a>().</p>   <h3 class="fn" id="setBinding-1">
<span class="type">bool</span> QObjectBindableProperty::<span class="name">setBinding</span>(const <span class="type">QUntypedPropertyBinding</span> &amp;<i>newBinding</i>)
</h3> <p>This is an overloaded function.</p> <p>Associates the value of this property with the provided <i>newBinding</i> expression. The first time the property value is read, the binding is evaluated. Whenever a dependency of the binding changes, the binding will be re-evaluated the next time the value of this property is read.</p> <p>Returns <code>true</code> if the type of this property is the same as the type the binding function returns; <code>false</code> otherwise.</p>   <h3 class="fn" id="setBinding-2">template &lt;typename Functor&gt; <span class="type">QPropertyBinding</span>&lt;<span class="type">T</span>&gt; QObjectBindableProperty::<span class="name">setBinding</span>(<span class="type">Functor</span> <i>f</i>)
</h3> <p>This is an overloaded function.</p> <p>Associates the value of this property with the provided functor <i>f</i> and returns the previously associated binding. The first time the property value is read, the binding is evaluated by invoking the call operator () of <i>f</i>. Whenever a dependency of the binding changes, the binding will be re-evaluated the next time the value of this property is read. When the property value changes, the owner is notified via the Callback function.</p> <p><b>See also </b><a href="bindableproperties#formulating-a-property-binding">Formulating a Property Binding</a>.</p>   <h3 class="fn" id="subscribe">template &lt;typename Functor&gt; <span class="type"><a href="qpropertychangehandler">QPropertyChangeHandler</a></span>&lt;<span class="type">Functor</span>&gt; QObjectBindableProperty::<span class="name">subscribe</span>(<span class="type">Functor</span> <i>f</i>)
</h3> <p>Subscribes the given functor <i>f</i> as a callback that is called immediately and whenever the value of the property changes in the future. On each value change, the handler is either called immediately, or deferred, depending on the context.</p> <p>The callback <i>f</i> is expected to be a type that has a plain call operator () without any parameters. This means that you can provide a C++ lambda expression, a std::function or even a custom struct with a call operator.</p> <p>The returned property change handler object keeps track of the subscription. When it goes out of scope, the callback is unsubscribed.</p>   <h3 class="fn" id="takeBinding">
<span class="type">QPropertyBinding</span>&lt;<span class="type">T</span>&gt; QObjectBindableProperty::<span class="name">takeBinding</span>()
</h3> <p>Disassociates the binding expression from this property and returns it. After calling this function, the value of the property will only change if you assign a new value to it, or when a new binding is set.</p>   <h3 class="fn" id="value">
<span class="type">QObjectBindableProperty::parameter_type</span> QObjectBindableProperty::<span class="name">value</span>() const
</h3> <p>Returns the value of the property. This may evaluate a binding expression that is tied to this property, before returning the value.</p> <p><b>See also </b><a href="qobjectbindableproperty#setValue">setValue</a>().</p>   <div class="macros"> <h2>Macro Documentation</h2>  <h3 class="fn" id="Q_OBJECT_BINDABLE_PROPERTY">
<code>[since 6.0] </code><span class="name">Q_OBJECT_BINDABLE_PROPERTY</span>(<i>containingClass</i>, <i>type</i>, <i>name</i>, <i>signal</i>)
</h3> <p>Declares a <a href="qobjectbindableproperty">QObjectBindableProperty</a> inside <i>containingClass</i> of type <i>type</i> with name <i>name</i>. If the optional argument <i>signal</i> is given, this signal will be emitted when the property is marked dirty.</p> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="properties">Qt's Property System</a> and <a href="bindableproperties">Qt Bindable Properties</a>.</p>   <h3 class="fn" id="Q_OBJECT_BINDABLE_PROPERTY_WITH_ARGS">
<code>[since 6.0] </code><span class="name">Q_OBJECT_BINDABLE_PROPERTY_WITH_ARGS</span>(<i>containingClass</i>, <i>type</i>, <i>name</i>, <i>initialvalue</i>, <i>signal</i>)
</h3> <p>Declares a <a href="qobjectbindableproperty">QObjectBindableProperty</a> inside <i>containingClass</i> of type <i>type</i> with name <i>name</i> which is initialized to <i>initialvalue</i>. If the optional argument <i>signal</i> is given, this signal will be emitted when the property is marked dirty.</p> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="properties">Qt's Property System</a> and <a href="bindableproperties">Qt Bindable Properties</a>.</p>  </div>
<div class="_attribution">
  <p class="_attribution-p">
    Â© The Qt Company Ltd<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://doc.qt.io/qt-6.2/qobjectbindableproperty.html" class="_attribution-link">https://doc.qt.io/qt-6.2/qobjectbindableproperty.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
