
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Queues - Laravel 8 - W3cubDocs</title>
  
  <meta name="description" content="Laravel now offers Horizon, a beautiful dashboard and configuration system for your Redis powered queues. Check out the full Horizon documentation &hellip;">
  <meta name="keywords" content="queues, laravel, laravel~8">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/laravel~8/docs/8.x/queues.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/laravel~8.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/laravel~8/" class="_nav-link" title="" style="margin-left:0;">Laravel 8</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _laravel">
				
				
<section class="docs_main"> <h1>Queues</h1> <ul> <li>
<a href="#introduction">Introduction</a> <ul> <li><a href="#connections-vs-queues">Connections Vs. Queues</a></li> <li><a href="#driver-prerequisites">Driver Notes &amp; Prerequisites</a></li> </ul>
</li> <li>
<a href="#creating-jobs">Creating Jobs</a> <ul> <li><a href="#generating-job-classes">Generating Job Classes</a></li> <li><a href="#class-structure">Class Structure</a></li> <li><a href="#unique-jobs">Unique Jobs</a></li> </ul>
</li> <li>
<a href="#job-middleware">Job Middleware</a> <ul> <li><a href="#rate-limiting">Rate Limiting</a></li> <li><a href="#preventing-job-overlaps">Preventing Job Overlaps</a></li> </ul>
</li> <li>
<a href="#dispatching-jobs">Dispatching Jobs</a> <ul> <li><a href="#delayed-dispatching">Delayed Dispatching</a></li> <li><a href="#synchronous-dispatching">Synchronous Dispatching</a></li> <li><a href="#job-chaining">Job Chaining</a></li> <li><a href="#customizing-the-queue-and-connection">Customizing The Queue &amp; Connection</a></li> <li><a href="#max-job-attempts-and-timeout">Specifying Max Job Attempts / Timeout Values</a></li> <li><a href="#error-handling">Error Handling</a></li> </ul>
</li> <li>
<a href="#job-batching">Job Batching</a> <ul> <li><a href="#defining-batchable-jobs">Defining Batchable Jobs</a></li> <li><a href="#dispatching-batches">Dispatching Batches</a></li> <li><a href="#adding-jobs-to-batches">Adding Jobs To Batches</a></li> <li><a href="#inspecting-batches">Inspecting Batches</a></li> <li><a href="#cancelling-batches">Cancelling Batches</a></li> <li><a href="#batch-failures">Batch Failures</a></li> </ul>
</li> <li><a href="#queueing-closures">Queueing Closures</a></li> <li>
<a href="#running-the-queue-worker">Running The Queue Worker</a> <ul> <li><a href="#queue-priorities">Queue Priorities</a></li> <li><a href="#queue-workers-and-deployment">Queue Workers &amp; Deployment</a></li> <li><a href="#job-expirations-and-timeouts">Job Expirations &amp; Timeouts</a></li> </ul>
</li> <li><a href="#supervisor-configuration">Supervisor Configuration</a></li> <li>
<a href="#dealing-with-failed-jobs">Dealing With Failed Jobs</a> <ul> <li><a href="#cleaning-up-after-failed-jobs">Cleaning Up After Failed Jobs</a></li> <li><a href="#failed-job-events">Failed Job Events</a></li> <li><a href="#retrying-failed-jobs">Retrying Failed Jobs</a></li> <li><a href="#ignoring-missing-models">Ignoring Missing Models</a></li> </ul>
</li> <li><a href="#clearing-jobs-from-queues">Clearing Jobs From Queues</a></li> <li><a href="#job-events">Job Events</a></li> </ul>  <h2 id="introduction">Introduction</h2> <blockquote class="tip"> <p>Laravel now offers Horizon, a beautiful dashboard and configuration system for your Redis powered queues. Check out the full <a href="horizon">Horizon documentation</a> for more information.</p> </blockquote> <p>Laravel queues provide a unified API across a variety of different queue backends, such as Beanstalk, Amazon SQS, Redis, or even a relational database. Queues allow you to defer the processing of a time consuming task, such as sending an email, until a later time. Deferring these time consuming tasks drastically speeds up web requests to your application.</p> <p>The queue configuration file is stored in <code>config/queue.php</code>. In this file you will find connection configurations for each of the queue drivers that are included with the framework, which includes a database, <a href="https://beanstalkd.github.io/">Beanstalkd</a>, <a href="https://aws.amazon.com/sqs/">Amazon SQS</a>, <a href="https://redis.io">Redis</a>, and a synchronous driver that will execute jobs immediately (for local use). A <code>null</code> queue driver is also included which discards queued jobs.</p>  <h3 id="connections-vs-queues">Connections Vs. Queues</h3> <p>Before getting started with Laravel queues, it is important to understand the distinction between "connections" and "queues". In your <code>config/queue.php</code> configuration file, there is a <code>connections</code> configuration option. This option defines a particular connection to a backend service such as Amazon SQS, Beanstalk, or Redis. However, any given queue connection may have multiple "queues" which may be thought of as different stacks or piles of queued jobs.</p> <p>Note that each connection configuration example in the <code>queue</code> configuration file contains a <code>queue</code> attribute. This is the default queue that jobs will be dispatched to when they are sent to a given connection. In other words, if you dispatch a job without explicitly defining which queue it should be dispatched to, the job will be placed on the queue that is defined in the <code>queue</code> attribute of the connection configuration:</p> <pre data-language="php">// This job is sent to the default queue...
Job::dispatch();

// This job is sent to the "emails" queue...
Job::dispatch()-&gt;onQueue('emails');</pre> <p>Some applications may not need to ever push jobs onto multiple queues, instead preferring to have one simple queue. However, pushing jobs to multiple queues can be especially useful for applications that wish to prioritize or segment how jobs are processed, since the Laravel queue worker allows you to specify which queues it should process by priority. For example, if you push jobs to a <code>high</code> queue, you may run a worker that gives them higher processing priority:</p> <pre data-language="php">php artisan queue:work --queue=high,default</pre>  <h3 id="driver-prerequisites">Driver Notes &amp; Prerequisites</h3>  <h4 id="database">Database</h4> <p>In order to use the <code>database</code> queue driver, you will need a database table to hold the jobs. To generate a migration that creates this table, run the <code>queue:table</code> Artisan command. Once the migration has been created, you may migrate your database using the <code>migrate</code> command:</p> <pre data-language="php">php artisan queue:table

php artisan migrate</pre>  <h4 id="redis">Redis</h4> <p>In order to use the <code>redis</code> queue driver, you should configure a Redis database connection in your <code>config/database.php</code> configuration file.</p> <p><strong>Redis Cluster</strong></p> <p>If your Redis queue connection uses a Redis Cluster, your queue names must contain a <a href="https://redis.io/topics/cluster-spec#keys-hash-tags">key hash tag</a>. This is required in order to ensure all of the Redis keys for a given queue are placed into the same hash slot:</p> <pre data-language="php">'redis' =&gt; [
    'driver' =&gt; 'redis',
    'connection' =&gt; 'default',
    'queue' =&gt; '{default}',
    'retry_after' =&gt; 90,
],</pre> <p><strong>Blocking</strong></p> <p>When using the Redis queue, you may use the <code>block_for</code> configuration option to specify how long the driver should wait for a job to become available before iterating through the worker loop and re-polling the Redis database.</p> <p>Adjusting this value based on your queue load can be more efficient than continually polling the Redis database for new jobs. For instance, you may set the value to <code>5</code> to indicate that the driver should block for five seconds while waiting for a job to become available:</p> <pre data-language="php">'redis' =&gt; [
    'driver' =&gt; 'redis',
    'connection' =&gt; 'default',
    'queue' =&gt; 'default',
    'retry_after' =&gt; 90,
    'block_for' =&gt; 5,
],</pre> <blockquote> <p>Setting <code>block_for</code> to <code>0</code> will cause queue workers to block indefinitely until a job is available. This will also prevent signals such as <code>SIGTERM</code> from being handled until the next job has been processed.</p> </blockquote>  <h4 id="other-driver-prerequisites">Other Driver Prerequisites</h4> <p>The following dependencies are needed for the listed queue drivers:</p> <div class="content-list"> <ul> <li>Amazon SQS: <code>aws/aws-sdk-php ~3.0</code>
</li> <li>Beanstalkd: <code>pda/pheanstalk ~4.0</code>
</li> <li>Redis: <code>predis/predis ~1.0</code> or phpredis PHP extension</li> </ul> </div>  <h2 id="creating-jobs">Creating Jobs</h2>  <h3 id="generating-job-classes">Generating Job Classes</h3> <p>By default, all of the queueable jobs for your application are stored in the <code>app/Jobs</code> directory. If the <code>app/Jobs</code> directory doesn't exist, it will be created when you run the <code>make:job</code> Artisan command. You may generate a new queued job using the Artisan CLI:</p> <pre data-language="php">php artisan make:job ProcessPodcast</pre> <p>The generated class will implement the <code>Illuminate\Contracts\Queue\ShouldQueue</code> interface, indicating to Laravel that the job should be pushed onto the queue to run asynchronously.</p> <blockquote class="tip"> <p>Job stubs may be customized using <a href="artisan#stub-customization">stub publishing</a></p> </blockquote>  <h3 id="class-structure">Class Structure</h3> <p>Job classes are very simple, normally containing only a <code>handle</code> method which is called when the job is processed by the queue. To get started, let's take a look at an example job class. In this example, we'll pretend we manage a podcast publishing service and need to process the uploaded podcast files before they are published:</p> <pre data-language="php">&lt;?php

namespace App\Jobs;

use App\Models\Podcast;
use App\Services\AudioProcessor;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;

class ProcessPodcast implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    protected $podcast;

    /**
     * Create a new job instance.
     *
     * @param  Podcast  $podcast
     * @return void
     */
    public function __construct(Podcast $podcast)
    {
        $this-&gt;podcast = $podcast;
    }

    /**
     * Execute the job.
     *
     * @param  AudioProcessor  $processor
     * @return void
     */
    public function handle(AudioProcessor $processor)
    {
        // Process uploaded podcast...
    }
}</pre> <p>In this example, note that we were able to pass an <a href="eloquent">Eloquent model</a> directly into the queued job's constructor. Because of the <code>SerializesModels</code> trait that the job is using, Eloquent models and their loaded relationships will be gracefully serialized and unserialized when the job is processing. If your queued job accepts an Eloquent model in its constructor, only the identifier for the model will be serialized onto the queue. When the job is actually handled, the queue system will automatically re-retrieve the full model instance and its loaded relationships from the database. It's all totally transparent to your application and prevents issues that can arise from serializing full Eloquent model instances.</p> <p>The <code>handle</code> method is called when the job is processed by the queue. Note that we are able to type-hint dependencies on the <code>handle</code> method of the job. The Laravel <a href="container">service container</a> automatically injects these dependencies.</p> <p>If you would like to take total control over how the container injects dependencies into the <code>handle</code> method, you may use the container's <code>bindMethod</code> method. The <code>bindMethod</code> method accepts a callback which receives the job and the container. Within the callback, you are free to invoke the <code>handle</code> method however you wish. Typically, you should call this method from a <a href="providers">service provider</a>:</p> <pre data-language="php">use App\Jobs\ProcessPodcast;

$this-&gt;app-&gt;bindMethod(ProcessPodcast::class.'@handle', function ($job, $app) {
    return $job-&gt;handle($app-&gt;make(AudioProcessor::class));
});</pre> <blockquote> <p>Binary data, such as raw image contents, should be passed through the <code>base64_encode</code> function before being passed to a queued job. Otherwise, the job may not properly serialize to JSON when being placed on the queue.</p> </blockquote>  <h4 id="handling-relationships">Handling Relationships</h4> <p>Because loaded relationships also get serialized, the serialized job string can become quite large. To prevent relations from being serialized, you can call the <code>withoutRelations</code> method on the model when setting a property value. This method will return an instance of the model with no loaded relationships:</p> <pre data-language="php">/**
 * Create a new job instance.
 *
 * @param  \App\Models\Podcast  $podcast
 * @return void
 */
public function __construct(Podcast $podcast)
{
    $this-&gt;podcast = $podcast-&gt;withoutRelations();
}</pre>  <h3 id="unique-jobs">Unique Jobs</h3> <blockquote> <p>Unique jobs require a cache driver that supports <a href="cache#atomic-locks">locks</a>.</p> </blockquote> <p>Sometimes, you may want to ensure that only one instance of a specific job is on the queue at any point in time. You may do so by implementing the <code>ShouldBeUnique</code> interface on your job class:</p> <pre data-language="php">&lt;?php

use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Contracts\Queue\ShouldBeUnique;

class UpdateSearchIndex implements ShouldQueue, ShouldBeUnique
{
    ...
}</pre> <p>In the example above, the <code>UpdateSearchIndex</code> job is unique. So, new dispatches of the job will be ignored if another instance of the job is already on the queue and has not finished processing.</p> <p>In certain cases, you may want to define a specific "key" that makes the job unique or you may want to specify a timeout beyond which the job no longer stays unique. To accomplish this, you may define <code>uniqueId</code> and <code>uniqueFor</code> properties or methods on your job class:</p> <pre data-language="php">&lt;?php

use App\Product;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Contracts\Queue\ShouldBeUnique;

class UpdateSearchIndex implements ShouldQueue, ShouldBeUnique
{
    /**
     * The product instance.
     *
     * @var \App\Product
     */
    public $product;

    /**
    * The number of seconds after which the job's unique lock will be released.
    *
    * @var int
    */
    public $uniqueFor = 3600;

    /**
    * The unique ID of the job.
    *
    * @return string
    */
    public function uniqueId()
    {
        return $this-&gt;product-&gt;id;
    }
}</pre> <p>In the example above, the <code>UpdateSearchIndex</code> job is unique by a product ID. So, any new dispatches of the job with the same product ID will be ignored until the existing job has completed processing. In addition, if the existing job is not processed within one hour, the unique lock will be released and another job with the same unique key can be dispatched to the queue.</p>  <h4 id="unique-job-locks">Unique Job Locks</h4> <p>Behind the scenes, when a <code>ShouldBeUnique</code> job is dispatched, Laravel attempts to acquire a <a href="cache#atomic-locks">lock</a> with the <code>uniqueId</code> key. If the lock is not acquired, the dispatch is ignored. This lock is released when the job completes processing or fails all of its retry attempts. By default, Laravel will use the default cache driver to obtain this lock. However, if you wish to use another driver for acquiring the lock, you may define a <code>uniqueVia</code> method the returns the cache driver that should be used:</p> <pre data-language="php">use Illuminate\Support\Facades\Cache;

class UpdateSearchIndex implements ShouldQueue, ShouldBeUnique
{
    ...

    /**
    * Get the cache driver for the unique job lock.
    *
    * @return \Illuminate\Contracts\Cache\Repository
    */
    public function uniqueVia()
    {
        return Cache::driver('redis');
    }
}</pre> <blockquote class="tip"> <p>If only need to limit the concurrent processing of a job, use the <a href="queues#preventing-job-overlaps"><code>WithoutOverlapping</code></a> job middleware instead.</p> </blockquote>  <h2 id="job-middleware">Job Middleware</h2> <p>Job middleware allow you to wrap custom logic around the execution of queued jobs, reducing boilerplate in the jobs themselves. For example, consider the following <code>handle</code> method which leverages Laravel's Redis rate limiting features to allow only one job to process every five seconds:</p> <pre data-language="php">/**
 * Execute the job.
 *
 * @return void
 */
public function handle()
{
    Redis::throttle('key')-&gt;block(0)-&gt;allow(1)-&gt;every(5)-&gt;then(function () {
        info('Lock obtained...');

        // Handle job...
    }, function () {
        // Could not obtain lock...

        return $this-&gt;release(5);
    });
}</pre> <p>While this code is valid, the structure of the <code>handle</code> method becomes noisy since it is cluttered with Redis rate limiting logic. In addition, this rate limiting logic must be duplicated for any other jobs that we want to rate limit.</p> <p>Instead of rate limiting in the handle method, we could define a job middleware that handles rate limiting. Laravel does not have a default location for job middleware, so you are welcome to place job middleware anywhere in your application. In this example, we will place the middleware in a <code>app/Jobs/Middleware</code> directory:</p> <pre data-language="php">&lt;?php

namespace App\Jobs\Middleware;

use Illuminate\Support\Facades\Redis;

class RateLimited
{
    /**
     * Process the queued job.
     *
     * @param  mixed  $job
     * @param  callable  $next
     * @return mixed
     */
    public function handle($job, $next)
    {
        Redis::throttle('key')
                -&gt;block(0)-&gt;allow(1)-&gt;every(5)
                -&gt;then(function () use ($job, $next) {
                    // Lock obtained...

                    $next($job);
                }, function () use ($job) {
                    // Could not obtain lock...

                    $job-&gt;release(5);
                });
    }
}</pre> <p>As you can see, like <a href="middleware">route middleware</a>, job middleware receive the job being processed and a callback that should be invoked to continue processing the job.</p> <p>After creating job middleware, they may be attached to a job by returning them from the job's <code>middleware</code> method. This method does not exist on jobs scaffolded by the <code>make:job</code> Artisan command, so you will need to add it to your own job class definition:</p> <pre data-language="php">use App\Jobs\Middleware\RateLimited;

/**
 * Get the middleware the job should pass through.
 *
 * @return array
 */
public function middleware()
{
    return [new RateLimited];
}</pre>  <h3 id="rate-limiting">Rate Limiting</h3> <p>Although we just demonstrated how to write your own rate limiting job middleware, Laravel includes a rate limiting middleware that you may utilize to rate limit jobs. Like <a href="routing#defining-rate-limiter">route rate limiters</a>, job rate limiters are defined using the <code>RateLimiter</code> facade's <code>for</code> method.</p> <p>For example, you may wish to allow users to backup their data once per hour while imposing no such limit on premium customers. To accomplish this, you may define a <code>RateLimiter</code> in your <code>AppServiceProvider</code>:</p> <pre data-language="php">use Illuminate\Support\Facades\RateLimiter;

RateLimiter::for('backups', function ($job) {
    return $job-&gt;user-&gt;vipCustomer()
                ? Limit::none()
                : Limit::perHour(1)-&gt;by($job-&gt;user-&gt;id);
});</pre> <p>You may then attach the rate limiter to your backup job using the <code>RateLimited</code> middleware. Each time the job exceeds the rate limit, this middleware will release the job back to the queue with an appropriate delay based on the rate limit duration.</p> <pre data-language="php">use Illuminate\Queue\Middleware\RateLimited;

/**
 * Get the middleware the job should pass through.
 *
 * @return array
 */
public function middleware()
{
    return [new RateLimited('backups')];
}</pre> <p>Releasing a rate limited job back onto the queue will still increment the job's total number of <code>attempts</code>. You may wish to tune your <code>tries</code> and <code>maxExceptions</code> properties on your job class accordingly. Or, you may wish to use the <a href="#time-based-attempts"><code>retryUntil</code> method</a> to define the amount of time until the job should no longer be attempted.</p> <blockquote class="tip"> <p>If you are using Redis, you may use the <code>RateLimitedWithRedis</code> middleware, which is fine-tuned for Redis and more efficient than the basic rate limiting middleware.</p> </blockquote>  <h3 id="preventing-job-overlaps">Preventing Job Overlaps</h3> <p>Laravel includes a <code>WithoutOverlapping</code> middleware that allows you to prevent job overlaps based on an arbitrary key. This can be helpful when a queued job is modifying a resource that should only be modified by one job at a time.</p> <p>For example, let's imagine you have a refund processing job and you want to prevent refund job overlaps for the same order ID. To accomplish this, you can return the <code>WithoutOverlapping</code> middleware from your refund processing job's <code>middleware</code> method:</p> <pre data-language="php">use Illuminate\Queue\Middleware\WithoutOverlapping;

/**
 * Get the middleware the job should pass through.
 *
 * @return array
 */
public function middleware()
{
    return [new WithoutOverlapping($this-&gt;order-&gt;id)];
}</pre> <p>Any overlapping jobs will be released back to the queue. You may also specify the number of seconds that must elapse before the job will be attempted again:</p> <pre data-language="php">/**
 * Get the middleware the job should pass through.
 *
 * @return array
 */
public function middleware()
{
    return [(new WithoutOverlapping($this-&gt;order-&gt;id))-&gt;releaseAfter(60)];
}</pre> <p>If you wish to immediately delete any overlapping jobs, you may use the <code>dontRelease</code> method:</p> <pre data-language="php">/**
 * Get the middleware the job should pass through.
 *
 * @return array
 */
public function middleware()
{
    return [(new WithoutOverlapping($this-&gt;order-&gt;id))-&gt;dontRelease()];
}</pre> <blockquote> <p>The <code>WithoutOverlapping</code> middleware requires a cache driver that supports <a href="cache#atomic-locks">locks</a>.</p> </blockquote>  <h2 id="dispatching-jobs">Dispatching Jobs</h2> <p>Once you have written your job class, you may dispatch it using the <code>dispatch</code> method on the job itself. The arguments passed to the <code>dispatch</code> method will be given to the job's constructor:</p> <pre data-language="php">&lt;?php

namespace App\Http\Controllers;

use App\Http\Controllers\Controller;
use App\Jobs\ProcessPodcast;
use Illuminate\Http\Request;

class PodcastController extends Controller
{
    /**
     * Store a new podcast.
     *
     * @param  Request  $request
     * @return Response
     */
    public function store(Request $request)
    {
        // Create podcast...

        ProcessPodcast::dispatch($podcast);
    }
}</pre> <p>If you would like to conditionally dispatch a job, you may use the <code>dispatchIf</code> and <code>dispatchUnless</code> methods:</p> <pre data-language="php">ProcessPodcast::dispatchIf($accountActive === true, $podcast);

ProcessPodcast::dispatchUnless($accountSuspended === false, $podcast);</pre>  <h3 id="delayed-dispatching">Delayed Dispatching</h3> <p>If you would like to delay the execution of a queued job, you may use the <code>delay</code> method when dispatching a job. For example, let's specify that a job should not be available for processing until 10 minutes after it has been dispatched:</p> <pre data-language="php">&lt;?php

namespace App\Http\Controllers;

use App\Http\Controllers\Controller;
use App\Jobs\ProcessPodcast;
use Illuminate\Http\Request;

class PodcastController extends Controller
{
    /**
     * Store a new podcast.
     *
     * @param  Request  $request
     * @return Response
     */
    public function store(Request $request)
    {
        // Create podcast...

        ProcessPodcast::dispatch($podcast)
                -&gt;delay(now()-&gt;addMinutes(10));
    }
}</pre> <blockquote> <p>The Amazon SQS queue service has a maximum delay time of 15 minutes.</p> </blockquote>  <h4 id="dispatching-after-the-response-is-sent-to-browser">Dispatching After The Response Is Sent To Browser</h4> <p>Alternatively, the <code>dispatchAfterResponse</code> method delays dispatching a job until after the response is sent to the user's browser. This will still allow the user to begin using the application even though a queued job is still executing. This should typically only be used for jobs that take about a second, such as sending an email:</p> <pre data-language="php">use App\Jobs\SendNotification;

SendNotification::dispatchAfterResponse();</pre> <p>You may <code>dispatch</code> a Closure and chain the <code>afterResponse</code> method onto the helper to execute a Closure after the response has been sent to the browser:</p> <pre data-language="php">use App\Mail\WelcomeMessage;
use Illuminate\Support\Facades\Mail;

dispatch(function () {
    Mail::to('taylor@laravel.com')-&gt;send(new WelcomeMessage);
})-&gt;afterResponse();</pre>  <h3 id="synchronous-dispatching">Synchronous Dispatching</h3> <p>If you would like to dispatch a job immediately (synchronously), you may use the <code>dispatchSync</code> method. When using this method, the job will not be queued and will be run immediately within the current process:</p> <pre data-language="php">&lt;?php

namespace App\Http\Controllers;

use App\Http\Controllers\Controller;
use App\Jobs\ProcessPodcast;
use Illuminate\Http\Request;

class PodcastController extends Controller
{
    /**
     * Store a new podcast.
     *
     * @param  Request  $request
     * @return Response
     */
    public function store(Request $request)
    {
        // Create podcast...

        ProcessPodcast::dispatchSync($podcast);
    }
}</pre>  <h3 id="job-chaining">Job Chaining</h3> <p>Job chaining allows you to specify a list of queued jobs that should be run in sequence after the primary job has executed successfully. If one job in the sequence fails, the rest of the jobs will not be run. To execute a queued job chain, you may use the <code>chain</code> method provided by the <code>Bus</code> facade:</p> <pre data-language="php">use Illuminate\Support\Facades\Bus;

Bus::chain([
    new ProcessPodcast,
    new OptimizePodcast,
    new ReleasePodcast,
])-&gt;dispatch();</pre> <p>In addition to chaining job class instances, you may also chain Closures:</p> <pre data-language="php">Bus::chain([
    new ProcessPodcast,
    new OptimizePodcast,
    function () {
        Podcast::update(...);
    },
])-&gt;dispatch();</pre> <blockquote> <p>Deleting jobs using the <code>$this-&gt;delete()</code> method will not prevent chained jobs from being processed. The chain will only stop executing if a job in the chain fails.</p> </blockquote>  <h4 id="chain-connection-queue">Chain Connection &amp; Queue</h4> <p>If you would like to specify the connection and queue that should be used for the chained jobs, you may use the <code>onConnection</code> and <code>onQueue</code> methods. These methods specify the queue connection and queue name that should be used unless the queued job is explicitly assigned a different connection / queue:</p> <pre data-language="php">Bus::chain([
    new ProcessPodcast,
    new OptimizePodcast,
    new ReleasePodcast,
])-&gt;onConnection('redis')-&gt;onQueue('podcasts')-&gt;dispatch();</pre>  <h4 id="chain-failures">Chain Failures</h4> <p>When chaining jobs, you may use the <code>catch</code> method to specify a Closure that should be invoked if a job within the chain fails. The given callback will receive the exception instance that caused the job failure:</p> <pre data-language="php">use Illuminate\Support\Facades\Bus;
use Throwable;

Bus::chain([
    new ProcessPodcast,
    new OptimizePodcast,
    new ReleasePodcast,
])-&gt;catch(function (Throwable $e) {
    // A job within the chain has failed...
})-&gt;dispatch();</pre>  <h3 id="customizing-the-queue-and-connection">Customizing The Queue &amp; Connection</h3>  <h4 id="dispatching-to-a-particular-queue">Dispatching To A Particular Queue</h4> <p>By pushing jobs to different queues, you may "categorize" your queued jobs and even prioritize how many workers you assign to various queues. Keep in mind, this does not push jobs to different queue "connections" as defined by your queue configuration file, but only to specific queues within a single connection. To specify the queue, use the <code>onQueue</code> method when dispatching the job:</p> <pre data-language="php">&lt;?php

namespace App\Http\Controllers;

use App\Http\Controllers\Controller;
use App\Jobs\ProcessPodcast;
use Illuminate\Http\Request;

class PodcastController extends Controller
{
    /**
     * Store a new podcast.
     *
     * @param  Request  $request
     * @return Response
     */
    public function store(Request $request)
    {
        // Create podcast...

        ProcessPodcast::dispatch($podcast)-&gt;onQueue('processing');
    }
}</pre>  <h4 id="dispatching-to-a-particular-connection">Dispatching To A Particular Connection</h4> <p>If you are working with multiple queue connections, you may specify which connection to push a job to. To specify the connection, use the <code>onConnection</code> method when dispatching the job:</p> <pre data-language="php">&lt;?php

namespace App\Http\Controllers;

use App\Http\Controllers\Controller;
use App\Jobs\ProcessPodcast;
use Illuminate\Http\Request;

class PodcastController extends Controller
{
    /**
     * Store a new podcast.
     *
     * @param  Request  $request
     * @return Response
     */
    public function store(Request $request)
    {
        // Create podcast...

        ProcessPodcast::dispatch($podcast)-&gt;onConnection('sqs');
    }
}</pre> <p>You may chain the <code>onConnection</code> and <code>onQueue</code> methods to specify the connection and the queue for a job:</p> <pre data-language="php">ProcessPodcast::dispatch($podcast)
              -&gt;onConnection('sqs')
              -&gt;onQueue('processing');</pre>  <h3 id="max-job-attempts-and-timeout">Specifying Max Job Attempts / Timeout Values</h3>  <h4 id="max-attempts">Max Attempts</h4> <p>One approach to specifying the maximum number of times a job may be attempted is via the <code>--tries</code> switch on the Artisan command line:</p> <pre data-language="php">php artisan queue:work --tries=3</pre> <p>However, you may take a more granular approach by defining the maximum number of attempts on the job class itself. If the maximum number of attempts is specified on the job, it will take precedence over the value provided on the command line:</p> <pre data-language="php">&lt;?php

namespace App\Jobs;

class ProcessPodcast implements ShouldQueue
{
    /**
     * The number of times the job may be attempted.
     *
     * @var int
     */
    public $tries = 5;
}</pre>  <h4 id="time-based-attempts">Time Based Attempts</h4> <p>As an alternative to defining how many times a job may be attempted before it fails, you may define a time at which the job should timeout. This allows a job to be attempted any number of times within a given time frame. To define the time at which a job should timeout, add a <code>retryUntil</code> method to your job class:</p> <pre data-language="php">/**
 * Determine the time at which the job should timeout.
 *
 * @return \DateTime
 */
public function retryUntil()
{
    return now()-&gt;addSeconds(5);
}</pre> <blockquote class="tip"> <p>You may also define a <code>retryUntil</code> method on your queued event listeners.</p> </blockquote>  <h4 id="max-exceptions">Max Exceptions</h4> <p>Sometimes you may wish to specify that a job may be attempted many times, but should fail if the retries are triggered by a given number of exceptions. To accomplish this, you may define a <code>maxExceptions</code> property on your job class:</p> <pre data-language="php">&lt;?php

namespace App\Jobs;

class ProcessPodcast implements ShouldQueue
{
    /**
     * The number of times the job may be attempted.
     *
     * @var int
     */
    public $tries = 25;

    /**
     * The maximum number of exceptions to allow before failing.
     *
     * @var int
     */
    public $maxExceptions = 3;

    /**
     * Execute the job.
     *
     * @return void
     */
    public function handle()
    {
        Redis::throttle('key')-&gt;allow(10)-&gt;every(60)-&gt;then(function () {
            // Lock obtained, process the podcast...
        }, function () {
            // Unable to obtain lock...
            return $this-&gt;release(10);
        });
    }
}</pre> <p>In this example, the job is released for ten seconds if the application is unable to obtain a Redis lock and will continue to be retried up to 25 times. However, the job will fail if three unhandled exceptions are thrown by the job.</p>  <h4 id="timeout">Timeout</h4> <blockquote> <p>The <code>pcntl</code> PHP extension must be installed in order to specify job timeouts.</p> </blockquote> <p>Likewise, the maximum number of seconds that jobs can run may be specified using the <code>--timeout</code> switch on the Artisan command line:</p> <pre data-language="php">php artisan queue:work --timeout=30</pre> <p>However, you may also define the maximum number of seconds a job should be allowed to run on the job class itself. If the timeout is specified on the job, it will take precedence over any timeout specified on the command line:</p> <pre data-language="php">&lt;?php

namespace App\Jobs;

class ProcessPodcast implements ShouldQueue
{
    /**
     * The number of seconds the job can run before timing out.
     *
     * @var int
     */
    public $timeout = 120;
}</pre> <p>Sometimes, IO blocking processes such as sockets or outgoing HTTP connections may not respect your specified timeout. Therefore, when using these features, you should always attempt to specify a timeout using their APIs as well. For example, when using Guzzle, you should always specify a connection and request timeout value.</p>  <h3 id="error-handling">Error Handling</h3> <p>If an exception is thrown while the job is being processed, the job will automatically be released back onto the queue so it may be attempted again. The job will continue to be released until it has been attempted the maximum number of times allowed by your application. The maximum number of attempts is defined by the <code>--tries</code> switch used on the <code>queue:work</code> Artisan command. Alternatively, the maximum number of attempts may be defined on the job class itself. More information on running the queue worker <a href="#running-the-queue-worker">can be found below</a>.</p>  <h2 id="job-batching">Job Batching</h2> <p>Laravel's job batching feature allows you to easily execute a batch of jobs and then perform some action when the batch of jobs has completed executing. Before getting started, you should create a database migration to build a table that will contain your job batch meta information. This migration may be generated using the <code>queue:batches-table</code> Artisan command:</p> <pre data-language="php">php artisan queue:batches-table

php artisan migrate</pre>  <h3 id="defining-batchable-jobs">Defining Batchable Jobs</h3> <p>To build a batchable job, you should <a href="#creating-jobs">create a queueable job</a> as normal; however, you should add the <code>Illuminate\Bus\Batchable</code> trait to the job class. This trait provides access to a <code>batch</code> method which may be used to retrieve the current batch that the job is executing in:</p> <pre data-language="php">&lt;?php

namespace App\Jobs;

use App\Models\Podcast;
use App\Services\AudioProcessor;
use Illuminate\Bus\Batchable;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;

class ProcessPodcast implements ShouldQueue
{
    use Batchable, Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    /**
     * Execute the job.
     *
     * @return void
     */
    public function handle()
    {
        if ($this-&gt;batch()-&gt;cancelled()) {
            // Detected cancelled batch...

            return;
        }

        // Batched job executing...
    }
}</pre>  <h3 id="dispatching-batches">Dispatching Batches</h3> <p>To dispatch a batch of jobs, you should use the <code>batch</code> method of the <code>Bus</code> facade. Of course, batching is primarily useful when combined with completion callbacks. So, you may use the <code>then</code>, <code>catch</code>, and <code>finally</code> methods to define completion callbacks for the batch. Each of these callbacks will receive an <code>Illuminate\Bus\Batch</code> instance when they are invoked:</p> <pre data-language="php">use App\Jobs\ProcessPodcast;
use App\Podcast;
use Illuminate\Bus\Batch;
use Illuminate\Support\Facades\Bus;
use Throwable;

$batch = Bus::batch([
    new ProcessPodcast(Podcast::find(1)),
    new ProcessPodcast(Podcast::find(2)),
    new ProcessPodcast(Podcast::find(3)),
    new ProcessPodcast(Podcast::find(4)),
    new ProcessPodcast(Podcast::find(5)),
])-&gt;then(function (Batch $batch) {
    // All jobs completed successfully...
})-&gt;catch(function (Batch $batch, Throwable $e) {
    // First batch job failure detected...
})-&gt;finally(function (Batch $batch) {
    // The batch has finished executing...
})-&gt;dispatch();

return $batch-&gt;id;</pre>  <h4 id="naming-batches">Naming Batches</h4> <p>Some tools such as Laravel Horizon and Laravel Telescope may provide more user-friendly debug information for batches if batches are named. To assign an arbitrary name to a batch, you may call the <code>name</code> method while defining the batch:</p> <pre data-language="php">$batch = Bus::batch([
    // ...
])-&gt;then(function (Batch $batch) {
    // All jobs completed successfully...
})-&gt;name('Process Podcasts')-&gt;dispatch();</pre>  <h4 id="batch-connection-queue">Batch Connection &amp; Queue</h4> <p>If you would like to specify the connection and queue that should be used for the batched jobs, you may use the <code>onConnection</code> and <code>onQueue</code> methods:</p> <pre data-language="php">$batch = Bus::batch([
    // ...
])-&gt;then(function (Batch $batch) {
    // All jobs completed successfully...
})-&gt;onConnection('redis')-&gt;onQueue('podcasts')-&gt;dispatch();</pre>  <h4 id="chains-within-batches">Chains Within Batches</h4> <p>You may add a set of <a href="#job-chaining">chained jobs</a> within a batch by placing the chained jobs within an array. For example, we may execute two job chains in parallel. Since the two chains are batched, we will be able to inspect the batch completion progress as a whole:</p> <pre data-language="php">Bus::batch([
    [
        new ReleasePodcast(1),
        new SendPodcastReleaseNotification(1),
    ],
    [
        new ReleasePodcast(2),
        new SendPodcastReleaseNotification(2),
    ],
])-&gt;dispatch();</pre>  <h3 id="adding-jobs-to-batches">Adding Jobs To Batches</h3> <p>Sometimes it may be useful to add additional jobs to a batch from within a batched job. This pattern can be useful when you need to batch thousands of jobs which may take too long to dispatch during a web request. So, instead, you may wish to dispatch an initial batch of "loader" jobs that hydrate the batch with more jobs:</p> <pre data-language="php">$batch = Bus::batch([
    new LoadImportBatch,
    new LoadImportBatch,
    new LoadImportBatch,
])-&gt;then(function (Batch $batch) {
    // All jobs completed successfully...
})-&gt;name('Import Contacts')-&gt;dispatch();</pre> <p>In this example, we will use the <code>LoadImportBatch</code> job to hydrate the batch with additional jobs. To accomplish this, we may use the <code>add</code> method on the batch instance that can be accessed within the job:</p> <pre data-language="php">use App\Jobs\ImportContacts;
use Illuminate\Support\Collection;

/**
 * Execute the job.
 *
 * @return void
 */
public function handle()
{
    if ($this-&gt;batch()-&gt;cancelled()) {
        return;
    }

    $this-&gt;batch()-&gt;add(Collection::times(1000, function () {
        return new ImportContacts;
    }));
}</pre> <blockquote> <p>You may only add jobs to a batch from within a job that belongs to the same batch.</p> </blockquote>  <h3 id="inspecting-batches">Inspecting Batches</h3> <p>The <code>Illuminate\Bus\Batch</code> method that is provided to batch completion callbacks has a variety of properties and methods to assist you in interacting with and inspecting a given batch of jobs.</p> <pre data-language="php">// The UUID of the batch...
$batch-&gt;id;

// The name of the batch (if applicable)...
$batch-&gt;name;

// The number of jobs assigned to the batch...
$batch-&gt;totalJobs;

// The number of jobs that have not been processed by the queue...
$batch-&gt;pendingJobs;

// The number of jobs that have failed...
$batch-&gt;failedJobs;

// The number of jobs that have been processed thus far...
$batch-&gt;processedJobs();

// The completion percentage of the batch (0-100)...
$batch-&gt;progress();

// Indicates if the batch has finished executing...
$batch-&gt;finished();

// Cancel the execution of the batch...
$batch-&gt;cancel();

// Indicates if the batch has been cancelled...
$batch-&gt;cancelled();</pre>  <h4 id="returning-batches-from-routes">Returning Batches From Routes</h4> <p>All <code>Illuminate\Bus\Batch</code> instances are JSON serializable, meaning you can return them directly from one of your application's routes to retrieve a JSON payload containing information about the batch, including its completion progress. To retrieve a batch by its ID, you may use the <code>Bus</code> facade's <code>findBatch</code> method:</p> <pre data-language="php">use Illuminate\Support\Facades\Bus;
use Illuminate\Support\Facades\Route;

Route::get('/batch/{batchId}', function (string $batchId) {
    return Bus::findBatch($batchId);
});</pre>  <h3 id="cancelling-batches">Cancelling Batches</h3> <p>Sometimes you may need to cancel a given batch's execution. This can be accomplished by calling the <code>cancel</code> method on the <code>Illuminate\Bus\Batch</code> instance:</p> <pre data-language="php">/**
 * Execute the job.
 *
 * @return void
 */
public function handle()
{
    if ($this-&gt;user-&gt;exceedsImportLimit()) {
        return $this-&gt;batch()-&gt;cancel();
    }

    if ($this-&gt;batch()-&gt;cancelled()) {
        return;
    }
}</pre>  <h3 id="batch-failures">Batch Failures</h3> <p>When a batch job fails, the <code>catch</code> callback (if assigned) will be invoked. This callback is only invoked for the job that fails within the batch.</p>  <h4 id="allowing-failures">Allowing Failures</h4> <p>When a job within a batch fails, Laravel will automatically mark the batch as "cancelled". If you wish, you may disable this behavior so that a job failure does not automatically mark the batch as cancelled. This may be accomplished by calling the <code>allowFailures</code> method while dispatching the batch:</p> <pre data-language="php">$batch = Bus::batch([
    // ...
])-&gt;then(function (Batch $batch) {
    // All jobs completed successfully...
})-&gt;allowFailures()-&gt;dispatch();</pre>  <h4 id="retrying-failed-batch-jobs">Retrying Failed Batch Jobs</h4> <p>For convenience, Laravel provides a <code>queue:retry-batch</code> Artisan command that allows you to easily retry all of the failed jobs for a given batch. The <code>queue:retry-batch</code> command accepts the UUID of the batch whose failed jobs should be retried:</p> <pre data-language="php">php artisan queue:retry-batch 32dbc76c-4f82-4749-b610-a639fe0099b5</pre>  <h2 id="queueing-closures">Queueing Closures</h2> <p>Instead of dispatching a job class to the queue, you may also dispatch a Closure. This is great for quick, simple tasks that need to be executed outside of the current request cycle. When dispatching Closures to the queue, the Closure's code contents is cryptographically signed so it can not be modified in transit:</p> <pre data-language="php">$podcast = App\Podcast::find(1);

dispatch(function () use ($podcast) {
    $podcast-&gt;publish();
});</pre> <p>Using the <code>catch</code> method, you may provide a Closure that should be executed if the queued Closure fails to complete successfully after exhausting all of your queue's configured retry attempts:</p> <pre data-language="php">use Throwable;

dispatch(function () use ($podcast) {
    $podcast-&gt;publish();
})-&gt;catch(function (Throwable $e) {
    // This job has failed...
});</pre>  <h2 id="running-the-queue-worker">Running The Queue Worker</h2> <p>Laravel includes a queue worker that will process new jobs as they are pushed onto the queue. You may run the worker using the <code>queue:work</code> Artisan command. Note that once the <code>queue:work</code> command has started, it will continue to run until it is manually stopped or you close your terminal:</p> <pre data-language="php">php artisan queue:work</pre> <blockquote class="tip"> <p>To keep the <code>queue:work</code> process running permanently in the background, you should use a process monitor such as <a href="#supervisor-configuration">Supervisor</a> to ensure that the queue worker does not stop running.</p> </blockquote> <p>Remember, queue workers are long-lived processes and store the booted application state in memory. As a result, they will not notice changes in your code base after they have been started. So, during your deployment process, be sure to <a href="#queue-workers-and-deployment">restart your queue workers</a>. In addition, remember that any static state created or modified by your application will not be automatically reset between jobs.</p> <p>Alternatively, you may run the <code>queue:listen</code> command. When using the <code>queue:listen</code> command, you don't have to manually restart the worker when you want to reload your updated code or reset the application state; however, this command is not as efficient as <code>queue:work</code>:</p> <pre data-language="php">php artisan queue:listen</pre>  <h4 id="specifying-the-connection-queue">Specifying The Connection &amp; Queue</h4> <p>You may also specify which queue connection the worker should utilize. The connection name passed to the <code>work</code> command should correspond to one of the connections defined in your <code>config/queue.php</code> configuration file:</p> <pre data-language="php">php artisan queue:work redis</pre> <p>You may customize your queue worker even further by only processing particular queues for a given connection. For example, if all of your emails are processed in an <code>emails</code> queue on your <code>redis</code> queue connection, you may issue the following command to start a worker that only processes that queue:</p> <pre data-language="php">php artisan queue:work redis --queue=emails</pre>  <h4 id="processing-a-specified-number-of-jobs">Processing A Specified Number Of Jobs</h4> <p>The <code>--once</code> option may be used to instruct the worker to only process a single job from the queue:</p> <pre data-language="php">php artisan queue:work --once</pre> <p>The <code>--max-jobs</code> option may be used to instruct the worker to process the given number of jobs and then exit. This option may be useful when combined with <a href="#supervisor-configuration">Supervisor</a> so that your workers are automatically restarted after processing a given number of jobs:</p> <pre data-language="php">php artisan queue:work --max-jobs=1000</pre>  <h4 id="processing-all-queued-jobs-then-exiting">Processing All Queued Jobs &amp; Then Exiting</h4> <p>The <code>--stop-when-empty</code> option may be used to instruct the worker to process all jobs and then exit gracefully. This option can be useful when working Laravel queues within a Docker container if you wish to shutdown the container after the queue is empty:</p> <pre data-language="php">php artisan queue:work --stop-when-empty</pre>  <h4 id="processing-jobs-for-a-given-number-of-seconds">Processing Jobs For A Given Number Of Seconds</h4> <p>The <code>--max-time</code> option may be used to instruct the worker to process jobs for the given number of seconds and then exit. This option may be useful when combined with <a href="#supervisor-configuration">Supervisor</a> so that your workers are automatically restarted after processing jobs for a given amount of time:</p> <pre data-language="php">// Process jobs for one hour and then exit...
php artisan queue:work --max-time=3600</pre>  <h4 id="resource-considerations">Resource Considerations</h4> <p>Daemon queue workers do not "reboot" the framework before processing each job. Therefore, you should free any heavy resources after each job completes. For example, if you are doing image manipulation with the GD library, you should free the memory with <code>imagedestroy</code> when you are done.</p>  <h3 id="queue-priorities">Queue Priorities</h3> <p>Sometimes you may wish to prioritize how your queues are processed. For example, in your <code>config/queue.php</code> you may set the default <code>queue</code> for your <code>redis</code> connection to <code>low</code>. However, occasionally you may wish to push a job to a <code>high</code> priority queue like so:</p> <pre data-language="php">dispatch((new Job)-&gt;onQueue('high'));</pre> <p>To start a worker that verifies that all of the <code>high</code> queue jobs are processed before continuing to any jobs on the <code>low</code> queue, pass a comma-delimited list of queue names to the <code>work</code> command:</p> <pre data-language="php">php artisan queue:work --queue=high,low</pre>  <h3 id="queue-workers-and-deployment">Queue Workers &amp; Deployment</h3> <p>Since queue workers are long-lived processes, they will not pick up changes to your code without being restarted. So, the simplest way to deploy an application using queue workers is to restart the workers during your deployment process. You may gracefully restart all of the workers by issuing the <code>queue:restart</code> command:</p> <pre data-language="php">php artisan queue:restart</pre> <p>This command will instruct all queue workers to gracefully "die" after they finish processing their current job so that no existing jobs are lost. Since the queue workers will die when the <code>queue:restart</code> command is executed, you should be running a process manager such as <a href="#supervisor-configuration">Supervisor</a> to automatically restart the queue workers.</p> <blockquote class="tip"> <p>The queue uses the <a href="cache">cache</a> to store restart signals, so you should verify a cache driver is properly configured for your application before using this feature.</p> </blockquote>  <h3 id="job-expirations-and-timeouts">Job Expirations &amp; Timeouts</h3>  <h4 id="job-expiration">Job Expiration</h4> <p>In your <code>config/queue.php</code> configuration file, each queue connection defines a <code>retry_after</code> option. This option specifies how many seconds the queue connection should wait before retrying a job that is being processed. For example, if the value of <code>retry_after</code> is set to <code>90</code>, the job will be released back onto the queue if it has been processing for 90 seconds without being deleted. Typically, you should set the <code>retry_after</code> value to the maximum number of seconds your jobs should reasonably take to complete processing.</p> <blockquote> <p>The only queue connection which does not contain a <code>retry_after</code> value is Amazon SQS. SQS will retry the job based on the <a href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/AboutVT.html">Default Visibility Timeout</a> which is managed within the AWS console.</p> </blockquote>  <h4 id="worker-timeouts">Worker Timeouts</h4> <p>The <code>queue:work</code> Artisan command exposes a <code>--timeout</code> option. The <code>--timeout</code> option specifies how long the Laravel queue master process will wait before killing off a child queue worker that is processing a job. Sometimes a child queue process can become "frozen" for various reasons. The <code>--timeout</code> option removes frozen processes that have exceeded that specified time limit:</p> <pre data-language="php">php artisan queue:work --timeout=60</pre> <p>The <code>retry_after</code> configuration option and the <code>--timeout</code> CLI option are different, but work together to ensure that jobs are not lost and that jobs are only successfully processed once.</p> <blockquote> <p>The <code>--timeout</code> value should always be at least several seconds shorter than your <code>retry_after</code> configuration value. This will ensure that a worker processing a given job is always killed before the job is retried. If your <code>--timeout</code> option is longer than your <code>retry_after</code> configuration value, your jobs may be processed twice.</p> </blockquote>  <h4 id="worker-sleep-duration">Worker Sleep Duration</h4> <p>When jobs are available on the queue, the worker will keep processing jobs with no delay in between them. However, the <code>sleep</code> option determines how long (in seconds) the worker will "sleep" if there are no new jobs available. While sleeping, the worker will not process any new jobs - the jobs will be processed after the worker wakes up again.</p> <pre data-language="php">php artisan queue:work --sleep=3</pre>  <h2 id="supervisor-configuration">Supervisor Configuration</h2>  <h4 id="installing-supervisor">Installing Supervisor</h4> <p>Supervisor is a process monitor for the Linux operating system, and will automatically restart your <code>queue:work</code> process if it fails. To install Supervisor on Ubuntu, you may use the following command:</p> <pre data-language="php">sudo apt-get install supervisor</pre> <blockquote class="tip"> <p>If configuring Supervisor yourself sounds overwhelming, consider using <a href="https://forge.laravel.com">Laravel Forge</a>, which will automatically install and configure Supervisor for your Laravel projects.</p> </blockquote>  <h4 id="configuring-supervisor">Configuring Supervisor</h4> <p>Supervisor configuration files are typically stored in the <code>/etc/supervisor/conf.d</code> directory. Within this directory, you may create any number of configuration files that instruct supervisor how your processes should be monitored. For example, let's create a <code>laravel-worker.conf</code> file that starts and monitors a <code>queue:work</code> process:</p> <pre data-language="php">[program:laravel-worker]
process_name=%(program_name)s_%(process_num)02d
command=php /home/forge/app.com/artisan queue:work sqs --sleep=3 --tries=3 --max-time=3600
autostart=true
autorestart=true
user=forge
numprocs=8
redirect_stderr=true
stdout_logfile=/home/forge/app.com/worker.log
stopwaitsecs=3600</pre> <p>In this example, the <code>numprocs</code> directive will instruct Supervisor to run 8 <code>queue:work</code> processes and monitor all of them, automatically restarting them if they fail. You should change the <code>queue:work sqs</code> portion of the <code>command</code> directive to reflect your desired queue connection.</p> <blockquote> <p>You should ensure that the value of <code>stopwaitsecs</code> is greater than the number of seconds consumed by your longest running job. Otherwise, Supervisor may kill the job before it is finished processing.</p> </blockquote>  <h4 id="starting-supervisor">Starting Supervisor</h4> <p>Once the configuration file has been created, you may update the Supervisor configuration and start the processes using the following commands:</p> <pre data-language="php">sudo supervisorctl reread

sudo supervisorctl update

sudo supervisorctl start laravel-worker:*</pre> <p>For more information on Supervisor, consult the <a href="http://supervisord.org/index.html">Supervisor documentation</a>.</p>  <h2 id="dealing-with-failed-jobs">Dealing With Failed Jobs</h2> <p>Sometimes your queued jobs will fail. Don't worry, things don't always go as planned! Laravel includes a convenient way to specify the maximum number of times a job should be attempted. After a job has exceeded this amount of attempts, it will be inserted into the <code>failed_jobs</code> database table. To create a migration for the <code>failed_jobs</code> table, you may use the <code>queue:failed-table</code> command:</p> <pre data-language="php">php artisan queue:failed-table

php artisan migrate</pre> <p>Then, when running your <a href="#running-the-queue-worker">queue worker</a>, you can specify the maximum number of times a job should be attempted using the <code>--tries</code> switch on the <code>queue:work</code> command. If you do not specify a value for the <code>--tries</code> option, jobs will only be attempted once:</p> <pre data-language="php">php artisan queue:work redis --tries=3</pre> <p>In addition, you may specify how many seconds Laravel should wait before retrying a job that has failed using the <code>--backoff</code> option. By default, a job is retried immediately:</p> <pre data-language="php">php artisan queue:work redis --tries=3 --backoff=3</pre> <p>If you would like to configure the failed job retry delay on a per-job basis, you may do so by defining a <code>backoff</code> property on your queued job class:</p> <pre data-language="php">/**
 * The number of seconds to wait before retrying the job.
 *
 * @var int
 */
public $backoff = 3;</pre> <p>If you require more complex logic for determining the retry delay, you may define a <code>backoff</code> method on your queued job class:</p> <pre data-language="php">/**
* Calculate the number of seconds to wait before retrying the job.
*
* @return int
*/
public function backoff()
{
    return 3;
}</pre> <p>You may easily configure "exponential" backoffs by returning an array of backoff values from the <code>backoff</code> method. In this example, the retry delay will be 1 seconds for the first retry, 5 seconds for the second retry, and 10 seconds for the third retry:</p> <pre data-language="php">/**
* Calculate the number of seconds to wait before retrying the job.
*
* @return array
*/
public function backoff()
{
    return [1, 5, 10];
}</pre>  <h3 id="cleaning-up-after-failed-jobs">Cleaning Up After Failed Jobs</h3> <p>You may define a <code>failed</code> method directly on your job class, allowing you to perform job specific clean-up when a failure occurs. This is the perfect location to send an alert to your users or revert any actions performed by the job. The <code>Throwable</code> exception that caused the job to fail will be passed to the <code>failed</code> method:</p> <pre data-language="php">&lt;?php

namespace App\Jobs;

use App\Models\Podcast;
use App\Services\AudioProcessor;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Throwable;

class ProcessPodcast implements ShouldQueue
{
    use InteractsWithQueue, Queueable, SerializesModels;

    protected $podcast;

    /**
     * Create a new job instance.
     *
     * @param  \App\Models\Podcast  $podcast
     * @return void
     */
    public function __construct(Podcast $podcast)
    {
        $this-&gt;podcast = $podcast;
    }

    /**
     * Execute the job.
     *
     * @param  \App\Services\AudioProcessor  $processor
     * @return void
     */
    public function handle(AudioProcessor $processor)
    {
        // Process uploaded podcast...
    }

    /**
     * Handle a job failure.
     *
     * @param  \Throwable  $exception
     * @return void
     */
    public function failed(Throwable $exception)
    {
        // Send user notification of failure, etc...
    }
}</pre>  <h3 id="failed-job-events">Failed Job Events</h3> <p>If you would like to register an event that will be called when a job fails, you may use the <code>Queue::failing</code> method. This event is a great opportunity to notify your team via email or <a href="https://www.slack.com">Slack</a>. For example, we may attach a callback to this event from the <code>AppServiceProvider</code> that is included with Laravel:</p> <pre data-language="php">&lt;?php

namespace App\Providers;

use Illuminate\Support\Facades\Queue;
use Illuminate\Support\ServiceProvider;
use Illuminate\Queue\Events\JobFailed;

class AppServiceProvider extends ServiceProvider
{
    /**
     * Register any application services.
     *
     * @return void
     */
    public function register()
    {
        //
    }

    /**
     * Bootstrap any application services.
     *
     * @return void
     */
    public function boot()
    {
        Queue::failing(function (JobFailed $event) {
            // $event-&gt;connectionName
            // $event-&gt;job
            // $event-&gt;exception
        });
    }
}</pre>  <h3 id="retrying-failed-jobs">Retrying Failed Jobs</h3> <p>To view all of your failed jobs that have been inserted into your <code>failed_jobs</code> database table, you may use the <code>queue:failed</code> Artisan command:</p> <pre data-language="php">php artisan queue:failed</pre> <p>The <code>queue:failed</code> command will list the job ID, connection, queue, failure time, and other information about the job. The job ID may be used to retry the failed job. For instance, to retry a failed job that has an ID of <code>5</code>, issue the following command:</p> <pre data-language="php">php artisan queue:retry 5</pre> <p>If necessary, you may pass multiple IDs or an ID range (when using numeric IDs) to the command:</p> <pre data-language="php">php artisan queue:retry 5 6 7 8 9 10

php artisan queue:retry --range=5-10</pre> <p>To retry all of your failed jobs, execute the <code>queue:retry</code> command and pass <code>all</code> as the ID:</p> <pre data-language="php">php artisan queue:retry all</pre> <p>If you would like to delete a failed job, you may use the <code>queue:forget</code> command:</p> <pre data-language="php">php artisan queue:forget 5</pre> <blockquote class="tip"> <p>When using <a href="horizon">Horizon</a>, you should use the <code>horizon:forget</code> command to delete a failed job instead of the <code>queue:forget</code> command.</p> </blockquote> <p>To delete all of your failed jobs, you may use the <code>queue:flush</code> command:</p> <pre data-language="php">php artisan queue:flush</pre>  <h3 id="ignoring-missing-models">Ignoring Missing Models</h3> <p>When injecting an Eloquent model into a job, it is automatically serialized before being placed on the queue and restored when the job is processed. However, if the model has been deleted while the job was waiting to be processed by a worker, your job may fail with a <code>ModelNotFoundException</code>.</p> <p>For convenience, you may choose to automatically delete jobs with missing models by setting your job's <code>deleteWhenMissingModels</code> property to <code>true</code>:</p> <pre data-language="php">/**
 * Delete the job if its models no longer exist.
 *
 * @var bool
 */
public $deleteWhenMissingModels = true;</pre>  <h2 id="clearing-jobs-from-queues">Clearing Jobs From Queues</h2> <blockquote class="tip"> <p>When using <a href="horizon">Horizon</a>, you should use the <code>horizon:clear</code> command to clear jobs from the queue instead of the <code>queue:clear</code> command.</p> </blockquote> <p>If you would like to delete all jobs from the default queue of the default connection, you may do so using the <code>queue:clear</code> Artisan command:</p> <pre data-language="php">php artisan queue:clear</pre> <p>You may also provide the <code>connection</code> argument and <code>queue</code> option to delete jobs from a specific connection and queue:</p> <pre data-language="php">php artisan queue:clear redis --queue=emails</pre> <blockquote> <p>Clearing jobs from queues is only available for the SQS, Redis, and database queue drivers. In addition, the SQS message deletion process takes up to 60 seconds, so jobs sent to the SQS queue up to 60 seconds after you clear the queue might also be deleted.</p> </blockquote>  <h2 id="job-events">Job Events</h2> <p>Using the <code>before</code> and <code>after</code> methods on the <code>Queue</code> <a href="facades">facade</a>, you may specify callbacks to be executed before or after a queued job is processed. These callbacks are a great opportunity to perform additional logging or increment statistics for a dashboard. Typically, you should call these methods from a <a href="providers">service provider</a>. For example, we may use the <code>AppServiceProvider</code> that is included with Laravel:</p> <pre data-language="php">&lt;?php

namespace App\Providers;

use Illuminate\Support\Facades\Queue;
use Illuminate\Support\ServiceProvider;
use Illuminate\Queue\Events\JobProcessed;
use Illuminate\Queue\Events\JobProcessing;

class AppServiceProvider extends ServiceProvider
{
    /**
     * Register any application services.
     *
     * @return void
     */
    public function register()
    {
        //
    }

    /**
     * Bootstrap any application services.
     *
     * @return void
     */
    public function boot()
    {
        Queue::before(function (JobProcessing $event) {
            // $event-&gt;connectionName
            // $event-&gt;job
            // $event-&gt;job-&gt;payload()
        });

        Queue::after(function (JobProcessed $event) {
            // $event-&gt;connectionName
            // $event-&gt;job
            // $event-&gt;job-&gt;payload()
        });
    }
}</pre> <p>Using the <code>looping</code> method on the <code>Queue</code> <a href="facades">facade</a>, you may specify callbacks that execute before the worker attempts to fetch a job from a queue. For example, you might register a Closure to rollback any transactions that were left open by a previously failed job:</p> <pre data-language="php">Queue::looping(function () {
    while (DB::transactionLevel() &gt; 0) {
        DB::rollBack();
    }
});</pre> </section><div class="_attribution">
  <p class="_attribution-p">
     Taylor Otwell<br>Licensed under the MIT License.<br>Laravel is a trademark of Taylor Otwell.<br>
    <a href="https://laravel.com/docs/8.x/queues" class="_attribution-link">https://laravel.com/docs/8.x/queues</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
