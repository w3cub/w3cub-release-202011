
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Partial Clone - Git - W3cubDocs</title>
  
  <meta name="description" content="The &#34;Partial Clone&#34; feature is a performance optimization for Git that allows Git to function without having a complete copy of the &hellip;">
  <meta name="keywords" content="partial-clone, partial, clone, git">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/git/partial-clone.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-9c7b0d969c0ce639a6c01c2badcdd81667c7c66206aa3d0fccc5cb0585fb1b912dab72ea882101d18010680927514b4b77b107282db8f756fbf63301fe9c88b0.css">
  <script type="text/javascript" src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js"></script>
  <script src="/json/git.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/git/" class="_nav-link" title="" style="margin-left:0;">Git</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _git">
				
				
<h1>partial-clone</h1>  <div class="sectionbody">  <p>The "Partial Clone" feature is a performance optimization for Git that allows Git to function without having a complete copy of the repository. The goal of this work is to allow Git better handle extremely large repositories.</p>   <p>During clone and fetch operations, Git downloads the complete contents and history of the repository. This includes all commits, trees, and blobs for the complete life of the repository. For extremely large repositories, clones can take hours (or days) and consume 100+GiB of disk space.</p>   <p>Often in these repositories there are many blobs and trees that the user does not need such as:</p>  <div class="olist arabic"> <ol class="arabic"> <li> <p>files outside of the user’s work area in the tree. For example, in a repository with 500K directories and 3.5M files in every commit, we can avoid downloading many objects if the user only needs a narrow "cone" of the source tree.</p> </li> <li> <p>large binary assets. For example, in a repository where large build artifacts are checked into the tree, we can avoid downloading all previous versions of these non-mergeable binary assets and only download versions that are actually referenced.</p> </li> </ol> </div>  <p>Partial clone allows us to avoid downloading such unneeded objects <strong>in advance</strong> during clone and fetch operations and thereby reduce download times and disk usage. Missing objects can later be "demand fetched" if/when needed.</p>   <p>A remote that can later provide the missing objects is called a promisor remote, as it promises to send the objects when requested. Initially Git supported only one promisor remote, the origin remote from which the user cloned and that was configured in the "extensions.partialClone" config option. Later support for more than one promisor remote has been implemented.</p>   <p>Use of partial clone requires that the user be online and the origin remote or other promisor remotes be available for on-demand fetching of missing objects. This may or may not be problematic for the user. For example, if the user can stay within the pre-selected subset of the source tree, they may not encounter any missing objects. Alternatively, the user could try to pre-fetch various objects if they know that they are going offline.</p>  </div>   <h2 id="_non_goals">Non-goals</h2> <div class="sectionbody">  <p>Partial clone is a mechanism to limit the number of blobs and trees downloaded <strong>within</strong> a given range of commits — and is therefore independent of and not intended to conflict with existing DAG-level mechanisms to limit the set of requested commits (i.e. shallow clone, single branch, or fetch <code>&lt;refspec&gt;</code>).</p>  </div>   <h2 id="_design_overview">Design overview</h2> <div class="sectionbody">  <p>Partial clone logically consists of the following parts:</p>  <div class="ulist"> <ul> <li> <p>A mechanism for the client to describe unneeded or unwanted objects to the server.</p> </li> <li> <p>A mechanism for the server to omit such unwanted objects from packfiles sent to the client.</p> </li> <li> <p>A mechanism for the client to gracefully handle missing objects (that were previously omitted by the server).</p> </li> <li> <p>A mechanism for the client to backfill missing objects as needed.</p> </li> </ul> </div> </div>   <h2 id="_design_details">Design details</h2> <div class="sectionbody"> <div class="ulist"> <ul> <li> <p>A new pack-protocol capability "filter" is added to the fetch-pack and upload-pack negotiation.</p>  <p>This uses the existing capability discovery mechanism. See "filter" in <a href="gitprotocol-pack">gitprotocol-pack[5]</a>.</p>  </li> <li> <p>Clients pass a "filter-spec" to clone and fetch which is passed to the server to request filtering during packfile construction.</p>  <p>There are various filters available to accommodate different situations. See "--filter=&lt;filter-spec&gt;" in Documentation/rev-list-options.txt.</p>  </li> <li> <p>On the server pack-objects applies the requested filter-spec as it creates "filtered" packfiles for the client.</p>  <p>These filtered packfiles are <strong>incomplete</strong> in the traditional sense because they may contain objects that reference objects not contained in the packfile and that the client doesn’t already have. For example, the filtered packfile may contain trees or tags that reference missing blobs or commits that reference missing trees.</p>  </li> <li> <p>On the client these incomplete packfiles are marked as "promisor packfiles" and treated differently by various commands.</p> </li> <li> <p>On the client a repository extension is added to the local config to prevent older versions of git from failing mid-operation because of missing objects that they cannot handle. See "extensions.partialClone" in Documentation/technical/repository-version.txt"</p> </li> </ul> </div> </div>   <h2 id="_handling_missing_objects">Handling missing objects</h2> <div class="sectionbody"> <div class="ulist"> <ul> <li> <p>An object may be missing due to a partial clone or fetch, or missing due to repository corruption. To differentiate these cases, the local repository specially indicates such filtered packfiles obtained from promisor remotes as "promisor packfiles".</p>  <p>These promisor packfiles consist of a "&lt;name&gt;.promisor" file with arbitrary contents (like the "&lt;name&gt;.keep" files), in addition to their "&lt;name&gt;.pack" and "&lt;name&gt;.idx" files.</p>  </li> <li> <p>The local repository considers a "promisor object" to be an object that it knows (to the best of its ability) that promisor remotes have promised that they have, either because the local repository has that object in one of its promisor packfiles, or because another promisor object refers to it.</p>  <p>When Git encounters a missing object, Git can see if it is a promisor object and handle it appropriately. If not, Git can report a corruption.</p>   <p>This means that there is no need for the client to explicitly maintain an expensive-to-modify list of missing objects.[a]</p>  </li> <li> <p>Since almost all Git code currently expects any referenced object to be present locally and because we do not want to force every command to do a dry-run first, a fallback mechanism is added to allow Git to attempt to dynamically fetch missing objects from promisor remotes.</p>  <p>When the normal object lookup fails to find an object, Git invokes promisor_remote_get_direct() to try to get the object from a promisor remote and then retry the object lookup. This allows objects to be "faulted in" without complicated prediction algorithms.</p>   <p>For efficiency reasons, no check as to whether the missing object is actually a promisor object is performed.</p>   <p>Dynamic object fetching tends to be slow as objects are fetched one at a time.</p>  </li> <li> <p><code>checkout</code> (and any other command using <code>unpack-trees</code>) has been taught to bulk pre-fetch all required missing blobs in a single batch.</p> </li> <li> <p><code>rev-list</code> has been taught to print missing objects.</p>  <p>This can be used by other commands to bulk prefetch objects. For example, a "git log -p A..B" may internally want to first do something like "git rev-list --objects --quiet --missing=print A..B" and prefetch those objects in bulk.</p>  </li> <li> <p><code>fsck</code> has been updated to be fully aware of promisor objects.</p> </li> <li> <p><code>repack</code> in GC has been updated to not touch promisor packfiles at all, and to only repack other objects.</p> </li> <li> <p>The global variable "fetch_if_missing" is used to control whether an object lookup will attempt to dynamically fetch a missing object or report an error.</p>  <p>We are not happy with this global variable and would like to remove it, but that requires significant refactoring of the object code to pass an additional flag.</p>  </li> </ul> </div> </div>   <h2 id="_fetching_missing_objects">Fetching missing objects</h2> <div class="sectionbody"> <div class="ulist"> <ul> <li> <p>Fetching of objects is done by invoking a "git fetch" subprocess.</p> </li> <li> <p>The local repository sends a request with the hashes of all requested objects, and does not perform any packfile negotiation. It then receives a packfile.</p> </li> <li> <p>Because we are reusing the existing fetch mechanism, fetching currently fetches all objects referred to by the requested objects, even though they are not necessary.</p> </li> <li> <p>Fetching with <code>--refetch</code> will request a complete new filtered packfile from the remote, which can be used to change a filter without needing to dynamically fetch missing objects.</p> </li> </ul> </div> </div>   <h2 id="_using_many_promisor_remotes">Using many promisor remotes</h2> <div class="sectionbody">  <p>Many promisor remotes can be configured and used.</p>   <p>This allows for example a user to have multiple geographically-close cache servers for fetching missing blobs while continuing to do filtered <code>git-fetch</code> commands from the central server.</p>   <p>When fetching objects, promisor remotes are tried one after the other until all the objects have been fetched.</p>   <p>Remotes that are considered "promisor" remotes are those specified by the following configuration variables:</p>  <div class="ulist"> <ul> <li> <p><code>extensions.partialClone = &lt;name&gt;</code></p> </li> <li> <p><code>remote.&lt;name&gt;.promisor = true</code></p> </li> <li> <p><code>remote.&lt;name&gt;.partialCloneFilter = ...</code></p> </li> </ul> </div>  <p>Only one promisor remote can be configured using the <code>extensions.partialClone</code> config variable. This promisor remote will be the last one tried when fetching objects.</p>   <p>We decided to make it the last one we try, because it is likely that someone using many promisor remotes is doing so because the other promisor remotes are better for some reason (maybe they are closer or faster for some kind of objects) than the origin, and the origin is likely to be the remote specified by extensions.partialClone.</p>   <p>This justification is not very strong, but one choice had to be made, and anyway the long term plan should be to make the order somehow fully configurable.</p>   <p>For now though the other promisor remotes will be tried in the order they appear in the config file.</p>  </div>   <h2 id="_current_limitations">Current limitations</h2> <div class="sectionbody"> <div class="ulist"> <ul> <li> <p>It is not possible to specify the order in which the promisor remotes are tried in other ways than the order in which they appear in the config file.</p>  <p>It is also not possible to specify an order to be used when fetching from one remote and a different order when fetching from another remote.</p>  </li> <li> <p>It is not possible to push only specific objects to a promisor remote.</p>  <p>It is not possible to push at the same time to multiple promisor remote in a specific order.</p>  </li> <li> <p>Dynamic object fetching will only ask promisor remotes for missing objects. We assume that promisor remotes have a complete view of the repository and can satisfy all such requests.</p> </li> <li> <p>Repack essentially treats promisor and non-promisor packfiles as 2 distinct partitions and does not mix them.</p> </li> <li> <p>Dynamic object fetching invokes fetch-pack once <strong>for each item</strong> because most algorithms stumble upon a missing object and need to have it resolved before continuing their work. This may incur significant overhead — and multiple authentication requests — if many objects are needed.</p> </li> <li> <p>Dynamic object fetching currently uses the existing pack protocol V0 which means that each object is requested via fetch-pack. The server will send a full set of info/refs when the connection is established. If there are large number of refs, this may incur significant overhead.</p> </li> </ul> </div> </div>   <h2 id="_future_work">Future work</h2> <div class="sectionbody"> <div class="ulist"> <ul> <li> <p>Improve the way to specify the order in which promisor remotes are tried.</p>  <p>For example this could allow to specify explicitly something like: "When fetching from this remote, I want to use these promisor remotes in this order, though, when pushing or fetching to that remote, I want to use those promisor remotes in that order."</p>  </li> <li> <p>Allow pushing to promisor remotes.</p>  <p>The user might want to work in a triangular work flow with multiple promisor remotes that each have an incomplete view of the repository.</p>  </li> <li> <p>Allow non-pathname-based filters to make use of packfile bitmaps (when present). This was just an omission during the initial implementation.</p> </li> <li> <p>Investigate use of a long-running process to dynamically fetch a series of objects, such as proposed in [5,6] to reduce process startup and overhead costs.</p>  <p>It would be nice if pack protocol V2 could allow that long-running process to make a series of requests over a single long-running connection.</p>  </li> <li> <p>Investigate pack protocol V2 to avoid the info/refs broadcast on each connection with the server to dynamically fetch missing objects.</p> </li> <li> <p>Investigate the need to handle loose promisor objects.</p>  <p>Objects in promisor packfiles are allowed to reference missing objects that can be dynamically fetched from the server. An assumption was made that loose objects are only created locally and therefore should not reference a missing object. We may need to revisit that assumption if, for example, we dynamically fetch a missing tree and store it as a loose object rather than a single object packfile.</p>   <p>This does not necessarily mean we need to mark loose objects as promisor; it may be sufficient to relax the object lookup or is-promisor functions.</p>  </li> </ul> </div> </div>   <h2 id="_non_tasks">Non-tasks</h2> <div class="sectionbody"> <div class="ulist"> <ul> <li> <p>Every time the subject of "demand loading blobs" comes up it seems that someone suggests that the server be allowed to "guess" and send additional objects that may be related to the requested objects.</p>  <p>No work has gone into actually doing that; we’re just documenting that it is a common suggestion. We’re not sure how it would work and have no plans to work on it.</p>   <p>It is valid for the server to send more objects than requested (even for a dynamic object fetch), but we are not building on that.</p>  </li> </ul> </div> </div>   <h2 id="_footnotes">Footnotes</h2> <div class="sectionbody">  <p>[a] expensive-to-modify list of missing objects: Earlier in the design of partial clone we discussed the need for a single list of missing objects. This would essentially be a sorted linear list of OIDs that the were omitted by the server during a clone or subsequent fetches.</p>   <p>This file would need to be loaded into memory on every object lookup. It would need to be read, updated, and re-written (like the .git/index) on every explicit "git fetch" command <strong>and</strong> on any dynamic object fetch.</p>   <p>The cost to read, update, and write this file could add significant overhead to every command if there are many missing objects. For example, if there are 100M missing blobs, this file would be at least 2GiB on disk.</p>   <p>With the "promisor" concept, we <strong>infer</strong> a missing object based upon the type of packfile that references it.</p>  </div>   <h2 id="_related_links">Related links</h2> <div class="sectionbody">  <p>[0] <a href="https://crbug.com/git/2" class="bare">https://crbug.com/git/2</a> Bug#2: Partial Clone</p>   <p>[1] <a href="https://lore.kernel.org/git/20170113155253.1644-1-benpeart@microsoft.com/" class="bare">https://lore.kernel.org/git/20170113155253.1644-1-benpeart@microsoft.com/</a><br> Subject: [RFC] Add support for downloading blobs on demand<br> Date: Fri, 13 Jan 2017 10:52:53 -0500</p>   <p>[2] <a href="https://lore.kernel.org/git/cover.1506714999.git.jonathantanmy@google.com/" class="bare">https://lore.kernel.org/git/cover.1506714999.git.jonathantanmy@google.com/</a><br> Subject: [PATCH 00/18] Partial clone (from clone to lazy fetch in 18 patches)<br> Date: Fri, 29 Sep 2017 13:11:36 -0700</p>   <p>[3] <a href="https://lore.kernel.org/git/20170426221346.25337-1-jonathantanmy@google.com/" class="bare">https://lore.kernel.org/git/20170426221346.25337-1-jonathantanmy@google.com/</a><br> Subject: Proposal for missing blob support in Git repos<br> Date: Wed, 26 Apr 2017 15:13:46 -0700</p>   <p>[4] <a href="https://lore.kernel.org/git/1488999039-37631-1-git-send-email-git@jeffhostetler.com/" class="bare">https://lore.kernel.org/git/1488999039-37631-1-git-send-email-git@jeffhostetler.com/</a><br> Subject: [PATCH 00/10] RFC Partial Clone and Fetch<br> Date: Wed, 8 Mar 2017 18:50:29 +0000</p>   <p>[5] <a href="https://lore.kernel.org/git/20170505152802.6724-1-benpeart@microsoft.com/" class="bare">https://lore.kernel.org/git/20170505152802.6724-1-benpeart@microsoft.com/</a><br> Subject: [PATCH v7 00/10] refactor the filter process code into a reusable module<br> Date: Fri, 5 May 2017 11:27:52 -0400</p>   <p>[6] <a href="https://lore.kernel.org/git/20170714132651.170708-1-benpeart@microsoft.com/" class="bare">https://lore.kernel.org/git/20170714132651.170708-1-benpeart@microsoft.com/</a><br> Subject: [RFC/PATCH v2 0/1] Add support for downloading blobs on demand<br> Date: Fri, 14 Jul 2017 09:26:50 -0400</p>  </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012–2023 Scott Chacon and others<br>Licensed under the MIT License.<br>
    <a href="https://git-scm.com/docs/partial-clone" class="_attribution-link">https://git-scm.com/docs/partial-clone</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
