
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Immutable.js Documentation - W3cubDocs</title>
  
  <meta name="description" content=" Immutable.js documentation ">
  <meta name="keywords" content="immutable, jsfromjs, is, listmaporderedmapsetorderedsetstackrange, repeat, recordrecord, classseqseq, keyedseq, keyediterableiterable, keyediterable, keyedcollectioncollection, keyedcollection, keyed, js, documentation">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/immutable/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/immutable.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/immutable/" class="_nav-link" title="" style="margin-left:0;">Immutable.js</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _simple">
				
				
<h1>Immutable.js</h1>
<p>Immutable data encourages pure functions (data-in, data-out) and lends itself to much simpler application development and enabling techniques from functional programming such as lazy evaluation.</p> <p>While designed to bring these powerful functional concepts to JavaScript, it presents an Object-Oriented API familiar to Javascript engineers and closely mirroring that of Array, Map, and Set. It is easy and efficient to convert to and from plain Javascript types.</p> <p>Note: all examples are presented in <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla">ES6</a>. To run in all browsers, they need to be translated to ES3. For example:</p> <pre data-language="js">// ES6
foo.map(x =&gt; x * x);
// ES3
foo.map(function (x) { return x * x; });</pre>
<h1 id="fromjs()">fromJS()</h1>
<p>Deeply converts plain JS objects and arrays to Immutable Maps and Lists.</p> <pre data-language="js">fromJS(json: any, reviver?: (k: any, v: Iterable&lt;any, any&gt;) =&gt; any): any
</pre>
<h4>Discussion</h4>
<p>If a <code>reviver</code> is optionally provided, it will be called with every collection as a Seq (beginning with the most nested collections and proceeding to the top-level collection itself), along with the key refering to each collection and the parent JS object provided as <code>this</code>. For the top level, object, the key will be <code>""</code>. This <code>reviver</code> is expected to return a new Immutable Iterable, allowing for custom conversions from deep JS objects.</p> <p>This example converts JSON to List and OrderedMap:</p> <pre data-language="js">Immutable.fromJS({a: {b: [10, 20, 30]}, c: 40}, function (key, value) {
  var isIndexed = Immutable.Iterable.isIndexed(value);
  return isIndexed ? value.toList() : value.toOrderedMap();
});

// true, "b", {b: [10, 20, 30]}
// false, "a", {a: {b: [10, 20, 30]}, c: 40}
// false, "", {"": {a: {b: [10, 20, 30]}, c: 40}}</pre>
<p>If <code>reviver</code> is not provided, the default behavior will convert Arrays into Lists and Objects into Maps.</p> <p><code>reviver</code> acts similarly to the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse#Example.3A_Using_the_reviver_parameter">same parameter in </a><code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse">JSON.parse</a></code>.</p> <p><code>Immutable.fromJS</code> is conservative in its conversion. It will only convert arrays which pass <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray">Array.isArray</a></code> to Lists, and only raw objects (no custom prototype) to Map.</p> <p>Keep in mind, when using JS objects to construct Immutable Maps, that JavaScript Object properties are always strings, even if written in a quote-less shorthand, while Immutable Maps accept keys of any type.</p> <pre data-language="js">var obj = { 1: "one" };
Object.keys(obj); // [ "1" ]
obj["1"]; // "one"
obj[1];   // "one"

var map = Map(obj);
map.get("1"); // "one"
map.get(1);   // undefined</pre>
<p>Property access for JavaScript Objects first converts the key to a string, but since Immutable Map keys can be of any type the argument to <code>get()</code> is not altered.</p> <pre data-language="js"> "Using the reviver parameter"</pre>
<h1 id="is()">is()</h1>
<p>Value equality check with semantics similar to <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is">Object.is</a></code>, but treats Immutable <code><a href="#iterable">Iterable</a></code>s as values, equal if the second <code><a href="#iterable">Iterable</a></code> includes equivalent values.</p> <pre data-language="js">is(first: any, second: any): boolean
</pre>
<h4>Discussion</h4>
<p>It's used throughout Immutable when checking for equality, including <code><a href="#map">Map</a></code> key equality and <code><a href="#set">Set</a></code> membership.</p> <pre data-language="js">var map1 = Immutable.Map({a:1, b:1, c:1});
var map2 = Immutable.Map({a:1, b:1, c:1});
assert(map1 !== map2);
assert(Object.is(map1, map2) === false);
assert(Immutable.is(map1, map2) === true);</pre>
<p>Note: Unlike <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is">Object.is</a></code>, <code>Immutable.is</code> assumes <code>0</code> and <code>-0</code> are the same value, matching the behavior of ES6 Map key equality.</p> <h1 id="list">List</h1>
<p>Lists are ordered indexed dense collections, much like a JavaScript Array.</p> <pre data-language="js">class List&lt;T&gt; extends Collection.Indexed&lt;T&gt;</pre>
<h4>Discussion</h4>
<p>Lists are immutable and fully persistent with O(log32 N) gets and sets, and O(1) push and pop.</p> <p>Lists implement Deque, with efficient addition and removal from both the end (<code><a href="#list.push">push</a></code>, <code><a href="#list.pop">pop</a></code>) and beginning (<code><a href="#list.unshift">unshift</a></code>, <code><a href="#list.shift">shift</a></code>).</p> <p>Unlike a JavaScript Array, there is no distinction between an "unset" index and an index set to <code>undefined</code>. <code><a href="#list.foreach">List#forEach</a></code> visits all indices from 0 to size, regardless of whether they were explicitly defined.</p> <h2>Construction</h2>
<h3 id="list()">List()</h3>
<p>Create a new immutable List containing the values of the provided iterable-like.</p> <pre data-language="js">List&lt;T&gt;(): List&lt;T&gt;
List&lt;T&gt;(iter: Iterable.Indexed&lt;T&gt;): List&lt;T&gt;
List&lt;T&gt;(iter: Iterable.Set&lt;T&gt;): List&lt;T&gt;
List&lt;K, V&gt;(iter: Iterable.Keyed&lt;K, V&gt;): List&lt;any&gt;
List&lt;T&gt;(array: Array&lt;T&gt;): List&lt;T&gt;
List&lt;T&gt;(iterator: Iterator&lt;T&gt;): List&lt;T&gt;
List&lt;T&gt;(iterable: Object): List&lt;T&gt;
</pre>
<h2>Static methods</h2>
<h3 id="list.islist">List.isList()</h3>
<p>True if the provided value is a List</p> <pre data-language="js">List.isList(maybeList: any): boolean
</pre>
<h3 id="list.of">List.of()</h3>
<p>Creates a new List containing <code>values</code>.</p> <pre data-language="js">List.of&lt;T&gt;(...values: T[]): List&lt;T&gt;
</pre>
<h2>Members</h2>
<h3 id="list.size">List#size</h3>
<pre data-language="js">size: number</pre>
<h4>Inherited from</h4>
<code><a href="#collection.size">Collection#size</a></code><h2>Persistent changes</h2>
<h3 id="list.set">List#set()</h3>
<p>Returns a new List which includes <code>value</code> at <code>index</code>. If <code>index</code> already exists in this List, it will be replaced.</p> <pre data-language="js">set(index: number, value: T): List&lt;T&gt;
</pre>
<h4>Discussion</h4>
<p><code>index</code> may be a negative number, which indexes back from the end of the List. <code>v.set(-1, "value")</code> sets the last item in the List.</p> <p>If <code>index</code> larger than <code><a href="#list.size">size</a></code>, the returned List's <code><a href="#list.size">size</a></code> will be large enough to include the <code>index</code>.</p> <h3 id="list.delete">List#delete()</h3>
<p>Returns a new List which excludes this <code>index</code> and with a size 1 less than this List. Values at indices above <code>index</code> are shifted down by 1 to fill the position.</p> <pre data-language="js">delete(index: number): List&lt;T&gt;
</pre>
<h4>alias</h4>
<code>remove()</code><h4>Discussion</h4>
<p>This is synonymous with <code>list.splice(index, 1)</code>.</p> <p><code>index</code> may be a negative number, which indexes back from the end of the List. <code>v.delete(-1)</code> deletes the last item in the List.</p> <p>Note: <code>delete</code> cannot be safely used in IE8</p> <h3 id="list.insert">List#insert()</h3>
<p>Returns a new List with <code>value</code> at <code>index</code> with a size 1 more than this List. Values at indices above <code>index</code> are shifted over by 1.</p> <pre data-language="js">insert(index: number, value: T): List&lt;T&gt;
</pre>
<h4>Discussion</h4>
<p>This is synonymous with `list.splice(index, 0, value)</p> <h3 id="list.clear">List#clear()</h3>
<p>Returns a new List with 0 size and no values.</p> <pre data-language="js">clear(): List&lt;T&gt;
</pre>
<h3 id="list.push">List#push()</h3>
<p>Returns a new List with the provided <code>values</code> appended, starting at this List's <code><a href="#list.size">size</a></code>.</p> <pre data-language="js">push(...values: T[]): List&lt;T&gt;
</pre>
<h3 id="list.pop">List#pop()</h3>
<p>Returns a new List with a size ones less than this List, excluding the last index in this List.</p> <pre data-language="js">pop(): List&lt;T&gt;
</pre>
<h4>Discussion</h4>
<p>Note: this differs from <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/pop">Array#pop</a></code> because it returns a new List rather than the removed value. Use <code><a href="#list.last">last()</a></code> to get the last value in this List.</p> <h3 id="list.unshift">List#unshift()</h3>
<p>Returns a new List with the provided <code>values</code> prepended, shifting other values ahead to higher indices.</p> <pre data-language="js">unshift(...values: T[]): List&lt;T&gt;
</pre>
<h3 id="list.shift">List#shift()</h3>
<p>Returns a new List with a size ones less than this List, excluding the first index in this List, shifting all other values to a lower index.</p> <pre data-language="js">shift(): List&lt;T&gt;
</pre>
<h4>Discussion</h4>
<p>Note: this differs from <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/shift">Array#shift</a></code> because it returns a new List rather than the removed value. Use <code><a href="#list.first">first()</a></code> to get the first value in this List.</p> <h3 id="list.update">List#update()</h3>
<p>Returns a new List with an updated value at <code>index</code> with the return value of calling <code>updater</code> with the existing value, or <code>notSetValue</code> if <code>index</code> was not set. If called with a single argument, <code>updater</code> is called with the List itself.</p> <pre data-language="js">update(updater: (value: List&lt;T&gt;) =&gt; List&lt;T&gt;): List&lt;T&gt;
update(index: number, updater: (value: T) =&gt; T): List&lt;T&gt;
update(index: number, notSetValue: T, updater: (value: T) =&gt; T): List&lt;T&gt;
</pre>
<h4>see</h4>
<p><code><a href="#map.update">Map#update</a></code></p> <h4>Discussion</h4>
<p><code>index</code> may be a negative number, which indexes back from the end of the List. <code>v.update(-1)</code> updates the last item in the List.</p> <h3 id="list.merge">List#merge()</h3>
<pre data-language="js">merge(...iterables: Iterable.Indexed&lt;T&gt;[]): List&lt;T&gt;
merge(...iterables: Array&lt;T&gt;[]): List&lt;T&gt;
</pre>
<h4>see</h4>
<p><code><a href="#map.merge">Map#merge</a></code></p> <h3 id="list.mergewith">List#mergeWith()</h3>
<pre data-language="js">mergeWith(merger: (previous?: T, next?: T, key?: number) =&gt; T,...iterables: Iterable.Indexed&lt;T&gt;[]): List&lt;T&gt;
mergeWith(merger: (previous?: T, next?: T, key?: number) =&gt; T,...iterables: Array&lt;T&gt;[]): List&lt;T&gt;
</pre>
<h4>see</h4>
<p><code><a href="#map.mergewith">Map#mergeWith</a></code></p> <h3 id="list.mergedeep">List#mergeDeep()</h3>
<pre data-language="js">mergeDeep(...iterables: Iterable.Indexed&lt;T&gt;[]): List&lt;T&gt;
mergeDeep(...iterables: Array&lt;T&gt;[]): List&lt;T&gt;
</pre>
<h4>see</h4>
<p><code><a href="#map.mergedeep">Map#mergeDeep</a></code></p> <h3 id="list.mergedeepwith">List#mergeDeepWith()</h3>
<pre data-language="js">mergeDeepWith(merger: (previous?: T, next?: T, key?: number) =&gt; T,...iterables: Iterable.Indexed&lt;T&gt;[]): List&lt;T&gt;
mergeDeepWith(merger: (previous?: T, next?: T, key?: number) =&gt; T,...iterables: Array&lt;T&gt;[]): List&lt;T&gt;
</pre>
<h4>see</h4>
<p><code><a href="#map.mergedeepwith">Map#mergeDeepWith</a></code></p> <h3 id="list.setsize">List#setSize()</h3>
<p>Returns a new List with size <code>size</code>. If <code>size</code> is less than this List's size, the new List will exclude values at the higher indices. If <code>size</code> is greater than this List's size, the new List will have undefined values for the newly available indices.</p> <pre data-language="js">setSize(size: number): List&lt;T&gt;
</pre>
<h4>Discussion</h4>
<p>When building a new List and the final size is known up front, <code>setSize</code> used in conjunction with <code><a href="#list.withmutations">withMutations</a></code> may result in the more performant construction.</p> <h2>Deep persistent changes</h2>
<h3 id="list.setin">List#setIn()</h3>
<p>Returns a new List having set <code>value</code> at this <code>keyPath</code>. If any keys in <code>keyPath</code> do not exist, a new immutable Map will be created at that key.</p> <pre data-language="js">setIn(keyPath: Array&lt;any&gt;, value: any): List&lt;T&gt;
setIn(keyPath: Iterable&lt;any, any&gt;, value: any): List&lt;T&gt;
</pre>
<h4>Discussion</h4>
<p>Index numbers are used as keys to determine the path to follow in the List.</p> <h3 id="list.deletein">List#deleteIn()</h3>
<p>Returns a new List having removed the value at this <code>keyPath</code>. If any keys in <code>keyPath</code> do not exist, no change will occur.</p> <pre data-language="js">deleteIn(keyPath: Array&lt;any&gt;): List&lt;T&gt;
deleteIn(keyPath: Iterable&lt;any, any&gt;): List&lt;T&gt;
</pre>
<h4>alias</h4>
<code>removeIn()</code><h3 id="list.updatein">List#updateIn()</h3>
<pre data-language="js">updateIn(keyPath: Array&lt;any&gt;, updater: (value: any) =&gt; any): List&lt;T&gt;
updateIn(keyPath: Array&lt;any&gt;,notSetValue: any,updater: (value: any) =&gt; any): List&lt;T&gt;
updateIn(keyPath: Iterable&lt;any, any&gt;, updater: (value: any) =&gt; any): List&lt;T&gt;
updateIn(keyPath: Iterable&lt;any, any&gt;,notSetValue: any,updater: (value: any) =&gt; any): List&lt;T&gt;
</pre>
<h4>see</h4>
<p><code><a href="#map.updatein">Map#updateIn</a></code></p> <h3 id="list.mergein">List#mergeIn()</h3>
<pre data-language="js">mergeIn(keyPath: Iterable&lt;any, any&gt;,...iterables: Iterable.Indexed&lt;T&gt;[]): List&lt;T&gt;
mergeIn(keyPath: Array&lt;any&gt;, ...iterables: Iterable.Indexed&lt;T&gt;[]): List&lt;T&gt;
mergeIn(keyPath: Array&lt;any&gt;, ...iterables: Array&lt;T&gt;[]): List&lt;T&gt;
</pre>
<h4>see</h4>
<p><code><a href="#map.mergein">Map#mergeIn</a></code></p> <h3 id="list.mergedeepin">List#mergeDeepIn()</h3>
<pre data-language="js">mergeDeepIn(keyPath: Iterable&lt;any, any&gt;,...iterables: Iterable.Indexed&lt;T&gt;[]): List&lt;T&gt;
mergeDeepIn(keyPath: Array&lt;any&gt;, ...iterables: Iterable.Indexed&lt;T&gt;[]): List&lt;T&gt;
mergeDeepIn(keyPath: Array&lt;any&gt;, ...iterables: Array&lt;T&gt;[]): List&lt;T&gt;
</pre>
<h4>see</h4>
<p><code><a href="#map.mergedeepin">Map#mergeDeepIn</a></code></p> <h2>Transient changes</h2>
<h3 id="list.withmutations">List#withMutations()</h3>
<p>Note: Not all methods can be used on a mutable collection or within <code>withMutations</code>! Only <code><a href="#list.set">set</a></code>, <code><a href="#list.push">push</a></code>, <code><a href="#list.pop">pop</a></code>, <code><a href="#list.shift">shift</a></code>, <code><a href="#list.unshift">unshift</a></code> and <code><a href="#list.merge">merge</a></code> may be used mutatively.</p> <pre data-language="js">withMutations(mutator: (mutable: List&lt;T&gt;) =&gt; any): List&lt;T&gt;
</pre>
<h4>see</h4>
<p><code><a href="#map.withmutations">Map#withMutations</a></code></p> <h3 id="list.asmutable">List#asMutable()</h3>
<pre data-language="js">asMutable(): List&lt;T&gt;
</pre>
<h4>see</h4>
<p><code><a href="#map.asmutable">Map#asMutable</a></code></p> <h3 id="list.asimmutable">List#asImmutable()</h3>
<pre data-language="js">asImmutable(): List&lt;T&gt;
</pre>
<h4>see</h4>
<p><code><a href="#map.asimmutable">Map#asImmutable</a></code></p> <h2>Conversion to Seq</h2>
<h3 id="list.toseq">List#toSeq()</h3>
<p>Returns Seq.Indexed.</p> <pre data-language="js">toSeq(): Seq.Indexed&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#collection.indexed.toseq">Collection.Indexed#toSeq</a></code><h3 id="list.tokeyedseq">List#toKeyedSeq()</h3>
<p>Returns a Seq.Keyed from this Iterable where indices are treated as keys.</p> <pre data-language="js">toKeyedSeq(): Seq.Keyed&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tokeyedseq">Iterable#toKeyedSeq</a></code><h4>Discussion</h4>
<p>This is useful if you want to operate on an Iterable.Indexed and preserve the [index, value] pairs.</p> <p>The returned Seq will have identical iteration order as this Iterable.</p> <p>Example:</p> <pre data-language="js">var indexedSeq = Immutable.Seq.of('A', 'B', 'C');
indexedSeq.filter(v =&gt; v === 'B').toString() // Seq [ 'B' ]
var keyedSeq = indexedSeq.toKeyedSeq();
keyedSeq.filter(v =&gt; v === 'B').toString() // Seq { 1: 'B' }</pre>
<h3 id="list.toindexedseq">List#toIndexedSeq()</h3>
<p>Returns an Seq.Indexed of the values of this Iterable, discarding keys.</p> <pre data-language="js">toIndexedSeq(): Seq.Indexed&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toindexedseq">Iterable#toIndexedSeq</a></code><h3 id="list.tosetseq">List#toSetSeq()</h3>
<p>Returns a Seq.Set of the values of this Iterable, discarding keys.</p> <pre data-language="js">toSetSeq(): Seq.Set&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tosetseq">Iterable#toSetSeq</a></code><h3 id="list.fromentryseq">List#fromEntrySeq()</h3>
<p>If this is an iterable of [key, value] entry tuples, it will return a Seq.Keyed of those entries.</p> <pre data-language="js">fromEntrySeq(): Seq.Keyed&lt;any, any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.indexed.fromentryseq">Iterable.Indexed#fromEntrySeq</a></code><h2>Value equality</h2>
<h3 id="list.equals">List#equals()</h3>
<p>True if this and the other Iterable have value equality, as defined by <code><a href="#is">Immutable.is()</a></code>.</p> <pre data-language="js">equals(other: Iterable&lt;number, T&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.equals">Iterable#equals</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Immutable.is(this, other)</code>, but provided to allow for chained expressions.</p> <h3 id="list.hashcode">List#hashCode()</h3>
<p>Computes and returns the hashed identity for this Iterable.</p> <pre data-language="js">hashCode(): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.hashcode">Iterable#hashCode</a></code><h4>Discussion</h4>
<p>The <code>hashCode</code> of an Iterable is used to determine potential equality, and is used when adding this to a <code><a href="#iterable.set">Set</a></code> or as a key in a <code><a href="#map">Map</a></code>, enabling lookup via a different instance.</p> <pre data-language="js">var a = List.of(1, 2, 3);
var b = List.of(1, 2, 3);
assert(a !== b); // different instances
var set = Set.of(a);
assert(set.has(b) === true);</pre>
<p>If two values have the same <code>hashCode</code>, they are <a href="http://en.wikipedia.org/wiki/Collision_(computer_science)">not guaranteed to be equal</a>. If two values have different <code>hashCode</code>s, they must not be equal.</p> <h2>Reading values</h2>
<h3 id="list.get">List#get()</h3>
<p>Returns the value associated with the provided key, or notSetValue if the Iterable does not contain this key.</p> <pre data-language="js">get(key: number, notSetValue?: T): T
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.get">Iterable#get</a></code><h4>Discussion</h4>
<p>Note: it is possible a key may be associated with an <code>undefined</code> value, so if <code>notSetValue</code> is not provided and this method returns <code>undefined</code>, that does not guarantee the key was not found.</p> <h3 id="list.has">List#has()</h3>
<p>True if a key exists within this <code>Iterable</code>, using <code><a href="#is">Immutable.is</a></code> to determine equality</p> <pre data-language="js">has(key: number): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.has">Iterable#has</a></code><h3 id="list.includes">List#includes()</h3>
<p>True if a value exists within this <code>Iterable</code>, using <code><a href="#is">Immutable.is</a></code> to determine equality</p> <pre data-language="js">includes(value: T): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.includes">Iterable#includes</a></code><h4>alias</h4>
<code>contains()</code><h3 id="list.first">List#first()</h3>
<p>The first value in the Iterable.</p> <pre data-language="js">first(): T
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.first">Iterable#first</a></code><h3 id="list.last">List#last()</h3>
<p>The last value in the Iterable.</p> <pre data-language="js">last(): T
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.last">Iterable#last</a></code><h2>Reading deep values</h2>
<h3 id="list.getin">List#getIn()</h3>
<p>Returns the value found by following a path of keys or indices through nested Iterables.</p> <pre data-language="js">getIn(searchKeyPath: Array&lt;any&gt;, notSetValue?: any): any
getIn(searchKeyPath: Iterable&lt;any, any&gt;, notSetValue?: any): any
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.getin">Iterable#getIn</a></code><h3 id="list.hasin">List#hasIn()</h3>
<p>True if the result of following a path of keys or indices through nested Iterables results in a set value.</p> <pre data-language="js">hasIn(searchKeyPath: Array&lt;any&gt;): boolean
hasIn(searchKeyPath: Iterable&lt;any, any&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.hasin">Iterable#hasIn</a></code><h2>Conversion to JavaScript types</h2>
<h3 id="list.tojs">List#toJS()</h3>
<p>Deeply converts this Iterable to equivalent JS.</p> <pre data-language="js">toJS(): any
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tojs">Iterable#toJS</a></code><h4>alias</h4>
<code>toJSON()</code><h4>Discussion</h4>
<p><code>Iterable.Indexeds</code>, and <code>Iterable.Sets</code> become Arrays, while <code>Iterable.Keyeds</code> become Objects.</p> <h3 id="list.toarray">List#toArray()</h3>
<p>Shallowly converts this iterable to an Array, discarding keys.</p> <pre data-language="js">toArray(): Array&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toarray">Iterable#toArray</a></code><h3 id="list.toobject">List#toObject()</h3>
<p>Shallowly converts this Iterable to an Object.</p> <pre data-language="js">toObject(): {[key: string]: V}
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toobject">Iterable#toObject</a></code><h4>Discussion</h4>
<p>Throws if keys are not strings.</p> <h2>Conversion to Collections</h2>
<h3 id="list.tomap">List#toMap()</h3>
<p>Converts this Iterable to a Map, Throws if keys are not hashable.</p> <pre data-language="js">toMap(): Map&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tomap">Iterable#toMap</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Map(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="list.toorderedmap">List#toOrderedMap()</h3>
<p>Converts this Iterable to a Map, maintaining the order of iteration.</p> <pre data-language="js">toOrderedMap(): OrderedMap&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toorderedmap">Iterable#toOrderedMap</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>OrderedMap(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="list.toset">List#toSet()</h3>
<p>Converts this Iterable to a Set, discarding keys. Throws if values are not hashable.</p> <pre data-language="js">toSet(): Set&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toset">Iterable#toSet</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Set(this)</code>, but provided to allow for chained expressions.</p> <h3 id="list.toorderedset">List#toOrderedSet()</h3>
<p>Converts this Iterable to a Set, maintaining the order of iteration and discarding keys.</p> <pre data-language="js">toOrderedSet(): OrderedSet&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toorderedset">Iterable#toOrderedSet</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>OrderedSet(this.valueSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="list.tolist">List#toList()</h3>
<p>Converts this Iterable to a List, discarding keys.</p> <pre data-language="js">toList(): List&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tolist">Iterable#toList</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>List(this)</code>, but provided to allow for chained expressions.</p> <h3 id="list.tostack">List#toStack()</h3>
<p>Converts this Iterable to a Stack, discarding keys. Throws if values are not hashable.</p> <pre data-language="js">toStack(): Stack&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tostack">Iterable#toStack</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Stack(this)</code>, but provided to allow for chained expressions.</p> <h2>Iterators</h2>
<h3 id="list.keys">List#keys()</h3>
<p>An iterator of this <code>Iterable</code>'s keys.</p> <pre data-language="js">keys(): Iterator&lt;number&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keys">Iterable#keys</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.keyseq">keySeq</a></code> instead, if this is what you want.</p> <h3 id="list.values">List#values()</h3>
<p>An iterator of this <code>Iterable</code>'s values.</p> <pre data-language="js">values(): Iterator&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.values">Iterable#values</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.valueseq">valueSeq</a></code> instead, if this is what you want.</p> <h3 id="list.entries">List#entries()</h3>
<p>An iterator of this <code>Iterable</code>'s entries as <code>[key, value]</code> tuples.</p> <pre data-language="js">entries(): Iterator&lt;Array&lt;any&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.entries">Iterable#entries</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.entryseq">entrySeq</a></code> instead, if this is what you want.</p> <h2>Iterables (Seq)</h2>
<h3 id="list.keyseq">List#keySeq()</h3>
<p>Returns a new Seq.Indexed of the keys of this Iterable, discarding values.</p> <pre data-language="js">keySeq(): Seq.Indexed&lt;number&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyseq">Iterable#keySeq</a></code><h3 id="list.valueseq">List#valueSeq()</h3>
<p>Returns an Seq.Indexed of the values of this Iterable, discarding keys.</p> <pre data-language="js">valueSeq(): Seq.Indexed&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.valueseq">Iterable#valueSeq</a></code><h3 id="list.entryseq">List#entrySeq()</h3>
<p>Returns a new Seq.Indexed of [key, value] tuples.</p> <pre data-language="js">entrySeq(): Seq.Indexed&lt;Array&lt;any&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.entryseq">Iterable#entrySeq</a></code><h2>Sequence algorithms</h2>
<h3 id="list.map">List#map()</h3>
<p>Returns a new Iterable of the same type with values passed through a <code>mapper</code> function.</p> <pre data-language="js">map&lt;M&gt;(mapper: (value?: T, key?: number, iter?: Iterable&lt;number, T&gt;) =&gt; M,context?: any): Iterable&lt;number, M&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.map">Iterable#map</a></code><h4>Example</h4>
<pre data-language="js">Seq({ a: 1, b: 2 }).map(x =&gt; 10 * x)
// Seq { a: 10, b: 20 }</pre>
<h3 id="list.filter">List#filter()</h3>
<p>Returns a new Iterable of the same type with only the entries for which the <code>predicate</code> function returns true.</p> <pre data-language="js">filter(predicate: (value?: T, key?: number, iter?: Iterable&lt;number, T&gt;) =&gt; boolean,context?: any): Iterable&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.filter">Iterable#filter</a></code><h4>Example</h4>
<pre data-language="js">Seq({a:1,b:2,c:3,d:4}).filter(x =&gt; x % 2 === 0)
// Seq { b: 2, d: 4 }</pre>
<h3 id="list.filternot">List#filterNot()</h3>
<p>Returns a new Iterable of the same type with only the entries for which the <code>predicate</code> function returns false.</p> <pre data-language="js">filterNot(predicate: (value?: T, key?: number, iter?: Iterable&lt;number, T&gt;) =&gt; boolean,context?: any): Iterable&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.filternot">Iterable#filterNot</a></code><h4>Example</h4>
<pre data-language="js">Seq({a:1,b:2,c:3,d:4}).filterNot(x =&gt; x % 2 === 0)
// Seq { a: 1, c: 3 }</pre>
<h3 id="list.reverse">List#reverse()</h3>
<p>Returns a new Iterable of the same type in reverse order.</p> <pre data-language="js">reverse(): Iterable&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reverse">Iterable#reverse</a></code><h3 id="list.sort">List#sort()</h3>
<p>Returns a new Iterable of the same type which includes the same entries, stably sorted by using a <code>comparator</code>.</p> <pre data-language="js">sort(comparator?: (valueA: T, valueB: T) =&gt; number): Iterable&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.sort">Iterable#sort</a></code><h4>Discussion</h4>
<p>If a <code>comparator</code> is not provided, a default comparator uses <code>&lt;</code> and <code>&gt;</code>.</p> <p><code>comparator(valueA, valueB)</code>:</p> <ul> <li>Returns <code>0</code> if the elements should not be swapped.</li> <li>Returns <code>-1</code> (or any negative number) if <code>valueA</code> comes before <code>valueB</code>
</li> <li>Returns <code>1</code> (or any positive number) if <code>valueA</code> comes after <code>valueB</code>
</li> <li>Is pure, i.e. it must always return the same value for the same pair of values.</li> </ul> <p>When sorting collections which have no defined order, their ordered equivalents will be returned. e.g. <code>map.sort()</code> returns OrderedMap.</p> <h3 id="list.sortby">List#sortBy()</h3>
<p>Like <code><a href="#iterable.sort">sort</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for sorting by more sophisticated means:</p> <pre data-language="js">sortBy&lt;C&gt;(comparatorValueMapper: (value?: T,key?: number,iter?: Iterable&lt;number, T&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): Iterable&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.sortby">Iterable#sortBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.sortBy(hitter =&gt; hitter.avgHits);</pre>
<h3 id="list.groupby">List#groupBy()</h3>
<p>Returns a <code><a href="#iterable.keyed">Iterable.Keyed</a></code> of <code>Iterable.Keyeds</code>, grouped by the return value of the <code>grouper</code> function.</p> <pre data-language="js">groupBy&lt;G&gt;(grouper: (value?: T, key?: number, iter?: Iterable&lt;number, T&gt;) =&gt; G,context?: any): Seq.Keyed&lt;G, Iterable&lt;number, T&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.groupby">Iterable#groupBy</a></code><h4>Discussion</h4>
<p>Note: This is always an eager operation.</p> <h2>Side effects</h2>
<h3 id="list.foreach">List#forEach()</h3>
<p>The <code>sideEffect</code> is executed for every entry in the Iterable.</p> <pre data-language="js">forEach(sideEffect: (value?: T, key?: number, iter?: Iterable&lt;number, T&gt;) =&gt; any,context?: any): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.foreach">Iterable#forEach</a></code><h4>Discussion</h4>
<p>Unlike <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">Array#forEach</a></code>, if any call of <code>sideEffect</code> returns <code>false</code>, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).</p> <h2>Creating subsets</h2>
<h3 id="list.slice">List#slice()</h3>
<p>Returns a new Iterable of the same type representing a portion of this Iterable from start up to but not including end.</p> <pre data-language="js">slice(begin?: number, end?: number): Iterable&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.slice">Iterable#slice</a></code><h4>Discussion</h4>
<p>If begin is negative, it is offset from the end of the Iterable. e.g. <code>slice(-2)</code> returns a Iterable of the last two entries. If it is not provided the new Iterable will begin at the beginning of this Iterable.</p> <p>If end is negative, it is offset from the end of the Iterable. e.g. <code>slice(0, -1)</code> returns an Iterable of everything but the last entry. If it is not provided, the new Iterable will continue through the end of this Iterable.</p> <p>If the requested slice is equivalent to the current Iterable, then it will return itself.</p> <h3 id="list.rest">List#rest()</h3>
<p>Returns a new Iterable of the same type containing all entries except the first.</p> <pre data-language="js">rest(): Iterable&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.rest">Iterable#rest</a></code><h3 id="list.butlast">List#butLast()</h3>
<p>Returns a new Iterable of the same type containing all entries except the last.</p> <pre data-language="js">butLast(): Iterable&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.butlast">Iterable#butLast</a></code><h3 id="list.skip">List#skip()</h3>
<p>Returns a new Iterable of the same type which excludes the first <code>amount</code> entries from this Iterable.</p> <pre data-language="js">skip(amount: number): Iterable&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skip">Iterable#skip</a></code><h3 id="list.skiplast">List#skipLast()</h3>
<p>Returns a new Iterable of the same type which excludes the last <code>amount</code> entries from this Iterable.</p> <pre data-language="js">skipLast(amount: number): Iterable&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skiplast">Iterable#skipLast</a></code><h3 id="list.skipwhile">List#skipWhile()</h3>
<p>Returns a new Iterable of the same type which includes entries starting from when <code>predicate</code> first returns false.</p> <pre data-language="js">skipWhile(predicate: (value?: T, key?: number, iter?: Iterable&lt;number, T&gt;) =&gt; boolean,context?: any): Iterable&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skipwhile">Iterable#skipWhile</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .skipWhile(x =&gt; x.match(/g/))
// Seq [ 'cat', 'hat', 'god' ]</pre>
<h3 id="list.skipuntil">List#skipUntil()</h3>
<p>Returns a new Iterable of the same type which includes entries starting from when <code>predicate</code> first returns true.</p> <pre data-language="js">skipUntil(predicate: (value?: T, key?: number, iter?: Iterable&lt;number, T&gt;) =&gt; boolean,context?: any): Iterable&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skipuntil">Iterable#skipUntil</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .skipUntil(x =&gt; x.match(/hat/))
// Seq [ 'hat', 'god' ]</pre>
<h3 id="list.take">List#take()</h3>
<p>Returns a new Iterable of the same type which includes the first <code>amount</code> entries from this Iterable.</p> <pre data-language="js">take(amount: number): Iterable&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.take">Iterable#take</a></code><h3 id="list.takelast">List#takeLast()</h3>
<p>Returns a new Iterable of the same type which includes the last <code>amount</code> entries from this Iterable.</p> <pre data-language="js">takeLast(amount: number): Iterable&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takelast">Iterable#takeLast</a></code><h3 id="list.takewhile">List#takeWhile()</h3>
<p>Returns a new Iterable of the same type which includes entries from this Iterable as long as the <code>predicate</code> returns true.</p> <pre data-language="js">takeWhile(predicate: (value?: T, key?: number, iter?: Iterable&lt;number, T&gt;) =&gt; boolean,context?: any): Iterable&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takewhile">Iterable#takeWhile</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .takeWhile(x =&gt; x.match(/o/))
// Seq [ 'dog', 'frog' ]</pre>
<h3 id="list.takeuntil">List#takeUntil()</h3>
<p>Returns a new Iterable of the same type which includes entries from this Iterable as long as the <code>predicate</code> returns false.</p> <pre data-language="js">takeUntil(predicate: (value?: T, key?: number, iter?: Iterable&lt;number, T&gt;) =&gt; boolean,context?: any): Iterable&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takeuntil">Iterable#takeUntil</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god').takeUntil(x =&gt; x.match(/at/))
// ['dog', 'frog']</pre>
<h2>Combination</h2>
<h3 id="list.concat">List#concat()</h3>
<p>Returns a new Iterable of the same type with other values and iterable-like concatenated to this one.</p> <pre data-language="js">concat(...valuesOrIterables: any[]): Iterable&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.concat">Iterable#concat</a></code><h4>Discussion</h4>
<p>For Seqs, all entries will be present in the resulting iterable, even if they have the same key.</p> <h3 id="list.flatten">List#flatten()</h3>
<p>Flattens nested Iterables.</p> <pre data-language="js">flatten(depth?: number): Iterable&lt;any, any&gt;
flatten(shallow?: boolean): Iterable&lt;any, any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.flatten">Iterable#flatten</a></code><h4>Discussion</h4>
<p>Will deeply flatten the Iterable by default, returning an Iterable of the same type, but a <code>depth</code> can be provided in the form of a number or boolean (where true means to shallowly flatten one level). A depth of 0 (or shallow: false) will deeply flatten.</p> <p>Flattens only others Iterable, not Arrays or Objects.</p> <p>Note: <code>flatten(true)</code> operates on Iterable<any iterable v="">&gt; and returns Iterable</any></p> <h3 id="list.flatmap">List#flatMap()</h3>
<p>Flat-maps the Iterable, returning an Iterable of the same type.</p> <pre data-language="js">flatMap&lt;MK, MV&gt;(mapper: (value?: T,key?: number,iter?: Iterable&lt;number, T&gt;) =&gt; Iterable&lt;MK, MV&gt;,context?: any): Iterable&lt;MK, MV&gt;
flatMap&lt;MK, MV&gt;(mapper: (value?: T, key?: number, iter?: Iterable&lt;number, T&gt;) =&gt; any,context?: any): Iterable&lt;MK, MV&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.flatmap">Iterable#flatMap</a></code><h4>Discussion</h4>
<p>Similar to <code>iter.map(...).flatten(true)</code>.</p> <h3 id="list.interpose">List#interpose()</h3>
<p>Returns an Iterable of the same type with <code>separator</code> between each item in this Iterable.</p> <pre data-language="js">interpose(separator: T): Iterable.Indexed&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.indexed.interpose">Iterable.Indexed#interpose</a></code><h3 id="list.interleave">List#interleave()</h3>
<p>Returns an Iterable of the same type with the provided <code>iterables</code> interleaved into this iterable.</p> <pre data-language="js">interleave(...iterables: Array&lt;Iterable&lt;any, T&gt;&gt;): Iterable.Indexed&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.indexed.interleave">Iterable.Indexed#interleave</a></code><h4>Discussion</h4>
<p>The resulting Iterable includes the first item from each, then the second from each, etc.</p> <pre data-language="js">I.Seq.of(1,2,3).interleave(I.Seq.of('A','B','C'))
// Seq [ 1, 'A', 2, 'B', 3, 'C' ]</pre>
<p>The shortest Iterable stops interleave.</p> <pre data-language="js">I.Seq.of(1,2,3).interleave(
  I.Seq.of('A','B'),
  I.Seq.of('X','Y','Z')
)
// Seq [ 1, 'A', 'X', 2, 'B', 'Y' ]</pre>
<h3 id="list.splice">List#splice()</h3>
<p>Splice returns a new indexed Iterable by replacing a region of this Iterable with new values. If values are not provided, it only skips the region to be removed.</p> <pre data-language="js">splice(index: number, removeNum: number, ...values: any[]): Iterable.Indexed&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.indexed.splice">Iterable.Indexed#splice</a></code><h4>Discussion</h4>
<p><code>index</code> may be a negative number, which indexes back from the end of the Iterable. <code>s.splice(-2)</code> splices after the second to last item.</p> <pre data-language="js">Seq(['a','b','c','d']).splice(1, 2, 'q', 'r', 's')
// Seq ['a', 'q', 'r', 's', 'd']</pre>
<h3 id="list.zip">List#zip()</h3>
<p>Returns an Iterable of the same type "zipped" with the provided iterables.</p> <pre data-language="js">zip(...iterables: Array&lt;Iterable&lt;any, any&gt;&gt;): Iterable.Indexed&lt;any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.indexed.zip">Iterable.Indexed#zip</a></code><h4>Discussion</h4>
<p>Like <code><a href="#iterable.indexed.zipwith">zipWith</a></code>, but using the default <code>zipper</code>: creating an <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">Array</a></code>.</p> <pre data-language="js">var a = Seq.of(1, 2, 3);
var b = Seq.of(4, 5, 6);
var c = a.zip(b); // Seq [ [ 1, 4 ], [ 2, 5 ], [ 3, 6 ] ]</pre>
<h3 id="list.zipwith">List#zipWith()</h3>
<p>Returns an Iterable of the same type "zipped" with the provided iterables by using a custom <code>zipper</code> function.</p> <pre data-language="js">zipWith&lt;U, Z&gt;(zipper: (value: T, otherValue: U) =&gt; Z,otherIterable: Iterable&lt;any, U&gt;): Iterable.Indexed&lt;Z&gt;
zipWith&lt;U, V, Z&gt;(zipper: (value: T, otherValue: U, thirdValue: V) =&gt; Z,otherIterable: Iterable&lt;any, U&gt;,thirdIterable: Iterable&lt;any, V&gt;): Iterable.Indexed&lt;Z&gt;
zipWith&lt;Z&gt;(zipper: (...any: Array&lt;any&gt;) =&gt; Z,...iterables: Array&lt;Iterable&lt;any, any&gt;&gt;): Iterable.Indexed&lt;Z&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.indexed.zipwith">Iterable.Indexed#zipWith</a></code><h4>Example</h4>
<pre data-language="js">var a = Seq.of(1, 2, 3);
var b = Seq.of(4, 5, 6);
var c = a.zipWith((a, b) =&gt; a + b, b); // Seq [ 5, 7, 9 ]</pre>
<h2>Reducing a value</h2>
<h3 id="list.reduce">List#reduce()</h3>
<p>Reduces the Iterable to a value by calling the <code>reducer</code> for every entry in the Iterable and passing along the reduced value.</p> <pre data-language="js">reduce&lt;R&gt;(reducer: (reduction?: R,value?: T,key?: number,iter?: Iterable&lt;number, T&gt;) =&gt; R,initialReduction?: R,context?: any): R
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reduce">Iterable#reduce</a></code><h4>see</h4>
<p><code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">Array#reduce</a></code>.</p> <h4>Discussion</h4>
<p>If <code>initialReduction</code> is not provided, or is null, the first item in the Iterable will be used.</p> <h3 id="list.reduceright">List#reduceRight()</h3>
<p>Reduces the Iterable in reverse (from the right side).</p> <pre data-language="js">reduceRight&lt;R&gt;(reducer: (reduction?: R,value?: T,key?: number,iter?: Iterable&lt;number, T&gt;) =&gt; R,initialReduction?: R,context?: any): R
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reduceright">Iterable#reduceRight</a></code><h4>Discussion</h4>
<p>Note: Similar to this.reverse().reduce(), and provided for parity with <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight">Array#reduceRight</a></code>.</p> <h3 id="list.every">List#every()</h3>
<p>True if <code>predicate</code> returns true for all entries in the Iterable.</p> <pre data-language="js">every(predicate: (value?: T, key?: number, iter?: Iterable&lt;number, T&gt;) =&gt; boolean,context?: any): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.every">Iterable#every</a></code><h3 id="list.some">List#some()</h3>
<p>True if <code>predicate</code> returns true for any entry in the Iterable.</p> <pre data-language="js">some(predicate: (value?: T, key?: number, iter?: Iterable&lt;number, T&gt;) =&gt; boolean,context?: any): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.some">Iterable#some</a></code><h3 id="list.join">List#join()</h3>
<p>Joins values together as a string, inserting a separator between each. The default separator is <code>","</code>.</p> <pre data-language="js">join(separator?: string): string
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.join">Iterable#join</a></code><h3 id="list.isempty">List#isEmpty()</h3>
<p>Returns true if this Iterable includes no values.</p> <pre data-language="js">isEmpty(): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.isempty">Iterable#isEmpty</a></code><h4>Discussion</h4>
<p>For some lazy <code><a href="#seq">Seq</a></code>, <code>isEmpty</code> might need to iterate to determine emptiness. At most one iteration will occur.</p> <h3 id="list.count">List#count()</h3>
<p>Returns the size of this Iterable.</p> <pre data-language="js">count(): number
count(predicate: (value?: T, key?: number, iter?: Iterable&lt;number, T&gt;) =&gt; boolean,context?: any): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.count">Iterable#count</a></code><h4>Discussion</h4>
<p>Regardless of if this Iterable can describe its size lazily (some Seqs cannot), this method will always return the correct size. E.g. it evaluates a lazy <code><a href="#seq">Seq</a></code> if necessary.</p> <p>If <code>predicate</code> is provided, then this returns the count of entries in the Iterable for which the <code>predicate</code> returns true.</p> <h3 id="list.countby">List#countBy()</h3>
<p>Returns a <code><a href="#seq.keyed">Seq.Keyed</a></code> of counts, grouped by the return value of the <code>grouper</code> function.</p> <pre data-language="js">countBy&lt;G&gt;(grouper: (value?: T, key?: number, iter?: Iterable&lt;number, T&gt;) =&gt; G,context?: any): Map&lt;G, number&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.countby">Iterable#countBy</a></code><h4>Discussion</h4>
<p>Note: This is not a lazy operation.</p> <h2>Search for value</h2>
<h3 id="list.find">List#find()</h3>
<p>Returns the first value for which the <code>predicate</code> returns true.</p> <pre data-language="js">find(predicate: (value?: T, key?: number, iter?: Iterable&lt;number, T&gt;) =&gt; boolean,context?: any,notSetValue?: T): T
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.find">Iterable#find</a></code><h3 id="list.findlast">List#findLast()</h3>
<p>Returns the last value for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLast(predicate: (value?: T, key?: number, iter?: Iterable&lt;number, T&gt;) =&gt; boolean,context?: any,notSetValue?: T): T
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlast">Iterable#findLast</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="list.findentry">List#findEntry()</h3>
<p>Returns the first [key, value] entry for which the <code>predicate</code> returns true.</p> <pre data-language="js">findEntry(predicate: (value?: T, key?: number, iter?: Iterable&lt;number, T&gt;) =&gt; boolean,context?: any,notSetValue?: T): Array&lt;any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findentry">Iterable#findEntry</a></code><h3 id="list.findlastentry">List#findLastEntry()</h3>
<p>Returns the last [key, value] entry for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLastEntry(predicate: (value?: T, key?: number, iter?: Iterable&lt;number, T&gt;) =&gt; boolean,context?: any,notSetValue?: T): Array&lt;any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlastentry">Iterable#findLastEntry</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="list.findkey">List#findKey()</h3>
<p>Returns the key for which the <code>predicate</code> returns true.</p> <pre data-language="js">findKey(predicate: (value?: T,key?: number,iter?: Iterable.Keyed&lt;number, T&gt;) =&gt; boolean,context?: any): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findkey">Iterable#findKey</a></code><h3 id="list.findlastkey">List#findLastKey()</h3>
<p>Returns the last key for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLastKey(predicate: (value?: T,key?: number,iter?: Iterable.Keyed&lt;number, T&gt;) =&gt; boolean,context?: any): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlastkey">Iterable#findLastKey</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="list.keyof">List#keyOf()</h3>
<p>Returns the key associated with the search value, or undefined.</p> <pre data-language="js">keyOf(searchValue: T): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyof">Iterable#keyOf</a></code><h3 id="list.lastkeyof">List#lastKeyOf()</h3>
<p>Returns the last key associated with the search value, or undefined.</p> <pre data-language="js">lastKeyOf(searchValue: T): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.lastkeyof">Iterable#lastKeyOf</a></code><h3 id="list.max">List#max()</h3>
<p>Returns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> <pre data-language="js">max(comparator?: (valueA: T, valueB: T) =&gt; number): T
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.max">Iterable#max</a></code><h4>Discussion</h4>
<p>The <code>comparator</code> is used in the same way as <code><a href="#iterable.sort">Iterable#sort</a></code>. If it is not provided, the default comparator is <code>&gt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code>max</code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&gt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> <h3 id="list.maxby">List#maxBy()</h3>
<p>Like <code><a href="#iterable.max">max</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> <pre data-language="js">maxBy&lt;C&gt;(comparatorValueMapper: (value?: T,key?: number,iter?: Iterable&lt;number, T&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): T
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.maxby">Iterable#maxBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.maxBy(hitter =&gt; hitter.avgHits);</pre>
<h3 id="list.min">List#min()</h3>
<p>Returns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> <pre data-language="js">min(comparator?: (valueA: T, valueB: T) =&gt; number): T
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.min">Iterable#min</a></code><h4>Discussion</h4>
<p>The <code>comparator</code> is used in the same way as <code><a href="#iterable.sort">Iterable#sort</a></code>. If it is not provided, the default comparator is <code>&lt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code>min</code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&lt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> <h3 id="list.minby">List#minBy()</h3>
<p>Like <code><a href="#iterable.min">min</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> <pre data-language="js">minBy&lt;C&gt;(comparatorValueMapper: (value?: T,key?: number,iter?: Iterable&lt;number, T&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): T
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.minby">Iterable#minBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.minBy(hitter =&gt; hitter.avgHits);</pre>
<h3 id="list.indexof">List#indexOf()</h3>
<p>Returns the first index at which a given value can be found in the Iterable, or -1 if it is not present.</p> <pre data-language="js">indexOf(searchValue: T): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.indexed.indexof">Iterable.Indexed#indexOf</a></code><h3 id="list.lastindexof">List#lastIndexOf()</h3>
<p>Returns the last index at which a given value can be found in the Iterable, or -1 if it is not present.</p> <pre data-language="js">lastIndexOf(searchValue: T): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.indexed.lastindexof">Iterable.Indexed#lastIndexOf</a></code><h3 id="list.findindex">List#findIndex()</h3>
<p>Returns the first index in the Iterable where a value satisfies the provided predicate function. Otherwise -1 is returned.</p> <pre data-language="js">findIndex(predicate: (value?: T, index?: number, iter?: Iterable.Indexed&lt;T&gt;) =&gt; boolean,context?: any): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.indexed.findindex">Iterable.Indexed#findIndex</a></code><h3 id="list.findlastindex">List#findLastIndex()</h3>
<p>Returns the last index in the Iterable where a value satisfies the provided predicate function. Otherwise -1 is returned.</p> <pre data-language="js">findLastIndex(predicate: (value?: T, index?: number, iter?: Iterable.Indexed&lt;T&gt;) =&gt; boolean,context?: any): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.indexed.findlastindex">Iterable.Indexed#findLastIndex</a></code><h2>Comparison</h2>
<h3 id="list.issubset">List#isSubset()</h3>
<p>True if <code>iter</code> includes every value in this Iterable.</p> <pre data-language="js">isSubset(iter: Iterable&lt;any, T&gt;): boolean
isSubset(iter: Array&lt;T&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.issubset">Iterable#isSubset</a></code><h3 id="list.issuperset">List#isSuperset()</h3>
<p>True if this Iterable includes every value in <code>iter</code>.</p> <pre data-language="js">isSuperset(iter: Iterable&lt;any, T&gt;): boolean
isSuperset(iter: Array&lt;T&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.issuperset">Iterable#isSuperset</a></code><h1 id="map">Map</h1>
<p>Immutable Map is an unordered Iterable.Keyed of (key, value) pairs with <code>O(log32 N)</code> gets and <code>O(log32 N)</code> persistent sets.</p> <pre data-language="js">class Map&lt;K, V&gt; extends Collection.Keyed&lt;K, V&gt;</pre>
<h4>Discussion</h4>
<p>Iteration order of a Map is undefined, however is stable. Multiple iterations of the same Map will iterate in the same order.</p> <p>Map's keys can be of any type, and use <code><a href="#is">Immutable.is</a></code> to determine key equality. This allows the use of any value (including NaN) as a key.</p> <p>Because <code><a href="#is">Immutable.is</a></code> returns equality based on value semantics, and Immutable collections are treated as values, any Immutable collection may be used as a key.</p> <pre data-language="js">Map().set(List.of(1), 'listofone').get(List.of(1));
// 'listofone'</pre>
<p>Any JavaScript object may be used as a key, however strict identity is used to evaluate key equality. Two similar looking objects will represent two different keys.</p> <p>Implemented by a hash-array mapped trie.</p> <h2>Construction</h2>
<h3 id="map()">Map()</h3>
<p>Creates a new Immutable Map.</p> <pre data-language="js">Map&lt;K, V&gt;(): Map&lt;K, V&gt;
Map&lt;K, V&gt;(iter: Iterable.Keyed&lt;K, V&gt;): Map&lt;K, V&gt;
Map&lt;K, V&gt;(iter: Iterable&lt;any, Array&lt;any&gt;&gt;): Map&lt;K, V&gt;
Map&lt;K, V&gt;(array: Array&lt;Array&lt;any&gt;&gt;): Map&lt;K, V&gt;
Map&lt;V&gt;(obj: {[key: string]: V}): Map&lt;string, V&gt;
Map&lt;K, V&gt;(iterator: Iterator&lt;Array&lt;any&gt;&gt;): Map&lt;K, V&gt;
Map&lt;K, V&gt;(iterable: Object): Map&lt;K, V&gt;
</pre>
<h4>Discussion</h4>
<p>Created with the same key value pairs as the provided Iterable.Keyed or JavaScript Object or expects an Iterable of [K, V] tuple entries.</p> <pre data-language="js">var newMap = Map({key: "value"});
var newMap = Map([["key", "value"]]);</pre>
<p>Keep in mind, when using JS objects to construct Immutable Maps, that JavaScript Object properties are always strings, even if written in a quote-less shorthand, while Immutable Maps accept keys of any type.</p> <pre data-language="js">var obj = { 1: "one" };
Object.keys(obj); // [ "1" ]
obj["1"]; // "one"
obj[1];   // "one"

var map = Map(obj);
map.get("1"); // "one"
map.get(1);   // undefined</pre>
<p>Property access for JavaScript Objects first converts the key to a string, but since Immutable Map keys can be of any type the argument to <code><a href="#map.get">get()</a></code> is not altered.</p> <h2>Static methods</h2>
<h3 id="map.ismap">Map.isMap()</h3>
<p>True if the provided value is a Map</p> <pre data-language="js">Map.isMap(maybeMap: any): boolean
</pre>
<h3 id="map.of">Map.of()</h3>
<p>Creates a new Map from alternating keys and values</p> <pre data-language="js">Map.of(...keyValues: any[]): Map&lt;any, any&gt;
</pre>
<h2>Members</h2>
<h3 id="map.size">Map#size</h3>
<pre data-language="js">size: number</pre>
<h4>Inherited from</h4>
<code><a href="#collection.size">Collection#size</a></code><h2>Persistent changes</h2>
<h3 id="map.set">Map#set()</h3>
<p>Returns a new Map also containing the new key, value pair. If an equivalent key already exists in this Map, it will be replaced.</p> <pre data-language="js">set(key: K, value: V): Map&lt;K, V&gt;
</pre>
<h3 id="map.delete">Map#delete()</h3>
<p>Returns a new Map which excludes this <code>key</code>.</p> <pre data-language="js">delete(key: K): Map&lt;K, V&gt;
</pre>
<h4>alias</h4>
<code>remove()</code><h4>Discussion</h4>
<p>Note: <code>delete</code> cannot be safely used in IE8, but is provided to mirror the ES6 collection API.</p> <h3 id="map.clear">Map#clear()</h3>
<p>Returns a new Map containing no keys or values.</p> <pre data-language="js">clear(): Map&lt;K, V&gt;
</pre>
<h3 id="map.update">Map#update()</h3>
<p>Returns a new Map having updated the value at this <code>key</code> with the return value of calling <code>updater</code> with the existing value, or <code>notSetValue</code> if the key was not set. If called with only a single argument, <code>updater</code> is called with the Map itself.</p> <pre data-language="js">update(updater: (value: Map&lt;K, V&gt;) =&gt; Map&lt;K, V&gt;): Map&lt;K, V&gt;
update(key: K, updater: (value: V) =&gt; V): Map&lt;K, V&gt;
update(key: K, notSetValue: V, updater: (value: V) =&gt; V): Map&lt;K, V&gt;
</pre>
<h4>Discussion</h4>
<p>Equivalent to: <code>map.set(key, updater(map.get(key, notSetValue)))</code>.</p> <h3 id="map.merge">Map#merge()</h3>
<p>Returns a new Map resulting from merging the provided Iterables (or JS objects) into this Map. In other words, this takes each entry of each iterable and sets it on this Map.</p> <pre data-language="js">merge(...iterables: Iterable&lt;K, V&gt;[]): Map&lt;K, V&gt;
merge(...iterables: {[key: string]: V}[]): Map&lt;string, V&gt;
</pre>
<h4>Discussion</h4>
<p>If any of the values provided to <code>merge</code> are not Iterable (would return false for <code>Immutable.Iterable.isIterable</code>) then they are deeply converted via <code><a href="#fromjs">Immutable.fromJS</a></code> before being merged. However, if the value is an Iterable but includes non-iterable JS objects or arrays, those nested values will be preserved.</p> <pre data-language="js">var x = Immutable.Map({a: 10, b: 20, c: 30});
var y = Immutable.Map({b: 40, a: 50, d: 60});
x.merge(y) // { a: 50, b: 40, c: 30, d: 60 }
y.merge(x) // { b: 20, a: 10, d: 60, c: 30 }</pre>
<h3 id="map.mergewith">Map#mergeWith()</h3>
<p>Like <code><a href="#map.merge">merge()</a></code>, <code>mergeWith()</code> returns a new Map resulting from merging the provided Iterables (or JS objects) into this Map, but uses the <code>merger</code> function for dealing with conflicts.</p> <pre data-language="js">mergeWith(merger: (previous?: V, next?: V, key?: K) =&gt; V,...iterables: Iterable&lt;K, V&gt;[]): Map&lt;K, V&gt;
mergeWith(merger: (previous?: V, next?: V, key?: K) =&gt; V,...iterables: {[key: string]: V}[]): Map&lt;string, V&gt;
</pre>
<h4>Example</h4>
<pre data-language="js">var x = Immutable.Map({a: 10, b: 20, c: 30});
var y = Immutable.Map({b: 40, a: 50, d: 60});
x.mergeWith((prev, next) =&gt; prev / next, y) // { a: 0.2, b: 0.5, c: 30, d: 60 }
y.mergeWith((prev, next) =&gt; prev / next, x) // { b: 2, a: 5, d: 60, c: 30 }</pre>
<h3 id="map.mergedeep">Map#mergeDeep()</h3>
<p>Like <code><a href="#map.merge">merge()</a></code>, but when two Iterables conflict, it merges them as well, recursing deeply through the nested data.</p> <pre data-language="js">mergeDeep(...iterables: Iterable&lt;K, V&gt;[]): Map&lt;K, V&gt;
mergeDeep(...iterables: {[key: string]: V}[]): Map&lt;string, V&gt;
</pre>
<h4>Example</h4>
<pre data-language="js">var x = Immutable.fromJS({a: { x: 10, y: 10 }, b: { x: 20, y: 50 } });
var y = Immutable.fromJS({a: { x: 2 }, b: { y: 5 }, c: { z: 3 } });
x.mergeDeep(y) // {a: { x: 2, y: 10 }, b: { x: 20, y: 5 }, c: { z: 3 } }</pre>
<h3 id="map.mergedeepwith">Map#mergeDeepWith()</h3>
<p>Like <code><a href="#map.mergedeep">mergeDeep()</a></code>, but when two non-Iterables conflict, it uses the <code>merger</code> function to determine the resulting value.</p> <pre data-language="js">mergeDeepWith(merger: (previous?: V, next?: V, key?: K) =&gt; V,...iterables: Iterable&lt;K, V&gt;[]): Map&lt;K, V&gt;
mergeDeepWith(merger: (previous?: V, next?: V, key?: K) =&gt; V,...iterables: {[key: string]: V}[]): Map&lt;string, V&gt;
</pre>
<h4>Example</h4>
<pre data-language="js">var x = Immutable.fromJS({a: { x: 10, y: 10 }, b: { x: 20, y: 50 } });
var y = Immutable.fromJS({a: { x: 2 }, b: { y: 5 }, c: { z: 3 } });
x.mergeDeepWith((prev, next) =&gt; prev / next, y)
// {a: { x: 5, y: 10 }, b: { x: 20, y: 10 }, c: { z: 3 } }</pre>
<h2>Deep persistent changes</h2>
<h3 id="map.setin">Map#setIn()</h3>
<p>Returns a new Map having set <code>value</code> at this <code>keyPath</code>. If any keys in <code>keyPath</code> do not exist, a new immutable Map will be created at that key.</p> <pre data-language="js">setIn(keyPath: Array&lt;any&gt;, value: any): Map&lt;K, V&gt;
setIn(KeyPath: Iterable&lt;any, any&gt;, value: any): Map&lt;K, V&gt;
</pre>
<h3 id="map.deletein">Map#deleteIn()</h3>
<p>Returns a new Map having removed the value at this <code>keyPath</code>. If any keys in <code>keyPath</code> do not exist, no change will occur.</p> <pre data-language="js">deleteIn(keyPath: Array&lt;any&gt;): Map&lt;K, V&gt;
deleteIn(keyPath: Iterable&lt;any, any&gt;): Map&lt;K, V&gt;
</pre>
<h4>alias</h4>
<code>removeIn()</code><h3 id="map.updatein">Map#updateIn()</h3>
<p>Returns a new Map having applied the <code>updater</code> to the entry found at the keyPath.</p> <pre data-language="js">updateIn(keyPath: Array&lt;any&gt;, updater: (value: any) =&gt; any): Map&lt;K, V&gt;
updateIn(keyPath: Array&lt;any&gt;,notSetValue: any,updater: (value: any) =&gt; any): Map&lt;K, V&gt;
updateIn(keyPath: Iterable&lt;any, any&gt;, updater: (value: any) =&gt; any): Map&lt;K, V&gt;
updateIn(keyPath: Iterable&lt;any, any&gt;,notSetValue: any,updater: (value: any) =&gt; any): Map&lt;K, V&gt;
</pre>
<h4>Discussion</h4>
<p>If any keys in <code>keyPath</code> do not exist, new Immutable <code>Map</code>s will be created at those keys. If the <code>keyPath</code> does not already contain a value, the <code>updater</code> function will be called with <code>notSetValue</code>, if provided, otherwise <code>undefined</code>.</p> <pre data-language="js">var data = Immutable.fromJS({ a: { b: { c: 10 } } });
data = data.updateIn(['a', 'b', 'c'], val =&gt; val * 2);
// { a: { b: { c: 20 } } }</pre>
<p>If the <code>updater</code> function returns the same value it was called with, then no change will occur. This is still true if <code>notSetValue</code> is provided.</p> <pre data-language="js">var data1 = Immutable.fromJS({ a: { b: { c: 10 } } });
data2 = data1.updateIn(['x', 'y', 'z'], 100, val =&gt; val);
assert(data2 === data1);</pre>
<h3 id="map.mergein">Map#mergeIn()</h3>
<p>A combination of <code><a href="#map.updatein">updateIn</a></code> and <code><a href="#map.merge">merge</a></code>, returning a new Map, but performing the merge at a point arrived at by following the keyPath. In other words, these two lines are equivalent:</p> <pre data-language="js">mergeIn(keyPath: Iterable&lt;any, any&gt;, ...iterables: Iterable&lt;K, V&gt;[]): Map&lt;K, V&gt;
mergeIn(keyPath: Array&lt;any&gt;, ...iterables: Iterable&lt;K, V&gt;[]): Map&lt;K, V&gt;
mergeIn(keyPath: Array&lt;any&gt;, ...iterables: {[key: string]: V}[]): Map&lt;string, V&gt;
</pre>
<h4>Example</h4>
<pre data-language="js">x.updateIn(['a', 'b', 'c'], abc =&gt; abc.merge(y));
x.mergeIn(['a', 'b', 'c'], y);</pre>
<h3 id="map.mergedeepin">Map#mergeDeepIn()</h3>
<p>A combination of <code><a href="#map.updatein">updateIn</a></code> and <code><a href="#map.mergedeep">mergeDeep</a></code>, returning a new Map, but performing the deep merge at a point arrived at by following the keyPath. In other words, these two lines are equivalent:</p> <pre data-language="js">mergeDeepIn(keyPath: Iterable&lt;any, any&gt;,...iterables: Iterable&lt;K, V&gt;[]): Map&lt;K, V&gt;
mergeDeepIn(keyPath: Array&lt;any&gt;, ...iterables: Iterable&lt;K, V&gt;[]): Map&lt;K, V&gt;
mergeDeepIn(keyPath: Array&lt;any&gt;,...iterables: {[key: string]: V}[]): Map&lt;string, V&gt;
</pre>
<h4>Example</h4>
<pre data-language="js">x.updateIn(['a', 'b', 'c'], abc =&gt; abc.mergeDeep(y));
x.mergeDeepIn(['a', 'b', 'c'], y);</pre>
<h2>Transient changes</h2>
<h3 id="map.withmutations">Map#withMutations()</h3>
<p>Every time you call one of the above functions, a new immutable Map is created. If a pure function calls a number of these to produce a final return value, then a penalty on performance and memory has been paid by creating all of the intermediate immutable Maps.</p> <pre data-language="js">withMutations(mutator: (mutable: Map&lt;K, V&gt;) =&gt; any): Map&lt;K, V&gt;
</pre>
<h4>Discussion</h4>
<p>If you need to apply a series of mutations to produce a new immutable Map, <code>withMutations()</code> creates a temporary mutable copy of the Map which can apply mutations in a highly performant manner. In fact, this is exactly how complex mutations like <code><a href="#map.merge">merge</a></code> are done.</p> <p>As an example, this results in the creation of 2, not 4, new Maps:</p> <pre data-language="js">var map1 = Immutable.Map();
var map2 = map1.withMutations(map =&gt; {
  map.set('a', 1).set('b', 2).set('c', 3);
});
assert(map1.size === 0);
assert(map2.size === 3);</pre>
<p>Note: Not all methods can be used on a mutable collection or within <code>withMutations</code>! Only <code><a href="#map.set">set</a></code> and <code><a href="#map.merge">merge</a></code> may be used mutatively.</p> <h3 id="map.asmutable">Map#asMutable()</h3>
<p>Another way to avoid creation of intermediate Immutable maps is to create a mutable copy of this collection. Mutable copies <em>always</em> return <code>this</code>, and thus shouldn't be used for equality. Your function should never return a mutable copy of a collection, only use it internally to create a new collection. If possible, use <code><a href="#map.withmutations">withMutations</a></code> as it provides an easier to use API.</p> <pre data-language="js">asMutable(): Map&lt;K, V&gt;
</pre>
<h4>Discussion</h4>
<p>Note: if the collection is already mutable, <code>asMutable</code> returns itself.</p> <p>Note: Not all methods can be used on a mutable collection or within <code><a href="#map.withmutations">withMutations</a></code>! Only <code><a href="#map.set">set</a></code> and <code><a href="#map.merge">merge</a></code> may be used mutatively.</p> <h3 id="map.asimmutable">Map#asImmutable()</h3>
<p>The yin to <code><a href="#map.asmutable">asMutable</a></code>'s yang. Because it applies to mutable collections, this operation is <em>mutable</em> and returns itself. Once performed, the mutable copy has become immutable and can be safely returned from a function.</p> <pre data-language="js">asImmutable(): Map&lt;K, V&gt;
</pre>
<h2>Conversion to Seq</h2>
<h3 id="map.toseq">Map#toSeq()</h3>
<p>Returns Seq.Keyed.</p> <pre data-language="js">toSeq(): Seq.Keyed&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#collection.keyed.toseq">Collection.Keyed#toSeq</a></code><h3 id="map.tokeyedseq">Map#toKeyedSeq()</h3>
<p>Returns a Seq.Keyed from this Iterable where indices are treated as keys.</p> <pre data-language="js">toKeyedSeq(): Seq.Keyed&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tokeyedseq">Iterable#toKeyedSeq</a></code><h4>Discussion</h4>
<p>This is useful if you want to operate on an Iterable.Indexed and preserve the [index, value] pairs.</p> <p>The returned Seq will have identical iteration order as this Iterable.</p> <p>Example:</p> <pre data-language="js">var indexedSeq = Immutable.Seq.of('A', 'B', 'C');
indexedSeq.filter(v =&gt; v === 'B').toString() // Seq [ 'B' ]
var keyedSeq = indexedSeq.toKeyedSeq();
keyedSeq.filter(v =&gt; v === 'B').toString() // Seq { 1: 'B' }</pre>
<h3 id="map.toindexedseq">Map#toIndexedSeq()</h3>
<p>Returns an Seq.Indexed of the values of this Iterable, discarding keys.</p> <pre data-language="js">toIndexedSeq(): Seq.Indexed&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toindexedseq">Iterable#toIndexedSeq</a></code><h3 id="map.tosetseq">Map#toSetSeq()</h3>
<p>Returns a Seq.Set of the values of this Iterable, discarding keys.</p> <pre data-language="js">toSetSeq(): Seq.Set&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tosetseq">Iterable#toSetSeq</a></code><h2>Value equality</h2>
<h3 id="map.equals">Map#equals()</h3>
<p>True if this and the other Iterable have value equality, as defined by <code><a href="#is">Immutable.is()</a></code>.</p> <pre data-language="js">equals(other: Iterable&lt;K, V&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.equals">Iterable#equals</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Immutable.is(this, other)</code>, but provided to allow for chained expressions.</p> <h3 id="map.hashcode">Map#hashCode()</h3>
<p>Computes and returns the hashed identity for this Iterable.</p> <pre data-language="js">hashCode(): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.hashcode">Iterable#hashCode</a></code><h4>Discussion</h4>
<p>The <code>hashCode</code> of an Iterable is used to determine potential equality, and is used when adding this to a <code><a href="#iterable.set">Set</a></code> or as a key in a <code><a href="#map">Map</a></code>, enabling lookup via a different instance.</p> <pre data-language="js">var a = List.of(1, 2, 3);
var b = List.of(1, 2, 3);
assert(a !== b); // different instances
var set = Set.of(a);
assert(set.has(b) === true);</pre>
<p>If two values have the same <code>hashCode</code>, they are <a href="http://en.wikipedia.org/wiki/Collision_(computer_science)">not guaranteed to be equal</a>. If two values have different <code>hashCode</code>s, they must not be equal.</p> <h2>Reading values</h2>
<h3 id="map.get">Map#get()</h3>
<p>Returns the value associated with the provided key, or notSetValue if the Iterable does not contain this key.</p> <pre data-language="js">get(key: K, notSetValue?: V): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.get">Iterable#get</a></code><h4>Discussion</h4>
<p>Note: it is possible a key may be associated with an <code>undefined</code> value, so if <code>notSetValue</code> is not provided and this method returns <code>undefined</code>, that does not guarantee the key was not found.</p> <h3 id="map.has">Map#has()</h3>
<p>True if a key exists within this <code>Iterable</code>, using <code><a href="#is">Immutable.is</a></code> to determine equality</p> <pre data-language="js">has(key: K): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.has">Iterable#has</a></code><h3 id="map.includes">Map#includes()</h3>
<p>True if a value exists within this <code>Iterable</code>, using <code><a href="#is">Immutable.is</a></code> to determine equality</p> <pre data-language="js">includes(value: V): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.includes">Iterable#includes</a></code><h4>alias</h4>
<code>contains()</code><h3 id="map.first">Map#first()</h3>
<p>The first value in the Iterable.</p> <pre data-language="js">first(): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.first">Iterable#first</a></code><h3 id="map.last">Map#last()</h3>
<p>The last value in the Iterable.</p> <pre data-language="js">last(): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.last">Iterable#last</a></code><h2>Reading deep values</h2>
<h3 id="map.getin">Map#getIn()</h3>
<p>Returns the value found by following a path of keys or indices through nested Iterables.</p> <pre data-language="js">getIn(searchKeyPath: Array&lt;any&gt;, notSetValue?: any): any
getIn(searchKeyPath: Iterable&lt;any, any&gt;, notSetValue?: any): any
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.getin">Iterable#getIn</a></code><h3 id="map.hasin">Map#hasIn()</h3>
<p>True if the result of following a path of keys or indices through nested Iterables results in a set value.</p> <pre data-language="js">hasIn(searchKeyPath: Array&lt;any&gt;): boolean
hasIn(searchKeyPath: Iterable&lt;any, any&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.hasin">Iterable#hasIn</a></code><h2>Conversion to JavaScript types</h2>
<h3 id="map.tojs">Map#toJS()</h3>
<p>Deeply converts this Iterable to equivalent JS.</p> <pre data-language="js">toJS(): any
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tojs">Iterable#toJS</a></code><h4>alias</h4>
<code>toJSON()</code><h4>Discussion</h4>
<p><code>Iterable.Indexeds</code>, and <code>Iterable.Sets</code> become Arrays, while <code>Iterable.Keyeds</code> become Objects.</p> <h3 id="map.toarray">Map#toArray()</h3>
<p>Shallowly converts this iterable to an Array, discarding keys.</p> <pre data-language="js">toArray(): Array&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toarray">Iterable#toArray</a></code><h3 id="map.toobject">Map#toObject()</h3>
<p>Shallowly converts this Iterable to an Object.</p> <pre data-language="js">toObject(): {[key: string]: V}
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toobject">Iterable#toObject</a></code><h4>Discussion</h4>
<p>Throws if keys are not strings.</p> <h2>Conversion to Collections</h2>
<h3 id="map.tomap">Map#toMap()</h3>
<p>Converts this Iterable to a Map, Throws if keys are not hashable.</p> <pre data-language="js">toMap(): Map&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tomap">Iterable#toMap</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Map(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="map.toorderedmap">Map#toOrderedMap()</h3>
<p>Converts this Iterable to a Map, maintaining the order of iteration.</p> <pre data-language="js">toOrderedMap(): OrderedMap&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toorderedmap">Iterable#toOrderedMap</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>OrderedMap(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="map.toset">Map#toSet()</h3>
<p>Converts this Iterable to a Set, discarding keys. Throws if values are not hashable.</p> <pre data-language="js">toSet(): Set&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toset">Iterable#toSet</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Set(this)</code>, but provided to allow for chained expressions.</p> <h3 id="map.toorderedset">Map#toOrderedSet()</h3>
<p>Converts this Iterable to a Set, maintaining the order of iteration and discarding keys.</p> <pre data-language="js">toOrderedSet(): OrderedSet&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toorderedset">Iterable#toOrderedSet</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>OrderedSet(this.valueSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="map.tolist">Map#toList()</h3>
<p>Converts this Iterable to a List, discarding keys.</p> <pre data-language="js">toList(): List&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tolist">Iterable#toList</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>List(this)</code>, but provided to allow for chained expressions.</p> <h3 id="map.tostack">Map#toStack()</h3>
<p>Converts this Iterable to a Stack, discarding keys. Throws if values are not hashable.</p> <pre data-language="js">toStack(): Stack&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tostack">Iterable#toStack</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Stack(this)</code>, but provided to allow for chained expressions.</p> <h2>Iterators</h2>
<h3 id="map.keys">Map#keys()</h3>
<p>An iterator of this <code>Iterable</code>'s keys.</p> <pre data-language="js">keys(): Iterator&lt;K&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keys">Iterable#keys</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.keyseq">keySeq</a></code> instead, if this is what you want.</p> <h3 id="map.values">Map#values()</h3>
<p>An iterator of this <code>Iterable</code>'s values.</p> <pre data-language="js">values(): Iterator&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.values">Iterable#values</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.valueseq">valueSeq</a></code> instead, if this is what you want.</p> <h3 id="map.entries">Map#entries()</h3>
<p>An iterator of this <code>Iterable</code>'s entries as <code>[key, value]</code> tuples.</p> <pre data-language="js">entries(): Iterator&lt;Array&lt;any&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.entries">Iterable#entries</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.entryseq">entrySeq</a></code> instead, if this is what you want.</p> <h2>Iterables (Seq)</h2>
<h3 id="map.keyseq">Map#keySeq()</h3>
<p>Returns a new Seq.Indexed of the keys of this Iterable, discarding values.</p> <pre data-language="js">keySeq(): Seq.Indexed&lt;K&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyseq">Iterable#keySeq</a></code><h3 id="map.valueseq">Map#valueSeq()</h3>
<p>Returns an Seq.Indexed of the values of this Iterable, discarding keys.</p> <pre data-language="js">valueSeq(): Seq.Indexed&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.valueseq">Iterable#valueSeq</a></code><h3 id="map.entryseq">Map#entrySeq()</h3>
<p>Returns a new Seq.Indexed of [key, value] tuples.</p> <pre data-language="js">entrySeq(): Seq.Indexed&lt;Array&lt;any&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.entryseq">Iterable#entrySeq</a></code><h2>Sequence algorithms</h2>
<h3 id="map()">map()</h3>
<p>Returns a new Iterable of the same type with values passed through a <code>mapper</code> function.</p> <pre data-language="js">map&lt;M&gt;(mapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; M,context?: any): Iterable&lt;K, M&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.map">Iterable#map</a></code><h4>Example</h4>
<pre data-language="js">Seq({ a: 1, b: 2 }).map(x =&gt; 10 * x)
// Seq { a: 10, b: 20 }</pre>
<h3 id="map.filter">Map#filter()</h3>
<p>Returns a new Iterable of the same type with only the entries for which the <code>predicate</code> function returns true.</p> <pre data-language="js">filter(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.filter">Iterable#filter</a></code><h4>Example</h4>
<pre data-language="js">Seq({a:1,b:2,c:3,d:4}).filter(x =&gt; x % 2 === 0)
// Seq { b: 2, d: 4 }</pre>
<h3 id="map.filternot">Map#filterNot()</h3>
<p>Returns a new Iterable of the same type with only the entries for which the <code>predicate</code> function returns false.</p> <pre data-language="js">filterNot(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.filternot">Iterable#filterNot</a></code><h4>Example</h4>
<pre data-language="js">Seq({a:1,b:2,c:3,d:4}).filterNot(x =&gt; x % 2 === 0)
// Seq { a: 1, c: 3 }</pre>
<h3 id="map.reverse">Map#reverse()</h3>
<p>Returns a new Iterable of the same type in reverse order.</p> <pre data-language="js">reverse(): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reverse">Iterable#reverse</a></code><h3 id="map.sort">Map#sort()</h3>
<p>Returns a new Iterable of the same type which includes the same entries, stably sorted by using a <code>comparator</code>.</p> <pre data-language="js">sort(comparator?: (valueA: V, valueB: V) =&gt; number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.sort">Iterable#sort</a></code><h4>Discussion</h4>
<p>If a <code>comparator</code> is not provided, a default comparator uses <code>&lt;</code> and <code>&gt;</code>.</p> <p><code>comparator(valueA, valueB)</code>:</p> <ul> <li>Returns <code>0</code> if the elements should not be swapped.</li> <li>Returns <code>-1</code> (or any negative number) if <code>valueA</code> comes before <code>valueB</code>
</li> <li>Returns <code>1</code> (or any positive number) if <code>valueA</code> comes after <code>valueB</code>
</li> <li>Is pure, i.e. it must always return the same value for the same pair of values.</li> </ul> <p>When sorting collections which have no defined order, their ordered equivalents will be returned. e.g. <code>map.sort()</code> returns OrderedMap.</p> <h3 id="map.sortby">Map#sortBy()</h3>
<p>Like <code><a href="#iterable.sort">sort</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for sorting by more sophisticated means:</p> <pre data-language="js">sortBy&lt;C&gt;(comparatorValueMapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.sortby">Iterable#sortBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.sortBy(hitter =&gt; hitter.avgHits);</pre>
<h3 id="map.groupby">Map#groupBy()</h3>
<p>Returns a <code><a href="#iterable.keyed">Iterable.Keyed</a></code> of <code>Iterable.Keyeds</code>, grouped by the return value of the <code>grouper</code> function.</p> <pre data-language="js">groupBy&lt;G&gt;(grouper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; G,context?: any): Seq.Keyed&lt;G, Iterable&lt;K, V&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.groupby">Iterable#groupBy</a></code><h4>Discussion</h4>
<p>Note: This is always an eager operation.</p> <h2>Side effects</h2>
<h3 id="map.foreach">Map#forEach()</h3>
<p>The <code>sideEffect</code> is executed for every entry in the Iterable.</p> <pre data-language="js">forEach(sideEffect: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; any,context?: any): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.foreach">Iterable#forEach</a></code><h4>Discussion</h4>
<p>Unlike <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">Array#forEach</a></code>, if any call of <code>sideEffect</code> returns <code>false</code>, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).</p> <h2>Creating subsets</h2>
<h3 id="map.slice">Map#slice()</h3>
<p>Returns a new Iterable of the same type representing a portion of this Iterable from start up to but not including end.</p> <pre data-language="js">slice(begin?: number, end?: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.slice">Iterable#slice</a></code><h4>Discussion</h4>
<p>If begin is negative, it is offset from the end of the Iterable. e.g. <code>slice(-2)</code> returns a Iterable of the last two entries. If it is not provided the new Iterable will begin at the beginning of this Iterable.</p> <p>If end is negative, it is offset from the end of the Iterable. e.g. <code>slice(0, -1)</code> returns an Iterable of everything but the last entry. If it is not provided, the new Iterable will continue through the end of this Iterable.</p> <p>If the requested slice is equivalent to the current Iterable, then it will return itself.</p> <h3 id="map.rest">Map#rest()</h3>
<p>Returns a new Iterable of the same type containing all entries except the first.</p> <pre data-language="js">rest(): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.rest">Iterable#rest</a></code><h3 id="map.butlast">Map#butLast()</h3>
<p>Returns a new Iterable of the same type containing all entries except the last.</p> <pre data-language="js">butLast(): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.butlast">Iterable#butLast</a></code><h3 id="map.skip">Map#skip()</h3>
<p>Returns a new Iterable of the same type which excludes the first <code>amount</code> entries from this Iterable.</p> <pre data-language="js">skip(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skip">Iterable#skip</a></code><h3 id="map.skiplast">Map#skipLast()</h3>
<p>Returns a new Iterable of the same type which excludes the last <code>amount</code> entries from this Iterable.</p> <pre data-language="js">skipLast(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skiplast">Iterable#skipLast</a></code><h3 id="map.skipwhile">Map#skipWhile()</h3>
<p>Returns a new Iterable of the same type which includes entries starting from when <code>predicate</code> first returns false.</p> <pre data-language="js">skipWhile(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skipwhile">Iterable#skipWhile</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .skipWhile(x =&gt; x.match(/g/))
// Seq [ 'cat', 'hat', 'god' ]</pre>
<h3 id="map.skipuntil">Map#skipUntil()</h3>
<p>Returns a new Iterable of the same type which includes entries starting from when <code>predicate</code> first returns true.</p> <pre data-language="js">skipUntil(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skipuntil">Iterable#skipUntil</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .skipUntil(x =&gt; x.match(/hat/))
// Seq [ 'hat', 'god' ]</pre>
<h3 id="map.take">Map#take()</h3>
<p>Returns a new Iterable of the same type which includes the first <code>amount</code> entries from this Iterable.</p> <pre data-language="js">take(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.take">Iterable#take</a></code><h3 id="map.takelast">Map#takeLast()</h3>
<p>Returns a new Iterable of the same type which includes the last <code>amount</code> entries from this Iterable.</p> <pre data-language="js">takeLast(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takelast">Iterable#takeLast</a></code><h3 id="map.takewhile">Map#takeWhile()</h3>
<p>Returns a new Iterable of the same type which includes entries from this Iterable as long as the <code>predicate</code> returns true.</p> <pre data-language="js">takeWhile(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takewhile">Iterable#takeWhile</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .takeWhile(x =&gt; x.match(/o/))
// Seq [ 'dog', 'frog' ]</pre>
<h3 id="map.takeuntil">Map#takeUntil()</h3>
<p>Returns a new Iterable of the same type which includes entries from this Iterable as long as the <code>predicate</code> returns false.</p> <pre data-language="js">takeUntil(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takeuntil">Iterable#takeUntil</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god').takeUntil(x =&gt; x.match(/at/))
// ['dog', 'frog']</pre>
<h2>Combination</h2>
<h3 id="map.concat">Map#concat()</h3>
<p>Returns a new Iterable of the same type with other values and iterable-like concatenated to this one.</p> <pre data-language="js">concat(...valuesOrIterables: any[]): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.concat">Iterable#concat</a></code><h4>Discussion</h4>
<p>For Seqs, all entries will be present in the resulting iterable, even if they have the same key.</p> <h3 id="map.flatten">Map#flatten()</h3>
<p>Flattens nested Iterables.</p> <pre data-language="js">flatten(depth?: number): Iterable&lt;any, any&gt;
flatten(shallow?: boolean): Iterable&lt;any, any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.flatten">Iterable#flatten</a></code><h4>Discussion</h4>
<p>Will deeply flatten the Iterable by default, returning an Iterable of the same type, but a <code>depth</code> can be provided in the form of a number or boolean (where true means to shallowly flatten one level). A depth of 0 (or shallow: false) will deeply flatten.</p> <p>Flattens only others Iterable, not Arrays or Objects.</p> <p>Note: <code>flatten(true)</code> operates on Iterable<any iterable v="">&gt; and returns Iterable</any></p> <h3 id="map.flatmap">Map#flatMap()</h3>
<p>Flat-maps the Iterable, returning an Iterable of the same type.</p> <pre data-language="js">flatMap&lt;MK, MV&gt;(mapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; Iterable&lt;MK, MV&gt;,context?: any): Iterable&lt;MK, MV&gt;
flatMap&lt;MK, MV&gt;(mapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; any,context?: any): Iterable&lt;MK, MV&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.flatmap">Iterable#flatMap</a></code><h4>Discussion</h4>
<p>Similar to <code>iter.map(...).flatten(true)</code>.</p> <h2>Reducing a value</h2>
<h3 id="map.reduce">Map#reduce()</h3>
<p>Reduces the Iterable to a value by calling the <code>reducer</code> for every entry in the Iterable and passing along the reduced value.</p> <pre data-language="js">reduce&lt;R&gt;(reducer: (reduction?: R, value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; R,initialReduction?: R,context?: any): R
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reduce">Iterable#reduce</a></code><h4>see</h4>
<p><code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">Array#reduce</a></code>.</p> <h4>Discussion</h4>
<p>If <code>initialReduction</code> is not provided, or is null, the first item in the Iterable will be used.</p> <h3 id="map.reduceright">Map#reduceRight()</h3>
<p>Reduces the Iterable in reverse (from the right side).</p> <pre data-language="js">reduceRight&lt;R&gt;(reducer: (reduction?: R, value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; R,initialReduction?: R,context?: any): R
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reduceright">Iterable#reduceRight</a></code><h4>Discussion</h4>
<p>Note: Similar to this.reverse().reduce(), and provided for parity with <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight">Array#reduceRight</a></code>.</p> <h3 id="map.every">Map#every()</h3>
<p>True if <code>predicate</code> returns true for all entries in the Iterable.</p> <pre data-language="js">every(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.every">Iterable#every</a></code><h3 id="map.some">Map#some()</h3>
<p>True if <code>predicate</code> returns true for any entry in the Iterable.</p> <pre data-language="js">some(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.some">Iterable#some</a></code><h3 id="map.join">Map#join()</h3>
<p>Joins values together as a string, inserting a separator between each. The default separator is <code>","</code>.</p> <pre data-language="js">join(separator?: string): string
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.join">Iterable#join</a></code><h3 id="map.isempty">Map#isEmpty()</h3>
<p>Returns true if this Iterable includes no values.</p> <pre data-language="js">isEmpty(): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.isempty">Iterable#isEmpty</a></code><h4>Discussion</h4>
<p>For some lazy <code><a href="#seq">Seq</a></code>, <code>isEmpty</code> might need to iterate to determine emptiness. At most one iteration will occur.</p> <h3 id="map.count">Map#count()</h3>
<p>Returns the size of this Iterable.</p> <pre data-language="js">count(): number
count(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.count">Iterable#count</a></code><h4>Discussion</h4>
<p>Regardless of if this Iterable can describe its size lazily (some Seqs cannot), this method will always return the correct size. E.g. it evaluates a lazy <code><a href="#seq">Seq</a></code> if necessary.</p> <p>If <code>predicate</code> is provided, then this returns the count of entries in the Iterable for which the <code>predicate</code> returns true.</p> <h3 id="map.countby">Map#countBy()</h3>
<p>Returns a <code><a href="#seq.keyed">Seq.Keyed</a></code> of counts, grouped by the return value of the <code>grouper</code> function.</p> <pre data-language="js">countBy&lt;G&gt;(grouper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; G,context?: any): Map&lt;G, number&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.countby">Iterable#countBy</a></code><h4>Discussion</h4>
<p>Note: This is not a lazy operation.</p> <h2>Search for value</h2>
<h3 id="map.find">Map#find()</h3>
<p>Returns the first value for which the <code>predicate</code> returns true.</p> <pre data-language="js">find(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.find">Iterable#find</a></code><h3 id="map.findlast">Map#findLast()</h3>
<p>Returns the last value for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLast(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlast">Iterable#findLast</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="map.findentry">Map#findEntry()</h3>
<p>Returns the first [key, value] entry for which the <code>predicate</code> returns true.</p> <pre data-language="js">findEntry(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): Array&lt;any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findentry">Iterable#findEntry</a></code><h3 id="map.findlastentry">Map#findLastEntry()</h3>
<p>Returns the last [key, value] entry for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLastEntry(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): Array&lt;any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlastentry">Iterable#findLastEntry</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="map.findkey">Map#findKey()</h3>
<p>Returns the key for which the <code>predicate</code> returns true.</p> <pre data-language="js">findKey(predicate: (value?: V, key?: K, iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; boolean,context?: any): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findkey">Iterable#findKey</a></code><h3 id="map.findlastkey">Map#findLastKey()</h3>
<p>Returns the last key for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLastKey(predicate: (value?: V, key?: K, iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; boolean,context?: any): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlastkey">Iterable#findLastKey</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="map.keyof">Map#keyOf()</h3>
<p>Returns the key associated with the search value, or undefined.</p> <pre data-language="js">keyOf(searchValue: V): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyof">Iterable#keyOf</a></code><h3 id="map.lastkeyof">Map#lastKeyOf()</h3>
<p>Returns the last key associated with the search value, or undefined.</p> <pre data-language="js">lastKeyOf(searchValue: V): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.lastkeyof">Iterable#lastKeyOf</a></code><h3 id="map.max">Map#max()</h3>
<p>Returns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> <pre data-language="js">max(comparator?: (valueA: V, valueB: V) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.max">Iterable#max</a></code><h4>Discussion</h4>
<p>The <code>comparator</code> is used in the same way as <code><a href="#iterable.sort">Iterable#sort</a></code>. If it is not provided, the default comparator is <code>&gt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code>max</code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&gt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> <h3 id="map.maxby">Map#maxBy()</h3>
<p>Like <code><a href="#iterable.max">max</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> <pre data-language="js">maxBy&lt;C&gt;(comparatorValueMapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.maxby">Iterable#maxBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.maxBy(hitter =&gt; hitter.avgHits);</pre>
<h3 id="map.min">Map#min()</h3>
<p>Returns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> <pre data-language="js">min(comparator?: (valueA: V, valueB: V) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.min">Iterable#min</a></code><h4>Discussion</h4>
<p>The <code>comparator</code> is used in the same way as <code><a href="#iterable.sort">Iterable#sort</a></code>. If it is not provided, the default comparator is <code>&lt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code>min</code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&lt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> <h3 id="map.minby">Map#minBy()</h3>
<p>Like <code><a href="#iterable.min">min</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> <pre data-language="js">minBy&lt;C&gt;(comparatorValueMapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.minby">Iterable#minBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.minBy(hitter =&gt; hitter.avgHits);</pre>
<h2>Comparison</h2>
<h3 id="map.issubset">Map#isSubset()</h3>
<p>True if <code>iter</code> includes every value in this Iterable.</p> <pre data-language="js">isSubset(iter: Iterable&lt;any, V&gt;): boolean
isSubset(iter: Array&lt;V&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.issubset">Iterable#isSubset</a></code><h3 id="map.issuperset">Map#isSuperset()</h3>
<p>True if this Iterable includes every value in <code>iter</code>.</p> <pre data-language="js">isSuperset(iter: Iterable&lt;any, V&gt;): boolean
isSuperset(iter: Array&lt;V&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.issuperset">Iterable#isSuperset</a></code><h2>Sequence functions</h2>
<h3 id="map.flip">Map#flip()</h3>
<p>Returns a new Iterable.Keyed of the same type where the keys and values have been flipped.</p> <pre data-language="js">flip(): Iterable.Keyed&lt;V, K&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyed.flip">Iterable.Keyed#flip</a></code><h4>Example</h4>
<pre data-language="js">Seq({ a: 'z', b: 'y' }).flip() // { z: 'a', y: 'b' }</pre>
<h3 id="mapkeys">mapKeys()</h3>
<p>Returns a new Iterable.Keyed of the same type with keys passed through a <code>mapper</code> function.</p> <pre data-language="js">mapKeys&lt;M&gt;(mapper: (key?: K, value?: V, iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; M,context?: any): Iterable.Keyed&lt;M, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyed.mapkeys">Iterable.Keyed#mapKeys</a></code><h4>Example</h4>
<pre data-language="js">Seq({ a: 1, b: 2 })
  .mapKeys(x =&gt; x.toUpperCase())
// Seq { A: 1, B: 2 }</pre>
<h3 id="mapentries">mapEntries()</h3>
<p>Returns a new Iterable.Keyed of the same type with entries ([key, value] tuples) passed through a <code>mapper</code> function.</p> <pre data-language="js">mapEntries&lt;KM, VM&gt;(mapper: (entry?: Array&lt;any&gt;,index?: number,iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; Array&lt;any&gt;,context?: any): Iterable.Keyed&lt;KM, VM&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyed.mapentries">Iterable.Keyed#mapEntries</a></code><h4>Example</h4>
<pre data-language="js">Seq({ a: 1, b: 2 })
  .mapEntries(([k, v]) =&gt; [k.toUpperCase(), v * 2])
// Seq { A: 2, B: 4 }</pre>
<h1 id="orderedmap">OrderedMap</h1>
<p>A type of Map that has the additional guarantee that the iteration order of entries will be the order in which they were set().</p> <pre data-language="js">class OrderedMap&lt;K, V&gt; extends Map&lt;K, V&gt;</pre>
<h4>Discussion</h4>
<p>The iteration behavior of OrderedMap is the same as native ES6 Map and JavaScript Object.</p> <p>Note that <code>OrderedMap</code> are more expensive than non-ordered <code><a href="#map">Map</a></code> and may consume more memory. <code><a href="#orderedmap.set">OrderedMap#set</a></code> is amortized O(log32 N), but not stable.</p> <h2>Construction</h2>
<h3 id="orderedmap()">OrderedMap()</h3>
<p>Creates a new Immutable OrderedMap.</p> <pre data-language="js">OrderedMap&lt;K, V&gt;(): OrderedMap&lt;K, V&gt;
OrderedMap&lt;K, V&gt;(iter: Iterable.Keyed&lt;K, V&gt;): OrderedMap&lt;K, V&gt;
OrderedMap&lt;K, V&gt;(iter: Iterable&lt;any, Array&lt;any&gt;&gt;): OrderedMap&lt;K, V&gt;
OrderedMap&lt;K, V&gt;(array: Array&lt;Array&lt;any&gt;&gt;): OrderedMap&lt;K, V&gt;
OrderedMap&lt;V&gt;(obj: {[key: string]: V}): OrderedMap&lt;string, V&gt;
OrderedMap&lt;K, V&gt;(iterator: Iterator&lt;Array&lt;any&gt;&gt;): OrderedMap&lt;K, V&gt;
OrderedMap&lt;K, V&gt;(iterable: Object): OrderedMap&lt;K, V&gt;
</pre>
<h4>Discussion</h4>
<p>Created with the same key value pairs as the provided Iterable.Keyed or JavaScript Object or expects an Iterable of [K, V] tuple entries.</p> <p>The iteration order of key-value pairs provided to this constructor will be preserved in the OrderedMap.</p> <pre data-language="js">var newOrderedMap = OrderedMap({key: "value"});
var newOrderedMap = OrderedMap([["key", "value"]]);</pre>
<h2>Static methods</h2>
<h3 id="orderedmap.isorderedmap">OrderedMap.isOrderedMap()</h3>
<p>True if the provided value is an OrderedMap.</p> <pre data-language="js">OrderedMap.isOrderedMap(maybeOrderedMap: any): boolean
</pre>
<h2>Members</h2>
<h3 id="orderedmap.size">OrderedMap#size</h3>
<pre data-language="js">size: number</pre>
<h4>Inherited from</h4>
<code><a href="#collection.size">Collection#size</a></code><h2>Persistent changes</h2>
<h3 id="orderedmap.set">OrderedMap#set()</h3>
<p>Returns a new Map also containing the new key, value pair. If an equivalent key already exists in this Map, it will be replaced.</p> <pre data-language="js">set(key: K, value: V): Map&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#map.set">Map#set</a></code><h3 id="orderedmap.delete">OrderedMap#delete()</h3>
<p>Returns a new Map which excludes this <code>key</code>.</p> <pre data-language="js">delete(key: K): Map&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#map.delete">Map#delete</a></code><h4>alias</h4>
<code>remove()</code><h4>Discussion</h4>
<p>Note: <code>delete</code> cannot be safely used in IE8, but is provided to mirror the ES6 collection API.</p> <h3 id="orderedmap.clear">OrderedMap#clear()</h3>
<p>Returns a new Map containing no keys or values.</p> <pre data-language="js">clear(): Map&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#map.clear">Map#clear</a></code><h3 id="orderedmap.update">OrderedMap#update()</h3>
<p>Returns a new Map having updated the value at this <code>key</code> with the return value of calling <code>updater</code> with the existing value, or <code>notSetValue</code> if the key was not set. If called with only a single argument, <code>updater</code> is called with the Map itself.</p> <pre data-language="js">update(updater: (value: Map&lt;K, V&gt;) =&gt; Map&lt;K, V&gt;): Map&lt;K, V&gt;
update(key: K, updater: (value: V) =&gt; V): Map&lt;K, V&gt;
update(key: K, notSetValue: V, updater: (value: V) =&gt; V): Map&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#map.update">Map#update</a></code><h4>Discussion</h4>
<p>Equivalent to: <code>map.set(key, updater(map.get(key, notSetValue)))</code>.</p> <h3 id="orderedmap.merge">OrderedMap#merge()</h3>
<p>Returns a new Map resulting from merging the provided Iterables (or JS objects) into this Map. In other words, this takes each entry of each iterable and sets it on this Map.</p> <pre data-language="js">merge(...iterables: Iterable&lt;K, V&gt;[]): Map&lt;K, V&gt;
merge(...iterables: {[key: string]: V}[]): Map&lt;string, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#map.merge">Map#merge</a></code><h4>Discussion</h4>
<p>If any of the values provided to <code>merge</code> are not Iterable (would return false for <code>Immutable.Iterable.isIterable</code>) then they are deeply converted via <code><a href="#fromjs">Immutable.fromJS</a></code> before being merged. However, if the value is an Iterable but includes non-iterable JS objects or arrays, those nested values will be preserved.</p> <pre data-language="js">var x = Immutable.Map({a: 10, b: 20, c: 30});
var y = Immutable.Map({b: 40, a: 50, d: 60});
x.merge(y) // { a: 50, b: 40, c: 30, d: 60 }
y.merge(x) // { b: 20, a: 10, d: 60, c: 30 }</pre>
<h3 id="orderedmap.mergewith">OrderedMap#mergeWith()</h3>
<p>Like <code><a href="#map.merge">merge()</a></code>, <code>mergeWith()</code> returns a new Map resulting from merging the provided Iterables (or JS objects) into this Map, but uses the <code>merger</code> function for dealing with conflicts.</p> <pre data-language="js">mergeWith(merger: (previous?: V, next?: V, key?: K) =&gt; V,...iterables: Iterable&lt;K, V&gt;[]): Map&lt;K, V&gt;
mergeWith(merger: (previous?: V, next?: V, key?: K) =&gt; V,...iterables: {[key: string]: V}[]): Map&lt;string, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#map.mergewith">Map#mergeWith</a></code><h4>Example</h4>
<pre data-language="js">var x = Immutable.Map({a: 10, b: 20, c: 30});
var y = Immutable.Map({b: 40, a: 50, d: 60});
x.mergeWith((prev, next) =&gt; prev / next, y) // { a: 0.2, b: 0.5, c: 30, d: 60 }
y.mergeWith((prev, next) =&gt; prev / next, x) // { b: 2, a: 5, d: 60, c: 30 }</pre>
<h3 id="orderedmap.mergedeep">OrderedMap#mergeDeep()</h3>
<p>Like <code><a href="#map.merge">merge()</a></code>, but when two Iterables conflict, it merges them as well, recursing deeply through the nested data.</p> <pre data-language="js">mergeDeep(...iterables: Iterable&lt;K, V&gt;[]): Map&lt;K, V&gt;
mergeDeep(...iterables: {[key: string]: V}[]): Map&lt;string, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#map.mergedeep">Map#mergeDeep</a></code><h4>Example</h4>
<pre data-language="js">var x = Immutable.fromJS({a: { x: 10, y: 10 }, b: { x: 20, y: 50 } });
var y = Immutable.fromJS({a: { x: 2 }, b: { y: 5 }, c: { z: 3 } });
x.mergeDeep(y) // {a: { x: 2, y: 10 }, b: { x: 20, y: 5 }, c: { z: 3 } }</pre>
<h3 id="orderedmap.mergedeepwith">OrderedMap#mergeDeepWith()</h3>
<p>Like <code><a href="#map.mergedeep">mergeDeep()</a></code>, but when two non-Iterables conflict, it uses the <code>merger</code> function to determine the resulting value.</p> <pre data-language="js">mergeDeepWith(merger: (previous?: V, next?: V, key?: K) =&gt; V,...iterables: Iterable&lt;K, V&gt;[]): Map&lt;K, V&gt;
mergeDeepWith(merger: (previous?: V, next?: V, key?: K) =&gt; V,...iterables: {[key: string]: V}[]): Map&lt;string, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#map.mergedeepwith">Map#mergeDeepWith</a></code><h4>Example</h4>
<pre data-language="js">var x = Immutable.fromJS({a: { x: 10, y: 10 }, b: { x: 20, y: 50 } });
var y = Immutable.fromJS({a: { x: 2 }, b: { y: 5 }, c: { z: 3 } });
x.mergeDeepWith((prev, next) =&gt; prev / next, y)
// {a: { x: 5, y: 10 }, b: { x: 20, y: 10 }, c: { z: 3 } }</pre>
<h2>Deep persistent changes</h2>
<h3 id="orderedmap.setin">OrderedMap#setIn()</h3>
<p>Returns a new Map having set <code>value</code> at this <code>keyPath</code>. If any keys in <code>keyPath</code> do not exist, a new immutable Map will be created at that key.</p> <pre data-language="js">setIn(keyPath: Array&lt;any&gt;, value: any): Map&lt;K, V&gt;
setIn(KeyPath: Iterable&lt;any, any&gt;, value: any): Map&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#map.setin">Map#setIn</a></code><h3 id="orderedmap.deletein">OrderedMap#deleteIn()</h3>
<p>Returns a new Map having removed the value at this <code>keyPath</code>. If any keys in <code>keyPath</code> do not exist, no change will occur.</p> <pre data-language="js">deleteIn(keyPath: Array&lt;any&gt;): Map&lt;K, V&gt;
deleteIn(keyPath: Iterable&lt;any, any&gt;): Map&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#map.deletein">Map#deleteIn</a></code><h4>alias</h4>
<code>removeIn()</code><h3 id="orderedmap.updatein">OrderedMap#updateIn()</h3>
<p>Returns a new Map having applied the <code>updater</code> to the entry found at the keyPath.</p> <pre data-language="js">updateIn(keyPath: Array&lt;any&gt;, updater: (value: any) =&gt; any): Map&lt;K, V&gt;
updateIn(keyPath: Array&lt;any&gt;,notSetValue: any,updater: (value: any) =&gt; any): Map&lt;K, V&gt;
updateIn(keyPath: Iterable&lt;any, any&gt;, updater: (value: any) =&gt; any): Map&lt;K, V&gt;
updateIn(keyPath: Iterable&lt;any, any&gt;,notSetValue: any,updater: (value: any) =&gt; any): Map&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#map.updatein">Map#updateIn</a></code><h4>Discussion</h4>
<p>If any keys in <code>keyPath</code> do not exist, new Immutable <code>Map</code>s will be created at those keys. If the <code>keyPath</code> does not already contain a value, the <code>updater</code> function will be called with <code>notSetValue</code>, if provided, otherwise <code>undefined</code>.</p> <pre data-language="js">var data = Immutable.fromJS({ a: { b: { c: 10 } } });
data = data.updateIn(['a', 'b', 'c'], val =&gt; val * 2);
// { a: { b: { c: 20 } } }</pre>
<p>If the <code>updater</code> function returns the same value it was called with, then no change will occur. This is still true if <code>notSetValue</code> is provided.</p> <pre data-language="js">var data1 = Immutable.fromJS({ a: { b: { c: 10 } } });
data2 = data1.updateIn(['x', 'y', 'z'], 100, val =&gt; val);
assert(data2 === data1);</pre>
<h3 id="orderedmap.mergein">OrderedMap#mergeIn()</h3>
<p>A combination of <code><a href="#map.updatein">updateIn</a></code> and <code><a href="#map.merge">merge</a></code>, returning a new Map, but performing the merge at a point arrived at by following the keyPath. In other words, these two lines are equivalent:</p> <pre data-language="js">mergeIn(keyPath: Iterable&lt;any, any&gt;, ...iterables: Iterable&lt;K, V&gt;[]): Map&lt;K, V&gt;
mergeIn(keyPath: Array&lt;any&gt;, ...iterables: Iterable&lt;K, V&gt;[]): Map&lt;K, V&gt;
mergeIn(keyPath: Array&lt;any&gt;, ...iterables: {[key: string]: V}[]): Map&lt;string, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#map.mergein">Map#mergeIn</a></code><h4>Example</h4>
<pre data-language="js">x.updateIn(['a', 'b', 'c'], abc =&gt; abc.merge(y));
x.mergeIn(['a', 'b', 'c'], y);</pre>
<h3 id="orderedmap.mergedeepin">OrderedMap#mergeDeepIn()</h3>
<p>A combination of <code><a href="#map.updatein">updateIn</a></code> and <code><a href="#map.mergedeep">mergeDeep</a></code>, returning a new Map, but performing the deep merge at a point arrived at by following the keyPath. In other words, these two lines are equivalent:</p> <pre data-language="js">mergeDeepIn(keyPath: Iterable&lt;any, any&gt;,...iterables: Iterable&lt;K, V&gt;[]): Map&lt;K, V&gt;
mergeDeepIn(keyPath: Array&lt;any&gt;, ...iterables: Iterable&lt;K, V&gt;[]): Map&lt;K, V&gt;
mergeDeepIn(keyPath: Array&lt;any&gt;,...iterables: {[key: string]: V}[]): Map&lt;string, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#map.mergedeepin">Map#mergeDeepIn</a></code><h4>Example</h4>
<pre data-language="js">x.updateIn(['a', 'b', 'c'], abc =&gt; abc.mergeDeep(y));
x.mergeDeepIn(['a', 'b', 'c'], y);</pre>
<h2>Transient changes</h2>
<h3 id="orderedmap.withmutations">OrderedMap#withMutations()</h3>
<p>Every time you call one of the above functions, a new immutable Map is created. If a pure function calls a number of these to produce a final return value, then a penalty on performance and memory has been paid by creating all of the intermediate immutable Maps.</p> <pre data-language="js">withMutations(mutator: (mutable: Map&lt;K, V&gt;) =&gt; any): Map&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#map.withmutations">Map#withMutations</a></code><h4>Discussion</h4>
<p>If you need to apply a series of mutations to produce a new immutable Map, <code>withMutations()</code> creates a temporary mutable copy of the Map which can apply mutations in a highly performant manner. In fact, this is exactly how complex mutations like <code><a href="#map.merge">merge</a></code> are done.</p> <p>As an example, this results in the creation of 2, not 4, new Maps:</p> <pre data-language="js">var map1 = Immutable.Map();
var map2 = map1.withMutations(map =&gt; {
  map.set('a', 1).set('b', 2).set('c', 3);
});
assert(map1.size === 0);
assert(map2.size === 3);</pre>
<p>Note: Not all methods can be used on a mutable collection or within <code>withMutations</code>! Only <code><a href="#map.set">set</a></code> and <code><a href="#map.merge">merge</a></code> may be used mutatively.</p> <h3 id="orderedmap.asmutable">OrderedMap#asMutable()</h3>
<p>Another way to avoid creation of intermediate Immutable maps is to create a mutable copy of this collection. Mutable copies <em>always</em> return <code>this</code>, and thus shouldn't be used for equality. Your function should never return a mutable copy of a collection, only use it internally to create a new collection. If possible, use <code><a href="#map.withmutations">withMutations</a></code> as it provides an easier to use API.</p> <pre data-language="js">asMutable(): Map&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#map.asmutable">Map#asMutable</a></code><h4>Discussion</h4>
<p>Note: if the collection is already mutable, <code>asMutable</code> returns itself.</p> <p>Note: Not all methods can be used on a mutable collection or within <code><a href="#map.withmutations">withMutations</a></code>! Only <code><a href="#map.set">set</a></code> and <code><a href="#map.merge">merge</a></code> may be used mutatively.</p> <h3 id="orderedmap.asimmutable">OrderedMap#asImmutable()</h3>
<p>The yin to <code><a href="#map.asmutable">asMutable</a></code>'s yang. Because it applies to mutable collections, this operation is <em>mutable</em> and returns itself. Once performed, the mutable copy has become immutable and can be safely returned from a function.</p> <pre data-language="js">asImmutable(): Map&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#map.asimmutable">Map#asImmutable</a></code><h2>Conversion to Seq</h2>
<h3 id="orderedmap.toseq">OrderedMap#toSeq()</h3>
<p>Returns Seq.Keyed.</p> <pre data-language="js">toSeq(): Seq.Keyed&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#collection.keyed.toseq">Collection.Keyed#toSeq</a></code><h3 id="orderedmap.tokeyedseq">OrderedMap#toKeyedSeq()</h3>
<p>Returns a Seq.Keyed from this Iterable where indices are treated as keys.</p> <pre data-language="js">toKeyedSeq(): Seq.Keyed&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tokeyedseq">Iterable#toKeyedSeq</a></code><h4>Discussion</h4>
<p>This is useful if you want to operate on an Iterable.Indexed and preserve the [index, value] pairs.</p> <p>The returned Seq will have identical iteration order as this Iterable.</p> <p>Example:</p> <pre data-language="js">var indexedSeq = Immutable.Seq.of('A', 'B', 'C');
indexedSeq.filter(v =&gt; v === 'B').toString() // Seq [ 'B' ]
var keyedSeq = indexedSeq.toKeyedSeq();
keyedSeq.filter(v =&gt; v === 'B').toString() // Seq { 1: 'B' }</pre>
<h3 id="orderedmap.toindexedseq">OrderedMap#toIndexedSeq()</h3>
<p>Returns an Seq.Indexed of the values of this Iterable, discarding keys.</p> <pre data-language="js">toIndexedSeq(): Seq.Indexed&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toindexedseq">Iterable#toIndexedSeq</a></code><h3 id="orderedmap.tosetseq">OrderedMap#toSetSeq()</h3>
<p>Returns a Seq.Set of the values of this Iterable, discarding keys.</p> <pre data-language="js">toSetSeq(): Seq.Set&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tosetseq">Iterable#toSetSeq</a></code><h2>Value equality</h2>
<h3 id="orderedmap.equals">OrderedMap#equals()</h3>
<p>True if this and the other Iterable have value equality, as defined by <code><a href="#is">Immutable.is()</a></code>.</p> <pre data-language="js">equals(other: Iterable&lt;K, V&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.equals">Iterable#equals</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Immutable.is(this, other)</code>, but provided to allow for chained expressions.</p> <h3 id="orderedmap.hashcode">OrderedMap#hashCode()</h3>
<p>Computes and returns the hashed identity for this Iterable.</p> <pre data-language="js">hashCode(): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.hashcode">Iterable#hashCode</a></code><h4>Discussion</h4>
<p>The <code>hashCode</code> of an Iterable is used to determine potential equality, and is used when adding this to a <code><a href="#iterable.set">Set</a></code> or as a key in a <code><a href="#map">Map</a></code>, enabling lookup via a different instance.</p> <pre data-language="js">var a = List.of(1, 2, 3);
var b = List.of(1, 2, 3);
assert(a !== b); // different instances
var set = Set.of(a);
assert(set.has(b) === true);</pre>
<p>If two values have the same <code>hashCode</code>, they are <a href="http://en.wikipedia.org/wiki/Collision_(computer_science)">not guaranteed to be equal</a>. If two values have different <code>hashCode</code>s, they must not be equal.</p> <h2>Reading values</h2>
<h3 id="orderedmap.get">OrderedMap#get()</h3>
<p>Returns the value associated with the provided key, or notSetValue if the Iterable does not contain this key.</p> <pre data-language="js">get(key: K, notSetValue?: V): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.get">Iterable#get</a></code><h4>Discussion</h4>
<p>Note: it is possible a key may be associated with an <code>undefined</code> value, so if <code>notSetValue</code> is not provided and this method returns <code>undefined</code>, that does not guarantee the key was not found.</p> <h3 id="orderedmap.has">OrderedMap#has()</h3>
<p>True if a key exists within this <code>Iterable</code>, using <code><a href="#is">Immutable.is</a></code> to determine equality</p> <pre data-language="js">has(key: K): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.has">Iterable#has</a></code><h3 id="orderedmap.includes">OrderedMap#includes()</h3>
<p>True if a value exists within this <code>Iterable</code>, using <code><a href="#is">Immutable.is</a></code> to determine equality</p> <pre data-language="js">includes(value: V): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.includes">Iterable#includes</a></code><h4>alias</h4>
<code>contains()</code><h3 id="orderedmap.first">OrderedMap#first()</h3>
<p>The first value in the Iterable.</p> <pre data-language="js">first(): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.first">Iterable#first</a></code><h3 id="orderedmap.last">OrderedMap#last()</h3>
<p>The last value in the Iterable.</p> <pre data-language="js">last(): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.last">Iterable#last</a></code><h2>Reading deep values</h2>
<h3 id="orderedmap.getin">OrderedMap#getIn()</h3>
<p>Returns the value found by following a path of keys or indices through nested Iterables.</p> <pre data-language="js">getIn(searchKeyPath: Array&lt;any&gt;, notSetValue?: any): any
getIn(searchKeyPath: Iterable&lt;any, any&gt;, notSetValue?: any): any
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.getin">Iterable#getIn</a></code><h3 id="orderedmap.hasin">OrderedMap#hasIn()</h3>
<p>True if the result of following a path of keys or indices through nested Iterables results in a set value.</p> <pre data-language="js">hasIn(searchKeyPath: Array&lt;any&gt;): boolean
hasIn(searchKeyPath: Iterable&lt;any, any&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.hasin">Iterable#hasIn</a></code><h2>Conversion to JavaScript types</h2>
<h3 id="orderedmap.tojs">OrderedMap#toJS()</h3>
<p>Deeply converts this Iterable to equivalent JS.</p> <pre data-language="js">toJS(): any
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tojs">Iterable#toJS</a></code><h4>alias</h4>
<code>toJSON()</code><h4>Discussion</h4>
<p><code>Iterable.Indexeds</code>, and <code>Iterable.Sets</code> become Arrays, while <code>Iterable.Keyeds</code> become Objects.</p> <h3 id="orderedmap.toarray">OrderedMap#toArray()</h3>
<p>Shallowly converts this iterable to an Array, discarding keys.</p> <pre data-language="js">toArray(): Array&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toarray">Iterable#toArray</a></code><h3 id="orderedmap.toobject">OrderedMap#toObject()</h3>
<p>Shallowly converts this Iterable to an Object.</p> <pre data-language="js">toObject(): {[key: string]: V}
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toobject">Iterable#toObject</a></code><h4>Discussion</h4>
<p>Throws if keys are not strings.</p> <h2>Conversion to Collections</h2>
<h3 id="orderedmap.tomap">OrderedMap#toMap()</h3>
<p>Converts this Iterable to a Map, Throws if keys are not hashable.</p> <pre data-language="js">toMap(): Map&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tomap">Iterable#toMap</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Map(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="orderedmap.toorderedmap">OrderedMap#toOrderedMap()</h3>
<p>Converts this Iterable to a Map, maintaining the order of iteration.</p> <pre data-language="js">toOrderedMap(): OrderedMap&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toorderedmap">Iterable#toOrderedMap</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>OrderedMap(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="orderedmap.toset">OrderedMap#toSet()</h3>
<p>Converts this Iterable to a Set, discarding keys. Throws if values are not hashable.</p> <pre data-language="js">toSet(): Set&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toset">Iterable#toSet</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Set(this)</code>, but provided to allow for chained expressions.</p> <h3 id="orderedmap.toorderedset">OrderedMap#toOrderedSet()</h3>
<p>Converts this Iterable to a Set, maintaining the order of iteration and discarding keys.</p> <pre data-language="js">toOrderedSet(): OrderedSet&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toorderedset">Iterable#toOrderedSet</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>OrderedSet(this.valueSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="orderedmap.tolist">OrderedMap#toList()</h3>
<p>Converts this Iterable to a List, discarding keys.</p> <pre data-language="js">toList(): List&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tolist">Iterable#toList</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>List(this)</code>, but provided to allow for chained expressions.</p> <h3 id="orderedmap.tostack">OrderedMap#toStack()</h3>
<p>Converts this Iterable to a Stack, discarding keys. Throws if values are not hashable.</p> <pre data-language="js">toStack(): Stack&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tostack">Iterable#toStack</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Stack(this)</code>, but provided to allow for chained expressions.</p> <h2>Iterators</h2>
<h3 id="orderedmap.keys">OrderedMap#keys()</h3>
<p>An iterator of this <code>Iterable</code>'s keys.</p> <pre data-language="js">keys(): Iterator&lt;K&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keys">Iterable#keys</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.keyseq">keySeq</a></code> instead, if this is what you want.</p> <h3 id="orderedmap.values">OrderedMap#values()</h3>
<p>An iterator of this <code>Iterable</code>'s values.</p> <pre data-language="js">values(): Iterator&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.values">Iterable#values</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.valueseq">valueSeq</a></code> instead, if this is what you want.</p> <h3 id="orderedmap.entries">OrderedMap#entries()</h3>
<p>An iterator of this <code>Iterable</code>'s entries as <code>[key, value]</code> tuples.</p> <pre data-language="js">entries(): Iterator&lt;Array&lt;any&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.entries">Iterable#entries</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.entryseq">entrySeq</a></code> instead, if this is what you want.</p> <h2>Iterables (Seq)</h2>
<h3 id="orderedmap.keyseq">OrderedMap#keySeq()</h3>
<p>Returns a new Seq.Indexed of the keys of this Iterable, discarding values.</p> <pre data-language="js">keySeq(): Seq.Indexed&lt;K&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyseq">Iterable#keySeq</a></code><h3 id="orderedmap.valueseq">OrderedMap#valueSeq()</h3>
<p>Returns an Seq.Indexed of the values of this Iterable, discarding keys.</p> <pre data-language="js">valueSeq(): Seq.Indexed&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.valueseq">Iterable#valueSeq</a></code><h3 id="orderedmap.entryseq">OrderedMap#entrySeq()</h3>
<p>Returns a new Seq.Indexed of [key, value] tuples.</p> <pre data-language="js">entrySeq(): Seq.Indexed&lt;Array&lt;any&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.entryseq">Iterable#entrySeq</a></code><h2>Sequence algorithms</h2>
<h3 id="orderedmap.map">OrderedMap#map()</h3>
<p>Returns a new Iterable of the same type with values passed through a <code>mapper</code> function.</p> <pre data-language="js">map&lt;M&gt;(mapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; M,context?: any): Iterable&lt;K, M&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.map">Iterable#map</a></code><h4>Example</h4>
<pre data-language="js">Seq({ a: 1, b: 2 }).map(x =&gt; 10 * x)
// Seq { a: 10, b: 20 }</pre>
<h3 id="orderedmap.filter">OrderedMap#filter()</h3>
<p>Returns a new Iterable of the same type with only the entries for which the <code>predicate</code> function returns true.</p> <pre data-language="js">filter(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.filter">Iterable#filter</a></code><h4>Example</h4>
<pre data-language="js">Seq({a:1,b:2,c:3,d:4}).filter(x =&gt; x % 2 === 0)
// Seq { b: 2, d: 4 }</pre>
<h3 id="orderedmap.filternot">OrderedMap#filterNot()</h3>
<p>Returns a new Iterable of the same type with only the entries for which the <code>predicate</code> function returns false.</p> <pre data-language="js">filterNot(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.filternot">Iterable#filterNot</a></code><h4>Example</h4>
<pre data-language="js">Seq({a:1,b:2,c:3,d:4}).filterNot(x =&gt; x % 2 === 0)
// Seq { a: 1, c: 3 }</pre>
<h3 id="orderedmap.reverse">OrderedMap#reverse()</h3>
<p>Returns a new Iterable of the same type in reverse order.</p> <pre data-language="js">reverse(): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reverse">Iterable#reverse</a></code><h3 id="orderedmap.sort">OrderedMap#sort()</h3>
<p>Returns a new Iterable of the same type which includes the same entries, stably sorted by using a <code>comparator</code>.</p> <pre data-language="js">sort(comparator?: (valueA: V, valueB: V) =&gt; number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.sort">Iterable#sort</a></code><h4>Discussion</h4>
<p>If a <code>comparator</code> is not provided, a default comparator uses <code>&lt;</code> and <code>&gt;</code>.</p> <p><code>comparator(valueA, valueB)</code>:</p> <ul> <li>Returns <code>0</code> if the elements should not be swapped.</li> <li>Returns <code>-1</code> (or any negative number) if <code>valueA</code> comes before <code>valueB</code>
</li> <li>Returns <code>1</code> (or any positive number) if <code>valueA</code> comes after <code>valueB</code>
</li> <li>Is pure, i.e. it must always return the same value for the same pair of values.</li> </ul> <p>When sorting collections which have no defined order, their ordered equivalents will be returned. e.g. <code>map.sort()</code> returns OrderedMap.</p> <h3 id="orderedmap.sortby">OrderedMap#sortBy()</h3>
<p>Like <code><a href="#iterable.sort">sort</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for sorting by more sophisticated means:</p> <pre data-language="js">sortBy&lt;C&gt;(comparatorValueMapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.sortby">Iterable#sortBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.sortBy(hitter =&gt; hitter.avgHits);</pre>
<h3 id="orderedmap.groupby">OrderedMap#groupBy()</h3>
<p>Returns a <code><a href="#iterable.keyed">Iterable.Keyed</a></code> of <code>Iterable.Keyeds</code>, grouped by the return value of the <code>grouper</code> function.</p> <pre data-language="js">groupBy&lt;G&gt;(grouper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; G,context?: any): Seq.Keyed&lt;G, Iterable&lt;K, V&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.groupby">Iterable#groupBy</a></code><h4>Discussion</h4>
<p>Note: This is always an eager operation.</p> <h2>Side effects</h2>
<h3 id="orderedmap.foreach">OrderedMap#forEach()</h3>
<p>The <code>sideEffect</code> is executed for every entry in the Iterable.</p> <pre data-language="js">forEach(sideEffect: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; any,context?: any): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.foreach">Iterable#forEach</a></code><h4>Discussion</h4>
<p>Unlike <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">Array#forEach</a></code>, if any call of <code>sideEffect</code> returns <code>false</code>, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).</p> <h2>Creating subsets</h2>
<h3 id="orderedmap.slice">OrderedMap#slice()</h3>
<p>Returns a new Iterable of the same type representing a portion of this Iterable from start up to but not including end.</p> <pre data-language="js">slice(begin?: number, end?: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.slice">Iterable#slice</a></code><h4>Discussion</h4>
<p>If begin is negative, it is offset from the end of the Iterable. e.g. <code>slice(-2)</code> returns a Iterable of the last two entries. If it is not provided the new Iterable will begin at the beginning of this Iterable.</p> <p>If end is negative, it is offset from the end of the Iterable. e.g. <code>slice(0, -1)</code> returns an Iterable of everything but the last entry. If it is not provided, the new Iterable will continue through the end of this Iterable.</p> <p>If the requested slice is equivalent to the current Iterable, then it will return itself.</p> <h3 id="orderedmap.rest">OrderedMap#rest()</h3>
<p>Returns a new Iterable of the same type containing all entries except the first.</p> <pre data-language="js">rest(): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.rest">Iterable#rest</a></code><h3 id="orderedmap.butlast">OrderedMap#butLast()</h3>
<p>Returns a new Iterable of the same type containing all entries except the last.</p> <pre data-language="js">butLast(): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.butlast">Iterable#butLast</a></code><h3 id="orderedmap.skip">OrderedMap#skip()</h3>
<p>Returns a new Iterable of the same type which excludes the first <code>amount</code> entries from this Iterable.</p> <pre data-language="js">skip(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skip">Iterable#skip</a></code><h3 id="orderedmap.skiplast">OrderedMap#skipLast()</h3>
<p>Returns a new Iterable of the same type which excludes the last <code>amount</code> entries from this Iterable.</p> <pre data-language="js">skipLast(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skiplast">Iterable#skipLast</a></code><h3 id="orderedmap.skipwhile">OrderedMap#skipWhile()</h3>
<p>Returns a new Iterable of the same type which includes entries starting from when <code>predicate</code> first returns false.</p> <pre data-language="js">skipWhile(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skipwhile">Iterable#skipWhile</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .skipWhile(x =&gt; x.match(/g/))
// Seq [ 'cat', 'hat', 'god' ]</pre>
<h3 id="orderedmap.skipuntil">OrderedMap#skipUntil()</h3>
<p>Returns a new Iterable of the same type which includes entries starting from when <code>predicate</code> first returns true.</p> <pre data-language="js">skipUntil(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skipuntil">Iterable#skipUntil</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .skipUntil(x =&gt; x.match(/hat/))
// Seq [ 'hat', 'god' ]</pre>
<h3 id="orderedmap.take">OrderedMap#take()</h3>
<p>Returns a new Iterable of the same type which includes the first <code>amount</code> entries from this Iterable.</p> <pre data-language="js">take(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.take">Iterable#take</a></code><h3 id="orderedmap.takelast">OrderedMap#takeLast()</h3>
<p>Returns a new Iterable of the same type which includes the last <code>amount</code> entries from this Iterable.</p> <pre data-language="js">takeLast(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takelast">Iterable#takeLast</a></code><h3 id="orderedmap.takewhile">OrderedMap#takeWhile()</h3>
<p>Returns a new Iterable of the same type which includes entries from this Iterable as long as the <code>predicate</code> returns true.</p> <pre data-language="js">takeWhile(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takewhile">Iterable#takeWhile</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .takeWhile(x =&gt; x.match(/o/))
// Seq [ 'dog', 'frog' ]</pre>
<h3 id="orderedmap.takeuntil">OrderedMap#takeUntil()</h3>
<p>Returns a new Iterable of the same type which includes entries from this Iterable as long as the <code>predicate</code> returns false.</p> <pre data-language="js">takeUntil(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takeuntil">Iterable#takeUntil</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god').takeUntil(x =&gt; x.match(/at/))
// ['dog', 'frog']</pre>
<h2>Combination</h2>
<h3 id="orderedmap.concat">OrderedMap#concat()</h3>
<p>Returns a new Iterable of the same type with other values and iterable-like concatenated to this one.</p> <pre data-language="js">concat(...valuesOrIterables: any[]): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.concat">Iterable#concat</a></code><h4>Discussion</h4>
<p>For Seqs, all entries will be present in the resulting iterable, even if they have the same key.</p> <h3 id="orderedmap.flatten">OrderedMap#flatten()</h3>
<p>Flattens nested Iterables.</p> <pre data-language="js">flatten(depth?: number): Iterable&lt;any, any&gt;
flatten(shallow?: boolean): Iterable&lt;any, any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.flatten">Iterable#flatten</a></code><h4>Discussion</h4>
<p>Will deeply flatten the Iterable by default, returning an Iterable of the same type, but a <code>depth</code> can be provided in the form of a number or boolean (where true means to shallowly flatten one level). A depth of 0 (or shallow: false) will deeply flatten.</p> <p>Flattens only others Iterable, not Arrays or Objects.</p> <p>Note: <code>flatten(true)</code> operates on Iterable<any iterable v="">&gt; and returns Iterable</any></p> <h3 id="orderedmap.flatmap">OrderedMap#flatMap()</h3>
<p>Flat-maps the Iterable, returning an Iterable of the same type.</p> <pre data-language="js">flatMap&lt;MK, MV&gt;(mapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; Iterable&lt;MK, MV&gt;,context?: any): Iterable&lt;MK, MV&gt;
flatMap&lt;MK, MV&gt;(mapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; any,context?: any): Iterable&lt;MK, MV&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.flatmap">Iterable#flatMap</a></code><h4>Discussion</h4>
<p>Similar to <code>iter.map(...).flatten(true)</code>.</p> <h2>Reducing a value</h2>
<h3 id="orderedmap.reduce">OrderedMap#reduce()</h3>
<p>Reduces the Iterable to a value by calling the <code>reducer</code> for every entry in the Iterable and passing along the reduced value.</p> <pre data-language="js">reduce&lt;R&gt;(reducer: (reduction?: R, value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; R,initialReduction?: R,context?: any): R
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reduce">Iterable#reduce</a></code><h4>see</h4>
<p><code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">Array#reduce</a></code>.</p> <h4>Discussion</h4>
<p>If <code>initialReduction</code> is not provided, or is null, the first item in the Iterable will be used.</p> <h3 id="orderedmap.reduceright">OrderedMap#reduceRight()</h3>
<p>Reduces the Iterable in reverse (from the right side).</p> <pre data-language="js">reduceRight&lt;R&gt;(reducer: (reduction?: R, value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; R,initialReduction?: R,context?: any): R
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reduceright">Iterable#reduceRight</a></code><h4>Discussion</h4>
<p>Note: Similar to this.reverse().reduce(), and provided for parity with <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight">Array#reduceRight</a></code>.</p> <h3 id="orderedmap.every">OrderedMap#every()</h3>
<p>True if <code>predicate</code> returns true for all entries in the Iterable.</p> <pre data-language="js">every(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.every">Iterable#every</a></code><h3 id="orderedmap.some">OrderedMap#some()</h3>
<p>True if <code>predicate</code> returns true for any entry in the Iterable.</p> <pre data-language="js">some(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.some">Iterable#some</a></code><h3 id="orderedmap.join">OrderedMap#join()</h3>
<p>Joins values together as a string, inserting a separator between each. The default separator is <code>","</code>.</p> <pre data-language="js">join(separator?: string): string
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.join">Iterable#join</a></code><h3 id="orderedmap.isempty">OrderedMap#isEmpty()</h3>
<p>Returns true if this Iterable includes no values.</p> <pre data-language="js">isEmpty(): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.isempty">Iterable#isEmpty</a></code><h4>Discussion</h4>
<p>For some lazy <code><a href="#seq">Seq</a></code>, <code>isEmpty</code> might need to iterate to determine emptiness. At most one iteration will occur.</p> <h3 id="orderedmap.count">OrderedMap#count()</h3>
<p>Returns the size of this Iterable.</p> <pre data-language="js">count(): number
count(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.count">Iterable#count</a></code><h4>Discussion</h4>
<p>Regardless of if this Iterable can describe its size lazily (some Seqs cannot), this method will always return the correct size. E.g. it evaluates a lazy <code><a href="#seq">Seq</a></code> if necessary.</p> <p>If <code>predicate</code> is provided, then this returns the count of entries in the Iterable for which the <code>predicate</code> returns true.</p> <h3 id="orderedmap.countby">OrderedMap#countBy()</h3>
<p>Returns a <code><a href="#seq.keyed">Seq.Keyed</a></code> of counts, grouped by the return value of the <code>grouper</code> function.</p> <pre data-language="js">countBy&lt;G&gt;(grouper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; G,context?: any): Map&lt;G, number&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.countby">Iterable#countBy</a></code><h4>Discussion</h4>
<p>Note: This is not a lazy operation.</p> <h2>Search for value</h2>
<h3 id="orderedmap.find">OrderedMap#find()</h3>
<p>Returns the first value for which the <code>predicate</code> returns true.</p> <pre data-language="js">find(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.find">Iterable#find</a></code><h3 id="orderedmap.findlast">OrderedMap#findLast()</h3>
<p>Returns the last value for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLast(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlast">Iterable#findLast</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="orderedmap.findentry">OrderedMap#findEntry()</h3>
<p>Returns the first [key, value] entry for which the <code>predicate</code> returns true.</p> <pre data-language="js">findEntry(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): Array&lt;any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findentry">Iterable#findEntry</a></code><h3 id="orderedmap.findlastentry">OrderedMap#findLastEntry()</h3>
<p>Returns the last [key, value] entry for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLastEntry(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): Array&lt;any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlastentry">Iterable#findLastEntry</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="orderedmap.findkey">OrderedMap#findKey()</h3>
<p>Returns the key for which the <code>predicate</code> returns true.</p> <pre data-language="js">findKey(predicate: (value?: V, key?: K, iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; boolean,context?: any): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findkey">Iterable#findKey</a></code><h3 id="orderedmap.findlastkey">OrderedMap#findLastKey()</h3>
<p>Returns the last key for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLastKey(predicate: (value?: V, key?: K, iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; boolean,context?: any): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlastkey">Iterable#findLastKey</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="orderedmap.keyof">OrderedMap#keyOf()</h3>
<p>Returns the key associated with the search value, or undefined.</p> <pre data-language="js">keyOf(searchValue: V): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyof">Iterable#keyOf</a></code><h3 id="orderedmap.lastkeyof">OrderedMap#lastKeyOf()</h3>
<p>Returns the last key associated with the search value, or undefined.</p> <pre data-language="js">lastKeyOf(searchValue: V): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.lastkeyof">Iterable#lastKeyOf</a></code><h3 id="orderedmap.max">OrderedMap#max()</h3>
<p>Returns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> <pre data-language="js">max(comparator?: (valueA: V, valueB: V) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.max">Iterable#max</a></code><h4>Discussion</h4>
<p>The <code>comparator</code> is used in the same way as <code><a href="#iterable.sort">Iterable#sort</a></code>. If it is not provided, the default comparator is <code>&gt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code>max</code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&gt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> <h3 id="orderedmap.maxby">OrderedMap#maxBy()</h3>
<p>Like <code><a href="#iterable.max">max</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> <pre data-language="js">maxBy&lt;C&gt;(comparatorValueMapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.maxby">Iterable#maxBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.maxBy(hitter =&gt; hitter.avgHits);</pre>
<h3 id="orderedmap.min">OrderedMap#min()</h3>
<p>Returns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> <pre data-language="js">min(comparator?: (valueA: V, valueB: V) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.min">Iterable#min</a></code><h4>Discussion</h4>
<p>The <code>comparator</code> is used in the same way as <code><a href="#iterable.sort">Iterable#sort</a></code>. If it is not provided, the default comparator is <code>&lt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code>min</code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&lt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> <h3 id="orderedmap.minby">OrderedMap#minBy()</h3>
<p>Like <code><a href="#iterable.min">min</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> <pre data-language="js">minBy&lt;C&gt;(comparatorValueMapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.minby">Iterable#minBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.minBy(hitter =&gt; hitter.avgHits);</pre>
<h2>Comparison</h2>
<h3 id="orderedmap.issubset">OrderedMap#isSubset()</h3>
<p>True if <code>iter</code> includes every value in this Iterable.</p> <pre data-language="js">isSubset(iter: Iterable&lt;any, V&gt;): boolean
isSubset(iter: Array&lt;V&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.issubset">Iterable#isSubset</a></code><h3 id="orderedmap.issuperset">OrderedMap#isSuperset()</h3>
<p>True if this Iterable includes every value in <code>iter</code>.</p> <pre data-language="js">isSuperset(iter: Iterable&lt;any, V&gt;): boolean
isSuperset(iter: Array&lt;V&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.issuperset">Iterable#isSuperset</a></code><h2>Sequence functions</h2>
<h3 id="orderedmap.flip">OrderedMap#flip()</h3>
<p>Returns a new Iterable.Keyed of the same type where the keys and values have been flipped.</p> <pre data-language="js">flip(): Iterable.Keyed&lt;V, K&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyed.flip">Iterable.Keyed#flip</a></code><h4>Example</h4>
<pre data-language="js">Seq({ a: 'z', b: 'y' }).flip() // { z: 'a', y: 'b' }</pre>
<h3 id="orderedmap.mapkeys">OrderedMap#mapKeys()</h3>
<p>Returns a new Iterable.Keyed of the same type with keys passed through a <code>mapper</code> function.</p> <pre data-language="js">mapKeys&lt;M&gt;(mapper: (key?: K, value?: V, iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; M,context?: any): Iterable.Keyed&lt;M, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyed.mapkeys">Iterable.Keyed#mapKeys</a></code><h4>Example</h4>
<pre data-language="js">Seq({ a: 1, b: 2 })
  .mapKeys(x =&gt; x.toUpperCase())
// Seq { A: 1, B: 2 }</pre>
<h3 id="orderedmap.mapentries">OrderedMap#mapEntries()</h3>
<p>Returns a new Iterable.Keyed of the same type with entries ([key, value] tuples) passed through a <code>mapper</code> function.</p> <pre data-language="js">mapEntries&lt;KM, VM&gt;(mapper: (entry?: Array&lt;any&gt;,index?: number,iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; Array&lt;any&gt;,context?: any): Iterable.Keyed&lt;KM, VM&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyed.mapentries">Iterable.Keyed#mapEntries</a></code><h4>Example</h4>
<pre data-language="js">Seq({ a: 1, b: 2 })
  .mapEntries(([k, v]) =&gt; [k.toUpperCase(), v * 2])
// Seq { A: 2, B: 4 }</pre>
<h1 id="set">Set</h1>
<p>A Collection of unique values with <code>O(log32 N)</code> adds and has.</p> <pre data-language="js">class Set&lt;T&gt; extends Collection.Set&lt;T&gt;</pre>
<h4>Discussion</h4>
<p>When iterating a Set, the entries will be (value, value) pairs. Iteration order of a Set is undefined, however is stable. Multiple iterations of the same Set will iterate in the same order.</p> <p>Set values, like Map keys, may be of any type. Equality is determined using <code><a href="#is">Immutable.is</a></code>, enabling Sets to uniquely include other Immutable collections, custom value types, and NaN.</p> <h2>Construction</h2>
<h3 id="set()">Set()</h3>
<p>Create a new immutable Set containing the values of the provided iterable-like.</p> <pre data-language="js">Set&lt;T&gt;(): Set&lt;T&gt;
Set&lt;T&gt;(iter: Iterable.Set&lt;T&gt;): Set&lt;T&gt;
Set&lt;T&gt;(iter: Iterable.Indexed&lt;T&gt;): Set&lt;T&gt;
Set&lt;K, V&gt;(iter: Iterable.Keyed&lt;K, V&gt;): Set&lt;any&gt;
Set&lt;T&gt;(array: Array&lt;T&gt;): Set&lt;T&gt;
Set&lt;T&gt;(iterator: Iterator&lt;T&gt;): Set&lt;T&gt;
Set&lt;T&gt;(iterable: Object): Set&lt;T&gt;
</pre>
<h2>Static methods</h2>
<h3 id="set.isset">Set.isSet()</h3>
<p>True if the provided value is a Set</p> <pre data-language="js">Set.isSet(maybeSet: any): boolean
</pre>
<h3 id="set.of">Set.of()</h3>
<p>Creates a new Set containing <code>values</code>.</p> <pre data-language="js">Set.of&lt;T&gt;(...values: T[]): Set&lt;T&gt;
</pre>
<h3 id="set.fromkeys">Set.fromKeys()</h3>
<p><code>Set.fromKeys()</code> creates a new immutable Set containing the keys from this Iterable or JavaScript Object.</p> <pre data-language="js">Set.fromKeys&lt;T&gt;(iter: Iterable&lt;T, any&gt;): Set&lt;T&gt;
Set.fromKeys(obj: {[key: string]: any}): Set&lt;string&gt;
</pre>
<h2>Members</h2>
<h3 id="set.size">Set#size</h3>
<pre data-language="js">size: number</pre>
<h4>Inherited from</h4>
<code><a href="#collection.size">Collection#size</a></code><h2>Persistent changes</h2>
<h3 id="set.add">Set#add()</h3>
<p>Returns a new Set which also includes this value.</p> <pre data-language="js">add(value: T): Set&lt;T&gt;
</pre>
<h3 id="set.delete">Set#delete()</h3>
<p>Returns a new Set which excludes this value.</p> <pre data-language="js">delete(value: T): Set&lt;T&gt;
</pre>
<h4>alias</h4>
<code>remove()</code><h4>Discussion</h4>
<p>Note: <code>delete</code> cannot be safely used in IE8</p> <h3 id="set.clear">Set#clear()</h3>
<p>Returns a new Set containing no values.</p> <pre data-language="js">clear(): Set&lt;T&gt;
</pre>
<h3 id="set.union">Set#union()</h3>
<p>Returns a Set including any value from <code>iterables</code> that does not already exist in this Set.</p> <pre data-language="js">union(...iterables: Iterable&lt;any, T&gt;[]): Set&lt;T&gt;
union(...iterables: Array&lt;T&gt;[]): Set&lt;T&gt;
</pre>
<h4>alias</h4>
<code>merge()</code><h3 id="set.intersect">Set#intersect()</h3>
<p>Returns a Set which has removed any values not also contained within <code>iterables</code>.</p> <pre data-language="js">intersect(...iterables: Iterable&lt;any, T&gt;[]): Set&lt;T&gt;
intersect(...iterables: Array&lt;T&gt;[]): Set&lt;T&gt;
</pre>
<h3 id="set.subtract">Set#subtract()</h3>
<p>Returns a Set excluding any values contained within <code>iterables</code>.</p> <pre data-language="js">subtract(...iterables: Iterable&lt;any, T&gt;[]): Set&lt;T&gt;
subtract(...iterables: Array&lt;T&gt;[]): Set&lt;T&gt;
</pre>
<h2>Transient changes</h2>
<h3 id="set.withmutations">Set#withMutations()</h3>
<p>Note: Not all methods can be used on a mutable collection or within <code>withMutations</code>! Only <code><a href="#set.add">add</a></code> may be used mutatively.</p> <pre data-language="js">withMutations(mutator: (mutable: Set&lt;T&gt;) =&gt; any): Set&lt;T&gt;
</pre>
<h4>see</h4>
<p><code><a href="#map.withmutations">Map#withMutations</a></code></p> <h3 id="set.asmutable">Set#asMutable()</h3>
<pre data-language="js">asMutable(): Set&lt;T&gt;
</pre>
<h4>see</h4>
<p><code><a href="#map.asmutable">Map#asMutable</a></code></p> <h3 id="set.asimmutable">Set#asImmutable()</h3>
<pre data-language="js">asImmutable(): Set&lt;T&gt;
</pre>
<h4>see</h4>
<p><code><a href="#map.asimmutable">Map#asImmutable</a></code></p> <h2>Conversion to Seq</h2>
<h3 id="set.toseq">Set#toSeq()</h3>
<p>Returns Seq.Set.</p> <pre data-language="js">toSeq(): Seq.Set&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#collection.set.toseq">Collection.Set#toSeq</a></code><h3 id="set.tokeyedseq">Set#toKeyedSeq()</h3>
<p>Returns a Seq.Keyed from this Iterable where indices are treated as keys.</p> <pre data-language="js">toKeyedSeq(): Seq.Keyed&lt;T, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tokeyedseq">Iterable#toKeyedSeq</a></code><h4>Discussion</h4>
<p>This is useful if you want to operate on an Iterable.Indexed and preserve the [index, value] pairs.</p> <p>The returned Seq will have identical iteration order as this Iterable.</p> <p>Example:</p> <pre data-language="js">var indexedSeq = Immutable.Seq.of('A', 'B', 'C');
indexedSeq.filter(v =&gt; v === 'B').toString() // Seq [ 'B' ]
var keyedSeq = indexedSeq.toKeyedSeq();
keyedSeq.filter(v =&gt; v === 'B').toString() // Seq { 1: 'B' }</pre>
<h3 id="set.toindexedseq">Set#toIndexedSeq()</h3>
<p>Returns an Seq.Indexed of the values of this Iterable, discarding keys.</p> <pre data-language="js">toIndexedSeq(): Seq.Indexed&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toindexedseq">Iterable#toIndexedSeq</a></code><h3 id="set.tosetseq">Set#toSetSeq()</h3>
<p>Returns a Seq.Set of the values of this Iterable, discarding keys.</p> <pre data-language="js">toSetSeq(): Seq.Set&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tosetseq">Iterable#toSetSeq</a></code><h2>Value equality</h2>
<h3 id="set.equals">Set#equals()</h3>
<p>True if this and the other Iterable have value equality, as defined by <code><a href="#is">Immutable.is()</a></code>.</p> <pre data-language="js">equals(other: Iterable&lt;T, T&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.equals">Iterable#equals</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Immutable.is(this, other)</code>, but provided to allow for chained expressions.</p> <h3 id="set.hashcode">Set#hashCode()</h3>
<p>Computes and returns the hashed identity for this Iterable.</p> <pre data-language="js">hashCode(): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.hashcode">Iterable#hashCode</a></code><h4>Discussion</h4>
<p>The <code>hashCode</code> of an Iterable is used to determine potential equality, and is used when adding this to a <code><a href="#iterable.set">Set</a></code> or as a key in a <code><a href="#map">Map</a></code>, enabling lookup via a different instance.</p> <pre data-language="js">var a = List.of(1, 2, 3);
var b = List.of(1, 2, 3);
assert(a !== b); // different instances
var set = Set.of(a);
assert(set.has(b) === true);</pre>
<p>If two values have the same <code>hashCode</code>, they are <a href="http://en.wikipedia.org/wiki/Collision_(computer_science)">not guaranteed to be equal</a>. If two values have different <code>hashCode</code>s, they must not be equal.</p> <h2>Reading values</h2>
<h3 id="set.get">Set#get()</h3>
<p>Returns the value associated with the provided key, or notSetValue if the Iterable does not contain this key.</p> <pre data-language="js">get(key: T, notSetValue?: T): T
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.get">Iterable#get</a></code><h4>Discussion</h4>
<p>Note: it is possible a key may be associated with an <code>undefined</code> value, so if <code>notSetValue</code> is not provided and this method returns <code>undefined</code>, that does not guarantee the key was not found.</p> <h3 id="set.has">Set#has()</h3>
<p>True if a key exists within this <code>Iterable</code>, using <code><a href="#is">Immutable.is</a></code> to determine equality</p> <pre data-language="js">has(key: T): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.has">Iterable#has</a></code><h3 id="set.includes">Set#includes()</h3>
<p>True if a value exists within this <code>Iterable</code>, using <code><a href="#is">Immutable.is</a></code> to determine equality</p> <pre data-language="js">includes(value: T): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.includes">Iterable#includes</a></code><h4>alias</h4>
<code>contains()</code><h3 id="set.first">Set#first()</h3>
<p>The first value in the Iterable.</p> <pre data-language="js">first(): T
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.first">Iterable#first</a></code><h3 id="set.last">Set#last()</h3>
<p>The last value in the Iterable.</p> <pre data-language="js">last(): T
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.last">Iterable#last</a></code><h2>Reading deep values</h2>
<h3 id="set.getin">Set#getIn()</h3>
<p>Returns the value found by following a path of keys or indices through nested Iterables.</p> <pre data-language="js">getIn(searchKeyPath: Array&lt;any&gt;, notSetValue?: any): any
getIn(searchKeyPath: Iterable&lt;any, any&gt;, notSetValue?: any): any
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.getin">Iterable#getIn</a></code><h3 id="set.hasin">Set#hasIn()</h3>
<p>True if the result of following a path of keys or indices through nested Iterables results in a set value.</p> <pre data-language="js">hasIn(searchKeyPath: Array&lt;any&gt;): boolean
hasIn(searchKeyPath: Iterable&lt;any, any&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.hasin">Iterable#hasIn</a></code><h2>Conversion to JavaScript types</h2>
<h3 id="set.tojs">Set#toJS()</h3>
<p>Deeply converts this Iterable to equivalent JS.</p> <pre data-language="js">toJS(): any
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tojs">Iterable#toJS</a></code><h4>alias</h4>
<code>toJSON()</code><h4>Discussion</h4>
<p><code>Iterable.Indexeds</code>, and <code>Iterable.Sets</code> become Arrays, while <code>Iterable.Keyeds</code> become Objects.</p> <h3 id="set.toarray">Set#toArray()</h3>
<p>Shallowly converts this iterable to an Array, discarding keys.</p> <pre data-language="js">toArray(): Array&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toarray">Iterable#toArray</a></code><h3 id="set.toobject">Set#toObject()</h3>
<p>Shallowly converts this Iterable to an Object.</p> <pre data-language="js">toObject(): {[key: string]: V}
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toobject">Iterable#toObject</a></code><h4>Discussion</h4>
<p>Throws if keys are not strings.</p> <h2>Conversion to Collections</h2>
<h3 id="set.tomap">Set#toMap()</h3>
<p>Converts this Iterable to a Map, Throws if keys are not hashable.</p> <pre data-language="js">toMap(): Map&lt;T, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tomap">Iterable#toMap</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Map(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="set.toorderedmap">Set#toOrderedMap()</h3>
<p>Converts this Iterable to a Map, maintaining the order of iteration.</p> <pre data-language="js">toOrderedMap(): OrderedMap&lt;T, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toorderedmap">Iterable#toOrderedMap</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>OrderedMap(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="set.toset">Set#toSet()</h3>
<p>Converts this Iterable to a Set, discarding keys. Throws if values are not hashable.</p> <pre data-language="js">toSet(): Set&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toset">Iterable#toSet</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Set(this)</code>, but provided to allow for chained expressions.</p> <h3 id="set.toorderedset">Set#toOrderedSet()</h3>
<p>Converts this Iterable to a Set, maintaining the order of iteration and discarding keys.</p> <pre data-language="js">toOrderedSet(): OrderedSet&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toorderedset">Iterable#toOrderedSet</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>OrderedSet(this.valueSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="set.tolist">Set#toList()</h3>
<p>Converts this Iterable to a List, discarding keys.</p> <pre data-language="js">toList(): List&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tolist">Iterable#toList</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>List(this)</code>, but provided to allow for chained expressions.</p> <h3 id="set.tostack">Set#toStack()</h3>
<p>Converts this Iterable to a Stack, discarding keys. Throws if values are not hashable.</p> <pre data-language="js">toStack(): Stack&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tostack">Iterable#toStack</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Stack(this)</code>, but provided to allow for chained expressions.</p> <h2>Iterators</h2>
<h3 id="set.keys">Set#keys()</h3>
<p>An iterator of this <code>Iterable</code>'s keys.</p> <pre data-language="js">keys(): Iterator&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keys">Iterable#keys</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.keyseq">keySeq</a></code> instead, if this is what you want.</p> <h3 id="set.values">Set#values()</h3>
<p>An iterator of this <code>Iterable</code>'s values.</p> <pre data-language="js">values(): Iterator&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.values">Iterable#values</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.valueseq">valueSeq</a></code> instead, if this is what you want.</p> <h3 id="set.entries">Set#entries()</h3>
<p>An iterator of this <code>Iterable</code>'s entries as <code>[key, value]</code> tuples.</p> <pre data-language="js">entries(): Iterator&lt;Array&lt;any&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.entries">Iterable#entries</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.entryseq">entrySeq</a></code> instead, if this is what you want.</p> <h2>Iterables (Seq)</h2>
<h3 id="set.keyseq">Set#keySeq()</h3>
<p>Returns a new Seq.Indexed of the keys of this Iterable, discarding values.</p> <pre data-language="js">keySeq(): Seq.Indexed&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyseq">Iterable#keySeq</a></code><h3 id="set.valueseq">Set#valueSeq()</h3>
<p>Returns an Seq.Indexed of the values of this Iterable, discarding keys.</p> <pre data-language="js">valueSeq(): Seq.Indexed&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.valueseq">Iterable#valueSeq</a></code><h3 id="set.entryseq">Set#entrySeq()</h3>
<p>Returns a new Seq.Indexed of [key, value] tuples.</p> <pre data-language="js">entrySeq(): Seq.Indexed&lt;Array&lt;any&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.entryseq">Iterable#entrySeq</a></code><h2>Sequence algorithms</h2>
<h3 id="set.map">Set#map()</h3>
<p>Returns a new Iterable of the same type with values passed through a <code>mapper</code> function.</p> <pre data-language="js">map&lt;M&gt;(mapper: (value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; M,context?: any): Iterable&lt;T, M&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.map">Iterable#map</a></code><h4>Example</h4>
<pre data-language="js">Seq({ a: 1, b: 2 }).map(x =&gt; 10 * x)
// Seq { a: 10, b: 20 }</pre>
<h3 id="set.filter">Set#filter()</h3>
<p>Returns a new Iterable of the same type with only the entries for which the <code>predicate</code> function returns true.</p> <pre data-language="js">filter(predicate: (value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; boolean,context?: any): Iterable&lt;T, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.filter">Iterable#filter</a></code><h4>Example</h4>
<pre data-language="js">Seq({a:1,b:2,c:3,d:4}).filter(x =&gt; x % 2 === 0)
// Seq { b: 2, d: 4 }</pre>
<h3 id="set.filternot">Set#filterNot()</h3>
<p>Returns a new Iterable of the same type with only the entries for which the <code>predicate</code> function returns false.</p> <pre data-language="js">filterNot(predicate: (value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; boolean,context?: any): Iterable&lt;T, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.filternot">Iterable#filterNot</a></code><h4>Example</h4>
<pre data-language="js">Seq({a:1,b:2,c:3,d:4}).filterNot(x =&gt; x % 2 === 0)
// Seq { a: 1, c: 3 }</pre>
<h3 id="set.reverse">Set#reverse()</h3>
<p>Returns a new Iterable of the same type in reverse order.</p> <pre data-language="js">reverse(): Iterable&lt;T, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reverse">Iterable#reverse</a></code><h3 id="set.sort">Set#sort()</h3>
<p>Returns a new Iterable of the same type which includes the same entries, stably sorted by using a <code>comparator</code>.</p> <pre data-language="js">sort(comparator?: (valueA: T, valueB: T) =&gt; number): Iterable&lt;T, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.sort">Iterable#sort</a></code><h4>Discussion</h4>
<p>If a <code>comparator</code> is not provided, a default comparator uses <code>&lt;</code> and <code>&gt;</code>.</p> <p><code>comparator(valueA, valueB)</code>:</p> <ul> <li>Returns <code>0</code> if the elements should not be swapped.</li> <li>Returns <code>-1</code> (or any negative number) if <code>valueA</code> comes before <code>valueB</code>
</li> <li>Returns <code>1</code> (or any positive number) if <code>valueA</code> comes after <code>valueB</code>
</li> <li>Is pure, i.e. it must always return the same value for the same pair of values.</li> </ul> <p>When sorting collections which have no defined order, their ordered equivalents will be returned. e.g. <code>map.sort()</code> returns OrderedMap.</p> <h3 id="set.sortby">Set#sortBy()</h3>
<p>Like <code><a href="#iterable.sort">sort</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for sorting by more sophisticated means:</p> <pre data-language="js">sortBy&lt;C&gt;(comparatorValueMapper: (value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): Iterable&lt;T, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.sortby">Iterable#sortBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.sortBy(hitter =&gt; hitter.avgHits);</pre>
<h3 id="set.groupby">Set#groupBy()</h3>
<p>Returns a <code><a href="#iterable.keyed">Iterable.Keyed</a></code> of <code>Iterable.Keyeds</code>, grouped by the return value of the <code>grouper</code> function.</p> <pre data-language="js">groupBy&lt;G&gt;(grouper: (value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; G,context?: any): Seq.Keyed&lt;G, Iterable&lt;T, T&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.groupby">Iterable#groupBy</a></code><h4>Discussion</h4>
<p>Note: This is always an eager operation.</p> <h2>Side effects</h2>
<h3 id="set.foreach">Set#forEach()</h3>
<p>The <code>sideEffect</code> is executed for every entry in the Iterable.</p> <pre data-language="js">forEach(sideEffect: (value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; any,context?: any): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.foreach">Iterable#forEach</a></code><h4>Discussion</h4>
<p>Unlike <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">Array#forEach</a></code>, if any call of <code>sideEffect</code> returns <code>false</code>, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).</p> <h2>Creating subsets</h2>
<h3 id="set.slice">Set#slice()</h3>
<p>Returns a new Iterable of the same type representing a portion of this Iterable from start up to but not including end.</p> <pre data-language="js">slice(begin?: number, end?: number): Iterable&lt;T, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.slice">Iterable#slice</a></code><h4>Discussion</h4>
<p>If begin is negative, it is offset from the end of the Iterable. e.g. <code>slice(-2)</code> returns a Iterable of the last two entries. If it is not provided the new Iterable will begin at the beginning of this Iterable.</p> <p>If end is negative, it is offset from the end of the Iterable. e.g. <code>slice(0, -1)</code> returns an Iterable of everything but the last entry. If it is not provided, the new Iterable will continue through the end of this Iterable.</p> <p>If the requested slice is equivalent to the current Iterable, then it will return itself.</p> <h3 id="set.rest">Set#rest()</h3>
<p>Returns a new Iterable of the same type containing all entries except the first.</p> <pre data-language="js">rest(): Iterable&lt;T, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.rest">Iterable#rest</a></code><h3 id="set.butlast">Set#butLast()</h3>
<p>Returns a new Iterable of the same type containing all entries except the last.</p> <pre data-language="js">butLast(): Iterable&lt;T, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.butlast">Iterable#butLast</a></code><h3 id="set.skip">Set#skip()</h3>
<p>Returns a new Iterable of the same type which excludes the first <code>amount</code> entries from this Iterable.</p> <pre data-language="js">skip(amount: number): Iterable&lt;T, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skip">Iterable#skip</a></code><h3 id="set.skiplast">Set#skipLast()</h3>
<p>Returns a new Iterable of the same type which excludes the last <code>amount</code> entries from this Iterable.</p> <pre data-language="js">skipLast(amount: number): Iterable&lt;T, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skiplast">Iterable#skipLast</a></code><h3 id="set.skipwhile">Set#skipWhile()</h3>
<p>Returns a new Iterable of the same type which includes entries starting from when <code>predicate</code> first returns false.</p> <pre data-language="js">skipWhile(predicate: (value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; boolean,context?: any): Iterable&lt;T, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skipwhile">Iterable#skipWhile</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .skipWhile(x =&gt; x.match(/g/))
// Seq [ 'cat', 'hat', 'god' ]</pre>
<h3 id="set.skipuntil">Set#skipUntil()</h3>
<p>Returns a new Iterable of the same type which includes entries starting from when <code>predicate</code> first returns true.</p> <pre data-language="js">skipUntil(predicate: (value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; boolean,context?: any): Iterable&lt;T, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skipuntil">Iterable#skipUntil</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .skipUntil(x =&gt; x.match(/hat/))
// Seq [ 'hat', 'god' ]</pre>
<h3 id="set.take">Set#take()</h3>
<p>Returns a new Iterable of the same type which includes the first <code>amount</code> entries from this Iterable.</p> <pre data-language="js">take(amount: number): Iterable&lt;T, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.take">Iterable#take</a></code><h3 id="set.takelast">Set#takeLast()</h3>
<p>Returns a new Iterable of the same type which includes the last <code>amount</code> entries from this Iterable.</p> <pre data-language="js">takeLast(amount: number): Iterable&lt;T, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takelast">Iterable#takeLast</a></code><h3 id="set.takewhile">Set#takeWhile()</h3>
<p>Returns a new Iterable of the same type which includes entries from this Iterable as long as the <code>predicate</code> returns true.</p> <pre data-language="js">takeWhile(predicate: (value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; boolean,context?: any): Iterable&lt;T, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takewhile">Iterable#takeWhile</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .takeWhile(x =&gt; x.match(/o/))
// Seq [ 'dog', 'frog' ]</pre>
<h3 id="set.takeuntil">Set#takeUntil()</h3>
<p>Returns a new Iterable of the same type which includes entries from this Iterable as long as the <code>predicate</code> returns false.</p> <pre data-language="js">takeUntil(predicate: (value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; boolean,context?: any): Iterable&lt;T, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takeuntil">Iterable#takeUntil</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god').takeUntil(x =&gt; x.match(/at/))
// ['dog', 'frog']</pre>
<h2>Combination</h2>
<h3 id="set.concat">Set#concat()</h3>
<p>Returns a new Iterable of the same type with other values and iterable-like concatenated to this one.</p> <pre data-language="js">concat(...valuesOrIterables: any[]): Iterable&lt;T, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.concat">Iterable#concat</a></code><h4>Discussion</h4>
<p>For Seqs, all entries will be present in the resulting iterable, even if they have the same key.</p> <h3 id="set.flatten">Set#flatten()</h3>
<p>Flattens nested Iterables.</p> <pre data-language="js">flatten(depth?: number): Iterable&lt;any, any&gt;
flatten(shallow?: boolean): Iterable&lt;any, any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.flatten">Iterable#flatten</a></code><h4>Discussion</h4>
<p>Will deeply flatten the Iterable by default, returning an Iterable of the same type, but a <code>depth</code> can be provided in the form of a number or boolean (where true means to shallowly flatten one level). A depth of 0 (or shallow: false) will deeply flatten.</p> <p>Flattens only others Iterable, not Arrays or Objects.</p> <p>Note: <code>flatten(true)</code> operates on Iterable<any iterable v="">&gt; and returns Iterable</any></p> <h3 id="set.flatmap">Set#flatMap()</h3>
<p>Flat-maps the Iterable, returning an Iterable of the same type.</p> <pre data-language="js">flatMap&lt;MK, MV&gt;(mapper: (value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; Iterable&lt;MK, MV&gt;,context?: any): Iterable&lt;MK, MV&gt;
flatMap&lt;MK, MV&gt;(mapper: (value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; any,context?: any): Iterable&lt;MK, MV&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.flatmap">Iterable#flatMap</a></code><h4>Discussion</h4>
<p>Similar to <code>iter.map(...).flatten(true)</code>.</p> <h2>Reducing a value</h2>
<h3 id="set.reduce">Set#reduce()</h3>
<p>Reduces the Iterable to a value by calling the <code>reducer</code> for every entry in the Iterable and passing along the reduced value.</p> <pre data-language="js">reduce&lt;R&gt;(reducer: (reduction?: R, value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; R,initialReduction?: R,context?: any): R
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reduce">Iterable#reduce</a></code><h4>see</h4>
<p><code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">Array#reduce</a></code>.</p> <h4>Discussion</h4>
<p>If <code>initialReduction</code> is not provided, or is null, the first item in the Iterable will be used.</p> <h3 id="set.reduceright">Set#reduceRight()</h3>
<p>Reduces the Iterable in reverse (from the right side).</p> <pre data-language="js">reduceRight&lt;R&gt;(reducer: (reduction?: R, value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; R,initialReduction?: R,context?: any): R
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reduceright">Iterable#reduceRight</a></code><h4>Discussion</h4>
<p>Note: Similar to this.reverse().reduce(), and provided for parity with <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight">Array#reduceRight</a></code>.</p> <h3 id="set.every">Set#every()</h3>
<p>True if <code>predicate</code> returns true for all entries in the Iterable.</p> <pre data-language="js">every(predicate: (value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; boolean,context?: any): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.every">Iterable#every</a></code><h3 id="set.some">Set#some()</h3>
<p>True if <code>predicate</code> returns true for any entry in the Iterable.</p> <pre data-language="js">some(predicate: (value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; boolean,context?: any): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.some">Iterable#some</a></code><h3 id="set.join">Set#join()</h3>
<p>Joins values together as a string, inserting a separator between each. The default separator is <code>","</code>.</p> <pre data-language="js">join(separator?: string): string
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.join">Iterable#join</a></code><h3 id="set.isempty">Set#isEmpty()</h3>
<p>Returns true if this Iterable includes no values.</p> <pre data-language="js">isEmpty(): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.isempty">Iterable#isEmpty</a></code><h4>Discussion</h4>
<p>For some lazy <code><a href="#seq">Seq</a></code>, <code>isEmpty</code> might need to iterate to determine emptiness. At most one iteration will occur.</p> <h3 id="set.count">Set#count()</h3>
<p>Returns the size of this Iterable.</p> <pre data-language="js">count(): number
count(predicate: (value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; boolean,context?: any): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.count">Iterable#count</a></code><h4>Discussion</h4>
<p>Regardless of if this Iterable can describe its size lazily (some Seqs cannot), this method will always return the correct size. E.g. it evaluates a lazy <code><a href="#seq">Seq</a></code> if necessary.</p> <p>If <code>predicate</code> is provided, then this returns the count of entries in the Iterable for which the <code>predicate</code> returns true.</p> <h3 id="set.countby">Set#countBy()</h3>
<p>Returns a <code><a href="#seq.keyed">Seq.Keyed</a></code> of counts, grouped by the return value of the <code>grouper</code> function.</p> <pre data-language="js">countBy&lt;G&gt;(grouper: (value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; G,context?: any): Map&lt;G, number&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.countby">Iterable#countBy</a></code><h4>Discussion</h4>
<p>Note: This is not a lazy operation.</p> <h2>Search for value</h2>
<h3 id="set.find">Set#find()</h3>
<p>Returns the first value for which the <code>predicate</code> returns true.</p> <pre data-language="js">find(predicate: (value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; boolean,context?: any,notSetValue?: T): T
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.find">Iterable#find</a></code><h3 id="set.findlast">Set#findLast()</h3>
<p>Returns the last value for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLast(predicate: (value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; boolean,context?: any,notSetValue?: T): T
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlast">Iterable#findLast</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="set.findentry">Set#findEntry()</h3>
<p>Returns the first [key, value] entry for which the <code>predicate</code> returns true.</p> <pre data-language="js">findEntry(predicate: (value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; boolean,context?: any,notSetValue?: T): Array&lt;any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findentry">Iterable#findEntry</a></code><h3 id="set.findlastentry">Set#findLastEntry()</h3>
<p>Returns the last [key, value] entry for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLastEntry(predicate: (value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; boolean,context?: any,notSetValue?: T): Array&lt;any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlastentry">Iterable#findLastEntry</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="set.findkey">Set#findKey()</h3>
<p>Returns the key for which the <code>predicate</code> returns true.</p> <pre data-language="js">findKey(predicate: (value?: T, key?: T, iter?: Iterable.Keyed&lt;T, T&gt;) =&gt; boolean,context?: any): T
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findkey">Iterable#findKey</a></code><h3 id="set.findlastkey">Set#findLastKey()</h3>
<p>Returns the last key for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLastKey(predicate: (value?: T, key?: T, iter?: Iterable.Keyed&lt;T, T&gt;) =&gt; boolean,context?: any): T
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlastkey">Iterable#findLastKey</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="set.keyof">Set#keyOf()</h3>
<p>Returns the key associated with the search value, or undefined.</p> <pre data-language="js">keyOf(searchValue: T): T
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyof">Iterable#keyOf</a></code><h3 id="set.lastkeyof">Set#lastKeyOf()</h3>
<p>Returns the last key associated with the search value, or undefined.</p> <pre data-language="js">lastKeyOf(searchValue: T): T
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.lastkeyof">Iterable#lastKeyOf</a></code><h3 id="set.max">Set#max()</h3>
<p>Returns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> <pre data-language="js">max(comparator?: (valueA: T, valueB: T) =&gt; number): T
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.max">Iterable#max</a></code><h4>Discussion</h4>
<p>The <code>comparator</code> is used in the same way as <code><a href="#iterable.sort">Iterable#sort</a></code>. If it is not provided, the default comparator is <code>&gt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code>max</code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&gt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> <h3 id="set.maxby">Set#maxBy()</h3>
<p>Like <code><a href="#iterable.max">max</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> <pre data-language="js">maxBy&lt;C&gt;(comparatorValueMapper: (value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): T
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.maxby">Iterable#maxBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.maxBy(hitter =&gt; hitter.avgHits);</pre>
<h3 id="set.min">Set#min()</h3>
<p>Returns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> <pre data-language="js">min(comparator?: (valueA: T, valueB: T) =&gt; number): T
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.min">Iterable#min</a></code><h4>Discussion</h4>
<p>The <code>comparator</code> is used in the same way as <code><a href="#iterable.sort">Iterable#sort</a></code>. If it is not provided, the default comparator is <code>&lt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code>min</code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&lt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> <h3 id="set.minby">Set#minBy()</h3>
<p>Like <code><a href="#iterable.min">min</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> <pre data-language="js">minBy&lt;C&gt;(comparatorValueMapper: (value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): T
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.minby">Iterable#minBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.minBy(hitter =&gt; hitter.avgHits);</pre>
<h2>Comparison</h2>
<h3 id="set.issubset">Set#isSubset()</h3>
<p>True if <code>iter</code> includes every value in this Iterable.</p> <pre data-language="js">isSubset(iter: Iterable&lt;any, T&gt;): boolean
isSubset(iter: Array&lt;T&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.issubset">Iterable#isSubset</a></code><h3 id="set.issuperset">Set#isSuperset()</h3>
<p>True if this Iterable includes every value in <code>iter</code>.</p> <pre data-language="js">isSuperset(iter: Iterable&lt;any, T&gt;): boolean
isSuperset(iter: Array&lt;T&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.issuperset">Iterable#isSuperset</a></code><h1 id="orderedset">OrderedSet</h1>
<p>A type of Set that has the additional guarantee that the iteration order of values will be the order in which they were <code><a href="#orderedset.add">add</a></code>ed.</p> <pre data-language="js">class OrderedSet&lt;T&gt; extends Set&lt;T&gt;</pre>
<h4>Discussion</h4>
<p>The iteration behavior of OrderedSet is the same as native ES6 Set.</p> <p>Note that <code>OrderedSet</code> are more expensive than non-ordered <code><a href="#set">Set</a></code> and may consume more memory. <code><a href="#orderedset.add">OrderedSet#add</a></code> is amortized O(log32 N), but not stable.</p> <h2>Construction</h2>
<h3 id="orderedset()">OrderedSet()</h3>
<p>Create a new immutable OrderedSet containing the values of the provided iterable-like.</p> <pre data-language="js">OrderedSet&lt;T&gt;(): OrderedSet&lt;T&gt;
OrderedSet&lt;T&gt;(iter: Iterable.Set&lt;T&gt;): OrderedSet&lt;T&gt;
OrderedSet&lt;T&gt;(iter: Iterable.Indexed&lt;T&gt;): OrderedSet&lt;T&gt;
OrderedSet&lt;K, V&gt;(iter: Iterable.Keyed&lt;K, V&gt;): OrderedSet&lt;any&gt;
OrderedSet&lt;T&gt;(array: Array&lt;T&gt;): OrderedSet&lt;T&gt;
OrderedSet&lt;T&gt;(iterator: Iterator&lt;T&gt;): OrderedSet&lt;T&gt;
OrderedSet&lt;T&gt;(iterable: Object): OrderedSet&lt;T&gt;
</pre>
<h2>Static methods</h2>
<h3 id="orderedset.isorderedset">OrderedSet.isOrderedSet()</h3>
<p>True if the provided value is an OrderedSet.</p> <pre data-language="js">OrderedSet.isOrderedSet(maybeOrderedSet: any): boolean
</pre>
<h3 id="orderedset.of">OrderedSet.of()</h3>
<p>Creates a new OrderedSet containing <code>values</code>.</p> <pre data-language="js">OrderedSet.of&lt;T&gt;(...values: T[]): OrderedSet&lt;T&gt;
</pre>
<h3 id="orderedset.fromkeys">OrderedSet.fromKeys()</h3>
<p><code>OrderedSet.fromKeys()</code> creates a new immutable OrderedSet containing the keys from this Iterable or JavaScript Object.</p> <pre data-language="js">OrderedSet.fromKeys&lt;T&gt;(iter: Iterable&lt;T, any&gt;): OrderedSet&lt;T&gt;
OrderedSet.fromKeys(obj: {[key: string]: any}): OrderedSet&lt;string&gt;
</pre>
<h2>Members</h2>
<h3 id="orderedset.size">OrderedSet#size</h3>
<pre data-language="js">size: number</pre>
<h4>Inherited from</h4>
<code><a href="#collection.size">Collection#size</a></code><h2>Persistent changes</h2>
<h3 id="orderedset.add">OrderedSet#add()</h3>
<p>Returns a new Set which also includes this value.</p> <pre data-language="js">add(value: T): Set&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#set.add">Set#add</a></code><h3 id="orderedset.delete">OrderedSet#delete()</h3>
<p>Returns a new Set which excludes this value.</p> <pre data-language="js">delete(value: T): Set&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#set.delete">Set#delete</a></code><h4>alias</h4>
<code>remove()</code><h4>Discussion</h4>
<p>Note: <code>delete</code> cannot be safely used in IE8</p> <h3 id="orderedset.clear">OrderedSet#clear()</h3>
<p>Returns a new Set containing no values.</p> <pre data-language="js">clear(): Set&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#set.clear">Set#clear</a></code><h3 id="orderedset.union">OrderedSet#union()</h3>
<p>Returns a Set including any value from <code>iterables</code> that does not already exist in this Set.</p> <pre data-language="js">union(...iterables: Iterable&lt;any, T&gt;[]): Set&lt;T&gt;
union(...iterables: Array&lt;T&gt;[]): Set&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#set.union">Set#union</a></code><h4>alias</h4>
<code>merge()</code><h3 id="orderedset.intersect">OrderedSet#intersect()</h3>
<p>Returns a Set which has removed any values not also contained within <code>iterables</code>.</p> <pre data-language="js">intersect(...iterables: Iterable&lt;any, T&gt;[]): Set&lt;T&gt;
intersect(...iterables: Array&lt;T&gt;[]): Set&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#set.intersect">Set#intersect</a></code><h3 id="orderedset.subtract">OrderedSet#subtract()</h3>
<p>Returns a Set excluding any values contained within <code>iterables</code>.</p> <pre data-language="js">subtract(...iterables: Iterable&lt;any, T&gt;[]): Set&lt;T&gt;
subtract(...iterables: Array&lt;T&gt;[]): Set&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#set.subtract">Set#subtract</a></code><h2>Transient changes</h2>
<h3 id="orderedset.withmutations">OrderedSet#withMutations()</h3>
<p>Note: Not all methods can be used on a mutable collection or within <code>withMutations</code>! Only <code><a href="#set.add">add</a></code> may be used mutatively.</p> <pre data-language="js">withMutations(mutator: (mutable: Set&lt;T&gt;) =&gt; any): Set&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#set.withmutations">Set#withMutations</a></code><h4>see</h4>
<p><code><a href="#map.withmutations">Map#withMutations</a></code></p> <h3 id="orderedset.asmutable">OrderedSet#asMutable()</h3>
<pre data-language="js">asMutable(): Set&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#set.asmutable">Set#asMutable</a></code><h4>see</h4>
<p><code><a href="#map.asmutable">Map#asMutable</a></code></p> <h3 id="orderedset.asimmutable">OrderedSet#asImmutable()</h3>
<pre data-language="js">asImmutable(): Set&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#set.asimmutable">Set#asImmutable</a></code><h4>see</h4>
<p><code><a href="#map.asimmutable">Map#asImmutable</a></code></p> <h2>Conversion to Seq</h2>
<h3 id="orderedset.toseq">OrderedSet#toSeq()</h3>
<p>Returns Seq.Set.</p> <pre data-language="js">toSeq(): Seq.Set&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#collection.set.toseq">Collection.Set#toSeq</a></code><h3 id="orderedset.tokeyedseq">OrderedSet#toKeyedSeq()</h3>
<p>Returns a Seq.Keyed from this Iterable where indices are treated as keys.</p> <pre data-language="js">toKeyedSeq(): Seq.Keyed&lt;T, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tokeyedseq">Iterable#toKeyedSeq</a></code><h4>Discussion</h4>
<p>This is useful if you want to operate on an Iterable.Indexed and preserve the [index, value] pairs.</p> <p>The returned Seq will have identical iteration order as this Iterable.</p> <p>Example:</p> <pre data-language="js">var indexedSeq = Immutable.Seq.of('A', 'B', 'C');
indexedSeq.filter(v =&gt; v === 'B').toString() // Seq [ 'B' ]
var keyedSeq = indexedSeq.toKeyedSeq();
keyedSeq.filter(v =&gt; v === 'B').toString() // Seq { 1: 'B' }</pre>
<h3 id="orderedset.toindexedseq">OrderedSet#toIndexedSeq()</h3>
<p>Returns an Seq.Indexed of the values of this Iterable, discarding keys.</p> <pre data-language="js">toIndexedSeq(): Seq.Indexed&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toindexedseq">Iterable#toIndexedSeq</a></code><h3 id="orderedset.tosetseq">OrderedSet#toSetSeq()</h3>
<p>Returns a Seq.Set of the values of this Iterable, discarding keys.</p> <pre data-language="js">toSetSeq(): Seq.Set&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tosetseq">Iterable#toSetSeq</a></code><h2>Value equality</h2>
<h3 id="orderedset.equals">OrderedSet#equals()</h3>
<p>True if this and the other Iterable have value equality, as defined by <code><a href="#is">Immutable.is()</a></code>.</p> <pre data-language="js">equals(other: Iterable&lt;T, T&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.equals">Iterable#equals</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Immutable.is(this, other)</code>, but provided to allow for chained expressions.</p> <h3 id="orderedset.hashcode">OrderedSet#hashCode()</h3>
<p>Computes and returns the hashed identity for this Iterable.</p> <pre data-language="js">hashCode(): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.hashcode">Iterable#hashCode</a></code><h4>Discussion</h4>
<p>The <code>hashCode</code> of an Iterable is used to determine potential equality, and is used when adding this to a <code><a href="#iterable.set">Set</a></code> or as a key in a <code><a href="#map">Map</a></code>, enabling lookup via a different instance.</p> <pre data-language="js">var a = List.of(1, 2, 3);
var b = List.of(1, 2, 3);
assert(a !== b); // different instances
var set = Set.of(a);
assert(set.has(b) === true);</pre>
<p>If two values have the same <code>hashCode</code>, they are <a href="http://en.wikipedia.org/wiki/Collision_(computer_science)">not guaranteed to be equal</a>. If two values have different <code>hashCode</code>s, they must not be equal.</p> <h2>Reading values</h2>
<h3 id="orderedset.get">OrderedSet#get()</h3>
<p>Returns the value associated with the provided key, or notSetValue if the Iterable does not contain this key.</p> <pre data-language="js">get(key: T, notSetValue?: T): T
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.get">Iterable#get</a></code><h4>Discussion</h4>
<p>Note: it is possible a key may be associated with an <code>undefined</code> value, so if <code>notSetValue</code> is not provided and this method returns <code>undefined</code>, that does not guarantee the key was not found.</p> <h3 id="orderedset.has">OrderedSet#has()</h3>
<p>True if a key exists within this <code>Iterable</code>, using <code><a href="#is">Immutable.is</a></code> to determine equality</p> <pre data-language="js">has(key: T): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.has">Iterable#has</a></code><h3 id="orderedset.includes">OrderedSet#includes()</h3>
<p>True if a value exists within this <code>Iterable</code>, using <code><a href="#is">Immutable.is</a></code> to determine equality</p> <pre data-language="js">includes(value: T): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.includes">Iterable#includes</a></code><h4>alias</h4>
<code>contains()</code><h3 id="orderedset.first">OrderedSet#first()</h3>
<p>The first value in the Iterable.</p> <pre data-language="js">first(): T
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.first">Iterable#first</a></code><h3 id="orderedset.last">OrderedSet#last()</h3>
<p>The last value in the Iterable.</p> <pre data-language="js">last(): T
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.last">Iterable#last</a></code><h2>Reading deep values</h2>
<h3 id="orderedset.getin">OrderedSet#getIn()</h3>
<p>Returns the value found by following a path of keys or indices through nested Iterables.</p> <pre data-language="js">getIn(searchKeyPath: Array&lt;any&gt;, notSetValue?: any): any
getIn(searchKeyPath: Iterable&lt;any, any&gt;, notSetValue?: any): any
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.getin">Iterable#getIn</a></code><h3 id="orderedset.hasin">OrderedSet#hasIn()</h3>
<p>True if the result of following a path of keys or indices through nested Iterables results in a set value.</p> <pre data-language="js">hasIn(searchKeyPath: Array&lt;any&gt;): boolean
hasIn(searchKeyPath: Iterable&lt;any, any&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.hasin">Iterable#hasIn</a></code><h2>Conversion to JavaScript types</h2>
<h3 id="orderedset.tojs">OrderedSet#toJS()</h3>
<p>Deeply converts this Iterable to equivalent JS.</p> <pre data-language="js">toJS(): any
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tojs">Iterable#toJS</a></code><h4>alias</h4>
<code>toJSON()</code><h4>Discussion</h4>
<p><code>Iterable.Indexeds</code>, and <code>Iterable.Sets</code> become Arrays, while <code>Iterable.Keyeds</code> become Objects.</p> <h3 id="orderedset.toarray">OrderedSet#toArray()</h3>
<p>Shallowly converts this iterable to an Array, discarding keys.</p> <pre data-language="js">toArray(): Array&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toarray">Iterable#toArray</a></code><h3 id="orderedset.toobject">OrderedSet#toObject()</h3>
<p>Shallowly converts this Iterable to an Object.</p> <pre data-language="js">toObject(): {[key: string]: V}
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toobject">Iterable#toObject</a></code><h4>Discussion</h4>
<p>Throws if keys are not strings.</p> <h2>Conversion to Collections</h2>
<h3 id="orderedset.tomap">OrderedSet#toMap()</h3>
<p>Converts this Iterable to a Map, Throws if keys are not hashable.</p> <pre data-language="js">toMap(): Map&lt;T, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tomap">Iterable#toMap</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Map(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="orderedset.toorderedmap">OrderedSet#toOrderedMap()</h3>
<p>Converts this Iterable to a Map, maintaining the order of iteration.</p> <pre data-language="js">toOrderedMap(): OrderedMap&lt;T, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toorderedmap">Iterable#toOrderedMap</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>OrderedMap(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="orderedset.toset">OrderedSet#toSet()</h3>
<p>Converts this Iterable to a Set, discarding keys. Throws if values are not hashable.</p> <pre data-language="js">toSet(): Set&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toset">Iterable#toSet</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Set(this)</code>, but provided to allow for chained expressions.</p> <h3 id="orderedset.toorderedset">OrderedSet#toOrderedSet()</h3>
<p>Converts this Iterable to a Set, maintaining the order of iteration and discarding keys.</p> <pre data-language="js">toOrderedSet(): OrderedSet&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toorderedset">Iterable#toOrderedSet</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>OrderedSet(this.valueSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="orderedset.tolist">OrderedSet#toList()</h3>
<p>Converts this Iterable to a List, discarding keys.</p> <pre data-language="js">toList(): List&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tolist">Iterable#toList</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>List(this)</code>, but provided to allow for chained expressions.</p> <h3 id="orderedset.tostack">OrderedSet#toStack()</h3>
<p>Converts this Iterable to a Stack, discarding keys. Throws if values are not hashable.</p> <pre data-language="js">toStack(): Stack&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tostack">Iterable#toStack</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Stack(this)</code>, but provided to allow for chained expressions.</p> <h2>Iterators</h2>
<h3 id="orderedset.keys">OrderedSet#keys()</h3>
<p>An iterator of this <code>Iterable</code>'s keys.</p> <pre data-language="js">keys(): Iterator&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keys">Iterable#keys</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.keyseq">keySeq</a></code> instead, if this is what you want.</p> <h3 id="orderedset.values">OrderedSet#values()</h3>
<p>An iterator of this <code>Iterable</code>'s values.</p> <pre data-language="js">values(): Iterator&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.values">Iterable#values</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.valueseq">valueSeq</a></code> instead, if this is what you want.</p> <h3 id="orderedset.entries">OrderedSet#entries()</h3>
<p>An iterator of this <code>Iterable</code>'s entries as <code>[key, value]</code> tuples.</p> <pre data-language="js">entries(): Iterator&lt;Array&lt;any&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.entries">Iterable#entries</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.entryseq">entrySeq</a></code> instead, if this is what you want.</p> <h2>Iterables (Seq)</h2>
<h3 id="orderedset.keyseq">OrderedSet#keySeq()</h3>
<p>Returns a new Seq.Indexed of the keys of this Iterable, discarding values.</p> <pre data-language="js">keySeq(): Seq.Indexed&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyseq">Iterable#keySeq</a></code><h3 id="orderedset.valueseq">OrderedSet#valueSeq()</h3>
<p>Returns an Seq.Indexed of the values of this Iterable, discarding keys.</p> <pre data-language="js">valueSeq(): Seq.Indexed&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.valueseq">Iterable#valueSeq</a></code><h3 id="orderedset.entryseq">OrderedSet#entrySeq()</h3>
<p>Returns a new Seq.Indexed of [key, value] tuples.</p> <pre data-language="js">entrySeq(): Seq.Indexed&lt;Array&lt;any&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.entryseq">Iterable#entrySeq</a></code><h2>Sequence algorithms</h2>
<h3 id="orderedset.map">OrderedSet#map()</h3>
<p>Returns a new Iterable of the same type with values passed through a <code>mapper</code> function.</p> <pre data-language="js">map&lt;M&gt;(mapper: (value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; M,context?: any): Iterable&lt;T, M&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.map">Iterable#map</a></code><h4>Example</h4>
<pre data-language="js">Seq({ a: 1, b: 2 }).map(x =&gt; 10 * x)
// Seq { a: 10, b: 20 }</pre>
<h3 id="orderedset.filter">OrderedSet#filter()</h3>
<p>Returns a new Iterable of the same type with only the entries for which the <code>predicate</code> function returns true.</p> <pre data-language="js">filter(predicate: (value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; boolean,context?: any): Iterable&lt;T, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.filter">Iterable#filter</a></code><h4>Example</h4>
<pre data-language="js">Seq({a:1,b:2,c:3,d:4}).filter(x =&gt; x % 2 === 0)
// Seq { b: 2, d: 4 }</pre>
<h3 id="orderedset.filternot">OrderedSet#filterNot()</h3>
<p>Returns a new Iterable of the same type with only the entries for which the <code>predicate</code> function returns false.</p> <pre data-language="js">filterNot(predicate: (value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; boolean,context?: any): Iterable&lt;T, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.filternot">Iterable#filterNot</a></code><h4>Example</h4>
<pre data-language="js">Seq({a:1,b:2,c:3,d:4}).filterNot(x =&gt; x % 2 === 0)
// Seq { a: 1, c: 3 }</pre>
<h3 id="orderedset.reverse">OrderedSet#reverse()</h3>
<p>Returns a new Iterable of the same type in reverse order.</p> <pre data-language="js">reverse(): Iterable&lt;T, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reverse">Iterable#reverse</a></code><h3 id="orderedset.sort">OrderedSet#sort()</h3>
<p>Returns a new Iterable of the same type which includes the same entries, stably sorted by using a <code>comparator</code>.</p> <pre data-language="js">sort(comparator?: (valueA: T, valueB: T) =&gt; number): Iterable&lt;T, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.sort">Iterable#sort</a></code><h4>Discussion</h4>
<p>If a <code>comparator</code> is not provided, a default comparator uses <code>&lt;</code> and <code>&gt;</code>.</p> <p><code>comparator(valueA, valueB)</code>:</p> <ul> <li>Returns <code>0</code> if the elements should not be swapped.</li> <li>Returns <code>-1</code> (or any negative number) if <code>valueA</code> comes before <code>valueB</code>
</li> <li>Returns <code>1</code> (or any positive number) if <code>valueA</code> comes after <code>valueB</code>
</li> <li>Is pure, i.e. it must always return the same value for the same pair of values.</li> </ul> <p>When sorting collections which have no defined order, their ordered equivalents will be returned. e.g. <code>map.sort()</code> returns OrderedMap.</p> <h3 id="orderedset.sortby">OrderedSet#sortBy()</h3>
<p>Like <code><a href="#iterable.sort">sort</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for sorting by more sophisticated means:</p> <pre data-language="js">sortBy&lt;C&gt;(comparatorValueMapper: (value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): Iterable&lt;T, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.sortby">Iterable#sortBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.sortBy(hitter =&gt; hitter.avgHits);</pre>
<h3 id="orderedset.groupby">OrderedSet#groupBy()</h3>
<p>Returns a <code><a href="#iterable.keyed">Iterable.Keyed</a></code> of <code>Iterable.Keyeds</code>, grouped by the return value of the <code>grouper</code> function.</p> <pre data-language="js">groupBy&lt;G&gt;(grouper: (value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; G,context?: any): Seq.Keyed&lt;G, Iterable&lt;T, T&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.groupby">Iterable#groupBy</a></code><h4>Discussion</h4>
<p>Note: This is always an eager operation.</p> <h2>Side effects</h2>
<h3 id="orderedset.foreach">OrderedSet#forEach()</h3>
<p>The <code>sideEffect</code> is executed for every entry in the Iterable.</p> <pre data-language="js">forEach(sideEffect: (value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; any,context?: any): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.foreach">Iterable#forEach</a></code><h4>Discussion</h4>
<p>Unlike <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">Array#forEach</a></code>, if any call of <code>sideEffect</code> returns <code>false</code>, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).</p> <h2>Creating subsets</h2>
<h3 id="orderedset.slice">OrderedSet#slice()</h3>
<p>Returns a new Iterable of the same type representing a portion of this Iterable from start up to but not including end.</p> <pre data-language="js">slice(begin?: number, end?: number): Iterable&lt;T, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.slice">Iterable#slice</a></code><h4>Discussion</h4>
<p>If begin is negative, it is offset from the end of the Iterable. e.g. <code>slice(-2)</code> returns a Iterable of the last two entries. If it is not provided the new Iterable will begin at the beginning of this Iterable.</p> <p>If end is negative, it is offset from the end of the Iterable. e.g. <code>slice(0, -1)</code> returns an Iterable of everything but the last entry. If it is not provided, the new Iterable will continue through the end of this Iterable.</p> <p>If the requested slice is equivalent to the current Iterable, then it will return itself.</p> <h3 id="orderedset.rest">OrderedSet#rest()</h3>
<p>Returns a new Iterable of the same type containing all entries except the first.</p> <pre data-language="js">rest(): Iterable&lt;T, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.rest">Iterable#rest</a></code><h3 id="orderedset.butlast">OrderedSet#butLast()</h3>
<p>Returns a new Iterable of the same type containing all entries except the last.</p> <pre data-language="js">butLast(): Iterable&lt;T, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.butlast">Iterable#butLast</a></code><h3 id="orderedset.skip">OrderedSet#skip()</h3>
<p>Returns a new Iterable of the same type which excludes the first <code>amount</code> entries from this Iterable.</p> <pre data-language="js">skip(amount: number): Iterable&lt;T, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skip">Iterable#skip</a></code><h3 id="orderedset.skiplast">OrderedSet#skipLast()</h3>
<p>Returns a new Iterable of the same type which excludes the last <code>amount</code> entries from this Iterable.</p> <pre data-language="js">skipLast(amount: number): Iterable&lt;T, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skiplast">Iterable#skipLast</a></code><h3 id="orderedset.skipwhile">OrderedSet#skipWhile()</h3>
<p>Returns a new Iterable of the same type which includes entries starting from when <code>predicate</code> first returns false.</p> <pre data-language="js">skipWhile(predicate: (value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; boolean,context?: any): Iterable&lt;T, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skipwhile">Iterable#skipWhile</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .skipWhile(x =&gt; x.match(/g/))
// Seq [ 'cat', 'hat', 'god' ]</pre>
<h3 id="orderedset.skipuntil">OrderedSet#skipUntil()</h3>
<p>Returns a new Iterable of the same type which includes entries starting from when <code>predicate</code> first returns true.</p> <pre data-language="js">skipUntil(predicate: (value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; boolean,context?: any): Iterable&lt;T, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skipuntil">Iterable#skipUntil</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .skipUntil(x =&gt; x.match(/hat/))
// Seq [ 'hat', 'god' ]</pre>
<h3 id="orderedset.take">OrderedSet#take()</h3>
<p>Returns a new Iterable of the same type which includes the first <code>amount</code> entries from this Iterable.</p> <pre data-language="js">take(amount: number): Iterable&lt;T, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.take">Iterable#take</a></code><h3 id="orderedset.takelast">OrderedSet#takeLast()</h3>
<p>Returns a new Iterable of the same type which includes the last <code>amount</code> entries from this Iterable.</p> <pre data-language="js">takeLast(amount: number): Iterable&lt;T, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takelast">Iterable#takeLast</a></code><h3 id="orderedset.takewhile">OrderedSet#takeWhile()</h3>
<p>Returns a new Iterable of the same type which includes entries from this Iterable as long as the <code>predicate</code> returns true.</p> <pre data-language="js">takeWhile(predicate: (value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; boolean,context?: any): Iterable&lt;T, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takewhile">Iterable#takeWhile</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .takeWhile(x =&gt; x.match(/o/))
// Seq [ 'dog', 'frog' ]</pre>
<h3 id="orderedset.takeuntil">OrderedSet#takeUntil()</h3>
<p>Returns a new Iterable of the same type which includes entries from this Iterable as long as the <code>predicate</code> returns false.</p> <pre data-language="js">takeUntil(predicate: (value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; boolean,context?: any): Iterable&lt;T, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takeuntil">Iterable#takeUntil</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god').takeUntil(x =&gt; x.match(/at/))
// ['dog', 'frog']</pre>
<h2>Combination</h2>
<h3 id="orderedset.concat">OrderedSet#concat()</h3>
<p>Returns a new Iterable of the same type with other values and iterable-like concatenated to this one.</p> <pre data-language="js">concat(...valuesOrIterables: any[]): Iterable&lt;T, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.concat">Iterable#concat</a></code><h4>Discussion</h4>
<p>For Seqs, all entries will be present in the resulting iterable, even if they have the same key.</p> <h3 id="orderedset.flatten">OrderedSet#flatten()</h3>
<p>Flattens nested Iterables.</p> <pre data-language="js">flatten(depth?: number): Iterable&lt;any, any&gt;
flatten(shallow?: boolean): Iterable&lt;any, any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.flatten">Iterable#flatten</a></code><h4>Discussion</h4>
<p>Will deeply flatten the Iterable by default, returning an Iterable of the same type, but a <code>depth</code> can be provided in the form of a number or boolean (where true means to shallowly flatten one level). A depth of 0 (or shallow: false) will deeply flatten.</p> <p>Flattens only others Iterable, not Arrays or Objects.</p> <p>Note: <code>flatten(true)</code> operates on Iterable<any iterable v="">&gt; and returns Iterable</any></p> <h3 id="orderedset.flatmap">OrderedSet#flatMap()</h3>
<p>Flat-maps the Iterable, returning an Iterable of the same type.</p> <pre data-language="js">flatMap&lt;MK, MV&gt;(mapper: (value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; Iterable&lt;MK, MV&gt;,context?: any): Iterable&lt;MK, MV&gt;
flatMap&lt;MK, MV&gt;(mapper: (value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; any,context?: any): Iterable&lt;MK, MV&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.flatmap">Iterable#flatMap</a></code><h4>Discussion</h4>
<p>Similar to <code>iter.map(...).flatten(true)</code>.</p> <h2>Reducing a value</h2>
<h3 id="orderedset.reduce">OrderedSet#reduce()</h3>
<p>Reduces the Iterable to a value by calling the <code>reducer</code> for every entry in the Iterable and passing along the reduced value.</p> <pre data-language="js">reduce&lt;R&gt;(reducer: (reduction?: R, value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; R,initialReduction?: R,context?: any): R
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reduce">Iterable#reduce</a></code><h4>see</h4>
<p><code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">Array#reduce</a></code>.</p> <h4>Discussion</h4>
<p>If <code>initialReduction</code> is not provided, or is null, the first item in the Iterable will be used.</p> <h3 id="orderedset.reduceright">OrderedSet#reduceRight()</h3>
<p>Reduces the Iterable in reverse (from the right side).</p> <pre data-language="js">reduceRight&lt;R&gt;(reducer: (reduction?: R, value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; R,initialReduction?: R,context?: any): R
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reduceright">Iterable#reduceRight</a></code><h4>Discussion</h4>
<p>Note: Similar to this.reverse().reduce(), and provided for parity with <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight">Array#reduceRight</a></code>.</p> <h3 id="orderedset.every">OrderedSet#every()</h3>
<p>True if <code>predicate</code> returns true for all entries in the Iterable.</p> <pre data-language="js">every(predicate: (value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; boolean,context?: any): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.every">Iterable#every</a></code><h3 id="orderedset.some">OrderedSet#some()</h3>
<p>True if <code>predicate</code> returns true for any entry in the Iterable.</p> <pre data-language="js">some(predicate: (value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; boolean,context?: any): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.some">Iterable#some</a></code><h3 id="orderedset.join">OrderedSet#join()</h3>
<p>Joins values together as a string, inserting a separator between each. The default separator is <code>","</code>.</p> <pre data-language="js">join(separator?: string): string
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.join">Iterable#join</a></code><h3 id="orderedset.isempty">OrderedSet#isEmpty()</h3>
<p>Returns true if this Iterable includes no values.</p> <pre data-language="js">isEmpty(): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.isempty">Iterable#isEmpty</a></code><h4>Discussion</h4>
<p>For some lazy <code><a href="#seq">Seq</a></code>, <code>isEmpty</code> might need to iterate to determine emptiness. At most one iteration will occur.</p> <h3 id="orderedset.count">OrderedSet#count()</h3>
<p>Returns the size of this Iterable.</p> <pre data-language="js">count(): number
count(predicate: (value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; boolean,context?: any): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.count">Iterable#count</a></code><h4>Discussion</h4>
<p>Regardless of if this Iterable can describe its size lazily (some Seqs cannot), this method will always return the correct size. E.g. it evaluates a lazy <code><a href="#seq">Seq</a></code> if necessary.</p> <p>If <code>predicate</code> is provided, then this returns the count of entries in the Iterable for which the <code>predicate</code> returns true.</p> <h3 id="orderedset.countby">OrderedSet#countBy()</h3>
<p>Returns a <code><a href="#seq.keyed">Seq.Keyed</a></code> of counts, grouped by the return value of the <code>grouper</code> function.</p> <pre data-language="js">countBy&lt;G&gt;(grouper: (value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; G,context?: any): Map&lt;G, number&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.countby">Iterable#countBy</a></code><h4>Discussion</h4>
<p>Note: This is not a lazy operation.</p> <h2>Search for value</h2>
<h3 id="orderedset.find">OrderedSet#find()</h3>
<p>Returns the first value for which the <code>predicate</code> returns true.</p> <pre data-language="js">find(predicate: (value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; boolean,context?: any,notSetValue?: T): T
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.find">Iterable#find</a></code><h3 id="orderedset.findlast">OrderedSet#findLast()</h3>
<p>Returns the last value for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLast(predicate: (value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; boolean,context?: any,notSetValue?: T): T
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlast">Iterable#findLast</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="orderedset.findentry">OrderedSet#findEntry()</h3>
<p>Returns the first [key, value] entry for which the <code>predicate</code> returns true.</p> <pre data-language="js">findEntry(predicate: (value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; boolean,context?: any,notSetValue?: T): Array&lt;any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findentry">Iterable#findEntry</a></code><h3 id="orderedset.findlastentry">OrderedSet#findLastEntry()</h3>
<p>Returns the last [key, value] entry for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLastEntry(predicate: (value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; boolean,context?: any,notSetValue?: T): Array&lt;any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlastentry">Iterable#findLastEntry</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="orderedset.findkey">OrderedSet#findKey()</h3>
<p>Returns the key for which the <code>predicate</code> returns true.</p> <pre data-language="js">findKey(predicate: (value?: T, key?: T, iter?: Iterable.Keyed&lt;T, T&gt;) =&gt; boolean,context?: any): T
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findkey">Iterable#findKey</a></code><h3 id="orderedset.findlastkey">OrderedSet#findLastKey()</h3>
<p>Returns the last key for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLastKey(predicate: (value?: T, key?: T, iter?: Iterable.Keyed&lt;T, T&gt;) =&gt; boolean,context?: any): T
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlastkey">Iterable#findLastKey</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="orderedset.keyof">OrderedSet#keyOf()</h3>
<p>Returns the key associated with the search value, or undefined.</p> <pre data-language="js">keyOf(searchValue: T): T
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyof">Iterable#keyOf</a></code><h3 id="orderedset.lastkeyof">OrderedSet#lastKeyOf()</h3>
<p>Returns the last key associated with the search value, or undefined.</p> <pre data-language="js">lastKeyOf(searchValue: T): T
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.lastkeyof">Iterable#lastKeyOf</a></code><h3 id="orderedset.max">OrderedSet#max()</h3>
<p>Returns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> <pre data-language="js">max(comparator?: (valueA: T, valueB: T) =&gt; number): T
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.max">Iterable#max</a></code><h4>Discussion</h4>
<p>The <code>comparator</code> is used in the same way as <code><a href="#iterable.sort">Iterable#sort</a></code>. If it is not provided, the default comparator is <code>&gt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code>max</code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&gt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> <h3 id="orderedset.maxby">OrderedSet#maxBy()</h3>
<p>Like <code><a href="#iterable.max">max</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> <pre data-language="js">maxBy&lt;C&gt;(comparatorValueMapper: (value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): T
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.maxby">Iterable#maxBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.maxBy(hitter =&gt; hitter.avgHits);</pre>
<h3 id="orderedset.min">OrderedSet#min()</h3>
<p>Returns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> <pre data-language="js">min(comparator?: (valueA: T, valueB: T) =&gt; number): T
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.min">Iterable#min</a></code><h4>Discussion</h4>
<p>The <code>comparator</code> is used in the same way as <code><a href="#iterable.sort">Iterable#sort</a></code>. If it is not provided, the default comparator is <code>&lt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code>min</code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&lt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> <h3 id="orderedset.minby">OrderedSet#minBy()</h3>
<p>Like <code><a href="#iterable.min">min</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> <pre data-language="js">minBy&lt;C&gt;(comparatorValueMapper: (value?: T, key?: T, iter?: Iterable&lt;T, T&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): T
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.minby">Iterable#minBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.minBy(hitter =&gt; hitter.avgHits);</pre>
<h2>Comparison</h2>
<h3 id="orderedset.issubset">OrderedSet#isSubset()</h3>
<p>True if <code>iter</code> includes every value in this Iterable.</p> <pre data-language="js">isSubset(iter: Iterable&lt;any, T&gt;): boolean
isSubset(iter: Array&lt;T&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.issubset">Iterable#isSubset</a></code><h3 id="orderedset.issuperset">OrderedSet#isSuperset()</h3>
<p>True if this Iterable includes every value in <code>iter</code>.</p> <pre data-language="js">isSuperset(iter: Iterable&lt;any, T&gt;): boolean
isSuperset(iter: Array&lt;T&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.issuperset">Iterable#isSuperset</a></code><h1 id="stack">Stack</h1>
<p>Stacks are indexed collections which support very efficient O(1) addition and removal from the front using <code>unshift(v)</code> and <code><a href="#stack.shift">shift()</a></code>.</p> <pre data-language="js">class Stack&lt;T&gt; extends Collection.Indexed&lt;T&gt;</pre>
<h4>Discussion</h4>
<p>For familiarity, Stack also provides <code>push(v)</code>, <code><a href="#stack.pop">pop()</a></code>, and <code><a href="#stack.peek">peek()</a></code>, but be aware that they also operate on the front of the list, unlike List or a JavaScript Array.</p> <p>Note: <code><a href="#stack.reverse">reverse()</a></code> or any inherent reverse traversal (<code><a href="#stack.reduceright">reduceRight</a></code>, <code><a href="#stack.lastindexof">lastIndexOf</a></code>, etc.) is not efficient with a Stack.</p> <p>Stack is implemented with a Single-Linked List.</p> <h2>Construction</h2>
<h3 id="stack()">Stack()</h3>
<p>Create a new immutable Stack containing the values of the provided iterable-like.</p> <pre data-language="js">Stack&lt;T&gt;(): Stack&lt;T&gt;
Stack&lt;T&gt;(iter: Iterable.Indexed&lt;T&gt;): Stack&lt;T&gt;
Stack&lt;T&gt;(iter: Iterable.Set&lt;T&gt;): Stack&lt;T&gt;
Stack&lt;K, V&gt;(iter: Iterable.Keyed&lt;K, V&gt;): Stack&lt;any&gt;
Stack&lt;T&gt;(array: Array&lt;T&gt;): Stack&lt;T&gt;
Stack&lt;T&gt;(iterator: Iterator&lt;T&gt;): Stack&lt;T&gt;
Stack&lt;T&gt;(iterable: Object): Stack&lt;T&gt;
</pre>
<h4>Discussion</h4>
<p>The iteration order of the provided iterable is preserved in the resulting <code>Stack</code>.</p> <h2>Static methods</h2>
<h3 id="stack.isstack">Stack.isStack()</h3>
<p>True if the provided value is a Stack</p> <pre data-language="js">Stack.isStack(maybeStack: any): boolean
</pre>
<h3 id="stack.of">Stack.of()</h3>
<p>Creates a new Stack containing <code>values</code>.</p> <pre data-language="js">Stack.of&lt;T&gt;(...values: T[]): Stack&lt;T&gt;
</pre>
<h2>Members</h2>
<h3 id="stack.size">Stack#size</h3>
<pre data-language="js">size: number</pre>
<h4>Inherited from</h4>
<code><a href="#collection.size">Collection#size</a></code><h2>Reading values</h2>
<h3 id="stack.peek">Stack#peek()</h3>
<p>Alias for <code><a href="#stack.first">Stack.first()</a></code>.</p> <pre data-language="js">peek(): T
</pre>
<h3 id="stack.get">Stack#get()</h3>
<p>Returns the value associated with the provided key, or notSetValue if the Iterable does not contain this key.</p> <pre data-language="js">get(key: number, notSetValue?: T): T
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.get">Iterable#get</a></code><h4>Discussion</h4>
<p>Note: it is possible a key may be associated with an <code>undefined</code> value, so if <code>notSetValue</code> is not provided and this method returns <code>undefined</code>, that does not guarantee the key was not found.</p> <h3 id="stack.has">Stack#has()</h3>
<p>True if a key exists within this <code>Iterable</code>, using <code><a href="#is">Immutable.is</a></code> to determine equality</p> <pre data-language="js">has(key: number): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.has">Iterable#has</a></code><h3 id="stack.includes">Stack#includes()</h3>
<p>True if a value exists within this <code>Iterable</code>, using <code><a href="#is">Immutable.is</a></code> to determine equality</p> <pre data-language="js">includes(value: T): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.includes">Iterable#includes</a></code><h4>alias</h4>
<code>contains()</code><h3 id="stack.first">Stack#first()</h3>
<p>The first value in the Iterable.</p> <pre data-language="js">first(): T
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.first">Iterable#first</a></code><h3 id="stack.last">Stack#last()</h3>
<p>The last value in the Iterable.</p> <pre data-language="js">last(): T
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.last">Iterable#last</a></code><h2>Persistent changes</h2>
<h3 id="stack.clear">Stack#clear()</h3>
<p>Returns a new Stack with 0 size and no values.</p> <pre data-language="js">clear(): Stack&lt;T&gt;
</pre>
<h3 id="stack.unshift">Stack#unshift()</h3>
<p>Returns a new Stack with the provided <code>values</code> prepended, shifting other values ahead to higher indices.</p> <pre data-language="js">unshift(...values: T[]): Stack&lt;T&gt;
</pre>
<h4>Discussion</h4>
<p>This is very efficient for Stack.</p> <h3 id="stack.unshiftall">Stack#unshiftAll()</h3>
<p>Like <code><a href="#stack.unshift">Stack#unshift</a></code>, but accepts a iterable rather than varargs.</p> <pre data-language="js">unshiftAll(iter: Iterable&lt;any, T&gt;): Stack&lt;T&gt;
unshiftAll(iter: Array&lt;T&gt;): Stack&lt;T&gt;
</pre>
<h3 id="stack.shift">Stack#shift()</h3>
<p>Returns a new Stack with a size ones less than this Stack, excluding the first item in this Stack, shifting all other values to a lower index.</p> <pre data-language="js">shift(): Stack&lt;T&gt;
</pre>
<h4>Discussion</h4>
<p>Note: this differs from <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/shift">Array#shift</a></code> because it returns a new Stack rather than the removed value. Use <code><a href="#stack.first">first()</a></code> or <code><a href="#stack.peek">peek()</a></code> to get the first value in this Stack.</p> <h3 id="stack.push">Stack#push()</h3>
<p>Alias for <code><a href="#stack.unshift">Stack#unshift</a></code> and is not equivalent to <code><a href="#list.push">List#push</a></code>.</p> <pre data-language="js">push(...values: T[]): Stack&lt;T&gt;
</pre>
<h3 id="stack.pushall">Stack#pushAll()</h3>
<p>Alias for <code><a href="#stack.unshiftall">Stack#unshiftAll</a></code>.</p> <pre data-language="js">pushAll(iter: Iterable&lt;any, T&gt;): Stack&lt;T&gt;
pushAll(iter: Array&lt;T&gt;): Stack&lt;T&gt;
</pre>
<h3 id="stack.pop">Stack#pop()</h3>
<p>Alias for <code><a href="#stack.shift">Stack#shift</a></code> and is not equivalent to <code><a href="#list.pop">List#pop</a></code>.</p> <pre data-language="js">pop(): Stack&lt;T&gt;
</pre>
<h2>Transient changes</h2>
<h3 id="stack.withmutations">Stack#withMutations()</h3>
<p>Note: Not all methods can be used on a mutable collection or within <code>withMutations</code>! Only <code>set</code>, <code><a href="#stack.push">push</a></code>, and <code><a href="#stack.pop">pop</a></code> may be used mutatively.</p> <pre data-language="js">withMutations(mutator: (mutable: Stack&lt;T&gt;) =&gt; any): Stack&lt;T&gt;
</pre>
<h4>see</h4>
<p><code><a href="#map.withmutations">Map#withMutations</a></code></p> <h3 id="stack.asmutable">Stack#asMutable()</h3>
<pre data-language="js">asMutable(): Stack&lt;T&gt;
</pre>
<h4>see</h4>
<p><code><a href="#map.asmutable">Map#asMutable</a></code></p> <h3 id="stack.asimmutable">Stack#asImmutable()</h3>
<pre data-language="js">asImmutable(): Stack&lt;T&gt;
</pre>
<h4>see</h4>
<p><code><a href="#map.asimmutable">Map#asImmutable</a></code></p> <h2>Conversion to Seq</h2>
<h3 id="stack.toseq">Stack#toSeq()</h3>
<p>Returns Seq.Indexed.</p> <pre data-language="js">toSeq(): Seq.Indexed&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#collection.indexed.toseq">Collection.Indexed#toSeq</a></code><h3 id="stack.tokeyedseq">Stack#toKeyedSeq()</h3>
<p>Returns a Seq.Keyed from this Iterable where indices are treated as keys.</p> <pre data-language="js">toKeyedSeq(): Seq.Keyed&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tokeyedseq">Iterable#toKeyedSeq</a></code><h4>Discussion</h4>
<p>This is useful if you want to operate on an Iterable.Indexed and preserve the [index, value] pairs.</p> <p>The returned Seq will have identical iteration order as this Iterable.</p> <p>Example:</p> <pre data-language="js">var indexedSeq = Immutable.Seq.of('A', 'B', 'C');
indexedSeq.filter(v =&gt; v === 'B').toString() // Seq [ 'B' ]
var keyedSeq = indexedSeq.toKeyedSeq();
keyedSeq.filter(v =&gt; v === 'B').toString() // Seq { 1: 'B' }</pre>
<h3 id="stack.toindexedseq">Stack#toIndexedSeq()</h3>
<p>Returns an Seq.Indexed of the values of this Iterable, discarding keys.</p> <pre data-language="js">toIndexedSeq(): Seq.Indexed&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toindexedseq">Iterable#toIndexedSeq</a></code><h3 id="stack.tosetseq">Stack#toSetSeq()</h3>
<p>Returns a Seq.Set of the values of this Iterable, discarding keys.</p> <pre data-language="js">toSetSeq(): Seq.Set&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tosetseq">Iterable#toSetSeq</a></code><h3 id="stack.fromentryseq">Stack#fromEntrySeq()</h3>
<p>If this is an iterable of [key, value] entry tuples, it will return a Seq.Keyed of those entries.</p> <pre data-language="js">fromEntrySeq(): Seq.Keyed&lt;any, any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.indexed.fromentryseq">Iterable.Indexed#fromEntrySeq</a></code><h2>Value equality</h2>
<h3 id="stack.equals">Stack#equals()</h3>
<p>True if this and the other Iterable have value equality, as defined by <code><a href="#is">Immutable.is()</a></code>.</p> <pre data-language="js">equals(other: Iterable&lt;number, T&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.equals">Iterable#equals</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Immutable.is(this, other)</code>, but provided to allow for chained expressions.</p> <h3 id="stack.hashcode">Stack#hashCode()</h3>
<p>Computes and returns the hashed identity for this Iterable.</p> <pre data-language="js">hashCode(): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.hashcode">Iterable#hashCode</a></code><h4>Discussion</h4>
<p>The <code>hashCode</code> of an Iterable is used to determine potential equality, and is used when adding this to a <code><a href="#iterable.set">Set</a></code> or as a key in a <code><a href="#map">Map</a></code>, enabling lookup via a different instance.</p> <pre data-language="js">var a = List.of(1, 2, 3);
var b = List.of(1, 2, 3);
assert(a !== b); // different instances
var set = Set.of(a);
assert(set.has(b) === true);</pre>
<p>If two values have the same <code>hashCode</code>, they are <a href="http://en.wikipedia.org/wiki/Collision_(computer_science)">not guaranteed to be equal</a>. If two values have different <code>hashCode</code>s, they must not be equal.</p> <h2>Reading deep values</h2>
<h3 id="stack.getin">Stack#getIn()</h3>
<p>Returns the value found by following a path of keys or indices through nested Iterables.</p> <pre data-language="js">getIn(searchKeyPath: Array&lt;any&gt;, notSetValue?: any): any
getIn(searchKeyPath: Iterable&lt;any, any&gt;, notSetValue?: any): any
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.getin">Iterable#getIn</a></code><h3 id="stack.hasin">Stack#hasIn()</h3>
<p>True if the result of following a path of keys or indices through nested Iterables results in a set value.</p> <pre data-language="js">hasIn(searchKeyPath: Array&lt;any&gt;): boolean
hasIn(searchKeyPath: Iterable&lt;any, any&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.hasin">Iterable#hasIn</a></code><h2>Conversion to JavaScript types</h2>
<h3 id="stack.tojs">Stack#toJS()</h3>
<p>Deeply converts this Iterable to equivalent JS.</p> <pre data-language="js">toJS(): any
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tojs">Iterable#toJS</a></code><h4>alias</h4>
<code>toJSON()</code><h4>Discussion</h4>
<p><code>Iterable.Indexeds</code>, and <code>Iterable.Sets</code> become Arrays, while <code>Iterable.Keyeds</code> become Objects.</p> <h3 id="stack.toarray">Stack#toArray()</h3>
<p>Shallowly converts this iterable to an Array, discarding keys.</p> <pre data-language="js">toArray(): Array&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toarray">Iterable#toArray</a></code><h3 id="stack.toobject">Stack#toObject()</h3>
<p>Shallowly converts this Iterable to an Object.</p> <pre data-language="js">toObject(): {[key: string]: V}
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toobject">Iterable#toObject</a></code><h4>Discussion</h4>
<p>Throws if keys are not strings.</p> <h2>Conversion to Collections</h2>
<h3 id="stack.tomap">Stack#toMap()</h3>
<p>Converts this Iterable to a Map, Throws if keys are not hashable.</p> <pre data-language="js">toMap(): Map&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tomap">Iterable#toMap</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Map(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="stack.toorderedmap">Stack#toOrderedMap()</h3>
<p>Converts this Iterable to a Map, maintaining the order of iteration.</p> <pre data-language="js">toOrderedMap(): OrderedMap&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toorderedmap">Iterable#toOrderedMap</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>OrderedMap(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="stack.toset">Stack#toSet()</h3>
<p>Converts this Iterable to a Set, discarding keys. Throws if values are not hashable.</p> <pre data-language="js">toSet(): Set&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toset">Iterable#toSet</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Set(this)</code>, but provided to allow for chained expressions.</p> <h3 id="stack.toorderedset">Stack#toOrderedSet()</h3>
<p>Converts this Iterable to a Set, maintaining the order of iteration and discarding keys.</p> <pre data-language="js">toOrderedSet(): OrderedSet&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toorderedset">Iterable#toOrderedSet</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>OrderedSet(this.valueSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="stack.tolist">Stack#toList()</h3>
<p>Converts this Iterable to a List, discarding keys.</p> <pre data-language="js">toList(): List&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tolist">Iterable#toList</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>List(this)</code>, but provided to allow for chained expressions.</p> <h3 id="stack.tostack">Stack#toStack()</h3>
<p>Converts this Iterable to a Stack, discarding keys. Throws if values are not hashable.</p> <pre data-language="js">toStack(): Stack&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tostack">Iterable#toStack</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Stack(this)</code>, but provided to allow for chained expressions.</p> <h2>Iterators</h2>
<h3 id="stack.keys">Stack#keys()</h3>
<p>An iterator of this <code>Iterable</code>'s keys.</p> <pre data-language="js">keys(): Iterator&lt;number&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keys">Iterable#keys</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.keyseq">keySeq</a></code> instead, if this is what you want.</p> <h3 id="stack.values">Stack#values()</h3>
<p>An iterator of this <code>Iterable</code>'s values.</p> <pre data-language="js">values(): Iterator&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.values">Iterable#values</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.valueseq">valueSeq</a></code> instead, if this is what you want.</p> <h3 id="stack.entries">Stack#entries()</h3>
<p>An iterator of this <code>Iterable</code>'s entries as <code>[key, value]</code> tuples.</p> <pre data-language="js">entries(): Iterator&lt;Array&lt;any&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.entries">Iterable#entries</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.entryseq">entrySeq</a></code> instead, if this is what you want.</p> <h2>Iterables (Seq)</h2>
<h3 id="stack.keyseq">Stack#keySeq()</h3>
<p>Returns a new Seq.Indexed of the keys of this Iterable, discarding values.</p> <pre data-language="js">keySeq(): Seq.Indexed&lt;number&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyseq">Iterable#keySeq</a></code><h3 id="stack.valueseq">Stack#valueSeq()</h3>
<p>Returns an Seq.Indexed of the values of this Iterable, discarding keys.</p> <pre data-language="js">valueSeq(): Seq.Indexed&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.valueseq">Iterable#valueSeq</a></code><h3 id="stack.entryseq">Stack#entrySeq()</h3>
<p>Returns a new Seq.Indexed of [key, value] tuples.</p> <pre data-language="js">entrySeq(): Seq.Indexed&lt;Array&lt;any&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.entryseq">Iterable#entrySeq</a></code><h2>Sequence algorithms</h2>
<h3 id="stack.map">Stack#map()</h3>
<p>Returns a new Iterable of the same type with values passed through a <code>mapper</code> function.</p> <pre data-language="js">map&lt;M&gt;(mapper: (value?: T, key?: number, iter?: Iterable&lt;number, T&gt;) =&gt; M,context?: any): Iterable&lt;number, M&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.map">Iterable#map</a></code><h4>Example</h4>
<pre data-language="js">Seq({ a: 1, b: 2 }).map(x =&gt; 10 * x)
// Seq { a: 10, b: 20 }</pre>
<h3 id="stack.filter">Stack#filter()</h3>
<p>Returns a new Iterable of the same type with only the entries for which the <code>predicate</code> function returns true.</p> <pre data-language="js">filter(predicate: (value?: T, key?: number, iter?: Iterable&lt;number, T&gt;) =&gt; boolean,context?: any): Iterable&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.filter">Iterable#filter</a></code><h4>Example</h4>
<pre data-language="js">Seq({a:1,b:2,c:3,d:4}).filter(x =&gt; x % 2 === 0)
// Seq { b: 2, d: 4 }</pre>
<h3 id="stack.filternot">Stack#filterNot()</h3>
<p>Returns a new Iterable of the same type with only the entries for which the <code>predicate</code> function returns false.</p> <pre data-language="js">filterNot(predicate: (value?: T, key?: number, iter?: Iterable&lt;number, T&gt;) =&gt; boolean,context?: any): Iterable&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.filternot">Iterable#filterNot</a></code><h4>Example</h4>
<pre data-language="js">Seq({a:1,b:2,c:3,d:4}).filterNot(x =&gt; x % 2 === 0)
// Seq { a: 1, c: 3 }</pre>
<h3 id="stack.reverse">Stack#reverse()</h3>
<p>Returns a new Iterable of the same type in reverse order.</p> <pre data-language="js">reverse(): Iterable&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reverse">Iterable#reverse</a></code><h3 id="stack.sort">Stack#sort()</h3>
<p>Returns a new Iterable of the same type which includes the same entries, stably sorted by using a <code>comparator</code>.</p> <pre data-language="js">sort(comparator?: (valueA: T, valueB: T) =&gt; number): Iterable&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.sort">Iterable#sort</a></code><h4>Discussion</h4>
<p>If a <code>comparator</code> is not provided, a default comparator uses <code>&lt;</code> and <code>&gt;</code>.</p> <p><code>comparator(valueA, valueB)</code>:</p> <ul> <li>Returns <code>0</code> if the elements should not be swapped.</li> <li>Returns <code>-1</code> (or any negative number) if <code>valueA</code> comes before <code>valueB</code>
</li> <li>Returns <code>1</code> (or any positive number) if <code>valueA</code> comes after <code>valueB</code>
</li> <li>Is pure, i.e. it must always return the same value for the same pair of values.</li> </ul> <p>When sorting collections which have no defined order, their ordered equivalents will be returned. e.g. <code>map.sort()</code> returns OrderedMap.</p> <h3 id="stack.sortby">Stack#sortBy()</h3>
<p>Like <code><a href="#iterable.sort">sort</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for sorting by more sophisticated means:</p> <pre data-language="js">sortBy&lt;C&gt;(comparatorValueMapper: (value?: T,key?: number,iter?: Iterable&lt;number, T&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): Iterable&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.sortby">Iterable#sortBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.sortBy(hitter =&gt; hitter.avgHits);</pre>
<h3 id="stack.groupby">Stack#groupBy()</h3>
<p>Returns a <code><a href="#iterable.keyed">Iterable.Keyed</a></code> of <code>Iterable.Keyeds</code>, grouped by the return value of the <code>grouper</code> function.</p> <pre data-language="js">groupBy&lt;G&gt;(grouper: (value?: T, key?: number, iter?: Iterable&lt;number, T&gt;) =&gt; G,context?: any): Seq.Keyed&lt;G, Iterable&lt;number, T&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.groupby">Iterable#groupBy</a></code><h4>Discussion</h4>
<p>Note: This is always an eager operation.</p> <h2>Side effects</h2>
<h3 id="stack.foreach">Stack#forEach()</h3>
<p>The <code>sideEffect</code> is executed for every entry in the Iterable.</p> <pre data-language="js">forEach(sideEffect: (value?: T, key?: number, iter?: Iterable&lt;number, T&gt;) =&gt; any,context?: any): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.foreach">Iterable#forEach</a></code><h4>Discussion</h4>
<p>Unlike <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">Array#forEach</a></code>, if any call of <code>sideEffect</code> returns <code>false</code>, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).</p> <h2>Creating subsets</h2>
<h3 id="stack.slice">Stack#slice()</h3>
<p>Returns a new Iterable of the same type representing a portion of this Iterable from start up to but not including end.</p> <pre data-language="js">slice(begin?: number, end?: number): Iterable&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.slice">Iterable#slice</a></code><h4>Discussion</h4>
<p>If begin is negative, it is offset from the end of the Iterable. e.g. <code>slice(-2)</code> returns a Iterable of the last two entries. If it is not provided the new Iterable will begin at the beginning of this Iterable.</p> <p>If end is negative, it is offset from the end of the Iterable. e.g. <code>slice(0, -1)</code> returns an Iterable of everything but the last entry. If it is not provided, the new Iterable will continue through the end of this Iterable.</p> <p>If the requested slice is equivalent to the current Iterable, then it will return itself.</p> <h3 id="stack.rest">Stack#rest()</h3>
<p>Returns a new Iterable of the same type containing all entries except the first.</p> <pre data-language="js">rest(): Iterable&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.rest">Iterable#rest</a></code><h3 id="stack.butlast">Stack#butLast()</h3>
<p>Returns a new Iterable of the same type containing all entries except the last.</p> <pre data-language="js">butLast(): Iterable&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.butlast">Iterable#butLast</a></code><h3 id="stack.skip">Stack#skip()</h3>
<p>Returns a new Iterable of the same type which excludes the first <code>amount</code> entries from this Iterable.</p> <pre data-language="js">skip(amount: number): Iterable&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skip">Iterable#skip</a></code><h3 id="stack.skiplast">Stack#skipLast()</h3>
<p>Returns a new Iterable of the same type which excludes the last <code>amount</code> entries from this Iterable.</p> <pre data-language="js">skipLast(amount: number): Iterable&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skiplast">Iterable#skipLast</a></code><h3 id="stack.skipwhile">Stack#skipWhile()</h3>
<p>Returns a new Iterable of the same type which includes entries starting from when <code>predicate</code> first returns false.</p> <pre data-language="js">skipWhile(predicate: (value?: T, key?: number, iter?: Iterable&lt;number, T&gt;) =&gt; boolean,context?: any): Iterable&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skipwhile">Iterable#skipWhile</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .skipWhile(x =&gt; x.match(/g/))
// Seq [ 'cat', 'hat', 'god' ]</pre>
<h3 id="stack.skipuntil">Stack#skipUntil()</h3>
<p>Returns a new Iterable of the same type which includes entries starting from when <code>predicate</code> first returns true.</p> <pre data-language="js">skipUntil(predicate: (value?: T, key?: number, iter?: Iterable&lt;number, T&gt;) =&gt; boolean,context?: any): Iterable&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skipuntil">Iterable#skipUntil</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .skipUntil(x =&gt; x.match(/hat/))
// Seq [ 'hat', 'god' ]</pre>
<h3 id="stack.take">Stack#take()</h3>
<p>Returns a new Iterable of the same type which includes the first <code>amount</code> entries from this Iterable.</p> <pre data-language="js">take(amount: number): Iterable&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.take">Iterable#take</a></code><h3 id="stack.takelast">Stack#takeLast()</h3>
<p>Returns a new Iterable of the same type which includes the last <code>amount</code> entries from this Iterable.</p> <pre data-language="js">takeLast(amount: number): Iterable&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takelast">Iterable#takeLast</a></code><h3 id="stack.takewhile">Stack#takeWhile()</h3>
<p>Returns a new Iterable of the same type which includes entries from this Iterable as long as the <code>predicate</code> returns true.</p> <pre data-language="js">takeWhile(predicate: (value?: T, key?: number, iter?: Iterable&lt;number, T&gt;) =&gt; boolean,context?: any): Iterable&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takewhile">Iterable#takeWhile</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .takeWhile(x =&gt; x.match(/o/))
// Seq [ 'dog', 'frog' ]</pre>
<h3 id="stack.takeuntil">Stack#takeUntil()</h3>
<p>Returns a new Iterable of the same type which includes entries from this Iterable as long as the <code>predicate</code> returns false.</p> <pre data-language="js">takeUntil(predicate: (value?: T, key?: number, iter?: Iterable&lt;number, T&gt;) =&gt; boolean,context?: any): Iterable&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takeuntil">Iterable#takeUntil</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god').takeUntil(x =&gt; x.match(/at/))
// ['dog', 'frog']</pre>
<h2>Combination</h2>
<h3 id="stack.concat">Stack#concat()</h3>
<p>Returns a new Iterable of the same type with other values and iterable-like concatenated to this one.</p> <pre data-language="js">concat(...valuesOrIterables: any[]): Iterable&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.concat">Iterable#concat</a></code><h4>Discussion</h4>
<p>For Seqs, all entries will be present in the resulting iterable, even if they have the same key.</p> <h3 id="stack.flatten">Stack#flatten()</h3>
<p>Flattens nested Iterables.</p> <pre data-language="js">flatten(depth?: number): Iterable&lt;any, any&gt;
flatten(shallow?: boolean): Iterable&lt;any, any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.flatten">Iterable#flatten</a></code><h4>Discussion</h4>
<p>Will deeply flatten the Iterable by default, returning an Iterable of the same type, but a <code>depth</code> can be provided in the form of a number or boolean (where true means to shallowly flatten one level). A depth of 0 (or shallow: false) will deeply flatten.</p> <p>Flattens only others Iterable, not Arrays or Objects.</p> <p>Note: <code>flatten(true)</code> operates on Iterable<any iterable v="">&gt; and returns Iterable</any></p> <h3 id="stack.flatmap">Stack#flatMap()</h3>
<p>Flat-maps the Iterable, returning an Iterable of the same type.</p> <pre data-language="js">flatMap&lt;MK, MV&gt;(mapper: (value?: T,key?: number,iter?: Iterable&lt;number, T&gt;) =&gt; Iterable&lt;MK, MV&gt;,context?: any): Iterable&lt;MK, MV&gt;
flatMap&lt;MK, MV&gt;(mapper: (value?: T, key?: number, iter?: Iterable&lt;number, T&gt;) =&gt; any,context?: any): Iterable&lt;MK, MV&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.flatmap">Iterable#flatMap</a></code><h4>Discussion</h4>
<p>Similar to <code>iter.map(...).flatten(true)</code>.</p> <h3 id="stack.interpose">Stack#interpose()</h3>
<p>Returns an Iterable of the same type with <code>separator</code> between each item in this Iterable.</p> <pre data-language="js">interpose(separator: T): Iterable.Indexed&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.indexed.interpose">Iterable.Indexed#interpose</a></code><h3 id="stack.interleave">Stack#interleave()</h3>
<p>Returns an Iterable of the same type with the provided <code>iterables</code> interleaved into this iterable.</p> <pre data-language="js">interleave(...iterables: Array&lt;Iterable&lt;any, T&gt;&gt;): Iterable.Indexed&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.indexed.interleave">Iterable.Indexed#interleave</a></code><h4>Discussion</h4>
<p>The resulting Iterable includes the first item from each, then the second from each, etc.</p> <pre data-language="js">I.Seq.of(1,2,3).interleave(I.Seq.of('A','B','C'))
// Seq [ 1, 'A', 2, 'B', 3, 'C' ]</pre>
<p>The shortest Iterable stops interleave.</p> <pre data-language="js">I.Seq.of(1,2,3).interleave(
  I.Seq.of('A','B'),
  I.Seq.of('X','Y','Z')
)
// Seq [ 1, 'A', 'X', 2, 'B', 'Y' ]</pre>
<h3 id="stack.splice">Stack#splice()</h3>
<p>Splice returns a new indexed Iterable by replacing a region of this Iterable with new values. If values are not provided, it only skips the region to be removed.</p> <pre data-language="js">splice(index: number, removeNum: number, ...values: any[]): Iterable.Indexed&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.indexed.splice">Iterable.Indexed#splice</a></code><h4>Discussion</h4>
<p><code>index</code> may be a negative number, which indexes back from the end of the Iterable. <code>s.splice(-2)</code> splices after the second to last item.</p> <pre data-language="js">Seq(['a','b','c','d']).splice(1, 2, 'q', 'r', 's')
// Seq ['a', 'q', 'r', 's', 'd']</pre>
<h3 id="stack.zip">Stack#zip()</h3>
<p>Returns an Iterable of the same type "zipped" with the provided iterables.</p> <pre data-language="js">zip(...iterables: Array&lt;Iterable&lt;any, any&gt;&gt;): Iterable.Indexed&lt;any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.indexed.zip">Iterable.Indexed#zip</a></code><h4>Discussion</h4>
<p>Like <code><a href="#iterable.indexed.zipwith">zipWith</a></code>, but using the default <code>zipper</code>: creating an <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">Array</a></code>.</p> <pre data-language="js">var a = Seq.of(1, 2, 3);
var b = Seq.of(4, 5, 6);
var c = a.zip(b); // Seq [ [ 1, 4 ], [ 2, 5 ], [ 3, 6 ] ]</pre>
<h3 id="stack.zipwith">Stack#zipWith()</h3>
<p>Returns an Iterable of the same type "zipped" with the provided iterables by using a custom <code>zipper</code> function.</p> <pre data-language="js">zipWith&lt;U, Z&gt;(zipper: (value: T, otherValue: U) =&gt; Z,otherIterable: Iterable&lt;any, U&gt;): Iterable.Indexed&lt;Z&gt;
zipWith&lt;U, V, Z&gt;(zipper: (value: T, otherValue: U, thirdValue: V) =&gt; Z,otherIterable: Iterable&lt;any, U&gt;,thirdIterable: Iterable&lt;any, V&gt;): Iterable.Indexed&lt;Z&gt;
zipWith&lt;Z&gt;(zipper: (...any: Array&lt;any&gt;) =&gt; Z,...iterables: Array&lt;Iterable&lt;any, any&gt;&gt;): Iterable.Indexed&lt;Z&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.indexed.zipwith">Iterable.Indexed#zipWith</a></code><h4>Example</h4>
<pre data-language="js">var a = Seq.of(1, 2, 3);
var b = Seq.of(4, 5, 6);
var c = a.zipWith((a, b) =&gt; a + b, b); // Seq [ 5, 7, 9 ]</pre>
<h2>Reducing a value</h2>
<h3 id="stack.reduce">Stack#reduce()</h3>
<p>Reduces the Iterable to a value by calling the <code>reducer</code> for every entry in the Iterable and passing along the reduced value.</p> <pre data-language="js">reduce&lt;R&gt;(reducer: (reduction?: R,value?: T,key?: number,iter?: Iterable&lt;number, T&gt;) =&gt; R,initialReduction?: R,context?: any): R
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reduce">Iterable#reduce</a></code><h4>see</h4>
<p><code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">Array#reduce</a></code>.</p> <h4>Discussion</h4>
<p>If <code>initialReduction</code> is not provided, or is null, the first item in the Iterable will be used.</p> <h3 id="stack.reduceright">Stack#reduceRight()</h3>
<p>Reduces the Iterable in reverse (from the right side).</p> <pre data-language="js">reduceRight&lt;R&gt;(reducer: (reduction?: R,value?: T,key?: number,iter?: Iterable&lt;number, T&gt;) =&gt; R,initialReduction?: R,context?: any): R
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reduceright">Iterable#reduceRight</a></code><h4>Discussion</h4>
<p>Note: Similar to this.reverse().reduce(), and provided for parity with <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight">Array#reduceRight</a></code>.</p> <h3 id="stack.every">Stack#every()</h3>
<p>True if <code>predicate</code> returns true for all entries in the Iterable.</p> <pre data-language="js">every(predicate: (value?: T, key?: number, iter?: Iterable&lt;number, T&gt;) =&gt; boolean,context?: any): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.every">Iterable#every</a></code><h3 id="stack.some">Stack#some()</h3>
<p>True if <code>predicate</code> returns true for any entry in the Iterable.</p> <pre data-language="js">some(predicate: (value?: T, key?: number, iter?: Iterable&lt;number, T&gt;) =&gt; boolean,context?: any): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.some">Iterable#some</a></code><h3 id="stack.join">Stack#join()</h3>
<p>Joins values together as a string, inserting a separator between each. The default separator is <code>","</code>.</p> <pre data-language="js">join(separator?: string): string
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.join">Iterable#join</a></code><h3 id="stack.isempty">Stack#isEmpty()</h3>
<p>Returns true if this Iterable includes no values.</p> <pre data-language="js">isEmpty(): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.isempty">Iterable#isEmpty</a></code><h4>Discussion</h4>
<p>For some lazy <code><a href="#seq">Seq</a></code>, <code>isEmpty</code> might need to iterate to determine emptiness. At most one iteration will occur.</p> <h3 id="stack.count">Stack#count()</h3>
<p>Returns the size of this Iterable.</p> <pre data-language="js">count(): number
count(predicate: (value?: T, key?: number, iter?: Iterable&lt;number, T&gt;) =&gt; boolean,context?: any): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.count">Iterable#count</a></code><h4>Discussion</h4>
<p>Regardless of if this Iterable can describe its size lazily (some Seqs cannot), this method will always return the correct size. E.g. it evaluates a lazy <code><a href="#seq">Seq</a></code> if necessary.</p> <p>If <code>predicate</code> is provided, then this returns the count of entries in the Iterable for which the <code>predicate</code> returns true.</p> <h3 id="stack.countby">Stack#countBy()</h3>
<p>Returns a <code><a href="#seq.keyed">Seq.Keyed</a></code> of counts, grouped by the return value of the <code>grouper</code> function.</p> <pre data-language="js">countBy&lt;G&gt;(grouper: (value?: T, key?: number, iter?: Iterable&lt;number, T&gt;) =&gt; G,context?: any): Map&lt;G, number&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.countby">Iterable#countBy</a></code><h4>Discussion</h4>
<p>Note: This is not a lazy operation.</p> <h2>Search for value</h2>
<h3 id="stack.find">Stack#find()</h3>
<p>Returns the first value for which the <code>predicate</code> returns true.</p> <pre data-language="js">find(predicate: (value?: T, key?: number, iter?: Iterable&lt;number, T&gt;) =&gt; boolean,context?: any,notSetValue?: T): T
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.find">Iterable#find</a></code><h3 id="stack.findlast">Stack#findLast()</h3>
<p>Returns the last value for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLast(predicate: (value?: T, key?: number, iter?: Iterable&lt;number, T&gt;) =&gt; boolean,context?: any,notSetValue?: T): T
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlast">Iterable#findLast</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="stack.findentry">Stack#findEntry()</h3>
<p>Returns the first [key, value] entry for which the <code>predicate</code> returns true.</p> <pre data-language="js">findEntry(predicate: (value?: T, key?: number, iter?: Iterable&lt;number, T&gt;) =&gt; boolean,context?: any,notSetValue?: T): Array&lt;any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findentry">Iterable#findEntry</a></code><h3 id="stack.findlastentry">Stack#findLastEntry()</h3>
<p>Returns the last [key, value] entry for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLastEntry(predicate: (value?: T, key?: number, iter?: Iterable&lt;number, T&gt;) =&gt; boolean,context?: any,notSetValue?: T): Array&lt;any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlastentry">Iterable#findLastEntry</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="stack.findkey">Stack#findKey()</h3>
<p>Returns the key for which the <code>predicate</code> returns true.</p> <pre data-language="js">findKey(predicate: (value?: T,key?: number,iter?: Iterable.Keyed&lt;number, T&gt;) =&gt; boolean,context?: any): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findkey">Iterable#findKey</a></code><h3 id="stack.findlastkey">Stack#findLastKey()</h3>
<p>Returns the last key for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLastKey(predicate: (value?: T,key?: number,iter?: Iterable.Keyed&lt;number, T&gt;) =&gt; boolean,context?: any): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlastkey">Iterable#findLastKey</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="stack.keyof">Stack#keyOf()</h3>
<p>Returns the key associated with the search value, or undefined.</p> <pre data-language="js">keyOf(searchValue: T): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyof">Iterable#keyOf</a></code><h3 id="stack.lastkeyof">Stack#lastKeyOf()</h3>
<p>Returns the last key associated with the search value, or undefined.</p> <pre data-language="js">lastKeyOf(searchValue: T): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.lastkeyof">Iterable#lastKeyOf</a></code><h3 id="stack.max">Stack#max()</h3>
<p>Returns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> <pre data-language="js">max(comparator?: (valueA: T, valueB: T) =&gt; number): T
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.max">Iterable#max</a></code><h4>Discussion</h4>
<p>The <code>comparator</code> is used in the same way as <code><a href="#iterable.sort">Iterable#sort</a></code>. If it is not provided, the default comparator is <code>&gt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code>max</code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&gt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> <h3 id="stack.maxby">Stack#maxBy()</h3>
<p>Like <code><a href="#iterable.max">max</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> <pre data-language="js">maxBy&lt;C&gt;(comparatorValueMapper: (value?: T,key?: number,iter?: Iterable&lt;number, T&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): T
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.maxby">Iterable#maxBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.maxBy(hitter =&gt; hitter.avgHits);</pre>
<h3 id="stack.min">Stack#min()</h3>
<p>Returns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> <pre data-language="js">min(comparator?: (valueA: T, valueB: T) =&gt; number): T
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.min">Iterable#min</a></code><h4>Discussion</h4>
<p>The <code>comparator</code> is used in the same way as <code><a href="#iterable.sort">Iterable#sort</a></code>. If it is not provided, the default comparator is <code>&lt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code>min</code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&lt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> <h3 id="stack.minby">Stack#minBy()</h3>
<p>Like <code><a href="#iterable.min">min</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> <pre data-language="js">minBy&lt;C&gt;(comparatorValueMapper: (value?: T,key?: number,iter?: Iterable&lt;number, T&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): T
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.minby">Iterable#minBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.minBy(hitter =&gt; hitter.avgHits);</pre>
<h3 id="stack.indexof">Stack#indexOf()</h3>
<p>Returns the first index at which a given value can be found in the Iterable, or -1 if it is not present.</p> <pre data-language="js">indexOf(searchValue: T): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.indexed.indexof">Iterable.Indexed#indexOf</a></code><h3 id="stack.lastindexof">Stack#lastIndexOf()</h3>
<p>Returns the last index at which a given value can be found in the Iterable, or -1 if it is not present.</p> <pre data-language="js">lastIndexOf(searchValue: T): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.indexed.lastindexof">Iterable.Indexed#lastIndexOf</a></code><h3 id="stack.findindex">Stack#findIndex()</h3>
<p>Returns the first index in the Iterable where a value satisfies the provided predicate function. Otherwise -1 is returned.</p> <pre data-language="js">findIndex(predicate: (value?: T, index?: number, iter?: Iterable.Indexed&lt;T&gt;) =&gt; boolean,context?: any): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.indexed.findindex">Iterable.Indexed#findIndex</a></code><h3 id="stack.findlastindex">Stack#findLastIndex()</h3>
<p>Returns the last index in the Iterable where a value satisfies the provided predicate function. Otherwise -1 is returned.</p> <pre data-language="js">findLastIndex(predicate: (value?: T, index?: number, iter?: Iterable.Indexed&lt;T&gt;) =&gt; boolean,context?: any): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.indexed.findlastindex">Iterable.Indexed#findLastIndex</a></code><h2>Comparison</h2>
<h3 id="stack.issubset">Stack#isSubset()</h3>
<p>True if <code>iter</code> includes every value in this Iterable.</p> <pre data-language="js">isSubset(iter: Iterable&lt;any, T&gt;): boolean
isSubset(iter: Array&lt;T&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.issubset">Iterable#isSubset</a></code><h3 id="stack.issuperset">Stack#isSuperset()</h3>
<p>True if this Iterable includes every value in <code>iter</code>.</p> <pre data-language="js">isSuperset(iter: Iterable&lt;any, T&gt;): boolean
isSuperset(iter: Array&lt;T&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.issuperset">Iterable#isSuperset</a></code><h1 id="range()">Range()</h1>
<p>Returns a Seq.Indexed of numbers from <code>start</code> (inclusive) to <code>end</code> (exclusive), by <code>step</code>, where <code>start</code> defaults to 0, <code>step</code> to 1, and <code>end</code> to infinity. When <code>start</code> is equal to <code>end</code>, returns empty range.</p> <pre data-language="js">Range(start?: number, end?: number, step?: number): Seq.Indexed&lt;number&gt;
</pre>
<h4>Example</h4>
<pre data-language="js">Range() // [0,1,2,3,...]
Range(10) // [10,11,12,13,...]
Range(10,15) // [10,11,12,13,14]
Range(10,30,5) // [10,15,20,25]
Range(30,10,5) // [30,25,20,15]
Range(30,30,5) // []</pre>
<h1 id="repeat()">Repeat()</h1>
<p>Returns a Seq.Indexed of <code>value</code> repeated <code>times</code> times. When <code>times</code> is not defined, returns an infinite <code><a href="#seq">Seq</a></code> of <code>value</code>.</p> <pre data-language="js">Repeat&lt;T&gt;(value: T, times?: number): Seq.Indexed&lt;T&gt;
</pre>
<h4>Example</h4>
<pre data-language="js">Repeat('foo') // ['foo','foo','foo',...]
Repeat('bar',4) // ['bar','bar','bar','bar']</pre>
<h1 id="record">Record</h1>
<p>Creates a new Class which produces Record instances. A record is similar to a JS object, but enforce a specific set of allowed string keys, and have default values.</p> <h4>Example</h4>
<pre data-language="js">var ABRecord = Record({a:1, b:2})
var myRecord = new ABRecord({b:3})</pre>
<p>Records always have a value for the keys they define. <code>remove</code>ing a key from a record simply resets it to the default value for that key.</p> <pre data-language="js">myRecord.size // 2
myRecord.get('a') // 1
myRecord.get('b') // 3
myRecordWithoutB = myRecord.remove('b')
myRecordWithoutB.get('b') // 2
myRecordWithoutB.size // 2</pre>
<p>Values provided to the constructor not found in the Record type will be ignored. For example, in this case, ABRecord is provided a key "x" even though only "a" and "b" have been defined. The value for "x" will be ignored for this record.</p> <pre data-language="js">var myRecord = new ABRecord({b:3, x:10})
myRecord.get('x') // undefined</pre>
<p>Because Records have a known set of string keys, property get access works as expected, however property sets will throw an Error.</p> <p>Note: IE8 does not support property access. Only use <code>get()</code> when supporting IE8.</p> <pre data-language="js">myRecord.b // 3
myRecord.b = 5 // throws Error</pre>
<p>Record Classes can be extended as well, allowing for custom methods on your Record. This is not a common pattern in functional environments, but is in many JS programs.</p> <p>Note: TypeScript does not support this type of subclassing.</p> <pre data-language="js">class ABRecord extends Record({a:1,b:2}) {
  getAB() {
    return this.a + this.b;
  }
}

var myRecord = new ABRecord({b: 3})
myRecord.getAB() // 4</pre>
<h2>Construction</h2>
<h3 id="record()">Record()</h3>
<pre data-language="js">Record(defaultValues: {[key: string]: any}, name?: string): Record.Class
</pre>
<h2>Types</h2>
<a href="#record.class">Record.Class</a><h1 id="record.class">Record.Class</h1>
<pre data-language="js">class Record.Class</pre>
<h1 id="seq">Seq</h1>
<p>Represents a sequence of values, but may not be backed by a concrete data structure.</p> <pre data-language="js">class Seq&lt;K, V&gt; extends Iterable&lt;K, V&gt;</pre>
<h4>Discussion</h4>
<p><strong>Seq is immutable</strong>  Once a Seq is created, it cannot be changed, appended to, rearranged or otherwise modified. Instead, any mutative method called on a <code>Seq</code> will return a new <code>Seq</code>.</p> <p><strong>Seq is lazy</strong>  Seq does as little work as necessary to respond to any method call. Values are often created during iteration, including implicit iteration when reducing or converting to a concrete data structure such as a <code><a href="#list">List</a></code> or JavaScript <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">Array</a></code>.</p> <p>For example, the following performs no work, because the resulting Seq's values are never iterated:</p> <pre data-language="js">var oddSquares = Immutable.Seq.of(1,2,3,4,5,6,7,8)
  .filter(x =&gt; x % 2).map(x =&gt; x * x);</pre>
<p>Once the Seq is used, it performs only the work necessary. In this example, no intermediate data structures are ever created, filter is only called three times, and map is only called once:</p> <pre data-language="js">console.log(oddSquares.get(1)); // 9</pre>
<p>Seq allows for the efficient chaining of operations, allowing for the expression of logic that can otherwise be very tedious:</p> <pre data-language="js">Immutable.Seq({a:1, b:1, c:1})
  .flip().map(key =&gt; key.toUpperCase()).flip().toObject();
// Map { A: 1, B: 1, C: 1 }</pre>
<p>As well as expressing logic that would otherwise be memory or time limited:</p> <pre data-language="js">Immutable.Range(1, Infinity)
  .skip(1000)
  .map(n =&gt; -n)
  .filter(n =&gt; n % 2 === 0)
  .take(2)
  .reduce((r, n) =&gt; r * n, 1);
// 1006008</pre>
<p>Seq is often used to provide a rich collection API to JavaScript Object.</p> <pre data-language="js">Immutable.Seq({ x: 0, y: 1, z: 2 }).map(v =&gt; v * 2).toObject();
// { x: 0, y: 2, z: 4 }</pre>
<h2>Construction</h2>
<h3 id="seq()">Seq()</h3>
<p>Creates a Seq.</p> <pre data-language="js">Seq&lt;K, V&gt;(): Seq&lt;K, V&gt;
Seq&lt;K, V&gt;(seq: Seq&lt;K, V&gt;): Seq&lt;K, V&gt;
Seq&lt;K, V&gt;(iterable: Iterable&lt;K, V&gt;): Seq&lt;K, V&gt;
Seq&lt;T&gt;(array: Array&lt;T&gt;): Seq.Indexed&lt;T&gt;
Seq&lt;V&gt;(obj: {[key: string]: V}): Seq.Keyed&lt;string, V&gt;
Seq&lt;T&gt;(iterator: Iterator&lt;T&gt;): Seq.Indexed&lt;T&gt;
Seq&lt;T&gt;(iterable: Object): Seq.Indexed&lt;T&gt;
</pre>
<h4>Discussion</h4>
<p>Returns a particular kind of <code>Seq</code> based on the input.</p> <ul> <li>If a <code>Seq</code>, that same <code>Seq</code>.</li> <li>If an <code><a href="#iterable">Iterable</a></code>, a <code>Seq</code> of the same kind (Keyed, Indexed, or Set).</li> <li>If an Array-like, an <code><a href="#seq.indexed">Seq.Indexed</a></code>.</li> <li>If an Object with an Iterator, an <code><a href="#seq.indexed">Seq.Indexed</a></code>.</li> <li>If an Iterator, an <code><a href="#seq.indexed">Seq.Indexed</a></code>.</li> <li>If an Object, a <code><a href="#seq.keyed">Seq.Keyed</a></code>.</li> </ul> <h2>Static methods</h2>
<h3 id="seq.isseq">Seq.isSeq()</h3>
<p>True if <code>maybeSeq</code> is a Seq, it is not backed by a concrete structure such as Map, List, or Set.</p> <pre data-language="js">Seq.isSeq(maybeSeq: any): boolean
</pre>
<h3 id="seq.of">Seq.of()</h3>
<p>Returns a Seq of the values provided. Alias for <code>Seq.Indexed.of()</code>.</p> <pre data-language="js">Seq.of&lt;T&gt;(...values: T[]): Seq.Indexed&lt;T&gt;
</pre>
<h2>Types</h2>
<a href="#seq.keyed">Seq.Keyed</a><h2>Members</h2>
<h3 id="seq.size">Seq#size</h3>
<pre data-language="js">size: number</pre>
<h2>Force evaluation</h2>
<h3 id="seq.cacheresult">Seq#cacheResult()</h3>
<p>Because Sequences are lazy and designed to be chained together, they do not cache their results. For example, this map function is called a total of 6 times, as each <code><a href="#seq.join">join</a></code> iterates the Seq of three values.</p> <pre data-language="js">cacheResult(): Seq&lt;K, V&gt;
</pre>
<h4>Example</h4>
<pre data-language="js">var squares = Seq.of(1,2,3).map(x =&gt; x * x);
squares.join() + squares.join();</pre>
<p>If you know a <code>Seq</code> will be used multiple times, it may be more efficient to first cache it in memory. Here, the map function is called only 3 times.</p> <pre data-language="js">var squares = Seq.of(1,2,3).map(x =&gt; x * x).cacheResult();
squares.join() + squares.join();</pre>
<p>Use this method judiciously, as it must fully evaluate a Seq which can be a burden on memory and possibly performance.</p> <p>Note: after calling <code>cacheResult</code>, a Seq will always have a <code><a href="#seq.size">size</a></code>.</p> <h2>Value equality</h2>
<h3 id="seq.equals">Seq#equals()</h3>
<p>True if this and the other Iterable have value equality, as defined by <code><a href="#is">Immutable.is()</a></code>.</p> <pre data-language="js">equals(other: Iterable&lt;K, V&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.equals">Iterable#equals</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Immutable.is(this, other)</code>, but provided to allow for chained expressions.</p> <h3 id="seq.hashcode">Seq#hashCode()</h3>
<p>Computes and returns the hashed identity for this Iterable.</p> <pre data-language="js">hashCode(): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.hashcode">Iterable#hashCode</a></code><h4>Discussion</h4>
<p>The <code>hashCode</code> of an Iterable is used to determine potential equality, and is used when adding this to a <code><a href="#iterable.set">Set</a></code> or as a key in a <code><a href="#map">Map</a></code>, enabling lookup via a different instance.</p> <pre data-language="js">var a = List.of(1, 2, 3);
var b = List.of(1, 2, 3);
assert(a !== b); // different instances
var set = Set.of(a);
assert(set.has(b) === true);</pre>
<p>If two values have the same <code>hashCode</code>, they are <a href="http://en.wikipedia.org/wiki/Collision_(computer_science)">not guaranteed to be equal</a>. If two values have different <code>hashCode</code>s, they must not be equal.</p> <h2>Reading values</h2>
<h3 id="seq.get">Seq#get()</h3>
<p>Returns the value associated with the provided key, or notSetValue if the Iterable does not contain this key.</p> <pre data-language="js">get(key: K, notSetValue?: V): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.get">Iterable#get</a></code><h4>Discussion</h4>
<p>Note: it is possible a key may be associated with an <code>undefined</code> value, so if <code>notSetValue</code> is not provided and this method returns <code>undefined</code>, that does not guarantee the key was not found.</p> <h3 id="seq.has">Seq#has()</h3>
<p>True if a key exists within this <code>Iterable</code>, using <code><a href="#is">Immutable.is</a></code> to determine equality</p> <pre data-language="js">has(key: K): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.has">Iterable#has</a></code><h3 id="seq.includes">Seq#includes()</h3>
<p>True if a value exists within this <code>Iterable</code>, using <code><a href="#is">Immutable.is</a></code> to determine equality</p> <pre data-language="js">includes(value: V): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.includes">Iterable#includes</a></code><h4>alias</h4>
<code>contains()</code><h3 id="seq.first">Seq#first()</h3>
<p>The first value in the Iterable.</p> <pre data-language="js">first(): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.first">Iterable#first</a></code><h3 id="seq.last">Seq#last()</h3>
<p>The last value in the Iterable.</p> <pre data-language="js">last(): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.last">Iterable#last</a></code><h2>Reading deep values</h2>
<h3 id="seq.getin">Seq#getIn()</h3>
<p>Returns the value found by following a path of keys or indices through nested Iterables.</p> <pre data-language="js">getIn(searchKeyPath: Array&lt;any&gt;, notSetValue?: any): any
getIn(searchKeyPath: Iterable&lt;any, any&gt;, notSetValue?: any): any
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.getin">Iterable#getIn</a></code><h3 id="seq.hasin">Seq#hasIn()</h3>
<p>True if the result of following a path of keys or indices through nested Iterables results in a set value.</p> <pre data-language="js">hasIn(searchKeyPath: Array&lt;any&gt;): boolean
hasIn(searchKeyPath: Iterable&lt;any, any&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.hasin">Iterable#hasIn</a></code><h2>Conversion to JavaScript types</h2>
<h3 id="seq.tojs">Seq#toJS()</h3>
<p>Deeply converts this Iterable to equivalent JS.</p> <pre data-language="js">toJS(): any
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tojs">Iterable#toJS</a></code><h4>alias</h4>
<code>toJSON()</code><h4>Discussion</h4>
<p><code>Iterable.Indexeds</code>, and <code>Iterable.Sets</code> become Arrays, while <code>Iterable.Keyeds</code> become Objects.</p> <h3 id="seq.toarray">Seq#toArray()</h3>
<p>Shallowly converts this iterable to an Array, discarding keys.</p> <pre data-language="js">toArray(): Array&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toarray">Iterable#toArray</a></code><h3 id="seq.toobject">Seq#toObject()</h3>
<p>Shallowly converts this Iterable to an Object.</p> <pre data-language="js">toObject(): {[key: string]: V}
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toobject">Iterable#toObject</a></code><h4>Discussion</h4>
<p>Throws if keys are not strings.</p> <h2>Conversion to Collections</h2>
<h3 id="seq.tomap">Seq#toMap()</h3>
<p>Converts this Iterable to a Map, Throws if keys are not hashable.</p> <pre data-language="js">toMap(): Map&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tomap">Iterable#toMap</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Map(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="seq.toorderedmap">Seq#toOrderedMap()</h3>
<p>Converts this Iterable to a Map, maintaining the order of iteration.</p> <pre data-language="js">toOrderedMap(): OrderedMap&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toorderedmap">Iterable#toOrderedMap</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>OrderedMap(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="seq.toset">Seq#toSet()</h3>
<p>Converts this Iterable to a Set, discarding keys. Throws if values are not hashable.</p> <pre data-language="js">toSet(): Set&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toset">Iterable#toSet</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Set(this)</code>, but provided to allow for chained expressions.</p> <h3 id="seq.toorderedset">Seq#toOrderedSet()</h3>
<p>Converts this Iterable to a Set, maintaining the order of iteration and discarding keys.</p> <pre data-language="js">toOrderedSet(): OrderedSet&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toorderedset">Iterable#toOrderedSet</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>OrderedSet(this.valueSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="seq.tolist">Seq#toList()</h3>
<p>Converts this Iterable to a List, discarding keys.</p> <pre data-language="js">toList(): List&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tolist">Iterable#toList</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>List(this)</code>, but provided to allow for chained expressions.</p> <h3 id="seq.tostack">Seq#toStack()</h3>
<p>Converts this Iterable to a Stack, discarding keys. Throws if values are not hashable.</p> <pre data-language="js">toStack(): Stack&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tostack">Iterable#toStack</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Stack(this)</code>, but provided to allow for chained expressions.</p> <h2>Conversion to Seq</h2>
<h3 id="seq.toseq">Seq#toSeq()</h3>
<p>Converts this Iterable to a Seq of the same kind (indexed, keyed, or set).</p> <pre data-language="js">toSeq(): Seq&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toseq">Iterable#toSeq</a></code><h3 id="seq.tokeyedseq">Seq#toKeyedSeq()</h3>
<p>Returns a Seq.Keyed from this Iterable where indices are treated as keys.</p> <pre data-language="js">toKeyedSeq(): Seq.Keyed&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tokeyedseq">Iterable#toKeyedSeq</a></code><h4>Discussion</h4>
<p>This is useful if you want to operate on an Iterable.Indexed and preserve the [index, value] pairs.</p> <p>The returned Seq will have identical iteration order as this Iterable.</p> <p>Example:</p> <pre data-language="js">var indexedSeq = Immutable.Seq.of('A', 'B', 'C');
indexedSeq.filter(v =&gt; v === 'B').toString() // Seq [ 'B' ]
var keyedSeq = indexedSeq.toKeyedSeq();
keyedSeq.filter(v =&gt; v === 'B').toString() // Seq { 1: 'B' }</pre>
<h3 id="seq.toindexedseq">Seq#toIndexedSeq()</h3>
<p>Returns an Seq.Indexed of the values of this Iterable, discarding keys.</p> <pre data-language="js">toIndexedSeq(): Seq.Indexed&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toindexedseq">Iterable#toIndexedSeq</a></code><h3 id="seq.tosetseq">Seq#toSetSeq()</h3>
<p>Returns a Seq.Set of the values of this Iterable, discarding keys.</p> <pre data-language="js">toSetSeq(): Seq.Set&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tosetseq">Iterable#toSetSeq</a></code><h2>Iterators</h2>
<h3 id="seq.keys">Seq#keys()</h3>
<p>An iterator of this <code>Iterable</code>'s keys.</p> <pre data-language="js">keys(): Iterator&lt;K&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keys">Iterable#keys</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.keyseq">keySeq</a></code> instead, if this is what you want.</p> <h3 id="seq.values">Seq#values()</h3>
<p>An iterator of this <code>Iterable</code>'s values.</p> <pre data-language="js">values(): Iterator&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.values">Iterable#values</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.valueseq">valueSeq</a></code> instead, if this is what you want.</p> <h3 id="seq.entries">Seq#entries()</h3>
<p>An iterator of this <code>Iterable</code>'s entries as <code>[key, value]</code> tuples.</p> <pre data-language="js">entries(): Iterator&lt;Array&lt;any&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.entries">Iterable#entries</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.entryseq">entrySeq</a></code> instead, if this is what you want.</p> <h2>Iterables (Seq)</h2>
<h3 id="seq.keyseq">Seq#keySeq()</h3>
<p>Returns a new Seq.Indexed of the keys of this Iterable, discarding values.</p> <pre data-language="js">keySeq(): Seq.Indexed&lt;K&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyseq">Iterable#keySeq</a></code><h3 id="seq.valueseq">Seq#valueSeq()</h3>
<p>Returns an Seq.Indexed of the values of this Iterable, discarding keys.</p> <pre data-language="js">valueSeq(): Seq.Indexed&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.valueseq">Iterable#valueSeq</a></code><h3 id="seq.entryseq">Seq#entrySeq()</h3>
<p>Returns a new Seq.Indexed of [key, value] tuples.</p> <pre data-language="js">entrySeq(): Seq.Indexed&lt;Array&lt;any&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.entryseq">Iterable#entrySeq</a></code><h2>Sequence algorithms</h2>
<h3 id="seq.map">Seq#map()</h3>
<p>Returns a new Iterable of the same type with values passed through a <code>mapper</code> function.</p> <pre data-language="js">map&lt;M&gt;(mapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; M,context?: any): Iterable&lt;K, M&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.map">Iterable#map</a></code><h4>Example</h4>
<pre data-language="js">Seq({ a: 1, b: 2 }).map(x =&gt; 10 * x)
// Seq { a: 10, b: 20 }</pre>
<h3 id="seq.filter">Seq#filter()</h3>
<p>Returns a new Iterable of the same type with only the entries for which the <code>predicate</code> function returns true.</p> <pre data-language="js">filter(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.filter">Iterable#filter</a></code><h4>Example</h4>
<pre data-language="js">Seq({a:1,b:2,c:3,d:4}).filter(x =&gt; x % 2 === 0)
// Seq { b: 2, d: 4 }</pre>
<h3 id="seq.filternot">Seq#filterNot()</h3>
<p>Returns a new Iterable of the same type with only the entries for which the <code>predicate</code> function returns false.</p> <pre data-language="js">filterNot(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.filternot">Iterable#filterNot</a></code><h4>Example</h4>
<pre data-language="js">Seq({a:1,b:2,c:3,d:4}).filterNot(x =&gt; x % 2 === 0)
// Seq { a: 1, c: 3 }</pre>
<h3 id="seq.reverse">Seq#reverse()</h3>
<p>Returns a new Iterable of the same type in reverse order.</p> <pre data-language="js">reverse(): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reverse">Iterable#reverse</a></code><h3 id="seq.sort">Seq#sort()</h3>
<p>Returns a new Iterable of the same type which includes the same entries, stably sorted by using a <code>comparator</code>.</p> <pre data-language="js">sort(comparator?: (valueA: V, valueB: V) =&gt; number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.sort">Iterable#sort</a></code><h4>Discussion</h4>
<p>If a <code>comparator</code> is not provided, a default comparator uses <code>&lt;</code> and <code>&gt;</code>.</p> <p><code>comparator(valueA, valueB)</code>:</p> <ul> <li>Returns <code>0</code> if the elements should not be swapped.</li> <li>Returns <code>-1</code> (or any negative number) if <code>valueA</code> comes before <code>valueB</code>
</li> <li>Returns <code>1</code> (or any positive number) if <code>valueA</code> comes after <code>valueB</code>
</li> <li>Is pure, i.e. it must always return the same value for the same pair of values.</li> </ul> <p>When sorting collections which have no defined order, their ordered equivalents will be returned. e.g. <code>map.sort()</code> returns OrderedMap.</p> <h3 id="seq.sortby">Seq#sortBy()</h3>
<p>Like <code><a href="#iterable.sort">sort</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for sorting by more sophisticated means:</p> <pre data-language="js">sortBy&lt;C&gt;(comparatorValueMapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.sortby">Iterable#sortBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.sortBy(hitter =&gt; hitter.avgHits);</pre>
<h3 id="seq.groupby">Seq#groupBy()</h3>
<p>Returns a <code><a href="#iterable.keyed">Iterable.Keyed</a></code> of <code>Iterable.Keyeds</code>, grouped by the return value of the <code>grouper</code> function.</p> <pre data-language="js">groupBy&lt;G&gt;(grouper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; G,context?: any): Seq.Keyed&lt;G, Iterable&lt;K, V&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.groupby">Iterable#groupBy</a></code><h4>Discussion</h4>
<p>Note: This is always an eager operation.</p> <h2>Side effects</h2>
<h3 id="seq.foreach">Seq#forEach()</h3>
<p>The <code>sideEffect</code> is executed for every entry in the Iterable.</p> <pre data-language="js">forEach(sideEffect: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; any,context?: any): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.foreach">Iterable#forEach</a></code><h4>Discussion</h4>
<p>Unlike <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">Array#forEach</a></code>, if any call of <code>sideEffect</code> returns <code>false</code>, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).</p> <h2>Creating subsets</h2>
<h3 id="seq.slice">Seq#slice()</h3>
<p>Returns a new Iterable of the same type representing a portion of this Iterable from start up to but not including end.</p> <pre data-language="js">slice(begin?: number, end?: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.slice">Iterable#slice</a></code><h4>Discussion</h4>
<p>If begin is negative, it is offset from the end of the Iterable. e.g. <code>slice(-2)</code> returns a Iterable of the last two entries. If it is not provided the new Iterable will begin at the beginning of this Iterable.</p> <p>If end is negative, it is offset from the end of the Iterable. e.g. <code>slice(0, -1)</code> returns an Iterable of everything but the last entry. If it is not provided, the new Iterable will continue through the end of this Iterable.</p> <p>If the requested slice is equivalent to the current Iterable, then it will return itself.</p> <h3 id="seq.rest">Seq#rest()</h3>
<p>Returns a new Iterable of the same type containing all entries except the first.</p> <pre data-language="js">rest(): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.rest">Iterable#rest</a></code><h3 id="seq.butlast">Seq#butLast()</h3>
<p>Returns a new Iterable of the same type containing all entries except the last.</p> <pre data-language="js">butLast(): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.butlast">Iterable#butLast</a></code><h3 id="seq.skip">Seq#skip()</h3>
<p>Returns a new Iterable of the same type which excludes the first <code>amount</code> entries from this Iterable.</p> <pre data-language="js">skip(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skip">Iterable#skip</a></code><h3 id="seq.skiplast">Seq#skipLast()</h3>
<p>Returns a new Iterable of the same type which excludes the last <code>amount</code> entries from this Iterable.</p> <pre data-language="js">skipLast(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skiplast">Iterable#skipLast</a></code><h3 id="seq.skipwhile">Seq#skipWhile()</h3>
<p>Returns a new Iterable of the same type which includes entries starting from when <code>predicate</code> first returns false.</p> <pre data-language="js">skipWhile(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skipwhile">Iterable#skipWhile</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .skipWhile(x =&gt; x.match(/g/))
// Seq [ 'cat', 'hat', 'god' ]</pre>
<h3 id="seq.skipuntil">Seq#skipUntil()</h3>
<p>Returns a new Iterable of the same type which includes entries starting from when <code>predicate</code> first returns true.</p> <pre data-language="js">skipUntil(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skipuntil">Iterable#skipUntil</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .skipUntil(x =&gt; x.match(/hat/))
// Seq [ 'hat', 'god' ]</pre>
<h3 id="seq.take">Seq#take()</h3>
<p>Returns a new Iterable of the same type which includes the first <code>amount</code> entries from this Iterable.</p> <pre data-language="js">take(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.take">Iterable#take</a></code><h3 id="seq.takelast">Seq#takeLast()</h3>
<p>Returns a new Iterable of the same type which includes the last <code>amount</code> entries from this Iterable.</p> <pre data-language="js">takeLast(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takelast">Iterable#takeLast</a></code><h3 id="seq.takewhile">Seq#takeWhile()</h3>
<p>Returns a new Iterable of the same type which includes entries from this Iterable as long as the <code>predicate</code> returns true.</p> <pre data-language="js">takeWhile(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takewhile">Iterable#takeWhile</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .takeWhile(x =&gt; x.match(/o/))
// Seq [ 'dog', 'frog' ]</pre>
<h3 id="seq.takeuntil">Seq#takeUntil()</h3>
<p>Returns a new Iterable of the same type which includes entries from this Iterable as long as the <code>predicate</code> returns false.</p> <pre data-language="js">takeUntil(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takeuntil">Iterable#takeUntil</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god').takeUntil(x =&gt; x.match(/at/))
// ['dog', 'frog']</pre>
<h2>Combination</h2>
<h3 id="seq.concat">Seq#concat()</h3>
<p>Returns a new Iterable of the same type with other values and iterable-like concatenated to this one.</p> <pre data-language="js">concat(...valuesOrIterables: any[]): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.concat">Iterable#concat</a></code><h4>Discussion</h4>
<p>For Seqs, all entries will be present in the resulting iterable, even if they have the same key.</p> <h3 id="seq.flatten">Seq#flatten()</h3>
<p>Flattens nested Iterables.</p> <pre data-language="js">flatten(depth?: number): Iterable&lt;any, any&gt;
flatten(shallow?: boolean): Iterable&lt;any, any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.flatten">Iterable#flatten</a></code><h4>Discussion</h4>
<p>Will deeply flatten the Iterable by default, returning an Iterable of the same type, but a <code>depth</code> can be provided in the form of a number or boolean (where true means to shallowly flatten one level). A depth of 0 (or shallow: false) will deeply flatten.</p> <p>Flattens only others Iterable, not Arrays or Objects.</p> <p>Note: <code>flatten(true)</code> operates on Iterable<any iterable v="">&gt; and returns Iterable</any></p> <h3 id="seq.flatmap">Seq#flatMap()</h3>
<p>Flat-maps the Iterable, returning an Iterable of the same type.</p> <pre data-language="js">flatMap&lt;MK, MV&gt;(mapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; Iterable&lt;MK, MV&gt;,context?: any): Iterable&lt;MK, MV&gt;
flatMap&lt;MK, MV&gt;(mapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; any,context?: any): Iterable&lt;MK, MV&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.flatmap">Iterable#flatMap</a></code><h4>Discussion</h4>
<p>Similar to <code>iter.map(...).flatten(true)</code>.</p> <h2>Reducing a value</h2>
<h3 id="seq.reduce">Seq#reduce()</h3>
<p>Reduces the Iterable to a value by calling the <code>reducer</code> for every entry in the Iterable and passing along the reduced value.</p> <pre data-language="js">reduce&lt;R&gt;(reducer: (reduction?: R, value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; R,initialReduction?: R,context?: any): R
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reduce">Iterable#reduce</a></code><h4>see</h4>
<p><code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">Array#reduce</a></code>.</p> <h4>Discussion</h4>
<p>If <code>initialReduction</code> is not provided, or is null, the first item in the Iterable will be used.</p> <h3 id="seq.reduceright">Seq#reduceRight()</h3>
<p>Reduces the Iterable in reverse (from the right side).</p> <pre data-language="js">reduceRight&lt;R&gt;(reducer: (reduction?: R, value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; R,initialReduction?: R,context?: any): R
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reduceright">Iterable#reduceRight</a></code><h4>Discussion</h4>
<p>Note: Similar to this.reverse().reduce(), and provided for parity with <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight">Array#reduceRight</a></code>.</p> <h3 id="seq.every">Seq#every()</h3>
<p>True if <code>predicate</code> returns true for all entries in the Iterable.</p> <pre data-language="js">every(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.every">Iterable#every</a></code><h3 id="seq.some">Seq#some()</h3>
<p>True if <code>predicate</code> returns true for any entry in the Iterable.</p> <pre data-language="js">some(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.some">Iterable#some</a></code><h3 id="seq.join">Seq#join()</h3>
<p>Joins values together as a string, inserting a separator between each. The default separator is <code>","</code>.</p> <pre data-language="js">join(separator?: string): string
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.join">Iterable#join</a></code><h3 id="seq.isempty">Seq#isEmpty()</h3>
<p>Returns true if this Iterable includes no values.</p> <pre data-language="js">isEmpty(): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.isempty">Iterable#isEmpty</a></code><h4>Discussion</h4>
<p>For some lazy <code><a href="#seq">Seq</a></code>, <code>isEmpty</code> might need to iterate to determine emptiness. At most one iteration will occur.</p> <h3 id="seq.count">Seq#count()</h3>
<p>Returns the size of this Iterable.</p> <pre data-language="js">count(): number
count(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.count">Iterable#count</a></code><h4>Discussion</h4>
<p>Regardless of if this Iterable can describe its size lazily (some Seqs cannot), this method will always return the correct size. E.g. it evaluates a lazy <code><a href="#seq">Seq</a></code> if necessary.</p> <p>If <code>predicate</code> is provided, then this returns the count of entries in the Iterable for which the <code>predicate</code> returns true.</p> <h3 id="seq.countby">Seq#countBy()</h3>
<p>Returns a <code><a href="#seq.keyed">Seq.Keyed</a></code> of counts, grouped by the return value of the <code>grouper</code> function.</p> <pre data-language="js">countBy&lt;G&gt;(grouper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; G,context?: any): Map&lt;G, number&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.countby">Iterable#countBy</a></code><h4>Discussion</h4>
<p>Note: This is not a lazy operation.</p> <h2>Search for value</h2>
<h3 id="seq.find">Seq#find()</h3>
<p>Returns the first value for which the <code>predicate</code> returns true.</p> <pre data-language="js">find(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.find">Iterable#find</a></code><h3 id="seq.findlast">Seq#findLast()</h3>
<p>Returns the last value for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLast(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlast">Iterable#findLast</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="seq.findentry">Seq#findEntry()</h3>
<p>Returns the first [key, value] entry for which the <code>predicate</code> returns true.</p> <pre data-language="js">findEntry(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): Array&lt;any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findentry">Iterable#findEntry</a></code><h3 id="seq.findlastentry">Seq#findLastEntry()</h3>
<p>Returns the last [key, value] entry for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLastEntry(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): Array&lt;any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlastentry">Iterable#findLastEntry</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="seq.findkey">Seq#findKey()</h3>
<p>Returns the key for which the <code>predicate</code> returns true.</p> <pre data-language="js">findKey(predicate: (value?: V, key?: K, iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; boolean,context?: any): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findkey">Iterable#findKey</a></code><h3 id="seq.findlastkey">Seq#findLastKey()</h3>
<p>Returns the last key for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLastKey(predicate: (value?: V, key?: K, iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; boolean,context?: any): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlastkey">Iterable#findLastKey</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="seq.keyof">Seq#keyOf()</h3>
<p>Returns the key associated with the search value, or undefined.</p> <pre data-language="js">keyOf(searchValue: V): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyof">Iterable#keyOf</a></code><h3 id="seq.lastkeyof">Seq#lastKeyOf()</h3>
<p>Returns the last key associated with the search value, or undefined.</p> <pre data-language="js">lastKeyOf(searchValue: V): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.lastkeyof">Iterable#lastKeyOf</a></code><h3 id="seq.max">Seq#max()</h3>
<p>Returns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> <pre data-language="js">max(comparator?: (valueA: V, valueB: V) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.max">Iterable#max</a></code><h4>Discussion</h4>
<p>The <code>comparator</code> is used in the same way as <code><a href="#iterable.sort">Iterable#sort</a></code>. If it is not provided, the default comparator is <code>&gt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code>max</code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&gt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> <h3 id="seq.maxby">Seq#maxBy()</h3>
<p>Like <code><a href="#iterable.max">max</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> <pre data-language="js">maxBy&lt;C&gt;(comparatorValueMapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.maxby">Iterable#maxBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.maxBy(hitter =&gt; hitter.avgHits);</pre>
<h3 id="seq.min">Seq#min()</h3>
<p>Returns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> <pre data-language="js">min(comparator?: (valueA: V, valueB: V) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.min">Iterable#min</a></code><h4>Discussion</h4>
<p>The <code>comparator</code> is used in the same way as <code><a href="#iterable.sort">Iterable#sort</a></code>. If it is not provided, the default comparator is <code>&lt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code>min</code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&lt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> <h3 id="seq.minby">Seq#minBy()</h3>
<p>Like <code><a href="#iterable.min">min</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> <pre data-language="js">minBy&lt;C&gt;(comparatorValueMapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.minby">Iterable#minBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.minBy(hitter =&gt; hitter.avgHits);</pre>
<h2>Comparison</h2>
<h3 id="seq.issubset">Seq#isSubset()</h3>
<p>True if <code>iter</code> includes every value in this Iterable.</p> <pre data-language="js">isSubset(iter: Iterable&lt;any, V&gt;): boolean
isSubset(iter: Array&lt;V&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.issubset">Iterable#isSubset</a></code><h3 id="seq.issuperset">Seq#isSuperset()</h3>
<p>True if this Iterable includes every value in <code>iter</code>.</p> <pre data-language="js">isSuperset(iter: Iterable&lt;any, V&gt;): boolean
isSuperset(iter: Array&lt;V&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.issuperset">Iterable#isSuperset</a></code><h1 id="seq.keyed">Seq.Keyed</h1>
<p><code>Seq</code> which represents key-value pairs.</p> <pre data-language="js">class Seq.Keyed&lt;K, V&gt; extends Seq&lt;K, V&gt;, Iterable.Keyed&lt;K, V&gt;</pre>
<h2>Construction</h2>
<h3 id="seq.keyed()">Seq.Keyed()</h3>
<p>Always returns a Seq.Keyed, if input is not keyed, expects an iterable of [K, V] tuples.</p> <pre data-language="js">Seq.Keyed&lt;K, V&gt;(): Seq.Keyed&lt;K, V&gt;
Seq.Keyed&lt;K, V&gt;(seq: Iterable.Keyed&lt;K, V&gt;): Seq.Keyed&lt;K, V&gt;
Seq.Keyed&lt;K, V&gt;(seq: Iterable&lt;any, any&gt;): Seq.Keyed&lt;K, V&gt;
Seq.Keyed&lt;K, V&gt;(array: Array&lt;any&gt;): Seq.Keyed&lt;K, V&gt;
Seq.Keyed&lt;V&gt;(obj: {[key: string]: V}): Seq.Keyed&lt;string, V&gt;
Seq.Keyed&lt;K, V&gt;(iterator: Iterator&lt;any&gt;): Seq.Keyed&lt;K, V&gt;
Seq.Keyed&lt;K, V&gt;(iterable: Object): Seq.Keyed&lt;K, V&gt;
</pre>
<h2>Members</h2>
<h3 id="seq.keyed.size">Seq.Keyed#size</h3>
<pre data-language="js">size: number</pre>
<h4>Inherited from</h4>
<code><a href="#seq.size">Seq#size</a></code><h2>Conversion to Seq</h2>
<h3 id="seq.keyed.toseq">Seq.Keyed#toSeq()</h3>
<p>Returns itself</p> <pre data-language="js">toSeq(): Seq.Keyed&lt;K, V&gt;
</pre>
<h4>Overrides</h4>
<code><a href="#iterable.toseq">Iterable#toSeq</a></code><h3 id="seq.keyed.tokeyedseq">Seq.Keyed#toKeyedSeq()</h3>
<p>Returns a Seq.Keyed from this Iterable where indices are treated as keys.</p> <pre data-language="js">toKeyedSeq(): Seq.Keyed&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tokeyedseq">Iterable#toKeyedSeq</a></code><h4>Discussion</h4>
<p>This is useful if you want to operate on an Iterable.Indexed and preserve the [index, value] pairs.</p> <p>The returned Seq will have identical iteration order as this Iterable.</p> <p>Example:</p> <pre data-language="js">var indexedSeq = Immutable.Seq.of('A', 'B', 'C');
indexedSeq.filter(v =&gt; v === 'B').toString() // Seq [ 'B' ]
var keyedSeq = indexedSeq.toKeyedSeq();
keyedSeq.filter(v =&gt; v === 'B').toString() // Seq { 1: 'B' }</pre>
<h3 id="seq.keyed.toindexedseq">Seq.Keyed#toIndexedSeq()</h3>
<p>Returns an Seq.Indexed of the values of this Iterable, discarding keys.</p> <pre data-language="js">toIndexedSeq(): Seq.Indexed&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toindexedseq">Iterable#toIndexedSeq</a></code><h3 id="seq.keyed.tosetseq">Seq.Keyed#toSetSeq()</h3>
<p>Returns a Seq.Set of the values of this Iterable, discarding keys.</p> <pre data-language="js">toSetSeq(): Seq.Set&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tosetseq">Iterable#toSetSeq</a></code><h2>Force evaluation</h2>
<h3 id="seq.keyed.cacheresult">Seq.Keyed#cacheResult()</h3>
<p>Because Sequences are lazy and designed to be chained together, they do not cache their results. For example, this map function is called a total of 6 times, as each <code><a href="#seq.join">join</a></code> iterates the Seq of three values.</p> <pre data-language="js">cacheResult(): Seq&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#seq.cacheresult">Seq#cacheResult</a></code><h4>Example</h4>
<pre data-language="js">var squares = Seq.of(1,2,3).map(x =&gt; x * x);
squares.join() + squares.join();</pre>
<p>If you know a <code>Seq</code> will be used multiple times, it may be more efficient to first cache it in memory. Here, the map function is called only 3 times.</p> <pre data-language="js">var squares = Seq.of(1,2,3).map(x =&gt; x * x).cacheResult();
squares.join() + squares.join();</pre>
<p>Use this method judiciously, as it must fully evaluate a Seq which can be a burden on memory and possibly performance.</p> <p>Note: after calling <code>cacheResult</code>, a Seq will always have a <code><a href="#seq.size">size</a></code>.</p> <h2>Value equality</h2>
<h3 id="seq.keyed.equals">Seq.Keyed#equals()</h3>
<p>True if this and the other Iterable have value equality, as defined by <code><a href="#is">Immutable.is()</a></code>.</p> <pre data-language="js">equals(other: Iterable&lt;K, V&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.equals">Iterable#equals</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Immutable.is(this, other)</code>, but provided to allow for chained expressions.</p> <h3 id="seq.keyed.hashcode">Seq.Keyed#hashCode()</h3>
<p>Computes and returns the hashed identity for this Iterable.</p> <pre data-language="js">hashCode(): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.hashcode">Iterable#hashCode</a></code><h4>Discussion</h4>
<p>The <code>hashCode</code> of an Iterable is used to determine potential equality, and is used when adding this to a <code><a href="#iterable.set">Set</a></code> or as a key in a <code><a href="#map">Map</a></code>, enabling lookup via a different instance.</p> <pre data-language="js">var a = List.of(1, 2, 3);
var b = List.of(1, 2, 3);
assert(a !== b); // different instances
var set = Set.of(a);
assert(set.has(b) === true);</pre>
<p>If two values have the same <code>hashCode</code>, they are <a href="http://en.wikipedia.org/wiki/Collision_(computer_science)">not guaranteed to be equal</a>. If two values have different <code>hashCode</code>s, they must not be equal.</p> <h2>Reading values</h2>
<h3 id="seq.keyed.get">Seq.Keyed#get()</h3>
<p>Returns the value associated with the provided key, or notSetValue if the Iterable does not contain this key.</p> <pre data-language="js">get(key: K, notSetValue?: V): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.get">Iterable#get</a></code><h4>Discussion</h4>
<p>Note: it is possible a key may be associated with an <code>undefined</code> value, so if <code>notSetValue</code> is not provided and this method returns <code>undefined</code>, that does not guarantee the key was not found.</p> <h3 id="seq.keyed.has">Seq.Keyed#has()</h3>
<p>True if a key exists within this <code>Iterable</code>, using <code><a href="#is">Immutable.is</a></code> to determine equality</p> <pre data-language="js">has(key: K): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.has">Iterable#has</a></code><h3 id="seq.keyed.includes">Seq.Keyed#includes()</h3>
<p>True if a value exists within this <code>Iterable</code>, using <code><a href="#is">Immutable.is</a></code> to determine equality</p> <pre data-language="js">includes(value: V): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.includes">Iterable#includes</a></code><h4>alias</h4>
<code>contains()</code><h3 id="seq.keyed.first">Seq.Keyed#first()</h3>
<p>The first value in the Iterable.</p> <pre data-language="js">first(): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.first">Iterable#first</a></code><h3 id="seq.keyed.last">Seq.Keyed#last()</h3>
<p>The last value in the Iterable.</p> <pre data-language="js">last(): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.last">Iterable#last</a></code><h2>Reading deep values</h2>
<h3 id="seq.keyed.getin">Seq.Keyed#getIn()</h3>
<p>Returns the value found by following a path of keys or indices through nested Iterables.</p> <pre data-language="js">getIn(searchKeyPath: Array&lt;any&gt;, notSetValue?: any): any
getIn(searchKeyPath: Iterable&lt;any, any&gt;, notSetValue?: any): any
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.getin">Iterable#getIn</a></code><h3 id="seq.keyed.hasin">Seq.Keyed#hasIn()</h3>
<p>True if the result of following a path of keys or indices through nested Iterables results in a set value.</p> <pre data-language="js">hasIn(searchKeyPath: Array&lt;any&gt;): boolean
hasIn(searchKeyPath: Iterable&lt;any, any&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.hasin">Iterable#hasIn</a></code><h2>Conversion to JavaScript types</h2>
<h3 id="seq.keyed.tojs">Seq.Keyed#toJS()</h3>
<p>Deeply converts this Iterable to equivalent JS.</p> <pre data-language="js">toJS(): any
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tojs">Iterable#toJS</a></code><h4>alias</h4>
<code>toJSON()</code><h4>Discussion</h4>
<p><code>Iterable.Indexeds</code>, and <code>Iterable.Sets</code> become Arrays, while <code>Iterable.Keyeds</code> become Objects.</p> <h3 id="seq.keyed.toarray">Seq.Keyed#toArray()</h3>
<p>Shallowly converts this iterable to an Array, discarding keys.</p> <pre data-language="js">toArray(): Array&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toarray">Iterable#toArray</a></code><h3 id="seq.keyed.toobject">Seq.Keyed#toObject()</h3>
<p>Shallowly converts this Iterable to an Object.</p> <pre data-language="js">toObject(): {[key: string]: V}
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toobject">Iterable#toObject</a></code><h4>Discussion</h4>
<p>Throws if keys are not strings.</p> <h2>Conversion to Collections</h2>
<h3 id="seq.keyed.tomap">Seq.Keyed#toMap()</h3>
<p>Converts this Iterable to a Map, Throws if keys are not hashable.</p> <pre data-language="js">toMap(): Map&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tomap">Iterable#toMap</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Map(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="seq.keyed.toorderedmap">Seq.Keyed#toOrderedMap()</h3>
<p>Converts this Iterable to a Map, maintaining the order of iteration.</p> <pre data-language="js">toOrderedMap(): OrderedMap&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toorderedmap">Iterable#toOrderedMap</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>OrderedMap(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="seq.keyed.toset">Seq.Keyed#toSet()</h3>
<p>Converts this Iterable to a Set, discarding keys. Throws if values are not hashable.</p> <pre data-language="js">toSet(): Set&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toset">Iterable#toSet</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Set(this)</code>, but provided to allow for chained expressions.</p> <h3 id="seq.keyed.toorderedset">Seq.Keyed#toOrderedSet()</h3>
<p>Converts this Iterable to a Set, maintaining the order of iteration and discarding keys.</p> <pre data-language="js">toOrderedSet(): OrderedSet&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toorderedset">Iterable#toOrderedSet</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>OrderedSet(this.valueSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="seq.keyed.tolist">Seq.Keyed#toList()</h3>
<p>Converts this Iterable to a List, discarding keys.</p> <pre data-language="js">toList(): List&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tolist">Iterable#toList</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>List(this)</code>, but provided to allow for chained expressions.</p> <h3 id="seq.keyed.tostack">Seq.Keyed#toStack()</h3>
<p>Converts this Iterable to a Stack, discarding keys. Throws if values are not hashable.</p> <pre data-language="js">toStack(): Stack&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tostack">Iterable#toStack</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Stack(this)</code>, but provided to allow for chained expressions.</p> <h2>Iterators</h2>
<h3 id="seq.keyed.keys">Seq.Keyed#keys()</h3>
<p>An iterator of this <code>Iterable</code>'s keys.</p> <pre data-language="js">keys(): Iterator&lt;K&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keys">Iterable#keys</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.keyseq">keySeq</a></code> instead, if this is what you want.</p> <h3 id="seq.keyed.values">Seq.Keyed#values()</h3>
<p>An iterator of this <code>Iterable</code>'s values.</p> <pre data-language="js">values(): Iterator&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.values">Iterable#values</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.valueseq">valueSeq</a></code> instead, if this is what you want.</p> <h3 id="seq.keyed.entries">Seq.Keyed#entries()</h3>
<p>An iterator of this <code>Iterable</code>'s entries as <code>[key, value]</code> tuples.</p> <pre data-language="js">entries(): Iterator&lt;Array&lt;any&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.entries">Iterable#entries</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.entryseq">entrySeq</a></code> instead, if this is what you want.</p> <h2>Iterables (Seq)</h2>
<h3 id="seq.keyed.keyseq">Seq.Keyed#keySeq()</h3>
<p>Returns a new Seq.Indexed of the keys of this Iterable, discarding values.</p> <pre data-language="js">keySeq(): Seq.Indexed&lt;K&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyseq">Iterable#keySeq</a></code><h3 id="seq.keyed.valueseq">Seq.Keyed#valueSeq()</h3>
<p>Returns an Seq.Indexed of the values of this Iterable, discarding keys.</p> <pre data-language="js">valueSeq(): Seq.Indexed&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.valueseq">Iterable#valueSeq</a></code><h3 id="seq.keyed.entryseq">Seq.Keyed#entrySeq()</h3>
<p>Returns a new Seq.Indexed of [key, value] tuples.</p> <pre data-language="js">entrySeq(): Seq.Indexed&lt;Array&lt;any&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.entryseq">Iterable#entrySeq</a></code><h2>Sequence algorithms</h2>
<h3 id="seq.keyed.map">Seq.Keyed#map()</h3>
<p>Returns a new Iterable of the same type with values passed through a <code>mapper</code> function.</p> <pre data-language="js">map&lt;M&gt;(mapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; M,context?: any): Iterable&lt;K, M&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.map">Iterable#map</a></code><h4>Example</h4>
<pre data-language="js">Seq({ a: 1, b: 2 }).map(x =&gt; 10 * x)
// Seq { a: 10, b: 20 }</pre>
<h3 id="seq.keyed.filter">Seq.Keyed#filter()</h3>
<p>Returns a new Iterable of the same type with only the entries for which the <code>predicate</code> function returns true.</p> <pre data-language="js">filter(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.filter">Iterable#filter</a></code><h4>Example</h4>
<pre data-language="js">Seq({a:1,b:2,c:3,d:4}).filter(x =&gt; x % 2 === 0)
// Seq { b: 2, d: 4 }</pre>
<h3 id="seq.keyed.filternot">Seq.Keyed#filterNot()</h3>
<p>Returns a new Iterable of the same type with only the entries for which the <code>predicate</code> function returns false.</p> <pre data-language="js">filterNot(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.filternot">Iterable#filterNot</a></code><h4>Example</h4>
<pre data-language="js">Seq({a:1,b:2,c:3,d:4}).filterNot(x =&gt; x % 2 === 0)
// Seq { a: 1, c: 3 }</pre>
<h3 id="seq.keyed.reverse">Seq.Keyed#reverse()</h3>
<p>Returns a new Iterable of the same type in reverse order.</p> <pre data-language="js">reverse(): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reverse">Iterable#reverse</a></code><h3 id="seq.keyed.sort">Seq.Keyed#sort()</h3>
<p>Returns a new Iterable of the same type which includes the same entries, stably sorted by using a <code>comparator</code>.</p> <pre data-language="js">sort(comparator?: (valueA: V, valueB: V) =&gt; number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.sort">Iterable#sort</a></code><h4>Discussion</h4>
<p>If a <code>comparator</code> is not provided, a default comparator uses <code>&lt;</code> and <code>&gt;</code>.</p> <p><code>comparator(valueA, valueB)</code>:</p> <ul> <li>Returns <code>0</code> if the elements should not be swapped.</li> <li>Returns <code>-1</code> (or any negative number) if <code>valueA</code> comes before <code>valueB</code>
</li> <li>Returns <code>1</code> (or any positive number) if <code>valueA</code> comes after <code>valueB</code>
</li> <li>Is pure, i.e. it must always return the same value for the same pair of values.</li> </ul> <p>When sorting collections which have no defined order, their ordered equivalents will be returned. e.g. <code>map.sort()</code> returns OrderedMap.</p> <h3 id="seq.keyed.sortby">Seq.Keyed#sortBy()</h3>
<p>Like <code><a href="#iterable.sort">sort</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for sorting by more sophisticated means:</p> <pre data-language="js">sortBy&lt;C&gt;(comparatorValueMapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.sortby">Iterable#sortBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.sortBy(hitter =&gt; hitter.avgHits);</pre>
<h3 id="seq.keyed.groupby">Seq.Keyed#groupBy()</h3>
<p>Returns a <code><a href="#iterable.keyed">Iterable.Keyed</a></code> of <code>Iterable.Keyeds</code>, grouped by the return value of the <code>grouper</code> function.</p> <pre data-language="js">groupBy&lt;G&gt;(grouper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; G,context?: any): Seq.Keyed&lt;G, Iterable&lt;K, V&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.groupby">Iterable#groupBy</a></code><h4>Discussion</h4>
<p>Note: This is always an eager operation.</p> <h2>Side effects</h2>
<h3 id="seq.keyed.foreach">Seq.Keyed#forEach()</h3>
<p>The <code>sideEffect</code> is executed for every entry in the Iterable.</p> <pre data-language="js">forEach(sideEffect: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; any,context?: any): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.foreach">Iterable#forEach</a></code><h4>Discussion</h4>
<p>Unlike <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">Array#forEach</a></code>, if any call of <code>sideEffect</code> returns <code>false</code>, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).</p> <h2>Creating subsets</h2>
<h3 id="seq.keyed.slice">Seq.Keyed#slice()</h3>
<p>Returns a new Iterable of the same type representing a portion of this Iterable from start up to but not including end.</p> <pre data-language="js">slice(begin?: number, end?: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.slice">Iterable#slice</a></code><h4>Discussion</h4>
<p>If begin is negative, it is offset from the end of the Iterable. e.g. <code>slice(-2)</code> returns a Iterable of the last two entries. If it is not provided the new Iterable will begin at the beginning of this Iterable.</p> <p>If end is negative, it is offset from the end of the Iterable. e.g. <code>slice(0, -1)</code> returns an Iterable of everything but the last entry. If it is not provided, the new Iterable will continue through the end of this Iterable.</p> <p>If the requested slice is equivalent to the current Iterable, then it will return itself.</p> <h3 id="seq.keyed.rest">Seq.Keyed#rest()</h3>
<p>Returns a new Iterable of the same type containing all entries except the first.</p> <pre data-language="js">rest(): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.rest">Iterable#rest</a></code><h3 id="seq.keyed.butlast">Seq.Keyed#butLast()</h3>
<p>Returns a new Iterable of the same type containing all entries except the last.</p> <pre data-language="js">butLast(): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.butlast">Iterable#butLast</a></code><h3 id="seq.keyed.skip">Seq.Keyed#skip()</h3>
<p>Returns a new Iterable of the same type which excludes the first <code>amount</code> entries from this Iterable.</p> <pre data-language="js">skip(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skip">Iterable#skip</a></code><h3 id="seq.keyed.skiplast">Seq.Keyed#skipLast()</h3>
<p>Returns a new Iterable of the same type which excludes the last <code>amount</code> entries from this Iterable.</p> <pre data-language="js">skipLast(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skiplast">Iterable#skipLast</a></code><h3 id="seq.keyed.skipwhile">Seq.Keyed#skipWhile()</h3>
<p>Returns a new Iterable of the same type which includes entries starting from when <code>predicate</code> first returns false.</p> <pre data-language="js">skipWhile(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skipwhile">Iterable#skipWhile</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .skipWhile(x =&gt; x.match(/g/))
// Seq [ 'cat', 'hat', 'god' ]</pre>
<h3 id="seq.keyed.skipuntil">Seq.Keyed#skipUntil()</h3>
<p>Returns a new Iterable of the same type which includes entries starting from when <code>predicate</code> first returns true.</p> <pre data-language="js">skipUntil(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skipuntil">Iterable#skipUntil</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .skipUntil(x =&gt; x.match(/hat/))
// Seq [ 'hat', 'god' ]</pre>
<h3 id="seq.keyed.take">Seq.Keyed#take()</h3>
<p>Returns a new Iterable of the same type which includes the first <code>amount</code> entries from this Iterable.</p> <pre data-language="js">take(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.take">Iterable#take</a></code><h3 id="seq.keyed.takelast">Seq.Keyed#takeLast()</h3>
<p>Returns a new Iterable of the same type which includes the last <code>amount</code> entries from this Iterable.</p> <pre data-language="js">takeLast(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takelast">Iterable#takeLast</a></code><h3 id="seq.keyed.takewhile">Seq.Keyed#takeWhile()</h3>
<p>Returns a new Iterable of the same type which includes entries from this Iterable as long as the <code>predicate</code> returns true.</p> <pre data-language="js">takeWhile(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takewhile">Iterable#takeWhile</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .takeWhile(x =&gt; x.match(/o/))
// Seq [ 'dog', 'frog' ]</pre>
<h3 id="seq.keyed.takeuntil">Seq.Keyed#takeUntil()</h3>
<p>Returns a new Iterable of the same type which includes entries from this Iterable as long as the <code>predicate</code> returns false.</p> <pre data-language="js">takeUntil(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takeuntil">Iterable#takeUntil</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god').takeUntil(x =&gt; x.match(/at/))
// ['dog', 'frog']</pre>
<h2>Combination</h2>
<h3 id="seq.keyed.concat">Seq.Keyed#concat()</h3>
<p>Returns a new Iterable of the same type with other values and iterable-like concatenated to this one.</p> <pre data-language="js">concat(...valuesOrIterables: any[]): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.concat">Iterable#concat</a></code><h4>Discussion</h4>
<p>For Seqs, all entries will be present in the resulting iterable, even if they have the same key.</p> <h3 id="seq.keyed.flatten">Seq.Keyed#flatten()</h3>
<p>Flattens nested Iterables.</p> <pre data-language="js">flatten(depth?: number): Iterable&lt;any, any&gt;
flatten(shallow?: boolean): Iterable&lt;any, any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.flatten">Iterable#flatten</a></code><h4>Discussion</h4>
<p>Will deeply flatten the Iterable by default, returning an Iterable of the same type, but a <code>depth</code> can be provided in the form of a number or boolean (where true means to shallowly flatten one level). A depth of 0 (or shallow: false) will deeply flatten.</p> <p>Flattens only others Iterable, not Arrays or Objects.</p> <p>Note: <code>flatten(true)</code> operates on Iterable<any iterable v="">&gt; and returns Iterable</any></p> <h3 id="seq.keyed.flatmap">Seq.Keyed#flatMap()</h3>
<p>Flat-maps the Iterable, returning an Iterable of the same type.</p> <pre data-language="js">flatMap&lt;MK, MV&gt;(mapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; Iterable&lt;MK, MV&gt;,context?: any): Iterable&lt;MK, MV&gt;
flatMap&lt;MK, MV&gt;(mapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; any,context?: any): Iterable&lt;MK, MV&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.flatmap">Iterable#flatMap</a></code><h4>Discussion</h4>
<p>Similar to <code>iter.map(...).flatten(true)</code>.</p> <h2>Reducing a value</h2>
<h3 id="seq.keyed.reduce">Seq.Keyed#reduce()</h3>
<p>Reduces the Iterable to a value by calling the <code>reducer</code> for every entry in the Iterable and passing along the reduced value.</p> <pre data-language="js">reduce&lt;R&gt;(reducer: (reduction?: R, value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; R,initialReduction?: R,context?: any): R
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reduce">Iterable#reduce</a></code><h4>see</h4>
<p><code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">Array#reduce</a></code>.</p> <h4>Discussion</h4>
<p>If <code>initialReduction</code> is not provided, or is null, the first item in the Iterable will be used.</p> <h3 id="seq.keyed.reduceright">Seq.Keyed#reduceRight()</h3>
<p>Reduces the Iterable in reverse (from the right side).</p> <pre data-language="js">reduceRight&lt;R&gt;(reducer: (reduction?: R, value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; R,initialReduction?: R,context?: any): R
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reduceright">Iterable#reduceRight</a></code><h4>Discussion</h4>
<p>Note: Similar to this.reverse().reduce(), and provided for parity with <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight">Array#reduceRight</a></code>.</p> <h3 id="seq.keyed.every">Seq.Keyed#every()</h3>
<p>True if <code>predicate</code> returns true for all entries in the Iterable.</p> <pre data-language="js">every(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.every">Iterable#every</a></code><h3 id="seq.keyed.some">Seq.Keyed#some()</h3>
<p>True if <code>predicate</code> returns true for any entry in the Iterable.</p> <pre data-language="js">some(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.some">Iterable#some</a></code><h3 id="seq.keyed.join">Seq.Keyed#join()</h3>
<p>Joins values together as a string, inserting a separator between each. The default separator is <code>","</code>.</p> <pre data-language="js">join(separator?: string): string
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.join">Iterable#join</a></code><h3 id="seq.keyed.isempty">Seq.Keyed#isEmpty()</h3>
<p>Returns true if this Iterable includes no values.</p> <pre data-language="js">isEmpty(): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.isempty">Iterable#isEmpty</a></code><h4>Discussion</h4>
<p>For some lazy <code><a href="#seq">Seq</a></code>, <code>isEmpty</code> might need to iterate to determine emptiness. At most one iteration will occur.</p> <h3 id="seq.keyed.count">Seq.Keyed#count()</h3>
<p>Returns the size of this Iterable.</p> <pre data-language="js">count(): number
count(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.count">Iterable#count</a></code><h4>Discussion</h4>
<p>Regardless of if this Iterable can describe its size lazily (some Seqs cannot), this method will always return the correct size. E.g. it evaluates a lazy <code><a href="#seq">Seq</a></code> if necessary.</p> <p>If <code>predicate</code> is provided, then this returns the count of entries in the Iterable for which the <code>predicate</code> returns true.</p> <h3 id="seq.keyed.countby">Seq.Keyed#countBy()</h3>
<p>Returns a <code><a href="#seq.keyed">Seq.Keyed</a></code> of counts, grouped by the return value of the <code>grouper</code> function.</p> <pre data-language="js">countBy&lt;G&gt;(grouper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; G,context?: any): Map&lt;G, number&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.countby">Iterable#countBy</a></code><h4>Discussion</h4>
<p>Note: This is not a lazy operation.</p> <h2>Search for value</h2>
<h3 id="seq.keyed.find">Seq.Keyed#find()</h3>
<p>Returns the first value for which the <code>predicate</code> returns true.</p> <pre data-language="js">find(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.find">Iterable#find</a></code><h3 id="seq.keyed.findlast">Seq.Keyed#findLast()</h3>
<p>Returns the last value for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLast(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlast">Iterable#findLast</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="seq.keyed.findentry">Seq.Keyed#findEntry()</h3>
<p>Returns the first [key, value] entry for which the <code>predicate</code> returns true.</p> <pre data-language="js">findEntry(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): Array&lt;any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findentry">Iterable#findEntry</a></code><h3 id="seq.keyed.findlastentry">Seq.Keyed#findLastEntry()</h3>
<p>Returns the last [key, value] entry for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLastEntry(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): Array&lt;any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlastentry">Iterable#findLastEntry</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="seq.keyed.findkey">Seq.Keyed#findKey()</h3>
<p>Returns the key for which the <code>predicate</code> returns true.</p> <pre data-language="js">findKey(predicate: (value?: V, key?: K, iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; boolean,context?: any): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findkey">Iterable#findKey</a></code><h3 id="seq.keyed.findlastkey">Seq.Keyed#findLastKey()</h3>
<p>Returns the last key for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLastKey(predicate: (value?: V, key?: K, iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; boolean,context?: any): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlastkey">Iterable#findLastKey</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="seq.keyed.keyof">Seq.Keyed#keyOf()</h3>
<p>Returns the key associated with the search value, or undefined.</p> <pre data-language="js">keyOf(searchValue: V): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyof">Iterable#keyOf</a></code><h3 id="seq.keyed.lastkeyof">Seq.Keyed#lastKeyOf()</h3>
<p>Returns the last key associated with the search value, or undefined.</p> <pre data-language="js">lastKeyOf(searchValue: V): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.lastkeyof">Iterable#lastKeyOf</a></code><h3 id="seq.keyed.max">Seq.Keyed#max()</h3>
<p>Returns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> <pre data-language="js">max(comparator?: (valueA: V, valueB: V) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.max">Iterable#max</a></code><h4>Discussion</h4>
<p>The <code>comparator</code> is used in the same way as <code><a href="#iterable.sort">Iterable#sort</a></code>. If it is not provided, the default comparator is <code>&gt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code>max</code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&gt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> <h3 id="seq.keyed.maxby">Seq.Keyed#maxBy()</h3>
<p>Like <code><a href="#iterable.max">max</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> <pre data-language="js">maxBy&lt;C&gt;(comparatorValueMapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.maxby">Iterable#maxBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.maxBy(hitter =&gt; hitter.avgHits);</pre>
<h3 id="seq.keyed.min">Seq.Keyed#min()</h3>
<p>Returns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> <pre data-language="js">min(comparator?: (valueA: V, valueB: V) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.min">Iterable#min</a></code><h4>Discussion</h4>
<p>The <code>comparator</code> is used in the same way as <code><a href="#iterable.sort">Iterable#sort</a></code>. If it is not provided, the default comparator is <code>&lt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code>min</code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&lt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> <h3 id="seq.keyed.minby">Seq.Keyed#minBy()</h3>
<p>Like <code><a href="#iterable.min">min</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> <pre data-language="js">minBy&lt;C&gt;(comparatorValueMapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.minby">Iterable#minBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.minBy(hitter =&gt; hitter.avgHits);</pre>
<h2>Comparison</h2>
<h3 id="seq.keyed.issubset">Seq.Keyed#isSubset()</h3>
<p>True if <code>iter</code> includes every value in this Iterable.</p> <pre data-language="js">isSubset(iter: Iterable&lt;any, V&gt;): boolean
isSubset(iter: Array&lt;V&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.issubset">Iterable#isSubset</a></code><h3 id="seq.keyed.issuperset">Seq.Keyed#isSuperset()</h3>
<p>True if this Iterable includes every value in <code>iter</code>.</p> <pre data-language="js">isSuperset(iter: Iterable&lt;any, V&gt;): boolean
isSuperset(iter: Array&lt;V&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.issuperset">Iterable#isSuperset</a></code><h2>Sequence functions</h2>
<h3 id="seq.keyed.flip">Seq.Keyed#flip()</h3>
<p>Returns a new Iterable.Keyed of the same type where the keys and values have been flipped.</p> <pre data-language="js">flip(): Iterable.Keyed&lt;V, K&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyed.flip">Iterable.Keyed#flip</a></code><h4>Example</h4>
<pre data-language="js">Seq({ a: 'z', b: 'y' }).flip() // { z: 'a', y: 'b' }</pre>
<h3 id="seq.keyed.mapkeys">Seq.Keyed#mapKeys()</h3>
<p>Returns a new Iterable.Keyed of the same type with keys passed through a <code>mapper</code> function.</p> <pre data-language="js">mapKeys&lt;M&gt;(mapper: (key?: K, value?: V, iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; M,context?: any): Iterable.Keyed&lt;M, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyed.mapkeys">Iterable.Keyed#mapKeys</a></code><h4>Example</h4>
<pre data-language="js">Seq({ a: 1, b: 2 })
  .mapKeys(x =&gt; x.toUpperCase())
// Seq { A: 1, B: 2 }</pre>
<h3 id="seq.keyed.mapentries">Seq.Keyed#mapEntries()</h3>
<p>Returns a new Iterable.Keyed of the same type with entries ([key, value] tuples) passed through a <code>mapper</code> function.</p> <pre data-language="js">mapEntries&lt;KM, VM&gt;(mapper: (entry?: Array&lt;any&gt;,index?: number,iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; Array&lt;any&gt;,context?: any): Iterable.Keyed&lt;KM, VM&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyed.mapentries">Iterable.Keyed#mapEntries</a></code><h4>Example</h4>
<pre data-language="js">Seq({ a: 1, b: 2 })
  .mapEntries(([k, v]) =&gt; [k.toUpperCase(), v * 2])
// Seq { A: 2, B: 4 }</pre>
<h1 id="seq.keyed">Seq.Keyed</h1>
<p><code>Seq</code> which represents key-value pairs.</p> <pre data-language="js">class Seq.Keyed&lt;K, V&gt; extends Seq&lt;K, V&gt;, Iterable.Keyed&lt;K, V&gt;</pre>
<h2>Construction</h2>
<h3 id="seq.keyed()">Seq.Keyed()</h3>
<p>Always returns a Seq.Keyed, if input is not keyed, expects an iterable of [K, V] tuples.</p> <pre data-language="js">Seq.Keyed&lt;K, V&gt;(): Seq.Keyed&lt;K, V&gt;
Seq.Keyed&lt;K, V&gt;(seq: Iterable.Keyed&lt;K, V&gt;): Seq.Keyed&lt;K, V&gt;
Seq.Keyed&lt;K, V&gt;(seq: Iterable&lt;any, any&gt;): Seq.Keyed&lt;K, V&gt;
Seq.Keyed&lt;K, V&gt;(array: Array&lt;any&gt;): Seq.Keyed&lt;K, V&gt;
Seq.Keyed&lt;V&gt;(obj: {[key: string]: V}): Seq.Keyed&lt;string, V&gt;
Seq.Keyed&lt;K, V&gt;(iterator: Iterator&lt;any&gt;): Seq.Keyed&lt;K, V&gt;
Seq.Keyed&lt;K, V&gt;(iterable: Object): Seq.Keyed&lt;K, V&gt;
</pre>
<h2>Members</h2>
<h3 id="seq.keyed.size">Seq.Keyed#size</h3>
<pre data-language="js">size: number</pre>
<h4>Inherited from</h4>
<code><a href="#seq.size">Seq#size</a></code><h2>Conversion to Seq</h2>
<h3 id="seq.keyed.toseq">Seq.Keyed#toSeq()</h3>
<p>Returns itself</p> <pre data-language="js">toSeq(): Seq.Keyed&lt;K, V&gt;
</pre>
<h4>Overrides</h4>
<code><a href="#iterable.toseq">Iterable#toSeq</a></code><h3 id="seq.keyed.tokeyedseq">Seq.Keyed#toKeyedSeq()</h3>
<p>Returns a Seq.Keyed from this Iterable where indices are treated as keys.</p> <pre data-language="js">toKeyedSeq(): Seq.Keyed&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tokeyedseq">Iterable#toKeyedSeq</a></code><h4>Discussion</h4>
<p>This is useful if you want to operate on an Iterable.Indexed and preserve the [index, value] pairs.</p> <p>The returned Seq will have identical iteration order as this Iterable.</p> <p>Example:</p> <pre data-language="js">var indexedSeq = Immutable.Seq.of('A', 'B', 'C');
indexedSeq.filter(v =&gt; v === 'B').toString() // Seq [ 'B' ]
var keyedSeq = indexedSeq.toKeyedSeq();
keyedSeq.filter(v =&gt; v === 'B').toString() // Seq { 1: 'B' }</pre>
<h3 id="seq.keyed.toindexedseq">Seq.Keyed#toIndexedSeq()</h3>
<p>Returns an Seq.Indexed of the values of this Iterable, discarding keys.</p> <pre data-language="js">toIndexedSeq(): Seq.Indexed&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toindexedseq">Iterable#toIndexedSeq</a></code><h3 id="seq.keyed.tosetseq">Seq.Keyed#toSetSeq()</h3>
<p>Returns a Seq.Set of the values of this Iterable, discarding keys.</p> <pre data-language="js">toSetSeq(): Seq.Set&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tosetseq">Iterable#toSetSeq</a></code><h2>Force evaluation</h2>
<h3 id="seq.keyed.cacheresult">Seq.Keyed#cacheResult()</h3>
<p>Because Sequences are lazy and designed to be chained together, they do not cache their results. For example, this map function is called a total of 6 times, as each <code><a href="#seq.join">join</a></code> iterates the Seq of three values.</p> <pre data-language="js">cacheResult(): Seq&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#seq.cacheresult">Seq#cacheResult</a></code><h4>Example</h4>
<pre data-language="js">var squares = Seq.of(1,2,3).map(x =&gt; x * x);
squares.join() + squares.join();</pre>
<p>If you know a <code>Seq</code> will be used multiple times, it may be more efficient to first cache it in memory. Here, the map function is called only 3 times.</p> <pre data-language="js">var squares = Seq.of(1,2,3).map(x =&gt; x * x).cacheResult();
squares.join() + squares.join();</pre>
<p>Use this method judiciously, as it must fully evaluate a Seq which can be a burden on memory and possibly performance.</p> <p>Note: after calling <code>cacheResult</code>, a Seq will always have a <code><a href="#seq.size">size</a></code>.</p> <h2>Value equality</h2>
<h3 id="seq.keyed.equals">Seq.Keyed#equals()</h3>
<p>True if this and the other Iterable have value equality, as defined by <code><a href="#is">Immutable.is()</a></code>.</p> <pre data-language="js">equals(other: Iterable&lt;K, V&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.equals">Iterable#equals</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Immutable.is(this, other)</code>, but provided to allow for chained expressions.</p> <h3 id="seq.keyed.hashcode">Seq.Keyed#hashCode()</h3>
<p>Computes and returns the hashed identity for this Iterable.</p> <pre data-language="js">hashCode(): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.hashcode">Iterable#hashCode</a></code><h4>Discussion</h4>
<p>The <code>hashCode</code> of an Iterable is used to determine potential equality, and is used when adding this to a <code><a href="#iterable.set">Set</a></code> or as a key in a <code><a href="#map">Map</a></code>, enabling lookup via a different instance.</p> <pre data-language="js">var a = List.of(1, 2, 3);
var b = List.of(1, 2, 3);
assert(a !== b); // different instances
var set = Set.of(a);
assert(set.has(b) === true);</pre>
<p>If two values have the same <code>hashCode</code>, they are <a href="http://en.wikipedia.org/wiki/Collision_(computer_science)">not guaranteed to be equal</a>. If two values have different <code>hashCode</code>s, they must not be equal.</p> <h2>Reading values</h2>
<h3 id="seq.keyed.get">Seq.Keyed#get()</h3>
<p>Returns the value associated with the provided key, or notSetValue if the Iterable does not contain this key.</p> <pre data-language="js">get(key: K, notSetValue?: V): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.get">Iterable#get</a></code><h4>Discussion</h4>
<p>Note: it is possible a key may be associated with an <code>undefined</code> value, so if <code>notSetValue</code> is not provided and this method returns <code>undefined</code>, that does not guarantee the key was not found.</p> <h3 id="seq.keyed.has">Seq.Keyed#has()</h3>
<p>True if a key exists within this <code>Iterable</code>, using <code><a href="#is">Immutable.is</a></code> to determine equality</p> <pre data-language="js">has(key: K): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.has">Iterable#has</a></code><h3 id="seq.keyed.includes">Seq.Keyed#includes()</h3>
<p>True if a value exists within this <code>Iterable</code>, using <code><a href="#is">Immutable.is</a></code> to determine equality</p> <pre data-language="js">includes(value: V): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.includes">Iterable#includes</a></code><h4>alias</h4>
<code>contains()</code><h3 id="seq.keyed.first">Seq.Keyed#first()</h3>
<p>The first value in the Iterable.</p> <pre data-language="js">first(): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.first">Iterable#first</a></code><h3 id="seq.keyed.last">Seq.Keyed#last()</h3>
<p>The last value in the Iterable.</p> <pre data-language="js">last(): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.last">Iterable#last</a></code><h2>Reading deep values</h2>
<h3 id="seq.keyed.getin">Seq.Keyed#getIn()</h3>
<p>Returns the value found by following a path of keys or indices through nested Iterables.</p> <pre data-language="js">getIn(searchKeyPath: Array&lt;any&gt;, notSetValue?: any): any
getIn(searchKeyPath: Iterable&lt;any, any&gt;, notSetValue?: any): any
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.getin">Iterable#getIn</a></code><h3 id="seq.keyed.hasin">Seq.Keyed#hasIn()</h3>
<p>True if the result of following a path of keys or indices through nested Iterables results in a set value.</p> <pre data-language="js">hasIn(searchKeyPath: Array&lt;any&gt;): boolean
hasIn(searchKeyPath: Iterable&lt;any, any&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.hasin">Iterable#hasIn</a></code><h2>Conversion to JavaScript types</h2>
<h3 id="seq.keyed.tojs">Seq.Keyed#toJS()</h3>
<p>Deeply converts this Iterable to equivalent JS.</p> <pre data-language="js">toJS(): any
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tojs">Iterable#toJS</a></code><h4>alias</h4>
<code>toJSON()</code><h4>Discussion</h4>
<p><code>Iterable.Indexeds</code>, and <code>Iterable.Sets</code> become Arrays, while <code>Iterable.Keyeds</code> become Objects.</p> <h3 id="seq.keyed.toarray">Seq.Keyed#toArray()</h3>
<p>Shallowly converts this iterable to an Array, discarding keys.</p> <pre data-language="js">toArray(): Array&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toarray">Iterable#toArray</a></code><h3 id="seq.keyed.toobject">Seq.Keyed#toObject()</h3>
<p>Shallowly converts this Iterable to an Object.</p> <pre data-language="js">toObject(): {[key: string]: V}
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toobject">Iterable#toObject</a></code><h4>Discussion</h4>
<p>Throws if keys are not strings.</p> <h2>Conversion to Collections</h2>
<h3 id="seq.keyed.tomap">Seq.Keyed#toMap()</h3>
<p>Converts this Iterable to a Map, Throws if keys are not hashable.</p> <pre data-language="js">toMap(): Map&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tomap">Iterable#toMap</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Map(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="seq.keyed.toorderedmap">Seq.Keyed#toOrderedMap()</h3>
<p>Converts this Iterable to a Map, maintaining the order of iteration.</p> <pre data-language="js">toOrderedMap(): OrderedMap&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toorderedmap">Iterable#toOrderedMap</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>OrderedMap(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="seq.keyed.toset">Seq.Keyed#toSet()</h3>
<p>Converts this Iterable to a Set, discarding keys. Throws if values are not hashable.</p> <pre data-language="js">toSet(): Set&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toset">Iterable#toSet</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Set(this)</code>, but provided to allow for chained expressions.</p> <h3 id="seq.keyed.toorderedset">Seq.Keyed#toOrderedSet()</h3>
<p>Converts this Iterable to a Set, maintaining the order of iteration and discarding keys.</p> <pre data-language="js">toOrderedSet(): OrderedSet&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toorderedset">Iterable#toOrderedSet</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>OrderedSet(this.valueSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="seq.keyed.tolist">Seq.Keyed#toList()</h3>
<p>Converts this Iterable to a List, discarding keys.</p> <pre data-language="js">toList(): List&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tolist">Iterable#toList</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>List(this)</code>, but provided to allow for chained expressions.</p> <h3 id="seq.keyed.tostack">Seq.Keyed#toStack()</h3>
<p>Converts this Iterable to a Stack, discarding keys. Throws if values are not hashable.</p> <pre data-language="js">toStack(): Stack&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tostack">Iterable#toStack</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Stack(this)</code>, but provided to allow for chained expressions.</p> <h2>Iterators</h2>
<h3 id="seq.keyed.keys">Seq.Keyed#keys()</h3>
<p>An iterator of this <code>Iterable</code>'s keys.</p> <pre data-language="js">keys(): Iterator&lt;K&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keys">Iterable#keys</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.keyseq">keySeq</a></code> instead, if this is what you want.</p> <h3 id="seq.keyed.values">Seq.Keyed#values()</h3>
<p>An iterator of this <code>Iterable</code>'s values.</p> <pre data-language="js">values(): Iterator&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.values">Iterable#values</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.valueseq">valueSeq</a></code> instead, if this is what you want.</p> <h3 id="seq.keyed.entries">Seq.Keyed#entries()</h3>
<p>An iterator of this <code>Iterable</code>'s entries as <code>[key, value]</code> tuples.</p> <pre data-language="js">entries(): Iterator&lt;Array&lt;any&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.entries">Iterable#entries</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.entryseq">entrySeq</a></code> instead, if this is what you want.</p> <h2>Iterables (Seq)</h2>
<h3 id="seq.keyed.keyseq">Seq.Keyed#keySeq()</h3>
<p>Returns a new Seq.Indexed of the keys of this Iterable, discarding values.</p> <pre data-language="js">keySeq(): Seq.Indexed&lt;K&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyseq">Iterable#keySeq</a></code><h3 id="seq.keyed.valueseq">Seq.Keyed#valueSeq()</h3>
<p>Returns an Seq.Indexed of the values of this Iterable, discarding keys.</p> <pre data-language="js">valueSeq(): Seq.Indexed&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.valueseq">Iterable#valueSeq</a></code><h3 id="seq.keyed.entryseq">Seq.Keyed#entrySeq()</h3>
<p>Returns a new Seq.Indexed of [key, value] tuples.</p> <pre data-language="js">entrySeq(): Seq.Indexed&lt;Array&lt;any&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.entryseq">Iterable#entrySeq</a></code><h2>Sequence algorithms</h2>
<h3 id="seq.keyed.map">Seq.Keyed#map()</h3>
<p>Returns a new Iterable of the same type with values passed through a <code>mapper</code> function.</p> <pre data-language="js">map&lt;M&gt;(mapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; M,context?: any): Iterable&lt;K, M&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.map">Iterable#map</a></code><h4>Example</h4>
<pre data-language="js">Seq({ a: 1, b: 2 }).map(x =&gt; 10 * x)
// Seq { a: 10, b: 20 }</pre>
<h3 id="seq.keyed.filter">Seq.Keyed#filter()</h3>
<p>Returns a new Iterable of the same type with only the entries for which the <code>predicate</code> function returns true.</p> <pre data-language="js">filter(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.filter">Iterable#filter</a></code><h4>Example</h4>
<pre data-language="js">Seq({a:1,b:2,c:3,d:4}).filter(x =&gt; x % 2 === 0)
// Seq { b: 2, d: 4 }</pre>
<h3 id="seq.keyed.filternot">Seq.Keyed#filterNot()</h3>
<p>Returns a new Iterable of the same type with only the entries for which the <code>predicate</code> function returns false.</p> <pre data-language="js">filterNot(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.filternot">Iterable#filterNot</a></code><h4>Example</h4>
<pre data-language="js">Seq({a:1,b:2,c:3,d:4}).filterNot(x =&gt; x % 2 === 0)
// Seq { a: 1, c: 3 }</pre>
<h3 id="seq.keyed.reverse">Seq.Keyed#reverse()</h3>
<p>Returns a new Iterable of the same type in reverse order.</p> <pre data-language="js">reverse(): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reverse">Iterable#reverse</a></code><h3 id="seq.keyed.sort">Seq.Keyed#sort()</h3>
<p>Returns a new Iterable of the same type which includes the same entries, stably sorted by using a <code>comparator</code>.</p> <pre data-language="js">sort(comparator?: (valueA: V, valueB: V) =&gt; number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.sort">Iterable#sort</a></code><h4>Discussion</h4>
<p>If a <code>comparator</code> is not provided, a default comparator uses <code>&lt;</code> and <code>&gt;</code>.</p> <p><code>comparator(valueA, valueB)</code>:</p> <ul> <li>Returns <code>0</code> if the elements should not be swapped.</li> <li>Returns <code>-1</code> (or any negative number) if <code>valueA</code> comes before <code>valueB</code>
</li> <li>Returns <code>1</code> (or any positive number) if <code>valueA</code> comes after <code>valueB</code>
</li> <li>Is pure, i.e. it must always return the same value for the same pair of values.</li> </ul> <p>When sorting collections which have no defined order, their ordered equivalents will be returned. e.g. <code>map.sort()</code> returns OrderedMap.</p> <h3 id="seq.keyed.sortby">Seq.Keyed#sortBy()</h3>
<p>Like <code><a href="#iterable.sort">sort</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for sorting by more sophisticated means:</p> <pre data-language="js">sortBy&lt;C&gt;(comparatorValueMapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.sortby">Iterable#sortBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.sortBy(hitter =&gt; hitter.avgHits);</pre>
<h3 id="seq.keyed.groupby">Seq.Keyed#groupBy()</h3>
<p>Returns a <code><a href="#iterable.keyed">Iterable.Keyed</a></code> of <code>Iterable.Keyeds</code>, grouped by the return value of the <code>grouper</code> function.</p> <pre data-language="js">groupBy&lt;G&gt;(grouper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; G,context?: any): Seq.Keyed&lt;G, Iterable&lt;K, V&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.groupby">Iterable#groupBy</a></code><h4>Discussion</h4>
<p>Note: This is always an eager operation.</p> <h2>Side effects</h2>
<h3 id="seq.keyed.foreach">Seq.Keyed#forEach()</h3>
<p>The <code>sideEffect</code> is executed for every entry in the Iterable.</p> <pre data-language="js">forEach(sideEffect: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; any,context?: any): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.foreach">Iterable#forEach</a></code><h4>Discussion</h4>
<p>Unlike <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">Array#forEach</a></code>, if any call of <code>sideEffect</code> returns <code>false</code>, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).</p> <h2>Creating subsets</h2>
<h3 id="seq.keyed.slice">Seq.Keyed#slice()</h3>
<p>Returns a new Iterable of the same type representing a portion of this Iterable from start up to but not including end.</p> <pre data-language="js">slice(begin?: number, end?: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.slice">Iterable#slice</a></code><h4>Discussion</h4>
<p>If begin is negative, it is offset from the end of the Iterable. e.g. <code>slice(-2)</code> returns a Iterable of the last two entries. If it is not provided the new Iterable will begin at the beginning of this Iterable.</p> <p>If end is negative, it is offset from the end of the Iterable. e.g. <code>slice(0, -1)</code> returns an Iterable of everything but the last entry. If it is not provided, the new Iterable will continue through the end of this Iterable.</p> <p>If the requested slice is equivalent to the current Iterable, then it will return itself.</p> <h3 id="seq.keyed.rest">Seq.Keyed#rest()</h3>
<p>Returns a new Iterable of the same type containing all entries except the first.</p> <pre data-language="js">rest(): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.rest">Iterable#rest</a></code><h3 id="seq.keyed.butlast">Seq.Keyed#butLast()</h3>
<p>Returns a new Iterable of the same type containing all entries except the last.</p> <pre data-language="js">butLast(): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.butlast">Iterable#butLast</a></code><h3 id="seq.keyed.skip">Seq.Keyed#skip()</h3>
<p>Returns a new Iterable of the same type which excludes the first <code>amount</code> entries from this Iterable.</p> <pre data-language="js">skip(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skip">Iterable#skip</a></code><h3 id="seq.keyed.skiplast">Seq.Keyed#skipLast()</h3>
<p>Returns a new Iterable of the same type which excludes the last <code>amount</code> entries from this Iterable.</p> <pre data-language="js">skipLast(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skiplast">Iterable#skipLast</a></code><h3 id="seq.keyed.skipwhile">Seq.Keyed#skipWhile()</h3>
<p>Returns a new Iterable of the same type which includes entries starting from when <code>predicate</code> first returns false.</p> <pre data-language="js">skipWhile(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skipwhile">Iterable#skipWhile</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .skipWhile(x =&gt; x.match(/g/))
// Seq [ 'cat', 'hat', 'god' ]</pre>
<h3 id="seq.keyed.skipuntil">Seq.Keyed#skipUntil()</h3>
<p>Returns a new Iterable of the same type which includes entries starting from when <code>predicate</code> first returns true.</p> <pre data-language="js">skipUntil(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skipuntil">Iterable#skipUntil</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .skipUntil(x =&gt; x.match(/hat/))
// Seq [ 'hat', 'god' ]</pre>
<h3 id="seq.keyed.take">Seq.Keyed#take()</h3>
<p>Returns a new Iterable of the same type which includes the first <code>amount</code> entries from this Iterable.</p> <pre data-language="js">take(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.take">Iterable#take</a></code><h3 id="seq.keyed.takelast">Seq.Keyed#takeLast()</h3>
<p>Returns a new Iterable of the same type which includes the last <code>amount</code> entries from this Iterable.</p> <pre data-language="js">takeLast(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takelast">Iterable#takeLast</a></code><h3 id="seq.keyed.takewhile">Seq.Keyed#takeWhile()</h3>
<p>Returns a new Iterable of the same type which includes entries from this Iterable as long as the <code>predicate</code> returns true.</p> <pre data-language="js">takeWhile(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takewhile">Iterable#takeWhile</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .takeWhile(x =&gt; x.match(/o/))
// Seq [ 'dog', 'frog' ]</pre>
<h3 id="seq.keyed.takeuntil">Seq.Keyed#takeUntil()</h3>
<p>Returns a new Iterable of the same type which includes entries from this Iterable as long as the <code>predicate</code> returns false.</p> <pre data-language="js">takeUntil(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takeuntil">Iterable#takeUntil</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god').takeUntil(x =&gt; x.match(/at/))
// ['dog', 'frog']</pre>
<h2>Combination</h2>
<h3 id="seq.keyed.concat">Seq.Keyed#concat()</h3>
<p>Returns a new Iterable of the same type with other values and iterable-like concatenated to this one.</p> <pre data-language="js">concat(...valuesOrIterables: any[]): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.concat">Iterable#concat</a></code><h4>Discussion</h4>
<p>For Seqs, all entries will be present in the resulting iterable, even if they have the same key.</p> <h3 id="seq.keyed.flatten">Seq.Keyed#flatten()</h3>
<p>Flattens nested Iterables.</p> <pre data-language="js">flatten(depth?: number): Iterable&lt;any, any&gt;
flatten(shallow?: boolean): Iterable&lt;any, any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.flatten">Iterable#flatten</a></code><h4>Discussion</h4>
<p>Will deeply flatten the Iterable by default, returning an Iterable of the same type, but a <code>depth</code> can be provided in the form of a number or boolean (where true means to shallowly flatten one level). A depth of 0 (or shallow: false) will deeply flatten.</p> <p>Flattens only others Iterable, not Arrays or Objects.</p> <p>Note: <code>flatten(true)</code> operates on Iterable<any iterable v="">&gt; and returns Iterable</any></p> <h3 id="seq.keyed.flatmap">Seq.Keyed#flatMap()</h3>
<p>Flat-maps the Iterable, returning an Iterable of the same type.</p> <pre data-language="js">flatMap&lt;MK, MV&gt;(mapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; Iterable&lt;MK, MV&gt;,context?: any): Iterable&lt;MK, MV&gt;
flatMap&lt;MK, MV&gt;(mapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; any,context?: any): Iterable&lt;MK, MV&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.flatmap">Iterable#flatMap</a></code><h4>Discussion</h4>
<p>Similar to <code>iter.map(...).flatten(true)</code>.</p> <h2>Reducing a value</h2>
<h3 id="seq.keyed.reduce">Seq.Keyed#reduce()</h3>
<p>Reduces the Iterable to a value by calling the <code>reducer</code> for every entry in the Iterable and passing along the reduced value.</p> <pre data-language="js">reduce&lt;R&gt;(reducer: (reduction?: R, value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; R,initialReduction?: R,context?: any): R
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reduce">Iterable#reduce</a></code><h4>see</h4>
<p><code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">Array#reduce</a></code>.</p> <h4>Discussion</h4>
<p>If <code>initialReduction</code> is not provided, or is null, the first item in the Iterable will be used.</p> <h3 id="seq.keyed.reduceright">Seq.Keyed#reduceRight()</h3>
<p>Reduces the Iterable in reverse (from the right side).</p> <pre data-language="js">reduceRight&lt;R&gt;(reducer: (reduction?: R, value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; R,initialReduction?: R,context?: any): R
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reduceright">Iterable#reduceRight</a></code><h4>Discussion</h4>
<p>Note: Similar to this.reverse().reduce(), and provided for parity with <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight">Array#reduceRight</a></code>.</p> <h3 id="seq.keyed.every">Seq.Keyed#every()</h3>
<p>True if <code>predicate</code> returns true for all entries in the Iterable.</p> <pre data-language="js">every(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.every">Iterable#every</a></code><h3 id="seq.keyed.some">Seq.Keyed#some()</h3>
<p>True if <code>predicate</code> returns true for any entry in the Iterable.</p> <pre data-language="js">some(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.some">Iterable#some</a></code><h3 id="seq.keyed.join">Seq.Keyed#join()</h3>
<p>Joins values together as a string, inserting a separator between each. The default separator is <code>","</code>.</p> <pre data-language="js">join(separator?: string): string
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.join">Iterable#join</a></code><h3 id="seq.keyed.isempty">Seq.Keyed#isEmpty()</h3>
<p>Returns true if this Iterable includes no values.</p> <pre data-language="js">isEmpty(): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.isempty">Iterable#isEmpty</a></code><h4>Discussion</h4>
<p>For some lazy <code><a href="#seq">Seq</a></code>, <code>isEmpty</code> might need to iterate to determine emptiness. At most one iteration will occur.</p> <h3 id="seq.keyed.count">Seq.Keyed#count()</h3>
<p>Returns the size of this Iterable.</p> <pre data-language="js">count(): number
count(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.count">Iterable#count</a></code><h4>Discussion</h4>
<p>Regardless of if this Iterable can describe its size lazily (some Seqs cannot), this method will always return the correct size. E.g. it evaluates a lazy <code><a href="#seq">Seq</a></code> if necessary.</p> <p>If <code>predicate</code> is provided, then this returns the count of entries in the Iterable for which the <code>predicate</code> returns true.</p> <h3 id="seq.keyed.countby">Seq.Keyed#countBy()</h3>
<p>Returns a <code><a href="#seq.keyed">Seq.Keyed</a></code> of counts, grouped by the return value of the <code>grouper</code> function.</p> <pre data-language="js">countBy&lt;G&gt;(grouper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; G,context?: any): Map&lt;G, number&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.countby">Iterable#countBy</a></code><h4>Discussion</h4>
<p>Note: This is not a lazy operation.</p> <h2>Search for value</h2>
<h3 id="seq.keyed.find">Seq.Keyed#find()</h3>
<p>Returns the first value for which the <code>predicate</code> returns true.</p> <pre data-language="js">find(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.find">Iterable#find</a></code><h3 id="seq.keyed.findlast">Seq.Keyed#findLast()</h3>
<p>Returns the last value for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLast(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlast">Iterable#findLast</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="seq.keyed.findentry">Seq.Keyed#findEntry()</h3>
<p>Returns the first [key, value] entry for which the <code>predicate</code> returns true.</p> <pre data-language="js">findEntry(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): Array&lt;any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findentry">Iterable#findEntry</a></code><h3 id="seq.keyed.findlastentry">Seq.Keyed#findLastEntry()</h3>
<p>Returns the last [key, value] entry for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLastEntry(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): Array&lt;any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlastentry">Iterable#findLastEntry</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="seq.keyed.findkey">Seq.Keyed#findKey()</h3>
<p>Returns the key for which the <code>predicate</code> returns true.</p> <pre data-language="js">findKey(predicate: (value?: V, key?: K, iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; boolean,context?: any): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findkey">Iterable#findKey</a></code><h3 id="seq.keyed.findlastkey">Seq.Keyed#findLastKey()</h3>
<p>Returns the last key for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLastKey(predicate: (value?: V, key?: K, iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; boolean,context?: any): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlastkey">Iterable#findLastKey</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="seq.keyed.keyof">Seq.Keyed#keyOf()</h3>
<p>Returns the key associated with the search value, or undefined.</p> <pre data-language="js">keyOf(searchValue: V): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyof">Iterable#keyOf</a></code><h3 id="seq.keyed.lastkeyof">Seq.Keyed#lastKeyOf()</h3>
<p>Returns the last key associated with the search value, or undefined.</p> <pre data-language="js">lastKeyOf(searchValue: V): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.lastkeyof">Iterable#lastKeyOf</a></code><h3 id="seq.keyed.max">Seq.Keyed#max()</h3>
<p>Returns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> <pre data-language="js">max(comparator?: (valueA: V, valueB: V) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.max">Iterable#max</a></code><h4>Discussion</h4>
<p>The <code>comparator</code> is used in the same way as <code><a href="#iterable.sort">Iterable#sort</a></code>. If it is not provided, the default comparator is <code>&gt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code>max</code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&gt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> <h3 id="seq.keyed.maxby">Seq.Keyed#maxBy()</h3>
<p>Like <code><a href="#iterable.max">max</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> <pre data-language="js">maxBy&lt;C&gt;(comparatorValueMapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.maxby">Iterable#maxBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.maxBy(hitter =&gt; hitter.avgHits);</pre>
<h3 id="seq.keyed.min">Seq.Keyed#min()</h3>
<p>Returns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> <pre data-language="js">min(comparator?: (valueA: V, valueB: V) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.min">Iterable#min</a></code><h4>Discussion</h4>
<p>The <code>comparator</code> is used in the same way as <code><a href="#iterable.sort">Iterable#sort</a></code>. If it is not provided, the default comparator is <code>&lt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code>min</code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&lt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> <h3 id="seq.keyed.minby">Seq.Keyed#minBy()</h3>
<p>Like <code><a href="#iterable.min">min</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> <pre data-language="js">minBy&lt;C&gt;(comparatorValueMapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.minby">Iterable#minBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.minBy(hitter =&gt; hitter.avgHits);</pre>
<h2>Comparison</h2>
<h3 id="seq.keyed.issubset">Seq.Keyed#isSubset()</h3>
<p>True if <code>iter</code> includes every value in this Iterable.</p> <pre data-language="js">isSubset(iter: Iterable&lt;any, V&gt;): boolean
isSubset(iter: Array&lt;V&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.issubset">Iterable#isSubset</a></code><h3 id="seq.keyed.issuperset">Seq.Keyed#isSuperset()</h3>
<p>True if this Iterable includes every value in <code>iter</code>.</p> <pre data-language="js">isSuperset(iter: Iterable&lt;any, V&gt;): boolean
isSuperset(iter: Array&lt;V&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.issuperset">Iterable#isSuperset</a></code><h2>Sequence functions</h2>
<h3 id="seq.keyed.flip">Seq.Keyed#flip()</h3>
<p>Returns a new Iterable.Keyed of the same type where the keys and values have been flipped.</p> <pre data-language="js">flip(): Iterable.Keyed&lt;V, K&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyed.flip">Iterable.Keyed#flip</a></code><h4>Example</h4>
<pre data-language="js">Seq({ a: 'z', b: 'y' }).flip() // { z: 'a', y: 'b' }</pre>
<h3 id="seq.keyed.mapkeys">Seq.Keyed#mapKeys()</h3>
<p>Returns a new Iterable.Keyed of the same type with keys passed through a <code>mapper</code> function.</p> <pre data-language="js">mapKeys&lt;M&gt;(mapper: (key?: K, value?: V, iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; M,context?: any): Iterable.Keyed&lt;M, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyed.mapkeys">Iterable.Keyed#mapKeys</a></code><h4>Example</h4>
<pre data-language="js">Seq({ a: 1, b: 2 })
  .mapKeys(x =&gt; x.toUpperCase())
// Seq { A: 1, B: 2 }</pre>
<h3 id="seq.keyed.mapentries">Seq.Keyed#mapEntries()</h3>
<p>Returns a new Iterable.Keyed of the same type with entries ([key, value] tuples) passed through a <code>mapper</code> function.</p> <pre data-language="js">mapEntries&lt;KM, VM&gt;(mapper: (entry?: Array&lt;any&gt;,index?: number,iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; Array&lt;any&gt;,context?: any): Iterable.Keyed&lt;KM, VM&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyed.mapentries">Iterable.Keyed#mapEntries</a></code><h4>Example</h4>
<pre data-language="js">Seq({ a: 1, b: 2 })
  .mapEntries(([k, v]) =&gt; [k.toUpperCase(), v * 2])
// Seq { A: 2, B: 4 }</pre>
<h1 id="seq.keyed">Seq.Keyed</h1>
<p><code>Seq</code> which represents key-value pairs.</p> <pre data-language="js">class Seq.Keyed&lt;K, V&gt; extends Seq&lt;K, V&gt;, Iterable.Keyed&lt;K, V&gt;</pre>
<h2>Construction</h2>
<h3 id="seq.keyed()">Seq.Keyed()</h3>
<p>Always returns a Seq.Keyed, if input is not keyed, expects an iterable of [K, V] tuples.</p> <pre data-language="js">Seq.Keyed&lt;K, V&gt;(): Seq.Keyed&lt;K, V&gt;
Seq.Keyed&lt;K, V&gt;(seq: Iterable.Keyed&lt;K, V&gt;): Seq.Keyed&lt;K, V&gt;
Seq.Keyed&lt;K, V&gt;(seq: Iterable&lt;any, any&gt;): Seq.Keyed&lt;K, V&gt;
Seq.Keyed&lt;K, V&gt;(array: Array&lt;any&gt;): Seq.Keyed&lt;K, V&gt;
Seq.Keyed&lt;V&gt;(obj: {[key: string]: V}): Seq.Keyed&lt;string, V&gt;
Seq.Keyed&lt;K, V&gt;(iterator: Iterator&lt;any&gt;): Seq.Keyed&lt;K, V&gt;
Seq.Keyed&lt;K, V&gt;(iterable: Object): Seq.Keyed&lt;K, V&gt;
</pre>
<h2>Members</h2>
<h3 id="seq.keyed.size">Seq.Keyed#size</h3>
<pre data-language="js">size: number</pre>
<h4>Inherited from</h4>
<code><a href="#seq.size">Seq#size</a></code><h2>Conversion to Seq</h2>
<h3 id="seq.keyed.toseq">Seq.Keyed#toSeq()</h3>
<p>Returns itself</p> <pre data-language="js">toSeq(): Seq.Keyed&lt;K, V&gt;
</pre>
<h4>Overrides</h4>
<code><a href="#iterable.toseq">Iterable#toSeq</a></code><h3 id="seq.keyed.tokeyedseq">Seq.Keyed#toKeyedSeq()</h3>
<p>Returns a Seq.Keyed from this Iterable where indices are treated as keys.</p> <pre data-language="js">toKeyedSeq(): Seq.Keyed&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tokeyedseq">Iterable#toKeyedSeq</a></code><h4>Discussion</h4>
<p>This is useful if you want to operate on an Iterable.Indexed and preserve the [index, value] pairs.</p> <p>The returned Seq will have identical iteration order as this Iterable.</p> <p>Example:</p> <pre data-language="js">var indexedSeq = Immutable.Seq.of('A', 'B', 'C');
indexedSeq.filter(v =&gt; v === 'B').toString() // Seq [ 'B' ]
var keyedSeq = indexedSeq.toKeyedSeq();
keyedSeq.filter(v =&gt; v === 'B').toString() // Seq { 1: 'B' }</pre>
<h3 id="seq.keyed.toindexedseq">Seq.Keyed#toIndexedSeq()</h3>
<p>Returns an Seq.Indexed of the values of this Iterable, discarding keys.</p> <pre data-language="js">toIndexedSeq(): Seq.Indexed&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toindexedseq">Iterable#toIndexedSeq</a></code><h3 id="seq.keyed.tosetseq">Seq.Keyed#toSetSeq()</h3>
<p>Returns a Seq.Set of the values of this Iterable, discarding keys.</p> <pre data-language="js">toSetSeq(): Seq.Set&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tosetseq">Iterable#toSetSeq</a></code><h2>Force evaluation</h2>
<h3 id="seq.keyed.cacheresult">Seq.Keyed#cacheResult()</h3>
<p>Because Sequences are lazy and designed to be chained together, they do not cache their results. For example, this map function is called a total of 6 times, as each <code><a href="#seq.join">join</a></code> iterates the Seq of three values.</p> <pre data-language="js">cacheResult(): Seq&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#seq.cacheresult">Seq#cacheResult</a></code><h4>Example</h4>
<pre data-language="js">var squares = Seq.of(1,2,3).map(x =&gt; x * x);
squares.join() + squares.join();</pre>
<p>If you know a <code>Seq</code> will be used multiple times, it may be more efficient to first cache it in memory. Here, the map function is called only 3 times.</p> <pre data-language="js">var squares = Seq.of(1,2,3).map(x =&gt; x * x).cacheResult();
squares.join() + squares.join();</pre>
<p>Use this method judiciously, as it must fully evaluate a Seq which can be a burden on memory and possibly performance.</p> <p>Note: after calling <code>cacheResult</code>, a Seq will always have a <code><a href="#seq.size">size</a></code>.</p> <h2>Value equality</h2>
<h3 id="seq.keyed.equals">Seq.Keyed#equals()</h3>
<p>True if this and the other Iterable have value equality, as defined by <code><a href="#is">Immutable.is()</a></code>.</p> <pre data-language="js">equals(other: Iterable&lt;K, V&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.equals">Iterable#equals</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Immutable.is(this, other)</code>, but provided to allow for chained expressions.</p> <h3 id="seq.keyed.hashcode">Seq.Keyed#hashCode()</h3>
<p>Computes and returns the hashed identity for this Iterable.</p> <pre data-language="js">hashCode(): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.hashcode">Iterable#hashCode</a></code><h4>Discussion</h4>
<p>The <code>hashCode</code> of an Iterable is used to determine potential equality, and is used when adding this to a <code><a href="#iterable.set">Set</a></code> or as a key in a <code><a href="#map">Map</a></code>, enabling lookup via a different instance.</p> <pre data-language="js">var a = List.of(1, 2, 3);
var b = List.of(1, 2, 3);
assert(a !== b); // different instances
var set = Set.of(a);
assert(set.has(b) === true);</pre>
<p>If two values have the same <code>hashCode</code>, they are <a href="http://en.wikipedia.org/wiki/Collision_(computer_science)">not guaranteed to be equal</a>. If two values have different <code>hashCode</code>s, they must not be equal.</p> <h2>Reading values</h2>
<h3 id="seq.keyed.get">Seq.Keyed#get()</h3>
<p>Returns the value associated with the provided key, or notSetValue if the Iterable does not contain this key.</p> <pre data-language="js">get(key: K, notSetValue?: V): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.get">Iterable#get</a></code><h4>Discussion</h4>
<p>Note: it is possible a key may be associated with an <code>undefined</code> value, so if <code>notSetValue</code> is not provided and this method returns <code>undefined</code>, that does not guarantee the key was not found.</p> <h3 id="seq.keyed.has">Seq.Keyed#has()</h3>
<p>True if a key exists within this <code>Iterable</code>, using <code><a href="#is">Immutable.is</a></code> to determine equality</p> <pre data-language="js">has(key: K): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.has">Iterable#has</a></code><h3 id="seq.keyed.includes">Seq.Keyed#includes()</h3>
<p>True if a value exists within this <code>Iterable</code>, using <code><a href="#is">Immutable.is</a></code> to determine equality</p> <pre data-language="js">includes(value: V): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.includes">Iterable#includes</a></code><h4>alias</h4>
<code>contains()</code><h3 id="seq.keyed.first">Seq.Keyed#first()</h3>
<p>The first value in the Iterable.</p> <pre data-language="js">first(): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.first">Iterable#first</a></code><h3 id="seq.keyed.last">Seq.Keyed#last()</h3>
<p>The last value in the Iterable.</p> <pre data-language="js">last(): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.last">Iterable#last</a></code><h2>Reading deep values</h2>
<h3 id="seq.keyed.getin">Seq.Keyed#getIn()</h3>
<p>Returns the value found by following a path of keys or indices through nested Iterables.</p> <pre data-language="js">getIn(searchKeyPath: Array&lt;any&gt;, notSetValue?: any): any
getIn(searchKeyPath: Iterable&lt;any, any&gt;, notSetValue?: any): any
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.getin">Iterable#getIn</a></code><h3 id="seq.keyed.hasin">Seq.Keyed#hasIn()</h3>
<p>True if the result of following a path of keys or indices through nested Iterables results in a set value.</p> <pre data-language="js">hasIn(searchKeyPath: Array&lt;any&gt;): boolean
hasIn(searchKeyPath: Iterable&lt;any, any&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.hasin">Iterable#hasIn</a></code><h2>Conversion to JavaScript types</h2>
<h3 id="seq.keyed.tojs">Seq.Keyed#toJS()</h3>
<p>Deeply converts this Iterable to equivalent JS.</p> <pre data-language="js">toJS(): any
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tojs">Iterable#toJS</a></code><h4>alias</h4>
<code>toJSON()</code><h4>Discussion</h4>
<p><code>Iterable.Indexeds</code>, and <code>Iterable.Sets</code> become Arrays, while <code>Iterable.Keyeds</code> become Objects.</p> <h3 id="seq.keyed.toarray">Seq.Keyed#toArray()</h3>
<p>Shallowly converts this iterable to an Array, discarding keys.</p> <pre data-language="js">toArray(): Array&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toarray">Iterable#toArray</a></code><h3 id="seq.keyed.toobject">Seq.Keyed#toObject()</h3>
<p>Shallowly converts this Iterable to an Object.</p> <pre data-language="js">toObject(): {[key: string]: V}
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toobject">Iterable#toObject</a></code><h4>Discussion</h4>
<p>Throws if keys are not strings.</p> <h2>Conversion to Collections</h2>
<h3 id="seq.keyed.tomap">Seq.Keyed#toMap()</h3>
<p>Converts this Iterable to a Map, Throws if keys are not hashable.</p> <pre data-language="js">toMap(): Map&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tomap">Iterable#toMap</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Map(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="seq.keyed.toorderedmap">Seq.Keyed#toOrderedMap()</h3>
<p>Converts this Iterable to a Map, maintaining the order of iteration.</p> <pre data-language="js">toOrderedMap(): OrderedMap&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toorderedmap">Iterable#toOrderedMap</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>OrderedMap(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="seq.keyed.toset">Seq.Keyed#toSet()</h3>
<p>Converts this Iterable to a Set, discarding keys. Throws if values are not hashable.</p> <pre data-language="js">toSet(): Set&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toset">Iterable#toSet</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Set(this)</code>, but provided to allow for chained expressions.</p> <h3 id="seq.keyed.toorderedset">Seq.Keyed#toOrderedSet()</h3>
<p>Converts this Iterable to a Set, maintaining the order of iteration and discarding keys.</p> <pre data-language="js">toOrderedSet(): OrderedSet&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toorderedset">Iterable#toOrderedSet</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>OrderedSet(this.valueSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="seq.keyed.tolist">Seq.Keyed#toList()</h3>
<p>Converts this Iterable to a List, discarding keys.</p> <pre data-language="js">toList(): List&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tolist">Iterable#toList</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>List(this)</code>, but provided to allow for chained expressions.</p> <h3 id="seq.keyed.tostack">Seq.Keyed#toStack()</h3>
<p>Converts this Iterable to a Stack, discarding keys. Throws if values are not hashable.</p> <pre data-language="js">toStack(): Stack&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tostack">Iterable#toStack</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Stack(this)</code>, but provided to allow for chained expressions.</p> <h2>Iterators</h2>
<h3 id="seq.keyed.keys">Seq.Keyed#keys()</h3>
<p>An iterator of this <code>Iterable</code>'s keys.</p> <pre data-language="js">keys(): Iterator&lt;K&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keys">Iterable#keys</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.keyseq">keySeq</a></code> instead, if this is what you want.</p> <h3 id="seq.keyed.values">Seq.Keyed#values()</h3>
<p>An iterator of this <code>Iterable</code>'s values.</p> <pre data-language="js">values(): Iterator&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.values">Iterable#values</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.valueseq">valueSeq</a></code> instead, if this is what you want.</p> <h3 id="seq.keyed.entries">Seq.Keyed#entries()</h3>
<p>An iterator of this <code>Iterable</code>'s entries as <code>[key, value]</code> tuples.</p> <pre data-language="js">entries(): Iterator&lt;Array&lt;any&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.entries">Iterable#entries</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.entryseq">entrySeq</a></code> instead, if this is what you want.</p> <h2>Iterables (Seq)</h2>
<h3 id="seq.keyed.keyseq">Seq.Keyed#keySeq()</h3>
<p>Returns a new Seq.Indexed of the keys of this Iterable, discarding values.</p> <pre data-language="js">keySeq(): Seq.Indexed&lt;K&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyseq">Iterable#keySeq</a></code><h3 id="seq.keyed.valueseq">Seq.Keyed#valueSeq()</h3>
<p>Returns an Seq.Indexed of the values of this Iterable, discarding keys.</p> <pre data-language="js">valueSeq(): Seq.Indexed&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.valueseq">Iterable#valueSeq</a></code><h3 id="seq.keyed.entryseq">Seq.Keyed#entrySeq()</h3>
<p>Returns a new Seq.Indexed of [key, value] tuples.</p> <pre data-language="js">entrySeq(): Seq.Indexed&lt;Array&lt;any&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.entryseq">Iterable#entrySeq</a></code><h2>Sequence algorithms</h2>
<h3 id="seq.keyed.map">Seq.Keyed#map()</h3>
<p>Returns a new Iterable of the same type with values passed through a <code>mapper</code> function.</p> <pre data-language="js">map&lt;M&gt;(mapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; M,context?: any): Iterable&lt;K, M&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.map">Iterable#map</a></code><h4>Example</h4>
<pre data-language="js">Seq({ a: 1, b: 2 }).map(x =&gt; 10 * x)
// Seq { a: 10, b: 20 }</pre>
<h3 id="seq.keyed.filter">Seq.Keyed#filter()</h3>
<p>Returns a new Iterable of the same type with only the entries for which the <code>predicate</code> function returns true.</p> <pre data-language="js">filter(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.filter">Iterable#filter</a></code><h4>Example</h4>
<pre data-language="js">Seq({a:1,b:2,c:3,d:4}).filter(x =&gt; x % 2 === 0)
// Seq { b: 2, d: 4 }</pre>
<h3 id="seq.keyed.filternot">Seq.Keyed#filterNot()</h3>
<p>Returns a new Iterable of the same type with only the entries for which the <code>predicate</code> function returns false.</p> <pre data-language="js">filterNot(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.filternot">Iterable#filterNot</a></code><h4>Example</h4>
<pre data-language="js">Seq({a:1,b:2,c:3,d:4}).filterNot(x =&gt; x % 2 === 0)
// Seq { a: 1, c: 3 }</pre>
<h3 id="seq.keyed.reverse">Seq.Keyed#reverse()</h3>
<p>Returns a new Iterable of the same type in reverse order.</p> <pre data-language="js">reverse(): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reverse">Iterable#reverse</a></code><h3 id="seq.keyed.sort">Seq.Keyed#sort()</h3>
<p>Returns a new Iterable of the same type which includes the same entries, stably sorted by using a <code>comparator</code>.</p> <pre data-language="js">sort(comparator?: (valueA: V, valueB: V) =&gt; number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.sort">Iterable#sort</a></code><h4>Discussion</h4>
<p>If a <code>comparator</code> is not provided, a default comparator uses <code>&lt;</code> and <code>&gt;</code>.</p> <p><code>comparator(valueA, valueB)</code>:</p> <ul> <li>Returns <code>0</code> if the elements should not be swapped.</li> <li>Returns <code>-1</code> (or any negative number) if <code>valueA</code> comes before <code>valueB</code>
</li> <li>Returns <code>1</code> (or any positive number) if <code>valueA</code> comes after <code>valueB</code>
</li> <li>Is pure, i.e. it must always return the same value for the same pair of values.</li> </ul> <p>When sorting collections which have no defined order, their ordered equivalents will be returned. e.g. <code>map.sort()</code> returns OrderedMap.</p> <h3 id="seq.keyed.sortby">Seq.Keyed#sortBy()</h3>
<p>Like <code><a href="#iterable.sort">sort</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for sorting by more sophisticated means:</p> <pre data-language="js">sortBy&lt;C&gt;(comparatorValueMapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.sortby">Iterable#sortBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.sortBy(hitter =&gt; hitter.avgHits);</pre>
<h3 id="seq.keyed.groupby">Seq.Keyed#groupBy()</h3>
<p>Returns a <code><a href="#iterable.keyed">Iterable.Keyed</a></code> of <code>Iterable.Keyeds</code>, grouped by the return value of the <code>grouper</code> function.</p> <pre data-language="js">groupBy&lt;G&gt;(grouper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; G,context?: any): Seq.Keyed&lt;G, Iterable&lt;K, V&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.groupby">Iterable#groupBy</a></code><h4>Discussion</h4>
<p>Note: This is always an eager operation.</p> <h2>Side effects</h2>
<h3 id="seq.keyed.foreach">Seq.Keyed#forEach()</h3>
<p>The <code>sideEffect</code> is executed for every entry in the Iterable.</p> <pre data-language="js">forEach(sideEffect: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; any,context?: any): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.foreach">Iterable#forEach</a></code><h4>Discussion</h4>
<p>Unlike <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">Array#forEach</a></code>, if any call of <code>sideEffect</code> returns <code>false</code>, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).</p> <h2>Creating subsets</h2>
<h3 id="seq.keyed.slice">Seq.Keyed#slice()</h3>
<p>Returns a new Iterable of the same type representing a portion of this Iterable from start up to but not including end.</p> <pre data-language="js">slice(begin?: number, end?: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.slice">Iterable#slice</a></code><h4>Discussion</h4>
<p>If begin is negative, it is offset from the end of the Iterable. e.g. <code>slice(-2)</code> returns a Iterable of the last two entries. If it is not provided the new Iterable will begin at the beginning of this Iterable.</p> <p>If end is negative, it is offset from the end of the Iterable. e.g. <code>slice(0, -1)</code> returns an Iterable of everything but the last entry. If it is not provided, the new Iterable will continue through the end of this Iterable.</p> <p>If the requested slice is equivalent to the current Iterable, then it will return itself.</p> <h3 id="seq.keyed.rest">Seq.Keyed#rest()</h3>
<p>Returns a new Iterable of the same type containing all entries except the first.</p> <pre data-language="js">rest(): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.rest">Iterable#rest</a></code><h3 id="seq.keyed.butlast">Seq.Keyed#butLast()</h3>
<p>Returns a new Iterable of the same type containing all entries except the last.</p> <pre data-language="js">butLast(): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.butlast">Iterable#butLast</a></code><h3 id="seq.keyed.skip">Seq.Keyed#skip()</h3>
<p>Returns a new Iterable of the same type which excludes the first <code>amount</code> entries from this Iterable.</p> <pre data-language="js">skip(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skip">Iterable#skip</a></code><h3 id="seq.keyed.skiplast">Seq.Keyed#skipLast()</h3>
<p>Returns a new Iterable of the same type which excludes the last <code>amount</code> entries from this Iterable.</p> <pre data-language="js">skipLast(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skiplast">Iterable#skipLast</a></code><h3 id="seq.keyed.skipwhile">Seq.Keyed#skipWhile()</h3>
<p>Returns a new Iterable of the same type which includes entries starting from when <code>predicate</code> first returns false.</p> <pre data-language="js">skipWhile(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skipwhile">Iterable#skipWhile</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .skipWhile(x =&gt; x.match(/g/))
// Seq [ 'cat', 'hat', 'god' ]</pre>
<h3 id="seq.keyed.skipuntil">Seq.Keyed#skipUntil()</h3>
<p>Returns a new Iterable of the same type which includes entries starting from when <code>predicate</code> first returns true.</p> <pre data-language="js">skipUntil(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skipuntil">Iterable#skipUntil</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .skipUntil(x =&gt; x.match(/hat/))
// Seq [ 'hat', 'god' ]</pre>
<h3 id="seq.keyed.take">Seq.Keyed#take()</h3>
<p>Returns a new Iterable of the same type which includes the first <code>amount</code> entries from this Iterable.</p> <pre data-language="js">take(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.take">Iterable#take</a></code><h3 id="seq.keyed.takelast">Seq.Keyed#takeLast()</h3>
<p>Returns a new Iterable of the same type which includes the last <code>amount</code> entries from this Iterable.</p> <pre data-language="js">takeLast(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takelast">Iterable#takeLast</a></code><h3 id="seq.keyed.takewhile">Seq.Keyed#takeWhile()</h3>
<p>Returns a new Iterable of the same type which includes entries from this Iterable as long as the <code>predicate</code> returns true.</p> <pre data-language="js">takeWhile(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takewhile">Iterable#takeWhile</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .takeWhile(x =&gt; x.match(/o/))
// Seq [ 'dog', 'frog' ]</pre>
<h3 id="seq.keyed.takeuntil">Seq.Keyed#takeUntil()</h3>
<p>Returns a new Iterable of the same type which includes entries from this Iterable as long as the <code>predicate</code> returns false.</p> <pre data-language="js">takeUntil(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takeuntil">Iterable#takeUntil</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god').takeUntil(x =&gt; x.match(/at/))
// ['dog', 'frog']</pre>
<h2>Combination</h2>
<h3 id="seq.keyed.concat">Seq.Keyed#concat()</h3>
<p>Returns a new Iterable of the same type with other values and iterable-like concatenated to this one.</p> <pre data-language="js">concat(...valuesOrIterables: any[]): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.concat">Iterable#concat</a></code><h4>Discussion</h4>
<p>For Seqs, all entries will be present in the resulting iterable, even if they have the same key.</p> <h3 id="seq.keyed.flatten">Seq.Keyed#flatten()</h3>
<p>Flattens nested Iterables.</p> <pre data-language="js">flatten(depth?: number): Iterable&lt;any, any&gt;
flatten(shallow?: boolean): Iterable&lt;any, any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.flatten">Iterable#flatten</a></code><h4>Discussion</h4>
<p>Will deeply flatten the Iterable by default, returning an Iterable of the same type, but a <code>depth</code> can be provided in the form of a number or boolean (where true means to shallowly flatten one level). A depth of 0 (or shallow: false) will deeply flatten.</p> <p>Flattens only others Iterable, not Arrays or Objects.</p> <p>Note: <code>flatten(true)</code> operates on Iterable<any iterable v="">&gt; and returns Iterable</any></p> <h3 id="seq.keyed.flatmap">Seq.Keyed#flatMap()</h3>
<p>Flat-maps the Iterable, returning an Iterable of the same type.</p> <pre data-language="js">flatMap&lt;MK, MV&gt;(mapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; Iterable&lt;MK, MV&gt;,context?: any): Iterable&lt;MK, MV&gt;
flatMap&lt;MK, MV&gt;(mapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; any,context?: any): Iterable&lt;MK, MV&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.flatmap">Iterable#flatMap</a></code><h4>Discussion</h4>
<p>Similar to <code>iter.map(...).flatten(true)</code>.</p> <h2>Reducing a value</h2>
<h3 id="seq.keyed.reduce">Seq.Keyed#reduce()</h3>
<p>Reduces the Iterable to a value by calling the <code>reducer</code> for every entry in the Iterable and passing along the reduced value.</p> <pre data-language="js">reduce&lt;R&gt;(reducer: (reduction?: R, value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; R,initialReduction?: R,context?: any): R
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reduce">Iterable#reduce</a></code><h4>see</h4>
<p><code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">Array#reduce</a></code>.</p> <h4>Discussion</h4>
<p>If <code>initialReduction</code> is not provided, or is null, the first item in the Iterable will be used.</p> <h3 id="seq.keyed.reduceright">Seq.Keyed#reduceRight()</h3>
<p>Reduces the Iterable in reverse (from the right side).</p> <pre data-language="js">reduceRight&lt;R&gt;(reducer: (reduction?: R, value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; R,initialReduction?: R,context?: any): R
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reduceright">Iterable#reduceRight</a></code><h4>Discussion</h4>
<p>Note: Similar to this.reverse().reduce(), and provided for parity with <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight">Array#reduceRight</a></code>.</p> <h3 id="seq.keyed.every">Seq.Keyed#every()</h3>
<p>True if <code>predicate</code> returns true for all entries in the Iterable.</p> <pre data-language="js">every(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.every">Iterable#every</a></code><h3 id="seq.keyed.some">Seq.Keyed#some()</h3>
<p>True if <code>predicate</code> returns true for any entry in the Iterable.</p> <pre data-language="js">some(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.some">Iterable#some</a></code><h3 id="seq.keyed.join">Seq.Keyed#join()</h3>
<p>Joins values together as a string, inserting a separator between each. The default separator is <code>","</code>.</p> <pre data-language="js">join(separator?: string): string
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.join">Iterable#join</a></code><h3 id="seq.keyed.isempty">Seq.Keyed#isEmpty()</h3>
<p>Returns true if this Iterable includes no values.</p> <pre data-language="js">isEmpty(): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.isempty">Iterable#isEmpty</a></code><h4>Discussion</h4>
<p>For some lazy <code><a href="#seq">Seq</a></code>, <code>isEmpty</code> might need to iterate to determine emptiness. At most one iteration will occur.</p> <h3 id="seq.keyed.count">Seq.Keyed#count()</h3>
<p>Returns the size of this Iterable.</p> <pre data-language="js">count(): number
count(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.count">Iterable#count</a></code><h4>Discussion</h4>
<p>Regardless of if this Iterable can describe its size lazily (some Seqs cannot), this method will always return the correct size. E.g. it evaluates a lazy <code><a href="#seq">Seq</a></code> if necessary.</p> <p>If <code>predicate</code> is provided, then this returns the count of entries in the Iterable for which the <code>predicate</code> returns true.</p> <h3 id="seq.keyed.countby">Seq.Keyed#countBy()</h3>
<p>Returns a <code><a href="#seq.keyed">Seq.Keyed</a></code> of counts, grouped by the return value of the <code>grouper</code> function.</p> <pre data-language="js">countBy&lt;G&gt;(grouper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; G,context?: any): Map&lt;G, number&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.countby">Iterable#countBy</a></code><h4>Discussion</h4>
<p>Note: This is not a lazy operation.</p> <h2>Search for value</h2>
<h3 id="seq.keyed.find">Seq.Keyed#find()</h3>
<p>Returns the first value for which the <code>predicate</code> returns true.</p> <pre data-language="js">find(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.find">Iterable#find</a></code><h3 id="seq.keyed.findlast">Seq.Keyed#findLast()</h3>
<p>Returns the last value for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLast(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlast">Iterable#findLast</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="seq.keyed.findentry">Seq.Keyed#findEntry()</h3>
<p>Returns the first [key, value] entry for which the <code>predicate</code> returns true.</p> <pre data-language="js">findEntry(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): Array&lt;any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findentry">Iterable#findEntry</a></code><h3 id="seq.keyed.findlastentry">Seq.Keyed#findLastEntry()</h3>
<p>Returns the last [key, value] entry for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLastEntry(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): Array&lt;any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlastentry">Iterable#findLastEntry</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="seq.keyed.findkey">Seq.Keyed#findKey()</h3>
<p>Returns the key for which the <code>predicate</code> returns true.</p> <pre data-language="js">findKey(predicate: (value?: V, key?: K, iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; boolean,context?: any): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findkey">Iterable#findKey</a></code><h3 id="seq.keyed.findlastkey">Seq.Keyed#findLastKey()</h3>
<p>Returns the last key for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLastKey(predicate: (value?: V, key?: K, iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; boolean,context?: any): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlastkey">Iterable#findLastKey</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="seq.keyed.keyof">Seq.Keyed#keyOf()</h3>
<p>Returns the key associated with the search value, or undefined.</p> <pre data-language="js">keyOf(searchValue: V): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyof">Iterable#keyOf</a></code><h3 id="seq.keyed.lastkeyof">Seq.Keyed#lastKeyOf()</h3>
<p>Returns the last key associated with the search value, or undefined.</p> <pre data-language="js">lastKeyOf(searchValue: V): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.lastkeyof">Iterable#lastKeyOf</a></code><h3 id="seq.keyed.max">Seq.Keyed#max()</h3>
<p>Returns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> <pre data-language="js">max(comparator?: (valueA: V, valueB: V) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.max">Iterable#max</a></code><h4>Discussion</h4>
<p>The <code>comparator</code> is used in the same way as <code><a href="#iterable.sort">Iterable#sort</a></code>. If it is not provided, the default comparator is <code>&gt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code>max</code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&gt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> <h3 id="seq.keyed.maxby">Seq.Keyed#maxBy()</h3>
<p>Like <code><a href="#iterable.max">max</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> <pre data-language="js">maxBy&lt;C&gt;(comparatorValueMapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.maxby">Iterable#maxBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.maxBy(hitter =&gt; hitter.avgHits);</pre>
<h3 id="seq.keyed.min">Seq.Keyed#min()</h3>
<p>Returns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> <pre data-language="js">min(comparator?: (valueA: V, valueB: V) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.min">Iterable#min</a></code><h4>Discussion</h4>
<p>The <code>comparator</code> is used in the same way as <code><a href="#iterable.sort">Iterable#sort</a></code>. If it is not provided, the default comparator is <code>&lt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code>min</code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&lt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> <h3 id="seq.keyed.minby">Seq.Keyed#minBy()</h3>
<p>Like <code><a href="#iterable.min">min</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> <pre data-language="js">minBy&lt;C&gt;(comparatorValueMapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.minby">Iterable#minBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.minBy(hitter =&gt; hitter.avgHits);</pre>
<h2>Comparison</h2>
<h3 id="seq.keyed.issubset">Seq.Keyed#isSubset()</h3>
<p>True if <code>iter</code> includes every value in this Iterable.</p> <pre data-language="js">isSubset(iter: Iterable&lt;any, V&gt;): boolean
isSubset(iter: Array&lt;V&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.issubset">Iterable#isSubset</a></code><h3 id="seq.keyed.issuperset">Seq.Keyed#isSuperset()</h3>
<p>True if this Iterable includes every value in <code>iter</code>.</p> <pre data-language="js">isSuperset(iter: Iterable&lt;any, V&gt;): boolean
isSuperset(iter: Array&lt;V&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.issuperset">Iterable#isSuperset</a></code><h2>Sequence functions</h2>
<h3 id="seq.keyed.flip">Seq.Keyed#flip()</h3>
<p>Returns a new Iterable.Keyed of the same type where the keys and values have been flipped.</p> <pre data-language="js">flip(): Iterable.Keyed&lt;V, K&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyed.flip">Iterable.Keyed#flip</a></code><h4>Example</h4>
<pre data-language="js">Seq({ a: 'z', b: 'y' }).flip() // { z: 'a', y: 'b' }</pre>
<h3 id="seq.keyed.mapkeys">Seq.Keyed#mapKeys()</h3>
<p>Returns a new Iterable.Keyed of the same type with keys passed through a <code>mapper</code> function.</p> <pre data-language="js">mapKeys&lt;M&gt;(mapper: (key?: K, value?: V, iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; M,context?: any): Iterable.Keyed&lt;M, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyed.mapkeys">Iterable.Keyed#mapKeys</a></code><h4>Example</h4>
<pre data-language="js">Seq({ a: 1, b: 2 })
  .mapKeys(x =&gt; x.toUpperCase())
// Seq { A: 1, B: 2 }</pre>
<h3 id="seq.keyed.mapentries">Seq.Keyed#mapEntries()</h3>
<p>Returns a new Iterable.Keyed of the same type with entries ([key, value] tuples) passed through a <code>mapper</code> function.</p> <pre data-language="js">mapEntries&lt;KM, VM&gt;(mapper: (entry?: Array&lt;any&gt;,index?: number,iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; Array&lt;any&gt;,context?: any): Iterable.Keyed&lt;KM, VM&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyed.mapentries">Iterable.Keyed#mapEntries</a></code><h4>Example</h4>
<pre data-language="js">Seq({ a: 1, b: 2 })
  .mapEntries(([k, v]) =&gt; [k.toUpperCase(), v * 2])
// Seq { A: 2, B: 4 }</pre>
<h1 id="iterable">Iterable</h1>
<p>The <code>Iterable</code> is a set of (key, value) entries which can be iterated, and is the base class for all collections in <code>immutable</code>, allowing them to make use of all the Iterable methods (such as <code><a href="#iterable.map">map</a></code> and <code><a href="#iterable.filter">filter</a></code>).</p> <pre data-language="js">class Iterable&lt;K, V&gt;</pre>
<h4>Discussion</h4>
<p>Note: An iterable is always iterated in the same order, however that order may not always be well defined, as is the case for the <code><a href="#map">Map</a></code> and <code><a href="#iterable.set">Set</a></code>.</p> <h2>Construction</h2>
<h3 id="iterable()">Iterable()</h3>
<p>Creates an Iterable.</p> <pre data-language="js">Iterable&lt;K, V&gt;(iterable: Iterable&lt;K, V&gt;): Iterable&lt;K, V&gt;
Iterable&lt;T&gt;(array: Array&lt;T&gt;): Iterable.Indexed&lt;T&gt;
Iterable&lt;V&gt;(obj: {[key: string]: V}): Iterable.Keyed&lt;string, V&gt;
Iterable&lt;T&gt;(iterator: Iterator&lt;T&gt;): Iterable.Indexed&lt;T&gt;
Iterable&lt;T&gt;(iterable: Object): Iterable.Indexed&lt;T&gt;
Iterable&lt;V&gt;(value: V): Iterable.Indexed&lt;V&gt;
</pre>
<h4>Discussion</h4>
<p>The type of Iterable created is based on the input.</p> <ul> <li>If an <code>Iterable</code>, that same <code>Iterable</code>.</li> <li>If an Array-like, an <code><a href="#iterable.indexed">Iterable.Indexed</a></code>.</li> <li>If an Object with an Iterator, an <code><a href="#iterable.indexed">Iterable.Indexed</a></code>.</li> <li>If an Iterator, an <code><a href="#iterable.indexed">Iterable.Indexed</a></code>.</li> <li>If an Object, an <code><a href="#iterable.keyed">Iterable.Keyed</a></code>.</li> </ul> <p>This methods forces the conversion of Objects and Strings to Iterables. If you want to ensure that a Iterable of one item is returned, use <code><a href="#seq.of">Seq.of</a></code>.</p> <h2>Static methods</h2>
<h3 id="iterable.isiterable">Iterable.isIterable()</h3>
<p>True if <code>maybeIterable</code> is an Iterable, or any of its subclasses.</p> <pre data-language="js">Iterable.isIterable(maybeIterable: any): boolean
</pre>
<h3 id="iterable.iskeyed">Iterable.isKeyed()</h3>
<p>True if <code>maybeKeyed</code> is an Iterable.Keyed, or any of its subclasses.</p> <pre data-language="js">Iterable.isKeyed(maybeKeyed: any): boolean
</pre>
<h3 id="iterable.isindexed">Iterable.isIndexed()</h3>
<p>True if <code>maybeIndexed</code> is a Iterable.Indexed, or any of its subclasses.</p> <pre data-language="js">Iterable.isIndexed(maybeIndexed: any): boolean
</pre>
<h3 id="iterable.isassociative">Iterable.isAssociative()</h3>
<p>True if <code>maybeAssociative</code> is either a keyed or indexed Iterable.</p> <pre data-language="js">Iterable.isAssociative(maybeAssociative: any): boolean
</pre>
<h3 id="iterable.isordered">Iterable.isOrdered()</h3>
<p>True if <code>maybeOrdered</code> is an Iterable where iteration order is well defined. True for Iterable.Indexed as well as OrderedMap and OrderedSet.</p> <pre data-language="js">Iterable.isOrdered(maybeOrdered: any): boolean
</pre>
<h2>Types</h2>
<a href="#iterable.keyed">Iterable.Keyed</a><h2>Value equality</h2>
<h3 id="iterable.equals">Iterable#equals()</h3>
<p>True if this and the other Iterable have value equality, as defined by <code><a href="#is">Immutable.is()</a></code>.</p> <pre data-language="js">equals(other: Iterable&lt;K, V&gt;): boolean
</pre>
<h4>Discussion</h4>
<p>Note: This is equivalent to <code>Immutable.is(this, other)</code>, but provided to allow for chained expressions.</p> <h3 id="iterable.hashcode">Iterable#hashCode()</h3>
<p>Computes and returns the hashed identity for this Iterable.</p> <pre data-language="js">hashCode(): number
</pre>
<h4>Discussion</h4>
<p>The <code>hashCode</code> of an Iterable is used to determine potential equality, and is used when adding this to a <code><a href="#iterable.set">Set</a></code> or as a key in a <code><a href="#map">Map</a></code>, enabling lookup via a different instance.</p> <pre data-language="js">var a = List.of(1, 2, 3);
var b = List.of(1, 2, 3);
assert(a !== b); // different instances
var set = Set.of(a);
assert(set.has(b) === true);</pre>
<p>If two values have the same <code>hashCode</code>, they are <a href="http://en.wikipedia.org/wiki/Collision_(computer_science)">not guaranteed to be equal</a>. If two values have different <code>hashCode</code>s, they must not be equal.</p> <h2>Reading values</h2>
<h3 id="iterable.get">Iterable#get()</h3>
<p>Returns the value associated with the provided key, or notSetValue if the Iterable does not contain this key.</p> <pre data-language="js">get(key: K, notSetValue?: V): V
</pre>
<h4>Discussion</h4>
<p>Note: it is possible a key may be associated with an <code>undefined</code> value, so if <code>notSetValue</code> is not provided and this method returns <code>undefined</code>, that does not guarantee the key was not found.</p> <h3 id="iterable.has">Iterable#has()</h3>
<p>True if a key exists within this <code>Iterable</code>, using <code><a href="#is">Immutable.is</a></code> to determine equality</p> <pre data-language="js">has(key: K): boolean
</pre>
<h3 id="iterable.includes">Iterable#includes()</h3>
<p>True if a value exists within this <code>Iterable</code>, using <code><a href="#is">Immutable.is</a></code> to determine equality</p> <pre data-language="js">includes(value: V): boolean
</pre>
<h4>alias</h4>
<code>contains()</code><h3 id="iterable.first">Iterable#first()</h3>
<p>The first value in the Iterable.</p> <pre data-language="js">first(): V
</pre>
<h3 id="iterable.last">Iterable#last()</h3>
<p>The last value in the Iterable.</p> <pre data-language="js">last(): V
</pre>
<h2>Reading deep values</h2>
<h3 id="iterable.getin">Iterable#getIn()</h3>
<p>Returns the value found by following a path of keys or indices through nested Iterables.</p> <pre data-language="js">getIn(searchKeyPath: Array&lt;any&gt;, notSetValue?: any): any
getIn(searchKeyPath: Iterable&lt;any, any&gt;, notSetValue?: any): any
</pre>
<h3 id="iterable.hasin">Iterable#hasIn()</h3>
<p>True if the result of following a path of keys or indices through nested Iterables results in a set value.</p> <pre data-language="js">hasIn(searchKeyPath: Array&lt;any&gt;): boolean
hasIn(searchKeyPath: Iterable&lt;any, any&gt;): boolean
</pre>
<h2>Conversion to JavaScript types</h2>
<h3 id="iterable.tojs">Iterable#toJS()</h3>
<p>Deeply converts this Iterable to equivalent JS.</p> <pre data-language="js">toJS(): any
</pre>
<h4>alias</h4>
<code>toJSON()</code><h4>Discussion</h4>
<p><code>Iterable.Indexeds</code>, and <code>Iterable.Sets</code> become Arrays, while <code>Iterable.Keyeds</code> become Objects.</p> <h3 id="iterable.toarray">Iterable#toArray()</h3>
<p>Shallowly converts this iterable to an Array, discarding keys.</p> <pre data-language="js">toArray(): Array&lt;V&gt;
</pre>
<h3 id="iterable.toobject">Iterable#toObject()</h3>
<p>Shallowly converts this Iterable to an Object.</p> <pre data-language="js">toObject(): {[key: string]: V}
</pre>
<h4>Discussion</h4>
<p>Throws if keys are not strings.</p> <h2>Conversion to Collections</h2>
<h3 id="iterable.tomap">Iterable#toMap()</h3>
<p>Converts this Iterable to a Map, Throws if keys are not hashable.</p> <pre data-language="js">toMap(): Map&lt;K, V&gt;
</pre>
<h4>Discussion</h4>
<p>Note: This is equivalent to <code>Map(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="iterable.toorderedmap">Iterable#toOrderedMap()</h3>
<p>Converts this Iterable to a Map, maintaining the order of iteration.</p> <pre data-language="js">toOrderedMap(): OrderedMap&lt;K, V&gt;
</pre>
<h4>Discussion</h4>
<p>Note: This is equivalent to <code>OrderedMap(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="iterable.toset">Iterable#toSet()</h3>
<p>Converts this Iterable to a Set, discarding keys. Throws if values are not hashable.</p> <pre data-language="js">toSet(): Set&lt;V&gt;
</pre>
<h4>Discussion</h4>
<p>Note: This is equivalent to <code>Set(this)</code>, but provided to allow for chained expressions.</p> <h3 id="iterable.toorderedset">Iterable#toOrderedSet()</h3>
<p>Converts this Iterable to a Set, maintaining the order of iteration and discarding keys.</p> <pre data-language="js">toOrderedSet(): OrderedSet&lt;V&gt;
</pre>
<h4>Discussion</h4>
<p>Note: This is equivalent to <code>OrderedSet(this.valueSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="iterable.tolist">Iterable#toList()</h3>
<p>Converts this Iterable to a List, discarding keys.</p> <pre data-language="js">toList(): List&lt;V&gt;
</pre>
<h4>Discussion</h4>
<p>Note: This is equivalent to <code>List(this)</code>, but provided to allow for chained expressions.</p> <h3 id="iterable.tostack">Iterable#toStack()</h3>
<p>Converts this Iterable to a Stack, discarding keys. Throws if values are not hashable.</p> <pre data-language="js">toStack(): Stack&lt;V&gt;
</pre>
<h4>Discussion</h4>
<p>Note: This is equivalent to <code>Stack(this)</code>, but provided to allow for chained expressions.</p> <h2>Conversion to Seq</h2>
<h3 id="iterable.toseq">Iterable#toSeq()</h3>
<p>Converts this Iterable to a Seq of the same kind (indexed, keyed, or set).</p> <pre data-language="js">toSeq(): Seq&lt;K, V&gt;
</pre>
<h3 id="iterable.tokeyedseq">Iterable#toKeyedSeq()</h3>
<p>Returns a Seq.Keyed from this Iterable where indices are treated as keys.</p> <pre data-language="js">toKeyedSeq(): Seq.Keyed&lt;K, V&gt;
</pre>
<h4>Discussion</h4>
<p>This is useful if you want to operate on an Iterable.Indexed and preserve the [index, value] pairs.</p> <p>The returned Seq will have identical iteration order as this Iterable.</p> <p>Example:</p> <pre data-language="js">var indexedSeq = Immutable.Seq.of('A', 'B', 'C');
indexedSeq.filter(v =&gt; v === 'B').toString() // Seq [ 'B' ]
var keyedSeq = indexedSeq.toKeyedSeq();
keyedSeq.filter(v =&gt; v === 'B').toString() // Seq { 1: 'B' }</pre>
<h3 id="iterable.toindexedseq">Iterable#toIndexedSeq()</h3>
<p>Returns an Seq.Indexed of the values of this Iterable, discarding keys.</p> <pre data-language="js">toIndexedSeq(): Seq.Indexed&lt;V&gt;
</pre>
<h3 id="iterable.tosetseq">Iterable#toSetSeq()</h3>
<p>Returns a Seq.Set of the values of this Iterable, discarding keys.</p> <pre data-language="js">toSetSeq(): Seq.Set&lt;V&gt;
</pre>
<h2>Iterators</h2>
<h3 id="iterable.keys">Iterable#keys()</h3>
<p>An iterator of this <code>Iterable</code>'s keys.</p> <pre data-language="js">keys(): Iterator&lt;K&gt;
</pre>
<h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.keyseq">keySeq</a></code> instead, if this is what you want.</p> <h3 id="iterable.values">Iterable#values()</h3>
<p>An iterator of this <code>Iterable</code>'s values.</p> <pre data-language="js">values(): Iterator&lt;V&gt;
</pre>
<h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.valueseq">valueSeq</a></code> instead, if this is what you want.</p> <h3 id="iterable.entries">Iterable#entries()</h3>
<p>An iterator of this <code>Iterable</code>'s entries as <code>[key, value]</code> tuples.</p> <pre data-language="js">entries(): Iterator&lt;Array&lt;any&gt;&gt;
</pre>
<h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.entryseq">entrySeq</a></code> instead, if this is what you want.</p> <h2>Iterables (Seq)</h2>
<h3 id="iterable.keyseq">Iterable#keySeq()</h3>
<p>Returns a new Seq.Indexed of the keys of this Iterable, discarding values.</p> <pre data-language="js">keySeq(): Seq.Indexed&lt;K&gt;
</pre>
<h3 id="iterable.valueseq">Iterable#valueSeq()</h3>
<p>Returns an Seq.Indexed of the values of this Iterable, discarding keys.</p> <pre data-language="js">valueSeq(): Seq.Indexed&lt;V&gt;
</pre>
<h3 id="iterable.entryseq">Iterable#entrySeq()</h3>
<p>Returns a new Seq.Indexed of [key, value] tuples.</p> <pre data-language="js">entrySeq(): Seq.Indexed&lt;Array&lt;any&gt;&gt;
</pre>
<h2>Sequence algorithms</h2>
<h3 id="iterable.map">Iterable#map()</h3>
<p>Returns a new Iterable of the same type with values passed through a <code>mapper</code> function.</p> <pre data-language="js">map&lt;M&gt;(mapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; M,context?: any): Iterable&lt;K, M&gt;
</pre>
<h4>Example</h4>
<pre data-language="js">Seq({ a: 1, b: 2 }).map(x =&gt; 10 * x)
// Seq { a: 10, b: 20 }</pre>
<h3 id="iterable.filter">Iterable#filter()</h3>
<p>Returns a new Iterable of the same type with only the entries for which the <code>predicate</code> function returns true.</p> <pre data-language="js">filter(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Example</h4>
<pre data-language="js">Seq({a:1,b:2,c:3,d:4}).filter(x =&gt; x % 2 === 0)
// Seq { b: 2, d: 4 }</pre>
<h3 id="iterable.filternot">Iterable#filterNot()</h3>
<p>Returns a new Iterable of the same type with only the entries for which the <code>predicate</code> function returns false.</p> <pre data-language="js">filterNot(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Example</h4>
<pre data-language="js">Seq({a:1,b:2,c:3,d:4}).filterNot(x =&gt; x % 2 === 0)
// Seq { a: 1, c: 3 }</pre>
<h3 id="iterable.reverse">Iterable#reverse()</h3>
<p>Returns a new Iterable of the same type in reverse order.</p> <pre data-language="js">reverse(): Iterable&lt;K, V&gt;
</pre>
<h3 id="iterable.sort">Iterable#sort()</h3>
<p>Returns a new Iterable of the same type which includes the same entries, stably sorted by using a <code>comparator</code>.</p> <pre data-language="js">sort(comparator?: (valueA: V, valueB: V) =&gt; number): Iterable&lt;K, V&gt;
</pre>
<h4>Discussion</h4>
<p>If a <code>comparator</code> is not provided, a default comparator uses <code>&lt;</code> and <code>&gt;</code>.</p> <p><code>comparator(valueA, valueB)</code>:</p> <ul> <li>Returns <code>0</code> if the elements should not be swapped.</li> <li>Returns <code>-1</code> (or any negative number) if <code>valueA</code> comes before <code>valueB</code>
</li> <li>Returns <code>1</code> (or any positive number) if <code>valueA</code> comes after <code>valueB</code>
</li> <li>Is pure, i.e. it must always return the same value for the same pair of values.</li> </ul> <p>When sorting collections which have no defined order, their ordered equivalents will be returned. e.g. <code>map.sort()</code> returns OrderedMap.</p> <h3 id="iterable.sortby">Iterable#sortBy()</h3>
<p>Like <code><a href="#iterable.sort">sort</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for sorting by more sophisticated means:</p> <pre data-language="js">sortBy&lt;C&gt;(comparatorValueMapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): Iterable&lt;K, V&gt;
</pre>
<h4>Example</h4>
<pre data-language="js">hitters.sortBy(hitter =&gt; hitter.avgHits);</pre>
<h3 id="iterable.groupby">Iterable#groupBy()</h3>
<p>Returns a <code><a href="#iterable.keyed">Iterable.Keyed</a></code> of <code>Iterable.Keyeds</code>, grouped by the return value of the <code>grouper</code> function.</p> <pre data-language="js">groupBy&lt;G&gt;(grouper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; G,context?: any): Seq.Keyed&lt;G, Iterable&lt;K, V&gt;&gt;
</pre>
<h4>Discussion</h4>
<p>Note: This is always an eager operation.</p> <h2>Side effects</h2>
<h3 id="iterable.foreach">Iterable#forEach()</h3>
<p>The <code>sideEffect</code> is executed for every entry in the Iterable.</p> <pre data-language="js">forEach(sideEffect: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; any,context?: any): number
</pre>
<h4>Discussion</h4>
<p>Unlike <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">Array#forEach</a></code>, if any call of <code>sideEffect</code> returns <code>false</code>, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).</p> <h2>Creating subsets</h2>
<h3 id="iterable.slice">Iterable#slice()</h3>
<p>Returns a new Iterable of the same type representing a portion of this Iterable from start up to but not including end.</p> <pre data-language="js">slice(begin?: number, end?: number): Iterable&lt;K, V&gt;
</pre>
<h4>Discussion</h4>
<p>If begin is negative, it is offset from the end of the Iterable. e.g. <code>slice(-2)</code> returns a Iterable of the last two entries. If it is not provided the new Iterable will begin at the beginning of this Iterable.</p> <p>If end is negative, it is offset from the end of the Iterable. e.g. <code>slice(0, -1)</code> returns an Iterable of everything but the last entry. If it is not provided, the new Iterable will continue through the end of this Iterable.</p> <p>If the requested slice is equivalent to the current Iterable, then it will return itself.</p> <h3 id="iterable.rest">Iterable#rest()</h3>
<p>Returns a new Iterable of the same type containing all entries except the first.</p> <pre data-language="js">rest(): Iterable&lt;K, V&gt;
</pre>
<h3 id="iterable.butlast">Iterable#butLast()</h3>
<p>Returns a new Iterable of the same type containing all entries except the last.</p> <pre data-language="js">butLast(): Iterable&lt;K, V&gt;
</pre>
<h3 id="iterable.skip">Iterable#skip()</h3>
<p>Returns a new Iterable of the same type which excludes the first <code>amount</code> entries from this Iterable.</p> <pre data-language="js">skip(amount: number): Iterable&lt;K, V&gt;
</pre>
<h3 id="iterable.skiplast">Iterable#skipLast()</h3>
<p>Returns a new Iterable of the same type which excludes the last <code>amount</code> entries from this Iterable.</p> <pre data-language="js">skipLast(amount: number): Iterable&lt;K, V&gt;
</pre>
<h3 id="iterable.skipwhile">Iterable#skipWhile()</h3>
<p>Returns a new Iterable of the same type which includes entries starting from when <code>predicate</code> first returns false.</p> <pre data-language="js">skipWhile(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .skipWhile(x =&gt; x.match(/g/))
// Seq [ 'cat', 'hat', 'god' ]</pre>
<h3 id="iterable.skipuntil">Iterable#skipUntil()</h3>
<p>Returns a new Iterable of the same type which includes entries starting from when <code>predicate</code> first returns true.</p> <pre data-language="js">skipUntil(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .skipUntil(x =&gt; x.match(/hat/))
// Seq [ 'hat', 'god' ]</pre>
<h3 id="iterable.take">Iterable#take()</h3>
<p>Returns a new Iterable of the same type which includes the first <code>amount</code> entries from this Iterable.</p> <pre data-language="js">take(amount: number): Iterable&lt;K, V&gt;
</pre>
<h3 id="iterable.takelast">Iterable#takeLast()</h3>
<p>Returns a new Iterable of the same type which includes the last <code>amount</code> entries from this Iterable.</p> <pre data-language="js">takeLast(amount: number): Iterable&lt;K, V&gt;
</pre>
<h3 id="iterable.takewhile">Iterable#takeWhile()</h3>
<p>Returns a new Iterable of the same type which includes entries from this Iterable as long as the <code>predicate</code> returns true.</p> <pre data-language="js">takeWhile(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .takeWhile(x =&gt; x.match(/o/))
// Seq [ 'dog', 'frog' ]</pre>
<h3 id="iterable.takeuntil">Iterable#takeUntil()</h3>
<p>Returns a new Iterable of the same type which includes entries from this Iterable as long as the <code>predicate</code> returns false.</p> <pre data-language="js">takeUntil(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god').takeUntil(x =&gt; x.match(/at/))
// ['dog', 'frog']</pre>
<h2>Combination</h2>
<h3 id="iterable.concat">Iterable#concat()</h3>
<p>Returns a new Iterable of the same type with other values and iterable-like concatenated to this one.</p> <pre data-language="js">concat(...valuesOrIterables: any[]): Iterable&lt;K, V&gt;
</pre>
<h4>Discussion</h4>
<p>For Seqs, all entries will be present in the resulting iterable, even if they have the same key.</p> <h3 id="iterable.flatten">Iterable#flatten()</h3>
<p>Flattens nested Iterables.</p> <pre data-language="js">flatten(depth?: number): Iterable&lt;any, any&gt;
flatten(shallow?: boolean): Iterable&lt;any, any&gt;
</pre>
<h4>Discussion</h4>
<p>Will deeply flatten the Iterable by default, returning an Iterable of the same type, but a <code>depth</code> can be provided in the form of a number or boolean (where true means to shallowly flatten one level). A depth of 0 (or shallow: false) will deeply flatten.</p> <p>Flattens only others Iterable, not Arrays or Objects.</p> <p>Note: <code>flatten(true)</code> operates on Iterable<any iterable v="">&gt; and returns Iterable</any></p> <h3 id="iterable.flatmap">Iterable#flatMap()</h3>
<p>Flat-maps the Iterable, returning an Iterable of the same type.</p> <pre data-language="js">flatMap&lt;MK, MV&gt;(mapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; Iterable&lt;MK, MV&gt;,context?: any): Iterable&lt;MK, MV&gt;
flatMap&lt;MK, MV&gt;(mapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; any,context?: any): Iterable&lt;MK, MV&gt;
</pre>
<h4>Discussion</h4>
<p>Similar to <code>iter.map(...).flatten(true)</code>.</p> <h2>Reducing a value</h2>
<h3 id="iterable.reduce">Iterable#reduce()</h3>
<p>Reduces the Iterable to a value by calling the <code>reducer</code> for every entry in the Iterable and passing along the reduced value.</p> <pre data-language="js">reduce&lt;R&gt;(reducer: (reduction?: R, value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; R,initialReduction?: R,context?: any): R
</pre>
<h4>see</h4>
<p><code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">Array#reduce</a></code>.</p> <h4>Discussion</h4>
<p>If <code>initialReduction</code> is not provided, or is null, the first item in the Iterable will be used.</p> <h3 id="iterable.reduceright">Iterable#reduceRight()</h3>
<p>Reduces the Iterable in reverse (from the right side).</p> <pre data-language="js">reduceRight&lt;R&gt;(reducer: (reduction?: R, value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; R,initialReduction?: R,context?: any): R
</pre>
<h4>Discussion</h4>
<p>Note: Similar to this.reverse().reduce(), and provided for parity with <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight">Array#reduceRight</a></code>.</p> <h3 id="iterable.every">Iterable#every()</h3>
<p>True if <code>predicate</code> returns true for all entries in the Iterable.</p> <pre data-language="js">every(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): boolean
</pre>
<h3 id="iterable.some">Iterable#some()</h3>
<p>True if <code>predicate</code> returns true for any entry in the Iterable.</p> <pre data-language="js">some(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): boolean
</pre>
<h3 id="iterable.join">Iterable#join()</h3>
<p>Joins values together as a string, inserting a separator between each. The default separator is <code>","</code>.</p> <pre data-language="js">join(separator?: string): string
</pre>
<h3 id="iterable.isempty">Iterable#isEmpty()</h3>
<p>Returns true if this Iterable includes no values.</p> <pre data-language="js">isEmpty(): boolean
</pre>
<h4>Discussion</h4>
<p>For some lazy <code><a href="#seq">Seq</a></code>, <code>isEmpty</code> might need to iterate to determine emptiness. At most one iteration will occur.</p> <h3 id="iterable.count">Iterable#count()</h3>
<p>Returns the size of this Iterable.</p> <pre data-language="js">count(): number
count(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): number
</pre>
<h4>Discussion</h4>
<p>Regardless of if this Iterable can describe its size lazily (some Seqs cannot), this method will always return the correct size. E.g. it evaluates a lazy <code><a href="#seq">Seq</a></code> if necessary.</p> <p>If <code>predicate</code> is provided, then this returns the count of entries in the Iterable for which the <code>predicate</code> returns true.</p> <h3 id="iterable.countby">Iterable#countBy()</h3>
<p>Returns a <code><a href="#seq.keyed">Seq.Keyed</a></code> of counts, grouped by the return value of the <code>grouper</code> function.</p> <pre data-language="js">countBy&lt;G&gt;(grouper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; G,context?: any): Map&lt;G, number&gt;
</pre>
<h4>Discussion</h4>
<p>Note: This is not a lazy operation.</p> <h2>Search for value</h2>
<h3 id="iterable.find">Iterable#find()</h3>
<p>Returns the first value for which the <code>predicate</code> returns true.</p> <pre data-language="js">find(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): V
</pre>
<h3 id="iterable.findlast">Iterable#findLast()</h3>
<p>Returns the last value for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLast(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): V
</pre>
<h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="iterable.findentry">Iterable#findEntry()</h3>
<p>Returns the first [key, value] entry for which the <code>predicate</code> returns true.</p> <pre data-language="js">findEntry(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): Array&lt;any&gt;
</pre>
<h3 id="iterable.findlastentry">Iterable#findLastEntry()</h3>
<p>Returns the last [key, value] entry for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLastEntry(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): Array&lt;any&gt;
</pre>
<h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="iterable.findkey">Iterable#findKey()</h3>
<p>Returns the key for which the <code>predicate</code> returns true.</p> <pre data-language="js">findKey(predicate: (value?: V, key?: K, iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; boolean,context?: any): K
</pre>
<h3 id="iterable.findlastkey">Iterable#findLastKey()</h3>
<p>Returns the last key for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLastKey(predicate: (value?: V, key?: K, iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; boolean,context?: any): K
</pre>
<h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="iterable.keyof">Iterable#keyOf()</h3>
<p>Returns the key associated with the search value, or undefined.</p> <pre data-language="js">keyOf(searchValue: V): K
</pre>
<h3 id="iterable.lastkeyof">Iterable#lastKeyOf()</h3>
<p>Returns the last key associated with the search value, or undefined.</p> <pre data-language="js">lastKeyOf(searchValue: V): K
</pre>
<h3 id="iterable.max">Iterable#max()</h3>
<p>Returns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> <pre data-language="js">max(comparator?: (valueA: V, valueB: V) =&gt; number): V
</pre>
<h4>Discussion</h4>
<p>The <code>comparator</code> is used in the same way as <code><a href="#iterable.sort">Iterable#sort</a></code>. If it is not provided, the default comparator is <code>&gt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code>max</code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&gt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> <h3 id="iterable.maxby">Iterable#maxBy()</h3>
<p>Like <code><a href="#iterable.max">max</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> <pre data-language="js">maxBy&lt;C&gt;(comparatorValueMapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): V
</pre>
<h4>Example</h4>
<pre data-language="js">hitters.maxBy(hitter =&gt; hitter.avgHits);</pre>
<h3 id="iterable.min">Iterable#min()</h3>
<p>Returns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> <pre data-language="js">min(comparator?: (valueA: V, valueB: V) =&gt; number): V
</pre>
<h4>Discussion</h4>
<p>The <code>comparator</code> is used in the same way as <code><a href="#iterable.sort">Iterable#sort</a></code>. If it is not provided, the default comparator is <code>&lt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code>min</code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&lt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> <h3 id="iterable.minby">Iterable#minBy()</h3>
<p>Like <code><a href="#iterable.min">min</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> <pre data-language="js">minBy&lt;C&gt;(comparatorValueMapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): V
</pre>
<h4>Example</h4>
<pre data-language="js">hitters.minBy(hitter =&gt; hitter.avgHits);</pre>
<h2>Comparison</h2>
<h3 id="iterable.issubset">Iterable#isSubset()</h3>
<p>True if <code>iter</code> includes every value in this Iterable.</p> <pre data-language="js">isSubset(iter: Iterable&lt;any, V&gt;): boolean
isSubset(iter: Array&lt;V&gt;): boolean
</pre>
<h3 id="iterable.issuperset">Iterable#isSuperset()</h3>
<p>True if this Iterable includes every value in <code>iter</code>.</p> <pre data-language="js">isSuperset(iter: Iterable&lt;any, V&gt;): boolean
isSuperset(iter: Array&lt;V&gt;): boolean
</pre>
<h1 id="iterable.keyed">Iterable.Keyed</h1>
<p>Keyed Iterables have discrete keys tied to each value.</p> <pre data-language="js">class Iterable.Keyed&lt;K, V&gt; extends Iterable&lt;K, V&gt;</pre>
<h4>Discussion</h4>
<p>When iterating <code>Iterable.Keyed</code>, each iteration will yield a <code>[K, V]</code> tuple, in other words, <code><a href="#iterable.entries">Iterable#entries</a></code> is the default iterator for Keyed Iterables.</p> <h2>Construction</h2>
<h3 id="iterable.keyed()">Iterable.Keyed()</h3>
<p>Creates an Iterable.Keyed</p> <pre data-language="js">Iterable.Keyed&lt;K, V&gt;(iter: Iterable.Keyed&lt;K, V&gt;): Iterable.Keyed&lt;K, V&gt;
Iterable.Keyed&lt;K, V&gt;(iter: Iterable&lt;any, any&gt;): Iterable.Keyed&lt;K, V&gt;
Iterable.Keyed&lt;K, V&gt;(array: Array&lt;any&gt;): Iterable.Keyed&lt;K, V&gt;
Iterable.Keyed&lt;V&gt;(obj: {[key: string]: V}): Iterable.Keyed&lt;string, V&gt;
Iterable.Keyed&lt;K, V&gt;(iterator: Iterator&lt;any&gt;): Iterable.Keyed&lt;K, V&gt;
Iterable.Keyed&lt;K, V&gt;(iterable: Object): Iterable.Keyed&lt;K, V&gt;
</pre>
<h4>Discussion</h4>
<p>Similar to <code>Iterable()</code>, however it expects iterable-likes of [K, V] tuples if not constructed from a Iterable.Keyed or JS Object.</p> <h2>Conversion to Seq</h2>
<h3 id="iterable.keyed.toseq">Iterable.Keyed#toSeq()</h3>
<p>Returns Seq.Keyed.</p> <pre data-language="js">toSeq(): Seq.Keyed&lt;K, V&gt;
</pre>
<h4>Overrides</h4>
<code><a href="#iterable.toseq">Iterable#toSeq</a></code><h3 id="iterable.keyed.tokeyedseq">Iterable.Keyed#toKeyedSeq()</h3>
<p>Returns a Seq.Keyed from this Iterable where indices are treated as keys.</p> <pre data-language="js">toKeyedSeq(): Seq.Keyed&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tokeyedseq">Iterable#toKeyedSeq</a></code><h4>Discussion</h4>
<p>This is useful if you want to operate on an Iterable.Indexed and preserve the [index, value] pairs.</p> <p>The returned Seq will have identical iteration order as this Iterable.</p> <p>Example:</p> <pre data-language="js">var indexedSeq = Immutable.Seq.of('A', 'B', 'C');
indexedSeq.filter(v =&gt; v === 'B').toString() // Seq [ 'B' ]
var keyedSeq = indexedSeq.toKeyedSeq();
keyedSeq.filter(v =&gt; v === 'B').toString() // Seq { 1: 'B' }</pre>
<h3 id="iterable.keyed.toindexedseq">Iterable.Keyed#toIndexedSeq()</h3>
<p>Returns an Seq.Indexed of the values of this Iterable, discarding keys.</p> <pre data-language="js">toIndexedSeq(): Seq.Indexed&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toindexedseq">Iterable#toIndexedSeq</a></code><h3 id="iterable.keyed.tosetseq">Iterable.Keyed#toSetSeq()</h3>
<p>Returns a Seq.Set of the values of this Iterable, discarding keys.</p> <pre data-language="js">toSetSeq(): Seq.Set&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tosetseq">Iterable#toSetSeq</a></code><h2>Sequence functions</h2>
<h3 id="iterable.keyed.flip">Iterable.Keyed#flip()</h3>
<p>Returns a new Iterable.Keyed of the same type where the keys and values have been flipped.</p> <pre data-language="js">flip(): Iterable.Keyed&lt;V, K&gt;
</pre>
<h4>Example</h4>
<pre data-language="js">Seq({ a: 'z', b: 'y' }).flip() // { z: 'a', y: 'b' }</pre>
<h3 id="iterable.keyed.mapkeys">Iterable.Keyed#mapKeys()</h3>
<p>Returns a new Iterable.Keyed of the same type with keys passed through a <code>mapper</code> function.</p> <pre data-language="js">mapKeys&lt;M&gt;(mapper: (key?: K, value?: V, iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; M,context?: any): Iterable.Keyed&lt;M, V&gt;
</pre>
<h4>Example</h4>
<pre data-language="js">Seq({ a: 1, b: 2 })
  .mapKeys(x =&gt; x.toUpperCase())
// Seq { A: 1, B: 2 }</pre>
<h3 id="iterable.keyed.mapentries">Iterable.Keyed#mapEntries()</h3>
<p>Returns a new Iterable.Keyed of the same type with entries ([key, value] tuples) passed through a <code>mapper</code> function.</p> <pre data-language="js">mapEntries&lt;KM, VM&gt;(mapper: (entry?: Array&lt;any&gt;,index?: number,iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; Array&lt;any&gt;,context?: any): Iterable.Keyed&lt;KM, VM&gt;
</pre>
<h4>Example</h4>
<pre data-language="js">Seq({ a: 1, b: 2 })
  .mapEntries(([k, v]) =&gt; [k.toUpperCase(), v * 2])
// Seq { A: 2, B: 4 }</pre>
<h2>Value equality</h2>
<h3 id="iterable.keyed.equals">Iterable.Keyed#equals()</h3>
<p>True if this and the other Iterable have value equality, as defined by <code><a href="#is">Immutable.is()</a></code>.</p> <pre data-language="js">equals(other: Iterable&lt;K, V&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.equals">Iterable#equals</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Immutable.is(this, other)</code>, but provided to allow for chained expressions.</p> <h3 id="iterable.keyed.hashcode">Iterable.Keyed#hashCode()</h3>
<p>Computes and returns the hashed identity for this Iterable.</p> <pre data-language="js">hashCode(): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.hashcode">Iterable#hashCode</a></code><h4>Discussion</h4>
<p>The <code>hashCode</code> of an Iterable is used to determine potential equality, and is used when adding this to a <code><a href="#iterable.set">Set</a></code> or as a key in a <code><a href="#map">Map</a></code>, enabling lookup via a different instance.</p> <pre data-language="js">var a = List.of(1, 2, 3);
var b = List.of(1, 2, 3);
assert(a !== b); // different instances
var set = Set.of(a);
assert(set.has(b) === true);</pre>
<p>If two values have the same <code>hashCode</code>, they are <a href="http://en.wikipedia.org/wiki/Collision_(computer_science)">not guaranteed to be equal</a>. If two values have different <code>hashCode</code>s, they must not be equal.</p> <h2>Reading values</h2>
<h3 id="iterable.keyed.get">Iterable.Keyed#get()</h3>
<p>Returns the value associated with the provided key, or notSetValue if the Iterable does not contain this key.</p> <pre data-language="js">get(key: K, notSetValue?: V): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.get">Iterable#get</a></code><h4>Discussion</h4>
<p>Note: it is possible a key may be associated with an <code>undefined</code> value, so if <code>notSetValue</code> is not provided and this method returns <code>undefined</code>, that does not guarantee the key was not found.</p> <h3 id="iterable.keyed.has">Iterable.Keyed#has()</h3>
<p>True if a key exists within this <code>Iterable</code>, using <code><a href="#is">Immutable.is</a></code> to determine equality</p> <pre data-language="js">has(key: K): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.has">Iterable#has</a></code><h3 id="iterable.keyed.includes">Iterable.Keyed#includes()</h3>
<p>True if a value exists within this <code>Iterable</code>, using <code><a href="#is">Immutable.is</a></code> to determine equality</p> <pre data-language="js">includes(value: V): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.includes">Iterable#includes</a></code><h4>alias</h4>
<code>contains()</code><h3 id="iterable.keyed.first">Iterable.Keyed#first()</h3>
<p>The first value in the Iterable.</p> <pre data-language="js">first(): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.first">Iterable#first</a></code><h3 id="iterable.keyed.last">Iterable.Keyed#last()</h3>
<p>The last value in the Iterable.</p> <pre data-language="js">last(): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.last">Iterable#last</a></code><h2>Reading deep values</h2>
<h3 id="iterable.keyed.getin">Iterable.Keyed#getIn()</h3>
<p>Returns the value found by following a path of keys or indices through nested Iterables.</p> <pre data-language="js">getIn(searchKeyPath: Array&lt;any&gt;, notSetValue?: any): any
getIn(searchKeyPath: Iterable&lt;any, any&gt;, notSetValue?: any): any
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.getin">Iterable#getIn</a></code><h3 id="iterable.keyed.hasin">Iterable.Keyed#hasIn()</h3>
<p>True if the result of following a path of keys or indices through nested Iterables results in a set value.</p> <pre data-language="js">hasIn(searchKeyPath: Array&lt;any&gt;): boolean
hasIn(searchKeyPath: Iterable&lt;any, any&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.hasin">Iterable#hasIn</a></code><h2>Conversion to JavaScript types</h2>
<h3 id="iterable.keyed.tojs">Iterable.Keyed#toJS()</h3>
<p>Deeply converts this Iterable to equivalent JS.</p> <pre data-language="js">toJS(): any
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tojs">Iterable#toJS</a></code><h4>alias</h4>
<code>toJSON()</code><h4>Discussion</h4>
<p><code>Iterable.Indexeds</code>, and <code>Iterable.Sets</code> become Arrays, while <code>Iterable.Keyeds</code> become Objects.</p> <h3 id="iterable.keyed.toarray">Iterable.Keyed#toArray()</h3>
<p>Shallowly converts this iterable to an Array, discarding keys.</p> <pre data-language="js">toArray(): Array&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toarray">Iterable#toArray</a></code><h3 id="iterable.keyed.toobject">Iterable.Keyed#toObject()</h3>
<p>Shallowly converts this Iterable to an Object.</p> <pre data-language="js">toObject(): {[key: string]: V}
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toobject">Iterable#toObject</a></code><h4>Discussion</h4>
<p>Throws if keys are not strings.</p> <h2>Conversion to Collections</h2>
<h3 id="iterable.keyed.tomap">Iterable.Keyed#toMap()</h3>
<p>Converts this Iterable to a Map, Throws if keys are not hashable.</p> <pre data-language="js">toMap(): Map&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tomap">Iterable#toMap</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Map(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="iterable.keyed.toorderedmap">Iterable.Keyed#toOrderedMap()</h3>
<p>Converts this Iterable to a Map, maintaining the order of iteration.</p> <pre data-language="js">toOrderedMap(): OrderedMap&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toorderedmap">Iterable#toOrderedMap</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>OrderedMap(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="iterable.keyed.toset">Iterable.Keyed#toSet()</h3>
<p>Converts this Iterable to a Set, discarding keys. Throws if values are not hashable.</p> <pre data-language="js">toSet(): Set&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toset">Iterable#toSet</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Set(this)</code>, but provided to allow for chained expressions.</p> <h3 id="iterable.keyed.toorderedset">Iterable.Keyed#toOrderedSet()</h3>
<p>Converts this Iterable to a Set, maintaining the order of iteration and discarding keys.</p> <pre data-language="js">toOrderedSet(): OrderedSet&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toorderedset">Iterable#toOrderedSet</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>OrderedSet(this.valueSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="iterable.keyed.tolist">Iterable.Keyed#toList()</h3>
<p>Converts this Iterable to a List, discarding keys.</p> <pre data-language="js">toList(): List&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tolist">Iterable#toList</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>List(this)</code>, but provided to allow for chained expressions.</p> <h3 id="iterable.keyed.tostack">Iterable.Keyed#toStack()</h3>
<p>Converts this Iterable to a Stack, discarding keys. Throws if values are not hashable.</p> <pre data-language="js">toStack(): Stack&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tostack">Iterable#toStack</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Stack(this)</code>, but provided to allow for chained expressions.</p> <h2>Iterators</h2>
<h3 id="iterable.keyed.keys">Iterable.Keyed#keys()</h3>
<p>An iterator of this <code>Iterable</code>'s keys.</p> <pre data-language="js">keys(): Iterator&lt;K&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keys">Iterable#keys</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.keyseq">keySeq</a></code> instead, if this is what you want.</p> <h3 id="iterable.keyed.values">Iterable.Keyed#values()</h3>
<p>An iterator of this <code>Iterable</code>'s values.</p> <pre data-language="js">values(): Iterator&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.values">Iterable#values</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.valueseq">valueSeq</a></code> instead, if this is what you want.</p> <h3 id="iterable.keyed.entries">Iterable.Keyed#entries()</h3>
<p>An iterator of this <code>Iterable</code>'s entries as <code>[key, value]</code> tuples.</p> <pre data-language="js">entries(): Iterator&lt;Array&lt;any&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.entries">Iterable#entries</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.entryseq">entrySeq</a></code> instead, if this is what you want.</p> <h2>Iterables (Seq)</h2>
<h3 id="iterable.keyed.keyseq">Iterable.Keyed#keySeq()</h3>
<p>Returns a new Seq.Indexed of the keys of this Iterable, discarding values.</p> <pre data-language="js">keySeq(): Seq.Indexed&lt;K&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyseq">Iterable#keySeq</a></code><h3 id="iterable.keyed.valueseq">Iterable.Keyed#valueSeq()</h3>
<p>Returns an Seq.Indexed of the values of this Iterable, discarding keys.</p> <pre data-language="js">valueSeq(): Seq.Indexed&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.valueseq">Iterable#valueSeq</a></code><h3 id="iterable.keyed.entryseq">Iterable.Keyed#entrySeq()</h3>
<p>Returns a new Seq.Indexed of [key, value] tuples.</p> <pre data-language="js">entrySeq(): Seq.Indexed&lt;Array&lt;any&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.entryseq">Iterable#entrySeq</a></code><h2>Sequence algorithms</h2>
<h3 id="iterable.keyed.map">Iterable.Keyed#map()</h3>
<p>Returns a new Iterable of the same type with values passed through a <code>mapper</code> function.</p> <pre data-language="js">map&lt;M&gt;(mapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; M,context?: any): Iterable&lt;K, M&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.map">Iterable#map</a></code><h4>Example</h4>
<pre data-language="js">Seq({ a: 1, b: 2 }).map(x =&gt; 10 * x)
// Seq { a: 10, b: 20 }</pre>
<h3 id="iterable.keyed.filter">Iterable.Keyed#filter()</h3>
<p>Returns a new Iterable of the same type with only the entries for which the <code>predicate</code> function returns true.</p> <pre data-language="js">filter(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.filter">Iterable#filter</a></code><h4>Example</h4>
<pre data-language="js">Seq({a:1,b:2,c:3,d:4}).filter(x =&gt; x % 2 === 0)
// Seq { b: 2, d: 4 }</pre>
<h3 id="iterable.keyed.filternot">Iterable.Keyed#filterNot()</h3>
<p>Returns a new Iterable of the same type with only the entries for which the <code>predicate</code> function returns false.</p> <pre data-language="js">filterNot(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.filternot">Iterable#filterNot</a></code><h4>Example</h4>
<pre data-language="js">Seq({a:1,b:2,c:3,d:4}).filterNot(x =&gt; x % 2 === 0)
// Seq { a: 1, c: 3 }</pre>
<h3 id="iterable.keyed.reverse">Iterable.Keyed#reverse()</h3>
<p>Returns a new Iterable of the same type in reverse order.</p> <pre data-language="js">reverse(): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reverse">Iterable#reverse</a></code><h3 id="iterable.keyed.sort">Iterable.Keyed#sort()</h3>
<p>Returns a new Iterable of the same type which includes the same entries, stably sorted by using a <code>comparator</code>.</p> <pre data-language="js">sort(comparator?: (valueA: V, valueB: V) =&gt; number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.sort">Iterable#sort</a></code><h4>Discussion</h4>
<p>If a <code>comparator</code> is not provided, a default comparator uses <code>&lt;</code> and <code>&gt;</code>.</p> <p><code>comparator(valueA, valueB)</code>:</p> <ul> <li>Returns <code>0</code> if the elements should not be swapped.</li> <li>Returns <code>-1</code> (or any negative number) if <code>valueA</code> comes before <code>valueB</code>
</li> <li>Returns <code>1</code> (or any positive number) if <code>valueA</code> comes after <code>valueB</code>
</li> <li>Is pure, i.e. it must always return the same value for the same pair of values.</li> </ul> <p>When sorting collections which have no defined order, their ordered equivalents will be returned. e.g. <code>map.sort()</code> returns OrderedMap.</p> <h3 id="iterable.keyed.sortby">Iterable.Keyed#sortBy()</h3>
<p>Like <code><a href="#iterable.sort">sort</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for sorting by more sophisticated means:</p> <pre data-language="js">sortBy&lt;C&gt;(comparatorValueMapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.sortby">Iterable#sortBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.sortBy(hitter =&gt; hitter.avgHits);</pre>
<h3 id="iterable.keyed.groupby">Iterable.Keyed#groupBy()</h3>
<p>Returns a <code><a href="#iterable.keyed">Iterable.Keyed</a></code> of <code>Iterable.Keyeds</code>, grouped by the return value of the <code>grouper</code> function.</p> <pre data-language="js">groupBy&lt;G&gt;(grouper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; G,context?: any): Seq.Keyed&lt;G, Iterable&lt;K, V&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.groupby">Iterable#groupBy</a></code><h4>Discussion</h4>
<p>Note: This is always an eager operation.</p> <h2>Side effects</h2>
<h3 id="iterable.keyed.foreach">Iterable.Keyed#forEach()</h3>
<p>The <code>sideEffect</code> is executed for every entry in the Iterable.</p> <pre data-language="js">forEach(sideEffect: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; any,context?: any): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.foreach">Iterable#forEach</a></code><h4>Discussion</h4>
<p>Unlike <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">Array#forEach</a></code>, if any call of <code>sideEffect</code> returns <code>false</code>, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).</p> <h2>Creating subsets</h2>
<h3 id="iterable.keyed.slice">Iterable.Keyed#slice()</h3>
<p>Returns a new Iterable of the same type representing a portion of this Iterable from start up to but not including end.</p> <pre data-language="js">slice(begin?: number, end?: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.slice">Iterable#slice</a></code><h4>Discussion</h4>
<p>If begin is negative, it is offset from the end of the Iterable. e.g. <code>slice(-2)</code> returns a Iterable of the last two entries. If it is not provided the new Iterable will begin at the beginning of this Iterable.</p> <p>If end is negative, it is offset from the end of the Iterable. e.g. <code>slice(0, -1)</code> returns an Iterable of everything but the last entry. If it is not provided, the new Iterable will continue through the end of this Iterable.</p> <p>If the requested slice is equivalent to the current Iterable, then it will return itself.</p> <h3 id="iterable.keyed.rest">Iterable.Keyed#rest()</h3>
<p>Returns a new Iterable of the same type containing all entries except the first.</p> <pre data-language="js">rest(): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.rest">Iterable#rest</a></code><h3 id="iterable.keyed.butlast">Iterable.Keyed#butLast()</h3>
<p>Returns a new Iterable of the same type containing all entries except the last.</p> <pre data-language="js">butLast(): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.butlast">Iterable#butLast</a></code><h3 id="iterable.keyed.skip">Iterable.Keyed#skip()</h3>
<p>Returns a new Iterable of the same type which excludes the first <code>amount</code> entries from this Iterable.</p> <pre data-language="js">skip(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skip">Iterable#skip</a></code><h3 id="iterable.keyed.skiplast">Iterable.Keyed#skipLast()</h3>
<p>Returns a new Iterable of the same type which excludes the last <code>amount</code> entries from this Iterable.</p> <pre data-language="js">skipLast(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skiplast">Iterable#skipLast</a></code><h3 id="iterable.keyed.skipwhile">Iterable.Keyed#skipWhile()</h3>
<p>Returns a new Iterable of the same type which includes entries starting from when <code>predicate</code> first returns false.</p> <pre data-language="js">skipWhile(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skipwhile">Iterable#skipWhile</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .skipWhile(x =&gt; x.match(/g/))
// Seq [ 'cat', 'hat', 'god' ]</pre>
<h3 id="iterable.keyed.skipuntil">Iterable.Keyed#skipUntil()</h3>
<p>Returns a new Iterable of the same type which includes entries starting from when <code>predicate</code> first returns true.</p> <pre data-language="js">skipUntil(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skipuntil">Iterable#skipUntil</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .skipUntil(x =&gt; x.match(/hat/))
// Seq [ 'hat', 'god' ]</pre>
<h3 id="iterable.keyed.take">Iterable.Keyed#take()</h3>
<p>Returns a new Iterable of the same type which includes the first <code>amount</code> entries from this Iterable.</p> <pre data-language="js">take(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.take">Iterable#take</a></code><h3 id="iterable.keyed.takelast">Iterable.Keyed#takeLast()</h3>
<p>Returns a new Iterable of the same type which includes the last <code>amount</code> entries from this Iterable.</p> <pre data-language="js">takeLast(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takelast">Iterable#takeLast</a></code><h3 id="iterable.keyed.takewhile">Iterable.Keyed#takeWhile()</h3>
<p>Returns a new Iterable of the same type which includes entries from this Iterable as long as the <code>predicate</code> returns true.</p> <pre data-language="js">takeWhile(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takewhile">Iterable#takeWhile</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .takeWhile(x =&gt; x.match(/o/))
// Seq [ 'dog', 'frog' ]</pre>
<h3 id="iterable.keyed.takeuntil">Iterable.Keyed#takeUntil()</h3>
<p>Returns a new Iterable of the same type which includes entries from this Iterable as long as the <code>predicate</code> returns false.</p> <pre data-language="js">takeUntil(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takeuntil">Iterable#takeUntil</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god').takeUntil(x =&gt; x.match(/at/))
// ['dog', 'frog']</pre>
<h2>Combination</h2>
<h3 id="iterable.keyed.concat">Iterable.Keyed#concat()</h3>
<p>Returns a new Iterable of the same type with other values and iterable-like concatenated to this one.</p> <pre data-language="js">concat(...valuesOrIterables: any[]): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.concat">Iterable#concat</a></code><h4>Discussion</h4>
<p>For Seqs, all entries will be present in the resulting iterable, even if they have the same key.</p> <h3 id="iterable.keyed.flatten">Iterable.Keyed#flatten()</h3>
<p>Flattens nested Iterables.</p> <pre data-language="js">flatten(depth?: number): Iterable&lt;any, any&gt;
flatten(shallow?: boolean): Iterable&lt;any, any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.flatten">Iterable#flatten</a></code><h4>Discussion</h4>
<p>Will deeply flatten the Iterable by default, returning an Iterable of the same type, but a <code>depth</code> can be provided in the form of a number or boolean (where true means to shallowly flatten one level). A depth of 0 (or shallow: false) will deeply flatten.</p> <p>Flattens only others Iterable, not Arrays or Objects.</p> <p>Note: <code>flatten(true)</code> operates on Iterable<any iterable v="">&gt; and returns Iterable</any></p> <h3 id="iterable.keyed.flatmap">Iterable.Keyed#flatMap()</h3>
<p>Flat-maps the Iterable, returning an Iterable of the same type.</p> <pre data-language="js">flatMap&lt;MK, MV&gt;(mapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; Iterable&lt;MK, MV&gt;,context?: any): Iterable&lt;MK, MV&gt;
flatMap&lt;MK, MV&gt;(mapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; any,context?: any): Iterable&lt;MK, MV&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.flatmap">Iterable#flatMap</a></code><h4>Discussion</h4>
<p>Similar to <code>iter.map(...).flatten(true)</code>.</p> <h2>Reducing a value</h2>
<h3 id="iterable.keyed.reduce">Iterable.Keyed#reduce()</h3>
<p>Reduces the Iterable to a value by calling the <code>reducer</code> for every entry in the Iterable and passing along the reduced value.</p> <pre data-language="js">reduce&lt;R&gt;(reducer: (reduction?: R, value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; R,initialReduction?: R,context?: any): R
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reduce">Iterable#reduce</a></code><h4>see</h4>
<p><code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">Array#reduce</a></code>.</p> <h4>Discussion</h4>
<p>If <code>initialReduction</code> is not provided, or is null, the first item in the Iterable will be used.</p> <h3 id="iterable.keyed.reduceright">Iterable.Keyed#reduceRight()</h3>
<p>Reduces the Iterable in reverse (from the right side).</p> <pre data-language="js">reduceRight&lt;R&gt;(reducer: (reduction?: R, value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; R,initialReduction?: R,context?: any): R
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reduceright">Iterable#reduceRight</a></code><h4>Discussion</h4>
<p>Note: Similar to this.reverse().reduce(), and provided for parity with <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight">Array#reduceRight</a></code>.</p> <h3 id="iterable.keyed.every">Iterable.Keyed#every()</h3>
<p>True if <code>predicate</code> returns true for all entries in the Iterable.</p> <pre data-language="js">every(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.every">Iterable#every</a></code><h3 id="iterable.keyed.some">Iterable.Keyed#some()</h3>
<p>True if <code>predicate</code> returns true for any entry in the Iterable.</p> <pre data-language="js">some(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.some">Iterable#some</a></code><h3 id="iterable.keyed.join">Iterable.Keyed#join()</h3>
<p>Joins values together as a string, inserting a separator between each. The default separator is <code>","</code>.</p> <pre data-language="js">join(separator?: string): string
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.join">Iterable#join</a></code><h3 id="iterable.keyed.isempty">Iterable.Keyed#isEmpty()</h3>
<p>Returns true if this Iterable includes no values.</p> <pre data-language="js">isEmpty(): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.isempty">Iterable#isEmpty</a></code><h4>Discussion</h4>
<p>For some lazy <code><a href="#seq">Seq</a></code>, <code>isEmpty</code> might need to iterate to determine emptiness. At most one iteration will occur.</p> <h3 id="iterable.keyed.count">Iterable.Keyed#count()</h3>
<p>Returns the size of this Iterable.</p> <pre data-language="js">count(): number
count(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.count">Iterable#count</a></code><h4>Discussion</h4>
<p>Regardless of if this Iterable can describe its size lazily (some Seqs cannot), this method will always return the correct size. E.g. it evaluates a lazy <code><a href="#seq">Seq</a></code> if necessary.</p> <p>If <code>predicate</code> is provided, then this returns the count of entries in the Iterable for which the <code>predicate</code> returns true.</p> <h3 id="iterable.keyed.countby">Iterable.Keyed#countBy()</h3>
<p>Returns a <code><a href="#seq.keyed">Seq.Keyed</a></code> of counts, grouped by the return value of the <code>grouper</code> function.</p> <pre data-language="js">countBy&lt;G&gt;(grouper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; G,context?: any): Map&lt;G, number&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.countby">Iterable#countBy</a></code><h4>Discussion</h4>
<p>Note: This is not a lazy operation.</p> <h2>Search for value</h2>
<h3 id="iterable.keyed.find">Iterable.Keyed#find()</h3>
<p>Returns the first value for which the <code>predicate</code> returns true.</p> <pre data-language="js">find(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.find">Iterable#find</a></code><h3 id="iterable.keyed.findlast">Iterable.Keyed#findLast()</h3>
<p>Returns the last value for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLast(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlast">Iterable#findLast</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="iterable.keyed.findentry">Iterable.Keyed#findEntry()</h3>
<p>Returns the first [key, value] entry for which the <code>predicate</code> returns true.</p> <pre data-language="js">findEntry(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): Array&lt;any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findentry">Iterable#findEntry</a></code><h3 id="iterable.keyed.findlastentry">Iterable.Keyed#findLastEntry()</h3>
<p>Returns the last [key, value] entry for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLastEntry(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): Array&lt;any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlastentry">Iterable#findLastEntry</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="iterable.keyed.findkey">Iterable.Keyed#findKey()</h3>
<p>Returns the key for which the <code>predicate</code> returns true.</p> <pre data-language="js">findKey(predicate: (value?: V, key?: K, iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; boolean,context?: any): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findkey">Iterable#findKey</a></code><h3 id="iterable.keyed.findlastkey">Iterable.Keyed#findLastKey()</h3>
<p>Returns the last key for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLastKey(predicate: (value?: V, key?: K, iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; boolean,context?: any): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlastkey">Iterable#findLastKey</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="iterable.keyed.keyof">Iterable.Keyed#keyOf()</h3>
<p>Returns the key associated with the search value, or undefined.</p> <pre data-language="js">keyOf(searchValue: V): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyof">Iterable#keyOf</a></code><h3 id="iterable.keyed.lastkeyof">Iterable.Keyed#lastKeyOf()</h3>
<p>Returns the last key associated with the search value, or undefined.</p> <pre data-language="js">lastKeyOf(searchValue: V): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.lastkeyof">Iterable#lastKeyOf</a></code><h3 id="iterable.keyed.max">Iterable.Keyed#max()</h3>
<p>Returns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> <pre data-language="js">max(comparator?: (valueA: V, valueB: V) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.max">Iterable#max</a></code><h4>Discussion</h4>
<p>The <code>comparator</code> is used in the same way as <code><a href="#iterable.sort">Iterable#sort</a></code>. If it is not provided, the default comparator is <code>&gt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code>max</code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&gt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> <h3 id="iterable.keyed.maxby">Iterable.Keyed#maxBy()</h3>
<p>Like <code><a href="#iterable.max">max</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> <pre data-language="js">maxBy&lt;C&gt;(comparatorValueMapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.maxby">Iterable#maxBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.maxBy(hitter =&gt; hitter.avgHits);</pre>
<h3 id="iterable.keyed.min">Iterable.Keyed#min()</h3>
<p>Returns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> <pre data-language="js">min(comparator?: (valueA: V, valueB: V) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.min">Iterable#min</a></code><h4>Discussion</h4>
<p>The <code>comparator</code> is used in the same way as <code><a href="#iterable.sort">Iterable#sort</a></code>. If it is not provided, the default comparator is <code>&lt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code>min</code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&lt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> <h3 id="iterable.keyed.minby">Iterable.Keyed#minBy()</h3>
<p>Like <code><a href="#iterable.min">min</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> <pre data-language="js">minBy&lt;C&gt;(comparatorValueMapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.minby">Iterable#minBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.minBy(hitter =&gt; hitter.avgHits);</pre>
<h2>Comparison</h2>
<h3 id="iterable.keyed.issubset">Iterable.Keyed#isSubset()</h3>
<p>True if <code>iter</code> includes every value in this Iterable.</p> <pre data-language="js">isSubset(iter: Iterable&lt;any, V&gt;): boolean
isSubset(iter: Array&lt;V&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.issubset">Iterable#isSubset</a></code><h3 id="iterable.keyed.issuperset">Iterable.Keyed#isSuperset()</h3>
<p>True if this Iterable includes every value in <code>iter</code>.</p> <pre data-language="js">isSuperset(iter: Iterable&lt;any, V&gt;): boolean
isSuperset(iter: Array&lt;V&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.issuperset">Iterable#isSuperset</a></code><h1 id="iterable.keyed">Iterable.Keyed</h1>
<p>Keyed Iterables have discrete keys tied to each value.</p> <pre data-language="js">class Iterable.Keyed&lt;K, V&gt; extends Iterable&lt;K, V&gt;</pre>
<h4>Discussion</h4>
<p>When iterating <code>Iterable.Keyed</code>, each iteration will yield a <code>[K, V]</code> tuple, in other words, <code><a href="#iterable.entries">Iterable#entries</a></code> is the default iterator for Keyed Iterables.</p> <h2>Construction</h2>
<h3 id="iterable.keyed()">Iterable.Keyed()</h3>
<p>Creates an Iterable.Keyed</p> <pre data-language="js">Iterable.Keyed&lt;K, V&gt;(iter: Iterable.Keyed&lt;K, V&gt;): Iterable.Keyed&lt;K, V&gt;
Iterable.Keyed&lt;K, V&gt;(iter: Iterable&lt;any, any&gt;): Iterable.Keyed&lt;K, V&gt;
Iterable.Keyed&lt;K, V&gt;(array: Array&lt;any&gt;): Iterable.Keyed&lt;K, V&gt;
Iterable.Keyed&lt;V&gt;(obj: {[key: string]: V}): Iterable.Keyed&lt;string, V&gt;
Iterable.Keyed&lt;K, V&gt;(iterator: Iterator&lt;any&gt;): Iterable.Keyed&lt;K, V&gt;
Iterable.Keyed&lt;K, V&gt;(iterable: Object): Iterable.Keyed&lt;K, V&gt;
</pre>
<h4>Discussion</h4>
<p>Similar to <code>Iterable()</code>, however it expects iterable-likes of [K, V] tuples if not constructed from a Iterable.Keyed or JS Object.</p> <h2>Conversion to Seq</h2>
<h3 id="iterable.keyed.toseq">Iterable.Keyed#toSeq()</h3>
<p>Returns Seq.Keyed.</p> <pre data-language="js">toSeq(): Seq.Keyed&lt;K, V&gt;
</pre>
<h4>Overrides</h4>
<code><a href="#iterable.toseq">Iterable#toSeq</a></code><h3 id="iterable.keyed.tokeyedseq">Iterable.Keyed#toKeyedSeq()</h3>
<p>Returns a Seq.Keyed from this Iterable where indices are treated as keys.</p> <pre data-language="js">toKeyedSeq(): Seq.Keyed&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tokeyedseq">Iterable#toKeyedSeq</a></code><h4>Discussion</h4>
<p>This is useful if you want to operate on an Iterable.Indexed and preserve the [index, value] pairs.</p> <p>The returned Seq will have identical iteration order as this Iterable.</p> <p>Example:</p> <pre data-language="js">var indexedSeq = Immutable.Seq.of('A', 'B', 'C');
indexedSeq.filter(v =&gt; v === 'B').toString() // Seq [ 'B' ]
var keyedSeq = indexedSeq.toKeyedSeq();
keyedSeq.filter(v =&gt; v === 'B').toString() // Seq { 1: 'B' }</pre>
<h3 id="iterable.keyed.toindexedseq">Iterable.Keyed#toIndexedSeq()</h3>
<p>Returns an Seq.Indexed of the values of this Iterable, discarding keys.</p> <pre data-language="js">toIndexedSeq(): Seq.Indexed&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toindexedseq">Iterable#toIndexedSeq</a></code><h3 id="iterable.keyed.tosetseq">Iterable.Keyed#toSetSeq()</h3>
<p>Returns a Seq.Set of the values of this Iterable, discarding keys.</p> <pre data-language="js">toSetSeq(): Seq.Set&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tosetseq">Iterable#toSetSeq</a></code><h2>Sequence functions</h2>
<h3 id="iterable.keyed.flip">Iterable.Keyed#flip()</h3>
<p>Returns a new Iterable.Keyed of the same type where the keys and values have been flipped.</p> <pre data-language="js">flip(): Iterable.Keyed&lt;V, K&gt;
</pre>
<h4>Example</h4>
<pre data-language="js">Seq({ a: 'z', b: 'y' }).flip() // { z: 'a', y: 'b' }</pre>
<h3 id="iterable.keyed.mapkeys">Iterable.Keyed#mapKeys()</h3>
<p>Returns a new Iterable.Keyed of the same type with keys passed through a <code>mapper</code> function.</p> <pre data-language="js">mapKeys&lt;M&gt;(mapper: (key?: K, value?: V, iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; M,context?: any): Iterable.Keyed&lt;M, V&gt;
</pre>
<h4>Example</h4>
<pre data-language="js">Seq({ a: 1, b: 2 })
  .mapKeys(x =&gt; x.toUpperCase())
// Seq { A: 1, B: 2 }</pre>
<h3 id="iterable.keyed.mapentries">Iterable.Keyed#mapEntries()</h3>
<p>Returns a new Iterable.Keyed of the same type with entries ([key, value] tuples) passed through a <code>mapper</code> function.</p> <pre data-language="js">mapEntries&lt;KM, VM&gt;(mapper: (entry?: Array&lt;any&gt;,index?: number,iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; Array&lt;any&gt;,context?: any): Iterable.Keyed&lt;KM, VM&gt;
</pre>
<h4>Example</h4>
<pre data-language="js">Seq({ a: 1, b: 2 })
  .mapEntries(([k, v]) =&gt; [k.toUpperCase(), v * 2])
// Seq { A: 2, B: 4 }</pre>
<h2>Value equality</h2>
<h3 id="iterable.keyed.equals">Iterable.Keyed#equals()</h3>
<p>True if this and the other Iterable have value equality, as defined by <code><a href="#is">Immutable.is()</a></code>.</p> <pre data-language="js">equals(other: Iterable&lt;K, V&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.equals">Iterable#equals</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Immutable.is(this, other)</code>, but provided to allow for chained expressions.</p> <h3 id="iterable.keyed.hashcode">Iterable.Keyed#hashCode()</h3>
<p>Computes and returns the hashed identity for this Iterable.</p> <pre data-language="js">hashCode(): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.hashcode">Iterable#hashCode</a></code><h4>Discussion</h4>
<p>The <code>hashCode</code> of an Iterable is used to determine potential equality, and is used when adding this to a <code><a href="#iterable.set">Set</a></code> or as a key in a <code><a href="#map">Map</a></code>, enabling lookup via a different instance.</p> <pre data-language="js">var a = List.of(1, 2, 3);
var b = List.of(1, 2, 3);
assert(a !== b); // different instances
var set = Set.of(a);
assert(set.has(b) === true);</pre>
<p>If two values have the same <code>hashCode</code>, they are <a href="http://en.wikipedia.org/wiki/Collision_(computer_science)">not guaranteed to be equal</a>. If two values have different <code>hashCode</code>s, they must not be equal.</p> <h2>Reading values</h2>
<h3 id="iterable.keyed.get">Iterable.Keyed#get()</h3>
<p>Returns the value associated with the provided key, or notSetValue if the Iterable does not contain this key.</p> <pre data-language="js">get(key: K, notSetValue?: V): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.get">Iterable#get</a></code><h4>Discussion</h4>
<p>Note: it is possible a key may be associated with an <code>undefined</code> value, so if <code>notSetValue</code> is not provided and this method returns <code>undefined</code>, that does not guarantee the key was not found.</p> <h3 id="iterable.keyed.has">Iterable.Keyed#has()</h3>
<p>True if a key exists within this <code>Iterable</code>, using <code><a href="#is">Immutable.is</a></code> to determine equality</p> <pre data-language="js">has(key: K): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.has">Iterable#has</a></code><h3 id="iterable.keyed.includes">Iterable.Keyed#includes()</h3>
<p>True if a value exists within this <code>Iterable</code>, using <code><a href="#is">Immutable.is</a></code> to determine equality</p> <pre data-language="js">includes(value: V): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.includes">Iterable#includes</a></code><h4>alias</h4>
<code>contains()</code><h3 id="iterable.keyed.first">Iterable.Keyed#first()</h3>
<p>The first value in the Iterable.</p> <pre data-language="js">first(): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.first">Iterable#first</a></code><h3 id="iterable.keyed.last">Iterable.Keyed#last()</h3>
<p>The last value in the Iterable.</p> <pre data-language="js">last(): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.last">Iterable#last</a></code><h2>Reading deep values</h2>
<h3 id="iterable.keyed.getin">Iterable.Keyed#getIn()</h3>
<p>Returns the value found by following a path of keys or indices through nested Iterables.</p> <pre data-language="js">getIn(searchKeyPath: Array&lt;any&gt;, notSetValue?: any): any
getIn(searchKeyPath: Iterable&lt;any, any&gt;, notSetValue?: any): any
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.getin">Iterable#getIn</a></code><h3 id="iterable.keyed.hasin">Iterable.Keyed#hasIn()</h3>
<p>True if the result of following a path of keys or indices through nested Iterables results in a set value.</p> <pre data-language="js">hasIn(searchKeyPath: Array&lt;any&gt;): boolean
hasIn(searchKeyPath: Iterable&lt;any, any&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.hasin">Iterable#hasIn</a></code><h2>Conversion to JavaScript types</h2>
<h3 id="iterable.keyed.tojs">Iterable.Keyed#toJS()</h3>
<p>Deeply converts this Iterable to equivalent JS.</p> <pre data-language="js">toJS(): any
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tojs">Iterable#toJS</a></code><h4>alias</h4>
<code>toJSON()</code><h4>Discussion</h4>
<p><code>Iterable.Indexeds</code>, and <code>Iterable.Sets</code> become Arrays, while <code>Iterable.Keyeds</code> become Objects.</p> <h3 id="iterable.keyed.toarray">Iterable.Keyed#toArray()</h3>
<p>Shallowly converts this iterable to an Array, discarding keys.</p> <pre data-language="js">toArray(): Array&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toarray">Iterable#toArray</a></code><h3 id="iterable.keyed.toobject">Iterable.Keyed#toObject()</h3>
<p>Shallowly converts this Iterable to an Object.</p> <pre data-language="js">toObject(): {[key: string]: V}
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toobject">Iterable#toObject</a></code><h4>Discussion</h4>
<p>Throws if keys are not strings.</p> <h2>Conversion to Collections</h2>
<h3 id="iterable.keyed.tomap">Iterable.Keyed#toMap()</h3>
<p>Converts this Iterable to a Map, Throws if keys are not hashable.</p> <pre data-language="js">toMap(): Map&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tomap">Iterable#toMap</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Map(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="iterable.keyed.toorderedmap">Iterable.Keyed#toOrderedMap()</h3>
<p>Converts this Iterable to a Map, maintaining the order of iteration.</p> <pre data-language="js">toOrderedMap(): OrderedMap&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toorderedmap">Iterable#toOrderedMap</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>OrderedMap(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="iterable.keyed.toset">Iterable.Keyed#toSet()</h3>
<p>Converts this Iterable to a Set, discarding keys. Throws if values are not hashable.</p> <pre data-language="js">toSet(): Set&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toset">Iterable#toSet</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Set(this)</code>, but provided to allow for chained expressions.</p> <h3 id="iterable.keyed.toorderedset">Iterable.Keyed#toOrderedSet()</h3>
<p>Converts this Iterable to a Set, maintaining the order of iteration and discarding keys.</p> <pre data-language="js">toOrderedSet(): OrderedSet&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toorderedset">Iterable#toOrderedSet</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>OrderedSet(this.valueSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="iterable.keyed.tolist">Iterable.Keyed#toList()</h3>
<p>Converts this Iterable to a List, discarding keys.</p> <pre data-language="js">toList(): List&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tolist">Iterable#toList</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>List(this)</code>, but provided to allow for chained expressions.</p> <h3 id="iterable.keyed.tostack">Iterable.Keyed#toStack()</h3>
<p>Converts this Iterable to a Stack, discarding keys. Throws if values are not hashable.</p> <pre data-language="js">toStack(): Stack&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tostack">Iterable#toStack</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Stack(this)</code>, but provided to allow for chained expressions.</p> <h2>Iterators</h2>
<h3 id="iterable.keyed.keys">Iterable.Keyed#keys()</h3>
<p>An iterator of this <code>Iterable</code>'s keys.</p> <pre data-language="js">keys(): Iterator&lt;K&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keys">Iterable#keys</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.keyseq">keySeq</a></code> instead, if this is what you want.</p> <h3 id="iterable.keyed.values">Iterable.Keyed#values()</h3>
<p>An iterator of this <code>Iterable</code>'s values.</p> <pre data-language="js">values(): Iterator&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.values">Iterable#values</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.valueseq">valueSeq</a></code> instead, if this is what you want.</p> <h3 id="iterable.keyed.entries">Iterable.Keyed#entries()</h3>
<p>An iterator of this <code>Iterable</code>'s entries as <code>[key, value]</code> tuples.</p> <pre data-language="js">entries(): Iterator&lt;Array&lt;any&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.entries">Iterable#entries</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.entryseq">entrySeq</a></code> instead, if this is what you want.</p> <h2>Iterables (Seq)</h2>
<h3 id="iterable.keyed.keyseq">Iterable.Keyed#keySeq()</h3>
<p>Returns a new Seq.Indexed of the keys of this Iterable, discarding values.</p> <pre data-language="js">keySeq(): Seq.Indexed&lt;K&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyseq">Iterable#keySeq</a></code><h3 id="iterable.keyed.valueseq">Iterable.Keyed#valueSeq()</h3>
<p>Returns an Seq.Indexed of the values of this Iterable, discarding keys.</p> <pre data-language="js">valueSeq(): Seq.Indexed&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.valueseq">Iterable#valueSeq</a></code><h3 id="iterable.keyed.entryseq">Iterable.Keyed#entrySeq()</h3>
<p>Returns a new Seq.Indexed of [key, value] tuples.</p> <pre data-language="js">entrySeq(): Seq.Indexed&lt;Array&lt;any&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.entryseq">Iterable#entrySeq</a></code><h2>Sequence algorithms</h2>
<h3 id="iterable.keyed.map">Iterable.Keyed#map()</h3>
<p>Returns a new Iterable of the same type with values passed through a <code>mapper</code> function.</p> <pre data-language="js">map&lt;M&gt;(mapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; M,context?: any): Iterable&lt;K, M&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.map">Iterable#map</a></code><h4>Example</h4>
<pre data-language="js">Seq({ a: 1, b: 2 }).map(x =&gt; 10 * x)
// Seq { a: 10, b: 20 }</pre>
<h3 id="iterable.keyed.filter">Iterable.Keyed#filter()</h3>
<p>Returns a new Iterable of the same type with only the entries for which the <code>predicate</code> function returns true.</p> <pre data-language="js">filter(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.filter">Iterable#filter</a></code><h4>Example</h4>
<pre data-language="js">Seq({a:1,b:2,c:3,d:4}).filter(x =&gt; x % 2 === 0)
// Seq { b: 2, d: 4 }</pre>
<h3 id="iterable.keyed.filternot">Iterable.Keyed#filterNot()</h3>
<p>Returns a new Iterable of the same type with only the entries for which the <code>predicate</code> function returns false.</p> <pre data-language="js">filterNot(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.filternot">Iterable#filterNot</a></code><h4>Example</h4>
<pre data-language="js">Seq({a:1,b:2,c:3,d:4}).filterNot(x =&gt; x % 2 === 0)
// Seq { a: 1, c: 3 }</pre>
<h3 id="iterable.keyed.reverse">Iterable.Keyed#reverse()</h3>
<p>Returns a new Iterable of the same type in reverse order.</p> <pre data-language="js">reverse(): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reverse">Iterable#reverse</a></code><h3 id="iterable.keyed.sort">Iterable.Keyed#sort()</h3>
<p>Returns a new Iterable of the same type which includes the same entries, stably sorted by using a <code>comparator</code>.</p> <pre data-language="js">sort(comparator?: (valueA: V, valueB: V) =&gt; number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.sort">Iterable#sort</a></code><h4>Discussion</h4>
<p>If a <code>comparator</code> is not provided, a default comparator uses <code>&lt;</code> and <code>&gt;</code>.</p> <p><code>comparator(valueA, valueB)</code>:</p> <ul> <li>Returns <code>0</code> if the elements should not be swapped.</li> <li>Returns <code>-1</code> (or any negative number) if <code>valueA</code> comes before <code>valueB</code>
</li> <li>Returns <code>1</code> (or any positive number) if <code>valueA</code> comes after <code>valueB</code>
</li> <li>Is pure, i.e. it must always return the same value for the same pair of values.</li> </ul> <p>When sorting collections which have no defined order, their ordered equivalents will be returned. e.g. <code>map.sort()</code> returns OrderedMap.</p> <h3 id="iterable.keyed.sortby">Iterable.Keyed#sortBy()</h3>
<p>Like <code><a href="#iterable.sort">sort</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for sorting by more sophisticated means:</p> <pre data-language="js">sortBy&lt;C&gt;(comparatorValueMapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.sortby">Iterable#sortBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.sortBy(hitter =&gt; hitter.avgHits);</pre>
<h3 id="iterable.keyed.groupby">Iterable.Keyed#groupBy()</h3>
<p>Returns a <code><a href="#iterable.keyed">Iterable.Keyed</a></code> of <code>Iterable.Keyeds</code>, grouped by the return value of the <code>grouper</code> function.</p> <pre data-language="js">groupBy&lt;G&gt;(grouper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; G,context?: any): Seq.Keyed&lt;G, Iterable&lt;K, V&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.groupby">Iterable#groupBy</a></code><h4>Discussion</h4>
<p>Note: This is always an eager operation.</p> <h2>Side effects</h2>
<h3 id="iterable.keyed.foreach">Iterable.Keyed#forEach()</h3>
<p>The <code>sideEffect</code> is executed for every entry in the Iterable.</p> <pre data-language="js">forEach(sideEffect: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; any,context?: any): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.foreach">Iterable#forEach</a></code><h4>Discussion</h4>
<p>Unlike <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">Array#forEach</a></code>, if any call of <code>sideEffect</code> returns <code>false</code>, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).</p> <h2>Creating subsets</h2>
<h3 id="iterable.keyed.slice">Iterable.Keyed#slice()</h3>
<p>Returns a new Iterable of the same type representing a portion of this Iterable from start up to but not including end.</p> <pre data-language="js">slice(begin?: number, end?: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.slice">Iterable#slice</a></code><h4>Discussion</h4>
<p>If begin is negative, it is offset from the end of the Iterable. e.g. <code>slice(-2)</code> returns a Iterable of the last two entries. If it is not provided the new Iterable will begin at the beginning of this Iterable.</p> <p>If end is negative, it is offset from the end of the Iterable. e.g. <code>slice(0, -1)</code> returns an Iterable of everything but the last entry. If it is not provided, the new Iterable will continue through the end of this Iterable.</p> <p>If the requested slice is equivalent to the current Iterable, then it will return itself.</p> <h3 id="iterable.keyed.rest">Iterable.Keyed#rest()</h3>
<p>Returns a new Iterable of the same type containing all entries except the first.</p> <pre data-language="js">rest(): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.rest">Iterable#rest</a></code><h3 id="iterable.keyed.butlast">Iterable.Keyed#butLast()</h3>
<p>Returns a new Iterable of the same type containing all entries except the last.</p> <pre data-language="js">butLast(): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.butlast">Iterable#butLast</a></code><h3 id="iterable.keyed.skip">Iterable.Keyed#skip()</h3>
<p>Returns a new Iterable of the same type which excludes the first <code>amount</code> entries from this Iterable.</p> <pre data-language="js">skip(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skip">Iterable#skip</a></code><h3 id="iterable.keyed.skiplast">Iterable.Keyed#skipLast()</h3>
<p>Returns a new Iterable of the same type which excludes the last <code>amount</code> entries from this Iterable.</p> <pre data-language="js">skipLast(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skiplast">Iterable#skipLast</a></code><h3 id="iterable.keyed.skipwhile">Iterable.Keyed#skipWhile()</h3>
<p>Returns a new Iterable of the same type which includes entries starting from when <code>predicate</code> first returns false.</p> <pre data-language="js">skipWhile(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skipwhile">Iterable#skipWhile</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .skipWhile(x =&gt; x.match(/g/))
// Seq [ 'cat', 'hat', 'god' ]</pre>
<h3 id="iterable.keyed.skipuntil">Iterable.Keyed#skipUntil()</h3>
<p>Returns a new Iterable of the same type which includes entries starting from when <code>predicate</code> first returns true.</p> <pre data-language="js">skipUntil(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skipuntil">Iterable#skipUntil</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .skipUntil(x =&gt; x.match(/hat/))
// Seq [ 'hat', 'god' ]</pre>
<h3 id="iterable.keyed.take">Iterable.Keyed#take()</h3>
<p>Returns a new Iterable of the same type which includes the first <code>amount</code> entries from this Iterable.</p> <pre data-language="js">take(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.take">Iterable#take</a></code><h3 id="iterable.keyed.takelast">Iterable.Keyed#takeLast()</h3>
<p>Returns a new Iterable of the same type which includes the last <code>amount</code> entries from this Iterable.</p> <pre data-language="js">takeLast(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takelast">Iterable#takeLast</a></code><h3 id="iterable.keyed.takewhile">Iterable.Keyed#takeWhile()</h3>
<p>Returns a new Iterable of the same type which includes entries from this Iterable as long as the <code>predicate</code> returns true.</p> <pre data-language="js">takeWhile(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takewhile">Iterable#takeWhile</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .takeWhile(x =&gt; x.match(/o/))
// Seq [ 'dog', 'frog' ]</pre>
<h3 id="iterable.keyed.takeuntil">Iterable.Keyed#takeUntil()</h3>
<p>Returns a new Iterable of the same type which includes entries from this Iterable as long as the <code>predicate</code> returns false.</p> <pre data-language="js">takeUntil(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takeuntil">Iterable#takeUntil</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god').takeUntil(x =&gt; x.match(/at/))
// ['dog', 'frog']</pre>
<h2>Combination</h2>
<h3 id="iterable.keyed.concat">Iterable.Keyed#concat()</h3>
<p>Returns a new Iterable of the same type with other values and iterable-like concatenated to this one.</p> <pre data-language="js">concat(...valuesOrIterables: any[]): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.concat">Iterable#concat</a></code><h4>Discussion</h4>
<p>For Seqs, all entries will be present in the resulting iterable, even if they have the same key.</p> <h3 id="iterable.keyed.flatten">Iterable.Keyed#flatten()</h3>
<p>Flattens nested Iterables.</p> <pre data-language="js">flatten(depth?: number): Iterable&lt;any, any&gt;
flatten(shallow?: boolean): Iterable&lt;any, any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.flatten">Iterable#flatten</a></code><h4>Discussion</h4>
<p>Will deeply flatten the Iterable by default, returning an Iterable of the same type, but a <code>depth</code> can be provided in the form of a number or boolean (where true means to shallowly flatten one level). A depth of 0 (or shallow: false) will deeply flatten.</p> <p>Flattens only others Iterable, not Arrays or Objects.</p> <p>Note: <code>flatten(true)</code> operates on Iterable<any iterable v="">&gt; and returns Iterable</any></p> <h3 id="iterable.keyed.flatmap">Iterable.Keyed#flatMap()</h3>
<p>Flat-maps the Iterable, returning an Iterable of the same type.</p> <pre data-language="js">flatMap&lt;MK, MV&gt;(mapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; Iterable&lt;MK, MV&gt;,context?: any): Iterable&lt;MK, MV&gt;
flatMap&lt;MK, MV&gt;(mapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; any,context?: any): Iterable&lt;MK, MV&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.flatmap">Iterable#flatMap</a></code><h4>Discussion</h4>
<p>Similar to <code>iter.map(...).flatten(true)</code>.</p> <h2>Reducing a value</h2>
<h3 id="iterable.keyed.reduce">Iterable.Keyed#reduce()</h3>
<p>Reduces the Iterable to a value by calling the <code>reducer</code> for every entry in the Iterable and passing along the reduced value.</p> <pre data-language="js">reduce&lt;R&gt;(reducer: (reduction?: R, value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; R,initialReduction?: R,context?: any): R
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reduce">Iterable#reduce</a></code><h4>see</h4>
<p><code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">Array#reduce</a></code>.</p> <h4>Discussion</h4>
<p>If <code>initialReduction</code> is not provided, or is null, the first item in the Iterable will be used.</p> <h3 id="iterable.keyed.reduceright">Iterable.Keyed#reduceRight()</h3>
<p>Reduces the Iterable in reverse (from the right side).</p> <pre data-language="js">reduceRight&lt;R&gt;(reducer: (reduction?: R, value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; R,initialReduction?: R,context?: any): R
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reduceright">Iterable#reduceRight</a></code><h4>Discussion</h4>
<p>Note: Similar to this.reverse().reduce(), and provided for parity with <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight">Array#reduceRight</a></code>.</p> <h3 id="iterable.keyed.every">Iterable.Keyed#every()</h3>
<p>True if <code>predicate</code> returns true for all entries in the Iterable.</p> <pre data-language="js">every(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.every">Iterable#every</a></code><h3 id="iterable.keyed.some">Iterable.Keyed#some()</h3>
<p>True if <code>predicate</code> returns true for any entry in the Iterable.</p> <pre data-language="js">some(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.some">Iterable#some</a></code><h3 id="iterable.keyed.join">Iterable.Keyed#join()</h3>
<p>Joins values together as a string, inserting a separator between each. The default separator is <code>","</code>.</p> <pre data-language="js">join(separator?: string): string
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.join">Iterable#join</a></code><h3 id="iterable.keyed.isempty">Iterable.Keyed#isEmpty()</h3>
<p>Returns true if this Iterable includes no values.</p> <pre data-language="js">isEmpty(): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.isempty">Iterable#isEmpty</a></code><h4>Discussion</h4>
<p>For some lazy <code><a href="#seq">Seq</a></code>, <code>isEmpty</code> might need to iterate to determine emptiness. At most one iteration will occur.</p> <h3 id="iterable.keyed.count">Iterable.Keyed#count()</h3>
<p>Returns the size of this Iterable.</p> <pre data-language="js">count(): number
count(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.count">Iterable#count</a></code><h4>Discussion</h4>
<p>Regardless of if this Iterable can describe its size lazily (some Seqs cannot), this method will always return the correct size. E.g. it evaluates a lazy <code><a href="#seq">Seq</a></code> if necessary.</p> <p>If <code>predicate</code> is provided, then this returns the count of entries in the Iterable for which the <code>predicate</code> returns true.</p> <h3 id="iterable.keyed.countby">Iterable.Keyed#countBy()</h3>
<p>Returns a <code><a href="#seq.keyed">Seq.Keyed</a></code> of counts, grouped by the return value of the <code>grouper</code> function.</p> <pre data-language="js">countBy&lt;G&gt;(grouper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; G,context?: any): Map&lt;G, number&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.countby">Iterable#countBy</a></code><h4>Discussion</h4>
<p>Note: This is not a lazy operation.</p> <h2>Search for value</h2>
<h3 id="iterable.keyed.find">Iterable.Keyed#find()</h3>
<p>Returns the first value for which the <code>predicate</code> returns true.</p> <pre data-language="js">find(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.find">Iterable#find</a></code><h3 id="iterable.keyed.findlast">Iterable.Keyed#findLast()</h3>
<p>Returns the last value for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLast(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlast">Iterable#findLast</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="iterable.keyed.findentry">Iterable.Keyed#findEntry()</h3>
<p>Returns the first [key, value] entry for which the <code>predicate</code> returns true.</p> <pre data-language="js">findEntry(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): Array&lt;any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findentry">Iterable#findEntry</a></code><h3 id="iterable.keyed.findlastentry">Iterable.Keyed#findLastEntry()</h3>
<p>Returns the last [key, value] entry for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLastEntry(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): Array&lt;any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlastentry">Iterable#findLastEntry</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="iterable.keyed.findkey">Iterable.Keyed#findKey()</h3>
<p>Returns the key for which the <code>predicate</code> returns true.</p> <pre data-language="js">findKey(predicate: (value?: V, key?: K, iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; boolean,context?: any): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findkey">Iterable#findKey</a></code><h3 id="iterable.keyed.findlastkey">Iterable.Keyed#findLastKey()</h3>
<p>Returns the last key for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLastKey(predicate: (value?: V, key?: K, iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; boolean,context?: any): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlastkey">Iterable#findLastKey</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="iterable.keyed.keyof">Iterable.Keyed#keyOf()</h3>
<p>Returns the key associated with the search value, or undefined.</p> <pre data-language="js">keyOf(searchValue: V): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyof">Iterable#keyOf</a></code><h3 id="iterable.keyed.lastkeyof">Iterable.Keyed#lastKeyOf()</h3>
<p>Returns the last key associated with the search value, or undefined.</p> <pre data-language="js">lastKeyOf(searchValue: V): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.lastkeyof">Iterable#lastKeyOf</a></code><h3 id="iterable.keyed.max">Iterable.Keyed#max()</h3>
<p>Returns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> <pre data-language="js">max(comparator?: (valueA: V, valueB: V) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.max">Iterable#max</a></code><h4>Discussion</h4>
<p>The <code>comparator</code> is used in the same way as <code><a href="#iterable.sort">Iterable#sort</a></code>. If it is not provided, the default comparator is <code>&gt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code>max</code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&gt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> <h3 id="iterable.keyed.maxby">Iterable.Keyed#maxBy()</h3>
<p>Like <code><a href="#iterable.max">max</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> <pre data-language="js">maxBy&lt;C&gt;(comparatorValueMapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.maxby">Iterable#maxBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.maxBy(hitter =&gt; hitter.avgHits);</pre>
<h3 id="iterable.keyed.min">Iterable.Keyed#min()</h3>
<p>Returns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> <pre data-language="js">min(comparator?: (valueA: V, valueB: V) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.min">Iterable#min</a></code><h4>Discussion</h4>
<p>The <code>comparator</code> is used in the same way as <code><a href="#iterable.sort">Iterable#sort</a></code>. If it is not provided, the default comparator is <code>&lt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code>min</code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&lt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> <h3 id="iterable.keyed.minby">Iterable.Keyed#minBy()</h3>
<p>Like <code><a href="#iterable.min">min</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> <pre data-language="js">minBy&lt;C&gt;(comparatorValueMapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.minby">Iterable#minBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.minBy(hitter =&gt; hitter.avgHits);</pre>
<h2>Comparison</h2>
<h3 id="iterable.keyed.issubset">Iterable.Keyed#isSubset()</h3>
<p>True if <code>iter</code> includes every value in this Iterable.</p> <pre data-language="js">isSubset(iter: Iterable&lt;any, V&gt;): boolean
isSubset(iter: Array&lt;V&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.issubset">Iterable#isSubset</a></code><h3 id="iterable.keyed.issuperset">Iterable.Keyed#isSuperset()</h3>
<p>True if this Iterable includes every value in <code>iter</code>.</p> <pre data-language="js">isSuperset(iter: Iterable&lt;any, V&gt;): boolean
isSuperset(iter: Array&lt;V&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.issuperset">Iterable#isSuperset</a></code><h1 id="iterable.keyed">Iterable.Keyed</h1>
<p>Keyed Iterables have discrete keys tied to each value.</p> <pre data-language="js">class Iterable.Keyed&lt;K, V&gt; extends Iterable&lt;K, V&gt;</pre>
<h4>Discussion</h4>
<p>When iterating <code>Iterable.Keyed</code>, each iteration will yield a <code>[K, V]</code> tuple, in other words, <code><a href="#iterable.entries">Iterable#entries</a></code> is the default iterator for Keyed Iterables.</p> <h2>Construction</h2>
<h3 id="iterable.keyed()">Iterable.Keyed()</h3>
<p>Creates an Iterable.Keyed</p> <pre data-language="js">Iterable.Keyed&lt;K, V&gt;(iter: Iterable.Keyed&lt;K, V&gt;): Iterable.Keyed&lt;K, V&gt;
Iterable.Keyed&lt;K, V&gt;(iter: Iterable&lt;any, any&gt;): Iterable.Keyed&lt;K, V&gt;
Iterable.Keyed&lt;K, V&gt;(array: Array&lt;any&gt;): Iterable.Keyed&lt;K, V&gt;
Iterable.Keyed&lt;V&gt;(obj: {[key: string]: V}): Iterable.Keyed&lt;string, V&gt;
Iterable.Keyed&lt;K, V&gt;(iterator: Iterator&lt;any&gt;): Iterable.Keyed&lt;K, V&gt;
Iterable.Keyed&lt;K, V&gt;(iterable: Object): Iterable.Keyed&lt;K, V&gt;
</pre>
<h4>Discussion</h4>
<p>Similar to <code>Iterable()</code>, however it expects iterable-likes of [K, V] tuples if not constructed from a Iterable.Keyed or JS Object.</p> <h2>Conversion to Seq</h2>
<h3 id="iterable.keyed.toseq">Iterable.Keyed#toSeq()</h3>
<p>Returns Seq.Keyed.</p> <pre data-language="js">toSeq(): Seq.Keyed&lt;K, V&gt;
</pre>
<h4>Overrides</h4>
<code><a href="#iterable.toseq">Iterable#toSeq</a></code><h3 id="iterable.keyed.tokeyedseq">Iterable.Keyed#toKeyedSeq()</h3>
<p>Returns a Seq.Keyed from this Iterable where indices are treated as keys.</p> <pre data-language="js">toKeyedSeq(): Seq.Keyed&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tokeyedseq">Iterable#toKeyedSeq</a></code><h4>Discussion</h4>
<p>This is useful if you want to operate on an Iterable.Indexed and preserve the [index, value] pairs.</p> <p>The returned Seq will have identical iteration order as this Iterable.</p> <p>Example:</p> <pre data-language="js">var indexedSeq = Immutable.Seq.of('A', 'B', 'C');
indexedSeq.filter(v =&gt; v === 'B').toString() // Seq [ 'B' ]
var keyedSeq = indexedSeq.toKeyedSeq();
keyedSeq.filter(v =&gt; v === 'B').toString() // Seq { 1: 'B' }</pre>
<h3 id="iterable.keyed.toindexedseq">Iterable.Keyed#toIndexedSeq()</h3>
<p>Returns an Seq.Indexed of the values of this Iterable, discarding keys.</p> <pre data-language="js">toIndexedSeq(): Seq.Indexed&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toindexedseq">Iterable#toIndexedSeq</a></code><h3 id="iterable.keyed.tosetseq">Iterable.Keyed#toSetSeq()</h3>
<p>Returns a Seq.Set of the values of this Iterable, discarding keys.</p> <pre data-language="js">toSetSeq(): Seq.Set&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tosetseq">Iterable#toSetSeq</a></code><h2>Sequence functions</h2>
<h3 id="iterable.keyed.flip">Iterable.Keyed#flip()</h3>
<p>Returns a new Iterable.Keyed of the same type where the keys and values have been flipped.</p> <pre data-language="js">flip(): Iterable.Keyed&lt;V, K&gt;
</pre>
<h4>Example</h4>
<pre data-language="js">Seq({ a: 'z', b: 'y' }).flip() // { z: 'a', y: 'b' }</pre>
<h3 id="iterable.keyed.mapkeys">Iterable.Keyed#mapKeys()</h3>
<p>Returns a new Iterable.Keyed of the same type with keys passed through a <code>mapper</code> function.</p> <pre data-language="js">mapKeys&lt;M&gt;(mapper: (key?: K, value?: V, iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; M,context?: any): Iterable.Keyed&lt;M, V&gt;
</pre>
<h4>Example</h4>
<pre data-language="js">Seq({ a: 1, b: 2 })
  .mapKeys(x =&gt; x.toUpperCase())
// Seq { A: 1, B: 2 }</pre>
<h3 id="iterable.keyed.mapentries">Iterable.Keyed#mapEntries()</h3>
<p>Returns a new Iterable.Keyed of the same type with entries ([key, value] tuples) passed through a <code>mapper</code> function.</p> <pre data-language="js">mapEntries&lt;KM, VM&gt;(mapper: (entry?: Array&lt;any&gt;,index?: number,iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; Array&lt;any&gt;,context?: any): Iterable.Keyed&lt;KM, VM&gt;
</pre>
<h4>Example</h4>
<pre data-language="js">Seq({ a: 1, b: 2 })
  .mapEntries(([k, v]) =&gt; [k.toUpperCase(), v * 2])
// Seq { A: 2, B: 4 }</pre>
<h2>Value equality</h2>
<h3 id="iterable.keyed.equals">Iterable.Keyed#equals()</h3>
<p>True if this and the other Iterable have value equality, as defined by <code><a href="#is">Immutable.is()</a></code>.</p> <pre data-language="js">equals(other: Iterable&lt;K, V&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.equals">Iterable#equals</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Immutable.is(this, other)</code>, but provided to allow for chained expressions.</p> <h3 id="iterable.keyed.hashcode">Iterable.Keyed#hashCode()</h3>
<p>Computes and returns the hashed identity for this Iterable.</p> <pre data-language="js">hashCode(): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.hashcode">Iterable#hashCode</a></code><h4>Discussion</h4>
<p>The <code>hashCode</code> of an Iterable is used to determine potential equality, and is used when adding this to a <code><a href="#iterable.set">Set</a></code> or as a key in a <code><a href="#map">Map</a></code>, enabling lookup via a different instance.</p> <pre data-language="js">var a = List.of(1, 2, 3);
var b = List.of(1, 2, 3);
assert(a !== b); // different instances
var set = Set.of(a);
assert(set.has(b) === true);</pre>
<p>If two values have the same <code>hashCode</code>, they are <a href="http://en.wikipedia.org/wiki/Collision_(computer_science)">not guaranteed to be equal</a>. If two values have different <code>hashCode</code>s, they must not be equal.</p> <h2>Reading values</h2>
<h3 id="iterable.keyed.get">Iterable.Keyed#get()</h3>
<p>Returns the value associated with the provided key, or notSetValue if the Iterable does not contain this key.</p> <pre data-language="js">get(key: K, notSetValue?: V): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.get">Iterable#get</a></code><h4>Discussion</h4>
<p>Note: it is possible a key may be associated with an <code>undefined</code> value, so if <code>notSetValue</code> is not provided and this method returns <code>undefined</code>, that does not guarantee the key was not found.</p> <h3 id="iterable.keyed.has">Iterable.Keyed#has()</h3>
<p>True if a key exists within this <code>Iterable</code>, using <code><a href="#is">Immutable.is</a></code> to determine equality</p> <pre data-language="js">has(key: K): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.has">Iterable#has</a></code><h3 id="iterable.keyed.includes">Iterable.Keyed#includes()</h3>
<p>True if a value exists within this <code>Iterable</code>, using <code><a href="#is">Immutable.is</a></code> to determine equality</p> <pre data-language="js">includes(value: V): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.includes">Iterable#includes</a></code><h4>alias</h4>
<code>contains()</code><h3 id="iterable.keyed.first">Iterable.Keyed#first()</h3>
<p>The first value in the Iterable.</p> <pre data-language="js">first(): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.first">Iterable#first</a></code><h3 id="iterable.keyed.last">Iterable.Keyed#last()</h3>
<p>The last value in the Iterable.</p> <pre data-language="js">last(): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.last">Iterable#last</a></code><h2>Reading deep values</h2>
<h3 id="iterable.keyed.getin">Iterable.Keyed#getIn()</h3>
<p>Returns the value found by following a path of keys or indices through nested Iterables.</p> <pre data-language="js">getIn(searchKeyPath: Array&lt;any&gt;, notSetValue?: any): any
getIn(searchKeyPath: Iterable&lt;any, any&gt;, notSetValue?: any): any
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.getin">Iterable#getIn</a></code><h3 id="iterable.keyed.hasin">Iterable.Keyed#hasIn()</h3>
<p>True if the result of following a path of keys or indices through nested Iterables results in a set value.</p> <pre data-language="js">hasIn(searchKeyPath: Array&lt;any&gt;): boolean
hasIn(searchKeyPath: Iterable&lt;any, any&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.hasin">Iterable#hasIn</a></code><h2>Conversion to JavaScript types</h2>
<h3 id="iterable.keyed.tojs">Iterable.Keyed#toJS()</h3>
<p>Deeply converts this Iterable to equivalent JS.</p> <pre data-language="js">toJS(): any
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tojs">Iterable#toJS</a></code><h4>alias</h4>
<code>toJSON()</code><h4>Discussion</h4>
<p><code>Iterable.Indexeds</code>, and <code>Iterable.Sets</code> become Arrays, while <code>Iterable.Keyeds</code> become Objects.</p> <h3 id="iterable.keyed.toarray">Iterable.Keyed#toArray()</h3>
<p>Shallowly converts this iterable to an Array, discarding keys.</p> <pre data-language="js">toArray(): Array&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toarray">Iterable#toArray</a></code><h3 id="iterable.keyed.toobject">Iterable.Keyed#toObject()</h3>
<p>Shallowly converts this Iterable to an Object.</p> <pre data-language="js">toObject(): {[key: string]: V}
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toobject">Iterable#toObject</a></code><h4>Discussion</h4>
<p>Throws if keys are not strings.</p> <h2>Conversion to Collections</h2>
<h3 id="iterable.keyed.tomap">Iterable.Keyed#toMap()</h3>
<p>Converts this Iterable to a Map, Throws if keys are not hashable.</p> <pre data-language="js">toMap(): Map&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tomap">Iterable#toMap</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Map(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="iterable.keyed.toorderedmap">Iterable.Keyed#toOrderedMap()</h3>
<p>Converts this Iterable to a Map, maintaining the order of iteration.</p> <pre data-language="js">toOrderedMap(): OrderedMap&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toorderedmap">Iterable#toOrderedMap</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>OrderedMap(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="iterable.keyed.toset">Iterable.Keyed#toSet()</h3>
<p>Converts this Iterable to a Set, discarding keys. Throws if values are not hashable.</p> <pre data-language="js">toSet(): Set&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toset">Iterable#toSet</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Set(this)</code>, but provided to allow for chained expressions.</p> <h3 id="iterable.keyed.toorderedset">Iterable.Keyed#toOrderedSet()</h3>
<p>Converts this Iterable to a Set, maintaining the order of iteration and discarding keys.</p> <pre data-language="js">toOrderedSet(): OrderedSet&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toorderedset">Iterable#toOrderedSet</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>OrderedSet(this.valueSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="iterable.keyed.tolist">Iterable.Keyed#toList()</h3>
<p>Converts this Iterable to a List, discarding keys.</p> <pre data-language="js">toList(): List&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tolist">Iterable#toList</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>List(this)</code>, but provided to allow for chained expressions.</p> <h3 id="iterable.keyed.tostack">Iterable.Keyed#toStack()</h3>
<p>Converts this Iterable to a Stack, discarding keys. Throws if values are not hashable.</p> <pre data-language="js">toStack(): Stack&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tostack">Iterable#toStack</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Stack(this)</code>, but provided to allow for chained expressions.</p> <h2>Iterators</h2>
<h3 id="iterable.keyed.keys">Iterable.Keyed#keys()</h3>
<p>An iterator of this <code>Iterable</code>'s keys.</p> <pre data-language="js">keys(): Iterator&lt;K&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keys">Iterable#keys</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.keyseq">keySeq</a></code> instead, if this is what you want.</p> <h3 id="iterable.keyed.values">Iterable.Keyed#values()</h3>
<p>An iterator of this <code>Iterable</code>'s values.</p> <pre data-language="js">values(): Iterator&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.values">Iterable#values</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.valueseq">valueSeq</a></code> instead, if this is what you want.</p> <h3 id="iterable.keyed.entries">Iterable.Keyed#entries()</h3>
<p>An iterator of this <code>Iterable</code>'s entries as <code>[key, value]</code> tuples.</p> <pre data-language="js">entries(): Iterator&lt;Array&lt;any&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.entries">Iterable#entries</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.entryseq">entrySeq</a></code> instead, if this is what you want.</p> <h2>Iterables (Seq)</h2>
<h3 id="iterable.keyed.keyseq">Iterable.Keyed#keySeq()</h3>
<p>Returns a new Seq.Indexed of the keys of this Iterable, discarding values.</p> <pre data-language="js">keySeq(): Seq.Indexed&lt;K&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyseq">Iterable#keySeq</a></code><h3 id="iterable.keyed.valueseq">Iterable.Keyed#valueSeq()</h3>
<p>Returns an Seq.Indexed of the values of this Iterable, discarding keys.</p> <pre data-language="js">valueSeq(): Seq.Indexed&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.valueseq">Iterable#valueSeq</a></code><h3 id="iterable.keyed.entryseq">Iterable.Keyed#entrySeq()</h3>
<p>Returns a new Seq.Indexed of [key, value] tuples.</p> <pre data-language="js">entrySeq(): Seq.Indexed&lt;Array&lt;any&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.entryseq">Iterable#entrySeq</a></code><h2>Sequence algorithms</h2>
<h3 id="iterable.keyed.map">Iterable.Keyed#map()</h3>
<p>Returns a new Iterable of the same type with values passed through a <code>mapper</code> function.</p> <pre data-language="js">map&lt;M&gt;(mapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; M,context?: any): Iterable&lt;K, M&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.map">Iterable#map</a></code><h4>Example</h4>
<pre data-language="js">Seq({ a: 1, b: 2 }).map(x =&gt; 10 * x)
// Seq { a: 10, b: 20 }</pre>
<h3 id="iterable.keyed.filter">Iterable.Keyed#filter()</h3>
<p>Returns a new Iterable of the same type with only the entries for which the <code>predicate</code> function returns true.</p> <pre data-language="js">filter(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.filter">Iterable#filter</a></code><h4>Example</h4>
<pre data-language="js">Seq({a:1,b:2,c:3,d:4}).filter(x =&gt; x % 2 === 0)
// Seq { b: 2, d: 4 }</pre>
<h3 id="iterable.keyed.filternot">Iterable.Keyed#filterNot()</h3>
<p>Returns a new Iterable of the same type with only the entries for which the <code>predicate</code> function returns false.</p> <pre data-language="js">filterNot(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.filternot">Iterable#filterNot</a></code><h4>Example</h4>
<pre data-language="js">Seq({a:1,b:2,c:3,d:4}).filterNot(x =&gt; x % 2 === 0)
// Seq { a: 1, c: 3 }</pre>
<h3 id="iterable.keyed.reverse">Iterable.Keyed#reverse()</h3>
<p>Returns a new Iterable of the same type in reverse order.</p> <pre data-language="js">reverse(): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reverse">Iterable#reverse</a></code><h3 id="iterable.keyed.sort">Iterable.Keyed#sort()</h3>
<p>Returns a new Iterable of the same type which includes the same entries, stably sorted by using a <code>comparator</code>.</p> <pre data-language="js">sort(comparator?: (valueA: V, valueB: V) =&gt; number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.sort">Iterable#sort</a></code><h4>Discussion</h4>
<p>If a <code>comparator</code> is not provided, a default comparator uses <code>&lt;</code> and <code>&gt;</code>.</p> <p><code>comparator(valueA, valueB)</code>:</p> <ul> <li>Returns <code>0</code> if the elements should not be swapped.</li> <li>Returns <code>-1</code> (or any negative number) if <code>valueA</code> comes before <code>valueB</code>
</li> <li>Returns <code>1</code> (or any positive number) if <code>valueA</code> comes after <code>valueB</code>
</li> <li>Is pure, i.e. it must always return the same value for the same pair of values.</li> </ul> <p>When sorting collections which have no defined order, their ordered equivalents will be returned. e.g. <code>map.sort()</code> returns OrderedMap.</p> <h3 id="iterable.keyed.sortby">Iterable.Keyed#sortBy()</h3>
<p>Like <code><a href="#iterable.sort">sort</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for sorting by more sophisticated means:</p> <pre data-language="js">sortBy&lt;C&gt;(comparatorValueMapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.sortby">Iterable#sortBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.sortBy(hitter =&gt; hitter.avgHits);</pre>
<h3 id="iterable.keyed.groupby">Iterable.Keyed#groupBy()</h3>
<p>Returns a <code><a href="#iterable.keyed">Iterable.Keyed</a></code> of <code>Iterable.Keyeds</code>, grouped by the return value of the <code>grouper</code> function.</p> <pre data-language="js">groupBy&lt;G&gt;(grouper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; G,context?: any): Seq.Keyed&lt;G, Iterable&lt;K, V&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.groupby">Iterable#groupBy</a></code><h4>Discussion</h4>
<p>Note: This is always an eager operation.</p> <h2>Side effects</h2>
<h3 id="iterable.keyed.foreach">Iterable.Keyed#forEach()</h3>
<p>The <code>sideEffect</code> is executed for every entry in the Iterable.</p> <pre data-language="js">forEach(sideEffect: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; any,context?: any): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.foreach">Iterable#forEach</a></code><h4>Discussion</h4>
<p>Unlike <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">Array#forEach</a></code>, if any call of <code>sideEffect</code> returns <code>false</code>, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).</p> <h2>Creating subsets</h2>
<h3 id="iterable.keyed.slice">Iterable.Keyed#slice()</h3>
<p>Returns a new Iterable of the same type representing a portion of this Iterable from start up to but not including end.</p> <pre data-language="js">slice(begin?: number, end?: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.slice">Iterable#slice</a></code><h4>Discussion</h4>
<p>If begin is negative, it is offset from the end of the Iterable. e.g. <code>slice(-2)</code> returns a Iterable of the last two entries. If it is not provided the new Iterable will begin at the beginning of this Iterable.</p> <p>If end is negative, it is offset from the end of the Iterable. e.g. <code>slice(0, -1)</code> returns an Iterable of everything but the last entry. If it is not provided, the new Iterable will continue through the end of this Iterable.</p> <p>If the requested slice is equivalent to the current Iterable, then it will return itself.</p> <h3 id="iterable.keyed.rest">Iterable.Keyed#rest()</h3>
<p>Returns a new Iterable of the same type containing all entries except the first.</p> <pre data-language="js">rest(): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.rest">Iterable#rest</a></code><h3 id="iterable.keyed.butlast">Iterable.Keyed#butLast()</h3>
<p>Returns a new Iterable of the same type containing all entries except the last.</p> <pre data-language="js">butLast(): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.butlast">Iterable#butLast</a></code><h3 id="iterable.keyed.skip">Iterable.Keyed#skip()</h3>
<p>Returns a new Iterable of the same type which excludes the first <code>amount</code> entries from this Iterable.</p> <pre data-language="js">skip(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skip">Iterable#skip</a></code><h3 id="iterable.keyed.skiplast">Iterable.Keyed#skipLast()</h3>
<p>Returns a new Iterable of the same type which excludes the last <code>amount</code> entries from this Iterable.</p> <pre data-language="js">skipLast(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skiplast">Iterable#skipLast</a></code><h3 id="iterable.keyed.skipwhile">Iterable.Keyed#skipWhile()</h3>
<p>Returns a new Iterable of the same type which includes entries starting from when <code>predicate</code> first returns false.</p> <pre data-language="js">skipWhile(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skipwhile">Iterable#skipWhile</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .skipWhile(x =&gt; x.match(/g/))
// Seq [ 'cat', 'hat', 'god' ]</pre>
<h3 id="iterable.keyed.skipuntil">Iterable.Keyed#skipUntil()</h3>
<p>Returns a new Iterable of the same type which includes entries starting from when <code>predicate</code> first returns true.</p> <pre data-language="js">skipUntil(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skipuntil">Iterable#skipUntil</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .skipUntil(x =&gt; x.match(/hat/))
// Seq [ 'hat', 'god' ]</pre>
<h3 id="iterable.keyed.take">Iterable.Keyed#take()</h3>
<p>Returns a new Iterable of the same type which includes the first <code>amount</code> entries from this Iterable.</p> <pre data-language="js">take(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.take">Iterable#take</a></code><h3 id="iterable.keyed.takelast">Iterable.Keyed#takeLast()</h3>
<p>Returns a new Iterable of the same type which includes the last <code>amount</code> entries from this Iterable.</p> <pre data-language="js">takeLast(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takelast">Iterable#takeLast</a></code><h3 id="iterable.keyed.takewhile">Iterable.Keyed#takeWhile()</h3>
<p>Returns a new Iterable of the same type which includes entries from this Iterable as long as the <code>predicate</code> returns true.</p> <pre data-language="js">takeWhile(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takewhile">Iterable#takeWhile</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .takeWhile(x =&gt; x.match(/o/))
// Seq [ 'dog', 'frog' ]</pre>
<h3 id="iterable.keyed.takeuntil">Iterable.Keyed#takeUntil()</h3>
<p>Returns a new Iterable of the same type which includes entries from this Iterable as long as the <code>predicate</code> returns false.</p> <pre data-language="js">takeUntil(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takeuntil">Iterable#takeUntil</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god').takeUntil(x =&gt; x.match(/at/))
// ['dog', 'frog']</pre>
<h2>Combination</h2>
<h3 id="iterable.keyed.concat">Iterable.Keyed#concat()</h3>
<p>Returns a new Iterable of the same type with other values and iterable-like concatenated to this one.</p> <pre data-language="js">concat(...valuesOrIterables: any[]): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.concat">Iterable#concat</a></code><h4>Discussion</h4>
<p>For Seqs, all entries will be present in the resulting iterable, even if they have the same key.</p> <h3 id="iterable.keyed.flatten">Iterable.Keyed#flatten()</h3>
<p>Flattens nested Iterables.</p> <pre data-language="js">flatten(depth?: number): Iterable&lt;any, any&gt;
flatten(shallow?: boolean): Iterable&lt;any, any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.flatten">Iterable#flatten</a></code><h4>Discussion</h4>
<p>Will deeply flatten the Iterable by default, returning an Iterable of the same type, but a <code>depth</code> can be provided in the form of a number or boolean (where true means to shallowly flatten one level). A depth of 0 (or shallow: false) will deeply flatten.</p> <p>Flattens only others Iterable, not Arrays or Objects.</p> <p>Note: <code>flatten(true)</code> operates on Iterable<any iterable v="">&gt; and returns Iterable</any></p> <h3 id="iterable.keyed.flatmap">Iterable.Keyed#flatMap()</h3>
<p>Flat-maps the Iterable, returning an Iterable of the same type.</p> <pre data-language="js">flatMap&lt;MK, MV&gt;(mapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; Iterable&lt;MK, MV&gt;,context?: any): Iterable&lt;MK, MV&gt;
flatMap&lt;MK, MV&gt;(mapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; any,context?: any): Iterable&lt;MK, MV&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.flatmap">Iterable#flatMap</a></code><h4>Discussion</h4>
<p>Similar to <code>iter.map(...).flatten(true)</code>.</p> <h2>Reducing a value</h2>
<h3 id="iterable.keyed.reduce">Iterable.Keyed#reduce()</h3>
<p>Reduces the Iterable to a value by calling the <code>reducer</code> for every entry in the Iterable and passing along the reduced value.</p> <pre data-language="js">reduce&lt;R&gt;(reducer: (reduction?: R, value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; R,initialReduction?: R,context?: any): R
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reduce">Iterable#reduce</a></code><h4>see</h4>
<p><code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">Array#reduce</a></code>.</p> <h4>Discussion</h4>
<p>If <code>initialReduction</code> is not provided, or is null, the first item in the Iterable will be used.</p> <h3 id="iterable.keyed.reduceright">Iterable.Keyed#reduceRight()</h3>
<p>Reduces the Iterable in reverse (from the right side).</p> <pre data-language="js">reduceRight&lt;R&gt;(reducer: (reduction?: R, value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; R,initialReduction?: R,context?: any): R
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reduceright">Iterable#reduceRight</a></code><h4>Discussion</h4>
<p>Note: Similar to this.reverse().reduce(), and provided for parity with <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight">Array#reduceRight</a></code>.</p> <h3 id="iterable.keyed.every">Iterable.Keyed#every()</h3>
<p>True if <code>predicate</code> returns true for all entries in the Iterable.</p> <pre data-language="js">every(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.every">Iterable#every</a></code><h3 id="iterable.keyed.some">Iterable.Keyed#some()</h3>
<p>True if <code>predicate</code> returns true for any entry in the Iterable.</p> <pre data-language="js">some(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.some">Iterable#some</a></code><h3 id="iterable.keyed.join">Iterable.Keyed#join()</h3>
<p>Joins values together as a string, inserting a separator between each. The default separator is <code>","</code>.</p> <pre data-language="js">join(separator?: string): string
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.join">Iterable#join</a></code><h3 id="iterable.keyed.isempty">Iterable.Keyed#isEmpty()</h3>
<p>Returns true if this Iterable includes no values.</p> <pre data-language="js">isEmpty(): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.isempty">Iterable#isEmpty</a></code><h4>Discussion</h4>
<p>For some lazy <code><a href="#seq">Seq</a></code>, <code>isEmpty</code> might need to iterate to determine emptiness. At most one iteration will occur.</p> <h3 id="iterable.keyed.count">Iterable.Keyed#count()</h3>
<p>Returns the size of this Iterable.</p> <pre data-language="js">count(): number
count(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.count">Iterable#count</a></code><h4>Discussion</h4>
<p>Regardless of if this Iterable can describe its size lazily (some Seqs cannot), this method will always return the correct size. E.g. it evaluates a lazy <code><a href="#seq">Seq</a></code> if necessary.</p> <p>If <code>predicate</code> is provided, then this returns the count of entries in the Iterable for which the <code>predicate</code> returns true.</p> <h3 id="iterable.keyed.countby">Iterable.Keyed#countBy()</h3>
<p>Returns a <code><a href="#seq.keyed">Seq.Keyed</a></code> of counts, grouped by the return value of the <code>grouper</code> function.</p> <pre data-language="js">countBy&lt;G&gt;(grouper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; G,context?: any): Map&lt;G, number&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.countby">Iterable#countBy</a></code><h4>Discussion</h4>
<p>Note: This is not a lazy operation.</p> <h2>Search for value</h2>
<h3 id="iterable.keyed.find">Iterable.Keyed#find()</h3>
<p>Returns the first value for which the <code>predicate</code> returns true.</p> <pre data-language="js">find(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.find">Iterable#find</a></code><h3 id="iterable.keyed.findlast">Iterable.Keyed#findLast()</h3>
<p>Returns the last value for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLast(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlast">Iterable#findLast</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="iterable.keyed.findentry">Iterable.Keyed#findEntry()</h3>
<p>Returns the first [key, value] entry for which the <code>predicate</code> returns true.</p> <pre data-language="js">findEntry(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): Array&lt;any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findentry">Iterable#findEntry</a></code><h3 id="iterable.keyed.findlastentry">Iterable.Keyed#findLastEntry()</h3>
<p>Returns the last [key, value] entry for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLastEntry(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): Array&lt;any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlastentry">Iterable#findLastEntry</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="iterable.keyed.findkey">Iterable.Keyed#findKey()</h3>
<p>Returns the key for which the <code>predicate</code> returns true.</p> <pre data-language="js">findKey(predicate: (value?: V, key?: K, iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; boolean,context?: any): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findkey">Iterable#findKey</a></code><h3 id="iterable.keyed.findlastkey">Iterable.Keyed#findLastKey()</h3>
<p>Returns the last key for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLastKey(predicate: (value?: V, key?: K, iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; boolean,context?: any): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlastkey">Iterable#findLastKey</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="iterable.keyed.keyof">Iterable.Keyed#keyOf()</h3>
<p>Returns the key associated with the search value, or undefined.</p> <pre data-language="js">keyOf(searchValue: V): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyof">Iterable#keyOf</a></code><h3 id="iterable.keyed.lastkeyof">Iterable.Keyed#lastKeyOf()</h3>
<p>Returns the last key associated with the search value, or undefined.</p> <pre data-language="js">lastKeyOf(searchValue: V): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.lastkeyof">Iterable#lastKeyOf</a></code><h3 id="iterable.keyed.max">Iterable.Keyed#max()</h3>
<p>Returns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> <pre data-language="js">max(comparator?: (valueA: V, valueB: V) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.max">Iterable#max</a></code><h4>Discussion</h4>
<p>The <code>comparator</code> is used in the same way as <code><a href="#iterable.sort">Iterable#sort</a></code>. If it is not provided, the default comparator is <code>&gt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code>max</code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&gt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> <h3 id="iterable.keyed.maxby">Iterable.Keyed#maxBy()</h3>
<p>Like <code><a href="#iterable.max">max</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> <pre data-language="js">maxBy&lt;C&gt;(comparatorValueMapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.maxby">Iterable#maxBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.maxBy(hitter =&gt; hitter.avgHits);</pre>
<h3 id="iterable.keyed.min">Iterable.Keyed#min()</h3>
<p>Returns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> <pre data-language="js">min(comparator?: (valueA: V, valueB: V) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.min">Iterable#min</a></code><h4>Discussion</h4>
<p>The <code>comparator</code> is used in the same way as <code><a href="#iterable.sort">Iterable#sort</a></code>. If it is not provided, the default comparator is <code>&lt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code>min</code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&lt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> <h3 id="iterable.keyed.minby">Iterable.Keyed#minBy()</h3>
<p>Like <code><a href="#iterable.min">min</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> <pre data-language="js">minBy&lt;C&gt;(comparatorValueMapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.minby">Iterable#minBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.minBy(hitter =&gt; hitter.avgHits);</pre>
<h2>Comparison</h2>
<h3 id="iterable.keyed.issubset">Iterable.Keyed#isSubset()</h3>
<p>True if <code>iter</code> includes every value in this Iterable.</p> <pre data-language="js">isSubset(iter: Iterable&lt;any, V&gt;): boolean
isSubset(iter: Array&lt;V&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.issubset">Iterable#isSubset</a></code><h3 id="iterable.keyed.issuperset">Iterable.Keyed#isSuperset()</h3>
<p>True if this Iterable includes every value in <code>iter</code>.</p> <pre data-language="js">isSuperset(iter: Iterable&lt;any, V&gt;): boolean
isSuperset(iter: Array&lt;V&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.issuperset">Iterable#isSuperset</a></code><h1 id="collection">Collection</h1>
<p>Collection is the abstract base class for concrete data structures. It cannot be constructed directly.</p> <pre data-language="js">class Collection&lt;K, V&gt; extends Iterable&lt;K, V&gt;</pre>
<h4>Discussion</h4>
<p>Implementations should extend one of the subclasses, <code><a href="#collection.keyed">Collection.Keyed</a></code>, <code><a href="#collection.indexed">Collection.Indexed</a></code>, or <code><a href="#collection.set">Collection.Set</a></code>.</p> <h2>Types</h2>
<a href="#collection.keyed">Collection.Keyed</a><h2>Members</h2>
<h3 id="collection.size">Collection#size</h3>
<pre data-language="js">size: number</pre>
<h2>Value equality</h2>
<h3 id="collection.equals">Collection#equals()</h3>
<p>True if this and the other Iterable have value equality, as defined by <code><a href="#is">Immutable.is()</a></code>.</p> <pre data-language="js">equals(other: Iterable&lt;K, V&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.equals">Iterable#equals</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Immutable.is(this, other)</code>, but provided to allow for chained expressions.</p> <h3 id="collection.hashcode">Collection#hashCode()</h3>
<p>Computes and returns the hashed identity for this Iterable.</p> <pre data-language="js">hashCode(): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.hashcode">Iterable#hashCode</a></code><h4>Discussion</h4>
<p>The <code>hashCode</code> of an Iterable is used to determine potential equality, and is used when adding this to a <code><a href="#iterable.set">Set</a></code> or as a key in a <code><a href="#map">Map</a></code>, enabling lookup via a different instance.</p> <pre data-language="js">var a = List.of(1, 2, 3);
var b = List.of(1, 2, 3);
assert(a !== b); // different instances
var set = Set.of(a);
assert(set.has(b) === true);</pre>
<p>If two values have the same <code>hashCode</code>, they are <a href="http://en.wikipedia.org/wiki/Collision_(computer_science)">not guaranteed to be equal</a>. If two values have different <code>hashCode</code>s, they must not be equal.</p> <h2>Reading values</h2>
<h3 id="collection.get">Collection#get()</h3>
<p>Returns the value associated with the provided key, or notSetValue if the Iterable does not contain this key.</p> <pre data-language="js">get(key: K, notSetValue?: V): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.get">Iterable#get</a></code><h4>Discussion</h4>
<p>Note: it is possible a key may be associated with an <code>undefined</code> value, so if <code>notSetValue</code> is not provided and this method returns <code>undefined</code>, that does not guarantee the key was not found.</p> <h3 id="collection.has">Collection#has()</h3>
<p>True if a key exists within this <code>Iterable</code>, using <code><a href="#is">Immutable.is</a></code> to determine equality</p> <pre data-language="js">has(key: K): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.has">Iterable#has</a></code><h3 id="collection.includes">Collection#includes()</h3>
<p>True if a value exists within this <code>Iterable</code>, using <code><a href="#is">Immutable.is</a></code> to determine equality</p> <pre data-language="js">includes(value: V): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.includes">Iterable#includes</a></code><h4>alias</h4>
<code>contains()</code><h3 id="collection.first">Collection#first()</h3>
<p>The first value in the Iterable.</p> <pre data-language="js">first(): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.first">Iterable#first</a></code><h3 id="collection.last">Collection#last()</h3>
<p>The last value in the Iterable.</p> <pre data-language="js">last(): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.last">Iterable#last</a></code><h2>Reading deep values</h2>
<h3 id="collection.getin">Collection#getIn()</h3>
<p>Returns the value found by following a path of keys or indices through nested Iterables.</p> <pre data-language="js">getIn(searchKeyPath: Array&lt;any&gt;, notSetValue?: any): any
getIn(searchKeyPath: Iterable&lt;any, any&gt;, notSetValue?: any): any
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.getin">Iterable#getIn</a></code><h3 id="collection.hasin">Collection#hasIn()</h3>
<p>True if the result of following a path of keys or indices through nested Iterables results in a set value.</p> <pre data-language="js">hasIn(searchKeyPath: Array&lt;any&gt;): boolean
hasIn(searchKeyPath: Iterable&lt;any, any&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.hasin">Iterable#hasIn</a></code><h2>Conversion to JavaScript types</h2>
<h3 id="collection.tojs">Collection#toJS()</h3>
<p>Deeply converts this Iterable to equivalent JS.</p> <pre data-language="js">toJS(): any
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tojs">Iterable#toJS</a></code><h4>alias</h4>
<code>toJSON()</code><h4>Discussion</h4>
<p><code>Iterable.Indexeds</code>, and <code>Iterable.Sets</code> become Arrays, while <code>Iterable.Keyeds</code> become Objects.</p> <h3 id="collection.toarray">Collection#toArray()</h3>
<p>Shallowly converts this iterable to an Array, discarding keys.</p> <pre data-language="js">toArray(): Array&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toarray">Iterable#toArray</a></code><h3 id="collection.toobject">Collection#toObject()</h3>
<p>Shallowly converts this Iterable to an Object.</p> <pre data-language="js">toObject(): {[key: string]: V}
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toobject">Iterable#toObject</a></code><h4>Discussion</h4>
<p>Throws if keys are not strings.</p> <h2>Conversion to Collections</h2>
<h3 id="collection.tomap">Collection#toMap()</h3>
<p>Converts this Iterable to a Map, Throws if keys are not hashable.</p> <pre data-language="js">toMap(): Map&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tomap">Iterable#toMap</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Map(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="collection.toorderedmap">Collection#toOrderedMap()</h3>
<p>Converts this Iterable to a Map, maintaining the order of iteration.</p> <pre data-language="js">toOrderedMap(): OrderedMap&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toorderedmap">Iterable#toOrderedMap</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>OrderedMap(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="collection.toset">Collection#toSet()</h3>
<p>Converts this Iterable to a Set, discarding keys. Throws if values are not hashable.</p> <pre data-language="js">toSet(): Set&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toset">Iterable#toSet</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Set(this)</code>, but provided to allow for chained expressions.</p> <h3 id="collection.toorderedset">Collection#toOrderedSet()</h3>
<p>Converts this Iterable to a Set, maintaining the order of iteration and discarding keys.</p> <pre data-language="js">toOrderedSet(): OrderedSet&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toorderedset">Iterable#toOrderedSet</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>OrderedSet(this.valueSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="collection.tolist">Collection#toList()</h3>
<p>Converts this Iterable to a List, discarding keys.</p> <pre data-language="js">toList(): List&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tolist">Iterable#toList</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>List(this)</code>, but provided to allow for chained expressions.</p> <h3 id="collection.tostack">Collection#toStack()</h3>
<p>Converts this Iterable to a Stack, discarding keys. Throws if values are not hashable.</p> <pre data-language="js">toStack(): Stack&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tostack">Iterable#toStack</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Stack(this)</code>, but provided to allow for chained expressions.</p> <h2>Conversion to Seq</h2>
<h3 id="collection.toseq">Collection#toSeq()</h3>
<p>Converts this Iterable to a Seq of the same kind (indexed, keyed, or set).</p> <pre data-language="js">toSeq(): Seq&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toseq">Iterable#toSeq</a></code><h3 id="collection.tokeyedseq">Collection#toKeyedSeq()</h3>
<p>Returns a Seq.Keyed from this Iterable where indices are treated as keys.</p> <pre data-language="js">toKeyedSeq(): Seq.Keyed&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tokeyedseq">Iterable#toKeyedSeq</a></code><h4>Discussion</h4>
<p>This is useful if you want to operate on an Iterable.Indexed and preserve the [index, value] pairs.</p> <p>The returned Seq will have identical iteration order as this Iterable.</p> <p>Example:</p> <pre data-language="js">var indexedSeq = Immutable.Seq.of('A', 'B', 'C');
indexedSeq.filter(v =&gt; v === 'B').toString() // Seq [ 'B' ]
var keyedSeq = indexedSeq.toKeyedSeq();
keyedSeq.filter(v =&gt; v === 'B').toString() // Seq { 1: 'B' }</pre>
<h3 id="collection.toindexedseq">Collection#toIndexedSeq()</h3>
<p>Returns an Seq.Indexed of the values of this Iterable, discarding keys.</p> <pre data-language="js">toIndexedSeq(): Seq.Indexed&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toindexedseq">Iterable#toIndexedSeq</a></code><h3 id="collection.tosetseq">Collection#toSetSeq()</h3>
<p>Returns a Seq.Set of the values of this Iterable, discarding keys.</p> <pre data-language="js">toSetSeq(): Seq.Set&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tosetseq">Iterable#toSetSeq</a></code><h2>Iterators</h2>
<h3 id="collection.keys">Collection#keys()</h3>
<p>An iterator of this <code>Iterable</code>'s keys.</p> <pre data-language="js">keys(): Iterator&lt;K&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keys">Iterable#keys</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.keyseq">keySeq</a></code> instead, if this is what you want.</p> <h3 id="collection.values">Collection#values()</h3>
<p>An iterator of this <code>Iterable</code>'s values.</p> <pre data-language="js">values(): Iterator&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.values">Iterable#values</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.valueseq">valueSeq</a></code> instead, if this is what you want.</p> <h3 id="collection.entries">Collection#entries()</h3>
<p>An iterator of this <code>Iterable</code>'s entries as <code>[key, value]</code> tuples.</p> <pre data-language="js">entries(): Iterator&lt;Array&lt;any&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.entries">Iterable#entries</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.entryseq">entrySeq</a></code> instead, if this is what you want.</p> <h2>Iterables (Seq)</h2>
<h3 id="collection.keyseq">Collection#keySeq()</h3>
<p>Returns a new Seq.Indexed of the keys of this Iterable, discarding values.</p> <pre data-language="js">keySeq(): Seq.Indexed&lt;K&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyseq">Iterable#keySeq</a></code><h3 id="collection.valueseq">Collection#valueSeq()</h3>
<p>Returns an Seq.Indexed of the values of this Iterable, discarding keys.</p> <pre data-language="js">valueSeq(): Seq.Indexed&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.valueseq">Iterable#valueSeq</a></code><h3 id="collection.entryseq">Collection#entrySeq()</h3>
<p>Returns a new Seq.Indexed of [key, value] tuples.</p> <pre data-language="js">entrySeq(): Seq.Indexed&lt;Array&lt;any&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.entryseq">Iterable#entrySeq</a></code><h2>Sequence algorithms</h2>
<h3 id="collection.map">Collection#map()</h3>
<p>Returns a new Iterable of the same type with values passed through a <code>mapper</code> function.</p> <pre data-language="js">map&lt;M&gt;(mapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; M,context?: any): Iterable&lt;K, M&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.map">Iterable#map</a></code><h4>Example</h4>
<pre data-language="js">Seq({ a: 1, b: 2 }).map(x =&gt; 10 * x)
// Seq { a: 10, b: 20 }</pre>
<h3 id="collection.filter">Collection#filter()</h3>
<p>Returns a new Iterable of the same type with only the entries for which the <code>predicate</code> function returns true.</p> <pre data-language="js">filter(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.filter">Iterable#filter</a></code><h4>Example</h4>
<pre data-language="js">Seq({a:1,b:2,c:3,d:4}).filter(x =&gt; x % 2 === 0)
// Seq { b: 2, d: 4 }</pre>
<h3 id="collection.filternot">Collection#filterNot()</h3>
<p>Returns a new Iterable of the same type with only the entries for which the <code>predicate</code> function returns false.</p> <pre data-language="js">filterNot(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.filternot">Iterable#filterNot</a></code><h4>Example</h4>
<pre data-language="js">Seq({a:1,b:2,c:3,d:4}).filterNot(x =&gt; x % 2 === 0)
// Seq { a: 1, c: 3 }</pre>
<h3 id="collection.reverse">Collection#reverse()</h3>
<p>Returns a new Iterable of the same type in reverse order.</p> <pre data-language="js">reverse(): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reverse">Iterable#reverse</a></code><h3 id="collection.sort">Collection#sort()</h3>
<p>Returns a new Iterable of the same type which includes the same entries, stably sorted by using a <code>comparator</code>.</p> <pre data-language="js">sort(comparator?: (valueA: V, valueB: V) =&gt; number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.sort">Iterable#sort</a></code><h4>Discussion</h4>
<p>If a <code>comparator</code> is not provided, a default comparator uses <code>&lt;</code> and <code>&gt;</code>.</p> <p><code>comparator(valueA, valueB)</code>:</p> <ul> <li>Returns <code>0</code> if the elements should not be swapped.</li> <li>Returns <code>-1</code> (or any negative number) if <code>valueA</code> comes before <code>valueB</code>
</li> <li>Returns <code>1</code> (or any positive number) if <code>valueA</code> comes after <code>valueB</code>
</li> <li>Is pure, i.e. it must always return the same value for the same pair of values.</li> </ul> <p>When sorting collections which have no defined order, their ordered equivalents will be returned. e.g. <code>map.sort()</code> returns OrderedMap.</p> <h3 id="collection.sortby">Collection#sortBy()</h3>
<p>Like <code><a href="#iterable.sort">sort</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for sorting by more sophisticated means:</p> <pre data-language="js">sortBy&lt;C&gt;(comparatorValueMapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.sortby">Iterable#sortBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.sortBy(hitter =&gt; hitter.avgHits);</pre>
<h3 id="collection.groupby">Collection#groupBy()</h3>
<p>Returns a <code><a href="#iterable.keyed">Iterable.Keyed</a></code> of <code>Iterable.Keyeds</code>, grouped by the return value of the <code>grouper</code> function.</p> <pre data-language="js">groupBy&lt;G&gt;(grouper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; G,context?: any): Seq.Keyed&lt;G, Iterable&lt;K, V&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.groupby">Iterable#groupBy</a></code><h4>Discussion</h4>
<p>Note: This is always an eager operation.</p> <h2>Side effects</h2>
<h3 id="collection.foreach">Collection#forEach()</h3>
<p>The <code>sideEffect</code> is executed for every entry in the Iterable.</p> <pre data-language="js">forEach(sideEffect: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; any,context?: any): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.foreach">Iterable#forEach</a></code><h4>Discussion</h4>
<p>Unlike <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">Array#forEach</a></code>, if any call of <code>sideEffect</code> returns <code>false</code>, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).</p> <h2>Creating subsets</h2>
<h3 id="collection.slice">Collection#slice()</h3>
<p>Returns a new Iterable of the same type representing a portion of this Iterable from start up to but not including end.</p> <pre data-language="js">slice(begin?: number, end?: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.slice">Iterable#slice</a></code><h4>Discussion</h4>
<p>If begin is negative, it is offset from the end of the Iterable. e.g. <code>slice(-2)</code> returns a Iterable of the last two entries. If it is not provided the new Iterable will begin at the beginning of this Iterable.</p> <p>If end is negative, it is offset from the end of the Iterable. e.g. <code>slice(0, -1)</code> returns an Iterable of everything but the last entry. If it is not provided, the new Iterable will continue through the end of this Iterable.</p> <p>If the requested slice is equivalent to the current Iterable, then it will return itself.</p> <h3 id="collection.rest">Collection#rest()</h3>
<p>Returns a new Iterable of the same type containing all entries except the first.</p> <pre data-language="js">rest(): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.rest">Iterable#rest</a></code><h3 id="collection.butlast">Collection#butLast()</h3>
<p>Returns a new Iterable of the same type containing all entries except the last.</p> <pre data-language="js">butLast(): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.butlast">Iterable#butLast</a></code><h3 id="collection.skip">Collection#skip()</h3>
<p>Returns a new Iterable of the same type which excludes the first <code>amount</code> entries from this Iterable.</p> <pre data-language="js">skip(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skip">Iterable#skip</a></code><h3 id="collection.skiplast">Collection#skipLast()</h3>
<p>Returns a new Iterable of the same type which excludes the last <code>amount</code> entries from this Iterable.</p> <pre data-language="js">skipLast(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skiplast">Iterable#skipLast</a></code><h3 id="collection.skipwhile">Collection#skipWhile()</h3>
<p>Returns a new Iterable of the same type which includes entries starting from when <code>predicate</code> first returns false.</p> <pre data-language="js">skipWhile(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skipwhile">Iterable#skipWhile</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .skipWhile(x =&gt; x.match(/g/))
// Seq [ 'cat', 'hat', 'god' ]</pre>
<h3 id="collection.skipuntil">Collection#skipUntil()</h3>
<p>Returns a new Iterable of the same type which includes entries starting from when <code>predicate</code> first returns true.</p> <pre data-language="js">skipUntil(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skipuntil">Iterable#skipUntil</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .skipUntil(x =&gt; x.match(/hat/))
// Seq [ 'hat', 'god' ]</pre>
<h3 id="collection.take">Collection#take()</h3>
<p>Returns a new Iterable of the same type which includes the first <code>amount</code> entries from this Iterable.</p> <pre data-language="js">take(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.take">Iterable#take</a></code><h3 id="collection.takelast">Collection#takeLast()</h3>
<p>Returns a new Iterable of the same type which includes the last <code>amount</code> entries from this Iterable.</p> <pre data-language="js">takeLast(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takelast">Iterable#takeLast</a></code><h3 id="collection.takewhile">Collection#takeWhile()</h3>
<p>Returns a new Iterable of the same type which includes entries from this Iterable as long as the <code>predicate</code> returns true.</p> <pre data-language="js">takeWhile(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takewhile">Iterable#takeWhile</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .takeWhile(x =&gt; x.match(/o/))
// Seq [ 'dog', 'frog' ]</pre>
<h3 id="collection.takeuntil">Collection#takeUntil()</h3>
<p>Returns a new Iterable of the same type which includes entries from this Iterable as long as the <code>predicate</code> returns false.</p> <pre data-language="js">takeUntil(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takeuntil">Iterable#takeUntil</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god').takeUntil(x =&gt; x.match(/at/))
// ['dog', 'frog']</pre>
<h2>Combination</h2>
<h3 id="collection.concat">Collection#concat()</h3>
<p>Returns a new Iterable of the same type with other values and iterable-like concatenated to this one.</p> <pre data-language="js">concat(...valuesOrIterables: any[]): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.concat">Iterable#concat</a></code><h4>Discussion</h4>
<p>For Seqs, all entries will be present in the resulting iterable, even if they have the same key.</p> <h3 id="collection.flatten">Collection#flatten()</h3>
<p>Flattens nested Iterables.</p> <pre data-language="js">flatten(depth?: number): Iterable&lt;any, any&gt;
flatten(shallow?: boolean): Iterable&lt;any, any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.flatten">Iterable#flatten</a></code><h4>Discussion</h4>
<p>Will deeply flatten the Iterable by default, returning an Iterable of the same type, but a <code>depth</code> can be provided in the form of a number or boolean (where true means to shallowly flatten one level). A depth of 0 (or shallow: false) will deeply flatten.</p> <p>Flattens only others Iterable, not Arrays or Objects.</p> <p>Note: <code>flatten(true)</code> operates on Iterable<any iterable v="">&gt; and returns Iterable</any></p> <h3 id="collection.flatmap">Collection#flatMap()</h3>
<p>Flat-maps the Iterable, returning an Iterable of the same type.</p> <pre data-language="js">flatMap&lt;MK, MV&gt;(mapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; Iterable&lt;MK, MV&gt;,context?: any): Iterable&lt;MK, MV&gt;
flatMap&lt;MK, MV&gt;(mapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; any,context?: any): Iterable&lt;MK, MV&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.flatmap">Iterable#flatMap</a></code><h4>Discussion</h4>
<p>Similar to <code>iter.map(...).flatten(true)</code>.</p> <h2>Reducing a value</h2>
<h3 id="collection.reduce">Collection#reduce()</h3>
<p>Reduces the Iterable to a value by calling the <code>reducer</code> for every entry in the Iterable and passing along the reduced value.</p> <pre data-language="js">reduce&lt;R&gt;(reducer: (reduction?: R, value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; R,initialReduction?: R,context?: any): R
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reduce">Iterable#reduce</a></code><h4>see</h4>
<p><code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">Array#reduce</a></code>.</p> <h4>Discussion</h4>
<p>If <code>initialReduction</code> is not provided, or is null, the first item in the Iterable will be used.</p> <h3 id="collection.reduceright">Collection#reduceRight()</h3>
<p>Reduces the Iterable in reverse (from the right side).</p> <pre data-language="js">reduceRight&lt;R&gt;(reducer: (reduction?: R, value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; R,initialReduction?: R,context?: any): R
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reduceright">Iterable#reduceRight</a></code><h4>Discussion</h4>
<p>Note: Similar to this.reverse().reduce(), and provided for parity with <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight">Array#reduceRight</a></code>.</p> <h3 id="collection.every">Collection#every()</h3>
<p>True if <code>predicate</code> returns true for all entries in the Iterable.</p> <pre data-language="js">every(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.every">Iterable#every</a></code><h3 id="collection.some">Collection#some()</h3>
<p>True if <code>predicate</code> returns true for any entry in the Iterable.</p> <pre data-language="js">some(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.some">Iterable#some</a></code><h3 id="collection.join">Collection#join()</h3>
<p>Joins values together as a string, inserting a separator between each. The default separator is <code>","</code>.</p> <pre data-language="js">join(separator?: string): string
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.join">Iterable#join</a></code><h3 id="collection.isempty">Collection#isEmpty()</h3>
<p>Returns true if this Iterable includes no values.</p> <pre data-language="js">isEmpty(): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.isempty">Iterable#isEmpty</a></code><h4>Discussion</h4>
<p>For some lazy <code><a href="#seq">Seq</a></code>, <code>isEmpty</code> might need to iterate to determine emptiness. At most one iteration will occur.</p> <h3 id="collection.count">Collection#count()</h3>
<p>Returns the size of this Iterable.</p> <pre data-language="js">count(): number
count(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.count">Iterable#count</a></code><h4>Discussion</h4>
<p>Regardless of if this Iterable can describe its size lazily (some Seqs cannot), this method will always return the correct size. E.g. it evaluates a lazy <code><a href="#seq">Seq</a></code> if necessary.</p> <p>If <code>predicate</code> is provided, then this returns the count of entries in the Iterable for which the <code>predicate</code> returns true.</p> <h3 id="collection.countby">Collection#countBy()</h3>
<p>Returns a <code><a href="#seq.keyed">Seq.Keyed</a></code> of counts, grouped by the return value of the <code>grouper</code> function.</p> <pre data-language="js">countBy&lt;G&gt;(grouper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; G,context?: any): Map&lt;G, number&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.countby">Iterable#countBy</a></code><h4>Discussion</h4>
<p>Note: This is not a lazy operation.</p> <h2>Search for value</h2>
<h3 id="collection.find">Collection#find()</h3>
<p>Returns the first value for which the <code>predicate</code> returns true.</p> <pre data-language="js">find(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.find">Iterable#find</a></code><h3 id="collection.findlast">Collection#findLast()</h3>
<p>Returns the last value for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLast(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlast">Iterable#findLast</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="collection.findentry">Collection#findEntry()</h3>
<p>Returns the first [key, value] entry for which the <code>predicate</code> returns true.</p> <pre data-language="js">findEntry(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): Array&lt;any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findentry">Iterable#findEntry</a></code><h3 id="collection.findlastentry">Collection#findLastEntry()</h3>
<p>Returns the last [key, value] entry for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLastEntry(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): Array&lt;any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlastentry">Iterable#findLastEntry</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="collection.findkey">Collection#findKey()</h3>
<p>Returns the key for which the <code>predicate</code> returns true.</p> <pre data-language="js">findKey(predicate: (value?: V, key?: K, iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; boolean,context?: any): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findkey">Iterable#findKey</a></code><h3 id="collection.findlastkey">Collection#findLastKey()</h3>
<p>Returns the last key for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLastKey(predicate: (value?: V, key?: K, iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; boolean,context?: any): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlastkey">Iterable#findLastKey</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="collection.keyof">Collection#keyOf()</h3>
<p>Returns the key associated with the search value, or undefined.</p> <pre data-language="js">keyOf(searchValue: V): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyof">Iterable#keyOf</a></code><h3 id="collection.lastkeyof">Collection#lastKeyOf()</h3>
<p>Returns the last key associated with the search value, or undefined.</p> <pre data-language="js">lastKeyOf(searchValue: V): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.lastkeyof">Iterable#lastKeyOf</a></code><h3 id="collection.max">Collection#max()</h3>
<p>Returns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> <pre data-language="js">max(comparator?: (valueA: V, valueB: V) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.max">Iterable#max</a></code><h4>Discussion</h4>
<p>The <code>comparator</code> is used in the same way as <code><a href="#iterable.sort">Iterable#sort</a></code>. If it is not provided, the default comparator is <code>&gt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code>max</code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&gt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> <h3 id="collection.maxby">Collection#maxBy()</h3>
<p>Like <code><a href="#iterable.max">max</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> <pre data-language="js">maxBy&lt;C&gt;(comparatorValueMapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.maxby">Iterable#maxBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.maxBy(hitter =&gt; hitter.avgHits);</pre>
<h3 id="collection.min">Collection#min()</h3>
<p>Returns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> <pre data-language="js">min(comparator?: (valueA: V, valueB: V) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.min">Iterable#min</a></code><h4>Discussion</h4>
<p>The <code>comparator</code> is used in the same way as <code><a href="#iterable.sort">Iterable#sort</a></code>. If it is not provided, the default comparator is <code>&lt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code>min</code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&lt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> <h3 id="collection.minby">Collection#minBy()</h3>
<p>Like <code><a href="#iterable.min">min</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> <pre data-language="js">minBy&lt;C&gt;(comparatorValueMapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.minby">Iterable#minBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.minBy(hitter =&gt; hitter.avgHits);</pre>
<h2>Comparison</h2>
<h3 id="collection.issubset">Collection#isSubset()</h3>
<p>True if <code>iter</code> includes every value in this Iterable.</p> <pre data-language="js">isSubset(iter: Iterable&lt;any, V&gt;): boolean
isSubset(iter: Array&lt;V&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.issubset">Iterable#isSubset</a></code><h3 id="collection.issuperset">Collection#isSuperset()</h3>
<p>True if this Iterable includes every value in <code>iter</code>.</p> <pre data-language="js">isSuperset(iter: Iterable&lt;any, V&gt;): boolean
isSuperset(iter: Array&lt;V&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.issuperset">Iterable#isSuperset</a></code><h1 id="collection.keyed">Collection.Keyed</h1>
<p><code>Collection</code> which represents key-value pairs.</p> <pre data-language="js">class Collection.Keyed&lt;K, V&gt; extends Collection&lt;K, V&gt;, Iterable.Keyed&lt;K, V&gt;</pre>
<h2>Members</h2>
<h3 id="collection.keyed.size">Collection.Keyed#size</h3>
<pre data-language="js">size: number</pre>
<h4>Inherited from</h4>
<code><a href="#collection.size">Collection#size</a></code><h2>Conversion to Seq</h2>
<h3 id="collection.keyed.toseq">Collection.Keyed#toSeq()</h3>
<p>Returns Seq.Keyed.</p> <pre data-language="js">toSeq(): Seq.Keyed&lt;K, V&gt;
</pre>
<h4>Overrides</h4>
<code><a href="#iterable.toseq">Iterable#toSeq</a></code><h3 id="collection.keyed.tokeyedseq">Collection.Keyed#toKeyedSeq()</h3>
<p>Returns a Seq.Keyed from this Iterable where indices are treated as keys.</p> <pre data-language="js">toKeyedSeq(): Seq.Keyed&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tokeyedseq">Iterable#toKeyedSeq</a></code><h4>Discussion</h4>
<p>This is useful if you want to operate on an Iterable.Indexed and preserve the [index, value] pairs.</p> <p>The returned Seq will have identical iteration order as this Iterable.</p> <p>Example:</p> <pre data-language="js">var indexedSeq = Immutable.Seq.of('A', 'B', 'C');
indexedSeq.filter(v =&gt; v === 'B').toString() // Seq [ 'B' ]
var keyedSeq = indexedSeq.toKeyedSeq();
keyedSeq.filter(v =&gt; v === 'B').toString() // Seq { 1: 'B' }</pre>
<h3 id="collection.keyed.toindexedseq">Collection.Keyed#toIndexedSeq()</h3>
<p>Returns an Seq.Indexed of the values of this Iterable, discarding keys.</p> <pre data-language="js">toIndexedSeq(): Seq.Indexed&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toindexedseq">Iterable#toIndexedSeq</a></code><h3 id="collection.keyed.tosetseq">Collection.Keyed#toSetSeq()</h3>
<p>Returns a Seq.Set of the values of this Iterable, discarding keys.</p> <pre data-language="js">toSetSeq(): Seq.Set&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tosetseq">Iterable#toSetSeq</a></code><h2>Value equality</h2>
<h3 id="collection.keyed.equals">Collection.Keyed#equals()</h3>
<p>True if this and the other Iterable have value equality, as defined by <code><a href="#is">Immutable.is()</a></code>.</p> <pre data-language="js">equals(other: Iterable&lt;K, V&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.equals">Iterable#equals</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Immutable.is(this, other)</code>, but provided to allow for chained expressions.</p> <h3 id="collection.keyed.hashcode">Collection.Keyed#hashCode()</h3>
<p>Computes and returns the hashed identity for this Iterable.</p> <pre data-language="js">hashCode(): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.hashcode">Iterable#hashCode</a></code><h4>Discussion</h4>
<p>The <code>hashCode</code> of an Iterable is used to determine potential equality, and is used when adding this to a <code><a href="#iterable.set">Set</a></code> or as a key in a <code><a href="#map">Map</a></code>, enabling lookup via a different instance.</p> <pre data-language="js">var a = List.of(1, 2, 3);
var b = List.of(1, 2, 3);
assert(a !== b); // different instances
var set = Set.of(a);
assert(set.has(b) === true);</pre>
<p>If two values have the same <code>hashCode</code>, they are <a href="http://en.wikipedia.org/wiki/Collision_(computer_science)">not guaranteed to be equal</a>. If two values have different <code>hashCode</code>s, they must not be equal.</p> <h2>Reading values</h2>
<h3 id="collection.keyed.get">Collection.Keyed#get()</h3>
<p>Returns the value associated with the provided key, or notSetValue if the Iterable does not contain this key.</p> <pre data-language="js">get(key: K, notSetValue?: V): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.get">Iterable#get</a></code><h4>Discussion</h4>
<p>Note: it is possible a key may be associated with an <code>undefined</code> value, so if <code>notSetValue</code> is not provided and this method returns <code>undefined</code>, that does not guarantee the key was not found.</p> <h3 id="collection.keyed.has">Collection.Keyed#has()</h3>
<p>True if a key exists within this <code>Iterable</code>, using <code><a href="#is">Immutable.is</a></code> to determine equality</p> <pre data-language="js">has(key: K): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.has">Iterable#has</a></code><h3 id="collection.keyed.includes">Collection.Keyed#includes()</h3>
<p>True if a value exists within this <code>Iterable</code>, using <code><a href="#is">Immutable.is</a></code> to determine equality</p> <pre data-language="js">includes(value: V): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.includes">Iterable#includes</a></code><h4>alias</h4>
<code>contains()</code><h3 id="collection.keyed.first">Collection.Keyed#first()</h3>
<p>The first value in the Iterable.</p> <pre data-language="js">first(): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.first">Iterable#first</a></code><h3 id="collection.keyed.last">Collection.Keyed#last()</h3>
<p>The last value in the Iterable.</p> <pre data-language="js">last(): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.last">Iterable#last</a></code><h2>Reading deep values</h2>
<h3 id="collection.keyed.getin">Collection.Keyed#getIn()</h3>
<p>Returns the value found by following a path of keys or indices through nested Iterables.</p> <pre data-language="js">getIn(searchKeyPath: Array&lt;any&gt;, notSetValue?: any): any
getIn(searchKeyPath: Iterable&lt;any, any&gt;, notSetValue?: any): any
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.getin">Iterable#getIn</a></code><h3 id="collection.keyed.hasin">Collection.Keyed#hasIn()</h3>
<p>True if the result of following a path of keys or indices through nested Iterables results in a set value.</p> <pre data-language="js">hasIn(searchKeyPath: Array&lt;any&gt;): boolean
hasIn(searchKeyPath: Iterable&lt;any, any&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.hasin">Iterable#hasIn</a></code><h2>Conversion to JavaScript types</h2>
<h3 id="collection.keyed.tojs">Collection.Keyed#toJS()</h3>
<p>Deeply converts this Iterable to equivalent JS.</p> <pre data-language="js">toJS(): any
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tojs">Iterable#toJS</a></code><h4>alias</h4>
<code>toJSON()</code><h4>Discussion</h4>
<p><code>Iterable.Indexeds</code>, and <code>Iterable.Sets</code> become Arrays, while <code>Iterable.Keyeds</code> become Objects.</p> <h3 id="collection.keyed.toarray">Collection.Keyed#toArray()</h3>
<p>Shallowly converts this iterable to an Array, discarding keys.</p> <pre data-language="js">toArray(): Array&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toarray">Iterable#toArray</a></code><h3 id="collection.keyed.toobject">Collection.Keyed#toObject()</h3>
<p>Shallowly converts this Iterable to an Object.</p> <pre data-language="js">toObject(): {[key: string]: V}
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toobject">Iterable#toObject</a></code><h4>Discussion</h4>
<p>Throws if keys are not strings.</p> <h2>Conversion to Collections</h2>
<h3 id="collection.keyed.tomap">Collection.Keyed#toMap()</h3>
<p>Converts this Iterable to a Map, Throws if keys are not hashable.</p> <pre data-language="js">toMap(): Map&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tomap">Iterable#toMap</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Map(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="collection.keyed.toorderedmap">Collection.Keyed#toOrderedMap()</h3>
<p>Converts this Iterable to a Map, maintaining the order of iteration.</p> <pre data-language="js">toOrderedMap(): OrderedMap&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toorderedmap">Iterable#toOrderedMap</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>OrderedMap(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="collection.keyed.toset">Collection.Keyed#toSet()</h3>
<p>Converts this Iterable to a Set, discarding keys. Throws if values are not hashable.</p> <pre data-language="js">toSet(): Set&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toset">Iterable#toSet</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Set(this)</code>, but provided to allow for chained expressions.</p> <h3 id="collection.keyed.toorderedset">Collection.Keyed#toOrderedSet()</h3>
<p>Converts this Iterable to a Set, maintaining the order of iteration and discarding keys.</p> <pre data-language="js">toOrderedSet(): OrderedSet&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toorderedset">Iterable#toOrderedSet</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>OrderedSet(this.valueSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="collection.keyed.tolist">Collection.Keyed#toList()</h3>
<p>Converts this Iterable to a List, discarding keys.</p> <pre data-language="js">toList(): List&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tolist">Iterable#toList</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>List(this)</code>, but provided to allow for chained expressions.</p> <h3 id="collection.keyed.tostack">Collection.Keyed#toStack()</h3>
<p>Converts this Iterable to a Stack, discarding keys. Throws if values are not hashable.</p> <pre data-language="js">toStack(): Stack&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tostack">Iterable#toStack</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Stack(this)</code>, but provided to allow for chained expressions.</p> <h2>Iterators</h2>
<h3 id="collection.keyed.keys">Collection.Keyed#keys()</h3>
<p>An iterator of this <code>Iterable</code>'s keys.</p> <pre data-language="js">keys(): Iterator&lt;K&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keys">Iterable#keys</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.keyseq">keySeq</a></code> instead, if this is what you want.</p> <h3 id="collection.keyed.values">Collection.Keyed#values()</h3>
<p>An iterator of this <code>Iterable</code>'s values.</p> <pre data-language="js">values(): Iterator&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.values">Iterable#values</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.valueseq">valueSeq</a></code> instead, if this is what you want.</p> <h3 id="collection.keyed.entries">Collection.Keyed#entries()</h3>
<p>An iterator of this <code>Iterable</code>'s entries as <code>[key, value]</code> tuples.</p> <pre data-language="js">entries(): Iterator&lt;Array&lt;any&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.entries">Iterable#entries</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.entryseq">entrySeq</a></code> instead, if this is what you want.</p> <h2>Iterables (Seq)</h2>
<h3 id="collection.keyed.keyseq">Collection.Keyed#keySeq()</h3>
<p>Returns a new Seq.Indexed of the keys of this Iterable, discarding values.</p> <pre data-language="js">keySeq(): Seq.Indexed&lt;K&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyseq">Iterable#keySeq</a></code><h3 id="collection.keyed.valueseq">Collection.Keyed#valueSeq()</h3>
<p>Returns an Seq.Indexed of the values of this Iterable, discarding keys.</p> <pre data-language="js">valueSeq(): Seq.Indexed&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.valueseq">Iterable#valueSeq</a></code><h3 id="collection.keyed.entryseq">Collection.Keyed#entrySeq()</h3>
<p>Returns a new Seq.Indexed of [key, value] tuples.</p> <pre data-language="js">entrySeq(): Seq.Indexed&lt;Array&lt;any&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.entryseq">Iterable#entrySeq</a></code><h2>Sequence algorithms</h2>
<h3 id="collection.keyed.map">Collection.Keyed#map()</h3>
<p>Returns a new Iterable of the same type with values passed through a <code>mapper</code> function.</p> <pre data-language="js">map&lt;M&gt;(mapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; M,context?: any): Iterable&lt;K, M&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.map">Iterable#map</a></code><h4>Example</h4>
<pre data-language="js">Seq({ a: 1, b: 2 }).map(x =&gt; 10 * x)
// Seq { a: 10, b: 20 }</pre>
<h3 id="collection.keyed.filter">Collection.Keyed#filter()</h3>
<p>Returns a new Iterable of the same type with only the entries for which the <code>predicate</code> function returns true.</p> <pre data-language="js">filter(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.filter">Iterable#filter</a></code><h4>Example</h4>
<pre data-language="js">Seq({a:1,b:2,c:3,d:4}).filter(x =&gt; x % 2 === 0)
// Seq { b: 2, d: 4 }</pre>
<h3 id="collection.keyed.filternot">Collection.Keyed#filterNot()</h3>
<p>Returns a new Iterable of the same type with only the entries for which the <code>predicate</code> function returns false.</p> <pre data-language="js">filterNot(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.filternot">Iterable#filterNot</a></code><h4>Example</h4>
<pre data-language="js">Seq({a:1,b:2,c:3,d:4}).filterNot(x =&gt; x % 2 === 0)
// Seq { a: 1, c: 3 }</pre>
<h3 id="collection.keyed.reverse">Collection.Keyed#reverse()</h3>
<p>Returns a new Iterable of the same type in reverse order.</p> <pre data-language="js">reverse(): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reverse">Iterable#reverse</a></code><h3 id="collection.keyed.sort">Collection.Keyed#sort()</h3>
<p>Returns a new Iterable of the same type which includes the same entries, stably sorted by using a <code>comparator</code>.</p> <pre data-language="js">sort(comparator?: (valueA: V, valueB: V) =&gt; number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.sort">Iterable#sort</a></code><h4>Discussion</h4>
<p>If a <code>comparator</code> is not provided, a default comparator uses <code>&lt;</code> and <code>&gt;</code>.</p> <p><code>comparator(valueA, valueB)</code>:</p> <ul> <li>Returns <code>0</code> if the elements should not be swapped.</li> <li>Returns <code>-1</code> (or any negative number) if <code>valueA</code> comes before <code>valueB</code>
</li> <li>Returns <code>1</code> (or any positive number) if <code>valueA</code> comes after <code>valueB</code>
</li> <li>Is pure, i.e. it must always return the same value for the same pair of values.</li> </ul> <p>When sorting collections which have no defined order, their ordered equivalents will be returned. e.g. <code>map.sort()</code> returns OrderedMap.</p> <h3 id="collection.keyed.sortby">Collection.Keyed#sortBy()</h3>
<p>Like <code><a href="#iterable.sort">sort</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for sorting by more sophisticated means:</p> <pre data-language="js">sortBy&lt;C&gt;(comparatorValueMapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.sortby">Iterable#sortBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.sortBy(hitter =&gt; hitter.avgHits);</pre>
<h3 id="collection.keyed.groupby">Collection.Keyed#groupBy()</h3>
<p>Returns a <code><a href="#iterable.keyed">Iterable.Keyed</a></code> of <code>Iterable.Keyeds</code>, grouped by the return value of the <code>grouper</code> function.</p> <pre data-language="js">groupBy&lt;G&gt;(grouper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; G,context?: any): Seq.Keyed&lt;G, Iterable&lt;K, V&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.groupby">Iterable#groupBy</a></code><h4>Discussion</h4>
<p>Note: This is always an eager operation.</p> <h2>Side effects</h2>
<h3 id="collection.keyed.foreach">Collection.Keyed#forEach()</h3>
<p>The <code>sideEffect</code> is executed for every entry in the Iterable.</p> <pre data-language="js">forEach(sideEffect: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; any,context?: any): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.foreach">Iterable#forEach</a></code><h4>Discussion</h4>
<p>Unlike <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">Array#forEach</a></code>, if any call of <code>sideEffect</code> returns <code>false</code>, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).</p> <h2>Creating subsets</h2>
<h3 id="collection.keyed.slice">Collection.Keyed#slice()</h3>
<p>Returns a new Iterable of the same type representing a portion of this Iterable from start up to but not including end.</p> <pre data-language="js">slice(begin?: number, end?: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.slice">Iterable#slice</a></code><h4>Discussion</h4>
<p>If begin is negative, it is offset from the end of the Iterable. e.g. <code>slice(-2)</code> returns a Iterable of the last two entries. If it is not provided the new Iterable will begin at the beginning of this Iterable.</p> <p>If end is negative, it is offset from the end of the Iterable. e.g. <code>slice(0, -1)</code> returns an Iterable of everything but the last entry. If it is not provided, the new Iterable will continue through the end of this Iterable.</p> <p>If the requested slice is equivalent to the current Iterable, then it will return itself.</p> <h3 id="collection.keyed.rest">Collection.Keyed#rest()</h3>
<p>Returns a new Iterable of the same type containing all entries except the first.</p> <pre data-language="js">rest(): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.rest">Iterable#rest</a></code><h3 id="collection.keyed.butlast">Collection.Keyed#butLast()</h3>
<p>Returns a new Iterable of the same type containing all entries except the last.</p> <pre data-language="js">butLast(): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.butlast">Iterable#butLast</a></code><h3 id="collection.keyed.skip">Collection.Keyed#skip()</h3>
<p>Returns a new Iterable of the same type which excludes the first <code>amount</code> entries from this Iterable.</p> <pre data-language="js">skip(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skip">Iterable#skip</a></code><h3 id="collection.keyed.skiplast">Collection.Keyed#skipLast()</h3>
<p>Returns a new Iterable of the same type which excludes the last <code>amount</code> entries from this Iterable.</p> <pre data-language="js">skipLast(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skiplast">Iterable#skipLast</a></code><h3 id="collection.keyed.skipwhile">Collection.Keyed#skipWhile()</h3>
<p>Returns a new Iterable of the same type which includes entries starting from when <code>predicate</code> first returns false.</p> <pre data-language="js">skipWhile(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skipwhile">Iterable#skipWhile</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .skipWhile(x =&gt; x.match(/g/))
// Seq [ 'cat', 'hat', 'god' ]</pre>
<h3 id="collection.keyed.skipuntil">Collection.Keyed#skipUntil()</h3>
<p>Returns a new Iterable of the same type which includes entries starting from when <code>predicate</code> first returns true.</p> <pre data-language="js">skipUntil(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skipuntil">Iterable#skipUntil</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .skipUntil(x =&gt; x.match(/hat/))
// Seq [ 'hat', 'god' ]</pre>
<h3 id="collection.keyed.take">Collection.Keyed#take()</h3>
<p>Returns a new Iterable of the same type which includes the first <code>amount</code> entries from this Iterable.</p> <pre data-language="js">take(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.take">Iterable#take</a></code><h3 id="collection.keyed.takelast">Collection.Keyed#takeLast()</h3>
<p>Returns a new Iterable of the same type which includes the last <code>amount</code> entries from this Iterable.</p> <pre data-language="js">takeLast(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takelast">Iterable#takeLast</a></code><h3 id="collection.keyed.takewhile">Collection.Keyed#takeWhile()</h3>
<p>Returns a new Iterable of the same type which includes entries from this Iterable as long as the <code>predicate</code> returns true.</p> <pre data-language="js">takeWhile(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takewhile">Iterable#takeWhile</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .takeWhile(x =&gt; x.match(/o/))
// Seq [ 'dog', 'frog' ]</pre>
<h3 id="collection.keyed.takeuntil">Collection.Keyed#takeUntil()</h3>
<p>Returns a new Iterable of the same type which includes entries from this Iterable as long as the <code>predicate</code> returns false.</p> <pre data-language="js">takeUntil(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takeuntil">Iterable#takeUntil</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god').takeUntil(x =&gt; x.match(/at/))
// ['dog', 'frog']</pre>
<h2>Combination</h2>
<h3 id="collection.keyed.concat">Collection.Keyed#concat()</h3>
<p>Returns a new Iterable of the same type with other values and iterable-like concatenated to this one.</p> <pre data-language="js">concat(...valuesOrIterables: any[]): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.concat">Iterable#concat</a></code><h4>Discussion</h4>
<p>For Seqs, all entries will be present in the resulting iterable, even if they have the same key.</p> <h3 id="collection.keyed.flatten">Collection.Keyed#flatten()</h3>
<p>Flattens nested Iterables.</p> <pre data-language="js">flatten(depth?: number): Iterable&lt;any, any&gt;
flatten(shallow?: boolean): Iterable&lt;any, any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.flatten">Iterable#flatten</a></code><h4>Discussion</h4>
<p>Will deeply flatten the Iterable by default, returning an Iterable of the same type, but a <code>depth</code> can be provided in the form of a number or boolean (where true means to shallowly flatten one level). A depth of 0 (or shallow: false) will deeply flatten.</p> <p>Flattens only others Iterable, not Arrays or Objects.</p> <p>Note: <code>flatten(true)</code> operates on Iterable<any iterable v="">&gt; and returns Iterable</any></p> <h3 id="collection.keyed.flatmap">Collection.Keyed#flatMap()</h3>
<p>Flat-maps the Iterable, returning an Iterable of the same type.</p> <pre data-language="js">flatMap&lt;MK, MV&gt;(mapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; Iterable&lt;MK, MV&gt;,context?: any): Iterable&lt;MK, MV&gt;
flatMap&lt;MK, MV&gt;(mapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; any,context?: any): Iterable&lt;MK, MV&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.flatmap">Iterable#flatMap</a></code><h4>Discussion</h4>
<p>Similar to <code>iter.map(...).flatten(true)</code>.</p> <h2>Reducing a value</h2>
<h3 id="collection.keyed.reduce">Collection.Keyed#reduce()</h3>
<p>Reduces the Iterable to a value by calling the <code>reducer</code> for every entry in the Iterable and passing along the reduced value.</p> <pre data-language="js">reduce&lt;R&gt;(reducer: (reduction?: R, value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; R,initialReduction?: R,context?: any): R
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reduce">Iterable#reduce</a></code><h4>see</h4>
<p><code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">Array#reduce</a></code>.</p> <h4>Discussion</h4>
<p>If <code>initialReduction</code> is not provided, or is null, the first item in the Iterable will be used.</p> <h3 id="collection.keyed.reduceright">Collection.Keyed#reduceRight()</h3>
<p>Reduces the Iterable in reverse (from the right side).</p> <pre data-language="js">reduceRight&lt;R&gt;(reducer: (reduction?: R, value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; R,initialReduction?: R,context?: any): R
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reduceright">Iterable#reduceRight</a></code><h4>Discussion</h4>
<p>Note: Similar to this.reverse().reduce(), and provided for parity with <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight">Array#reduceRight</a></code>.</p> <h3 id="collection.keyed.every">Collection.Keyed#every()</h3>
<p>True if <code>predicate</code> returns true for all entries in the Iterable.</p> <pre data-language="js">every(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.every">Iterable#every</a></code><h3 id="collection.keyed.some">Collection.Keyed#some()</h3>
<p>True if <code>predicate</code> returns true for any entry in the Iterable.</p> <pre data-language="js">some(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.some">Iterable#some</a></code><h3 id="collection.keyed.join">Collection.Keyed#join()</h3>
<p>Joins values together as a string, inserting a separator between each. The default separator is <code>","</code>.</p> <pre data-language="js">join(separator?: string): string
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.join">Iterable#join</a></code><h3 id="collection.keyed.isempty">Collection.Keyed#isEmpty()</h3>
<p>Returns true if this Iterable includes no values.</p> <pre data-language="js">isEmpty(): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.isempty">Iterable#isEmpty</a></code><h4>Discussion</h4>
<p>For some lazy <code><a href="#seq">Seq</a></code>, <code>isEmpty</code> might need to iterate to determine emptiness. At most one iteration will occur.</p> <h3 id="collection.keyed.count">Collection.Keyed#count()</h3>
<p>Returns the size of this Iterable.</p> <pre data-language="js">count(): number
count(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.count">Iterable#count</a></code><h4>Discussion</h4>
<p>Regardless of if this Iterable can describe its size lazily (some Seqs cannot), this method will always return the correct size. E.g. it evaluates a lazy <code><a href="#seq">Seq</a></code> if necessary.</p> <p>If <code>predicate</code> is provided, then this returns the count of entries in the Iterable for which the <code>predicate</code> returns true.</p> <h3 id="collection.keyed.countby">Collection.Keyed#countBy()</h3>
<p>Returns a <code><a href="#seq.keyed">Seq.Keyed</a></code> of counts, grouped by the return value of the <code>grouper</code> function.</p> <pre data-language="js">countBy&lt;G&gt;(grouper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; G,context?: any): Map&lt;G, number&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.countby">Iterable#countBy</a></code><h4>Discussion</h4>
<p>Note: This is not a lazy operation.</p> <h2>Search for value</h2>
<h3 id="collection.keyed.find">Collection.Keyed#find()</h3>
<p>Returns the first value for which the <code>predicate</code> returns true.</p> <pre data-language="js">find(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.find">Iterable#find</a></code><h3 id="collection.keyed.findlast">Collection.Keyed#findLast()</h3>
<p>Returns the last value for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLast(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlast">Iterable#findLast</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="collection.keyed.findentry">Collection.Keyed#findEntry()</h3>
<p>Returns the first [key, value] entry for which the <code>predicate</code> returns true.</p> <pre data-language="js">findEntry(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): Array&lt;any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findentry">Iterable#findEntry</a></code><h3 id="collection.keyed.findlastentry">Collection.Keyed#findLastEntry()</h3>
<p>Returns the last [key, value] entry for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLastEntry(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): Array&lt;any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlastentry">Iterable#findLastEntry</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="collection.keyed.findkey">Collection.Keyed#findKey()</h3>
<p>Returns the key for which the <code>predicate</code> returns true.</p> <pre data-language="js">findKey(predicate: (value?: V, key?: K, iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; boolean,context?: any): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findkey">Iterable#findKey</a></code><h3 id="collection.keyed.findlastkey">Collection.Keyed#findLastKey()</h3>
<p>Returns the last key for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLastKey(predicate: (value?: V, key?: K, iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; boolean,context?: any): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlastkey">Iterable#findLastKey</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="collection.keyed.keyof">Collection.Keyed#keyOf()</h3>
<p>Returns the key associated with the search value, or undefined.</p> <pre data-language="js">keyOf(searchValue: V): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyof">Iterable#keyOf</a></code><h3 id="collection.keyed.lastkeyof">Collection.Keyed#lastKeyOf()</h3>
<p>Returns the last key associated with the search value, or undefined.</p> <pre data-language="js">lastKeyOf(searchValue: V): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.lastkeyof">Iterable#lastKeyOf</a></code><h3 id="collection.keyed.max">Collection.Keyed#max()</h3>
<p>Returns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> <pre data-language="js">max(comparator?: (valueA: V, valueB: V) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.max">Iterable#max</a></code><h4>Discussion</h4>
<p>The <code>comparator</code> is used in the same way as <code><a href="#iterable.sort">Iterable#sort</a></code>. If it is not provided, the default comparator is <code>&gt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code>max</code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&gt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> <h3 id="collection.keyed.maxby">Collection.Keyed#maxBy()</h3>
<p>Like <code><a href="#iterable.max">max</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> <pre data-language="js">maxBy&lt;C&gt;(comparatorValueMapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.maxby">Iterable#maxBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.maxBy(hitter =&gt; hitter.avgHits);</pre>
<h3 id="collection.keyed.min">Collection.Keyed#min()</h3>
<p>Returns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> <pre data-language="js">min(comparator?: (valueA: V, valueB: V) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.min">Iterable#min</a></code><h4>Discussion</h4>
<p>The <code>comparator</code> is used in the same way as <code><a href="#iterable.sort">Iterable#sort</a></code>. If it is not provided, the default comparator is <code>&lt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code>min</code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&lt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> <h3 id="collection.keyed.minby">Collection.Keyed#minBy()</h3>
<p>Like <code><a href="#iterable.min">min</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> <pre data-language="js">minBy&lt;C&gt;(comparatorValueMapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.minby">Iterable#minBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.minBy(hitter =&gt; hitter.avgHits);</pre>
<h2>Comparison</h2>
<h3 id="collection.keyed.issubset">Collection.Keyed#isSubset()</h3>
<p>True if <code>iter</code> includes every value in this Iterable.</p> <pre data-language="js">isSubset(iter: Iterable&lt;any, V&gt;): boolean
isSubset(iter: Array&lt;V&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.issubset">Iterable#isSubset</a></code><h3 id="collection.keyed.issuperset">Collection.Keyed#isSuperset()</h3>
<p>True if this Iterable includes every value in <code>iter</code>.</p> <pre data-language="js">isSuperset(iter: Iterable&lt;any, V&gt;): boolean
isSuperset(iter: Array&lt;V&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.issuperset">Iterable#isSuperset</a></code><h2>Sequence functions</h2>
<h3 id="collection.keyed.flip">Collection.Keyed#flip()</h3>
<p>Returns a new Iterable.Keyed of the same type where the keys and values have been flipped.</p> <pre data-language="js">flip(): Iterable.Keyed&lt;V, K&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyed.flip">Iterable.Keyed#flip</a></code><h4>Example</h4>
<pre data-language="js">Seq({ a: 'z', b: 'y' }).flip() // { z: 'a', y: 'b' }</pre>
<h3 id="collection.keyed.mapkeys">Collection.Keyed#mapKeys()</h3>
<p>Returns a new Iterable.Keyed of the same type with keys passed through a <code>mapper</code> function.</p> <pre data-language="js">mapKeys&lt;M&gt;(mapper: (key?: K, value?: V, iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; M,context?: any): Iterable.Keyed&lt;M, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyed.mapkeys">Iterable.Keyed#mapKeys</a></code><h4>Example</h4>
<pre data-language="js">Seq({ a: 1, b: 2 })
  .mapKeys(x =&gt; x.toUpperCase())
// Seq { A: 1, B: 2 }</pre>
<h3 id="collection.keyed.mapentries">Collection.Keyed#mapEntries()</h3>
<p>Returns a new Iterable.Keyed of the same type with entries ([key, value] tuples) passed through a <code>mapper</code> function.</p> <pre data-language="js">mapEntries&lt;KM, VM&gt;(mapper: (entry?: Array&lt;any&gt;,index?: number,iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; Array&lt;any&gt;,context?: any): Iterable.Keyed&lt;KM, VM&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyed.mapentries">Iterable.Keyed#mapEntries</a></code><h4>Example</h4>
<pre data-language="js">Seq({ a: 1, b: 2 })
  .mapEntries(([k, v]) =&gt; [k.toUpperCase(), v * 2])
// Seq { A: 2, B: 4 }</pre>
<h1 id="collection.keyed">Collection.Keyed</h1>
<p><code>Collection</code> which represents key-value pairs.</p> <pre data-language="js">class Collection.Keyed&lt;K, V&gt; extends Collection&lt;K, V&gt;, Iterable.Keyed&lt;K, V&gt;</pre>
<h2>Members</h2>
<h3 id="collection.keyed.size">Collection.Keyed#size</h3>
<pre data-language="js">size: number</pre>
<h4>Inherited from</h4>
<code><a href="#collection.size">Collection#size</a></code><h2>Conversion to Seq</h2>
<h3 id="collection.keyed.toseq">Collection.Keyed#toSeq()</h3>
<p>Returns Seq.Keyed.</p> <pre data-language="js">toSeq(): Seq.Keyed&lt;K, V&gt;
</pre>
<h4>Overrides</h4>
<code><a href="#iterable.toseq">Iterable#toSeq</a></code><h3 id="collection.keyed.tokeyedseq">Collection.Keyed#toKeyedSeq()</h3>
<p>Returns a Seq.Keyed from this Iterable where indices are treated as keys.</p> <pre data-language="js">toKeyedSeq(): Seq.Keyed&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tokeyedseq">Iterable#toKeyedSeq</a></code><h4>Discussion</h4>
<p>This is useful if you want to operate on an Iterable.Indexed and preserve the [index, value] pairs.</p> <p>The returned Seq will have identical iteration order as this Iterable.</p> <p>Example:</p> <pre data-language="js">var indexedSeq = Immutable.Seq.of('A', 'B', 'C');
indexedSeq.filter(v =&gt; v === 'B').toString() // Seq [ 'B' ]
var keyedSeq = indexedSeq.toKeyedSeq();
keyedSeq.filter(v =&gt; v === 'B').toString() // Seq { 1: 'B' }</pre>
<h3 id="collection.keyed.toindexedseq">Collection.Keyed#toIndexedSeq()</h3>
<p>Returns an Seq.Indexed of the values of this Iterable, discarding keys.</p> <pre data-language="js">toIndexedSeq(): Seq.Indexed&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toindexedseq">Iterable#toIndexedSeq</a></code><h3 id="collection.keyed.tosetseq">Collection.Keyed#toSetSeq()</h3>
<p>Returns a Seq.Set of the values of this Iterable, discarding keys.</p> <pre data-language="js">toSetSeq(): Seq.Set&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tosetseq">Iterable#toSetSeq</a></code><h2>Value equality</h2>
<h3 id="collection.keyed.equals">Collection.Keyed#equals()</h3>
<p>True if this and the other Iterable have value equality, as defined by <code><a href="#is">Immutable.is()</a></code>.</p> <pre data-language="js">equals(other: Iterable&lt;K, V&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.equals">Iterable#equals</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Immutable.is(this, other)</code>, but provided to allow for chained expressions.</p> <h3 id="collection.keyed.hashcode">Collection.Keyed#hashCode()</h3>
<p>Computes and returns the hashed identity for this Iterable.</p> <pre data-language="js">hashCode(): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.hashcode">Iterable#hashCode</a></code><h4>Discussion</h4>
<p>The <code>hashCode</code> of an Iterable is used to determine potential equality, and is used when adding this to a <code><a href="#iterable.set">Set</a></code> or as a key in a <code><a href="#map">Map</a></code>, enabling lookup via a different instance.</p> <pre data-language="js">var a = List.of(1, 2, 3);
var b = List.of(1, 2, 3);
assert(a !== b); // different instances
var set = Set.of(a);
assert(set.has(b) === true);</pre>
<p>If two values have the same <code>hashCode</code>, they are <a href="http://en.wikipedia.org/wiki/Collision_(computer_science)">not guaranteed to be equal</a>. If two values have different <code>hashCode</code>s, they must not be equal.</p> <h2>Reading values</h2>
<h3 id="collection.keyed.get">Collection.Keyed#get()</h3>
<p>Returns the value associated with the provided key, or notSetValue if the Iterable does not contain this key.</p> <pre data-language="js">get(key: K, notSetValue?: V): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.get">Iterable#get</a></code><h4>Discussion</h4>
<p>Note: it is possible a key may be associated with an <code>undefined</code> value, so if <code>notSetValue</code> is not provided and this method returns <code>undefined</code>, that does not guarantee the key was not found.</p> <h3 id="collection.keyed.has">Collection.Keyed#has()</h3>
<p>True if a key exists within this <code>Iterable</code>, using <code><a href="#is">Immutable.is</a></code> to determine equality</p> <pre data-language="js">has(key: K): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.has">Iterable#has</a></code><h3 id="collection.keyed.includes">Collection.Keyed#includes()</h3>
<p>True if a value exists within this <code>Iterable</code>, using <code><a href="#is">Immutable.is</a></code> to determine equality</p> <pre data-language="js">includes(value: V): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.includes">Iterable#includes</a></code><h4>alias</h4>
<code>contains()</code><h3 id="collection.keyed.first">Collection.Keyed#first()</h3>
<p>The first value in the Iterable.</p> <pre data-language="js">first(): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.first">Iterable#first</a></code><h3 id="collection.keyed.last">Collection.Keyed#last()</h3>
<p>The last value in the Iterable.</p> <pre data-language="js">last(): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.last">Iterable#last</a></code><h2>Reading deep values</h2>
<h3 id="collection.keyed.getin">Collection.Keyed#getIn()</h3>
<p>Returns the value found by following a path of keys or indices through nested Iterables.</p> <pre data-language="js">getIn(searchKeyPath: Array&lt;any&gt;, notSetValue?: any): any
getIn(searchKeyPath: Iterable&lt;any, any&gt;, notSetValue?: any): any
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.getin">Iterable#getIn</a></code><h3 id="collection.keyed.hasin">Collection.Keyed#hasIn()</h3>
<p>True if the result of following a path of keys or indices through nested Iterables results in a set value.</p> <pre data-language="js">hasIn(searchKeyPath: Array&lt;any&gt;): boolean
hasIn(searchKeyPath: Iterable&lt;any, any&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.hasin">Iterable#hasIn</a></code><h2>Conversion to JavaScript types</h2>
<h3 id="collection.keyed.tojs">Collection.Keyed#toJS()</h3>
<p>Deeply converts this Iterable to equivalent JS.</p> <pre data-language="js">toJS(): any
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tojs">Iterable#toJS</a></code><h4>alias</h4>
<code>toJSON()</code><h4>Discussion</h4>
<p><code>Iterable.Indexeds</code>, and <code>Iterable.Sets</code> become Arrays, while <code>Iterable.Keyeds</code> become Objects.</p> <h3 id="collection.keyed.toarray">Collection.Keyed#toArray()</h3>
<p>Shallowly converts this iterable to an Array, discarding keys.</p> <pre data-language="js">toArray(): Array&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toarray">Iterable#toArray</a></code><h3 id="collection.keyed.toobject">Collection.Keyed#toObject()</h3>
<p>Shallowly converts this Iterable to an Object.</p> <pre data-language="js">toObject(): {[key: string]: V}
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toobject">Iterable#toObject</a></code><h4>Discussion</h4>
<p>Throws if keys are not strings.</p> <h2>Conversion to Collections</h2>
<h3 id="collection.keyed.tomap">Collection.Keyed#toMap()</h3>
<p>Converts this Iterable to a Map, Throws if keys are not hashable.</p> <pre data-language="js">toMap(): Map&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tomap">Iterable#toMap</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Map(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="collection.keyed.toorderedmap">Collection.Keyed#toOrderedMap()</h3>
<p>Converts this Iterable to a Map, maintaining the order of iteration.</p> <pre data-language="js">toOrderedMap(): OrderedMap&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toorderedmap">Iterable#toOrderedMap</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>OrderedMap(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="collection.keyed.toset">Collection.Keyed#toSet()</h3>
<p>Converts this Iterable to a Set, discarding keys. Throws if values are not hashable.</p> <pre data-language="js">toSet(): Set&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toset">Iterable#toSet</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Set(this)</code>, but provided to allow for chained expressions.</p> <h3 id="collection.keyed.toorderedset">Collection.Keyed#toOrderedSet()</h3>
<p>Converts this Iterable to a Set, maintaining the order of iteration and discarding keys.</p> <pre data-language="js">toOrderedSet(): OrderedSet&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toorderedset">Iterable#toOrderedSet</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>OrderedSet(this.valueSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="collection.keyed.tolist">Collection.Keyed#toList()</h3>
<p>Converts this Iterable to a List, discarding keys.</p> <pre data-language="js">toList(): List&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tolist">Iterable#toList</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>List(this)</code>, but provided to allow for chained expressions.</p> <h3 id="collection.keyed.tostack">Collection.Keyed#toStack()</h3>
<p>Converts this Iterable to a Stack, discarding keys. Throws if values are not hashable.</p> <pre data-language="js">toStack(): Stack&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tostack">Iterable#toStack</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Stack(this)</code>, but provided to allow for chained expressions.</p> <h2>Iterators</h2>
<h3 id="collection.keyed.keys">Collection.Keyed#keys()</h3>
<p>An iterator of this <code>Iterable</code>'s keys.</p> <pre data-language="js">keys(): Iterator&lt;K&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keys">Iterable#keys</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.keyseq">keySeq</a></code> instead, if this is what you want.</p> <h3 id="collection.keyed.values">Collection.Keyed#values()</h3>
<p>An iterator of this <code>Iterable</code>'s values.</p> <pre data-language="js">values(): Iterator&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.values">Iterable#values</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.valueseq">valueSeq</a></code> instead, if this is what you want.</p> <h3 id="collection.keyed.entries">Collection.Keyed#entries()</h3>
<p>An iterator of this <code>Iterable</code>'s entries as <code>[key, value]</code> tuples.</p> <pre data-language="js">entries(): Iterator&lt;Array&lt;any&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.entries">Iterable#entries</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.entryseq">entrySeq</a></code> instead, if this is what you want.</p> <h2>Iterables (Seq)</h2>
<h3 id="collection.keyed.keyseq">Collection.Keyed#keySeq()</h3>
<p>Returns a new Seq.Indexed of the keys of this Iterable, discarding values.</p> <pre data-language="js">keySeq(): Seq.Indexed&lt;K&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyseq">Iterable#keySeq</a></code><h3 id="collection.keyed.valueseq">Collection.Keyed#valueSeq()</h3>
<p>Returns an Seq.Indexed of the values of this Iterable, discarding keys.</p> <pre data-language="js">valueSeq(): Seq.Indexed&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.valueseq">Iterable#valueSeq</a></code><h3 id="collection.keyed.entryseq">Collection.Keyed#entrySeq()</h3>
<p>Returns a new Seq.Indexed of [key, value] tuples.</p> <pre data-language="js">entrySeq(): Seq.Indexed&lt;Array&lt;any&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.entryseq">Iterable#entrySeq</a></code><h2>Sequence algorithms</h2>
<h3 id="collection.keyed.map">Collection.Keyed#map()</h3>
<p>Returns a new Iterable of the same type with values passed through a <code>mapper</code> function.</p> <pre data-language="js">map&lt;M&gt;(mapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; M,context?: any): Iterable&lt;K, M&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.map">Iterable#map</a></code><h4>Example</h4>
<pre data-language="js">Seq({ a: 1, b: 2 }).map(x =&gt; 10 * x)
// Seq { a: 10, b: 20 }</pre>
<h3 id="collection.keyed.filter">Collection.Keyed#filter()</h3>
<p>Returns a new Iterable of the same type with only the entries for which the <code>predicate</code> function returns true.</p> <pre data-language="js">filter(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.filter">Iterable#filter</a></code><h4>Example</h4>
<pre data-language="js">Seq({a:1,b:2,c:3,d:4}).filter(x =&gt; x % 2 === 0)
// Seq { b: 2, d: 4 }</pre>
<h3 id="collection.keyed.filternot">Collection.Keyed#filterNot()</h3>
<p>Returns a new Iterable of the same type with only the entries for which the <code>predicate</code> function returns false.</p> <pre data-language="js">filterNot(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.filternot">Iterable#filterNot</a></code><h4>Example</h4>
<pre data-language="js">Seq({a:1,b:2,c:3,d:4}).filterNot(x =&gt; x % 2 === 0)
// Seq { a: 1, c: 3 }</pre>
<h3 id="collection.keyed.reverse">Collection.Keyed#reverse()</h3>
<p>Returns a new Iterable of the same type in reverse order.</p> <pre data-language="js">reverse(): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reverse">Iterable#reverse</a></code><h3 id="collection.keyed.sort">Collection.Keyed#sort()</h3>
<p>Returns a new Iterable of the same type which includes the same entries, stably sorted by using a <code>comparator</code>.</p> <pre data-language="js">sort(comparator?: (valueA: V, valueB: V) =&gt; number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.sort">Iterable#sort</a></code><h4>Discussion</h4>
<p>If a <code>comparator</code> is not provided, a default comparator uses <code>&lt;</code> and <code>&gt;</code>.</p> <p><code>comparator(valueA, valueB)</code>:</p> <ul> <li>Returns <code>0</code> if the elements should not be swapped.</li> <li>Returns <code>-1</code> (or any negative number) if <code>valueA</code> comes before <code>valueB</code>
</li> <li>Returns <code>1</code> (or any positive number) if <code>valueA</code> comes after <code>valueB</code>
</li> <li>Is pure, i.e. it must always return the same value for the same pair of values.</li> </ul> <p>When sorting collections which have no defined order, their ordered equivalents will be returned. e.g. <code>map.sort()</code> returns OrderedMap.</p> <h3 id="collection.keyed.sortby">Collection.Keyed#sortBy()</h3>
<p>Like <code><a href="#iterable.sort">sort</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for sorting by more sophisticated means:</p> <pre data-language="js">sortBy&lt;C&gt;(comparatorValueMapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.sortby">Iterable#sortBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.sortBy(hitter =&gt; hitter.avgHits);</pre>
<h3 id="collection.keyed.groupby">Collection.Keyed#groupBy()</h3>
<p>Returns a <code><a href="#iterable.keyed">Iterable.Keyed</a></code> of <code>Iterable.Keyeds</code>, grouped by the return value of the <code>grouper</code> function.</p> <pre data-language="js">groupBy&lt;G&gt;(grouper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; G,context?: any): Seq.Keyed&lt;G, Iterable&lt;K, V&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.groupby">Iterable#groupBy</a></code><h4>Discussion</h4>
<p>Note: This is always an eager operation.</p> <h2>Side effects</h2>
<h3 id="collection.keyed.foreach">Collection.Keyed#forEach()</h3>
<p>The <code>sideEffect</code> is executed for every entry in the Iterable.</p> <pre data-language="js">forEach(sideEffect: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; any,context?: any): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.foreach">Iterable#forEach</a></code><h4>Discussion</h4>
<p>Unlike <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">Array#forEach</a></code>, if any call of <code>sideEffect</code> returns <code>false</code>, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).</p> <h2>Creating subsets</h2>
<h3 id="collection.keyed.slice">Collection.Keyed#slice()</h3>
<p>Returns a new Iterable of the same type representing a portion of this Iterable from start up to but not including end.</p> <pre data-language="js">slice(begin?: number, end?: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.slice">Iterable#slice</a></code><h4>Discussion</h4>
<p>If begin is negative, it is offset from the end of the Iterable. e.g. <code>slice(-2)</code> returns a Iterable of the last two entries. If it is not provided the new Iterable will begin at the beginning of this Iterable.</p> <p>If end is negative, it is offset from the end of the Iterable. e.g. <code>slice(0, -1)</code> returns an Iterable of everything but the last entry. If it is not provided, the new Iterable will continue through the end of this Iterable.</p> <p>If the requested slice is equivalent to the current Iterable, then it will return itself.</p> <h3 id="collection.keyed.rest">Collection.Keyed#rest()</h3>
<p>Returns a new Iterable of the same type containing all entries except the first.</p> <pre data-language="js">rest(): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.rest">Iterable#rest</a></code><h3 id="collection.keyed.butlast">Collection.Keyed#butLast()</h3>
<p>Returns a new Iterable of the same type containing all entries except the last.</p> <pre data-language="js">butLast(): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.butlast">Iterable#butLast</a></code><h3 id="collection.keyed.skip">Collection.Keyed#skip()</h3>
<p>Returns a new Iterable of the same type which excludes the first <code>amount</code> entries from this Iterable.</p> <pre data-language="js">skip(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skip">Iterable#skip</a></code><h3 id="collection.keyed.skiplast">Collection.Keyed#skipLast()</h3>
<p>Returns a new Iterable of the same type which excludes the last <code>amount</code> entries from this Iterable.</p> <pre data-language="js">skipLast(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skiplast">Iterable#skipLast</a></code><h3 id="collection.keyed.skipwhile">Collection.Keyed#skipWhile()</h3>
<p>Returns a new Iterable of the same type which includes entries starting from when <code>predicate</code> first returns false.</p> <pre data-language="js">skipWhile(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skipwhile">Iterable#skipWhile</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .skipWhile(x =&gt; x.match(/g/))
// Seq [ 'cat', 'hat', 'god' ]</pre>
<h3 id="collection.keyed.skipuntil">Collection.Keyed#skipUntil()</h3>
<p>Returns a new Iterable of the same type which includes entries starting from when <code>predicate</code> first returns true.</p> <pre data-language="js">skipUntil(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skipuntil">Iterable#skipUntil</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .skipUntil(x =&gt; x.match(/hat/))
// Seq [ 'hat', 'god' ]</pre>
<h3 id="collection.keyed.take">Collection.Keyed#take()</h3>
<p>Returns a new Iterable of the same type which includes the first <code>amount</code> entries from this Iterable.</p> <pre data-language="js">take(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.take">Iterable#take</a></code><h3 id="collection.keyed.takelast">Collection.Keyed#takeLast()</h3>
<p>Returns a new Iterable of the same type which includes the last <code>amount</code> entries from this Iterable.</p> <pre data-language="js">takeLast(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takelast">Iterable#takeLast</a></code><h3 id="collection.keyed.takewhile">Collection.Keyed#takeWhile()</h3>
<p>Returns a new Iterable of the same type which includes entries from this Iterable as long as the <code>predicate</code> returns true.</p> <pre data-language="js">takeWhile(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takewhile">Iterable#takeWhile</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .takeWhile(x =&gt; x.match(/o/))
// Seq [ 'dog', 'frog' ]</pre>
<h3 id="collection.keyed.takeuntil">Collection.Keyed#takeUntil()</h3>
<p>Returns a new Iterable of the same type which includes entries from this Iterable as long as the <code>predicate</code> returns false.</p> <pre data-language="js">takeUntil(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takeuntil">Iterable#takeUntil</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god').takeUntil(x =&gt; x.match(/at/))
// ['dog', 'frog']</pre>
<h2>Combination</h2>
<h3 id="collection.keyed.concat">Collection.Keyed#concat()</h3>
<p>Returns a new Iterable of the same type with other values and iterable-like concatenated to this one.</p> <pre data-language="js">concat(...valuesOrIterables: any[]): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.concat">Iterable#concat</a></code><h4>Discussion</h4>
<p>For Seqs, all entries will be present in the resulting iterable, even if they have the same key.</p> <h3 id="collection.keyed.flatten">Collection.Keyed#flatten()</h3>
<p>Flattens nested Iterables.</p> <pre data-language="js">flatten(depth?: number): Iterable&lt;any, any&gt;
flatten(shallow?: boolean): Iterable&lt;any, any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.flatten">Iterable#flatten</a></code><h4>Discussion</h4>
<p>Will deeply flatten the Iterable by default, returning an Iterable of the same type, but a <code>depth</code> can be provided in the form of a number or boolean (where true means to shallowly flatten one level). A depth of 0 (or shallow: false) will deeply flatten.</p> <p>Flattens only others Iterable, not Arrays or Objects.</p> <p>Note: <code>flatten(true)</code> operates on Iterable<any iterable v="">&gt; and returns Iterable</any></p> <h3 id="collection.keyed.flatmap">Collection.Keyed#flatMap()</h3>
<p>Flat-maps the Iterable, returning an Iterable of the same type.</p> <pre data-language="js">flatMap&lt;MK, MV&gt;(mapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; Iterable&lt;MK, MV&gt;,context?: any): Iterable&lt;MK, MV&gt;
flatMap&lt;MK, MV&gt;(mapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; any,context?: any): Iterable&lt;MK, MV&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.flatmap">Iterable#flatMap</a></code><h4>Discussion</h4>
<p>Similar to <code>iter.map(...).flatten(true)</code>.</p> <h2>Reducing a value</h2>
<h3 id="collection.keyed.reduce">Collection.Keyed#reduce()</h3>
<p>Reduces the Iterable to a value by calling the <code>reducer</code> for every entry in the Iterable and passing along the reduced value.</p> <pre data-language="js">reduce&lt;R&gt;(reducer: (reduction?: R, value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; R,initialReduction?: R,context?: any): R
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reduce">Iterable#reduce</a></code><h4>see</h4>
<p><code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">Array#reduce</a></code>.</p> <h4>Discussion</h4>
<p>If <code>initialReduction</code> is not provided, or is null, the first item in the Iterable will be used.</p> <h3 id="collection.keyed.reduceright">Collection.Keyed#reduceRight()</h3>
<p>Reduces the Iterable in reverse (from the right side).</p> <pre data-language="js">reduceRight&lt;R&gt;(reducer: (reduction?: R, value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; R,initialReduction?: R,context?: any): R
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reduceright">Iterable#reduceRight</a></code><h4>Discussion</h4>
<p>Note: Similar to this.reverse().reduce(), and provided for parity with <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight">Array#reduceRight</a></code>.</p> <h3 id="collection.keyed.every">Collection.Keyed#every()</h3>
<p>True if <code>predicate</code> returns true for all entries in the Iterable.</p> <pre data-language="js">every(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.every">Iterable#every</a></code><h3 id="collection.keyed.some">Collection.Keyed#some()</h3>
<p>True if <code>predicate</code> returns true for any entry in the Iterable.</p> <pre data-language="js">some(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.some">Iterable#some</a></code><h3 id="collection.keyed.join">Collection.Keyed#join()</h3>
<p>Joins values together as a string, inserting a separator between each. The default separator is <code>","</code>.</p> <pre data-language="js">join(separator?: string): string
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.join">Iterable#join</a></code><h3 id="collection.keyed.isempty">Collection.Keyed#isEmpty()</h3>
<p>Returns true if this Iterable includes no values.</p> <pre data-language="js">isEmpty(): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.isempty">Iterable#isEmpty</a></code><h4>Discussion</h4>
<p>For some lazy <code><a href="#seq">Seq</a></code>, <code>isEmpty</code> might need to iterate to determine emptiness. At most one iteration will occur.</p> <h3 id="collection.keyed.count">Collection.Keyed#count()</h3>
<p>Returns the size of this Iterable.</p> <pre data-language="js">count(): number
count(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.count">Iterable#count</a></code><h4>Discussion</h4>
<p>Regardless of if this Iterable can describe its size lazily (some Seqs cannot), this method will always return the correct size. E.g. it evaluates a lazy <code><a href="#seq">Seq</a></code> if necessary.</p> <p>If <code>predicate</code> is provided, then this returns the count of entries in the Iterable for which the <code>predicate</code> returns true.</p> <h3 id="collection.keyed.countby">Collection.Keyed#countBy()</h3>
<p>Returns a <code><a href="#seq.keyed">Seq.Keyed</a></code> of counts, grouped by the return value of the <code>grouper</code> function.</p> <pre data-language="js">countBy&lt;G&gt;(grouper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; G,context?: any): Map&lt;G, number&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.countby">Iterable#countBy</a></code><h4>Discussion</h4>
<p>Note: This is not a lazy operation.</p> <h2>Search for value</h2>
<h3 id="collection.keyed.find">Collection.Keyed#find()</h3>
<p>Returns the first value for which the <code>predicate</code> returns true.</p> <pre data-language="js">find(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.find">Iterable#find</a></code><h3 id="collection.keyed.findlast">Collection.Keyed#findLast()</h3>
<p>Returns the last value for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLast(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlast">Iterable#findLast</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="collection.keyed.findentry">Collection.Keyed#findEntry()</h3>
<p>Returns the first [key, value] entry for which the <code>predicate</code> returns true.</p> <pre data-language="js">findEntry(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): Array&lt;any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findentry">Iterable#findEntry</a></code><h3 id="collection.keyed.findlastentry">Collection.Keyed#findLastEntry()</h3>
<p>Returns the last [key, value] entry for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLastEntry(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): Array&lt;any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlastentry">Iterable#findLastEntry</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="collection.keyed.findkey">Collection.Keyed#findKey()</h3>
<p>Returns the key for which the <code>predicate</code> returns true.</p> <pre data-language="js">findKey(predicate: (value?: V, key?: K, iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; boolean,context?: any): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findkey">Iterable#findKey</a></code><h3 id="collection.keyed.findlastkey">Collection.Keyed#findLastKey()</h3>
<p>Returns the last key for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLastKey(predicate: (value?: V, key?: K, iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; boolean,context?: any): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlastkey">Iterable#findLastKey</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="collection.keyed.keyof">Collection.Keyed#keyOf()</h3>
<p>Returns the key associated with the search value, or undefined.</p> <pre data-language="js">keyOf(searchValue: V): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyof">Iterable#keyOf</a></code><h3 id="collection.keyed.lastkeyof">Collection.Keyed#lastKeyOf()</h3>
<p>Returns the last key associated with the search value, or undefined.</p> <pre data-language="js">lastKeyOf(searchValue: V): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.lastkeyof">Iterable#lastKeyOf</a></code><h3 id="collection.keyed.max">Collection.Keyed#max()</h3>
<p>Returns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> <pre data-language="js">max(comparator?: (valueA: V, valueB: V) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.max">Iterable#max</a></code><h4>Discussion</h4>
<p>The <code>comparator</code> is used in the same way as <code><a href="#iterable.sort">Iterable#sort</a></code>. If it is not provided, the default comparator is <code>&gt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code>max</code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&gt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> <h3 id="collection.keyed.maxby">Collection.Keyed#maxBy()</h3>
<p>Like <code><a href="#iterable.max">max</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> <pre data-language="js">maxBy&lt;C&gt;(comparatorValueMapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.maxby">Iterable#maxBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.maxBy(hitter =&gt; hitter.avgHits);</pre>
<h3 id="collection.keyed.min">Collection.Keyed#min()</h3>
<p>Returns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> <pre data-language="js">min(comparator?: (valueA: V, valueB: V) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.min">Iterable#min</a></code><h4>Discussion</h4>
<p>The <code>comparator</code> is used in the same way as <code><a href="#iterable.sort">Iterable#sort</a></code>. If it is not provided, the default comparator is <code>&lt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code>min</code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&lt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> <h3 id="collection.keyed.minby">Collection.Keyed#minBy()</h3>
<p>Like <code><a href="#iterable.min">min</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> <pre data-language="js">minBy&lt;C&gt;(comparatorValueMapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.minby">Iterable#minBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.minBy(hitter =&gt; hitter.avgHits);</pre>
<h2>Comparison</h2>
<h3 id="collection.keyed.issubset">Collection.Keyed#isSubset()</h3>
<p>True if <code>iter</code> includes every value in this Iterable.</p> <pre data-language="js">isSubset(iter: Iterable&lt;any, V&gt;): boolean
isSubset(iter: Array&lt;V&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.issubset">Iterable#isSubset</a></code><h3 id="collection.keyed.issuperset">Collection.Keyed#isSuperset()</h3>
<p>True if this Iterable includes every value in <code>iter</code>.</p> <pre data-language="js">isSuperset(iter: Iterable&lt;any, V&gt;): boolean
isSuperset(iter: Array&lt;V&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.issuperset">Iterable#isSuperset</a></code><h2>Sequence functions</h2>
<h3 id="collection.keyed.flip">Collection.Keyed#flip()</h3>
<p>Returns a new Iterable.Keyed of the same type where the keys and values have been flipped.</p> <pre data-language="js">flip(): Iterable.Keyed&lt;V, K&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyed.flip">Iterable.Keyed#flip</a></code><h4>Example</h4>
<pre data-language="js">Seq({ a: 'z', b: 'y' }).flip() // { z: 'a', y: 'b' }</pre>
<h3 id="collection.keyed.mapkeys">Collection.Keyed#mapKeys()</h3>
<p>Returns a new Iterable.Keyed of the same type with keys passed through a <code>mapper</code> function.</p> <pre data-language="js">mapKeys&lt;M&gt;(mapper: (key?: K, value?: V, iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; M,context?: any): Iterable.Keyed&lt;M, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyed.mapkeys">Iterable.Keyed#mapKeys</a></code><h4>Example</h4>
<pre data-language="js">Seq({ a: 1, b: 2 })
  .mapKeys(x =&gt; x.toUpperCase())
// Seq { A: 1, B: 2 }</pre>
<h3 id="collection.keyed.mapentries">Collection.Keyed#mapEntries()</h3>
<p>Returns a new Iterable.Keyed of the same type with entries ([key, value] tuples) passed through a <code>mapper</code> function.</p> <pre data-language="js">mapEntries&lt;KM, VM&gt;(mapper: (entry?: Array&lt;any&gt;,index?: number,iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; Array&lt;any&gt;,context?: any): Iterable.Keyed&lt;KM, VM&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyed.mapentries">Iterable.Keyed#mapEntries</a></code><h4>Example</h4>
<pre data-language="js">Seq({ a: 1, b: 2 })
  .mapEntries(([k, v]) =&gt; [k.toUpperCase(), v * 2])
// Seq { A: 2, B: 4 }</pre>
<h1 id="collection.keyed">Collection.Keyed</h1>
<p><code>Collection</code> which represents key-value pairs.</p> <pre data-language="js">class Collection.Keyed&lt;K, V&gt; extends Collection&lt;K, V&gt;, Iterable.Keyed&lt;K, V&gt;</pre>
<h2>Members</h2>
<h3 id="collection.keyed.size">Collection.Keyed#size</h3>
<pre data-language="js">size: number</pre>
<h4>Inherited from</h4>
<code><a href="#collection.size">Collection#size</a></code><h2>Conversion to Seq</h2>
<h3 id="collection.keyed.toseq">Collection.Keyed#toSeq()</h3>
<p>Returns Seq.Keyed.</p> <pre data-language="js">toSeq(): Seq.Keyed&lt;K, V&gt;
</pre>
<h4>Overrides</h4>
<code><a href="#iterable.toseq">Iterable#toSeq</a></code><h3 id="collection.keyed.tokeyedseq">Collection.Keyed#toKeyedSeq()</h3>
<p>Returns a Seq.Keyed from this Iterable where indices are treated as keys.</p> <pre data-language="js">toKeyedSeq(): Seq.Keyed&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tokeyedseq">Iterable#toKeyedSeq</a></code><h4>Discussion</h4>
<p>This is useful if you want to operate on an Iterable.Indexed and preserve the [index, value] pairs.</p> <p>The returned Seq will have identical iteration order as this Iterable.</p> <p>Example:</p> <pre data-language="js">var indexedSeq = Immutable.Seq.of('A', 'B', 'C');
indexedSeq.filter(v =&gt; v === 'B').toString() // Seq [ 'B' ]
var keyedSeq = indexedSeq.toKeyedSeq();
keyedSeq.filter(v =&gt; v === 'B').toString() // Seq { 1: 'B' }</pre>
<h3 id="collection.keyed.toindexedseq">Collection.Keyed#toIndexedSeq()</h3>
<p>Returns an Seq.Indexed of the values of this Iterable, discarding keys.</p> <pre data-language="js">toIndexedSeq(): Seq.Indexed&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toindexedseq">Iterable#toIndexedSeq</a></code><h3 id="collection.keyed.tosetseq">Collection.Keyed#toSetSeq()</h3>
<p>Returns a Seq.Set of the values of this Iterable, discarding keys.</p> <pre data-language="js">toSetSeq(): Seq.Set&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tosetseq">Iterable#toSetSeq</a></code><h2>Value equality</h2>
<h3 id="collection.keyed.equals">Collection.Keyed#equals()</h3>
<p>True if this and the other Iterable have value equality, as defined by <code><a href="#is">Immutable.is()</a></code>.</p> <pre data-language="js">equals(other: Iterable&lt;K, V&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.equals">Iterable#equals</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Immutable.is(this, other)</code>, but provided to allow for chained expressions.</p> <h3 id="collection.keyed.hashcode">Collection.Keyed#hashCode()</h3>
<p>Computes and returns the hashed identity for this Iterable.</p> <pre data-language="js">hashCode(): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.hashcode">Iterable#hashCode</a></code><h4>Discussion</h4>
<p>The <code>hashCode</code> of an Iterable is used to determine potential equality, and is used when adding this to a <code><a href="#iterable.set">Set</a></code> or as a key in a <code><a href="#map">Map</a></code>, enabling lookup via a different instance.</p> <pre data-language="js">var a = List.of(1, 2, 3);
var b = List.of(1, 2, 3);
assert(a !== b); // different instances
var set = Set.of(a);
assert(set.has(b) === true);</pre>
<p>If two values have the same <code>hashCode</code>, they are <a href="http://en.wikipedia.org/wiki/Collision_(computer_science)">not guaranteed to be equal</a>. If two values have different <code>hashCode</code>s, they must not be equal.</p> <h2>Reading values</h2>
<h3 id="collection.keyed.get">Collection.Keyed#get()</h3>
<p>Returns the value associated with the provided key, or notSetValue if the Iterable does not contain this key.</p> <pre data-language="js">get(key: K, notSetValue?: V): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.get">Iterable#get</a></code><h4>Discussion</h4>
<p>Note: it is possible a key may be associated with an <code>undefined</code> value, so if <code>notSetValue</code> is not provided and this method returns <code>undefined</code>, that does not guarantee the key was not found.</p> <h3 id="collection.keyed.has">Collection.Keyed#has()</h3>
<p>True if a key exists within this <code>Iterable</code>, using <code><a href="#is">Immutable.is</a></code> to determine equality</p> <pre data-language="js">has(key: K): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.has">Iterable#has</a></code><h3 id="collection.keyed.includes">Collection.Keyed#includes()</h3>
<p>True if a value exists within this <code>Iterable</code>, using <code><a href="#is">Immutable.is</a></code> to determine equality</p> <pre data-language="js">includes(value: V): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.includes">Iterable#includes</a></code><h4>alias</h4>
<code>contains()</code><h3 id="collection.keyed.first">Collection.Keyed#first()</h3>
<p>The first value in the Iterable.</p> <pre data-language="js">first(): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.first">Iterable#first</a></code><h3 id="collection.keyed.last">Collection.Keyed#last()</h3>
<p>The last value in the Iterable.</p> <pre data-language="js">last(): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.last">Iterable#last</a></code><h2>Reading deep values</h2>
<h3 id="collection.keyed.getin">Collection.Keyed#getIn()</h3>
<p>Returns the value found by following a path of keys or indices through nested Iterables.</p> <pre data-language="js">getIn(searchKeyPath: Array&lt;any&gt;, notSetValue?: any): any
getIn(searchKeyPath: Iterable&lt;any, any&gt;, notSetValue?: any): any
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.getin">Iterable#getIn</a></code><h3 id="collection.keyed.hasin">Collection.Keyed#hasIn()</h3>
<p>True if the result of following a path of keys or indices through nested Iterables results in a set value.</p> <pre data-language="js">hasIn(searchKeyPath: Array&lt;any&gt;): boolean
hasIn(searchKeyPath: Iterable&lt;any, any&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.hasin">Iterable#hasIn</a></code><h2>Conversion to JavaScript types</h2>
<h3 id="collection.keyed.tojs">Collection.Keyed#toJS()</h3>
<p>Deeply converts this Iterable to equivalent JS.</p> <pre data-language="js">toJS(): any
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tojs">Iterable#toJS</a></code><h4>alias</h4>
<code>toJSON()</code><h4>Discussion</h4>
<p><code>Iterable.Indexeds</code>, and <code>Iterable.Sets</code> become Arrays, while <code>Iterable.Keyeds</code> become Objects.</p> <h3 id="collection.keyed.toarray">Collection.Keyed#toArray()</h3>
<p>Shallowly converts this iterable to an Array, discarding keys.</p> <pre data-language="js">toArray(): Array&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toarray">Iterable#toArray</a></code><h3 id="collection.keyed.toobject">Collection.Keyed#toObject()</h3>
<p>Shallowly converts this Iterable to an Object.</p> <pre data-language="js">toObject(): {[key: string]: V}
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toobject">Iterable#toObject</a></code><h4>Discussion</h4>
<p>Throws if keys are not strings.</p> <h2>Conversion to Collections</h2>
<h3 id="collection.keyed.tomap">Collection.Keyed#toMap()</h3>
<p>Converts this Iterable to a Map, Throws if keys are not hashable.</p> <pre data-language="js">toMap(): Map&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tomap">Iterable#toMap</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Map(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="collection.keyed.toorderedmap">Collection.Keyed#toOrderedMap()</h3>
<p>Converts this Iterable to a Map, maintaining the order of iteration.</p> <pre data-language="js">toOrderedMap(): OrderedMap&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toorderedmap">Iterable#toOrderedMap</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>OrderedMap(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="collection.keyed.toset">Collection.Keyed#toSet()</h3>
<p>Converts this Iterable to a Set, discarding keys. Throws if values are not hashable.</p> <pre data-language="js">toSet(): Set&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toset">Iterable#toSet</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Set(this)</code>, but provided to allow for chained expressions.</p> <h3 id="collection.keyed.toorderedset">Collection.Keyed#toOrderedSet()</h3>
<p>Converts this Iterable to a Set, maintaining the order of iteration and discarding keys.</p> <pre data-language="js">toOrderedSet(): OrderedSet&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.toorderedset">Iterable#toOrderedSet</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>OrderedSet(this.valueSeq())</code>, but provided for convenience and to allow for chained expressions.</p> <h3 id="collection.keyed.tolist">Collection.Keyed#toList()</h3>
<p>Converts this Iterable to a List, discarding keys.</p> <pre data-language="js">toList(): List&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tolist">Iterable#toList</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>List(this)</code>, but provided to allow for chained expressions.</p> <h3 id="collection.keyed.tostack">Collection.Keyed#toStack()</h3>
<p>Converts this Iterable to a Stack, discarding keys. Throws if values are not hashable.</p> <pre data-language="js">toStack(): Stack&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.tostack">Iterable#toStack</a></code><h4>Discussion</h4>
<p>Note: This is equivalent to <code>Stack(this)</code>, but provided to allow for chained expressions.</p> <h2>Iterators</h2>
<h3 id="collection.keyed.keys">Collection.Keyed#keys()</h3>
<p>An iterator of this <code>Iterable</code>'s keys.</p> <pre data-language="js">keys(): Iterator&lt;K&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keys">Iterable#keys</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.keyseq">keySeq</a></code> instead, if this is what you want.</p> <h3 id="collection.keyed.values">Collection.Keyed#values()</h3>
<p>An iterator of this <code>Iterable</code>'s values.</p> <pre data-language="js">values(): Iterator&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.values">Iterable#values</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.valueseq">valueSeq</a></code> instead, if this is what you want.</p> <h3 id="collection.keyed.entries">Collection.Keyed#entries()</h3>
<p>An iterator of this <code>Iterable</code>'s entries as <code>[key, value]</code> tuples.</p> <pre data-language="js">entries(): Iterator&lt;Array&lt;any&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.entries">Iterable#entries</a></code><h4>Discussion</h4>
<p>Note: this will return an ES6 iterator which does not support Immutable JS sequence algorithms. Use <code><a href="#iterable.entryseq">entrySeq</a></code> instead, if this is what you want.</p> <h2>Iterables (Seq)</h2>
<h3 id="collection.keyed.keyseq">Collection.Keyed#keySeq()</h3>
<p>Returns a new Seq.Indexed of the keys of this Iterable, discarding values.</p> <pre data-language="js">keySeq(): Seq.Indexed&lt;K&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyseq">Iterable#keySeq</a></code><h3 id="collection.keyed.valueseq">Collection.Keyed#valueSeq()</h3>
<p>Returns an Seq.Indexed of the values of this Iterable, discarding keys.</p> <pre data-language="js">valueSeq(): Seq.Indexed&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.valueseq">Iterable#valueSeq</a></code><h3 id="collection.keyed.entryseq">Collection.Keyed#entrySeq()</h3>
<p>Returns a new Seq.Indexed of [key, value] tuples.</p> <pre data-language="js">entrySeq(): Seq.Indexed&lt;Array&lt;any&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.entryseq">Iterable#entrySeq</a></code><h2>Sequence algorithms</h2>
<h3 id="collection.keyed.map">Collection.Keyed#map()</h3>
<p>Returns a new Iterable of the same type with values passed through a <code>mapper</code> function.</p> <pre data-language="js">map&lt;M&gt;(mapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; M,context?: any): Iterable&lt;K, M&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.map">Iterable#map</a></code><h4>Example</h4>
<pre data-language="js">Seq({ a: 1, b: 2 }).map(x =&gt; 10 * x)
// Seq { a: 10, b: 20 }</pre>
<h3 id="collection.keyed.filter">Collection.Keyed#filter()</h3>
<p>Returns a new Iterable of the same type with only the entries for which the <code>predicate</code> function returns true.</p> <pre data-language="js">filter(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.filter">Iterable#filter</a></code><h4>Example</h4>
<pre data-language="js">Seq({a:1,b:2,c:3,d:4}).filter(x =&gt; x % 2 === 0)
// Seq { b: 2, d: 4 }</pre>
<h3 id="collection.keyed.filternot">Collection.Keyed#filterNot()</h3>
<p>Returns a new Iterable of the same type with only the entries for which the <code>predicate</code> function returns false.</p> <pre data-language="js">filterNot(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.filternot">Iterable#filterNot</a></code><h4>Example</h4>
<pre data-language="js">Seq({a:1,b:2,c:3,d:4}).filterNot(x =&gt; x % 2 === 0)
// Seq { a: 1, c: 3 }</pre>
<h3 id="collection.keyed.reverse">Collection.Keyed#reverse()</h3>
<p>Returns a new Iterable of the same type in reverse order.</p> <pre data-language="js">reverse(): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reverse">Iterable#reverse</a></code><h3 id="collection.keyed.sort">Collection.Keyed#sort()</h3>
<p>Returns a new Iterable of the same type which includes the same entries, stably sorted by using a <code>comparator</code>.</p> <pre data-language="js">sort(comparator?: (valueA: V, valueB: V) =&gt; number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.sort">Iterable#sort</a></code><h4>Discussion</h4>
<p>If a <code>comparator</code> is not provided, a default comparator uses <code>&lt;</code> and <code>&gt;</code>.</p> <p><code>comparator(valueA, valueB)</code>:</p> <ul> <li>Returns <code>0</code> if the elements should not be swapped.</li> <li>Returns <code>-1</code> (or any negative number) if <code>valueA</code> comes before <code>valueB</code>
</li> <li>Returns <code>1</code> (or any positive number) if <code>valueA</code> comes after <code>valueB</code>
</li> <li>Is pure, i.e. it must always return the same value for the same pair of values.</li> </ul> <p>When sorting collections which have no defined order, their ordered equivalents will be returned. e.g. <code>map.sort()</code> returns OrderedMap.</p> <h3 id="collection.keyed.sortby">Collection.Keyed#sortBy()</h3>
<p>Like <code><a href="#iterable.sort">sort</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for sorting by more sophisticated means:</p> <pre data-language="js">sortBy&lt;C&gt;(comparatorValueMapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.sortby">Iterable#sortBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.sortBy(hitter =&gt; hitter.avgHits);</pre>
<h3 id="collection.keyed.groupby">Collection.Keyed#groupBy()</h3>
<p>Returns a <code><a href="#iterable.keyed">Iterable.Keyed</a></code> of <code>Iterable.Keyeds</code>, grouped by the return value of the <code>grouper</code> function.</p> <pre data-language="js">groupBy&lt;G&gt;(grouper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; G,context?: any): Seq.Keyed&lt;G, Iterable&lt;K, V&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.groupby">Iterable#groupBy</a></code><h4>Discussion</h4>
<p>Note: This is always an eager operation.</p> <h2>Side effects</h2>
<h3 id="collection.keyed.foreach">Collection.Keyed#forEach()</h3>
<p>The <code>sideEffect</code> is executed for every entry in the Iterable.</p> <pre data-language="js">forEach(sideEffect: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; any,context?: any): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.foreach">Iterable#forEach</a></code><h4>Discussion</h4>
<p>Unlike <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">Array#forEach</a></code>, if any call of <code>sideEffect</code> returns <code>false</code>, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).</p> <h2>Creating subsets</h2>
<h3 id="collection.keyed.slice">Collection.Keyed#slice()</h3>
<p>Returns a new Iterable of the same type representing a portion of this Iterable from start up to but not including end.</p> <pre data-language="js">slice(begin?: number, end?: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.slice">Iterable#slice</a></code><h4>Discussion</h4>
<p>If begin is negative, it is offset from the end of the Iterable. e.g. <code>slice(-2)</code> returns a Iterable of the last two entries. If it is not provided the new Iterable will begin at the beginning of this Iterable.</p> <p>If end is negative, it is offset from the end of the Iterable. e.g. <code>slice(0, -1)</code> returns an Iterable of everything but the last entry. If it is not provided, the new Iterable will continue through the end of this Iterable.</p> <p>If the requested slice is equivalent to the current Iterable, then it will return itself.</p> <h3 id="collection.keyed.rest">Collection.Keyed#rest()</h3>
<p>Returns a new Iterable of the same type containing all entries except the first.</p> <pre data-language="js">rest(): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.rest">Iterable#rest</a></code><h3 id="collection.keyed.butlast">Collection.Keyed#butLast()</h3>
<p>Returns a new Iterable of the same type containing all entries except the last.</p> <pre data-language="js">butLast(): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.butlast">Iterable#butLast</a></code><h3 id="collection.keyed.skip">Collection.Keyed#skip()</h3>
<p>Returns a new Iterable of the same type which excludes the first <code>amount</code> entries from this Iterable.</p> <pre data-language="js">skip(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skip">Iterable#skip</a></code><h3 id="collection.keyed.skiplast">Collection.Keyed#skipLast()</h3>
<p>Returns a new Iterable of the same type which excludes the last <code>amount</code> entries from this Iterable.</p> <pre data-language="js">skipLast(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skiplast">Iterable#skipLast</a></code><h3 id="collection.keyed.skipwhile">Collection.Keyed#skipWhile()</h3>
<p>Returns a new Iterable of the same type which includes entries starting from when <code>predicate</code> first returns false.</p> <pre data-language="js">skipWhile(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skipwhile">Iterable#skipWhile</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .skipWhile(x =&gt; x.match(/g/))
// Seq [ 'cat', 'hat', 'god' ]</pre>
<h3 id="collection.keyed.skipuntil">Collection.Keyed#skipUntil()</h3>
<p>Returns a new Iterable of the same type which includes entries starting from when <code>predicate</code> first returns true.</p> <pre data-language="js">skipUntil(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.skipuntil">Iterable#skipUntil</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .skipUntil(x =&gt; x.match(/hat/))
// Seq [ 'hat', 'god' ]</pre>
<h3 id="collection.keyed.take">Collection.Keyed#take()</h3>
<p>Returns a new Iterable of the same type which includes the first <code>amount</code> entries from this Iterable.</p> <pre data-language="js">take(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.take">Iterable#take</a></code><h3 id="collection.keyed.takelast">Collection.Keyed#takeLast()</h3>
<p>Returns a new Iterable of the same type which includes the last <code>amount</code> entries from this Iterable.</p> <pre data-language="js">takeLast(amount: number): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takelast">Iterable#takeLast</a></code><h3 id="collection.keyed.takewhile">Collection.Keyed#takeWhile()</h3>
<p>Returns a new Iterable of the same type which includes entries from this Iterable as long as the <code>predicate</code> returns true.</p> <pre data-language="js">takeWhile(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takewhile">Iterable#takeWhile</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god')
  .takeWhile(x =&gt; x.match(/o/))
// Seq [ 'dog', 'frog' ]</pre>
<h3 id="collection.keyed.takeuntil">Collection.Keyed#takeUntil()</h3>
<p>Returns a new Iterable of the same type which includes entries from this Iterable as long as the <code>predicate</code> returns false.</p> <pre data-language="js">takeUntil(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.takeuntil">Iterable#takeUntil</a></code><h4>Example</h4>
<pre data-language="js">Seq.of('dog','frog','cat','hat','god').takeUntil(x =&gt; x.match(/at/))
// ['dog', 'frog']</pre>
<h2>Combination</h2>
<h3 id="collection.keyed.concat">Collection.Keyed#concat()</h3>
<p>Returns a new Iterable of the same type with other values and iterable-like concatenated to this one.</p> <pre data-language="js">concat(...valuesOrIterables: any[]): Iterable&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.concat">Iterable#concat</a></code><h4>Discussion</h4>
<p>For Seqs, all entries will be present in the resulting iterable, even if they have the same key.</p> <h3 id="collection.keyed.flatten">Collection.Keyed#flatten()</h3>
<p>Flattens nested Iterables.</p> <pre data-language="js">flatten(depth?: number): Iterable&lt;any, any&gt;
flatten(shallow?: boolean): Iterable&lt;any, any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.flatten">Iterable#flatten</a></code><h4>Discussion</h4>
<p>Will deeply flatten the Iterable by default, returning an Iterable of the same type, but a <code>depth</code> can be provided in the form of a number or boolean (where true means to shallowly flatten one level). A depth of 0 (or shallow: false) will deeply flatten.</p> <p>Flattens only others Iterable, not Arrays or Objects.</p> <p>Note: <code>flatten(true)</code> operates on Iterable<any iterable v="">&gt; and returns Iterable</any></p> <h3 id="collection.keyed.flatmap">Collection.Keyed#flatMap()</h3>
<p>Flat-maps the Iterable, returning an Iterable of the same type.</p> <pre data-language="js">flatMap&lt;MK, MV&gt;(mapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; Iterable&lt;MK, MV&gt;,context?: any): Iterable&lt;MK, MV&gt;
flatMap&lt;MK, MV&gt;(mapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; any,context?: any): Iterable&lt;MK, MV&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.flatmap">Iterable#flatMap</a></code><h4>Discussion</h4>
<p>Similar to <code>iter.map(...).flatten(true)</code>.</p> <h2>Reducing a value</h2>
<h3 id="collection.keyed.reduce">Collection.Keyed#reduce()</h3>
<p>Reduces the Iterable to a value by calling the <code>reducer</code> for every entry in the Iterable and passing along the reduced value.</p> <pre data-language="js">reduce&lt;R&gt;(reducer: (reduction?: R, value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; R,initialReduction?: R,context?: any): R
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reduce">Iterable#reduce</a></code><h4>see</h4>
<p><code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">Array#reduce</a></code>.</p> <h4>Discussion</h4>
<p>If <code>initialReduction</code> is not provided, or is null, the first item in the Iterable will be used.</p> <h3 id="collection.keyed.reduceright">Collection.Keyed#reduceRight()</h3>
<p>Reduces the Iterable in reverse (from the right side).</p> <pre data-language="js">reduceRight&lt;R&gt;(reducer: (reduction?: R, value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; R,initialReduction?: R,context?: any): R
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.reduceright">Iterable#reduceRight</a></code><h4>Discussion</h4>
<p>Note: Similar to this.reverse().reduce(), and provided for parity with <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight">Array#reduceRight</a></code>.</p> <h3 id="collection.keyed.every">Collection.Keyed#every()</h3>
<p>True if <code>predicate</code> returns true for all entries in the Iterable.</p> <pre data-language="js">every(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.every">Iterable#every</a></code><h3 id="collection.keyed.some">Collection.Keyed#some()</h3>
<p>True if <code>predicate</code> returns true for any entry in the Iterable.</p> <pre data-language="js">some(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.some">Iterable#some</a></code><h3 id="collection.keyed.join">Collection.Keyed#join()</h3>
<p>Joins values together as a string, inserting a separator between each. The default separator is <code>","</code>.</p> <pre data-language="js">join(separator?: string): string
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.join">Iterable#join</a></code><h3 id="collection.keyed.isempty">Collection.Keyed#isEmpty()</h3>
<p>Returns true if this Iterable includes no values.</p> <pre data-language="js">isEmpty(): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.isempty">Iterable#isEmpty</a></code><h4>Discussion</h4>
<p>For some lazy <code><a href="#seq">Seq</a></code>, <code>isEmpty</code> might need to iterate to determine emptiness. At most one iteration will occur.</p> <h3 id="collection.keyed.count">Collection.Keyed#count()</h3>
<p>Returns the size of this Iterable.</p> <pre data-language="js">count(): number
count(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any): number
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.count">Iterable#count</a></code><h4>Discussion</h4>
<p>Regardless of if this Iterable can describe its size lazily (some Seqs cannot), this method will always return the correct size. E.g. it evaluates a lazy <code><a href="#seq">Seq</a></code> if necessary.</p> <p>If <code>predicate</code> is provided, then this returns the count of entries in the Iterable for which the <code>predicate</code> returns true.</p> <h3 id="collection.keyed.countby">Collection.Keyed#countBy()</h3>
<p>Returns a <code><a href="#seq.keyed">Seq.Keyed</a></code> of counts, grouped by the return value of the <code>grouper</code> function.</p> <pre data-language="js">countBy&lt;G&gt;(grouper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; G,context?: any): Map&lt;G, number&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.countby">Iterable#countBy</a></code><h4>Discussion</h4>
<p>Note: This is not a lazy operation.</p> <h2>Search for value</h2>
<h3 id="collection.keyed.find">Collection.Keyed#find()</h3>
<p>Returns the first value for which the <code>predicate</code> returns true.</p> <pre data-language="js">find(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.find">Iterable#find</a></code><h3 id="collection.keyed.findlast">Collection.Keyed#findLast()</h3>
<p>Returns the last value for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLast(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlast">Iterable#findLast</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="collection.keyed.findentry">Collection.Keyed#findEntry()</h3>
<p>Returns the first [key, value] entry for which the <code>predicate</code> returns true.</p> <pre data-language="js">findEntry(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): Array&lt;any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findentry">Iterable#findEntry</a></code><h3 id="collection.keyed.findlastentry">Collection.Keyed#findLastEntry()</h3>
<p>Returns the last [key, value] entry for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLastEntry(predicate: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; boolean,context?: any,notSetValue?: V): Array&lt;any&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlastentry">Iterable#findLastEntry</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="collection.keyed.findkey">Collection.Keyed#findKey()</h3>
<p>Returns the key for which the <code>predicate</code> returns true.</p> <pre data-language="js">findKey(predicate: (value?: V, key?: K, iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; boolean,context?: any): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findkey">Iterable#findKey</a></code><h3 id="collection.keyed.findlastkey">Collection.Keyed#findLastKey()</h3>
<p>Returns the last key for which the <code>predicate</code> returns true.</p> <pre data-language="js">findLastKey(predicate: (value?: V, key?: K, iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; boolean,context?: any): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.findlastkey">Iterable#findLastKey</a></code><h4>Discussion</h4>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> <h3 id="collection.keyed.keyof">Collection.Keyed#keyOf()</h3>
<p>Returns the key associated with the search value, or undefined.</p> <pre data-language="js">keyOf(searchValue: V): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyof">Iterable#keyOf</a></code><h3 id="collection.keyed.lastkeyof">Collection.Keyed#lastKeyOf()</h3>
<p>Returns the last key associated with the search value, or undefined.</p> <pre data-language="js">lastKeyOf(searchValue: V): K
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.lastkeyof">Iterable#lastKeyOf</a></code><h3 id="collection.keyed.max">Collection.Keyed#max()</h3>
<p>Returns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> <pre data-language="js">max(comparator?: (valueA: V, valueB: V) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.max">Iterable#max</a></code><h4>Discussion</h4>
<p>The <code>comparator</code> is used in the same way as <code><a href="#iterable.sort">Iterable#sort</a></code>. If it is not provided, the default comparator is <code>&gt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code>max</code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&gt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> <h3 id="collection.keyed.maxby">Collection.Keyed#maxBy()</h3>
<p>Like <code><a href="#iterable.max">max</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> <pre data-language="js">maxBy&lt;C&gt;(comparatorValueMapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.maxby">Iterable#maxBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.maxBy(hitter =&gt; hitter.avgHits);</pre>
<h3 id="collection.keyed.min">Collection.Keyed#min()</h3>
<p>Returns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> <pre data-language="js">min(comparator?: (valueA: V, valueB: V) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.min">Iterable#min</a></code><h4>Discussion</h4>
<p>The <code>comparator</code> is used in the same way as <code><a href="#iterable.sort">Iterable#sort</a></code>. If it is not provided, the default comparator is <code>&lt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code>min</code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&lt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> <h3 id="collection.keyed.minby">Collection.Keyed#minBy()</h3>
<p>Like <code><a href="#iterable.min">min</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> <pre data-language="js">minBy&lt;C&gt;(comparatorValueMapper: (value?: V, key?: K, iter?: Iterable&lt;K, V&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): V
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.minby">Iterable#minBy</a></code><h4>Example</h4>
<pre data-language="js">hitters.minBy(hitter =&gt; hitter.avgHits);</pre>
<h2>Comparison</h2>
<h3 id="collection.keyed.issubset">Collection.Keyed#isSubset()</h3>
<p>True if <code>iter</code> includes every value in this Iterable.</p> <pre data-language="js">isSubset(iter: Iterable&lt;any, V&gt;): boolean
isSubset(iter: Array&lt;V&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.issubset">Iterable#isSubset</a></code><h3 id="collection.keyed.issuperset">Collection.Keyed#isSuperset()</h3>
<p>True if this Iterable includes every value in <code>iter</code>.</p> <pre data-language="js">isSuperset(iter: Iterable&lt;any, V&gt;): boolean
isSuperset(iter: Array&lt;V&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.issuperset">Iterable#isSuperset</a></code><h2>Sequence functions</h2>
<h3 id="collection.keyed.flip">Collection.Keyed#flip()</h3>
<p>Returns a new Iterable.Keyed of the same type where the keys and values have been flipped.</p> <pre data-language="js">flip(): Iterable.Keyed&lt;V, K&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyed.flip">Iterable.Keyed#flip</a></code><h4>Example</h4>
<pre data-language="js">Seq({ a: 'z', b: 'y' }).flip() // { z: 'a', y: 'b' }</pre>
<h3 id="collection.keyed.mapkeys">Collection.Keyed#mapKeys()</h3>
<p>Returns a new Iterable.Keyed of the same type with keys passed through a <code>mapper</code> function.</p> <pre data-language="js">mapKeys&lt;M&gt;(mapper: (key?: K, value?: V, iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; M,context?: any): Iterable.Keyed&lt;M, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyed.mapkeys">Iterable.Keyed#mapKeys</a></code><h4>Example</h4>
<pre data-language="js">Seq({ a: 1, b: 2 })
  .mapKeys(x =&gt; x.toUpperCase())
// Seq { A: 1, B: 2 }</pre>
<h3 id="collection.keyed.mapentries">Collection.Keyed#mapEntries()</h3>
<p>Returns a new Iterable.Keyed of the same type with entries ([key, value] tuples) passed through a <code>mapper</code> function.</p> <pre data-language="js">mapEntries&lt;KM, VM&gt;(mapper: (entry?: Array&lt;any&gt;,index?: number,iter?: Iterable.Keyed&lt;K, V&gt;) =&gt; Array&lt;any&gt;,context?: any): Iterable.Keyed&lt;KM, VM&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="#iterable.keyed.mapentries">Iterable.Keyed#mapEntries</a></code><h4>Example</h4>
<pre data-language="js">Seq({ a: 1, b: 2 })
  .mapEntries(([k, v]) =&gt; [k.toUpperCase(), v * 2])
// Seq { A: 2, B: 4 }</pre>
<div class="_attribution">
  <p class="_attribution-p">
     20142015 Facebook, Inc.<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://facebook.github.io/immutable-js/docs/" class="_attribution-link">https://facebook.github.io/immutable-js/docs/</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
