
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Tutorial - Falcon 2.0 - W3cubDocs</title>
  
  <meta name="description" content="In this tutorial we’ll walk through building an API for a simple image sharing service. Along the way, we’ll discuss Falcon’s major features and &hellip;">
  <meta name="keywords" content="tutorial, falcon, falcon~2.0">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/falcon~2.0/user/tutorial.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/falcon~2.0.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/falcon~2.0/" class="_nav-link" title="" style="margin-left:0;">Falcon 2.0</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _sphinx">
				
				
<h1 id="id1">Tutorial</h1> <p id="tutorial">In this tutorial we’ll walk through building an API for a simple image sharing service. Along the way, we’ll discuss Falcon’s major features and introduce the terminology used by the framework.</p>  <h2 id="first-steps">First Steps</h2> <p>The first thing we’ll do is <a class="reference internal" href="install#install"><span class="std std-ref">install</span></a> Falcon inside a fresh <a class="reference external" href="http://docs.python-guide.org/en/latest/dev/virtualenvs/">virtualenv</a>. To that end, let’s create a new project folder called “look”, and set up a virtual environment within it that we can use for the tutorial:</p> <pre data-language="bash">$ mkdir look
$ cd look
$ virtualenv .venv
$ source .venv/bin/activate
$ pip install falcon
</pre> <p>It’s customary for the project’s top-level module to be called the same as the project, so let’s create another “look” folder inside the first one and mark it as a python module by creating an empty <code>__init__.py</code> file in it:</p> <pre data-language="bash">$ mkdir look
$ touch look/__init__.py
</pre> <p>Next, let’s create a new file that will be the entry point into your app:</p> <pre data-language="bash">$ touch look/app.py
</pre> <p>The file hierarchy should now look like this:</p> <pre data-language="bash">look
├── .venv
└── look
    ├── __init__.py
    └── app.py
</pre> <p>Now, open <code>app.py</code> in your favorite text editor and add the following lines:</p> <pre data-language="python">import falcon

api = application = falcon.API()
</pre> <p>This code creates your WSGI application and aliases it as <code>api</code>. You can use any variable names you like, but we’ll use <code>application</code> since that is what Gunicorn, by default, expects it to be called (we’ll see how this works in the next section of the tutorial).</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">A WSGI application is just a callable with a well-defined signature so that you can host the application with any web server that understands the <a class="reference external" href="http://legacy.python.org/dev/peps/pep-3333/">WSGI protocol</a>.</p> </div> <p>Next let’s take a look at the <a class="reference internal" href="../api/api#falcon.API" title="falcon.API"><code>falcon.API</code></a> class. Install <a class="reference external" href="http://ipython.org/">IPython</a> and fire it up:</p> <pre data-language="bash">$ pip install ipython
$ ipython
</pre> <p>Now, type the following to introspect the <a class="reference internal" href="../api/api#falcon.API" title="falcon.API"><code>falcon.API</code></a> callable:</p> <pre data-language="bash">In [1]: import falcon

In [2]: falcon.API.__call__?
</pre> <p>Alternatively, you can use the standard Python <code>help()</code> function:</p> <pre data-language="bash">In [3]: help(falcon.API.__call__)
</pre> <p>Note the method signature. <code>env</code> and <code>start_response</code> are standard WSGI params. Falcon adds a thin abstraction on top of these params so you don’t have to interact with them directly.</p> <p>The Falcon framework contains extensive inline documentation that you can query using the above technique.</p> <div class="admonition tip"> <p class="first admonition-title">Tip</p> <p class="last">In addition to <a class="reference external" href="http://ipython.org/">IPython</a>, the Python community maintains several other super-powered REPLs that you may wish to try, including <a class="reference external" href="http://bpython-interpreter.org/">bpython</a> and <a class="reference external" href="https://github.com/jonathanslenders/ptpython">ptpython</a>.</p> </div>   <h2 id="hosting-your-app">Hosting Your App</h2> <p>Now that you have a simple Falcon app, you can take it for a spin with a WSGI server. Python includes a reference server for self-hosting, but let’s use something more robust that you might use in production.</p> <p>Open a new terminal and run the following:</p> <pre data-language="bash">$ source .venv/bin/activate
$ pip install gunicorn
$ gunicorn --reload look.app
</pre> <p>(Note the use of the <code>--reload</code> option to tell Gunicorn to reload the app whenever its code changes.)</p> <p>If you are a Windows user, Waitress can be used in lieu of Gunicorn, since the latter doesn’t work under Windows:</p> <pre data-language="bash">$ pip install waitress
$ waitress-serve --port=8000 look.app:api
</pre> <p>Now, in a different terminal, try querying the running app with curl:</p> <pre data-language="bash">$ curl -v localhost:8000
</pre> <p>You should get a 404. That’s actually OK, because we haven’t specified any routes yet. Falcon includes a default 404 response handler that will fire for any requested path for which a route does not exist.</p> <p>While curl certainly gets the job done, it can be a bit crufty to use. <a class="reference external" href="https://github.com/jkbr/httpie">HTTPie</a> is a modern, user-friendly alternative. Let’s install HTTPie and use it from now on:</p> <pre data-language="bash">$ source .venv/bin/activate
$ pip install httpie
$ http localhost:8000
</pre>   <h2 id="tutorial-resources">Creating Resources</h2> <p id="creating-resources">Falcon’s design borrows several key concepts from the REST architectural style.</p> <p>Central to both REST and the Falcon framework is the concept of a “resource”. Resources are simply all the things in your API or application that can be accessed by a URL. For example, an event booking application may have resources such as “ticket” and “venue”, while a video game backend may have resources such as “achievements” and “player”.</p> <p>URLs provide a way for the client to uniquely identify resources. For example, <code>/players</code> might identify the “list of all players” resource, while <code>/players/45301f54</code> might identify the “individual player with ID 45301f54”, and <code>/players/45301f54/achievements</code> the “list of all achievements for the player resource with ID 45301f54”.</p> <pre data-language="python">  POST        /players/45301f54/achievements
└──────┘    └────────────────────────────────┘
 Action            Resource Identifier
</pre> <p>In the REST architectural style, the URL only identifies the resource; it does not specify what action to take on that resource. Instead, users choose from a set of standard methods. For HTTP, these are the familiar GET, POST, HEAD, etc. Clients can query a resource to discover which methods it supports.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">This is one of the key differences between the REST and RPC architectural styles. REST applies a standard set of verbs across any number of resources, as opposed to having each application define its own unique set of methods.</p> </div> <p>Depending on the requested action, the server may or may not return a representation to the client. Representations may be encoded in any one of a number of Internet media types, such as JSON and HTML.</p> <p>Falcon uses Python classes to represent resources. In practice, these classes act as controllers in your application. They convert an incoming request into one or more internal actions, and then compose a response back to the client based on the results of those actions.</p> <pre data-language="python">           ┌────────────┐
request  → │            │
           │ Resource   │ ↻ Orchestrate the requested action
           │ Controller │ ↻ Compose the result
response ← │            │
           └────────────┘
</pre> <p>A resource in Falcon is just a regular Python class that includes one or more methods representing the standard HTTP verbs supported by that resource. Each requested URL is mapped to a specific resource.</p> <p>Since we are building an image-sharing API, let’s start by creating an “images” resource. Create a new module, <code>images.py</code> next to <code>app.py</code>, and add the following code to it:</p> <pre data-language="python">import json

import falcon


class Resource(object):

    def on_get(self, req, resp):
        doc = {
            'images': [
                {
                    'href': '/images/1eaf6ef1-7f2d-4ecc-a8d5-6e8adba7cc0e.png'
                }
            ]
        }

        # Create a JSON representation of the resource
        resp.body = json.dumps(doc, ensure_ascii=False)

        # The following line can be omitted because 200 is the default
        # status returned by the framework, but it is included here to
        # illustrate how this may be overridden as needed.
        resp.status = falcon.HTTP_200
</pre> <p>As you can see, <code>Resource</code> is just a regular class. You can name the class anything you like. Falcon uses duck-typing, so you don’t need to inherit from any sort of special base class.</p> <p>The image resource above defines a single method, <code>on_get()</code>. For any HTTP method you want your resource to support, simply add an <code>on_*()</code> method to the class, where <code>*</code> is any one of the standard HTTP methods, lowercased (e.g., <code>on_get()</code>, <code>on_put()</code>, <code>on_head()</code>, etc.).</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Supported HTTP methods are those specified in <a class="reference external" href="https://tools.ietf.org/html/rfc7231">RFC 7231</a> and <a class="reference external" href="https://tools.ietf.org/html/rfc5789">RFC 5789</a>. This includes GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, and PATCH.</p> </div> <p>We call these well-known methods “responders”. Each responder takes (at least) two params, one representing the HTTP request, and one representing the HTTP response to that request. By convention, these are called <code>req</code> and <code>resp</code>, respectively. Route templates and hooks can inject extra params, as we shall see later on.</p> <p>Right now, the image resource responds to GET requests with a simple <code>200 OK</code> and a JSON body. Falcon’s Internet media type defaults to <code>application/json</code> but you can set it to whatever you like. Noteworthy JSON alternatives include <a class="reference external" href="http://yaml.org/">YAML</a> and <a class="reference external" href="http://msgpack.org/">MessagePack</a>.</p> <p>Next let’s wire up this resource and see it in action. Go back to <code>app.py</code> and modify it so that it looks something like this:</p> <pre data-language="python">import falcon

from .images import Resource


api = application = falcon.API()

images = Resource()
api.add_route('/images', images)
</pre> <p>Now, when a request comes in for <code>/images</code>, Falcon will call the responder on the images resource that corresponds to the requested HTTP method.</p> <p>Let’s try it. Restart Gunicorn (unless you’re using <code>--reload</code>), and send a GET request to the resource:</p> <pre data-language="bash">$ http localhost:8000/images
</pre> <p>You should receive a <code>200 OK</code> response, including a JSON-encoded representation of the “images” resource.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last"><code>add_route()</code> expects an instance of the resource class, not the class itself. The same instance is used for all requests. This strategy improves performance and reduces memory usage, but this also means that if you host your application with a threaded web server, resources and their dependencies must be thread-safe.</p> </div> <p>So far we have only implemented a responder for GET. Let’s see what happens when a different method is requested:</p> <pre data-language="bash">$ http PUT localhost:8000/images
</pre> <p>This time you should get back <code>405 Method Not Allowed</code>, since the resource does not support the <code>PUT</code> method. Note the value of the Allow header:</p> <pre data-language="bash">allow: GET, OPTIONS
</pre> <p>This is generated automatically by Falcon based on the set of methods implemented by the target resource. If a resource does not include its own OPTIONS responder, the framework provides a default implementation. Therefore, OPTIONS is always included in the list of allowable methods.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p>If you have a lot of experience with other Python web frameworks, you may be used to using decorators to set up your routes. Falcon’s particular approach provides the following benefits:</p> <ul class="last simple"> <li>The URL structure of the application is centralized. This makes it easier to reason about and maintain the API over time.</li> <li>The use of resource classes maps somewhat naturally to the REST architectural style, in which a URL is used to identify a resource only, not the action to perform on that resource.</li> <li>Resource class methods provide a uniform interface that does not have to be reinvented (and maintained) from class to class and application to application.</li> </ul> </div> <p>Next, just for fun, let’s modify our resource to use <a class="reference external" href="http://msgpack.org/">MessagePack</a> instead of JSON. Start by installing the relevant package:</p> <pre data-language="bash">$ pip install msgpack-python
</pre> <p>Then, update the responder to use the new media type:</p> <pre data-language="python">import falcon

import msgpack


class Resource(object):

    def on_get(self, req, resp):
        doc = {
            'images': [
                {
                    'href': '/images/1eaf6ef1-7f2d-4ecc-a8d5-6e8adba7cc0e.png'
                }
            ]
        }

        resp.data = msgpack.packb(doc, use_bin_type=True)
        resp.content_type = falcon.MEDIA_MSGPACK
        resp.status = falcon.HTTP_200
</pre> <p>Note the use of <code>resp.data</code> in lieu of <code>resp.body</code>. If you assign a bytestring to the latter, Falcon will figure it out, but you can realize a small performance gain by assigning directly to <code>resp.data</code>.</p> <p>Also note the use of <code>falcon.MEDIA_MSGPACK</code>. The <code>falcon</code> module provides a number of constants for common media types, including <code>falcon.MEDIA_JSON</code>, <code>falcon.MEDIA_MSGPACK</code>, <code>falcon.MEDIA_YAML</code>, <code>falcon.MEDIA_XML</code>, <code>falcon.MEDIA_HTML</code>, <code>falcon.MEDIA_JS</code>, <code>falcon.MEDIA_TEXT</code>, <code>falcon.MEDIA_JPEG</code>, <code>falcon.MEDIA_PNG</code>, and <code>falcon.MEDIA_GIF</code>.</p> <p>Restart Gunicorn (unless you’re using <code>--reload</code>), and then try sending a GET request to the revised resource:</p> <pre data-language="bash">$ http localhost:8000/images
</pre>   <h2 id="testing-tutorial">Testing your application</h2> <p id="testing-your-application">Fully exercising your code is critical to creating a robust application. Let’s take a moment to write a test for what’s been implemented so far.</p> <p>First, create a <code>tests</code> directory with <code>__init__.py</code> and a test module (<code>test_app.py</code>) inside it. The project’s structure should now look like this:</p> <pre data-language="bash">look
├── .venv
├── look
│   ├── __init__.py
│   ├── app.py
│   └── images.py
└── tests
    ├── __init__.py
    └── test_app.py
</pre> <p>Falcon supports <a class="reference internal" href="../api/testing#testing"><span class="std std-ref">testing</span></a> its <a class="reference internal" href="../api/api#falcon.API" title="falcon.API"><code>API</code></a> object by simulating HTTP requests.</p> <p>Tests can either be written using Python’s standard <a class="reference external" href="https://docs.python.org/3/library/unittest.html#module-unittest" title="(in Python v3.7)"><code>unittest</code></a> module, or with any of a number of third-party testing frameworks, such as <a class="reference external" href="http://docs.pytest.org/en/latest/">pytest</a>. For this tutorial we’ll use <a class="reference external" href="http://docs.pytest.org/en/latest/">pytest</a> since it allows for more pythonic test code as compared to the JUnit-inspired <a class="reference external" href="https://docs.python.org/3/library/unittest.html#module-unittest" title="(in Python v3.7)"><code>unittest</code></a> module.</p> <p>Let’s start by installing the <a class="reference external" href="http://docs.pytest.org/en/latest/">pytest</a> package:</p> <pre data-language="bash">$ pip install pytest
</pre> <p>Next, edit <code>test_app.py</code> to look like this:</p> <pre data-language="python">import falcon
from falcon import testing
import msgpack
import pytest

from look.app import api


@pytest.fixture
def client():
    return testing.TestClient(api)


# pytest will inject the object returned by the "client" function
# as an additional parameter.
def test_list_images(client):
    doc = {
        'images': [
            {
                'href': '/images/1eaf6ef1-7f2d-4ecc-a8d5-6e8adba7cc0e.png'
            }
        ]
    }

    response = client.simulate_get('/images')
    result_doc = msgpack.unpackb(response.content, raw=False)

    assert result_doc == doc
    assert response.status == falcon.HTTP_OK
</pre> <p>From the main project directory, exercise your new test by running pytest against the <code>tests</code> directory:</p> <pre data-language="bash">$ pytest tests
</pre> <p>If pytest reports any errors, take a moment to fix them up before proceeding to the next section of the tutorial.</p>   <h2 id="request-and-response-objects">Request and Response Objects</h2> <p>Each responder in a resource receives a <code>Request</code> object that can be used to read the headers, query parameters, and body of the request. You can use the standard <code>help()</code> function or IPython’s magic <code>?</code> function to list the attributes and methods of Falcon’s <code>Request</code> class:</p> <pre data-language="bash">In [1]: import falcon

In [2]: falcon.Request?
</pre> <p>Each responder also receives a <code>Response</code> object that can be used for setting the status code, headers, and body of the response:</p> <pre data-language="bash">In [3]: falcon.Response?
</pre> <p>This will be useful when creating a POST endpoint in the application that can add new image resources to our collection. We’ll tackle this functionality next.</p> <p>We’ll use TDD this time around, to demonstrate how to apply this particular testing strategy when developing a Falcon application. Via tests, we’ll first define precisely what we want the application to do, and then code until the tests tell us that we’re done.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">To learn more about TDD, you may wish to check out one of the many books on the topic, such as <a class="reference external" href="http://www.obeythetestinggoat.com/pages/book.html">Test Driven Development with Python</a>. The examples in this particular book use the Django framework and even JavaScript, but the author covers a number of testing principles that are widely applicable.</p> </div> <p>Let’s start by adding an additional import statement to <code>test_app.py</code>. We need to import two modules from <code>unittest.mock</code> if you are using Python 3, or from <code>mock</code> if you are using Python 2.</p> <pre data-language="python"># Python 3
from unittest.mock import mock_open, call

# Python 2
from mock import mock_open, call
</pre> <p>For Python 2, you will also need to install the <code>mock</code> package:</p> <pre data-language="bash">$ pip install mock
</pre> <p>Now add the following test:</p> <pre data-language="python"># "monkeypatch" is a special built-in pytest fixture that can be
# used to install mocks.
def test_posted_image_gets_saved(client, monkeypatch):
    mock_file_open = mock_open()
    monkeypatch.setattr('io.open', mock_file_open)

    fake_uuid = '123e4567-e89b-12d3-a456-426655440000'
    monkeypatch.setattr('uuid.uuid4', lambda: fake_uuid)

    # When the service receives an image through POST...
    fake_image_bytes = b'fake-image-bytes'
    response = client.simulate_post(
        '/images',
        body=fake_image_bytes,
        headers={'content-type': 'image/png'}
    )

    # ...it must return a 201 code, save the file, and return the
    # image's resource location.
    assert response.status == falcon.HTTP_CREATED
    assert call().write(fake_image_bytes) in mock_file_open.mock_calls
    assert response.headers['location'] == '/images/{}.png'.format(fake_uuid)
</pre> <p>As you can see, this test relies heavily on mocking, making it somewhat fragile in the face of implementation changes. We’ll revisit this later. For now, run the tests again and watch to make sure they fail. A key step in the TDD workflow is verifying that your tests <strong>do not</strong> pass before moving on to the implementation:</p> <pre data-language="bash">$ pytest tests
</pre> <p>To make the new test pass, we need to add a new method for handling POSTs. Open <code>images.py</code> and add a POST responder to the <code>Resource</code> class as follows:</p> <pre data-language="python">import io
import os
import uuid
import mimetypes

import falcon
import msgpack


class Resource(object):

    _CHUNK_SIZE_BYTES = 4096

    # The resource object must now be initialized with a path used during POST
    def __init__(self, storage_path):
        self._storage_path = storage_path

    # This is the method we implemented before
    def on_get(self, req, resp):
        doc = {
            'images': [
                {
                    'href': '/images/1eaf6ef1-7f2d-4ecc-a8d5-6e8adba7cc0e.png'
                }
            ]
        }

        resp.data = msgpack.packb(doc, use_bin_type=True)
        resp.content_type = falcon.MEDIA_MSGPACK
        resp.status = falcon.HTTP_200

    def on_post(self, req, resp):
        ext = mimetypes.guess_extension(req.content_type)
        name = '{uuid}{ext}'.format(uuid=uuid.uuid4(), ext=ext)
        image_path = os.path.join(self._storage_path, name)

        with io.open(image_path, 'wb') as image_file:
            while True:
                chunk = req.stream.read(self._CHUNK_SIZE_BYTES)
                if not chunk:
                    break

                image_file.write(chunk)

        resp.status = falcon.HTTP_201
        resp.location = '/images/' + name
</pre> <p>As you can see, we generate a unique name for the image, and then write it out by reading from <code>req.stream</code>. It’s called <code>stream</code> instead of <code>body</code> to emphasize the fact that you are really reading from an input stream; by default Falcon does not spool or decode request data, instead giving you direct access to the incoming binary stream provided by the WSGI server.</p> <p>Note the use of <code>falcon.HTTP_201</code> for setting the response status to “201 Created”. We could have also used the <code>falcon.HTTP_CREATED</code> alias. For a full list of predefined status strings, simply call <code>help()</code> on <code>falcon.status_codes</code>:</p> <pre data-language="bash">In [4]: help(falcon.status_codes)
</pre> <p>The last line in the <code>on_post()</code> responder sets the Location header for the newly created resource. (We will create a route for that path in just a minute.) The <a class="reference internal" href="../api/request_and_response#falcon.Request" title="falcon.Request"><code>Request</code></a> and <a class="reference internal" href="../api/request_and_response#falcon.Response" title="falcon.Response"><code>Response</code></a> classes contain convenient attributes for reading and setting common headers, but you can always access any header by name with the <code>req.get_header()</code> and <code>resp.set_header()</code> methods.</p> <p>Take a moment to run pytest again to check your progress:</p> <pre data-language="bash">$ pytest tests
</pre> <p>You should see a <code>TypeError</code> as a consequence of adding the <code>storage_path</code> parameter to <code>Resource.__init__()</code>.</p> <p>To fix this, simply edit <code>app.py</code> and pass in a path to the initializer. For now, just use the working directory from which you started the service:</p> <pre data-language="python">images = Resource(storage_path='.')
</pre> <p>Try running the tests again. This time, they should pass with flying colors!</p> <pre data-language="bash">$ pytest tests
</pre> <p>Finally, restart Gunicorn and then try sending a POST request to the resource from the command line (substituting <code>test.png</code> for a path to any PNG you like.)</p> <pre data-language="bash">$ http POST localhost:8000/images Content-Type:image/png &lt; test.png
</pre> <p>Now, if you check your storage directory, it should contain a copy of the image you just POSTed.</p> <p>Upward and onward!</p>   <h2 id="refactoring-for-testability">Refactoring for testability</h2> <p>Earlier we pointed out that our POST test relied heavily on mocking, relying on assumptions that may or may not hold true as the code evolves. To mitigate this problem, we’ll not only have to refactor the tests, but also the application itself.</p> <p>We’ll start by factoring out the business logic from the resource’s POST responder in <code>images.py</code> so that it can be tested independently. In this case, the resource’s “business logic” is simply the image-saving operation:</p> <pre data-language="python">import io
import mimetypes
import os
import uuid

import falcon
import msgpack


class Resource(object):

    def __init__(self, image_store):
        self._image_store = image_store

    def on_get(self, req, resp):
        doc = {
            'images': [
                {
                    'href': '/images/1eaf6ef1-7f2d-4ecc-a8d5-6e8adba7cc0e.png'
                }
            ]
        }

        resp.data = msgpack.packb(doc, use_bin_type=True)
        resp.content_type = falcon.MEDIA_MSGPACK
        resp.status = falcon.HTTP_200

    def on_post(self, req, resp):
        name = self._image_store.save(req.stream, req.content_type)
        resp.status = falcon.HTTP_201
        resp.location = '/images/' + name


class ImageStore(object):

    _CHUNK_SIZE_BYTES = 4096

    # Note the use of dependency injection for standard library
    # methods. We'll use these later to avoid monkey-patching.
    def __init__(self, storage_path, uuidgen=uuid.uuid4, fopen=io.open):
        self._storage_path = storage_path
        self._uuidgen = uuidgen
        self._fopen = fopen

    def save(self, image_stream, image_content_type):
        ext = mimetypes.guess_extension(image_content_type)
        name = '{uuid}{ext}'.format(uuid=self._uuidgen(), ext=ext)
        image_path = os.path.join(self._storage_path, name)

        with self._fopen(image_path, 'wb') as image_file:
            while True:
                chunk = image_stream.read(self._CHUNK_SIZE_BYTES)
                if not chunk:
                    break

                image_file.write(chunk)

        return name
</pre> <p>Let’s check to see if we broke anything with the changes above:</p> <pre data-language="bash">$ pytest tests
</pre> <p>Hmm, it looks like we forgot to update <code>app.py</code>. Let’s do that now:</p> <pre data-language="python">import falcon

from .images import ImageStore, Resource


api = application = falcon.API()

image_store = ImageStore('.')
images = Resource(image_store)
api.add_route('/images', images)
</pre> <p>Let’s try again:</p> <pre data-language="bash">$ pytest tests
</pre> <p>Now you should see a failed test assertion regarding <code>mock_file_open</code>. To fix this, we need to switch our strategy from monkey-patching to dependency injection. Return to <code>app.py</code> and modify it to look similar to the following:</p> <pre data-language="python">import falcon

from .images import ImageStore, Resource


def create_app(image_store):
    image_resource = Resource(image_store)
    api = falcon.API()
    api.add_route('/images', image_resource)
    return api


def get_app():
    image_store = ImageStore('.')
    return create_app(image_store)
</pre> <p>As you can see, the bulk of the setup logic has been moved to <code>create_app()</code>, which can be used to obtain an API object either for testing or for hosting in production. <code>get_app()</code> takes care of instantiating additional resources and configuring the application for hosting.</p> <p>The command to run the application is now:</p> <pre data-language="bash">$ gunicorn --reload 'look.app:get_app()'
</pre> <p>Finally, we need to update the test code. Modify <code>test_app.py</code> to look similar to this:</p> <pre data-language="python">import io

# Python 3
from unittest.mock import call, MagicMock, mock_open

# Python 2
# from mock import call, MagicMock, mock_open

import falcon
from falcon import testing
import msgpack
import pytest

import look.app
import look.images


@pytest.fixture
def mock_store():
    return MagicMock()


@pytest.fixture
def client(mock_store):
    api = look.app.create_app(mock_store)
    return testing.TestClient(api)


def test_list_images(client):
    doc = {
        'images': [
            {
                'href': '/images/1eaf6ef1-7f2d-4ecc-a8d5-6e8adba7cc0e.png'
            }
        ]
    }

    response = client.simulate_get('/images')
    result_doc = msgpack.unpackb(response.content, raw=False)

    assert result_doc == doc
    assert response.status == falcon.HTTP_OK


# With clever composition of fixtures, we can observe what happens with
# the mock injected into the image resource.
def test_post_image(client, mock_store):
    file_name = 'fake-image-name.xyz'

    # We need to know what ImageStore method will be used
    mock_store.save.return_value = file_name
    image_content_type = 'image/xyz'

    response = client.simulate_post(
        '/images',
        body=b'some-fake-bytes',
        headers={'content-type': image_content_type}
    )

    assert response.status == falcon.HTTP_CREATED
    assert response.headers['location'] == '/images/{}'.format(file_name)
    saver_call = mock_store.save.call_args

    # saver_call is a unittest.mock.call tuple. It's first element is a
    # tuple of positional arguments supplied when calling the mock.
    assert isinstance(saver_call[0][0], falcon.request_helpers.BoundedStream)
    assert saver_call[0][1] == image_content_type
</pre> <p>As you can see, we’ve redone the POST. While there are fewer mocks, the assertions have gotten more elaborate to properly check interactions at the interface boundaries.</p> <p>Let’s check our progress:</p> <pre data-language="bash">$ pytest tests
</pre> <p>All green! But since we used a mock, we’re no longer covering the actual saving of the image. Let’s add a test for that:</p> <pre data-language="python">def test_saving_image(monkeypatch):
    # This still has some mocks, but they are more localized and do not
    # have to be monkey-patched into standard library modules (always a
    # risky business).
    mock_file_open = mock_open()

    fake_uuid = '123e4567-e89b-12d3-a456-426655440000'
    def mock_uuidgen():
        return fake_uuid

    fake_image_bytes = b'fake-image-bytes'
    fake_request_stream = io.BytesIO(fake_image_bytes)
    storage_path = 'fake-storage-path'
    store = look.images.ImageStore(
        storage_path,
        uuidgen=mock_uuidgen,
        fopen=mock_file_open
    )

    assert store.save(fake_request_stream, 'image/png') == fake_uuid + '.png'
    assert call().write(fake_image_bytes) in mock_file_open.mock_calls
</pre> <p>Now give it a try:</p> <pre data-language="bash">$ pytest tests -k test_saving_image
</pre> <p>Like the former test, this one still uses mocks. But the structure of the code has been improved through the techniques of componentization and dependency inversion, making the application more flexible and testable.</p> <div class="admonition tip"> <p class="first admonition-title">Tip</p> <p class="last">Checking code <a class="reference external" href="https://coverage.readthedocs.io/">coverage</a> would have helped us detect the missing test above; it’s always a good idea to include coverage testing in your workflow to ensure you don’t have any bugs hiding off somewhere in an unexercised code path.</p> </div>   <h2 id="functional-tests">Functional tests</h2> <p>Functional tests define the application’s behavior from the outside. When using TDD, this can be a more natural place to start as opposed to lower-level unit testing, since it is difficult to anticipate what internal interfaces and components are needed in advance of defining the application’s user-facing functionality.</p> <p>In the case of the refactoring work from the last section, we could have inadvertently introduced a functional bug into the application that our unit tests would not have caught. This can happen when a bug is a result of an unexpected interaction between multiple units, between the application and the web server, or between the application and any external services it depends on.</p> <p>With test helpers such as <code>simulate_get()</code> and <code>simulate_post()</code>, we can create tests that span multiple units. But we can also go one step further and run the application as a normal, separate process (e.g. with Gunicorn). We can then write tests that interact with the running process through HTTP, behaving like a normal client.</p> <p>Let’s see this in action. Create a new test module, <code>tests/test_integration.py</code> with the following contents:</p> <pre data-language="python">import os

import requests


def test_posted_image_gets_saved():
    file_save_prefix = '/tmp/'
    location_prefix = '/images/'
    fake_image_bytes = b'fake-image-bytes'

    response = requests.post(
        'http://localhost:8000/images',
        data=fake_image_bytes,
        headers={'content-type': 'image/png'}
    )

    assert response.status_code == 201
    location = response.headers['location']
    assert location.startswith(location_prefix)
    image_name = location.replace(location_prefix, '')

    file_path = file_save_prefix + image_name
    with open(file_path, 'rb') as image_file:
        assert image_file.read() == fake_image_bytes

    os.remove(file_path)
</pre> <p>Next, install the <code>requests</code> package (as required by the new test) and make sure Gunicorn is up and running:</p> <pre data-language="bash">$ pip install requests
$ gunicorn 'look.app:get_app()'
</pre> <p>Then, in another terminal, try running the new test:</p> <pre data-language="bash">$ pytest tests -k test_posted_image_gets_saved
</pre> <p>The test will fail since it expects the image file to reside under <code>/tmp</code>. To fix this, modify <code>app.py</code> to add the ability to configure the image storage directory with an environment variable:</p> <pre data-language="python">import os

import falcon

from .images import ImageStore, Resource


def create_app(image_store):
    image_resource = Resource(image_store)
    api = falcon.API()
    api.add_route('/images', image_resource)
    return api


def get_app():
    storage_path = os.environ.get('LOOK_STORAGE_PATH', '.')
    image_store = ImageStore(storage_path)
    return create_app(image_store)
</pre> <p>Now you can re-run the app against the desired storage directory:</p> <pre data-language="bash">$ LOOK_STORAGE_PATH=/tmp gunicorn --reload 'look.app:get_app()'
</pre> <p>You should now be able to re-run the test and see it succeed:</p> <pre data-language="bash">$ pytest tests -k test_posted_image_gets_saved
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">The above process of starting, testing, stopping, and cleaning up after each test run can (and really should be) automated. Depending on your needs, you can develop your own automation fixtures, or use a library such as <a class="reference external" href="https://github.com/butla/mountepy">mountepy</a>.</p> </div> <p>Many developers choose to write tests like the above to sanity-check their application’s primary functionality, while leaving the bulk of testing to simulated requests and unit tests. These latter types of tests generally execute much faster and facilitate more fine-grained test assertions as compared to higher-level functional and system tests. That being said, testing strategies vary widely and you should choose the one that best suits your needs.</p> <p>At this point, you should have a good grip on how to apply common testing strategies to your Falcon application. For the sake of brevity we’ll omit further testing instructions from the following sections, focusing instead on showcasing more of Falcon’s features.</p>   <h2 id="tutorial-serving-images">Serving Images</h2> <p id="serving-images">Now that we have a way of getting images into the service, we of course need a way to get them back out. What we want to do is return an image when it is requested, using the path that came back in the Location header.</p> <p>Try executing the following:</p> <pre data-language="bash">$ http localhost:8000/images/db79e518-c8d3-4a87-93fe-38b620f9d410.png
</pre> <p>In response, you should get a <code>404 Not Found</code>. This is the default response given by Falcon when it can not find a resource that matches the requested URL path.</p> <p>Let’s address this by creating a separate class to represent a single image resource. We will then add an <code>on_get()</code> method to respond to the path above.</p> <p>Go ahead and edit your <code>images.py</code> file to look something like this:</p> <pre data-language="python">import io
import os
import re
import uuid
import mimetypes

import falcon
import msgpack


class Collection(object):

    def __init__(self, image_store):
        self._image_store = image_store

    def on_get(self, req, resp):
        # TODO: Modify this to return a list of href's based on
        # what images are actually available.
        doc = {
            'images': [
                {
                    'href': '/images/1eaf6ef1-7f2d-4ecc-a8d5-6e8adba7cc0e.png'
                }
            ]
        }

        resp.data = msgpack.packb(doc, use_bin_type=True)
        resp.content_type = falcon.MEDIA_MSGPACK
        resp.status = falcon.HTTP_200

    def on_post(self, req, resp):
        name = self._image_store.save(req.stream, req.content_type)
        resp.status = falcon.HTTP_201
        resp.location = '/images/' + name


class Item(object):

    def __init__(self, image_store):
        self._image_store = image_store

    def on_get(self, req, resp, name):
        resp.content_type = mimetypes.guess_type(name)[0]
        resp.stream, resp.content_length = self._image_store.open(name)


class ImageStore(object):

    _CHUNK_SIZE_BYTES = 4096
    _IMAGE_NAME_PATTERN = re.compile(
        '[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\.[a-z]{2,4}$'
    )

    def __init__(self, storage_path, uuidgen=uuid.uuid4, fopen=io.open):
        self._storage_path = storage_path
        self._uuidgen = uuidgen
        self._fopen = fopen

    def save(self, image_stream, image_content_type):
        ext = mimetypes.guess_extension(image_content_type)
        name = '{uuid}{ext}'.format(uuid=self._uuidgen(), ext=ext)
        image_path = os.path.join(self._storage_path, name)

        with self._fopen(image_path, 'wb') as image_file:
            while True:
                chunk = image_stream.read(self._CHUNK_SIZE_BYTES)
                if not chunk:
                    break

                image_file.write(chunk)

        return name

    def open(self, name):
        # Always validate untrusted input!
        if not self._IMAGE_NAME_PATTERN.match(name):
            raise IOError('File not found')

        image_path = os.path.join(self._storage_path, name)
        stream = self._fopen(image_path, 'rb')
        content_length = os.path.getsize(image_path)

        return stream, content_length
</pre> <p>As you can see, we renamed <code>Resource</code> to <code>Collection</code> and added a new <code>Item</code> class to represent a single image resource. Alternatively, these two classes could be consolidated into one by using suffixed responders. (See also: <a class="reference internal" href="../api/api#falcon.API.add_route" title="falcon.API.add_route"><code>add_route()</code></a>)</p> <p>Also, note the <code>name</code> parameter for the <code>on_get()</code> responder. Any URI parameters that you specify in your routes will be turned into corresponding kwargs and passed into the target responder as such. We’ll see how to specify URI parameters in a moment.</p> <p>Inside the <code>on_get()</code> responder, we set the Content-Type header based on the filename extension, and then stream out the image directly from an open file handle. Note the use of <code>resp.content_length</code>. Whenever using <code>resp.stream</code> instead of <code>resp.body</code> or <code>resp.data</code>, you typically also specify the expected length of the stream using the Content-Length header, so that the web client knows how much data to read from the response.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">If you do not know the size of the stream in advance, you can work around that by using chunked encoding, but that’s beyond the scope of this tutorial.</p> </div> <p>If <code>resp.status</code> is not set explicitly, it defaults to <code>200 OK</code>, which is exactly what we want <code>on_get()</code> to do.</p> <p>Now let’s wire everything up and give it a try. Edit <code>app.py</code> to look similar to the following:</p> <pre data-language="python">import os

import falcon

import images


def create_app(image_store):
    api = falcon.API()
    api.add_route('/images', images.Collection(image_store))
    api.add_route('/images/{name}', images.Item(image_store))
    return api


def get_app():
    storage_path = os.environ.get('LOOK_STORAGE_PATH', '.')
    image_store = images.ImageStore(storage_path)
    return create_app(image_store)
</pre> <p>As you can see, we specified a new route, <code>/images/{name}</code>. This causes Falcon to expect all associated responders to accept a <code>name</code> argument.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p>Falcon also supports more complex parameterized path segments that contain multiple values. For example, a version control API might use the following route template for diffing two code branches:</p> <pre data-language="python">/repos/{org}/{repo}/compare/{usr0}:{branch0}...{usr1}:{branch1}
</pre> </div> <p>Now re-run your app and try to POST another picture:</p> <pre data-language="bash">$ http POST localhost:8000/images Content-Type:image/png &lt; test.png
</pre> <p>Make a note of the path returned in the Location header, and use it to GET the image:</p> <pre data-language="bash">$ http localhost:8000/images/dddff30e-d2a6-4b57-be6a-b985ee67fa87.png
</pre> <p>HTTPie won’t display the image, but you can see that the response headers were set correctly. Just for fun, go ahead and paste the above URI into your browser. The image should display correctly.</p>   <h2 id="introducing-hooks">Introducing Hooks</h2> <p>At this point you should have a pretty good understanding of the basic parts that make up a Falcon-based API. Before we finish up, let’s just take a few minutes to clean up the code and add some error handling.</p> <p>First, let’s check the incoming media type when something is posted to make sure it is a common image type. We’ll implement this with a <code>before</code> hook.</p> <p>Start by defining a list of media types the service will accept. Place this constant near the top, just after the import statements in <code>images.py</code>:</p> <pre data-language="python">ALLOWED_IMAGE_TYPES = (
    'image/gif',
    'image/jpeg',
    'image/png',
)
</pre> <p>The idea here is to only accept GIF, JPEG, and PNG images. You can add others to the list if you like.</p> <p>Next, let’s create a hook that will run before each request to post a message. Add this method below the definition of <code>ALLOWED_IMAGE_TYPES</code>:</p> <pre data-language="python">def validate_image_type(req, resp, resource, params):
    if req.content_type not in ALLOWED_IMAGE_TYPES:
        msg = 'Image type not allowed. Must be PNG, JPEG, or GIF'
        raise falcon.HTTPBadRequest('Bad request', msg)
</pre> <p>And then attach the hook to the <code>on_post()</code> responder:</p> <pre data-language="python">@falcon.before(validate_image_type)
def on_post(self, req, resp):
    # ...
</pre> <p>Now, before every call to that responder, Falcon will first invoke <code>validate_image_type()</code>. There isn’t anything special about this function, other than it must accept four arguments. Every hook takes, as its first two arguments, a reference to the same <code>req</code> and <code>resp</code> objects that are passed into responders. The <code>resource</code> argument is a Resource instance associated with the request. The fourth argument, named <code>params</code> by convention, is a reference to the kwarg dictionary Falcon creates for each request. <code>params</code> will contain the route’s URI template params and their values, if any.</p> <p>As you can see in the example above, you can use <code>req</code> to get information about the incoming request. However, you can also use <code>resp</code> to play with the HTTP response as needed, and you can even use hooks to inject extra kwargs:</p> <pre data-language="python">def extract_project_id(req, resp, resource, params):
    """Adds `project_id` to the list of params for all responders.

    Meant to be used as a `before` hook.
    """
    params['project_id'] = req.get_header('X-PROJECT-ID')
</pre> <p>Now, you might imagine that such a hook should apply to all responders for a resource. In fact, hooks can be applied to an entire resource by simply decorating the class:</p> <pre data-language="python">@falcon.before(extract_project_id)
class Message(object):

    # ...
</pre> <p>Similar logic can be applied globally with middleware. (See also: <a class="reference internal" href="../api/middleware#middleware"><span class="std std-ref">falcon.middleware</span></a>)</p> <p>Now that you’ve added a hook to validate the media type, you can see it in action by attempting to POST something nefarious:</p> <pre data-language="bash">$ http POST localhost:8000/images Content-Type:image/jpx
</pre> <p>You should get back a <code>400 Bad Request</code> status and a nicely structured error body.</p> <div class="admonition tip"> <p class="first admonition-title">Tip</p> <p class="last">When something goes wrong, you usually want to give your users some info to help them resolve the issue. The exception to this rule is when an error occurs because the user is requested something they are not authorized to access. In that case, you may wish to simply return <code>404 Not Found</code> with an empty body, in case a malicious user is fishing for information that will help them crack your app.</p> </div> <p>Check out the <a class="reference internal" href="../api/hooks#hooks"><span class="std std-ref">hooks reference</span></a> to learn more.</p>   <h2 id="error-handling">Error Handling</h2> <p>Generally speaking, Falcon assumes that resource responders (<code>on_get()</code>, <code>on_post()</code>, etc.) will, for the most part, do the right thing. In other words, Falcon doesn’t try very hard to protect responder code from itself.</p> <p>This approach reduces the number of (often) extraneous checks that Falcon would otherwise have to perform, making the framework more efficient. With that in mind, writing a high-quality API based on Falcon requires that:</p> <ol class="arabic simple"> <li>Resource responders set response variables to sane values.</li> <li>Untrusted input (i.e., input from an external client or service) is validated.</li> <li>Your code is well-tested, with high code coverage.</li> <li>Errors are anticipated, detected, logged, and handled appropriately within each responder or by global error handling hooks.</li> </ol> <p>When it comes to error handling, you can always directly set the error status, appropriate response headers, and error body using the <code>resp</code> object. However, Falcon tries to make things a little easier by providing a <a class="reference internal" href="../api/errors#predefined-errors"><span class="std std-ref">set of error classes</span></a> you can raise when something goes wrong. Falcon will convert any instance or subclass of <a class="reference internal" href="../api/errors#falcon.HTTPError" title="falcon.HTTPError"><code>falcon.HTTPError</code></a> raised by a responder, hook, or middleware component into an appropriate HTTP response.</p> <p>You may raise an instance of <a class="reference internal" href="../api/errors#falcon.HTTPError" title="falcon.HTTPError"><code>falcon.HTTPError</code></a> directly, or use any one of a number of <a class="reference internal" href="../api/errors#predefined-errors"><span class="std std-ref">predefined errors</span></a> that are designed to set the response headers and body appropriately for each error type.</p> <div class="admonition tip"> <p class="first admonition-title">Tip</p> <p>Falcon will re-raise errors that do not inherit from <a class="reference internal" href="../api/errors#falcon.HTTPError" title="falcon.HTTPError"><code>falcon.HTTPError</code></a> unless you have registered a custom error handler for that type.</p> <p>Error handlers may be registered for any type, including <a class="reference internal" href="../api/errors#falcon.HTTPError" title="falcon.HTTPError"><code>HTTPError</code></a>. This feature provides a central location for logging and otherwise handling exceptions raised by responders, hooks, and middleware components.</p> <p class="last">See also: <a class="reference internal" href="../api/api#falcon.API.add_error_handler" title="falcon.API.add_error_handler"><code>add_error_handler()</code></a>.</p> </div> <p>Let’s see a quick example of how this works. Try requesting an invalid image name from your application:</p> <pre data-language="bash">$ http localhost:8000/images/voltron.png
</pre> <p>As you can see, the result isn’t exactly graceful. To fix this, we’ll need to add some exception handling. Modify your <code>Item</code> class as follows:</p> <pre data-language="python">class Item(object):

    def __init__(self, image_store):
        self._image_store = image_store

    def on_get(self, req, resp, name):
        resp.content_type = mimetypes.guess_type(name)[0]

        try:
            resp.stream, resp.content_length = self._image_store.open(name)
        except IOError:
            # Normally you would also log the error.
            raise falcon.HTTPNotFound()
</pre> <p>Now let’s try that request again:</p> <pre data-language="bash">$ http localhost:8000/images/voltron.png
</pre> <p>Additional information about error handling is available in the <a class="reference internal" href="../api/errors#errors"><span class="std std-ref">error handling reference</span></a>.</p>   <h2 id="what-now">What Now?</h2> <p>Our friendly community is available to answer your questions and help you work through sticky problems. See also: <a class="reference internal" href="https://falcon.readthedocs.io/en/2.0.0/community/help.html#help"><span class="std std-ref">Getting Help</span></a>.</p> <p>As mentioned previously, Falcon’s docstrings are quite extensive, and so you can learn a lot just by poking around Falcon’s modules from a Python REPL, such as <a class="reference external" href="http://ipython.org/">IPython</a> or <a class="reference external" href="http://bpython-interpreter.org/">bpython</a>.</p> <p>Also, don’t be shy about pulling up Falcon’s source code on GitHub or in your favorite text editor. The team has tried to make the code as straightforward and readable as possible; where other documentation may fall short, the code basically can’t be wrong.</p> <p>A number of Falcon add-ons, templates, and complementary packages are available for use in your projects. We’ve listed several of these on the <a class="reference external" href="https://github.com/falconry/falcon/wiki">Falcon wiki</a> as a starting point, but you may also wish to search PyPI for additional resources.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2019 by Falcon contributors<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://falcon.readthedocs.io/en/2.0.0/user/tutorial.html" class="_attribution-link">https://falcon.readthedocs.io/en/2.0.0/user/tutorial.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
