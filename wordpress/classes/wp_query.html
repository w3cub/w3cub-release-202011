
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>WP_Query - WordPress - W3cubDocs</title>
  
  <meta name="description" content=" The WordPress Query class. ">
  <meta name="keywords" content="wp, query, wordpress">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/wordpress/classes/wp_query.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/wordpress.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/wordpress/" class="_nav-link" title="" style="margin-left:0;">WordPress</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _wordpress">
				
				
<h1>WP_Query</h1>  <section class="summary"> <p>The WordPress Query class.</p> </section> <div class="content-toc">  <section class="explanation"> <h2 class="toc-heading" id="more-information" tabindex="-1">More Information </h2> <p>Most of the time you can find the information you want without actually dealing with the class internals and global variables. There are a whole bunch of functions that you can call from anywhere that will enable you to get the information you need.</p> <p>There are two main scenarios you might want to use <code>WP_Query</code> in. The first is to find out what type of request WordPress is currently dealing with. The <code>$is_*</code> properties are designed to hold this information: use the <a href="https://developer.wordpress.org/themes/basics/conditional-tags/">Conditional Tags</a> to interact here. This is the more common scenario to plugin writers (the second normally applies to theme writers).</p> <p>The second is during <a href="https://developer.wordpress.org/themes/basics/the-loop/">The Loop</a>. <code>WP_Query</code> provides numerous functions for common tasks within <a href="https://developer.wordpress.org/themes/basics/the-loop/">The Loop</a>. To begin with, <a href="../functions/have_posts">have_posts()</a>, which calls <code>$wp_query-&gt;have_posts()</code>, is called to see if there are any posts to show. If there are, a <code>while</code> loop is begun, using <a href="../functions/have_posts">have_posts()</a> as the condition. This will iterate around as long as there are posts to show. In each iteration, <a href="../functions/the_post">the_post()</a>, which calls <code>$wp_query-&gt;the_post()</code> is called, setting up internal variables within <code>$wp_query</code> and the global <code>$post</code> variable (which the <a href="https://developer.wordpress.org/themes/basics/template-tags/">Template Tags</a> rely on), as above. These are the functions you should use when writing a theme file that needs a loop.</p> <p><strong>Note:</strong> If you use <a href="../functions/the_post">the_post()</a> with your query, you need to run <a href="../functions/wp_reset_postdata">wp_reset_postdata()</a> afterwards to have template tags use the main query’s current post again.</p> <p><strong>Note:</strong> <a href="https://core.trac.wordpress.org/ticket/18408">Ticket #18408</a> For querying posts in the admin, consider using <a href="../functions/get_posts">get_posts()</a> as <a href="../functions/wp_reset_postdata">wp_reset_postdata()</a> might not behave as expected.</p> <h2 class="toc-heading" id="usage" tabindex="-1">Usage </h2> <h3 class="toc-heading" id="standard-loop" tabindex="-1">Standard Loop </h3> <section class="source-content"> <pre class="source-code-container" data-language="php">&lt;?php

// The Query
$the_query = new WP_Query( $args );

// The Loop
if ( $the_query-&gt;have_posts() ) {
	echo '&lt;ul&gt;';
	while ( $the_query-&gt;have_posts() ) {
		$the_query-&gt;the_post();
		echo '&lt;li&gt;' . get_the_title() . '&lt;/li&gt;';
	}
	echo '&lt;/ul&gt;';
} else {
	// no posts found
}
/* Restore original Post Data */
wp_reset_postdata();</pre>  </section>  <h3 class="toc-heading" id="standard-loop-alternate" tabindex="-1">Standard Loop (Alternate) </h3> <section class="source-content"> <pre class="source-code-container" data-language="php">&lt;?php 
// the query
$the_query = new WP_Query( $args ); ?&gt;

&lt;?php if ( $the_query-&gt;have_posts() ) : ?&gt;

	&lt;!-- pagination here --&gt;

	&lt;!-- the loop --&gt;
	&lt;?php while ( $the_query-&gt;have_posts() ) : $the_query-&gt;the_post(); ?&gt;
		&lt;h2&gt;&lt;?php the_title(); ?&gt;&lt;/h2&gt;
	&lt;?php endwhile; ?&gt;
	&lt;!-- end of the loop --&gt;

	&lt;!-- pagination here --&gt;

	&lt;?php wp_reset_postdata(); ?&gt;

&lt;?php else : ?&gt;
	&lt;p&gt;&lt;?php _e( 'Sorry, no posts matched your criteria.' ); ?&gt;&lt;/p&gt;
&lt;?php endif; ?&gt;</pre>  </section>  <h3 class="toc-heading" id="multiple-loops" tabindex="-1">Multiple Loops </h3> <p>If you have multiple queries, you need to perform multiple loops. Like so…</p> <section class="source-content"> <pre class="source-code-container" data-language="php">&lt;?php

// The Query
$query1 = new WP_Query( $args );

// The Loop
while ( $query1-&gt;have_posts() ) {
	$query1-&gt;the_post();
	echo '&lt;li&gt;' . get_the_title() . '&lt;/li&gt;';
}

/* Restore original Post Data 
 * NB: Because we are using new WP_Query we aren't stomping on the 
 * original $wp_query and it does not need to be reset with 
 * wp_reset_query(). We just need to set the post data back up with
 * wp_reset_postdata().
 */
wp_reset_postdata();


/* The 2nd Query (without global var) */
$query2 = new WP_Query( $args2 );

// The 2nd Loop
while ( $query2-&gt;have_posts() ) {
	$query2-&gt;the_post();
	echo '&lt;li&gt;' . get_the_title( $query2-&gt;post-&gt;ID ) . '&lt;/li&gt;';
}

// Restore original Post Data
wp_reset_postdata();

?&gt;</pre>  </section> <h2 class="toc-heading" id="properties-and-methods" tabindex="-1">Properties and Methods </h2> <p>This is the formal documentation of <code>WP_Query</code>. You shouldn’t alter the properties directly, but instead use the <a href="#methods">methods (see methods list below)</a> to interact with them.</p>  <h3 class="toc-heading" id="properties" tabindex="-1">Properties </h3> <ul> <li>
<code>$query</code><br> Holds the query string that was passed to the <code>$wp_query</code> object by WP class.</li> <li>
<code>$query_vars</code><br> An associative array containing the dissected <code>$query</code>: an array of the query variables and their respective values.</li> <li>
<code>$queried_object</code><br> Applicable if the request is a category, author, permalink or Page. Holds information on the requested category, author, post or Page.</li> <li>
<code>$queried_object_id</code><br> If the request is a category, author, permalink or post / page, holds the corresponding ID.</li> <li>
<code>$posts</code><br> Gets filled with the requested posts from the database.</li> <li>
<code>$post_count</code><br> The number of posts being displayed.</li> <li>
<code>$found_posts</code><br> The total number of posts found matching the current query parameters</li> <li>
<code>$max_num_pages</code><br> The total number of pages. Is the result of $found_posts / $posts_per_page</li> <li>
<code>$current_post</code><br> (available during The Loop) Index of the post currently being displayed.</li> <li>
<code>$post</code><br> (available during The Loop) The post currently being displayed.</li> <li>
<code>$is_single</code>, <code>$is_page</code>, <code>$is_archive</code>, <code>$is_preview</code>, <code>$is_date</code>, <code>$is_year</code>, <code>$is_month</code>, <code>$is_time</code>, <code>$is_author</code>, <code>$is_category</code>, <code>$is_tag</code>, <code>$is_tax</code>, <code>$is_search</code>, <code>$is_feed</code>, <code>$is_comment_feed</code>, <code>$is_trackback</code>, <code>$is_home</code>, <code>$is_404</code>, <code>$is_comments_popup</code>, <code>$is_admin</code>, <code>$is_attachment</code>, <code>$is_singular</code>, <code>$is_robots</code>, <code>$is_posts_page</code>, <code>$is_paged</code><br> Booleans dictating what type of request this is. For example, the first three represent ‘is it a permalink?’, ‘is it a Page?’, ‘is it any type of archive page?’, respectively. See also <a href="https://developer.wordpress.org/themes/basics/conditional-tags/">Conditional Tags</a>.</li> </ul>  <h2 class="toc-heading" id="parameters" tabindex="-1">Parameters </h2> <h3 class="toc-heading" id="author-parameters" tabindex="-1">Author Parameters </h3> <p>Show posts associated with certain author.</p> <ul> <li>
<strong><code>author</code></strong> (<em>int</em>) – use author id.</li> <li>
<strong><code>author_name</code></strong> (<em>string</em>) – use ‘<code>user_nicename</code>‘ – NOT name.</li> <li>
<strong><code>author__in</code></strong> (<em>array</em>) – use author id (available since version 3.7).</li> <li>
<strong><code>author__not_in</code></strong> (<em>array</em>) – use author id (available since version 3.7).</li> </ul> <p><strong>Show Posts for one Author </strong></p> <p>Display posts by author, using author id:</p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'author' =&gt; 123 ) );</pre> <p>Display posts by author, using author ‘<code>user_nicename</code>‘:</p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'author_name' =&gt; 'rami' ) );</pre> <p><strong>Show Posts From Several Authors</strong></p> <p>Display posts from several specific authors:</p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'author' =&gt; '2,6,17,38' ) );</pre> <p><strong>Exclude Posts Belonging to an Author</strong></p> <p>Display all posts <em>except</em> those from an author(singular) by prefixing its id with a ‘-‘ (minus) sign:</p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'author' =&gt; -12 ) );</pre> <p><strong>Multiple Author Handling</strong></p> <p>Display posts from multiple authors:</p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'author__in' =&gt; array( 2, 6 ) ) );</pre> <p>You can also exclude multiple author this way:</p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'author__not_in' =&gt; array( 2, 6 ) ) );</pre>  <h3 class="toc-heading" id="category-parameters" tabindex="-1">Category Parameters </h3> <p>Show posts associated with certain categories.</p> <ul> <li>
<strong><code>cat</code></strong> (<em>int</em>) – use category id.</li> <li>
<strong><code>category_name</code></strong> (<em>string</em>) – use category slug.</li> <li>
<strong><code>category__and</code></strong> (<em>array</em>) – use category id.</li> <li>
<strong><code>category__in</code></strong> (<em>array</em>) – use category id.</li> <li>
<strong><code>category__not_in</code></strong> (<em>array</em>) – use category id.</li> </ul> <p><strong>Display posts that have one category (and any children of that category), using category id:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'cat' =&gt; 4 ) );</pre> <p><strong>Display posts that have this category (and any children of that category), using category slug:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'category_name' =&gt; 'staff' ) );</pre> <p><strong>Display posts that have this category (not children of that category), using category id:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'category__in' =&gt; 4 ) );</pre> <p><strong>Display posts that have several categories, using category id:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'cat' =&gt; '2,6,17,38' ) );</pre> <p><strong>Display posts that have these categories, using category slug:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'category_name' =&gt; 'staff,news' ) );</pre> <p><strong>Display posts that have “all” of these categories:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'category_name' =&gt; 'staff+news' ) );</pre> <p><strong>Display all posts <em>except</em> those from a category by prefixing its id with a ‘-‘ (minus) sign.</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'cat' =&gt; '-12,-34,-56' ) );</pre> <p><strong>Display posts that are in multiple categories. This shows posts that are in both categories 2 and 6:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'category__and' =&gt; array( 2, 6 ) ) );</pre> <p>To display posts from either category 2 OR 6, you could use <code>cat</code> as mentioned above, or by using <code>category__in</code> (note this does not show posts from any children of these categories):</p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'category__in' =&gt; array( 2, 6 ) ) );</pre> <p>You can also exclude multiple categories this way:</p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'category__not_in' =&gt; array( 2, 6 ) ) );</pre>  <h3 class="toc-heading" id="tag-parameters" tabindex="-1">Tag Parameters </h3> <p>Show posts associated with certain tags.</p> <ul> <li>
<strong><code>tag</code></strong> (<em>string</em>) – use tag slug.</li> <li>
<strong><code>tag_id</code></strong> (<em>int</em>) – use tag id.</li> <li>
<strong><code>tag__and</code></strong> (<em>array</em>) – use tag ids.</li> <li>
<strong><code>tag__in</code></strong> (<em>array</em>) – use tag ids.</li> <li>
<strong><code>tag__not_in</code></strong> (<em>array</em>) – use tag ids.</li> <li>
<strong><code>tag_slug__and</code></strong> (<em>array</em>) – use tag slugs.</li> <li>
<strong><code>tag_slug__in</code></strong> (<em>array</em>) – use tag slugs.</li> </ul> <p><strong>Display posts that have one tag, using tag slug:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'tag' =&gt; 'cooking' ) );</pre> <p><strong>Display posts that have this tag, using tag id:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'tag_id' =&gt; 13 ) );</pre> <p><strong>Display posts that have “either” of these tags:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'tag' =&gt; 'bread,baking' ) );</pre> <p><strong>Display posts that have “all” of these tags:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'tag' =&gt; 'bread+baking+recipe' ) );</pre> <p><strong>Display posts that are tagged with both tag id 37 and tag id 47:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'tag__and' =&gt; array( 37, 47 ) ) );</pre> <p>To display posts from either tag id 37 or 47, you could use <code>tag</code> as mentioned above, or explicitly specify by using <code>tag__in</code>:</p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'tag__in' =&gt; array( 37, 47 ) ) );</pre> <p><strong>Display posts that do not have any of the two tag ids 37 and 47:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'tag__not_in' =&gt; array( 37, 47 ) ) );</pre> <p>The <code>tag_slug__in</code> and <code>tag_slug__and</code> behave much the same, except match against the tag’s slug.</p>  <h3 class="toc-heading" id="taxonomy-parameters" tabindex="-1">Taxonomy Parameters </h3> <p>Show posts associated with certain taxonomy.</p> <ul> <li>
<strong><code>{tax}</code></strong> (<em>string</em>) – use taxonomy slug. (<strong>Deprecated</strong> since version 3.1 in favor of ‘<code>tax_query</code>‘).</li> <li>
<strong><code>tax_query</code></strong> (<em>array</em>) – use taxonomy parameters (available since version 3.1). <ul> <li>
<strong><code>relation</code></strong> (<em>string</em>) – The logical relationship between each inner taxonomy array when there is more than one. Possible values are ‘AND’, ‘OR’. Do not use with a single inner taxonomy array. <ul> <li>
<strong><code>taxonomy</code></strong> (<em>string</em>) – Taxonomy.</li> <li>
<strong><code>field</code></strong> (<em>string</em>) – Select taxonomy term by. Possible values are ‘term_id’, ‘name’, ‘slug’ or ‘term_taxonomy_id’. Default value is ‘term_id’.</li> <li>
<strong><code>terms</code></strong> (<em>int/string/array</em>) – Taxonomy term(s).</li> <li>
<strong><code>include_children</code></strong> (<em>boolean</em>) – Whether or not to include children for hierarchical taxonomies. Defaults to true.</li> <li>
<strong><code>operator</code></strong> (<em>string</em>) – Operator to test. Possible values are ‘IN’, ‘NOT IN’, ‘AND’, ‘EXISTS’ and ‘NOT EXISTS’. Default value is ‘IN’.</li> </ul> </li> </ul> </li> </ul> <p><strong>Important Note:</strong> <code>tax_query</code> takes an <strong>array</strong> of tax query arguments <strong>arrays</strong> (it takes an array of arrays).<br> This construct allows you to query multiple taxonomies by using the <strong><code>relation</code></strong> parameter in the first (outer) array to describe the boolean relationship between the taxonomy arrays.</p> <p><strong>Simple Taxonomy Query:</strong></p> <p>Display <strong>posts</strong> tagged with <strong>bob</strong>, under <strong>people</strong> custom taxonomy:</p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">
$args = array(
	'post_type' =&gt; 'post',
	'tax_query' =&gt; array(
		array(
			'taxonomy' =&gt; 'people',
			'field'    =&gt; 'slug',
			'terms'    =&gt; 'bob',
		),
	),
);
$query = new WP_Query( $args );
</pre> <p><strong>Multiple Taxonomy Handling:</strong></p> <p>Display <strong>posts</strong> from several custom taxonomies:</p> <section class="source-content"> <pre class="source-code-container" data-language="php">$args = array(
	'post_type' =&gt; 'post',
	'tax_query' =&gt; array(
		'relation' =&gt; 'AND',
		array(
			'taxonomy' =&gt; 'movie_genre',
			'field'    =&gt; 'slug',
			'terms'    =&gt; array( 'action', 'comedy' ),
		),
		array(
			'taxonomy' =&gt; 'actor',
			'field'    =&gt; 'term_id',
			'terms'    =&gt; array( 103, 115, 206 ),
			'operator' =&gt; 'NOT IN',
		),
	),
);
$query = new WP_Query( $args );</pre>  </section> <p>Display <strong>posts</strong> that are in the <strong>quotes</strong> category OR have the <strong>quote</strong> post format:</p> <section class="source-content"> <pre class="source-code-container" data-language="php">$args = array(
	'post_type' =&gt; 'post',
	'tax_query' =&gt; array(
		'relation' =&gt; 'OR',
		array(
			'taxonomy' =&gt; 'category',
			'field'    =&gt; 'slug',
			'terms'    =&gt; array( 'quotes' ),
		),
		array(
			'taxonomy' =&gt; 'post_format',
			'field'    =&gt; 'slug',
			'terms'    =&gt; array( 'post-format-quote' ),
		),
	),
);
$query = new WP_Query( $args );</pre>  </section> <p><strong>Nested Taxonomy Handling:</strong></p> <p>The <code>'tax_query'</code> clauses can be nested, to create more complex queries. Example: Display <strong>posts</strong> that are in the <strong>quotes</strong> category OR both have the <strong>quote</strong> post format AND are in the <strong>wisdom</strong> category:</p> <section class="source-content"> <pre class="source-code-container" data-language="php">$args = array(
	'post_type' =&gt; 'post',
	'tax_query' =&gt; array(
		'relation' =&gt; 'OR',
		array(
			'taxonomy' =&gt; 'category',
			'field'    =&gt; 'slug',
			'terms'    =&gt; array( 'quotes' ),
		),
		array(
                        'relation' =&gt; 'AND',
                        array(
			        'taxonomy' =&gt; 'post_format',
			        'field'    =&gt; 'slug',
			        'terms'    =&gt; array( 'post-format-quote' ),
                        ),
                        array(
                                'taxonomy' =&gt; 'category',
                                'field'    =&gt; 'slug',
                                'terms'    =&gt; array( 'wisdom' ),
                        ),
		),
	),
);
$query = new WP_Query( $args );</pre>  </section>  <h3 class="toc-heading" id="search-parameters" tabindex="-1">Search Parameters </h3> <p>Show posts based on a keyword search.</p> <ul> <li>
<strong><code>s</code></strong> (<em>string</em>) – Search keyword.</li> </ul> <p><strong>Show Posts based on a keyword search</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 's' =&gt; 'keyword' ) );</pre> <p>Prepending a term with a hyphen will exclude posts matching that term. Eg, <code>'pillow -sofa'</code> will return posts containing ‘pillow’ but not ‘sofa’ (available since Version 4.4).</p>  <h3 class="toc-heading" id="post-page-parameters" tabindex="-1">Post &amp; Page Parameters </h3> <p>Display content based on post and page parameters. Remember that default <code>post_type</code> is only set to display posts but not pages.</p> <ul> <li>
<strong><code>p</code></strong> (<em>int</em>) – use post id.</li> <li>
<strong><code>name</code></strong> (<em>string</em>) – use post slug.</li> <li>
<strong><code>page_id</code></strong> (<em>int</em>) – use page id.</li> <li>
<strong><code>pagename</code></strong> (<em>string</em>) – use page slug.</li> <li>
<strong><code>post_parent</code></strong> (<em>int</em>) – use page id to return only child pages. Set to 0 to return only top-level entries.</li> <li>
<strong><code>post_parent__in</code></strong> (<em>array</em>) – use post ids. Specify posts whose parent is in an array. (available since version 3.6)</li> <li>
<strong><code>post_parent__not_in</code></strong> (<em>array</em>) – use post ids. Specify posts whose parent is not in an array. (available since version 3.6)</li> <li>
<strong><code>post__in</code></strong> (<em>array</em>) – use post ids. Specify posts to retrieve. <strong>ATTENTION</strong> If you use sticky posts, they will be included (prepended!) in the posts you retrieve whether you want it or not. To suppress this behaviour use <code>ignore_sticky_posts</code>.</li> <li>
<strong><code>post__not_in</code></strong> (<em>array</em>) – use post ids. Specify post NOT to retrieve.</li> <li>
<strong><code>post_name__in</code></strong> (<em>array</em>) – use post slugs. Specify posts to retrieve. (Will be available in version 4.4)</li> </ul> <p><strong>NOTE:</strong> <a href="https://core.trac.wordpress.org/ticket/28099">Ticket #28099</a>: Passing an empty array to <code>post__in</code> will return <code>has_posts()</code> as true (and all posts will be returned). Logic should be used before hand to determine if <code>WP_Query</code> should be used in the event that the array being passed to <code>post__in</code> is empty.</p> <p><strong>Display post by ID:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'p' =&gt; 7 ) );</pre> <p><strong>Display page by ID:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'page_id' =&gt; 7 ) );</pre> <p><strong>Show post/page by slug</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'name' =&gt; 'about-my-life' ) );</pre> <p><strong>Display page by <code>slug</code>:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'pagename' =&gt; 'contact' ) );</pre> <p><strong>Display child page using the slug of the parent and the child page, separated by a slash (e.g. ‘parent_slug/child_slug’):</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'pagename' =&gt; 'contact_us/canada' ) );</pre> <p><strong>Display child pages using parent page ID:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'post_parent' =&gt; 93 ) );</pre> <p><strong>Display only top-level pages, exclude all child pages:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'post_parent' =&gt; 0 ) );</pre> <p><strong>Display posts whose parent is in an array:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'post_parent__in' =&gt; array( 2, 5, 12, 14, 20 ) ) );</pre> <p><strong>Display only the specific posts:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'post_type' =&gt; 'page', 'post__in' =&gt; array( 2, 5, 12, 14, 20 ) ) );</pre> <p><strong>Display all posts but NOT the specified ones:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'post_type' =&gt; 'post', 'post__not_in' =&gt; array( 2, 5, 12, 14, 20 ) ) );</pre> <p><strong>Note:</strong> you cannot combine <code>post__in</code> and <code>post__not_in</code> in the same query.</p> <p>Also note that using a string containing a comma separated list will not work here. If you’re passing a variable, make sure it’s a proper array of integer values:</p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">
// This will NOT work
$exclude_ids = '1,2,3';
$query = new WP_Query( array( 'post__not_in' =&gt; array( $exclude_ids ) ) );

// This WILL work
$exclude_ids = array( 1, 2, 3 );
$query = new WP_Query( array( 'post__not_in' =&gt; $exclude_ids ) );
</pre>  <h3 class="toc-heading" id="password-parameters" tabindex="-1">Password Parameters </h3> <p>Show content based on post and page parameters. Remember that default <code>post_type</code> is only set to display posts but not pages.</p> <ul> <li>
<strong><code>has_password</code></strong> (<em>bool</em>) – true for posts with passwords ; false for posts without passwords ; null for all posts with and without passwords (available since version 3.9).</li> <li>
<strong><code>post_password</code></strong> (<em>string</em>) – show posts with a particular password (available since version 3.9)</li> </ul> <p><strong>Display only password protected posts:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'has_password' =&gt; true ) );</pre> <p><strong>Display only posts without passwords:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'has_password' =&gt; false ) );</pre> <p><strong>Display only posts with and without passwords:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'has_password' =&gt; null ) );</pre> <p><strong>Display posts with a particular password:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'post_password' =&gt; 'zxcvbn' ) );</pre>  <h3 class="toc-heading" id="post-type-parameters" tabindex="-1">Post Type Parameters </h3> <p>Show posts associated with certain <a href="https://developer.wordpress.org/themes/basics/post-types/">type</a>.</p> <ul> <li>
<strong><code>post_type</code></strong> (<em>string</em> / <em>array</em>) – use post types. Retrieves posts by post types, default value is ‘<code>post</code>‘. If ‘<code>tax_query</code>‘ is set for a query, the default value becomes ‘<code>any</code>‘; <ul> <li>‘<code>post</code>‘ – a post.</li> <li>‘<code>page</code>‘ – a page.</li> <li>‘<code>revision</code>‘ – a revision.</li> <li>‘<code>attachment</code>‘ – an attachment. Whilst the default <a href="wp_query">WP_Query</a> <code>post_status</code> is ‘publish’, attachments have a default <code>post_status</code> of ‘inherit’. This means no attachments will be returned unless you also explicitly set <code>post_status</code> to ‘inherit’ or ‘any’. See <a href="#status-parameters">Status parameters</a> section below.</li> <li>‘<code>nav_menu_item</code>‘ – a navigation menu item</li> <li>‘<code>any</code>‘ – retrieves any type except revisions and types with ‘exclude_from_search’ set to true.<br> ** Custom Post Types (e.g. movies)</li> </ul> </li> </ul> <p><strong>Display only pages:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'post_type' =&gt; 'page' ) );</pre> <p><strong>Display ‘<code>any</code>‘ post type (retrieves any type except revisions and types with ‘exclude_from_search’ set to TRUE):</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'post_type' =&gt; 'any' ) );</pre> <p><strong>Display multiple post types, including custom post types:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">
$args = array(
	'post_type' =&gt; array( 'post', 'page', 'movie', 'book' )
);
$query = new WP_Query( $args );
</pre>  <h3 class="toc-heading" id="status-parameters" tabindex="-1">Status Parameters </h3> <p>Show posts associated with certain <a href="https://wordpress.org/support/article/post-status/">post status</a>.</p> <ul> <li>
<strong><code>post_status</code></strong> (<em>string</em> / <em>array</em>) – use post status. Retrieves posts by post status. Default value is ‘<code>publish</code>‘, but if the user is logged in, ‘<code>private</code>‘ is added. Public <a href="https://wordpress.org/support/article/post-status/#custom-status">custom post statuses</a> are also included by default. And if the query is run in an admin context (administration area or AJAX call), protected statuses are added too. By default protected statuses are ‘<code>future</code>‘, ‘<code>draft</code>‘ and ‘<code>pending</code>‘. <ul> <li>‘<code>publish</code>‘ – a published post or page.</li> <li>‘<code>pending</code>‘ – post is pending review.</li> <li>‘<code>draft</code>‘ – a post in draft status.</li> <li>‘<code>auto-draft</code>‘ – a newly created post, with no content.</li> <li>‘<code>future</code>‘ – a post to publish in the future.</li> <li>‘<code>private</code>‘ – not visible to users who are not logged in.</li> <li>‘<code>inherit</code>‘ – a revision. see <a href="../functions/get_children">get_children()</a>.</li> <li>‘<code>trash</code>‘ – post is in trashbin (available since version 2.9).</li> <li>‘<code>any</code>‘ – retrieves any status except those from post statuses with ‘exclude_from_search’ set to true (i.e. trash and auto-draft).</li> </ul> </li> </ul> <p><strong>Display only posts with the ‘<code>draft</code>‘ status:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'post_status' =&gt; 'draft' ) );</pre> <p><strong>Display multiple post status:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">
$args = array(
	'post_status' =&gt; array( 'pending', 'draft', 'future' )
);
$query = new WP_Query( $args );
</pre> <p><strong>Display all attachments:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">
$args = array(
	'post_status' =&gt; 'any',
	'post_type'   =&gt; 'attachment'
);
$query = new WP_Query( $args );
</pre>  <h3 class="toc-heading" id="comment-parameters" tabindex="-1">Comment Parameters </h3> <p>Since Version 4.9 Introduced the `$comment_count` parameter. It can be either an Integer or an Array.</p> <ul> <li>
<strong><code>comment_count</code></strong> (<em>int</em>) – The amount of comments your CPT has to have ( Search operator will do a ‘=’ operation )</li> <li>
<strong><code>comment_count</code></strong> (<em>Array</em>) – If comment_count is an array, it should have two arguments: <ul> <li>‘<code>value</code>‘ – The amount of comments your post has to have when comparing</li> <li>‘<code>compare</code>‘ – The search operator. Possible values are ‘=’, ‘!=’, ‘&gt;’, ‘&gt;=’, ‘&lt;‘, ‘&lt;=’. Default value is ‘=’.</li> </ul> </li> </ul> <p><strong>Display posts with with 20 comments: </strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">
$args = array(
	'post_type' =&gt; 'post',
	'comment_count' =&gt; 20,
	)
);
$query = new WP_Query( $args );
</pre> <p><strong>Display posts with with 25 comments or more:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">
$args = array(
	'post_type' =&gt; 'post',
	'comment_count' =&gt; array(
		'value' =&gt; 25,
		'compare' =&gt; '&gt;=',
	)
);
$query = new WP_Query( $args );
</pre>  <h3 class="toc-heading" id="pagination-parameters" tabindex="-1">Pagination Parameters </h3> <ul> <li>
<strong><code>nopaging</code></strong> (<em>boolean</em>) – show all posts or use pagination. Default value is ‘false’, use paging.</li> <li>
<strong><code>posts_per_page</code></strong> (<em>int</em>) – number of post to show per page (available since version 2.1, replaced <strong><code>showposts</code></strong> parameter). Use <code>'posts_per_page'=&gt;-1</code> to show all posts (the <code>'offset'</code> parameter is ignored with a <code>-1</code> value). Set the ‘paged’ parameter if pagination is off after using this parameter. <em>Note</em>: if the query is in a feed, wordpress overwrites this parameter with the stored ‘posts_per_rss’ option. To reimpose the limit, try using the ‘post_limits’ filter, or filter ‘pre_option_posts_per_rss’ and return -1</li> <li>
<strong><code>posts_per_archive_page</code></strong> (<em>int</em>) – number of posts to show per page – on archive pages only. Over-rides <strong><code>posts_per_page</code></strong> and <strong><code>showposts</code></strong> on pages where <a href="../functions/is_archive">is_archive()</a> or <a href="../functions/is_search">is_search()</a> would be true.</li> <li>
<strong><code>offset</code></strong> (<em>int</em>) – number of post to <em>displace</em> or pass over. <em>Warning</em>: Setting the offset parameter overrides/ignores the paged parameter and breaks pagination. The <code>'offset'</code> parameter is ignored when <code>'posts_per_page'=&gt;-1</code> (show all posts) is used.</li> <li>
<strong><code>paged</code></strong> (<em>int</em>) – number of page. Show the posts that would normally show up just on page X when using the “Older Entries” link.</li> <li>
<strong><code>page</code></strong> (<em>int</em>) – number of page for a static front page. Show the posts that would normally show up just on page X of a Static Front Page.</li> <li>
<strong><code>ignore_sticky_posts</code></strong> (<em>boolean</em>) – ignore post stickiness (available since version 3.1, replaced <strong><code>caller_get_posts</code></strong> parameter). <code>false</code> (default): move sticky posts to the start of the set. <code>true</code>: do not move sticky posts to the start of the set.</li> </ul> <p><strong>Display x posts per page:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'posts_per_page' =&gt; 3 ) );</pre> <p><strong>Display all posts in one page:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'posts_per_page' =&gt; -1 ) );</pre> <p><strong>Display all posts by disabling pagination:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'nopaging' =&gt; true ) );</pre> <p><strong>Display posts from the 4th one:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'offset' =&gt; 3 ) );</pre> <p><strong>Display 5 posts per page which follow the 3 most recent posts:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'posts_per_page' =&gt; 5, 'offset' =&gt; 3 ) );</pre> <p><strong>Display posts from page number x:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'paged' =&gt; 6 ) );</pre> <p><strong>Display posts from current page:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'paged' =&gt; get_query_var( 'paged' ) ) );</pre> <p><span id="set-paged">Display posts from the current page and set the ‘paged’ parameter to 1 when the query variable is not set (first page).</span></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">
$paged = ( get_query_var('paged') ) ? get_query_var('paged') : 1;
$query = new WP_Query( array( 'paged' =&gt; $paged ) );
</pre> <p>Pagination Note: Use <code>get_query_var('page');</code> if you want your query to work in a <a href="https://developer.wordpress.org/themes/template-files-section/page-template-files/">page template</a> that you’ve set as your <a href="https://wordpress.org/support/article/creating-a-static-front-page/">static front page</a>. The query variable ‘page’ also holds the pagenumber for a single paginated Post or Page that includes the <code>&lt;!--nextpage--&gt;</code> quicktag in the post content.</p> <p><strong>Display posts from current page on a <a href="https://wordpress.org/support/article/creating-a-static-front-page/">static front page</a>:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">
$paged = ( get_query_var('page') ) ? get_query_var('page') : 1;
$query = new WP_Query( array( 'paged' =&gt; $paged ) );
</pre> <p><strong>Display just the first sticky post:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">
$sticky = get_option( 'sticky_posts' );
$query = new WP_Query( array( 'p' =&gt; $sticky[0] ) );
</pre> <p><strong>Display just the first sticky post, if none return the last post published:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">
$args = array(
	'posts_per_page'      =&gt; 1,
	'post__in'            =&gt; get_option( 'sticky_posts' ),
	'ignore_sticky_posts' =&gt; 1,
);
$query = new WP_Query( $args );
</pre> <p><strong>Display just the first sticky post, if none return nothing:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">
$sticky = get_option( 'sticky_posts' );
$args = array(
	'posts_per_page'      =&gt; 1,
	'post__in'            =&gt; $sticky,
	'ignore_sticky_posts' =&gt; 1,
);
$query = new WP_Query( $args );
if ( $sticky[0] ) {
	// insert here your stuff...
}
</pre> <p><strong>Exclude all sticky posts from the query:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'post__not_in' =&gt; get_option( 'sticky_posts' ) ) );</pre> <p><strong>Exclude sticky posts from a category:</strong></p> <p>Return ALL posts within the category, but don’t show sticky posts at the top. The ‘sticky posts’ will still show in their natural position (e.g. by date):</p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'ignore_sticky_posts' =&gt; 1, 'posts_per_page' =&gt; 3, 'cat' =&gt; 6 );</pre> <p><strong>Exclude sticky posts from a category:</strong></p> <p>Return posts within the category, but exclude sticky posts completely, and adhere to paging rules:</p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">
$paged = get_query_var( 'paged' ) ? get_query_var( 'paged' ) : 1;
$sticky = get_option( 'sticky_posts' );
$args = array(
	'cat'                 =&gt; 3,
	'ignore_sticky_posts' =&gt; 1,
	'post__not_in'        =&gt; $sticky,
	'paged'               =&gt; $paged,
);
$query = new WP_Query( $args );
</pre>  <h3 class="toc-heading" id="order-orderby-parameters" tabindex="-1">Order &amp; Orderby Parameters </h3> <p>Sort retrieved posts.</p> <ul> <li>
<strong><code>order</code></strong> (<em>string | array</em>) – Designates the ascending or descending order of the ‘<code>orderby</code>‘ parameter. Defaults to ‘DESC’. An array can be used for multiple order/orderby sets. <ul> <li>‘<code>ASC</code>‘ – ascending order from lowest to highest values (1, 2, 3; a, b, c).</li> <li>‘<code>DESC</code>‘ – descending order from highest to lowest values (3, 2, 1; c, b, a).</li> </ul> </li> <li>
<strong><code>orderby</code></strong> (<em>string | array</em>) – Sort retrieved posts by parameter. Defaults to ‘date (post_date)’. One or more options can be passed. <ul> <li>‘<code>none</code>‘ – No order (available since version 2.8).</li> <li>‘<code>ID</code>‘ – Order by post id. Note the capitalization.</li> <li>‘<code>author</code>‘ – Order by author.</li> <li>‘<code>title</code>‘ – Order by title.</li> <li>‘<code>name</code>‘ – Order by post name (post slug).</li> <li>‘<code>type</code>‘ – Order by post type (available since version 4.0).</li> <li>‘<code>date</code>‘ – Order by date.</li> <li>‘<code>modified</code>‘ – Order by last modified date.</li> <li>‘<code>parent</code>‘ – Order by post/page parent id.</li> <li>‘<code>rand</code>‘ – Random order.</li> <li>‘<code>comment_count</code>‘ – Order by number of comments (available since version 2.9).</li> <li>‘<code>relevance</code>‘ – Order by search terms in the following order: First, whether the entire sentence is matched. Second, if all the search terms are within the titles. Third, if any of the search terms appear in the titles. And, fourth, if the full sentence appears in the contents.</li> <li>‘<code>menu_order</code>‘ – Order by Page Order. Used most often for pages (<em>Order</em> field in the Edit Page Attributes box) and for attachments (the integer fields in the Insert / Upload Media Gallery dialog), but could be used for any post type with distinct ‘<code>menu_order</code>‘ values (they all default to <var>0</var>).</li> <li>‘<code>meta_value</code>‘ – Note that a ‘<code>meta_key=keyname</code>‘ must also be present in the query. Note also that the sorting will be alphabetical which is fine for strings (i.e. words), but can be unexpected for numbers (e.g. 1, 3, 34, 4, 56, 6, etc, rather than 1, 3, 4, 6, 34, 56 as you might naturally expect). Use ‘<code>meta_value_num</code>‘ instead for numeric values. You may also specify ‘<code>meta_type</code>‘ if you want to cast the meta value as a specific type. Possible values are ‘NUMERIC’, ‘BINARY’, ‘CHAR’, ‘DATE’, ‘DATETIME’, ‘DECIMAL’, ‘SIGNED’, ‘TIME’, ‘UNSIGNED’, same as in ‘<code>$meta_query</code>‘. When using ‘meta_type’ you can also use ‘meta_value_*’ accordingly. For example, when using DATETIME as ‘meta_type’ you can use ‘meta_value_datetime’ to define order structure.</li> <li>‘<code>meta_value_num</code>‘ – Order by numeric meta value (available since version 2.8). Also note that a ‘<code>meta_key=keyname</code>‘ must also be present in the query. This value allows for numerical sorting as noted above in ‘<code>meta_value</code>‘.</li> <li>‘<code>post__in</code>‘ – Preserve post ID order given in the post__in array (available since version 3.5). Note – the value of the order parameter does not change the resulting sort order.</li> <li>‘<code>post_name__in</code>‘ – Preserve post slug order given in the ‘post_name__in’ array (available since Version 4.6). Note – the value of the order parameter does not change the resulting sort order.</li> <li>‘<code>post_parent__in</code>‘ -Preserve post parent order given in the ‘post_parent__in’ array (available since Version 4.6). Note – the value of the order parameter does not change the resulting sort order.</li> </ul> </li> </ul> <p><strong>Display posts sorted by post ‘title’ in a descending order:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">
$args = array(
	'orderby' =&gt; 'title',
	'order'   =&gt; 'DESC',
);
$query = new WP_Query( $args );
</pre> <p><strong>Display posts sorted by ‘menu_order’ with a fallback to post ‘title’, in a descending order:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">
$args = array(
	'orderby' =&gt; 'menu_order title',
	'order'   =&gt; 'DESC',
);
$query = new WP_Query( $args );
</pre> <p><strong>Display one random post:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">
$args = array(
	'orderby'        =&gt; 'rand',
	'posts_per_page' =&gt; '1',

);
$query = new WP_Query( $args );
</pre> <p><strong>Display posts ordered by comment count (popularity):</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">
$args = array(
	'orderby' =&gt; 'comment_count'
);
$query = new WP_Query( $args );
</pre> <p><strong>Display posts with ‘Product’ type ordered by ‘Price’ custom field:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">
$args = array(
	'post_type' =&gt; 'product',
	'orderby'   =&gt; 'meta_value_num',
	'meta_key'  =&gt; 'price',
);
$query = new WP_Query( $args );
</pre> <p><strong>Display pages ordered by ‘title’ and ‘menu_order’. (title is dominant):</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">
$args = array(
	'post_type' =&gt; 'page',
	'orderby'   =&gt; 'title menu_order',
	'order'     =&gt; 'ASC',
);
$query = new WP_Query( $args );
</pre> <p><strong>Display pages ordered by ‘title’ and ‘menu_order’ with different sort orders (ASC/DESC) (available since version 4.0):</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">
$args = array(
	'orderby' =&gt; array( 'title' =&gt; 'DESC', 'menu_order' =&gt; 'ASC' )
);
$query = new WP_Query( $args );
</pre> <p>Related article: <a href="https://make.wordpress.org/core/2014/08/29/a-more-powerful-order-by-in-wordpress-4-0/">A more powerful ORDER BY in WordPress 4.0</a>.</p> <p><strong>Mulitiple orderby/order pairs</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">
$args = array(
	'orderby'  =&gt; array( 'meta_value_num' =&gt; 'DESC', 'title' =&gt; 'ASC' ),
	'meta_key' =&gt; 'age'
);
$query = new WP_Query( $args );
</pre> <p><strong>‘orderby’ with ‘meta_value’ and custom post type</strong></p> <p>Display posts of type ‘my_custom_post_type’, ordered by ‘age’, and filtered to show only ages 3 and 4 (using meta_query).</p> <section class="source-content"> <pre class="source-code-container" data-language="php">$args = array(
	'post_type'  =&gt; 'my_custom_post_type',
	'meta_key'   =&gt; 'age',
	'orderby'    =&gt; 'meta_value_num',
	'order'      =&gt; 'ASC',
	'meta_query' =&gt; array(
		array(
			'key'     =&gt; 'age',
			'value'   =&gt; array( 3, 4 ),
			'compare' =&gt; 'IN',
		),
	),
);
$query = new WP_Query( $args );</pre>  </section> <p><strong>‘orderby’ with multiple ‘meta_key’s</strong></p> <p>If you wish to order by two different pieces of postmeta (for example, City first and State second), you need to combine and link your meta query to your orderby array using ‘named meta queries’. See the example below:</p> <section class="source-content"> <pre class="source-code-container" data-language="php">$q = new WP_Query( array(
    'meta_query' =&gt; array(
        'relation' =&gt; 'AND',
        'state_clause' =&gt; array(
            'key' =&gt; 'state',
            'value' =&gt; 'Wisconsin',
        ),
        'city_clause' =&gt; array(
            'key' =&gt; 'city',
            'compare' =&gt; 'EXISTS',
        ), 
    ),
    'orderby' =&gt; array( 
        'city_clause' =&gt; 'ASC',
        'state_clause' =&gt; 'DESC',
    ),
) );</pre>  </section> <p>(props to cybmeta on WPSE for <a href="http://wordpress.stackexchange.com/a/246358/3687">this example</a>).</p>  <h3 class="toc-heading" id="date-parameters" tabindex="-1">Date Parameters </h3> <p>Show posts associated with a certain time and date period.</p> <ul> <li>
<strong><code>year</code></strong> (<em>int</em>) – 4 digit year (e.g. 2011).</li> <li>
<strong><code>monthnum</code></strong> (<em>int</em>) – Month number (from 1 to 12).</li> <li>
<strong><code>w</code></strong> (<em>int</em>) – Week of the year (from 0 to 53). Uses <a href="http://dev.mysql.com/doc/refman/5.1/en/date-and-time-functions.html#function_week">MySQL WEEK command</a>. The mode is dependent on the “start_of_week” option.</li> <li>
<strong><code>day</code></strong> (<em>int</em>) – Day of the month (from 1 to 31).</li> <li>
<strong><code>hour</code></strong> (<em>int</em>) – Hour (from 0 to 23).</li> <li>
<strong><code>minute</code></strong> (<em>int</em>) – Minute (from 0 to 60).</li> <li>
<strong><code>second</code></strong> (<em>int</em>) – Second (0 to 60).</li> <li>
<strong><code>m</code></strong> (<em>int</em>) – YearMonth (For e.g.: <strong><code>201307</code></strong>).</li> <li>
<strong><code>date_query</code></strong> (<em>array</em>) – Date parameters (available since version 3.7). <ul> <li>
<strong><code>year</code></strong> (<em>int</em>) – 4 digit year (e.g. 2011).</li> <li>
<strong><code>month</code></strong> (<em>int</em>) – Month number (from 1 to 12).</li> <li>
<strong><code>week</code></strong> (<em>int</em>) – Week of the year (from 0 to 53).</li> <li>
<strong><code>day</code></strong> (<em>int</em>) – Day of the month (from 1 to 31).</li> <li>
<strong><code>hour</code></strong> (<em>int</em>) – Hour (from 0 to 23).</li> <li>
<strong><code>minute</code></strong> (<em>int</em>) – Minute (from 0 to 59).</li> <li>
<strong><code>second</code></strong> (<em>int</em>) – Second (0 to 59).</li> <li>
<strong><code>after</code></strong> (<em>string/array</em>) – Date to retrieve posts after. Accepts <code><a href="http://php.net/strtotime">strtotime()</a></code>-compatible string, or array of ‘year’, ‘month’, ‘day’ values: <ul> <li>
<strong><code>year</code></strong> (<em>string</em>) Accepts any four-digit year. Default is empty.</li> <li>
<strong><code>month</code></strong> (<em>string</em>) The month of the year. Accepts numbers 1-12. Default: 12.</li> <li>
<strong><code>day</code></strong> (<em>string</em>) The day of the month. Accepts numbers 1-31. Default: last day of month.</li> </ul> </li> <li>
<strong><code>before</code></strong> (<em>string/array</em>) – Date to retrieve posts before. Accepts <code><a href="http://php.net/strtotime">strtotime()</a></code>-compatible string, or array of ‘year’, ‘month’, ‘day’ values: <ul> <li>
<strong><code>year</code></strong> (<em>string</em>) Accepts any four-digit year. Default is empty.</li> <li>
<strong><code>month</code></strong> (<em>string</em>) The month of the year. Accepts numbers 1-12. Default: 1.</li> <li>
<strong><code>day</code></strong> (<em>string</em>) The day of the month. Accepts numbers 1-31. Default: 1.</li> </ul> </li> <li>
<strong><code>inclusive</code></strong> (<em>boolean</em>) – For after/before, whether exact value should be matched or not’.</li> <li>
<strong><code>compare</code></strong> (<em>string</em>) – See <a href="wp_date_query/get_compare">WP_Date_Query::get_compare()</a>.</li> <li>
<strong><code>column</code></strong> (<em>string</em>) – Posts column to query against. Default: ‘post_date’.</li> <li>
<strong><code>relation</code></strong> (<em>string</em>) – OR or AND, how the sub-arrays should be compared. Default: AND.</li> </ul> </li> </ul> <p><strong>Returns posts dated December 12, 2012:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">
$query = new WP_Query( 'year=2012&amp;monthnum=12&amp;day=12' );
</pre> <p>or:</p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">
$args = array(
	'date_query' =&gt; array(
		array(
			'year'  =&gt; 2012,
			'month' =&gt; 12,
			'day'   =&gt; 12,
		),
	),
);
$query = new WP_Query( $args );
</pre> <p><strong>Returns posts for today:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">
$today = getdate();
$query = new WP_Query( 'year=' . $today['year'] . '&amp;monthnum=' . $today['mon'] . '&amp;day=' . $today['mday'] );
</pre> <p>or:</p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">
$today = getdate();
$args = array(
	'date_query' =&gt; array(
		array(
			'year'  =&gt; $today['year'],
			'month' =&gt; $today['mon'],
			'day'   =&gt; $today['mday'],
		),
	),
);
$query = new WP_Query( $args );
</pre> <p><strong>Returns posts for this week:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">
$week = date( 'W' );
$year = date( 'Y' );
$query = new WP_Query( 'year=' . $year . '&amp;w=' . $week );
</pre> <p>or:</p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">
$args = array(
	'date_query' =&gt; array(
		array(
			'year' =&gt; date( 'Y' ),
			'week' =&gt; date( 'W' ),
		),
	),
);
$query = new WP_Query( $args );
</pre> <p><strong>Return posts between 9AM to 5PM on weekdays</strong></p> <section class="source-content"> <pre class="source-code-container" data-language="php">$args = array(
	'date_query' =&gt; array(
		array(
			'hour'      =&gt; 9,
			'compare'   =&gt; '&gt;=',
		),
		array(
			'hour'      =&gt; 17,
			'compare'   =&gt; '&lt;=',
		),
		array(
			'dayofweek' =&gt; array( 2, 6 ),
			'compare'   =&gt; 'BETWEEN',
		),
	),
	'posts_per_page' =&gt; -1,
);
$query = new WP_Query( $args );</pre>  </section> <p><strong>Return posts from January 1st to February 28th</strong></p> <section class="source-content"> <pre class="source-code-container" data-language="php">$args = array(
	'date_query' =&gt; array(
		array(
			'after'     =&gt; 'January 1st, 2013',
			'before'    =&gt; array(
				'year'  =&gt; 2013,
				'month' =&gt; 2,
				'day'   =&gt; 28,
			),
			'inclusive' =&gt; true,
		),
	),
	'posts_per_page' =&gt; -1,
);
$query = new WP_Query( $args );</pre>  </section> <p>Note that if a <code><a href="http://php.net/strtotime">strtotime()</a></code>-compatible string with just a date was passed in the <code>before</code> parameter, this will be converted to 00:00:00 on that date. In this case, even if <code>inclusive</code> was set to true, the date would not be included in the query. If you want a before date to be inclusive, include the time as well, such as <code>'before' =&gt; '2013-02-28 23:59:59'</code>, or use the array format, which is adjusted automatically if <code>inclusive</code> is set.</p> <p><strong>Return posts made over a year ago but modified in the past month</strong></p> <section class="source-content"> <pre class="source-code-container" data-language="php">$args = array(
	'date_query' =&gt; array(
		array(
			'column' =&gt; 'post_date_gmt',
			'before' =&gt; '1 year ago',
		),
		array(
			'column' =&gt; 'post_modified_gmt',
			'after'  =&gt; '1 month ago',
		),
	),
	'posts_per_page' =&gt; -1,
);
$query = new WP_Query( $args );</pre>  </section> <p>The <code>'date_query'</code> clauses can be nested, in order to construct complex queries. See <a href="#taxonomy-parameters">Taxonomy Parameters</a> for details on the syntax.</p>  <h3 class="toc-heading" id="custom-field-post-meta-parameters" tabindex="-1">Custom Field (post meta) Parameters </h3> <p>Show posts associated with a certain custom field.</p> <p>This part of the query is parsed by <a href="wp_meta_query">WP_Meta_Query</a>, so check the docs for it as well in case this list of arguments isn’t up to date.</p> <ul> <li>
<strong><code>meta_key</code></strong> (<em>string</em>) – Custom field key.</li> <li>
<strong><code>meta_value</code></strong> (<em>string</em>) – Custom field value.</li> <li>
<strong><code>meta_value_num</code></strong> (<em>number</em>) – Custom field value.</li> <li>
<strong><code>meta_compare</code></strong> (<em>string</em>) – Operator to test the ‘<code>meta_value</code>‘. Possible values are ‘=’, ‘!=’, ‘&gt;’, ‘&gt;=’, ‘&lt;‘, ‘&lt;=’, ‘LIKE’, ‘NOT LIKE’, ‘IN’, ‘NOT IN’, ‘BETWEEN’, ‘NOT BETWEEN’, ‘NOT EXISTS’, ‘REGEXP’, ‘NOT REGEXP’ or ‘RLIKE’. Default value is ‘=’.</li> <li>
<strong><code>meta_query</code></strong> (<em>array</em>) – Custom field parameters (available since version 3.1). <ul> <li>
<strong><code>relation</code></strong> (<em>string</em>) – The logical relationship between each inner meta_query array when there is more than one. Possible values are ‘AND’, ‘OR’. Do not use with a single inner meta_query array.</li> </ul> </li> </ul> <p><code>meta_query</code> also contains one or more arrays with the following keys:</p> <ul> <li>
<strong><code>key</code></strong> (<em>string</em>) – Custom field key.</li> <li>
<strong><code>value</code></strong> (<em>string</em>|<em>array</em>) – Custom field value. It can be an array only when <code><strong>compare</strong></code> is <code>'IN'</code>, <code>'NOT IN'</code>, <code>'BETWEEN'</code>, or <code>'NOT BETWEEN'</code>. You don’t have to specify a value when using the <code>'EXISTS'</code> or <code>'NOT EXISTS'</code> comparisons in WordPress 3.9 and up.<br> (<strong>Note:</strong> Due to <a href="https://core.trac.wordpress.org/ticket/23268">bug #23268</a>, <code>value</code> is required for <code>NOT EXISTS</code> comparisons to work correctly prior to 3.9. You must supply <em>some</em> string for the <code>value</code> parameter. An empty string or NULL will NOT work. However, any other string will do the trick and will NOT show up in your SQL when using <code>NOT EXISTS</code>. Need inspiration? How about <code>'bug #23268'</code>.)</li> <li>
<strong><code>compare</code></strong> (<em>string</em>) – Operator to test. Possible values are ‘=’, ‘!=’, ‘&gt;’, ‘&gt;=’, ‘&lt;‘, ‘&lt;=’, ‘LIKE’, ‘NOT LIKE’, ‘IN’, ‘NOT IN’, ‘BETWEEN’, ‘NOT BETWEEN’, ‘EXISTS’ and ‘NOT EXISTS’. Default value is ‘=’.</li> <li>
<strong><code>type</code></strong> (<em>string</em>) – Custom field type. Possible values are ‘NUMERIC’, ‘BINARY’, ‘CHAR’, ‘DATE’, ‘DATETIME’, ‘DECIMAL’, ‘SIGNED’, ‘TIME’, ‘UNSIGNED’. Default value is ‘CHAR’.</li> </ul> <p>The ‘type’ DATE works with the ‘compare’ value BETWEEN only if the date is stored at the format YYYY-MM-DD and tested with this format.</p> <p><strong>Important Note:</strong> <code>meta_query</code> takes an <strong>array</strong> of meta query arguments <strong>arrays</strong> (it takes an array of arrays) – you can see this in the examples below.<br> This construct allows you to query multiple metadatas by using the <strong><code>relation</code></strong> parameter in the first (outer) array to describe the boolean relationship between the meta queries. Accepted arguments are ‘AND’, ‘OR’. The default is ‘AND’.</p> <p><strong>Simple Custom Field Query:</strong></p> <p>Display posts where the custom field key is ‘color’, regardless of the custom field value:</p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'meta_key' =&gt; 'color' ) );</pre> <p>Display posts where the custom field value is ‘blue’, regardless of the custom field key:</p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">$query = new WP_Query( array( 'meta_value' =&gt; 'blue' ) );</pre> <p>Display page where the custom field value is ‘blue’, regardless of the custom field key:</p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">
$args = array(
	'meta_value' =&gt; 'blue',
	'post_type'  =&gt; 'page'
);
$query = new WP_Query( $args );
</pre> <p>Display posts where the custom field key is ‘color’ and the custom field value is ‘blue’:</p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">
$args = array(
	'meta_key'   =&gt; 'color',
	'meta_value' =&gt; 'blue'
);
$query = new WP_Query( $args );
</pre> <p>Display posts where the custom field key is ‘color’ and the custom field value IS NOT ‘blue’:</p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">
$args = array(
	'meta_key'     =&gt; 'color',
	'meta_value'   =&gt; 'blue',
	'meta_compare' =&gt; '!='
);
$query = new WP_Query( $args );
</pre> <p>Display posts where the custom field key is a set date and the custom field value is now. Displays only posts which date has not passed.</p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">
$args = array(
	'post_type'    =&gt; 'event',
	'meta_key'     =&gt; 'event_date',
	'meta_value'   =&gt; date( "Ymd" ), // change to how "event date" is stored
	'meta_compare' =&gt; '&gt;',
);
$query = new WP_Query( $args );
</pre> <p>Display ‘product'(s) where the custom field key is ‘price’ and the custom field value that is LESS THAN OR EQUAL TO 22.<br> <em>By using the ‘meta_value’ parameter the value 99 will be considered greater than 100 as the data are stored as ‘strings’, not ‘numbers’. For number comparison use ‘meta_value_num’.</em></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">
$args = array(
	'meta_key'     =&gt; 'price',
	'meta_value'   =&gt; '22',
	'meta_compare' =&gt; '&lt;=',
	'post_type'    =&gt; 'product'
);
$query = new WP_Query( $args );
</pre> <p>Display posts with a custom field value of zero (0), regardless of the custom field key:</p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">
$args = array(
	'meta_value' =&gt; '_wp_zero_value'
);
$query = new WP_Query( $args );
</pre> <p><strong>Display posts from a single custom field:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">
$args = array(
	'post_type'  =&gt; 'product',
	'meta_query' =&gt; array(
		array(
			'key'     =&gt; 'color',
			'value'   =&gt; 'blue',
			'compare' =&gt; 'NOT LIKE',
		),
	),
);
$query = new WP_Query( $args );
</pre> <p>(Note that meta_query expects nested arrays, even if you only have one query.)</p> <p><strong>Display posts from several custom fields:</strong></p> <section class="source-content"> <pre class="source-code-container" data-language="php">$args = array(
	'post_type'  =&gt; 'product',
	'meta_query' =&gt; array(
		array(
			'key'     =&gt; 'color',
			'value'   =&gt; 'blue',
			'compare' =&gt; 'NOT LIKE',
		),
		array(
			'key' =&gt; 'price',
			'value'   =&gt; array( 20, 100 ),
			'type'    =&gt; 'numeric',
			'compare' =&gt; 'BETWEEN',
		),
	),
);
$query = new WP_Query( $args );</pre>  </section> <p><strong>Display posts that have meta key ‘color’ NOT LIKE value ‘blue’ OR meta key ‘price’ with values BETWEEN 20 and 100:</strong></p> <section class="source-content"> <pre class="source-code-container" data-language="php">$args = array(
	'post_type'  =&gt; 'product',
	'meta_query' =&gt; array(
		'relation' =&gt; 'OR',
		array(
			'key'     =&gt; 'color',
			'value'   =&gt; 'blue',
			'compare' =&gt; 'NOT LIKE',
		),
		array(
			'key'     =&gt; 'price',
			'value'   =&gt; array( 20, 100 ),
			'type'    =&gt; 'numeric',
			'compare' =&gt; 'BETWEEN',
		),
	),
);
$query = new WP_Query( $args );</pre>  </section> <p>The <code>'meta_query'</code> clauses can be nested in order to construct complex queries. For example, show productss where <strong>color=orange</strong> OR <strong>color=red&amp;size=small</strong> translates to the following:</p> <section class="source-content"> <pre class="source-code-container" data-language="php">$args = array(
	'post_type'  =&gt; 'product',
	'meta_query' =&gt; array(
		'relation' =&gt; 'OR',
		array(
			'key'     =&gt; 'color',
			'value'   =&gt; 'orange',
			'compare' =&gt; '=',
		),
                array(
                        'relation' =&gt; 'AND',
                        array(
                                'key' =&gt; 'color',
                                'value' =&gt; 'red',
                                'compare' =&gt; '=',
                        ),
                        array(
                                'key' =&gt; 'size',
                                'value' =&gt; 'small',
                                'compare' =&gt; '=',
                        ),
		),
	),
);
$query = new WP_Query( $args );</pre>  </section>  <h3 class="toc-heading" id="permission-parameters" tabindex="-1">Permission Parameters </h3> <p>Show posts if user has the appropriate capability</p> <ul> <li>
<strong><code>perm</code></strong> (<em>string</em>) – User permission.</li> </ul> <p><strong>Display published and private posts, if the user has the appropriate capability:</strong></p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">
$args = array(
	'post_status' =&gt; array( 'publish', 'private' ),
	'perm'        =&gt; 'readable',
);
$query = new WP_Query( $args );
</pre>  <h3 class="toc-heading" id="mime-type-parameters" tabindex="-1">Mime Type Parameters </h3> <p>Used with the attachments post type.</p> <ul> <li>
<strong><code>post_mime_type</code></strong> (<em>string/array</em>) – Allowed mime types.</li> </ul> <p><strong>Get attachments that are <em>gif</em> images:</strong></p> <p>Get gif images and remember that by default the attachment’s post_status is set to <strong>inherit</strong>.</p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">
$args = array(
	'post_type'	 =&gt; 'attachment',
	'post_status'	 =&gt; 'inherit',
	'post_mime_type' =&gt; 'image/gif',
);
$query = new WP_Query( $args );
</pre> <p><strong>Get attachments that are not images:</strong></p> <p>To exclude certain mime types you first need to get all mime types using <a href="../functions/get_allowed_mime_types">get_allowed_mime_types()</a> and run a difference between arrays of what you want and the allowed mime types with <code><a href="http://php.net/manual/en/function.array-diff.php">array_diff()</a></code>.</p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">
$unsupported_mimes  = array( 'image/jpeg', 'image/gif', 'image/png', 'image/bmp', 'image/tiff', 'image/x-icon' );
$all_mimes          = get_allowed_mime_types();
$accepted_mimes     = array_diff( $all_mimes, $unsupported_mimes );
$args		    = array(
    'post_type'         =&gt; 'attachment',
    'post_status'       =&gt; 'inherit',
    'post_mime_type'    =&gt; $accepted_mimes,
);
$query		    = new WP_Query( $query_args );
</pre>  <h3 class="toc-heading" id="caching-parameters" tabindex="-1">Caching Parameters </h3> <p>Stop the data retrieved from being added to the cache.</p> <ul> <li>
<strong><code>cache_results</code></strong> (<em>boolean</em>) – Post information cache.</li> <li>
<strong><code>update_post_meta_cache</code></strong> (<em>boolean</em>) – Post meta information cache.</li> <li>
<strong><code>update_post_term_cache</code></strong> (<em>boolean</em>) – Post term information cache.</li> </ul> <p><strong>Show Posts without adding post information to the cache</strong></p> <p>Display 50 posts, but don’t add post information to the cache:</p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">
$args = array(
	'posts_per_page' =&gt; 50,
	'cache_results'  =&gt; false
);
$query = new WP_Query( $args );
</pre> <p><strong>Show Posts without adding post meta information to the cache</strong></p> <p>Display 50 posts, but don’t add post meta information to the cache:</p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">
$args = array(
	'posts_per_page'         =&gt; 50,
	'update_post_meta_cache' =&gt; false
);
$query = new WP_Query( $args );
</pre> <p><strong>Show Posts without adding post term information to the cache</strong></p> <p>Display 50 posts, but don’t add post term information to the cache:</p> <pre class="brush: php; title: ; notranslate" title="" data-language="php">
$args = array(
	'posts_per_page'         =&gt; 50,
	'update_post_term_cache' =&gt; false
);
$query = new WP_Query( $args );
</pre> <p>In general usage you should not need to use these, adding to the cache is the right thing to do, however they may be useful in specific circumstances. An example of such circumstances might be when using a <a href="wp_query">WP_Query</a> to retrieve a list of post titles and URLs to be displayed, but in which no other information about the post will be used and the taxonomy and meta data won’t be needed. By not loading this information, you can save time from the extra unnecessary SQL queries.</p> <p><strong>Note</strong>: If a persistent object cache backend (such as memcached) is used, these flags are set to false by default since there is no need to update the cache every page load when a persistent cache exists.</p>  <h3 class="toc-heading" id="return-fields-parameter" tabindex="-1">Return Fields Parameter </h3> <p>Set return values.</p> <ul> <li>
<strong><code>fields</code></strong> (<em>string</em>) – Which fields to return. There are three options: <ul> <li>
<strong><code>'all'</code></strong> – Return all fields (default).</li> <li>
<strong><code>'ids'</code></strong> – Return an array of post IDs.</li> <li>
<strong><code>'id=&gt;parent'</code></strong> – Return an array of stdClass objects with ID and post_parent properties.</li> </ul> </li> </ul> <p>Passing anything else will return all fields (default) – an array of post objects.</p> </section>  <section class="source-content"> <h2 class="toc-heading" id="source" tabindex="-1">Source </h2> <p> File: <a href="https://developer.wordpress.org/reference/files/wp-includes/class-wp-query.php/">wp-includes/class-wp-query.php</a> </p> <pre class="source-code-container" data-language="php">class WP_Query {

	/**
	 * Query vars set by the user
	 *
	 * @since 1.5.0
	 * @var array
	 */
	public $query;

	/**
	 * Query vars, after parsing
	 *
	 * @since 1.5.0
	 * @var array
	 */
	public $query_vars = array();

	/**
	 * Taxonomy query, as passed to get_tax_sql()
	 *
	 * @since 3.1.0
	 * @var WP_Tax_Query A taxonomy query instance.
	 */
	public $tax_query;

	/**
	 * Metadata query container
	 *
	 * @since 3.2.0
	 * @var WP_Meta_Query A meta query instance.
	 */
	public $meta_query = false;

	/**
	 * Date query container
	 *
	 * @since 3.7.0
	 * @var WP_Date_Query A date query instance.
	 */
	public $date_query = false;

	/**
	 * Holds the data for a single object that is queried.
	 *
	 * Holds the contents of a post, page, category, attachment.
	 *
	 * @since 1.5.0
	 * @var object|array
	 */
	public $queried_object;

	/**
	 * The ID of the queried object.
	 *
	 * @since 1.5.0
	 * @var int
	 */
	public $queried_object_id;

	/**
	 * Get post database query.
	 *
	 * @since 2.0.1
	 * @var string
	 */
	public $request;

	/**
	 * List of posts.
	 *
	 * @since 1.5.0
	 * @var array
	 */
	public $posts;

	/**
	 * The amount of posts for the current query.
	 *
	 * @since 1.5.0
	 * @var int
	 */
	public $post_count = 0;

	/**
	 * Index of the current item in the loop.
	 *
	 * @since 1.5.0
	 * @var int
	 */
	public $current_post = -1;

	/**
	 * Whether the loop has started and the caller is in the loop.
	 *
	 * @since 2.0.0
	 * @var bool
	 */
	public $in_the_loop = false;

	/**
	 * The current post.
	 *
	 * @since 1.5.0
	 * @var WP_Post
	 */
	public $post;

	/**
	 * The list of comments for current post.
	 *
	 * @since 2.2.0
	 * @var array
	 */
	public $comments;

	/**
	 * The amount of comments for the posts.
	 *
	 * @since 2.2.0
	 * @var int
	 */
	public $comment_count = 0;

	/**
	 * The index of the comment in the comment loop.
	 *
	 * @since 2.2.0
	 * @var int
	 */
	public $current_comment = -1;

	/**
	 * Current comment ID.
	 *
	 * @since 2.2.0
	 * @var int
	 */
	public $comment;

	/**
	 * The amount of found posts for the current query.
	 *
	 * If limit clause was not used, equals $post_count.
	 *
	 * @since 2.1.0
	 * @var int
	 */
	public $found_posts = 0;

	/**
	 * The amount of pages.
	 *
	 * @since 2.1.0
	 * @var int
	 */
	public $max_num_pages = 0;

	/**
	 * The amount of comment pages.
	 *
	 * @since 2.7.0
	 * @var int
	 */
	public $max_num_comment_pages = 0;

	/**
	 * Signifies whether the current query is for a single post.
	 *
	 * @since 1.5.0
	 * @var bool
	 */
	public $is_single = false;

	/**
	 * Signifies whether the current query is for a preview.
	 *
	 * @since 2.0.0
	 * @var bool
	 */
	public $is_preview = false;

	/**
	 * Signifies whether the current query is for a page.
	 *
	 * @since 1.5.0
	 * @var bool
	 */
	public $is_page = false;

	/**
	 * Signifies whether the current query is for an archive.
	 *
	 * @since 1.5.0
	 * @var bool
	 */
	public $is_archive = false;

	/**
	 * Signifies whether the current query is for a date archive.
	 *
	 * @since 1.5.0
	 * @var bool
	 */
	public $is_date = false;

	/**
	 * Signifies whether the current query is for a year archive.
	 *
	 * @since 1.5.0
	 * @var bool
	 */
	public $is_year = false;

	/**
	 * Signifies whether the current query is for a month archive.
	 *
	 * @since 1.5.0
	 * @var bool
	 */
	public $is_month = false;

	/**
	 * Signifies whether the current query is for a day archive.
	 *
	 * @since 1.5.0
	 * @var bool
	 */
	public $is_day = false;

	/**
	 * Signifies whether the current query is for a specific time.
	 *
	 * @since 1.5.0
	 * @var bool
	 */
	public $is_time = false;

	/**
	 * Signifies whether the current query is for an author archive.
	 *
	 * @since 1.5.0
	 * @var bool
	 */
	public $is_author = false;

	/**
	 * Signifies whether the current query is for a category archive.
	 *
	 * @since 1.5.0
	 * @var bool
	 */
	public $is_category = false;

	/**
	 * Signifies whether the current query is for a tag archive.
	 *
	 * @since 2.3.0
	 * @var bool
	 */
	public $is_tag = false;

	/**
	 * Signifies whether the current query is for a taxonomy archive.
	 *
	 * @since 2.5.0
	 * @var bool
	 */
	public $is_tax = false;

	/**
	 * Signifies whether the current query is for a search.
	 *
	 * @since 1.5.0
	 * @var bool
	 */
	public $is_search = false;

	/**
	 * Signifies whether the current query is for a feed.
	 *
	 * @since 1.5.0
	 * @var bool
	 */
	public $is_feed = false;

	/**
	 * Signifies whether the current query is for a comment feed.
	 *
	 * @since 2.2.0
	 * @var bool
	 */
	public $is_comment_feed = false;

	/**
	 * Signifies whether the current query is for trackback endpoint call.
	 *
	 * @since 1.5.0
	 * @var bool
	 */
	public $is_trackback = false;

	/**
	 * Signifies whether the current query is for the site homepage.
	 *
	 * @since 1.5.0
	 * @var bool
	 */
	public $is_home = false;

	/**
	 * Signifies whether the current query is for the Privacy Policy page.
	 *
	 * @since 5.2.0
	 * @var bool
	 */
	public $is_privacy_policy = false;

	/**
	 * Signifies whether the current query couldn't find anything.
	 *
	 * @since 1.5.0
	 * @var bool
	 */
	public $is_404 = false;

	/**
	 * Signifies whether the current query is for an embed.
	 *
	 * @since 4.4.0
	 * @var bool
	 */
	public $is_embed = false;

	/**
	 * Signifies whether the current query is for a paged result and not for the first page.
	 *
	 * @since 1.5.0
	 * @var bool
	 */
	public $is_paged = false;

	/**
	 * Signifies whether the current query is for an administrative interface page.
	 *
	 * @since 1.5.0
	 * @var bool
	 */
	public $is_admin = false;

	/**
	 * Signifies whether the current query is for an attachment page.
	 *
	 * @since 2.0.0
	 * @var bool
	 */
	public $is_attachment = false;

	/**
	 * Signifies whether the current query is for an existing single post of any post type
	 * (post, attachment, page, custom post types).
	 *
	 * @since 2.1.0
	 * @var bool
	 */
	public $is_singular = false;

	/**
	 * Signifies whether the current query is for the robots.txt file.
	 *
	 * @since 2.1.0
	 * @var bool
	 */
	public $is_robots = false;

	/**
	 * Signifies whether the current query is for the favicon.ico file.
	 *
	 * @since 5.4.0
	 * @var bool
	 */
	public $is_favicon = false;

	/**
	 * Signifies whether the current query is for the page_for_posts page.
	 *
	 * Basically, the homepage if the option isn't set for the static homepage.
	 *
	 * @since 2.1.0
	 * @var bool
	 */
	public $is_posts_page = false;

	/**
	 * Signifies whether the current query is for a post type archive.
	 *
	 * @since 3.1.0
	 * @var bool
	 */
	public $is_post_type_archive = false;

	/**
	 * Stores the -&gt;query_vars state like md5(serialize( $this-&gt;query_vars ) ) so we know
	 * whether we have to re-parse because something has changed
	 *
	 * @since 3.1.0
	 * @var bool|string
	 */
	private $query_vars_hash = false;

	/**
	 * Whether query vars have changed since the initial parse_query() call. Used to catch modifications to query vars made
	 * via pre_get_posts hooks.
	 *
	 * @since 3.1.1
	 */
	private $query_vars_changed = true;

	/**
	 * Set if post thumbnails are cached
	 *
	 * @since 3.2.0
	 * @var bool
	 */
	public $thumbnails_cached = false;

	/**
	 * Cached list of search stopwords.
	 *
	 * @since 3.7.0
	 * @var array
	 */
	private $stopwords;

	private $compat_fields = array( 'query_vars_hash', 'query_vars_changed' );

	private $compat_methods = array( 'init_query_flags', 'parse_tax_query' );

	/**
	 * Resets query flags to false.
	 *
	 * The query flags are what page info WordPress was able to figure out.
	 *
	 * @since 2.0.0
	 */
	private function init_query_flags() {
		$this-&gt;is_single            = false;
		$this-&gt;is_preview           = false;
		$this-&gt;is_page              = false;
		$this-&gt;is_archive           = false;
		$this-&gt;is_date              = false;
		$this-&gt;is_year              = false;
		$this-&gt;is_month             = false;
		$this-&gt;is_day               = false;
		$this-&gt;is_time              = false;
		$this-&gt;is_author            = false;
		$this-&gt;is_category          = false;
		$this-&gt;is_tag               = false;
		$this-&gt;is_tax               = false;
		$this-&gt;is_search            = false;
		$this-&gt;is_feed              = false;
		$this-&gt;is_comment_feed      = false;
		$this-&gt;is_trackback         = false;
		$this-&gt;is_home              = false;
		$this-&gt;is_privacy_policy    = false;
		$this-&gt;is_404               = false;
		$this-&gt;is_paged             = false;
		$this-&gt;is_admin             = false;
		$this-&gt;is_attachment        = false;
		$this-&gt;is_singular          = false;
		$this-&gt;is_robots            = false;
		$this-&gt;is_favicon           = false;
		$this-&gt;is_posts_page        = false;
		$this-&gt;is_post_type_archive = false;
	}

	/**
	 * Initiates object properties and sets default values.
	 *
	 * @since 1.5.0
	 */
	public function init() {
		unset( $this-&gt;posts );
		unset( $this-&gt;query );
		$this-&gt;query_vars = array();
		unset( $this-&gt;queried_object );
		unset( $this-&gt;queried_object_id );
		$this-&gt;post_count   = 0;
		$this-&gt;current_post = -1;
		$this-&gt;in_the_loop  = false;
		unset( $this-&gt;request );
		unset( $this-&gt;post );
		unset( $this-&gt;comments );
		unset( $this-&gt;comment );
		$this-&gt;comment_count         = 0;
		$this-&gt;current_comment       = -1;
		$this-&gt;found_posts           = 0;
		$this-&gt;max_num_pages         = 0;
		$this-&gt;max_num_comment_pages = 0;

		$this-&gt;init_query_flags();
	}

	/**
	 * Reparse the query vars.
	 *
	 * @since 1.5.0
	 */
	public function parse_query_vars() {
		$this-&gt;parse_query();
	}

	/**
	 * Fills in the query variables, which do not exist within the parameter.
	 *
	 * @since 2.1.0
	 * @since 4.5.0 Removed the `comments_popup` public query variable.
	 *
	 * @param array $array Defined query variables.
	 * @return array Complete query variables with undefined ones filled in empty.
	 */
	public function fill_query_vars( $array ) {
		$keys = array(
			'error',
			'm',
			'p',
			'post_parent',
			'subpost',
			'subpost_id',
			'attachment',
			'attachment_id',
			'name',
			'pagename',
			'page_id',
			'second',
			'minute',
			'hour',
			'day',
			'monthnum',
			'year',
			'w',
			'category_name',
			'tag',
			'cat',
			'tag_id',
			'author',
			'author_name',
			'feed',
			'tb',
			'paged',
			'meta_key',
			'meta_value',
			'preview',
			's',
			'sentence',
			'title',
			'fields',
			'menu_order',
			'embed',
		);

		foreach ( $keys as $key ) {
			if ( ! isset( $array[ $key ] ) ) {
				$array[ $key ] = '';
			}
		}

		$array_keys = array(
			'category__in',
			'category__not_in',
			'category__and',
			'post__in',
			'post__not_in',
			'post_name__in',
			'tag__in',
			'tag__not_in',
			'tag__and',
			'tag_slug__in',
			'tag_slug__and',
			'post_parent__in',
			'post_parent__not_in',
			'author__in',
			'author__not_in',
		);

		foreach ( $array_keys as $key ) {
			if ( ! isset( $array[ $key ] ) ) {
				$array[ $key ] = array();
			}
		}
		return $array;
	}

	/**
	 * Parse a query string and set query type booleans.
	 *
	 * @since 1.5.0
	 * @since 4.2.0 Introduced the ability to order by specific clauses of a `$meta_query`, by passing the clause's
	 *              array key to `$orderby`.
	 * @since 4.4.0 Introduced `$post_name__in` and `$title` parameters. `$s` was updated to support excluded
	 *              search terms, by prepending a hyphen.
	 * @since 4.5.0 Removed the `$comments_popup` parameter.
	 *              Introduced the `$comment_status` and `$ping_status` parameters.
	 *              Introduced `RAND(x)` syntax for `$orderby`, which allows an integer seed value to random sorts.
	 * @since 4.6.0 Added 'post_name__in' support for `$orderby`. Introduced the `$lazy_load_term_meta` argument.
	 * @since 4.9.0 Introduced the `$comment_count` parameter.
	 * @since 5.1.0 Introduced the `$meta_compare_key` parameter.
	 * @since 5.3.0 Introduced the `$meta_type_key` parameter.
	 *
	 * @param string|array $query {
	 *     Optional. Array or string of Query parameters.
	 *
	 *     @type int          $attachment_id           Attachment post ID. Used for 'attachment' post_type.
	 *     @type int|string   $author                  Author ID, or comma-separated list of IDs.
	 *     @type string       $author_name             User 'user_nicename'.
	 *     @type array        $author__in              An array of author IDs to query from.
	 *     @type array        $author__not_in          An array of author IDs not to query from.
	 *     @type bool         $cache_results           Whether to cache post information. Default true.
	 *     @type int|string   $cat                     Category ID or comma-separated list of IDs (this or any children).
	 *     @type array        $category__and           An array of category IDs (AND in).
	 *     @type array        $category__in            An array of category IDs (OR in, no children).
	 *     @type array        $category__not_in        An array of category IDs (NOT in).
	 *     @type string       $category_name           Use category slug (not name, this or any children).
	 *     @type array|int    $comment_count           Filter results by comment count. Provide an integer to match
	 *                                                 comment count exactly. Provide an array with integer 'value'
	 *                                                 and 'compare' operator ('=', '!=', '&gt;', '&gt;=', '&lt;', '&lt;=' ) to
	 *                                                 compare against comment_count in a specific way.
	 *     @type string       $comment_status          Comment status.
	 *     @type int          $comments_per_page       The number of comments to return per page.
	 *                                                 Default 'comments_per_page' option.
	 *     @type array        $date_query              An associative array of WP_Date_Query arguments.
	 *                                                 See WP_Date_Query::__construct().
	 *     @type int          $day                     Day of the month. Default empty. Accepts numbers 1-31.
	 *     @type bool         $exact                   Whether to search by exact keyword. Default false.
	 *     @type string       $fields                  Post fields to query for. Accepts:
	 *                                                 - '' Returns an array of complete post objects (`WP_Post[]`).
	 *                                                 - 'ids' Returns an array of post IDs (`int[]`).
	 *                                                 - 'id=&gt;parent' Returns an associative array of parent post IDs,
	 *                                                   keyed by post ID (`int[]`).
	 *                                                 Default ''.
	 *     @type int          $hour                    Hour of the day. Default empty. Accepts numbers 0-23.
	 *     @type int|bool     $ignore_sticky_posts     Whether to ignore sticky posts or not. Setting this to false
	 *                                                 excludes stickies from 'post__in'. Accepts 1|true, 0|false.
	 *                                                 Default false.
	 *     @type int          $m                       Combination YearMonth. Accepts any four-digit year and month
	 *                                                 numbers 1-12. Default empty.
	 *     @type string       $meta_compare            Comparison operator to test the 'meta_value'.
	 *     @type string       $meta_compare_key        Comparison operator to test the 'meta_key'.
	 *     @type string       $meta_key                Custom field key.
	 *     @type array        $meta_query              An associative array of WP_Meta_Query arguments. See WP_Meta_Query.
	 *     @type string       $meta_value              Custom field value.
	 *     @type int          $meta_value_num          Custom field value number.
	 *     @type string       $meta_type_key           Cast for 'meta_key'. See WP_Meta_Query::construct().
	 *     @type int          $menu_order              The menu order of the posts.
	 *     @type int          $monthnum                The two-digit month. Default empty. Accepts numbers 1-12.
	 *     @type string       $name                    Post slug.
	 *     @type bool         $nopaging                Show all posts (true) or paginate (false). Default false.
	 *     @type bool         $no_found_rows           Whether to skip counting the total rows found. Enabling can improve
	 *                                                 performance. Default false.
	 *     @type int          $offset                  The number of posts to offset before retrieval.
	 *     @type string       $order                   Designates ascending or descending order of posts. Default 'DESC'.
	 *                                                 Accepts 'ASC', 'DESC'.
	 *     @type string|array $orderby                 Sort retrieved posts by parameter. One or more options may be
	 *                                                 passed. To use 'meta_value', or 'meta_value_num',
	 *                                                 'meta_key=keyname' must be also be defined. To sort by a
	 *                                                 specific `$meta_query` clause, use that clause's array key.
	 *                                                 Accepts 'none', 'name', 'author', 'date', 'title',
	 *                                                 'modified', 'menu_order', 'parent', 'ID', 'rand',
	 *                                                 'relevance', 'RAND(x)' (where 'x' is an integer seed value),
	 *                                                 'comment_count', 'meta_value', 'meta_value_num', 'post__in',
	 *                                                 'post_name__in', 'post_parent__in', and the array keys
	 *                                                 of `$meta_query`. Default is 'date', except when a search
	 *                                                 is being performed, when the default is 'relevance'.
	 *     @type int          $p                       Post ID.
	 *     @type int          $page                    Show the number of posts that would show up on page X of a
	 *                                                 static front page.
	 *     @type int          $paged                   The number of the current page.
	 *     @type int          $page_id                 Page ID.
	 *     @type string       $pagename                Page slug.
	 *     @type string       $perm                    Show posts if user has the appropriate capability.
	 *     @type string       $ping_status             Ping status.
	 *     @type array        $post__in                An array of post IDs to retrieve, sticky posts will be included.
	 *     @type array        $post__not_in            An array of post IDs not to retrieve. Note: a string of comma-
	 *                                                 separated IDs will NOT work.
	 *     @type string       $post_mime_type          The mime type of the post. Used for 'attachment' post_type.
	 *     @type array        $post_name__in           An array of post slugs that results must match.
	 *     @type int          $post_parent             Page ID to retrieve child pages for. Use 0 to only retrieve
	 *                                                 top-level pages.
	 *     @type array        $post_parent__in         An array containing parent page IDs to query child pages from.
	 *     @type array        $post_parent__not_in     An array containing parent page IDs not to query child pages from.
	 *     @type string|array $post_type               A post type slug (string) or array of post type slugs.
	 *                                                 Default 'any' if using 'tax_query'.
	 *     @type string|array $post_status             A post status (string) or array of post statuses.
	 *     @type int          $posts_per_page          The number of posts to query for. Use -1 to request all posts.
	 *     @type int          $posts_per_archive_page  The number of posts to query for by archive page. Overrides
	 *                                                 'posts_per_page' when is_archive(), or is_search() are true.
	 *     @type string       $s                       Search keyword(s). Prepending a term with a hyphen will
	 *                                                 exclude posts matching that term. Eg, 'pillow -sofa' will
	 *                                                 return posts containing 'pillow' but not 'sofa'. The
	 *                                                 character used for exclusion can be modified using the
	 *                                                 the 'wp_query_search_exclusion_prefix' filter.
	 *     @type int          $second                  Second of the minute. Default empty. Accepts numbers 0-60.
	 *     @type bool         $sentence                Whether to search by phrase. Default false.
	 *     @type bool         $suppress_filters        Whether to suppress filters. Default false.
	 *     @type string       $tag                     Tag slug. Comma-separated (either), Plus-separated (all).
	 *     @type array        $tag__and                An array of tag IDs (AND in).
	 *     @type array        $tag__in                 An array of tag IDs (OR in).
	 *     @type array        $tag__not_in             An array of tag IDs (NOT in).
	 *     @type int          $tag_id                  Tag id or comma-separated list of IDs.
	 *     @type array        $tag_slug__and           An array of tag slugs (AND in).
	 *     @type array        $tag_slug__in            An array of tag slugs (OR in). unless 'ignore_sticky_posts' is
	 *                                                 true. Note: a string of comma-separated IDs will NOT work.
	 *     @type array        $tax_query               An associative array of WP_Tax_Query arguments.
	 *                                                 See WP_Tax_Query-&gt;queries.
	 *     @type string       $title                   Post title.
	 *     @type bool         $update_post_meta_cache  Whether to update the post meta cache. Default true.
	 *     @type bool         $update_post_term_cache  Whether to update the post term cache. Default true.
	 *     @type bool         $lazy_load_term_meta     Whether to lazy-load term meta. Setting to false will
	 *                                                 disable cache priming for term meta, so that each
	 *                                                 get_term_meta() call will hit the database.
	 *                                                 Defaults to the value of `$update_post_term_cache`.
	 *     @type int          $w                       The week number of the year. Default empty. Accepts numbers 0-53.
	 *     @type int          $year                    The four-digit year. Default empty. Accepts any four-digit year.
	 * }
	 */
	public function parse_query( $query = '' ) {
		if ( ! empty( $query ) ) {
			$this-&gt;init();
			$this-&gt;query      = wp_parse_args( $query );
			$this-&gt;query_vars = $this-&gt;query;
		} elseif ( ! isset( $this-&gt;query ) ) {
			$this-&gt;query = $this-&gt;query_vars;
		}

		$this-&gt;query_vars         = $this-&gt;fill_query_vars( $this-&gt;query_vars );
		$qv                       = &amp;$this-&gt;query_vars;
		$this-&gt;query_vars_changed = true;

		if ( ! empty( $qv['robots'] ) ) {
			$this-&gt;is_robots = true;
		} elseif ( ! empty( $qv['favicon'] ) ) {
			$this-&gt;is_favicon = true;
		}

		if ( ! is_scalar( $qv['p'] ) || $qv['p'] &lt; 0 ) {
			$qv['p']     = 0;
			$qv['error'] = '404';
		} else {
			$qv['p'] = intval( $qv['p'] );
		}

		$qv['page_id']  = absint( $qv['page_id'] );
		$qv['year']     = absint( $qv['year'] );
		$qv['monthnum'] = absint( $qv['monthnum'] );
		$qv['day']      = absint( $qv['day'] );
		$qv['w']        = absint( $qv['w'] );
		$qv['m']        = is_scalar( $qv['m'] ) ? preg_replace( '|[^0-9]|', '', $qv['m'] ) : '';
		$qv['paged']    = absint( $qv['paged'] );
		$qv['cat']      = preg_replace( '|[^0-9,-]|', '', $qv['cat'] );    // Comma-separated list of positive or negative integers.
		$qv['author']   = preg_replace( '|[^0-9,-]|', '', $qv['author'] ); // Comma-separated list of positive or negative integers.
		$qv['pagename'] = trim( $qv['pagename'] );
		$qv['name']     = trim( $qv['name'] );
		$qv['title']    = trim( $qv['title'] );
		if ( '' !== $qv['hour'] ) {
			$qv['hour'] = absint( $qv['hour'] );
		}
		if ( '' !== $qv['minute'] ) {
			$qv['minute'] = absint( $qv['minute'] );
		}
		if ( '' !== $qv['second'] ) {
			$qv['second'] = absint( $qv['second'] );
		}
		if ( '' !== $qv['menu_order'] ) {
			$qv['menu_order'] = absint( $qv['menu_order'] );
		}

		// Fairly insane upper bound for search string lengths.
		if ( ! is_scalar( $qv['s'] ) || ( ! empty( $qv['s'] ) &amp;&amp; strlen( $qv['s'] ) &gt; 1600 ) ) {
			$qv['s'] = '';
		}

		// Compat. Map subpost to attachment.
		if ( '' != $qv['subpost'] ) {
			$qv['attachment'] = $qv['subpost'];
		}
		if ( '' != $qv['subpost_id'] ) {
			$qv['attachment_id'] = $qv['subpost_id'];
		}

		$qv['attachment_id'] = absint( $qv['attachment_id'] );

		if ( ( '' !== $qv['attachment'] ) || ! empty( $qv['attachment_id'] ) ) {
			$this-&gt;is_single     = true;
			$this-&gt;is_attachment = true;
		} elseif ( '' !== $qv['name'] ) {
			$this-&gt;is_single = true;
		} elseif ( $qv['p'] ) {
			$this-&gt;is_single = true;
		} elseif ( '' !== $qv['pagename'] || ! empty( $qv['page_id'] ) ) {
			$this-&gt;is_page   = true;
			$this-&gt;is_single = false;
		} else {
			// Look for archive queries. Dates, categories, authors, search, post type archives.

			if ( isset( $this-&gt;query['s'] ) ) {
				$this-&gt;is_search = true;
			}

			if ( '' !== $qv['second'] ) {
				$this-&gt;is_time = true;
				$this-&gt;is_date = true;
			}

			if ( '' !== $qv['minute'] ) {
				$this-&gt;is_time = true;
				$this-&gt;is_date = true;
			}

			if ( '' !== $qv['hour'] ) {
				$this-&gt;is_time = true;
				$this-&gt;is_date = true;
			}

			if ( $qv['day'] ) {
				if ( ! $this-&gt;is_date ) {
					$date = sprintf( '%04d-%02d-%02d', $qv['year'], $qv['monthnum'], $qv['day'] );
					if ( $qv['monthnum'] &amp;&amp; $qv['year'] &amp;&amp; ! wp_checkdate( $qv['monthnum'], $qv['day'], $qv['year'], $date ) ) {
						$qv['error'] = '404';
					} else {
						$this-&gt;is_day  = true;
						$this-&gt;is_date = true;
					}
				}
			}

			if ( $qv['monthnum'] ) {
				if ( ! $this-&gt;is_date ) {
					if ( 12 &lt; $qv['monthnum'] ) {
						$qv['error'] = '404';
					} else {
						$this-&gt;is_month = true;
						$this-&gt;is_date  = true;
					}
				}
			}

			if ( $qv['year'] ) {
				if ( ! $this-&gt;is_date ) {
					$this-&gt;is_year = true;
					$this-&gt;is_date = true;
				}
			}

			if ( $qv['m'] ) {
				$this-&gt;is_date = true;
				if ( strlen( $qv['m'] ) &gt; 9 ) {
					$this-&gt;is_time = true;
				} elseif ( strlen( $qv['m'] ) &gt; 7 ) {
					$this-&gt;is_day = true;
				} elseif ( strlen( $qv['m'] ) &gt; 5 ) {
					$this-&gt;is_month = true;
				} else {
					$this-&gt;is_year = true;
				}
			}

			if ( $qv['w'] ) {
				$this-&gt;is_date = true;
			}

			$this-&gt;query_vars_hash = false;
			$this-&gt;parse_tax_query( $qv );

			foreach ( $this-&gt;tax_query-&gt;queries as $tax_query ) {
				if ( ! is_array( $tax_query ) ) {
					continue;
				}

				if ( isset( $tax_query['operator'] ) &amp;&amp; 'NOT IN' !== $tax_query['operator'] ) {
					switch ( $tax_query['taxonomy'] ) {
						case 'category':
							$this-&gt;is_category = true;
							break;
						case 'post_tag':
							$this-&gt;is_tag = true;
							break;
						default:
							$this-&gt;is_tax = true;
					}
				}
			}
			unset( $tax_query );

			if ( empty( $qv['author'] ) || ( '0' == $qv['author'] ) ) {
				$this-&gt;is_author = false;
			} else {
				$this-&gt;is_author = true;
			}

			if ( '' !== $qv['author_name'] ) {
				$this-&gt;is_author = true;
			}

			if ( ! empty( $qv['post_type'] ) &amp;&amp; ! is_array( $qv['post_type'] ) ) {
				$post_type_obj = get_post_type_object( $qv['post_type'] );
				if ( ! empty( $post_type_obj-&gt;has_archive ) ) {
					$this-&gt;is_post_type_archive = true;
				}
			}

			if ( $this-&gt;is_post_type_archive || $this-&gt;is_date || $this-&gt;is_author || $this-&gt;is_category || $this-&gt;is_tag || $this-&gt;is_tax ) {
				$this-&gt;is_archive = true;
			}
		}

		if ( '' != $qv['feed'] ) {
			$this-&gt;is_feed = true;
		}

		if ( '' != $qv['embed'] ) {
			$this-&gt;is_embed = true;
		}

		if ( '' != $qv['tb'] ) {
			$this-&gt;is_trackback = true;
		}

		if ( '' != $qv['paged'] &amp;&amp; ( intval( $qv['paged'] ) &gt; 1 ) ) {
			$this-&gt;is_paged = true;
		}

		// If we're previewing inside the write screen.
		if ( '' != $qv['preview'] ) {
			$this-&gt;is_preview = true;
		}

		if ( is_admin() ) {
			$this-&gt;is_admin = true;
		}

		if ( false !== strpos( $qv['feed'], 'comments-' ) ) {
			$qv['feed']         = str_replace( 'comments-', '', $qv['feed'] );
			$qv['withcomments'] = 1;
		}

		$this-&gt;is_singular = $this-&gt;is_single || $this-&gt;is_page || $this-&gt;is_attachment;

		if ( $this-&gt;is_feed &amp;&amp; ( ! empty( $qv['withcomments'] ) || ( empty( $qv['withoutcomments'] ) &amp;&amp; $this-&gt;is_singular ) ) ) {
			$this-&gt;is_comment_feed = true;
		}

		if ( ! ( $this-&gt;is_singular || $this-&gt;is_archive || $this-&gt;is_search || $this-&gt;is_feed
				|| ( defined( 'REST_REQUEST' ) &amp;&amp; REST_REQUEST &amp;&amp; $this-&gt;is_main_query() )
				|| $this-&gt;is_trackback || $this-&gt;is_404 || $this-&gt;is_admin || $this-&gt;is_robots || $this-&gt;is_favicon ) ) {
			$this-&gt;is_home = true;
		}

		// Correct `is_*` for 'page_on_front' and 'page_for_posts'.
		if ( $this-&gt;is_home &amp;&amp; 'page' === get_option( 'show_on_front' ) &amp;&amp; get_option( 'page_on_front' ) ) {
			$_query = wp_parse_args( $this-&gt;query );
			// 'pagename' can be set and empty depending on matched rewrite rules. Ignore an empty 'pagename'.
			if ( isset( $_query['pagename'] ) &amp;&amp; '' === $_query['pagename'] ) {
				unset( $_query['pagename'] );
			}

			unset( $_query['embed'] );

			if ( empty( $_query ) || ! array_diff( array_keys( $_query ), array( 'preview', 'page', 'paged', 'cpage' ) ) ) {
				$this-&gt;is_page = true;
				$this-&gt;is_home = false;
				$qv['page_id'] = get_option( 'page_on_front' );
				// Correct &lt;!--nextpage--&gt; for 'page_on_front'.
				if ( ! empty( $qv['paged'] ) ) {
					$qv['page'] = $qv['paged'];
					unset( $qv['paged'] );
				}
			}
		}

		if ( '' !== $qv['pagename'] ) {
			$this-&gt;queried_object = get_page_by_path( $qv['pagename'] );

			if ( $this-&gt;queried_object &amp;&amp; 'attachment' === $this-&gt;queried_object-&gt;post_type ) {
				if ( preg_match( '/^[^%]*%(?:postname)%/', get_option( 'permalink_structure' ) ) ) {
					// See if we also have a post with the same slug.
					$post = get_page_by_path( $qv['pagename'], OBJECT, 'post' );
					if ( $post ) {
						$this-&gt;queried_object = $post;
						$this-&gt;is_page        = false;
						$this-&gt;is_single      = true;
					}
				}
			}

			if ( ! empty( $this-&gt;queried_object ) ) {
				$this-&gt;queried_object_id = (int) $this-&gt;queried_object-&gt;ID;
			} else {
				unset( $this-&gt;queried_object );
			}

			if ( 'page' === get_option( 'show_on_front' ) &amp;&amp; isset( $this-&gt;queried_object_id ) &amp;&amp; get_option( 'page_for_posts' ) == $this-&gt;queried_object_id ) {
				$this-&gt;is_page       = false;
				$this-&gt;is_home       = true;
				$this-&gt;is_posts_page = true;
			}

			if ( isset( $this-&gt;queried_object_id ) &amp;&amp; get_option( 'wp_page_for_privacy_policy' ) == $this-&gt;queried_object_id ) {
				$this-&gt;is_privacy_policy = true;
			}
		}

		if ( $qv['page_id'] ) {
			if ( 'page' === get_option( 'show_on_front' ) &amp;&amp; get_option( 'page_for_posts' ) == $qv['page_id'] ) {
				$this-&gt;is_page       = false;
				$this-&gt;is_home       = true;
				$this-&gt;is_posts_page = true;
			}

			if ( get_option( 'wp_page_for_privacy_policy' ) == $qv['page_id'] ) {
				$this-&gt;is_privacy_policy = true;
			}
		}

		if ( ! empty( $qv['post_type'] ) ) {
			if ( is_array( $qv['post_type'] ) ) {
				$qv['post_type'] = array_map( 'sanitize_key', $qv['post_type'] );
			} else {
				$qv['post_type'] = sanitize_key( $qv['post_type'] );
			}
		}

		if ( ! empty( $qv['post_status'] ) ) {
			if ( is_array( $qv['post_status'] ) ) {
				$qv['post_status'] = array_map( 'sanitize_key', $qv['post_status'] );
			} else {
				$qv['post_status'] = preg_replace( '|[^a-z0-9_,-]|', '', $qv['post_status'] );
			}
		}

		if ( $this-&gt;is_posts_page &amp;&amp; ( ! isset( $qv['withcomments'] ) || ! $qv['withcomments'] ) ) {
			$this-&gt;is_comment_feed = false;
		}

		$this-&gt;is_singular = $this-&gt;is_single || $this-&gt;is_page || $this-&gt;is_attachment;
		// Done correcting `is_*` for 'page_on_front' and 'page_for_posts'.

		if ( '404' == $qv['error'] ) {
			$this-&gt;set_404();
		}

		$this-&gt;is_embed = $this-&gt;is_embed &amp;&amp; ( $this-&gt;is_singular || $this-&gt;is_404 );

		$this-&gt;query_vars_hash    = md5( serialize( $this-&gt;query_vars ) );
		$this-&gt;query_vars_changed = false;

		/**
		 * Fires after the main query vars have been parsed.
		 *
		 * @since 1.5.0
		 *
		 * @param WP_Query $this The WP_Query instance (passed by reference).
		 */
		do_action_ref_array( 'parse_query', array( &amp;$this ) );
	}

	/**
	 * Parses various taxonomy related query vars.
	 *
	 * For BC, this method is not marked as protected. See [28987].
	 *
	 * @since 3.1.0
	 *
	 * @param array $q The query variables. Passed by reference.
	 */
	public function parse_tax_query( &amp;$q ) {
		if ( ! empty( $q['tax_query'] ) &amp;&amp; is_array( $q['tax_query'] ) ) {
			$tax_query = $q['tax_query'];
		} else {
			$tax_query = array();
		}

		if ( ! empty( $q['taxonomy'] ) &amp;&amp; ! empty( $q['term'] ) ) {
			$tax_query[] = array(
				'taxonomy' =&gt; $q['taxonomy'],
				'terms'    =&gt; array( $q['term'] ),
				'field'    =&gt; 'slug',
			);
		}

		foreach ( get_taxonomies( array(), 'objects' ) as $taxonomy =&gt; $t ) {
			if ( 'post_tag' === $taxonomy ) {
				continue; // Handled further down in the $q['tag'] block.
			}

			if ( $t-&gt;query_var &amp;&amp; ! empty( $q[ $t-&gt;query_var ] ) ) {
				$tax_query_defaults = array(
					'taxonomy' =&gt; $taxonomy,
					'field'    =&gt; 'slug',
				);

				if ( isset( $t-&gt;rewrite['hierarchical'] ) &amp;&amp; $t-&gt;rewrite['hierarchical'] ) {
					$q[ $t-&gt;query_var ] = wp_basename( $q[ $t-&gt;query_var ] );
				}

				$term = $q[ $t-&gt;query_var ];

				if ( is_array( $term ) ) {
					$term = implode( ',', $term );
				}

				if ( strpos( $term, '+' ) !== false ) {
					$terms = preg_split( '/[+]+/', $term );
					foreach ( $terms as $term ) {
						$tax_query[] = array_merge(
							$tax_query_defaults,
							array(
								'terms' =&gt; array( $term ),
							)
						);
					}
				} else {
					$tax_query[] = array_merge(
						$tax_query_defaults,
						array(
							'terms' =&gt; preg_split( '/[,]+/', $term ),
						)
					);
				}
			}
		}

		// If query string 'cat' is an array, implode it.
		if ( is_array( $q['cat'] ) ) {
			$q['cat'] = implode( ',', $q['cat'] );
		}

		// Category stuff.

		if ( ! empty( $q['cat'] ) &amp;&amp; ! $this-&gt;is_singular ) {
			$cat_in     = array();
			$cat_not_in = array();

			$cat_array = preg_split( '/[,\s]+/', urldecode( $q['cat'] ) );
			$cat_array = array_map( 'intval', $cat_array );
			$q['cat']  = implode( ',', $cat_array );

			foreach ( $cat_array as $cat ) {
				if ( $cat &gt; 0 ) {
					$cat_in[] = $cat;
				} elseif ( $cat &lt; 0 ) {
					$cat_not_in[] = abs( $cat );
				}
			}

			if ( ! empty( $cat_in ) ) {
				$tax_query[] = array(
					'taxonomy'         =&gt; 'category',
					'terms'            =&gt; $cat_in,
					'field'            =&gt; 'term_id',
					'include_children' =&gt; true,
				);
			}

			if ( ! empty( $cat_not_in ) ) {
				$tax_query[] = array(
					'taxonomy'         =&gt; 'category',
					'terms'            =&gt; $cat_not_in,
					'field'            =&gt; 'term_id',
					'operator'         =&gt; 'NOT IN',
					'include_children' =&gt; true,
				);
			}
			unset( $cat_array, $cat_in, $cat_not_in );
		}

		if ( ! empty( $q['category__and'] ) &amp;&amp; 1 === count( (array) $q['category__and'] ) ) {
			$q['category__and'] = (array) $q['category__and'];
			if ( ! isset( $q['category__in'] ) ) {
				$q['category__in'] = array();
			}
			$q['category__in'][] = absint( reset( $q['category__and'] ) );
			unset( $q['category__and'] );
		}

		if ( ! empty( $q['category__in'] ) ) {
			$q['category__in'] = array_map( 'absint', array_unique( (array) $q['category__in'] ) );
			$tax_query[]       = array(
				'taxonomy'         =&gt; 'category',
				'terms'            =&gt; $q['category__in'],
				'field'            =&gt; 'term_id',
				'include_children' =&gt; false,
			);
		}

		if ( ! empty( $q['category__not_in'] ) ) {
			$q['category__not_in'] = array_map( 'absint', array_unique( (array) $q['category__not_in'] ) );
			$tax_query[]           = array(
				'taxonomy'         =&gt; 'category',
				'terms'            =&gt; $q['category__not_in'],
				'operator'         =&gt; 'NOT IN',
				'include_children' =&gt; false,
			);
		}

		if ( ! empty( $q['category__and'] ) ) {
			$q['category__and'] = array_map( 'absint', array_unique( (array) $q['category__and'] ) );
			$tax_query[]        = array(
				'taxonomy'         =&gt; 'category',
				'terms'            =&gt; $q['category__and'],
				'field'            =&gt; 'term_id',
				'operator'         =&gt; 'AND',
				'include_children' =&gt; false,
			);
		}

		// If query string 'tag' is array, implode it.
		if ( is_array( $q['tag'] ) ) {
			$q['tag'] = implode( ',', $q['tag'] );
		}

		// Tag stuff.

		if ( '' !== $q['tag'] &amp;&amp; ! $this-&gt;is_singular &amp;&amp; $this-&gt;query_vars_changed ) {
			if ( strpos( $q['tag'], ',' ) !== false ) {
				$tags = preg_split( '/[,\r\n\t ]+/', $q['tag'] );
				foreach ( (array) $tags as $tag ) {
					$tag                 = sanitize_term_field( 'slug', $tag, 0, 'post_tag', 'db' );
					$q['tag_slug__in'][] = $tag;
				}
			} elseif ( preg_match( '/[+\r\n\t ]+/', $q['tag'] ) || ! empty( $q['cat'] ) ) {
				$tags = preg_split( '/[+\r\n\t ]+/', $q['tag'] );
				foreach ( (array) $tags as $tag ) {
					$tag                  = sanitize_term_field( 'slug', $tag, 0, 'post_tag', 'db' );
					$q['tag_slug__and'][] = $tag;
				}
			} else {
				$q['tag']            = sanitize_term_field( 'slug', $q['tag'], 0, 'post_tag', 'db' );
				$q['tag_slug__in'][] = $q['tag'];
			}
		}

		if ( ! empty( $q['tag_id'] ) ) {
			$q['tag_id'] = absint( $q['tag_id'] );
			$tax_query[] = array(
				'taxonomy' =&gt; 'post_tag',
				'terms'    =&gt; $q['tag_id'],
			);
		}

		if ( ! empty( $q['tag__in'] ) ) {
			$q['tag__in'] = array_map( 'absint', array_unique( (array) $q['tag__in'] ) );
			$tax_query[]  = array(
				'taxonomy' =&gt; 'post_tag',
				'terms'    =&gt; $q['tag__in'],
			);
		}

		if ( ! empty( $q['tag__not_in'] ) ) {
			$q['tag__not_in'] = array_map( 'absint', array_unique( (array) $q['tag__not_in'] ) );
			$tax_query[]      = array(
				'taxonomy' =&gt; 'post_tag',
				'terms'    =&gt; $q['tag__not_in'],
				'operator' =&gt; 'NOT IN',
			);
		}

		if ( ! empty( $q['tag__and'] ) ) {
			$q['tag__and'] = array_map( 'absint', array_unique( (array) $q['tag__and'] ) );
			$tax_query[]   = array(
				'taxonomy' =&gt; 'post_tag',
				'terms'    =&gt; $q['tag__and'],
				'operator' =&gt; 'AND',
			);
		}

		if ( ! empty( $q['tag_slug__in'] ) ) {
			$q['tag_slug__in'] = array_map( 'sanitize_title_for_query', array_unique( (array) $q['tag_slug__in'] ) );
			$tax_query[]       = array(
				'taxonomy' =&gt; 'post_tag',
				'terms'    =&gt; $q['tag_slug__in'],
				'field'    =&gt; 'slug',
			);
		}

		if ( ! empty( $q['tag_slug__and'] ) ) {
			$q['tag_slug__and'] = array_map( 'sanitize_title_for_query', array_unique( (array) $q['tag_slug__and'] ) );
			$tax_query[]        = array(
				'taxonomy' =&gt; 'post_tag',
				'terms'    =&gt; $q['tag_slug__and'],
				'field'    =&gt; 'slug',
				'operator' =&gt; 'AND',
			);
		}

		$this-&gt;tax_query = new WP_Tax_Query( $tax_query );

		/**
		 * Fires after taxonomy-related query vars have been parsed.
		 *
		 * @since 3.7.0
		 *
		 * @param WP_Query $this The WP_Query instance.
		 */
		do_action( 'parse_tax_query', $this );
	}

	/**
	 * Generates SQL for the WHERE clause based on passed search terms.
	 *
	 * @since 3.7.0
	 *
	 * @global wpdb $wpdb WordPress database abstraction object.
	 *
	 * @param array $q Query variables.
	 * @return string WHERE clause.
	 */
	protected function parse_search( &amp;$q ) {
		global $wpdb;

		$search = '';

		// Added slashes screw with quote grouping when done early, so done later.
		$q['s'] = stripslashes( $q['s'] );
		if ( empty( $_GET['s'] ) &amp;&amp; $this-&gt;is_main_query() ) {
			$q['s'] = urldecode( $q['s'] );
		}
		// There are no line breaks in &lt;input /&gt; fields.
		$q['s']                  = str_replace( array( "\r", "\n" ), '', $q['s'] );
		$q['search_terms_count'] = 1;
		if ( ! empty( $q['sentence'] ) ) {
			$q['search_terms'] = array( $q['s'] );
		} else {
			if ( preg_match_all( '/".*?("|$)|((?&lt;=[\t ",+])|^)[^\t ",+]+/', $q['s'], $matches ) ) {
				$q['search_terms_count'] = count( $matches[0] );
				$q['search_terms']       = $this-&gt;parse_search_terms( $matches[0] );
				// If the search string has only short terms or stopwords, or is 10+ terms long, match it as sentence.
				if ( empty( $q['search_terms'] ) || count( $q['search_terms'] ) &gt; 9 ) {
					$q['search_terms'] = array( $q['s'] );
				}
			} else {
				$q['search_terms'] = array( $q['s'] );
			}
		}

		$n                         = ! empty( $q['exact'] ) ? '' : '%';
		$searchand                 = '';
		$q['search_orderby_title'] = array();

		/**
		 * Filters the prefix that indicates that a search term should be excluded from results.
		 *
		 * @since 4.7.0
		 *
		 * @param string $exclusion_prefix The prefix. Default '-'. Returning
		 *                                 an empty value disables exclusions.
		 */
		$exclusion_prefix = apply_filters( 'wp_query_search_exclusion_prefix', '-' );

		foreach ( $q['search_terms'] as $term ) {
			// If there is an $exclusion_prefix, terms prefixed with it should be excluded.
			$exclude = $exclusion_prefix &amp;&amp; ( substr( $term, 0, 1 ) === $exclusion_prefix );
			if ( $exclude ) {
				$like_op  = 'NOT LIKE';
				$andor_op = 'AND';
				$term     = substr( $term, 1 );
			} else {
				$like_op  = 'LIKE';
				$andor_op = 'OR';
			}

			if ( $n &amp;&amp; ! $exclude ) {
				$like                        = '%' . $wpdb-&gt;esc_like( $term ) . '%';
				$q['search_orderby_title'][] = $wpdb-&gt;prepare( "{$wpdb-&gt;posts}.post_title LIKE %s", $like );
			}

			$like      = $n . $wpdb-&gt;esc_like( $term ) . $n;
			$search   .= $wpdb-&gt;prepare( "{$searchand}(({$wpdb-&gt;posts}.post_title $like_op %s) $andor_op ({$wpdb-&gt;posts}.post_excerpt $like_op %s) $andor_op ({$wpdb-&gt;posts}.post_content $like_op %s))", $like, $like, $like );
			$searchand = ' AND ';
		}

		if ( ! empty( $search ) ) {
			$search = " AND ({$search}) ";
			if ( ! is_user_logged_in() ) {
				$search .= " AND ({$wpdb-&gt;posts}.post_password = '') ";
			}
		}

		return $search;
	}

	/**
	 * Check if the terms are suitable for searching.
	 *
	 * Uses an array of stopwords (terms) that are excluded from the separate
	 * term matching when searching for posts. The list of English stopwords is
	 * the approximate search engines list, and is translatable.
	 *
	 * @since 3.7.0
	 *
	 * @param string[] $terms Array of terms to check.
	 * @return string[] Terms that are not stopwords.
	 */
	protected function parse_search_terms( $terms ) {
		$strtolower = function_exists( 'mb_strtolower' ) ? 'mb_strtolower' : 'strtolower';
		$checked    = array();

		$stopwords = $this-&gt;get_search_stopwords();

		foreach ( $terms as $term ) {
			// Keep before/after spaces when term is for exact match.
			if ( preg_match( '/^".+"$/', $term ) ) {
				$term = trim( $term, "\"'" );
			} else {
				$term = trim( $term, "\"' " );
			}

			// Avoid single A-Z and single dashes.
			if ( ! $term || ( 1 === strlen( $term ) &amp;&amp; preg_match( '/^[a-z\-]$/i', $term ) ) ) {
				continue;
			}

			if ( in_array( call_user_func( $strtolower, $term ), $stopwords, true ) ) {
				continue;
			}

			$checked[] = $term;
		}

		return $checked;
	}

	/**
	 * Retrieve stopwords used when parsing search terms.
	 *
	 * @since 3.7.0
	 *
	 * @return string[] Stopwords.
	 */
	protected function get_search_stopwords() {
		if ( isset( $this-&gt;stopwords ) ) {
			return $this-&gt;stopwords;
		}

		/*
		 * translators: This is a comma-separated list of very common words that should be excluded from a search,
		 * like a, an, and the. These are usually called "stopwords". You should not simply translate these individual
		 * words into your language. Instead, look for and provide commonly accepted stopwords in your language.
		 */
		$words = explode(
			',',
			_x(
				'about,an,are,as,at,be,by,com,for,from,how,in,is,it,of,on,or,that,the,this,to,was,what,when,where,who,will,with,www',
				'Comma-separated list of search stopwords in your language'
			)
		);

		$stopwords = array();
		foreach ( $words as $word ) {
			$word = trim( $word, "\r\n\t " );
			if ( $word ) {
				$stopwords[] = $word;
			}
		}

		/**
		 * Filters stopwords used when parsing search terms.
		 *
		 * @since 3.7.0
		 *
		 * @param string[] $stopwords Array of stopwords.
		 */
		$this-&gt;stopwords = apply_filters( 'wp_search_stopwords', $stopwords );
		return $this-&gt;stopwords;
	}

	/**
	 * Generates SQL for the ORDER BY condition based on passed search terms.
	 *
	 * @since 3.7.0
	 *
	 * @global wpdb $wpdb WordPress database abstraction object.
	 *
	 * @param array $q Query variables.
	 * @return string ORDER BY clause.
	 */
	protected function parse_search_order( &amp;$q ) {
		global $wpdb;

		if ( $q['search_terms_count'] &gt; 1 ) {
			$num_terms = count( $q['search_orderby_title'] );

			// If the search terms contain negative queries, don't bother ordering by sentence matches.
			$like = '';
			if ( ! preg_match( '/(?:\s|^)\-/', $q['s'] ) ) {
				$like = '%' . $wpdb-&gt;esc_like( $q['s'] ) . '%';
			}

			$search_orderby = '';

			// Sentence match in 'post_title'.
			if ( $like ) {
				$search_orderby .= $wpdb-&gt;prepare( "WHEN {$wpdb-&gt;posts}.post_title LIKE %s THEN 1 ", $like );
			}

			// Sanity limit, sort as sentence when more than 6 terms
			// (few searches are longer than 6 terms and most titles are not).
			if ( $num_terms &lt; 7 ) {
				// All words in title.
				$search_orderby .= 'WHEN ' . implode( ' AND ', $q['search_orderby_title'] ) . ' THEN 2 ';
				// Any word in title, not needed when $num_terms == 1.
				if ( $num_terms &gt; 1 ) {
					$search_orderby .= 'WHEN ' . implode( ' OR ', $q['search_orderby_title'] ) . ' THEN 3 ';
				}
			}

			// Sentence match in 'post_content' and 'post_excerpt'.
			if ( $like ) {
				$search_orderby .= $wpdb-&gt;prepare( "WHEN {$wpdb-&gt;posts}.post_excerpt LIKE %s THEN 4 ", $like );
				$search_orderby .= $wpdb-&gt;prepare( "WHEN {$wpdb-&gt;posts}.post_content LIKE %s THEN 5 ", $like );
			}

			if ( $search_orderby ) {
				$search_orderby = '(CASE ' . $search_orderby . 'ELSE 6 END)';
			}
		} else {
			// Single word or sentence search.
			$search_orderby = reset( $q['search_orderby_title'] ) . ' DESC';
		}

		return $search_orderby;
	}

	/**
	 * Converts the given orderby alias (if allowed) to a properly-prefixed value.
	 *
	 * @since 4.0.0
	 *
	 * @global wpdb $wpdb WordPress database abstraction object.
	 *
	 * @param string $orderby Alias for the field to order by.
	 * @return string|false Table-prefixed value to used in the ORDER clause. False otherwise.
	 */
	protected function parse_orderby( $orderby ) {
		global $wpdb;

		// Used to filter values.
		$allowed_keys = array(
			'post_name',
			'post_author',
			'post_date',
			'post_title',
			'post_modified',
			'post_parent',
			'post_type',
			'name',
			'author',
			'date',
			'title',
			'modified',
			'parent',
			'type',
			'ID',
			'menu_order',
			'comment_count',
			'rand',
			'post__in',
			'post_parent__in',
			'post_name__in',
		);

		$primary_meta_key   = '';
		$primary_meta_query = false;
		$meta_clauses       = $this-&gt;meta_query-&gt;get_clauses();
		if ( ! empty( $meta_clauses ) ) {
			$primary_meta_query = reset( $meta_clauses );

			if ( ! empty( $primary_meta_query['key'] ) ) {
				$primary_meta_key = $primary_meta_query['key'];
				$allowed_keys[]   = $primary_meta_key;
			}

			$allowed_keys[] = 'meta_value';
			$allowed_keys[] = 'meta_value_num';
			$allowed_keys   = array_merge( $allowed_keys, array_keys( $meta_clauses ) );
		}

		// If RAND() contains a seed value, sanitize and add to allowed keys.
		$rand_with_seed = false;
		if ( preg_match( '/RAND\(([0-9]+)\)/i', $orderby, $matches ) ) {
			$orderby        = sprintf( 'RAND(%s)', intval( $matches[1] ) );
			$allowed_keys[] = $orderby;
			$rand_with_seed = true;
		}

		if ( ! in_array( $orderby, $allowed_keys, true ) ) {
			return false;
		}

		$orderby_clause = '';

		switch ( $orderby ) {
			case 'post_name':
			case 'post_author':
			case 'post_date':
			case 'post_title':
			case 'post_modified':
			case 'post_parent':
			case 'post_type':
			case 'ID':
			case 'menu_order':
			case 'comment_count':
				$orderby_clause = "{$wpdb-&gt;posts}.{$orderby}";
				break;
			case 'rand':
				$orderby_clause = 'RAND()';
				break;
			case $primary_meta_key:
			case 'meta_value':
				if ( ! empty( $primary_meta_query['type'] ) ) {
					$orderby_clause = "CAST({$primary_meta_query['alias']}.meta_value AS {$primary_meta_query['cast']})";
				} else {
					$orderby_clause = "{$primary_meta_query['alias']}.meta_value";
				}
				break;
			case 'meta_value_num':
				$orderby_clause = "{$primary_meta_query['alias']}.meta_value+0";
				break;
			case 'post__in':
				if ( ! empty( $this-&gt;query_vars['post__in'] ) ) {
					$orderby_clause = "FIELD({$wpdb-&gt;posts}.ID," . implode( ',', array_map( 'absint', $this-&gt;query_vars['post__in'] ) ) . ')';
				}
				break;
			case 'post_parent__in':
				if ( ! empty( $this-&gt;query_vars['post_parent__in'] ) ) {
					$orderby_clause = "FIELD( {$wpdb-&gt;posts}.post_parent," . implode( ', ', array_map( 'absint', $this-&gt;query_vars['post_parent__in'] ) ) . ' )';
				}
				break;
			case 'post_name__in':
				if ( ! empty( $this-&gt;query_vars['post_name__in'] ) ) {
					$post_name__in        = array_map( 'sanitize_title_for_query', $this-&gt;query_vars['post_name__in'] );
					$post_name__in_string = "'" . implode( "','", $post_name__in ) . "'";
					$orderby_clause       = "FIELD( {$wpdb-&gt;posts}.post_name," . $post_name__in_string . ' )';
				}
				break;
			default:
				if ( array_key_exists( $orderby, $meta_clauses ) ) {
					// $orderby corresponds to a meta_query clause.
					$meta_clause    = $meta_clauses[ $orderby ];
					$orderby_clause = "CAST({$meta_clause['alias']}.meta_value AS {$meta_clause['cast']})";
				} elseif ( $rand_with_seed ) {
					$orderby_clause = $orderby;
				} else {
					// Default: order by post field.
					$orderby_clause = "{$wpdb-&gt;posts}.post_" . sanitize_key( $orderby );
				}

				break;
		}

		return $orderby_clause;
	}

	/**
	 * Parse an 'order' query variable and cast it to ASC or DESC as necessary.
	 *
	 * @since 4.0.0
	 *
	 * @param string $order The 'order' query variable.
	 * @return string The sanitized 'order' query variable.
	 */
	protected function parse_order( $order ) {
		if ( ! is_string( $order ) || empty( $order ) ) {
			return 'DESC';
		}

		if ( 'ASC' === strtoupper( $order ) ) {
			return 'ASC';
		} else {
			return 'DESC';
		}
	}

	/**
	 * Sets the 404 property and saves whether query is feed.
	 *
	 * @since 2.0.0
	 */
	public function set_404() {
		$is_feed = $this-&gt;is_feed;

		$this-&gt;init_query_flags();
		$this-&gt;is_404 = true;

		$this-&gt;is_feed = $is_feed;

		/**
		 * Fires after a 404 is triggered.
		 *
		 * @since 5.5.0
		 *
		 * @param WP_Query $this The WP_Query instance (passed by reference).
		 */
		do_action_ref_array( 'set_404', array( $this ) );
	}

	/**
	 * Retrieve query variable.
	 *
	 * @since 1.5.0
	 * @since 3.9.0 The `$default` argument was introduced.
	 *
	 * @param string $query_var Query variable key.
	 * @param mixed  $default   Optional. Value to return if the query variable is not set. Default empty.
	 * @return mixed Contents of the query variable.
	 */
	public function get( $query_var, $default = '' ) {
		if ( isset( $this-&gt;query_vars[ $query_var ] ) ) {
			return $this-&gt;query_vars[ $query_var ];
		}

		return $default;
	}

	/**
	 * Set query variable.
	 *
	 * @since 1.5.0
	 *
	 * @param string $query_var Query variable key.
	 * @param mixed  $value     Query variable value.
	 */
	public function set( $query_var, $value ) {
		$this-&gt;query_vars[ $query_var ] = $value;
	}

	/**
	 * Retrieves an array of posts based on query variables.
	 *
	 * There are a few filters and actions that can be used to modify the post
	 * database query.
	 *
	 * @since 1.5.0
	 *
	 * @return WP_Post[]|int[] Array of post objects or post IDs.
	 */
	public function get_posts() {
		global $wpdb;

		$this-&gt;parse_query();

		/**
		 * Fires after the query variable object is created, but before the actual query is run.
		 *
		 * Note: If using conditional tags, use the method versions within the passed instance
		 * (e.g. $this-&gt;is_main_query() instead of is_main_query()). This is because the functions
		 * like is_main_query() test against the global $wp_query instance, not the passed one.
		 *
		 * @since 2.0.0
		 *
		 * @param WP_Query $this The WP_Query instance (passed by reference).
		 */
		do_action_ref_array( 'pre_get_posts', array( &amp;$this ) );

		// Shorthand.
		$q = &amp;$this-&gt;query_vars;

		// Fill again in case 'pre_get_posts' unset some vars.
		$q = $this-&gt;fill_query_vars( $q );

		// Parse meta query.
		$this-&gt;meta_query = new WP_Meta_Query();
		$this-&gt;meta_query-&gt;parse_query_vars( $q );

		// Set a flag if a 'pre_get_posts' hook changed the query vars.
		$hash = md5( serialize( $this-&gt;query_vars ) );
		if ( $hash != $this-&gt;query_vars_hash ) {
			$this-&gt;query_vars_changed = true;
			$this-&gt;query_vars_hash    = $hash;
		}
		unset( $hash );

		// First let's clear some variables.
		$distinct         = '';
		$whichauthor      = '';
		$whichmimetype    = '';
		$where            = '';
		$limits           = '';
		$join             = '';
		$search           = '';
		$groupby          = '';
		$post_status_join = false;
		$page             = 1;

		if ( isset( $q['caller_get_posts'] ) ) {
			_deprecated_argument(
				'WP_Query',
				'3.1.0',
				sprintf(
					/* translators: 1: caller_get_posts, 2: ignore_sticky_posts */
					__( '%1$s is deprecated. Use %2$s instead.' ),
					'&lt;code&gt;caller_get_posts&lt;/code&gt;',
					'&lt;code&gt;ignore_sticky_posts&lt;/code&gt;'
				)
			);

			if ( ! isset( $q['ignore_sticky_posts'] ) ) {
				$q['ignore_sticky_posts'] = $q['caller_get_posts'];
			}
		}

		if ( ! isset( $q['ignore_sticky_posts'] ) ) {
			$q['ignore_sticky_posts'] = false;
		}

		if ( ! isset( $q['suppress_filters'] ) ) {
			$q['suppress_filters'] = false;
		}

		if ( ! isset( $q['cache_results'] ) ) {
			if ( wp_using_ext_object_cache() ) {
				$q['cache_results'] = false;
			} else {
				$q['cache_results'] = true;
			}
		}

		if ( ! isset( $q['update_post_term_cache'] ) ) {
			$q['update_post_term_cache'] = true;
		}

		if ( ! isset( $q['lazy_load_term_meta'] ) ) {
			$q['lazy_load_term_meta'] = $q['update_post_term_cache'];
		}

		if ( ! isset( $q['update_post_meta_cache'] ) ) {
			$q['update_post_meta_cache'] = true;
		}

		if ( ! isset( $q['post_type'] ) ) {
			if ( $this-&gt;is_search ) {
				$q['post_type'] = 'any';
			} else {
				$q['post_type'] = '';
			}
		}
		$post_type = $q['post_type'];
		if ( empty( $q['posts_per_page'] ) ) {
			$q['posts_per_page'] = get_option( 'posts_per_page' );
		}
		if ( isset( $q['showposts'] ) &amp;&amp; $q['showposts'] ) {
			$q['showposts']      = (int) $q['showposts'];
			$q['posts_per_page'] = $q['showposts'];
		}
		if ( ( isset( $q['posts_per_archive_page'] ) &amp;&amp; 0 != $q['posts_per_archive_page'] ) &amp;&amp; ( $this-&gt;is_archive || $this-&gt;is_search ) ) {
			$q['posts_per_page'] = $q['posts_per_archive_page'];
		}
		if ( ! isset( $q['nopaging'] ) ) {
			if ( -1 == $q['posts_per_page'] ) {
				$q['nopaging'] = true;
			} else {
				$q['nopaging'] = false;
			}
		}

		if ( $this-&gt;is_feed ) {
			// This overrides 'posts_per_page'.
			if ( ! empty( $q['posts_per_rss'] ) ) {
				$q['posts_per_page'] = $q['posts_per_rss'];
			} else {
				$q['posts_per_page'] = get_option( 'posts_per_rss' );
			}
			$q['nopaging'] = false;
		}
		$q['posts_per_page'] = (int) $q['posts_per_page'];
		if ( $q['posts_per_page'] &lt; -1 ) {
			$q['posts_per_page'] = abs( $q['posts_per_page'] );
		} elseif ( 0 == $q['posts_per_page'] ) {
			$q['posts_per_page'] = 1;
		}

		if ( ! isset( $q['comments_per_page'] ) || 0 == $q['comments_per_page'] ) {
			$q['comments_per_page'] = get_option( 'comments_per_page' );
		}

		if ( $this-&gt;is_home &amp;&amp; ( empty( $this-&gt;query ) || 'true' === $q['preview'] ) &amp;&amp; ( 'page' === get_option( 'show_on_front' ) ) &amp;&amp; get_option( 'page_on_front' ) ) {
			$this-&gt;is_page = true;
			$this-&gt;is_home = false;
			$q['page_id']  = get_option( 'page_on_front' );
		}

		if ( isset( $q['page'] ) ) {
			$q['page'] = trim( $q['page'], '/' );
			$q['page'] = absint( $q['page'] );
		}

		// If true, forcibly turns off SQL_CALC_FOUND_ROWS even when limits are present.
		if ( isset( $q['no_found_rows'] ) ) {
			$q['no_found_rows'] = (bool) $q['no_found_rows'];
		} else {
			$q['no_found_rows'] = false;
		}

		switch ( $q['fields'] ) {
			case 'ids':
				$fields = "{$wpdb-&gt;posts}.ID";
				break;
			case 'id=&gt;parent':
				$fields = "{$wpdb-&gt;posts}.ID, {$wpdb-&gt;posts}.post_parent";
				break;
			default:
				$fields = "{$wpdb-&gt;posts}.*";
		}

		if ( '' !== $q['menu_order'] ) {
			$where .= " AND {$wpdb-&gt;posts}.menu_order = " . $q['menu_order'];
		}
		// The "m" parameter is meant for months but accepts datetimes of varying specificity.
		if ( $q['m'] ) {
			$where .= " AND YEAR({$wpdb-&gt;posts}.post_date)=" . substr( $q['m'], 0, 4 );
			if ( strlen( $q['m'] ) &gt; 5 ) {
				$where .= " AND MONTH({$wpdb-&gt;posts}.post_date)=" . substr( $q['m'], 4, 2 );
			}
			if ( strlen( $q['m'] ) &gt; 7 ) {
				$where .= " AND DAYOFMONTH({$wpdb-&gt;posts}.post_date)=" . substr( $q['m'], 6, 2 );
			}
			if ( strlen( $q['m'] ) &gt; 9 ) {
				$where .= " AND HOUR({$wpdb-&gt;posts}.post_date)=" . substr( $q['m'], 8, 2 );
			}
			if ( strlen( $q['m'] ) &gt; 11 ) {
				$where .= " AND MINUTE({$wpdb-&gt;posts}.post_date)=" . substr( $q['m'], 10, 2 );
			}
			if ( strlen( $q['m'] ) &gt; 13 ) {
				$where .= " AND SECOND({$wpdb-&gt;posts}.post_date)=" . substr( $q['m'], 12, 2 );
			}
		}

		// Handle the other individual date parameters.
		$date_parameters = array();

		if ( '' !== $q['hour'] ) {
			$date_parameters['hour'] = $q['hour'];
		}

		if ( '' !== $q['minute'] ) {
			$date_parameters['minute'] = $q['minute'];
		}

		if ( '' !== $q['second'] ) {
			$date_parameters['second'] = $q['second'];
		}

		if ( $q['year'] ) {
			$date_parameters['year'] = $q['year'];
		}

		if ( $q['monthnum'] ) {
			$date_parameters['monthnum'] = $q['monthnum'];
		}

		if ( $q['w'] ) {
			$date_parameters['week'] = $q['w'];
		}

		if ( $q['day'] ) {
			$date_parameters['day'] = $q['day'];
		}

		if ( $date_parameters ) {
			$date_query = new WP_Date_Query( array( $date_parameters ) );
			$where     .= $date_query-&gt;get_sql();
		}
		unset( $date_parameters, $date_query );

		// Handle complex date queries.
		if ( ! empty( $q['date_query'] ) ) {
			$this-&gt;date_query = new WP_Date_Query( $q['date_query'] );
			$where           .= $this-&gt;date_query-&gt;get_sql();
		}

		// If we've got a post_type AND it's not "any" post_type.
		if ( ! empty( $q['post_type'] ) &amp;&amp; 'any' !== $q['post_type'] ) {
			foreach ( (array) $q['post_type'] as $_post_type ) {
				$ptype_obj = get_post_type_object( $_post_type );
				if ( ! $ptype_obj || ! $ptype_obj-&gt;query_var || empty( $q[ $ptype_obj-&gt;query_var ] ) ) {
					continue;
				}

				if ( ! $ptype_obj-&gt;hierarchical ) {
					// Non-hierarchical post types can directly use 'name'.
					$q['name'] = $q[ $ptype_obj-&gt;query_var ];
				} else {
					// Hierarchical post types will operate through 'pagename'.
					$q['pagename'] = $q[ $ptype_obj-&gt;query_var ];
					$q['name']     = '';
				}

				// Only one request for a slug is possible, this is why name &amp; pagename are overwritten above.
				break;
			} // End foreach.
			unset( $ptype_obj );
		}

		if ( '' !== $q['title'] ) {
			$where .= $wpdb-&gt;prepare( " AND {$wpdb-&gt;posts}.post_title = %s", stripslashes( $q['title'] ) );
		}

		// Parameters related to 'post_name'.
		if ( '' !== $q['name'] ) {
			$q['name'] = sanitize_title_for_query( $q['name'] );
			$where    .= " AND {$wpdb-&gt;posts}.post_name = '" . $q['name'] . "'";
		} elseif ( '' !== $q['pagename'] ) {
			if ( isset( $this-&gt;queried_object_id ) ) {
				$reqpage = $this-&gt;queried_object_id;
			} else {
				if ( 'page' !== $q['post_type'] ) {
					foreach ( (array) $q['post_type'] as $_post_type ) {
						$ptype_obj = get_post_type_object( $_post_type );
						if ( ! $ptype_obj || ! $ptype_obj-&gt;hierarchical ) {
							continue;
						}

						$reqpage = get_page_by_path( $q['pagename'], OBJECT, $_post_type );
						if ( $reqpage ) {
							break;
						}
					}
					unset( $ptype_obj );
				} else {
					$reqpage = get_page_by_path( $q['pagename'] );
				}
				if ( ! empty( $reqpage ) ) {
					$reqpage = $reqpage-&gt;ID;
				} else {
					$reqpage = 0;
				}
			}

			$page_for_posts = get_option( 'page_for_posts' );
			if ( ( 'page' !== get_option( 'show_on_front' ) ) || empty( $page_for_posts ) || ( $reqpage != $page_for_posts ) ) {
				$q['pagename'] = sanitize_title_for_query( wp_basename( $q['pagename'] ) );
				$q['name']     = $q['pagename'];
				$where        .= " AND ({$wpdb-&gt;posts}.ID = '$reqpage')";
				$reqpage_obj   = get_post( $reqpage );
				if ( is_object( $reqpage_obj ) &amp;&amp; 'attachment' === $reqpage_obj-&gt;post_type ) {
					$this-&gt;is_attachment = true;
					$post_type           = 'attachment';
					$q['post_type']      = 'attachment';
					$this-&gt;is_page       = true;
					$q['attachment_id']  = $reqpage;
				}
			}
		} elseif ( '' !== $q['attachment'] ) {
			$q['attachment'] = sanitize_title_for_query( wp_basename( $q['attachment'] ) );
			$q['name']       = $q['attachment'];
			$where          .= " AND {$wpdb-&gt;posts}.post_name = '" . $q['attachment'] . "'";
		} elseif ( is_array( $q['post_name__in'] ) &amp;&amp; ! empty( $q['post_name__in'] ) ) {
			$q['post_name__in'] = array_map( 'sanitize_title_for_query', $q['post_name__in'] );
			$post_name__in      = "'" . implode( "','", $q['post_name__in'] ) . "'";
			$where             .= " AND {$wpdb-&gt;posts}.post_name IN ($post_name__in)";
		}

		// If an attachment is requested by number, let it supersede any post number.
		if ( $q['attachment_id'] ) {
			$q['p'] = absint( $q['attachment_id'] );
		}

		// If a post number is specified, load that post.
		if ( $q['p'] ) {
			$where .= " AND {$wpdb-&gt;posts}.ID = " . $q['p'];
		} elseif ( $q['post__in'] ) {
			$post__in = implode( ',', array_map( 'absint', $q['post__in'] ) );
			$where   .= " AND {$wpdb-&gt;posts}.ID IN ($post__in)";
		} elseif ( $q['post__not_in'] ) {
			$post__not_in = implode( ',', array_map( 'absint', $q['post__not_in'] ) );
			$where       .= " AND {$wpdb-&gt;posts}.ID NOT IN ($post__not_in)";
		}

		if ( is_numeric( $q['post_parent'] ) ) {
			$where .= $wpdb-&gt;prepare( " AND {$wpdb-&gt;posts}.post_parent = %d ", $q['post_parent'] );
		} elseif ( $q['post_parent__in'] ) {
			$post_parent__in = implode( ',', array_map( 'absint', $q['post_parent__in'] ) );
			$where          .= " AND {$wpdb-&gt;posts}.post_parent IN ($post_parent__in)";
		} elseif ( $q['post_parent__not_in'] ) {
			$post_parent__not_in = implode( ',', array_map( 'absint', $q['post_parent__not_in'] ) );
			$where              .= " AND {$wpdb-&gt;posts}.post_parent NOT IN ($post_parent__not_in)";
		}

		if ( $q['page_id'] ) {
			if ( ( 'page' !== get_option( 'show_on_front' ) ) || ( get_option( 'page_for_posts' ) != $q['page_id'] ) ) {
				$q['p'] = $q['page_id'];
				$where  = " AND {$wpdb-&gt;posts}.ID = " . $q['page_id'];
			}
		}

		// If a search pattern is specified, load the posts that match.
		if ( strlen( $q['s'] ) ) {
			$search = $this-&gt;parse_search( $q );
		}

		if ( ! $q['suppress_filters'] ) {
			/**
			 * Filters the search SQL that is used in the WHERE clause of WP_Query.
			 *
			 * @since 3.0.0
			 *
			 * @param string   $search Search SQL for WHERE clause.
			 * @param WP_Query $this   The current WP_Query object.
			 */
			$search = apply_filters_ref_array( 'posts_search', array( $search, &amp;$this ) );
		}

		// Taxonomies.
		if ( ! $this-&gt;is_singular ) {
			$this-&gt;parse_tax_query( $q );

			$clauses = $this-&gt;tax_query-&gt;get_sql( $wpdb-&gt;posts, 'ID' );

			$join  .= $clauses['join'];
			$where .= $clauses['where'];
		}

		if ( $this-&gt;is_tax ) {
			if ( empty( $post_type ) ) {
				// Do a fully inclusive search for currently registered post types of queried taxonomies.
				$post_type  = array();
				$taxonomies = array_keys( $this-&gt;tax_query-&gt;queried_terms );
				foreach ( get_post_types( array( 'exclude_from_search' =&gt; false ) ) as $pt ) {
					$object_taxonomies = 'attachment' === $pt ? get_taxonomies_for_attachments() : get_object_taxonomies( $pt );
					if ( array_intersect( $taxonomies, $object_taxonomies ) ) {
						$post_type[] = $pt;
					}
				}
				if ( ! $post_type ) {
					$post_type = 'any';
				} elseif ( count( $post_type ) == 1 ) {
					$post_type = $post_type[0];
				}

				$post_status_join = true;
			} elseif ( in_array( 'attachment', (array) $post_type, true ) ) {
				$post_status_join = true;
			}
		}

		/*
		 * Ensure that 'taxonomy', 'term', 'term_id', 'cat', and
		 * 'category_name' vars are set for backward compatibility.
		 */
		if ( ! empty( $this-&gt;tax_query-&gt;queried_terms ) ) {

			/*
			 * Set 'taxonomy', 'term', and 'term_id' to the
			 * first taxonomy other than 'post_tag' or 'category'.
			 */
			if ( ! isset( $q['taxonomy'] ) ) {
				foreach ( $this-&gt;tax_query-&gt;queried_terms as $queried_taxonomy =&gt; $queried_items ) {
					if ( empty( $queried_items['terms'][0] ) ) {
						continue;
					}

					if ( ! in_array( $queried_taxonomy, array( 'category', 'post_tag' ), true ) ) {
						$q['taxonomy'] = $queried_taxonomy;

						if ( 'slug' === $queried_items['field'] ) {
							$q['term'] = $queried_items['terms'][0];
						} else {
							$q['term_id'] = $queried_items['terms'][0];
						}

						// Take the first one we find.
						break;
					}
				}
			}

			// 'cat', 'category_name', 'tag_id'.
			foreach ( $this-&gt;tax_query-&gt;queried_terms as $queried_taxonomy =&gt; $queried_items ) {
				if ( empty( $queried_items['terms'][0] ) ) {
					continue;
				}

				if ( 'category' === $queried_taxonomy ) {
					$the_cat = get_term_by( $queried_items['field'], $queried_items['terms'][0], 'category' );
					if ( $the_cat ) {
						$this-&gt;set( 'cat', $the_cat-&gt;term_id );
						$this-&gt;set( 'category_name', $the_cat-&gt;slug );
					}
					unset( $the_cat );
				}

				if ( 'post_tag' === $queried_taxonomy ) {
					$the_tag = get_term_by( $queried_items['field'], $queried_items['terms'][0], 'post_tag' );
					if ( $the_tag ) {
						$this-&gt;set( 'tag_id', $the_tag-&gt;term_id );
					}
					unset( $the_tag );
				}
			}
		}

		if ( ! empty( $this-&gt;tax_query-&gt;queries ) || ! empty( $this-&gt;meta_query-&gt;queries ) ) {
			$groupby = "{$wpdb-&gt;posts}.ID";
		}

		// Author/user stuff.

		if ( ! empty( $q['author'] ) &amp;&amp; '0' != $q['author'] ) {
			$q['author'] = addslashes_gpc( '' . urldecode( $q['author'] ) );
			$authors     = array_unique( array_map( 'intval', preg_split( '/[,\s]+/', $q['author'] ) ) );
			foreach ( $authors as $author ) {
				$key         = $author &gt; 0 ? 'author__in' : 'author__not_in';
				$q[ $key ][] = abs( $author );
			}
			$q['author'] = implode( ',', $authors );
		}

		if ( ! empty( $q['author__not_in'] ) ) {
			$author__not_in = implode( ',', array_map( 'absint', array_unique( (array) $q['author__not_in'] ) ) );
			$where         .= " AND {$wpdb-&gt;posts}.post_author NOT IN ($author__not_in) ";
		} elseif ( ! empty( $q['author__in'] ) ) {
			$author__in = implode( ',', array_map( 'absint', array_unique( (array) $q['author__in'] ) ) );
			$where     .= " AND {$wpdb-&gt;posts}.post_author IN ($author__in) ";
		}

		// Author stuff for nice URLs.

		if ( '' !== $q['author_name'] ) {
			if ( strpos( $q['author_name'], '/' ) !== false ) {
				$q['author_name'] = explode( '/', $q['author_name'] );
				if ( $q['author_name'][ count( $q['author_name'] ) - 1 ] ) {
					$q['author_name'] = $q['author_name'][ count( $q['author_name'] ) - 1 ]; // No trailing slash.
				} else {
					$q['author_name'] = $q['author_name'][ count( $q['author_name'] ) - 2 ]; // There was a trailing slash.
				}
			}
			$q['author_name'] = sanitize_title_for_query( $q['author_name'] );
			$q['author']      = get_user_by( 'slug', $q['author_name'] );
			if ( $q['author'] ) {
				$q['author'] = $q['author']-&gt;ID;
			}
			$whichauthor .= " AND ({$wpdb-&gt;posts}.post_author = " . absint( $q['author'] ) . ')';
		}

		// Matching by comment count.
		if ( isset( $q['comment_count'] ) ) {
			// Numeric comment count is converted to array format.
			if ( is_numeric( $q['comment_count'] ) ) {
				$q['comment_count'] = array(
					'value' =&gt; intval( $q['comment_count'] ),
				);
			}

			if ( isset( $q['comment_count']['value'] ) ) {
				$q['comment_count'] = array_merge(
					array(
						'compare' =&gt; '=',
					),
					$q['comment_count']
				);

				// Fallback for invalid compare operators is '='.
				$compare_operators = array( '=', '!=', '&gt;', '&gt;=', '&lt;', '&lt;=' );
				if ( ! in_array( $q['comment_count']['compare'], $compare_operators, true ) ) {
					$q['comment_count']['compare'] = '=';
				}

				$where .= $wpdb-&gt;prepare( " AND {$wpdb-&gt;posts}.comment_count {$q['comment_count']['compare']} %d", $q['comment_count']['value'] );
			}
		}

		// MIME-Type stuff for attachment browsing.

		if ( isset( $q['post_mime_type'] ) &amp;&amp; '' !== $q['post_mime_type'] ) {
			$whichmimetype = wp_post_mime_type_where( $q['post_mime_type'], $wpdb-&gt;posts );
		}
		$where .= $search . $whichauthor . $whichmimetype;

		if ( ! empty( $this-&gt;meta_query-&gt;queries ) ) {
			$clauses = $this-&gt;meta_query-&gt;get_sql( 'post', $wpdb-&gt;posts, 'ID', $this );
			$join   .= $clauses['join'];
			$where  .= $clauses['where'];
		}

		$rand = ( isset( $q['orderby'] ) &amp;&amp; 'rand' === $q['orderby'] );
		if ( ! isset( $q['order'] ) ) {
			$q['order'] = $rand ? '' : 'DESC';
		} else {
			$q['order'] = $rand ? '' : $this-&gt;parse_order( $q['order'] );
		}

		// These values of orderby should ignore the 'order' parameter.
		$force_asc = array( 'post__in', 'post_name__in', 'post_parent__in' );
		if ( isset( $q['orderby'] ) &amp;&amp; in_array( $q['orderby'], $force_asc, true ) ) {
			$q['order'] = '';
		}

		// Order by.
		if ( empty( $q['orderby'] ) ) {
			/*
			 * Boolean false or empty array blanks out ORDER BY,
			 * while leaving the value unset or otherwise empty sets the default.
			 */
			if ( isset( $q['orderby'] ) &amp;&amp; ( is_array( $q['orderby'] ) || false === $q['orderby'] ) ) {
				$orderby = '';
			} else {
				$orderby = "{$wpdb-&gt;posts}.post_date " . $q['order'];
			}
		} elseif ( 'none' === $q['orderby'] ) {
			$orderby = '';
		} else {
			$orderby_array = array();
			if ( is_array( $q['orderby'] ) ) {
				foreach ( $q['orderby'] as $_orderby =&gt; $order ) {
					$orderby = addslashes_gpc( urldecode( $_orderby ) );
					$parsed  = $this-&gt;parse_orderby( $orderby );

					if ( ! $parsed ) {
						continue;
					}

					$orderby_array[] = $parsed . ' ' . $this-&gt;parse_order( $order );
				}
				$orderby = implode( ', ', $orderby_array );

			} else {
				$q['orderby'] = urldecode( $q['orderby'] );
				$q['orderby'] = addslashes_gpc( $q['orderby'] );

				foreach ( explode( ' ', $q['orderby'] ) as $i =&gt; $orderby ) {
					$parsed = $this-&gt;parse_orderby( $orderby );
					// Only allow certain values for safety.
					if ( ! $parsed ) {
						continue;
					}

					$orderby_array[] = $parsed;
				}
				$orderby = implode( ' ' . $q['order'] . ', ', $orderby_array );

				if ( empty( $orderby ) ) {
					$orderby = "{$wpdb-&gt;posts}.post_date " . $q['order'];
				} elseif ( ! empty( $q['order'] ) ) {
					$orderby .= " {$q['order']}";
				}
			}
		}

		// Order search results by relevance only when another "orderby" is not specified in the query.
		if ( ! empty( $q['s'] ) ) {
			$search_orderby = '';
			if ( ! empty( $q['search_orderby_title'] ) &amp;&amp; ( empty( $q['orderby'] ) &amp;&amp; ! $this-&gt;is_feed ) || ( isset( $q['orderby'] ) &amp;&amp; 'relevance' === $q['orderby'] ) ) {
				$search_orderby = $this-&gt;parse_search_order( $q );
			}

			if ( ! $q['suppress_filters'] ) {
				/**
				 * Filters the ORDER BY used when ordering search results.
				 *
				 * @since 3.7.0
				 *
				 * @param string   $search_orderby The ORDER BY clause.
				 * @param WP_Query $this           The current WP_Query instance.
				 */
				$search_orderby = apply_filters( 'posts_search_orderby', $search_orderby, $this );
			}

			if ( $search_orderby ) {
				$orderby = $orderby ? $search_orderby . ', ' . $orderby : $search_orderby;
			}
		}

		if ( is_array( $post_type ) &amp;&amp; count( $post_type ) &gt; 1 ) {
			$post_type_cap = 'multiple_post_type';
		} else {
			if ( is_array( $post_type ) ) {
				$post_type = reset( $post_type );
			}
			$post_type_object = get_post_type_object( $post_type );
			if ( empty( $post_type_object ) ) {
				$post_type_cap = $post_type;
			}
		}

		if ( isset( $q['post_password'] ) ) {
			$where .= $wpdb-&gt;prepare( " AND {$wpdb-&gt;posts}.post_password = %s", $q['post_password'] );
			if ( empty( $q['perm'] ) ) {
				$q['perm'] = 'readable';
			}
		} elseif ( isset( $q['has_password'] ) ) {
			$where .= sprintf( " AND {$wpdb-&gt;posts}.post_password %s ''", $q['has_password'] ? '!=' : '=' );
		}

		if ( ! empty( $q['comment_status'] ) ) {
			$where .= $wpdb-&gt;prepare( " AND {$wpdb-&gt;posts}.comment_status = %s ", $q['comment_status'] );
		}

		if ( ! empty( $q['ping_status'] ) ) {
			$where .= $wpdb-&gt;prepare( " AND {$wpdb-&gt;posts}.ping_status = %s ", $q['ping_status'] );
		}

		if ( 'any' === $post_type ) {
			$in_search_post_types = get_post_types( array( 'exclude_from_search' =&gt; false ) );
			if ( empty( $in_search_post_types ) ) {
				$where .= ' AND 1=0 ';
			} else {
				$where .= " AND {$wpdb-&gt;posts}.post_type IN ('" . join( "', '", array_map( 'esc_sql', $in_search_post_types ) ) . "')";
			}
		} elseif ( ! empty( $post_type ) &amp;&amp; is_array( $post_type ) ) {
			$where .= " AND {$wpdb-&gt;posts}.post_type IN ('" . join( "', '", esc_sql( $post_type ) ) . "')";
		} elseif ( ! empty( $post_type ) ) {
			$where           .= $wpdb-&gt;prepare( " AND {$wpdb-&gt;posts}.post_type = %s", $post_type );
			$post_type_object = get_post_type_object( $post_type );
		} elseif ( $this-&gt;is_attachment ) {
			$where           .= " AND {$wpdb-&gt;posts}.post_type = 'attachment'";
			$post_type_object = get_post_type_object( 'attachment' );
		} elseif ( $this-&gt;is_page ) {
			$where           .= " AND {$wpdb-&gt;posts}.post_type = 'page'";
			$post_type_object = get_post_type_object( 'page' );
		} else {
			$where           .= " AND {$wpdb-&gt;posts}.post_type = 'post'";
			$post_type_object = get_post_type_object( 'post' );
		}

		$edit_cap = 'edit_post';
		$read_cap = 'read_post';

		if ( ! empty( $post_type_object ) ) {
			$edit_others_cap  = $post_type_object-&gt;cap-&gt;edit_others_posts;
			$read_private_cap = $post_type_object-&gt;cap-&gt;read_private_posts;
		} else {
			$edit_others_cap  = 'edit_others_' . $post_type_cap . 's';
			$read_private_cap = 'read_private_' . $post_type_cap . 's';
		}

		$user_id = get_current_user_id();

		$q_status = array();
		if ( ! empty( $q['post_status'] ) ) {
			$statuswheres = array();
			$q_status     = $q['post_status'];
			if ( ! is_array( $q_status ) ) {
				$q_status = explode( ',', $q_status );
			}
			$r_status = array();
			$p_status = array();
			$e_status = array();
			if ( in_array( 'any', $q_status, true ) ) {
				foreach ( get_post_stati( array( 'exclude_from_search' =&gt; true ) ) as $status ) {
					if ( ! in_array( $status, $q_status, true ) ) {
						$e_status[] = "{$wpdb-&gt;posts}.post_status &lt;&gt; '$status'";
					}
				}
			} else {
				foreach ( get_post_stati() as $status ) {
					if ( in_array( $status, $q_status, true ) ) {
						if ( 'private' === $status ) {
							$p_status[] = "{$wpdb-&gt;posts}.post_status = '$status'";
						} else {
							$r_status[] = "{$wpdb-&gt;posts}.post_status = '$status'";
						}
					}
				}
			}

			if ( empty( $q['perm'] ) || 'readable' !== $q['perm'] ) {
				$r_status = array_merge( $r_status, $p_status );
				unset( $p_status );
			}

			if ( ! empty( $e_status ) ) {
				$statuswheres[] = '(' . join( ' AND ', $e_status ) . ')';
			}
			if ( ! empty( $r_status ) ) {
				if ( ! empty( $q['perm'] ) &amp;&amp; 'editable' === $q['perm'] &amp;&amp; ! current_user_can( $edit_others_cap ) ) {
					$statuswheres[] = "({$wpdb-&gt;posts}.post_author = $user_id " . 'AND (' . join( ' OR ', $r_status ) . '))';
				} else {
					$statuswheres[] = '(' . join( ' OR ', $r_status ) . ')';
				}
			}
			if ( ! empty( $p_status ) ) {
				if ( ! empty( $q['perm'] ) &amp;&amp; 'readable' === $q['perm'] &amp;&amp; ! current_user_can( $read_private_cap ) ) {
					$statuswheres[] = "({$wpdb-&gt;posts}.post_author = $user_id " . 'AND (' . join( ' OR ', $p_status ) . '))';
				} else {
					$statuswheres[] = '(' . join( ' OR ', $p_status ) . ')';
				}
			}
			if ( $post_status_join ) {
				$join .= " LEFT JOIN {$wpdb-&gt;posts} AS p2 ON ({$wpdb-&gt;posts}.post_parent = p2.ID) ";
				foreach ( $statuswheres as $index =&gt; $statuswhere ) {
					$statuswheres[ $index ] = "($statuswhere OR ({$wpdb-&gt;posts}.post_status = 'inherit' AND " . str_replace( $wpdb-&gt;posts, 'p2', $statuswhere ) . '))';
				}
			}
			$where_status = implode( ' OR ', $statuswheres );
			if ( ! empty( $where_status ) ) {
				$where .= " AND ($where_status)";
			}
		} elseif ( ! $this-&gt;is_singular ) {
			$where .= " AND ({$wpdb-&gt;posts}.post_status = 'publish'";

			// Add public states.
			$public_states = get_post_stati( array( 'public' =&gt; true ) );
			foreach ( (array) $public_states as $state ) {
				if ( 'publish' === $state ) { // Publish is hard-coded above.
					continue;
				}
				$where .= " OR {$wpdb-&gt;posts}.post_status = '$state'";
			}

			if ( $this-&gt;is_admin ) {
				// Add protected states that should show in the admin all list.
				$admin_all_states = get_post_stati(
					array(
						'protected'              =&gt; true,
						'show_in_admin_all_list' =&gt; true,
					)
				);
				foreach ( (array) $admin_all_states as $state ) {
					$where .= " OR {$wpdb-&gt;posts}.post_status = '$state'";
				}
			}

			if ( is_user_logged_in() ) {
				// Add private states that are limited to viewing by the author of a post or someone who has caps to read private states.
				$private_states = get_post_stati( array( 'private' =&gt; true ) );
				foreach ( (array) $private_states as $state ) {
					$where .= current_user_can( $read_private_cap ) ? " OR {$wpdb-&gt;posts}.post_status = '$state'" : " OR {$wpdb-&gt;posts}.post_author = $user_id AND {$wpdb-&gt;posts}.post_status = '$state'";
				}
			}

			$where .= ')';
		}

		/*
		 * Apply filters on where and join prior to paging so that any
		 * manipulations to them are reflected in the paging by day queries.
		 */
		if ( ! $q['suppress_filters'] ) {
			/**
			 * Filters the WHERE clause of the query.
			 *
			 * @since 1.5.0
			 *
			 * @param string   $where The WHERE clause of the query.
			 * @param WP_Query $this The WP_Query instance (passed by reference).
			 */
			$where = apply_filters_ref_array( 'posts_where', array( $where, &amp;$this ) );

			/**
			 * Filters the JOIN clause of the query.
			 *
			 * @since 1.5.0
			 *
			 * @param string   $join  The JOIN clause of the query.
			 * @param WP_Query $this The WP_Query instance (passed by reference).
			 */
			$join = apply_filters_ref_array( 'posts_join', array( $join, &amp;$this ) );
		}

		// Paging.
		if ( empty( $q['nopaging'] ) &amp;&amp; ! $this-&gt;is_singular ) {
			$page = absint( $q['paged'] );
			if ( ! $page ) {
				$page = 1;
			}

			// If 'offset' is provided, it takes precedence over 'paged'.
			if ( isset( $q['offset'] ) &amp;&amp; is_numeric( $q['offset'] ) ) {
				$q['offset'] = absint( $q['offset'] );
				$pgstrt      = $q['offset'] . ', ';
			} else {
				$pgstrt = absint( ( $page - 1 ) * $q['posts_per_page'] ) . ', ';
			}
			$limits = 'LIMIT ' . $pgstrt . $q['posts_per_page'];
		}

		// Comments feeds.
		if ( $this-&gt;is_comment_feed &amp;&amp; ! $this-&gt;is_singular ) {
			if ( $this-&gt;is_archive || $this-&gt;is_search ) {
				$cjoin    = "JOIN {$wpdb-&gt;posts} ON ({$wpdb-&gt;comments}.comment_post_ID = {$wpdb-&gt;posts}.ID) $join ";
				$cwhere   = "WHERE comment_approved = '1' $where";
				$cgroupby = "{$wpdb-&gt;comments}.comment_id";
			} else { // Other non-singular, e.g. front.
				$cjoin    = "JOIN {$wpdb-&gt;posts} ON ( {$wpdb-&gt;comments}.comment_post_ID = {$wpdb-&gt;posts}.ID )";
				$cwhere   = "WHERE ( post_status = 'publish' OR ( post_status = 'inherit' AND post_type = 'attachment' ) ) AND comment_approved = '1'";
				$cgroupby = '';
			}

			if ( ! $q['suppress_filters'] ) {
				/**
				 * Filters the JOIN clause of the comments feed query before sending.
				 *
				 * @since 2.2.0
				 *
				 * @param string   $cjoin The JOIN clause of the query.
				 * @param WP_Query $this The WP_Query instance (passed by reference).
				 */
				$cjoin = apply_filters_ref_array( 'comment_feed_join', array( $cjoin, &amp;$this ) );

				/**
				 * Filters the WHERE clause of the comments feed query before sending.
				 *
				 * @since 2.2.0
				 *
				 * @param string   $cwhere The WHERE clause of the query.
				 * @param WP_Query $this   The WP_Query instance (passed by reference).
				 */
				$cwhere = apply_filters_ref_array( 'comment_feed_where', array( $cwhere, &amp;$this ) );

				/**
				 * Filters the GROUP BY clause of the comments feed query before sending.
				 *
				 * @since 2.2.0
				 *
				 * @param string   $cgroupby The GROUP BY clause of the query.
				 * @param WP_Query $this     The WP_Query instance (passed by reference).
				 */
				$cgroupby = apply_filters_ref_array( 'comment_feed_groupby', array( $cgroupby, &amp;$this ) );

				/**
				 * Filters the ORDER BY clause of the comments feed query before sending.
				 *
				 * @since 2.8.0
				 *
				 * @param string   $corderby The ORDER BY clause of the query.
				 * @param WP_Query $this     The WP_Query instance (passed by reference).
				 */
				$corderby = apply_filters_ref_array( 'comment_feed_orderby', array( 'comment_date_gmt DESC', &amp;$this ) );

				/**
				 * Filters the LIMIT clause of the comments feed query before sending.
				 *
				 * @since 2.8.0
				 *
				 * @param string   $climits The JOIN clause of the query.
				 * @param WP_Query $this    The WP_Query instance (passed by reference).
				 */
				$climits = apply_filters_ref_array( 'comment_feed_limits', array( 'LIMIT ' . get_option( 'posts_per_rss' ), &amp;$this ) );
			}

			$cgroupby = ( ! empty( $cgroupby ) ) ? 'GROUP BY ' . $cgroupby : '';
			$corderby = ( ! empty( $corderby ) ) ? 'ORDER BY ' . $corderby : '';
			$climits  = ( ! empty( $climits ) ) ? $climits : '';

			$comments = (array) $wpdb-&gt;get_results( "SELECT $distinct {$wpdb-&gt;comments}.* FROM {$wpdb-&gt;comments} $cjoin $cwhere $cgroupby $corderby $climits" );
			// Convert to WP_Comment.
			$this-&gt;comments      = array_map( 'get_comment', $comments );
			$this-&gt;comment_count = count( $this-&gt;comments );

			$post_ids = array();

			foreach ( $this-&gt;comments as $comment ) {
				$post_ids[] = (int) $comment-&gt;comment_post_ID;
			}

			$post_ids = join( ',', $post_ids );
			$join     = '';
			if ( $post_ids ) {
				$where = "AND {$wpdb-&gt;posts}.ID IN ($post_ids) ";
			} else {
				$where = 'AND 0';
			}
		}

		$pieces = array( 'where', 'groupby', 'join', 'orderby', 'distinct', 'fields', 'limits' );

		/*
		 * Apply post-paging filters on where and join. Only plugins that
		 * manipulate paging queries should use these hooks.
		 */
		if ( ! $q['suppress_filters'] ) {
			/**
			 * Filters the WHERE clause of the query.
			 *
			 * Specifically for manipulating paging queries.
			 *
			 * @since 1.5.0
			 *
			 * @param string   $where The WHERE clause of the query.
			 * @param WP_Query $this The WP_Query instance (passed by reference).
			 */
			$where = apply_filters_ref_array( 'posts_where_paged', array( $where, &amp;$this ) );

			/**
			 * Filters the GROUP BY clause of the query.
			 *
			 * @since 2.0.0
			 *
			 * @param string   $groupby The GROUP BY clause of the query.
			 * @param WP_Query $this    The WP_Query instance (passed by reference).
			 */
			$groupby = apply_filters_ref_array( 'posts_groupby', array( $groupby, &amp;$this ) );

			/**
			 * Filters the JOIN clause of the query.
			 *
			 * Specifically for manipulating paging queries.
			 *
			 * @since 1.5.0
			 *
			 * @param string   $join  The JOIN clause of the query.
			 * @param WP_Query $this The WP_Query instance (passed by reference).
			 */
			$join = apply_filters_ref_array( 'posts_join_paged', array( $join, &amp;$this ) );

			/**
			 * Filters the ORDER BY clause of the query.
			 *
			 * @since 1.5.1
			 *
			 * @param string   $orderby The ORDER BY clause of the query.
			 * @param WP_Query $this    The WP_Query instance (passed by reference).
			 */
			$orderby = apply_filters_ref_array( 'posts_orderby', array( $orderby, &amp;$this ) );

			/**
			 * Filters the DISTINCT clause of the query.
			 *
			 * @since 2.1.0
			 *
			 * @param string   $distinct The DISTINCT clause of the query.
			 * @param WP_Query $this     The WP_Query instance (passed by reference).
			 */
			$distinct = apply_filters_ref_array( 'posts_distinct', array( $distinct, &amp;$this ) );

			/**
			 * Filters the LIMIT clause of the query.
			 *
			 * @since 2.1.0
			 *
			 * @param string   $limits The LIMIT clause of the query.
			 * @param WP_Query $this   The WP_Query instance (passed by reference).
			 */
			$limits = apply_filters_ref_array( 'post_limits', array( $limits, &amp;$this ) );

			/**
			 * Filters the SELECT clause of the query.
			 *
			 * @since 2.1.0
			 *
			 * @param string   $fields The SELECT clause of the query.
			 * @param WP_Query $this   The WP_Query instance (passed by reference).
			 */
			$fields = apply_filters_ref_array( 'posts_fields', array( $fields, &amp;$this ) );

			/**
			 * Filters all query clauses at once, for convenience.
			 *
			 * Covers the WHERE, GROUP BY, JOIN, ORDER BY, DISTINCT,
			 * fields (SELECT), and LIMITS clauses.
			 *
			 * @since 3.1.0
			 *
			 * @param string[] $clauses Associative array of the clauses for the query.
			 * @param WP_Query $this    The WP_Query instance (passed by reference).
			 */
			$clauses = (array) apply_filters_ref_array( 'posts_clauses', array( compact( $pieces ), &amp;$this ) );

			$where    = isset( $clauses['where'] ) ? $clauses['where'] : '';
			$groupby  = isset( $clauses['groupby'] ) ? $clauses['groupby'] : '';
			$join     = isset( $clauses['join'] ) ? $clauses['join'] : '';
			$orderby  = isset( $clauses['orderby'] ) ? $clauses['orderby'] : '';
			$distinct = isset( $clauses['distinct'] ) ? $clauses['distinct'] : '';
			$fields   = isset( $clauses['fields'] ) ? $clauses['fields'] : '';
			$limits   = isset( $clauses['limits'] ) ? $clauses['limits'] : '';
		}

		/**
		 * Fires to announce the query's current selection parameters.
		 *
		 * For use by caching plugins.
		 *
		 * @since 2.3.0
		 *
		 * @param string $selection The assembled selection query.
		 */
		do_action( 'posts_selection', $where . $groupby . $orderby . $limits . $join );

		/*
		 * Filters again for the benefit of caching plugins.
		 * Regular plugins should use the hooks above.
		 */
		if ( ! $q['suppress_filters'] ) {
			/**
			 * Filters the WHERE clause of the query.
			 *
			 * For use by caching plugins.
			 *
			 * @since 2.5.0
			 *
			 * @param string   $where The WHERE clause of the query.
			 * @param WP_Query $this The WP_Query instance (passed by reference).
			 */
			$where = apply_filters_ref_array( 'posts_where_request', array( $where, &amp;$this ) );

			/**
			 * Filters the GROUP BY clause of the query.
			 *
			 * For use by caching plugins.
			 *
			 * @since 2.5.0
			 *
			 * @param string   $groupby The GROUP BY clause of the query.
			 * @param WP_Query $this    The WP_Query instance (passed by reference).
			 */
			$groupby = apply_filters_ref_array( 'posts_groupby_request', array( $groupby, &amp;$this ) );

			/**
			 * Filters the JOIN clause of the query.
			 *
			 * For use by caching plugins.
			 *
			 * @since 2.5.0
			 *
			 * @param string   $join  The JOIN clause of the query.
			 * @param WP_Query $this The WP_Query instance (passed by reference).
			 */
			$join = apply_filters_ref_array( 'posts_join_request', array( $join, &amp;$this ) );

			/**
			 * Filters the ORDER BY clause of the query.
			 *
			 * For use by caching plugins.
			 *
			 * @since 2.5.0
			 *
			 * @param string   $orderby The ORDER BY clause of the query.
			 * @param WP_Query $this    The WP_Query instance (passed by reference).
			 */
			$orderby = apply_filters_ref_array( 'posts_orderby_request', array( $orderby, &amp;$this ) );

			/**
			 * Filters the DISTINCT clause of the query.
			 *
			 * For use by caching plugins.
			 *
			 * @since 2.5.0
			 *
			 * @param string   $distinct The DISTINCT clause of the query.
			 * @param WP_Query $this     The WP_Query instance (passed by reference).
			 */
			$distinct = apply_filters_ref_array( 'posts_distinct_request', array( $distinct, &amp;$this ) );

			/**
			 * Filters the SELECT clause of the query.
			 *
			 * For use by caching plugins.
			 *
			 * @since 2.5.0
			 *
			 * @param string   $fields The SELECT clause of the query.
			 * @param WP_Query $this   The WP_Query instance (passed by reference).
			 */
			$fields = apply_filters_ref_array( 'posts_fields_request', array( $fields, &amp;$this ) );

			/**
			 * Filters the LIMIT clause of the query.
			 *
			 * For use by caching plugins.
			 *
			 * @since 2.5.0
			 *
			 * @param string   $limits The LIMIT clause of the query.
			 * @param WP_Query $this   The WP_Query instance (passed by reference).
			 */
			$limits = apply_filters_ref_array( 'post_limits_request', array( $limits, &amp;$this ) );

			/**
			 * Filters all query clauses at once, for convenience.
			 *
			 * For use by caching plugins.
			 *
			 * Covers the WHERE, GROUP BY, JOIN, ORDER BY, DISTINCT,
			 * fields (SELECT), and LIMITS clauses.
			 *
			 * @since 3.1.0
			 *
			 * @param string[] $pieces Associative array of the pieces of the query.
			 * @param WP_Query $this   The WP_Query instance (passed by reference).
			 */
			$clauses = (array) apply_filters_ref_array( 'posts_clauses_request', array( compact( $pieces ), &amp;$this ) );

			$where    = isset( $clauses['where'] ) ? $clauses['where'] : '';
			$groupby  = isset( $clauses['groupby'] ) ? $clauses['groupby'] : '';
			$join     = isset( $clauses['join'] ) ? $clauses['join'] : '';
			$orderby  = isset( $clauses['orderby'] ) ? $clauses['orderby'] : '';
			$distinct = isset( $clauses['distinct'] ) ? $clauses['distinct'] : '';
			$fields   = isset( $clauses['fields'] ) ? $clauses['fields'] : '';
			$limits   = isset( $clauses['limits'] ) ? $clauses['limits'] : '';
		}

		if ( ! empty( $groupby ) ) {
			$groupby = 'GROUP BY ' . $groupby;
		}
		if ( ! empty( $orderby ) ) {
			$orderby = 'ORDER BY ' . $orderby;
		}

		$found_rows = '';
		if ( ! $q['no_found_rows'] &amp;&amp; ! empty( $limits ) ) {
			$found_rows = 'SQL_CALC_FOUND_ROWS';
		}

		$old_request   = "SELECT $found_rows $distinct $fields FROM {$wpdb-&gt;posts} $join WHERE 1=1 $where $groupby $orderby $limits";
		$this-&gt;request = $old_request;

		if ( ! $q['suppress_filters'] ) {
			/**
			 * Filters the completed SQL query before sending.
			 *
			 * @since 2.0.0
			 *
			 * @param string   $request The complete SQL query.
			 * @param WP_Query $this    The WP_Query instance (passed by reference).
			 */
			$this-&gt;request = apply_filters_ref_array( 'posts_request', array( $this-&gt;request, &amp;$this ) );
		}

		/**
		 * Filters the posts array before the query takes place.
		 *
		 * Return a non-null value to bypass WordPress's default post queries.
		 *
		 * Filtering functions that require pagination information are encouraged to set
		 * the `found_posts` and `max_num_pages` properties of the WP_Query object,
		 * passed to the filter by reference. If WP_Query does not perform a database
		 * query, it will not have enough information to generate these values itself.
		 *
		 * @since 4.6.0
		 *
		 * @param array|null $posts Return an array of post data to short-circuit WP's query,
		 *                          or null to allow WP to run its normal queries.
		 * @param WP_Query   $this  The WP_Query instance (passed by reference).
		 */
		$this-&gt;posts = apply_filters_ref_array( 'posts_pre_query', array( null, &amp;$this ) );

		if ( 'ids' === $q['fields'] ) {
			if ( null === $this-&gt;posts ) {
				$this-&gt;posts = $wpdb-&gt;get_col( $this-&gt;request );
			}

			$this-&gt;posts      = array_map( 'intval', $this-&gt;posts );
			$this-&gt;post_count = count( $this-&gt;posts );
			$this-&gt;set_found_posts( $q, $limits );

			return $this-&gt;posts;
		}

		if ( 'id=&gt;parent' === $q['fields'] ) {
			if ( null === $this-&gt;posts ) {
				$this-&gt;posts = $wpdb-&gt;get_results( $this-&gt;request );
			}

			$this-&gt;post_count = count( $this-&gt;posts );
			$this-&gt;set_found_posts( $q, $limits );

			$r = array();
			foreach ( $this-&gt;posts as $key =&gt; $post ) {
				$this-&gt;posts[ $key ]-&gt;ID          = (int) $post-&gt;ID;
				$this-&gt;posts[ $key ]-&gt;post_parent = (int) $post-&gt;post_parent;

				$r[ (int) $post-&gt;ID ] = (int) $post-&gt;post_parent;
			}

			return $r;
		}

		if ( null === $this-&gt;posts ) {
			$split_the_query = ( $old_request == $this-&gt;request &amp;&amp; "{$wpdb-&gt;posts}.*" === $fields &amp;&amp; ! empty( $limits ) &amp;&amp; $q['posts_per_page'] &lt; 500 );

			/**
			 * Filters whether to split the query.
			 *
			 * Splitting the query will cause it to fetch just the IDs of the found posts
			 * (and then individually fetch each post by ID), rather than fetching every
			 * complete row at once. One massive result vs. many small results.
			 *
			 * @since 3.4.0
			 *
			 * @param bool     $split_the_query Whether or not to split the query.
			 * @param WP_Query $this            The WP_Query instance.
			 */
			$split_the_query = apply_filters( 'split_the_query', $split_the_query, $this );

			if ( $split_the_query ) {
				// First get the IDs and then fill in the objects.

				$this-&gt;request = "SELECT $found_rows $distinct {$wpdb-&gt;posts}.ID FROM {$wpdb-&gt;posts} $join WHERE 1=1 $where $groupby $orderby $limits";

				/**
				 * Filters the Post IDs SQL request before sending.
				 *
				 * @since 3.4.0
				 *
				 * @param string   $request The post ID request.
				 * @param WP_Query $this    The WP_Query instance.
				 */
				$this-&gt;request = apply_filters( 'posts_request_ids', $this-&gt;request, $this );

				$ids = $wpdb-&gt;get_col( $this-&gt;request );

				if ( $ids ) {
					$this-&gt;posts = $ids;
					$this-&gt;set_found_posts( $q, $limits );
					_prime_post_caches( $ids, $q['update_post_term_cache'], $q['update_post_meta_cache'] );
				} else {
					$this-&gt;posts = array();
				}
			} else {
				$this-&gt;posts = $wpdb-&gt;get_results( $this-&gt;request );
				$this-&gt;set_found_posts( $q, $limits );
			}
		}

		// Convert to WP_Post objects.
		if ( $this-&gt;posts ) {
			$this-&gt;posts = array_map( 'get_post', $this-&gt;posts );
		}

		if ( ! $q['suppress_filters'] ) {
			/**
			 * Filters the raw post results array, prior to status checks.
			 *
			 * @since 2.3.0
			 *
			 * @param WP_Post[] $posts Array of post objects.
			 * @param WP_Query  $this  The WP_Query instance (passed by reference).
			 */
			$this-&gt;posts = apply_filters_ref_array( 'posts_results', array( $this-&gt;posts, &amp;$this ) );
		}

		if ( ! empty( $this-&gt;posts ) &amp;&amp; $this-&gt;is_comment_feed &amp;&amp; $this-&gt;is_singular ) {
			/** This filter is documented in wp-includes/query.php */
			$cjoin = apply_filters_ref_array( 'comment_feed_join', array( '', &amp;$this ) );

			/** This filter is documented in wp-includes/query.php */
			$cwhere = apply_filters_ref_array( 'comment_feed_where', array( "WHERE comment_post_ID = '{$this-&gt;posts[0]-&gt;ID}' AND comment_approved = '1'", &amp;$this ) );

			/** This filter is documented in wp-includes/query.php */
			$cgroupby = apply_filters_ref_array( 'comment_feed_groupby', array( '', &amp;$this ) );
			$cgroupby = ( ! empty( $cgroupby ) ) ? 'GROUP BY ' . $cgroupby : '';

			/** This filter is documented in wp-includes/query.php */
			$corderby = apply_filters_ref_array( 'comment_feed_orderby', array( 'comment_date_gmt DESC', &amp;$this ) );
			$corderby = ( ! empty( $corderby ) ) ? 'ORDER BY ' . $corderby : '';

			/** This filter is documented in wp-includes/query.php */
			$climits = apply_filters_ref_array( 'comment_feed_limits', array( 'LIMIT ' . get_option( 'posts_per_rss' ), &amp;$this ) );

			$comments_request = "SELECT {$wpdb-&gt;comments}.* FROM {$wpdb-&gt;comments} $cjoin $cwhere $cgroupby $corderby $climits";
			$comments         = $wpdb-&gt;get_results( $comments_request );
			// Convert to WP_Comment.
			$this-&gt;comments      = array_map( 'get_comment', $comments );
			$this-&gt;comment_count = count( $this-&gt;comments );
		}

		// Check post status to determine if post should be displayed.
		if ( ! empty( $this-&gt;posts ) &amp;&amp; ( $this-&gt;is_single || $this-&gt;is_page ) ) {
			$status = get_post_status( $this-&gt;posts[0] );

			if ( 'attachment' === $this-&gt;posts[0]-&gt;post_type &amp;&amp; 0 === (int) $this-&gt;posts[0]-&gt;post_parent ) {
				$this-&gt;is_page       = false;
				$this-&gt;is_single     = true;
				$this-&gt;is_attachment = true;
			}

			// If the post_status was specifically requested, let it pass through.
			if ( ! in_array( $status, $q_status, true ) ) {
				$post_status_obj = get_post_status_object( $status );

				if ( $post_status_obj &amp;&amp; ! $post_status_obj-&gt;public ) {
					if ( ! is_user_logged_in() ) {
						// User must be logged in to view unpublished posts.
						$this-&gt;posts = array();
					} else {
						if ( $post_status_obj-&gt;protected ) {
							// User must have edit permissions on the draft to preview.
							if ( ! current_user_can( $edit_cap, $this-&gt;posts[0]-&gt;ID ) ) {
								$this-&gt;posts = array();
							} else {
								$this-&gt;is_preview = true;
								if ( 'future' !== $status ) {
									$this-&gt;posts[0]-&gt;post_date = current_time( 'mysql' );
								}
							}
						} elseif ( $post_status_obj-&gt;private ) {
							if ( ! current_user_can( $read_cap, $this-&gt;posts[0]-&gt;ID ) ) {
								$this-&gt;posts = array();
							}
						} else {
							$this-&gt;posts = array();
						}
					}
				} elseif ( ! $post_status_obj ) {
					// Post status is not registered, assume it's not public.
					if ( ! current_user_can( $edit_cap, $this-&gt;posts[0]-&gt;ID ) ) {
						$this-&gt;posts = array();
					}
				}
			}

			if ( $this-&gt;is_preview &amp;&amp; $this-&gt;posts &amp;&amp; current_user_can( $edit_cap, $this-&gt;posts[0]-&gt;ID ) ) {
				/**
				 * Filters the single post for preview mode.
				 *
				 * @since 2.7.0
				 *
				 * @param WP_Post  $post_preview  The Post object.
				 * @param WP_Query $this          The WP_Query instance (passed by reference).
				 */
				$this-&gt;posts[0] = get_post( apply_filters_ref_array( 'the_preview', array( $this-&gt;posts[0], &amp;$this ) ) );
			}
		}

		// Put sticky posts at the top of the posts array.
		$sticky_posts = get_option( 'sticky_posts' );
		if ( $this-&gt;is_home &amp;&amp; $page &lt;= 1 &amp;&amp; is_array( $sticky_posts ) &amp;&amp; ! empty( $sticky_posts ) &amp;&amp; ! $q['ignore_sticky_posts'] ) {
			$num_posts     = count( $this-&gt;posts );
			$sticky_offset = 0;
			// Loop over posts and relocate stickies to the front.
			for ( $i = 0; $i &lt; $num_posts; $i++ ) {
				if ( in_array( $this-&gt;posts[ $i ]-&gt;ID, $sticky_posts, true ) ) {
					$sticky_post = $this-&gt;posts[ $i ];
					// Remove sticky from current position.
					array_splice( $this-&gt;posts, $i, 1 );
					// Move to front, after other stickies.
					array_splice( $this-&gt;posts, $sticky_offset, 0, array( $sticky_post ) );
					// Increment the sticky offset. The next sticky will be placed at this offset.
					$sticky_offset++;
					// Remove post from sticky posts array.
					$offset = array_search( $sticky_post-&gt;ID, $sticky_posts, true );
					unset( $sticky_posts[ $offset ] );
				}
			}

			// If any posts have been excluded specifically, Ignore those that are sticky.
			if ( ! empty( $sticky_posts ) &amp;&amp; ! empty( $q['post__not_in'] ) ) {
				$sticky_posts = array_diff( $sticky_posts, $q['post__not_in'] );
			}

			// Fetch sticky posts that weren't in the query results.
			if ( ! empty( $sticky_posts ) ) {
				$stickies = get_posts(
					array(
						'post__in'    =&gt; $sticky_posts,
						'post_type'   =&gt; $post_type,
						'post_status' =&gt; 'publish',
						'nopaging'    =&gt; true,
					)
				);

				foreach ( $stickies as $sticky_post ) {
					array_splice( $this-&gt;posts, $sticky_offset, 0, array( $sticky_post ) );
					$sticky_offset++;
				}
			}
		}

		// If comments have been fetched as part of the query, make sure comment meta lazy-loading is set up.
		if ( ! empty( $this-&gt;comments ) ) {
			wp_queue_comments_for_comment_meta_lazyload( $this-&gt;comments );
		}

		if ( ! $q['suppress_filters'] ) {
			/**
			 * Filters the array of retrieved posts after they've been fetched and
			 * internally processed.
			 *
			 * @since 1.5.0
			 *
			 * @param WP_Post[] $posts Array of post objects.
			 * @param WP_Query  $this The WP_Query instance (passed by reference).
			 */
			$this-&gt;posts = apply_filters_ref_array( 'the_posts', array( $this-&gt;posts, &amp;$this ) );
		}

		// Ensure that any posts added/modified via one of the filters above are
		// of the type WP_Post and are filtered.
		if ( $this-&gt;posts ) {
			$this-&gt;post_count = count( $this-&gt;posts );

			$this-&gt;posts = array_map( 'get_post', $this-&gt;posts );

			if ( $q['cache_results'] ) {
				update_post_caches( $this-&gt;posts, $post_type, $q['update_post_term_cache'], $q['update_post_meta_cache'] );
			}

			$this-&gt;post = reset( $this-&gt;posts );
		} else {
			$this-&gt;post_count = 0;
			$this-&gt;posts      = array();
		}

		if ( $q['lazy_load_term_meta'] ) {
			wp_queue_posts_for_term_meta_lazyload( $this-&gt;posts );
		}

		return $this-&gt;posts;
	}

	/**
	 * Set up the amount of found posts and the number of pages (if limit clause was used)
	 * for the current query.
	 *
	 * @since 3.5.0
	 *
	 * @param array  $q      Query variables.
	 * @param string $limits LIMIT clauses of the query.
	 */
	private function set_found_posts( $q, $limits ) {
		global $wpdb;
		// Bail if posts is an empty array. Continue if posts is an empty string,
		// null, or false to accommodate caching plugins that fill posts later.
		if ( $q['no_found_rows'] || ( is_array( $this-&gt;posts ) &amp;&amp; ! $this-&gt;posts ) ) {
			return;
		}

		if ( ! empty( $limits ) ) {
			/**
			 * Filters the query to run for retrieving the found posts.
			 *
			 * @since 2.1.0
			 *
			 * @param string   $found_posts_query The query to run to find the found posts.
			 * @param WP_Query $this              The WP_Query instance (passed by reference).
			 */
			$found_posts_query = apply_filters_ref_array( 'found_posts_query', array( 'SELECT FOUND_ROWS()', &amp;$this ) );

			$this-&gt;found_posts = (int) $wpdb-&gt;get_var( $found_posts_query );
		} else {
			if ( is_array( $this-&gt;posts ) ) {
				$this-&gt;found_posts = count( $this-&gt;posts );
			} else {
				if ( null === $this-&gt;posts ) {
					$this-&gt;found_posts = 0;
				} else {
					$this-&gt;found_posts = 1;
				}
			}
		}

		/**
		 * Filters the number of found posts for the query.
		 *
		 * @since 2.1.0
		 *
		 * @param int      $found_posts The number of posts found.
		 * @param WP_Query $this        The WP_Query instance (passed by reference).
		 */
		$this-&gt;found_posts = (int) apply_filters_ref_array( 'found_posts', array( $this-&gt;found_posts, &amp;$this ) );

		if ( ! empty( $limits ) ) {
			$this-&gt;max_num_pages = ceil( $this-&gt;found_posts / $q['posts_per_page'] );
		}
	}

	/**
	 * Set up the next post and iterate current post index.
	 *
	 * @since 1.5.0
	 *
	 * @return WP_Post Next post.
	 */
	public function next_post() {

		$this-&gt;current_post++;

		$this-&gt;post = $this-&gt;posts[ $this-&gt;current_post ];
		return $this-&gt;post;
	}

	/**
	 * Sets up the current post.
	 *
	 * Retrieves the next post, sets up the post, sets the 'in the loop'
	 * property to true.
	 *
	 * @since 1.5.0
	 *
	 * @global WP_Post $post Global post object.
	 */
	public function the_post() {
		global $post;
		$this-&gt;in_the_loop = true;

		if ( -1 == $this-&gt;current_post ) { // Loop has just started.
			/**
			 * Fires once the loop is started.
			 *
			 * @since 2.0.0
			 *
			 * @param WP_Query $this The WP_Query instance (passed by reference).
			 */
			do_action_ref_array( 'loop_start', array( &amp;$this ) );
		}

		$post = $this-&gt;next_post();
		$this-&gt;setup_postdata( $post );
	}

	/**
	 * Determines whether there are more posts available in the loop.
	 *
	 * Calls the {@see 'loop_end'} action when the loop is complete.
	 *
	 * @since 1.5.0
	 *
	 * @return bool True if posts are available, false if end of the loop.
	 */
	public function have_posts() {
		if ( $this-&gt;current_post + 1 &lt; $this-&gt;post_count ) {
			return true;
		} elseif ( $this-&gt;current_post + 1 == $this-&gt;post_count &amp;&amp; $this-&gt;post_count &gt; 0 ) {
			/**
			 * Fires once the loop has ended.
			 *
			 * @since 2.0.0
			 *
			 * @param WP_Query $this The WP_Query instance (passed by reference).
			 */
			do_action_ref_array( 'loop_end', array( &amp;$this ) );
			// Do some cleaning up after the loop.
			$this-&gt;rewind_posts();
		} elseif ( 0 === $this-&gt;post_count ) {
			/**
			 * Fires if no results are found in a post query.
			 *
			 * @since 4.9.0
			 *
			 * @param WP_Query $this The WP_Query instance.
			 */
			do_action( 'loop_no_results', $this );
		}

		$this-&gt;in_the_loop = false;
		return false;
	}

	/**
	 * Rewind the posts and reset post index.
	 *
	 * @since 1.5.0
	 */
	public function rewind_posts() {
		$this-&gt;current_post = -1;
		if ( $this-&gt;post_count &gt; 0 ) {
			$this-&gt;post = $this-&gt;posts[0];
		}
	}

	/**
	 * Iterate current comment index and return WP_Comment object.
	 *
	 * @since 2.2.0
	 *
	 * @return WP_Comment Comment object.
	 */
	public function next_comment() {
		$this-&gt;current_comment++;

		$this-&gt;comment = $this-&gt;comments[ $this-&gt;current_comment ];
		return $this-&gt;comment;
	}

	/**
	 * Sets up the current comment.
	 *
	 * @since 2.2.0
	 *
	 * @global WP_Comment $comment Global comment object.
	 */
	public function the_comment() {
		global $comment;

		$comment = $this-&gt;next_comment();

		if ( 0 == $this-&gt;current_comment ) {
			/**
			 * Fires once the comment loop is started.
			 *
			 * @since 2.2.0
			 */
			do_action( 'comment_loop_start' );
		}
	}

	/**
	 * Whether there are more comments available.
	 *
	 * Automatically rewinds comments when finished.
	 *
	 * @since 2.2.0
	 *
	 * @return bool True if comments are available, false if no more comments.
	 */
	public function have_comments() {
		if ( $this-&gt;current_comment + 1 &lt; $this-&gt;comment_count ) {
			return true;
		} elseif ( $this-&gt;current_comment + 1 == $this-&gt;comment_count ) {
			$this-&gt;rewind_comments();
		}

		return false;
	}

	/**
	 * Rewind the comments, resets the comment index and comment to first.
	 *
	 * @since 2.2.0
	 */
	public function rewind_comments() {
		$this-&gt;current_comment = -1;
		if ( $this-&gt;comment_count &gt; 0 ) {
			$this-&gt;comment = $this-&gt;comments[0];
		}
	}

	/**
	 * Sets up the WordPress query by parsing query string.
	 *
	 * @since 1.5.0
	 *
	 * @see WP_Query::parse_query() for all available arguments.
	 *
	 * @param string|array $query URL query string or array of query arguments.
	 * @return WP_Post[]|int[] Array of post objects or post IDs.
	 */
	public function query( $query ) {
		$this-&gt;init();
		$this-&gt;query      = wp_parse_args( $query );
		$this-&gt;query_vars = $this-&gt;query;
		return $this-&gt;get_posts();
	}

	/**
	 * Retrieve queried object.
	 *
	 * If queried object is not set, then the queried object will be set from
	 * the category, tag, taxonomy, posts page, single post, page, or author
	 * query variable. After it is set up, it will be returned.
	 *
	 * @since 1.5.0
	 *
	 * @return object
	 */
	public function get_queried_object() {
		if ( isset( $this-&gt;queried_object ) ) {
			return $this-&gt;queried_object;
		}

		$this-&gt;queried_object    = null;
		$this-&gt;queried_object_id = null;

		if ( $this-&gt;is_category || $this-&gt;is_tag || $this-&gt;is_tax ) {
			if ( $this-&gt;is_category ) {
				if ( $this-&gt;get( 'cat' ) ) {
					$term = get_term( $this-&gt;get( 'cat' ), 'category' );
				} elseif ( $this-&gt;get( 'category_name' ) ) {
					$term = get_term_by( 'slug', $this-&gt;get( 'category_name' ), 'category' );
				}
			} elseif ( $this-&gt;is_tag ) {
				if ( $this-&gt;get( 'tag_id' ) ) {
					$term = get_term( $this-&gt;get( 'tag_id' ), 'post_tag' );
				} elseif ( $this-&gt;get( 'tag' ) ) {
					$term = get_term_by( 'slug', $this-&gt;get( 'tag' ), 'post_tag' );
				}
			} else {
				// For other tax queries, grab the first term from the first clause.
				if ( ! empty( $this-&gt;tax_query-&gt;queried_terms ) ) {
					$queried_taxonomies = array_keys( $this-&gt;tax_query-&gt;queried_terms );
					$matched_taxonomy   = reset( $queried_taxonomies );
					$query              = $this-&gt;tax_query-&gt;queried_terms[ $matched_taxonomy ];

					if ( ! empty( $query['terms'] ) ) {
						if ( 'term_id' === $query['field'] ) {
							$term = get_term( reset( $query['terms'] ), $matched_taxonomy );
						} else {
							$term = get_term_by( $query['field'], reset( $query['terms'] ), $matched_taxonomy );
						}
					}
				}
			}

			if ( ! empty( $term ) &amp;&amp; ! is_wp_error( $term ) ) {
				$this-&gt;queried_object    = $term;
				$this-&gt;queried_object_id = (int) $term-&gt;term_id;

				if ( $this-&gt;is_category &amp;&amp; 'category' === $this-&gt;queried_object-&gt;taxonomy ) {
					_make_cat_compat( $this-&gt;queried_object );
				}
			}
		} elseif ( $this-&gt;is_post_type_archive ) {
			$post_type = $this-&gt;get( 'post_type' );
			if ( is_array( $post_type ) ) {
				$post_type = reset( $post_type );
			}
			$this-&gt;queried_object = get_post_type_object( $post_type );
		} elseif ( $this-&gt;is_posts_page ) {
			$page_for_posts          = get_option( 'page_for_posts' );
			$this-&gt;queried_object    = get_post( $page_for_posts );
			$this-&gt;queried_object_id = (int) $this-&gt;queried_object-&gt;ID;
		} elseif ( $this-&gt;is_singular &amp;&amp; ! empty( $this-&gt;post ) ) {
			$this-&gt;queried_object    = $this-&gt;post;
			$this-&gt;queried_object_id = (int) $this-&gt;post-&gt;ID;
		} elseif ( $this-&gt;is_author ) {
			$this-&gt;queried_object_id = (int) $this-&gt;get( 'author' );
			$this-&gt;queried_object    = get_userdata( $this-&gt;queried_object_id );
		}

		return $this-&gt;queried_object;
	}

	/**
	 * Retrieve ID of the current queried object.
	 *
	 * @since 1.5.0
	 *
	 * @return int
	 */
	public function get_queried_object_id() {
		$this-&gt;get_queried_object();

		if ( isset( $this-&gt;queried_object_id ) ) {
			return $this-&gt;queried_object_id;
		}

		return 0;
	}

	/**
	 * Constructor.
	 *
	 * Sets up the WordPress query, if parameter is not empty.
	 *
	 * @since 1.5.0
	 *
	 * @see WP_Query::parse_query() for all available arguments.
	 *
	 * @param string|array $query URL query string or array of vars.
	 */
	public function __construct( $query = '' ) {
		if ( ! empty( $query ) ) {
			$this-&gt;query( $query );
		}
	}

	/**
	 * Make private properties readable for backward compatibility.
	 *
	 * @since 4.0.0
	 *
	 * @param string $name Property to get.
	 * @return mixed Property.
	 */
	public function __get( $name ) {
		if ( in_array( $name, $this-&gt;compat_fields, true ) ) {
			return $this-&gt;$name;
		}
	}

	/**
	 * Make private properties checkable for backward compatibility.
	 *
	 * @since 4.0.0
	 *
	 * @param string $name Property to check if set.
	 * @return bool Whether the property is set.
	 */
	public function __isset( $name ) {
		if ( in_array( $name, $this-&gt;compat_fields, true ) ) {
			return isset( $this-&gt;$name );
		}
	}

	/**
	 * Make private/protected methods readable for backward compatibility.
	 *
	 * @since 4.0.0
	 *
	 * @param string $name      Method to call.
	 * @param array  $arguments Arguments to pass when calling.
	 * @return mixed|false Return value of the callback, false otherwise.
	 */
	public function __call( $name, $arguments ) {
		if ( in_array( $name, $this-&gt;compat_methods, true ) ) {
			return $this-&gt;$name( ...$arguments );
		}
		return false;
	}

	/**
	 * Is the query for an existing archive page?
	 *
	 * Month, Year, Category, Author, Post Type archive...
	 *
	 * @since 3.1.0
	 *
	 * @return bool Whether the query is for an existing archive page.
	 */
	public function is_archive() {
		return (bool) $this-&gt;is_archive;
	}

	/**
	 * Is the query for an existing post type archive page?
	 *
	 * @since 3.1.0
	 *
	 * @param string|string[] $post_types Optional. Post type or array of posts types
	 *                                    to check against. Default empty.
	 * @return bool Whether the query is for an existing post type archive page.
	 */
	public function is_post_type_archive( $post_types = '' ) {
		if ( empty( $post_types ) || ! $this-&gt;is_post_type_archive ) {
			return (bool) $this-&gt;is_post_type_archive;
		}

		$post_type = $this-&gt;get( 'post_type' );
		if ( is_array( $post_type ) ) {
			$post_type = reset( $post_type );
		}
		$post_type_object = get_post_type_object( $post_type );

		return in_array( $post_type_object-&gt;name, (array) $post_types, true );
	}

	/**
	 * Is the query for an existing attachment page?
	 *
	 * @since 3.1.0
	 *
	 * @param int|string|int[]|string[] $attachment Optional. Attachment ID, title, slug, or array of such
	 *                                              to check against. Default empty.
	 * @return bool Whether the query is for an existing attachment page.
	 */
	public function is_attachment( $attachment = '' ) {
		if ( ! $this-&gt;is_attachment ) {
			return false;
		}

		if ( empty( $attachment ) ) {
			return true;
		}

		$attachment = array_map( 'strval', (array) $attachment );

		$post_obj = $this-&gt;get_queried_object();

		if ( in_array( (string) $post_obj-&gt;ID, $attachment, true ) ) {
			return true;
		} elseif ( in_array( $post_obj-&gt;post_title, $attachment, true ) ) {
			return true;
		} elseif ( in_array( $post_obj-&gt;post_name, $attachment, true ) ) {
			return true;
		}
		return false;
	}

	/**
	 * Is the query for an existing author archive page?
	 *
	 * If the $author parameter is specified, this function will additionally
	 * check if the query is for one of the authors specified.
	 *
	 * @since 3.1.0
	 *
	 * @param int|string|int[]|string[] $author Optional. User ID, nickname, nicename, or array of such
	 *                                          to check against. Default empty.
	 * @return bool Whether the query is for an existing author archive page.
	 */
	public function is_author( $author = '' ) {
		if ( ! $this-&gt;is_author ) {
			return false;
		}

		if ( empty( $author ) ) {
			return true;
		}

		$author_obj = $this-&gt;get_queried_object();

		$author = array_map( 'strval', (array) $author );

		if ( in_array( (string) $author_obj-&gt;ID, $author, true ) ) {
			return true;
		} elseif ( in_array( $author_obj-&gt;nickname, $author, true ) ) {
			return true;
		} elseif ( in_array( $author_obj-&gt;user_nicename, $author, true ) ) {
			return true;
		}

		return false;
	}

	/**
	 * Is the query for an existing category archive page?
	 *
	 * If the $category parameter is specified, this function will additionally
	 * check if the query is for one of the categories specified.
	 *
	 * @since 3.1.0
	 *
	 * @param int|string|int[]|string[] $category Optional. Category ID, name, slug, or array of such
	 *                                            to check against. Default empty.
	 * @return bool Whether the query is for an existing category archive page.
	 */
	public function is_category( $category = '' ) {
		if ( ! $this-&gt;is_category ) {
			return false;
		}

		if ( empty( $category ) ) {
			return true;
		}

		$cat_obj = $this-&gt;get_queried_object();

		$category = array_map( 'strval', (array) $category );

		if ( in_array( (string) $cat_obj-&gt;term_id, $category, true ) ) {
			return true;
		} elseif ( in_array( $cat_obj-&gt;name, $category, true ) ) {
			return true;
		} elseif ( in_array( $cat_obj-&gt;slug, $category, true ) ) {
			return true;
		}

		return false;
	}

	/**
	 * Is the query for an existing tag archive page?
	 *
	 * If the $tag parameter is specified, this function will additionally
	 * check if the query is for one of the tags specified.
	 *
	 * @since 3.1.0
	 *
	 * @param int|string|int[]|string[] $tag Optional. Tag ID, name, slug, or array of such
	 *                                       to check against. Default empty.
	 * @return bool Whether the query is for an existing tag archive page.
	 */
	public function is_tag( $tag = '' ) {
		if ( ! $this-&gt;is_tag ) {
			return false;
		}

		if ( empty( $tag ) ) {
			return true;
		}

		$tag_obj = $this-&gt;get_queried_object();

		$tag = array_map( 'strval', (array) $tag );

		if ( in_array( (string) $tag_obj-&gt;term_id, $tag, true ) ) {
			return true;
		} elseif ( in_array( $tag_obj-&gt;name, $tag, true ) ) {
			return true;
		} elseif ( in_array( $tag_obj-&gt;slug, $tag, true ) ) {
			return true;
		}

		return false;
	}

	/**
	 * Is the query for an existing custom taxonomy archive page?
	 *
	 * If the $taxonomy parameter is specified, this function will additionally
	 * check if the query is for that specific $taxonomy.
	 *
	 * If the $term parameter is specified in addition to the $taxonomy parameter,
	 * this function will additionally check if the query is for one of the terms
	 * specified.
	 *
	 * @since 3.1.0
	 *
	 * @global array $wp_taxonomies
	 *
	 * @param string|string[]           $taxonomy Optional. Taxonomy slug or slugs to check against.
	 *                                            Default empty.
	 * @param int|string|int[]|string[] $term     Optional. Term ID, name, slug, or array of such
	 *                                            to check against. Default empty.
	 * @return bool Whether the query is for an existing custom taxonomy archive page.
	 *              True for custom taxonomy archive pages, false for built-in taxonomies
	 *              (category and tag archives).
	 */
	public function is_tax( $taxonomy = '', $term = '' ) {
		global $wp_taxonomies;

		if ( ! $this-&gt;is_tax ) {
			return false;
		}

		if ( empty( $taxonomy ) ) {
			return true;
		}

		$queried_object = $this-&gt;get_queried_object();
		$tax_array      = array_intersect( array_keys( $wp_taxonomies ), (array) $taxonomy );
		$term_array     = (array) $term;

		// Check that the taxonomy matches.
		if ( ! ( isset( $queried_object-&gt;taxonomy ) &amp;&amp; count( $tax_array ) &amp;&amp; in_array( $queried_object-&gt;taxonomy, $tax_array, true ) ) ) {
			return false;
		}

		// Only a taxonomy provided.
		if ( empty( $term ) ) {
			return true;
		}

		return isset( $queried_object-&gt;term_id ) &amp;&amp;
			count(
				array_intersect(
					array( $queried_object-&gt;term_id, $queried_object-&gt;name, $queried_object-&gt;slug ),
					$term_array
				)
			);
	}

	/**
	 * Whether the current URL is within the comments popup window.
	 *
	 * @since 3.1.0
	 * @deprecated 4.5.0
	 *
	 * @return false Always returns false.
	 */
	public function is_comments_popup() {
		_deprecated_function( __FUNCTION__, '4.5.0' );

		return false;
	}

	/**
	 * Is the query for an existing date archive?
	 *
	 * @since 3.1.0
	 *
	 * @return bool Whether the query is for an existing date archive.
	 */
	public function is_date() {
		return (bool) $this-&gt;is_date;
	}

	/**
	 * Is the query for an existing day archive?
	 *
	 * @since 3.1.0
	 *
	 * @return bool Whether the query is for an existing day archive.
	 */
	public function is_day() {
		return (bool) $this-&gt;is_day;
	}

	/**
	 * Is the query for a feed?
	 *
	 * @since 3.1.0
	 *
	 * @param string|string[] $feeds Optional. Feed type or array of feed types
	 *                                         to check against. Default empty.
	 * @return bool Whether the query is for a feed.
	 */
	public function is_feed( $feeds = '' ) {
		if ( empty( $feeds ) || ! $this-&gt;is_feed ) {
			return (bool) $this-&gt;is_feed;
		}

		$qv = $this-&gt;get( 'feed' );
		if ( 'feed' === $qv ) {
			$qv = get_default_feed();
		}

		return in_array( $qv, (array) $feeds, true );
	}

	/**
	 * Is the query for a comments feed?
	 *
	 * @since 3.1.0
	 *
	 * @return bool Whether the query is for a comments feed.
	 */
	public function is_comment_feed() {
		return (bool) $this-&gt;is_comment_feed;
	}

	/**
	 * Is the query for the front page of the site?
	 *
	 * This is for what is displayed at your site's main URL.
	 *
	 * Depends on the site's "Front page displays" Reading Settings 'show_on_front' and 'page_on_front'.
	 *
	 * If you set a static page for the front page of your site, this function will return
	 * true when viewing that page.
	 *
	 * Otherwise the same as @see WP_Query::is_home()
	 *
	 * @since 3.1.0
	 *
	 * @return bool Whether the query is for the front page of the site.
	 */
	public function is_front_page() {
		// Most likely case.
		if ( 'posts' === get_option( 'show_on_front' ) &amp;&amp; $this-&gt;is_home() ) {
			return true;
		} elseif ( 'page' === get_option( 'show_on_front' ) &amp;&amp; get_option( 'page_on_front' )
			&amp;&amp; $this-&gt;is_page( get_option( 'page_on_front' ) )
		) {
			return true;
		} else {
			return false;
		}
	}

	/**
	 * Is the query for the blog homepage?
	 *
	 * This is the page which shows the time based blog content of your site.
	 *
	 * Depends on the site's "Front page displays" Reading Settings 'show_on_front' and 'page_for_posts'.
	 *
	 * If you set a static page for the front page of your site, this function will return
	 * true only on the page you set as the "Posts page".
	 *
	 * @see WP_Query::is_front_page()
	 *
	 * @since 3.1.0
	 *
	 * @return bool Whether the query is for the blog homepage.
	 */
	public function is_home() {
		return (bool) $this-&gt;is_home;
	}

	/**
	 * Is the query for the Privacy Policy page?
	 *
	 * This is the page which shows the Privacy Policy content of your site.
	 *
	 * Depends on the site's "Change your Privacy Policy page" Privacy Settings 'wp_page_for_privacy_policy'.
	 *
	 * This function will return true only on the page you set as the "Privacy Policy page".
	 *
	 * @since 5.2.0
	 *
	 * @return bool Whether the query is for the Privacy Policy page.
	 */
	public function is_privacy_policy() {
		if ( get_option( 'wp_page_for_privacy_policy' )
			&amp;&amp; $this-&gt;is_page( get_option( 'wp_page_for_privacy_policy' ) )
		) {
			return true;
		} else {
			return false;
		}
	}

	/**
	 * Is the query for an existing month archive?
	 *
	 * @since 3.1.0
	 *
	 * @return bool Whether the query is for an existing month archive.
	 */
	public function is_month() {
		return (bool) $this-&gt;is_month;
	}

	/**
	 * Is the query for an existing single page?
	 *
	 * If the $page parameter is specified, this function will additionally
	 * check if the query is for one of the pages specified.
	 *
	 * @see WP_Query::is_single()
	 * @see WP_Query::is_singular()
	 *
	 * @since 3.1.0
	 *
	 * @param int|string|int[]|string[] $page Optional. Page ID, title, slug, path, or array of such
	 *                                        to check against. Default empty.
	 * @return bool Whether the query is for an existing single page.
	 */
	public function is_page( $page = '' ) {
		if ( ! $this-&gt;is_page ) {
			return false;
		}

		if ( empty( $page ) ) {
			return true;
		}

		$page_obj = $this-&gt;get_queried_object();

		$page = array_map( 'strval', (array) $page );

		if ( in_array( (string) $page_obj-&gt;ID, $page, true ) ) {
			return true;
		} elseif ( in_array( $page_obj-&gt;post_title, $page, true ) ) {
			return true;
		} elseif ( in_array( $page_obj-&gt;post_name, $page, true ) ) {
			return true;
		} else {
			foreach ( $page as $pagepath ) {
				if ( ! strpos( $pagepath, '/' ) ) {
					continue;
				}
				$pagepath_obj = get_page_by_path( $pagepath );

				if ( $pagepath_obj &amp;&amp; ( $pagepath_obj-&gt;ID == $page_obj-&gt;ID ) ) {
					return true;
				}
			}
		}

		return false;
	}

	/**
	 * Is the query for a paged result and not for the first page?
	 *
	 * @since 3.1.0
	 *
	 * @return bool Whether the query is for a paged result.
	 */
	public function is_paged() {
		return (bool) $this-&gt;is_paged;
	}

	/**
	 * Is the query for a post or page preview?
	 *
	 * @since 3.1.0
	 *
	 * @return bool Whether the query is for a post or page preview.
	 */
	public function is_preview() {
		return (bool) $this-&gt;is_preview;
	}

	/**
	 * Is the query for the robots.txt file?
	 *
	 * @since 3.1.0
	 *
	 * @return bool Whether the query is for the robots.txt file.
	 */
	public function is_robots() {
		return (bool) $this-&gt;is_robots;
	}

	/**
	 * Is the query for the favicon.ico file?
	 *
	 * @since 5.4.0
	 *
	 * @return bool Whether the query is for the favicon.ico file.
	 */
	public function is_favicon() {
		return (bool) $this-&gt;is_favicon;
	}

	/**
	 * Is the query for a search?
	 *
	 * @since 3.1.0
	 *
	 * @return bool Whether the query is for a search.
	 */
	public function is_search() {
		return (bool) $this-&gt;is_search;
	}

	/**
	 * Is the query for an existing single post?
	 *
	 * Works for any post type excluding pages.
	 *
	 * If the $post parameter is specified, this function will additionally
	 * check if the query is for one of the Posts specified.
	 *
	 * @see WP_Query::is_page()
	 * @see WP_Query::is_singular()
	 *
	 * @since 3.1.0
	 *
	 * @param int|string|int[]|string[] $post Optional. Post ID, title, slug, path, or array of such
	 *                                        to check against. Default empty.
	 * @return bool Whether the query is for an existing single post.
	 */
	public function is_single( $post = '' ) {
		if ( ! $this-&gt;is_single ) {
			return false;
		}

		if ( empty( $post ) ) {
			return true;
		}

		$post_obj = $this-&gt;get_queried_object();

		$post = array_map( 'strval', (array) $post );

		if ( in_array( (string) $post_obj-&gt;ID, $post, true ) ) {
			return true;
		} elseif ( in_array( $post_obj-&gt;post_title, $post, true ) ) {
			return true;
		} elseif ( in_array( $post_obj-&gt;post_name, $post, true ) ) {
			return true;
		} else {
			foreach ( $post as $postpath ) {
				if ( ! strpos( $postpath, '/' ) ) {
					continue;
				}
				$postpath_obj = get_page_by_path( $postpath, OBJECT, $post_obj-&gt;post_type );

				if ( $postpath_obj &amp;&amp; ( $postpath_obj-&gt;ID == $post_obj-&gt;ID ) ) {
					return true;
				}
			}
		}
		return false;
	}

	/**
	 * Is the query for an existing single post of any post type (post, attachment, page,
	 * custom post types)?
	 *
	 * If the $post_types parameter is specified, this function will additionally
	 * check if the query is for one of the Posts Types specified.
	 *
	 * @see WP_Query::is_page()
	 * @see WP_Query::is_single()
	 *
	 * @since 3.1.0
	 *
	 * @param string|string[] $post_types Optional. Post type or array of post types
	 *                                    to check against. Default empty.
	 * @return bool Whether the query is for an existing single post
	 *              or any of the given post types.
	 */
	public function is_singular( $post_types = '' ) {
		if ( empty( $post_types ) || ! $this-&gt;is_singular ) {
			return (bool) $this-&gt;is_singular;
		}

		$post_obj = $this-&gt;get_queried_object();

		return in_array( $post_obj-&gt;post_type, (array) $post_types, true );
	}

	/**
	 * Is the query for a specific time?
	 *
	 * @since 3.1.0
	 *
	 * @return bool Whether the query is for a specific time.
	 */
	public function is_time() {
		return (bool) $this-&gt;is_time;
	}

	/**
	 * Is the query for a trackback endpoint call?
	 *
	 * @since 3.1.0
	 *
	 * @return bool Whether the query is for a trackback endpoint call.
	 */
	public function is_trackback() {
		return (bool) $this-&gt;is_trackback;
	}

	/**
	 * Is the query for an existing year archive?
	 *
	 * @since 3.1.0
	 *
	 * @return bool Whether the query is for an existing year archive.
	 */
	public function is_year() {
		return (bool) $this-&gt;is_year;
	}

	/**
	 * Is the query a 404 (returns no results)?
	 *
	 * @since 3.1.0
	 *
	 * @return bool Whether the query is a 404 error.
	 */
	public function is_404() {
		return (bool) $this-&gt;is_404;
	}

	/**
	 * Is the query for an embedded post?
	 *
	 * @since 4.4.0
	 *
	 * @return bool Whether the query is for an embedded post.
	 */
	public function is_embed() {
		return (bool) $this-&gt;is_embed;
	}

	/**
	 * Is the query the main query?
	 *
	 * @since 3.3.0
	 *
	 * @global WP_Query $wp_query WordPress Query object.
	 *
	 * @return bool Whether the query is the main query.
	 */
	public function is_main_query() {
		global $wp_the_query;
		return $wp_the_query === $this;
	}

	/**
	 * Set up global post data.
	 *
	 * @since 4.1.0
	 * @since 4.4.0 Added the ability to pass a post ID to `$post`.
	 *
	 * @global int     $id
	 * @global WP_User $authordata
	 * @global string  $currentday
	 * @global string  $currentmonth
	 * @global int     $page
	 * @global array   $pages
	 * @global int     $multipage
	 * @global int     $more
	 * @global int     $numpages
	 *
	 * @param WP_Post|object|int $post WP_Post instance or Post ID/object.
	 * @return true True when finished.
	 */
	public function setup_postdata( $post ) {
		global $id, $authordata, $currentday, $currentmonth, $page, $pages, $multipage, $more, $numpages;

		if ( ! ( $post instanceof WP_Post ) ) {
			$post = get_post( $post );
		}

		if ( ! $post ) {
			return;
		}

		$elements = $this-&gt;generate_postdata( $post );
		if ( false === $elements ) {
			return;
		}

		$id           = $elements['id'];
		$authordata   = $elements['authordata'];
		$currentday   = $elements['currentday'];
		$currentmonth = $elements['currentmonth'];
		$page         = $elements['page'];
		$pages        = $elements['pages'];
		$multipage    = $elements['multipage'];
		$more         = $elements['more'];
		$numpages     = $elements['numpages'];

		/**
		 * Fires once the post data has been set up.
		 *
		 * @since 2.8.0
		 * @since 4.1.0 Introduced `$this` parameter.
		 *
		 * @param WP_Post  $post The Post object (passed by reference).
		 * @param WP_Query $this The current Query object (passed by reference).
		 */
		do_action_ref_array( 'the_post', array( &amp;$post, &amp;$this ) );

		return true;
	}

	/**
	 * Generate post data.
	 *
	 * @since 5.2.0
	 *
	 * @param WP_Post|object|int $post WP_Post instance or Post ID/object.
	 * @return array|bool Elements of post or false on failure.
	 */
	public function generate_postdata( $post ) {

		if ( ! ( $post instanceof WP_Post ) ) {
			$post = get_post( $post );
		}

		if ( ! $post ) {
			return false;
		}

		$id = (int) $post-&gt;ID;

		$authordata = get_userdata( $post-&gt;post_author );

		$currentday   = mysql2date( 'd.m.y', $post-&gt;post_date, false );
		$currentmonth = mysql2date( 'm', $post-&gt;post_date, false );
		$numpages     = 1;
		$multipage    = 0;
		$page         = $this-&gt;get( 'page' );
		if ( ! $page ) {
			$page = 1;
		}

		/*
		 * Force full post content when viewing the permalink for the $post,
		 * or when on an RSS feed. Otherwise respect the 'more' tag.
		 */
		if ( get_queried_object_id() === $post-&gt;ID &amp;&amp; ( $this-&gt;is_page() || $this-&gt;is_single() ) ) {
			$more = 1;
		} elseif ( $this-&gt;is_feed() ) {
			$more = 1;
		} else {
			$more = 0;
		}

		$content = $post-&gt;post_content;
		if ( false !== strpos( $content, '&lt;!--nextpage--&gt;' ) ) {
			$content = str_replace( "\n&lt;!--nextpage--&gt;\n", '&lt;!--nextpage--&gt;', $content );
			$content = str_replace( "\n&lt;!--nextpage--&gt;", '&lt;!--nextpage--&gt;', $content );
			$content = str_replace( "&lt;!--nextpage--&gt;\n", '&lt;!--nextpage--&gt;', $content );

			// Remove the nextpage block delimiters, to avoid invalid block structures in the split content.
			$content = str_replace( '&lt;!-- wp:nextpage --&gt;', '', $content );
			$content = str_replace( '&lt;!-- /wp:nextpage --&gt;', '', $content );

			// Ignore nextpage at the beginning of the content.
			if ( 0 === strpos( $content, '&lt;!--nextpage--&gt;' ) ) {
				$content = substr( $content, 15 );
			}

			$pages = explode( '&lt;!--nextpage--&gt;', $content );
		} else {
			$pages = array( $post-&gt;post_content );
		}

		/**
		 * Filters the "pages" derived from splitting the post content.
		 *
		 * "Pages" are determined by splitting the post content based on the presence
		 * of `&lt;!-- nextpage --&gt;` tags.
		 *
		 * @since 4.4.0
		 *
		 * @param string[] $pages Array of "pages" from the post content split by `&lt;!-- nextpage --&gt;` tags.
		 * @param WP_Post  $post  Current post object.
		 */
		$pages = apply_filters( 'content_pagination', $pages, $post );

		$numpages = count( $pages );

		if ( $numpages &gt; 1 ) {
			if ( $page &gt; 1 ) {
				$more = 1;
			}
			$multipage = 1;
		} else {
			$multipage = 0;
		}

		$elements = compact( 'id', 'authordata', 'currentday', 'currentmonth', 'page', 'pages', 'multipage', 'more', 'numpages' );

		return $elements;
	}
	/**
	 * After looping through a nested query, this function
	 * restores the $post global to the current post in this query.
	 *
	 * @since 3.7.0
	 *
	 * @global WP_Post $post Global post object.
	 */
	public function reset_postdata() {
		if ( ! empty( $this-&gt;post ) ) {
			$GLOBALS['post'] = $this-&gt;post;
			$this-&gt;setup_postdata( $this-&gt;post );
		}
	}

	/**
	 * Lazyload term meta for posts in the loop.
	 *
	 * @since 4.4.0
	 * @deprecated 4.5.0 See wp_queue_posts_for_term_meta_lazyload().
	 *
	 * @param mixed $check
	 * @param int   $term_id
	 * @return mixed
	 */
	public function lazyload_term_meta( $check, $term_id ) {
		_deprecated_function( __METHOD__, '4.5.0' );
		return $check;
	}

	/**
	 * Lazyload comment meta for comments in the loop.
	 *
	 * @since 4.4.0
	 * @deprecated 4.5.0 See wp_queue_comments_for_comment_meta_lazyload().
	 *
	 * @param mixed $check
	 * @param int   $comment_id
	 * @return mixed
	 */
	public function lazyload_comment_meta( $check, $comment_id ) {
		_deprecated_function( __METHOD__, '4.5.0' );
		return $check;
	}
}</pre>  </section>  <section class="class-methods"> <h2 class="toc-heading" id="methods" tabindex="-1">Methods </h2> <ul> <li>
<a href="wp_query/__call"> __call</a> — Make private/protected methods readable for backward compatibility. </li> <li>
<a href="wp_query/__construct"> __construct</a> — Constructor. </li> <li>
<a href="wp_query/__get"> __get</a> — Make private properties readable for backward compatibility. </li> <li>
<a href="wp_query/__isset"> __isset</a> — Make private properties checkable for backward compatibility. </li> <li>
<a href="wp_query/__unset"> __unset</a> — Make private properties settable for backwards compatibility. </li> <li>
<a href="wp_query/fill_query_vars"> fill_query_vars</a> — Fills in the query variables, which do not exist within the parameter. </li> <li>
<a href="wp_query/generate_postdata"> generate_postdata</a> — Generate post data. </li> <li>
<a href="wp_query/get"> get</a> — Retrieve query variable. </li> <li>
<a href="wp_query/get_posts"> get_posts</a> — Retrieves an array of posts based on query variables. </li> <li>
<a href="wp_query/get_queried_object"> get_queried_object</a> — Retrieve queried object. </li> <li>
<a href="wp_query/get_queried_object_id"> get_queried_object_id</a> — Retrieve ID of the current queried object. </li> <li>
<a href="wp_query/get_search_stopwords"> get_search_stopwords</a> — Retrieve stopwords used when parsing search terms. </li> <li>
<a href="wp_query/have_comments"> have_comments</a> — Whether there are more comments available. </li> <li>
<a href="wp_query/have_posts"> have_posts</a> — Determines whether there are more posts available in the loop. </li> <li>
<a href="wp_query/init"> init</a> — Initiates object properties and sets default values. </li> <li>
<a href="wp_query/init_query_flags"> init_query_flags</a> — Resets query flags to false. </li> <li>
<a href="wp_query/is_404"> is_404</a> — Is the query a 404 (returns no results)? </li> <li>
<a href="wp_query/is_archive"> is_archive</a> — Is the query for an existing archive page? </li> <li>
<a href="wp_query/is_attachment"> is_attachment</a> — Is the query for an existing attachment page? </li> <li>
<a href="wp_query/is_author"> is_author</a> — Is the query for an existing author archive page? </li> <li>
<a href="wp_query/is_category"> is_category</a> — Is the query for an existing category archive page? </li> <li>
<a href="wp_query/is_comment_feed"> is_comment_feed</a> — Is the query for a comments feed? </li> <li>
<a href="wp_query/is_comments_popup"> is_comments_popup</a> — Whether the current URL is within the comments popup window. — <span class="deprecated-method">deprecated</span> </li> <li>
<a href="wp_query/is_date"> is_date</a> — Is the query for an existing date archive? </li> <li>
<a href="wp_query/is_day"> is_day</a> — Is the query for an existing day archive? </li> <li>
<a href="wp_query/is_embed"> is_embed</a> — Is the query for an embedded post? </li> <li>
<a href="wp_query/is_favicon"> is_favicon</a> — Is the query for the favicon.ico file? </li> <li>
<a href="wp_query/is_feed"> is_feed</a> — Is the query for a feed? </li> <li>
<a href="wp_query/is_front_page"> is_front_page</a> — Is the query for the front page of the site? </li> <li>
<a href="wp_query/is_home"> is_home</a> — Is the query for the blog homepage? </li> <li>
<a href="wp_query/is_main_query"> is_main_query</a> — Is the query the main query? </li> <li>
<a href="wp_query/is_month"> is_month</a> — Is the query for an existing month archive? </li> <li>
<a href="wp_query/is_page"> is_page</a> — Is the query for an existing single page? </li> <li>
<a href="wp_query/is_paged"> is_paged</a> — Is the query for a paged result and not for the first page? </li> <li>
<a href="wp_query/is_post_type_archive"> is_post_type_archive</a> — Is the query for an existing post type archive page? </li> <li>
<a href="wp_query/is_preview"> is_preview</a> — Is the query for a post or page preview? </li> <li>
<a href="wp_query/is_privacy_policy"> is_privacy_policy</a> — Is the query for the Privacy Policy page? </li> <li>
<a href="wp_query/is_robots"> is_robots</a> — Is the query for the robots.txt file? </li> <li>
<a href="wp_query/is_search"> is_search</a> — Is the query for a search? </li> <li>
<a href="wp_query/is_single"> is_single</a> — Is the query for an existing single post? </li> <li>
<a href="wp_query/is_singular"> is_singular</a> — Is the query for an existing single post of any post type (post, attachment, page, custom post types)? </li> <li>
<a href="wp_query/is_tag"> is_tag</a> — Is the query for an existing tag archive page? </li> <li>
<a href="wp_query/is_tax"> is_tax</a> — Is the query for an existing custom taxonomy archive page? </li> <li>
<a href="wp_query/is_time"> is_time</a> — Is the query for a specific time? </li> <li>
<a href="wp_query/is_trackback"> is_trackback</a> — Is the query for a trackback endpoint call? </li> <li>
<a href="wp_query/is_year"> is_year</a> — Is the query for an existing year archive? </li> <li>
<a href="wp_query/lazyload_comment_meta"> lazyload_comment_meta</a> — Lazyload comment meta for comments in the loop. — <span class="deprecated-method">deprecated</span> </li> <li>
<a href="wp_query/lazyload_term_meta"> lazyload_term_meta</a> — Lazyload term meta for posts in the loop. — <span class="deprecated-method">deprecated</span> </li> <li>
<a href="wp_query/next_comment"> next_comment</a> — Iterate current comment index and return WP_Comment object. </li> <li>
<a href="wp_query/next_post"> next_post</a> — Set up the next post and iterate current post index. </li> <li>
<a href="wp_query/parse_order"> parse_order</a> — Parse an 'order' query variable and cast it to ASC or DESC as necessary. </li> <li>
<a href="wp_query/parse_orderby"> parse_orderby</a> — Converts the given orderby alias (if allowed) to a properly-prefixed value. </li> <li>
<a href="wp_query/parse_query"> parse_query</a> — Parse a query string and set query type booleans. </li> <li>
<a href="wp_query/parse_query_vars"> parse_query_vars</a> — Reparse the query vars. </li> <li>
<a href="wp_query/parse_search"> parse_search</a> — Generates SQL for the WHERE clause based on passed search terms. </li> <li>
<a href="wp_query/parse_search_order"> parse_search_order</a> — Generates SQL for the ORDER BY condition based on passed search terms. </li> <li>
<a href="wp_query/parse_search_terms"> parse_search_terms</a> — Check if the terms are suitable for searching. </li> <li>
<a href="wp_query/parse_tax_query"> parse_tax_query</a> — Parses various taxonomy related query vars. </li> <li>
<a href="wp_query/query"> query</a> — Sets up the WordPress query by parsing query string. </li> <li>
<a href="wp_query/reset_postdata"> reset_postdata</a> — After looping through a nested query, this function restores the $post global to the current post in this query. </li> <li>
<a href="wp_query/rewind_comments"> rewind_comments</a> — Rewind the comments, resets the comment index and comment to first. </li> <li>
<a href="wp_query/rewind_posts"> rewind_posts</a> — Rewind the posts and reset post index. </li> <li>
<a href="wp_query/set"> set</a> — Set query variable. </li> <li>
<a href="wp_query/set_404"> set_404</a> — Sets the 404 property and saves whether query is feed. </li> <li>
<a href="wp_query/set_found_posts"> set_found_posts</a> — Set up the amount of found posts and the number of pages (if limit clause was used) for the current query. </li> <li>
<a href="wp_query/setup_postdata"> setup_postdata</a> — Set up global post data. </li> <li>
<a href="wp_query/the_comment"> the_comment</a> — Sets up the current comment. </li> <li>
<a href="wp_query/the_post"> the_post</a> — Sets up the current post. </li> </ul> </section>  <section class="changelog"> <h2 class="toc-heading" id="changelog" tabindex="-1">Changelog </h2> <table>  <thead> <tr> <th class="changelog-version">Version</th> <th class="changelog-desc">Description</th> </tr> </thead> <tbody> <tr> <td><a href="https://developer.wordpress.org/reference/since/4.5.0/" alt="WordPress 4.5.0">4.5.0</a></td> <td><span class="since-description">Removed the <code>$comments_popup</code> property.</span></td> </tr> <tr> <td><a href="https://developer.wordpress.org/reference/since/1.5.0/" alt="WordPress 1.5.0">1.5.0</a></td> <td>Introduced.</td> </tr> </tbody> </table> </section>   </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2003–2019 WordPress Foundation<br>Licensed under the GNU GPLv2+ License.<br>
    <a href="https://developer.wordpress.org/reference/classes/wp_query" class="_attribution-link">https://developer.wordpress.org/reference/classes/wp_query</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
