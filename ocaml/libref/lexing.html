
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Lexing - OCaml - W3cubDocs</title>
  
  <meta name="description" content=" The run-time library for lexers generated by ocamllex. ">
  <meta name="keywords" content="module, lexing, ocaml">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/ocaml/libref/lexing.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-c2f2e7d1236e299f399a2d9bf4342fa70a8839fbe6eb79130546d6bf383b99636ffdf29c557090085d7c4ac34eeb5426851b42d2f4ec63cf218916cbd19aa876.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/ocaml.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/ocaml/" class="_nav-link" title="" style="margin-left:0;">OCaml</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _ocaml">
				
				
<h1>Module Lexing</h1> <pre id="MODULELexing" data-type="module Lexing [Module Lexing]" data-language="ocaml">module Lexing: sig .. end</pre>
<div class="info module top"> <div class="info-desc"> <p>The run-time library for lexers generated by <code class="code">ocamllex</code>.</p> </div> </div> <hr width="100%"> <h2 id="1_Positions">Positions</h2> <pre id="TYPEposition" data-type="type position [Module Lexing]" data-language="ocaml">type position = {</pre>
<table class="typetable"> <tr> <td align="left" valign="top"> 
</td> <td align="left" valign="top"> <code><span id="TYPEELTposition.pos_fname">pos_fname</span> : <code class="type">string</code>;</code>
</td> </tr> <tr> <td align="left" valign="top"> 
</td> <td align="left" valign="top"> <code><span id="TYPEELTposition.pos_lnum">pos_lnum</span> : <code class="type">int</code>;</code>
</td> </tr> <tr> <td align="left" valign="top"> 
</td> <td align="left" valign="top"> <code><span id="TYPEELTposition.pos_bol">pos_bol</span> : <code class="type">int</code>;</code>
</td> </tr> <tr> <td align="left" valign="top"> 
</td> <td align="left" valign="top"> <code><span id="TYPEELTposition.pos_cnum">pos_cnum</span> : <code class="type">int</code>;</code>
</td> </tr>
</table> <code>}</code> <div class="info "> <div class="info-desc"> <p>A value of type <code class="code">position</code> describes a point in a source file. <code class="code">pos_fname</code> is the file name; <code class="code">pos_lnum</code> is the line number; <code class="code">pos_bol</code> is the offset of the beginning of the line (number of characters between the beginning of the lexbuf and the beginning of the line); <code class="code">pos_cnum</code> is the offset of the position (number of characters between the beginning of the lexbuf and the position). The difference between <code class="code">pos_cnum</code> and <code class="code">pos_bol</code> is the character offset within the line (i.e. the column number, assuming each character is one column wide).</p> <p>See the documentation of type <code class="code">lexbuf</code> for information about how the lexing engine will manage positions.</p> </div> </div> <pre id="VALdummy_pos" data-type="val dummy_pos [Module Lexing]" data-language="ocaml">val dummy_pos : position</pre>
<div class="info "> <div class="info-desc"> <p>A value of type <code class="code">position</code>, guaranteed to be different from any valid position.</p> </div> </div> <h2 id="1_Lexerbuffers">Lexer buffers</h2> <pre id="TYPElexbuf" data-type="type lexbuf [Module Lexing]" data-language="ocaml">type lexbuf = {</pre>
<table class="typetable"> <tr> <td align="left" valign="top"> 
</td> <td align="left" valign="top"> <code><span id="TYPEELTlexbuf.refill_buff">refill_buff</span> : <code class="type"><a href="lexing#TYPElexbuf">lexbuf</a> -&gt; unit</code>;</code>
</td> </tr> <tr> <td align="left" valign="top"> 
</td> <td align="left" valign="top"> <code><span class="keyword">mutable </span><span id="TYPEELTlexbuf.lex_buffer">lex_buffer</span> : <code class="type">bytes</code>;</code>
</td> </tr> <tr> <td align="left" valign="top"> 
</td> <td align="left" valign="top"> <code><span class="keyword">mutable </span><span id="TYPEELTlexbuf.lex_buffer_len">lex_buffer_len</span> : <code class="type">int</code>;</code>
</td> </tr> <tr> <td align="left" valign="top"> 
</td> <td align="left" valign="top"> <code><span class="keyword">mutable </span><span id="TYPEELTlexbuf.lex_abs_pos">lex_abs_pos</span> : <code class="type">int</code>;</code>
</td> </tr> <tr> <td align="left" valign="top"> 
</td> <td align="left" valign="top"> <code><span class="keyword">mutable </span><span id="TYPEELTlexbuf.lex_start_pos">lex_start_pos</span> : <code class="type">int</code>;</code>
</td> </tr> <tr> <td align="left" valign="top"> 
</td> <td align="left" valign="top"> <code><span class="keyword">mutable </span><span id="TYPEELTlexbuf.lex_curr_pos">lex_curr_pos</span> : <code class="type">int</code>;</code>
</td> </tr> <tr> <td align="left" valign="top"> 
</td> <td align="left" valign="top"> <code><span class="keyword">mutable </span><span id="TYPEELTlexbuf.lex_last_pos">lex_last_pos</span> : <code class="type">int</code>;</code>
</td> </tr> <tr> <td align="left" valign="top"> 
</td> <td align="left" valign="top"> <code><span class="keyword">mutable </span><span id="TYPEELTlexbuf.lex_last_action">lex_last_action</span> : <code class="type">int</code>;</code>
</td> </tr> <tr> <td align="left" valign="top"> 
</td> <td align="left" valign="top"> <code><span class="keyword">mutable </span><span id="TYPEELTlexbuf.lex_eof_reached">lex_eof_reached</span> : <code class="type">bool</code>;</code>
</td> </tr> <tr> <td align="left" valign="top"> 
</td> <td align="left" valign="top"> <code><span class="keyword">mutable </span><span id="TYPEELTlexbuf.lex_mem">lex_mem</span> : <code class="type">int array</code>;</code>
</td> </tr> <tr> <td align="left" valign="top"> 
</td> <td align="left" valign="top"> <code><span class="keyword">mutable </span><span id="TYPEELTlexbuf.lex_start_p">lex_start_p</span> : <code class="type"><a href="lexing#TYPEposition">position</a></code>;</code>
</td> </tr> <tr> <td align="left" valign="top"> 
</td> <td align="left" valign="top"> <code><span class="keyword">mutable </span><span id="TYPEELTlexbuf.lex_curr_p">lex_curr_p</span> : <code class="type"><a href="lexing#TYPEposition">position</a></code>;</code>
</td> </tr>
</table> <code>}</code> <div class="info "> <div class="info-desc"> <p>The type of lexer buffers. A lexer buffer is the argument passed to the scanning functions defined by the generated scanners. The lexer buffer holds the current state of the scanner, plus a function to refill the buffer from the input.</p> <p>Lexers can optionally maintain the <code class="code">lex_curr_p</code> and <code class="code">lex_start_p</code> position fields. This "position tracking" mode is the default, and it corresponds to passing <code class="code">~with_position:<span class="keyword">true</span></code> to functions that create lexer buffers. In this mode, the lexing engine and lexer actions are co-responsible for properly updating the position fields, as described in the next paragraph. When the mode is explicitly disabled (with <code class="code">~with_position:<span class="keyword">false</span></code>), the lexing engine will not touch the position fields and the lexer actions should be careful not to do it either; the <code class="code">lex_curr_p</code> and <code class="code">lex_start_p</code> field will then always hold the <code class="code">dummy_pos</code> invalid position. Not tracking positions avoids allocations and memory writes and can significantly improve the performance of the lexer in contexts where <code class="code">lex_start_p</code> and <code class="code">lex_curr_p</code> are not needed.</p> <p>Position tracking mode works as follows. At each token, the lexing engine will copy <code class="code">lex_curr_p</code> to <code class="code">lex_start_p</code>, then change the <code class="code">pos_cnum</code> field of <code class="code">lex_curr_p</code> by updating it with the number of characters read since the start of the <code class="code">lexbuf</code>. The other fields are left unchanged by the lexing engine. In order to keep them accurate, they must be initialised before the first use of the lexbuf, and updated by the relevant lexer actions (i.e. at each end of line -- see also <code class="code">new_line</code>).</p> </div> </div> <pre id="VALfrom_channel" data-type="val from_channel [Module Lexing]" data-language="ocaml">val from_channel : ?with_positions:bool -&gt; in_channel -&gt; lexbuf</pre>
<div class="info "> <div class="info-desc"> <p>Create a lexer buffer on the given input channel. <code class="code"><span class="constructor">Lexing</span>.from_channel inchan</code> returns a lexer buffer which reads from the input channel <code class="code">inchan</code>, at the current reading position.</p> </div> </div> <pre id="VALfrom_string" data-type="val from_string [Module Lexing]" data-language="ocaml">val from_string : ?with_positions:bool -&gt; string -&gt; lexbuf</pre>
<div class="info "> <div class="info-desc"> <p>Create a lexer buffer which reads from the given string. Reading starts from the first character in the string. An end-of-input condition is generated when the end of the string is reached.</p> </div> </div> <pre id="VALfrom_function" data-type="val from_function [Module Lexing]" data-language="ocaml">val from_function : ?with_positions:bool -&gt; (bytes -&gt; int -&gt; int) -&gt; lexbuf</pre>
<div class="info "> <div class="info-desc"> <p>Create a lexer buffer with the given function as its reading method. When the scanner needs more characters, it will call the given function, giving it a byte sequence <code class="code">s</code> and a byte count <code class="code">n</code>. The function should put <code class="code">n</code> bytes or fewer in <code class="code">s</code>, starting at index 0, and return the number of bytes provided. A return value of 0 means end of input.</p> </div> </div> <pre id="VALset_position" data-type="val set_position [Module Lexing]" data-language="ocaml">val set_position : lexbuf -&gt; position -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p>Set the initial tracked input position for <code class="code">lexbuf</code> to a custom value. Ignores <code class="code">pos_fname</code>. See <a href="lexing#VALset_filename"><code class="code"><span class="constructor">Lexing</span>.set_filename</code></a> for changing this field.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.11</li> </ul> </div> <pre id="VALset_filename" data-type="val set_filename [Module Lexing]" data-language="ocaml">val set_filename : lexbuf -&gt; string -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p>Set filename in the initial tracked position to <code class="code">file</code> in <code class="code">lexbuf</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.11</li> </ul> </div> <pre id="VALwith_positions" data-type="val with_positions [Module Lexing]" data-language="ocaml">val with_positions : lexbuf -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p>Tell whether the lexer buffer keeps track of position fields <code class="code">lex_curr_p</code> / <code class="code">lex_start_p</code>, as determined by the corresponding optional argument for functions that create lexer buffers (whose default value is <code class="code"><span class="keyword">true</span></code>).</p> <p>When <code class="code">with_positions</code> is <code class="code"><span class="keyword">false</span></code>, lexer actions should not modify position fields. Doing it nevertheless could re-enable the <code class="code">with_position</code> mode and degrade performances.</p> </div> </div> <h2 id="1_Functionsforlexersemanticactions">Functions for lexer semantic actions</h2>
<p>The following functions can be called from the semantic actions of lexer definitions (the ML code enclosed in braces that computes the value returned by lexing functions). They give access to the character string matched by the regular expression associated with the semantic action. These functions must be applied to the argument <code class="code">lexbuf</code>, which, in the code generated by <code class="code">ocamllex</code>, is bound to the lexer buffer passed to the parsing function.</p> <pre id="VALlexeme" data-type="val lexeme [Module Lexing]" data-language="ocaml">val lexeme : lexbuf -&gt; string</pre>
<div class="info "> <div class="info-desc"> <p><code class="code"><span class="constructor">Lexing</span>.lexeme lexbuf</code> returns the string matched by the regular expression.</p> </div> </div> <pre id="VALlexeme_char" data-type="val lexeme_char [Module Lexing]" data-language="ocaml">val lexeme_char : lexbuf -&gt; int -&gt; char</pre>
<div class="info "> <div class="info-desc"> <p><code class="code"><span class="constructor">Lexing</span>.lexeme_char lexbuf i</code> returns character number <code class="code">i</code> in the matched string.</p> </div> </div> <pre id="VALlexeme_start" data-type="val lexeme_start [Module Lexing]" data-language="ocaml">val lexeme_start : lexbuf -&gt; int</pre>
<div class="info "> <div class="info-desc"> <p><code class="code"><span class="constructor">Lexing</span>.lexeme_start lexbuf</code> returns the offset in the input stream of the first character of the matched string. The first character of the stream has offset 0.</p> </div> </div> <pre id="VALlexeme_end" data-type="val lexeme_end [Module Lexing]" data-language="ocaml">val lexeme_end : lexbuf -&gt; int</pre>
<div class="info "> <div class="info-desc"> <p><code class="code"><span class="constructor">Lexing</span>.lexeme_end lexbuf</code> returns the offset in the input stream of the character following the last character of the matched string. The first character of the stream has offset 0.</p> </div> </div> <pre id="VALlexeme_start_p" data-type="val lexeme_start_p [Module Lexing]" data-language="ocaml">val lexeme_start_p : lexbuf -&gt; position</pre>
<div class="info "> <div class="info-desc"> <p>Like <code class="code">lexeme_start</code>, but return a complete <code class="code">position</code> instead of an offset. When position tracking is disabled, the function returns <code class="code">dummy_pos</code>.</p> </div> </div> <pre id="VALlexeme_end_p" data-type="val lexeme_end_p [Module Lexing]" data-language="ocaml">val lexeme_end_p : lexbuf -&gt; position</pre>
<div class="info "> <div class="info-desc"> <p>Like <code class="code">lexeme_end</code>, but return a complete <code class="code">position</code> instead of an offset. When position tracking is disabled, the function returns <code class="code">dummy_pos</code>.</p> </div> </div> <pre id="VALnew_line" data-type="val new_line [Module Lexing]" data-language="ocaml">val new_line : lexbuf -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p>Update the <code class="code">lex_curr_p</code> field of the lexbuf to reflect the start of a new line. You can call this function in the semantic action of the rule that matches the end-of-line character. The function does nothing when position tracking is disabled.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 3.11.0</li> </ul> </div> <h2 id="1_Miscellaneousfunctions">Miscellaneous functions</h2> <pre id="VALflush_input" data-type="val flush_input [Module Lexing]" data-language="ocaml">val flush_input : lexbuf -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p>Discard the contents of the buffer and reset the current position to 0. The next use of the lexbuf will trigger a refill.</p> </div> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © INRIA 1995-2020.<br>
    <a href="https://www.ocaml.org/releases/4.11/htmlman/libref/Lexing.html" class="_attribution-link">https://www.ocaml.org/releases/4.11/htmlman/libref/Lexing.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
