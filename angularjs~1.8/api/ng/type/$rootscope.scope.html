
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>&#36;rootScope.Scope - Angular.js 1.8 - W3cubDocs</title>
  
  <meta name="description" content="A root scope can be retrieved using the &#36;rootScope key from the &#36;injector. Child scopes are created using the &#36;new() method. (Most &hellip;">
  <meta name="keywords" content="&#36;rootscope, scope, angular, js, angularjs~1.8">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/angularjs~1.8/api/ng/type/$rootscope.scope.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/angularjs~1.8.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/angularjs~1.8/" class="_nav-link" title="" style="margin-left:0;">Angular.js 1.8</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _angularjs">
				
				
<h1 class="api-profile-header-heading">
<a href="https://github.com/angular/angular.js/edit/v1.8.x/src/ng/rootScope.js?message=docs(%24rootScope.Scope)%3A%20describe%20your%20change...#L135" class="improve-docs btn btn-primary">Improve this Doc</a><a href="https://github.com/angular/angular.js/tree/v1.8.2/src/ng/rootScope.js#L135" class="view-source pull-right btn btn-primary"> View Source </a>$rootScope.Scope</h1> <ol class="api-profile-header-structure naked-list step-list"> <li> type in module <a href="https://code.angularjs.org/1.8.2/docs/api/ng">ng</a> </li> </ol>  <div class="api-profile-description"> <h2 id="overview">Overview</h2> <p>A root scope can be retrieved using the <a href="../service/%24rootscope">$rootScope</a> key from the <a href="../../auto/service/%24injector">$injector</a>. Child scopes are created using the <a href="%24rootscope.scope#%24new.html">$new()</a> method. (Most scopes are created automatically when compiled HTML template is executed.) See also the <a href="../../../guide/scope">Scopes guide</a> for an in-depth introduction and usage examples.</p> <h2 id="inheritance">Inheritance</h2> <p>A scope can inherit from a parent scope, as in this example:</p> <pre data-language="javascript">var parent = $rootScope;
var child = parent.$new();

parent.salutation = "Hello";
expect(child.salutation).toEqual('Hello');

child.salutation = "Welcome";
expect(child.salutation).toEqual('Welcome');
expect(parent.salutation).toEqual('Hello');
</pre> <p>When interacting with <code>Scope</code> in tests, additional helper methods are available on the instances of <code>Scope</code> type. See <a href="../../ngmock/type/%24rootscope.scope">ngMock Scope</a> for additional details.</p> </div> <div> <h2 id="usage">Usage</h2> <p><code>$rootScope.Scope([providers], [instanceCache]);</code></p> <section class="api-section"> <h3 id="$rootScope.Scope-arguments">Arguments</h3> <table class="variables-matrix input-arguments"> <thead> <tr> <th>Param</th> <th>Type</th> <th>Details</th> </tr> </thead> <tbody> <tr> <td> providers <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-object">Object.&lt;string, function()&gt;=</code> </td> <td> <p>Map of service factory which need to be provided for the current scope. Defaults to <a href="https://code.angularjs.org/1.8.2/docs/api/ng"><code>ng</code></a>.</p> </td> </tr> <tr> <td> instanceCache <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-object">Object.&lt;string, *&gt;=</code> </td> <td> <p>Provides pre-instantiated services which should append/override services provided by <code>providers</code>. This is handy when unit-testing and having the need to override a default service.</p> </td> </tr> </tbody> </table> </section> <h3 id="$rootScope.Scope-returns">Returns</h3> <table class="variables-matrix return-arguments"> <tr> <td><code class="label type-hint type-hint-object">Object</code></td> <td>
<p>Newly created scope.</p> </td> </tr> </table> <h2 id="$rootScope.Scope-methods">Methods</h2> <ul class="methods defs"> <li> <h3 id="$new">$new(isolate, parent);</h3> <div>
<p>Creates a new child <a href="%24rootscope.scope">scope</a>.</p> <p>The parent scope will propagate the <a href="%24rootscope.scope#%24digest.html">$digest()</a> event. The scope can be removed from the scope hierarchy using <a href="%24rootscope.scope#%24destroy.html">$destroy()</a>.</p> <p><a href="%24rootscope.scope#%24destroy.html">$destroy()</a> must be called on a scope when it is desired for the scope and its child scopes to be permanently detached from the parent and thus stop participating in model change detection and listener notification by invoking.</p> </div> <h4>Parameters</h4> <table class="variables-matrix input-arguments"> <thead> <tr> <th>Param</th> <th>Type</th> <th>Details</th> </tr> </thead> <tbody> <tr> <td> isolate </td> <td> <code class="label type-hint type-hint-boolean">boolean</code> </td> <td> <p>If true, then the scope does not prototypically inherit from the parent scope. The scope is isolated, as it can not see parent scope properties. When creating widgets, it is useful for the widget to not accidentally read parent state.</p> </td> </tr> <tr> <td> parent <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-scope">Scope</code> </td> <td> <p>The <a href="%24rootscope.scope"><code>Scope</code></a> that will be the <code>$parent</code> of the newly created scope. Defaults to <code>this</code> scope if not provided. This is used when creating a transclude scope to correctly place it in the scope hierarchy while maintaining the correct prototypical inheritance.</p> <p><em>(default: this)</em></p> </td> </tr> </tbody> </table> <h4>Returns</h4> <table class="variables-matrix return-arguments"> <tr> <td><code class="label type-hint type-hint-object">Object</code></td> <td>
<p>The newly created child scope.</p> </td> </tr> </table> </li> <li> <h3 id="$watch">$watch(watchExpression, listener, [objectEquality]);</h3> <div>
<p>Registers a <code>listener</code> callback to be executed whenever the <code>watchExpression</code> changes.</p> <ul> <li>The <code>watchExpression</code> is called on every call to <a href="%24rootscope.scope#%24digest.html">$digest()</a> and should return the value that will be watched. (<code>watchExpression</code> should not change its value when executed multiple times with the same input because it may be executed multiple times by <a href="%24rootscope.scope#%24digest.html">$digest()</a>. That is, <code>watchExpression</code> should be <a href="http://en.wikipedia.org/wiki/Idempotence">idempotent</a>.)</li> <li>The <code>listener</code> is called only when the value from the current <code>watchExpression</code> and the previous call to <code>watchExpression</code> are not equal (with the exception of the initial run, see below). Inequality is determined according to reference inequality, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators">strict comparison</a> via the <code>!==</code> Javascript operator, unless <code>objectEquality == true</code> (see next point)</li> <li>When <code>objectEquality == true</code>, inequality of the <code>watchExpression</code> is determined according to the <a href="../function/angular.equals"><code>angular.equals</code></a> function. To save the value of the object for later comparison, the <a href="../function/angular.copy"><code>angular.copy</code></a> function is used. This therefore means that watching complex objects will have adverse memory and performance implications.</li> <li>This should not be used to watch for changes in objects that are (or contain) <a href="https://developer.mozilla.org/docs/Web/API/File">File</a> objects due to limitations with <a href="../function/angular.copy"><code>angular.copy</code></a>.</li> <li>The watch <code>listener</code> may change the model, which may trigger other <code>listener</code>s to fire. This is achieved by rerunning the watchers until no changes are detected. The rerun iteration limit is 10 to prevent an infinite loop deadlock.</li> </ul> <p>If you want to be notified whenever <a href="%24rootscope.scope#%24digest.html">$digest</a> is called, you can register a <code>watchExpression</code> function with no <code>listener</code>. (Be prepared for multiple calls to your <code>watchExpression</code> because it will execute multiple times in a single <a href="%24rootscope.scope#%24digest.html">$digest</a> cycle if a change is detected.)</p> <p>After a watcher is registered with the scope, the <code>listener</code> fn is called asynchronously (via <a href="%24rootscope.scope#%24evalAsync.html">$evalAsync</a>) to initialize the watcher. In rare cases, this is undesirable because the listener is called when the result of <code>watchExpression</code> didn't change. To detect this scenario within the <code>listener</code> fn, you can compare the <code>newVal</code> and <code>oldVal</code>. If these two values are identical (<code>===</code>) then the listener was called due to initialization.</p> </div> <h4>Parameters</h4> <table class="variables-matrix input-arguments"> <thead> <tr> <th>Param</th> <th>Type</th> <th>Details</th> </tr> </thead> <tbody> <tr> <td> watchExpression </td> <td> <code class="label type-hint type-hint-function">function()</code><code class="label type-hint type-hint-string">string</code> </td> <td> <p>Expression that is evaluated on each <a href="%24rootscope.scope#%24digest.html">$digest</a> cycle. A change in the return value triggers a call to the <code>listener</code>.</p> <ul> <li>
<code>string</code>: Evaluated as <a href="../../../guide/expression">expression</a>
</li> <li>
<code>function(scope)</code>: called with current <code>scope</code> as a parameter.</li> </ul> </td> </tr> <tr> <td> listener </td> <td> <code class="label type-hint type-hint-function">function(newVal, oldVal, scope)</code> </td> <td> <p>Callback called whenever the value of <code>watchExpression</code> changes.</p> <ul> <li>
<code>newVal</code> contains the current value of the <code>watchExpression</code>
</li> <li>
<code>oldVal</code> contains the previous value of the <code>watchExpression</code>
</li> <li>
<code>scope</code> refers to the current scope</li> </ul> </td> </tr> <tr> <td> objectEquality <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-boolean">boolean</code> </td> <td> <p>Compare for object equality using <a href="../function/angular.equals"><code>angular.equals</code></a> instead of comparing for reference equality.</p> <p><em>(default: false)</em></p> </td> </tr> </tbody> </table> <h4>Returns</h4> <table class="variables-matrix return-arguments"> <tr> <td><code class="label type-hint type-hint-function">function()</code></td> <td>
<p>Returns a deregistration function for this listener.</p> </td> </tr> </table> <h4 id="$rootScope.Scope.$watch-examples">Example</h4>
<pre data-language="javascript">// let's assume that scope was dependency injected as the $rootScope
var scope = $rootScope;
scope.name = 'misko';
scope.counter = 0;

expect(scope.counter).toEqual(0);
scope.$watch('name', function(newValue, oldValue) {
  scope.counter = scope.counter + 1;
});
expect(scope.counter).toEqual(0);

scope.$digest();
// the listener is always called during the first $digest loop after it was registered
expect(scope.counter).toEqual(1);

scope.$digest();
// but now it will not be called unless the value changes
expect(scope.counter).toEqual(1);

scope.name = 'adam';
scope.$digest();
expect(scope.counter).toEqual(2);



// Using a function as a watchExpression
var food;
scope.foodCounter = 0;
expect(scope.foodCounter).toEqual(0);
scope.$watch(
  // This function returns the value being watched. It is called for each turn of the $digest loop
  function() { return food; },
  // This is the change listener, called when the value returned from the above function changes
  function(newValue, oldValue) {
    if ( newValue !== oldValue ) {
      // Only increment the counter if the value changed
      scope.foodCounter = scope.foodCounter + 1;
    }
  }
);
// No digest has been run so the counter will be zero
expect(scope.foodCounter).toEqual(0);

// Run the digest but since food has not changed count will still be zero
scope.$digest();
expect(scope.foodCounter).toEqual(0);

// Update food and run digest.  Now the counter will increment
food = 'cheeseburger';
scope.$digest();
expect(scope.foodCounter).toEqual(1);
</pre> </li> <li> <h3 id="$watchGroup">$watchGroup(watchExpressions, listener);</h3> <div>
<p>A variant of <a href="%24rootscope.scope#%24watch.html">$watch()</a> where it watches an array of <code>watchExpressions</code>. If any one expression in the collection changes the <code>listener</code> is executed.</p> <ul> <li>The items in the <code>watchExpressions</code> array are observed via the standard <code>$watch</code> operation. Their return values are examined for changes on every call to <code>$digest</code>.</li> <li>The <code>listener</code> is called whenever any expression in the <code>watchExpressions</code> array changes.</li> </ul> </div> <h4>Parameters</h4> <table class="variables-matrix input-arguments"> <thead> <tr> <th>Param</th> <th>Type</th> <th>Details</th> </tr> </thead> <tbody> <tr> <td> watchExpressions </td> <td> <code class="label type-hint type-hint-array">Array.&lt;string|Function(scope)&gt;</code> </td> <td> <p>Array of expressions that will be individually watched using <a href="%24rootscope.scope#%24watch.html">$watch()</a></p> </td> </tr> <tr> <td> listener </td> <td> <code class="label type-hint type-hint-function">function(newValues, oldValues, scope)</code> </td> <td> <p>Callback called whenever the return value of any expression in <code>watchExpressions</code> changes The <code>newValues</code> array contains the current values of the <code>watchExpressions</code>, with the indexes matching those of <code>watchExpression</code> and the <code>oldValues</code> array contains the previous values of the <code>watchExpressions</code>, with the indexes matching those of <code>watchExpression</code> The <code>scope</code> refers to the current scope.</p> </td> </tr> </tbody> </table> <h4>Returns</h4> <table class="variables-matrix return-arguments"> <tr> <td><code class="label type-hint type-hint-function">function()</code></td> <td>
<p>Returns a de-registration function for all listeners.</p> </td> </tr> </table> </li> <li> <h3 id="$watchCollection">$watchCollection(obj, listener);</h3> <div>
<p>Shallow watches the properties of an object and fires whenever any of the properties change (for arrays, this implies watching the array items; for object maps, this implies watching the properties). If a change is detected, the <code>listener</code> callback is fired.</p> <ul> <li>The <code>obj</code> collection is observed via standard $watch operation and is examined on every call to $digest() to see if any items have been added, removed, or moved.</li> <li>The <code>listener</code> is called whenever anything within the <code>obj</code> has changed. Examples include adding, removing, and moving items belonging to an object or array.</li> </ul> </div> <h4>Parameters</h4> <table class="variables-matrix input-arguments"> <thead> <tr> <th>Param</th> <th>Type</th> <th>Details</th> </tr> </thead> <tbody> <tr> <td> obj </td> <td> <code class="label type-hint type-hint-string">string</code><code class="label type-hint type-hint-function">function(scope)</code> </td> <td> <p>Evaluated as <a href="../../../guide/expression">expression</a>. The expression value should evaluate to an object or an array which is observed on each <a href="%24rootscope.scope#%24digest.html">$digest</a> cycle. Any shallow change within the collection will trigger a call to the <code>listener</code>.</p> </td> </tr> <tr> <td> listener </td> <td> <code class="label type-hint type-hint-function">function(newCollection, oldCollection, scope)</code> </td> <td> <p>a callback function called when a change is detected.</p> <ul> <li>The <code>newCollection</code> object is the newly modified data obtained from the <code>obj</code> expression</li> <li>The <code>oldCollection</code> object is a copy of the former collection data. Due to performance considerations, the<code>oldCollection</code> value is computed only if the <code>listener</code> function declares two or more arguments.</li> <li>The <code>scope</code> argument refers to the current scope.</li> </ul> </td> </tr> </tbody> </table> <h4>Returns</h4> <table class="variables-matrix return-arguments"> <tr> <td><code class="label type-hint type-hint-function">function()</code></td> <td>
<p>Returns a de-registration function for this listener. When the de-registration function is executed, the internal watch operation is terminated.</p> </td> </tr> </table> <h4 id="$rootScope.Scope.$watchCollection-examples">Example</h4>
<pre data-language="javascript">$scope.names = ['igor', 'matias', 'misko', 'james'];
$scope.dataCount = 4;

$scope.$watchCollection('names', function(newNames, oldNames) {
  $scope.dataCount = newNames.length;
});

expect($scope.dataCount).toEqual(4);
$scope.$digest();

//still at 4 ... no changes
expect($scope.dataCount).toEqual(4);

$scope.names.pop();
$scope.$digest();

//now there's been a change
expect($scope.dataCount).toEqual(3);
</pre> </li> <li> <h3 id="$digest">$digest();</h3> <div>
<p>Processes all of the <a href="%24rootscope.scope#%24watch.html">watchers</a> of the current scope and its children. Because a <a href="%24rootscope.scope#%24watch.html">watcher</a>'s listener can change the model, the <code>$digest()</code> keeps calling the <a href="%24rootscope.scope#%24watch.html">watchers</a> until no more listeners are firing. This means that it is possible to get into an infinite loop. This function will throw <code>'Maximum iteration limit exceeded.'</code> if the number of iterations exceeds 10.</p> <p>Usually, you don't call <code>$digest()</code> directly in <a href="../directive/ngcontroller">controllers</a> or in <a href="../provider/%24compileprovider#directive.html">directives</a>. Instead, you should call <a href="%24rootscope.scope#%24apply.html">$apply()</a> (typically from within a <a href="../provider/%24compileprovider#directive.html">directive</a>), which will force a <code>$digest()</code>.</p> <p>If you want to be notified whenever <code>$digest()</code> is called, you can register a <code>watchExpression</code> function with <a href="%24rootscope.scope#%24watch.html">$watch()</a> with no <code>listener</code>.</p> <p>In unit tests, you may need to call <code>$digest()</code> to simulate the scope life cycle.</p> </div> <h4 id="$rootScope.Scope.$digest-examples">Example</h4>
<pre data-language="javascript">var scope = ...;
scope.name = 'misko';
scope.counter = 0;

expect(scope.counter).toEqual(0);
scope.$watch('name', function(newValue, oldValue) {
  scope.counter = scope.counter + 1;
});
expect(scope.counter).toEqual(0);

scope.$digest();
// the listener is always called during the first $digest loop after it was registered
expect(scope.counter).toEqual(1);

scope.$digest();
// but now it will not be called unless the value changes
expect(scope.counter).toEqual(1);

scope.name = 'adam';
scope.$digest();
expect(scope.counter).toEqual(2);
</pre> </li> <li> <h3 id="$suspend">$suspend();</h3> <div>
<p>Suspend watchers of this scope subtree so that they will not be invoked during digest.</p> <p>This can be used to optimize your application when you know that running those watchers is redundant.</p> <p><strong>Warning</strong></p> <p>Suspending scopes from the digest cycle can have unwanted and difficult to debug results. Only use this approach if you are confident that you know what you are doing and have ample tests to ensure that bindings get updated as you expect.</p> <p>Some of the things to consider are:</p> <ul> <li>Any external event on a directive/component will not trigger a digest while the hosting scope is suspended - even if the event handler calls <code>$apply()</code> or <code>$rootScope.$digest()</code>.</li> <li>Transcluded content exists on a scope that inherits from outside a directive but exists as a child of the directive's containing scope. If the containing scope is suspended the transcluded scope will also be suspended, even if the scope from which the transcluded scope inherits is not suspended.</li> <li>Multiple directives trying to manage the suspended status of a scope can confuse each other:<ul> <li>A call to <code>$suspend()</code> on an already suspended scope is a no-op.</li> <li>A call to <code>$resume()</code> on a non-suspended scope is a no-op.</li> <li>If two directives suspend a scope, then one of them resumes the scope, the scope will no longer be suspended. This could result in the other directive believing a scope to be suspended when it is not.</li> </ul> </li> <li>If a parent scope is suspended then all its descendants will be also excluded from future digests whether or not they have been suspended themselves. Note that this also applies to isolate child scopes.</li> <li>Calling <code>$digest()</code> directly on a descendant of a suspended scope will still run the watchers for that scope and its descendants. When digesting we only check whether the current scope is locally suspended, rather than checking whether it has a suspended ancestor.</li> <li>Calling <code>$resume()</code> on a scope that has a suspended ancestor will not cause the scope to be included in future digests until all its ancestors have been resumed.</li> <li>Resolved promises, e.g. from explicit <code>$q</code> deferreds and <code>$http</code> calls, trigger <code>$apply()</code> against the <code>$rootScope</code> and so will still trigger a global digest even if the promise was initiated by a component that lives on a suspended scope.</li> </ul> </div> </li> <li> <h3 id="$isSuspended">$isSuspended();</h3> <div>
<p>Call this method to determine if this scope has been explicitly suspended. It will not tell you whether an ancestor has been suspended. To determine if this scope will be excluded from a digest triggered at the $rootScope, for example, you must check all its ancestors:</p> <pre>function isExcludedFromDigest(scope) {
while(scope) {
  if (scope.$isSuspended()) return true;
  scope = scope.$parent;
}
return false;
</pre> <p>Be aware that a scope may not be included in digests if it has a suspended ancestor, even if <code>$isSuspended()</code> returns false.</p> </div> <h4>Returns</h4> <table class="variables-matrix return-arguments"> <tr> <td></td> <td>
<p>true if the current scope has been suspended.</p> </td> </tr> </table> </li> <li> <h3 id="$resume">$resume();</h3> <div>
<p>Resume watchers of this scope subtree in case it was suspended.</p> <p>See <a href="%24rootscope.scope#%24suspend.html"><code>$rootScope.Scope</code></a> for information about the dangers of using this approach.</p> </div> </li> <li> <h3 id="$destroy">$destroy();</h3> <div>
<p>Removes the current scope (and all of its children) from the parent scope. Removal implies that calls to <a href="%24rootscope.scope#%24digest.html">$digest()</a> will no longer propagate to the current scope and its children. Removal also implies that the current scope is eligible for garbage collection.</p> <p>The <code>$destroy()</code> is usually used by directives such as <a href="../directive/ngrepeat">ngRepeat</a> for managing the unrolling of the loop.</p> <p>Just before a scope is destroyed, a <code>$destroy</code> event is broadcasted on this scope. Application code can register a <code>$destroy</code> event handler that will give it a chance to perform any necessary cleanup.</p> <p>Note that, in AngularJS, there is also a <code>$destroy</code> jQuery event, which can be used to clean up DOM bindings before an element is removed from the DOM.</p> </div> </li> <li> <h3 id="$eval">$eval([expression], [locals]);</h3> <div>
<p>Executes the <code>expression</code> on the current scope and returns the result. Any exceptions in the expression are propagated (uncaught). This is useful when evaluating AngularJS expressions.</p> </div> <h4>Parameters</h4> <table class="variables-matrix input-arguments"> <thead> <tr> <th>Param</th> <th>Type</th> <th>Details</th> </tr> </thead> <tbody> <tr> <td> expression <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-string">string</code><code class="label type-hint type-hint-function">function()</code> </td> <td> <p>An AngularJS expression to be executed.</p> <ul> <li>
<code>string</code>: execute using the rules as defined in <a href="../../../guide/expression">expression</a>.</li> <li>
<code>function(scope)</code>: execute the function with the current <code>scope</code> parameter.</li> </ul> </td> </tr> <tr> <td> locals <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-object">object</code> </td> <td> <p>Local variables object, useful for overriding values in scope.</p> </td> </tr> </tbody> </table> <h4>Returns</h4> <table class="variables-matrix return-arguments"> <tr> <td><code class="label type-hint type-hint-object">*</code></td> <td>
<p>The result of evaluating the expression.</p> </td> </tr> </table> <h4 id="$rootScope.Scope.$eval-examples">Example</h4>
<pre data-language="javascript">var scope = ng.$rootScope.Scope();
scope.a = 1;
scope.b = 2;

expect(scope.$eval('a+b')).toEqual(3);
expect(scope.$eval(function(scope){ return scope.a + scope.b; })).toEqual(3);
</pre> </li> <li> <h3 id="$evalAsync">$evalAsync([expression], [locals]);</h3> <div>
<p>Executes the expression on the current scope at a later point in time.</p> <p>The <code>$evalAsync</code> makes no guarantees as to when the <code>expression</code> will be executed, only that:</p> <ul> <li>it will execute after the function that scheduled the evaluation (preferably before DOM rendering).</li> <li>at least one <a href="%24rootscope.scope#%24digest.html">$digest cycle</a> will be performed after <code>expression</code> execution.</li> </ul> <p>Any exceptions from the execution of the expression are forwarded to the <a href="../service/%24exceptionhandler">$exceptionHandler</a> service.</p> <p><strong>Note:</strong> if this function is called outside of a <code>$digest</code> cycle, a new <code>$digest</code> cycle will be scheduled. However, it is encouraged to always call code that changes the model from within an <code>$apply</code> call. That includes code evaluated via <code>$evalAsync</code>.</p> </div> <h4>Parameters</h4> <table class="variables-matrix input-arguments"> <thead> <tr> <th>Param</th> <th>Type</th> <th>Details</th> </tr> </thead> <tbody> <tr> <td> expression <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-string">string</code><code class="label type-hint type-hint-function">function()</code> </td> <td> <p>An AngularJS expression to be executed.</p> <ul> <li>
<code>string</code>: execute using the rules as defined in <a href="../../../guide/expression">expression</a>.</li> <li>
<code>function(scope)</code>: execute the function with the current <code>scope</code> parameter.</li> </ul> </td> </tr> <tr> <td> locals <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-object">object</code> </td> <td> <p>Local variables object, useful for overriding values in scope.</p> </td> </tr> </tbody> </table> </li> <li> <h3 id="$apply">$apply([exp]);</h3> <div>
<p><code>$apply()</code> is used to execute an expression in AngularJS from outside of the AngularJS framework. (For example from browser DOM events, setTimeout, XHR or third party libraries). Because we are calling into the AngularJS framework we need to perform proper scope life cycle of <a href="../service/%24exceptionhandler">exception handling</a>, <a href="%24rootscope.scope#%24digest.html">executing watches</a>.</p> <p><strong>Life cycle: Pseudo-Code of <code>$apply()</code></strong></p> <pre data-language="javascript">function $apply(expr) {
  try {
    return $eval(expr);
  } catch (e) {
    $exceptionHandler(e);
  } finally {
    $root.$digest();
  }
}
</pre> <p>Scope's <code>$apply()</code> method transitions through the following stages:</p> <ol> <li>The <a href="../../../guide/expression">expression</a> is executed using the <a href="%24rootscope.scope#%24eval.html">$eval()</a> method.</li> <li>Any exceptions from the execution of the expression are forwarded to the <a href="../service/%24exceptionhandler">$exceptionHandler</a> service.</li> <li>The <a href="%24rootscope.scope#%24watch.html">watch</a> listeners are fired immediately after the expression was executed using the <a href="%24rootscope.scope#%24digest.html">$digest()</a> method.</li> </ol> </div> <h4>Parameters</h4> <table class="variables-matrix input-arguments"> <thead> <tr> <th>Param</th> <th>Type</th> <th>Details</th> </tr> </thead> <tbody> <tr> <td> exp <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-string">string</code><code class="label type-hint type-hint-function">function()</code> </td> <td> <p>An AngularJS expression to be executed.</p> <ul> <li>
<code>string</code>: execute using the rules as defined in <a href="../../../guide/expression">expression</a>.</li> <li>
<code>function(scope)</code>: execute the function with current <code>scope</code> parameter.</li> </ul> </td> </tr> </tbody> </table> <h4>Returns</h4> <table class="variables-matrix return-arguments"> <tr> <td><code class="label type-hint type-hint-object">*</code></td> <td>
<p>The result of evaluating the expression.</p> </td> </tr> </table> </li> <li> <h3 id="$applyAsync">$applyAsync([exp]);</h3> <div>
<p>Schedule the invocation of $apply to occur at a later time. The actual time difference varies across browsers, but is typically around ~10 milliseconds.</p> <p>This can be used to queue up multiple expressions which need to be evaluated in the same digest.</p> </div> <h4>Parameters</h4> <table class="variables-matrix input-arguments"> <thead> <tr> <th>Param</th> <th>Type</th> <th>Details</th> </tr> </thead> <tbody> <tr> <td> exp <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-string">string</code><code class="label type-hint type-hint-function">function()</code> </td> <td> <p>An AngularJS expression to be executed.</p> <ul> <li>
<code>string</code>: execute using the rules as defined in <a href="../../../guide/expression">expression</a>.</li> <li>
<code>function(scope)</code>: execute the function with current <code>scope</code> parameter.</li> </ul> </td> </tr> </tbody> </table> </li> <li> <h3 id="$on">$on(name, listener);</h3> <div>
<p>Listens on events of a given type. See <a href="%24rootscope.scope#%24emit.html">$emit</a> for discussion of event life cycle.</p> <p>The event listener function format is: <code>function(event, args...)</code>. The <code>event</code> object passed into the listener has the following attributes:</p> <ul> <li>
<code>targetScope</code> - <code>{Scope}</code>: the scope on which the event was <code>$emit</code>-ed or <code>$broadcast</code>-ed.</li> <li>
<code>currentScope</code> - <code>{Scope}</code>: the scope that is currently handling the event. Once the event propagates through the scope hierarchy, this property is set to null.</li> <li>
<code>name</code> - <code>{string}</code>: name of the event.</li> <li>
<code>stopPropagation</code> - <code>{function=}</code>: calling <code>stopPropagation</code> function will cancel further event propagation (available only for events that were <code>$emit</code>-ed).</li> <li>
<code>preventDefault</code> - <code>{function}</code>: calling <code>preventDefault</code> sets <code>defaultPrevented</code> flag to true.</li> <li>
<code>defaultPrevented</code> - <code>{boolean}</code>: true if <code>preventDefault</code> was called.</li> </ul> </div> <h4>Parameters</h4> <table class="variables-matrix input-arguments"> <thead> <tr> <th>Param</th> <th>Type</th> <th>Details</th> </tr> </thead> <tbody> <tr> <td> name </td> <td> <code class="label type-hint type-hint-string">string</code> </td> <td> <p>Event name to listen on.</p> </td> </tr> <tr> <td> listener </td> <td> <code class="label type-hint type-hint-function">function(event, ...args)</code> </td> <td> <p>Function to call when the event is emitted.</p> </td> </tr> </tbody> </table> <h4>Returns</h4> <table class="variables-matrix return-arguments"> <tr> <td><code class="label type-hint type-hint-function">function()</code></td> <td>
<p>Returns a deregistration function for this listener.</p> </td> </tr> </table> </li> <li> <h3 id="$emit">$emit(name, args);</h3> <div>
<p>Dispatches an event <code>name</code> upwards through the scope hierarchy notifying the registered <a href="%24rootscope.scope#%24on.html"><code>$rootScope.Scope</code></a> listeners.</p> <p>The event life cycle starts at the scope on which <code>$emit</code> was called. All <a href="%24rootscope.scope#%24on.html">listeners</a> listening for <code>name</code> event on this scope get notified. Afterwards, the event traverses upwards toward the root scope and calls all registered listeners along the way. The event will stop propagating if one of the listeners cancels it.</p> <p>Any exception emitted from the <a href="%24rootscope.scope#%24on.html">listeners</a> will be passed onto the <a href="../service/%24exceptionhandler">$exceptionHandler</a> service.</p> </div> <h4>Parameters</h4> <table class="variables-matrix input-arguments"> <thead> <tr> <th>Param</th> <th>Type</th> <th>Details</th> </tr> </thead> <tbody> <tr> <td> name </td> <td> <code class="label type-hint type-hint-string">string</code> </td> <td> <p>Event name to emit.</p> </td> </tr> <tr> <td> args </td> <td> <code class="label type-hint type-hint-object">*</code> </td> <td> <p>Optional one or more arguments which will be passed onto the event listeners.</p> </td> </tr> </tbody> </table> <h4>Returns</h4> <table class="variables-matrix return-arguments"> <tr> <td><code class="label type-hint type-hint-object">Object</code></td> <td>
<p>Event object (see <a href="%24rootscope.scope#%24on.html"><code>$rootScope.Scope</code></a>).</p> </td> </tr> </table> </li> <li> <h3 id="$broadcast">$broadcast(name, args);</h3> <div>
<p>Dispatches an event <code>name</code> downwards to all child scopes (and their children) notifying the registered <a href="%24rootscope.scope#%24on.html"><code>$rootScope.Scope</code></a> listeners.</p> <p>The event life cycle starts at the scope on which <code>$broadcast</code> was called. All <a href="%24rootscope.scope#%24on.html">listeners</a> listening for <code>name</code> event on this scope get notified. Afterwards, the event propagates to all direct and indirect scopes of the current scope and calls all registered listeners along the way. The event cannot be canceled.</p> <p>Any exception emitted from the <a href="%24rootscope.scope#%24on.html">listeners</a> will be passed onto the <a href="../service/%24exceptionhandler">$exceptionHandler</a> service.</p> </div> <h4>Parameters</h4> <table class="variables-matrix input-arguments"> <thead> <tr> <th>Param</th> <th>Type</th> <th>Details</th> </tr> </thead> <tbody> <tr> <td> name </td> <td> <code class="label type-hint type-hint-string">string</code> </td> <td> <p>Event name to broadcast.</p> </td> </tr> <tr> <td> args </td> <td> <code class="label type-hint type-hint-object">*</code> </td> <td> <p>Optional one or more arguments which will be passed onto the event listeners.</p> </td> </tr> </tbody> </table> <h4>Returns</h4> <table class="variables-matrix return-arguments"> <tr> <td><code class="label type-hint type-hint-object">Object</code></td> <td>
<p>Event object, see <a href="%24rootscope.scope#%24on.html"><code>$rootScope.Scope</code></a></p> </td> </tr> </table> </li> </ul> <h2 id="events">Events</h2> <ul class="events defs"> <li id="$destroy"> <h3 id="event-$destroy">$destroy</h3> <div>
<p>Broadcasted when a scope and its children are being destroyed.</p> <p>Note that, in AngularJS, there is also a <code>$destroy</code> jQuery event, which can be used to clean up DOM bindings before an element is removed from the DOM.</p> </div> <div class="inline"> <h4>Type:</h4> <div class="type">broadcast</div> </div> <div class="inline"> <h4>Target:</h4> <div class="target">scope being destroyed </div> </div> </li> </ul> <h2 id="$rootScope.Scope-properties">Properties</h2> <ul class="properties defs"> <li> <h3 id="$id">$id</h3> <table class="variables-matrix return-arguments"> <tr> <td></td> <td>
<p>Unique scope ID (monotonically increasing) useful for debugging.</p> </td> </tr> </table> </li> <li> <h3 id="$parent">$parent</h3> <table class="variables-matrix return-arguments"> <tr> <td></td> <td>
<p>Reference to the parent scope.</p> </td> </tr> </table> </li> <li> <h3 id="$root">$root</h3> <table class="variables-matrix return-arguments"> <tr> <td></td> <td>
<p>Reference to the root scope.</p> </td> </tr> </table> </li> </ul> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2010–2020 Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>
    <a href="https://code.angularjs.org/1.8.2/docs/api/ng/type/%24rootScope.Scope" class="_attribution-link">https://code.angularjs.org/1.8.2/docs/api/ng/type/$rootScope.Scope</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
