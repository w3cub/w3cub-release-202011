
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Constructor Functions for Smooth Terms in a GAM - R - W3cubDocs</title>
  
  <meta name="description" content="Smooth terms in a GAM formula are turned into smooth specification objects of class xx.smooth.spec during processing of the formula. Each of these &hellip;">
  <meta name="keywords" content="constructor, functions, for, smooth, terms, gam, r">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/r/library/mgcv/html/smooth.construct.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/r.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/r/" class="_nav-link" title="" style="margin-left:0;">R</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _simple">
				
				
<h2>
<code>smooth.construct</code> Constructor functions for smooth terms in a GAM</h2> <h3>Description</h3> <p>Smooth terms in a GAM formula are turned into smooth specification objects of class <code>xx.smooth.spec</code> during processing of the formula. Each of these objects is converted to a smooth object using an appropriate <code>smooth.construct</code> function. New smooth classes can be added by writing a new <code>smooth.construct</code> method function and a corresponding <code><a href="predict.matrix">Predict.matrix</a></code> method function (see example code below). </p> <p>In practice, <code>smooth.construct</code> is usually called via <code>smooth.construct2</code> and the wrapper function <code><a href="smoothcon">smoothCon</a></code>, in order to handle <code>by</code> variables and centering constraints (see the <code><a href="smoothcon">smoothCon</a></code> documentation if you need to handle these things directly, for a user defined smooth class). </p> <h3>Usage</h3> <pre data-language="r">
smooth.construct(object,data,knots)
smooth.construct2(object,data,knots)
</pre> <h3>Arguments</h3> <table summary="R argblock"> <tr valign="top">
<td><code>object</code></td> <td> <p> is a smooth specification object, generated by an <code><a href="s">s</a></code> or <code><a href="te">te</a></code> term in a GAM formula. Objects generated by <code>s</code> terms have class <code>xx.smooth.spec</code> where <code>xx</code> is given by the <code>bs</code> argument of <code>s</code> (this convention allows the user to add their own smoothers). If <code>object</code> is not class <code>tensor.smooth.spec</code> it will have the following elements: </p> <dl> <dt>term</dt>
<dd>
<p>The names of the covariates for this smooth, in an array.</p> </dd> <dt>bs.dim</dt>
<dd>
<p> Argument <code>k</code> of the <code>s</code> term generating the object. This is the dimension of the basis used to represent the term (or, arguably, 1 greater than the basis dimension for <code>cc</code> terms). <code>bs.dim&lt;0</code> indicates that the constructor should set this to the default value.</p> </dd> <dt>fixed</dt>
<dd>
<p><code>TRUE</code> if the term is to be unpenalized, otherwise <code>FALSE</code>.</p> </dd> <dt>dim</dt>
<dd>
<p>the number covariates of which this smooth is a function.</p> </dd> <dt>p.order</dt>
<dd>
<p>the order of the smoothness penalty or <code>NA</code> for autoselection of this. This is argument <code>m</code> of the <code>s</code> term that generated <code>object</code>.</p> </dd> <dt>by</dt>
<dd>
<p>the name of any <code>by</code> variable to multiply this term as supplied as an argument to <code>s</code>. <code>"NA"</code> if there is no such term.</p> </dd> <dt>label</dt>
<dd>
<p>A suitable label for use with this term.</p> </dd> <dt>xt</dt>
<dd>
<p>An object containing information that may be needed for basis setup (used, e.g. by <code>"tp"</code> smooths to pass optional information on big dataset handling).</p> </dd> <dt>id</dt>
<dd>
<p>Any identity associated with this term — used for linking bases and smoothing parameters. <code>NULL</code> by default, indicating no linkage.</p> </dd> <dt>sp</dt>
<dd>
<p>Smoothing parameters for the term. Any negative are estimated, otherwise they are fixed at the supplied value. Unless <code>NULL</code> (default), over-rides <code>sp</code> argument to <code><a href="gam">gam</a></code>.</p> </dd> </dl> <p>If <code>object</code> is of class <code>tensor.smooth.spec</code> then it was generated by a <code>te</code> term in the GAM formula, and specifies a smooth of several variables with a basis generated as a tensor product of lower dimensional bases. In this case the object will be different and will have the following elements: </p> <dl> <dt>margin</dt>
<dd>
<p>is a list of smooth specification objects of the type listed above, defining the bases which have their tensor product formed in order to construct this term.</p> </dd> <dt>term</dt>
<dd>
<p>is the array of names of the covariates that are arguments of the smooth.</p> </dd> <dt>by</dt>
<dd>
<p>is the name of any <code>by</code> variable, or <code>"NA"</code>.</p> </dd> <dt>fx</dt>
<dd>
<p>is an array, the elements of which indicate whether (<code>TRUE</code>) any of the margins in the tensor product should be unpenalized.</p> </dd> <dt>label</dt>
<dd>
<p>A suitable label for use with this term.</p> </dd> <dt>dim</dt>
<dd>
<p>is the number of covariates of which this smooth is a function.</p> </dd> <dt>mp</dt>
<dd>
<p><code>TRUE</code> if multiple penalties are to be used.</p> </dd> <dt>np</dt>
<dd>
<p><code>TRUE</code> if 1-D marginal smooths are to be re-parameterized in terms of function values.</p> </dd> <dt>id</dt>
<dd>
<p>Any identity associated with this term — used for linking bases and smoothing parameters. <code>NULL</code> by default, indicating no linkage.</p> </dd> <dt>sp</dt>
<dd>
<p>Smoothing parameters for the term. Any negative are estimated, otherwise they are fixed at the supplied value. Unless <code>NULL</code> (default), over-rides <code>sp</code> argument to <code><a href="gam">gam</a></code>.</p> </dd> </dl> </td>
</tr> <tr valign="top">
<td><code>data</code></td> <td> <p>For <code>smooth.construct</code> a data frame or list containing the evaluation of the elements of <code>object$term</code>, with names given by <code>object$term</code>. The last entry will be the <code>by</code> variable, if <code>object$by</code> is not <code>"NA"</code>. For <code>smooth.construct2</code> <code>data</code> need only be an object within which <code>object$term</code> can be evaluated, the variables can be in any order, and there can be irrelevant variables present as well. </p> </td>
</tr> <tr valign="top">
<td><code>knots</code></td> <td> <p>an optional data frame or list containing the knots relating to <code>object$term</code>. If it is <code>NULL</code> then the knot locations are generated automatically. The structure of <code>knots</code> should be as for <code>data</code>, depending on whether <code>smooth.construct</code> or <code>smooth.construct2</code> is used.</p> </td>
</tr> </table> <h3>Details</h3> <p> There are built in methods for objects with the following classes: <code>tp.smooth.spec</code> (thin plate regression splines: see <code><a href="smooth.construct.tp.smooth.spec">tprs</a></code>); <code>ts.smooth.spec</code> (thin plate regression splines with shrinkage-to-zero); <code>cr.smooth.spec</code> (cubic regression splines: see <code><a href="smooth.construct.cr.smooth.spec">cubic.regression.spline</a></code>; <code>cs.smooth.spec</code> (cubic regression splines with shrinkage-to-zero); <code>cc.smooth.spec</code> (cyclic cubic regression splines); <code>ps.smooth.spec</code> (Eilers and Marx (1986) style P-splines: see <code><a href="smooth.construct.ps.smooth.spec">p.spline</a></code>); <code>cp.smooth.spec</code> (cyclic P-splines); <code>ad.smooth.spec</code> (adaptive smooths of 1 or 2 variables: see <code><a href="smooth.construct.ad.smooth.spec">adaptive.smooth</a></code>); <code>re.smooth.spec</code> (simple random effect terms); <code>mrf.smooth.spec</code> (Markov random field smoothers for smoothing over discrete districts); <code>tensor.smooth.spec</code> (tensor product smooths). </p> <p>There is an implicit assumption that the basis only depends on the knots and/or the set of unique covariate combinations; i.e. that the basis is the same whether generated from the full set of covariates, or just the unique combinations of covariates. </p> <p>Plotting of smooths is handled by plot methods for smooth objects. A default <code>mgcv.smooth</code> method is used if there is no more specific method available. Plot methods can be added for specific smooth classes, see source code for <code>mgcv:::plot.sos.smooth</code>, <code>mgcv:::plot.random.effect</code>, <code>mgcv:::plot.mgcv.smooth</code> for example code. </p> <h3>Value</h3> <p>The input argument <code>object</code>, assigned a new class to indicate what type of smooth it is and with at least the following items added: </p> <table summary="R valueblock"> <tr valign="top">
<td><code>X</code></td> <td> <p>The model matrix from this term. This may have an <code>"offset"</code> attribute: a vector of length <code>nrow(X)</code> containing any contribution of the smooth to the model offset term. <code>by</code> variables do not need to be dealt with here, but if they are then an item <code>by.done</code> must be added to the <code>object</code>.</p> </td>
</tr> <tr valign="top">
<td><code>S</code></td> <td> <p>A list of positive semi-definite penalty matrices that apply to this term. The list will be empty if the term is to be left un-penalized.</p> </td>
</tr> <tr valign="top">
<td><code>rank</code></td> <td> <p>An array giving the ranks of the penalties.</p> </td>
</tr> <tr valign="top">
<td><code>null.space.dim</code></td> <td> <p>The dimension of the penalty null space (before centering).</p> </td>
</tr> </table> <p>The following items may be added: </p> <table summary="R valueblock"> <tr valign="top">
<td><code>C</code></td> <td> <p>The matrix defining any identifiability constraints on the term, for use when fitting. If this is <code>NULL</code> then <code>smoothCon</code> will add an identifiability constraint that each term should sum to zero over the covariate values. Set to a zero row matrix if no constraints are required. If a supplied <code>C</code> has an attribute <code>"always.apply"</code> then it is never ignored, even if any <code>by</code> variables of a smooth imply that no constraint is actually needed. Code for creating <code>C</code> should check whether the specification object already contains a zero row matrix, and leave this unchanged if it is (since this signifies no constraint should be produced). </p> </td>
</tr> <tr valign="top">
<td><code>Cp</code></td> <td> <p>An optional matrix supplying alternative identifiability constraints for use when predicting. By default the fitting constrants are used. This option is useful when some sort of simple sparse constraint is required for fitting, but the usual sum-to-zero constraint is required for prediction so that, e.g. the CIs for model components are as narrow as possible. </p> </td>
</tr> <tr valign="top">
<td><code>no.rescale</code></td> <td> <p>if this is non-NULL then the penalty coefficient matrix of the smooth will not be rescaled for enhaced numerical stability (rescaling is the default, because <code><a href="gamm">gamm</a></code> requires it). Turning off rescaling is useful if the values of the smoothing parameters should be interpretable in a model, for example because they are inverse variance components. </p> </td>
</tr> <tr valign="top">
<td><code>df</code></td> <td> <p>the degrees of freedom associated with this term (when unpenalized and unconstrained). If this is null then <code>smoothCon</code> will set it to the basis dimension. <code>smoothCon</code> will reduce this by the number of constraints.</p> </td>
</tr> <tr valign="top">
<td><code>te.ok</code></td> <td> <p><code>0</code> if this term should not be used as a tensor product marginal, <code>1</code> if it can be used and plotted, and <code>2</code> is it can be used but not plotted. Set to <code>1</code> if <code>NULL</code>.</p> </td>
</tr> <tr valign="top">
<td><code>plot.me</code></td> <td> <p>Set to <code>FALSE</code> if this smooth should not be plotted by <code><a href="plot.gam">plot.gam</a></code>. Set to <code>TRUE</code> if <code>NULL</code>.</p> </td>
</tr> <tr valign="top">
<td><code>side.constrain</code></td> <td> <p>Set to <code>FALSE</code> to ensure that the smooth is never subject to side constraints as a result of nesting. </p> </td>
</tr> <tr valign="top">
<td><code>L</code></td> <td> <p>smooths may depend on fewer ‘underlying’ smoothing parameters than there are elements of <code>S</code>. In this case <code>L</code> is the matrix mapping the vector of underlying log smoothing parameters to the vector of logs of the smoothing parameters actually multiplying the <code>S[[i]]</code>. <code>L=NULL</code> signifies that there is one smoothing parameter per <code>S[[i]]</code>. </p> </td>
</tr> </table> <p>Usually the returned object will also include extra information required to define the basis, and used by <code><a href="predict.matrix">Predict.matrix</a></code> methods to make predictions using the basis. See the <code>Details</code> section for links to the information included for the built in smooth classes. </p> <p><code>tensor.smooth</code> returned objects will additionally have each element of the <code>margin</code> list updated in the same way. <code>tensor.smooths</code> also have a list, <code>XP</code>, containing re-parameterization matrices for any 1-D marginal terms re-parameterized in terms of function values. This list will have <code>NULL</code> entries for marginal smooths that are not re-parameterized, and is only long enough to reach the last re-parameterized marginal in the list. </p> <h3>WARNING</h3> <p>User defined smooth objects should avoid having attributes names <code>"qrc"</code> or <code>"nCons"</code> as these are used internally to provide constraint free parameterizations.</p> <h3>Author(s)</h3> <p>Simon N. Wood <a href="mailto:simon.wood@r-project.org">simon.wood@r-project.org</a></p> <h3>References</h3> <p>Wood, S.N. (2003) Thin plate regression splines. J.R.Statist.Soc.B 65(1):95-114 </p> <p>Wood, S.N. (2006) Low rank scale invariant tensor product smooths for generalized additive mixed models. Biometrics 62(4):1025-1036 </p> <p>The code given in the example is based on the smooths advocated in: </p> <p>Ruppert, D., M.P. Wand and R.J. Carroll (2003) Semiparametric Regression. Cambridge University Press. </p> <p>However if you want p-splines, rather than splines with derivative based penalties, then the built in "ps" class is probably a marginally better bet. It's based on </p> <p>Eilers, P.H.C. and B.D. Marx (1996) Flexible Smoothing with B-splines and Penalties. Statistical Science, 11(2):89-121 </p> <p><a href="https://www.maths.ed.ac.uk/~swood34/">https://www.maths.ed.ac.uk/~swood34/</a> </p> <h3>See Also</h3> <p><code><a href="s">s</a></code>,<code><a href="get.var">get.var</a></code>, <code><a href="gamm">gamm</a></code>, <code><a href="gam">gam</a></code>, <code><a href="predict.matrix">Predict.matrix</a></code>, <code><a href="smoothcon">smoothCon</a></code>, <code><a href="smoothcon">PredictMat</a></code> </p> <h3>Examples</h3> <pre data-language="r">
## Adding a penalized truncated power basis class and methods
## as favoured by Ruppert, Wand and Carroll (2003) 
## Semiparametric regression CUP. (No advantage to actually
## using this, since mgcv can happily handle non-identity 
## penalties.)

smooth.construct.tr.smooth.spec&lt;-function(object,data,knots) {
## a truncated power spline constructor method function
## object$p.order = null space dimension
  m &lt;- object$p.order[1]
  if (is.na(m)) m &lt;- 2 ## default 
  if (m&lt;1) stop("silly m supplied")
  if (object$bs.dim&lt;0) object$bs.dim &lt;- 10 ## default
  nk&lt;-object$bs.dim-m-1 ## number of knots
  if (nk&lt;=0) stop("k too small for m")
  x &lt;- data[[object$term]]  ## the data
  x.shift &lt;- mean(x) # shift used to enhance stability
  k &lt;- knots[[object$term]] ## will be NULL if none supplied
  if (is.null(k)) # space knots through data
  { n&lt;-length(x)
    k&lt;-quantile(x[2:(n-1)],seq(0,1,length=nk+2))[2:(nk+1)]
  }
  if (length(k)!=nk) # right number of knots?
  stop(paste("there should be ",nk," supplied knots"))
  x &lt;- x - x.shift # basis stabilizing shift
  k &lt;- k - x.shift # knots treated the same!
  X&lt;-matrix(0,length(x),object$bs.dim)
  for (i in 1:(m+1)) X[,i] &lt;- x^(i-1)
  for (i in 1:nk) X[,i+m+1]&lt;-(x-k[i])^m*as.numeric(x&gt;k[i])
  object$X&lt;-X # the finished model matrix
  if (!object$fixed) # create the penalty matrix
  { object$S[[1]]&lt;-diag(c(rep(0,m+1),rep(1,nk)))
  }
  object$rank&lt;-nk  # penalty rank
  object$null.space.dim &lt;- m+1  # dim. of unpenalized space
  ## store "tr" specific stuff ...
  object$knots&lt;-k;object$m&lt;-m;object$x.shift &lt;- x.shift
 
  object$df&lt;-ncol(object$X)     # maximum DoF (if unconstrained)
 
  class(object)&lt;-"tr.smooth"  # Give object a class
  object
}

Predict.matrix.tr.smooth&lt;-function(object,data) {
## prediction method function for the `tr' smooth class
  x &lt;- data[[object$term]]
  x &lt;- x - object$x.shift # stabilizing shift
  m &lt;- object$m;     # spline order (3=cubic)
  k&lt;-object$knots    # knot locations
  nk&lt;-length(k)      # number of knots
  X&lt;-matrix(0,length(x),object$bs.dim)
  for (i in 1:(m+1)) X[,i] &lt;- x^(i-1)
  for (i in 1:nk) X[,i+m+1] &lt;- (x-k[i])^m*as.numeric(x&gt;k[i])
  X # return the prediction matrix
}

# an example, using the new class....
require(mgcv)
set.seed(100)
dat &lt;- gamSim(1,n=400,scale=2)
b&lt;-gam(y~s(x0,bs="tr",m=2)+s(x1,bs="ps",m=c(1,3))+
         s(x2,bs="tr",m=3)+s(x3,bs="tr",m=2),data=dat)
plot(b,pages=1)
b&lt;-gamm(y~s(x0,bs="tr",m=2)+s(x1,bs="ps",m=c(1,3))+
         s(x2,bs="tr",m=3)+s(x3,bs="tr",m=2),data=dat)
plot(b$gam,pages=1)
# another example using tensor products of the new class
dat &lt;- gamSim(2,n=400,scale=.1)$data
b &lt;- gam(y~te(x,z,bs=c("tr","tr"),m=c(2,2)),data=dat)
vis.gam(b)
</pre>
<div class="_attribution">
  <p class="_attribution-p">
    Copyright (©) 1999–2012 R Foundation for Statistical Computing.<br>Licensed under the <a href="https://www.gnu.org/copyleft/gpl.html">GNU General Public License</a>.<br>
    
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
