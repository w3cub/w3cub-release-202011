
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>cyclic.p.spline - R - W3cubDocs</title>
  
  <meta name="description" content="gam can use univariate P-splines as proposed by Eilers and Marx (1996), specified via terms like s(x,bs&#61;&#34;ps&#34;). These terms use B-spline &hellip;">
  <meta name="keywords" content="cyclic, p, spline, r">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/r/library/mgcv/html/smooth.construct.ps.smooth.spec.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/r.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/r/" class="_nav-link" title="" style="margin-left:0;">R</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _simple">
				
				
<h2>
<code>smooth.construct.ps.smooth.spec</code> P-splines in GAMs</h2> <h3>Description</h3> <p><code><a href="gam">gam</a></code> can use univariate P-splines as proposed by Eilers and Marx (1996), specified via terms like <code>s(x,bs="ps")</code>. These terms use B-spline bases penalized by discrete penalties applied directly to the basis coefficients. Cyclic P-splines are specified by model terms like <code>s(x,bs="cp",...)</code>. These bases can be used in tensor product smooths (see <code><a href="te">te</a></code>). </p> <p>The advantage of P-splines is the flexible way that penalty and basis order can be mixed (but see also <code><a href="smooth.construct.bs.smooth.spec">d.spline</a></code>). This often provides a useful way of ‘taming’ an otherwise poorly behave smooth. However, in regular use, splines with derivative based penalties (e.g. <code>"tp"</code> or <code>"cr"</code> bases) tend to result in slightly better MSE performance, presumably because the good approximation theoretic properties of splines are rather closely connected to the use of derivative penalties. </p> <h3>Usage</h3> <pre data-language="r">
## S3 method for class 'ps.smooth.spec'
smooth.construct(object, data, knots)
## S3 method for class 'cp.smooth.spec'
smooth.construct(object, data, knots)
</pre> <h3>Arguments</h3> <table summary="R argblock"> <tr valign="top">
<td><code>object</code></td> <td> <p>a smooth specification object, usually generated by a term <code>s(x,bs="ps",...)</code> or <code>s(x,bs="cp",...)</code></p> </td>
</tr> <tr valign="top">
<td><code>data</code></td> <td> <p>a list containing just the data (including any <code>by</code> variable) required by this term, with names corresponding to <code>object$term</code> (and <code>object$by</code>). The <code>by</code> variable is the last element.</p> </td>
</tr> <tr valign="top">
<td><code>knots</code></td> <td> <p>a list containing any knots supplied for basis setup — in same order and with same names as <code>data</code>. Can be <code>NULL</code>. See details for further information.</p> </td>
</tr> </table> <h3>Details</h3> <p>A smooth term of the form <code>s(x,bs="ps",m=c(2,3))</code> specifies a 2nd order P-spline basis (cubic spline), with a third order difference penalty (0th order is a ridge penalty) on the coefficients. If <code>m</code> is a single number then it is taken as the basis order and penalty order. The default is the ‘cubic spline like’ <code>m=c(2,2)</code>. </p> <p>The default basis dimension, <code>k</code>, is the larger of 10 and <code>m[1]+1</code> for a <code>"ps"</code> terms and the larger of 10 and <code>m[1]</code> for a <code>"cp"</code> term. <code>m[1]+1</code> and <code>m[1]</code> are the lower limits on basis dimension for the two types. </p> <p>If knots are supplied, then the number of knots should be one more than the basis dimension (i.e. <code>k+1</code>) for a <code>"cp"</code>smooth. For the <code>"ps"</code> basis the number of supplied knots should be <code>k + m[1] + 2</code>, and the range of the middle <code>k-m[1]</code> knots should include all the covariate values. See example. </p> <p>Alternatively, for both types of smooth, 2 knots can be supplied, denoting the lower and upper limits between which the spline can be evaluated (Don't make this range too wide, however, or you can end up with no information about some basis coefficients, because the corresponding basis functions have a span that includes no data!). Note that P-splines don't make much sense with uneven knot spacing. </p> <p>Linear extrapolation is used for prediction that requires extrapolation (i.e. prediction outside the range of the interior <code>k-m[1]</code> knots). Such extrapolation is not allowed in basis construction, but is when predicting. </p> <p>For the <code>"ps"</code> basis it is possible to set flags in the smooth specification object, requesting setup according to the SCOP-spline monotonic smoother construction of Pya and Wood (2015). As yet this is not supported by any modelling functions in <code>mgcv</code> (see package <code>scam</code>). Similarly it is possible to set a <code>deriv</code> flag in a smooth specification or smooth object, so that a model or prediction matrix produces the requested derivative of the spline, rather than evaluating it. See examples below. </p> <h3>Value</h3> <p> An object of class <code>"pspline.smooth"</code> or <code>"cp.smooth"</code>. See <code><a href="smooth.construct">smooth.construct</a></code>, for the elements that this object will contain. </p> <h3>Author(s)</h3> <p> Simon N. Wood <a href="mailto:simon.wood@r-project.org">simon.wood@r-project.org</a></p> <h3>References</h3> <p>Eilers, P.H.C. and B.D. Marx (1996) Flexible Smoothing with B-splines and Penalties. Statistical Science, 11(2):89-121 </p> <p>Pya, N., and Wood, S.N. (2015). Shape constrained additive models. Statistics and Computing, 25(3), 543-559. </p> <h3>See Also</h3> <p><code><a href="csplinedes">cSplineDes</a></code>, <code><a href="smooth.construct.ad.smooth.spec">adaptive.smooth</a></code>, <code><a href="smooth.construct.bs.smooth.spec">d.spline</a></code></p> <h3>Examples</h3> <pre data-language="r">
## see ?gam
## cyclic example ...
  require(mgcv)
  set.seed(6)
  x &lt;- sort(runif(200)*10)
  z &lt;- runif(200)
  f &lt;- sin(x*2*pi/10)+.5
  y &lt;- rpois(exp(f),exp(f)) 

## finished simulating data, now fit model...
  b &lt;- gam(y ~ s(x,bs="cp") + s(z,bs="ps"),family=poisson)

## example with supplied knot ranges for x and z (can do just one)
  b &lt;- gam(y ~ s(x,bs="cp") + s(z,bs="ps"),family=poisson,
           knots=list(x=c(0,10),z=c(0,1))) 

## example with supplied knots...
  bk &lt;- gam(y ~ s(x,bs="cp",k=12) + s(z,bs="ps",k=13),family=poisson,
                      knots=list(x=seq(0,10,length=13),z=(-3):13/10))

## plot results...
  par(mfrow=c(2,2))
  plot(b,select=1,shade=TRUE);lines(x,f-mean(f),col=2)
  plot(b,select=2,shade=TRUE);lines(z,0*z,col=2)
  plot(bk,select=1,shade=TRUE);lines(x,f-mean(f),col=2)
  plot(bk,select=2,shade=TRUE);lines(z,0*z,col=2)
  
## Example using montonic constraints via the SCOP-spline
## construction, and of computng derivatives...
  x &lt;- seq(0,1,length=100); dat &lt;- data.frame(x)
  sspec &lt;- s(x,bs="ps")
  sspec$mono &lt;- 1
  sm &lt;- smoothCon(sspec,dat)[[1]]
  sm$deriv &lt;- 1
  Xd &lt;- PredictMat(sm,dat)
## generate random coeffients in the unconstrainted 
## parameterization...
  b &lt;- runif(10)*3-2.5
## exponentiate those parameters indicated by sm$g.index 
## to obtain coefficients meeting the constraints...
  b[sm$g.index] &lt;- exp(b[sm$g.index]) 
## plot monotonic spline and its derivative
  par(mfrow=c(2,2))
  plot(x,sm$X%*%b,type="l",ylab="f(x)")
  plot(x,Xd%*%b,type="l",ylab="f'(x)")
## repeat for decrease...
  sspec$mono &lt;- -1
  sm1 &lt;- smoothCon(sspec,dat)[[1]]
  sm1$deriv &lt;- 1
  Xd1 &lt;- PredictMat(sm1,dat)
  plot(x,sm1$X%*%b,type="l",ylab="f(x)")
  plot(x,Xd1%*%b,type="l",ylab="f'(x)")

## Now with sum to zero constraints as well...
  sspec$mono &lt;- 1
  sm &lt;- smoothCon(sspec,dat,absorb.cons=TRUE)[[1]]
  sm$deriv &lt;- 1
  Xd &lt;- PredictMat(sm,dat)
  b &lt;- b[-1] ## dropping first param
  plot(x,sm$X%*%b,type="l",ylab="f(x)")
  plot(x,Xd%*%b,type="l",ylab="f'(x)")
  
  sspec$mono &lt;- -1
  sm1 &lt;- smoothCon(sspec,dat,absorb.cons=TRUE)[[1]]
  sm1$deriv &lt;- 1
  Xd1 &lt;- PredictMat(sm1,dat)
  plot(x,sm1$X%*%b,type="l",ylab="f(x)")
  plot(x,Xd1%*%b,type="l",ylab="f'(x)")
  
</pre>
<div class="_attribution">
  <p class="_attribution-p">
    Copyright (©) 1999–2012 R Foundation for Statistical Computing.<br>Licensed under the <a href="https://www.gnu.org/copyleft/gpl.html">GNU General Public License</a>.<br>
    
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
