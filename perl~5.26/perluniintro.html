
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Perluniintro - Perl 5.26 - W3cubDocs</title>
  
  <meta name="description" content=" perluniintro - Perl Unicode introduction ">
  <meta name="keywords" content="perluniintro, perl, perl~5.26">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/perl~5.26/perluniintro.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/perl~5.26.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/perl~5.26/" class="_nav-link" title="" style="margin-left:0;">Perl 5.26</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _perl">
				
				
<h1>perluniintro</h1>  <ul>
<li><a href="#NAME">NAME</a></li>
<li>
<a href="#DESCRIPTION">DESCRIPTION</a><ul>
<li><a href="#Unicode">Unicode</a></li>
<li><a href="#Perl's-Unicode-Support">Perl's Unicode Support</a></li>
<li><a href="#Perl's-Unicode-Model">Perl's Unicode Model</a></li>
<li><a href="#Unicode-and-EBCDIC">Unicode and EBCDIC</a></li>
<li><a href="#Creating-Unicode">Creating Unicode</a></li>
<li><a href="#Handling-Unicode">Handling Unicode</a></li>
<li><a href="#Legacy-Encodings">Legacy Encodings</a></li>
<li><a href="#Unicode-I%2fO">Unicode I/O</a></li>
<li><a href="#Displaying-Unicode-As-Text">Displaying Unicode As Text</a></li>
<li><a href="#Special-Cases">Special Cases</a></li>
<li><a href="#Advanced-Topics">Advanced Topics</a></li>
<li><a href="#Miscellaneous">Miscellaneous</a></li>
<li><a href="#Questions-With-Answers">Questions With Answers</a></li>
<li><a href="#Hexadecimal-Notation">Hexadecimal Notation</a></li>
<li><a href="#Further-Resources">Further Resources</a></li>
</ul>
</li>
<li><a href="#UNICODE-IN-OLDER-PERLS">UNICODE IN OLDER PERLS</a></li>
<li><a href="#SEE-ALSO">SEE ALSO</a></li>
<li><a href="#ACKNOWLEDGMENTS">ACKNOWLEDGMENTS</a></li>
<li><a href="#AUTHOR%2c-COPYRIGHT%2c-AND-LICENSE">AUTHOR, COPYRIGHT, AND LICENSE</a></li>
</ul>
<h2 id="NAME">NAME</h2> <p>perluniintro - Perl Unicode introduction</p> <h2 id="DESCRIPTION">DESCRIPTION</h2> <p>This document gives a general idea of Unicode and how to use Unicode in Perl. See <a href="#Further-Resources">Further Resources</a> for references to more in-depth treatments of Unicode.</p> <h3 id="Unicode">Unicode</h3> <p>Unicode is a character set standard which plans to codify all of the writing systems of the world, plus many other symbols.</p> <p>Unicode and ISO/IEC 10646 are coordinated standards that unify almost all other modern character set standards, covering more than 80 writing systems and hundreds of languages, including all commercially-important modern languages. All characters in the largest Chinese, Japanese, and Korean dictionaries are also encoded. The standards will eventually cover almost all characters in more than 250 writing systems and thousands of languages. Unicode 1.0 was released in October 1991, and 6.0 in October 2010.</p> <p>A Unicode <i>character</i> is an abstract entity. It is not bound to any particular integer width, especially not to the C language <code class="inline"><span class="w">char</span></code> . Unicode is language-neutral and display-neutral: it does not encode the language of the text, and it does not generally define fonts or other graphical layout details. Unicode operates on characters and on text built from those characters.</p> <p>Unicode defines characters like <code class="inline"><span class="w">LATIN</span> <span class="w">CAPITAL</span> <span class="w">LETTER</span> <span class="w">A</span></code> or <code class="inline"><span class="w">GREEK</span>
<span class="w">SMALL</span> <span class="w">LETTER</span> <span class="w">ALPHA</span></code> and unique numbers for the characters, in this case 0x0041 and 0x03B1, respectively. These unique numbers are called <i>code points</i>. A code point is essentially the position of the character within the set of all possible Unicode characters, and thus in Perl, the term <i>ordinal</i> is often used interchangeably with it.</p> <p>The Unicode standard prefers using hexadecimal notation for the code points. If numbers like <code class="inline"><span class="n">0x0041</span></code> are unfamiliar to you, take a peek at a later section, <a href="#Hexadecimal-Notation">Hexadecimal Notation</a>. The Unicode standard uses the notation <code class="inline">U+0041 LATIN CAPITAL LETTER A</code>, to give the hexadecimal code point and the normative name of the character.</p> <p>Unicode also defines various <i>properties</i> for the characters, like "uppercase" or "lowercase", "decimal digit", or "punctuation"; these properties are independent of the names of the characters. Furthermore, various operations on the characters like uppercasing, lowercasing, and collating (sorting) are defined.</p> <p>A Unicode <i>logical</i> "character" can actually consist of more than one internal <i>actual</i> "character" or code point. For Western languages, this is adequately modelled by a <i>base character</i> (like <code class="inline"><span class="w">LATIN</span> <span class="w">CAPITAL</span> <span class="w">LETTER</span> <span class="w">A</span></code> ) followed by one or more <i>modifiers</i> (like <code class="inline"><span class="w">COMBINING</span> <span class="w">ACUTE</span> <span class="w">ACCENT</span></code> ). This sequence of base character and modifiers is called a <i>combining character sequence</i>. Some non-western languages require more complicated models, so Unicode created the <i>grapheme cluster</i> concept, which was later further refined into the <i>extended grapheme cluster</i>. For example, a Korean Hangul syllable is considered a single logical character, but most often consists of three actual Unicode characters: a leading consonant followed by an interior vowel followed by a trailing consonant.</p> <p>Whether to call these extended grapheme clusters "characters" depends on your point of view. If you are a programmer, you probably would tend towards seeing each element in the sequences as one unit, or "character". However from the user's point of view, the whole sequence could be seen as one "character" since that's probably what it looks like in the context of the user's language. In this document, we take the programmer's point of view: one "character" is one Unicode code point.</p> <p>For some combinations of base character and modifiers, there are <i>precomposed</i> characters. There is a single character equivalent, for example, for the sequence <code class="inline"><span class="w">LATIN</span> <span class="w">CAPITAL</span> <span class="w">LETTER</span> <span class="w">A</span></code> followed by <code class="inline"><span class="w">COMBINING</span> <span class="w">ACUTE</span> <span class="w">ACCENT</span></code> . It is called <code class="inline"><span class="w">LATIN</span> <span class="w">CAPITAL</span> <span class="w">LETTER</span> <span class="w">A</span> <span class="w">WITH</span>
<span class="w">ACUTE</span></code> . These precomposed characters are, however, only available for some combinations, and are mainly meant to support round-trip conversions between Unicode and legacy standards (like ISO 8859). Using sequences, as Unicode does, allows for needing fewer basic building blocks (code points) to express many more potential grapheme clusters. To support conversion between equivalent forms, various <i>normalization forms</i> are also defined. Thus, <code class="inline"><span class="w">LATIN</span> <span class="w">CAPITAL</span> <span class="w">LETTER</span> <span class="w">A</span> <span class="w">WITH</span> <span class="w">ACUTE</span></code> is in <i>Normalization Form Composed</i>, (abbreviated NFC), and the sequence <code class="inline"><span class="w">LATIN</span> <span class="w">CAPITAL</span> <span class="w">LETTER</span> <span class="w">A</span></code> followed by <code class="inline"><span class="w">COMBINING</span> <span class="w">ACUTE</span> <span class="w">ACCENT</span></code> represents the same character in <i>Normalization Form Decomposed</i> (NFD).</p> <p>Because of backward compatibility with legacy encodings, the "a unique number for every character" idea breaks down a bit: instead, there is "at least one number for every character". The same character could be represented differently in several legacy encodings. The converse is not true: some code points do not have an assigned character. Firstly, there are unallocated code points within otherwise used blocks. Secondly, there are special Unicode control characters that do not represent true characters.</p> <p>When Unicode was first conceived, it was thought that all the world's characters could be represented using a 16-bit word; that is a maximum of <code class="inline"><span class="n">0x10000</span></code> (or 65,536) characters would be needed, from <code class="inline"><span class="n">0x0000</span></code> to <code class="inline"><span class="n">0xFFFF</span></code> . This soon proved to be wrong, and since Unicode 2.0 (July 1996), Unicode has been defined all the way up to 21 bits (<code class="inline"><span class="n">0x10FFFF</span></code> ), and Unicode 3.1 (March 2001) defined the first characters above <code class="inline"><span class="n">0xFFFF</span></code> . The first <code class="inline"><span class="n">0x10000</span></code> characters are called the <i>Plane 0</i>, or the <i>Basic Multilingual Plane</i> (BMP). With Unicode 3.1, 17 (yes, seventeen) planes in all were defined--but they are nowhere near full of defined characters, yet.</p> <p>When a new language is being encoded, Unicode generally will choose a <code class="inline"><span class="w">block</span></code> of consecutive unallocated code points for its characters. So far, the number of code points in these blocks has always been evenly divisible by 16. Extras in a block, not currently needed, are left unallocated, for future growth. But there have been occasions when a later release needed more code points than the available extras, and a new block had to allocated somewhere else, not contiguous to the initial one, to handle the overflow. Thus, it became apparent early on that "block" wasn't an adequate organizing principal, and so the <code class="inline"><span class="w">Script</span></code> property was created. (Later an improved script property was added as well, the <code class="inline"><span class="w">Script_Extensions</span></code> property.) Those code points that are in overflow blocks can still have the same script as the original ones. The script concept fits more closely with natural language: there is <code class="inline"><span class="w">Latin</span></code> script, <code class="inline"><span class="w">Greek</span></code> script, and so on; and there are several artificial scripts, like <code class="inline"><span class="w">Common</span></code> for characters that are used in multiple scripts, such as mathematical symbols. Scripts usually span varied parts of several blocks. For more information about scripts, see <a href="perlunicode#Scripts">Scripts in perlunicode</a>. The division into blocks exists, but it is almost completely accidental--an artifact of how the characters have been and still are allocated. (Note that this paragraph has oversimplified things for the sake of this being an introduction. Unicode doesn't really encode languages, but the writing systems for them--their scripts; and one script can be used by many languages. Unicode also encodes things that aren't really about languages, such as symbols like <code class="inline"><span class="w">BAGGAGE</span> <span class="w">CLAIM</span></code> .)</p> <p>The Unicode code points are just abstract numbers. To input and output these abstract numbers, the numbers must be <i>encoded</i> or <i>serialised</i> somehow. Unicode defines several <i>character encoding forms</i>, of which <i>UTF-8</i> is the most popular. UTF-8 is a variable length encoding that encodes Unicode characters as 1 to 4 bytes. Other encodings include UTF-16 and UTF-32 and their big- and little-endian variants (UTF-8 is byte-order independent). The ISO/IEC 10646 defines the UCS-2 and UCS-4 encoding forms.</p> <p>For more information about encodings--for instance, to learn what <i>surrogates</i> and <i>byte order marks</i> (BOMs) are--see <a href="perlunicode">perlunicode</a>.</p> <h3 id="Perl's-Unicode-Support">Perl's Unicode Support</h3> <p>Starting from Perl v5.6.0, Perl has had the capacity to handle Unicode natively. Perl v5.8.0, however, is the first recommended release for serious Unicode work. The maintenance release 5.6.1 fixed many of the problems of the initial Unicode implementation, but for example regular expressions still do not work with Unicode in 5.6.1. Perl v5.14.0 is the first release where Unicode support is (almost) seamlessly integrable without some gotchas (the exception being some differences in <a href="functions/quotemeta">quotemeta</a>, and that is fixed starting in Perl 5.16.0). To enable this seamless support, you should <code class="inline"><a class="l_k" href="functions/use">use</a> <span class="w">feature</span> <span class="q">'unicode_strings'</span></code> (which is automatically selected if you <code class="inline"><a class="l_k" href="functions/use">use</a> <span class="n">5.012</span></code> or higher). See <a href="feature">feature</a>. (5.14 also fixes a number of bugs and departures from the Unicode standard.)</p> <p>Before Perl v5.8.0, the use of <code class="inline"><a class="l_k" href="functions/use">use</a> <span class="w">utf8</span></code> was used to declare that operations in the current block or file would be Unicode-aware. This model was found to be wrong, or at least clumsy: the "Unicodeness" is now carried with the data, instead of being attached to the operations. Starting with Perl v5.8.0, only one case remains where an explicit <code class="inline"><a class="l_k" href="functions/use">use</a>
<span class="w">utf8</span></code> is needed: if your Perl script itself is encoded in UTF-8, you can use UTF-8 in your identifier names, and in string and regular expression literals, by saying <code class="inline"><a class="l_k" href="functions/use">use</a> <span class="w">utf8</span></code> . This is not the default because scripts with legacy 8-bit data in them would break. See <a href="utf8">utf8</a>.</p> <h3 id="Perl's-Unicode-Model">Perl's Unicode Model</h3> <p>Perl supports both pre-5.6 strings of eight-bit native bytes, and strings of Unicode characters. The general principle is that Perl tries to keep its data as eight-bit bytes for as long as possible, but as soon as Unicodeness cannot be avoided, the data is transparently upgraded to Unicode. Prior to Perl v5.14.0, the upgrade was not completely transparent (see <a href="perlunicode#The-%22Unicode-Bug%22">The Unicode Bug in perlunicode</a>), and for backwards compatibility, full transparency is not gained unless <code class="inline"><a class="l_k" href="functions/use">use</a> <span class="w">feature</span>
<span class="q">'unicode_strings'</span></code> (see <a href="feature">feature</a>) or <code class="inline"><a class="l_k" href="functions/use">use</a> <span class="n">5.012</span></code> (or higher) is selected.</p> <p>Internally, Perl currently uses either whatever the native eight-bit character set of the platform (for example Latin-1) is, defaulting to UTF-8, to encode Unicode strings. Specifically, if all code points in the string are <code class="inline"><span class="n">0xFF</span></code> or less, Perl uses the native eight-bit character set. Otherwise, it uses UTF-8.</p> <p>A user of Perl does not normally need to know nor care how Perl happens to encode its internal strings, but it becomes relevant when outputting Unicode strings to a stream without a PerlIO layer (one with the "default" encoding). In such a case, the raw bytes used internally (the native character set or UTF-8, as appropriate for each string) will be used, and a "Wide character" warning will be issued if those strings contain a character beyond 0x00FF.</p> <p>For example,</p> <pre class="verbatim" data-language="perl">perl -e 'print "\x{DF}\n", "\x{0100}\x{DF}\n"'
</pre>
<p>produces a fairly useless mixture of native bytes and UTF-8, as well as a warning:</p> <pre class="verbatim" data-language="perl">Wide character in print at ...
</pre>
<p>To output UTF-8, use the <code class="inline"><span class="j">:</span><span class="w">encoding</span></code> or <code class="inline"><span class="j">:</span><span class="w">utf8</span></code> output layer. Prepending</p> <pre class="verbatim" data-language="perl">binmode(STDOUT, ":utf8");
</pre>
<p>to this sample program ensures that the output is completely UTF-8, and removes the program's warning.</p> <p>You can enable automatic UTF-8-ification of your standard file handles, default <code class="inline"><a class="l_k" href="functions/open">open()</a></code> layer, and <code class="inline"><span class="i">@ARGV</span></code> by using either the <code class="inline">-C</code> command line switch or the <code class="inline"><span class="w">PERL_UNICODE</span></code> environment variable, see <a href="perlrun">perlrun</a> for the documentation of the <code class="inline">-C</code> switch.</p> <p>Note that this means that Perl expects other software to work the same way: if Perl has been led to believe that STDIN should be UTF-8, but then STDIN coming in from another command is not UTF-8, Perl will likely complain about the malformed UTF-8.</p> <p>All features that combine Unicode and I/O also require using the new PerlIO feature. Almost all Perl 5.8 platforms do use PerlIO, though: you can see whether yours is by running "perl -V" and looking for <code class="inline"><span class="w">useperlio</span>=<span class="w">define</span></code> .</p> <h3 id="Unicode-and-EBCDIC">Unicode and EBCDIC</h3> <p>Perl 5.8.0 added support for Unicode on EBCDIC platforms. This support was allowed to lapse in later releases, but was revived in 5.22. Unicode support is somewhat more complex to implement since additional conversions are needed. See <a href="perlebcdic">perlebcdic</a> for more information.</p> <p>On EBCDIC platforms, the internal Unicode encoding form is UTF-EBCDIC instead of UTF-8. The difference is that as UTF-8 is "ASCII-safe" in that ASCII characters encode to UTF-8 as-is, while UTF-EBCDIC is "EBCDIC-safe", in that all the basic characters (which includes all those that have ASCII equivalents (like <code class="inline"><span class="q">"A"</span></code> , <code class="inline"><span class="q">"0"</span></code> , <code class="inline"><span class="q">"%"</span></code> , <i>etc.</i>) are the same in both EBCDIC and UTF-EBCDIC. Often, documentation will use the term "UTF-8" to mean UTF-EBCDIC as well. This is the case in this document.</p> <h3 id="Creating-Unicode">Creating Unicode</h3> <p>This section applies fully to Perls starting with v5.22. Various caveats for earlier releases are in the <a href="#Earlier-releases-caveats">Earlier releases caveats</a> subsection below.</p> <p>To create Unicode characters in literals, use the <code class="inline">\<span class="i">N</span><span class="s">{</span>...<span class="s">}</span></code> notation in double-quoted strings:</p> <pre class="verbatim" data-language="perl">my $smiley_from_name = "\N{WHITE SMILING FACE}";
my $smiley_from_code_point = "\N{U+263a}";
</pre>
<p>Similarly, they can be used in regular expression literals</p> <pre class="verbatim" data-language="perl">$smiley =~ /\N{WHITE SMILING FACE}/;
$smiley =~ /\N{U+263a}/;
</pre>
<p>At run-time you can use:</p> <pre class="verbatim" data-language="perl">use charnames ();
my $hebrew_alef_from_name
                     = charnames::string_vianame("HEBREW LETTER ALEF");
my $hebrew_alef_from_code_point = charnames::string_vianame("U+05D0");
</pre>
<p>Naturally, <code class="inline"><a class="l_k" href="functions/ord">ord()</a></code> will do the reverse: it turns a character into a code point.</p> <p>There are other runtime options as well. You can use <code class="inline"><a class="l_k" href="functions/pack">pack()</a></code>:</p> <pre class="verbatim" data-language="perl">my $hebrew_alef_from_code_point = pack("U", 0x05d0);
</pre>
<p>Or you can use <code class="inline"><a class="l_k" href="functions/chr">chr()</a></code>, though it is less convenient in the general case:</p> <pre class="verbatim" data-language="perl">$hebrew_alef_from_code_point = chr(utf8::unicode_to_native(0x05d0));
utf8::upgrade($hebrew_alef_from_code_point);
</pre>
<p>The <code class="inline"><span class="i">utf8::unicode_to_native</span><span class="s">(</span><span class="s">)</span></code> and <code class="inline"><span class="i">utf8::upgrade</span><span class="s">(</span><span class="s">)</span></code> aren't needed if the argument is above 0xFF, so the above could have been written as</p> <pre class="verbatim" data-language="perl">$hebrew_alef_from_code_point = chr(0x05d0);
</pre>
<p>since 0x5d0 is above 255.</p> <p><code class="inline">\<span class="w">x</span><span class="s">{</span><span class="s">}</span></code> and <code class="inline">\<span class="w">o</span><span class="s">{</span><span class="s">}</span></code> can also be used to specify code points at compile time in double-quotish strings, but, for backward compatibility with older Perls, the same rules apply as with <code class="inline"><a class="l_k" href="functions/chr">chr()</a></code> for code points less than 256.</p> <p><code class="inline"><span class="i">utf8::unicode_to_native</span><span class="s">(</span><span class="s">)</span></code> is used so that the Perl code is portable to EBCDIC platforms. You can omit it if you're <i>really</i> sure no one will ever want to use your code on a non-ASCII platform. Starting in Perl v5.22, calls to it on ASCII platforms are optimized out, so there's no performance penalty at all in adding it. Or you can simply use the other constructs that don't require it.</p> <p>See <a href="#Further-Resources">Further Resources</a> for how to find all these names and numeric codes.</p> <h4 id="Earlier-releases-caveats">Earlier releases caveats</h4> <p>On EBCDIC platforms, prior to v5.22, using <code class="inline">\<span class="i">N</span><span class="s">{</span><span class="w">U</span>+...<span class="s">}</span></code> doesn't work properly.</p> <p>Prior to v5.16, using <code class="inline">\<span class="i">N</span><span class="s">{</span>...<span class="s">}</span></code> with a character name (as opposed to a <code class="inline"><span class="w">U</span>+...</code> code point) required a <code class="inline"><a class="l_k" href="functions/use">use</a> <span class="w">charnames</span> <span class="co">:</span><span class="w">full</span></code> .</p> <p>Prior to v5.14, there were some bugs in <code class="inline">\<span class="i">N</span><span class="s">{</span>...<span class="s">}</span></code> with a character name (as opposed to a <code class="inline"><span class="w">U</span>+...</code> code point).</p> <p><code class="inline"><span class="i">charnames::string_vianame</span><span class="s">(</span><span class="s">)</span></code> was introduced in v5.14. Prior to that, <code class="inline"><span class="i">charnames::vianame</span><span class="s">(</span><span class="s">)</span></code> should work, but only if the argument is of the form <code class="inline"><span class="q">"U+..."</span></code> . Your best bet there for runtime Unicode by character name is probably:</p> <pre class="verbatim" data-language="perl">use charnames ();
my $hebrew_alef_from_name
                 = pack("U", charnames::vianame("HEBREW LETTER ALEF"));
</pre>
<h3 id="Handling-Unicode">Handling Unicode</h3> <p>Handling Unicode is for the most part transparent: just use the strings as usual. Functions like <code class="inline"><a class="l_k" href="functions/index">index()</a></code>, <code class="inline"><a class="l_k" href="functions/length">length()</a></code>, and <code class="inline"><a class="l_k" href="functions/substr">substr()</a></code> will work on the Unicode characters; regular expressions will work on the Unicode characters (see <a href="perlunicode">perlunicode</a> and <a href="perlretut">perlretut</a>).</p> <p>Note that Perl considers grapheme clusters to be separate characters, so for example</p> <pre class="verbatim" data-language="perl">print length("\N{LATIN CAPITAL LETTER A}\N{COMBINING ACUTE ACCENT}"),
      "\n";
</pre>
<p>will print 2, not 1. The only exception is that regular expressions have <code class="inline">\<span class="w">X</span></code> for matching an extended grapheme cluster. (Thus <code class="inline">\<span class="w">X</span></code> in a regular expression would match the entire sequence of both the example characters.)</p> <p>Life is not quite so transparent, however, when working with legacy encodings, I/O, and certain special cases:</p> <h3 id="Legacy-Encodings">Legacy Encodings</h3> <p>When you combine legacy data and Unicode, the legacy data needs to be upgraded to Unicode. Normally the legacy data is assumed to be ISO 8859-1 (or EBCDIC, if applicable).</p> <p>The <code class="inline"><span class="w">Encode</span></code> module knows about many encodings and has interfaces for doing conversions between those encodings:</p> <pre class="verbatim" data-language="perl">use Encode 'decode';
$data = decode("iso-8859-3", $data); # convert from legacy to utf-8
</pre>
<h3 id="Unicode-I%2fO">Unicode I/O</h3> <p>Normally, writing out Unicode data</p> <pre class="verbatim" data-language="perl">print FH $some_string_with_unicode, "\n";
</pre>
<p>produces raw bytes that Perl happens to use to internally encode the Unicode string. Perl's internal encoding depends on the system as well as what characters happen to be in the string at the time. If any of the characters are at code points <code class="inline"><span class="n">0x100</span></code> or above, you will get a warning. To ensure that the output is explicitly rendered in the encoding you desire--and to avoid the warning--open the stream with the desired encoding. Some examples:</p> <pre class="verbatim" data-language="perl">open FH, "&gt;:utf8", "file";

open FH, "&gt;:encoding(ucs2)",      "file";
open FH, "&gt;:encoding(UTF-8)",     "file";
open FH, "&gt;:encoding(shift_jis)", "file";
</pre>
<p>and on already open streams, use <code class="inline"><a class="l_k" href="functions/binmode">binmode()</a></code>:</p> <pre class="verbatim" data-language="perl">binmode(STDOUT, ":utf8");

binmode(STDOUT, ":encoding(ucs2)");
binmode(STDOUT, ":encoding(UTF-8)");
binmode(STDOUT, ":encoding(shift_jis)");
</pre>
<p>The matching of encoding names is loose: case does not matter, and many encodings have several aliases. Note that the <code class="inline"><span class="j">:</span><span class="w">utf8</span></code> layer must always be specified exactly like that; it is <i>not</i> subject to the loose matching of encoding names. Also note that currently <code class="inline"><span class="j">:</span><span class="w">utf8</span></code> is unsafe for input, because it accepts the data without validating that it is indeed valid UTF-8; you should instead use <code class="inline"><span class="j">:</span><span class="i">encoding</span><span class="s">(</span><span class="w">utf</span>-<span class="n">8</span><span class="s">)</span></code> (with or without a hyphen).</p> <p>See <a href="perlio">PerlIO</a> for the <code class="inline"><span class="j">:</span><span class="w">utf8</span></code> layer, <a href="perlio/encoding">PerlIO::encoding</a> and <a href="encode/perlio">Encode::PerlIO</a> for the <code class="inline"><span class="j">:</span><span class="i">encoding</span><span class="s">(</span><span class="s">)</span></code> layer, and <a href="encode/supported">Encode::Supported</a> for many encodings supported by the <code class="inline"><span class="w">Encode</span></code> module.</p> <p>Reading in a file that you know happens to be encoded in one of the Unicode or legacy encodings does not magically turn the data into Unicode in Perl's eyes. To do that, specify the appropriate layer when opening files</p> <pre class="verbatim" data-language="perl">open(my $fh,'&lt;:encoding(utf8)', 'anything');
my $line_of_unicode = &lt;$fh&gt;;

open(my $fh,'&lt;:encoding(Big5)', 'anything');
my $line_of_unicode = &lt;$fh&gt;;
</pre>
<p>The I/O layers can also be specified more flexibly with the <code class="inline"><a class="l_k" href="functions/open">open</a></code> pragma. See <a href="open">open</a>, or look at the following example.</p> <pre class="verbatim" data-language="perl">use open ':encoding(utf8)'; # input/output default encoding will be
                            # UTF-8
open X, "&gt;file";
print X chr(0x100), "\n";
close X;
open Y, "&lt;file";
printf "%#x\n", ord(&lt;Y&gt;); # this should print 0x100
close Y;
</pre>
<p>With the <code class="inline"><a class="l_k" href="functions/open">open</a></code> pragma you can use the <code class="inline"><span class="j">:</span><span class="w">locale</span></code> layer</p> <pre class="verbatim" data-language="perl">BEGIN { $ENV{LC_ALL} = $ENV{LANG} = 'ru_RU.KOI8-R' }
# the :locale will probe the locale environment variables like
# LC_ALL
use open OUT =&gt; ':locale'; # russki parusski
open(O, "&gt;koi8");
print O chr(0x430); # Unicode CYRILLIC SMALL LETTER A = KOI8-R 0xc1
close O;
open(I, "&lt;koi8");
printf "%#x\n", ord(&lt;I&gt;), "\n"; # this should print 0xc1
close I;
</pre>
<p>These methods install a transparent filter on the I/O stream that converts data from the specified encoding when it is read in from the stream. The result is always Unicode.</p> <p>The <a href="open">open</a> pragma affects all the <code class="inline"><a class="l_k" href="functions/open">open()</a></code> calls after the pragma by setting default layers. If you want to affect only certain streams, use explicit layers directly in the <code class="inline"><a class="l_k" href="functions/open">open()</a></code> call.</p> <p>You can switch encodings on an already opened stream by using <code class="inline"><a class="l_k" href="functions/binmode">binmode()</a></code>; see <a href="functions/binmode">binmode</a>.</p> <p>The <code class="inline"><span class="j">:</span><span class="w">locale</span></code> does not currently work with <code class="inline"><a class="l_k" href="functions/open">open()</a></code> and <code class="inline"><a class="l_k" href="functions/binmode">binmode()</a></code>, only with the <code class="inline"><a class="l_k" href="functions/open">open</a></code> pragma. The <code class="inline"><span class="j">:</span><span class="w">utf8</span></code> and <code class="inline"><span class="j">:</span><span class="i">encoding</span><span class="s">(</span>...<span class="s">)</span></code> methods do work with all of <code class="inline"><a class="l_k" href="functions/open">open()</a></code>, <code class="inline"><a class="l_k" href="functions/binmode">binmode()</a></code>, and the <code class="inline"><a class="l_k" href="functions/open">open</a></code> pragma.</p> <p>Similarly, you may use these I/O layers on output streams to automatically convert Unicode to the specified encoding when it is written to the stream. For example, the following snippet copies the contents of the file "text.jis" (encoded as ISO-2022-JP, aka JIS) to the file "text.utf8", encoded as UTF-8:</p> <pre class="verbatim" data-language="perl">open(my $nihongo, '&lt;:encoding(iso-2022-jp)', 'text.jis');
open(my $unicode, '&gt;:utf8',                  'text.utf8');
while (&lt;$nihongo&gt;) { print $unicode $_ }
</pre>
<p>The naming of encodings, both by the <code class="inline"><a class="l_k" href="functions/open">open()</a></code> and by the <code class="inline"><a class="l_k" href="functions/open">open</a></code> pragma allows for flexible names: <code class="inline"><span class="w">koi8</span>-r</code> and <code class="inline"><span class="w">KOI8R</span></code> will both be understood.</p> <p>Common encodings recognized by ISO, MIME, IANA, and various other standardisation organisations are recognised; for a more detailed list see <a href="encode/supported">Encode::Supported</a>.</p> <p><code class="inline"><a class="l_k" href="functions/read">read()</a></code> reads characters and returns the number of characters. <code class="inline"><a class="l_k" href="functions/seek">seek()</a></code> and <code class="inline"><a class="l_k" href="functions/tell">tell()</a></code> operate on byte counts, as do <code class="inline"><a class="l_k" href="functions/sysread">sysread()</a></code> and <code class="inline"><a class="l_k" href="functions/sysseek">sysseek()</a></code>.</p> <p>Notice that because of the default behaviour of not doing any conversion upon input if there is no default layer, it is easy to mistakenly write code that keeps on expanding a file by repeatedly encoding the data:</p> <pre class="verbatim" data-language="perl"># BAD CODE WARNING
open F, "file";
local $/; ## read in the whole file of 8-bit characters
$t = &lt;F&gt;;
close F;
open F, "&gt;:encoding(utf8)", "file";
print F $t; ## convert to UTF-8 on output
close F;
</pre>
<p>If you run this code twice, the contents of the <i>file</i> will be twice UTF-8 encoded. A <code class="inline"><a class="l_k" href="functions/use">use</a> <a class="l_k" href="functions/open">open</a> <span class="q">':encoding(utf8)'</span></code> would have avoided the bug, or explicitly opening also the <i>file</i> for input as UTF-8.</p> <p><b>NOTE</b>: the <code class="inline"><span class="j">:</span><span class="w">utf8</span></code> and <code class="inline"><span class="j">:</span><span class="w">encoding</span></code> features work only if your Perl has been built with <a href="perlio">PerlIO</a>, which is the default on most systems.</p> <h3 id="Displaying-Unicode-As-Text">Displaying Unicode As Text</h3> <p>Sometimes you might want to display Perl scalars containing Unicode as simple ASCII (or EBCDIC) text. The following subroutine converts its argument so that Unicode characters with code points greater than 255 are displayed as <code class="inline">\<span class="i">x</span><span class="s">{</span>...<span class="s">}</span></code> , control characters (like <code class="inline">\<span class="w">n</span></code> ) are displayed as <code class="inline">\<span class="w">x</span>..</code> , and the rest of the characters as themselves:</p> <pre class="verbatim" data-language="perl">sub nice_string {
       join("",
       map { $_ &gt; 255                    # if wide character...
             ? sprintf("\\x{%04X}", $_)  # \x{...}
             : chr($_) =~ /[[:cntrl:]]/  # else if control character...
               ? sprintf("\\x%02X", $_)  # \x..
               : quotemeta(chr($_))      # else quoted or as themselves
       } unpack("W*", $_[0]));           # unpack Unicode characters
  }
</pre>
<p>For example,</p> <pre class="verbatim" data-language="perl">nice_string("foo\x{100}bar\n")
</pre>
<p>returns the string</p> <pre class="verbatim" data-language="perl">'foo\x{0100}bar\x0A'
</pre>
<p>which is ready to be printed.</p> <p>(<code class="inline">\\<span class="w">x</span><span class="s">{</span><span class="s">}</span></code> is used here instead of <code class="inline">\\<span class="w">N</span><span class="s">{</span><span class="s">}</span></code> , since it's most likely that you want to see what the native values are.)</p> <h3 id="Special-Cases">Special Cases</h3> <ul> <li> <p>Bit Complement Operator ~ And vec()</p> <p>The bit complement operator <code class="inline">~</code> may produce surprising results if used on strings containing characters with ordinal values above 255. In such a case, the results are consistent with the internal encoding of the characters, but not with much else. So don't do that. Similarly for <code class="inline"><a class="l_k" href="functions/vec">vec()</a></code>: you will be operating on the internally-encoded bit patterns of the Unicode characters, not on the code point values, which is very probably not what you want.</p> </li> <li> <p>Peeking At Perl's Internal Encoding</p> <p>Normal users of Perl should never care how Perl encodes any particular Unicode string (because the normal ways to get at the contents of a string with Unicode--via input and output--should always be via explicitly-defined I/O layers). But if you must, there are two ways of looking behind the scenes.</p> <p>One way of peeking inside the internal encoding of Unicode characters is to use <code class="inline">unpack("C*", ...</code> to get the bytes of whatever the string encoding happens to be, or <code class="inline"><a class="l_k" href="functions/unpack">unpack</a><span class="s">(</span><span class="q">"U0.."</span><span class="cm">,</span> ...<span class="s">)</span></code> to get the bytes of the UTF-8 encoding:</p> <pre class="verbatim" data-language="perl"># this prints  c4 80  for the UTF-8 bytes 0xc4 0x80
print join(" ", unpack("U0(H2)*", pack("U", 0x100))), "\n";
</pre>
<p>Yet another way would be to use the Devel::Peek module:</p> <pre class="verbatim" data-language="perl">perl -MDevel::Peek -e 'Dump(chr(0x100))'
</pre>
<p>That shows the <code class="inline"><span class="w">UTF8</span></code> flag in FLAGS and both the UTF-8 bytes and Unicode characters in <code class="inline"><span class="w">PV</span></code> . See also later in this document the discussion about the <code class="inline"><span class="i">utf8::is_utf8</span><span class="s">(</span><span class="s">)</span></code> function.</p> </li> </ul> <h3 id="Advanced-Topics">Advanced Topics</h3> <ul> <li> <p>String Equivalence</p> <p>The question of string equivalence turns somewhat complicated in Unicode: what do you mean by "equal"?</p> <p>(Is <code class="inline"><span class="w">LATIN</span> <span class="w">CAPITAL</span> <span class="w">LETTER</span> <span class="w">A</span> <span class="w">WITH</span> <span class="w">ACUTE</span></code> equal to <code class="inline"><span class="w">LATIN</span> <span class="w">CAPITAL</span> <span class="w">LETTER</span> <span class="w">A</span></code> ?)</p> <p>The short answer is that by default Perl compares equivalence (<code class="inline">eq</code> , <code class="inline">ne</code> ) based only on code points of the characters. In the above case, the answer is no (because 0x00C1 != 0x0041). But sometimes, any CAPITAL LETTER A's should be considered equal, or even A's of any case.</p> <p>The long answer is that you need to consider character normalization and casing issues: see <a href="unicode/normalize">Unicode::Normalize</a>, Unicode Technical Report #15, <a href="http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2funicode%2freports%2ftr15">Unicode Normalization Forms</a> and sections on case mapping in the <a href="http://search.cpan.org/perldoc/http:#%2fwww.unicode.org">Unicode Standard</a>.</p> <p>As of Perl 5.8.0, the "Full" case-folding of <i>Case Mappings/SpecialCasing</i> is implemented, but bugs remain in <code class="inline"><a class="l_k" href="functions/qr">qr//i</a></code> with them, mostly fixed by 5.14, and essentially entirely by 5.18.</p> </li> <li> <p>String Collation</p> <p>People like to see their strings nicely sorted--or as Unicode parlance goes, collated. But again, what do you mean by collate?</p> <p>(Does <code class="inline"><span class="w">LATIN</span> <span class="w">CAPITAL</span> <span class="w">LETTER</span> <span class="w">A</span> <span class="w">WITH</span> <span class="w">ACUTE</span></code> come before or after <code class="inline"><span class="w">LATIN</span> <span class="w">CAPITAL</span> <span class="w">LETTER</span> <span class="w">A</span> <span class="w">WITH</span> <span class="w">GRAVE</span></code> ?)</p> <p>The short answer is that by default, Perl compares strings (<code class="inline">lt</code> , <code class="inline">le</code> , <code class="inline">cmp</code> , <code class="inline">ge</code> , <code class="inline">gt</code> ) based only on the code points of the characters. In the above case, the answer is "after", since <code class="inline"><span class="n">0x00C1</span></code> &gt; <code class="inline"><span class="n">0x00C0</span></code> .</p> <p>The long answer is that "it depends", and a good answer cannot be given without knowing (at the very least) the language context. See <a href="unicode/collate">Unicode::Collate</a>, and <i>Unicode Collation Algorithm</i> <a href="http://www.unicode.org/unicode/reports/tr10/">http://www.unicode.org/unicode/reports/tr10/</a></p> </li> </ul> <h3 id="Miscellaneous">Miscellaneous</h3> <ul> <li> <p>Character Ranges and Classes</p> <p>Character ranges in regular expression bracketed character classes ( e.g., <code class="inline"><span class="q">/[a-z]/</span></code> ) and in the <code class="inline"><a class="l_k" href="functions/tr">tr///</a></code> (also known as <code class="inline"><a class="l_k" href="functions/y">y///</a></code>) operator are not magically Unicode-aware. What this means is that <code class="inline"><span class="s">[</span><span class="w">A</span>-<span class="w">Za</span>-z<span class="s">]</span></code> will not magically start to mean "all alphabetic letters" (not that it does mean that even for 8-bit characters; for those, if you are using locales (<a href="perllocale">perllocale</a>), use <code class="inline"><span class="q">/[[:alpha:]]/</span></code> ; and if not, use the 8-bit-aware property <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">alpha</span><span class="s">}</span></code> ).</p> <p>All the properties that begin with <code class="inline">\<span class="w">p</span></code> (and its inverse <code class="inline">\<span class="w">P</span></code> ) are actually character classes that are Unicode-aware. There are dozens of them, see <a href="perluniprops">perluniprops</a>.</p> <p>Starting in v5.22, you can use Unicode code points as the end points of regular expression pattern character ranges, and the range will include all Unicode code points that lie between those end points, inclusive.</p> <pre class="verbatim" data-language="perl">qr/ [\N{U+03]-\N{U+20}] /x
</pre>
<p>includes the code points <code class="inline">\<span class="i">N</span><span class="s">{</span><span class="w">U</span>+<span class="n">03</span><span class="s">}</span></code> , <code class="inline">\<span class="i">N</span><span class="s">{</span><span class="w">U</span>+<span class="n">04</span><span class="s">}</span></code> , ..., <code class="inline">\<span class="i">N</span><span class="s">{</span><span class="w">U</span>+<span class="n">20</span><span class="s">}</span></code> .</p> <p>(It is planned to extend this behavior to ranges in <code class="inline"><a class="l_k" href="functions/tr">tr///</a></code> in Perl v5.24.)</p> </li> <li> <p>String-To-Number Conversions</p> <p>Unicode does define several other decimal--and numeric--characters besides the familiar 0 to 9, such as the Arabic and Indic digits. Perl does not support string-to-number conversion for digits other than ASCII <code class="inline"><span class="n">0</span></code> to <code class="inline"><span class="n">9</span></code> (and ASCII <code class="inline"><span class="w">a</span></code> to <code class="inline"><span class="w">f</span></code> for hexadecimal). To get safe conversions from any Unicode string, use <a href="unicode/ucd#num()">num() in Unicode::UCD</a>.</p> </li> </ul> <h3 id="Questions-With-Answers">Questions With Answers</h3> <ul> <li> <p>Will My Old Scripts Break?</p> <p>Very probably not. Unless you are generating Unicode characters somehow, old behaviour should be preserved. About the only behaviour that has changed and which could start generating Unicode is the old behaviour of <code class="inline"><a class="l_k" href="functions/chr">chr()</a></code> where supplying an argument more than 255 produced a character modulo 255. <code class="inline"><a class="l_k" href="functions/chr">chr(300)</a></code>, for example, was equal to <code class="inline"><a class="l_k" href="functions/chr">chr(45)</a></code> or "-" (in ASCII), now it is LATIN CAPITAL LETTER I WITH BREVE.</p> </li> <li> <p>How Do I Make My Scripts Work With Unicode?</p> <p>Very little work should be needed since nothing changes until you generate Unicode data. The most important thing is getting input as Unicode; for that, see the earlier I/O discussion. To get full seamless Unicode support, add <code class="inline"><a class="l_k" href="functions/use">use</a> <span class="w">feature</span> <span class="q">'unicode_strings'</span></code> (or <code class="inline"><a class="l_k" href="functions/use">use</a> <span class="n">5.012</span></code> or higher) to your script.</p> </li> <li> <p>How Do I Know Whether My String Is In Unicode?</p> <p>You shouldn't have to care. But you may if your Perl is before 5.14.0 or you haven't specified <code class="inline"><a class="l_k" href="functions/use">use</a> <span class="w">feature</span> <span class="q">'unicode_strings'</span></code> or <code class="inline"><a class="l_k" href="functions/use">use</a>
<span class="n">5.012</span></code> (or higher) because otherwise the rules for the code points in the range 128 to 255 are different depending on whether the string they are contained within is in Unicode or not. (See <a href="perlunicode#When-Unicode-Does-Not-Happen">When Unicode Does Not Happen in perlunicode</a>.)</p> <p>To determine if a string is in Unicode, use:</p> <pre class="verbatim" data-language="perl">print utf8::is_utf8($string) ? 1 : 0, "\n";
</pre>
<p>But note that this doesn't mean that any of the characters in the string are necessary UTF-8 encoded, or that any of the characters have code points greater than 0xFF (255) or even 0x80 (128), or that the string has any characters at all. All the <code class="inline"><span class="i">is_utf8</span><span class="s">(</span><span class="s">)</span></code> does is to return the value of the internal "utf8ness" flag attached to the <code class="inline"><span class="i">$string</span></code> . If the flag is off, the bytes in the scalar are interpreted as a single byte encoding. If the flag is on, the bytes in the scalar are interpreted as the (variable-length, potentially multi-byte) UTF-8 encoded code points of the characters. Bytes added to a UTF-8 encoded string are automatically upgraded to UTF-8. If mixed non-UTF-8 and UTF-8 scalars are merged (double-quoted interpolation, explicit concatenation, or printf/sprintf parameter substitution), the result will be UTF-8 encoded as if copies of the byte strings were upgraded to UTF-8: for example,</p> <pre class="verbatim" data-language="perl">$a = "ab\x80c";
$b = "\x{100}";
print "$a = $b\n";
</pre>
<p>the output string will be UTF-8-encoded <code class="inline"><span class="w">ab</span>\<span class="w">x80c</span> = \<span class="i">x</span><span class="s">{</span><span class="n">100</span><span class="s">}</span>\<span class="w">n</span></code> , but <code class="inline"><span class="i">$a</span></code> will stay byte-encoded.</p> <p>Sometimes you might really need to know the byte length of a string instead of the character length. For that use either the <code class="inline"><span class="i">Encode::encode_utf8</span><span class="s">(</span><span class="s">)</span></code> function or the <code class="inline"><span class="w">bytes</span></code> pragma and the <code class="inline"><a class="l_k" href="functions/length">length()</a></code> function:</p> <pre class="verbatim" data-language="perl">my $unicode = chr(0x100);
print length($unicode), "\n"; # will print 1
require Encode;
print length(Encode::encode_utf8($unicode)),"\n"; # will print 2
use bytes;
print length($unicode), "\n"; # will also print 2
                              # (the 0xC4 0x80 of the UTF-8)
no bytes;
</pre>
</li> <li> <p>How Do I Find Out What Encoding a File Has?</p> <p>You might try <a href="encode/guess">Encode::Guess</a>, but it has a number of limitations.</p> </li> <li> <p>How Do I Detect Data That's Not Valid In a Particular Encoding?</p> <p>Use the <code class="inline"><span class="w">Encode</span></code> package to try converting it. For example,</p> <pre class="verbatim" data-language="perl">use Encode 'decode_utf8';

if (eval { decode_utf8($string, Encode::FB_CROAK); 1 }) {
    # $string is valid utf8
} else {
    # $string is not valid utf8
}
</pre>
<p>Or use <code class="inline"><a class="l_k" href="functions/unpack">unpack</a></code> to try decoding it:</p> <pre class="verbatim" data-language="perl">use warnings;
@chars = unpack("C0U*", $string_of_bytes_that_I_think_is_utf8);
</pre>
<p>If invalid, a <code class="inline">Malformed UTF-8 character</code> warning is produced. The "C0" means "process the string character per character". Without that, the <code class="inline"><a class="l_k" href="functions/unpack">unpack</a><span class="s">(</span><span class="q">"U*"</span><span class="cm">,</span> ...<span class="s">)</span></code> would work in <code class="inline"><span class="w">U0</span></code> mode (the default if the format string starts with <code class="inline"><span class="w">U</span></code> ) and it would return the bytes making up the UTF-8 encoding of the target string, something that will always work.</p> </li> <li> <p>How Do I Convert Binary Data Into a Particular Encoding, Or Vice Versa?</p> <p>This probably isn't as useful as you might think. Normally, you shouldn't need to.</p> <p>In one sense, what you are asking doesn't make much sense: encodings are for characters, and binary data are not "characters", so converting "data" into some encoding isn't meaningful unless you know in what character set and encoding the binary data is in, in which case it's not just binary data, now is it?</p> <p>If you have a raw sequence of bytes that you know should be interpreted via a particular encoding, you can use <code class="inline"><span class="w">Encode</span></code> :</p> <pre class="verbatim" data-language="perl">use Encode 'from_to';
from_to($data, "iso-8859-1", "utf-8"); # from latin-1 to utf-8
</pre>
<p>The call to <code class="inline"><span class="i">from_to</span><span class="s">(</span><span class="s">)</span></code> changes the bytes in <code class="inline"><span class="i">$data</span></code> , but nothing material about the nature of the string has changed as far as Perl is concerned. Both before and after the call, the string <code class="inline"><span class="i">$data</span></code> contains just a bunch of 8-bit bytes. As far as Perl is concerned, the encoding of the string remains as "system-native 8-bit bytes".</p> <p>You might relate this to a fictional 'Translate' module:</p> <pre class="verbatim" data-language="perl">use Translate;
my $phrase = "Yes";
Translate::from_to($phrase, 'english', 'deutsch');
## phrase now contains "Ja"
</pre>
<p>The contents of the string changes, but not the nature of the string. Perl doesn't know any more after the call than before that the contents of the string indicates the affirmative.</p> <p>Back to converting data. If you have (or want) data in your system's native 8-bit encoding (e.g. Latin-1, EBCDIC, etc.), you can use pack/unpack to convert to/from Unicode.</p> <pre class="verbatim" data-language="perl">$native_string  = pack("W*", unpack("U*", $Unicode_string));
$Unicode_string = pack("U*", unpack("W*", $native_string));
</pre>
<p>If you have a sequence of bytes you <b>know</b> is valid UTF-8, but Perl doesn't know it yet, you can make Perl a believer, too:</p> <pre class="verbatim" data-language="perl">use Encode 'decode_utf8';
$Unicode = decode_utf8($bytes);
</pre>
<p>or:</p> <pre class="verbatim" data-language="perl">$Unicode = pack("U0a*", $bytes);
</pre>
<p>You can find the bytes that make up a UTF-8 sequence with</p> <pre class="verbatim" data-language="perl">@bytes = unpack("C*", $Unicode_string)
</pre>
<p>and you can create well-formed Unicode with</p> <pre class="verbatim" data-language="perl">$Unicode_string = pack("U*", 0xff, ...)
</pre>
</li> <li> <p>How Do I Display Unicode? How Do I Input Unicode?</p> <p>See <a href="http://www.alanwood.net/unicode/">http://www.alanwood.net/unicode/</a> and <a href="http://www.cl.cam.ac.uk/~mgk25/unicode.html">http://www.cl.cam.ac.uk/~mgk25/unicode.html</a></p> </li> <li> <p>How Does Unicode Work With Traditional Locales?</p> <p>If your locale is a UTF-8 locale, starting in Perl v5.20, Perl works well for all categories except <code class="inline"><span class="w">LC_COLLATE</span></code> dealing with sorting and the <code class="inline">cmp</code> operator.</p> <p>For other locales, starting in Perl 5.16, you can specify</p> <pre class="verbatim" data-language="perl">use locale ':not_characters';
</pre>
<p>to get Perl to work well with them. The catch is that you have to translate from the locale character set to/from Unicode yourself. See <a href="#Unicode-I%2fO">Unicode I/O</a> above for how to</p> <pre class="verbatim" data-language="perl">use open ':locale';
</pre>
<p>to accomplish this, but full details are in <a href="perllocale#Unicode-and-UTF-8">Unicode and UTF-8 in perllocale</a>, including gotchas that happen if you don't specify <code class="inline"><span class="j">:</span><span class="w">not_characters</span></code> .</p> </li> </ul> <h3 id="Hexadecimal-Notation">Hexadecimal Notation</h3> <p>The Unicode standard prefers using hexadecimal notation because that more clearly shows the division of Unicode into blocks of 256 characters. Hexadecimal is also simply shorter than decimal. You can use decimal notation, too, but learning to use hexadecimal just makes life easier with the Unicode standard. The <code class="inline"><span class="w">U</span>+<span class="w">HHHH</span></code> notation uses hexadecimal, for example.</p> <p>The <code class="inline"><span class="n">0</span>x</code> prefix means a hexadecimal number, the digits are 0-9 <i>and</i> a-f (or A-F, case doesn't matter). Each hexadecimal digit represents four bits, or half a byte. <code class="inline"><a class="l_k" href="functions/print">print</a> <span class="n">0</span>x...<span class="cm">,</span> <span class="q">"\n"</span></code> will show a hexadecimal number in decimal, and <code class="inline"><a class="l_k" href="functions/printf">printf</a> <span class="q">"%x\n"</span><span class="cm">,</span> <span class="i">$decimal</span></code> will show a decimal number in hexadecimal. If you have just the "hex digits" of a hexadecimal number, you can use the <code class="inline"><a class="l_k" href="functions/hex">hex()</a></code> function.</p> <pre class="verbatim" data-language="perl">print 0x0009, "\n";    # 9
print 0x000a, "\n";    # 10
print 0x000f, "\n";    # 15
print 0x0010, "\n";    # 16
print 0x0011, "\n";    # 17
print 0x0100, "\n";    # 256

print 0x0041, "\n";    # 65

printf "%x\n",  65;    # 41
printf "%#x\n", 65;    # 0x41

print hex("41"), "\n"; # 65
</pre>
<h3 id="Further-Resources">Further Resources</h3> <ul> <li> <p>Unicode Consortium</p> <p><a href="http://www.unicode.org/">http://www.unicode.org/</a></p> </li> <li> <p>Unicode FAQ</p> <p><a href="http://www.unicode.org/unicode/faq/">http://www.unicode.org/unicode/faq/</a></p> </li> <li> <p>Unicode Glossary</p> <p><a href="http://www.unicode.org/glossary/">http://www.unicode.org/glossary/</a></p> </li> <li> <p>Unicode Recommended Reading List</p> <p>The Unicode Consortium has a list of articles and books, some of which give a much more in depth treatment of Unicode: <a href="http://unicode.org/resources/readinglist.html">http://unicode.org/resources/readinglist.html</a></p> </li> <li> <p>Unicode Useful Resources</p> <p><a href="http://www.unicode.org/unicode/onlinedat/resources.html">http://www.unicode.org/unicode/onlinedat/resources.html</a></p> </li> <li> <p>Unicode and Multilingual Support in HTML, Fonts, Web Browsers and Other Applications</p> <p><a href="http://www.alanwood.net/unicode/">http://www.alanwood.net/unicode/</a></p> </li> <li> <p>UTF-8 and Unicode FAQ for Unix/Linux</p> <p><a href="http://www.cl.cam.ac.uk/~mgk25/unicode.html">http://www.cl.cam.ac.uk/~mgk25/unicode.html</a></p> </li> <li> <p>Legacy Character Sets</p> <p><a href="http://www.czyborra.com/">http://www.czyborra.com/</a> <a href="http://www.eki.ee/letter/">http://www.eki.ee/letter/</a></p> </li> <li> <p>You can explore various information from the Unicode data files using the <code class="inline"><span class="w">Unicode::UCD</span></code> module.</p> </li> </ul> <h2 id="UNICODE-IN-OLDER-PERLS">UNICODE IN OLDER PERLS</h2> <p>If you cannot upgrade your Perl to 5.8.0 or later, you can still do some Unicode processing by using the modules <code class="inline"><span class="w">Unicode::String</span></code> , <code class="inline"><span class="w">Unicode::Map8</span></code> , and <code class="inline"><span class="w">Unicode::Map</span></code> , available from CPAN. If you have the GNU recode installed, you can also use the Perl front-end <code class="inline"><span class="w">Convert::Recode</span></code> for character conversions.</p> <p>The following are fast conversions from ISO 8859-1 (Latin-1) bytes to UTF-8 bytes and back, the code works even with older Perl 5 versions.</p> <pre class="verbatim" data-language="perl"># ISO 8859-1 to UTF-8
s/([\x80-\xFF])/chr(0xC0|ord($1)&gt;&gt;6).chr(0x80|ord($1)&amp;0x3F)/eg;

# UTF-8 to ISO 8859-1
s/([\xC2\xC3])([\x80-\xBF])/chr(ord($1)&lt;&lt;6&amp;0xC0|ord($2)&amp;0x3F)/eg;
</pre>
<h2 id="SEE-ALSO">SEE ALSO</h2> <p><a href="perlunitut">perlunitut</a>, <a href="perlunicode">perlunicode</a>, <a href="encode">Encode</a>, <a href="open">open</a>, <a href="utf8">utf8</a>, <a href="bytes">bytes</a>, <a href="perlretut">perlretut</a>, <a href="perlrun">perlrun</a>, <a href="unicode/collate">Unicode::Collate</a>, <a href="unicode/normalize">Unicode::Normalize</a>, <a href="unicode/ucd">Unicode::UCD</a></p> <h2 id="ACKNOWLEDGMENTS">ACKNOWLEDGMENTS</h2> <p>Thanks to the kind readers of the perl5-porters@perl.org, perl-unicode@perl.org, linux-utf8@nl.linux.org, and unicore@unicode.org mailing lists for their valuable feedback.</p> <h2 id="AUTHOR%2c-COPYRIGHT%2c-AND-LICENSE">AUTHOR, COPYRIGHT, AND LICENSE</h2> <p>Copyright 2001-2011 Jarkko Hietaniemi &lt;jhi@iki.fi&gt;. Now maintained by Perl 5 Porters.</p> <p>This document may be distributed under the same terms as Perl itself.</p>
<div class="_attribution">
  <p class="_attribution-p">
     19932016 Larry Wall and others<br>Licensed under the GNU General Public License version 1 or later, or the Artistic License.<br>The Perl logo is a trademark of the Perl Foundation.<br>
    <a href="https://perldoc.perl.org/5.26.0/perluniintro.html" class="_attribution-link">https://perldoc.perl.org/5.26.0/perluniintro.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
