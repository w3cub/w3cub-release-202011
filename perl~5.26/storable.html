
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Storable - Perl 5.26 - W3cubDocs</title>
  
  <meta name="description" content=" Storable - persistence for Perl data structures ">
  <meta name="keywords" content="storable, perl, perl~5.26">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/perl~5.26/storable.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/perl~5.26.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/perl~5.26/" class="_nav-link" title="" style="margin-left:0;">Perl 5.26</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _perl">
				
				
<h1>Storable</h1>  <ul>
<li><a href="#NAME">NAME</a></li>
<li><a href="#SYNOPSIS">SYNOPSIS</a></li>
<li><a href="#DESCRIPTION">DESCRIPTION</a></li>
<li><a href="#MEMORY-STORE">MEMORY STORE</a></li>
<li><a href="#ADVISORY-LOCKING">ADVISORY LOCKING</a></li>
<li><a href="#SPEED">SPEED</a></li>
<li><a href="#CANONICAL-REPRESENTATION">CANONICAL REPRESENTATION</a></li>
<li><a href="#CODE-REFERENCES">CODE REFERENCES</a></li>
<li><a href="#FORWARD-COMPATIBILITY">FORWARD COMPATIBILITY</a></li>
<li><a href="#ERROR-REPORTING">ERROR REPORTING</a></li>
<li>
<a href="#WIZARDS-ONLY">WIZARDS ONLY</a><ul>
<li><a href="#Hooks">Hooks</a></li>
<li><a href="#Predicates">Predicates</a></li>
<li><a href="#Recursion">Recursion</a></li>
<li><a href="#Deep-Cloning">Deep Cloning</a></li>
</ul>
</li>
<li><a href="#Storable-magic">Storable magic</a></li>
<li><a href="#EXAMPLES">EXAMPLES</a></li>
<li><a href="#SECURITY-WARNING">SECURITY WARNING</a></li>
<li><a href="#WARNING">WARNING</a></li>
<li>
<a href="#BUGS">BUGS</a><ul><li><a href="#64-bit-data-in-perl-5.6.0-and-5.6.1">64 bit data in perl 5.6.0 and 5.6.1</a></li></ul>
</li>
<li><a href="#CREDITS">CREDITS</a></li>
<li><a href="#AUTHOR">AUTHOR</a></li>
<li><a href="#SEE-ALSO">SEE ALSO</a></li>
</ul>
<h2 id="NAME">NAME</h2> <p>Storable - persistence for Perl data structures</p> <h2 id="SYNOPSIS">SYNOPSIS</h2> <pre class="verbatim" data-language="perl">use Storable;
store \%table, 'file';
$hashref = retrieve('file');

use Storable qw(nstore store_fd nstore_fd freeze thaw dclone);

# Network order
nstore \%table, 'file';
$hashref = retrieve('file');	# There is NO nretrieve()

# Storing to and retrieving from an already opened file
store_fd \@array, \*STDOUT;
nstore_fd \%table, \*STDOUT;
$aryref = fd_retrieve(\*SOCKET);
$hashref = fd_retrieve(\*SOCKET);

# Serializing to memory
$serialized = freeze \%table;
%table_clone = %{ thaw($serialized) };

# Deep (recursive) cloning
$cloneref = dclone($ref);

# Advisory locking
use Storable qw(lock_store lock_nstore lock_retrieve)
lock_store \%table, 'file';
lock_nstore \%table, 'file';
$hashref = lock_retrieve('file');
</pre>
<h2 id="DESCRIPTION">DESCRIPTION</h2> <p>The Storable package brings persistence to your Perl data structures containing SCALAR, ARRAY, HASH or REF objects, i.e. anything that can be conveniently stored to disk and retrieved at a later time.</p> <p>It can be used in the regular procedural way by calling <code class="inline"><span class="w">store</span></code> with a reference to the object to be stored, along with the file name where the image should be written.</p> <p>The routine returns <code class="inline"><a class="l_k" href="functions/undef">undef</a></code> for I/O problems or other internal error, a true value otherwise. Serious errors are propagated as a <code class="inline"><a class="l_k" href="functions/die">die</a></code> exception.</p> <p>To retrieve data stored to disk, use <code class="inline"><span class="w">retrieve</span></code> with a file name. The objects stored into that file are recreated into memory for you, and a <i>reference</i> to the root object is returned. In case an I/O error occurs while reading, <code class="inline"><a class="l_k" href="functions/undef">undef</a></code> is returned instead. Other serious errors are propagated via <code class="inline"><a class="l_k" href="functions/die">die</a></code>.</p> <p>Since storage is performed recursively, you might want to stuff references to objects that share a lot of common data into a single array or hash table, and then store that object. That way, when you retrieve back the whole thing, the objects will continue to share what they originally shared.</p> <p>At the cost of a slight header overhead, you may store to an already opened file descriptor using the <code class="inline"><span class="w">store_fd</span></code> routine, and retrieve from a file via <code class="inline"><span class="w">fd_retrieve</span></code> . Those names aren't imported by default, so you will have to do that explicitly if you need those routines. The file descriptor you supply must be already opened, for read if you're going to retrieve and for write if you wish to store.</p> <pre class="verbatim" data-language="perl">store_fd(\%table, *STDOUT) || die "can't store to stdout\n";
$hashref = fd_retrieve(*STDIN);
</pre>
<p>You can also store data in network order to allow easy sharing across multiple platforms, or when storing on a socket known to be remotely connected. The routines to call have an initial <code class="inline"><span class="w">n</span></code> prefix for <i>network</i>, as in <code class="inline"><span class="w">nstore</span></code> and <code class="inline"><span class="w">nstore_fd</span></code> . At retrieval time, your data will be correctly restored so you don't have to know whether you're restoring from native or network ordered data. Double values are stored stringified to ensure portability as well, at the slight risk of loosing some precision in the last decimals.</p> <p>When using <code class="inline"><span class="w">fd_retrieve</span></code> , objects are retrieved in sequence, one object (i.e. one recursive tree) per associated <code class="inline"><span class="w">store_fd</span></code> .</p> <p>If you're more from the object-oriented camp, you can inherit from Storable and directly store your objects by invoking <code class="inline"><span class="w">store</span></code> as a method. The fact that the root of the to-be-stored tree is a blessed reference (i.e. an object) is special-cased so that the retrieve does not provide a reference to that object but rather the blessed object reference itself. (Otherwise, you'd get a reference to that blessed object).</p> <h2 id="MEMORY-STORE">MEMORY STORE</h2> <p>The Storable engine can also store data into a Perl scalar instead, to later retrieve them. This is mainly used to freeze a complex structure in some safe compact memory place (where it can possibly be sent to another process via some IPC, since freezing the structure also serializes it in effect). Later on, and maybe somewhere else, you can thaw the Perl scalar out and recreate the original complex structure in memory.</p> <p>Surprisingly, the routines to be called are named <code class="inline"><span class="w">freeze</span></code> and <code class="inline"><span class="w">thaw</span></code> . If you wish to send out the frozen scalar to another machine, use <code class="inline"><span class="w">nfreeze</span></code> instead to get a portable image.</p> <p>Note that freezing an object structure and immediately thawing it actually achieves a deep cloning of that structure:</p> <pre class="verbatim" data-language="perl">dclone(.) = thaw(freeze(.))
</pre>
<p>Storable provides you with a <code class="inline"><span class="w">dclone</span></code> interface which does not create that intermediary scalar but instead freezes the structure in some internal memory space and then immediately thaws it out.</p> <h2 id="ADVISORY-LOCKING">ADVISORY LOCKING</h2> <p>The <code class="inline"><span class="w">lock_store</span></code> and <code class="inline"><span class="w">lock_nstore</span></code> routine are equivalent to <code class="inline"><span class="w">store</span></code> and <code class="inline"><span class="w">nstore</span></code> , except that they get an exclusive lock on the file before writing. Likewise, <code class="inline"><span class="w">lock_retrieve</span></code> does the same as <code class="inline"><span class="w">retrieve</span></code> , but also gets a shared lock on the file before reading.</p> <p>As with any advisory locking scheme, the protection only works if you systematically use <code class="inline"><span class="w">lock_store</span></code> and <code class="inline"><span class="w">lock_retrieve</span></code> . If one side of your application uses <code class="inline"><span class="w">store</span></code> whilst the other uses <code class="inline"><span class="w">lock_retrieve</span></code> , you will get no protection at all.</p> <p>The internal advisory locking is implemented using Perl's flock() routine. If your system does not support any form of flock(), or if you share your files across NFS, you might wish to use other forms of locking by using modules such as LockFile::Simple which lock a file using a filesystem entry, instead of locking the file descriptor.</p> <h2 id="SPEED">SPEED</h2> <p>The heart of Storable is written in C for decent speed. Extra low-level optimizations have been made when manipulating perl internals, to sacrifice encapsulation for the benefit of greater speed.</p> <h2 id="CANONICAL-REPRESENTATION">CANONICAL REPRESENTATION</h2> <p>Normally, Storable stores elements of hashes in the order they are stored internally by Perl, i.e. pseudo-randomly. If you set <code class="inline"><span class="i">$Storable::canonical</span></code> to some <code class="inline"><span class="w">TRUE</span></code> value, Storable will store hashes with the elements sorted by their key. This allows you to compare data structures by comparing their frozen representations (or even the compressed frozen representations), which can be useful for creating lookup tables for complicated queries.</p> <p>Canonical order does not imply network order; those are two orthogonal settings.</p> <h2 id="CODE-REFERENCES">CODE REFERENCES</h2> <p>Since Storable version 2.05, CODE references may be serialized with the help of <a href="b/deparse">B::Deparse</a>. To enable this feature, set <code class="inline"><span class="i">$Storable::Deparse</span></code> to a true value. To enable deserialization, <code class="inline"><span class="i">$Storable::Eval</span></code> should be set to a true value. Be aware that deserialization is done through <code class="inline"><a class="l_k" href="functions/eval">eval</a></code>, which is dangerous if the Storable file contains malicious data. You can set <code class="inline"><span class="i">$Storable::Eval</span></code> to a subroutine reference which would be used instead of <code class="inline"><a class="l_k" href="functions/eval">eval</a></code>. See below for an example using a <a href="safe">Safe</a> compartment for deserialization of CODE references.</p> <p>If <code class="inline"><span class="i">$Storable::Deparse</span></code> and/or <code class="inline"><span class="i">$Storable::Eval</span></code> are set to false values, then the value of <code class="inline"><span class="i">$Storable::forgive_me</span></code> (see below) is respected while serializing and deserializing.</p> <h2 id="FORWARD-COMPATIBILITY">FORWARD COMPATIBILITY</h2> <p>This release of Storable can be used on a newer version of Perl to serialize data which is not supported by earlier Perls. By default, Storable will attempt to do the right thing, by <code class="inline"><span class="i">croak</span><span class="s">(</span><span class="s">)</span></code> ing if it encounters data that it cannot deserialize. However, the defaults can be changed as follows:</p> <ul> <li id="utf8-data">
<b>utf8 data</b> <p>Perl 5.6 added support for Unicode characters with code points &gt; 255, and Perl 5.8 has full support for Unicode characters in hash keys. Perl internally encodes strings with these characters using utf8, and Storable serializes them as utf8. By default, if an older version of Perl encounters a utf8 value it cannot represent, it will <code class="inline"><span class="i">croak</span><span class="s">(</span><span class="s">)</span></code> . To change this behaviour so that Storable deserializes utf8 encoded values as the string of bytes (effectively dropping the <i>is_utf8</i> flag) set <code class="inline"><span class="i">$Storable::drop_utf8</span></code> to some <code class="inline"><span class="w">TRUE</span></code> value. This is a form of data loss, because with <code class="inline"><span class="i">$drop_utf8</span></code> true, it becomes impossible to tell whether the original data was the Unicode string, or a series of bytes that happen to be valid utf8.</p> </li> <li id="restricted-hashes">
<b>restricted hashes</b> <p>Perl 5.8 adds support for restricted hashes, which have keys restricted to a given set, and can have values locked to be read only. By default, when Storable encounters a restricted hash on a perl that doesn't support them, it will deserialize it as a normal hash, silently discarding any placeholder keys and leaving the keys and all values unlocked. To make Storable <code class="inline"><span class="i">croak</span><span class="s">(</span><span class="s">)</span></code> instead, set <code class="inline"><span class="i">$Storable::downgrade_restricted</span></code> to a <code class="inline"><span class="w">FALSE</span></code> value. To restore the default set it back to some <code class="inline"><span class="w">TRUE</span></code> value.</p> </li> <li id="files-from-future-versions-of-Storable">
<b>files from future versions of Storable</b> <p>Earlier versions of Storable would immediately croak if they encountered a file with a higher internal version number than the reading Storable knew about. Internal version numbers are increased each time new data types (such as restricted hashes) are added to the vocabulary of the file format. This meant that a newer Storable module had no way of writing a file readable by an older Storable, even if the writer didn't store newer data types.</p> <p>This version of Storable will defer croaking until it encounters a data type in the file that it does not recognize. This means that it will continue to read files generated by newer Storable modules which are careful in what they write out, making it easier to upgrade Storable modules in a mixed environment.</p> <p>The old behaviour of immediate croaking can be re-instated by setting <code class="inline"><span class="i">$Storable::accept_future_minor</span></code> to some <code class="inline"><span class="w">FALSE</span></code> value.</p> </li> </ul> <p>All these variables have no effect on a newer Perl which supports the relevant feature.</p> <h2 id="ERROR-REPORTING">ERROR REPORTING</h2> <p>Storable uses the "exception" paradigm, in that it does not try to workaround failures: if something bad happens, an exception is generated from the caller's perspective (see <a href="carp">Carp</a> and <code class="inline"><span class="i">croak</span><span class="s">(</span><span class="s">)</span></code> ). Use eval {} to trap those exceptions.</p> <p>When Storable croaks, it tries to report the error via the <code class="inline"><span class="i">logcroak</span><span class="s">(</span><span class="s">)</span></code> routine from the <code class="inline"><span class="w">Log::Agent</span></code> package, if it is available.</p> <p>Normal errors are reported by having store() or retrieve() return <code class="inline"><a class="l_k" href="functions/undef">undef</a></code>. Such errors are usually I/O errors (or truncated stream errors at retrieval).</p> <h2 id="WIZARDS-ONLY">WIZARDS ONLY</h2> <h3 id="Hooks">Hooks</h3> <p>Any class may define hooks that will be called during the serialization and deserialization process on objects that are instances of that class. Those hooks can redefine the way serialization is performed (and therefore, how the symmetrical deserialization should be conducted).</p> <p>Since we said earlier:</p> <pre class="verbatim" data-language="perl">dclone(.) = thaw(freeze(.))
</pre>
<p>everything we say about hooks should also hold for deep cloning. However, hooks get to know whether the operation is a mere serialization, or a cloning.</p> <p>Therefore, when serializing hooks are involved,</p> <pre class="verbatim" data-language="perl">dclone(.) &lt;&gt; thaw(freeze(.))
</pre>
<p>Well, you could keep them in sync, but there's no guarantee it will always hold on classes somebody else wrote. Besides, there is little to gain in doing so: a serializing hook could keep only one attribute of an object, which is probably not what should happen during a deep cloning of that same object.</p> <p>Here is the hooking interface:</p> <ul> <li id="STORABLE_freeze-_obj_%2c-_cloning_">
<b><code class="inline"><span class="w">STORABLE_freeze</span></code> <i>obj</i>, <i>cloning</i></b> <p>The serializing hook, called on the object during serialization. It can be inherited, or defined in the class itself, like any other method.</p> <p>Arguments: <i>obj</i> is the object to serialize, <i>cloning</i> is a flag indicating whether we're in a dclone() or a regular serialization via store() or freeze().</p> <p>Returned value: A LIST <code class="inline"><span class="s">(</span><span class="i">$serialized</span><span class="cm">,</span> <span class="i">$ref1</span><span class="cm">,</span> <span class="i">$ref2</span><span class="cm">,</span> ...<span class="s">)</span></code> where $serialized is the serialized form to be used, and the optional $ref1, $ref2, etc... are extra references that you wish to let the Storable engine serialize.</p> <p>At deserialization time, you will be given back the same LIST, but all the extra references will be pointing into the deserialized structure.</p> <p>The <b>first time</b> the hook is hit in a serialization flow, you may have it return an empty list. That will signal the Storable engine to further discard that hook for this class and to therefore revert to the default serialization of the underlying Perl data. The hook will again be normally processed in the next serialization.</p> <p>Unless you know better, serializing hook should always say:</p> <pre class="verbatim" data-language="perl">sub STORABLE_freeze {
    my ($self, $cloning) = @_;
    return if $cloning;         # Regular default serialization
    ....
}
</pre>
<p>in order to keep reasonable dclone() semantics.</p> </li> <li id="STORABLE_thaw-_obj_%2c-_cloning_%2c-_serialized_%2c-...">
<b><code class="inline"><span class="w">STORABLE_thaw</span></code> <i>obj</i>, <i>cloning</i>, <i>serialized</i>, ...</b> <p>The deserializing hook called on the object during deserialization. But wait: if we're deserializing, there's no object yet... right?</p> <p>Wrong: the Storable engine creates an empty one for you. If you know Eiffel, you can view <code class="inline"><span class="w">STORABLE_thaw</span></code> as an alternate creation routine.</p> <p>This means the hook can be inherited like any other method, and that <i>obj</i> is your blessed reference for this particular instance.</p> <p>The other arguments should look familiar if you know <code class="inline"><span class="w">STORABLE_freeze</span></code> : <i>cloning</i> is true when we're part of a deep clone operation, <i>serialized</i> is the serialized string you returned to the engine in <code class="inline"><span class="w">STORABLE_freeze</span></code> , and there may be an optional list of references, in the same order you gave them at serialization time, pointing to the deserialized objects (which have been processed courtesy of the Storable engine).</p> <p>When the Storable engine does not find any <code class="inline"><span class="w">STORABLE_thaw</span></code> hook routine, it tries to load the class by requiring the package dynamically (using the blessed package name), and then re-attempts the lookup. If at that time the hook cannot be located, the engine croaks. Note that this mechanism will fail if you define several classes in the same file, but <a href="perlmod">perlmod</a> warned you.</p> <p>It is up to you to use this information to populate <i>obj</i> the way you want.</p> <p>Returned value: none.</p> </li> <li id="STORABLE_attach-_class_%2c-_cloning_%2c-_serialized_">
<b><code class="inline"><span class="w">STORABLE_attach</span></code> <i>class</i>, <i>cloning</i>, <i>serialized</i></b> <p>While <code class="inline"><span class="w">STORABLE_freeze</span></code> and <code class="inline"><span class="w">STORABLE_thaw</span></code> are useful for classes where each instance is independent, this mechanism has difficulty (or is incompatible) with objects that exist as common process-level or system-level resources, such as singleton objects, database pools, caches or memoized objects.</p> <p>The alternative <code class="inline"><span class="w">STORABLE_attach</span></code> method provides a solution for these shared objects. Instead of <code class="inline"><span class="w">STORABLE_freeze</span></code> --&gt; <code class="inline"><span class="w">STORABLE_thaw</span></code> , you implement <code class="inline"><span class="w">STORABLE_freeze</span></code> --&gt; <code class="inline"><span class="w">STORABLE_attach</span></code> instead.</p> <p>Arguments: <i>class</i> is the class we are attaching to, <i>cloning</i> is a flag indicating whether we're in a dclone() or a regular de-serialization via thaw(), and <i>serialized</i> is the stored string for the resource object.</p> <p>Because these resource objects are considered to be owned by the entire process/system, and not the "property" of whatever is being serialized, no references underneath the object should be included in the serialized string. Thus, in any class that implements <code class="inline"><span class="w">STORABLE_attach</span></code> , the <code class="inline"><span class="w">STORABLE_freeze</span></code> method cannot return any references, and <code class="inline"><span class="w">Storable</span></code> will throw an error if <code class="inline"><span class="w">STORABLE_freeze</span></code> tries to return references.</p> <p>All information required to "attach" back to the shared resource object <b>must</b> be contained <b>only</b> in the <code class="inline"><span class="w">STORABLE_freeze</span></code> return string. Otherwise, <code class="inline"><span class="w">STORABLE_freeze</span></code> behaves as normal for <code class="inline"><span class="w">STORABLE_attach</span></code> classes.</p> <p>Because <code class="inline"><span class="w">STORABLE_attach</span></code> is passed the class (rather than an object), it also returns the object directly, rather than modifying the passed object.</p> <p>Returned value: object of type <code class="inline"><span class="w">class</span></code> </p> </li> </ul> <h3 id="Predicates">Predicates</h3> <p>Predicates are not exportable. They must be called by explicitly prefixing them with the Storable package name.</p> <ul> <li id="Storable%3a%3alast_op_in_netorder">
<b><code class="inline"><span class="w">Storable::last_op_in_netorder</span></code> </b> <p>The <code class="inline"><span class="i">Storable::last_op_in_netorder</span><span class="s">(</span><span class="s">)</span></code> predicate will tell you whether network order was used in the last store or retrieve operation. If you don't know how to use this, just forget about it.</p> </li> <li id="Storable%3a%3ais_storing">
<b><code class="inline"><span class="w">Storable::is_storing</span></code> </b> <p>Returns true if within a store operation (via STORABLE_freeze hook).</p> </li> <li id="Storable%3a%3ais_retrieving">
<b><code class="inline"><span class="w">Storable::is_retrieving</span></code> </b> <p>Returns true if within a retrieve operation (via STORABLE_thaw hook).</p> </li> </ul> <h3 id="Recursion">Recursion</h3> <p>With hooks comes the ability to recurse back to the Storable engine. Indeed, hooks are regular Perl code, and Storable is convenient when it comes to serializing and deserializing things, so why not use it to handle the serialization string?</p> <p>There are a few things you need to know, however:</p> <ul> <li> <p>You can create endless loops if the things you serialize via freeze() (for instance) point back to the object we're trying to serialize in the hook.</p> </li> <li> <p>Shared references among objects will not stay shared: if we're serializing the list of object [A, C] where both object A and C refer to the SAME object B, and if there is a serializing hook in A that says freeze(B), then when deserializing, we'll get [A', C'] where A' refers to B', but C' refers to D, a deep clone of B'. The topology was not preserved.</p> </li> </ul> <p>That's why <code class="inline"><span class="w">STORABLE_freeze</span></code> lets you provide a list of references to serialize. The engine guarantees that those will be serialized in the same context as the other objects, and therefore that shared objects will stay shared.</p> <p>In the above [A, C] example, the <code class="inline"><span class="w">STORABLE_freeze</span></code> hook could return:</p> <pre class="verbatim" data-language="perl">("something", $self-&gt;{B})
</pre>
<p>and the B part would be serialized by the engine. In <code class="inline"><span class="w">STORABLE_thaw</span></code> , you would get back the reference to the B' object, deserialized for you.</p> <p>Therefore, recursion should normally be avoided, but is nonetheless supported.</p> <h3 id="Deep-Cloning">Deep Cloning</h3> <p>There is a Clone module available on CPAN which implements deep cloning natively, i.e. without freezing to memory and thawing the result. It is aimed to replace Storable's dclone() some day. However, it does not currently support Storable hooks to redefine the way deep cloning is performed.</p> <h2 id="Storable-magic">Storable magic</h2> <p>Yes, there's a lot of that :-) But more precisely, in UNIX systems there's a utility called <code class="inline"><span class="w">file</span></code> , which recognizes data files based on their contents (usually their first few bytes). For this to work, a certain file called <i>magic</i> needs to taught about the <i>signature</i> of the data. Where that configuration file lives depends on the UNIX flavour; often it's something like <i>/usr/share/misc/magic</i> or <i>/etc/magic</i>. Your system administrator needs to do the updating of the <i>magic</i> file. The necessary signature information is output to STDOUT by invoking Storable::show_file_magic(). Note that the GNU implementation of the <code class="inline"><span class="w">file</span></code> utility, version 3.38 or later, is expected to contain support for recognising Storable files out-of-the-box, in addition to other kinds of Perl files.</p> <p>You can also use the following functions to extract the file header information from Storable images:</p> <ul> <li id="%24info-%3d-Storable%3a%3afile_magic(-%24filename-)">
<b>$info = Storable::file_magic( $filename )</b> <p>If the given file is a Storable image return a hash describing it. If the file is readable, but not a Storable image return <code class="inline"><a class="l_k" href="functions/undef">undef</a></code>. If the file does not exist or is unreadable then croak.</p> <p>The hash returned has the following elements:</p> <ul> <li id="version">
<b><code class="inline"><span class="w">version</span></code> </b> <p>This returns the file format version. It is a string like "2.7".</p> <p>Note that this version number is not the same as the version number of the Storable module itself. For instance Storable v0.7 create files in format v2.0 and Storable v2.15 create files in format v2.7. The file format version number only increment when additional features that would confuse older versions of the module are added.</p> <p>Files older than v2.0 will have the one of the version numbers "-1", "0" or "1". No minor number was used at that time.</p> </li> <li id="version_nv">
<b><code class="inline"><span class="w">version_nv</span></code> </b> <p>This returns the file format version as number. It is a string like "2.007". This value is suitable for numeric comparisons.</p> <p>The constant function <code class="inline"><span class="w">Storable::BIN_VERSION_NV</span></code> returns a comparable number that represents the highest file version number that this version of Storable fully supports (but see discussion of <code class="inline"><span class="i">$Storable::accept_future_minor</span></code> above). The constant <code class="inline"><span class="w">Storable::BIN_WRITE_VERSION_NV</span></code> function returns what file version is written and might be less than <code class="inline"><span class="w">Storable::BIN_VERSION_NV</span></code> in some configurations.</p> </li> <li id="major%2c-minor">
<b><code class="inline"><span class="w">major</span></code> , <code class="inline"><span class="w">minor</span></code> </b> <p>This also returns the file format version. If the version is "2.7" then major would be 2 and minor would be 7. The minor element is missing for when major is less than 2.</p> </li> <li id="hdrsize">
<b><code class="inline"><span class="w">hdrsize</span></code> </b> <p>The is the number of bytes that the Storable header occupies.</p> </li> <li id="netorder">
<b><code class="inline"><span class="w">netorder</span></code> </b> <p>This is TRUE if the image store data in network order. This means that it was created with nstore() or similar.</p> </li> <li id="byteorder">
<b><code class="inline"><span class="w">byteorder</span></code> </b> <p>This is only present when <code class="inline"><span class="w">netorder</span></code> is FALSE. It is the $Config{byteorder} string of the perl that created this image. It is a string like "1234" (32 bit little endian) or "87654321" (64 bit big endian). This must match the current perl for the image to be readable by Storable.</p> </li> <li id="intsize%2c-longsize%2c-ptrsize%2c-nvsize">
<b><code class="inline"><span class="w">intsize</span></code> , <code class="inline"><span class="w">longsize</span></code> , <code class="inline"><span class="w">ptrsize</span></code> , <code class="inline"><span class="w">nvsize</span></code> </b> <p>These are only present when <code class="inline"><span class="w">netorder</span></code> is FALSE. These are the sizes of various C datatypes of the perl that created this image. These must match the current perl for the image to be readable by Storable.</p> <p>The <code class="inline"><span class="w">nvsize</span></code> element is only present for file format v2.2 and higher.</p> </li> <li id="file">
<b><code class="inline"><span class="w">file</span></code> </b> <p>The name of the file.</p> </li> </ul> </li> <li id="%24info-%3d-Storable%3a%3aread_magic(-%24buffer-)">
<b>$info = Storable::read_magic( $buffer )</b> </li> <li id="%24info-%3d-Storable%3a%3aread_magic(-%24buffer%2c-%24must_be_file-)">
<b>$info = Storable::read_magic( $buffer, $must_be_file )</b> <p>The $buffer should be a Storable image or the first few bytes of it. If $buffer starts with a Storable header, then a hash describing the image is returned, otherwise <code class="inline"><a class="l_k" href="functions/undef">undef</a></code> is returned.</p> <p>The hash has the same structure as the one returned by Storable::file_magic(). The <code class="inline"><span class="w">file</span></code> element is true if the image is a file image.</p> <p>If the $must_be_file argument is provided and is TRUE, then return <code class="inline"><a class="l_k" href="functions/undef">undef</a></code> unless the image looks like it belongs to a file dump.</p> <p>The maximum size of a Storable header is currently 21 bytes. If the provided $buffer is only the first part of a Storable image it should at least be this long to ensure that read_magic() will recognize it as such.</p> </li> </ul> <h2 id="EXAMPLES">EXAMPLES</h2> <p>Here are some code samples showing a possible usage of Storable:</p> <pre class="verbatim" data-language="perl">use Storable qw(store retrieve freeze thaw dclone);

%color = ('Blue' =&gt; 0.1, 'Red' =&gt; 0.8, 'Black' =&gt; 0, 'White' =&gt; 1);

store(\%color, 'mycolors') or die "Can't store %a in mycolors!\n";

$colref = retrieve('mycolors');
die "Unable to retrieve from mycolors!\n" unless defined $colref;
printf "Blue is still %lf\n", $colref-&gt;{'Blue'};

$colref2 = dclone(\%color);

$str = freeze(\%color);
printf "Serialization of %%color is %d bytes long.\n", length($str);
$colref3 = thaw($str);
</pre>
<p>which prints (on my machine):</p> <pre class="verbatim" data-language="perl">Blue is still 0.100000
Serialization of %color is 102 bytes long.
</pre>
<p>Serialization of CODE references and deserialization in a safe compartment:</p> <pre class="verbatim" data-language="perl">use Storable qw(freeze thaw);
use Safe;
use strict;
my $safe = new Safe;
        # because of opcodes used in "use strict":
$safe-&gt;permit(qw(:default require));
local $Storable::Deparse = 1;
local $Storable::Eval = sub { $safe-&gt;reval($_[0]) };
my $serialized = freeze(sub { 42 });
my $code = thaw($serialized);
$code-&gt;() == 42;
</pre>
<h2 id="SECURITY-WARNING">SECURITY WARNING</h2> <p><b>Do not accept Storable documents from untrusted sources!</b></p> <p>Some features of Storable can lead to security vulnerabilities if you accept Storable documents from untrusted sources. Most obviously, the optional (off by default) CODE reference serialization feature allows transfer of code to the deserializing process. Furthermore, any serialized object will cause Storable to helpfully load the module corresponding to the class of the object in the deserializing module. For manipulated module names, this can load almost arbitrary code. Finally, the deserialized object's destructors will be invoked when the objects get destroyed in the deserializing process. Maliciously crafted Storable documents may put such objects in the value of a hash key that is overridden by another key/value pair in the same hash, thus causing immediate destructor execution.</p> <p>In a future version of Storable, we intend to provide options to disable loading modules for classes and to disable deserializing objects altogether. <i>Nonetheless, Storable deserializing documents from untrusted sources is expected to have other, yet undiscovered, security concerns such as allowing an attacker to cause the deserializer to crash hard.</i></p> <p><b>Therefore, let me repeat: Do not accept Storable documents from untrusted sources!</b></p> <p>If your application requires accepting data from untrusted sources, you are best off with a less powerful and more-likely safe serialization format and implementation. If your data is sufficiently simple, JSON is a good choice and offers maximum interoperability.</p> <h2 id="WARNING">WARNING</h2> <p>If you're using references as keys within your hash tables, you're bound to be disappointed when retrieving your data. Indeed, Perl stringifies references used as hash table keys. If you later wish to access the items via another reference stringification (i.e. using the same reference that was used for the key originally to record the value into the hash table), it will work because both references stringify to the same string.</p> <p>It won't work across a sequence of <code class="inline"><span class="w">store</span></code> and <code class="inline"><span class="w">retrieve</span></code> operations, however, because the addresses in the retrieved objects, which are part of the stringified references, will probably differ from the original addresses. The topology of your structure is preserved, but not hidden semantics like those.</p> <p>On platforms where it matters, be sure to call <code class="inline"><a class="l_k" href="functions/binmode">binmode()</a></code> on the descriptors that you pass to Storable functions.</p> <p>Storing data canonically that contains large hashes can be significantly slower than storing the same data normally, as temporary arrays to hold the keys for each hash have to be allocated, populated, sorted and freed. Some tests have shown a halving of the speed of storing -- the exact penalty will depend on the complexity of your data. There is no slowdown on retrieval.</p> <h2 id="BUGS">BUGS</h2> <p>You can't store GLOB, FORMLINE, REGEXP, etc.... If you can define semantics for those operations, feel free to enhance Storable so that it can deal with them.</p> <p>The store functions will <code class="inline"><span class="w">croak</span></code> if they run into such references unless you set <code class="inline"><span class="i">$Storable::forgive_me</span></code> to some <code class="inline"><span class="w">TRUE</span></code> value. In that case, the fatal message is converted to a warning and some meaningless string is stored instead.</p> <p>Setting <code class="inline"><span class="i">$Storable::canonical</span></code> may not yield frozen strings that compare equal due to possible stringification of numbers. When the string version of a scalar exists, it is the form stored; therefore, if you happen to use your numbers as strings between two freezing operations on the same data structures, you will get different results.</p> <p>When storing doubles in network order, their value is stored as text. However, you should also not expect non-numeric floating-point values such as infinity and "not a number" to pass successfully through a nstore()/retrieve() pair.</p> <p>As Storable neither knows nor cares about character sets (although it does know that characters may be more than eight bits wide), any difference in the interpretation of character codes between a host and a target system is your problem. In particular, if host and target use different code points to represent the characters used in the text representation of floating-point numbers, you will not be able be able to exchange floating-point data, even with nstore().</p> <p><code class="inline"><span class="w">Storable::drop_utf8</span></code> is a blunt tool. There is no facility either to return <b>all</b> strings as utf8 sequences, or to attempt to convert utf8 data back to 8 bit and <code class="inline"><span class="i">croak</span><span class="s">(</span><span class="s">)</span></code> if the conversion fails.</p> <p>Prior to Storable 2.01, no distinction was made between signed and unsigned integers on storing. By default Storable prefers to store a scalars string representation (if it has one) so this would only cause problems when storing large unsigned integers that had never been converted to string or floating point. In other words values that had been generated by integer operations such as logic ops and then not used in any string or arithmetic context before storing.</p> <h3 id="64-bit-data-in-perl-5.6.0-and-5.6.1">64 bit data in perl 5.6.0 and 5.6.1</h3> <p>This section only applies to you if you have existing data written out by Storable 2.02 or earlier on perl 5.6.0 or 5.6.1 on Unix or Linux which has been configured with 64 bit integer support (not the default) If you got a precompiled perl, rather than running Configure to build your own perl from source, then it almost certainly does not affect you, and you can stop reading now (unless you're curious). If you're using perl on Windows it does not affect you.</p> <p>Storable writes a file header which contains the sizes of various C language types for the C compiler that built Storable (when not writing in network order), and will refuse to load files written by a Storable not on the same (or compatible) architecture. This check and a check on machine byteorder is needed because the size of various fields in the file are given by the sizes of the C language types, and so files written on different architectures are incompatible. This is done for increased speed. (When writing in network order, all fields are written out as standard lengths, which allows full interworking, but takes longer to read and write)</p> <p>Perl 5.6.x introduced the ability to optional configure the perl interpreter to use C's <code class="inline"><span class="w">long</span> <span class="w">long</span></code> type to allow scalars to store 64 bit integers on 32 bit systems. However, due to the way the Perl configuration system generated the C configuration files on non-Windows platforms, and the way Storable generates its header, nothing in the Storable file header reflected whether the perl writing was using 32 or 64 bit integers, despite the fact that Storable was storing some data differently in the file. Hence Storable running on perl with 64 bit integers will read the header from a file written by a 32 bit perl, not realise that the data is actually in a subtly incompatible format, and then go horribly wrong (possibly crashing) if it encountered a stored integer. This is a design failure.</p> <p>Storable has now been changed to write out and read in a file header with information about the size of integers. It's impossible to detect whether an old file being read in was written with 32 or 64 bit integers (they have the same header) so it's impossible to automatically switch to a correct backwards compatibility mode. Hence this Storable defaults to the new, correct behaviour.</p> <p>What this means is that if you have data written by Storable 1.x running on perl 5.6.0 or 5.6.1 configured with 64 bit integers on Unix or Linux then by default this Storable will refuse to read it, giving the error <i>Byte order is not compatible</i>. If you have such data then you should set <code class="inline"><span class="i">$Storable::interwork_56_64bit</span></code> to a true value to make this Storable read and write files with the old header. You should also migrate your data, or any older perl you are communicating with, to this current version of Storable.</p> <p>If you don't have data written with specific configuration of perl described above, then you do not and should not do anything. Don't set the flag - not only will Storable on an identically configured perl refuse to load them, but Storable a differently configured perl will load them believing them to be correct for it, and then may well fail or crash part way through reading them.</p> <h2 id="CREDITS">CREDITS</h2> <p>Thank you to (in chronological order):</p> <pre class="verbatim" data-language="perl">Jarkko Hietaniemi &lt;jhi@iki.fi&gt;
Ulrich Pfeifer &lt;pfeifer@charly.informatik.uni-dortmund.de&gt;
Benjamin A. Holzman &lt;bholzman@earthlink.net&gt;
Andrew Ford &lt;A.Ford@ford-mason.co.uk&gt;
Gisle Aas &lt;gisle@aas.no&gt;
Jeff Gresham &lt;gresham_jeffrey@jpmorgan.com&gt;
Murray Nesbitt &lt;murray@activestate.com&gt;
Marc Lehmann &lt;pcg@opengroup.org&gt;
Justin Banks &lt;justinb@wamnet.com&gt;
Jarkko Hietaniemi &lt;jhi@iki.fi&gt; (AGAIN, as perl 5.7.0 Pumpkin!)
Salvador Ortiz Garcia &lt;sog@msg.com.mx&gt;
Dominic Dunlop &lt;domo@computer.org&gt;
Erik Haugan &lt;erik@solbors.no&gt;
Benjamin A. Holzman &lt;ben.holzman@grantstreet.com&gt;
Reini Urban &lt;rurban@cpanel.net&gt;
</pre>
<p>for their bug reports, suggestions and contributions.</p> <p>Benjamin Holzman contributed the tied variable support, Andrew Ford contributed the canonical order for hashes, and Gisle Aas fixed a few misunderstandings of mine regarding the perl internals, and optimized the emission of "tags" in the output streams by simply counting the objects instead of tagging them (leading to a binary incompatibility for the Storable image starting at version 0.6--older images are, of course, still properly understood). Murray Nesbitt made Storable thread-safe. Marc Lehmann added overloading and references to tied items support. Benjamin Holzman added a performance improvement for overloaded classes; thanks to Grant Street Group for footing the bill.</p> <h2 id="AUTHOR">AUTHOR</h2> <p>Storable was written by Raphael Manfredi <i>&lt;Raphael_Manfredi@pobox.com&gt;</i> Maintenance is now done by the perl5-porters <i>&lt;perl5-porters@perl.org&gt;</i></p> <p>Please e-mail us with problems, bug fixes, comments and complaints, although if you have compliments you should send them to Raphael. Please don't e-mail Raphael with problems, as he no longer works on Storable, and your message will be delayed while he forwards it to us.</p> <h2 id="SEE-ALSO">SEE ALSO</h2> <p><a href="http://search.cpan.org/perldoc/Clone">Clone</a>.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 1993–2016 Larry Wall and others<br>Licensed under the GNU General Public License version 1 or later, or the Artistic License.<br>The Perl logo is a trademark of the Perl Foundation.<br>
    <a href="https://perldoc.perl.org/5.26.0/Storable.html" class="_attribution-link">https://perldoc.perl.org/5.26.0/Storable.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
