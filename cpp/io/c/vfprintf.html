
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Std&#58;&#58;vfprintf - C++ - W3cubDocs</title>
  
  <meta name="description" content=" Loads the data from the locations, defined by vlist, converts them to character string equivalents and writes the results to a variety of sinks. ">
  <meta name="keywords" content="std, vprintf, vfprintf, vsprintf, vsnprintf, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/io/c/vfprintf.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-9c7b0d969c0ce639a6c01c2badcdd81667c7c66206aa3d0fccc5cb0585fb1b912dab72ea882101d18010680927514b4b77b107282db8f756fbf63301fe9c88b0.css">
  <script type="text/javascript" src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js"></script>
  <script src="/json/cpp.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _cppref">
				
				
<h1 id="firstHeading" class="firstHeading">std::vprintf, std::vfprintf, std::vsprintf, std::vsnprintf</h1>            <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th> Defined in header <code><a href="../../header/cstdio" title="cpp/header/cstdio">&lt;cstdio&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">int vprintf( const char* format, va_list vlist );</pre>
</td> <td> (1) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">int vfprintf( std::FILE* stream, const char* format, va_list vlist );</pre>
</td> <td> (2) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">int vsprintf( char* buffer, const char* format, va_list vlist );</pre>
</td> <td> (3) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">int vsnprintf( char* buffer, std::size_t buf_size, const char* format, va_list vlist );</pre>
</td> <td> (4) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr>  </table> <p>Loads the data from the locations, defined by <code>vlist</code>, converts them to character string equivalents and writes the results to a variety of sinks.</p>
<div class="t-li1">
<span class="t-li">1)</span> Writes the results to <code><a href="std_streams" title="cpp/io/c/std streams">stdout</a></code>.</div> <div class="t-li1">
<span class="t-li">2)</span> Writes the results to a file stream <code>stream</code>.</div> <div class="t-li1">
<span class="t-li">3)</span> Writes the results to a character string <code>buffer</code>.</div> <div class="t-li1">
<span class="t-li">4)</span> Writes the results to a character string <code>buffer</code>. At most <code>buf_size-1</code> characters are written. The resulting character string will be terminated with a null character, unless <code>buf_size</code> is zero. If <code>buf_size</code> is zero, nothing is written and <code>buffer</code> may be a null pointer, however the return value (number of bytes that would be written not including the null terminator) is still calculated and returned.</div>  <h3 id="Parameters"> Parameters</h3> <table class="t-par-begin"> <tr class="t-par"> <td> stream </td> <td> - </td> <td> output file stream to write to </td>
</tr> <tr class="t-par"> <td> buffer </td> <td> - </td> <td> pointer to a character string to write to </td>
</tr> <tr class="t-par"> <td> buf_size </td> <td> - </td> <td> maximum number of characters to write </td>
</tr> <tr class="t-par"> <td> format </td> <td> - </td> <td> pointer to a null-terminated character string specifying how to interpret the data </td>
</tr> <tr class="t-par"> <td> vlist </td> <td> - </td> <td> variable argument list containing the data to print. </td>
</tr>
</table> <p><br> The <b>format</b> string consists of ordinary byte characters (except <code>%</code>), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:</p>
<ul>
<li> introductory <code>%</code> character </li>
<li> <span class="t-mark">(optional)</span> one or more flags that modify the behavior of the conversion: </li>
<ul>
<li> <code>-</code>: the result of the conversion is left-justified within the field (by default it is right-justified) </li>
<li> <code>+</code>: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative) </li>
<li> <i>space</i>: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if <code>+</code> flag is present. </li>
<li> <code>#</code> : <i>alternative form</i> of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined. </li>
<li> <code>0</code> : for integer and floating point number conversions, leading zeros are used to pad the field instead of <i>space</i> characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if <code>-</code> flag is present. </li>
</ul>
<li> <span class="t-mark">(optional)</span> integer value or <code>*</code> that specifies minimum field width. The result is padded with <i>space</i> characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when <code>*</code> is used, the width is specified by an additional argument of type <code>int</code>, which appears before the argument to be converted and the argument supplying precision if one is supplied. If the value of the argument is negative, it results with the <code>-</code> flag specified and positive field width. (Note: This is the minimum width: The value is never truncated.) </li>
<ul>
<li> <span class="t-mark">(optional)</span> <code>.</code> followed by integer number or <code>*</code>, or neither that specifies <i>precision</i> of the conversion. In the case when <code>*</code> is used, the <i>precision</i> is specified by an additional argument of type <code>int</code>, which appears before the argument to be converted, but after the argument supplying minimum field width if one is supplied. If the value of this argument is negative, it is ignored. If neither a number nor <code>*</code> is used, the precision is taken as zero. See the table below for exact effects of <i>precision</i>. </li>
<li> <span class="t-mark">(optional)</span> <i>length modifier</i> that specifies the size of the argument (in combination with the conversion format specifier, it specifies the type of the corresponding argument) </li>
<li> conversion format specifier </li>
</ul>
</ul>        <p>The following format specifiers are available:</p>
<table class="wikitable"> <tr> <th rowspan="1"> Conversion<br>Specifier </th> <th rowspan="1"> Explanation </th> <th colspan="9"> Expected<br>Argument Type </th>
</tr> <tr> <th colspan="2"> <b>Length<br>Modifier</b><b>â†’</b> </th> <th> <code>hh</code> <p><span class="t-mark-rev t-since-cxx11">(C++11)</span>.</p>
</th> <th> <code>h</code> </th> <th> (none) </th> <th> <code>l</code> </th> <th> <code>ll</code> <p><span class="t-mark-rev t-since-cxx11">(C++11)</span>.</p>
</th> <th> <code>j</code> <p><span class="t-mark-rev t-since-cxx11">(C++11)</span>.</p>
</th> <th> <code>z</code> <p><span class="t-mark-rev t-since-cxx11">(C++11)</span>.</p>
</th> <th> <code>t</code> <p><span class="t-mark-rev t-since-cxx11">(C++11)</span>.</p>
</th> <th> <code>L</code> </th>
</tr> <tr> <th> <code>%</code> </th> <td> writes literal <code>%</code>. The full conversion specification must be <code>%%</code>. </td> <td class="table-na"> <small>N/A</small> </td> <td class="table-na"> <small>N/A</small> </td> <td class="table-na"> <small>N/A</small> </td> <td class="table-na"> <small>N/A</small> </td> <td class="table-na"> <small>N/A</small> </td> <td class="table-na"> <small>N/A</small> </td> <td class="table-na"> <small>N/A</small> </td> <td class="table-na"> <small>N/A</small> </td> <td class="table-na"> <small>N/A</small> </td>
</tr> <tr> <th> <code>c</code> </th> <td>  writes a <b>single character</b>.  <p>The argument is first converted to <code>unsigned char</code>. If the <b>l</b> modifier is used, the argument is first converted to a character string as if by <b>%ls</b> with a <code>wchar_t[2]</code> argument.</p>
</td> <td class="table-na"> <small>N/A</small> </td> <td class="table-na"> <small>N/A</small> </td> <td> <div><code>int</code></div> </td> <td> <div><code>wint_t</code></div> </td> <td class="table-na"> <small>N/A</small> </td> <td class="table-na"> <small>N/A</small> </td> <td class="table-na"> <small>N/A</small> </td> <td class="table-na"> <small>N/A</small> </td> <td class="table-na"> <small>N/A</small> </td>
</tr> <tr> <th> <code>s</code> </th> <td>  writes a <b>character string</b>  <p>The argument must be a pointer to the initial element of an array of characters. <i>Precision</i> specifies the maximum number of bytes to be written. If <i>Precision</i> is not specified, writes every byte up to and not including the first null terminator. If the <b>l</b> specifier is used, the argument must be a pointer to the initial element of an array of <code>wchar_t</code>, which is converted to char array as if by a call to <code>wcrtomb</code> with zero-initialized conversion state.</p>
</td> <td class="table-na"> <small>N/A</small> </td> <td class="table-na"> <small>N/A</small> </td> <td> <div><code>char*</code></div> </td> <td> <div><code>wchar_t*</code></div> </td> <td class="table-na"> <small>N/A</small> </td> <td class="table-na"> <small>N/A</small> </td> <td class="table-na"> <small>N/A</small> </td> <td class="table-na"> <small>N/A</small> </td> <td class="table-na"> <small>N/A</small> </td>
</tr> <tr> <th> <code>d</code><br> <code>i</code> </th> <td> converts a <b>signed integer</b> into decimal representation <i>[-]dddd</i>.  <p><i>Precision</i> specifies the minimum number of digits to appear. The default precision is <code>1</code>.<br><br> If both the converted value and the precision are <code>â€‹0â€‹</code> the conversion results in no characters.<br><br></p>
</td> <td rowspan="1"> <div><code>signed char</code></div> </td> <td rowspan="1"> <div><code>short</code></div> </td> <td rowspan="1"> <div><code>int</code></div> </td> <td rowspan="1"> <div><code>long</code></div> </td> <td rowspan="1"> <div><code>long long</code></div> </td> <td rowspan="1"> <div><code>intmax_t</code></div> </td> <td rowspan="1"> <div>signed <code>size_t</code>
</div> </td> <td rowspan="1"> <div><code>ptrdiff_t</code></div> </td> <td class="table-na"> <small>N/A</small> </td>
</tr> <tr> <th> <code>o</code> </th> <td> converts an <b>unsigned integer</b> into octal representation <i>oooo</i>.  <p><i>Precision</i> specifies the minimum number of digits to appear. The default precision is <code>1</code>. If both the converted value and the precision are <code>â€‹0â€‹</code> the conversion results in no characters. In the <i>alternative implementation</i> precision is increased if necessary, to write one leading zero. In that case if both the converted value and the precision are <code>â€‹0â€‹</code>, single <code>â€‹0â€‹</code> is written.</p>
</td> <td rowspan="3"> <div><code>unsigned char</code></div> </td> <td rowspan="3"> <div><code>unsigned short</code></div> </td> <td rowspan="3"> <div><code>unsigned int</code></div> </td> <td rowspan="3"> <div><code>unsigned long</code></div> </td> <td rowspan="3"> <div><code>unsigned long long</code></div> </td> <td rowspan="3"> <div><code>uintmax_t</code></div> </td> <td rowspan="3"> <div><code>size_t</code></div> </td> <td rowspan="3"> <div>unsigned version of <code>ptrdiff_t</code>
</div> </td> <td class="table-na"> <small>N/A</small> </td>
</tr> <tr> <th> <code>x</code><br> <code>X</code> </th> <td> converts an <b>unsigned integer</b> into hexadecimal representation <i>hhhh</i>.  <p>For the <code>x</code> conversion letters <code>abcdef</code> are used.<br> For the <code>X</code> conversion letters <code>ABCDEF</code> are used.<br> <i>Precision</i> specifies the minimum number of digits to appear. The default precision is <code>1</code>. If both the converted value and the precision are <code>â€‹0â€‹</code> the conversion results in no characters. In the <i>alternative implementation</i> <code>0x</code> or <code>0X</code> is prefixed to results if the converted value is nonzero.</p>
</td> <td class="table-na"> <small>N/A</small> </td>
</tr> <tr> <th> <code>u</code> </th> <td> converts an <b>unsigned integer</b> into decimal representation <i>dddd</i>.  <p><i>Precision</i> specifies the minimum number of digits to appear. The default precision is <code>1</code>. If both the converted value and the precision are <code>â€‹0â€‹</code> the conversion results in no characters.</p>
</td> <td class="table-na"> <small>N/A</small> </td>
</tr> <tr> <th> <code>f</code><br> <code>F</code> </th> <td> converts <b>floating-point number</b> to the decimal notation in the style <i>[-]ddd.ddd</i>.  <p><i>Precision</i> specifies the exact number of digits to appear after the decimal point character. The default precision is <code>6</code>. In the <i>alternative implementation</i> decimal point character is written even if no digits follow it. For infinity and not-a-number conversion style see notes.</p>
</td> <td class="table-na"> <small>N/A</small> </td> <td class="table-na"> <small>N/A</small> </td> <td rowspan="4"> <div><code>double</code></div> </td> <td rowspan="4"> <div>
<code>double</code> <span class="t-mark-rev t-since-cxx11">(C++11)</span>
</div> </td> <td class="table-na"> <small>N/A</small> </td> <td class="table-na"> <small>N/A</small> </td> <td class="table-na"> <small>N/A</small> </td> <td class="table-na"> <small>N/A</small> </td> <td rowspan="4"> <div><code>long double</code></div> </td>
</tr> <tr> <th> <code>e</code><br> <code>E</code> </th> <td> converts <b>floating-point number</b> to the decimal exponent notation.  <p>For the <code>e</code> conversion style <i>[-]d.ddd</i><code>e</code><i>Â±dd</i> is used.<br> For the <code>E</code> conversion style <i>[-]d.ddd</i><code>E</code><i>Â±dd</i> is used.<br> The exponent contains at least two digits, more digits are used only if necessary. If the value is <code>â€‹0â€‹</code>, the exponent is also <code>â€‹0â€‹</code>. <i>Precision</i> specifies the exact number of digits to appear after the decimal point character. The default precision is <code>6</code>. In the <i>alternative implementation</i> decimal point character is written even if no digits follow it. For infinity and not-a-number conversion style see notes.</p>
</td> <td class="table-na"> <small>N/A</small> </td> <td class="table-na"> <small>N/A</small> </td> <td class="table-na"> <small>N/A</small> </td> <td class="table-na"> <small>N/A</small> </td> <td class="table-na"> <small>N/A</small> </td> <td class="table-na"> <small>N/A</small> </td>
</tr> <tr> <th> <code>a</code><br> <code>A</code> <p><span class="t-mark-rev t-since-cxx11">(C++11)</span>.</p>
</th> <td> converts <b>floating-point number</b> to the hexadecimal exponent notation.  <p>For the <code>a</code> conversion style <i>[-]</i><code>0x</code><i>h.hhh</i><code>p</code><i>Â±d</i> is used.<br> For the <code>A</code> conversion style <i>[-]</i><code>0X</code><i>h.hhh</i><code>P</code><i>Â±d</i> is used.<br> The first hexadecimal digit is not <code>0</code> if the argument is a normalized floating point value. If the value is <code>â€‹0â€‹</code>, the exponent is also <code>â€‹0â€‹</code>. <i>Precision</i> specifies the exact number of digits to appear after the hexadecimal point character. The default precision is sufficient for exact representation of the value. In the <i>alternative implementation</i> decimal point character is written even if no digits follow it. For infinity and not-a-number conversion style see notes.</p>
</td> <td class="table-na"> <small>N/A</small> </td> <td class="table-na"> <small>N/A</small> </td> <td class="table-na"> <small>N/A</small> </td> <td class="table-na"> <small>N/A</small> </td> <td class="table-na"> <small>N/A</small> </td> <td class="table-na"> <small>N/A</small> </td>
</tr> <tr> <th> <code>g</code><br> <code>G</code> </th> <td> converts <b>floating-point number</b> to decimal or decimal exponent notation depending on the value and the <i>precision</i>.  <p>For the <code>g</code> conversion style conversion with style <code>e</code> or <code>f</code> will be performed.<br> For the <code>G</code> conversion style conversion with style <code>E</code> or <code>F</code> will be performed.<br> Let <code>P</code> equal the precision if nonzero, <code>6</code> if the precision is not specified, or <code>1</code> if the precision is <code>â€‹0â€‹</code>. Then, if a conversion with style <code>E</code> would have an exponent of <code>X</code>:</p>
<ul>
<li> if <i>P &gt; X â‰¥ âˆ’4</i>, the conversion is with style <code>f</code> or <code>F</code> and precision <i>P âˆ’ 1 âˆ’ X</i>. </li>
<li> otherwise, the conversion is with style <code>e</code> or <code>E</code> and precision <i>P âˆ’ 1</i>. </li>
</ul> <p>Unless <i>alternative representation</i> is requested the trailing zeros are removed, also the decimal point character is removed if no fractional part is left. For infinity and not-a-number conversion style see notes.</p>
</td> <td class="table-na"> <small>N/A</small> </td> <td class="table-na"> <small>N/A</small> </td> <td class="table-na"> <small>N/A</small> </td> <td class="table-na"> <small>N/A</small> </td> <td class="table-na"> <small>N/A</small> </td> <td class="table-na"> <small>N/A</small> </td>
</tr> <tr> <th> <code>n</code> </th> <td> returns the <b>number of characters written</b> so far by this call to the function.  <p>The result is <i>written</i> to the value pointed to by the argument. The specification may not contain any <i>flag</i>, <i>field width</i>, or <i>precision</i>. <br><br><br><br></p>
</td> <td> <div><code>signed char*</code></div> </td> <td> <div><code>short*</code></div> </td> <td> <div><code>int*</code></div> </td> <td> <div><code>long*</code></div> </td> <td> <div><code>long long*</code></div> </td> <td> <div><code>intmax_t*</code></div> </td> <td> <div>signed <code>size_t*</code>
</div> </td> <td> <div><code>ptrdiff_t*</code></div> </td> <td class="table-na"> <small>N/A</small> </td>
</tr> <tr> <th> <code>p</code> </th> <td> writes an implementation defined character sequence defining a <b>pointer</b>. </td> <td class="table-na"> <small>N/A</small> </td> <td class="table-na"> <small>N/A</small> </td> <td> <code>void*</code> </td> <td class="table-na"> <small>N/A</small> </td> <td class="table-na"> <small>N/A</small> </td> <td class="table-na"> <small>N/A</small> </td> <td class="table-na"> <small>N/A</small> </td> <td class="table-na"> <small>N/A</small> </td> <td class="table-na"> <small>N/A</small> </td>
</tr>
</table> <p>The floating point conversion functions convert infinity to <code>inf</code> or <code>infinity</code>. Which one is used is implementation defined.</p>
<p>Not-a-number is converted to <code>nan</code> or <code>nan(<i>char_sequence</i>)</code>. Which one is used is implementation defined.</p>
<p>The conversions <code>F</code>, <code>E</code>, <code>G</code>, <code>A</code> output <code>INF</code>, <code>INFINITY</code>, <code>NAN</code> instead.</p>
<p>Even though <code>%c</code> expects <code>int</code> argument, it is safe to pass a <code>char</code> because of the integer promotion that takes place when a variadic function is called.</p>
<p>The correct conversion specifications for the fixed-width character types (<code>int8_t</code>, etc) are defined in the header <a href="../../header/cinttypes" title="cpp/header/cinttypes"><code>&lt;cinttypes&gt;</code></a> (although <code><a href="../../types/integer" title="cpp/types/integer">PRIdMAX</a></code>, <code><a href="../../types/integer" title="cpp/types/integer">PRIuMAX</a></code>, etc is synonymous with <code>%jd</code>, <code>%ju</code>, etc).</p>
<p>The memory-writing conversion specifier <code>%n</code> is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked <code>printf_s</code> family of functions.</p>
<p>There is a <a href="../../language/eval_order" title="cpp/language/eval order">sequence point</a> after the action of each conversion specifier; this permits storing multiple <code>%n</code> results in the same variable or, as an edge case, printing a string modified by an earlier <code>%n</code> within the same call.</p>
<p>If a conversion specification is invalid, the behavior is undefined.</p>
<h3 id="Return_value"> Return value</h3> <div class="t-li1">
<span class="t-li">1-3)</span> Number of characters written if successful or negative value if an error occurred.</div> <div class="t-li1">
<span class="t-li">4)</span> Number of characters written if successful or negative value if an error occurred. If the resulting string gets truncated due to <code>buf_size</code> limit, function returns the total number of characters (not including the terminating null-byte) which would have been written, if the limit was not imposed. </div> <h3 id="Notes"> Notes</h3> <p>All these functions invoke <code><a href="../../utility/variadic/va_arg" title="cpp/utility/variadic/va arg">va_arg</a></code> at least once, the value of <code>arg</code> is indeterminate after the return. These functions do not invoke <code><a href="../../utility/variadic/va_end" title="cpp/utility/variadic/va end">va_end</a></code>, and it must be done by the caller.</p>
<h3 id="Example"> Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;vector&gt;
#include &lt;cstdio&gt;
#include &lt;cstdarg&gt;
#include &lt;ctime&gt;
 
void debug_log(const char *fmt, ...)
{
    std::time_t t = std::time(nullptr);
    char time_buf[100];
    std::strftime(time_buf, sizeof time_buf, "%D %T", std::gmtime(&amp;t));
    va_list args1;
    va_start(args1, fmt);
    va_list args2;
    va_copy(args2, args1);
    std::vector&lt;char&gt; buf(1+std::vsnprintf(nullptr, 0, fmt, args1));
    va_end(args1);
    std::vsnprintf(buf.data(), buf.size(), fmt, args2);
    va_end(args2);
    std::printf("%s [debug]: %s\n", time_buf, buf.data());
}
 
int main()
{
    debug_log("Logging, %d, %d, %d", 1, 2, 3);
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">04/13/15 15:09:18 [debug]: Logging, 1, 2, 3</pre></div> </div> <h3 id="See_also"> See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="fprintf" title="cpp/io/c/fprintf"> <span class="t-lines"><span>printf</span><span>fprintf</span><span>sprintf</span><span>snprintf</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> prints formatted output to <code><a href="std_streams" title="cpp/io/c/std streams">stdout</a></code>, a file stream or a buffer <br> <span class="t-mark">(function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="vfscanf" title="cpp/io/c/vfscanf"> <span class="t-lines"><span>vscanf</span><span>vfscanf</span><span>vsscanf</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> reads formatted input from <code><a href="std_streams" title="cpp/io/c/std streams">stdin</a></code>, a file stream or a buffer<br> using variable argument list <br> <span class="t-mark">(function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../vprint_unicode" title="cpp/io/vprint unicode"> <span class="t-lines"><span>vprint_unicode</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> prints to Unicode capable <code><a href="std_streams" title="cpp/io/c/std streams">stdout</a></code> or a file stream using <a href="../../utility/format/basic_format_args" title="cpp/utility/format/basic format args">type-erased</a> argument representation <br> <span class="t-mark">(function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../vprint_nonunicode" title="cpp/io/vprint nonunicode"> <span class="t-lines"><span>vprint_nonunicode</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> prints to <code><a href="std_streams" title="cpp/io/c/std streams">stdout</a></code> or a file stream using <a href="../../utility/format/basic_format_args" title="cpp/utility/format/basic format args">type-erased</a> argument representation <br> <span class="t-mark">(function)</span>  </td>
</tr> <tr class="t-dsc"> <td colspan="2"> <span><a href="https://en.cppreference.com/w/c/io/vfprintf" title="c/io/vfprintf">C documentation</a></span> for <code>vprintf, vfprintf, vsprintf, vsnprintf</code> </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    Â© cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/io/c/vfprintf" class="_attribution-link">https://en.cppreference.com/w/cpp/io/c/vfprintf</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
