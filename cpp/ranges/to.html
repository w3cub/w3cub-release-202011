
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Std&#58;&#58;ranges&#58;&#58;to - C++ - W3cubDocs</title>
  
  <meta name="description" content="The overloads of the range conversion function construct a new non-view object from a source range as its first argument by calling a constructor &hellip;">
  <meta name="keywords" content="std, ranges, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/ranges/to.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-9c7b0d969c0ce639a6c01c2badcdd81667c7c66206aa3d0fccc5cb0585fb1b912dab72ea882101d18010680927514b4b77b107282db8f756fbf63301fe9c88b0.css">
  <script type="text/javascript" src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js"></script>
  <script src="/json/cpp.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _cppref">
				
				
<h1 id="firstHeading" class="firstHeading">std::ranges::to</h1>            <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th> Defined in header <code><a href="../header/ranges" title="cpp/header/ranges">&lt;ranges&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">template&lt; class C, ranges::input_range R, class... Args &gt;
  requires (!ranges::view&lt;C&gt;)
constexpr C to( R&amp;&amp; r, Args&amp;&amp;... args );</pre>
</td> <td> (1) </td> <td> <span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">template&lt; template&lt; class... &gt; class C, ranges::input_range R, class... Args &gt;
constexpr auto to( R&amp;&amp; r, Args&amp;&amp;... args );</pre>
</td> <td> (2) </td> <td> <span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">template&lt; class C, class... Args &gt;
  requires (!ranges::view&lt;C&gt;)
constexpr /*range adaptor closure*/ to( Args&amp;&amp;... args );</pre>
</td> <td> (3) </td> <td> <span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">template&lt; template&lt; class... &gt; class C, class... Args &gt;
constexpr /*range adaptor closure*/ to( Args&amp;&amp;... args );</pre>
</td> <td> (4) </td> <td> <span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td> </tr> <tr class="t-dcl-h"> <td> Helper templates</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">template&lt; class Container &gt;
constexpr bool /*reservable-container*/ =
  ranges::sized_range&lt;Container&gt; &amp;&amp;
  requires (Container&amp; c, ranges::range_size_t&lt;Container&gt; n) {
    c.reserve(n);
    { c.capacity() } -&gt; std::same_as&lt;decltype(n)&gt;;
    { c.max_size() } -&gt; std::same_as&lt;decltype(n)&gt;;
  };</pre>
</td> <td> (5) </td> <td> <span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">template&lt; class Container, class Reference &gt;
constexpr bool /*container-insertable*/ = requires (Container&amp; c, Reference&amp;&amp; ref) {
  requires (requires { c.push_back(std::forward&lt;Reference&gt;(ref)); } ||
            requires { c.insert(c.end(), std::forward&lt;Reference&gt;(ref)); });
};</pre>
</td> <td> (6) </td> <td> <span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">template&lt; class Reference, class C &gt;
constexpr auto /*container-inserter*/( C&amp; c ) {
  if constexpr (requires { c.push_back(std::declval&lt;Reference&gt;()); })
    return std::back_inserter(c);
  else
    return std::inserter(c, c.end());
}</pre>
</td> <td> (7) </td> <td> <span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">template&lt; class R, class T &gt;
concept /*container-compatible-range*/ =
  ranges::input_range&lt;R&gt; &amp;&amp;
  std::convertible_to&lt;ranges::range_reference_t&lt;R&gt;, T&gt;;</pre>
</td> <td> (8) </td> <td> <span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td> </tr>  </table> <p>The overloads of the range conversion function construct a new non-view object from a source range as its first argument by calling a constructor taking a range, a <code>std::from_range_t</code> tagged ranged constructor, a constructor taking an iterator-sentinel pair, or by back inserting each element of the source range into the arguments-constructed object.</p>
<div class="t-li1">
<span class="t-li">1)</span> Constructs an object of type <code>C</code> from the elements of <code>r</code> in the following:</div> <div class="t-li2">
<span class="t-li">a)</span> If <code>C</code> does not satisfy <a href="input_range" title="cpp/ranges/input range"><code>input_range</code></a> or <code><a href="http://en.cppreference.com/w/cpp/concepts/convertible_to"><span class="kw2938">std::<span class="me2">convertible_to</span></span></a><span class="sy1">&lt;</span><a href="http://en.cppreference.com/w/cpp/ranges/iterator_t"><span class="kw2898">ranges::<span class="me2">range_reference_t</span></span></a><span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, <a href="http://en.cppreference.com/w/cpp/ranges/iterator_t"><span class="kw2897">ranges::<span class="me2">range_value_t</span></span></a><span class="sy1">&lt;</span>C<span class="sy1">&gt;&gt;</span></code> is <code>true</code>:</div> <div class="t-li3">
<span class="t-li">1)</span> Constructing a non-view object as if <a href="../language/direct_initialization" title="cpp/language/direct initialization">direct-initializing</a> (but not direct-list-initializing) an object of type <code>C</code> from the source range <code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>R<span class="sy1">&gt;</span><span class="br0">(</span>r<span class="br0">)</span></code> and the rest of the functional arguments <code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>Args<span class="sy1">&gt;</span><span class="br0">(</span>args<span class="br0">)</span>...</code> if <code><a href="http://en.cppreference.com/w/cpp/concepts/constructible_from"><span class="kw2949">std::<span class="me2">constructible_from</span></span></a><span class="sy1">&lt;</span>C, R, Args...<span class="sy1">&gt;</span></code> is <code>true</code>.</div> <div class="t-li3">
<span class="t-li">2)</span> Otherwise, constructing a non-view object as if <a href="../language/direct_initialization" title="cpp/language/direct initialization">direct-initializing</a> (but not direct-list-initializing) an object of type <code>C</code> from additional disambiguation tag <code>std::from_range</code>, the source range <code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>R<span class="sy1">&gt;</span><span class="br0">(</span>r<span class="br0">)</span></code> and the rest of the functional arguments <code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>Args<span class="sy1">&gt;</span><span class="br0">(</span>args<span class="br0">)</span>...</code> if <code><a href="http://en.cppreference.com/w/cpp/concepts/constructible_from"><span class="kw2949">std::<span class="me2">constructible_from</span></span></a><span class="sy1">&lt;</span>C, std<span class="sy4">::</span><span class="me2">from_range_t</span>, R, Args...<span class="sy1">&gt;</span></code> is <code>true</code>.</div> <span class="t-li">3)</span> Otherwise, constructing a non-view object as if <a href="../language/direct_initialization" title="cpp/language/direct initialization">direct-initializing</a> (but not direct-list-initializing) an object of type <code>C</code> from the iterator-sentinel pair (<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2885">ranges::<span class="me2">begin</span></span></a><span class="br0">(</span>r<span class="br0">)</span></code> as an iterator and <code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2887">ranges::<span class="me2">end</span></span></a><span class="br0">(</span>r<span class="br0">)</span></code> as sentinel, where iterator and sentinel have the same type. In other words, the source range must be a common range), and the rest of function arguments <code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>Args<span class="sy1">&gt;</span><span class="br0">(</span>args<span class="br0">)</span>...</code> if all of the conditions below are <code>true</code>: <ul>
<li> <code><a href="http://en.cppreference.com/w/cpp/ranges/common_range"><span class="kw2911">ranges::<span class="me2">common_range</span></span></a><span class="sy1">&lt;</span>R<span class="sy1">&gt;</span></code> </li>
<li> If <code><a href="http://en.cppreference.com/w/cpp/iterator/iterator_traits"><span class="kw653">std::<span class="me2">iterator_traits</span></span></a><span class="sy1">&lt;</span><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/iterator_t"><span class="kw2893">ranges::<span class="me2">iterator_t</span></span></a><span class="sy1">&lt;</span>R<span class="sy1">&gt;&gt;</span><span class="sy4">::</span><span class="me2">iterator_category</span></code> is valid and denotes a type that satisfies <code><a href="http://en.cppreference.com/w/cpp/concepts/derived_from"><span class="kw2937">std::<span class="me2">derived_from</span></span></a><span class="sy1">&lt;</span><a href="http://en.cppreference.com/w/cpp/iterator/iterator_tags"><span class="kw654">std::<span class="me2">input_iterator_tag</span></span></a><span class="sy1">&gt;</span></code> </li>
<li> <code><a href="http://en.cppreference.com/w/cpp/concepts/constructible_from"><span class="kw2949">std::<span class="me2">constructible_from</span></span></a><span class="sy1">&lt;</span>C, <a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/iterator_t"><span class="kw2893">ranges::<span class="me2">iterator_t</span></span></a><span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, <a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/iterator_t"><span class="kw2894">ranges::<span class="me2">sentinel_t</span></span></a><span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Args...<span class="sy1">&gt;</span></code>
</li>
</ul> <span class="t-li">4)</span> Otherwise, constructing a non-view range object as if <a href="../language/direct_initialization" title="cpp/language/direct initialization">direct-initializing</a> (but not direct-list-initializing) an object of type <code>C</code> from the rest of the function arguments <code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>Args<span class="sy1">&gt;</span><span class="br0">(</span>args<span class="br0">)</span>...</code> with the following equivalent call below after the construction: <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">if constexpr (ranges::sized_range&lt;R&gt; &amp;&amp; /*reservable-container*/&lt;C&gt;)
  c.reserve(static_cast&lt;ranges::range_size_t&lt;C&gt;&gt;(ranges::size(r)));
ranges::copy(r, /*container-inserter*/&lt;ranges::range_reference_t&lt;R&gt;&gt;(c));</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <p>If the <code>R</code> satisfies <a href="sized_range" title="cpp/ranges/sized range"><code>sized_range</code></a> and <code>C</code> satisfies <code>/*reservable-container*/</code>, the constructed object <code>c</code> of type <code>C</code> is able to reserve storage with the initial storage size <code><a href="http://en.cppreference.com/w/cpp/ranges/size"><span class="kw3103">ranges::<span class="me2">size</span></span></a><span class="br0">(</span>r<span class="br0">)</span></code> to prevent additional allocations during inserting new elements. Each range reference element of <code>r</code> is back inserted to <code>c</code> through <code>ranges::copy</code> with back inserter adaptor. The operations above are valid if both of the conditions below are <code>true</code>:</p>
<ul>
<li> <code><a href="http://en.cppreference.com/w/cpp/concepts/constructible_from"><span class="kw2949">std::<span class="me2">constructible_from</span></span></a><span class="sy1">&lt;</span>C, Args...<span class="sy1">&gt;</span></code> </li>
<li> <code><span class="coMULTI">/*container-insertable*/</span><span class="sy1">&lt;</span>C, <a href="http://en.cppreference.com/w/cpp/ranges/iterator_t"><span class="kw2898">ranges::<span class="me2">range_reference_t</span></span></a><span class="sy1">&lt;</span>R<span class="sy1">&gt;&gt;</span></code>
</li>
</ul> <div class="t-li2">
<span class="t-li">b)</span> Otherwise, the return expression is equivalent to: <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">to&lt;C&gt;(r | views::transform([](auto&amp;&amp; elem) {
  return to&lt;ranges::range_value_t&lt;C&gt;&gt;(std::forward&lt;decltype(elem)&gt;(elem));
}), std::forward&lt;Args&gt;(args)...)</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <p>Which allows nested range constructions within the range if <code><a href="http://en.cppreference.com/w/cpp/ranges/input_range"><span class="kw2905">ranges::<span class="me2">input_range</span></span></a><span class="sy1">&lt;</span><a href="http://en.cppreference.com/w/cpp/ranges/iterator_t"><span class="kw2898">ranges::<span class="me2">range_reference_t</span></span></a><span class="sy1">&lt;</span>C<span class="sy1">&gt;&gt;</span></code> is <code>true</code>.  Otherwise, the program is ill-formed.</p>
</div> <span class="t-li">2)</span> Constructs an object of deduced type from the elements of <code>r</code>. <p>Let <code>/*input-iterator*/</code> be an exposition only type that satisfies <a href="../named_req/inputiterator" title="cpp/named req/InputIterator">LegacyInputIterator</a>:</p>
<table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">struct /*input-iterator*/ {                         // exposition only
  using iterator_category = std::input_iterator_tag;
  using value_type = ranges::range_value_t&lt;R&gt;;
  using difference_type = std::ptrdiff_t;
  using pointer = std::add_pointer_t&lt;ranges::range_reference_t&lt;R&gt;&gt;;
  using reference = ranges::range_reference_t&lt;R&gt;;
  reference operator*() const;                      // not defined
  pointer operator-&gt;() const;                       // not defined
  /*input-iterator*/&amp; operator++();                 // not defined
  /*input-iterator*/ operator++(int);               // not defined
  bool operator==(const /*input-iterator*/&amp;) const; // not defined
};</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <p>Let <code>/*DEDUCE-EXPR*/</code> be defined as follows:</p>
<ul>
<li> <code>C<span class="br0">(</span><a href="http://en.cppreference.com/w/cpp/utility/declval"><span class="kw1123">std::<span class="me2">declval</span></span></a><span class="sy1">&lt;</span>R<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/utility/declval"><span class="kw1123">std::<span class="me2">declval</span></span></a><span class="sy1">&lt;</span>Args<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span>...<span class="br0">)</span></code>, if that expression is valid. </li>
<li> Otherwise, <code>C<span class="br0">(</span>std<span class="sy4">::</span><span class="me2">from_range</span>, <a href="http://en.cppreference.com/w/cpp/utility/declval"><span class="kw1123">std::<span class="me2">declval</span></span></a><span class="sy1">&lt;</span>R<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/utility/declval"><span class="kw1123">std::<span class="me2">declval</span></span></a><span class="sy1">&lt;</span>Args<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span>...<span class="br0">)</span></code>, if that expression is valid. </li>
<li> Otherwise, <code>C<span class="br0">(</span><a href="http://en.cppreference.com/w/cpp/utility/declval"><span class="kw1123">std::<span class="me2">declval</span></span></a><span class="sy1">&lt;</span><span class="coMULTI">/*input-iterator*/</span><span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/utility/declval"><span class="kw1123">std::<span class="me2">declval</span></span></a><span class="sy1">&lt;</span><span class="coMULTI">/*input-iterator*/</span><span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/utility/declval"><span class="kw1123">std::<span class="me2">declval</span></span></a><span class="sy1">&lt;</span>Args<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span>...<span class="br0">)</span></code>, if that expression is valid. </li>
<li> Otherwise, the program is ill-formed. </li>
</ul> The call is equivalent to <code>to<span class="sy1">&lt;</span>decltype<span class="br0">(</span><span class="coMULTI">/*DEDUCE-EXPR*/</span><span class="br0">)</span><span class="sy1">&gt;</span><span class="br0">(</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>R<span class="sy1">&gt;</span><span class="br0">(</span>r<span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>Args<span class="sy1">&gt;</span><span class="br0">(</span>args<span class="br0">)</span>...<span class="br0">)</span></code>. <div class="t-li1">
<span class="t-li">3-4)</span> Returns a perfect forwarding call wrapper that is also a <a href="../named_req/rangeadaptorclosureobject" title="cpp/named req/RangeAdaptorClosureObject">RangeAdaptorClosureObject</a>.</div> <div class="t-li1">
<span class="t-li">5)</span> The exposition-only variable template <code>/*reservable-container*/&lt;Container&gt;</code> is <code>true</code> if it satisfies <code><a href="http://en.cppreference.com/w/cpp/ranges/sized_range"><span class="kw2903">ranges::<span class="me2">sized_range</span></span></a></code> and is eligible to be reservable.</div> <div class="t-li1">
<span class="t-li">6)</span> The exposition-only variable template <code>/*container-insertable*/&lt;Container, Reference&gt;</code> is <code>true</code> if <code>Container</code> is back insertable by a member function call <code>push_back</code> or <code>insert</code>.</div> <div class="t-li1">
<span class="t-li">7)</span> The exposition-only function template <code>/*container-inserter*/</code> returns an output iterator of type <code>std::back_insert_iterator</code> if member function <code>push_back</code> is available, otherwise the type is <code>std::insert_iterator</code>. 
</div> <div class="t-li1">
<span class="t-li">8)</span> The exposition-only concept <code>/*container-compatible-range*/</code> is used in the definition of containers in constructing an input range <code>R</code> and its range reference type must be convertible to <code>T</code>.</div>  <h3 id="Parameters"> Parameters</h3> <table class="t-par-begin"> <tr class="t-par"> <td> r </td> <td> - </td> <td> a source range object </td>
</tr> <tr class="t-par"> <td> args </td> <td> - </td> <td> list of the arguments to <span class="t-v">(<a href="#Version_1">1-2</a>)</span> construct a range or <span class="t-v">(<a href="#Version_3">3-4</a>)</span> bind to the last parameters of range adaptor closure object. </td>
</tr>
</table> <h3 id="Return_value"> Return value</h3> <div class="t-li1">
<span class="t-li">1-2)</span> a constructed non-view object</div> <div class="t-li1">
<span class="t-li">3-4)</span> a range adaptor closure object of unspecified type, with the following properties:  <h2 id="ranges::to_return_type"> ranges::to return type</h2> <p>The return type is derived from <code>ranges::range_adaptor_closure&lt;/*return-type*/&gt;</code>.</p>
<h4 id="Member_objects"> Member objects</h4> <p>The returned object behaves as if it has no target object, and an <code><a href="../utility/tuple" title="cpp/utility/tuple">std::tuple</a></code> object <code>tup</code> constructed with <code><a href="http://en.cppreference.com/w/cpp/utility/tuple"><span class="kw1101">std::<span class="me2">tuple</span></span></a><span class="sy1">&lt;</span><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw631">std::<span class="me2">decay_t</span></span></a><span class="sy1">&lt;</span>Args<span class="sy1">&gt;</span>...<span class="sy1">&gt;</span><span class="br0">(</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>Args<span class="sy1">&gt;</span><span class="br0">(</span>args<span class="br0">)</span>...<span class="br0">)</span></code>, except that the returned object's assignment behavior is unspecified and the names are for exposition only.</p>
<h4 id="Constructors"> Constructors</h4> <p>The return type of <code>ranges::to</code> <span class="t-v">(3-4)</span> behaves as if its copy/move constructors perform a memberwise copy/move. It is <a href="../named_req/copyconstructible" title="cpp/named req/CopyConstructible">CopyConstructible</a> if all of its member objects (specified above) are CopyConstructible, and is <a href="../named_req/moveconstructible" title="cpp/named req/MoveConstructible">MoveConstructible</a> otherwise.</p>
<h4 id="Member_function_operator.28.29"> Member function <code>operator()</code>
</h4> <p>Given an object <code>G</code> obtained from an earlier call to <code>range::to&lt;/* see below */&gt;(args...)</code>, when a glvalue <code>g</code> designating <code>G</code> is invoked in a function call expression <code>g(r)</code>, an invocation of the stored object takes place, as if by.</p>
<ul>
<li> <code>ranges<span class="sy4">::</span><span class="me2">to</span><span class="sy1">&lt;</span><span class="coMULTI">/* see below */</span><span class="sy1">&gt;</span><span class="br0">(</span>r, <a href="http://en.cppreference.com/w/cpp/utility/variant/get"><span class="kw3220">std::<span class="me2">get</span></span></a><span class="sy1">&lt;</span>Ns<span class="sy1">&gt;</span><span class="br0">(</span>g.<span class="me1">tup</span><span class="br0">)</span>...<span class="br0">)</span></code>, where </li>
<ul>
<li> <code>r</code> is a source range object that must satisfy <a href="input_range" title="cpp/ranges/input range"><code>input_range</code></a> </li>
<li> <code>Ns</code> is an integer pack <code>0, 1, ..., (sizeof...(Args) - 1)</code> </li>
<li> <code>g</code> is an lvalue in the call expression if it is an lvalue in the call expression, and is an rvalue otherwise. Thus <code>std::move(g)(r)</code> can move the bound arguments into the call, where <code>g(r)</code> would copy. </li>
<li> The specified template argument is <span class="t-v">(3)</span> <code>C</code> or <span class="t-v">(4)</span> the deduced type from a class template <code>C</code> that must not satisfy <a href="view" title="cpp/ranges/view"><code>view</code></a>. </li>
</ul>
</ul>  <p>The program is ill-formed if <code>g</code> has volatile-qualified type.</p>
</div> <h3 id="Exceptions"> Exceptions</h3> <p>Only throws if construction of a range object throws.</p>
<h3 id="Notes"> Notes</h3> <p>The insertion of elements into the container may involve copy which can be more inefficient than move because lvalue references are produced during the indirection call. Users can opt-in to use <code>views::as_rvalue</code> to adapt the range in order for their elements to always produce an rvalue reference during the indirection call which implies move.</p>
<table class="wikitable ftm-begin ftm-has-value"> <tr> <th>
<a href="../utility/feature_test" title="cpp/utility/feature test">Feature-test</a> macro</th> <th>Value</th> <th><span title="Standard in which the feature is introduced">Std</span></th> <th>Comment </th>
</tr> <tr> <td><a href="../feature_test#Library_features" title="cpp/feature test"><code>__cpp_lib_ranges_to_container</code></a></td> <td><span class="nu0">202202L</span></td> <td><span class="t-mark">(C++23)</span></td> <td>
<a href="#top"><code>std::ranges::to</code></a> </td>
</tr>
</table> <h3 id="Example"> Example</h3> <div class="t-example">
<p>A link to test <a rel="nofollow" class="external text" href="https://godbolt.org/z/Yaa79fG4M">Compiler Explorer msvc.latest</a>.</p>
<div class="cpp source-cpp"><pre data-language="cpp">#include &lt;algorithm&gt;
#include &lt;concepts&gt;
#include &lt;iostream&gt;
#include &lt;ranges&gt;
#include &lt;vector&gt;
 
int main()
{
    auto vec = std::views::iota(1, 5)
             | std::views::transform([](auto const v){ return v * 2; })
             | std::ranges::to&lt;std::vector&gt;();
 
    static_assert(std::same_as&lt;decltype(vec), std::vector&lt;int&gt;&gt;);
 
    std::ranges::for_each(vec, [](auto const v){ std::cout &lt;&lt; v &lt;&lt; ' '; });
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">2 4 6 8</pre></div> </div> <h3 id="References"> References</h3>  <ul>
<li> C++23 standard (ISO/IEC 14882:2023): </li>
<ul><li> 26.5.7 Range conversions [range.utility.conv] </li></ul>
</ul>             <div class="_attribution">
  <p class="_attribution-p">
    Â© cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/ranges/to" class="_attribution-link">https://en.cppreference.com/w/cpp/ranges/to</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
