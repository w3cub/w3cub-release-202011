
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Operators (New[]) - C++ - W3cubDocs</title>
  
  <meta name="description" content="Allocates requested number of bytes. These allocation functions are called by new-expressions to allocate memory in which new object would then be &hellip;">
  <meta name="keywords" content="operator, new, operators, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/memory/new/operator_new.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/cpp.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _c">
				
				
<h1 id="firstHeading" class="firstHeading">operator new, operator new[]</h1>            <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th> Defined in header <code><a href="../../header/new" title="cpp/header/new">&lt;new&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-h"> <td> replaceable allocation functions<br><code>[[nodiscard]]</code> <span class="t-mark-rev t-since-cxx20">(since C++20)</span>
</td> <td></td> <td></td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">void* operator new  ( std::size_t count );</pre>
</td> <td> (1) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">void* operator new[]( std::size_t count );</pre>
</td> <td> (2) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">void* operator new  ( std::size_t count, std::align_val_t al);</pre>
</td> <td> (3) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">void* operator new[]( std::size_t count, std::align_val_t al);</pre>
</td> <td> (4) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr> <tr class="t-dcl-h"> <td> replaceable non-throwing allocation functions<br><code>[[nodiscard]]</code> <span class="t-mark-rev t-since-cxx20">(since C++20)</span>
</td> <td></td> <td></td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">void* operator new  ( std::size_t count, const std::nothrow_t&amp; tag);</pre>
</td> <td> (5) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">void* operator new[]( std::size_t count, const std::nothrow_t&amp; tag);</pre>
</td> <td> (6) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">void* operator new  ( std::size_t count,
                      std::align_val_t al, const std::nothrow_t&amp;);</pre>
</td> <td> (7) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">void* operator new[]( std::size_t count,
                      std::align_val_t al, const std::nothrow_t&amp;);</pre>
</td> <td> (8) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr> <tr class="t-dcl-h"> <td> non-allocating placement allocation functions<br><code>[[nodiscard]]</code> <span class="t-mark-rev t-since-cxx20">(since C++20)</span>
</td> <td></td> <td></td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">void* operator new  ( std::size_t count, void* ptr );</pre>
</td> <td> (9) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">void* operator new[]( std::size_t count, void* ptr );</pre>
</td> <td> (10) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl-h"> <td> user-defined placement allocation functions</td> <td></td> <td></td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">void* operator new  ( std::size_t count, user-defined-args... );</pre>
</td> <td> (11) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">void* operator new[]( std::size_t count, user-defined-args... );</pre>
</td> <td> (12) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">void* operator new  ( std::size_t count,
                      std::align_val_t al, user-defined-args... );</pre>
</td> <td> (13) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">void* operator new[]( std::size_t count, 
                      std::align_val_t al, user-defined-args... );</pre>
</td> <td> (14) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr> <tr class="t-dcl-h"> <td> class-specific allocation functions</td> <td></td> <td></td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">void* T::operator new  ( std::size_t count );</pre>
</td> <td> (15) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">void* T::operator new[]( std::size_t count );</pre>
</td> <td> (16) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">void* T::operator new  ( std::size_t count, std::align_val_t al );</pre>
</td> <td> (17) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">void* T::operator new[]( std::size_t count, std::align_val_t al );</pre>
</td> <td> (18) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr> <tr class="t-dcl-h"> <td> class-specific placement allocation functions</td> <td></td> <td></td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">void* T::operator new  ( std::size_t count, user-defined-args... );</pre>
</td> <td> (19) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">void* T::operator new[]( std::size_t count, user-defined-args... );</pre>
</td> <td> (20) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">void* T::operator new  ( std::size_t count,
                         std::align_val_t al, user-defined-args... );</pre>
</td> <td> (21) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">void* T::operator new[]( std::size_t count,
                         std::align_val_t al, user-defined-args... );</pre>
</td> <td> (22) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr>  </table> <p>Allocates requested number of bytes. These allocation functions are called by <a href="../../language/new" title="cpp/language/new">new-expressions</a> to allocate memory in which new object would then be initialized. They may also be called using regular function call syntax.</p>
<div class="t-li1">
<span class="t-li">1)</span> Called by non-array <a href="../../language/new" title="cpp/language/new">new-expressions</a> to allocate storage required for a single object. The standard library implementation allocates <code>count</code> bytes from free store. In case of failure, the standard library implementation calls the function pointer returned by <code><a href="get_new_handler" title="cpp/memory/new/get new handler">std::get_new_handler</a></code> and repeats allocation attempts until new handler does not return or becomes a null pointer, at which time it throws <code><a href="bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code>. This function is required to return a pointer suitably aligned to hold an object of any fundamental alignment.</div> <div class="t-li1">
<span class="t-li">2)</span> Called by the array form of <a href="../../language/new" title="cpp/language/new">new[]-expressions</a> to allocate all storage required for an array (including possible <i>new-expression</i> overhead). The standard library implementation calls version <span class="t-v">(1)</span>
</div> <div class="t-li1">
<span class="t-li">3)</span> Called by non-array <a href="../../language/new" title="cpp/language/new">new-expressions</a> to allocate storage required for a single object whose alignment requirement exceeds <code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>
</div> <div class="t-li1">
<span class="t-li">4)</span> Called by the array form of <a href="../../language/new" title="cpp/language/new">new[]-expressions</a> to allocate all storage required for an array of objects whose alignment requirement exceeds <code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>
</div> <div class="t-li1">
<span class="t-li">5)</span> Called by the non-throwing non-array <a href="../../language/new" title="cpp/language/new">new-expressions</a>. The standard library implementation calls the version <span class="t-v">(1)</span> and returns a null pointer on failure instead of propagating the exception.</div> <div class="t-li1">
<span class="t-li">6)</span> Called by the non-throwing array form of <a href="../../language/new" title="cpp/language/new">new[]-expressions</a>. The standard library implementation calls the version <span class="t-v">(2)</span> and returns a null pointer on failure instead of propagating the exception.</div> <div class="t-li1">
<span class="t-li">7)</span> Called by the non-throwing non-array <a href="../../language/new" title="cpp/language/new">new-expressions</a> when the object's alignment requirement exceeds <code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>. The standard library implementation calls the version <span class="t-v">(3)</span> and returns a null pointer on failure instead of propagating the exception.</div> <div class="t-li1">
<span class="t-li">8)</span> Called by the non-throwing array form of <a href="../../language/new" title="cpp/language/new">new[]-expressions</a> when the alignment requirement of array elements exceeds <code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>. The standard library implementation calls the version <span class="t-v">(4)</span> and returns a null pointer on failure instead of propagating the exception.</div> <div class="t-li1">
<span class="t-li">9)</span> Called by the standard single-object <a href="../../language/new" title="cpp/language/new">placement new</a> expression. The standard library implementation performs no action and returns <code>ptr</code> unmodified.</div> <div class="t-li1">
<span class="t-li">10)</span> Called by the standard array form <a href="../../language/new" title="cpp/language/new">placement new</a> expression. The standard library implementation performs no action and returns <code>ptr</code> unmodified.</div> <div class="t-li1">
<span class="t-li">11)</span> If defined, called by the custom single-object <a href="../../language/new" title="cpp/language/new">placement new</a> expression with the matching signature. If a class-specific version <span class="t-v">(19)</span> is defined, it is called in preference to <span class="t-v">(11)</span>. If neither <span class="t-v">(11)</span> nor <span class="t-v">(19)</span> is provided by the user, the placement new expression is ill-formed.</div> <div class="t-li1">
<span class="t-li">12)</span> If defined, called by the custom array form <a href="../../language/new" title="cpp/language/new">placement new</a> expression with the matching signature. If a class-specific version <span class="t-v">(20)</span> is defined, it is called in preference to <span class="t-v">(12)</span>. If neither <span class="t-v">(12)</span> nor <span class="t-v">(20)</span> is provided by the user, the placement new expression is ill-formed.</div> <div class="t-li1">
<span class="t-li">13)</span> If defined, called by the custom single-object <a href="../../language/new" title="cpp/language/new">placement new</a> expression with the matching signature if the object's alignment requirement exceeds <code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>. If a class-specific version is defined (<span class="t-v">(15)</span> or <span class="t-v">(17)</span>), it is called instead. If neither class-specific nor global alignment-aware (this one) placement form is provided, alignment-unaware placement form <span class="t-v">(11)</span> is looked up instead.</div> <div class="t-li1">
<span class="t-li">14)</span> If defined, called by the custom array form <a href="../../language/new" title="cpp/language/new">placement new</a> expression with the matching signature if the element's alignment requirement exceeds <code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>. If a class-specific version (<span class="t-v">(16)</span> or <span class="t-v">(18)</span>) is defined, it is called instead. If neither class-specific nor global alignment-aware (this one) placement form is provided, alignment-unaware placement form <span class="t-v">(12)</span> is looked up instead.</div> <div class="t-li1">
<span class="t-li">15)</span> If defined, called by the usual single-object <a href="../../language/new" title="cpp/language/new">new-expressions</a> if allocating an object of type T.</div> <div class="t-li1">
<span class="t-li">16)</span> If defined, called by the usual array <a href="../../language/new" title="cpp/language/new">new[]-expressions</a> if allocating an array of objects of type T.</div> <div class="t-li1">
<span class="t-li">17)</span> If defined, called by the usual single-object <a href="../../language/new" title="cpp/language/new">new-expressions</a> if allocating an object of type T if its alignment requirement exceeds <code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>. If this overload is not provided, but allocator-unaware member form <span class="t-v">(15)</span> is, allocator-unaware member overload is called instead.</div> <div class="t-li1">
<span class="t-li">18)</span> If defined, called by the usual array <a href="../../language/new" title="cpp/language/new">new[]-expressions</a> if allocating an array of objects of type T if its alignment requirement exceeds <code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>. If this overload is not provided, but allocator-unaware member form <span class="t-v">(16)</span> is, allocator-unaware member overload is called instead.</div> <div class="t-li1">
<span class="t-li">19)</span> If defined, called by the custom single-object <a href="../../language/new" title="cpp/language/new">placement new</a> expression with the matching signature if allocating an object of type T.</div> <div class="t-li1">
<span class="t-li">20)</span> If defined, called by the custom array form of <a href="../../language/new" title="cpp/language/new">placement new[] </a> expression with the matching signature if allocating an array of objects of type T.</div> <div class="t-li1">
<span class="t-li">21)</span> If defined, called by the custom single-object <a href="../../language/new" title="cpp/language/new">placement new</a> expression with the matching signature if allocating an object of type T if its alignment requirement exceeds <code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>. If this overload is not provided, but allocator-unaware member form <span class="t-v">(19)</span> is, allocator-unaware member overload is called instead.</div> <div class="t-li1">
<span class="t-li">22)</span> If defined, called by the custom array form of <a href="../../language/new" title="cpp/language/new">placement new[] </a> expression with the matching signature if allocating an array of objects of type T. if its alignment requirement exceeds <code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>. If this overload is not provided, but allocator-unaware member form <span class="t-v">(20)</span> is, allocator-unaware member overload is called instead.</div> <h3 id="Parameters">Parameters</h3> <table class="t-par-begin"> <tr class="t-par"> <td> count </td> <td> - </td> <td> number of bytes to allocate </td>
</tr> <tr class="t-par"> <td> ptr </td> <td> - </td> <td> pointer to a memory area to initialize the object at </td>
</tr> <tr class="t-par"> <td> tag </td> <td> - </td> <td> disambiguation tag used to select non-throwing overloads </td>
</tr> <tr class="t-par"> <td> al </td> <td> - </td> <td> alignment to use. The behavior is undefined if this is not a valid alignment value </td>
</tr>
</table> <h3 id="Return_value">Return value</h3> <div class="t-li1">
<span class="t-li">1-4)</span> non-null pointer to suitably aligned memory of size at least <code>size</code>
</div> <div class="t-li1">
<span class="t-li">5-8)</span> non-null pointer to suitably aligned memory of size at least <code>size</code>, or null pointer on allocation failure</div> <div class="t-li1">
<span class="t-li">9-10)</span> <code>ptr</code>
</div> <div class="t-li1">
<span class="t-li">11-22)</span> same as <span class="t-v">(1-4)</span> if the function does not return on allocation failure, otherwise same as <span class="t-v">(5-8)</span>
</div> <h3 id="Exceptions">Exceptions</h3> <div class="t-li1">
<span class="t-li">1-4)</span> throws <code><a href="bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code> <span class="t-rev-inl t-since-cxx11"><span>or another exception derived from <code><a href="bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code></span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span> on failure to allocate memory</div> <div class="t-li1">
<span class="t-li">5-10)</span> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx11">
<td> <p>(none).</p>
</td> <td><span class="t-mark-rev t-until-cxx11">(until C++11)</span></td>
</tr> <tr class="t-rev t-since-cxx11">
<td> <a href="../../language/noexcept_spec" title="cpp/language/noexcept spec"><code>noexcept</code></a> specification: <div class="t-noexcept-box"><span class="t-cc"><code>noexcept</code></span></div>  </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table>
</div> <div class="t-li1">
<span class="t-li">11-22)</span> same as <span class="t-v">(1-4)</span> if the function does not return on allocation failure, otherwise same as <span class="t-v">(5-8)</span>
</div> <h3 id="Global_replacements">Global replacements</h3> <p>The versions <span class="t-v">(1-4)</span> are implicitly declared in each translation unit even if the <code>&lt;new&gt;</code> header is not included. Versions <span class="t-v">(1-8)</span> are <i>replaceable</i>: a user-provided non-member function with the same signature defined anywhere in the program, in any source file, replaces the default version. Its declaration does not need to be visible.</p>
<p>The behavior is undefined if more than one replacement is provided in the program for any of the replaceable allocation function, or if a replacement is defined with the <code>inline</code> specifier. The program is ill-formed if a replacement is defined in namespace other than global namespace, or if it is defined as a static non-member function at global scope.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>The standard library implementations of the nothrow versions <span class="t-v">(5-8)</span> directly calls the corresponding throwing versions <span class="t-v">(1-4)</span>. The standard library implementation of the throwing array versions <span class="t-v">(2,4)</span> directly calls the corresponding single-object version <span class="t-v">(1,3)</span>. Thus, replacing the throwing single object allocation functions is sufficient to handle all allocations.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;new&gt;
// replacement of a minimal set of functions:
void* operator new(std::size_t sz) {
    std::printf("global op new called, size = %zu\n", sz);
    void *ptr = std::malloc(sz);
    if (ptr)
        return ptr;
    else
        throw std::bad_alloc{};
}
void operator delete(void* ptr) noexcept
{
    std::puts("global op delete called");
    std::free(ptr);
}
int main() {
     int* p1 = new int;
     delete p1;
 
     int* p2 = new int[10]; // guaranteed to call the replacement in C++11
     delete[] p2;
}</pre></div> <p>Possible output:</p>
<div class="text source-text"><pre data-language="c">global op new called, size = 4
global op delete called
global op new called, size = 40
global op delete called</pre></div> </div> <p>Overloads of <code>operator new</code> and <code>operator new[]</code> with additional user-defined parameters ("placement forms", versions <span class="t-v">(11-14)</span>) may be declared at global scope as usual, and are called by the matching placement forms of <i>new-expressions</i>.</p>
<p>The standard library's non-allocating placement forms of operator new <span class="t-v">(9-10)</span> cannot be replaced and can only be customized if the placement new-expression did not use the <code>::new</code> syntax, by providing a class-specific placement new <span class="t-v">(19,20)</span> with matching signature: <code>void* T::operator new(size_t, void*)</code> or <code>void* T::operator new[](size_t, void*)</code>.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx14">
<td> <p>The placement form <code>void* operator new(std::size_t, std::size_t)</code> is not allowed because the matching signature of the deallocation function, <code>void operator delete(void*, std::size_t)</code>, is a usual (not placement) deallocation function.</p>
</td> <td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr> </table> <h3 id="Class-specific_overloads">Class-specific overloads</h3> <p>Both single-object and array allocation functions may be defined as public static member functions of a class (versions <span class="t-v">(15-18)</span>). If defined, these allocation functions are called by <a href="../../language/new" title="cpp/language/new">new-expressions</a> to allocate memory for single objects and arrays of this class, unless the new expression used the form <code>::new</code> which bypasses class-scope lookup. The keyword <code>static</code> is optional for these functions: whether used or not, the allocation function is a static member function.</p>
<p>The new expression looks for appropriate allocation function's name firstly in the class scope, and after that in the global scope. Note, that as per <a href="../../language/lookup" title="cpp/language/lookup">name lookup rules</a>, any allocation functions declared in class scope hides all global allocation functions for the new-expressions that attempt to allocate objects of this class.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <p>When allocating objects and arrays of objects whose alignment exceeds <code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>, overload resolution is performed twice: first, for alignment-aware function signatures, then for alignment-unaware function signatures. This means that if a class with extended alignment has an alignment-unaware class-specific allocation function, it is the function that will be called, not the global alignment-aware allocation function. This is intentional: the class member is expected to know best how to handle that class.</p>
</td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
// class-specific allocation functions
struct X {
    static void* operator new(std::size_t sz)
    {
        std::cout &lt;&lt; "custom new for size " &lt;&lt; sz &lt;&lt; '\n';
        return ::operator new(sz);
    }
    static void* operator new[](std::size_t sz)
    {
        std::cout &lt;&lt; "custom new for size " &lt;&lt; sz &lt;&lt; '\n';
        return ::operator new(sz);
    }
};
int main() {
     X* p1 = new X;
     delete p1;
     X* p2 = new X[10];
     delete[] p2;
}</pre></div> <p>Possible output:</p>
<div class="text source-text"><pre data-language="c">custom new for size 1
custom new for size 10</pre></div> </div> <p>Overloads of <code>operator new</code> and <code>operator new[]</code> with additional user-defined parameters ("placement forms"), may also be defined as class members <span class="t-v">(19-22)</span>). When the placement new expression with the matching signature looks for the corresponding allocation function to call, it begins at class scope before examining the global scope, and if the class-specific placement new is provided, it is called.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <p>When allocating objects and arrays of objects whose alignment exceeds <code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>, overload resolution for placement forms is performed twice just as for regular forms: first, for alignment-aware function signatures, then for alignment-unaware function signatures.</p>
</td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;stdexcept&gt;
#include &lt;iostream&gt;
struct X {
    X() { throw std::runtime_error(""); }
    // custom placement new
    static void* operator new(std::size_t sz, bool b) {
        std::cout &lt;&lt; "custom placement new called, b = " &lt;&lt; b &lt;&lt; '\n';
        return ::operator new(sz);
    }
    // custom placement delete
    static void operator delete(void* ptr, bool b)
    {
        std::cout &lt;&lt; "custom placement delete called, b = " &lt;&lt; b &lt;&lt; '\n';
        ::operator delete(ptr);
    }
};
int main() {
   try {
     X* p1 = new (true) X;
   } catch(const std::exception&amp;) { }
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">custom placement new called, b = 1
custom placement delete called, b = 1</pre></div> </div> <p>If class-level <code>operator new</code> is a template function, it must have the return type of <code>void*</code>, the first argument <code>std::size_t</code>, and it must have two or more parameters. In other words, only placement forms can be templates.</p>
<h3 id="Notes">Notes</h3> <p>Even though the non-allocating placement new <span class="t-v">(9,10)</span> cannot be replaced, a function with the same signature may be defined at class scope as described above. In addition, global overloads that look like placement new but take a non-void pointer type as the second argument are allowed, so the code that wants to ensure that the true placement new is called (e.g. <code><a href="../allocator/construct" title="cpp/memory/allocator/construct">std::allocator::construct</a></code>), must use <code>::new</code> and also cast the pointer to <code>void*</code>.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>The following functions are required to be thread-safe:</p>
<ul>
<li> The library versions of <strong class="selflink"><code>operator new</code></strong> and <a href="operator_delete" title="cpp/memory/new/operator delete"><code>operator delete</code></a> </li>
<li> User replacement versions of global <strong class="selflink"><code>operator new</code></strong> and <a href="operator_delete" title="cpp/memory/new/operator delete"><code>operator delete</code></a> </li>
<li> <code><a href="../c/calloc" title="cpp/memory/c/calloc">std::calloc</a></code>, <code><a href="../c/malloc" title="cpp/memory/c/malloc">std::malloc</a></code>, <code><a href="../c/realloc" title="cpp/memory/c/realloc">std::realloc</a></code><span class="t-rev-inl t-since-cxx17"><span>, <code><a href="../c/aligned_alloc" title="cpp/memory/c/aligned alloc">std::aligned_alloc</a></code></span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span>, <code><a href="../c/free" title="cpp/memory/c/free">std::free</a></code> </li>
</ul> <p>Calls to these functions that allocate or deallocate a particular unit of storage occur in a single total order, and each such deallocation call <a href="../../atomic/memory_order" title="cpp/atomic/memory order">happens-before</a> the next allocation (if any) in this order.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <p>It is unspecified whether library versions of <code>operator new</code> make any calls to <code><a href="../c/malloc" title="cpp/memory/c/malloc">std::malloc</a></code> <span class="t-rev-inl t-since-cxx17"><span>or <code><a href="../c/aligned_alloc" title="cpp/memory/c/aligned alloc">std::aligned_alloc</a></code></span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span>.</p>
<h3 id="Example">Example</h3> <div class="t-example">
<p>Custom placement forms of operator new can be used for any purpose, for example, to fill the allocated array.</p>
<div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
 
void* operator new[](std::size_t sz, char c)
{
    void* p = operator new[](sz);
    std::fill_n(reinterpret_cast&lt;char*&gt;(p), sz, c);
    return p;
}
 
int main()
{
    char* p = new('*') char[6];
    p[5] = '\0';
    std::cout &lt;&lt; p &lt;&lt; '\n';
    delete[] p;
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">*****</pre></div> </div> <h3 id="See_also">See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="operator_delete" title="cpp/memory/new/operator delete"> <span class="t-lines"><span>operator delete</span><span>operator delete[]</span></span></a></div> </td> <td> deallocation functions <br> <span class="t-mark">(function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="get_new_handler" title="cpp/memory/new/get new handler"> <span class="t-lines"><span>get_new_handler</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> obtains the current new handler <br> <span class="t-mark">(function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="set_new_handler" title="cpp/memory/new/set new handler"> <span class="t-lines"><span>set_new_handler</span></span></a></div> </td> <td> registers a new handler <br> <span class="t-mark">(function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../get_temporary_buffer" title="cpp/memory/get temporary buffer"> <span class="t-lines"><span>get_temporary_buffer</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark">(deprecated in C++17)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span></span></div> </td> <td> obtains uninitialized storage <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../c/malloc" title="cpp/memory/c/malloc"> <span class="t-lines"><span>malloc</span></span></a></div> </td> <td> allocates memory <br> <span class="t-mark">(function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../c/aligned_alloc" title="cpp/memory/c/aligned alloc"> <span class="t-lines"><span>aligned_alloc</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> allocates aligned memory <br> <span class="t-mark">(function)</span> </td>
</tr> </table> <h3 id="References">References</h3>  <ul>
<li> C++11 standard (ISO/IEC 14882:2011): </li>
<ul><li> 18.6 Dynamic memory management [support.dynamic] </li></ul>
</ul>            <div class="_attribution">
  <p class="_attribution-p">
    Â© cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/memory/new/operator_new" class="_attribution-link">http://en.cppreference.com/w/cpp/memory/new/operator_new</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
