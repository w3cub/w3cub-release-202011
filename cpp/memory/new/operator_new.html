
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Operators (New[]) - C++ - W3cubDocs</title>
  
  <meta name="description" content=" [[nodiscard]] ">
  <meta name="keywords" content="operator, new, operators, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/memory/new/operator_new.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-9c7b0d969c0ce639a6c01c2badcdd81667c7c66206aa3d0fccc5cb0585fb1b912dab72ea882101d18010680927514b4b77b107282db8f756fbf63301fe9c88b0.css">
  <script type="text/javascript" src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js"></script>
  <script src="/json/cpp.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _cppref">
				
				
<h1 id="firstHeading" class="firstHeading">operator new, operator new[]</h1>            <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th> Defined in header <code><a href="../../header/new" title="cpp/header/new">&lt;new&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-h"> <td> replaceable allocation functions <table class="t-rev-begin t-rev-begin-noborder"> <tr class="t-rev t-since-cxx20">
<td> <p><code>[[nodiscard]]</code></p>
</td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table>
</td> <td></td> <td></td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">void* operator new  ( std::size_t count );</pre>
</td> <td> (1) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">void* operator new[]( std::size_t count );</pre>
</td> <td> (2) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">void* operator new  ( std::size_t count, std::align_val_t al );</pre>
</td> <td> (3) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">void* operator new[]( std::size_t count, std::align_val_t al );</pre>
</td> <td> (4) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr> <tr class="t-dcl-h"> <td> replaceable non-throwing allocation functions <table class="t-rev-begin t-rev-begin-noborder"> <tr class="t-rev t-since-cxx11">
<td> <p><code>noexcept</code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <table class="t-rev-begin t-rev-begin-noborder"> <tr class="t-rev t-since-cxx20">
<td> <p><code>[[nodiscard]]</code></p>
</td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table>
</td> <td></td> <td></td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">void* operator new  ( std::size_t count, const std::nothrow_t&amp; tag );</pre>
</td> <td> (5) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">void* operator new[]( std::size_t count, const std::nothrow_t&amp; tag );</pre>
</td> <td> (6) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">void* operator new  ( std::size_t count,
                      std::align_val_t al, const std::nothrow_t&amp; );</pre>
</td> <td> (7) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">void* operator new[]( std::size_t count,
                      std::align_val_t al, const std::nothrow_t&amp; );</pre>
</td> <td> (8) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr> <tr class="t-dcl-h"> <td> non-allocating placement allocation functions <table class="t-rev-begin t-rev-begin-noborder"> <tr class="t-rev t-since-cxx11">
<td> <p><code>noexcept</code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <table class="t-rev-begin t-rev-begin-noborder"> <tr class="t-rev t-since-cxx20">
<td> <p><code>[[nodiscard]]</code></p>
</td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table>
</td> <td></td> <td></td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">void* operator new  ( std::size_t count, void* ptr );</pre>
</td> <td> (9) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">void* operator new[]( std::size_t count, void* ptr );</pre>
</td> <td> (10) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl-h"> <td> user-defined placement allocation functions</td> <td></td> <td></td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">void* operator new  ( std::size_t count, user-defined-args... );</pre>
</td> <td> (11) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">void* operator new[]( std::size_t count, user-defined-args... );</pre>
</td> <td> (12) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">void* operator new  ( std::size_t count,
                      std::align_val_t al, user-defined-args... );</pre>
</td> <td> (13) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">void* operator new[]( std::size_t count, 
                      std::align_val_t al, user-defined-args... );</pre>
</td> <td> (14) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr> <tr class="t-dcl-h"> <td> class-specific allocation functions</td> <td></td> <td></td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">void* T::operator new  ( std::size_t count );</pre>
</td> <td> (15) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">void* T::operator new[]( std::size_t count );</pre>
</td> <td> (16) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">void* T::operator new  ( std::size_t count, std::align_val_t al );</pre>
</td> <td> (17) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">void* T::operator new[]( std::size_t count, std::align_val_t al );</pre>
</td> <td> (18) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr> <tr class="t-dcl-h"> <td> class-specific placement allocation functions</td> <td></td> <td></td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">void* T::operator new  ( std::size_t count, user-defined-args... );</pre>
</td> <td> (19) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">void* T::operator new[]( std::size_t count, user-defined-args... );</pre>
</td> <td> (20) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">void* T::operator new  ( std::size_t count,
                         std::align_val_t al, user-defined-args... );</pre>
</td> <td> (21) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">void* T::operator new[]( std::size_t count,
                         std::align_val_t al, user-defined-args... );</pre>
</td> <td> (22) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr>  </table> <p>Attempts to allocate requested number of bytes, and the allocation request can fail (even if the requested number of bytes is zero). These allocation functions are called by <a href="../../language/new" title="cpp/language/new">new-expressions</a> to allocate memory in which new object would then be initialized. They may also be called using regular function call syntax.</p>
<div class="t-li1">
<span class="t-li">1)</span> Called by non-array <a href="../../language/new" title="cpp/language/new">new-expressions</a> to allocate storage required for a single object. The standard library implementation allocates <code>count</code> bytes from free store. In case of failure, the standard library implementation calls the function pointer returned by <code><a href="get_new_handler" title="cpp/memory/new/get new handler">std::get_new_handler</a></code> and repeats allocation attempts until new handler does not return or becomes a null pointer, at which time it throws <code><a href="bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code>. This function is required to return a pointer suitably aligned to point to an object of the requested size.</div> <div class="t-li1">
<span class="t-li">2)</span> Called by the array form of <a href="../../language/new" title="cpp/language/new">new[]-expressions</a> to allocate all storage required for an array (including possible <i>new-expression</i> overhead). The standard library implementation calls version <span class="t-v">(1)</span>.</div> <div class="t-li1">
<span class="t-li">3)</span> Called by non-array <a href="../../language/new" title="cpp/language/new">new-expressions</a> to allocate storage required for a single object whose alignment requirement exceeds <code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>.</div> <div class="t-li1">
<span class="t-li">4)</span> Called by the array form of <a href="../../language/new" title="cpp/language/new">new[]-expressions</a> to allocate all storage required for an array of objects whose alignment requirement exceeds <code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>.</div> <div class="t-li1">
<span class="t-li">5)</span> Called by the non-throwing non-array <a href="../../language/new" title="cpp/language/new">new-expressions</a>. The standard library implementation calls the version <span class="t-v">(1)</span> and returns a null pointer on failure instead of propagating the exception.</div> <div class="t-li1">
<span class="t-li">6)</span> Called by the non-throwing array form of <a href="../../language/new" title="cpp/language/new">new[]-expressions</a>. The standard library implementation calls the version <span class="t-v">(2)</span> and returns a null pointer on failure instead of propagating the exception.</div> <div class="t-li1">
<span class="t-li">7)</span> Called by the non-throwing non-array <a href="../../language/new" title="cpp/language/new">new-expressions</a> when the object's alignment requirement exceeds <code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>. The standard library implementation calls the version <span class="t-v">(3)</span> and returns a null pointer on failure instead of propagating the exception.</div> <div class="t-li1">
<span class="t-li">8)</span> Called by the non-throwing array form of <a href="../../language/new" title="cpp/language/new">new[]-expressions</a> when the alignment requirement of array elements exceeds <code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>. The standard library implementation calls the version <span class="t-v">(4)</span> and returns a null pointer on failure instead of propagating the exception.</div> <div class="t-li1">
<span class="t-li">9)</span> Called by the standard single-object <a href="../../language/new" title="cpp/language/new">placement new</a> expression. The standard library implementation performs no action and returns <code>ptr</code> unmodified. The behavior is undefined if this function is called through a placement new expression and <code>ptr</code> is a null pointer. </div> <div class="t-li1">
<span class="t-li">10)</span> Called by the standard array form <a href="../../language/new" title="cpp/language/new">placement new</a> expression. The standard library implementation performs no action and returns <code>ptr</code> unmodified. The behavior is undefined if this function is called through a placement new expression and <code>ptr</code> is a null pointer. </div> <div class="t-li1">
<span class="t-li">11)</span> If defined, called by the custom single-object <a href="../../language/new" title="cpp/language/new">placement new</a> expression with the matching signature. If a class-specific version <span class="t-v">(19)</span> is defined, it is called in preference to <span class="t-v">(11)</span>. If neither <span class="t-v">(11)</span> nor <span class="t-v">(19)</span> is provided by the user, the placement new expression is ill-formed.</div> <div class="t-li1">
<span class="t-li">12)</span> If defined, called by the custom array form <a href="../../language/new" title="cpp/language/new">placement new</a> expression with the matching signature. If a class-specific version <span class="t-v">(20)</span> is defined, it is called in preference to <span class="t-v">(12)</span>. If neither <span class="t-v">(12)</span> nor <span class="t-v">(20)</span> is provided by the user, the placement new expression is ill-formed.</div> <div class="t-li1">
<span class="t-li">13)</span> If defined, called by the custom single-object <a href="../../language/new" title="cpp/language/new">placement new</a> expression with the matching signature if the object's alignment requirement exceeds <code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>. If a class-specific version is defined (<span class="t-v">(15)</span> or <span class="t-v">(17)</span>), it is called instead. If neither class-specific nor global alignment-aware (this one) placement form is provided, alignment-unaware placement form <span class="t-v">(11)</span> is looked up instead.</div> <div class="t-li1">
<span class="t-li">14)</span> If defined, called by the custom array form <a href="../../language/new" title="cpp/language/new">placement new</a> expression with the matching signature if the element's alignment requirement exceeds <code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>. If a class-specific version (<span class="t-v">(16)</span> or <span class="t-v">(18)</span>) is defined, it is called instead. If neither class-specific nor global alignment-aware (this one) placement form is provided, alignment-unaware placement form <span class="t-v">(12)</span> is looked up instead.</div> <div class="t-li1">
<span class="t-li">15)</span> If defined, called by the usual single-object <a href="../../language/new" title="cpp/language/new">new-expressions</a> if allocating an object of type T.</div> <div class="t-li1">
<span class="t-li">16)</span> If defined, called by the usual array <a href="../../language/new" title="cpp/language/new">new[]-expressions</a> if allocating an array of objects of type T.</div> <div class="t-li1">
<span class="t-li">17)</span> If defined, called by the usual single-object <a href="../../language/new" title="cpp/language/new">new-expressions</a> if allocating an object of type T if its alignment requirement exceeds <code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>. If this overload is not provided, but alignment-unaware member form <span class="t-v">(15)</span> is, alignment-unaware member overload is called instead.</div> <div class="t-li1">
<span class="t-li">18)</span> If defined, called by the usual array <a href="../../language/new" title="cpp/language/new">new[]-expressions</a> if allocating an array of objects of type T if its alignment requirement exceeds <code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>. If this overload is not provided, but alignment-unaware member form <span class="t-v">(16)</span> is, alignment-unaware member overload is called instead.</div> <div class="t-li1">
<span class="t-li">19)</span> If defined, called by the custom single-object <a href="../../language/new" title="cpp/language/new">placement new</a> expression with the matching signature if allocating an object of type T.</div> <div class="t-li1">
<span class="t-li">20)</span> If defined, called by the custom array form of <a href="../../language/new" title="cpp/language/new">placement new[]</a> expression with the matching signature if allocating an array of objects of type T.</div> <div class="t-li1">
<span class="t-li">21)</span> If defined, called by the custom single-object <a href="../../language/new" title="cpp/language/new">placement new</a> expression with the matching signature if allocating an object of type T if its alignment requirement exceeds <code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>. If this overload is not provided, but alignment-unaware member form <span class="t-v">(19)</span> is, alignment-unaware member overload is called instead.</div> <div class="t-li1">
<span class="t-li">22)</span> If defined, called by the custom array form of <a href="../../language/new" title="cpp/language/new">placement new[]</a> expression with the matching signature if allocating an array of objects of type T if its alignment requirement exceeds <code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>. If this overload is not provided, but alignment-unaware member form <span class="t-v">(20)</span> is, alignment-unaware member overload is called instead.</div>  <h3 id="Parameters"> Parameters</h3> <table class="t-par-begin"> <tr class="t-par"> <td> count </td> <td> - </td> <td> number of bytes to allocate </td>
</tr> <tr class="t-par"> <td> ptr </td> <td> - </td> <td> pointer to a memory area to initialize the object at </td>
</tr> <tr class="t-par"> <td> tag </td> <td> - </td> <td> disambiguation tag used to select non-throwing overloads </td>
</tr> <tr class="t-par"> <td> al </td> <td> - </td> <td> alignment to use. The behavior is undefined if this is not a valid alignment value </td>
</tr>
</table> <h3 id="Return_value"> Return value</h3> <div class="t-li1">
<span class="t-li">1-4)</span> If the allocation succeeds, a non-null pointer <code>p0</code> which points to suitably aligned memory of size at least <code>size</code> and is different from any previously returned value <code>p1</code>, unless that value <code>p1</code> was subsequently passed to a replaceable <a href="operator_delete" title="cpp/memory/new/operator delete">deallocation function</a>; if the allocation fails, does not return (an exception is thrown, see below).</div> <div class="t-li1">
<span class="t-li">5-8)</span> Same as <span class="t-v">(<a href="#Version_1">1-4</a>)</span>, but returns a null pointer if the allocation fails.</div> <div class="t-li1">
<span class="t-li">9-10)</span> <code>ptr</code>.</div> <div class="t-li1">
<span class="t-li">11-22)</span> Same as <span class="t-v">(<a href="#Version_1">1-4</a>)</span> if the function does not return on allocation failure, otherwise same as <span class="t-v">(<a href="#Version_5">5-8</a>)</span>.</div> <h3 id="Exceptions"> Exceptions</h3> <div class="t-li1">
<span class="t-li">1-4)</span> Throws an exception of a type that would match a handler of type <code><a href="bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code> on failure to allocate memory.</div> <div class="t-li1">
<span class="t-li">11-22)</span> Same as <span class="t-v">(<a href="#Version_1">1-4</a>)</span> if the function does not return on allocation failure, otherwise same as <span class="t-v">(<a href="#Version_5">5-8</a>)</span>.</div> <h3 id="Global_replacements"> Global replacements</h3> <p>The versions <span class="t-v">(<a href="#Version_1">1-4</a>)</span> are implicitly declared in each translation unit even if the <a href="../../header/new" title="cpp/header/new"><code>&lt;new&gt;</code></a> header is not included. Versions <span class="t-v">(1-8)</span> are <i>replaceable</i>: a user-provided non-member function with the same signature defined anywhere in the program, in any source file, replaces the default version. Its declaration does not need to be visible.</p>
<p>The program is ill-formed, no diagnostic required if more than one replacement is provided in the program for any of the replaceable allocation function, or if a replacement is declared with the <a href="../../language/inline" title="cpp/language/inline"><code>inline</code> specifier</a>. The program is ill-formed if a replacement is defined in namespace other than global namespace, or if it is defined as a static non-member function at global scope.</p>
<p>The standard library implementations of the nothrow versions <span class="t-v">(<a href="#Version_5">5-8</a>)</span> directly calls the corresponding throwing versions <span class="t-v">(<a href="#Version_1">1-4</a>)</span>. The standard library implementation of the throwing array versions <span class="t-v">(<a href="#Version_2">2,4</a>)</span> directly calls the corresponding single-object version <span class="t-v">(<a href="#Version_1">1,3</a>)</span>. Thus, replacing the throwing single object allocation functions is sufficient to handle all allocations.</p>
<div class="t-example">
<p>Global <code>operator</code>s new/delete replacement:</p>
<div class="cpp source-cpp"><pre data-language="cpp">#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;new&gt;
 
// no inline, required by [replacement.functions]/3
void* operator new(std::size_t sz)
{
    std::printf("1) new(size_t), size = %zu\n", sz);
    if (sz == 0)
        ++sz; // avoid std::malloc(0) which may return nullptr on success
 
    if (void *ptr = std::malloc(sz))
        return ptr;
 
    throw std::bad_alloc{}; // required by [new.delete.single]/3
}
 
// no inline, required by [replacement.functions]/3
void* operator new[](std::size_t sz)
{
    std::printf("2) new[](size_t), size = %zu\n", sz);
    if (sz == 0)
        ++sz; // avoid std::malloc(0) which may return nullptr on success
 
    if (void *ptr = std::malloc(sz))
        return ptr;
 
    throw std::bad_alloc{}; // required by [new.delete.single]/3
}
 
void operator delete(void* ptr) noexcept
{
    std::puts("3) delete(void*)");
    std::free(ptr);
}
 
void operator delete(void* ptr, std::size_t size) noexcept
{
    std::printf("4) delete(void*, size_t), size = %zu\n", size);
    std::free(ptr);
}
 
void operator delete[](void* ptr) noexcept
{
    std::puts("5) delete[](void* ptr)");
    std::free(ptr);
}
 
void operator delete[](void* ptr, std::size_t size) noexcept
{
    std::printf("6) delete[](void*, size_t), size = %zu\n", size);
    std::free(ptr);
}
 
int main()
{
    int* p1 = new int;
    delete p1;
 
    int* p2 = new int[10]; // guaranteed to call the replacement in C++11
    delete[] p2;
}</pre></div> <p>Possible output:</p>
<div class="text source-text"><pre data-language="c">// Compiled with GCC-5 in C++17 mode to obtain the following:
1) op new(size_t), size = 4
4) op delete(void*, size_t), size = 4
2) op new[](size_t), size = 40
5) op delete[](void* ptr)</pre></div> </div> <p>Overloads of <code>operator new</code> and <code>operator new[]</code> with additional user-defined parameters ("placement forms", versions <span class="t-v">(<a href="#Version_11">11-14</a>)</span>) may be declared at global scope as usual, and are called by the matching placement forms of <i>new-expressions</i>.</p>
<p>The standard library's non-allocating placement forms of <code>operator new</code> <span class="t-v">(<a href="#Version_9">9-10</a>)</span> cannot be replaced and can only be customized if the placement new-expression did not use the <span class="sy4">::</span><span class="me2">new</span> syntax, by providing a class-specific placement new <span class="t-v">(<a href="#Version_19">19,20</a>)</span> with matching signature: <span class="kw4">void</span><span class="sy2">*</span> T<span class="sy4">::</span><span class="me2">operator</span> new<span class="br0">(</span><a href="http://en.cppreference.com/w/cpp/types/size_t"><span class="kw107">std::<span class="me2">size_t</span></span></a>, <span class="kw4">void</span><span class="sy2">*</span><span class="br0">)</span> or <span class="kw4">void</span><span class="sy2">*</span> T<span class="sy4">::</span><span class="me2">operator</span> new<span class="br0">[</span><span class="br0">]</span><span class="br0">(</span><a href="http://en.cppreference.com/w/cpp/types/size_t"><span class="kw107">std::<span class="me2">size_t</span></span></a>, <span class="kw4">void</span><span class="sy2">*</span><span class="br0">)</span>.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx14">
<td> <p>The placement form <span class="kw4">void</span><span class="sy2">*</span> operator new<span class="br0">(</span><a href="http://en.cppreference.com/w/cpp/types/size_t"><span class="kw107">std::<span class="me2">size_t</span></span></a>, <a href="http://en.cppreference.com/w/cpp/types/size_t"><span class="kw107">std::<span class="me2">size_t</span></span></a><span class="br0">)</span> is not allowed because the matching signature of the deallocation function, <span class="kw4">void</span> <a href="http://en.cppreference.com/w/cpp/memory/new/operator_delete"><span class="kw690">operator delete</span></a><span class="br0">(</span><span class="kw4">void</span><span class="sy2">*</span>, <a href="http://en.cppreference.com/w/cpp/types/size_t"><span class="kw107">std::<span class="me2">size_t</span></span></a><span class="br0">)</span>, is a usual (not placement) deallocation function.</p>
</td> <td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr> </table> <h3 id="Class-specific_overloads"> Class-specific overloads</h3> <p>Both single-object and array allocation functions may be defined as public static member functions of a class (versions <span class="t-v">(<a href="#Version_15">15-18</a>)</span>). If defined, these allocation functions are called by <a href="../../language/new" title="cpp/language/new">new-expressions</a> to allocate memory for single objects and arrays of this class, unless the new expression used the form <span class="sy4">::</span><span class="me2">new</span> which bypasses class-scope lookup. The keyword <a href="../../keyword/static" title="cpp/keyword/static"><code>static</code></a> is optional for these functions: whether used or not, the allocation function is a static member function.</p>
<p>The new expression looks for appropriate allocation function's name firstly in the class scope, and after that in the global scope. Note, that as per <a href="../../language/lookup" title="cpp/language/lookup">name lookup rules</a>, any allocation functions declared in class scope hides all global allocation functions for the new-expressions that attempt to allocate objects of this class.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <p>When allocating objects and arrays of objects whose alignment exceeds <code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>, overload resolution is performed twice: first, for alignment-aware function signatures, then for alignment-unaware function signatures. This means that if a class with extended alignment has an alignment-unaware class-specific allocation function, it is the function that will be called, not the global alignment-aware allocation function. This is intentional: the class member is expected to know best how to handle that class.</p>
</td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>When allocating objects and arrays of objects whose alignment does not exceed <code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>, overload resolution is performed twice: first, for alignment-unaware function signatures, then for alignment-aware function signatures.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
 
// class-specific allocation functions
struct X
{
    static void* operator new(std::size_t count)
    {
        std::cout &lt;&lt; "custom new for size " &lt;&lt; count &lt;&lt; '\n';
        return ::operator new(count);
    }
 
    static void* operator new[](std::size_t count)
    {
        std::cout &lt;&lt; "custom new[] for size " &lt;&lt; count &lt;&lt; '\n';
        return ::operator new[](count);
    }
};
 
int main()
{
    X* p1 = new X;
    delete p1;
    X* p2 = new X[10];
    delete[] p2;
}</pre></div> <p>Possible output:</p>
<div class="text source-text"><pre data-language="c">custom new for size 1
custom new[] for size 10</pre></div> </div> <p>Overloads of <code>operator new</code> and <code>operator new[]</code> with additional user-defined parameters ("placement forms"), may also be defined as class members <span class="t-v">(<a href="#Version_19">19-22</a>)</span>). When the placement new expression with the matching signature looks for the corresponding allocation function to call, it begins at class scope before examining the global scope, and if the class-specific placement new is provided, it is called.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <p>When allocating objects and arrays of objects whose alignment exceeds <code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>, overload resolution for placement forms is performed twice just as for regular forms: first, for alignment-aware function signatures, then for alignment-unaware function signatures.</p>
</td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>When allocating objects and arrays of objects whose alignment does not exceed <code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>, overload resolution for placement forms is performed twice just as for regular forms: first, for alignment-unaware function signatures, then for alignment-aware function signatures.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
 
struct X
{
    X() { throw std::runtime_error(""); }
 
    // custom placement new
    static void* operator new(std::size_t count, bool b)
    {
        std::cout &lt;&lt; "custom placement new called, b = " &lt;&lt; b &lt;&lt; '\n';
        return ::operator new(count);
    }
 
    // custom placement delete
    static void operator delete(void* ptr, bool b)
    {
        std::cout &lt;&lt; "custom placement delete called, b = " &lt;&lt; b &lt;&lt; '\n';
        ::operator delete(ptr);
    }
};
 
int main()
{
    try
    {
        [[maybe_unused]] X* p1 = new (true) X;
    }
    catch (const std::exception&amp;)
    {}
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">custom placement new called, b = 1
custom placement delete called, b = 1</pre></div> </div> <p>If class-level <code>operator new</code> is a template function, it must have the return type of <span class="kw4">void</span><span class="sy2">*</span>, the first argument <code><a href="../../types/size_t" title="cpp/types/size t">std::size_t</a></code>, and it must have two or more parameters. In other words, only placement forms can be templates.</p>
<h3 id="Notes"> Notes</h3> <p>Even though the non-allocating placement new <span class="t-v">(<a href="#Version_9">9,10</a>)</span> cannot be replaced, a function with the same signature may be defined at class scope as described above. In addition, global overloads that look like placement new but take a non-void pointer type as the second argument are allowed, so the code that wants to ensure that the true placement new is called (e.g. <code><a href="../allocator/construct" title="cpp/memory/allocator/construct">std::allocator::construct</a></code>), must use <span class="sy4">::</span><span class="me2">new</span> and also cast the pointer to <span class="kw4">void</span><span class="sy2">*</span>.</p>
<p>If the behavior of a deallocation function does not satisfy the default constraints, the behavior is undefined.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>The following functions are required to be thread-safe:</p>
<ul>
<li> The library versions of <strong class="selflink"><code>operator new</code></strong> and <a href="operator_delete" title="cpp/memory/new/operator delete"><code>operator delete</code></a> </li>
<li> User replacement versions of global <strong class="selflink"><code>operator new</code></strong> and <a href="operator_delete" title="cpp/memory/new/operator delete"><code>operator delete</code></a> </li>
<li> <code><a href="../c/calloc" title="cpp/memory/c/calloc">std::calloc</a></code>, <code><a href="../c/malloc" title="cpp/memory/c/malloc">std::malloc</a></code>, <code><a href="../c/realloc" title="cpp/memory/c/realloc">std::realloc</a></code><span class="t-rev-inl t-since-cxx17"><span>, <code><a href="../c/aligned_alloc" title="cpp/memory/c/aligned alloc">std::aligned_alloc</a></code></span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span>, <code><a href="../c/free" title="cpp/memory/c/free">std::free</a></code> </li>
</ul> <p>Calls to these functions that allocate or deallocate a particular unit of storage occur in a single total order, and each such deallocation call <a href="../../atomic/memory_order" title="cpp/atomic/memory order">happens-before</a> the next allocation (if any) in this order.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <p>It is unspecified whether library versions of <code>operator new</code> make any calls to <code><a href="../c/malloc" title="cpp/memory/c/malloc">std::malloc</a></code><span class="t-rev-inl t-since-cxx17"><span> or <code><a href="../c/aligned_alloc" title="cpp/memory/c/aligned alloc">std::aligned_alloc</a></code></span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span>.</p>
<p>For loading a large file, file mapping via OS-specific functions, e.g. <a rel="nofollow" class="external text" href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/mmap.html"><code>mmap</code></a> on POSIX or <code>CreateFileMapping</code>(<a rel="nofollow" class="external text" href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga"><code>A</code></a>/<a rel="nofollow" class="external text" href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-createfilemappingw"><code>W</code></a>) along with <a rel="nofollow" class="external text" href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-mapviewoffile"><code>MapViewOfFile</code></a> on Windows, is preferable to allocating a buffer for file reading.</p>
<h3 id="Defect_Reports"> Defect Reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th> DR </th> <th> Applied to </th> <th> Behavior as published </th> <th> Correct behavior </th>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/521.html">CWG 521</a> </td> <td> C++98 </td> <td> any class derived from <code><a href="bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code> could be thrown,<br>even if the <code><a href="bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code> base is ambiguous or inaccessible </td> <td> the exception thrown should match<br>a handler of type <code><a href="bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code> </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue9">LWG 9</a> </td> <td> C++98 </td> <td> multiple calls for allocating zero<br>bytes could yield the same pointer </td> <td> only allowed if all such previously<br>yielded pointers have been<br>passed to deallocation functions </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue206">LWG 206</a> </td> <td> C++98 </td> <td> replacing the replaceable allocation functions did<br>not affect the default behaviors of the corresponding<br>replaceable non-throwing allocation functions </td> <td> the default behaviors<br>change accordingly </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue404">LWG 404</a> </td> <td> C++98 </td> <td> replacements of the replaceable allocation<br>functions could be declared <span class="kw1">inline</span> </td> <td> prohibited, no diagnostic required </td>
</tr>
</table> <h3 id="References"> References</h3>  <ul>
<li> C++23 standard (ISO/IEC 14882:2023): </li>
<ul><li> 17.7 Dynamic memory management [support.dynamic] </li></ul>
<li> C++20 standard (ISO/IEC 14882:2020): </li>
<ul><li> 17.6 Dynamic memory management [support.dynamic] </li></ul>
<li> C++17 standard (ISO/IEC 14882:2017): </li>
<ul><li> 21.6 Dynamic memory management [support.dynamic] </li></ul>
<li> C++14 standard (ISO/IEC 14882:2014): </li>
<ul><li> 18.6 Dynamic memory management [support.dynamic] </li></ul>
<li> C++11 standard (ISO/IEC 14882:2011): </li>
<ul><li> 18.6 Dynamic memory management [support.dynamic] </li></ul>
</ul>                   <h3 id="See_also"> See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="operator_delete" title="cpp/memory/new/operator delete"> <span class="t-lines"><span>operator delete</span><span>operator delete[]</span></span></a></div> </td> <td> deallocation functions <br> <span class="t-mark">(function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="get_new_handler" title="cpp/memory/new/get new handler"> <span class="t-lines"><span>get_new_handler</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> obtains the current new handler <br> <span class="t-mark">(function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="set_new_handler" title="cpp/memory/new/set new handler"> <span class="t-lines"><span>set_new_handler</span></span></a></div> </td> <td> registers a new handler <br> <span class="t-mark">(function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../get_temporary_buffer" title="cpp/memory/get temporary buffer"> <span class="t-lines"><span>get_temporary_buffer</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark">(deprecated in C++17)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span></span></div> </td> <td> obtains uninitialized storage <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../c/malloc" title="cpp/memory/c/malloc"> <span class="t-lines"><span>malloc</span></span></a></div> </td> <td> allocates memory <br> <span class="t-mark">(function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../c/aligned_alloc" title="cpp/memory/c/aligned alloc"> <span class="t-lines"><span>aligned_alloc</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> allocates aligned memory <br> <span class="t-mark">(function)</span>  </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    © cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/memory/new/operator_new" class="_attribution-link">https://en.cppreference.com/w/cpp/memory/new/operator_new</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
