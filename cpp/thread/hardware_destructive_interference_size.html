
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Std&#58;&#58;hardware_constructive_interference_size - C++ - W3cubDocs</title>
  
  <meta name="description" content=" These constants provide a portable way to access the L1 data cache line size. ">
  <meta name="keywords" content="std, hardware, destructive, interference, size, constructive, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/thread/hardware_destructive_interference_size.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-9c7b0d969c0ce639a6c01c2badcdd81667c7c66206aa3d0fccc5cb0585fb1b912dab72ea882101d18010680927514b4b77b107282db8f756fbf63301fe9c88b0.css">
  <script type="text/javascript" src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js"></script>
  <script src="/json/cpp.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _cppref">
				
				
<h1 id="firstHeading" class="firstHeading">std::hardware_destructive_interference_size, std::hardware_constructive_interference_size</h1>            <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th> Defined in header <code><a href="../header/new" title="cpp/header/new">&lt;new&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">inline constexpr std::size_t
    hardware_destructive_interference_size = /*implementation-defined*/;</pre>
</td> <td> (1) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">inline constexpr std::size_t
    hardware_constructive_interference_size = /*implementation-defined*/;</pre>
</td> <td> (2) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr>  </table> <div class="t-li1">
<span class="t-li">1)</span> Minimum offset between two objects to avoid false sharing. Guaranteed to be at least <code>alignof<span class="br0">(</span><a href="http://en.cppreference.com/w/cpp/types/max_align_t"><span class="kw111">std::<span class="me2">max_align_t</span></span></a><span class="br0">)</span></code> <div class="cpp source-cpp"><pre data-language="cpp">struct keep_apart {
  alignas(std::hardware_destructive_interference_size) std::atomic&lt;int&gt; cat;
  alignas(std::hardware_destructive_interference_size) std::atomic&lt;int&gt; dog;
};</pre></div>
</div> <div class="t-li1">
<span class="t-li">2)</span> Maximum size of contiguous memory to promote true sharing. Guaranteed to be at least <code>alignof<span class="br0">(</span><a href="http://en.cppreference.com/w/cpp/types/max_align_t"><span class="kw111">std::<span class="me2">max_align_t</span></span></a><span class="br0">)</span></code> <div class="cpp source-cpp"><pre data-language="cpp">struct together {
  std::atomic&lt;int&gt; dog;
  int puppy;
};
struct kennel {
  // Other data members...
  alignas(sizeof(together)) together pack;
  // Other data members...
};
static_assert(sizeof(together) &lt;= std::hardware_constructive_interference_size);</pre></div>
</div> <h3 id="Notes"> Notes</h3> <p>These constants provide a portable way to access the L1 data cache line size.</p>
<table class="wikitable ftm-begin ftm-has-value"> <tr> <th>
<a href="../utility/feature_test" title="cpp/utility/feature test">Feature-test</a> macro</th> <th>Value</th> <th>
<span title="Standard in which the feature is introduced">Std</span> </th>
</tr> <tr> <td><a href="../feature_test#Library_features" title="cpp/feature test"><code>__cpp_lib_hardware_interference_size</code></a></td> <td><span class="nu0">201703L</span></td> <td>
<span class="t-mark">(C++17)</span> </td>
</tr>
</table> <h3 id="Example"> Example</h3> <div class="t-example">
<p>The program uses two threads that write (atomically) to the data members of the given global objects. The first object fits in one cache line, which results in "hardware interference". The second object keeps its data members on separate cache lines, so possible "cache synchronization" after thread writes is avoided.</p>
<div class="cpp source-cpp"><pre data-language="cpp">#include &lt;atomic&gt;
#include &lt;chrono&gt;
#include &lt;cstddef&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;new&gt;
#include &lt;thread&gt;
 
#ifdef __cpp_lib_hardware_interference_size
    using std::hardware_constructive_interference_size;
    using std::hardware_destructive_interference_size;
#else
    // 64 bytes on x86-64 │ L1_CACHE_BYTES │ L1_CACHE_SHIFT │ __cacheline_aligned │ ...
    constexpr std::size_t hardware_constructive_interference_size = 64;
    constexpr std::size_t hardware_destructive_interference_size = 64;
#endif
 
std::mutex cout_mutex;
 
constexpr int max_write_iterations{10'000'000}; // the benchmark time tuning
 
struct alignas(hardware_constructive_interference_size)
OneCacheLiner { // occupies one cache line
    std::atomic_uint64_t x{};
    std::atomic_uint64_t y{};
} oneCacheLiner;
 
struct TwoCacheLiner { // occupies two cache lines
    alignas(hardware_destructive_interference_size) std::atomic_uint64_t x{};
    alignas(hardware_destructive_interference_size) std::atomic_uint64_t y{};
} twoCacheLiner;
 
inline auto now() noexcept { return std::chrono::high_resolution_clock::now(); }
 
template&lt;bool xy&gt;
void oneCacheLinerThread() {
    const auto start { now() };
 
    for (uint64_t count{}; count != max_write_iterations; ++count)
        if constexpr (xy)
             oneCacheLiner.x.fetch_add(1, std::memory_order_relaxed);
        else oneCacheLiner.y.fetch_add(1, std::memory_order_relaxed);
 
    const std::chrono::duration&lt;double, std::milli&gt; elapsed { now() - start };
    std::lock_guard lk{cout_mutex};
    std::cout &lt;&lt; "oneCacheLinerThread() spent " &lt;&lt; elapsed.count() &lt;&lt; " ms\n";
    if constexpr (xy)
         oneCacheLiner.x = elapsed.count();
    else oneCacheLiner.y = elapsed.count();
}
 
template&lt;bool xy&gt;
void twoCacheLinerThread() {
    const auto start { now() };
 
    for (uint64_t count{}; count != max_write_iterations; ++count)
        if constexpr (xy)
             twoCacheLiner.x.fetch_add(1, std::memory_order_relaxed);
        else twoCacheLiner.y.fetch_add(1, std::memory_order_relaxed);
 
    const std::chrono::duration&lt;double, std::milli&gt; elapsed { now() - start };
    std::lock_guard lk{cout_mutex};
    std::cout &lt;&lt; "twoCacheLinerThread() spent " &lt;&lt; elapsed.count() &lt;&lt; " ms\n";
    if constexpr (xy)
         twoCacheLiner.x = elapsed.count();
    else twoCacheLiner.y = elapsed.count();
}
 
int main() {
    std::cout &lt;&lt; "__cpp_lib_hardware_interference_size "
#   ifdef __cpp_lib_hardware_interference_size
        " = " &lt;&lt; __cpp_lib_hardware_interference_size &lt;&lt; '\n';
#   else
        "is not defined, use " &lt;&lt; hardware_destructive_interference_size &lt;&lt; " as fallback\n";
#   endif
 
    std::cout
        &lt;&lt; "hardware_destructive_interference_size == "
        &lt;&lt; hardware_destructive_interference_size &lt;&lt; '\n'
        &lt;&lt; "hardware_constructive_interference_size == "
        &lt;&lt; hardware_constructive_interference_size &lt;&lt; "\n\n";
 
    std::cout
        &lt;&lt; std::fixed &lt;&lt; std::setprecision(2)
        &lt;&lt; "sizeof( OneCacheLiner ) == " &lt;&lt; sizeof( OneCacheLiner ) &lt;&lt; '\n'
        &lt;&lt; "sizeof( TwoCacheLiner ) == " &lt;&lt; sizeof( TwoCacheLiner ) &lt;&lt; "\n\n";
 
    constexpr int max_runs{4};
 
    int oneCacheLiner_average{0};
    for (auto i{0}; i != max_runs; ++i) {
        std::thread th1{oneCacheLinerThread&lt;0&gt;};
        std::thread th2{oneCacheLinerThread&lt;1&gt;};
        th1.join(); th2.join();
        oneCacheLiner_average += oneCacheLiner.x + oneCacheLiner.y;
    }
    std::cout &lt;&lt; "Average T1 time: " &lt;&lt; (oneCacheLiner_average / max_runs / 2) &lt;&lt; " ms\n\n";
 
    int twoCacheLiner_average{0};
    for (auto i{0}; i != max_runs; ++i) {
        std::thread th1{twoCacheLinerThread&lt;0&gt;};
        std::thread th2{twoCacheLinerThread&lt;1&gt;};
        th1.join(); th2.join();
        twoCacheLiner_average += twoCacheLiner.x + twoCacheLiner.y;
    }
    std::cout &lt;&lt; "Average T2 time: " &lt;&lt; (twoCacheLiner_average / max_runs / 2) &lt;&lt; " ms\n\n";
 
    std::cout &lt;&lt; "Ratio T1/T2:~ " &lt;&lt; 1.*oneCacheLiner_average/twoCacheLiner_average &lt;&lt; '\n';
}</pre></div> <p>Possible output:</p>
<div class="text source-text"><pre data-language="c">__cpp_lib_hardware_interference_size is not defined, use 64 as fallback
hardware_destructive_interference_size == 64
hardware_constructive_interference_size == 64
 
sizeof( OneCacheLiner ) == 64
sizeof( TwoCacheLiner ) == 128
 
oneCacheLinerThread() spent 634.25 ms
oneCacheLinerThread() spent 651.55 ms
oneCacheLinerThread() spent 990.23 ms
oneCacheLinerThread() spent 1033.94 ms
oneCacheLinerThread() spent 838.14 ms
oneCacheLinerThread() spent 883.25 ms
oneCacheLinerThread() spent 873.02 ms
oneCacheLinerThread() spent 914.26 ms
Average T1 time: 852 ms
 
twoCacheLinerThread() spent 119.22 ms
twoCacheLinerThread() spent 127.91 ms
twoCacheLinerThread() spent 114.17 ms
twoCacheLinerThread() spent 126.41 ms
twoCacheLinerThread() spent 125.17 ms
twoCacheLinerThread() spent 126.06 ms
twoCacheLinerThread() spent 117.94 ms
twoCacheLinerThread() spent 129.03 ms
Average T2 time: 122 ms
 
Ratio T1/T2:~ 6.98</pre></div> </div> <h3 id="See_also"> See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="thread/hardware_concurrency" title="cpp/thread/thread/hardware concurrency"> <span class="t-lines"><span>hardware_concurrency</span></span></a></div>
<div><span class="t-lines"><span><span class="t-cmark">[static]</span></span></span></div> </td> <td> returns the number of concurrent threads supported by the implementation <br> <span class="t-mark">(public static member function of <code>std::thread</code>)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="jthread/hardware_concurrency" title="cpp/thread/jthread/hardware concurrency"> <span class="t-lines"><span>hardware_concurrency</span></span></a></div>
<div><span class="t-lines"><span><span class="t-cmark">[static]</span></span></span></div> </td> <td> returns the number of concurrent threads supported by the implementation <br> <span class="t-mark">(public static member function of <code>std::jthread</code>)</span>  </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    © cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/thread/hardware_destructive_interference_size" class="_attribution-link">https://en.cppreference.com/w/cpp/thread/hardware_destructive_interference_size</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
