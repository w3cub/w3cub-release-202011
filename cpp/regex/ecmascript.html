
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Modified ECMAScript Regular Expression Grammar - C++ - W3cubDocs</title>
  
  <meta name="description" content="This page describes the regular expression grammar that is used when std&#58;&#58;basic_regex is constructed with syntax_option_type set to &hellip;">
  <meta name="keywords" content="modified, ecmascript, regular, expression, grammar, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/regex/ecmascript.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-1810d67ab7e57be09d8247710d2feb6954566959eb82322d1fee3a0c9156f56974b78ebaa9928774f00767342bbe58b0799d91fcc336b92b319170b196f9b64b.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/cpp.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _c">
				
				
<h1 id="firstHeading" class="firstHeading">Modified ECMAScript regular expression grammar</h1>            <p>This page describes the regular expression grammar that is used when <code><a href="basic_regex" title="cpp/regex/basic regex">std::basic_regex</a></code> is constructed with <a href="syntax_option_type" title="cpp/regex/syntax option type"><code>syntax_option_type</code></a> set to <code>ECMAScript</code> (the default). See <a href="syntax_option_type" title="cpp/regex/syntax option type"><code>syntax_option_type</code></a> for the other supported regular expression grammars.</p>
<p>The <code>ECMAScript</code> 3 regular expression grammar in C++ is <a rel="nofollow" class="external text" href="http://ecma-international.org/ecma-262/5.1/#sec-15.10">ECMA-262 grammar</a> with modifications marked with <span class="t-mark">(C++ only)</span> below.</p>
<h3 id="Overview"> Overview</h3> <p>The <a rel="nofollow" class="external text" href="https://eel.is/c++draft/re.grammar">modified regular expression grammar</a> is mostly ECMAScript RegExp grammar with a POSIX-type expansion on locales under <i>ClassAtom</i>. Some clarifications on equality checks and number parsing is made. For many of the examples here, you can try this equivalent in your browser console:</p>
<div class="javascript source-javascript"><pre data-language="c">function match(s, re) { return s.match(new RegExp(re)); }</pre></div> <p>The "normative references" in the standard specifies ECMAScript 3. We link to the ECMAScript 5.1 spec here because it is a version with only minor changes from ECMAScript 3, and it also has an HTML version. See the <a rel="nofollow" class="external text" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions">MDN Guide on JavaScript RegExp</a> for an overview on the dialect features.</p>
<h3 id="Alternatives"> Alternatives</h3> <p>A regular expression pattern is sequence of one or more <i>Alternative</i>s, separated by the disjunction operator <code>|</code> (in other words, the disjunction operator has the lowest precedence).</p>
<p><i>Pattern</i> ::</p>
<i>Disjunction</i>  <p><i>Disjunction</i> ::</p>
<dl>
<dd>
<i>Alternative</i> </dd>
<dd>
<i>Alternative</i> <code>|</code> <i>Disjunction</i> </dd>
</dl> <p>The pattern first tries to skip the <i>Disjunction</i> and match the left <i>Alternative</i> followed by the rest of the regular expression (after the Disjunction).</p>
<p>If it fails, it tries to skip the left <i>Alternative</i> and match the right <i>Disjunction</i> (followed by the rest of the regular expression).</p>
<p>If the left <i>Alternative</i>, the right <i>Disjunction</i>, and the remainder of the regular expression all have choice points, all choices in the remainder of the expression are tried before moving on to the next choice in the left <i>Alternative</i>. If choices in the left <i>Alternative</i> are exhausted, the right <i>Disjunction</i> is tried instead of the left <i>Alternative</i>.</p>
<p>Any capturing parentheses inside a skipped <i>Alternative</i> produce empty submatches.</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;regex&gt;
 
void show_matches(const std::string&amp; in, const std::string&amp; re)
{
    std::smatch m;
    std::regex_search(in, m, std::regex(re));
    if(!m.empty()) {
        std::cout &lt;&lt; "input=[" &lt;&lt; in &lt;&lt; "], regex=[" &lt;&lt; re &lt;&lt; "]\n  "
                     "prefix=[" &lt;&lt; m.prefix() &lt;&lt; "]\n  smatch: ";
        for(std::size_t n = 0; n &lt; m.size(); ++n)
            std::cout &lt;&lt; "m[" &lt;&lt; n &lt;&lt; "]=[" &lt;&lt; m[n] &lt;&lt; "] ";
        std::cout &lt;&lt; "\n  suffix=[" &lt;&lt; m.suffix() &lt;&lt; "]\n";
    } else {
        std::cout &lt;&lt; "input=[" &lt;&lt; in &lt;&lt; "], regex=[" &lt;&lt; re &lt;&lt; "]: NO MATCH\n";
    }
}
 
int main()
{
    show_matches("abcdef", "abc|def");
    show_matches("abc", "ab|abc"); // left Alernative matched first
 
    // Match of the input against the left Alternative (a) followed
    // by the remained of the regex (c|bc) succeeds, which results
    // in m[1]="a" and m[4]="bc".
    // The skipped Alternatives (ab) and (c) leave their submatches
    // m[3] and m[5] empty.
    show_matches("abc", "((a)|(ab))((c)|(bc))");
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">input=[abcdef], regex=[abc|def]
  prefix=[]
  smatch: m[0]=[abc]
  suffix=[def]
input=[abc], regex=[ab|abc]
  prefix=[]
  smatch: m[0]=[ab]
  suffix=[c]
input=[abc], regex=[((a)|(ab))((c)|(bc))]
  prefix=[]
  smatch: m[0]=[abc] m[1]=[a] m[2]=[a] m[3]=[] m[4]=[bc] m[5]=[] m[6]=[bc]
  suffix=[]</pre></div> </div> <h3 id="Terms"> Terms</h3> <p>Each <i>Alternative</i> is either empty or is a sequence of <i>Term</i>s (with no separators between the <i>Term</i>s).</p>
<p><i>Alternative</i> ::</p>
<dl>
<dd> <i>[empty]</i> </dd>
<dd> <i>Alternative</i> <i>Term</i> </dd>
</dl> <p>Empty <i>Alternative</i> always matches and does not consume any input.</p>
<p>Consecutive <i>Term</i>s try to simultaneously match consecutive portions of the input.</p>
<p>If the left <i>Alternative</i>, the right <i>Term</i>, and the remainder of the regular expression all have choice points, all choices in the remained of the expression are tried before moving on to the next choice in the right <i>Term</i>, and all choices in the right <i>Term</i> are tried before moving on to the next choice in the left <i>Alternative</i>.</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;regex&gt;
 
void show_matches(const std::string&amp; in, const std::string&amp; re)
{
    std::smatch m;
    std::regex_search(in, m, std::regex(re));
    if(!m.empty()) {
        std::cout &lt;&lt; "input=[" &lt;&lt; in &lt;&lt; "], regex=[" &lt;&lt; re &lt;&lt; "]\n  "
                     "prefix=[" &lt;&lt; m.prefix() &lt;&lt; "]\n  smatch: ";
        for(std::size_t n = 0; n &lt; m.size(); ++n)
            std::cout &lt;&lt; "m[" &lt;&lt; n &lt;&lt; "]=[" &lt;&lt; m[n] &lt;&lt; "] ";
        std::cout &lt;&lt; "\n  suffix=[" &lt;&lt; m.suffix() &lt;&lt; "]\n";
    } else {
        std::cout &lt;&lt; "input=[" &lt;&lt; in &lt;&lt; "], regex=[" &lt;&lt; re &lt;&lt; "]: NO MATCH\n";
    }
}
 
int main()
{
    show_matches("abcdef", ""); // empty regex is a single empty Alternative
    show_matches("abc", "abc|"); // left Alernative matched first
    show_matches("abc", "|abc"); // left Alernative matched first, leaving abc unmatched
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">input=[abcdef], regex=[]
  prefix=[]
  smatch: m[0]=[]
  suffix=[abcdef]
input=[abc], regex=[abc|]
  prefix=[]
  smatch: m[0]=[abc]
  suffix=[]
input=[abc], regex=[|abc]
  prefix=[]
  smatch: m[0]=[]
  suffix=[abc]</pre></div> </div> <h3 id="Quantifiers"> Quantifiers</h3> <ul><li> Each <i>Term</i> is either an <i>Assertion</i> (see below), or an <i>Atom</i> (see below), or an <i>Atom</i> immediately followed by a <i>Quantifier</i> </li></ul> <p><i>Term</i> ::</p>
<dl>
<dd> <i>Assertion</i> </dd>
<dd> <i>Atom</i> </dd>
<dd> <i>Atom</i> <i>Quantifier</i> </dd>
</dl> <p>Each <i>Quantifier</i> is either a <i>greedy</i> quantifier (which consists of just one <i>QuantifierPrefix</i>) or a <i>non-greedy</i> quantifier (which consists of one <i>QuantifierPrefix</i> followed by the question mark <code>?</code>).</p>
<p><i>Quantifier</i> ::</p>
<dl>
<dd> <i>QuantifierPrefix</i> </dd>
<dd> <i>QuantifierPrefix</i> <code>?</code> </dd>
</dl> <p>Each <i>QuantifierPrefix</i> determines two numbers: the minimum number of repetitions and the maximum number of repetitions, as follows:</p>
<table class="wikitable"> <tr> <th>QuantifierPrefix</th> <th>Minimum</th> <th>Maximum </th>
</tr> <tr> <td> <code>*</code> </td> <td> zero </td> <td> infinity </td>
</tr> <tr> <td> <code>+</code> </td> <td> one </td> <td> infinity </td>
</tr> <tr> <td> <code>?</code> </td> <td> zero </td> <td> one </td>
</tr> <tr> <td> <code>{ </code> <i>DecimalDigits</i> <code>} </code> </td> <td> value of DecimalDigits </td> <td> value of DecimalDigits </td>
</tr> <tr> <td> <code>{</code> <i>DecimalDigits</i> <code>,</code> <code>} </code> </td> <td> value of DecimalDigits </td> <td> infinity </td>
</tr> <tr> <td> <code>{</code> <i>DecimalDigits</i> <code>,</code> <i>DecimalDigits</i> <code>} </code> </td> <td> value of DecimalDigits before the comma </td> <td> value of DecimalDigits after the comma </td>
</tr>
</table> <p>The values of the individual <i>DecimalDigits</i> are obtained by calling <code><a href="regex_traits/value" title="cpp/regex/regex traits/value">std::regex_traits::value</a></code><span class="t-mark">(C++ only)</span> on each of the digits.</p>
<p>An <i>Atom</i> followed by a <i>Quantifier</i> is repeated the number of times specified by the <i>Quantifier</i>. A <i>Quantifier</i> can be <i>non-greedy</i>, in which case the <i>Atom</i> pattern is repeated as few times as possible while still matching the remainder of the regular expression, or it can be <i>greedy</i>, in which case the <i>Atom</i> pattern is repeated as many times as possible while still matching the remainder of the regular expression.</p>
<p>The <i>Atom</i> pattern is what is repeated, not the input that it matches, so different repetitions of the <i>Atom</i> can match different input substrings.</p>
<p>If the <i>Atom</i> and the remainder of the regular expression all have choice points, the <i>Atom</i> is first matched as many (or as few, if <i>non-greedy</i>) times as possible. All choices in the remainder of the regular expression are tried before moving on to the next choice in the last repetition of <i>Atom</i>. All choices in the last (nth) repetition of <i>Atom</i> are tried before moving on to the next choice in the next-to-last (n–1)st repetition of <i>Atom</i>; at which point it may turn out that more or fewer repetitions of <i>Atom</i> are now possible; these are exhausted (again, starting with either as few or as many as possible) before moving on to the next choice in the (n-1)st repetition of <i>Atom</i> and so on.</p>
<p>The <i>Atom'</i>s captures are cleared each time it is repeated (see the <code>"(z)((a+)?(b+)?(c))*"</code> example below).</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;regex&gt;
 
void show_matches(const std::string&amp; in, const std::string&amp; re)
{
    std::smatch m;
    std::regex_search(in, m, std::regex(re));
    if(!m.empty()) {
        std::cout &lt;&lt; "input=[" &lt;&lt; in &lt;&lt; "], regex=[" &lt;&lt; re &lt;&lt; "]\n  "
                     "prefix=[" &lt;&lt; m.prefix() &lt;&lt; "]\n  smatch: ";
        for(std::size_t n = 0; n &lt; m.size(); ++n)
            std::cout &lt;&lt; "m[" &lt;&lt; n &lt;&lt; "]=[" &lt;&lt; m[n] &lt;&lt; "] ";
        std::cout &lt;&lt; "\n  suffix=[" &lt;&lt; m.suffix() &lt;&lt; "]\n";
    } else {
        std::cout &lt;&lt; "input=[" &lt;&lt; in &lt;&lt; "], regex=[" &lt;&lt; re &lt;&lt; "]: NO MATCH\n";
    }
}
 
int main()
{
    // greedy match, repeats [a-z] 4 times
    show_matches("abcdefghi", "a[a-z]{2,4}");
    // non-greedy match, repeats [a-z] 2 times
    show_matches("abcdefghi", "a[a-z]{2,4}?");
 
    // Choice point ordering for quantifiers results in a match
    // with two repetitions, first matching the substring "aa",
    // second matching the substring "ba", leaving "ac" not matched
    // ("ba" appears in the capture clause m[1])
    show_matches("aabaac", "(aa|aabaac|ba|b|c)*");
 
    // Choice point ordering for quantifiers makes this regex 
    // calculate the greatest common divisor between 10 and 15
    // (the answer is 5, and it populates m[1] with "aaaaa")
    show_matches("aaaaaaaaaa,aaaaaaaaaaaaaaa", "^(a+)\\1*,\\1+$");
 
    // the substring "bbb" does not appear in the capture clause m[4]
    // because it is cleared when the second repetition of the atom
    // (a+)?(b+)?(c) is matching the substring "ac"
    // NOTE: gcc gets this wrong - it does not correctly clear the
    // matches[4] capture group as required by ECMA-262 21.2.2.5.1,
    // and thus incorrectly captures "bbb" for that group.
    show_matches("zaacbbbcac", "(z)((a+)?(b+)?(c))*");
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">input=[abcdefghi], regex=[a[a-z]{2,4}]
  prefix=[]
  smatch: m[0]=[abcde]
  suffix=[fghi]
input=[abcdefghi], regex=[a[a-z]{2,4}?]
  prefix=[]
  smatch: m[0]=[abc]
  suffix=[defghi]
input=[aabaac], regex=[(aa|aabaac|ba|b|c)*]
  prefix=[]
  smatch: m[0]=[aaba] m[1]=[ba]
  suffix=[ac]
input=[aaaaaaaaaa,aaaaaaaaaaaaaaa], regex=[^(a+)\1*,\1+$]
  prefix=[]
  smatch: m[0]=[aaaaaaaaaa,aaaaaaaaaaaaaaa] m[1]=[aaaaa]
  suffix=[]
input=[zaacbbbcac], regex=[(z)((a+)?(b+)?(c))*]
  prefix=[]
  smatch: m[0]=[zaacbbbcac] m[1]=[z] m[2]=[ac] m[3]=[a] m[4]=[] m[5]=[c] 
  suffix=[]</pre></div> </div> <h3 id="Assertions"> Assertions</h3> <p><i>Assertion</i>s match conditions, rather than substrings of the input string. They never consume any characters from the input. Each <i>Assertion</i> is one of the following.</p>
<p><i>Assertion</i> ::</p>
<dl>
<dd> <code>^</code> </dd>
<dd> <code>$</code> </dd>
<dd> <code>\</code> <code>b</code> </dd>
<dd> <code>\</code> <code>B</code> </dd>
<dd> <code>(</code> <code>?</code> <code>=</code> <i>Disjunction</i> <code>)</code> </dd>
<dd> <code>(</code> <code>?</code> <code>!</code> <i>Disjunction</i> <code>)</code> </dd>
</dl> <p>The assertion <code>^</code> (beginning of line) matches.</p>
<div class="t-li1">
<span class="t-li">1)</span> The position that immediately follows a <i>LineTerminator</i> character <span class="t-rev-inl t-until-cxx17"><span>(this may not be supported)</span> <span><span class="t-mark-rev t-until-cxx17">(until C++17)</span></span></span><span class="t-rev-inl t-since-cxx17"><span> (this is only guaranteed if <a href="syntax_option_type" title="cpp/regex/syntax option type"><code>std::regex_constants::multiline</code></a><span class="t-mark">(C++ only)</span> is enabled)</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span>
</div> <div class="t-li1">
<span class="t-li">2)</span> The beginning of the input (unless <code><a href="match_flag_type" title="cpp/regex/match flag type">std::regex_constants::match_not_bol</a></code><span class="t-mark">(C++ only)</span> is enabled)</div> <p>The assertion <code>$</code> (end of line) matches.</p>
<div class="t-li1">
<span class="t-li">1)</span> The position of a <i>LineTerminator</i> character <span class="t-rev-inl t-until-cxx17"><span>(this may not be supported)</span> <span><span class="t-mark-rev t-until-cxx17">(until C++17)</span></span></span><span class="t-rev-inl t-since-cxx17"><span>(this is only guaranteed if <a href="syntax_option_type" title="cpp/regex/syntax option type"><code>std::regex_constants::multiline</code></a><span class="t-mark">(C++ only)</span> is enabled)</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span>
</div> <div class="t-li1">
<span class="t-li">2)</span> The end of the input (unless <code><a href="match_flag_type" title="cpp/regex/match flag type">std::regex_constants::match_not_eol</a></code><span class="t-mark">(C++ only)</span> is enabled)</div> <p>In the two assertions above and in the Atom <code>.</code> below, <i>LineTerminator</i> is one of the following four characters: <code>U+000A</code> (<code>\n</code> or line feed), <code>U+000D</code> (<code>\r</code> or carriage return), <code>U+2028</code> (line separator), or <code>U+2029</code> (paragraph separator).</p>
<p>The assertion <code>\b</code> (word boundary) matches.</p>
<div class="t-li1">
<span class="t-li">1)</span> The beginning of a word (current character is a letter, digit, or underscore, and the previous character is not)</div> <div class="t-li1">
<span class="t-li">2)</span> The end of a word (current character is not a letter, digit, or underscore, and the previous character is one of those)</div> <div class="t-li1">
<span class="t-li">3)</span> The beginning of input if the first character is a letter, digit, or underscore (unless <code><a href="match_flag_type" title="cpp/regex/match flag type">std::regex_constants::match_not_bow</a></code><span class="t-mark">(C++ only)</span> is enabled)</div> <div class="t-li1">
<span class="t-li">4)</span> The end of input if the last character is a letter, digit, or underscore (unless <code><a href="match_flag_type" title="cpp/regex/match flag type">std::regex_constants::match_not_eow</a></code><span class="t-mark">(C++ only)</span> is enabled)</div> <p>The assertion <code>\B</code> (negative word boundary) matches everything EXCEPT the following.</p>
<div class="t-li1">
<span class="t-li">1)</span> The beginning of a word (current character is a letter, digit, or underscore, and the previous character is not one of those or does not exist)</div> <div class="t-li1">
<span class="t-li">2)</span> The end of a word (current character is not a letter, digit, or underscore (or the matcher is at the end of input), and the previous character is one of those)</div> <p>The assertion <code>(</code> <code>?</code> <code>=</code> <i>Disjunction</i> <code>)</code> (zero-width positive lookahead) matches if <i>Disjunction</i> would match the input at the current position.</p>
<p>The assertion <code>(</code> <code>?</code> <code>!</code> <i>Disjunction</i> <code>)</code> (zero-width negative lookahead) matches if <i>Disjunction</i> would NOT match the input at the current position.</p>
<p>For both Lookahead assertions, when matching the <i>Disjunction</i>, the position is not advanced before matching the remainder of the regular expression. Also, if <i>Disjunction</i> can match at the current position in several ways, only the first one is tried.</p>
<p>ECMAScript forbids backtracking into the lookahead Disjunctions, which affects the behavior of backreferences into a positive lookahead from the remainder of the regular expression (see example below). Backreferences into the negative lookahead from the rest of the regular expression are always undefined (since the lookahead Disjunction must fail to proceed).</p>
<p>Note: Lookahead assertions may be used to create logical AND between multiple regular expressions (see example below).</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;regex&gt;
 
void show_matches(const std::string&amp; in, const std::string&amp; re)
{
    std::smatch m;
    std::regex_search(in, m, std::regex(re));
    if(!m.empty()) {
        std::cout &lt;&lt; "input=[" &lt;&lt; in &lt;&lt; "], regex=[" &lt;&lt; re &lt;&lt; "]\n  "
                     "prefix=[" &lt;&lt; m.prefix() &lt;&lt; "]\n  smatch: ";
        for(std::size_t n = 0; n &lt; m.size(); ++n)
            std::cout &lt;&lt; "m[" &lt;&lt; n &lt;&lt; "]=[" &lt;&lt; m[n] &lt;&lt; "] ";
        std::cout &lt;&lt; "\n  suffix=[" &lt;&lt; m.suffix() &lt;&lt; "]\n";
    } else {
        std::cout &lt;&lt; "input=[" &lt;&lt; in &lt;&lt; "], regex=[" &lt;&lt; re &lt;&lt; "]: NO MATCH\n";
    }
}
 
int main()
{
    // matches the a at the end of input
    show_matches("aaa", "a$");
 
    // matches the o at the end of the first word
    show_matches("moo goo gai pan", "o\\b");
 
    // the lookahead matches the empty string immediately after the first b
    // this populates m[1] with "aaa" although m[0] is empty
    show_matches("baaabac", "(?=(a+))");
 
    // because backtracking into lookaheads is prohibited, 
    // this matches aba rather than aaaba
    show_matches("baaabac", "(?=(a+))a*b\\1");
 
    // logical AND via lookahead: this password matches IF it contains
    // at least one lowercase letter
    // AND at least one uppercase letter
    // AND at least one punctuation character
    // AND be at least 6 characters long
    show_matches("abcdef", "(?=.*[[:lower:]])(?=.*[[:upper:]])(?=.*[[:punct:]]).{6,}");
    show_matches("aB,def", "(?=.*[[:lower:]])(?=.*[[:upper:]])(?=.*[[:punct:]]).{6,}");
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">input=[aaa], regex=[a$]
  prefix=[aa]
  smatch: m[0]=[a] 
  suffix=[]
input=[moo goo gai pan], regex=[o\b]
  prefix=[mo]
  smatch: m[0]=[o] 
  suffix=[ goo gai pan]
input=[baaabac], regex=[(?=(a+))]
  prefix=[b]
  smatch: m[0]=[] m[1]=[aaa] 
  suffix=[aaabac]
input=[baaabac], regex=[(?=(a+))a*b\1]
  prefix=[baa]
  smatch: m[0]=[aba] m[1]=[a] 
  suffix=[c]
input=[abcdef], regex=[(?=.*[[:lower:]])(?=.*[[:upper:]])(?=.*[[:punct:]]).{6,}]: NO MATCH
input=[aB,def], regex=[(?=.*[[:lower:]])(?=.*[[:upper:]])(?=.*[[:punct:]]).{6,}]
  prefix=[]
  smatch: m[0]=[aB,def] 
  suffix=[]</pre></div> </div> <h3 id="Atoms"> Atoms</h3> <p>An <i>Atom</i> can be one of the following:</p>
<p><i>Atom</i> ::</p>
<dl>
<dd> <i>PatternCharacter</i> </dd>
<dd> <code>.</code> </dd>
<dd> <code>\</code> <i>AtomEscape</i> </dd>
<dd> <i>CharacterClass</i> </dd>
<dd> <code>(</code> <i>Disjunction</i> <code>)</code> </dd>
<dd> <code>(</code> <code>?</code> <code>:</code> <i>Disjunction</i> <code>)</code> </dd>
</dl> <p>where <i>AtomEscape</i> ::</p>
<dl>
<dd> <i>DecimalEscape</i> </dd>
<dd> <i>CharacterEscape</i> </dd>
<dd> <i>CharacterClassEscape</i> </dd>
</dl> <p>Different kinds of atoms evaluate differently.</p>
<h3 id="Sub-expressions"> Sub-expressions</h3> <p>The <i>Atom</i> <code>(</code> <i>Disjunction</i> <code>)</code> is a marked subexpression: it executes the <i>Disjunction</i> and stores the copy of the input substring that was consumed by <i>Disjunction</i> in the submatch array at the index that corresponds to the number of times the left open parenthesis <code>(</code> of marked subexpressions has been encountered in the entire regular expression at this point.</p>
<p>Besides being returned in the <code><a href="match_results" title="cpp/regex/match results">std::match_results</a></code>, the captured submatches are accessible as backreferences (<code>\1</code>, <code>\2</code>, ...) and can be referenced in regular expressions. Note that <code><a href="regex_replace" title="cpp/regex/regex replace">std::regex_replace</a></code> uses <code>$</code> instead of <code>\</code> for backreferences (<code>$1</code>, <code>$2</code>, ...) in the same manner as <code>String.prototype.replace</code> (ECMA-262, part 15.5.4.11).</p>
<p>The <i>Atom</i> <code>(</code> <code>?</code> <code>:</code> <i>Disjunction</i> <code>)</code> (non-marking subexpression) simply evaluates the <i>Disjunction</i> and does not store its results in the submatch. This is a purely lexical grouping.</p>
<h3 id="Backreferences"> Backreferences</h3> <p><i>DecimalEscape</i> ::</p>
<i>DecimalIntegerLiteral</i> [<i>lookahead</i> ∉ <i>DecimalDigit</i>]  <p>If <code>\</code> is followed by a decimal number <code>N</code> whose first digit is not <code>0</code>, then the escape sequence is considered to be a <i>backreference</i>. The value <code>N</code> is obtained by calling <code><a href="regex_traits/value" title="cpp/regex/regex traits/value">std::regex_traits::value</a></code><span class="t-mark">(C++ only)</span> on each of the digits and combining their results using base-10 arithmetic. It is an error if <code>N</code> is greater than the total number of left capturing parentheses in the entire regular expression.</p>
<p>When a backreference <code>\N</code> appears as an <i>Atom</i>, it matches the same substring as what is currently stored in the N'th element of the submatch array.</p>
<p>The decimal escape <code>\0</code> is NOT a backreference: it is a character escape that represents the <a href="../language/ascii" title="cpp/language/ascii"> <code>NUL</code></a> character. It cannot be followed by a decimal digit.</p>
<p>As above, note that <code><a href="regex_replace" title="cpp/regex/regex replace">std::regex_replace</a></code> uses <code>$</code> instead of <code>\</code> for backreferences (<code>$1</code>, <code>$2</code>, ...).</p>
<h3 id="Single_character_matches"> Single character matches</h3> <p>The <i>Atom</i> <code>.</code> matches and consumes any one character from the input string except for <i>LineTerminator</i> (<code>U+000D</code>, <code>U+000A</code>, <code>U+2029</code>, or <code>U+2028</code>).</p>
<p>The <i>Atom</i> <i>PatternCharacter</i>, where <i>PatternCharacter</i> is any <i>SourceCharacter</i> EXCEPT the characters <code>^ $ \ . * + ? ( ) [ ] { } |</code>, matches and consumes one character from the input if it is equal to this <i>PatternCharacter</i>.</p>
<p>The equality for this and all other single character matches is defined as follows:</p>
<div class="t-li1">
<span class="t-li">1)</span> If <code><a href="syntax_option_type" title="cpp/regex/syntax option type">std::regex_constants::icase</a></code> is set, the characters are equal if the return values of <code><a href="regex_traits/translate_nocase" title="cpp/regex/regex traits/translate nocase">std::regex_traits::translate_nocase</a></code> are equal <span class="t-mark">(C++ only)</span>.</div> <div class="t-li1">
<span class="t-li">2)</span> Otherwise, if <code><a href="syntax_option_type" title="cpp/regex/syntax option type">std::regex_constants::collate</a></code> is set, the characters are equal if the return values of <code><a href="regex_traits/translate" title="cpp/regex/regex traits/translate">std::regex_traits::translate</a></code> are equal <span class="t-mark">(C++ only)</span>.</div> <div class="t-li1">
<span class="t-li">3)</span> Otherwise, the characters are equal if <code>operator==</code> returns <code>true</code>.</div> <p>Each <i>Atom</i> that consists of the escape character <code>\</code> followed by <i>CharacterEscape</i> as well as the special DecimalEscape <code>\0</code>, matches and consumes one character from the input if it is equal to the character represented by the <i>CharacterEscape</i>. The following character escape sequences are recognized:</p>
<p><i>CharacterEscape</i> ::</p>
<dl>
<dd> <i>ControlEscape</i> </dd>
<dd> <code>c</code> <i>ControlLetter</i> </dd>
<dd> <i>HexEscapeSequence</i> </dd>
<dd> <i>UnicodeEscapeSequence</i> </dd>
<dd> <i>IdentityEscape</i> </dd>
</dl> <p>Here, <i>ControlEscape</i> is one of the following five characters: <code>f n r t v</code>.</p>
<table class="wikitable"> <tr> <th>ControlEscape</th> <th>Code Unit</th> <th>Name </th>
</tr> <tr> <td> <code>f</code> </td> <td> U+000C </td> <td> form feed </td>
</tr> <tr> <td> <code>n</code> </td> <td> U+000A </td> <td> new line </td>
</tr> <tr> <td> <code>r</code> </td> <td> U+000D </td> <td> carriage return </td>
</tr> <tr> <td> <code>t</code> </td> <td> U+0009 </td> <td> horizontal tab </td>
</tr> <tr> <td> <code>v</code> </td> <td> U+000B </td> <td> vertical tab </td>
</tr>
</table> <p><i>ControlLetter</i> is any lowercase or uppercase ASCII letters and this character escape matches the character whose code unit equals the remainder of dividing the value of the code unit of <i>ControlLetter</i> by <code>32</code>. For example, <code>\cD</code> and <code>\cd</code> both match code unit <code>U+0004</code> (EOT) because 'D' is <code>U+0044</code> and <code>0x44 % 32 == 4</code>, and 'd' is <code>U+0064</code> and <code>0x64 % 32 == 4</code>.</p>
<p><i>HexEscapeSequence</i> is the letter <code>x</code> followed by exactly two <i>HexDigit</i>s (where <i>HexDigit</i> is one of <code>0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F</code>). This character escape matches the character whose code unit equals the numeric value of the two-digit hexadecimal number.</p>
<p><i>UnicodeEscapeSequence</i> is the letter <code>u</code> followed by exactly four <i>HexDigit</i>s. This character escape matches the character whose code unit equals the numeric value of this four-digit hexadecimal number. If the value does not fit in this <code><a href="basic_regex" title="cpp/regex/basic regex">std::basic_regex</a></code>'s <code>CharT</code>, <code><a href="regex_error" title="cpp/regex/regex error">std::regex_error</a></code> is thrown <span class="t-mark">(C++ only)</span>.</p>
<p><i>IdentityEscape</i> can be any non-alphanumeric character: for example, another backslash. It matches the character as-is.</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;regex&gt;
 
void show_matches(const std::wstring&amp; in, const std::wstring&amp; re)
{
    std::wsmatch m;
    std::regex_search(in, m, std::wregex(re));
    if(!m.empty()) {
        std::wcout &lt;&lt; L"input=[" &lt;&lt; in &lt;&lt; L"], regex=[" &lt;&lt; re &lt;&lt; L"]\n  "
                      L"prefix=[" &lt;&lt; m.prefix() &lt;&lt; L"]\n  wsmatch: ";
        for(std::size_t n = 0; n &lt; m.size(); ++n)
            std::wcout &lt;&lt; L"m[" &lt;&lt; n &lt;&lt; L"]=[" &lt;&lt; m[n] &lt;&lt; L"] ";
        std::wcout &lt;&lt; L"\n  suffix=[" &lt;&lt; m.suffix() &lt;&lt; L"]\n";
    } else {
        std::wcout &lt;&lt; L"input=[" &lt;&lt; in &lt;&lt; "], regex=[" &lt;&lt; re &lt;&lt; L"]: NO MATCH\n";
    }
}
 
int main()
{
    // Most escapes are similar to C++, save for metacharacters. You will have to
    // double-escape or use raw strings on the slashes though.
    show_matches(L"C++\\", LR"(C\+\+\\)");
 
    // Escape sequences and NUL.
    std::wstring s(L"ab\xff\0cd", 5);
    show_matches(s, L"(\\0|\\u00ff)");
 
    // No matching for non-BMP Unicode is defined, because ECMAScript uses UTF-16
    // atoms. Whether this emoji banana matches can be platform dependent:
    // These need to be wide-strings!
    show_matches(L"\U0001f34c", L"[\\u0000-\\ufffe]+");
}</pre></div> <p>Possible output:</p>
<div class="text source-text"><pre data-language="c">
input=[C++\], regex=[C\+\+\\]
  prefix=[]
  wsmatch: m[0]=[C++\]
  suffix=[]
input=[ab?c], regex=[(\0{{!}}\u00ff)]
  prefix=[ab]
  wsmatch: m[0]=[?] m[1]=[?]
  suffix=[c]
input=[?], regex=[[\u0000-\ufffe]+]: NO MATCH
</pre></div> </div> <h3 id="Character_classes"> Character classes</h3> <p>An Atom can represent a character class, that is, it will match and consume one character if it belongs to one of the predefined groups of characters.</p>
<p>A character class can be introduced through a character class escape:</p>
<p><i>Atom</i> ::   <code>\</code></p>
<i>CharacterClassEscape</i>  <p>or directly.</p>
<p><i>Atom</i> ::</p>
<i>CharacterClass</i>  <p>The character class escapes are shorthands for some of the common characters classes, as follows:</p>
<table class="wikitable"> <tr> <th>CharacterClassEscape</th> <th>ClassName expression<span class="t-mark">(C++ only)</span>
</th> <th>Meaning </th>
</tr> <tr> <td> <code>d</code> </td> <td> <code>[[:digit:]]</code> </td> <td> digits </td>
</tr> <tr> <td> <code>D</code> </td> <td> <code>[^[:digit:]]</code> </td> <td> non-digits </td>
</tr> <tr> <td> <code>s</code> </td> <td> <code>[[:space:]]</code> </td> <td> whitespace characters </td>
</tr> <tr> <td> <code>S</code> </td> <td> <code>[^[:space:]]</code> </td> <td> non-whitespace characters </td>
</tr> <tr> <td> <code>w</code> </td> <td> <code>[_[:alnum:]]</code> </td> <td> alphanumeric characters and the character <code>_</code> </td>
</tr> <tr> <td> <code>W</code> </td> <td> <code>[^_[:alnum:]]</code> </td> <td> characters other than alphanumeric or <code>_</code> </td>
</tr>
</table>The exact meaning of each of these character class escapes in C++ is defined in terms of the locale-dependent named character classes, and not by explicitly listing the acceptable characters as in ECMAScript. <p>A <i>CharacterClass</i> is a bracket-enclosed sequence of <i>ClassRanges</i>, optionally beginning with the negation operator <code>^</code>. If it begins with <code>^</code>, this <i>Atom</i> matches any character that is NOT in the set of characters represented by the union of all <i>ClassRanges</i>. Otherwise, this <i>Atom</i> matches any character that IS in the set of the characters represented by the union of all <i>ClassRanges</i>.</p>
<p><i>CharacterClass</i> ::</p>
<dl>
<dd> <code>[</code> <code>[</code> <i>lookahead ∉ {</i><code>^</code><i>}]</i> <i>ClassRanges</i> <code>]</code> </dd>
<dd> <code>[</code> <code>^</code> <i>ClassRanges</i> <code>]</code> </dd>
</dl> <p>ClassRanges ::</p>
<dl>
<dd> [empty] </dd>
<dd> <i>NonemptyClassRanges</i> </dd>
</dl> <p><i>NonemptyClassRanges</i> ::</p>
<dl>
<dd> <i>ClassAtom</i> </dd>
<dd> <i>ClassAtom</i> <i>NonemptyClassRangesNoDash</i> </dd>
<dd> <i>ClassAtom</i> - <i>ClassAtom</i> <i>ClassRanges</i> </dd>
</dl> <p>If non-empty class range has the form <code><i>ClassAtom</i> - <i>ClassAtom</i></code>, it matches any character from a range defined as follows: <span class="t-mark">(C++ only)</span>.</p>
<p>The first <i>ClassAtom</i> must match a single collating element <code>c1</code> and the second <i>ClassAtom</i> must match a single collating element <code>c2</code>. To test if the input character <code>c</code> is matched by this range, the following steps are taken:</p>
<div class="t-li1">
<span class="t-li">1)</span> If <code><a href="syntax_option_type" title="cpp/regex/syntax option type">std::regex_constants::collate</a></code> is not on, the character is matched by direct comparison of code points: <code>c</code> is matched if <code>c1 &lt;= c &amp;&amp; c &lt;= c2</code>
</div> <div class="t-li1">
<span class="t-li">1)</span> Otherwise (if <code><a href="syntax_option_type" title="cpp/regex/syntax option type">std::regex_constants::collate</a></code> is enabled):</div> <div class="t-li2">
<span class="t-li">1)</span> If <code><a href="syntax_option_type" title="cpp/regex/syntax option type">std::regex_constants::icase</a></code> is enabled, all three characters (<code>c</code>, <code>c1</code>, and <code>c2</code>) are passed <code><a href="regex_traits/translate_nocase" title="cpp/regex/regex traits/translate nocase">std::regex_traits::translate_nocase</a></code>
</div> <div class="t-li2">
<span class="t-li">2)</span> Otherwise (if <code><a href="syntax_option_type" title="cpp/regex/syntax option type">std::regex_constants::icase</a></code> is not set), all three characters (<code>c</code>, <code>c1</code>, and <code>c2</code>) are passed <code><a href="regex_traits/translate" title="cpp/regex/regex traits/translate">std::regex_traits::translate</a></code>
</div> <div class="t-li1">
<span class="t-li">2)</span> The resulting strings are compared using <code><a href="regex_traits/transform" title="cpp/regex/regex traits/transform">std::regex_traits::transform</a></code> and the character <code>c</code> is matched if <code>transformed c1 &lt;= transformed c &amp;&amp; transformed c &lt;= transformed c2</code>
</div> <p>The character <code>-</code> is treated literally if it is.</p>
<ul>
<li> the first or last character of <i>ClassRanges</i> </li>
<li> the beginning or end ClassAtom of a dash-separated range specification </li>
<li> immediately follows a dash-separated range specification. </li>
<li> escaped with a backslash as a <i>CharacterEscape</i> </li>
</ul> <p>NonemptyClassRangesNoDash ::</p>
<dl>
<dd> <i>ClassAtom</i> </dd>
<dd> <i>ClassAtomNoDash</i> <i>NonemptyClassRangesNoDash</i> </dd>
<dd> <i>ClassAtomNoDash</i> - <i>ClassAtom</i> <i>ClassRanges</i> </dd>
</dl> <p><i>ClassAtom</i> ::</p>
<dl>
<dd> <code>-</code> </dd>
<dd> <i>ClassAtomNoDash</i> </dd>
<dd> <i>ClassAtomExClass</i><span class="t-mark">(C++ only)</span> </dd>
<dd> <i>ClassAtomCollatingElement</i><span class="t-mark">(C++ only)</span> </dd>
<dd> <i>ClassAtomEquivalence</i><span class="t-mark">(C++ only)</span> </dd>
</dl> <p>ClassAtomNoDash ::</p>
<dl>
<dd> <i>SourceCharacter</i> but not one of <code>\ or ] or -</code> </dd>
<dd> <code>\</code> <i>ClassEscape</i> </dd>
</dl> <p>Each <i>ClassAtomNoDash</i> represents a single character -- either <i>SourceCharacter</i> as-is or escaped as follows:</p>
<p>ClassEscape ::</p>
<dl>
<dd> <i>DecimalEscape</i> </dd>
<dd> <code>b</code> </dd>
<dd> <i>CharacterEscape</i> </dd>
<dd> <i>CharacterClassEscape</i> </dd>
</dl> <p>The special <i>ClassEscape</i> <code>\b</code> produces a character set that matches the code unit U+0008 (backspace). Outside of <i>CharacterClass</i>, it is the word-boundary <i>Assertion</i>.</p>
<p>The use of <code>\B</code> and the use of any backreference (<i>DecimalEscape</i> other than zero) inside a <i>CharacterClass</i> is an error.</p>
<p>The characters <code>-</code> and <code>]</code> may need to be escaped in some situations in order to be treated as atoms. Other characters that have special meaning outside of <i>CharacterClass</i>, such as <code>*</code> or <code>?</code>, do not need to be escaped.</p>
<h3 id="POSIX-based_character_classes"> POSIX-based character classes</h3> <p>These character classes are an extension to the ECMAScript grammar, and are equivalent to character classes found in the POSIX regular expressions.</p>
<p>ClassAtomExClass<span class="t-mark">(C++ only)</span> ::   <code>[:</code></p>
<i>ClassName</i> <code>:]</code>  <p>Represents all characters that are members of the named character class <i>ClassName</i>. The name is valid only if <code><a href="regex_traits/lookup_classname" title="cpp/regex/regex traits/lookup classname">std::regex_traits::lookup_classname</a></code> returns non-zero for this name. As described in <code><a href="regex_traits/lookup_classname" title="cpp/regex/regex traits/lookup classname">std::regex_traits::lookup_classname</a></code>, the following names are guaranteed to be recognized: <code>alnum, alpha, blank, cntrl, digit, graph, lower, print, punct, space, upper, xdigit, d, s, w</code>. Additional names may be provided by system-supplied locales (such as <code>jdigit</code> or <code>jkanji</code> in Japanese) or implemented as a user-defined extension.</p>
<p>ClassAtomCollatingElement<span class="t-mark">(C++ only)</span> ::   <code>[.</code></p>
<i>ClassName</i> <code>.]</code>  <p>Represents the named collating element, which may represent a single character or a sequence of characters that collates as a single unit under the imbued locale, such as <code>[.tilde.]</code> or <code>[.ch.]</code> in Czech. The name is valid only if <code><a href="regex_traits/lookup_collatename" title="cpp/regex/regex traits/lookup collatename">std::regex_traits::lookup_collatename</a></code> is not an empty string.</p>
<p>When using <code><a href="syntax_option_type" title="cpp/regex/syntax option type">std::regex_constants::collate</a></code>, collating elements can always be used as ends points of a range (e.g. <code>[[.dz.]-g]</code> in Hungarian).</p>
<p>ClassAtomEquivalence<span class="t-mark">(C++ only)</span> ::   <code>[=</code></p>
<i>ClassName</i> <code>=]</code>  <p>Represents all characters that are members of the same equivalence class as the named collating element, that is, all characters whose whose primary collation key is the same as that for collating element <i>ClassName</i>. The name is valid only if <code><a href="regex_traits/lookup_collatename" title="cpp/regex/regex traits/lookup collatename">std::regex_traits::lookup_collatename</a></code> for that name is not an empty string and if the value returned by <code><a href="regex_traits/transform_primary" title="cpp/regex/regex traits/transform primary">std::regex_traits::transform_primary</a></code> for the result of the call to <code><a href="regex_traits/lookup_collatename" title="cpp/regex/regex traits/lookup collatename">std::regex_traits::lookup_collatename</a></code> is not an empty string.</p>
<p>A primary sort key is one that ignores case, accentation, or locale-specific tailorings; so for example <code>[[=a=]]</code> matches any of the characters: <code>a, À, Á, Â, Ã, Ä, Å, A, à, á, â, ã, ä and å. </code></p>
<p>ClassName<span class="t-mark">(C++ only)</span> ::</p>
<dl>
<dd> ClassNameCharacter </dd>
<dd> ClassNameCharacter ClassName </dd>
</dl> <p>ClassNameCharacter<span class="t-mark">(C++ only)</span> ::</p>
<i>SourceCharacter</i> but not one of <code>. = :</code>             <div class="_attribution">
  <p class="_attribution-p">
    © cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/regex/ecmascript" class="_attribution-link">https://en.cppreference.com/w/cpp/regex/ecmascript</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
