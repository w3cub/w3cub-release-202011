
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Algorithm - C++ - W3cubDocs</title>
  
  <meta name="description" content=" This header is part of the algorithm library. ">
  <meta name="keywords" content="standard, library, header, algorithm, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/header/algorithm.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-1810d67ab7e57be09d8247710d2feb6954566959eb82322d1fee3a0c9156f56974b78ebaa9928774f00767342bbe58b0799d91fcc336b92b319170b196f9b64b.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/cpp.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _c">
				
				
<h1 id="firstHeading" class="firstHeading">Standard library header &lt;algorithm&gt;</h1>            <p>This header is part of the <a href="../algorithm" title="cpp/algorithm">algorithm</a> library.</p>
<table class="t-dsc-begin"> <tr> <td colspan="2">  <h3 id="Includes">  Includes</h3> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="initializer_list" title="cpp/header/initializer list"> <span class="t-lines"><span>&lt;initializer_list&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> <code><a href="../utility/initializer_list" title="cpp/utility/initializer list">std::initializer_list</a></code> class template  </td>
</tr> <tr> <td colspan="2"> <h3 id="Classes">  Classes</h3> </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in namespace <code>std::ranges</code>  </th>
</tr> <tr> <td colspan="2"> <h5 id="Return_types_.28C.2B.2B20.29">  Return types <span class="t-mark">(C++20)</span> </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/return_types/in_fun_result" title="cpp/algorithm/ranges/return types/in fun result"> <span class="t-lines"><span>ranges::in_fun_result</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> provides a way to store an iterator and a function object as a single unit <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/return_types/in_in_result" title="cpp/algorithm/ranges/return types/in in result"> <span class="t-lines"><span>ranges::in_in_result</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> provides a way to store two iterators as a single unit <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/return_types/in_out_result" title="cpp/algorithm/ranges/return types/in out result"> <span class="t-lines"><span>ranges::in_out_result</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> provides a way to store two iterators as a single unit <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/return_types/in_in_out_result" title="cpp/algorithm/ranges/return types/in in out result"> <span class="t-lines"><span>ranges::in_in_out_result</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> provides a way to store three iterators as a single unit <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/return_types/in_out_out_result" title="cpp/algorithm/ranges/return types/in out out result"> <span class="t-lines"><span>ranges::in_out_out_result</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> provides a way to store three iterators as a single unit <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/return_types/min_max_result" title="cpp/algorithm/ranges/return types/min max result"> <span class="t-lines"><span>ranges::min_max_result</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> provides a way to store two objects or references of the same type as a single unit <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/return_types/in_found_result" title="cpp/algorithm/ranges/return types/in found result"> <span class="t-lines"><span>ranges::in_found_result</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> provides a way to store an iterator and a boolean flag as a single unit <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/return_types/in_value_result" title="cpp/algorithm/ranges/return types/in value result"> <span class="t-lines"><span>ranges::in_value_result</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> provides a way to store an iterator and a value as a single unit <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/return_types/out_value_result" title="cpp/algorithm/ranges/return types/out value result"> <span class="t-lines"><span>ranges::out_value_result</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> provides a way to store an iterator and a value as a single unit <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr> <td colspan="2"> <h3 id="Functions">  Functions</h3> </td>
</tr> <tr> <td colspan="2"> <h5 id="Non-modifying_sequence_operations">  Non-modifying sequence operations </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/all_any_none_of" title="cpp/algorithm/all any none of"> <span class="t-lines"><span>all_of</span><span>any_of</span><span>none_of</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> checks if a predicate is <code>true</code> for all, any or none of the elements in a range <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/for_each" title="cpp/algorithm/for each"> <span class="t-lines"><span>for_each</span></span></a></div> </td> <td> applies a function to a range of elements <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/for_each_n" title="cpp/algorithm/for each n"> <span class="t-lines"><span>for_each_n</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> applies a function object to the first n elements of a sequence <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/count" title="cpp/algorithm/count"> <span class="t-lines"><span>count</span><span>count_if</span></span></a></div> </td> <td> returns the number of elements satisfying specific criteria <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/mismatch" title="cpp/algorithm/mismatch"> <span class="t-lines"><span>mismatch</span></span></a></div> </td> <td> finds the first position where two ranges differ <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/find" title="cpp/algorithm/find"> <span class="t-lines"><span>find</span><span>find_if</span><span>find_if_not</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> finds the first element satisfying specific criteria <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/find_end" title="cpp/algorithm/find end"> <span class="t-lines"><span>find_end</span></span></a></div> </td> <td> finds the last sequence of elements in a certain range <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/find_first_of" title="cpp/algorithm/find first of"> <span class="t-lines"><span>find_first_of</span></span></a></div> </td> <td> searches for any one of a set of elements <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/adjacent_find" title="cpp/algorithm/adjacent find"> <span class="t-lines"><span>adjacent_find</span></span></a></div> </td> <td> finds the first two adjacent items that are equal (or satisfy a given predicate) <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/search" title="cpp/algorithm/search"> <span class="t-lines"><span>search</span></span></a></div> </td> <td> searches for a range of elements <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/search_n" title="cpp/algorithm/search n"> <span class="t-lines"><span>search_n</span></span></a></div> </td> <td> searches a range for a number of consecutive copies of an element <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Modifying_sequence_operations">  Modifying sequence operations </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/copy" title="cpp/algorithm/copy"> <span class="t-lines"><span>copy</span><span>copy_if</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> copies a range of elements to a new location <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/copy_n" title="cpp/algorithm/copy n"> <span class="t-lines"><span>copy_n</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> copies a number of elements to a new location <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/copy_backward" title="cpp/algorithm/copy backward"> <span class="t-lines"><span>copy_backward</span></span></a></div> </td> <td> copies a range of elements in backwards order <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/move" title="cpp/algorithm/move"> <span class="t-lines"><span>move</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> moves a range of elements to a new location <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/move_backward" title="cpp/algorithm/move backward"> <span class="t-lines"><span>move_backward</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> moves a range of elements to a new location in backwards order <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/fill" title="cpp/algorithm/fill"> <span class="t-lines"><span>fill</span></span></a></div> </td> <td> copy-assigns the given value to every element in a range <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/fill_n" title="cpp/algorithm/fill n"> <span class="t-lines"><span>fill_n</span></span></a></div> </td> <td> copy-assigns the given value to N elements in a range <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/transform" title="cpp/algorithm/transform"> <span class="t-lines"><span>transform</span></span></a></div> </td> <td> applies a function to a range of elements, storing results in a destination range <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/generate" title="cpp/algorithm/generate"> <span class="t-lines"><span>generate</span></span></a></div> </td> <td> assigns the results of successive function calls to every element in a range <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/generate_n" title="cpp/algorithm/generate n"> <span class="t-lines"><span>generate_n</span></span></a></div> </td> <td> assigns the results of successive function calls to N elements in a range <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/remove" title="cpp/algorithm/remove"> <span class="t-lines"><span>remove</span><span>remove_if</span></span></a></div> </td> <td> removes elements satisfying specific criteria <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/remove_copy" title="cpp/algorithm/remove copy"> <span class="t-lines"><span>remove_copy</span><span>remove_copy_if</span></span></a></div> </td> <td> copies a range of elements omitting those that satisfy specific criteria <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/replace" title="cpp/algorithm/replace"> <span class="t-lines"><span>replace</span><span>replace_if</span></span></a></div> </td> <td> replaces all values satisfying specific criteria with another value <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/replace_copy" title="cpp/algorithm/replace copy"> <span class="t-lines"><span>replace_copy</span><span>replace_copy_if</span></span></a></div> </td> <td> copies a range, replacing elements satisfying specific criteria with another value <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/swap" title="cpp/algorithm/swap"> <span class="t-lines"><span>swap</span></span></a></div> </td> <td> swaps the values of two objects <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/swap_ranges" title="cpp/algorithm/swap ranges"> <span class="t-lines"><span>swap_ranges</span></span></a></div> </td> <td> swaps two ranges of elements <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/iter_swap" title="cpp/algorithm/iter swap"> <span class="t-lines"><span>iter_swap</span></span></a></div> </td> <td> swaps the elements pointed to by two iterators <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/reverse" title="cpp/algorithm/reverse"> <span class="t-lines"><span>reverse</span></span></a></div> </td> <td> reverses the order of elements in a range <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/reverse_copy" title="cpp/algorithm/reverse copy"> <span class="t-lines"><span>reverse_copy</span></span></a></div> </td> <td> creates a copy of a range that is reversed <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/rotate" title="cpp/algorithm/rotate"> <span class="t-lines"><span>rotate</span></span></a></div> </td> <td> rotates the order of elements in a range <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/rotate_copy" title="cpp/algorithm/rotate copy"> <span class="t-lines"><span>rotate_copy</span></span></a></div> </td> <td> copies and rotate a range of elements <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/shift" title="cpp/algorithm/shift"> <span class="t-lines"><span>shift_left</span><span>shift_right</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> shifts elements in a range <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/random_shuffle" title="cpp/algorithm/random shuffle"> <span class="t-lines"><span>random_shuffle</span><span>shuffle</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx17">(until C++17)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> randomly re-orders elements in a range <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/sample" title="cpp/algorithm/sample"> <span class="t-lines"><span>sample</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> selects n random elements from a sequence <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/unique" title="cpp/algorithm/unique"> <span class="t-lines"><span>unique</span></span></a></div> </td> <td> removes consecutive duplicate elements in a range <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/unique_copy" title="cpp/algorithm/unique copy"> <span class="t-lines"><span>unique_copy</span></span></a></div> </td> <td> creates a copy of some range of elements that contains no consecutive duplicates <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Partitioning_operations">  Partitioning operations </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/is_partitioned" title="cpp/algorithm/is partitioned"> <span class="t-lines"><span>is_partitioned</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> determines if the range is partitioned by the given predicate <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/partition" title="cpp/algorithm/partition"> <span class="t-lines"><span>partition</span></span></a></div> </td> <td> divides a range of elements into two groups <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/partition_copy" title="cpp/algorithm/partition copy"> <span class="t-lines"><span>partition_copy</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> copies a range dividing the elements into two groups <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/stable_partition" title="cpp/algorithm/stable partition"> <span class="t-lines"><span>stable_partition</span></span></a></div> </td> <td> divides elements into two groups while preserving their relative order <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/partition_point" title="cpp/algorithm/partition point"> <span class="t-lines"><span>partition_point</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> locates the partition point of a partitioned range <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Sorting_operations">  Sorting operations </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/is_sorted" title="cpp/algorithm/is sorted"> <span class="t-lines"><span>is_sorted</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> checks whether a range is sorted into ascending order <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/is_sorted_until" title="cpp/algorithm/is sorted until"> <span class="t-lines"><span>is_sorted_until</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> finds the largest sorted subrange <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/sort" title="cpp/algorithm/sort"> <span class="t-lines"><span>sort</span></span></a></div> </td> <td> sorts a range into ascending order <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/partial_sort" title="cpp/algorithm/partial sort"> <span class="t-lines"><span>partial_sort</span></span></a></div> </td> <td> sorts the first N elements of a range <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/partial_sort_copy" title="cpp/algorithm/partial sort copy"> <span class="t-lines"><span>partial_sort_copy</span></span></a></div> </td> <td> copies and partially sorts a range of elements <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/stable_sort" title="cpp/algorithm/stable sort"> <span class="t-lines"><span>stable_sort</span></span></a></div> </td> <td> sorts a range of elements while preserving order between equal elements <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/nth_element" title="cpp/algorithm/nth element"> <span class="t-lines"><span>nth_element</span></span></a></div> </td> <td> partially sorts the given range making sure that it is partitioned by the given element <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Binary_search_operations_.28on_sorted_ranges.29">  Binary search operations (on sorted ranges) </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/lower_bound" title="cpp/algorithm/lower bound"> <span class="t-lines"><span>lower_bound</span></span></a></div> </td> <td> returns an iterator to the first element <i>not less</i> than the given value <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/upper_bound" title="cpp/algorithm/upper bound"> <span class="t-lines"><span>upper_bound</span></span></a></div> </td> <td> returns an iterator to the first element <i>greater</i> than a certain value <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/binary_search" title="cpp/algorithm/binary search"> <span class="t-lines"><span>binary_search</span></span></a></div> </td> <td> determines if an element exists in a partially-ordered range <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/equal_range" title="cpp/algorithm/equal range"> <span class="t-lines"><span>equal_range</span></span></a></div> </td> <td> returns range of elements matching a specific key <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Other_operations_on_sorted_ranges">  Other operations on sorted ranges </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/merge" title="cpp/algorithm/merge"> <span class="t-lines"><span>merge</span></span></a></div> </td> <td> merges two sorted ranges <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/inplace_merge" title="cpp/algorithm/inplace merge"> <span class="t-lines"><span>inplace_merge</span></span></a></div> </td> <td> merges two ordered ranges in-place <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Set_operations_.28on_sorted_ranges.29">  Set operations (on sorted ranges) </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/includes" title="cpp/algorithm/includes"> <span class="t-lines"><span>includes</span></span></a></div> </td> <td> returns true if one sequence is a subsequence of another <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/set_difference" title="cpp/algorithm/set difference"> <span class="t-lines"><span>set_difference</span></span></a></div> </td> <td> computes the difference between two sets <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/set_intersection" title="cpp/algorithm/set intersection"> <span class="t-lines"><span>set_intersection</span></span></a></div> </td> <td> computes the intersection of two sets <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/set_symmetric_difference" title="cpp/algorithm/set symmetric difference"> <span class="t-lines"><span>set_symmetric_difference</span></span></a></div> </td> <td> computes the symmetric difference between two sets <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/set_union" title="cpp/algorithm/set union"> <span class="t-lines"><span>set_union</span></span></a></div> </td> <td> computes the union of two sets <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Heap_operations">  Heap operations </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/is_heap" title="cpp/algorithm/is heap"> <span class="t-lines"><span>is_heap</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> checks if the given range is a max heap <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/is_heap_until" title="cpp/algorithm/is heap until"> <span class="t-lines"><span>is_heap_until</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> finds the largest subrange that is a max heap <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/make_heap" title="cpp/algorithm/make heap"> <span class="t-lines"><span>make_heap</span></span></a></div> </td> <td> creates a max heap out of a range of elements <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/push_heap" title="cpp/algorithm/push heap"> <span class="t-lines"><span>push_heap</span></span></a></div> </td> <td> adds an element to a max heap <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/pop_heap" title="cpp/algorithm/pop heap"> <span class="t-lines"><span>pop_heap</span></span></a></div> </td> <td> removes the largest element from a max heap <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/sort_heap" title="cpp/algorithm/sort heap"> <span class="t-lines"><span>sort_heap</span></span></a></div> </td> <td> turns a max heap into a range of elements sorted in ascending order <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Minimum.2Fmaximum_operations">  Minimum/maximum operations </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/max" title="cpp/algorithm/max"> <span class="t-lines"><span>max</span></span></a></div> </td> <td> returns the greater of the given values <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/max_element" title="cpp/algorithm/max element"> <span class="t-lines"><span>max_element</span></span></a></div> </td> <td> returns the largest element in a range <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/min" title="cpp/algorithm/min"> <span class="t-lines"><span>min</span></span></a></div> </td> <td> returns the smaller of the given values <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/min_element" title="cpp/algorithm/min element"> <span class="t-lines"><span>min_element</span></span></a></div> </td> <td> returns the smallest element in a range <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/minmax" title="cpp/algorithm/minmax"> <span class="t-lines"><span>minmax</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> returns the smaller and larger of two elements <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/minmax_element" title="cpp/algorithm/minmax element"> <span class="t-lines"><span>minmax_element</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> returns the smallest and the largest elements in a range <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/clamp" title="cpp/algorithm/clamp"> <span class="t-lines"><span>clamp</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> clamps a value between a pair of boundary values <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Comparison_operations">  Comparison operations </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/equal" title="cpp/algorithm/equal"> <span class="t-lines"><span>equal</span></span></a></div> </td> <td> determines if two sets of elements are the same <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/lexicographical_compare" title="cpp/algorithm/lexicographical compare"> <span class="t-lines"><span>lexicographical_compare</span></span></a></div> </td> <td> returns true if one range is lexicographically less than another <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/lexicographical_compare_three_way" title="cpp/algorithm/lexicographical compare three way"> <span class="t-lines"><span>lexicographical_compare_three_way</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> compares two ranges using three-way comparison <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Permutation_operations">  Permutation operations </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/is_permutation" title="cpp/algorithm/is permutation"> <span class="t-lines"><span>is_permutation</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> determines if a sequence is a permutation of another sequence <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/next_permutation" title="cpp/algorithm/next permutation"> <span class="t-lines"><span>next_permutation</span></span></a></div> </td> <td> generates the next greater lexicographic permutation of a range of elements <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/prev_permutation" title="cpp/algorithm/prev permutation"> <span class="t-lines"><span>prev_permutation</span></span></a></div> </td> <td> generates the next smaller lexicographic permutation of a range of elements <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr> <td colspan="2"> <h3 id="Function-like_entities_.28C.2B.2B20.29">  Function-like entities <span class="t-mark">(C++20)</span>
</h3> </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in namespace <code>std::ranges</code>  </th>
</tr> <tr> <td colspan="2"> <h5 id="Non-modifying_sequence_operations_2">  Non-modifying sequence operations </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/all_any_none_of" title="cpp/algorithm/ranges/all any none of"> <span class="t-lines"><span>ranges::all_of</span><span>ranges::any_of</span><span>ranges::none_of</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> checks if a predicate is <code>true</code> for all, any or none of the elements in a range <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/for_each" title="cpp/algorithm/ranges/for each"> <span class="t-lines"><span>ranges::for_each</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> applies a function to a range of elements <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/for_each_n" title="cpp/algorithm/ranges/for each n"> <span class="t-lines"><span>ranges::for_each_n</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> applies a function object to the first n elements of a sequence <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/count" title="cpp/algorithm/ranges/count"> <span class="t-lines"><span>ranges::count</span><span>ranges::count_if</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> returns the number of elements satisfying specific criteria <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/mismatch" title="cpp/algorithm/ranges/mismatch"> <span class="t-lines"><span>ranges::mismatch</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> finds the first position where two ranges differ <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/find" title="cpp/algorithm/ranges/find"> <span class="t-lines"><span>ranges::find</span><span>ranges::find_if</span><span>ranges::find_if_not</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> finds the first element satisfying specific criteria <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/find_last" title="cpp/algorithm/ranges/find last"> <span class="t-lines"><span>ranges::find_last</span><span>ranges::find_last_if</span><span>ranges::find_last_if_not</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> finds the last element satisfying specific criteria <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/find_end" title="cpp/algorithm/ranges/find end"> <span class="t-lines"><span>ranges::find_end</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> finds the last sequence of elements in a certain range <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/find_first_of" title="cpp/algorithm/ranges/find first of"> <span class="t-lines"><span>ranges::find_first_of</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> searches for any one of a set of elements <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/adjacent_find" title="cpp/algorithm/ranges/adjacent find"> <span class="t-lines"><span>ranges::adjacent_find</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> finds the first two adjacent items that are equal (or satisfy a given predicate) <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/search" title="cpp/algorithm/ranges/search"> <span class="t-lines"><span>ranges::search</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> searches for a range of elements <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/search_n" title="cpp/algorithm/ranges/search n"> <span class="t-lines"><span>ranges::search_n</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> searches for a number consecutive copies of an element in a range <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/contains" title="cpp/algorithm/ranges/contains"> <span class="t-lines"><span>ranges::contains</span><span>ranges::contains_subrange</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> checks if the range contains the given element or subrange <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/starts_with" title="cpp/algorithm/ranges/starts with"> <span class="t-lines"><span>ranges::starts_with</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> checks whether a range starts with another range <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/ends_with" title="cpp/algorithm/ranges/ends with"> <span class="t-lines"><span>ranges::ends_with</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> checks whether a range ends with another range <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Modifying_sequence_operations_2">  Modifying sequence operations </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/copy" title="cpp/algorithm/ranges/copy"> <span class="t-lines"><span>ranges::copy</span><span>ranges::copy_if</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> copies a range of elements to a new location <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/copy_n" title="cpp/algorithm/ranges/copy n"> <span class="t-lines"><span>ranges::copy_n</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> copies a number of elements to a new location <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/copy_backward" title="cpp/algorithm/ranges/copy backward"> <span class="t-lines"><span>ranges::copy_backward</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> copies a range of elements in backwards order <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/move" title="cpp/algorithm/ranges/move"> <span class="t-lines"><span>ranges::move</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> moves a range of elements to a new location <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/move_backward" title="cpp/algorithm/ranges/move backward"> <span class="t-lines"><span>ranges::move_backward</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> moves a range of elements to a new location in backwards order <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/fill" title="cpp/algorithm/ranges/fill"> <span class="t-lines"><span>ranges::fill</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> assigns a range of elements a certain value <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/fill_n" title="cpp/algorithm/ranges/fill n"> <span class="t-lines"><span>ranges::fill_n</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> assigns a value to a number of elements <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/transform" title="cpp/algorithm/ranges/transform"> <span class="t-lines"><span>ranges::transform</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> applies a function to a range of elements <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/generate" title="cpp/algorithm/ranges/generate"> <span class="t-lines"><span>ranges::generate</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> saves the result of a function in a range <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/generate_n" title="cpp/algorithm/ranges/generate n"> <span class="t-lines"><span>ranges::generate_n</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> saves the result of N applications of a function <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/remove" title="cpp/algorithm/ranges/remove"> <span class="t-lines"><span>ranges::remove</span><span>ranges::remove_if</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> removes elements satisfying specific criteria <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/remove_copy" title="cpp/algorithm/ranges/remove copy"> <span class="t-lines"><span>ranges::remove_copy</span><span>ranges::remove_copy_if</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> copies a range of elements omitting those that satisfy specific criteria <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/replace" title="cpp/algorithm/ranges/replace"> <span class="t-lines"><span>ranges::replace</span><span>ranges::replace_if</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> replaces all values satisfying specific criteria with another value <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/replace_copy" title="cpp/algorithm/ranges/replace copy"> <span class="t-lines"><span>ranges::replace_copy</span><span>ranges::replace_copy_if</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> copies a range, replacing elements satisfying specific criteria with another value <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/swap_ranges" title="cpp/algorithm/ranges/swap ranges"> <span class="t-lines"><span>ranges::swap_ranges</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> swaps two ranges of elements <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/reverse" title="cpp/algorithm/ranges/reverse"> <span class="t-lines"><span>ranges::reverse</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> reverses the order of elements in a range <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/reverse_copy" title="cpp/algorithm/ranges/reverse copy"> <span class="t-lines"><span>ranges::reverse_copy</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> creates a copy of a range that is reversed <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/rotate" title="cpp/algorithm/ranges/rotate"> <span class="t-lines"><span>ranges::rotate</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> rotates the order of elements in a range <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/rotate_copy" title="cpp/algorithm/ranges/rotate copy"> <span class="t-lines"><span>ranges::rotate_copy</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> copies and rotate a range of elements <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/shift" title="cpp/algorithm/ranges/shift"> <span class="t-lines"><span>ranges::shift_left</span><span>ranges::shift_right</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> shifts elements in a range <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/sample" title="cpp/algorithm/ranges/sample"> <span class="t-lines"><span>ranges::sample</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> selects n random elements from a sequence <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/shuffle" title="cpp/algorithm/ranges/shuffle"> <span class="t-lines"><span>ranges::shuffle</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> randomly re-orders elements in a range <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/unique" title="cpp/algorithm/ranges/unique"> <span class="t-lines"><span>ranges::unique</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> removes consecutive duplicate elements in a range <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/unique_copy" title="cpp/algorithm/ranges/unique copy"> <span class="t-lines"><span>ranges::unique_copy</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> creates a copy of some range of elements that contains no consecutive duplicates <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Partitioning_operations_2">  Partitioning operations </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/is_partitioned" title="cpp/algorithm/ranges/is partitioned"> <span class="t-lines"><span>ranges::is_partitioned</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> determines if the range is partitioned by the given predicate <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/partition" title="cpp/algorithm/ranges/partition"> <span class="t-lines"><span>ranges::partition</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> divides a range of elements into two groups <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/partition_copy" title="cpp/algorithm/ranges/partition copy"> <span class="t-lines"><span>ranges::partition_copy</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> copies a range dividing the elements into two groups <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/stable_partition" title="cpp/algorithm/ranges/stable partition"> <span class="t-lines"><span>ranges::stable_partition</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> divides elements into two groups while preserving their relative order <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/partition_point" title="cpp/algorithm/ranges/partition point"> <span class="t-lines"><span>ranges::partition_point</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> locates the partition point of a partitioned range <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Sorting_operations_2">  Sorting operations </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/is_sorted" title="cpp/algorithm/ranges/is sorted"> <span class="t-lines"><span>ranges::is_sorted</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> checks whether a range is sorted into ascending order <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/is_sorted_until" title="cpp/algorithm/ranges/is sorted until"> <span class="t-lines"><span>ranges::is_sorted_until</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> finds the largest sorted subrange <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/sort" title="cpp/algorithm/ranges/sort"> <span class="t-lines"><span>ranges::sort</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> sorts a range into ascending order <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/partial_sort" title="cpp/algorithm/ranges/partial sort"> <span class="t-lines"><span>ranges::partial_sort</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> sorts the first N elements of a range <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/partial_sort_copy" title="cpp/algorithm/ranges/partial sort copy"> <span class="t-lines"><span>ranges::partial_sort_copy</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> copies and partially sorts a range of elements <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/stable_sort" title="cpp/algorithm/ranges/stable sort"> <span class="t-lines"><span>ranges::stable_sort</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> sorts a range of elements while preserving order between equal elements <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/nth_element" title="cpp/algorithm/ranges/nth element"> <span class="t-lines"><span>ranges::nth_element</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> partially sorts the given range making sure that it is partitioned by the given element <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Binary_search_operations_.28on_sorted_ranges.29_2">  Binary search operations (on sorted ranges) </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/lower_bound" title="cpp/algorithm/ranges/lower bound"> <span class="t-lines"><span>ranges::lower_bound</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> returns an iterator to the first element <i>not less</i> than the given value <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/upper_bound" title="cpp/algorithm/ranges/upper bound"> <span class="t-lines"><span>ranges::upper_bound</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> returns an iterator to the first element <i>greater</i> than a certain value <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/binary_search" title="cpp/algorithm/ranges/binary search"> <span class="t-lines"><span>ranges::binary_search</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> determines if an element exists in a partially-ordered range <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/equal_range" title="cpp/algorithm/ranges/equal range"> <span class="t-lines"><span>ranges::equal_range</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> returns range of elements matching a specific key <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Other_operations_on_sorted_ranges_2">  Other operations on sorted ranges </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/merge" title="cpp/algorithm/ranges/merge"> <span class="t-lines"><span>ranges::merge</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> merges two sorted ranges <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/inplace_merge" title="cpp/algorithm/ranges/inplace merge"> <span class="t-lines"><span>ranges::inplace_merge</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> merges two ordered ranges in-place <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Set_operations_.28on_sorted_ranges.29_2">  Set operations (on sorted ranges) </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/includes" title="cpp/algorithm/ranges/includes"> <span class="t-lines"><span>ranges::includes</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> returns true if one sequence is a subsequence of another <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/set_difference" title="cpp/algorithm/ranges/set difference"> <span class="t-lines"><span>ranges::set_difference</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> computes the difference between two sets <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/set_intersection" title="cpp/algorithm/ranges/set intersection"> <span class="t-lines"><span>ranges::set_intersection</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> computes the intersection of two sets <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/set_symmetric_difference" title="cpp/algorithm/ranges/set symmetric difference"> <span class="t-lines"><span>ranges::set_symmetric_difference</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> computes the symmetric difference between two sets <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/set_union" title="cpp/algorithm/ranges/set union"> <span class="t-lines"><span>ranges::set_union</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> computes the union of two sets <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Heap_operations_2">  Heap operations </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/is_heap" title="cpp/algorithm/ranges/is heap"> <span class="t-lines"><span>ranges::is_heap</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> checks if the given range is a max heap <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/is_heap_until" title="cpp/algorithm/ranges/is heap until"> <span class="t-lines"><span>ranges::is_heap_until</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> finds the largest subrange that is a max heap <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/make_heap" title="cpp/algorithm/ranges/make heap"> <span class="t-lines"><span>ranges::make_heap</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> creates a max heap out of a range of elements <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/push_heap" title="cpp/algorithm/ranges/push heap"> <span class="t-lines"><span>ranges::push_heap</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> adds an element to a max heap <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/pop_heap" title="cpp/algorithm/ranges/pop heap"> <span class="t-lines"><span>ranges::pop_heap</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> removes the largest element from a max heap <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/sort_heap" title="cpp/algorithm/ranges/sort heap"> <span class="t-lines"><span>ranges::sort_heap</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> turns a max heap into a range of elements sorted in ascending order <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Minimum.2Fmaximum_operations_2">  Minimum/maximum operations </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/max" title="cpp/algorithm/ranges/max"> <span class="t-lines"><span>ranges::max</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> returns the greater of the given values <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/max_element" title="cpp/algorithm/ranges/max element"> <span class="t-lines"><span>ranges::max_element</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> returns the largest element in a range <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/min" title="cpp/algorithm/ranges/min"> <span class="t-lines"><span>ranges::min</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> returns the smaller of the given values <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/min_element" title="cpp/algorithm/ranges/min element"> <span class="t-lines"><span>ranges::min_element</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> returns the smallest element in a range <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/minmax" title="cpp/algorithm/ranges/minmax"> <span class="t-lines"><span>ranges::minmax</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> returns the smaller and larger of two elements <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/minmax_element" title="cpp/algorithm/ranges/minmax element"> <span class="t-lines"><span>ranges::minmax_element</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> returns the smallest and the largest elements in a range <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/clamp" title="cpp/algorithm/ranges/clamp"> <span class="t-lines"><span>ranges::clamp</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> clamps a value between a pair of boundary values <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Comparison_operations_2">  Comparison operations </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/equal" title="cpp/algorithm/ranges/equal"> <span class="t-lines"><span>ranges::equal</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> determines if two sets of elements are the same <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/lexicographical_compare" title="cpp/algorithm/ranges/lexicographical compare"> <span class="t-lines"><span>ranges::lexicographical_compare</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> returns true if one range is lexicographically less than another <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Permutation_operations_2">  Permutation operations </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/is_permutation" title="cpp/algorithm/ranges/is permutation"> <span class="t-lines"><span>ranges::is_permutation</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> determines if a sequence is a permutation of another sequence <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/next_permutation" title="cpp/algorithm/ranges/next permutation"> <span class="t-lines"><span>ranges::next_permutation</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> generates the next greater lexicographic permutation of a range of elements <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/prev_permutation" title="cpp/algorithm/ranges/prev permutation"> <span class="t-lines"><span>ranges::prev_permutation</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> generates the next smaller lexicographic permutation of a range of elements <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> </table> <h3 id="Synopsis"> Synopsis</h3> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;initializer_list&gt;
 
namespace std {
  namespace ranges {
    // algorithm result types
    template&lt;class I, class F&gt;
      struct in_fun_result;
 
    template&lt;class I1, class I2&gt;
      struct in_in_result;
 
    template&lt;class I, class O&gt;
      struct in_out_result;
 
    template&lt;class I1, class I2, class O&gt;
      struct in_in_out_result;
 
    template&lt;class I, class O1, class O2&gt;
      struct in_out_out_result;
 
    template&lt;class T&gt;
      struct min_max_result;
 
    template&lt;class I&gt;
      struct in_found_result;
 
    template&lt;class I, class T&gt;
      struct in_value_result;
 
    template&lt;class O, class T&gt;
      struct out_value_result;
  }
 
  // non-modifying sequence operations
  // all of
  template&lt;class InputIter, class Pred&gt;
    constexpr bool all_of(InputIter first, InputIter last, Pred pred);
  template&lt;class ExecutionPolicy, class ForwardIter, class Pred&gt;
    bool all_of(ExecutionPolicy&amp;&amp; exec,
                ForwardIter first, ForwardIter last, Pred pred);
 
  namespace ranges {
    template&lt;input_iterator I, sentinel_for&lt;I&gt; S, class Proj = identity,
             indirect_unary_predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
      constexpr bool all_of(I first, S last, Pred pred, Proj proj = {});
    template&lt;input_range R, class Proj = identity,
             indirect_unary_predicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
      constexpr bool all_of(R&amp;&amp; r, Pred pred, Proj proj = {});
  }
 
  // any of
  template&lt;class InputIter, class Pred&gt;
    constexpr bool any_of(InputIter first, InputIter last, Pred pred);
  template&lt;class ExecutionPolicy, class ForwardIter, class Pred&gt;
    bool any_of(ExecutionPolicy&amp;&amp; exec,
                ForwardIter first, ForwardIter last, Pred pred);
 
  namespace ranges {
    template&lt;input_iterator I, sentinel_for&lt;I&gt; S, class Proj = identity,
             indirect_unary_predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
      constexpr bool any_of(I first, S last, Pred pred, Proj proj = {});
    template&lt;input_range R, class Proj = identity,
             indirect_unary_predicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
      constexpr bool any_of(R&amp;&amp; r, Pred pred, Proj proj = {});
  }
 
  // none of
  template&lt;class InputIter, class Pred&gt;
    constexpr bool none_of(InputIter first, InputIter last, Pred pred);
  template&lt;class ExecutionPolicy, class ForwardIter, class Pred&gt;
    bool none_of(ExecutionPolicy&amp;&amp; exec,
                 ForwardIter first, ForwardIter last, Pred pred);
 
  namespace ranges {
    template&lt;input_iterator I, sentinel_for&lt;I&gt; S, class Proj = identity,
             indirect_unary_predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
      constexpr bool none_of(I first, S last, Pred pred, Proj proj = {});
    template&lt;input_range R, class Proj = identity,
             indirect_unary_predicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
      constexpr bool none_of(R&amp;&amp; r, Pred pred, Proj proj = {});
  }
 
  // contains
  namespace ranges {
    template&lt;input_iterator I, sentinel_for&lt;I&gt; S, class T, class Proj = identity&gt;
      requires indirect_binary_predicate&lt;ranges::equal_to, projected&lt;I, Proj&gt;, const T*&gt;
      constexpr bool contains(I first, S last, const T&amp; value, Proj proj = {});
    template&lt;input_range R, class T, class Proj = identity&gt;
      requires
        indirect_binary_predicate&lt;ranges::equal_to,
                                  projected&lt;iterator_t&lt;R&gt;, Proj&gt;, const T*&gt;
      constexpr bool contains(R&amp;&amp; r, const T&amp; value, Proj proj = {});
 
    template&lt;forward_iterator I1, sentinel_for&lt;I1&gt; S1,
             forward_iterator I2, sentinel_for&lt;I2&gt; S2,
             class Pred = ranges::equal_to, class Proj1 = identity, 
             class Proj2 = identity&gt;
      requires indirectly_comparable&lt;I1, I2, Pred, Proj1, Proj2&gt;
      constexpr bool contains_subrange(I1 first1, S1 last1, I2 first2, S2 last2,
                                       Pred pred = {}, Proj1 proj1 = {}, 
                                       Proj2 proj2 = {});
    template&lt;forward_range R1, forward_range R2,
             class Pred = ranges::equal_to, class Proj1 = identity, 
             class Proj2 = identity&gt;
      requires indirectly_comparable&lt;iterator_t&lt;R1&gt;, iterator_t&lt;R2&gt;, Pred, Proj1, Proj2&gt;
      constexpr bool contains_subrange(R1&amp;&amp; r1, R2&amp;&amp; r2,
                                       Pred pred = {}, Proj1 proj1 = {}, 
                                       Proj2 proj2 = {});
  }
 
  // for each
  template&lt;class InputIter, class Function&gt;
    constexpr Function for_each(InputIter first, InputIter last, Function f);
  template&lt;class ExecutionPolicy, class ForwardIter, class Function&gt;
    void for_each(ExecutionPolicy&amp;&amp; exec,
                  ForwardIter first, ForwardIter last, Function f);
 
  namespace ranges {
    template&lt;class I, class F&gt;
      using for_each_result = in_fun_result&lt;I, F&gt;;
 
    template&lt;input_iterator I, sentinel_for&lt;I&gt; S, class Proj = identity,
             indirectly_unary_invocable&lt;projected&lt;I, Proj&gt;&gt; Fun&gt;
      constexpr for_each_result&lt;I, Fun&gt;
        for_each(I first, S last, Fun f, Proj proj = {});
    template&lt;input_range R, class Proj = identity,
             indirectly_unary_invocable&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Fun&gt;
      constexpr for_each_result&lt;borrowed_iterator_t&lt;R&gt;, Fun&gt;
        for_each(R&amp;&amp; r, Fun f, Proj proj = {});
  }
 
  template&lt;class InputIter, class Size, class Function&gt;
    constexpr InputIter for_each_n(InputIter first, Size n, Function f);
  template&lt;class ExecutionPolicy, class ForwardIter, class Size, class Function&gt;
    ForwardIter for_each_n(ExecutionPolicy&amp;&amp; exec,
                               ForwardIter first, Size n, Function f);
 
  namespace ranges {
    template&lt;class I, class F&gt;
      using for_each_n_result = in_fun_result&lt;I, F&gt;;
 
    template&lt;input_iterator I, class Proj = identity,
             indirectly_unary_invocable&lt;projected&lt;I, Proj&gt;&gt; Fun&gt;
      constexpr for_each_n_result&lt;I, Fun&gt;
        for_each_n(I first, iter_difference_t&lt;I&gt; n, Fun f, Proj proj = {});
  }
 
  // find
  template&lt;class InputIter, class T&gt;
    constexpr InputIter find(InputIter first, InputIter last,
                                 const T&amp; value);
  template&lt;class ExecutionPolicy, class ForwardIter, class T&gt;
    ForwardIter find(ExecutionPolicy&amp;&amp; exec,
                         ForwardIter first, ForwardIter last,
                         const T&amp; value);
  template&lt;class InputIter, class Pred&gt;
    constexpr InputIter find_if(InputIter first, InputIter last,
                                    Pred pred);
  template&lt;class ExecutionPolicy, class ForwardIter, class Pred&gt;
    ForwardIter find_if(ExecutionPolicy&amp;&amp; exec,
                            ForwardIter first, ForwardIter last,
                            Pred pred);
  template&lt;class InputIter, class Pred&gt;
    constexpr InputIter find_if_not(InputIter first, InputIter last,
                                        Pred pred);
  template&lt;class ExecutionPolicy, class ForwardIter, class Pred&gt;
    ForwardIter find_if_not(ExecutionPolicy&amp;&amp; exec,
                                ForwardIter first, ForwardIter last,
                                Pred pred);
 
  namespace ranges {
    template&lt;input_iterator I, sentinel_for&lt;I&gt; S, class T, class Proj = identity&gt;
      requires indirect_binary_predicate&lt;ranges::equal_to, projected&lt;I, Proj&gt;, const T*&gt;
      constexpr I find(I first, S last, const T&amp; value, Proj proj = {});
    template&lt;input_range R, class T, class Proj = identity&gt;
      requires indirect_binary_predicate&lt;ranges::equal_to,
                                         projected&lt;iterator_t&lt;R&gt;, Proj&gt;, const T*&gt;
      constexpr borrowed_iterator_t&lt;R&gt;
        find(R&amp;&amp; r, const T&amp; value, Proj proj = {});
    template&lt;input_iterator I, sentinel_for&lt;I&gt; S, class Proj = identity,
             indirect_unary_predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
      constexpr I find_if(I first, S last, Pred pred, Proj proj = {});
    template&lt;input_range R, class Proj = identity,
             indirect_unary_predicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
      constexpr borrowed_iterator_t&lt;R&gt;
        find_if(R&amp;&amp; r, Pred pred, Proj proj = {});
    template&lt;input_iterator I, sentinel_for&lt;I&gt; S, class Proj = identity,
             indirect_unary_predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
      constexpr I find_if_not(I first, S last, Pred pred, Proj proj = {});
    template&lt;input_range R, class Proj = identity,
             indirect_unary_predicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
      constexpr borrowed_iterator_t&lt;R&gt;
        find_if_not(R&amp;&amp; r, Pred pred, Proj proj = {});
  }
 
  // find last
  namespace ranges {
    template&lt;forward_iterator I, sentinel_for&lt;I&gt; S, class T, class Proj = identity&gt;
      requires indirect_binary_predicate&lt;ranges::equal_to, projected&lt;I, Proj&gt;, const T*&gt;
      constexpr subrange&lt;I&gt; find_last(I first, S last, const T&amp; value, Proj proj = {});
    template&lt;forward_range R, class T, class Proj = identity&gt;
      requires
        indirect_binary_predicate&lt;ranges::equal_to,
                                  projected&lt;iterator_t&lt;R&gt;, Proj&gt;, const T*&gt;
      constexpr borrowed_subrange_t&lt;R&gt; find_last(R&amp;&amp; r, const T&amp; value, Proj proj = {});
    template&lt;forward_iterator I, sentinel_for&lt;I&gt; S, class Proj = identity,
             indirect_unary_predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
      constexpr subrange&lt;I&gt; find_last_if(I first, S last, Pred pred, Proj proj = {});
    template&lt;forward_range R, class Proj = identity,
             indirect_unary_predicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
      constexpr borrowed_subrange_t&lt;R&gt; find_last_if(R&amp;&amp; r, Pred pred, Proj proj = {});
    template&lt;forward_iterator I, sentinel_for&lt;I&gt; S, class Proj = identity,
             indirect_unary_predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
      constexpr subrange&lt;I&gt; find_last_if_not(I first, S last, Pred pred, Proj proj = {});
    template&lt;forward_range R, class Proj = identity,
             indirect_unary_predicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
      constexpr borrowed_subrange_t&lt;R&gt; find_last_if_not(R&amp;&amp; r, Pred pred, Proj proj = {});
  }
 
  // find end
  template&lt;class ForwardIter1, class ForwardIter2&gt;
    constexpr ForwardIter1
      find_end(ForwardIter1 first1, ForwardIter1 last1,
               ForwardIter2 first2, ForwardIter2 last2);
  template&lt;class ForwardIter1, class ForwardIter2, class BinaryPred&gt;
    constexpr ForwardIter1
      find_end(ForwardIter1 first1, ForwardIter1 last1,
               ForwardIter2 first2, ForwardIter2 last2,
               BinaryPred pred);
  template&lt;class ExecutionPolicy, class ForwardIter1, class ForwardIter2&gt;
    ForwardIter1
      find_end(ExecutionPolicy&amp;&amp; exec,
               ForwardIter1 first1, ForwardIter1 last1,
               ForwardIter2 first2, ForwardIter2 last2);
  template&lt;class ExecutionPolicy, class ForwardIter1,
           class ForwardIter2, class BinaryPred&gt;
    ForwardIter1
      find_end(ExecutionPolicy&amp;&amp; exec,
               ForwardIter1 first1, ForwardIter1 last1,
               ForwardIter2 first2, ForwardIter2 last2,
               BinaryPred pred);
 
  namespace ranges {
    template&lt;forward_iterator I1, sentinel_for&lt;I1&gt; S1, forward_iterator I2,
             sentinel_for&lt;I2&gt; S2, class Pred = ranges::equal_to,
             class Proj1 = identity, class Proj2 = identity&gt;
      requires indirectly_comparable&lt;I1, I2, Pred, Proj1, Proj2&gt;
      constexpr subrange&lt;I1&gt;
        find_end(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                 Proj1 proj1 = {}, Proj2 proj2 = {});
    template&lt;forward_range R1, forward_range R2, class Pred = ranges::equal_to,
             class Proj1 = identity, class Proj2 = identity&gt;
      requires indirectly_comparable&lt;iterator_t&lt;R1&gt;, iterator_t&lt;R2&gt;, Pred, Proj1, Proj2&gt;
      constexpr borrowed_subrange_t&lt;R1&gt;
        find_end(R1&amp;&amp; r1, R2&amp;&amp; r2, Pred pred = {},
                 Proj1 proj1 = {}, Proj2 proj2 = {});
  }
 
  // find first
  template&lt;class InputIter, class ForwardIter&gt;
    constexpr InputIter
      find_first_of(InputIter first1, InputIter last1,
                    ForwardIter first2, ForwardIter last2);
  template&lt;class InputIter, class ForwardIter, class BinaryPred&gt;
    constexpr InputIter
      find_first_of(InputIter first1, InputIter last1,
                    ForwardIter first2, ForwardIter last2,
                    BinaryPred pred);
  template&lt;class ExecutionPolicy, class ForwardIter1, class ForwardIter2&gt;
    ForwardIter1
      find_first_of(ExecutionPolicy&amp;&amp; exec,
                    ForwardIter1 first1, ForwardIter1 last1,
                    ForwardIter2 first2, ForwardIter2 last2);
  template&lt;class ExecutionPolicy, class ForwardIter1,
           class ForwardIter2, class BinaryPred&gt;
    ForwardIter1
      find_first_of(ExecutionPolicy&amp;&amp; exec,
                    ForwardIter1 first1, ForwardIter1 last1,
                    ForwardIter2 first2, ForwardIter2 last2,
                    BinaryPred pred);
 
  namespace ranges {
    template&lt;input_iterator I1, sentinel_for&lt;I1&gt; S1, forward_iterator I2,
             sentinel_for&lt;I2&gt; S2, class Pred = ranges::equal_to, class Proj1 = identity,
             class Proj2 = identity&gt;
      requires indirectly_comparable&lt;I1, I2, Pred, Proj1, Proj2&gt;
      constexpr I1 find_first_of(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                                 Proj1 proj1 = {}, Proj2 proj2 = {});
    template&lt;input_range R1, forward_range R2,
             class Pred = ranges::equal_to, class Proj1 = identity,
             class Proj2 = identity&gt;
      requires indirectly_comparable&lt;iterator_t&lt;R1&gt;, iterator_t&lt;R2&gt;, Pred, Proj1, Proj2&gt;
      constexpr borrowed_iterator_t&lt;R1&gt;
        find_first_of(R1&amp;&amp; r1, R2&amp;&amp; r2, Pred pred = {},
                      Proj1 proj1 = {}, Proj2 proj2 = {});
  }
 
  // adjacent find
  template&lt;class ForwardIter&gt;
    constexpr ForwardIter
      adjacent_find(ForwardIter first, ForwardIter last);
  template&lt;class ForwardIter, class BinaryPred&gt;
    constexpr ForwardIter
      adjacent_find(ForwardIter first, ForwardIter last,
                    BinaryPred pred);
  template&lt;class ExecutionPolicy, class ForwardIter&gt;
    ForwardIter
      adjacent_find(ExecutionPolicy&amp;&amp; exec,
                    ForwardIter first, ForwardIter last);
  template&lt;class ExecutionPolicy, class ForwardIter, class BinaryPred&gt;
    ForwardIter
      adjacent_find(ExecutionPolicy&amp;&amp; exec,
                    ForwardIter first, ForwardIter last,
                    BinaryPred pred);
 
  namespace ranges {
    template&lt;forward_iterator I, sentinel_for&lt;I&gt; S, class Proj = identity,
             indirect_binary_predicate&lt;projected&lt;I, Proj&gt;,
                                       projected&lt;I, Proj&gt;&gt; Pred = ranges::equal_to&gt;
      constexpr I adjacent_find(I first, S last, Pred pred = {},
                                Proj proj = {});
    template&lt;forward_range R, class Proj = identity,
             indirect_binary_predicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;,
                                       projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred =
                                           ranges::equal_to&gt;
      constexpr borrowed_iterator_t&lt;R&gt;
        adjacent_find(R&amp;&amp; r, Pred pred = {}, Proj proj = {});
  }
 
  // count
  template&lt;class InputIter, class T&gt;
    constexpr typename iterator_traits&lt;InputIter&gt;::difference_type
      count(InputIter first, InputIter last, const T&amp; value);
  template&lt;class ExecutionPolicy, class ForwardIter, class T&gt;
    typename iterator_traits&lt;ForwardIter&gt;::difference_type
      count(ExecutionPolicy&amp;&amp; exec,
            ForwardIter first, ForwardIter last, const T&amp; value);
  template&lt;class InputIter, class Pred&gt;
    constexpr typename iterator_traits&lt;InputIter&gt;::difference_type
      count_if(InputIter first, InputIter last, Pred pred);
  template&lt;class ExecutionPolicy, class ForwardIter, class Pred&gt;
    typename iterator_traits&lt;ForwardIter&gt;::difference_type
      count_if(ExecutionPolicy&amp;&amp; exec,
               ForwardIter first, ForwardIter last, Pred pred);
 
  namespace ranges {
    template&lt;input_iterator I, sentinel_for&lt;I&gt; S, class T, class Proj = identity&gt;
      requires indirect_binary_predicate&lt;ranges::equal_to, projected&lt;I, Proj&gt;, const T*&gt;
      constexpr iter_difference_t&lt;I&gt;
        count(I first, S last, const T&amp; value, Proj proj = {});
    template&lt;input_range R, class T, class Proj = identity&gt;
      requires indirect_binary_predicate&lt;ranges::equal_to,
                                         projected&lt;iterator_t&lt;R&gt;, Proj&gt;, const T*&gt;
      constexpr range_difference_t&lt;R&gt;
        count(R&amp;&amp; r, const T&amp; value, Proj proj = {});
    template&lt;input_iterator I, sentinel_for&lt;I&gt; S, class Proj = identity,
             indirect_unary_predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
      constexpr iter_difference_t&lt;I&gt;
        count_if(I first, S last, Pred pred, Proj proj = {});
    template&lt;input_range R, class Proj = identity,
             indirect_unary_predicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
      constexpr range_difference_t&lt;R&gt;
        count_if(R&amp;&amp; r, Pred pred, Proj proj = {});
  }
 
  // mismatch
  template&lt;class InputIter1, class InputIter2&gt;
    constexpr pair&lt;InputIter1, InputIter2&gt;
      mismatch(InputIter1 first1, InputIter1 last1,
               InputIter2 first2);
  template&lt;class InputIter1, class InputIter2, class BinaryPred&gt;
    constexpr pair&lt;InputIter1, InputIter2&gt;
      mismatch(InputIter1 first1, InputIter1 last1,
               InputIter2 first2, BinaryPred pred);
  template&lt;class InputIter1, class InputIter2&gt;
    constexpr pair&lt;InputIter1, InputIter2&gt;
      mismatch(InputIter1 first1, InputIter1 last1,
               InputIter2 first2, InputIter2 last2);
  template&lt;class InputIter1, class InputIter2, class BinaryPred&gt;
    constexpr pair&lt;InputIter1, InputIter2&gt;
      mismatch(InputIter1 first1, InputIter1 last1,
               InputIter2 first2, InputIter2 last2,
               BinaryPred pred);
  template&lt;class ExecutionPolicy, class ForwardIter1, class ForwardIter2&gt;
    pair&lt;ForwardIter1, ForwardIter2&gt;
      mismatch(ExecutionPolicy&amp;&amp; exec,
               ForwardIter1 first1, ForwardIter1 last1,
               ForwardIter2 first2);
  template&lt;class ExecutionPolicy, class ForwardIter1, class ForwardIter2,
           class BinaryPred&gt;
    pair&lt;ForwardIter1, ForwardIter2&gt;
      mismatch(ExecutionPolicy&amp;&amp; exec,
               ForwardIter1 first1, ForwardIter1 last1,
               ForwardIter2 first2, BinaryPred pred);
  template&lt;class ExecutionPolicy, class ForwardIter1, class ForwardIter2&gt;
    pair&lt;ForwardIter1, ForwardIter2&gt;
      mismatch(ExecutionPolicy&amp;&amp; exec,
               ForwardIter1 first1, ForwardIter1 last1,
               ForwardIter2 first2, ForwardIter2 last2);
  template&lt;class ExecutionPolicy, class ForwardIter1, class ForwardIter2,
           class BinaryPred&gt;
    pair&lt;ForwardIter1, ForwardIter2&gt;
      mismatch(ExecutionPolicy&amp;&amp; exec,
               ForwardIter1 first1, ForwardIter1 last1,
               ForwardIter2 first2, ForwardIter2 last2,
               BinaryPred pred);
 
  namespace ranges {
    template&lt;class I1, class I2&gt;
      using mismatch_result = in_in_result&lt;I1, I2&gt;;
 
    template&lt;input_iterator I1, sentinel_for&lt;I1&gt; S1, input_iterator I2,
             sentinel_for&lt;I2&gt; S2,
             class Pred = ranges::equal_to, class Proj1 = identity,
             class Proj2 = identity&gt;
      requires indirectly_comparable&lt;I1, I2, Pred, Proj1, Proj2&gt;
      constexpr mismatch_result&lt;I1, I2&gt;
        mismatch(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                 Proj1 proj1 = {}, Proj2 proj2 = {});
    template&lt;input_range R1, input_range R2,
             class Pred = ranges::equal_to, class Proj1 = identity,
             class Proj2 = identity&gt;
      requires indirectly_comparable&lt;iterator_t&lt;R1&gt;, iterator_t&lt;R2&gt;, Pred, Proj1, Proj2&gt;
      constexpr mismatch_result&lt;borrowed_iterator_t&lt;R1&gt;, borrowed_iterator_t&lt;R2&gt;&gt;
        mismatch(R1&amp;&amp; r1, R2&amp;&amp; r2, Pred pred = {},
                 Proj1 proj1 = {}, Proj2 proj2 = {});
  }
 
  // equal
  template&lt;class InputIter1, class InputIter2&gt;
    constexpr bool equal(InputIter1 first1, InputIter1 last1,
                         InputIter2 first2);
  template&lt;class InputIter1, class InputIter2, class BinaryPred&gt;
    constexpr bool equal(InputIter1 first1, InputIter1 last1,
                         InputIter2 first2, BinaryPred pred);
  template&lt;class InputIter1, class InputIter2&gt;
    constexpr bool equal(InputIter1 first1, InputIter1 last1,
                         InputIter2 first2, InputIter2 last2);
  template&lt;class InputIter1, class InputIter2, class BinaryPred&gt;
    constexpr bool equal(InputIter1 first1, InputIter1 last1,
                         InputIter2 first2, InputIter2 last2,
                         BinaryPred pred);
  template&lt;class ExecutionPolicy, class ForwardIter1, class ForwardIter2&gt;
    bool equal(ExecutionPolicy&amp;&amp; exec,
               ForwardIter1 first1, ForwardIter1 last1,
               ForwardIter2 first2);
  template&lt;class ExecutionPolicy, class ForwardIter1, class ForwardIter2,
           class BinaryPred&gt;
    bool equal(ExecutionPolicy&amp;&amp; exec,
               ForwardIter1 first1, ForwardIter1 last1,
               ForwardIter2 first2, BinaryPred pred);
  template&lt;class ExecutionPolicy, class ForwardIter1, class ForwardIter2&gt;
    bool equal(ExecutionPolicy&amp;&amp; exec,
               ForwardIter1 first1, ForwardIter1 last1,
               ForwardIter2 first2, ForwardIter2 last2);
  template&lt;class ExecutionPolicy, class ForwardIter1, class ForwardIter2,
           class BinaryPred&gt;
    bool equal(ExecutionPolicy&amp;&amp; exec,
               ForwardIter1 first1, ForwardIter1 last1,
               ForwardIter2 first2, ForwardIter2 last2,
               BinaryPred pred);
 
  namespace ranges {
    template&lt;input_iterator I1, sentinel_for&lt;I1&gt; S1, input_iterator I2,
             sentinel_for&lt;I2&gt; S2,
             class Pred = ranges::equal_to, class Proj1 = identity,
             class Proj2 = identity&gt;
      requires indirectly_comparable&lt;I1, I2, Pred, Proj1, Proj2&gt;
      constexpr bool equal(I1 first1, S1 last1, I2 first2, S2 last2,
                           Pred pred = {},
                           Proj1 proj1 = {}, Proj2 proj2 = {});
    template&lt;input_range R1, input_range R2, class Pred = ranges::equal_to,
             class Proj1 = identity, class Proj2 = identity&gt;
      requires indirectly_comparable&lt;iterator_t&lt;R1&gt;, iterator_t&lt;R2&gt;, Pred, Proj1, Proj2&gt;
      constexpr bool equal(R1&amp;&amp; r1, R2&amp;&amp; r2, Pred pred = {},
                           Proj1 proj1 = {}, Proj2 proj2 = {});
  }
 
  // is permutation
  template&lt;class ForwardIter1, class ForwardIter2&gt;
    constexpr bool is_permutation(ForwardIter1 first1, ForwardIter1 last1,
                                  ForwardIter2 first2);
  template&lt;class ForwardIter1, class ForwardIter2, class BinaryPred&gt;
    constexpr bool is_permutation(ForwardIter1 first1, ForwardIter1 last1,
                                  ForwardIter2 first2, BinaryPred pred);
  template&lt;class ForwardIter1, class ForwardIter2&gt;
    constexpr bool is_permutation(ForwardIter1 first1, ForwardIter1 last1,
                                  ForwardIter2 first2, ForwardIter2 last2);
  template&lt;class ForwardIter1, class ForwardIter2, class BinaryPred&gt;
    constexpr bool is_permutation(ForwardIter1 first1, ForwardIter1 last1,
                                  ForwardIter2 first2, ForwardIter2 last2,
                                  BinaryPred pred);
 
  namespace ranges {
    template&lt;forward_iterator I1, sentinel_for&lt;I1&gt; S1, forward_iterator I2,
             sentinel_for&lt;I2&gt; S2, class Proj1 = identity, class Proj2 = identity,
             indirect_equivalence_relation&lt;projected&lt;I1, Proj1&gt;,
                                           projected&lt;I2, Proj2&gt;&gt; Pred = ranges::equal_to&gt;
      constexpr bool is_permutation(I1 first1, S1 last1, I2 first2, S2 last2,
                                    Pred pred = {},
                                    Proj1 proj1 = {}, Proj2 proj2 = {});
    template&lt;forward_range R1, forward_range R2,
             class Proj1 = identity, class Proj2 = identity,
             indirect_equivalence_relation&lt;projected&lt;iterator_t&lt;R1&gt;, Proj1&gt;,
                                           projected&lt;iterator_t&lt;R2&gt;, Proj2&gt;&gt;
               Pred = ranges::equal_to&gt;
      constexpr bool is_permutation(R1&amp;&amp; r1, R2&amp;&amp; r2, Pred pred = {},
                                    Proj1 proj1 = {}, Proj2 proj2 = {});
  }
 
  // search
  template&lt;class ForwardIter1, class ForwardIter2&gt;
    constexpr ForwardIter1
      search(ForwardIter1 first1, ForwardIter1 last1,
             ForwardIter2 first2, ForwardIter2 last2);
  template&lt;class ForwardIter1, class ForwardIter2, class BinaryPred&gt;
    constexpr ForwardIter1
      search(ForwardIter1 first1, ForwardIter1 last1,
             ForwardIter2 first2, ForwardIter2 last2,
             BinaryPred pred);
  template&lt;class ExecutionPolicy, class ForwardIter1, class ForwardIter2&gt;
    ForwardIter1
      search(ExecutionPolicy&amp;&amp; exec,
             ForwardIter1 first1, ForwardIter1 last1,
             ForwardIter2 first2, ForwardIter2 last2);
  template&lt;class ExecutionPolicy, class ForwardIter1, class ForwardIter2,
           class BinaryPred&gt;
    ForwardIter1
      search(ExecutionPolicy&amp;&amp; exec,
             ForwardIter1 first1, ForwardIter1 last1,
             ForwardIter2 first2, ForwardIter2 last2,
             BinaryPred pred);
 
  namespace ranges {
    template&lt;forward_iterator I1, sentinel_for&lt;I1&gt; S1, forward_iterator I2,
             sentinel_for&lt;I2&gt; S2, class Pred = ranges::equal_to,
             class Proj1 = identity, class Proj2 = identity&gt;
      requires indirectly_comparable&lt;I1, I2, Pred, Proj1, Proj2&gt;
      constexpr subrange&lt;I1&gt;
        search(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
               Proj1 proj1 = {}, Proj2 proj2 = {});
    template&lt;forward_range R1, forward_range R2, class Pred = ranges::equal_to,
             class Proj1 = identity, class Proj2 = identity&gt;
      requires indirectly_comparable&lt;iterator_t&lt;R1&gt;, iterator_t&lt;R2&gt;, Pred, Proj1, Proj2&gt;
      constexpr borrowed_subrange_t&lt;R1&gt;
        search(R1&amp;&amp; r1, R2&amp;&amp; r2, Pred pred = {},
               Proj1 proj1 = {}, Proj2 proj2 = {});
  }
 
  template&lt;class ForwardIter, class Size, class T&gt;
    constexpr ForwardIter
      search_n(ForwardIter first, ForwardIter last,
               Size count, const T&amp; value);
  template&lt;class ForwardIter, class Size, class T, class BinaryPred&gt;
    constexpr ForwardIter
      search_n(ForwardIter first, ForwardIter last,
               Size count, const T&amp; value, BinaryPred pred);
  template&lt;class ExecutionPolicy, class ForwardIter, class Size, class T&gt;
    ForwardIter
      search_n(ExecutionPolicy&amp;&amp; exec,
               ForwardIter first, ForwardIter last,
               Size count, const T&amp; value);
  template&lt;class ExecutionPolicy, class ForwardIter, class Size, class T,
           class BinaryPred&gt;
    ForwardIter
      search_n(ExecutionPolicy&amp;&amp; exec,
               ForwardIter first, ForwardIter last,
               Size count, const T&amp; value,
               BinaryPred pred);
 
  namespace ranges {
    template&lt;forward_iterator I, sentinel_for&lt;I&gt; S, class T,
             class Pred = ranges::equal_to, class Proj = identity&gt;
      requires indirectly_comparable&lt;I, const T*, Pred, Proj&gt;
      constexpr subrange&lt;I&gt;
        search_n(I first, S last, iter_difference_t&lt;I&gt; count,
                 const T&amp; value, Pred pred = {}, Proj proj = {});
    template&lt;forward_range R, class T, class Pred = ranges::equal_to,
             class Proj = identity&gt;
      requires indirectly_comparable&lt;iterator_t&lt;R&gt;, const T*, Pred, Proj&gt;
      constexpr borrowed_subrange_t&lt;R&gt;
        search_n(R&amp;&amp; r, range_difference_t&lt;R&gt; count,
                 const T&amp; value, Pred pred = {}, Proj proj = {});
  }
 
  template&lt;class ForwardIter, class Searcher&gt;
    constexpr ForwardIter
      search(ForwardIter first, ForwardIter last, const Searcher&amp; searcher);
 
  namespace ranges {
    // starts with
    template&lt;input_iterator I1, sentinel_for&lt;I1&gt; S1, input_iterator I2,
             sentinel_for&lt;I2&gt; S2,
             class Pred = ranges::equal_to, class Proj1 = identity,
             class Proj2 = identity&gt;
      requires indirectly_comparable&lt;I1, I2, Pred, Proj1, Proj2&gt;
      constexpr bool starts_with(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                                 Proj1 proj1 = {}, Proj2 proj2 = {});
    template&lt;input_range R1, input_range R2, class Pred = ranges::equal_to,
             class Proj1 = identity, class Proj2 = identity&gt;
      requires indirectly_comparable&lt;iterator_t&lt;R1&gt;, iterator_t&lt;R2&gt;, Pred, Proj1, Proj2&gt;
      constexpr bool starts_with(R1&amp;&amp; r1, R2&amp;&amp; r2, Pred pred = {},
                                 Proj1 proj1 = {}, Proj2 proj2 = {});
 
    // ends with
    template&lt;input_iterator I1, sentinel_for&lt;I1&gt; S1, input_iterator I2,
             sentinel_for&lt;I2&gt; S2,
             class Pred = ranges::equal_to, class Proj1 = identity,
             class Proj2 = identity&gt;
      requires (forward_iterator&lt;I1&gt; || sized_sentinel_for&lt;S1, I1&gt;) &amp;&amp;
               (forward_iterator&lt;I2&gt; || sized_sentinel_for&lt;S2, I2&gt;) &amp;&amp;
               indirectly_comparable&lt;I1, I2, Pred, Proj1, Proj2&gt;
      constexpr bool ends_with(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                               Proj1 proj1 = {}, Proj2 proj2 = {});
    template&lt;input_range R1, input_range R2, class Pred = ranges::equal_to,
             class Proj1 = identity, class Proj2 = identity&gt;
      requires (forward_range&lt;R1&gt; || sized_range&lt;R1&gt;) &amp;&amp;
               (forward_range&lt;R2&gt; || sized_range&lt;R2&gt;) &amp;&amp;
               indirectly_comparable&lt;iterator_t&lt;R1&gt;, iterator_t&lt;R2&gt;, Pred, Proj1, Proj2&gt;
      constexpr bool ends_with(R1&amp;&amp; r1, R2&amp;&amp; r2, Pred pred = {},
                               Proj1 proj1 = {}, Proj2 proj2 = {});
 
    // fold
    template&lt;class F&gt;
    class flipped {     // exposition only
      F f;              // exposition only
 
    public:
      template&lt;class T, class U&gt; requires invocable&lt;F&amp;, U, T&gt;
      invoke_result_t&lt;F&amp;, U, T&gt; operator()(T&amp;&amp;, U&amp;&amp;);
    };
 
    template&lt;class F, class T, class I, class U&gt;
      concept /*indirectly-binary-left-foldable-impl*/ =  // exposition only
        movable&lt;T&gt; &amp;&amp; movable&lt;U&gt; &amp;&amp;
        convertible_to&lt;T, U&gt; &amp;&amp; invocable&lt;F&amp;, U, iter_reference_t&lt;I&gt;&gt; &amp;&amp;
        assignable_from&lt;U&amp;, invoke_result_t&lt;F&amp;, U, iter_reference_t&lt;I&gt;&gt;&gt;;
 
    template&lt;class F, class T, class I&gt;
      concept /*indirectly-binary-left-foldable*/ =      // exposition only
        copy_constructible&lt;F&gt; &amp;&amp; indirectly_readable&lt;I&gt; &amp;&amp;
        invocable&lt;F&amp;, T, iter_reference_t&lt;I&gt;&gt; &amp;&amp;
        convertible_to&lt;invoke_result_t&lt;F&amp;, T, iter_reference_t&lt;I&gt;&gt;,
               decay_t&lt;invoke_result_t&lt;F&amp;, T, iter_reference_t&lt;I&gt;&gt;&gt;&gt; &amp;&amp;
        /*indirectly-binary-left-foldable-impl*/&lt;F, T, I,
                        decay_t&lt;invoke_result_t&lt;F&amp;, T, iter_reference_t&lt;I&gt;&gt;&gt;&gt;;
 
    template&lt;class F, class T, class I&gt;
      concept /*indirectly-binary-right-foldable*/ =    // exposition only
        /*indirectly-binary-left-foldable*/&lt;flipped&lt;F&gt;, T, I&gt;;
 
    template&lt;input_iterator I, sentinel_for&lt;I&gt; S, class T,
             /*indirectly-binary-left-foldable*/&lt;T, I&gt; F&gt;
      constexpr auto fold_left(I first, S last, T init, F f);
 
    template&lt;input_range R, class T,
             /*indirectly-binary-left-foldable*/&lt;T, iterator_t&lt;R&gt;&gt; F&gt;
      constexpr auto fold_left(R&amp;&amp; r, T init, F f);
 
    template&lt;input_iterator I, sentinel_for&lt;I&gt; S,
             /*indirectly-binary-left-foldable*/&lt;iter_value_t&lt;I&gt;, I&gt; F&gt;
      requires constructible_from&lt;iter_value_t&lt;I&gt;, iter_reference_t&lt;I&gt;&gt;
      constexpr auto fold_left_first(I first, S last, F f);
 
    template&lt;input_range R, /*indirectly-binary-left-foldable*/&lt;range_value_t&lt;R&gt;,
             iterator_t&lt;R&gt;&gt; F&gt;
      requires constructible_from&lt;range_value_t&lt;R&gt;, range_reference_t&lt;R&gt;&gt;
      constexpr auto fold_left_first(R&amp;&amp; r, F f);
 
    template&lt;bidirectional_iterator I, sentinel_for&lt;I&gt; S, class T,
      /*indirectly-binary-right-foldable*/&lt;T, I&gt; F&gt;
      constexpr auto fold_right(I first, S last, T init, F f);
 
    template&lt;bidirectional_range R, class T,
      /*indirectly-binary-right-foldable*/&lt;T, iterator_t&lt;R&gt;&gt; F&gt;
      constexpr auto fold_right(R&amp;&amp; r, T init, F f);
 
    template &lt;bidirectional_iterator I, sentinel_for&lt;I&gt; S,
      /*indirectly-binary-right-foldable*/&lt;iter_value_t&lt;I&gt;, I&gt; F&gt;
      requires constructible_from&lt;iter_value_t&lt;I&gt;, iter_reference_t&lt;I&gt;&gt;
    constexpr auto fold_right_last(I first, S last, F f);
 
    template&lt;bidirectional_range R,
             /*indirectly-binary-right-foldable*/&lt;range_value_t&lt;R&gt;, iterator_t&lt;R&gt;&gt; F&gt;
      requires constructible_from&lt;range_value_t&lt;R&gt;, range_reference_t&lt;R&gt;&gt;
      constexpr auto fold_right_last(R&amp;&amp; r, F f);
 
    template&lt;class I, class T&gt;
      using fold_left_with_iter_result = in_value_result&lt;I, T&gt;;
    template&lt;class I, class T&gt;
      using fold_left_first_with_iter_result = in_value_result&lt;I, T&gt;;
 
    template&lt;input_iterator I, sentinel_for&lt;I&gt; S, class T,
       /*indirectly-binary-left-foldable*/&lt;T, I&gt; F&gt;
      constexpr /* see description */ fold_left_with_iter(I first, S last, T init, F f);
 
    template&lt;input_range R, class T,
             /*indirectly-binary-left-foldable*/&lt;T, iterator_t&lt;R&gt;&gt; F&gt;
      constexpr /* see description */ fold_left_with_iter(R&amp;&amp; r, T init, F f);
 
    template&lt;input_iterator I, sentinel_for&lt;I&gt; S,
             /*indirectly-binary-left-foldable*/&lt;iter_value_t&lt;I&gt;, I&gt; F&gt;
      requires constructible_from&lt;iter_value_t&lt;I&gt;, iter_reference_t&lt;I&gt;&gt;
      constexpr /* see description */ fold_left_first_with_iter(I first, S last, F f);
 
    template&lt;input_range R,
             /*indirectly-binary-left-foldable*/&lt;range_value_t&lt;R&gt;, iterator_t&lt;R&gt;&gt; F&gt;
      requires constructible_from&lt;range_value_t&lt;R&gt;, range_reference_t&lt;R&gt;&gt;
      constexpr /* see description */ fold_left_first_with_iter(R&amp;&amp; r, F f);
  }
 
  // mutating sequence operations
  // copy
  template&lt;class InputIter, class OutputIter&gt;
    constexpr OutputIter copy(InputIter first, InputIter last,
                                  OutputIter result);
  template&lt;class ExecutionPolicy, class ForwardIter1, class ForwardIter2&gt;
    ForwardIter2 copy(ExecutionPolicy&amp;&amp; exec,
                          ForwardIter1 first, ForwardIter1 last,
                          ForwardIter2 result);
 
  namespace ranges {
    template&lt;class I, class O&gt;
      using copy_result = in_out_result&lt;I, O&gt;;
 
    template&lt;input_iterator I, sentinel_for&lt;I&gt; S, weakly_incrementable O&gt;
      requires indirectly_copyable&lt;I, O&gt;
      constexpr copy_result&lt;I, O&gt;
        copy(I first, S last, O result);
    template&lt;input_range R, weakly_incrementable O&gt;
      requires indirectly_copyable&lt;iterator_t&lt;R&gt;, O&gt;
      constexpr copy_result&lt;borrowed_iterator_t&lt;R&gt;, O&gt;
        copy(R&amp;&amp; r, O result);
  }
 
  template&lt;class InputIter, class Size, class OutputIter&gt;
    constexpr OutputIter copy_n(InputIter first, Size n,
                                    OutputIter result);
  template&lt;class ExecutionPolicy, class ForwardIter1, class Size,
           class ForwardIter2&gt;
    ForwardIter2 copy_n(ExecutionPolicy&amp;&amp; exec,
                            ForwardIter1 first, Size n,
                            ForwardIter2 result);
 
  namespace ranges {
    template&lt;class I, class O&gt;
      using copy_n_result = in_out_result&lt;I, O&gt;;
 
    template&lt;input_iterator I, weakly_incrementable O&gt;
      requires indirectly_copyable&lt;I, O&gt;
      constexpr copy_n_result&lt;I, O&gt;
        copy_n(I first, iter_difference_t&lt;I&gt; n, O result);
  }
 
  template&lt;class InputIter, class OutputIter, class Pred&gt;
    constexpr OutputIter copy_if(InputIter first, InputIter last,
                                     OutputIter result, Pred pred);
  template&lt;class ExecutionPolicy, class ForwardIter1, class ForwardIter2,
           class Pred&gt;
    ForwardIter2 copy_if(ExecutionPolicy&amp;&amp; exec,
                             ForwardIter1 first, ForwardIter1 last,
                             ForwardIter2 result, Pred pred);
 
  namespace ranges {
    template&lt;class I, class O&gt;
      using copy_if_result = in_out_result&lt;I, O&gt;;
 
    template&lt;input_iterator I, sentinel_for&lt;I&gt; S, weakly_incrementable O,
             class Proj = identity,
             indirect_unary_predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
      requires indirectly_copyable&lt;I, O&gt;
      constexpr copy_if_result&lt;I, O&gt;
        copy_if(I first, S last, O result, Pred pred, Proj proj = {});
    template&lt;input_range R, weakly_incrementable O, class Proj = identity,
             indirect_unary_predicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
      requires indirectly_copyable&lt;iterator_t&lt;R&gt;, O&gt;
      constexpr copy_if_result&lt;borrowed_iterator_t&lt;R&gt;, O&gt;
        copy_if(R&amp;&amp; r, O result, Pred pred, Proj proj = {});
  }
 
  template&lt;class BidirectionalIter1, class BidirectionalIter2&gt;
    constexpr BidirectionalIter2
      copy_backward(BidirectionalIter1 first, BidirectionalIter1 last,
                    BidirectionalIter2 result);
 
  namespace ranges {
    template&lt;class I1, class I2&gt;
      using copy_backward_result = in_out_result&lt;I1, I2&gt;;
 
    template&lt;bidirectional_iterator I1, sentinel_for&lt;I1&gt; S1, bidirectional_iterator I2&gt;
      requires indirectly_copyable&lt;I1, I2&gt;
      constexpr copy_backward_result&lt;I1, I2&gt;
        copy_backward(I1 first, S1 last, I2 result);
    template&lt;bidirectional_range R, bidirectional_iterator I&gt;
      requires indirectly_copyable&lt;iterator_t&lt;R&gt;, I&gt;
      constexpr copy_backward_result&lt;borrowed_iterator_t&lt;R&gt;, I&gt;
        copy_backward(R&amp;&amp; r, I result);
  }
 
  // move
  template&lt;class InputIter, class OutputIter&gt;
    constexpr OutputIter move(InputIter first, InputIter last,
                                  OutputIter result);
  template&lt;class ExecutionPolicy, class ForwardIter1,
           class ForwardIter2&gt;
    ForwardIter2 move(ExecutionPolicy&amp;&amp; exec,
                          ForwardIter1 first, ForwardIter1 last,
                          ForwardIter2 result);
 
  namespace ranges {
    template&lt;class I, class O&gt;
      using move_result = in_out_result&lt;I, O&gt;;
 
    template&lt;input_iterator I, sentinel_for&lt;I&gt; S, weakly_incrementable O&gt;
      requires indirectly_movable&lt;I, O&gt;
      constexpr move_result&lt;I, O&gt;
        move(I first, S last, O result);
    template&lt;input_range R, weakly_incrementable O&gt;
      requires indirectly_movable&lt;iterator_t&lt;R&gt;, O&gt;
      constexpr move_result&lt;borrowed_iterator_t&lt;R&gt;, O&gt;
        move(R&amp;&amp; r, O result);
  }
 
  template&lt;class BidirectionalIter1, class BidirectionalIter2&gt;
    constexpr BidirectionalIter2
      move_backward(BidirectionalIter1 first, BidirectionalIter1 last,
                    BidirectionalIter2 result);
 
  namespace ranges {
    template&lt;class I1, class I2&gt;
      using move_backward_result = in_out_result&lt;I1, I2&gt;;
 
    template&lt;bidirectional_iterator I1, sentinel_for&lt;I1&gt; S1, bidirectional_iterator I2&gt;
      requires indirectly_movable&lt;I1, I2&gt;
      constexpr move_backward_result&lt;I1, I2&gt;
        move_backward(I1 first, S1 last, I2 result);
    template&lt;bidirectional_range R, bidirectional_iterator I&gt;
      requires indirectly_movable&lt;iterator_t&lt;R&gt;, I&gt;
      constexpr move_backward_result&lt;borrowed_iterator_t&lt;R&gt;, I&gt;
        move_backward(R&amp;&amp; r, I result);
  }
 
  // swap
  template&lt;class ForwardIter1, class ForwardIter2&gt;
    constexpr ForwardIter2 swap_ranges(ForwardIter1 first1,
                                           ForwardIter1 last1,
                                           ForwardIter2 first2);
  template&lt;class ExecutionPolicy, class ForwardIter1, class ForwardIter2&gt;
    ForwardIter2 swap_ranges(ExecutionPolicy&amp;&amp; exec,
                                 ForwardIter1 first1, ForwardIter1 last1,
                                 ForwardIter2 first2);
 
  namespace ranges {
    template&lt;class I1, class I2&gt;
      using swap_ranges_result = in_in_result&lt;I1, I2&gt;;
 
    template&lt;input_iterator I1, sentinel_for&lt;I1&gt; S1, input_iterator I2,
             sentinel_for&lt;I2&gt; S2&gt;
      requires indirectly_swappable&lt;I1, I2&gt;
      constexpr swap_ranges_result&lt;I1, I2&gt;
        swap_ranges(I1 first1, S1 last1, I2 first2, S2 last2);
    template&lt;input_range R1, input_range R2&gt;
      requires indirectly_swappable&lt;iterator_t&lt;R1&gt;, iterator_t&lt;R2&gt;&gt;
      constexpr swap_ranges_result&lt;borrowed_iterator_t&lt;R1&gt;, borrowed_iterator_t&lt;R2&gt;&gt;
        swap_ranges(R1&amp;&amp; r1, R2&amp;&amp; r2);
  }
 
  template&lt;class ForwardIter1, class ForwardIter2&gt;
    constexpr void iter_swap(ForwardIter1 a, ForwardIter2 b);
 
  // transform
  template&lt;class InputIter, class OutputIter, class UnaryOperation&gt;
    constexpr OutputIter
      transform(InputIter first1, InputIter last1,
                OutputIter result, UnaryOperation op);
  template&lt;class InputIter1, class InputIter2, class OutputIter,
           class BinaryOperation&gt;
    constexpr OutputIter
      transform(InputIter1 first1, InputIter1 last1,
                InputIter2 first2, OutputIter result,
                BinaryOperation binary_op);
  template&lt;class ExecutionPolicy, class ForwardIter1, class ForwardIter2,
           class UnaryOperation&gt;
    ForwardIter2
      transform(ExecutionPolicy&amp;&amp; exec,
                ForwardIter1 first1, ForwardIter1 last1,
                ForwardIter2 result, UnaryOperation op);
  template&lt;class ExecutionPolicy, class ForwardIter1, class ForwardIter2,
           class ForwardIter, class BinaryOperation&gt;
    ForwardIter
      transform(ExecutionPolicy&amp;&amp; exec,
                ForwardIter1 first1, ForwardIter1 last1,
                ForwardIter2 first2, ForwardIter result,
                BinaryOperation binary_op);
 
  namespace ranges {
    template&lt;class I, class O&gt;
      using unary_transform_result = in_out_result&lt;I, O&gt;;
 
    template&lt;input_iterator I, sentinel_for&lt;I&gt; S, weakly_incrementable O,
             copy_constructible F, class Proj = identity&gt;
      requires indirectly_writable&lt;O, indirect_result_t&lt;F&amp;, projected&lt;I, Proj&gt;&gt;&gt;
      constexpr unary_transform_result&lt;I, O&gt;
        transform(I first1, S last1, O result, F op, Proj proj = {});
    template&lt;input_range R, weakly_incrementable O, copy_constructible F,
             class Proj = identity&gt;
      requires indirectly_writable&lt;O,
                   indirect_result_t&lt;F&amp;, projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt;&gt;
      constexpr unary_transform_result&lt;borrowed_iterator_t&lt;R&gt;, O&gt;
        transform(R&amp;&amp; r, O result, F op, Proj proj = {});
 
    template&lt;class I1, class I2, class O&gt;
      using binary_transform_result = in_in_out_result&lt;I1, I2, O&gt;;
 
    template&lt;input_iterator I1, sentinel_for&lt;I1&gt; S1, input_iterator I2,
             sentinel_for&lt;I2&gt; S2,
             weakly_incrementable O, copy_constructible F, class Proj1 = identity,
             class Proj2 = identity&gt;
      requires indirectly_writable&lt;O, indirect_result_t&lt;F&amp;, projected&lt;I1, Proj1&gt;,
                                             projected&lt;I2, Proj2&gt;&gt;&gt;
      constexpr binary_transform_result&lt;I1, I2, O&gt;
        transform(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                  F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {});
    template&lt;input_range R1, input_range R2, weakly_incrementable O,
             copy_constructible F, class Proj1 = identity, class Proj2 = identity&gt;
      requires indirectly_writable&lt;O, indirect_result_t&lt;F&amp;,
                   projected&lt;iterator_t&lt;R1&gt;, Proj1&gt;, projected&lt;iterator_t&lt;R2&gt;, Proj2&gt;&gt;&gt;
      constexpr binary_transform_result&lt;borrowed_iterator_t&lt;R1&gt;,
                                        borrowed_iterator_t&lt;R2&gt;, O&gt;
        transform(R1&amp;&amp; r1, R2&amp;&amp; r2, O result,
                  F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {});
  }
 
  // replace
  template&lt;class ForwardIter, class T&gt;
    constexpr void replace(ForwardIter first, ForwardIter last,
                           const T&amp; old_value, const T&amp; new_value);
  template&lt;class ExecutionPolicy, class ForwardIter, class T&gt;
    void replace(ExecutionPolicy&amp;&amp; exec,
                 ForwardIter first, ForwardIter last,
                 const T&amp; old_value, const T&amp; new_value);
  template&lt;class ForwardIter, class Pred, class T&gt;
    constexpr void replace_if(ForwardIter first, ForwardIter last,
                              Pred pred, const T&amp; new_value);
  template&lt;class ExecutionPolicy, class ForwardIter, class Pred, class T&gt;
    void replace_if(ExecutionPolicy&amp;&amp; exec,
                    ForwardIter first, ForwardIter last,
                    Pred pred, const T&amp; new_value);
 
  namespace ranges {
    template&lt;input_iterator I, sentinel_for&lt;I&gt; S, class T1, class T2,
             class Proj = identity&gt;
      requires indirectly_writable&lt;I, const T2&amp;&gt; &amp;&amp;
               indirect_binary_predicate&lt;ranges::equal_to, projected&lt;I, Proj&gt;, const T1*&gt;
      constexpr I
        replace(I first, S last, const T1&amp; old_value, const T2&amp; new_value,
                Proj proj = {});
    template&lt;input_range R, class T1, class T2, class Proj = identity&gt;
      requires indirectly_writable&lt;iterator_t&lt;R&gt;, const T2&amp;&gt; &amp;&amp;
               indirect_binary_predicate&lt;ranges::equal_to,
                                         projected&lt;iterator_t&lt;R&gt;, Proj&gt;, const T1*&gt;
      constexpr borrowed_iterator_t&lt;R&gt;
        replace(R&amp;&amp; r, const T1&amp; old_value, const T2&amp; new_value, Proj proj = {});
    template&lt;input_iterator I, sentinel_for&lt;I&gt; S, class T, class Proj = identity,
             indirect_unary_predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
      requires indirectly_writable&lt;I, const T&amp;&gt;
      constexpr I replace_if(I first, S last, Pred pred, const T&amp; new_value,
                             Proj proj = {});
    template&lt;input_range R, class T, class Proj = identity,
             indirect_unary_predicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
      requires indirectly_writable&lt;iterator_t&lt;R&gt;, const T&amp;&gt;
      constexpr borrowed_iterator_t&lt;R&gt;
        replace_if(R&amp;&amp; r, Pred pred, const T&amp; new_value, Proj proj = {});
  }
 
  template&lt;class InputIter, class OutputIter, class T&gt;
    constexpr OutputIter replace_copy(InputIter first, InputIter last,
                                          OutputIter result,
                                          const T&amp; old_value, const T&amp; new_value);
  template&lt;class ExecutionPolicy, class ForwardIter1, class ForwardIter2, class T&gt;
    ForwardIter2 replace_copy(ExecutionPolicy&amp;&amp; exec,
                                  ForwardIter1 first, ForwardIter1 last,
                                  ForwardIter2 result,
                                  const T&amp; old_value, const T&amp; new_value);
  template&lt;class InputIter, class OutputIter, class Pred, class T&gt;
    constexpr OutputIter replace_copy_if(InputIter first, InputIter last,
                                             OutputIter result,
                                             Pred pred, const T&amp; new_value);
  template&lt;class ExecutionPolicy, class ForwardIter1, class ForwardIter2,
           class Pred, class T&gt;
    ForwardIter2 replace_copy_if(ExecutionPolicy&amp;&amp; exec,
                                     ForwardIter1 first, ForwardIter1 last,
                                     ForwardIter2 result,
                                     Pred pred, const T&amp; new_value);
 
  namespace ranges {
    template&lt;class I, class O&gt;
      using replace_copy_result = in_out_result&lt;I, O&gt;;
 
    template&lt;input_iterator I, sentinel_for&lt;I&gt; S, class T1, class T2,
             output_iterator&lt;const T2&amp;&gt; O, class Proj = identity&gt;
      requires indirectly_copyable&lt;I, O&gt; &amp;&amp;
               indirect_binary_predicate&lt;ranges::equal_to, projected&lt;I, Proj&gt;, const T1*&gt;
      constexpr replace_copy_result&lt;I, O&gt;
        replace_copy(I first, S last, O result, const T1&amp; old_value, const T2&amp; new_value,
                     Proj proj = {});
    template&lt;input_range R, class T1, class T2, output_iterator&lt;const T2&amp;&gt; O,
             class Proj = identity&gt;
      requires indirectly_copyable&lt;iterator_t&lt;R&gt;, O&gt; &amp;&amp;
               indirect_binary_predicate&lt;ranges::equal_to,
                                         projected&lt;iterator_t&lt;R&gt;, Proj&gt;, const T1*&gt;
      constexpr replace_copy_result&lt;borrowed_iterator_t&lt;R&gt;, O&gt;
        replace_copy(R&amp;&amp; r, O result, const T1&amp; old_value, const T2&amp; new_value,
                     Proj proj = {});
 
    template&lt;class I, class O&gt;
      using replace_copy_if_result = in_out_result&lt;I, O&gt;;
 
    template&lt;input_iterator I, sentinel_for&lt;I&gt; S, class T, output_iterator&lt;const T&amp;&gt; O,
             class Proj = identity, indirect_unary_predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
      requires indirectly_copyable&lt;I, O&gt;
      constexpr replace_copy_if_result&lt;I, O&gt;
        replace_copy_if(I first, S last, O result, Pred pred, const T&amp; new_value,
                        Proj proj = {});
    template&lt;input_range R, class T, output_iterator&lt;const T&amp;&gt; O, class Proj = identity,
             indirect_unary_predicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
      requires indirectly_copyable&lt;iterator_t&lt;R&gt;, O&gt;
      constexpr replace_copy_if_result&lt;borrowed_iterator_t&lt;R&gt;, O&gt;
        replace_copy_if(R&amp;&amp; r, O result, Pred pred, const T&amp; new_value,
                        Proj proj = {});
  }
 
  // fill
  template&lt;class ForwardIter, class T&gt;
    constexpr void fill(ForwardIter first, ForwardIter last, const T&amp; value);
  template&lt;class ExecutionPolicy, class ForwardIter, class T&gt;
    void fill(ExecutionPolicy&amp;&amp; exec,
              ForwardIter first, ForwardIter last, const T&amp; value);
  template&lt;class OutputIter, class Size, class T&gt;
    constexpr OutputIter fill_n(OutputIter first, Size n, const T&amp; value);
  template&lt;class ExecutionPolicy, class ForwardIter,
           class Size, class T&gt;
    ForwardIter fill_n(ExecutionPolicy&amp;&amp; exec,
                           ForwardIter first, Size n, const T&amp; value);
 
  namespace ranges {
    template&lt;class T, output_iterator&lt;const T&amp;&gt; O, sentinel_for&lt;O&gt; S&gt;
      constexpr O fill(O first, S last, const T&amp; value);
    template&lt;class T, output_range&lt;const T&amp;&gt; R&gt;
      constexpr borrowed_iterator_t&lt;R&gt; fill(R&amp;&amp; r, const T&amp; value);
    template&lt;class T, output_iterator&lt;const T&amp;&gt; O&gt;
      constexpr O fill_n(O first, iter_difference_t&lt;O&gt; n, const T&amp; value);
  }
 
  // generate
  template&lt;class ForwardIter, class Generator&gt;
    constexpr void generate(ForwardIter first, ForwardIter last,
                            Generator gen);
  template&lt;class ExecutionPolicy, class ForwardIter, class Generator&gt;
    void generate(ExecutionPolicy&amp;&amp; exec,
                  ForwardIter first, ForwardIter last,
                  Generator gen);
  template&lt;class OutputIter, class Size, class Generator&gt;
    constexpr OutputIter generate_n(OutputIter first, Size n, Generator gen);
  template&lt;class ExecutionPolicy, class ForwardIter, class Size, class Generator&gt;
    ForwardIter generate_n(ExecutionPolicy&amp;&amp; exec,
                               ForwardIter first, Size n, Generator gen);
 
  namespace ranges {
    template&lt;input_or_output_iterator O, sentinel_for&lt;O&gt; S, copy_constructible F&gt;
      requires invocable&lt;F&amp;&gt; &amp;&amp; indirectly_writable&lt;O, invoke_result_t&lt;F&amp;&gt;&gt;
      constexpr O generate(O first, S last, F gen);
    template&lt;class R, copy_constructible F&gt;
      requires invocable&lt;F&amp;&gt; &amp;&amp; output_range&lt;R, invoke_result_t&lt;F&amp;&gt;&gt;
      constexpr borrowed_iterator_t&lt;R&gt; generate(R&amp;&amp; r, F gen);
    template&lt;input_or_output_iterator O, copy_constructible F&gt;
      requires invocable&lt;F&amp;&gt; &amp;&amp; indirectly_writable&lt;O, invoke_result_t&lt;F&amp;&gt;&gt;
      constexpr O generate_n(O first, iter_difference_t&lt;O&gt; n, F gen);
  }
 
  // remove
  template&lt;class ForwardIter, class T&gt;
    constexpr ForwardIter remove(ForwardIter first, ForwardIter last,
                                     const T&amp; value);
  template&lt;class ExecutionPolicy, class ForwardIter, class T&gt;
    ForwardIter remove(ExecutionPolicy&amp;&amp; exec,
                           ForwardIter first, ForwardIter last,
                           const T&amp; value);
  template&lt;class ForwardIter, class Pred&gt;
    constexpr ForwardIter remove_if(ForwardIter first, ForwardIter last,
                                        Pred pred);
  template&lt;class ExecutionPolicy, class ForwardIter, class Pred&gt;
    ForwardIter remove_if(ExecutionPolicy&amp;&amp; exec,
                              ForwardIter first, ForwardIter last,
                              Pred pred);
 
  namespace ranges {
    template&lt;permutable I, sentinel_for&lt;I&gt; S, class T, class Proj = identity&gt;
      requires indirect_binary_predicate&lt;ranges::equal_to, projected&lt;I, Proj&gt;, const T*&gt;
      constexpr subrange&lt;I&gt; remove(I first, S last, const T&amp; value, Proj proj = {});
    template&lt;forward_range R, class T, class Proj = identity&gt;
      requires permutable&lt;iterator_t&lt;R&gt;&gt; &amp;&amp;
               indirect_binary_predicate&lt;ranges::equal_to,
                                         projected&lt;iterator_t&lt;R&gt;, Proj&gt;, const T*&gt;
      constexpr borrowed_subrange_t&lt;R&gt;
        remove(R&amp;&amp; r, const T&amp; value, Proj proj = {});
    template&lt;permutable I, sentinel_for&lt;I&gt; S, class Proj = identity,
             indirect_unary_predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
      constexpr subrange&lt;I&gt; remove_if(I first, S last, Pred pred, Proj proj = {});
    template&lt;forward_range R, class Proj = identity,
             indirect_unary_predicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
      requires permutable&lt;iterator_t&lt;R&gt;&gt;
      constexpr borrowed_subrange_t&lt;R&gt;
        remove_if(R&amp;&amp; r, Pred pred, Proj proj = {});
  }
 
  template&lt;class InputIter, class OutputIter, class T&gt;
    constexpr OutputIter
      remove_copy(InputIter first, InputIter last,
                  OutputIter result, const T&amp; value);
  template&lt;class ExecutionPolicy, class ForwardIter1, class ForwardIter2,
           class T&gt;
    ForwardIter2
      remove_copy(ExecutionPolicy&amp;&amp; exec,
                  ForwardIter1 first, ForwardIter1 last,
                  ForwardIter2 result, const T&amp; value);
  template&lt;class InputIter, class OutputIter, class Pred&gt;
    constexpr OutputIter
      remove_copy_if(InputIter first, InputIter last,
                     OutputIter result, Pred pred);
  template&lt;class ExecutionPolicy, class ForwardIter1, class ForwardIter2,
           class Pred&gt;
    ForwardIter2
      remove_copy_if(ExecutionPolicy&amp;&amp; exec,
                     ForwardIter1 first, ForwardIter1 last,
                     ForwardIter2 result, Pred pred);
 
  namespace ranges {
    template&lt;class I, class O&gt;
      using remove_copy_result = in_out_result&lt;I, O&gt;;
 
    template&lt;input_iterator I, sentinel_for&lt;I&gt; S, weakly_incrementable O, class T,
             class Proj = identity&gt;
      requires indirectly_copyable&lt;I, O&gt; &amp;&amp;
               indirect_binary_predicate&lt;ranges::equal_to, projected&lt;I, Proj&gt;, const T*&gt;
      constexpr remove_copy_result&lt;I, O&gt;
        remove_copy(I first, S last, O result, const T&amp; value, Proj proj = {});
    template&lt;input_range R, weakly_incrementable O, class T, class Proj = identity&gt;
      requires indirectly_copyable&lt;iterator_t&lt;R&gt;, O&gt; &amp;&amp;
               indirect_binary_predicate&lt;ranges::equal_to,
                                         projected&lt;iterator_t&lt;R&gt;, Proj&gt;, const T*&gt;
      constexpr remove_copy_result&lt;borrowed_iterator_t&lt;R&gt;, O&gt;
        remove_copy(R&amp;&amp; r, O result, const T&amp; value, Proj proj = {});
 
    template&lt;class I, class O&gt;
      using remove_copy_if_result = in_out_result&lt;I, O&gt;;
 
    template&lt;input_iterator I, sentinel_for&lt;I&gt; S, weakly_incrementable O,
             class Proj = identity, indirect_unary_predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
      requires indirectly_copyable&lt;I, O&gt;
      constexpr remove_copy_if_result&lt;I, O&gt;
        remove_copy_if(I first, S last, O result, Pred pred, Proj proj = {});
    template&lt;input_range R, weakly_incrementable O, class Proj = identity,
             indirect_unary_predicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
      requires indirectly_copyable&lt;iterator_t&lt;R&gt;, O&gt;
      constexpr remove_copy_if_result&lt;borrowed_iterator_t&lt;R&gt;, O&gt;
        remove_copy_if(R&amp;&amp; r, O result, Pred pred, Proj proj = {});
  }
 
  // unique
  template&lt;class ForwardIter&gt;
    constexpr ForwardIter unique(ForwardIter first, ForwardIter last);
  template&lt;class ForwardIter, class BinaryPred&gt;
    constexpr ForwardIter unique(ForwardIter first, ForwardIter last,
                                     BinaryPred pred);
  template&lt;class ExecutionPolicy, class ForwardIter&gt;
    ForwardIter unique(ExecutionPolicy&amp;&amp; exec,
                           ForwardIter first, ForwardIter last);
  template&lt;class ExecutionPolicy, class ForwardIter, class BinaryPred&gt;
    ForwardIter unique(ExecutionPolicy&amp;&amp; exec,
                           ForwardIter first, ForwardIter last,
                           BinaryPred pred);
 
  namespace ranges {
    template&lt;permutable I, sentinel_for&lt;I&gt; S, class Proj = identity,
             indirect_equivalence_relation&lt;projected&lt;I, Proj&gt;&gt; C = ranges::equal_to&gt;
      constexpr subrange&lt;I&gt; unique(I first, S last, C comp = {}, Proj proj = {});
    template&lt;forward_range R, class Proj = identity,
             indirect_equivalence_relation&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; C =
                 ranges::equal_to&gt;
      requires permutable&lt;iterator_t&lt;R&gt;&gt;
      constexpr borrowed_subrange_t&lt;R&gt;
        unique(R&amp;&amp; r, C comp = {}, Proj proj = {});
  }
 
  template&lt;class InputIter, class OutputIter&gt;
    constexpr OutputIter
      unique_copy(InputIter first, InputIter last,
                  OutputIter result);
  template&lt;class InputIter, class OutputIter, class BinaryPred&gt;
    constexpr OutputIter
      unique_copy(InputIter first, InputIter last,
                  OutputIter result, BinaryPred pred);
  template&lt;class ExecutionPolicy, class ForwardIter1, class ForwardIter2&gt;
    ForwardIter2
      unique_copy(ExecutionPolicy&amp;&amp; exec,
                  ForwardIter1 first, ForwardIter1 last,
                  ForwardIter2 result);
  template&lt;class ExecutionPolicy, class ForwardIter1, class ForwardIter2,
           class BinaryPred&gt;
    ForwardIter2
      unique_copy(ExecutionPolicy&amp;&amp; exec,
                  ForwardIter1 first, ForwardIter1 last,
                  ForwardIter2 result, BinaryPred pred);
 
  namespace ranges {
    template&lt;class I, class O&gt;
      using unique_copy_result = in_out_result&lt;I, O&gt;;
 
    template&lt;input_iterator I, sentinel_for&lt;I&gt; S, weakly_incrementable O,
             class Proj = identity,
             indirect_equivalence_relation&lt;projected&lt;I, Proj&gt;&gt; C = ranges::equal_to&gt;
      requires indirectly_copyable&lt;I, O&gt; &amp;&amp;
               (forward_iterator&lt;I&gt; ||
                (input_iterator&lt;O&gt; &amp;&amp; same_as&lt;iter_value_t&lt;I&gt;, iter_value_t&lt;O&gt;&gt;) ||
                indirectly_copyable_storable&lt;I, O&gt;)
      constexpr unique_copy_result&lt;I, O&gt;
        unique_copy(I first, S last, O result, C comp = {}, Proj proj = {});
    template&lt;input_range R, weakly_incrementable O, class Proj = identity,
             indirect_equivalence_relation&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; C =
                 ranges::equal_to&gt;
      requires indirectly_copyable&lt;iterator_t&lt;R&gt;, O&gt; &amp;&amp;
               (forward_iterator&lt;iterator_t&lt;R&gt;&gt; ||
                (input_iterator&lt;O&gt; &amp;&amp; same_as&lt;range_value_t&lt;R&gt;, iter_value_t&lt;O&gt;&gt;) ||
                indirectly_copyable_storable&lt;iterator_t&lt;R&gt;, O&gt;)
      constexpr unique_copy_result&lt;borrowed_iterator_t&lt;R&gt;, O&gt;
        unique_copy(R&amp;&amp; r, O result, C comp = {}, Proj proj = {});
  }
 
  // reverse
  template&lt;class BidirectionalIter&gt;
    constexpr void reverse(BidirectionalIter first, BidirectionalIter last);
  template&lt;class ExecutionPolicy, class BidirectionalIter&gt;
    void reverse(ExecutionPolicy&amp;&amp; exec,
                 BidirectionalIter first, BidirectionalIter last);
 
  namespace ranges {
    template&lt;bidirectional_iterator I, sentinel_for&lt;I&gt; S&gt;
      requires permutable&lt;I&gt;
      constexpr I reverse(I first, S last);
    template&lt;bidirectional_range R&gt;
      requires permutable&lt;iterator_t&lt;R&gt;&gt;
      constexpr borrowed_iterator_t&lt;R&gt; reverse(R&amp;&amp; r);
  }
 
  template&lt;class BidirectionalIter, class OutputIter&gt;
    constexpr OutputIter
      reverse_copy(BidirectionalIter first, BidirectionalIter last,
                   OutputIter result);
  template&lt;class ExecutionPolicy, class BidirectionalIter, class ForwardIter&gt;
    ForwardIter
      reverse_copy(ExecutionPolicy&amp;&amp; exec,
                   BidirectionalIter first, BidirectionalIter last,
                   ForwardIter result);
 
  namespace ranges {
    template&lt;class I, class O&gt;
      using reverse_copy_result = in_out_result&lt;I, O&gt;;
 
    template&lt;bidirectional_iterator I, sentinel_for&lt;I&gt; S, weakly_incrementable O&gt;
      requires indirectly_copyable&lt;I, O&gt;
      constexpr reverse_copy_result&lt;I, O&gt;
        reverse_copy(I first, S last, O result);
    template&lt;bidirectional_range R, weakly_incrementable O&gt;
      requires indirectly_copyable&lt;iterator_t&lt;R&gt;, O&gt;
      constexpr reverse_copy_result&lt;borrowed_iterator_t&lt;R&gt;, O&gt;
        reverse_copy(R&amp;&amp; r, O result);
  }
 
  // rotate
  template&lt;class ForwardIter&gt;
    constexpr ForwardIter rotate(ForwardIter first,
                                     ForwardIter middle,
                                     ForwardIter last);
  template&lt;class ExecutionPolicy, class ForwardIter&gt;
    ForwardIter rotate(ExecutionPolicy&amp;&amp; exec,
                           ForwardIter first,
                           ForwardIter middle,
                           ForwardIter last);
 
  namespace ranges {
    template&lt;permutable I, sentinel_for&lt;I&gt; S&gt;
      constexpr subrange&lt;I&gt; rotate(I first, I middle, S last);
    template&lt;forward_range R&gt;
      requires permutable&lt;iterator_t&lt;R&gt;&gt;
      constexpr borrowed_subrange_t&lt;R&gt; rotate(R&amp;&amp; r, iterator_t&lt;R&gt; middle);
  }
 
  template&lt;class ForwardIter, class OutputIter&gt;
    constexpr OutputIter
      rotate_copy(ForwardIter first, ForwardIter middle,
                  ForwardIter last, OutputIter result);
  template&lt;class ExecutionPolicy, class ForwardIter1, class ForwardIter2&gt;
    ForwardIter2
      rotate_copy(ExecutionPolicy&amp;&amp; exec,
                  ForwardIter1 first, ForwardIter1 middle,
                  ForwardIter1 last, ForwardIter2 result);
 
  namespace ranges {
    template&lt;class I, class O&gt;
      using rotate_copy_result = in_out_result&lt;I, O&gt;;
 
    template&lt;forward_iterator I, sentinel_for&lt;I&gt; S, weakly_incrementable O&gt;
      requires indirectly_copyable&lt;I, O&gt;
      constexpr rotate_copy_result&lt;I, O&gt;
        rotate_copy(I first, I middle, S last, O result);
    template&lt;forward_range R, weakly_incrementable O&gt;
      requires indirectly_copyable&lt;iterator_t&lt;R&gt;, O&gt;
      constexpr rotate_copy_result&lt;borrowed_iterator_t&lt;R&gt;, O&gt;
        rotate_copy(R&amp;&amp; r, iterator_t&lt;R&gt; middle, O result);
  }
 
  // sample
  template&lt;class PopulationIter, class SampleIter,
           class Distance, class UniformRandomBitGenerator&gt;
    SampleIter sample(PopulationIter first, PopulationIter last,
                          SampleIter out, Distance n,
                          UniformRandomBitGenerator&amp;&amp; g);
 
  namespace ranges {
    template&lt;input_iterator I, sentinel_for&lt;I&gt; S,
             weakly_incrementable O, class Gen&gt;
      requires (forward_iterator&lt;I&gt; || random_access_iterator&lt;O&gt;) &amp;&amp;
               indirectly_copyable&lt;I, O&gt; &amp;&amp;
               uniform_random_bit_generator&lt;remove_reference_t&lt;Gen&gt;&gt;
      O sample(I first, S last, O out, iter_difference_t&lt;I&gt; n, Gen&amp;&amp; g);
    template&lt;input_range R, weakly_incrementable O, class Gen&gt;
      requires (forward_range&lt;R&gt; || random_access_iterator&lt;O&gt;) &amp;&amp;
               indirectly_copyable&lt;iterator_t&lt;R&gt;, O&gt; &amp;&amp;
               uniform_random_bit_generator&lt;remove_reference_t&lt;Gen&gt;&gt;
      O sample(R&amp;&amp; r, O out, range_difference_t&lt;R&gt; n, Gen&amp;&amp; g);
  }
 
  // shuffle
  template&lt;class RandomAccessIter, class UniformRandomBitGenerator&gt;
    void shuffle(RandomAccessIter first,
                 RandomAccessIter last,
                 UniformRandomBitGenerator&amp;&amp; g);
 
  namespace ranges {
    template&lt;random_access_iterator I, sentinel_for&lt;I&gt; S, class Gen&gt;
      requires permutable&lt;I&gt; &amp;&amp;
               uniform_random_bit_generator&lt;remove_reference_t&lt;Gen&gt;&gt;
      I shuffle(I first, S last, Gen&amp;&amp; g);
    template&lt;random_access_range R, class Gen&gt;
      requires permutable&lt;iterator_t&lt;R&gt;&gt; &amp;&amp;
               uniform_random_bit_generator&lt;remove_reference_t&lt;Gen&gt;&gt;
      borrowed_iterator_t&lt;R&gt; shuffle(R&amp;&amp; r, Gen&amp;&amp; g);
  }
 
  // shift
  template&lt;class ForwardIter&gt;
    constexpr ForwardIter
      shift_left(ForwardIter first, ForwardIter last,
                 typename iterator_traits&lt;ForwardIter&gt;::difference_type n);
  template&lt;class ExecutionPolicy, class ForwardIter&gt;
    ForwardIter
      shift_left(ExecutionPolicy&amp;&amp; exec,
                 ForwardIter first, ForwardIter last,
                 typename iterator_traits&lt;ForwardIter&gt;::difference_type n);
 
  namespace ranges {
    template&lt;permutable I, sentinel_for&lt;I&gt; S&gt;
      constexpr subrange&lt;I&gt; shift_left(I first, S last, iter_difference_t&lt;I&gt; n);
    template&lt;forward_range R&gt;
      requires permutable&lt;iterator_t&lt;R&gt;&gt;
      constexpr borrowed_subrange_t&lt;R&gt; shift_left(R&amp;&amp; r, range_difference_t&lt;R&gt; n);
  }
 
  template&lt;class ForwardIter&gt;
    constexpr ForwardIter
      shift_right(ForwardIter first, ForwardIter last,
                  typename iterator_traits&lt;ForwardIter&gt;::difference_type n);
  template&lt;class ExecutionPolicy, class ForwardIter&gt;
    ForwardIter
      shift_right(ExecutionPolicy&amp;&amp; exec,
                  ForwardIter first, ForwardIter last,
                  typename iterator_traits&lt;ForwardIter&gt;::difference_type n);
 
  namespace ranges {
    template&lt;permutable I, sentinel_for&lt;I&gt; S&gt;
      constexpr subrange&lt;I&gt; shift_right(I first, S last, iter_difference_t&lt;I&gt; n);
    template&lt;forward_range R&gt;
      requires permutable&lt;iterator_t&lt;R&gt;&gt;
      constexpr borrowed_subrange_t&lt;R&gt; shift_right(R&amp;&amp; r, range_difference_t&lt;R&gt; n);
  }
 
  // sorting and related operations
  // sorting
  template&lt;class RandomAccessIter&gt;
    constexpr void sort(RandomAccessIter first, RandomAccessIter last);
  template&lt;class RandomAccessIter, class Compare&gt;
    constexpr void sort(RandomAccessIter first, RandomAccessIter last,
                        Compare comp);
  template&lt;class ExecutionPolicy, class RandomAccessIter&gt;
    void sort(ExecutionPolicy&amp;&amp; exec,
              RandomAccessIter first, RandomAccessIter last);
  template&lt;class ExecutionPolicy, class RandomAccessIter, class Compare&gt;
    void sort(ExecutionPolicy&amp;&amp; exec,
              RandomAccessIter first, RandomAccessIter last,
              Compare comp);
 
  namespace ranges {
    template&lt;random_access_iterator I, sentinel_for&lt;I&gt; S, class Comp = ranges::less,
             class Proj = identity&gt;
      requires sortable&lt;I, Comp, Proj&gt;
      constexpr I
        sort(I first, S last, Comp comp = {}, Proj proj = {});
    template&lt;random_access_range R, class Comp = ranges::less, class Proj = identity&gt;
      requires sortable&lt;iterator_t&lt;R&gt;, Comp, Proj&gt;
      constexpr borrowed_iterator_t&lt;R&gt;
        sort(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
  }
 
  template&lt;class RandomAccessIter&gt;
    void stable_sort(RandomAccessIter first, RandomAccessIter last);
  template&lt;class RandomAccessIter, class Compare&gt;
    void stable_sort(RandomAccessIter first, RandomAccessIter last,
                     Compare comp);
  template&lt;class ExecutionPolicy, class RandomAccessIter&gt;
    void stable_sort(ExecutionPolicy&amp;&amp; exec,
                     RandomAccessIter first, RandomAccessIter last);
  template&lt;class ExecutionPolicy, class RandomAccessIter, class Compare&gt;
    void stable_sort(ExecutionPolicy&amp;&amp; exec,
                     RandomAccessIter first, RandomAccessIter last,
                     Compare comp);
 
  namespace ranges {
    template&lt;random_access_iterator I, sentinel_for&lt;I&gt; S, class Comp = ranges::less,
             class Proj = identity&gt;
      requires sortable&lt;I, Comp, Proj&gt;
      I stable_sort(I first, S last, Comp comp = {}, Proj proj = {});
    template&lt;random_access_range R, class Comp = ranges::less, class Proj = identity&gt;
      requires sortable&lt;iterator_t&lt;R&gt;, Comp, Proj&gt;
      borrowed_iterator_t&lt;R&gt;
        stable_sort(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
  }
 
  template&lt;class RandomAccessIter&gt;
    constexpr void partial_sort(RandomAccessIter first, RandomAccessIter middle,
                                RandomAccessIter last);
  template&lt;class RandomAccessIter, class Compare&gt;
    constexpr void partial_sort(RandomAccessIter first, RandomAccessIter middle,
                                RandomAccessIter last, Compare comp);
  template&lt;class ExecutionPolicy, class RandomAccessIter&gt;
    void partial_sort(ExecutionPolicy&amp;&amp; exec,
                      RandomAccessIter first, RandomAccessIter middle,
                      RandomAccessIter last);
  template&lt;class ExecutionPolicy, class RandomAccessIter, class Compare&gt;
    void partial_sort(ExecutionPolicy&amp;&amp; exec,
                      RandomAccessIter first, RandomAccessIter middle,
                      RandomAccessIter last, Compare comp);
 
  namespace ranges {
    template&lt;random_access_iterator I, sentinel_for&lt;I&gt; S, class Comp = ranges::less,
             class Proj = identity&gt;
      requires sortable&lt;I, Comp, Proj&gt;
      constexpr I
        partial_sort(I first, I middle, S last, Comp comp = {}, Proj proj = {});
    template&lt;random_access_range R, class Comp = ranges::less, class Proj = identity&gt;
      requires sortable&lt;iterator_t&lt;R&gt;, Comp, Proj&gt;
      constexpr borrowed_iterator_t&lt;R&gt;
        partial_sort(R&amp;&amp; r, iterator_t&lt;R&gt; middle, Comp comp = {},
                     Proj proj = {});
  }
 
  template&lt;class InputIter, class RandomAccessIter&gt;
    constexpr RandomAccessIter
      partial_sort_copy(InputIter first, InputIter last,
                        RandomAccessIter result_first,
                        RandomAccessIter result_last);
  template&lt;class InputIter, class RandomAccessIter, class Compare&gt;
    constexpr RandomAccessIter
      partial_sort_copy(InputIter first, InputIter last,
                        RandomAccessIter result_first,
                        RandomAccessIter result_last,
                        Compare comp);
  template&lt;class ExecutionPolicy, class ForwardIter, class RandomAccessIter&gt;
    RandomAccessIter
      partial_sort_copy(ExecutionPolicy&amp;&amp; exec,
                        ForwardIter first, ForwardIter last,
                        RandomAccessIter result_first,
                        RandomAccessIter result_last);
  template&lt;class ExecutionPolicy, class ForwardIter, class RandomAccessIter,
           class Compare&gt;
    RandomAccessIter
      partial_sort_copy(ExecutionPolicy&amp;&amp; exec,
                        ForwardIter first, ForwardIter last,
                        RandomAccessIter result_first,
                        RandomAccessIter result_last,
                        Compare comp);
 
  namespace ranges {
    template&lt;class I, class O&gt;
      using partial_sort_copy_result = in_out_result&lt;I, O&gt;;
 
    template&lt;input_iterator I1, sentinel_for&lt;I1&gt; S1,
             random_access_iterator I2, sentinel_for&lt;I2&gt; S2,
             class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&gt;
      requires indirectly_copyable&lt;I1, I2&gt; &amp;&amp; sortable&lt;I2, Comp, Proj2&gt; &amp;&amp;
               indirect_strict_weak_order&lt;Comp, projected&lt;I1, Proj1&gt;,
                                          projected&lt;I2, Proj2&gt;&gt;
      constexpr partial_sort_copy_result&lt;I1, I2&gt;
        partial_sort_copy(I1 first, S1 last, I2 result_first, S2 result_last,
                          Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
    template&lt;input_range R1, random_access_range R2, class Comp = ranges::less,
             class Proj1 = identity, class Proj2 = identity&gt;
      requires indirectly_copyable&lt;iterator_t&lt;R1&gt;, iterator_t&lt;R2&gt;&gt; &amp;&amp;
               sortable&lt;iterator_t&lt;R2&gt;, Comp, Proj2&gt; &amp;&amp;
               indirect_strict_weak_order&lt;Comp, projected&lt;iterator_t&lt;R1&gt;, Proj1&gt;,
                                          projected&lt;iterator_t&lt;R2&gt;, Proj2&gt;&gt;
      constexpr partial_sort_copy_result&lt;borrowed_iterator_t&lt;R1&gt;, borrowed_iterator_t&lt;R2&gt;&gt;
        partial_sort_copy(R1&amp;&amp; r, R2&amp;&amp; result_r, Comp comp = {},
                          Proj1 proj1 = {}, Proj2 proj2 = {});
  }
 
  template&lt;class ForwardIter&gt;
    constexpr bool is_sorted(ForwardIter first, ForwardIter last);
  template&lt;class ForwardIter, class Compare&gt;
    constexpr bool is_sorted(ForwardIter first, ForwardIter last,
                             Compare comp);
  template&lt;class ExecutionPolicy, class ForwardIter&gt;
    bool is_sorted(ExecutionPolicy&amp;&amp; exec,
                   ForwardIter first, ForwardIter last);
  template&lt;class ExecutionPolicy, class ForwardIter, class Compare&gt;
    bool is_sorted(ExecutionPolicy&amp;&amp; exec,
                   ForwardIter first, ForwardIter last,
                   Compare comp);
 
  namespace ranges {
    template&lt;forward_iterator I, sentinel_for&lt;I&gt; S, class Proj = identity,
             indirect_strict_weak_order&lt;projected&lt;I, Proj&gt;&gt; Comp = ranges::less&gt;
      constexpr bool is_sorted(I first, S last, Comp comp = {}, Proj proj = {});
    template&lt;forward_range R, class Proj = identity,
             indirect_strict_weak_order&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Comp =
                 ranges::less&gt;
      constexpr bool is_sorted(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
  }
 
  template&lt;class ForwardIter&gt;
    constexpr ForwardIter
      is_sorted_until(ForwardIter first, ForwardIter last);
  template&lt;class ForwardIter, class Compare&gt;
    constexpr ForwardIter
      is_sorted_until(ForwardIter first, ForwardIter last,
                      Compare comp);
  template&lt;class ExecutionPolicy, class ForwardIter&gt;
    ForwardIter
      is_sorted_until(ExecutionPolicy&amp;&amp; exec,
                      ForwardIter first, ForwardIter last);
  template&lt;class ExecutionPolicy, class ForwardIter, class Compare&gt;
    ForwardIter
      is_sorted_until(ExecutionPolicy&amp;&amp; exec,
                      ForwardIter first, ForwardIter last,
                      Compare comp);
 
  namespace ranges {
    template&lt;forward_iterator I, sentinel_for&lt;I&gt; S, class Proj = identity,
             indirect_strict_weak_order&lt;projected&lt;I, Proj&gt;&gt; Comp = ranges::less&gt;
      constexpr I is_sorted_until(I first, S last, Comp comp = {}, Proj proj = {});
    template&lt;forward_range R, class Proj = identity,
             indirect_strict_weak_order&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Comp =
                 ranges::less&gt;
      constexpr borrowed_iterator_t&lt;R&gt;
        is_sorted_until(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
  }
 
  // Nth element
  template&lt;class RandomAccessIter&gt;
    constexpr void nth_element(RandomAccessIter first, RandomAccessIter nth,
                               RandomAccessIter last);
  template&lt;class RandomAccessIter, class Compare&gt;
    constexpr void nth_element(RandomAccessIter first, RandomAccessIter nth,
                               RandomAccessIter last, Compare comp);
  template&lt;class ExecutionPolicy, class RandomAccessIter&gt;
    void nth_element(ExecutionPolicy&amp;&amp; exec,
                     RandomAccessIter first, RandomAccessIter nth,
                     RandomAccessIter last);
  template&lt;class ExecutionPolicy, class RandomAccessIter, class Compare&gt;
    void nth_element(ExecutionPolicy&amp;&amp; exec,
                     RandomAccessIter first, RandomAccessIter nth,
                     RandomAccessIter last, Compare comp);
 
  namespace ranges {
    template&lt;random_access_iterator I, sentinel_for&lt;I&gt; S, class Comp = ranges::less,
             class Proj = identity&gt;
      requires sortable&lt;I, Comp, Proj&gt;
      constexpr I
        nth_element(I first, I nth, S last, Comp comp = {}, Proj proj = {});
    template&lt;random_access_range R, class Comp = ranges::less, class Proj = identity&gt;
      requires sortable&lt;iterator_t&lt;R&gt;, Comp, Proj&gt;
      constexpr borrowed_iterator_t&lt;R&gt;
        nth_element(R&amp;&amp; r, iterator_t&lt;R&gt; nth, Comp comp = {}, Proj proj = {});
  }
 
  // binary search
  template&lt;class ForwardIter, class T&gt;
    constexpr ForwardIter
      lower_bound(ForwardIter first, ForwardIter last,
                  const T&amp; value);
  template&lt;class ForwardIter, class T, class Compare&gt;
    constexpr ForwardIter
      lower_bound(ForwardIter first, ForwardIter last,
                  const T&amp; value, Compare comp);
 
  namespace ranges {
    template&lt;forward_iterator I, sentinel_for&lt;I&gt; S, class T, class Proj = identity,
             indirect_strict_weak_order&lt;const T*, projected&lt;I, Proj&gt;&gt; Comp = ranges::less&gt;
      constexpr I lower_bound(I first, S last, const T&amp; value, Comp comp = {},
                              Proj proj = {});
    template&lt;forward_range R, class T, class Proj = identity,
             indirect_strict_weak_order&lt;const T*, projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Comp =
               ranges::less&gt;
      constexpr borrowed_iterator_t&lt;R&gt;
        lower_bound(R&amp;&amp; r, const T&amp; value, Comp comp = {}, Proj proj = {});
  }
 
  template&lt;class ForwardIter, class T&gt;
    constexpr ForwardIter
      upper_bound(ForwardIter first, ForwardIter last,
                  const T&amp; value);
  template&lt;class ForwardIter, class T, class Compare&gt;
    constexpr ForwardIter
      upper_bound(ForwardIter first, ForwardIter last,
                  const T&amp; value, Compare comp);
 
  namespace ranges {
    template&lt;forward_iterator I, sentinel_for&lt;I&gt; S, class T, class Proj = identity,
             indirect_strict_weak_order&lt;const T*, projected&lt;I, Proj&gt;&gt; Comp = ranges::less&gt;
      constexpr I upper_bound(I first, S last, const T&amp; value, Comp comp = {},
                              Proj proj = {});
    template&lt;forward_range R, class T, class Proj = identity,
             indirect_strict_weak_order&lt;const T*, projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Comp =
               ranges::less&gt;
      constexpr borrowed_iterator_t&lt;R&gt;
        upper_bound(R&amp;&amp; r, const T&amp; value, Comp comp = {}, Proj proj = {});
  }
 
  template&lt;class ForwardIter, class T&gt;
    constexpr pair&lt;ForwardIter, ForwardIter&gt;
      equal_range(ForwardIter first, ForwardIter last,
                  const T&amp; value);
  template&lt;class ForwardIter, class T, class Compare&gt;
    constexpr pair&lt;ForwardIter, ForwardIter&gt;
      equal_range(ForwardIter first, ForwardIter last,
                  const T&amp; value, Compare comp);
 
  namespace ranges {
    template&lt;forward_iterator I, sentinel_for&lt;I&gt; S, class T, class Proj = identity,
             indirect_strict_weak_order&lt;const T*, projected&lt;I, Proj&gt;&gt; Comp = ranges::less&gt;
      constexpr subrange&lt;I&gt;
        equal_range(I first, S last, const T&amp; value, Comp comp = {}, Proj proj = {});
    template&lt;forward_range R, class T, class Proj = identity,
             indirect_strict_weak_order&lt;const T*, projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Comp =
               ranges::less&gt;
      constexpr borrowed_subrange_t&lt;R&gt;
        equal_range(R&amp;&amp; r, const T&amp; value, Comp comp = {}, Proj proj = {});
  }
 
  template&lt;class ForwardIter, class T&gt;
    constexpr bool
      binary_search(ForwardIter first, ForwardIter last,
                    const T&amp; value);
  template&lt;class ForwardIter, class T, class Compare&gt;
    constexpr bool
      binary_search(ForwardIter first, ForwardIter last,
                    const T&amp; value, Compare comp);
 
  namespace ranges {
    template&lt;forward_iterator I, sentinel_for&lt;I&gt; S, class T, class Proj = identity,
             indirect_strict_weak_order&lt;const T*, projected&lt;I, Proj&gt;&gt; Comp = ranges::less&gt;
      constexpr bool binary_search(I first, S last, const T&amp; value, Comp comp = {},
                                   Proj proj = {});
    template&lt;forward_range R, class T, class Proj = identity,
             indirect_strict_weak_order&lt;const T*, projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Comp =
               ranges::less&gt;
      constexpr bool binary_search(R&amp;&amp; r, const T&amp; value, Comp comp = {},
                                   Proj proj = {});
  }
 
  // partitions
  template&lt;class InputIter, class Pred&gt;
    constexpr bool is_partitioned(InputIter first, InputIter last,
                                  Pred pred);
  template&lt;class ExecutionPolicy, class ForwardIter, class Pred&gt;
    bool is_partitioned(ExecutionPolicy&amp;&amp; exec,
                        ForwardIter first, ForwardIter last, Pred pred);
 
  namespace ranges {
    template&lt;input_iterator I, sentinel_for&lt;I&gt; S, class Proj = identity,
             indirect_unary_predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
      constexpr bool is_partitioned(I first, S last, Pred pred, Proj proj = {});
    template&lt;input_range R, class Proj = identity,
             indirect_unary_predicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
      constexpr bool is_partitioned(R&amp;&amp; r, Pred pred, Proj proj = {});
  }
 
  template&lt;class ForwardIter, class Pred&gt;
    constexpr ForwardIter partition(ForwardIter first,
                                        ForwardIter last,
                                        Pred pred);
  template&lt;class ExecutionPolicy, class ForwardIter, class Pred&gt;
    ForwardIter partition(ExecutionPolicy&amp;&amp; exec,
                              ForwardIter first,
                              ForwardIter last,
                              Pred pred);
 
  namespace ranges {
    template&lt;permutable I, sentinel_for&lt;I&gt; S, class Proj = identity,
             indirect_unary_predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
      constexpr subrange&lt;I&gt;
        partition(I first, S last, Pred pred, Proj proj = {});
    template&lt;forward_range R, class Proj = identity,
             indirect_unary_predicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
      requires permutable&lt;iterator_t&lt;R&gt;&gt;
      constexpr borrowed_subrange_t&lt;R&gt;
        partition(R&amp;&amp; r, Pred pred, Proj proj = {});
  }
 
  template&lt;class BidirectionalIter, class Pred&gt;
    BidirectionalIter stable_partition(BidirectionalIter first,
                                           BidirectionalIter last,
                                           Pred pred);
  template&lt;class ExecutionPolicy, class BidirectionalIter, class Pred&gt;
    BidirectionalIter stable_partition(ExecutionPolicy&amp;&amp; exec,
                                           BidirectionalIter first,
                                           BidirectionalIter last,
                                           Pred pred);
 
  namespace ranges {
    template&lt;bidirectional_iterator I, sentinel_for&lt;I&gt; S, class Proj = identity,
             indirect_unary_predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
      requires permutable&lt;I&gt;
      subrange&lt;I&gt; stable_partition(I first, S last, Pred pred, Proj proj = {});
    template&lt;bidirectional_range R, class Proj = identity,
             indirect_unary_predicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
      requires permutable&lt;iterator_t&lt;R&gt;&gt;
      borrowed_subrange_t&lt;R&gt; stable_partition(R&amp;&amp; r, Pred pred, Proj proj = {});
  }
 
  template&lt;class InputIter, class OutputIter1,
           class OutputIter2, class Pred&gt;
    constexpr pair&lt;OutputIter1, OutputIter2&gt;
      partition_copy(InputIter first, InputIter last,
                     OutputIter1 out_true, OutputIter2 out_false,
                     Pred pred);
  template&lt;class ExecutionPolicy, class ForwardIter, class ForwardIter1,
           class ForwardIter2, class Pred&gt;
    pair&lt;ForwardIter1, ForwardIter2&gt;
      partition_copy(ExecutionPolicy&amp;&amp; exec,
                     ForwardIter first, ForwardIter last,
                     ForwardIter1 out_true, ForwardIter2 out_false,
                     Pred pred);
 
  namespace ranges {
    template&lt;class I, class O1, class O2&gt;
      using partition_copy_result = in_out_out_result&lt;I, O1, O2&gt;;
 
    template&lt;input_iterator I, sentinel_for&lt;I&gt; S,
             weakly_incrementable O1, weakly_incrementable O2,
             class Proj = identity, indirect_unary_predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
      requires indirectly_copyable&lt;I, O1&gt; &amp;&amp; indirectly_copyable&lt;I, O2&gt;
      constexpr partition_copy_result&lt;I, O1, O2&gt;
        partition_copy(I first, S last, O1 out_true, O2 out_false, Pred pred,
                       Proj proj = {});
    template&lt;input_range R, weakly_incrementable O1, weakly_incrementable O2,
             class Proj = identity,
             indirect_unary_predicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
      requires indirectly_copyable&lt;iterator_t&lt;R&gt;, O1&gt; &amp;&amp;
               indirectly_copyable&lt;iterator_t&lt;R&gt;, O2&gt;
      constexpr partition_copy_result&lt;borrowed_iterator_t&lt;R&gt;, O1, O2&gt;
        partition_copy(R&amp;&amp; r, O1 out_true, O2 out_false, Pred pred, Proj proj = {});
  }
 
  template&lt;class ForwardIter, class Pred&gt;
    constexpr ForwardIter
      partition_point(ForwardIter first, ForwardIter last,
                      Pred pred);
 
  namespace ranges {
    template&lt;forward_iterator I, sentinel_for&lt;I&gt; S, class Proj = identity,
             indirect_unary_predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
      constexpr I partition_point(I first, S last, Pred pred, Proj proj = {});
    template&lt;forward_range R, class Proj = identity,
             indirect_unary_predicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
      constexpr borrowed_iterator_t&lt;R&gt;
        partition_point(R&amp;&amp; r, Pred pred, Proj proj = {});
  }
 
  // merge
  template&lt;class InputIter1, class InputIter2, class OutputIter&gt;
    constexpr OutputIter
      merge(InputIter1 first1, InputIter1 last1,
            InputIter2 first2, InputIter2 last2,
            OutputIter result);
  template&lt;class InputIter1, class InputIter2, class OutputIter,
           class Compare&gt;
    constexpr OutputIter
      merge(InputIter1 first1, InputIter1 last1,
            InputIter2 first2, InputIter2 last2,
            OutputIter result, Compare comp);
  template&lt;class ExecutionPolicy, class ForwardIter1, class ForwardIter2,
           class ForwardIter&gt;
    ForwardIter
      merge(ExecutionPolicy&amp;&amp; exec,
            ForwardIter1 first1, ForwardIter1 last1,
            ForwardIter2 first2, ForwardIter2 last2,
            ForwardIter result);
  template&lt;class ExecutionPolicy, class ForwardIter1, class ForwardIter2,
           class ForwardIter, class Compare&gt;
    ForwardIter
      merge(ExecutionPolicy&amp;&amp; exec,
            ForwardIter1 first1, ForwardIter1 last1,
            ForwardIter2 first2, ForwardIter2 last2,
            ForwardIter result, Compare comp);
 
  namespace ranges {
    template&lt;class I1, class I2, class O&gt;
      using merge_result = in_in_out_result&lt;I1, I2, O&gt;;
 
    template&lt;input_iterator I1, sentinel_for&lt;I1&gt; S1, input_iterator I2,
             sentinel_for&lt;I2&gt; S2,
             weakly_incrementable O, class Comp = ranges::less, class Proj1 = identity,
             class Proj2 = identity&gt;
      requires mergeable&lt;I1, I2, O, Comp, Proj1, Proj2&gt;
      constexpr merge_result&lt;I1, I2, O&gt;
        merge(I1 first1, S1 last1, I2 first2, S2 last2, O result,
              Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
    template&lt;input_range R1, input_range R2, weakly_incrementable O, class Comp =
                 ranges::less, class Proj1 = identity, class Proj2 = identity&gt;
      requires mergeable&lt;iterator_t&lt;R1&gt;, iterator_t&lt;R2&gt;, O, Comp, Proj1, Proj2&gt;
      constexpr merge_result&lt;borrowed_iterator_t&lt;R1&gt;, borrowed_iterator_t&lt;R2&gt;, O&gt;
        merge(R1&amp;&amp; r1, R2&amp;&amp; r2, O result,
              Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
  }
 
  template&lt;class BidirectionalIter&gt;
    void inplace_merge(BidirectionalIter first,
                       BidirectionalIter middle,
                       BidirectionalIter last);
  template&lt;class BidirectionalIter, class Compare&gt;
    void inplace_merge(BidirectionalIter first,
                       BidirectionalIter middle,
                       BidirectionalIter last, Compare comp);
  template&lt;class ExecutionPolicy, class BidirectionalIter&gt;
    void inplace_merge(ExecutionPolicy&amp;&amp; exec,
                       BidirectionalIter first,
                       BidirectionalIter middle,
                       BidirectionalIter last);
  template&lt;class ExecutionPolicy, class BidirectionalIter, class Compare&gt;
    void inplace_merge(ExecutionPolicy&amp;&amp; exec,
                       BidirectionalIter first,
                       BidirectionalIter middle,
                       BidirectionalIter last, Compare comp);
 
  namespace ranges {
    template&lt;bidirectional_iterator I, sentinel_for&lt;I&gt; S, class Comp = ranges::less,
             class Proj = identity&gt;
      requires sortable&lt;I, Comp, Proj&gt;
      I inplace_merge(I first, I middle, S last, Comp comp = {}, Proj proj = {});
    template&lt;bidirectional_range R, class Comp = ranges::less, class Proj = identity&gt;
      requires sortable&lt;iterator_t&lt;R&gt;, Comp, Proj&gt;
      borrowed_iterator_t&lt;R&gt;
        inplace_merge(R&amp;&amp; r, iterator_t&lt;R&gt; middle, Comp comp = {},
                      Proj proj = {});
  }
 
  // set operations
  template&lt;class InputIter1, class InputIter2&gt;
    constexpr bool includes(InputIter1 first1, InputIter1 last1,
                            InputIter2 first2, InputIter2 last2);
  template&lt;class InputIter1, class InputIter2, class Compare&gt;
    constexpr bool includes(InputIter1 first1, InputIter1 last1,
                            InputIter2 first2, InputIter2 last2,
                            Compare comp);
  template&lt;class ExecutionPolicy, class ForwardIter1, class ForwardIter2&gt;
    bool includes(ExecutionPolicy&amp;&amp; exec,
                  ForwardIter1 first1, ForwardIter1 last1,
                  ForwardIter2 first2, ForwardIter2 last2);
  template&lt;class ExecutionPolicy, class ForwardIter1, class ForwardIter2,
           class Compare&gt;
    bool includes(ExecutionPolicy&amp;&amp; exec,
                  ForwardIter1 first1, ForwardIter1 last1,
                  ForwardIter2 first2, ForwardIter2 last2,
                  Compare comp);
 
  namespace ranges {
    template&lt;input_iterator I1, sentinel_for&lt;I1&gt; S1, input_iterator I2,
             sentinel_for&lt;I2&gt; S2, class Proj1 = identity, class Proj2 = identity,
             indirect_strict_weak_order&lt;projected&lt;I1, Proj1&gt;, projected&lt;I2, Proj2&gt;&gt; Comp =
               ranges::less&gt;
      constexpr bool includes(I1 first1, S1 last1, I2 first2, S2 last2, Comp comp = {},
                              Proj1 proj1 = {}, Proj2 proj2 = {});
    template&lt;input_range R1, input_range R2, class Proj1 = identity,
             class Proj2 = identity,
             indirect_strict_weak_order&lt;projected&lt;iterator_t&lt;R1&gt;, Proj1&gt;,
                                        projected&lt;iterator_t&lt;R2&gt;, Proj2&gt;&gt; Comp =
                                          ranges::less&gt;
      constexpr bool includes(R1&amp;&amp; r1, R2&amp;&amp; r2, Comp comp = {},
                              Proj1 proj1 = {}, Proj2 proj2 = {});
  }
 
  template&lt;class InputIter1, class InputIter2, class OutputIter&gt;
    constexpr OutputIter
      set_union(InputIter1 first1, InputIter1 last1,
                InputIter2 first2, InputIter2 last2,
                OutputIter result);
  template&lt;class InputIter1, class InputIter2, class OutputIter,
           class Compare&gt;
    constexpr OutputIter
                set_union(InputIter1 first1, InputIter1 last1,
                InputIter2 first2, InputIter2 last2,
                OutputIter result, Compare comp);
  template&lt;class ExecutionPolicy, class ForwardIter1, class ForwardIter2,
           class ForwardIter&gt;
    ForwardIter
      set_union(ExecutionPolicy&amp;&amp; exec,
                ForwardIter1 first1, ForwardIter1 last1,
                ForwardIter2 first2, ForwardIter2 last2,
                ForwardIter result);
  template&lt;class ExecutionPolicy, class ForwardIter1, class ForwardIter2,
           class ForwardIter, class Compare&gt;
    ForwardIter
      set_union(ExecutionPolicy&amp;&amp; exec,
                ForwardIter1 first1, ForwardIter1 last1,
                ForwardIter2 first2, ForwardIter2 last2,
                ForwardIter result, Compare comp);
 
  namespace ranges {
    template&lt;class I1, class I2, class O&gt;
      using set_union_result = in_in_out_result&lt;I1, I2, O&gt;;
 
    template&lt;input_iterator I1, sentinel_for&lt;I1&gt; S1, input_iterator I2,
             sentinel_for&lt;I2&gt; S2,
             weakly_incrementable O, class Comp = ranges::less,
             class Proj1 = identity, class Proj2 = identity&gt;
      requires mergeable&lt;I1, I2, O, Comp, Proj1, Proj2&gt;
      constexpr set_union_result&lt;I1, I2, O&gt;
        set_union(I1 first1, S1 last1, I2 first2, S2 last2, O result, Comp comp = {},
                  Proj1 proj1 = {}, Proj2 proj2 = {});
    template&lt;input_range R1, input_range R2, weakly_incrementable O,
             class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&gt;
      requires mergeable&lt;iterator_t&lt;R1&gt;, iterator_t&lt;R2&gt;, O, Comp, Proj1, Proj2&gt;
      constexpr set_union_result&lt;borrowed_iterator_t&lt;R1&gt;, borrowed_iterator_t&lt;R2&gt;, O&gt;
        set_union(R1&amp;&amp; r1, R2&amp;&amp; r2, O result, Comp comp = {},
                  Proj1 proj1 = {}, Proj2 proj2 = {});
  }
 
  template&lt;class InputIter1, class InputIter2, class OutputIter&gt;
    constexpr OutputIter
      set_intersection(InputIter1 first1, InputIter1 last1,
                       InputIter2 first2, InputIter2 last2,
                       OutputIter result);
  template&lt;class InputIter1, class InputIter2, class OutputIter,
           class Compare&gt;
    constexpr OutputIter
      set_intersection(InputIter1 first1, InputIter1 last1,
                       InputIter2 first2, InputIter2 last2,
                       OutputIter result, Compare comp);
  template&lt;class ExecutionPolicy, class ForwardIter1, class ForwardIter2,
           class ForwardIter&gt;
    ForwardIter
      set_intersection(ExecutionPolicy&amp;&amp; exec,
                       ForwardIter1 first1, ForwardIter1 last1,
                       ForwardIter2 first2, ForwardIter2 last2,
                       ForwardIter result);
  template&lt;class ExecutionPolicy, class ForwardIter1, class ForwardIter2,
           class ForwardIter, class Compare&gt;
    ForwardIter
      set_intersection(ExecutionPolicy&amp;&amp; exec,
                       ForwardIter1 first1, ForwardIter1 last1,
                       ForwardIter2 first2, ForwardIter2 last2,
                       ForwardIter result, Compare comp);
 
  namespace ranges {
    template&lt;class I1, class I2, class O&gt;
      using set_intersection_result = in_in_out_result&lt;I1, I2, O&gt;;
 
    template&lt;input_iterator I1, sentinel_for&lt;I1&gt; S1, input_iterator I2,
             sentinel_for&lt;I2&gt; S2,
             weakly_incrementable O, class Comp = ranges::less,
             class Proj1 = identity, class Proj2 = identity&gt;
      requires mergeable&lt;I1, I2, O, Comp, Proj1, Proj2&gt;
      constexpr set_intersection_result&lt;I1, I2, O&gt;
        set_intersection(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                         Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
    template&lt;input_range R1, input_range R2, weakly_incrementable O,
             class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&gt;
      requires mergeable&lt;iterator_t&lt;R1&gt;, iterator_t&lt;R2&gt;, O, Comp, Proj1, Proj2&gt;
      constexpr set_intersection_result&lt;borrowed_iterator_t&lt;R1&gt;,
                                        borrowed_iterator_t&lt;R2&gt;, O&gt;
        set_intersection(R1&amp;&amp; r1, R2&amp;&amp; r2, O result,
                         Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
  }
 
  template&lt;class InputIter1, class InputIter2, class OutputIter&gt;
    constexpr OutputIter
      set_difference(InputIter1 first1, InputIter1 last1,
                     InputIter2 first2, InputIter2 last2,
                     OutputIter result);
  template&lt;class InputIter1, class InputIter2, class OutputIter,
           class Compare&gt;
    constexpr OutputIter
      set_difference(InputIter1 first1, InputIter1 last1,
                     InputIter2 first2, InputIter2 last2,
                     OutputIter result, Compare comp);
  template&lt;class ExecutionPolicy, class ForwardIter1, class ForwardIter2,
           class ForwardIter&gt;
    ForwardIter
      set_difference(ExecutionPolicy&amp;&amp; exec,
                     ForwardIter1 first1, ForwardIter1 last1,
                     ForwardIter2 first2, ForwardIter2 last2,
                     ForwardIter result);
  template&lt;class ExecutionPolicy, class ForwardIter1, class ForwardIter2,
           class ForwardIter, class Compare&gt;
    ForwardIter
      set_difference(ExecutionPolicy&amp;&amp; exec,
                     ForwardIter1 first1, ForwardIter1 last1,
                     ForwardIter2 first2, ForwardIter2 last2,
                     ForwardIter result, Compare comp);
 
  namespace ranges {
    template&lt;class I, class O&gt;
      using set_difference_result = in_out_result&lt;I, O&gt;;
 
    template&lt;input_iterator I1, sentinel_for&lt;I1&gt; S1, input_iterator I2,
             sentinel_for&lt;I2&gt; S2,
             weakly_incrementable O, class Comp = ranges::less,
             class Proj1 = identity, class Proj2 = identity&gt;
      requires mergeable&lt;I1, I2, O, Comp, Proj1, Proj2&gt;
      constexpr set_difference_result&lt;I1, O&gt;
        set_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                       Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
    template&lt;input_range R1, input_range R2, weakly_incrementable O,
             class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&gt;
      requires mergeable&lt;iterator_t&lt;R1&gt;, iterator_t&lt;R2&gt;, O, Comp, Proj1, Proj2&gt;
      constexpr set_difference_result&lt;borrowed_iterator_t&lt;R1&gt;, O&gt;
        set_difference(R1&amp;&amp; r1, R2&amp;&amp; r2, O result,
                       Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
  }
 
  template&lt;class InputIter1, class InputIter2, class OutputIter&gt;
    constexpr OutputIter
      set_symmetric_difference(InputIter1 first1, InputIter1 last1,
                               InputIter2 first2, InputIter2 last2,
                               OutputIter result);
  template&lt;class InputIter1, class InputIter2, class OutputIter,
           class Compare&gt;
    constexpr OutputIter
      set_symmetric_difference(InputIter1 first1, InputIter1 last1,
                               InputIter2 first2, InputIter2 last2,
                               OutputIter result, Compare comp);
  template&lt;class ExecutionPolicy, class ForwardIter1, class ForwardIter2,
           class ForwardIter&gt;
    ForwardIter
      set_symmetric_difference(ExecutionPolicy&amp;&amp; exec,
                               ForwardIter1 first1, ForwardIter1 last1,
                               ForwardIter2 first2, ForwardIter2 last2,
                               ForwardIter result);
  template&lt;class ExecutionPolicy, class ForwardIter1, class ForwardIter2,
           class ForwardIter, class Compare&gt;
    ForwardIter
      set_symmetric_difference(ExecutionPolicy&amp;&amp; exec,
                               ForwardIter1 first1, ForwardIter1 last1,
                               ForwardIter2 first2, ForwardIter2 last2,
                               ForwardIter result, Compare comp);
 
  namespace ranges {
    template&lt;class I1, class I2, class O&gt;
      using set_symmetric_difference_result = in_in_out_result&lt;I1, I2, O&gt;;
 
    template&lt;input_iterator I1, sentinel_for&lt;I1&gt; S1, input_iterator I2,
             sentinel_for&lt;I2&gt; S2,
             weakly_incrementable O, class Comp = ranges::less,
             class Proj1 = identity, class Proj2 = identity&gt;
      requires mergeable&lt;I1, I2, O, Comp, Proj1, Proj2&gt;
      constexpr set_symmetric_difference_result&lt;I1, I2, O&gt;
        set_symmetric_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                                 Comp comp = {}, Proj1 proj1 = {},
                                 Proj2 proj2 = {});
    template&lt;input_range R1, input_range R2, weakly_incrementable O,
             class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&gt;
      requires mergeable&lt;iterator_t&lt;R1&gt;, iterator_t&lt;R2&gt;, O, Comp, Proj1, Proj2&gt;
      constexpr set_symmetric_difference_result&lt;borrowed_iterator_t&lt;R1&gt;,
                                                borrowed_iterator_t&lt;R2&gt;, O&gt;
        set_symmetric_difference(R1&amp;&amp; r1, R2&amp;&amp; r2, O result, Comp comp = {},
                                 Proj1 proj1 = {}, Proj2 proj2 = {});
  }
 
  // heap operations
  template&lt;class RandomAccessIter&gt;
    constexpr void push_heap(RandomAccessIter first, RandomAccessIter last);
  template&lt;class RandomAccessIter, class Compare&gt;
    constexpr void push_heap(RandomAccessIter first, RandomAccessIter last,
                             Compare comp);
 
  namespace ranges {
    template&lt;random_access_iterator I, sentinel_for&lt;I&gt; S, class Comp = ranges::less,
             class Proj = identity&gt;
      requires sortable&lt;I, Comp, Proj&gt;
      constexpr I
        push_heap(I first, S last, Comp comp = {}, Proj proj = {});
    template&lt;random_access_range R, class Comp = ranges::less, class Proj = identity&gt;
      requires sortable&lt;iterator_t&lt;R&gt;, Comp, Proj&gt;
      constexpr borrowed_iterator_t&lt;R&gt;
        push_heap(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
  }
 
  template&lt;class RandomAccessIter&gt;
    constexpr void pop_heap(RandomAccessIter first, RandomAccessIter last);
  template&lt;class RandomAccessIter, class Compare&gt;
    constexpr void pop_heap(RandomAccessIter first, RandomAccessIter last,
                            Compare comp);
 
  namespace ranges {
    template&lt;random_access_iterator I, sentinel_for&lt;I&gt; S, class Comp = ranges::less,
             class Proj = identity&gt;
      requires sortable&lt;I, Comp, Proj&gt;
      constexpr I
        pop_heap(I first, S last, Comp comp = {}, Proj proj = {});
    template&lt;random_access_range R, class Comp = ranges::less, class Proj = identity&gt;
      requires sortable&lt;iterator_t&lt;R&gt;, Comp, Proj&gt;
      constexpr borrowed_iterator_t&lt;R&gt;
        pop_heap(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
  }
 
  template&lt;class RandomAccessIter&gt;
    constexpr void make_heap(RandomAccessIter first, RandomAccessIter last);
  template&lt;class RandomAccessIter, class Compare&gt;
    constexpr void make_heap(RandomAccessIter first, RandomAccessIter last,
                             Compare comp);
 
  namespace ranges {
    template&lt;random_access_iterator I, sentinel_for&lt;I&gt; S, class Comp = ranges::less,
             class Proj = identity&gt;
      requires sortable&lt;I, Comp, Proj&gt;
      constexpr I
        make_heap(I first, S last, Comp comp = {}, Proj proj = {});
    template&lt;random_access_range R, class Comp = ranges::less, class Proj = identity&gt;
      requires sortable&lt;iterator_t&lt;R&gt;, Comp, Proj&gt;
      constexpr borrowed_iterator_t&lt;R&gt;
        make_heap(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
  }
 
  template&lt;class RandomAccessIter&gt;
    constexpr void sort_heap(RandomAccessIter first, RandomAccessIter last);
  template&lt;class RandomAccessIter, class Compare&gt;
    constexpr void sort_heap(RandomAccessIter first, RandomAccessIter last,
                             Compare comp);
 
  namespace ranges {
    template&lt;random_access_iterator I, sentinel_for&lt;I&gt; S, class Comp = ranges::less,
             class Proj = identity&gt;
      requires sortable&lt;I, Comp, Proj&gt;
      constexpr I
        sort_heap(I first, S last, Comp comp = {}, Proj proj = {});
    template&lt;random_access_range R, class Comp = ranges::less, class Proj = identity&gt;
      requires sortable&lt;iterator_t&lt;R&gt;, Comp, Proj&gt;
      constexpr borrowed_iterator_t&lt;R&gt;
        sort_heap(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
  }
 
  template&lt;class RandomAccessIter&gt;
    constexpr bool is_heap(RandomAccessIter first, RandomAccessIter last);
  template&lt;class RandomAccessIter, class Compare&gt;
    constexpr bool is_heap(RandomAccessIter first, RandomAccessIter last,
                           Compare comp);
  template&lt;class ExecutionPolicy, class RandomAccessIter&gt;
    bool is_heap(ExecutionPolicy&amp;&amp; exec,
                 RandomAccessIter first, RandomAccessIter last);
  template&lt;class ExecutionPolicy, class RandomAccessIter, class Compare&gt;
    bool is_heap(ExecutionPolicy&amp;&amp; exec,
                 RandomAccessIter first, RandomAccessIter last,
                 Compare comp);
 
  namespace ranges {
    template&lt;random_access_iterator I, sentinel_for&lt;I&gt; S, class Proj = identity,
             indirect_strict_weak_order&lt;projected&lt;I, Proj&gt;&gt; Comp = ranges::less&gt;
      constexpr bool is_heap(I first, S last, Comp comp = {}, Proj proj = {});
    template&lt;random_access_range R, class Proj = identity,
             indirect_strict_weak_order&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Comp =
               ranges::less&gt;
      constexpr bool is_heap(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
  }
 
  template&lt;class RandomAccessIter&gt;
    constexpr RandomAccessIter
      is_heap_until(RandomAccessIter first, RandomAccessIter last);
  template&lt;class RandomAccessIter, class Compare&gt;
    constexpr RandomAccessIter
      is_heap_until(RandomAccessIter first, RandomAccessIter last,
                    Compare comp);
  template&lt;class ExecutionPolicy, class RandomAccessIter&gt;
    RandomAccessIter
      is_heap_until(ExecutionPolicy&amp;&amp; exec,
                    RandomAccessIter first, RandomAccessIter last);
  template&lt;class ExecutionPolicy, class RandomAccessIter, class Compare&gt;
    RandomAccessIter
      is_heap_until(ExecutionPolicy&amp;&amp; exec,
                    RandomAccessIter first, RandomAccessIter last,
                    Compare comp);
 
  namespace ranges {
    template&lt;random_access_iterator I, sentinel_for&lt;I&gt; S, class Proj = identity,
             indirect_strict_weak_order&lt;projected&lt;I, Proj&gt;&gt; Comp = ranges::less&gt;
      constexpr I is_heap_until(I first, S last, Comp comp = {}, Proj proj = {});
    template&lt;random_access_range R, class Proj = identity,
             indirect_strict_weak_order&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Comp =
               ranges::less&gt;
      constexpr borrowed_iterator_t&lt;R&gt;
        is_heap_until(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
  }
 
  // minimum and maximum
  template&lt;class T&gt; constexpr const T&amp; min(const T&amp; a, const T&amp; b);
  template&lt;class T, class Compare&gt;
    constexpr const T&amp; min(const T&amp; a, const T&amp; b, Compare comp);
  template&lt;class T&gt;
    constexpr T min(initializer_list&lt;T&gt; t);
  template&lt;class T, class Compare&gt;
    constexpr T min(initializer_list&lt;T&gt; t, Compare comp);
 
  namespace ranges {
    template&lt;class T, class Proj = identity,
             indirect_strict_weak_order&lt;projected&lt;const T*, Proj&gt;&gt; Comp = ranges::less&gt;
      constexpr const T&amp; min(const T&amp; a, const T&amp; b, Comp comp = {}, Proj proj = {});
    template&lt;copyable T, class Proj = identity,
             indirect_strict_weak_order&lt;projected&lt;const T*, Proj&gt;&gt; Comp = ranges::less&gt;
      constexpr T min(initializer_list&lt;T&gt; r, Comp comp = {}, Proj proj = {});
    template&lt;input_range R, class Proj = identity,
             indirect_strict_weak_order&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Comp =
               ranges::less&gt;
      requires indirectly_copyable_storable&lt;iterator_t&lt;R&gt;, range_value_t&lt;R&gt;*&gt;
      constexpr range_value_t&lt;R&gt;
        min(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
  }
 
  template&lt;class T&gt; constexpr const T&amp; max(const T&amp; a, const T&amp; b);
  template&lt;class T, class Compare&gt;
    constexpr const T&amp; max(const T&amp; a, const T&amp; b, Compare comp);
  template&lt;class T&gt;
    constexpr T max(initializer_list&lt;T&gt; t);
  template&lt;class T, class Compare&gt;
    constexpr T max(initializer_list&lt;T&gt; t, Compare comp);
 
  namespace ranges {
    template&lt;class T, class Proj = identity,
             indirect_strict_weak_order&lt;projected&lt;const T*, Proj&gt;&gt; Comp = ranges::less&gt;
      constexpr const T&amp; max(const T&amp; a, const T&amp; b, Comp comp = {}, Proj proj = {});
    template&lt;copyable T, class Proj = identity,
             indirect_strict_weak_order&lt;projected&lt;const T*, Proj&gt;&gt; Comp = ranges::less&gt;
      constexpr T max(initializer_list&lt;T&gt; r, Comp comp = {}, Proj proj = {});
    template&lt;input_range R, class Proj = identity,
             indirect_strict_weak_order&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Comp =
               ranges::less&gt;
      requires indirectly_copyable_storable&lt;iterator_t&lt;R&gt;, range_value_t&lt;R&gt;*&gt;
      constexpr range_value_t&lt;R&gt;
        max(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
  }
 
  template&lt;class T&gt; constexpr pair&lt;const T&amp;, const T&amp;&gt; minmax(const T&amp; a, const T&amp; b);
  template&lt;class T, class Compare&gt;
    constexpr pair&lt;const T&amp;, const T&amp;&gt; minmax(const T&amp; a, const T&amp; b, Compare comp);
  template&lt;class T&gt;
    constexpr pair&lt;T, T&gt; minmax(initializer_list&lt;T&gt; t);
  template&lt;class T, class Compare&gt;
    constexpr pair&lt;T, T&gt; minmax(initializer_list&lt;T&gt; t, Compare comp);
 
  namespace ranges {
    template&lt;class T&gt;
      using minmax_result = min_max_result&lt;T&gt;;
 
    template&lt;class T, class Proj = identity,
             indirect_strict_weak_order&lt;projected&lt;const T*, Proj&gt;&gt; Comp = ranges::less&gt;
      constexpr minmax_result&lt;const T&amp;&gt;
        minmax(const T&amp; a, const T&amp; b, Comp comp = {}, Proj proj = {});
    template&lt;copyable T, class Proj = identity,
             indirect_strict_weak_order&lt;projected&lt;const T*, Proj&gt;&gt; Comp = ranges::less&gt;
      constexpr minmax_result&lt;T&gt;
        minmax(initializer_list&lt;T&gt; r, Comp comp = {}, Proj proj = {});
    template&lt;input_range R, class Proj = identity,
             indirect_strict_weak_order&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Comp =
               ranges::less&gt;
      requires indirectly_copyable_storable&lt;iterator_t&lt;R&gt;, range_value_t&lt;R&gt;*&gt;
      constexpr minmax_result&lt;range_value_t&lt;R&gt;&gt;
        minmax(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
  }
 
  template&lt;class ForwardIter&gt;
    constexpr ForwardIter min_element(ForwardIter first, ForwardIter last);
  template&lt;class ForwardIter, class Compare&gt;
    constexpr ForwardIter min_element(ForwardIter first, ForwardIter last,
                                          Compare comp);
  template&lt;class ExecutionPolicy, class ForwardIter&gt;
    ForwardIter min_element(ExecutionPolicy&amp;&amp; exec,
                                ForwardIter first, ForwardIter last);
  template&lt;class ExecutionPolicy, class ForwardIter, class Compare&gt;
    ForwardIter min_element(ExecutionPolicy&amp;&amp; exec,
                                ForwardIter first, ForwardIter last,
                                Compare comp);
 
  namespace ranges {
    template&lt;forward_iterator I, sentinel_for&lt;I&gt; S, class Proj = identity,
             indirect_strict_weak_order&lt;projected&lt;I, Proj&gt;&gt; Comp = ranges::less&gt;
      constexpr I min_element(I first, S last, Comp comp = {}, Proj proj = {});
    template&lt;forward_range R, class Proj = identity,
             indirect_strict_weak_order&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Comp =
               ranges::less&gt;
      constexpr borrowed_iterator_t&lt;R&gt;
        min_element(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
  }
 
  template&lt;class ForwardIter&gt;
    constexpr ForwardIter max_element(ForwardIter first, ForwardIter last);
  template&lt;class ForwardIter, class Compare&gt;
    constexpr ForwardIter max_element(ForwardIter first, ForwardIter last,
                                          Compare comp);
  template&lt;class ExecutionPolicy, class ForwardIter&gt;
    ForwardIter max_element(ExecutionPolicy&amp;&amp; exec,
                                ForwardIter first, ForwardIter last);
  template&lt;class ExecutionPolicy, class ForwardIter, class Compare&gt;
    ForwardIter max_element(ExecutionPolicy&amp;&amp; exec,
                                ForwardIter first, ForwardIter last,
                                Compare comp);
 
  namespace ranges {
    template&lt;forward_iterator I, sentinel_for&lt;I&gt; S, class Proj = identity,
             indirect_strict_weak_order&lt;projected&lt;I, Proj&gt;&gt; Comp = ranges::less&gt;
      constexpr I max_element(I first, S last, Comp comp = {}, Proj proj = {});
    template&lt;forward_range R, class Proj = identity,
             indirect_strict_weak_order&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Comp =
               ranges::less&gt;
      constexpr borrowed_iterator_t&lt;R&gt;
        max_element(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
  }
 
  template&lt;class ForwardIter&gt;
    constexpr pair&lt;ForwardIter, ForwardIter&gt;
      minmax_element(ForwardIter first, ForwardIter last);
  template&lt;class ForwardIter, class Compare&gt;
    constexpr pair&lt;ForwardIter, ForwardIter&gt;
      minmax_element(ForwardIter first, ForwardIter last, Compare comp);
  template&lt;class ExecutionPolicy, class ForwardIter&gt;
    pair&lt;ForwardIter, ForwardIter&gt;
      minmax_element(ExecutionPolicy&amp;&amp; exec,
                     ForwardIter first, ForwardIter last);
  template&lt;class ExecutionPolicy, class ForwardIter, class Compare&gt;
    pair&lt;ForwardIter, ForwardIter&gt;
      minmax_element(ExecutionPolicy&amp;&amp; exec,
                     ForwardIter first, ForwardIter last, Compare comp);
 
  namespace ranges {
    template&lt;class I&gt;
      using minmax_element_result = min_max_result&lt;I&gt;;
 
    template&lt;forward_iterator I, sentinel_for&lt;I&gt; S, class Proj = identity,
             indirect_strict_weak_order&lt;projected&lt;I, Proj&gt;&gt; Comp = ranges::less&gt;
      constexpr minmax_element_result&lt;I&gt;
        minmax_element(I first, S last, Comp comp = {}, Proj proj = {});
    template&lt;forward_range R, class Proj = identity,
             indirect_strict_weak_order&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Comp =
               ranges::less&gt;
      constexpr minmax_element_result&lt;borrowed_iterator_t&lt;R&gt;&gt;
        minmax_element(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
  }
 
  // bounded value
  template&lt;class T&gt;
    constexpr const T&amp; clamp(const T&amp; v, const T&amp; lo, const T&amp; hi);
  template&lt;class T, class Compare&gt;
    constexpr const T&amp; clamp(const T&amp; v, const T&amp; lo, const T&amp; hi, Compare comp);
 
  namespace ranges {
    template&lt;class T, class Proj = identity,
             indirect_strict_weak_order&lt;projected&lt;const T*, Proj&gt;&gt; Comp = ranges::less&gt;
      constexpr const T&amp;
        clamp(const T&amp; v, const T&amp; lo, const T&amp; hi, Comp comp = {}, Proj proj = {});
  }
 
  // lexicographical comparison
  template&lt;class InputIter1, class InputIter2&gt;
    constexpr bool
      lexicographical_compare(InputIter1 first1, InputIter1 last1,
                              InputIter2 first2, InputIter2 last2);
  template&lt;class InputIter1, class InputIter2, class Compare&gt;
    constexpr bool
      lexicographical_compare(InputIter1 first1, InputIter1 last1,
                              InputIter2 first2, InputIter2 last2,
                              Compare comp);
  template&lt;class ExecutionPolicy, class ForwardIter1, class ForwardIter2&gt;
    bool
      lexicographical_compare(ExecutionPolicy&amp;&amp; exec,
                              ForwardIter1 first1, ForwardIter1 last1,
                              ForwardIter2 first2, ForwardIter2 last2);
  template&lt;class ExecutionPolicy, class ForwardIter1, class ForwardIter2,
           class Compare&gt;
    bool
      lexicographical_compare(ExecutionPolicy&amp;&amp; exec,
                              ForwardIter1 first1, ForwardIter1 last1,
                              ForwardIter2 first2, ForwardIter2 last2,
                              Compare comp);
 
  namespace ranges {
    template&lt;input_iterator I1, sentinel_for&lt;I1&gt; S1, input_iterator I2,
             sentinel_for&lt;I2&gt; S2, class Proj1 = identity, class Proj2 = identity,
             indirect_strict_weak_order&lt;projected&lt;I1, Proj1&gt;, projected&lt;I2, Proj2&gt;&gt; Comp =
               ranges::less&gt;
      constexpr bool
        lexicographical_compare(I1 first1, S1 last1, I2 first2, S2 last2,
                                Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
    template&lt;input_range R1, input_range R2, class Proj1 = identity,
             class Proj2 = identity,
             indirect_strict_weak_order&lt;projected&lt;iterator_t&lt;R1&gt;, Proj1&gt;,
                                        projected&lt;iterator_t&lt;R2&gt;, Proj2&gt;&gt; Comp =
                                          ranges::less&gt;
      constexpr bool
        lexicographical_compare(R1&amp;&amp; r1, R2&amp;&amp; r2, Comp comp = {},
                                Proj1 proj1 = {}, Proj2 proj2 = {});
  }
 
  // three-way comparison algorithms
  template&lt;class InputIter1, class InputIter2, class Cmp&gt;
    constexpr auto
      lexicographical_compare_three_way(InputIter1 b1, InputIter1 e1,
                                        InputIter2 b2, InputIter2 e2,
                                        Cmp comp)
        -&gt; decltype(comp(*b1, *b2));
  template&lt;class InputIter1, class InputIter2&gt;
    constexpr auto
      lexicographical_compare_three_way(InputIter1 b1, InputIter1 e1,
                                        InputIter2 b2, InputIter2 e2);
 
  // permutations
  template&lt;class BidirectionalIter&gt;
    constexpr bool next_permutation(BidirectionalIter first,
                                    BidirectionalIter last);
  template&lt;class BidirectionalIter, class Compare&gt;
    constexpr bool next_permutation(BidirectionalIter first,
                                    BidirectionalIter last, Compare comp);
 
  namespace ranges {
    template&lt;class I&gt;
      using next_permutation_result = in_found_result&lt;I&gt;;
 
    template&lt;bidirectional_iterator I, sentinel_for&lt;I&gt; S, class Comp = ranges::less,
             class Proj = identity&gt;
      requires sortable&lt;I, Comp, Proj&gt;
      constexpr next_permutation_result&lt;I&gt;
        next_permutation(I first, S last, Comp comp = {}, Proj proj = {});
    template&lt;bidirectional_range R, class Comp = ranges::less,
             class Proj = identity&gt;
      requires sortable&lt;iterator_t&lt;R&gt;, Comp, Proj&gt;
      constexpr next_permutation_result&lt;borrowed_iterator_t&lt;R&gt;&gt;
        next_permutation(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
  }
 
  template&lt;class BidirectionalIter&gt;
    constexpr bool prev_permutation(BidirectionalIter first,
                                    BidirectionalIter last);
  template&lt;class BidirectionalIter, class Compare&gt;
    constexpr bool prev_permutation(BidirectionalIter first,
                                    BidirectionalIter last, Compare comp);
 
  namespace ranges {
    template&lt;class I&gt;
      using prev_permutation_result = in_found_result&lt;I&gt;;
 
    template&lt;bidirectional_iterator I, sentinel_for&lt;I&gt; S, class Comp = ranges::less,
             class Proj = identity&gt;
      requires sortable&lt;I, Comp, Proj&gt;
      constexpr prev_permutation_result&lt;I&gt;
        prev_permutation(I first, S last, Comp comp = {}, Proj proj = {});
    template&lt;bidirectional_range R, class Comp = ranges::less,
             class Proj = identity&gt;
      requires sortable&lt;iterator_t&lt;R&gt;, Comp, Proj&gt;
      constexpr prev_permutation_result&lt;borrowed_iterator_t&lt;R&gt;&gt;
        prev_permutation(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
  }
}</pre></div> <h4 id="Class_template_std::ranges::in_fun_result"> Class template <code><a href="../algorithm/ranges/return_types/in_fun_result" title="cpp/algorithm/ranges/return types/in fun result">std::ranges::in_fun_result</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class I, class F&gt;
  struct in_fun_result {
    [[no_unique_address]] I in;
    [[no_unique_address]] F fun;
 
    template&lt;class I2, class F2&gt;
      requires convertible_to&lt;const I&amp;, I2&gt; &amp;&amp; convertible_to&lt;const F&amp;, F2&gt;
    constexpr operator in_fun_result&lt;I2, F2&gt;() const &amp; {
      return {in, fun};
    }
 
    template&lt;class I2, class F2&gt;
      requires convertible_to&lt;I, I2&gt; &amp;&amp; convertible_to&lt;F, F2&gt;
    constexpr operator in_fun_result&lt;I2, F2&gt;() &amp;&amp; {
      return {std::move(in), std::move(fun)};
    }
  };
}</pre></div> <h4 id="Class_template_std::ranges::in_in_result"> Class template <code><a href="../algorithm/ranges/return_types/in_in_result" title="cpp/algorithm/ranges/return types/in in result">std::ranges::in_in_result</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class I1, class I2&gt;
  struct in_in_result {
    [[no_unique_address]] I1 in1;
    [[no_unique_address]] I2 in2;
 
    template&lt;class II1, class II2&gt;
      requires convertible_to&lt;const I1&amp;, II1&gt; &amp;&amp; convertible_to&lt;const I2&amp;, II2&gt;
    constexpr operator in_in_result&lt;II1, II2&gt;() const &amp; {
      return {in1, in2};
    }
 
    template&lt;class II1, class II2&gt;
      requires convertible_to&lt;I1, II1&gt; &amp;&amp; convertible_to&lt;I2, II2&gt;
    constexpr operator in_in_result&lt;II1, II2&gt;() &amp;&amp; {
      return {std::move(in1), std::move(in2)};
    }
  };
}</pre></div> <h4 id="Class_template_std::ranges::in_out_result"> Class template <code><a href="../algorithm/ranges/return_types/in_out_result" title="cpp/algorithm/ranges/return types/in out result">std::ranges::in_out_result</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class I, class O&gt;
  struct in_out_result {
    [[no_unique_address]] I in;
    [[no_unique_address]] O out;
 
    template&lt;class I2, class O2&gt;
      requires convertible_to&lt;const I&amp;, I2&gt; &amp;&amp; convertible_to&lt;const O&amp;, O2&gt;
    constexpr operator in_out_result&lt;I2, O2&gt;() const &amp; {
      return {in, out};
    }
 
    template&lt;class I2, class O2&gt;
      requires convertible_to&lt;I, I2&gt; &amp;&amp; convertible_to&lt;O, O2&gt;
    constexpr operator in_out_result&lt;I2, O2&gt;() &amp;&amp; {
      return {std::move(in), std::move(out)};
    }
  };
}</pre></div> <h4 id="Class_template_std::ranges::in_in_out_result"> Class template <code><a href="../algorithm/ranges/return_types/in_in_out_result" title="cpp/algorithm/ranges/return types/in in out result">std::ranges::in_in_out_result</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class I1, class I2, class O&gt;
  struct in_in_out_result {
    [[no_unique_address]] I1 in1;
    [[no_unique_address]] I2 in2;
    [[no_unique_address]] O  out;
 
    template&lt;class II1, class II2, class OO&gt;
      requires convertible_to&lt;const I1&amp;, II1&gt; &amp;&amp;
               convertible_to&lt;const I2&amp;, II2&gt; &amp;&amp;
               convertible_to&lt;const O&amp;, OO&gt;
    constexpr operator in_in_out_result&lt;II1, II2, OO&gt;() const &amp; {
      return {in1, in2, out};
    }
 
    template&lt;class II1, class II2, class OO&gt;
      requires convertible_to&lt;I1, II1&gt; &amp;&amp;
               convertible_to&lt;I2, II2&gt; &amp;&amp;
               convertible_to&lt;O, OO&gt;
    constexpr operator in_in_out_result&lt;II1, II2, OO&gt;() &amp;&amp; {
      return {std::move(in1), std::move(in2), std::move(out)};
    }
  };
}</pre></div> <h4 id="Class_template_std::ranges::in_out_out_result"> Class template <code><a href="../algorithm/ranges/return_types/in_out_out_result" title="cpp/algorithm/ranges/return types/in out out result">std::ranges::in_out_out_result</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class I, class O1, class O2&gt;
  struct in_out_out_result {
    [[no_unique_address]] I  in;
    [[no_unique_address]] O1 out1;
    [[no_unique_address]] O2 out2;
 
    template&lt;class II, class OO1, class OO2&gt;
      requires convertible_to&lt;const I&amp;, II&gt; &amp;&amp;
               convertible_to&lt;const O1&amp;, OO1&gt; &amp;&amp;
               convertible_to&lt;const O2&amp;, OO2&gt;
    constexpr operator in_out_out_result&lt;II, OO1, OO2&gt;() const &amp; {
      return {in, out1, out2};
    }
 
    template&lt;class II, class OO1, class OO2&gt;
      requires convertible_to&lt;I, II&gt; &amp;&amp;
               convertible_to&lt;O1, OO1&gt; &amp;&amp;
               convertible_to&lt;O2, OO2&gt;
    constexpr operator in_out_out_result&lt;II, OO1, OO2&gt;() &amp;&amp; {
      return {std::move(in), std::move(out1), std::move(out2)};
    }
  };
}</pre></div> <h4 id="Class_template_std::ranges::min_max_result"> Class template <code><a href="../algorithm/ranges/return_types/min_max_result" title="cpp/algorithm/ranges/return types/min max result">std::ranges::min_max_result</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class T&gt;
  struct min_max_result {
    [[no_unique_address]] T min;
    [[no_unique_address]] T max;
 
    template&lt;class T2&gt;
      requires convertible_to&lt;const T&amp;, T2&gt;
    constexpr operator min_max_result&lt;T2&gt;() const &amp; {
      return {min, max};
    }
 
    template&lt;class T2&gt;
      requires convertible_to&lt;T, T2&gt;
    constexpr operator min_max_result&lt;T2&gt;() &amp;&amp; {
      return {std::move(min), std::move(max)};
    }
  };
}</pre></div> <h4 id="Class_template_std::ranges::in_found_result"> Class template <code><a href="../algorithm/ranges/return_types/in_found_result" title="cpp/algorithm/ranges/return types/in found result">std::ranges::in_found_result</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class I&gt;
  struct in_found_result {
    [[no_unique_address]] I in;
    bool found;
 
    template&lt;class I2&gt;
      requires convertible_to&lt;const I&amp;, I2&gt;
    constexpr operator in_found_result&lt;I2&gt;() const &amp; {
      return {in, found};
    }
    template&lt;class I2&gt;
      requires convertible_to&lt;I, I2&gt;
    constexpr operator in_found_result&lt;I2&gt;() &amp;&amp; {
      return {std::move(in), found};
    }
  };
}</pre></div> <h4 id="Class_template_std::ranges::in_value_result"> Class template <code>std::ranges::in_value_result</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
template&lt;class I, class T&gt;
  struct in_value_result {
    [[no_unique_address]] I in;
    [[no_unique_address]] T value;
 
    template&lt;class I2, class T2&gt;
      requires convertible_to&lt;const I&amp;, I2&gt; &amp;&amp; convertible_to&lt;const T&amp;, T2&gt;
    constexpr operator in_value_result&lt;I2, T2&gt;() const &amp; {
      return {in, value};
    }
 
    template&lt;class I2, class T2&gt;
      requires convertible_to&lt;I, I2&gt; &amp;&amp; convertible_to&lt;T, T2&gt;
    constexpr operator in_value_result&lt;I2, T2&gt;() &amp;&amp; {
      return {std::move(in), std::move(value)};
    }
  };
}</pre></div> <h4 id="Class_template_std::ranges::out_value_result"> Class template <code>std::ranges::out_value_result</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
template&lt;class O, class T&gt;
  struct out_value_result {
    [[no_unique_address]] O out;
    [[no_unique_address]] T value;
 
    template&lt;class O2, class T2&gt;
      requires convertible_to&lt;const O&amp;, O2&gt; &amp;&amp; convertible_to&lt;const T&amp;, T2&gt;
    constexpr operator out_value_result&lt;O2, T2&gt;() const &amp; {
      return {out, value};
    }
 
    template&lt;class O2, class T2&gt;
      requires convertible_to&lt;O, O2&gt; &amp;&amp; convertible_to&lt;T, T2&gt;
    constexpr operator out_value_result&lt;O2, T2&gt;() &amp;&amp; {
      return {std::move(out), std::move(value)};
    }
  };
}</pre></div>           <div class="_attribution">
  <p class="_attribution-p">
     cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/header/algorithm" class="_attribution-link">https://en.cppreference.com/w/cpp/header/algorithm</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
