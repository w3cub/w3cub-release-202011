
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Iterator - C++ - W3cubDocs</title>
  
  <meta name="description" content=" This header is part of the iterator library. ">
  <meta name="keywords" content="standard, library, header, iterator, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/header/iterator.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/cpp.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _c">
				
				
<h1 id="firstHeading" class="firstHeading">Standard library header &lt;iterator&gt;</h1>            <p>This header is part of the <a href="../iterator" title="cpp/iterator">iterator</a> library.</p>
<table class="t-dsc-begin"> <tr> <td colspan="2"> <h3 id="Concepts"> Concepts</h3> </td>
</tr> <tr> <td colspan="2"> <h5 id="Iterator_concepts">  Iterator concepts </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Readable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/Readable（页面不存在）"> <span class="t-lines"><span>Readable</span></span></a></div> </td> <td> specifies that a type is readable by applying operator <code>*</code> <br> <span class="t-mark">(concept)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Writable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/Writable（页面不存在）"> <span class="t-lines"><span>Writable</span></span></a></div> </td> <td> specifies that a value can be written to an iterator's referenced object <br> <span class="t-mark">(concept)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/WeaklyIncrementable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/WeaklyIncrementable（页面不存在）"> <span class="t-lines"><span>WeaklyIncrementable</span></span></a></div> </td> <td> specifies that a <a href="../concepts/semiregular" title="cpp/concepts/Semiregular"><code>Semiregular</code></a> type can be incremented with pre- and post-increment operators <br> <span class="t-mark">(concept)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Incrementable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/Incrementable（页面不存在）"> <span class="t-lines"><span>Incrementable</span></span></a></div> </td> <td> specifies that the increment operation on a <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/WeaklyIncrementable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/WeaklyIncrementable（页面不存在）"><code>WeaklyIncrementable</code></a> type is equality-preserving and that the type is <a href="../concepts/equalitycomparable" title="cpp/concepts/EqualityComparable"><code>EqualityComparable</code></a> <br> <span class="t-mark">(concept)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Iterator&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/Iterator（页面不存在）"> <span class="t-lines"><span>Iterator</span></span></a></div> </td> <td> specifies that objects of a type can be incremented and dereferenced <br> <span class="t-mark">(concept)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Sentinel&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/Sentinel（页面不存在）"> <span class="t-lines"><span>Sentinel</span></span></a></div> </td> <td> specifies a type is a sentinel for an <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Iterator&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/Iterator（页面不存在）"><code>Iterator</code></a> type <br> <span class="t-mark">(concept)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/SizedSentinel&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/SizedSentinel（页面不存在）"> <span class="t-lines"><span>SizedSentinel</span></span></a></div> </td> <td> specifies that the - operator can be applied to an iterator and a sentinel to calculate their difference in constant time <br> <span class="t-mark">(concept)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/InputIterator&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/InputIterator（页面不存在）"> <span class="t-lines"><span>InputIterator</span></span></a></div> </td> <td> specifies that a type is an input iterator, that is, its referenced values can be read and it can be both pre- and post-incremented <br> <span class="t-mark">(concept)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/OutputIterator&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/OutputIterator（页面不存在）"> <span class="t-lines"><span>OutputIterator</span></span></a></div> </td> <td> specifies that a type is an output iterator for a given value type, that is, values of that type can be written to it and it can be both pre- and post-incremented <br> <span class="t-mark">(concept)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/ForwardIterator&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/ForwardIterator（页面不存在）"> <span class="t-lines"><span>ForwardIterator</span></span></a></div> </td> <td> specifies that an <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/InputIterator&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/InputIterator（页面不存在）"><code>InputIterator</code></a> is a forward iterator, supporting equality comparison and multi-pass <br> <span class="t-mark">(concept)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/BidirectionalIterator&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/BidirectionalIterator（页面不存在）"> <span class="t-lines"><span>BidirectionalIterator</span></span></a></div> </td> <td> specifies that a <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/ForwardIterator&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/ForwardIterator（页面不存在）"><code>ForwardIterator</code></a> is a bidirectional interator, supporting movement backwards <br> <span class="t-mark">(concept)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/RandomAccessIterator&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/RandomAccessIterator（页面不存在）"> <span class="t-lines"><span>RandomAccessIterator</span></span></a></div> </td> <td> specifies that a <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/BidirectionalIterator&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/BidirectionalIterator（页面不存在）"><code>BidirectionalIterator</code></a> is a random-access iterator, supporting advancement in constant time and subscripting <br> <span class="t-mark">(concept)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/ContiguousIterator&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/ContiguousIterator（页面不存在）"> <span class="t-lines"><span>ContiguousIterator</span></span></a></div> </td> <td> specifies that a <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/RandomAccessIterator&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/RandomAccessIterator（页面不存在）"><code>RandomAccessIterator</code></a> is a contiguous iterator, referring to elements that are contiguous in memory <br> <span class="t-mark">(concept)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Indirect_callable_concepts">  Indirect callable concepts </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/IndirectUnaryInvocable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/IndirectUnaryInvocable（页面不存在）"> <span class="t-lines"><span>IndirectUnaryInvocable</span><span>IndirectRegularUnaryInvocable</span></span></a></div> </td> <td> specifies that a callable type can be invoked with the result of dereferencing a <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Readable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/Readable（页面不存在）"><code>Readable</code></a> type <br> <span class="t-mark">(concept)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/IndirectUnaryPredicate&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/IndirectUnaryPredicate（页面不存在）"> <span class="t-lines"><span>IndirectUnaryPredicate</span></span></a></div> </td> <td> specifies that a callable type, when invoked with the result of dereferencing a <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Readable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/Readable（页面不存在）"><code>Readable</code></a> type, satisfies <a href="../concepts/predicate" title="cpp/concepts/Predicate"><code>Predicate</code></a> <br> <span class="t-mark">(concept)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/IndirectRelation&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/IndirectRelation（页面不存在）"> <span class="t-lines"><span>IndirectRelation</span></span></a></div> </td> <td> specifies that a callable type, when invoked with the result of dereferencing two <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Readable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/Readable（页面不存在）"><code>Readable</code></a> types, satisfies <a href="../concepts/predicate" title="cpp/concepts/Predicate"><code>Predicate</code></a> <br> <span class="t-mark">(concept)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/IndirectStrictWeakOrder&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/IndirectStrictWeakOrder（页面不存在）"> <span class="t-lines"><span>IndirectStrictWeakOrder</span></span></a></div> </td> <td> specifies that a callable type, when invoked with the result of dereferencing two <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Readable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/Readable（页面不存在）"><code>Readable</code></a> types, satisfies <a href="../concepts/strictweakorder" title="cpp/concepts/StrictWeakOrder"><code>StrictWeakOrder</code></a> <br> <span class="t-mark">(concept)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Common_algorithm_requirements">  Common algorithm requirements </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/IndirectlyMovable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/IndirectlyMovable（页面不存在）"> <span class="t-lines"><span>IndirectlyMovable</span></span></a></div> </td> <td> specifies that values may be moved from a <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Readable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/Readable（页面不存在）"><code>Readable</code></a> type to a <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Writable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/Writable（页面不存在）"><code>Writable</code></a> type <br> <span class="t-mark">(concept)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/IndirectlyMovableStorable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/IndirectlyMovableStorable（页面不存在）"> <span class="t-lines"><span>IndirectlyMovableStorable</span></span></a></div> </td> <td> specifies that values may be moved from a <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Readable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/Readable（页面不存在）"><code>Readable</code></a> type to a <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Writable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/Writable（页面不存在）"><code>Writable</code></a> type and that the move may be performed via an intermediate object <br> <span class="t-mark">(concept)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/IndirectlyCopyable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/IndirectlyCopyable（页面不存在）"> <span class="t-lines"><span>IndirectlyCopyable</span></span></a></div> </td> <td> specifies that values may be copied from a <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Readable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/Readable（页面不存在）"><code>Readable</code></a> type to a <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Writable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/Writable（页面不存在）"><code>Writable</code></a> type <br> <span class="t-mark">(concept)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/IndirectlyCopyableStorable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/IndirectlyCopyableStorable（页面不存在）"> <span class="t-lines"><span>IndirectlyCopyableStorable</span></span></a></div> </td> <td> specifies that values may be copied from a <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Readable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/Readable（页面不存在）"><code>Readable</code></a> type to a <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Writable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/Writable（页面不存在）"><code>Writable</code></a> type and that the copy may be performed via an intermediate object <br> <span class="t-mark">(concept)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/IndirectlySwappable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/IndirectlySwappable（页面不存在）"> <span class="t-lines"><span>IndirectlySwappable</span></span></a></div> </td> <td> specifies that the values referenced by two <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Readable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/Readable（页面不存在）"><code>Readable</code></a> types can be swapped <br> <span class="t-mark">(concept)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/IndirectlyComparable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/IndirectlyComparable（页面不存在）"> <span class="t-lines"><span>IndirectlyComparable</span></span></a></div> </td> <td> specifies that the values referenced by two <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Readable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/Readable（页面不存在）"><code>Readable</code></a> types can be compared <br> <span class="t-mark">(concept)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Permutable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/Permutable（页面不存在）"> <span class="t-lines"><span>Permutable</span></span></a></div> </td> <td> specifies the common requirements of algorithms that reorder elements in place <br> <span class="t-mark">(concept)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Mergeable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/Mergeable（页面不存在）"> <span class="t-lines"><span>Mergeable</span></span></a></div> </td> <td> specifies the requirements of algorithms that merge sorted sequences into an output sequence by copying elements <br> <span class="t-mark">(concept)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Sortable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/Sortable（页面不存在）"> <span class="t-lines"><span>Sortable</span></span></a></div> </td> <td> specifies the common requirements of algorithms that permute sequences into ordered sequences <br> <span class="t-mark">(concept)</span> </td>
</tr> <tr> <td colspan="2"> <h3 id="Classes"> Classes</h3> </td>
</tr> <tr> <td colspan="2"> <h5 id="Algorithm_utilities">  Algorithm utilities </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/indirect_result_t&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/indirect result t（页面不存在）"> <span class="t-lines"><span>indirect_result_t</span></span></a></div> </td> <td> computes the result of invoking a callable object on the result of dereferencing some set of <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Readable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/Readable（页面不存在）"><code>Readable</code></a> types <br> <span class="t-mark">(alias template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/projected&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/projected（页面不存在）"> <span class="t-lines"><span>projected</span></span></a></div> </td> <td> helper template for specifying the constraints on algorithms that accept projections <br> <span class="t-mark">(class template)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Associated_types">  Associated types </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/incrementable_traits" title="cpp/iterator/incrementable traits"> <span class="t-lines"><span>incrementable_traits</span></span></a></div> </td> <td> computes the difference type of a <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/WeaklyIncrementable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/WeaklyIncrementable（页面不存在）"><code>WeaklyIncrementable</code></a> type <br> <span class="t-mark">(class template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/readable_traits" title="cpp/iterator/readable traits"> <span class="t-lines"><span>readable_traits</span></span></a></div> </td> <td> computes the value type of a <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Readable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/Readable（页面不存在）"><code>Readable</code></a> type <br> <span class="t-mark">(class template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/iter_t" title="cpp/iterator/iter t"> <span class="t-lines"><span>iter_value_t</span><span>iter_reference_t</span><span>iter_difference_t</span><span>iter_rvalue_reference_t</span><span>iter_common_reference_t</span></span></a></div> </td> <td> computes the associate types of an iterator <br> <span class="t-mark">(alias template)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Primitives">  Primitives </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/iterator_traits" title="cpp/iterator/iterator traits"> <span class="t-lines"><span>iterator_traits</span></span></a></div> </td> <td> provides uniform interface to the properties of an iterator <br> <span class="t-mark">(class template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/iterator_tags" title="cpp/iterator/iterator tags"> <span class="t-lines"><span>input_iterator_tag</span><span>output_iterator_tag</span><span>forward_iterator_tag</span><span>bidirectional_iterator_tag</span><span>random_access_iterator_tag</span><span>contiguous_iterator_tag</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> empty class types used to indicate iterator categories <br> <span class="t-mark">(class)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/iterator" title="cpp/iterator/iterator"> <span class="t-lines"><span>iterator</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark">(deprecated in C++17)</span></span></span></div> </td> <td> base class to ease the definition of required types for simple iterators <br> <span class="t-mark">(class template)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Adaptors">  Adaptors </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/reverse_iterator" title="cpp/iterator/reverse iterator"> <span class="t-lines"><span>reverse_iterator</span></span></a></div> </td> <td> iterator adaptor for reverse-order traversal <br> <span class="t-mark">(class template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/move_iterator" title="cpp/iterator/move iterator"> <span class="t-lines"><span>move_iterator</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> iterator adaptor which dereferences to an rvalue reference <br> <span class="t-mark">(class template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/move_sentinel&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/move sentinel（页面不存在）"> <span class="t-lines"><span>move_sentinel</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> sentinel adaptor for use with <code><a href="../iterator/move_iterator" title="cpp/iterator/move iterator">std::move_iterator</a></code> <br> <span class="t-mark">(class template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/common_iterator&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/common iterator（页面不存在）"> <span class="t-lines"><span>common_iterator</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> adapts an iterator type and its sentinel into a common iterator type <br> <span class="t-mark">(class template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/default_sentinel_t&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/default sentinel t（页面不存在）"> <span class="t-lines"><span>default_sentinel_t</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> default sentinel for use with iterators that know the bound of their range <br> <span class="t-mark">(class)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/counted_iterator&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/counted iterator（页面不存在）"> <span class="t-lines"><span>counted_iterator</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> iterator adaptor that tracks the distance to the end of the range <br> <span class="t-mark">(class template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/unreachable_sentinel_t&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/unreachable sentinel t（页面不存在）"> <span class="t-lines"><span>unreachable_sentinel_t</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> sentinel that always compares unequal to any <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/WeaklyIncrementable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/WeaklyIncrementable（页面不存在）"><code>WeaklyIncrementable</code></a> type <br> <span class="t-mark">(class)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/back_insert_iterator" title="cpp/iterator/back insert iterator"> <span class="t-lines"><span>back_insert_iterator</span></span></a></div> </td> <td> iterator adaptor for insertion at the end of a container <br> <span class="t-mark">(class template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/front_insert_iterator" title="cpp/iterator/front insert iterator"> <span class="t-lines"><span>front_insert_iterator</span></span></a></div> </td> <td> iterator adaptor for insertion at the front of a container <br> <span class="t-mark">(class template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/insert_iterator" title="cpp/iterator/insert iterator"> <span class="t-lines"><span>insert_iterator</span></span></a></div> </td> <td> iterator adaptor for insertion into a container <br> <span class="t-mark">(class template)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Stream_Iterators">  Stream Iterators </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/istream_iterator" title="cpp/iterator/istream iterator"> <span class="t-lines"><span>istream_iterator</span></span></a></div> </td> <td> input iterator that reads from <code><a href="../io/basic_istream" title="cpp/io/basic istream">std::basic_istream</a></code> <br> <span class="t-mark">(class template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/ostream_iterator" title="cpp/iterator/ostream iterator"> <span class="t-lines"><span>ostream_iterator</span></span></a></div> </td> <td> output iterator that writes to <code><a href="../io/basic_ostream" title="cpp/io/basic ostream">std::basic_ostream</a></code> <br> <span class="t-mark">(class template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/istreambuf_iterator" title="cpp/iterator/istreambuf iterator"> <span class="t-lines"><span>istreambuf_iterator</span></span></a></div> </td> <td> input iterator that reads from <code><a href="../io/basic_streambuf" title="cpp/io/basic streambuf">std::basic_streambuf</a></code> <br> <span class="t-mark">(class template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/ostreambuf_iterator" title="cpp/iterator/ostreambuf iterator"> <span class="t-lines"><span>ostreambuf_iterator</span></span></a></div> </td> <td> output iterator that writes to <code><a href="../io/basic_streambuf" title="cpp/io/basic streambuf">std::basic_streambuf</a></code> <br> <span class="t-mark">(class template)</span> </td>
</tr> <tr> <td colspan="2"> <h3 id="Customization_point_objects"> Customization point objects</h3> </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in namespace <code>std::ranges</code>  </th>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/ranges/iter_move&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/ranges/iter move（页面不存在）"> <span class="t-lines"><span>iter_move</span></span></a></div> </td> <td> casts the result of dereferencing an object to its associated rvalue reference type <br> <span class="t-mark">(customization point object)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/ranges/iter_swap&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/ranges/iter swap（页面不存在）"> <span class="t-lines"><span>iter_swap</span></span></a></div> </td> <td> swap the values referenced by two dereferenceable objects <br> <span class="t-mark">(customization point object)</span> </td>
</tr> <tr> <td colspan="2"> <h3 id="Functions"> Functions</h3> </td>
</tr> <tr> <td colspan="2"> <h5 id="Adaptors_2">  Adaptors </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/make_reverse_iterator" title="cpp/iterator/make reverse iterator"> <span class="t-lines"><span>make_reverse_iterator</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx14">(C++14)</span></span></span></div> </td> <td> creates a <code><a href="../iterator/reverse_iterator" title="cpp/iterator/reverse iterator">std::reverse_iterator</a></code> of type inferred from the argument <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/make_move_iterator" title="cpp/iterator/make move iterator"> <span class="t-lines"><span>make_move_iterator</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> creates a <code><a href="../iterator/move_iterator" title="cpp/iterator/move iterator">std::move_iterator</a></code> of type inferred from the argument <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/front_inserter" title="cpp/iterator/front inserter"> <span class="t-lines"><span>front_inserter</span></span></a></div> </td> <td> creates a <code><a href="../iterator/front_insert_iterator" title="cpp/iterator/front insert iterator">std::front_insert_iterator</a></code> of type inferred from the argument <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/back_inserter" title="cpp/iterator/back inserter"> <span class="t-lines"><span>back_inserter</span></span></a></div> </td> <td> creates a <code><a href="../iterator/back_insert_iterator" title="cpp/iterator/back insert iterator">std::back_insert_iterator</a></code> of type inferred from the argument <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/inserter" title="cpp/iterator/inserter"> <span class="t-lines"><span>inserter</span></span></a></div> </td> <td> creates a <code><a href="../iterator/insert_iterator" title="cpp/iterator/insert iterator">std::insert_iterator</a></code> of type inferred from the argument <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Non-member_operators">  Non-member operators </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/move_iterator/operator_cmp" title="cpp/iterator/move iterator/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span></span></a></div> </td> <td> compares the underlying iterators <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="http://en.cppreference.com/w/cpp/iterator/move_iterator/operator%20" title="cpp/iterator/move iterator/operator+"> <span class="t-lines"><span>operator+</span></span></a></div> </td> <td> advances the iterator <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/move_iterator/operator-" title="cpp/iterator/move iterator/operator-"> <span class="t-lines"><span>operator-</span></span></a></div> </td> <td> computes the distance between two iterator adaptors <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/reverse_iterator/operator_cmp" title="cpp/iterator/reverse iterator/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span></span></a></div> </td> <td> compares the underlying iterators <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="http://en.cppreference.com/w/cpp/iterator/reverse_iterator/operator%20" title="cpp/iterator/reverse iterator/operator+"> <span class="t-lines"><span>operator+</span></span></a></div> </td> <td> advances the iterator <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/reverse_iterator/operator-" title="cpp/iterator/reverse iterator/operator-"> <span class="t-lines"><span>operator-</span></span></a></div> </td> <td> computes the distance between two iterator adaptors <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/istream_iterator/operator_cmp" title="cpp/iterator/istream iterator/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span></span></a></div> </td> <td> compares two <code>istream_iterator</code>s <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/istreambuf_iterator/operator_cmp" title="cpp/iterator/istreambuf iterator/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span></span></a></div> </td> <td> compares two <code>istreambuf_iterator</code>s <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Operations">  Operations </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/advance" title="cpp/iterator/advance"> <span class="t-lines"><span>advance</span></span></a></div> </td> <td> advances an iterator by given distance <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/distance" title="cpp/iterator/distance"> <span class="t-lines"><span>distance</span></span></a></div> </td> <td> returns the distance between two iterators <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/next" title="cpp/iterator/next"> <span class="t-lines"><span>next</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> increment an iterator <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/prev" title="cpp/iterator/prev"> <span class="t-lines"><span>prev</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> decrement an iterator <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/ranges/advance&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/ranges/advance（页面不存在）"> <span class="t-lines"><span>ranges::advance</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> advances an iterator by given distance or to a given bound <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/ranges/distance&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/ranges/distance（页面不存在）"> <span class="t-lines"><span>ranges::distance</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> returns the distance between an iterator and a sentinel, or between the beginning and end of a range <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/ranges/next&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/ranges/next（页面不存在）"> <span class="t-lines"><span>ranges::next</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> increment an iterator by a given distance or to a bound <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/ranges/prev&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/ranges/prev（页面不存在）"> <span class="t-lines"><span>ranges::prev</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> decrement an iterator by a given distance or to a bound <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Range_access">  Range access </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/begin" title="cpp/iterator/begin"> <span class="t-lines"><span>begin</span><span>cbegin</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx14">(C++14)</span></span></span></div> </td> <td> returns an iterator to the beginning of a container or array <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/end" title="cpp/iterator/end"> <span class="t-lines"><span>end</span><span>cend</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx14">(C++14)</span></span></span></div> </td> <td> returns an iterator to the end of a container or array <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/rbegin" title="cpp/iterator/rbegin"> <span class="t-lines"><span>rbegin</span><span>crbegin</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx14">(C++14)</span></span></span></div> </td> <td> returns a reverse iterator to a container or array <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/rend" title="cpp/iterator/rend"> <span class="t-lines"><span>rend</span><span>crend</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx14">(C++14)</span></span></span></div> </td> <td> returns a reverse end iterator for a container or array <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/size" title="cpp/iterator/size"> <span class="t-lines"><span>size</span><span>ssize</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> returns the size of a container or array <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/empty" title="cpp/iterator/empty"> <span class="t-lines"><span>empty</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> checks whether the container is empty <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/data" title="cpp/iterator/data"> <span class="t-lines"><span>data</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> obtains the pointer to the underlying array <br> <span class="t-mark">(function template)</span> </td>
</tr> </table> <h3 id="Synopsis">Synopsis</h3> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;concepts&gt;
 
namespace std {
  template&lt;class T&gt; using __with_reference = T&amp;;// exposition only
  template&lt;class T&gt; concept __Referenceable     // exposition only
    = requires { typename __with_reference&lt;T&gt;; };
  template&lt;class T&gt; concept __Dereferenceable   // exposition only
    = requires(T&amp; t) {
      { *t } -&gt; __Referenceable; // not required to be equality-preserving
    };
 
  // associated types
  // incrementable traits
  template&lt;class&gt; struct incrementable_traits;
  template&lt;class T&gt;
    using iter_difference_t = /* see definition */;
 
  // readable traits
  template&lt;class&gt; struct readable_traits;
  template&lt;class T&gt;
    using iter_value_t = /* see definition */;
 
  // iterator traits
  template&lt;class I&gt; struct iterator_traits;
  template&lt;class T&gt; struct iterator_traits&lt;T*&gt;;
 
  template&lt;__Dereferenceable T&gt;
    using iter_reference_t = decltype(*declval&lt;T&amp;&gt;());
 
  namespace ranges {
    // customization points
    inline namespace /* unspecified */ {
      // ranges​::​iter_­move
      inline constexpr /* unspecified */ iter_move = /* unspecified */;
 
      // ranges​::​iter_­swap
      inline constexpr /* unspecified */ iter_swap = /* unspecified */;
    }
  }
 
  template&lt;__Dereferenceable T&gt;
    requires requires(T&amp; t) {
      { ranges::iter_move(t) } -&gt; __Referenceable;
    }
  using iter_rvalue_reference_t
    = decltype(ranges::iter_move(declval&lt;T&amp;&gt;()));
 
  // iterator concepts
  // concept Readable
  template&lt;class In&gt;
    concept Readable = /* see definition */;
 
  template&lt;Readable T&gt;
    using iter_common_reference_t =
      common_reference_t&lt;iter_reference_t&lt;T&gt;, iter_value_t&lt;T&gt;&amp;&gt;;
 
  // concept Writable
  template&lt;class Out, class T&gt;
    concept Writable = /* see definition */;
 
  // concept WeaklyIncrementable
  template&lt;class I&gt;
    concept WeaklyIncrementable = /* see definition */;
 
  // concept Incrementable
  template&lt;class I&gt;
    concept Incrementable = /* see definition */;
 
  // concept Iterator
  template&lt;class I&gt;
    concept Iterator = /* see definition */;
 
  // concept Sentinel
  template&lt;class S, class I&gt;
    concept Sentinel = /* see definition */;
 
  // concept SizedSentinel
  template&lt;class S, class I&gt;
    inline constexpr bool disable_sized_sentinel = false;
 
  template&lt;class S, class I&gt;
    concept SizedSentinel = /* see definition */;
 
  // concept InputIterator
  template&lt;class I&gt;
    concept InputIterator = /* see definition */;
 
  // concept OutputIterator
  template&lt;class I, class T&gt;
    concept OutputIterator = /* see definition */;
 
  // concept ForwardIterator
  template&lt;class I&gt;
    concept ForwardIterator = /* see definition */;
 
  // concept BidirectionalIterator
  template&lt;class I&gt;
    concept BidirectionalIterator = /* see definition */;
 
  // concept RandomAccessIterator
  template&lt;class I&gt;
    concept RandomAccessIterator = /* see definition */;
 
  // concept ContiguousIterator
  template&lt;class I&gt;
    concept ContiguousIterator = /* see definition */;
 
  // indirect callable requirements
  // indirect callables
  template&lt;class F, class I&gt;
    concept IndirectUnaryInvocable = /* see definition */;
 
  template&lt;class F, class I&gt;
    concept IndirectRegularUnaryInvocable = /* see definition */;
 
  template&lt;class F, class I&gt;
    concept IndirectUnaryPredicate = /* see definition */;
 
  template&lt;class F, class I1, class I2 = I1&gt;
    concept IndirectRelation = /* see definition */;
 
  template&lt;class F, class I1, class I2 = I1&gt;
    concept IndirectStrictWeakOrder = /* see definition */;
 
  template&lt;class F, class... Is&gt;
    requires (Readable&lt;Is&gt; &amp;&amp; ...) &amp;&amp; Invocable&lt;F, iter_reference_t&lt;Is&gt;...&gt;
      using indirect_result_t = invoke_result_t&lt;F, iter_reference_t&lt;Is&gt;...&gt;;
 
  // projected
  template&lt;Readable I, IndirectRegularUnaryInvocable&lt;I&gt; Proj&gt;
    struct projected;
 
  template&lt;WeaklyIncrementable I, class Proj&gt;
    struct incrementable_traits&lt;projected&lt;I, Proj&gt;&gt;;
 
  // common algorithm requirements
  // concept IndirectlyMovable
  template&lt;class In, class Out&gt;
    concept IndirectlyMovable = /* see definition */;
 
  template&lt;class In, class Out&gt;
    concept IndirectlyMovableStorable = /* see definition */;
 
  // concept IndirectlyCopyable
  template&lt;class In, class Out&gt;
    concept IndirectlyCopyable = /* see definition */;
 
  template&lt;class In, class Out&gt;
    concept IndirectlyCopyableStorable = /* see definition */;
 
  // concept IndirectlySwappable
  template&lt;class I1, class I2 = I1&gt;
    concept IndirectlySwappable = /* see definition */;
 
  // concept IndirectlyComparable
  template&lt;class I1, class I2, class R, class P1 = identity, class P2 = identity&gt;
    concept IndirectlyComparable = /* see definition */;
 
  // concept Permutable
  template&lt;class I&gt;
    concept Permutable = /* see definition */;
 
  // concept Mergeable
  template&lt;class I1, class I2, class Out,
      class R = ranges::less, class P1 = identity, class P2 = identity&gt;
    concept Mergeable = /* see definition */;
 
  // concept Sortable
  template&lt;class I, class R = ranges::less, class P = identity&gt;
    concept Sortable = /* see definition */;
 
  // primitives
  // iterator tags
  struct input_iterator_tag { };
  struct output_iterator_tag { };
  struct forward_iterator_tag: public input_iterator_tag { };
  struct bidirectional_iterator_tag: public forward_iterator_tag { };
  struct random_access_iterator_tag: public bidirectional_iterator_tag { };
  struct contiguous_iterator_tag: public random_access_iterator_tag { };
 
  // iterator operations
  template&lt;class InputIter, class Distance&gt;
    constexpr void
      advance(InputIter&amp; i, Distance n);
  template&lt;class InputIter&gt;
    constexpr typename iterator_traits&lt;InputIter&gt;::difference_type
      distance(InputIter first, InputIter last);
  template&lt;class InputIter&gt;
    constexpr InputIter
      next(InputIter x,
           typename iterator_traits&lt;InputIter&gt;::difference_type n = 1);
  template&lt;class BidirIter&gt;
    constexpr BidirIter
      prev(BidirIter x,
           typename iterator_traits&lt;BidirIter&gt;::difference_type n = 1);
 
  // range iterator operations
  namespace ranges {
    // ranges​::​advance
    template&lt;Iterator I&gt;
      constexpr void advance(I&amp; i, iter_difference_t&lt;I&gt; n);
    template&lt;Iterator I, Sentinel&lt;I&gt; S&gt;
      constexpr void advance(I&amp; i, S bound);
    template&lt;Iterator I, Sentinel&lt;I&gt; S&gt;
      constexpr iter_difference_t&lt;I&gt; advance(I&amp; i, iter_difference_t&lt;I&gt; n, S bound);
 
    // ranges​::​distance
    template&lt;Iterator I, Sentinel&lt;I&gt; S&gt;
      constexpr iter_difference_t&lt;I&gt; distance(I first, S last);
    template&lt;Range R&gt;
      constexpr iter_difference_t&lt;iterator_t&lt;R&gt;&gt; distance(R&amp;&amp; r);
 
    // ranges​::​next
    template&lt;Iterator I&gt;
      constexpr I next(I x);
    template&lt;Iterator I&gt;
      constexpr I next(I x, iter_difference_t&lt;I&gt; n);
    template&lt;Iterator I, Sentinel&lt;I&gt; S&gt;
      constexpr I next(I x, S bound);
    template&lt;Iterator I, Sentinel&lt;I&gt; S&gt;
      constexpr I next(I x, iter_difference_t&lt;I&gt; n, S bound);
 
    // ranges​::​prev
    template&lt;BidirectionalIterator I&gt;
      constexpr I prev(I x);
    template&lt;BidirectionalIterator I&gt;
      constexpr I prev(I x, iter_difference_t&lt;I&gt; n);
    template&lt;BidirectionalIterator I&gt;
      constexpr I prev(I x, iter_difference_t&lt;I&gt; n, I bound);
  }
 
  // predefined iterators and sentinels
  // reverse iterators
  template&lt;class Iter&gt; class reverse_iterator;
 
  template&lt;class Iter1, class Iter2&gt;
    constexpr bool operator==(
      const reverse_iterator&lt;Iter1&gt;&amp; x,
      const reverse_iterator&lt;Iter2&gt;&amp; y);
  template&lt;class Iter1, class Iter2&gt;
    constexpr bool operator!=(
      const reverse_iterator&lt;Iter1&gt;&amp; x,
      const reverse_iterator&lt;Iter2&gt;&amp; y);
  template&lt;class Iter1, class Iter2&gt;
    constexpr bool operator&lt;(
      const reverse_iterator&lt;Iter1&gt;&amp; x,
      const reverse_iterator&lt;Iter2&gt;&amp; y);
  template&lt;class Iter1, class Iter2&gt;
    constexpr bool operator&gt;(
      const reverse_iterator&lt;Iter1&gt;&amp; x,
      const reverse_iterator&lt;Iter2&gt;&amp; y);
  template&lt;class Iter1, class Iter2&gt;
    constexpr bool operator&lt;=(
      const reverse_iterator&lt;Iter1&gt;&amp; x,
      const reverse_iterator&lt;Iter2&gt;&amp; y);
  template&lt;class Iter1, class Iter2&gt;
    constexpr bool operator&gt;=(
      const reverse_iterator&lt;Iter1&gt;&amp; x,
      const reverse_iterator&lt;Iter2&gt;&amp; y);
 
  template&lt;class Iter1, class Iter2&gt;
    constexpr auto operator-(
      const reverse_iterator&lt;Iter1&gt;&amp; x,
      const reverse_iterator&lt;Iter2&gt;&amp; y) -&gt; decltype(y.base() - x.base());
  template&lt;class Iter&gt;
    constexpr reverse_iterator&lt;Iter&gt;
      operator+(
    typename reverse_iterator&lt;Iter&gt;::difference_type n,
    const reverse_iterator&lt;Iter&gt;&amp; x);
 
  template&lt;class Iter&gt;
    constexpr reverse_iterator&lt;Iter&gt; make_reverse_iterator(Iter i);
 
  template&lt;class Iter1, class Iter2&gt;
      requires (!SizedSentinel&lt;Iter1, Iter2&gt;)
    inline constexpr bool disable_sized_sentinel&lt;reverse_iterator&lt;Iter1&gt;,
                                                 reverse_iterator&lt;Iter2&gt;&gt; = true;
 
  // insert iterators
  template&lt;class Container&gt; class back_insert_iterator;
  template&lt;class Container&gt;
    constexpr back_insert_iterator&lt;Container&gt; back_inserter(Container&amp; x);
 
  template&lt;class Container&gt; class front_insert_iterator;
  template&lt;class Container&gt;
    constexpr front_insert_iterator&lt;Container&gt; front_inserter(Container&amp; x);
 
  template&lt;class Container&gt; class insert_iterator;
  template&lt;class Container&gt;
    constexpr insert_iterator&lt;Container&gt;
      inserter(Container&amp; x, ranges::iterator_t&lt;Container&gt; i);
 
  // move iterators and sentinels
  template&lt;class Iter&gt; class move_iterator;
 
  template&lt;class Iter1, class Iter2&gt;
    constexpr bool operator==(
      const move_iterator&lt;Iter1&gt;&amp; x, const move_iterator&lt;Iter2&gt;&amp; y);
  template&lt;class Iter1, class Iter2&gt;
    constexpr bool operator!=(
      const move_iterator&lt;Iter1&gt;&amp; x, const move_iterator&lt;Iter2&gt;&amp; y);
  template&lt;class Iterator1, class Iterator2&gt;
    constexpr bool operator&lt;(
      const move_iterator&lt;Iter1&gt;&amp; x, const move_iterator&lt;Iter2&gt;&amp; y);
  template&lt;class Iter1, class Iter2&gt;
    constexpr bool operator&gt;(
      const move_iterator&lt;Iter1&gt;&amp; x, const move_iterator&lt;Iter2&gt;&amp; y);
  template&lt;class Iter1, class Iter2&gt;
    constexpr bool operator&lt;=(
      const move_iterator&lt;Iter1&gt;&amp; x, const move_iterator&lt;Iter2&gt;&amp; y);
  template&lt;class Iter1, class Iter2&gt;
    constexpr bool operator&gt;=(
      const move_iterator&lt;Iter1&gt;&amp; x, const move_iterator&lt;Iter2&gt;&amp; y);
 
  template&lt;class Iter1, class Iter2&gt;
    constexpr auto operator-(
    const move_iterator&lt;Iter1&gt;&amp; x,
    const move_iterator&lt;Iter2&gt;&amp; y) -&gt; decltype(x.base() - y.base());
  template&lt;class Iter&gt;
    constexpr move_iterator&lt;Iter&gt; operator+(
      typename move_iterator&lt;Iter&gt;::difference_type n, const move_iterator&lt;Iter&gt;&amp; x);
 
  template&lt;class Iter&gt;
    constexpr move_iterator&lt;Iter&gt; make_move_iterator(Iter i);
 
  template&lt;Semiregular S&gt; class move_sentinel;
 
  // common iterators
  template&lt;Iterator I, Sentinel&lt;I&gt; S&gt;
    requires (!Same&lt;I, S&gt;)
      class common_iterator;
 
  template&lt;class I, class S&gt;
    struct incrementable_traits&lt;common_iterator&lt;I, S&gt;&gt;;
 
  template&lt;InputIterator I, class S&gt;
    struct iterator_traits&lt;common_iterator&lt;I, S&gt;&gt;;
 
  // default sentinels
  struct default_sentinel_t;
  inline constexpr default_sentinel_t default_sentinel{};
 
  // counted iterators
  template&lt;Iterator I&gt; class counted_iterator;
 
  template&lt;class I&gt;
    struct incrementable_traits&lt;counted_iterator&lt;I&gt;&gt;;
 
  template&lt;InputIterator I&gt;
    struct iterator_traits&lt;counted_iterator&lt;I&gt;&gt;;
 
  // unreachable sentinels
  struct unreachable_sentinel_t;
  inline constexpr unreachable_sentinel_t unreachable_sentinel{};
 
  // stream iterators
  template&lt;class T, class CharT = char, class Traits = char_traits&lt;CharT&gt;,
           class Distance = ptrdiff_t&gt;
  class istream_iterator;
  template&lt;class T, class CharT, class Traits, class Distance&gt;
    bool operator==(const istream_iterator&lt;T, CharT, Traits, Distance&gt;&amp; x,
            const istream_iterator&lt;T, CharT, Traits, Distance&gt;&amp; y);
  template&lt;class T, class CharT, class Traits, class Distance&gt;
    bool operator!=(const istream_iterator&lt;T, CharT, Traits, Distance&gt;&amp; x,
            const istream_iterator&lt;T, CharT, Traits, Distance&gt;&amp; y);
 
  template&lt;class T, class CharT = char, class Traits = char_traits&lt;CharT&gt;&gt;
      class ostream_iterator;
 
  template&lt;class CharT, class Traits = char_traits&lt;CharT&gt;&gt;
    class istreambuf_iterator;
  template&lt;class CharT, class Traits&gt;
    bool operator==(const istreambuf_iterator&lt;CharT, Traits&gt;&amp; a,
            const istreambuf_iterator&lt;CharT, Traits&gt;&amp; b);
  template&lt;class CharT, class Traits&gt;
    bool operator!=(const istreambuf_iterator&lt;CharT, Traits&gt;&amp; a,
            const istreambuf_iterator&lt;CharT, Traits&gt;&amp; b);
 
  template&lt;class CharT, class Traits = char_traits&lt;CharT&gt;&gt;
    class ostreambuf_iterator;
 
  // range access
  template&lt;class C&gt; constexpr auto begin(C&amp; c) -&gt; decltype(c.begin());
  template&lt;class C&gt; constexpr auto begin(const C&amp; c) -&gt; decltype(c.begin());
  template&lt;class C&gt; constexpr auto end(C&amp; c) -&gt; decltype(c.end());
  template&lt;class C&gt; constexpr auto end(const C&amp; c) -&gt; decltype(c.end());
  template&lt;class T, size_t N&gt; constexpr T* begin(T (&amp;a)[N]) noexcept;
  template&lt;class T, size_t N&gt; constexpr T* end(T (&amp;a)[N]) noexcept;
  template&lt;class C&gt; constexpr auto cbegin(const C&amp; c) noexcept(noexcept(std::begin(c)))
    -&gt; decltype(std::begin(c));
  template&lt;class C&gt; constexpr auto cend(const C&amp; c) noexcept(noexcept(std::end(c)))
    -&gt; decltype(std::end(c));
  template&lt;class C&gt; constexpr auto rbegin(C&amp; c) -&gt; decltype(c.rbegin());
  template&lt;class C&gt; constexpr auto rbegin(const C&amp; c) -&gt; decltype(c.rbegin());
  template&lt;class C&gt; constexpr auto rend(C&amp; c) -&gt; decltype(c.rend());
  template&lt;class C&gt; constexpr auto rend(const C&amp; c) -&gt; decltype(c.rend());
  template&lt;class T, size_t N&gt; constexpr reverse_iterator&lt;T*&gt; rbegin(T (&amp;a)[N]);
  template&lt;class T, size_t N&gt; constexpr reverse_iterator&lt;T*&gt; rend(T (&amp;a)[N]);
  template&lt;class E&gt; constexpr reverse_iterator&lt;const E*&gt; rbegin(initializer_list&lt;E&gt; il);
  template&lt;class E&gt; constexpr reverse_iterator&lt;const E*&gt; rend(initializer_list&lt;E&gt; il);
  template&lt;class C&gt; constexpr auto crbegin(const C&amp; c) -&gt; decltype(std::rbegin(c));
  template&lt;class C&gt; constexpr auto crend(const C&amp; c) -&gt; decltype(std::rend(c));
 
  template&lt;class C&gt; constexpr auto size(const C&amp; c) -&gt; decltype(c.size());
  template&lt;class T, size_t N&gt; constexpr size_t size(const T (&amp;a)[N]) noexcept;
  template&lt;class C&gt; constexpr auto ssize(const C&amp; c)
    -&gt; common_type_t&lt;ptrdiff_t, make_signed_t&lt;decltype(c.size())&gt;&gt;;
  template&lt;class T, ptrdiff_t N&gt; constexpr ptrdiff_t ssize(const T (&amp;a)[N]) noexcept;
  template&lt;class C&gt; [[nodiscard]] constexpr auto empty(const C&amp; c) -&gt; decltype(c.empty());
  template&lt;class T, size_t N&gt; [[nodiscard]] constexpr bool empty(const T (&amp;a)[N]) noexcept;
  template&lt;class E&gt; [[nodiscard]] constexpr bool empty(initializer_list&lt;E&gt; il) noexcept;
  template&lt;class C&gt; constexpr auto data(C&amp; c) -&gt; decltype(c.data());
  template&lt;class C&gt; constexpr auto data(const C&amp; c) -&gt; decltype(c.data());
  template&lt;class T, size_t N&gt; constexpr T* data(T (&amp;a)[N]) noexcept;
  template&lt;class E&gt; constexpr const E* data(initializer_list&lt;E&gt; il) noexcept;
}</pre></div> <h4 id="Concept_Readable">Concept <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Readable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/Readable（页面不存在）"><code>Readable</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class In&gt;
    concept Readable =
        requires {
            typename iter_value_t&lt;In&gt;;
            typename iter_reference_t&lt;In&gt;;
            typename iter_rvalue_reference_t&lt;In&gt;;
        } &amp;&amp;
        CommonReference&lt;iter_reference_t&lt;In&gt;&amp;&amp;, iter_value_t&lt;In&gt;&amp;&gt; &amp;&amp;
        CommonReference&lt;iter_reference_t&lt;In&gt;&amp;&amp;, iter_rvalue_reference_t&lt;In&gt;&amp;&amp;&gt; &amp;&amp;
        CommonReference&lt;iter_rvalue_reference_t&lt;In&gt;&amp;&amp;, const iter_value_t&lt;In&gt;&amp;&gt;;</pre></div> <h4 id="Concept_Writable">Concept <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Writable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/Writable（页面不存在）"><code>Writable</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class Out, class T&gt;
    concept Writable =
        requires(Out&amp;&amp; o, T&amp;&amp; t) {
            *o = std::forward&lt;T&gt;(t); // not required to be equality-preserving
            *std::forward&lt;Out&gt;(o) =
                std::forward&lt;T&gt;(t); // not required to be equality-preserving
            const_cast&lt;const iter_reference_t&lt;Out&gt;&amp;&amp;&gt;(*o) =
                std::forward&lt;T&gt;(t); // not required to be equality-preserving
            const_cast&lt;const iter_reference_t&lt;Out&gt;&amp;&amp;&gt;(*std::forward&lt;Out&gt;(o)) =
                std::forward&lt;T&gt;(t); // not required to be equality-preserving
    };</pre></div> <h4 id="Concept_WeaklyIncrementable">Concept <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/WeaklyIncrementable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/WeaklyIncrementable（页面不存在）"><code>WeaklyIncrementable</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class I&gt;
    concept WeaklyIncrementable =
        Semiregular&lt;I&gt; &amp;&amp;
        requires(I i) {
            typename iter_difference_t&lt;I&gt;;
            requires SignedIntegral&lt;iter_difference_t&lt;I&gt;&gt;;
            { ++i } -&gt; Same&lt;I&amp;&gt;; // not required to be equality-preserving
            i++; // not required to be equality-preserving
        };</pre></div> <h4 id="Concept_Incrementable">Concept <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Incrementable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/Incrementable（页面不存在）"><code>Incrementable</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class I&gt;
    concept Incrementable =
        Regular&lt;I&gt; &amp;&amp;
        WeaklyIncrementable&lt;I&gt; &amp;&amp;
        requires(I i) {
            { i++ } -&gt; Same&lt;I&gt;;
        };</pre></div> <h4 id="Concept_Iterator">Concept <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Iterator&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/Iterator（页面不存在）"><code>Iterator</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class I&gt;
    concept Iterator =
        requires(I i) {
            { *i } -&gt; __Referenceable;
        } &amp;&amp;
        WeaklyIncrementable&lt;I&gt;;</pre></div> <h4 id="Concept_Sentinel">Concept <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Sentinel&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/Sentinel（页面不存在）"><code>Sentinel</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class S, class I&gt;
    concept Sentinel =
        Semiregular&lt;S&gt; &amp;&amp;
        Iterator&lt;I&gt; &amp;&amp;
        __WeaklyEqualityComparableWith&lt;S, I&gt;; // See [concept.equalitycomparable]</pre></div> <h4 id="Concept_SizedSentinel">Concept <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/SizedSentinel&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/SizedSentinel（页面不存在）"><code>SizedSentinel</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class S, class I&gt;
    concept SizedSentinel =
        Sentinel&lt;S, I&gt; &amp;&amp;
        !disable_sized_sentinel&lt;remove_cv_t&lt;S&gt;, remove_cv_t&lt;I&gt;&gt; &amp;&amp;
        requires(const I&amp; i, const S&amp; s) {
            { s - i } -&gt; Same&lt;iter_difference_t&lt;I&gt;&gt;;
            { i - s } -&gt; Same&lt;iter_difference_t&lt;I&gt;&gt;;
        };</pre></div> <h4 id="Concept_InputIterator">Concept <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/InputIterator&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/InputIterator（页面不存在）"><code>InputIterator</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class I&gt;
    concept InputIterator =
        Iterator&lt;I&gt; &amp;&amp;
        Readable&lt;I&gt; &amp;&amp;
        requires { typename ITER_CONCEPT(I); } &amp;&amp;
        DerivedFrom&lt;ITER_CONCEPT(I), input_iterator_tag&gt;;</pre></div> <h4 id="Concept_OutputIterator">Concept <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/OutputIterator&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/OutputIterator（页面不存在）"><code>OutputIterator</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class I, class T&gt;
    concept OutputIterator =
        Iterator&lt;I&gt; &amp;&amp;
        Writable&lt;I, T&gt; &amp;&amp;
        requires(I i, T&amp;&amp; t) {
            *i++ = std::forward&lt;T&gt;(t); // not required to be equality-preserving
        };</pre></div> <h4 id="Concept_ForwardIterator">Concept <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/ForwardIterator&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/ForwardIterator（页面不存在）"><code>ForwardIterator</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class I&gt;
    concept ForwardIterator =
        InputIterator&lt;I&gt; &amp;&amp;
        DerivedFrom&lt;ITER_CONCEPT(I), forward_iterator_tag&gt; &amp;&amp;
        Incrementable&lt;I&gt; &amp;&amp;
        Sentinel&lt;I, I&gt;;</pre></div> <h4 id="Concept_BidirectionalIterator">Concept <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/BidirectionalIterator&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/BidirectionalIterator（页面不存在）"><code>BidirectionalIterator</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class I&gt;
    concept BidirectionalIterator =
        ForwardIterator&lt;I&gt; &amp;&amp;
        DerivedFrom&lt;ITER_CONCEPT(I), bidirectional_iterator_tag&gt; &amp;&amp;
        requires(I i) {
            { --i } -&gt; Same&lt;I&amp;&gt;;
            { i-- } -&gt; Same&lt;I&gt;;
        };</pre></div> <h4 id="Concept_RandomAccessIterator">Concept <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/RandomAccessIterator&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/RandomAccessIterator（页面不存在）"><code>RandomAccessIterator</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class I&gt;
    concept RandomAccessIterator =
        BidirectionalIterator&lt;I&gt; &amp;&amp;
        DerivedFrom&lt;ITER_CONCEPT(I), random_access_iterator_tag&gt; &amp;&amp;
        StrictTotallyOrdered&lt;I&gt; &amp;&amp;
        SizedSentinel&lt;I, I&gt; &amp;&amp;
        requires(I i, const I j, const iter_difference_t&lt;I&gt; n) {
            { i += n } -&gt; Same&lt;I&amp;&gt;;
            { j +  n } -&gt; Same&lt;I&gt;;
            { n +  j } -&gt; Same&lt;I&gt;;
            { i -= n } -&gt; Same&lt;I&amp;&gt;;
            { j -  n } -&gt; Same&lt;I&gt;;
            {  j[n]  } -&gt; Same&lt;iter_reference_t&lt;I&gt;&gt;;
        };</pre></div> <h4 id="Concept_ContiguousIterator">Concept <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/ContiguousIterator&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/ContiguousIterator（页面不存在）"><code>ContiguousIterator</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class I&gt;
    concept ContiguousIterator =
        RandomAccessIterator&lt;I&gt; &amp;&amp;
        DerivedFrom&lt;ITER_CONCEPT(I), contiguous_iterator_tag&gt; &amp;&amp;
        is_lvalue_reference_v&lt;iter_reference_t&lt;I&gt;&gt; &amp;&amp;
        Same&lt;iter_value_t&lt;I&gt;, remove_cvref_t&lt;iter_reference_t&lt;I&gt;&gt;&gt;;</pre></div> <h4 id="Concept_IndirectUnaryInvocable">Concept <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/IndirectUnaryInvocable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/IndirectUnaryInvocable（页面不存在）"><code>IndirectUnaryInvocable</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class F, class I&gt;
    concept IndirectUnaryInvocable =
        Readable&lt;I&gt; &amp;&amp;
        CopyConstructible&lt;F&gt; &amp;&amp;
        Invocable&lt;F&amp;, iter_value_t&lt;I&gt;&amp;&gt; &amp;&amp;
        Invocable&lt;F&amp;, iter_reference_t&lt;I&gt;&gt; &amp;&amp;
        Invocable&lt;F&amp;, iter_common_reference_t&lt;I&gt;&gt; &amp;&amp;
        CommonReference&lt;
            invoke_result_t&lt;F&amp;, iter_value_t&lt;I&gt;&amp;&gt;,
            invoke_result_t&lt;F&amp;, iter_reference_t&lt;I&gt;&gt;&gt;;</pre></div> <h4 id="Concept_IndirectRegularUnaryInvocable">Concept <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/IndirectUnaryInvocable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/IndirectUnaryInvocable（页面不存在）"><code>IndirectRegularUnaryInvocable</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class F, class I&gt;
    concept IndirectRegularUnaryInvocable =
        Readable&lt;I&gt; &amp;&amp;
        CopyConstructible&lt;F&gt; &amp;&amp;
        RegularInvocable&lt;F&amp;, iter_value_t&lt;I&gt;&amp;&gt; &amp;&amp;
        RegularInvocable&lt;F&amp;, iter_reference_t&lt;I&gt;&gt; &amp;&amp;
        RegularInvocable&lt;F&amp;, iter_common_reference_t&lt;I&gt;&gt; &amp;&amp;
        CommonReference&lt;
            invoke_result_t&lt;F&amp;, iter_value_t&lt;I&gt;&amp;&gt;,
            invoke_result_t&lt;F&amp;, iter_reference_t&lt;I&gt;&gt;&gt;;</pre></div> <h4 id="Concept_IndirectUnaryPredicate">Concept <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/IndirectUnaryPredicate&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/IndirectUnaryPredicate（页面不存在）"><code>IndirectUnaryPredicate</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class F, class I&gt;
    concept IndirectUnaryPredicate =
        Readable&lt;I&gt; &amp;&amp;
        CopyConstructible&lt;F&gt; &amp;&amp;
        Predicate&lt;F&amp;, iter_value_t&lt;I&gt;&amp;&gt; &amp;&amp;
        Predicate&lt;F&amp;, iter_reference_t&lt;I&gt;&gt; &amp;&amp;
        Predicate&lt;F&amp;, iter_common_reference_t&lt;I&gt;&gt;;</pre></div> <h4 id="Concept_IndirectRelation">Concept <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/IndirectRelation&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/IndirectRelation（页面不存在）"><code>IndirectRelation</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class F, class I1, class I2 = I1&gt;
    concept IndirectRelation =
        Readable&lt;I1&gt; &amp;&amp; Readable&lt;I2&gt; &amp;&amp;
        CopyConstructible&lt;F&gt; &amp;&amp;
        Relation&lt;F&amp;, iter_value_t&lt;I1&gt;&amp;, iter_value_t&lt;I2&gt;&amp;&gt; &amp;&amp;
        Relation&lt;F&amp;, iter_value_t&lt;I1&gt;&amp;, iter_reference_t&lt;I2&gt;&gt; &amp;&amp;
        Relation&lt;F&amp;, iter_reference_t&lt;I1&gt;, iter_value_t&lt;I2&gt;&amp;&gt; &amp;&amp;
        Relation&lt;F&amp;, iter_reference_t&lt;I1&gt;, iter_reference_t&lt;I2&gt;&gt; &amp;&amp;
        Relation&lt;F&amp;, iter_common_reference_t&lt;I1&gt;, iter_common_reference_t&lt;I2&gt;&gt;;</pre></div> <h4 id="Concept_IndirectStrictWeakOrder">Concept <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/IndirectStrictWeakOrder&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/IndirectStrictWeakOrder（页面不存在）"><code>IndirectStrictWeakOrder</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class F, class I1, class I2 = I1&gt;
    concept IndirectStrictWeakOrder =
        Readable&lt;I1&gt; &amp;&amp; Readable&lt;I2&gt; &amp;&amp;
        CopyConstructible&lt;F&gt; &amp;&amp;
        StrictWeakOrder&lt;F&amp;, iter_value_t&lt;I1&gt;&amp;, iter_value_t&lt;I2&gt;&amp;&gt; &amp;&amp;
        StrictWeakOrder&lt;F&amp;, iter_value_t&lt;I1&gt;&amp;, iter_reference_t&lt;I2&gt;&gt; &amp;&amp;
        StrictWeakOrder&lt;F&amp;, iter_reference_t&lt;I1&gt;, iter_value_t&lt;I2&gt;&amp;&gt; &amp;&amp;
        StrictWeakOrder&lt;F&amp;, iter_reference_t&lt;I1&gt;, iter_reference_t&lt;I2&gt;&gt; &amp;&amp;
        StrictWeakOrder&lt;F&amp;, iter_common_reference_t&lt;I1&gt;, iter_common_reference_t&lt;I2&gt;&gt;;</pre></div> <h4 id="Concept_IndirectlyMovable">Concept <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/IndirectlyMovable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/IndirectlyMovable（页面不存在）"><code>IndirectlyMovable</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class In, class Out&gt;
    concept IndirectlyMovable =
        Readable&lt;In&gt; &amp;&amp;
        Writable&lt;Out, iter_rvalue_reference_t&lt;In&gt;&gt;;</pre></div> <h4 id="Concept_IndirectlyMovableStorable">Concept <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/IndirectlyMovableStorable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/IndirectlyMovableStorable（页面不存在）"><code>IndirectlyMovableStorable</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class In, class Out&gt;
    concept IndirectlyMovableStorable =
        IndirectlyMovable&lt;In, Out&gt; &amp;&amp;
        Writable&lt;Out, iter_value_t&lt;In&gt;&gt; &amp;&amp;
        Movable&lt;iter_value_t&lt;In&gt;&gt; &amp;&amp;
        Constructible&lt;iter_value_t&lt;In&gt;, iter_rvalue_reference_t&lt;In&gt;&gt; &amp;&amp;
        Assignable&lt;iter_value_t&lt;In&gt;&amp;, iter_rvalue_reference_t&lt;In&gt;&gt;;</pre></div> <h4 id="Concept_IndirectlyCopyable">Concept <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/IndirectlyCopyable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/IndirectlyCopyable（页面不存在）"><code>IndirectlyCopyable</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class In, class Out&gt;
    concept IndirectlyCopyable =
        Readable&lt;In&gt; &amp;&amp;
        Writable&lt;Out, iter_reference_t&lt;In&gt;&gt;;</pre></div> <h4 id="Concept_IndirectlyCopyableStorable">Concept <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/IndirectlyCopyableStorable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/IndirectlyCopyableStorable（页面不存在）"><code>IndirectlyCopyableStorable</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class In, class Out&gt;
    concept IndirectlyCopyableStorable =
        IndirectlyCopyable&lt;In, Out&gt; &amp;&amp;
        Writable&lt;Out, const iter_value_t&lt;In&gt;&amp;&gt; &amp;&amp;
        Copyable&lt;iter_value_t&lt;In&gt;&gt; &amp;&amp;
        Constructible&lt;iter_value_t&lt;In&gt;, iter_reference_t&lt;In&gt;&gt; &amp;&amp;
        Assignable&lt;iter_value_t&lt;In&gt;&amp;, iter_reference_t&lt;In&gt;&gt;;</pre></div> <h4 id="Concept_IndirectlySwappable">Concept <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/IndirectlySwappable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/IndirectlySwappable（页面不存在）"><code>IndirectlySwappable</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class I1, class I2 = I1&gt;
    concept IndirectlySwappable =
        Readable&lt;I1&gt; &amp;&amp; Readable&lt;I2&gt; &amp;&amp;
        requires(I1&amp; i1, I2&amp; i2) {
            ranges::iter_swap(i1, i1);
            ranges::iter_swap(i2, i2);
            ranges::iter_swap(i1, i2);
            ranges::iter_swap(i2, i1);
        };</pre></div> <h4 id="Concept_IndirectlyComparable">Concept <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/IndirectlyComparable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/IndirectlyComparable（页面不存在）"><code>IndirectlyComparable</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class I1, class I2, class R, class P1 = identity,
         class P2 = identity&gt;
    concept IndirectlyComparable =
        IndirectRelation&lt;R, projected&lt;I1, P1&gt;, projected&lt;I2, P2&gt;&gt;;</pre></div> <h4 id="Concept_Permutable">Concept <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Permutable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/Permutable（页面不存在）"><code>Permutable</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class I&gt;
    concept Permutable =
        ForwardIterator&lt;I&gt; &amp;&amp;
        IndirectlyMovableStorable&lt;I, I&gt; &amp;&amp;
        IndirectlySwappable&lt;I, I&gt;;</pre></div> <h4 id="Concept_Mergeable">Concept <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Mergeable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/Mergeable（页面不存在）"><code>Mergeable</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class I1, class I2, class Out, class R = ranges::less,
         class P1 = identity, class P2 = identity&gt;
    concept Mergeable =
        InputIterator&lt;I1&gt; &amp;&amp;
        InputIterator&lt;I2&gt; &amp;&amp;
        WeaklyIncrementable&lt;Out&gt; &amp;&amp;
        IndirectlyCopyable&lt;I1, Out&gt; &amp;&amp;
        IndirectlyCopyable&lt;I2, Out&gt; &amp;&amp;
        IndirectStrictWeakOrder&lt;R, projected&lt;I1, P1&gt;, projected&lt;I2, P2&gt;&gt;;</pre></div> <h4 id="Concept_Sortable">Concept <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Sortable&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/Sortable（页面不存在）"><code>Sortable</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class I, class R = ranges::less, class P = identity&gt;
    concept Sortable =
        Permutable&lt;I&gt; &amp;&amp;
        IndirectStrictWeakOrder&lt;R, projected&lt;I, P&gt;&gt;;</pre></div> <h4 id="Class_template_std::incrementable_traits">Class template <code>std::incrementable_traits</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class&gt; struct incrementable_traits { };
 
template&lt;class T&gt;
    requires is_object_v&lt;T&gt;
struct incrementable_traits&lt;T*&gt; {
    using difference_type = ptrdiff_t;
};
 
template&lt;class I&gt;
struct incrementable_traits&lt;const I&gt;
    : incrementable_traits&lt;I&gt; { };
 
template&lt;class T&gt; requires requires { typename T::difference_type; }
struct incrementable_traits&lt;T&gt; {
    using difference_type = typename T::difference_type;
};
 
template&lt;class T&gt;
    requires (!requires { typename T::difference_type; } &amp;&amp;
               requires(const T&amp; a, const T&amp; b) { { a - b } -&gt; Integral; })
struct incrementable_traits&lt;T&gt; {
    using difference_type = make_signed_t&lt;decltype(declval&lt;T&gt;() - declval&lt;T&gt;())&gt;;
};</pre></div> <h4 id="Class_template_std::readable_traits">Class template <code>std::readable_traits</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class&gt; struct __cond_value_type { };   // exposition only
template&lt;class T&gt;
    requires is_object_v&lt;T&gt;
struct __cond_value_type {
    using value_type = remove_cv_t&lt;T&gt;;
};
 
template&lt;class&gt; struct readable_traits { };
 
template&lt;class T&gt;
struct readable_traits&lt;T*&gt;
    : __cond_value_type&lt;T&gt; { };
 
template&lt;class I&gt;
    requires is_array_v&lt;I&gt;
struct readable_traits&lt;I&gt; {
    using value_type = remove_cv_t&lt;remove_extent_t&lt;I&gt;&gt;;
};
 
template&lt;class I&gt;
struct readable_traits&lt;const I&gt;
    : readable_traits&lt;I&gt; { };
 
template&lt;class T&gt;
    requires requires { typename T::value_type; }
struct readable_traits&lt;T&gt;
    : __cond_value_type&lt;typename T::value_type&gt; { };
 
template&lt;class T&gt;
    requires requires { typename T::element_type; }
struct readable_traits&lt;T&gt;
    : __cond_value_type&lt;typename T::element_type&gt; { };</pre></div> <h4 id="Class_template_std::projected">Class template <code>std::projected</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;Readable I, IndirectRegularUnaryInvocable&lt;I&gt; Proj&gt;
struct projected {
    using value_type = remove_cvref_t&lt;indirect_result_t&lt;Proj&amp;, I&gt;&gt;;
    indirect_result_t&lt;Proj&amp;, I&gt; operator*() const; // not defined
};
 
template&lt;WeaklyIncrementable I, class Proj&gt;
struct incrementable_traits&lt;projected&lt;I, Proj&gt;&gt; {
    using difference_type = iter_difference_t&lt;I&gt;;
};</pre></div> <h4 id="Class_template_std::iterator_traits">Class template <code><a href="../iterator/iterator_traits" title="cpp/iterator/iterator traits">std::iterator_traits</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class It&gt; struct iterator_traits {
    using difference_type   = /* see definition */;
    using value_typet       = /* see definition */;
    using pointer           = /* see definition */;
    using reference         = /* see definition */;
    using iterator_category = /* see definition */;
};
 
template&lt;class T&gt;
    requires is_object_v&lt;T&gt;
struct iterator_traits&lt;T*&gt; {
    using difference_type   = ptrdiff_t;
    using value_type        = remove_cv_t&lt;T&gt;;
    using pointer           = T*;
    using reference         = T&amp;;
    using iterator_concept  = contiguous_iterator_tag;
    using iterator_category = random_access_iterator_tag;
};</pre></div> <h4 id="Iterator_tags">Iterator tags</h4> <div class="cpp source-cpp"><pre data-language="cpp">struct input_iterator_tag { };
struct output_iterator_tag { };
struct forward_iterator_tag: public input_iterator_tag { };
struct bidirectional_iterator_tag: public forward_iterator_tag { };
struct random_access_iterator_tag: public bidirectional_iterator_tag { };
struct contiguous_iterator_tag: public random_access_iterator_tag { };</pre></div> <h4 id="Class_template_std::reverse_iterator">Class template <code><a href="../iterator/reverse_iterator" title="cpp/iterator/reverse iterator">std::reverse_iterator</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template &lt;class It&gt;
class reverse_iterator {
public:
    using iterator_type     = It;
    using iterator_concept  = /* see definition */;
    using iterator_category = /* see definition */;
    using value_type        = iter_value_t&lt;It&gt;;
    using difference_type   = iter_difference_t&lt;It&gt;;
    using pointer           = typename iterator_traits&lt;It&gt;::pointer;
    using reference         = iter_reference_t&lt;It&gt;::reference;
 
    constexpr reverse_iterator();
    constexpr explicit reverse_iterator(It x);
    template &lt;class U&gt; constexpr reverse_iterator(const reverse_iterator&lt;U&gt;&amp; u);
    template &lt;class U&gt; constexpr reverse_iterator&amp; operator=(const reverse_iterator&lt;U&gt;&amp; u);
 
    constexpr iterator_type base() const;
    constexpr reference operator*() const;
    constexpr pointer   operator-&gt;() const;
 
    constexpr reverse_iterator&amp; operator++();
    constexpr reverse_iterator  operator++(int);
    constexpr reverse_iterator&amp; operator--();
    constexpr reverse_iterator  operator--(int);
 
    constexpr reverse_iterator  operator+ (difference_type n) const;
    constexpr reverse_iterator&amp; operator+=(difference_type n);
    constexpr reverse_iterator  operator- (difference_type n) const;
    constexpr reverse_iterator&amp; operator-=(difference_type n);
 
    constexpr /*unspecified*/ operator[](difference_type n) const;
 
    friend constexpr iter_rvalue_reference_t&lt;It&gt;
        iter_move(const reverse_iterator&amp; i) noexcept(/* see definition */);
    template&lt;IndirectlySwappable&lt;It&gt; It2&gt;
        friend constexpr void
            iter_swap(const reverse_iterator&amp; x,
                      const reverse_iterator&lt;It2&gt;&amp; y) noexcept(/* see definition */);
 
protected:
    It current;
};</pre></div> <h4 id="Class_template_std::back_insert_iterator">Class template <code><a href="../iterator/back_insert_iterator" title="cpp/iterator/back insert iterator">std::back_insert_iterator</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class Container&gt;
class back_insert_iterator {
protected:
    Container* container = nullptr;
 
public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;
    using difference_type   = void;
    using pointer           = void;
    using reference         = void;
    using container_type    = Container;
 
    constexpr back_insert_iterator() noexcept = default;
    explicit constexpr back_insert_iterator(Container&amp; x);
    constexpr back_insert_iterator&amp; operator=(const typename Container::value_type&amp; value);
    constexpr back_insert_iterator&amp; operator=(typename Container::value_type&amp;&amp; value);
 
    constexpr back_insert_iterator&amp; operator*();
    constexpr back_insert_iterator&amp; operator++();
    constexpr back_insert_iterator operator++(int);
};</pre></div> <h4 id="Class_template_std::front_insert_iterator">Class template <code><a href="../iterator/front_insert_iterator" title="cpp/iterator/front insert iterator">std::front_insert_iterator</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class Container&gt;
class front_insert_iterator {
protected:
    Container* container = nullptr;
 
public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;
    using difference_type   = void;
    using pointer           = void;
    using reference         = void;
    using container_type    = Container;
 
    constexpr front_insert_iterator(Container&amp; x) noexcept = default;
    explicit constexpr front_insert_iterator(Container&amp; x);
    constexpr front_insert_iterator&amp; operator=(const typename Container::value_type&amp; val);
    constexpr front_insert_iterator&amp; operator=(typename Container::value_type&amp;&amp; val);
 
    constexpr front_insert_iterator&amp; operator*();
    constexpr front_insert_iterator&amp; operator++();
    constexpr front_insert_iterator operator++(int);
};</pre></div> <h4 id="Class_template_std::insert_iterator">Class template <code><a href="../iterator/insert_iterator" title="cpp/iterator/insert iterator">std::insert_iterator</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class Container&gt;
class insert_iterator {
protected:
    Container* container = nullptr;
    ranges::iterator_t&lt;Container&gt; iter = ranges::iterator_t&lt;Container&gt;();
 
public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;
    using difference_type   = void;
    using pointer           = void;
    using reference         = void;
    using container_type    = Container;
 
    insert_iterator() = default;
    constexpr insert_iterator(Container&amp; x, ranges::iterator_t&lt;Container&gt; i);
    constexpr insert_iterator&amp; operator=(const typename Container::value_type&amp; value);
    constexpr insert_iterator&amp; operator=(typename Container::value_type&amp;&amp; value);
 
    constexpr insert_iterator&amp; operator*();
    constexpr insert_iterator&amp; operator++();
    constexpr insert_iterator&amp; operator++(int);
};</pre></div> <h4 id="Class_template_std::move_iterator">Class template <code><a href="../iterator/move_iterator" title="cpp/iterator/move iterator">std::move_iterator</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class It&gt;
class move_iterator {
public:
    using iterator_type     = It;
    using iterator_concept  = input_iterator_tag;
    using iterator_category = /* see definition */;
    using value_type        = iter_value_t&lt;It&gt;;
    using difference_type   = iter_difference_t&lt;It&gt;;
    using pointer           = It;
    using reference         = iter_rvalue_reference_t&lt;It&gt;;
 
    constexpr move_iterator();
    constexpr explicit move_iterator(It i);
    template&lt;class U&gt; constexpr move_iterator(const move_iterator&lt;U&gt;&amp; u);
    template&lt;class U&gt; constexpr move_iterator&amp; operator=(const move_iterator&lt;U&gt;&amp; u);
 
    constexpr iterator_type base() const;
    constexpr reference operator*() const;
    constexpr pointer operator-&gt;() const;
 
    constexpr move_iterator&amp; operator++();
    constexpr move_iterator operator++(int);
    constexpr move_iterator&amp; operator--();
    constexpr move_iterator operator--(int);
 
    constexpr move_iterator operator+(difference_type n) const;
    constexpr move_iterator&amp; operator+=(difference_type n);
    constexpr move_iterator operator-(difference_type n) const;
    constexpr move_iterator&amp; operator-=(difference_type n);
    constexpr reference operator[](difference_type n) const;
 
    template&lt;Sentinel&lt;It&gt; S&gt;
        friend constexpr bool
            operator==(const move_iterator&amp; x, const move_sentinel&lt;S&gt;&amp; y);
    template&lt;Sentinel&lt;It&gt; S&gt;
        friend constexpr bool
            operator==(const move_sentinel&lt;S&gt;&amp; x, const move_iterator&amp; y);
    template&lt;Sentinel&lt;It&gt; S&gt;
        friend constexpr bool
            operator!=(const move_iterator&amp; x, const move_sentinel&lt;S&gt;&amp; y);
    template&lt;Sentinel&lt;It&gt; S&gt;
        friend constexpr bool
            operator!=(const move_sentinel&lt;S&gt;&amp; x, const move_iterator&amp; y);
    template&lt;SizedSentinel&lt;It&gt; S&gt;
        friend constexpr iter_difference_t&lt;It&gt;
            operator-(const move_sentinel&lt;S&gt;&amp; x, const move_iterator&amp; y);
    template&lt;SizedSentinel&lt;It&gt; S&gt;
        friend constexpr iter_difference_t&lt;It&gt;
            operator-(const move_iterator&amp; x, const move_sentinel&lt;S&gt;&amp; y);
    friend constexpr iter_rvalue_reference_t&lt;It&gt;
        iter_move(const move_iterator&amp; i)
            noexcept(noexcept(ranges::iter_move(i.current)));
    template&lt;IndirectlySwappable&lt;It&gt; It2&gt;
        friend constexpr void
            iter_swap(const move_iterator&amp; x, const move_iterator&lt;It2&gt;&amp; y)
                noexcept(noexcept(ranges::iter_swap(x.current, y.current)));
 
private:
    It current; // exposition only
};</pre></div> <h4 id="Class_template_std::move_sentinel">Class template <code>std::move_sentinel</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;Semiregular S&gt;
class move_sentinel {
public:
    constexpr move_sentinel();
    constexpr explicit move_sentinel(S s);
    template&lt;class S2&gt;
        requires ConvertibleTo&lt;const S2&amp;, S&gt;
            constexpr move_sentinel(const move_sentinel&lt;S2&gt;&amp; s);
    template&lt;class S2&gt;
        requires Assignable&lt;S&amp;, const S2&amp;&gt;
            constexpr move_sentinel&amp; operator=(const move_sentinel&lt;S2&gt;&amp; s);
 
    constexpr S base() const;
private:
    S last;     // exposition only
};</pre></div> <h4 id="Class_template_std::common_iterator">Class template <code>std::common_iterator</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;Iterator I, Sentinel&lt;I&gt; S&gt;
    requires (!Same&lt;I, S&gt;)
class common_iterator {
public:
    constexpr common_iterator() = default;
    constexpr common_iterator(I i);
    constexpr common_iterator(S s);
    template&lt;class I2, class S2&gt;
        requires ConvertibleTo&lt;const I2&amp;, I&gt; &amp;&amp; ConvertibleTo&lt;const S2&amp;, S&gt;
            constexpr common_iterator(const common_iterator&lt;I2, S2&gt;&amp; x);
 
    template&lt;class I2, class S2&gt;
        requires ConvertibleTo&lt;const I2&amp;, I&gt; &amp;&amp; ConvertibleTo&lt;const S2&amp;, S&gt; &amp;&amp;
                 Assignable&lt;I&amp;, const I2&amp;&gt; &amp;&amp; Assignable&lt;S&amp;, const S2&amp;&gt;
            common_iterator&amp; operator=(const common_iterator&lt;I2, S2&gt;&amp; x);
 
    decltype(auto) operator*();
    decltype(auto) operator*() const
        requires __Dereferenceable&lt;const I&gt;;
    decltype(auto) operator-&gt;() const
        requires /* see definition */;
 
    common_iterator&amp; operator++();
    decltype(auto) operator++(int);
 
    template&lt;class I2, Sentinel&lt;I&gt; S2&gt;
        requires Sentinel&lt;S, I2&gt;
    friend bool operator==(
        const common_iterator&amp; x, const common_iterator&lt;I2, S2&gt;&amp; y);
    template&lt;class I2, Sentinel&lt;I&gt; S2&gt;
      requires Sentinel&lt;S, I2&gt; &amp;&amp; EqualityComparableWith&lt;I, I2&gt;
    friend bool operator==(
        const common_iterator&amp; x, const common_iterator&lt;I2, S2&gt;&amp; y);
    template&lt;class I2, Sentinel&lt;I&gt; S2&gt;
        requires Sentinel&lt;S, I2&gt;
    friend bool operator!=(
        const common_iterator&amp; x, const common_iterator&lt;I2, S2&gt;&amp; y);
 
    template&lt;SizedSentinel&lt;I&gt; I2, SizedSentinel&lt;I&gt; S2&gt;
        requires SizedSentinel&lt;S, I2&gt;
    friend iter_difference_t&lt;I2&gt; operator-(
        const common_iterator&amp; x, const common_iterator&lt;I2, S2&gt;&amp; y);
 
    friend iter_rvalue_reference_t&lt;I&gt; iter_move(const common_iterator&amp; i)
        noexcept(noexcept(ranges::iter_move(declval&lt;const I&amp;&gt;())))
            requires InputIterator&lt;I&gt;;
    template&lt;IndirectlySwappable&lt;I&gt; I2, class S2&gt;
        friend void iter_swap(const common_iterator&amp; x, const common_iterator&lt;I2, S2&gt;&amp; y)
            noexcept(noexcept(
                ranges::iter_swap(declval&lt;const I&amp;&gt;(), declval&lt;const I2&amp;&gt;())));
 
private:
    variant&lt;I, S&gt; v_;   // exposition only
};
 
template&lt;class I, class S&gt;
struct incrementable_traits&lt;common_iterator&lt;I, S&gt;&gt; {
    using difference_type = iter_difference_t&lt;I&gt;;
};
 
template&lt;InputIterator I, class S&gt;
struct iterator_traits&lt;common_iterator&lt;I, S&gt;&gt; {
    using iterator_concept = /* see definition */;
    using iterator_category = /* see definition */;
    using value_type = iter_value_t&lt;I&gt;;
    using difference_type = iter_difference_t&lt;I&gt;;
    using pointer = /* see definition */;
    using reference = iter_reference_t&lt;I&gt;;
};</pre></div> <h4 id="Class_std::default_sentinel_t">Class <code>std::default_sentinel_t</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">struct default_sentinel_t { };</pre></div> <h4 id="Class_template_std::counted_iterator">Class template <code>std::counted_iterator</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;Iterator I&gt;
class counted_iterator {
public:
    using iterator_type = I;
 
    constexpr counted_iterator() = default;
    constexpr counted_iterator(I x, iter_difference_t&lt;I&gt; n);
    template&lt;class I2&gt;
        requires ConvertibleTo&lt;const I2&amp;, I&gt;
            constexpr counted_iterator(const counted_iterator&lt;I2&gt;&amp; x);
 
    template&lt;class I2&gt;
        requires Assignable&lt;I&amp;, const I2&amp;&gt;
            constexpr counted_iterator&amp; operator=(const counted_iterator&lt;I2&gt;&amp; x);
 
    constexpr I base() const;
    constexpr iter_difference_t&lt;I&gt; count() const noexcept;
    constexpr decltype(auto) operator*();
    constexpr decltype(auto) operator*() const
        requires __Dereferenceable&lt;const I&gt;;
 
    constexpr counted_iterator&amp; operator++();
    decltype(auto) operator++(int);
    constexpr counted_iterator operator++(int)
        requires ForwardIterator&lt;I&gt;;
    constexpr counted_iterator&amp; operator--()
        requires BidirectionalIterator&lt;I&gt;;
    constexpr counted_iterator operator--(int)
        requires BidirectionalIterator&lt;I&gt;;
 
    constexpr counted_iterator operator+(iter_difference_t&lt;I&gt; n) const
        requires RandomAccessIterator&lt;I&gt;;
    friend constexpr counted_iterator operator+(
        iter_difference_t&lt;I&gt; n, const counted_iterator&amp; x)
            requires RandomAccessIterator&lt;I&gt;;
    constexpr counted_iterator&amp; operator+=(iter_difference_t&lt;I&gt; n)
        requires RandomAccessIterator&lt;I&gt;;
 
    constexpr counted_iterator operator-(iter_difference_t&lt;I&gt; n) const
        requires RandomAccessIterator&lt;I&gt;;
    template&lt;Common&lt;I&gt; I2&gt;
        friend constexpr iter_difference_t&lt;I2&gt; operator-(
            const counted_iterator&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
    friend constexpr iter_difference_t&lt;I&gt; operator-(
        const counted_iterator&amp; x, default_sentinel_t);
    friend constexpr iter_difference_t&lt;I&gt; operator-(
        default_sentinel_t, const counted_iterator&amp; y);
    constexpr counted_iterator&amp; operator-=(iter_difference_t&lt;I&gt; n)
        requires RandomAccessIterator&lt;I&gt;;
 
    constexpr decltype(auto) operator[](iter_difference_t&lt;I&gt; n) const
        requires RandomAccessIterator&lt;I&gt;;
 
    template&lt;Common&lt;I&gt; I2&gt;
        friend constexpr bool operator==(
            const counted_iterator&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
    friend constexpr bool operator==(
        const counted_iterator&amp; x, default_sentinel_t);
    friend constexpr bool operator==(
        default_sentinel_t, const counted_iterator&amp; x);
 
    template&lt;Common&lt;I&gt; I2&gt;
        friend constexpr bool operator!=(
            const counted_iterator&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
    friend constexpr bool operator!=(
        const counted_iterator&amp; x, default_sentinel_t y);
    friend constexpr bool operator!=(
        default_sentinel_t x, const counted_iterator&amp; y);
 
    template&lt;Common&lt;I&gt; I2&gt;
        friend constexpr bool operator&lt;(
            const counted_iterator&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
    template&lt;Common&lt;I&gt; I2&gt;
        friend constexpr bool operator&gt;(
            const counted_iterator&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
    template&lt;Common&lt;I&gt; I2&gt;
        friend constexpr bool operator&lt;=(
            const counted_iterator&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
    template&lt;Common&lt;I&gt; I2&gt;
        friend constexpr bool operator&gt;=(
            const counted_iterator&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
 
    friend constexpr iter_rvalue_reference_t&lt;I&gt; iter_move(const counted_iterator&amp; i)
        noexcept(noexcept(ranges::iter_move(i.current)))
            requires InputIterator&lt;I&gt;;
    template&lt;IndirectlySwappable&lt;I&gt; I2&gt;
        friend constexpr void iter_swap(const counted_iterator&amp; x,
                                        const counted_iterator&lt;I2&gt;&amp; y)
            noexcept(noexcept(ranges::iter_swap(x.current, y.current)));
 
private:
    I current = I();                    // exposition only
    iter_difference_t&lt;I&gt; length = 0;    // exposition only
};
 
template&lt;class I&gt;
struct incrementable_traits&lt;counted_iterator&lt;I&gt;&gt; {
    using difference_type = iter_difference_t&lt;I&gt;;
};
 
template&lt;InputIterator I&gt;
struct iterator_traits&lt;counted_iterator&lt;I&gt;&gt; : iterator_traits&lt;I&gt; {
    using pointer = void;
};</pre></div> <h4 id="Class_std::unreachable_sentinel_t">Class <code>std::unreachable_sentinel_t</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">struct unreachable_sentinel_t {
    template&lt;WeaklyIncrementable I&gt;
        friend constexpr bool operator==(unreachable_sentinel_t, const I&amp;) noexcept;
    template&lt;WeaklyIncrementable I&gt;
        friend constexpr bool operator==(const I&amp;, unreachable_sentinel_t) noexcept;
    template&lt;WeaklyIncrementable I&gt;
        friend constexpr bool operator!=(unreachable_sentinel_t, const I&amp;) noexcept;
    template&lt;WeaklyIncrementable I&gt;
        friend constexpr bool operator!=(const I&amp;, unreachable_sentinel_t) noexcept;
};</pre></div> <h4 id="Class_template_std::istream_iterator">Class template <code><a href="../iterator/istream_iterator" title="cpp/iterator/istream iterator">std::istream_iterator</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class T, class CharT = char, class Traits = char_traits&lt;CharT&gt;,
         class Distance = ptrdiff_t&gt;
class istream_iterator {
public:
    using iterator_category = input_iterator_tag;
    using value_type        = T;
    using difference_type   = Distance;
    using pointer           = const T*;
    using reference         = const T&amp;;
    using char_type         = CharT;
    using traits_type       = Traits;
    using istream_type      = basic_istream&lt;CharT, Traits&gt;;
 
    constexpr istream_iterator();
    istream_iterator(istream_type&amp; s);
    istream_iterator(const istream_iterator&amp; x) = default;
    ~istream_iterator() = default;
 
    const T&amp; operator*() const;
    const T* operator-&gt;() const;
    istream_iterator&amp; operator++();
    istream_iterator operator++(int);
 
private:
    basic_istream&lt;CharT, Traits&gt;* in_stream; // exposition only
    T value;                                 // exposition only
};</pre></div> <h4 id="Class_template_std::ostream_iterator">Class template <code><a href="../iterator/ostream_iterator" title="cpp/iterator/ostream iterator">std::ostream_iterator</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class T, class CharT = char, class Traits = char_traits&lt;CharT&gt;&gt;
class ostream_iterator {
public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;
    using difference_type   = void;
    using pointer           = void;
    using reference         = void;
    using char_type         = CharT;
    using traits_type       = Traits;
    using ostream_type      = basic_ostream&lt;CharT, Traits&gt;;
 
    ostream_iterator(ostream_type&amp; s);
    ostream_iterator(ostream_type&amp; s, const CharT* delimiter);
    ostream_iterator(const ostream_iterator&amp; x);
    ~ostream_iterator();
 
    ostream_iterator&amp; operator=(const T&amp; value);
    ostream_iterator&amp; operator*();
    ostream_iterator&amp; operator++();
    ostream_iterator&amp; operator++(int);
 
private:
    basic_ostream&lt;CharT, Traits&gt;* out_stream; // exposition only
    const CharT* delim;                       // exposition only
};</pre></div> <h4 id="Class_template_std::istreambuf_iterator">Class template <code><a href="../iterator/istreambuf_iterator" title="cpp/iterator/istreambuf iterator">std::istreambuf_iterator</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class CharT, class Traits = char_traits&lt;CharT&gt;&gt;
class istreambuf_iterator {
public:
    using iterator_category = input_iterator_tag;
    using value_type        = CharT;
    using difference_type   = typename Traits::off_type;
    using pointer           = /*unspecified*/;
    using reference         = CharT;
    using char_type         = CharT;
    using traits_type       = Traits;
    using int_type          = typename Traits::int_type;
    using streambuf_type    = basic_streambuf&lt;CharT, Traits&gt;;
    using istream_type      = basic_istream&lt;CharT, Traits&gt;;
 
    class proxy; // exposition only
 
    constexpr istreambuf_iterator() noexcept;
    istreambuf_iterator(const istreambuf_iterator&amp;) noexcept = default;
    ~istreambuf_iterator() = default;
 
    istreambuf_iterator(istream_type&amp; s) noexcept;
    istreambuf_iterator(streambuf_type* s) noexcept;
    istreambuf_iterator(const proxy&amp; p) noexcept;
    CharT operator*() const;
    istreambuf_iterator&amp; operator++();
    proxy operator++(int);
    bool equal(const istreambuf_iterator&amp; b) const;
 
private:
    streambuf_type* sbuf_; // exposition only
};
 
template&lt;class CharT, class Traits = char_traits&lt;CharT&gt;&gt;
class istreambuf_iterator&lt;CharT, Traits&gt;::proxy { // exposition only
    CharT keep_;
    basic_streambuf&lt;CharT, Traits&gt;* sbuf_;
    proxy(CharT c, basic_streambuf&lt;CharT, Traits&gt;* sbuf)
        : keep_(c), sbuf_(sbuf) { }
public:
    CharT operator*() { return keep_; }
};</pre></div> <h4 id="Class_template_std::ostreambuf_iterator">Class template <code><a href="../iterator/ostreambuf_iterator" title="cpp/iterator/ostreambuf iterator">std::ostreambuf_iterator</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class CharT, class Traits = char_traits&lt;CharT&gt;&gt;
class ostreambuf_iterator {
public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;
    using difference_type   = void;
    using pointer           = void;
    using reference         = void;
    using char_type         = CharT;
    using traits_type       = Traits;
    using streambuf_type    = basic_streambuf&lt;CharT, Traits&gt;;
    using ostream_type      = basic_ostream&lt;CharT, Traits&gt;;
 
    ostreambuf_iterator(ostream_type&amp; s) noexcept;
    ostreambuf_iterator(streambuf_type* s) noexcept;
    ostreambuf_iterator&amp; operator=(CharT c);
 
    ostreambuf_iterator&amp; operator*();
    ostreambuf_iterator&amp; operator++();
    ostreambuf_iterator&amp; operator++(int);
    bool failed() const noexcept;
 
private:
    streambuf_type* sbuf_; // exposition only
};</pre></div> <h4 id="Class_template_std::iterator">Class template <code><a href="../iterator/iterator" title="cpp/iterator/iterator">std::iterator</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class Category, class T, class Distance = ptrdiff_t,
         class Pointer = T*, class Reference = T&amp;&gt;
struct iterator {
    typedef T           value_type;
    typedef Distance    difference_type;
    typedef Pointer     pointer;
    typedef Reference   reference;
    typedef Category    iterator_category;
};</pre></div>          <div class="_attribution">
  <p class="_attribution-p">
    © cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/header/iterator" class="_attribution-link">http://en.cppreference.com/w/cpp/header/iterator</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
