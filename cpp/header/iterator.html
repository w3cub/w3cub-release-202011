
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Iterator - C++ - W3cubDocs</title>
  
  <meta name="description" content=" This header is part of the iterator library. ">
  <meta name="keywords" content="standard, library, header, iterator, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/header/iterator.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-9c7b0d969c0ce639a6c01c2badcdd81667c7c66206aa3d0fccc5cb0585fb1b912dab72ea882101d18010680927514b4b77b107282db8f756fbf63301fe9c88b0.css">
  <script type="text/javascript" src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js"></script>
  <script src="/json/cpp.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _cppref">
				
				
<h1 id="firstHeading" class="firstHeading">Standard library header &lt;iterator&gt;</h1>            <p>This header is part of the <a href="../iterator" title="cpp/iterator">iterator</a> library.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx23">
<td> <p>This header is a partial <a href="../freestanding" title="cpp/freestanding">freestanding</a> header. Everything inside this header is freestanding beside stream iterators.</p>
</td> <td><span class="t-mark-rev t-since-cxx23">(since C++23)</span></td>
</tr> </table> <table class="t-dsc-begin"> <tr> <td colspan="2">  <h3 id="Concepts"> Concepts</h3> </td>
</tr> <tr> <td colspan="2"> <h5 id="Iterator_concepts">  Iterator concepts </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/indirectly_readable" title="cpp/iterator/indirectly readable"> <span class="t-lines"><span>indirectly_readable</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies that a type is indirectly readable by applying operator <code>*</code> <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/indirectly_writable" title="cpp/iterator/indirectly writable"> <span class="t-lines"><span>indirectly_writable</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies that a value can be written to an iterator's referenced object <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/weakly_incrementable" title="cpp/iterator/weakly incrementable"> <span class="t-lines"><span>weakly_incrementable</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies that a <a href="../concepts/semiregular" title="cpp/concepts/semiregular"><code>semiregular</code></a> type can be incremented with pre- and post-increment operators <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/incrementable" title="cpp/iterator/incrementable"> <span class="t-lines"><span>incrementable</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies that the increment operation on a <a href="../iterator/weakly_incrementable" title="cpp/iterator/weakly incrementable"><code>weakly_incrementable</code></a> type is <a href="../concepts#Equality_preservation" title="cpp/concepts">equality-preserving</a> and that the type is <a href="../concepts/equality_comparable" title="cpp/concepts/equality comparable"><code>equality_comparable</code></a> <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/input_or_output_iterator" title="cpp/iterator/input or output iterator"> <span class="t-lines"><span>input_or_output_iterator</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies that objects of a type can be incremented and dereferenced <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/sentinel_for" title="cpp/iterator/sentinel for"> <span class="t-lines"><span>sentinel_for</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies a type is a sentinel for an <a href="../iterator/input_or_output_iterator" title="cpp/iterator/input or output iterator"><code>input_or_output_iterator</code></a> type <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/sized_sentinel_for" title="cpp/iterator/sized sentinel for"> <span class="t-lines"><span>sized_sentinel_for</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies that the <code>-</code> operator can be applied to an iterator and a sentinel to calculate their difference in constant time <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/input_iterator" title="cpp/iterator/input iterator"> <span class="t-lines"><span>input_iterator</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies that a type is an input iterator, that is, its referenced values can be read and it can be both pre- and post-incremented <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/output_iterator" title="cpp/iterator/output iterator"> <span class="t-lines"><span>output_iterator</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies that a type is an output iterator for a given value type, that is, values of that type can be written to it and it can be both pre- and post-incremented <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/forward_iterator" title="cpp/iterator/forward iterator"> <span class="t-lines"><span>forward_iterator</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies that an <a href="../iterator/input_iterator" title="cpp/iterator/input iterator"><code>input_iterator</code></a> is a forward iterator, supporting equality comparison and multi-pass <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/bidirectional_iterator" title="cpp/iterator/bidirectional iterator"> <span class="t-lines"><span>bidirectional_iterator</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies that a <a href="../iterator/forward_iterator" title="cpp/iterator/forward iterator"><code>forward_iterator</code></a> is a bidirectional iterator, supporting movement backwards <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/random_access_iterator" title="cpp/iterator/random access iterator"> <span class="t-lines"><span>random_access_iterator</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies that a <a href="../iterator/bidirectional_iterator" title="cpp/iterator/bidirectional iterator"><code>bidirectional_iterator</code></a> is a random-access iterator, supporting advancement in constant time and subscripting <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/contiguous_iterator" title="cpp/iterator/contiguous iterator"> <span class="t-lines"><span>contiguous_iterator</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies that a <a href="../iterator/random_access_iterator" title="cpp/iterator/random access iterator"><code>random_access_iterator</code></a> is a contiguous iterator, referring to elements that are contiguous in memory <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Indirect_callable_concepts">  Indirect callable concepts </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/indirectly_unary_invocable" title="cpp/iterator/indirectly unary invocable"> <span class="t-lines"><span>indirectly_unary_invocable</span><span>indirectly_regular_unary_invocable</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies that a callable type can be invoked with the result of dereferencing an <a href="../iterator/indirectly_readable" title="cpp/iterator/indirectly readable"><code>indirectly_readable</code></a> type <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/indirect_unary_predicate" title="cpp/iterator/indirect unary predicate"> <span class="t-lines"><span>indirect_unary_predicate</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies that a callable type, when invoked with the result of dereferencing an <a href="../iterator/indirectly_readable" title="cpp/iterator/indirectly readable"><code>indirectly_readable</code></a> type, satisfies <a href="../concepts/predicate" title="cpp/concepts/predicate"><code>predicate</code></a> <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/indirect_binary_predicate" title="cpp/iterator/indirect binary predicate"> <span class="t-lines"><span>indirect_binary_predicate</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies that a callable type, when invoked with the result of dereferencing two <a href="../iterator/indirectly_readable" title="cpp/iterator/indirectly readable"><code>indirectly_readable</code></a> types, satisfies <a href="../concepts/predicate" title="cpp/concepts/predicate"><code>predicate</code></a> <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/indirect_equivalence_relation" title="cpp/iterator/indirect equivalence relation"> <span class="t-lines"><span>indirect_equivalence_relation</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies that a callable type, when invoked with the result of dereferencing two <a href="../iterator/indirectly_readable" title="cpp/iterator/indirectly readable"><code>indirectly_readable</code></a> types, satisfies <a href="../concepts/equivalence_relation" title="cpp/concepts/equivalence relation"><code>equivalence_relation</code></a> <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/indirect_strict_weak_order" title="cpp/iterator/indirect strict weak order"> <span class="t-lines"><span>indirect_strict_weak_order</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies that a callable type, when invoked with the result of dereferencing two <a href="../iterator/indirectly_readable" title="cpp/iterator/indirectly readable"><code>indirectly_readable</code></a> types, satisfies <a href="../concepts/strict_weak_order" title="cpp/concepts/strict weak order"><code>strict_weak_order</code></a> <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Common_algorithm_requirements">  Common algorithm requirements </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/indirectly_movable" title="cpp/iterator/indirectly movable"> <span class="t-lines"><span>indirectly_movable</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies that values may be moved from an <a href="../iterator/indirectly_readable" title="cpp/iterator/indirectly readable"><code>indirectly_readable</code></a> type to an <a href="../iterator/indirectly_writable" title="cpp/iterator/indirectly writable"><code>indirectly_writable</code></a> type <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/indirectly_movable_storable" title="cpp/iterator/indirectly movable storable"> <span class="t-lines"><span>indirectly_movable_storable</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies that values may be moved from an <a href="../iterator/indirectly_readable" title="cpp/iterator/indirectly readable"><code>indirectly_readable</code></a> type to an <a href="../iterator/indirectly_writable" title="cpp/iterator/indirectly writable"><code>indirectly_writable</code></a> type and that the move may be performed via an intermediate object <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/indirectly_copyable" title="cpp/iterator/indirectly copyable"> <span class="t-lines"><span>indirectly_copyable</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies that values may be copied from an <a href="../iterator/indirectly_readable" title="cpp/iterator/indirectly readable"><code>indirectly_readable</code></a> type to an <a href="../iterator/indirectly_writable" title="cpp/iterator/indirectly writable"><code>indirectly_writable</code></a> type <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/indirectly_copyable_storable" title="cpp/iterator/indirectly copyable storable"> <span class="t-lines"><span>indirectly_copyable_storable</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies that values may be copied from an <a href="../iterator/indirectly_readable" title="cpp/iterator/indirectly readable"><code>indirectly_readable</code></a> type to an <a href="../iterator/indirectly_writable" title="cpp/iterator/indirectly writable"><code>indirectly_writable</code></a> type and that the copy may be performed via an intermediate object <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/indirectly_swappable" title="cpp/iterator/indirectly swappable"> <span class="t-lines"><span>indirectly_swappable</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies that the values referenced by two <a href="../iterator/indirectly_readable" title="cpp/iterator/indirectly readable"><code>indirectly_readable</code></a> types can be swapped <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/indirectly_comparable" title="cpp/iterator/indirectly comparable"> <span class="t-lines"><span>indirectly_comparable</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies that the values referenced by two <a href="../iterator/indirectly_readable" title="cpp/iterator/indirectly readable"><code>indirectly_readable</code></a> types can be compared <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/permutable" title="cpp/iterator/permutable"> <span class="t-lines"><span>permutable</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies the common requirements of algorithms that reorder elements in place <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/mergeable" title="cpp/iterator/mergeable"> <span class="t-lines"><span>mergeable</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies the requirements of algorithms that merge sorted sequences into an output sequence by copying elements <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/sortable" title="cpp/iterator/sortable"> <span class="t-lines"><span>sortable</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies the common requirements of algorithms that permute sequences into ordered sequences <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr> <td colspan="2"> <h3 id="Classes"> Classes</h3> </td>
</tr> <tr> <td colspan="2"> <h5 id="Algorithm_utilities">  Algorithm utilities </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/indirect_result_t" title="cpp/iterator/indirect result t"> <span class="t-lines"><span>indirect_result_t</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> computes the result of invoking a callable object on the result of dereferencing some set of <a href="../iterator/indirectly_readable" title="cpp/iterator/indirectly readable"><code>indirectly_readable</code></a> types <br> <span class="t-mark">(alias template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/projected" title="cpp/iterator/projected"> <span class="t-lines"><span>projected</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> helper template for specifying the constraints on algorithms that accept projections <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Associated_types">  Associated types </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/incrementable_traits" title="cpp/iterator/incrementable traits"> <span class="t-lines"><span>incrementable_traits</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> computes the difference type of a <a href="../iterator/weakly_incrementable" title="cpp/iterator/weakly incrementable"><code>weakly_incrementable</code></a> type <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/indirectly_readable_traits" title="cpp/iterator/indirectly readable traits"> <span class="t-lines"><span>indirectly_readable_traits</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> computes the value type of an <a href="../iterator/indirectly_readable" title="cpp/iterator/indirectly readable"><code>indirectly_readable</code></a> type <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/iter_t" title="cpp/iterator/iter t"> <span class="t-lines"><span>iter_value_t</span><span>iter_reference_t</span><span>iter_const_reference_t</span><span>iter_difference_t</span><span>iter_rvalue_reference_t</span><span>iter_common_reference_t</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> computes the associated types of an iterator <br> <span class="t-mark">(alias template)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Primitives">  Primitives </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/iterator_traits" title="cpp/iterator/iterator traits"> <span class="t-lines"><span>iterator_traits</span></span></a></div> </td> <td> provides uniform interface to the properties of an iterator <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/iterator_tags" title="cpp/iterator/iterator tags"> <span class="t-lines"><span>input_iterator_tag</span><span>output_iterator_tag</span><span>forward_iterator_tag</span><span>bidirectional_iterator_tag</span><span>random_access_iterator_tag</span><span>contiguous_iterator_tag</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> empty class types used to indicate iterator categories <br> <span class="t-mark">(class)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/iterator" title="cpp/iterator/iterator"> <span class="t-lines"><span>iterator</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark">(deprecated in C++17)</span></span></span></div> </td> <td> base class to ease the definition of required types for simple iterators <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Adaptors">  Adaptors </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/reverse_iterator" title="cpp/iterator/reverse iterator"> <span class="t-lines"><span>reverse_iterator</span></span></a></div> </td> <td> iterator adaptor for reverse-order traversal <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/move_iterator" title="cpp/iterator/move iterator"> <span class="t-lines"><span>move_iterator</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> iterator adaptor which dereferences to an rvalue reference <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/move_sentinel" title="cpp/iterator/move sentinel"> <span class="t-lines"><span>move_sentinel</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> sentinel adaptor for use with <code><a href="../iterator/move_iterator" title="cpp/iterator/move iterator">std::move_iterator</a></code> <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/common_iterator" title="cpp/iterator/common iterator"> <span class="t-lines"><span>common_iterator</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> adapts an iterator type and its sentinel into a common iterator type <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/default_sentinel_t" title="cpp/iterator/default sentinel t"> <span class="t-lines"><span>default_sentinel_t</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> default sentinel for use with iterators that know the bound of their range <br> <span class="t-mark">(class)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/counted_iterator" title="cpp/iterator/counted iterator"> <span class="t-lines"><span>counted_iterator</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> iterator adaptor that tracks the distance to the end of the range <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/unreachable_sentinel_t" title="cpp/iterator/unreachable sentinel t"> <span class="t-lines"><span>unreachable_sentinel_t</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> sentinel that always compares unequal to any <a href="../iterator/weakly_incrementable" title="cpp/iterator/weakly incrementable"><code>weakly_incrementable</code></a> type <br> <span class="t-mark">(class)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/back_insert_iterator" title="cpp/iterator/back insert iterator"> <span class="t-lines"><span>back_insert_iterator</span></span></a></div> </td> <td> iterator adaptor for insertion at the end of a container <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/front_insert_iterator" title="cpp/iterator/front insert iterator"> <span class="t-lines"><span>front_insert_iterator</span></span></a></div> </td> <td> iterator adaptor for insertion at the front of a container <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/insert_iterator" title="cpp/iterator/insert iterator"> <span class="t-lines"><span>insert_iterator</span></span></a></div> </td> <td> iterator adaptor for insertion into a container <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Stream_Iterators">  Stream Iterators </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/istream_iterator" title="cpp/iterator/istream iterator"> <span class="t-lines"><span>istream_iterator</span></span></a></div> </td> <td> input iterator that reads from <code><a href="../io/basic_istream" title="cpp/io/basic istream">std::basic_istream</a></code> <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/ostream_iterator" title="cpp/iterator/ostream iterator"> <span class="t-lines"><span>ostream_iterator</span></span></a></div> </td> <td> output iterator that writes to <code><a href="../io/basic_ostream" title="cpp/io/basic ostream">std::basic_ostream</a></code> <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/istreambuf_iterator" title="cpp/iterator/istreambuf iterator"> <span class="t-lines"><span>istreambuf_iterator</span></span></a></div> </td> <td> input iterator that reads from <code><a href="../io/basic_streambuf" title="cpp/io/basic streambuf">std::basic_streambuf</a></code> <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/ostreambuf_iterator" title="cpp/iterator/ostreambuf iterator"> <span class="t-lines"><span>ostreambuf_iterator</span></span></a></div> </td> <td> output iterator that writes to <code><a href="../io/basic_streambuf" title="cpp/io/basic streambuf">std::basic_streambuf</a></code> <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr> <td colspan="2"> <h3 id="Customization_point_objects"> Customization point objects</h3> </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in namespace <code>std::ranges</code>  </th>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/ranges/iter_move" title="cpp/iterator/ranges/iter move"> <span class="t-lines"><span>iter_move</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> casts the result of dereferencing an object to its associated rvalue reference type <br> <span class="t-mark">(customization point object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/ranges/iter_swap" title="cpp/iterator/ranges/iter swap"> <span class="t-lines"><span>iter_swap</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> swaps the values referenced by two dereferenceable objects <br> <span class="t-mark">(customization point object)</span>  </td>
</tr> <tr> <td colspan="2"> <h3 id="Constants">  Constants</h3> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/unreachable_sentinel_t" title="cpp/iterator/unreachable sentinel t"> <span class="t-lines"><span>unreachable_sentinel</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> an object of type <code>unreachable_sentinel_t</code> that always compares unequal to any <a href="../iterator/weakly_incrementable" title="cpp/iterator/weakly incrementable"><code>weakly_incrementable</code></a> type <br> <span class="t-mark">(constant)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/default_sentinel_t" title="cpp/iterator/default sentinel t"> <span class="t-lines"><span>default_sentinel</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> an object of type <code>default_sentinel_t</code> used with iterators that know the bound of their range <br> <span class="t-mark">(constant)</span>  </td>
</tr> <tr> <td colspan="2"> <h3 id="Functions"> Functions</h3> </td>
</tr> <tr> <td colspan="2"> <h5 id="Adaptors_2">  Adaptors </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/make_reverse_iterator" title="cpp/iterator/make reverse iterator"> <span class="t-lines"><span>make_reverse_iterator</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx14">(C++14)</span></span></span></div> </td> <td> creates a <code><a href="../iterator/reverse_iterator" title="cpp/iterator/reverse iterator">std::reverse_iterator</a></code> of type inferred from the argument <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/make_move_iterator" title="cpp/iterator/make move iterator"> <span class="t-lines"><span>make_move_iterator</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> creates a <code><a href="../iterator/move_iterator" title="cpp/iterator/move iterator">std::move_iterator</a></code> of type inferred from the argument <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/front_inserter" title="cpp/iterator/front inserter"> <span class="t-lines"><span>front_inserter</span></span></a></div> </td> <td> creates a <code><a href="../iterator/front_insert_iterator" title="cpp/iterator/front insert iterator">std::front_insert_iterator</a></code> of type inferred from the argument <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/back_inserter" title="cpp/iterator/back inserter"> <span class="t-lines"><span>back_inserter</span></span></a></div> </td> <td> creates a <code><a href="../iterator/back_insert_iterator" title="cpp/iterator/back insert iterator">std::back_insert_iterator</a></code> of type inferred from the argument <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/inserter" title="cpp/iterator/inserter"> <span class="t-lines"><span>inserter</span></span></a></div> </td> <td> creates a <code><a href="../iterator/insert_iterator" title="cpp/iterator/insert iterator">std::insert_iterator</a></code> of type inferred from the argument <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Non-member_operators">  Non-member operators </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/move_iterator/operator_cmp" title="cpp/iterator/move iterator/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span><span>operator&lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> compares the underlying iterators <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/move_iterator/operator_plus_" title="cpp/iterator/move iterator/operator+"> <span class="t-lines"><span>operator+</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> advances the iterator <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/move_iterator/operator-" title="cpp/iterator/move iterator/operator-"> <span class="t-lines"><span>operator-</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> computes the distance between two iterator adaptors <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/reverse_iterator/operator_cmp" title="cpp/iterator/reverse iterator/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span><span>operator&lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> compares the underlying iterators <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/reverse_iterator/operator_plus_" title="cpp/iterator/reverse iterator/operator+"> <span class="t-lines"><span>operator+</span></span></a></div> </td> <td> advances the iterator <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/reverse_iterator/operator-" title="cpp/iterator/reverse iterator/operator-"> <span class="t-lines"><span>operator-</span></span></a></div> </td> <td> computes the distance between two iterator adaptors <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/counted_iterator/operator_cmp" title="cpp/iterator/counted iterator/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator&lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> compares the distances to the end <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/counted_iterator/operator_plus_" title="cpp/iterator/counted iterator/operator+"> <span class="t-lines"><span>operator+</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> advances the iterator <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/counted_iterator/operator-" title="cpp/iterator/counted iterator/operator-"> <span class="t-lines"><span>operator-</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> computes the distance between two iterator adaptors <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/istream_iterator/operator_cmp" title="cpp/iterator/istream iterator/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span></span></div> </td> <td> compares two <code>istream_iterator</code>s <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/istreambuf_iterator/operator_cmp" title="cpp/iterator/istreambuf iterator/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span></span></div> </td> <td> compares two <code>istreambuf_iterator</code>s <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Operations">  Operations </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/advance" title="cpp/iterator/advance"> <span class="t-lines"><span>advance</span></span></a></div> </td> <td> advances an iterator by given distance <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/distance" title="cpp/iterator/distance"> <span class="t-lines"><span>distance</span></span></a></div> </td> <td> returns the distance between two iterators <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/next" title="cpp/iterator/next"> <span class="t-lines"><span>next</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> increment an iterator <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/prev" title="cpp/iterator/prev"> <span class="t-lines"><span>prev</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> decrement an iterator <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/ranges/advance" title="cpp/iterator/ranges/advance"> <span class="t-lines"><span>ranges::advance</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> advances an iterator by given distance or to a given bound <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/ranges/distance" title="cpp/iterator/ranges/distance"> <span class="t-lines"><span>ranges::distance</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> returns the distance between an iterator and a sentinel, or between the beginning and end of a range <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/ranges/next" title="cpp/iterator/ranges/next"> <span class="t-lines"><span>ranges::next</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> increment an iterator by a given distance or to a bound <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/ranges/prev" title="cpp/iterator/ranges/prev"> <span class="t-lines"><span>ranges::prev</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> decrement an iterator by a given distance or to a bound <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Range_access">  Range access </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/begin" title="cpp/iterator/begin"> <span class="t-lines"><span>begin</span><span>cbegin</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx14">(C++14)</span></span></span></div> </td> <td> returns an iterator to the beginning of a container or array <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/end" title="cpp/iterator/end"> <span class="t-lines"><span>end</span><span>cend</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx14">(C++14)</span></span></span></div> </td> <td> returns an iterator to the end of a container or array <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/rbegin" title="cpp/iterator/rbegin"> <span class="t-lines"><span>rbegin</span><span>crbegin</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx14">(C++14)</span></span></span></div> </td> <td> returns a reverse iterator to the beginning of a container or array <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/rend" title="cpp/iterator/rend"> <span class="t-lines"><span>rend</span><span>crend</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx14">(C++14)</span></span></span></div> </td> <td> returns a reverse end iterator for a container or array <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/size" title="cpp/iterator/size"> <span class="t-lines"><span>size</span><span>ssize</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> returns the size of a container or array <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/empty" title="cpp/iterator/empty"> <span class="t-lines"><span>empty</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> checks whether the container is empty <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/data" title="cpp/iterator/data"> <span class="t-lines"><span>data</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> obtains the pointer to the underlying array <br> <span class="t-mark">(function template)</span>  </td>
</tr> </table> <h3 id="Synopsis"> Synopsis</h3> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;compare&gt;
#include &lt;concepts&gt;
 
namespace std {
  template&lt;class T&gt; using /*with-reference*/ = T&amp;;  // exposition only
  template&lt;class T&gt; concept /*can-reference*/       // exposition only
    = requires { typename /*with-reference*/&lt;T&gt;; };
  template&lt;class T&gt; concept /*dereferenceable*/     // exposition only
    = requires(T&amp; t) {
      { *t } -&gt; /*can-reference*/;  // not required to be equality-preserving
    };
 
  // associated types
  // incrementable traits
  template&lt;class&gt; struct incrementable_traits;
  template&lt;class T&gt;
    using iter_difference_t = /* see description */;
 
  // indirectly readable traits
  template&lt;class&gt; struct indirectly_readable_traits;
  template&lt;class T&gt;
    using iter_value_t = /* see description */;
 
  // iterator traits
  template&lt;class I&gt; struct iterator_traits;
  template&lt;class T&gt; requires is_object_v&lt;T&gt; struct iterator_traits&lt;T*&gt;;
 
  template&lt;/*dereferenceable*/ T&gt;
    using iter_reference_t = decltype(*declval&lt;T&amp;&gt;());
 
  namespace ranges {
    // customization point objects
    inline namespace /* unspecified */ {
      // ranges::iter_move
      inline constexpr /* unspecified */ iter_move = /* unspecified */;
 
      // ranges::iter_swap
      inline constexpr /* unspecified */ iter_swap = /* unspecified */;
    }
  }
 
  template&lt;/*dereferenceable*/ T&gt;
    requires requires(T&amp; t) {
      { ranges::iter_move(t) } -&gt; /*can-reference*/;
    }
  using iter_rvalue_reference_t
    = decltype(ranges::iter_move(declval&lt;T&amp;&gt;()));
 
  // iterator concepts
  // concept indirectly_readable
  template&lt;class In&gt;
    concept indirectly_readable = /* see description */;
 
  template&lt;indirectly_readable T&gt;
    using iter_common_reference_t =
      common_reference_t&lt;iter_reference_t&lt;T&gt;, iter_value_t&lt;T&gt;&amp;&gt;;
 
  // concept indirectly_writable
  template&lt;class Out, class T&gt;
    concept indirectly_writable = /* see description */;
 
  // concept weakly_incrementable
  template&lt;class I&gt;
    concept weakly_incrementable = /* see description */;
 
  // concept incrementable
  template&lt;class I&gt;
    concept incrementable = /* see description */;
 
  // concept input_or_output_iterator
  template&lt;class I&gt;
    concept input_or_output_iterator = /* see description */;
 
  // concept sentinel_for
  template&lt;class S, class I&gt;
    concept sentinel_for = /* see description */;
 
  // concept sized_sentinel_for
  template&lt;class S, class I&gt;
    inline constexpr bool disable_sized_sentinel_for = false;
 
  template&lt;class S, class I&gt;
    concept sized_sentinel_for = /* see description */;
 
  // concept input_iterator
  template&lt;class I&gt;
    concept input_iterator = /* see description */;
 
  // concept output_iterator
  template&lt;class I, class T&gt;
    concept output_iterator = /* see description */;
 
  // concept forward_iterator
  template&lt;class I&gt;
    concept forward_iterator = /* see description */;
 
  // concept bidirectional_iterator
  template&lt;class I&gt;
    concept bidirectional_iterator = /* see description */;
 
  // concept random_access_iterator
  template&lt;class I&gt;
    concept random_access_iterator = /* see description */;
 
  // concept contiguous_iterator
  template&lt;class I&gt;
    concept contiguous_iterator = /* see description */;
 
  // indirect callable requirements
  // indirect callables
  template&lt;class F, class I&gt;
    concept indirectly_unary_invocable = /* see description */;
 
  template&lt;class F, class I&gt;
    concept indirectly_regular_unary_invocable = /* see description */;
 
  template&lt;class F, class I&gt;
    concept indirect_unary_predicate = /* see description */;
 
  template&lt;class F, class I1, class I2&gt;
    concept indirect_binary_predicate = /* see description */;
 
  template&lt;class F, class I1, class I2 = I1&gt;
    concept indirect_equivalence_relation = /* see description */;
 
  template&lt;class F, class I1, class I2 = I1&gt;
    concept indirect_strict_weak_order = /* see description */;
 
  template&lt;class F, class... Is&gt;
    requires (indirectly_readable&lt;Is&gt; &amp;&amp; ...) &amp;&amp; invocable&lt;F, iter_reference_t&lt;Is&gt;...&gt;
      using indirect_result_t = invoke_result_t&lt;F, iter_reference_t&lt;Is&gt;...&gt;;
 
  // projected
  template&lt;indirectly_readable I, indirectly_regular_unary_invocable&lt;I&gt; Proj&gt;
    struct projected;
 
  template&lt;weakly_incrementable I, class Proj&gt;
    struct incrementable_traits&lt;projected&lt;I, Proj&gt;&gt;;
 
  // common algorithm requirements
  // concept indirectly_movable
  template&lt;class In, class Out&gt;
    concept indirectly_movable = /* see description */;
 
  template&lt;class In, class Out&gt;
    concept indirectly_movable_storable = /* see description */;
 
  // concept indirectly_copyable
  template&lt;class In, class Out&gt;
    concept indirectly_copyable = /* see description */;
 
  template&lt;class In, class Out&gt;
    concept indirectly_copyable_storable = /* see description */;
 
  // concept indirectly_swappable
  template&lt;class I1, class I2 = I1&gt;
    concept indirectly_swappable = /* see description */;
 
  // concept indirectly_comparable
  template&lt;class I1, class I2, class R, class P1 = identity, class P2 = identity&gt;
    concept indirectly_comparable = /* see description */;
 
  // concept permutable
  template&lt;class I&gt;
    concept permutable = /* see description */;
 
  // concept mergeable
  template&lt;class I1, class I2, class Out,
      class R = ranges::less, class P1 = identity, class P2 = identity&gt;
    concept mergeable = /* see description */;
 
  // concept sortable
  template&lt;class I, class R = ranges::less, class P = identity&gt;
    concept sortable = /* see description */;
 
  // primitives
  // iterator tags
  struct input_iterator_tag { };
  struct output_iterator_tag { };
  struct forward_iterator_tag: public input_iterator_tag { };
  struct bidirectional_iterator_tag: public forward_iterator_tag { };
  struct random_access_iterator_tag: public bidirectional_iterator_tag { };
  struct contiguous_iterator_tag: public random_access_iterator_tag { };
 
  // iterator operations
  template&lt;class InputIt, class Distance&gt;
    constexpr void advance(InputIt&amp; i, Distance n);
  template&lt;class InputIt&gt;
    constexpr typename iterator_traits&lt;InputIt&gt;::difference_type
      distance(InputIt first, InputIt last);
  template&lt;class InputIt&gt;
    constexpr InputIt
      next(InputIt x, typename iterator_traits&lt;InputIt&gt;::difference_type n = 1);
  template&lt;class BidirIt&gt;
    constexpr BidirIt
      prev(BidirIt x, typename iterator_traits&lt;BidirIt&gt;::difference_type n = 1);
 
  // range iterator operations
  namespace ranges {
    // ranges::advance
    template&lt;input_or_output_iterator I&gt;
      constexpr void advance(I&amp; i, iter_difference_t&lt;I&gt; n);
    template&lt;input_or_output_iterator I, sentinel_for&lt;I&gt; S&gt;
      constexpr void advance(I&amp; i, S bound);
    template&lt;input_or_output_iterator I, sentinel_for&lt;I&gt; S&gt;
      constexpr iter_difference_t&lt;I&gt; advance(I&amp; i, iter_difference_t&lt;I&gt; n, S bound);
 
    // ranges::distance
    template&lt;class I, sentinel_for&lt;I&gt; S&gt;
      requires (!sized_sentinel_for&lt;S, I&gt;)
      constexpr iter_difference_t&lt;I&gt; distance(I first, S last);
    template&lt;class I, sized_sentinel_for&lt;decay_t&lt;I&gt;&gt; S&gt;
      constexpr iter_difference_t&lt;decay_t&lt;I&gt;&gt; distance(I&amp;&amp; first, S last);
    template&lt;range R&gt;
      constexpr range_difference_t&lt;R&gt; distance(R&amp;&amp; r);
 
    // ranges::next
    template&lt;input_or_output_iterator I&gt;
      constexpr I next(I x);
    template&lt;input_or_output_iterator I&gt;
      constexpr I next(I x, iter_difference_t&lt;I&gt; n);
    template&lt;input_or_output_iterator I, sentinel_for&lt;I&gt; S&gt;
      constexpr I next(I x, S bound);
    template&lt;input_or_output_iterator I, sentinel_for&lt;I&gt; S&gt;
      constexpr I next(I x, iter_difference_t&lt;I&gt; n, S bound);
 
    // ranges::prev
    template&lt;bidirectional_iterator I&gt;
      constexpr I prev(I x);
    template&lt;bidirectional_iterator I&gt;
      constexpr I prev(I x, iter_difference_t&lt;I&gt; n);
    template&lt;bidirectional_iterator I&gt;
      constexpr I prev(I x, iter_difference_t&lt;I&gt; n, I bound);
  }
 
  // predefined iterators and sentinels
  // reverse iterators
  template&lt;class It&gt; class reverse_iterator;
 
  template&lt;class It1, class It2&gt;
    constexpr bool operator==(const reverse_iterator&lt;It1&gt;&amp; x,
                              const reverse_iterator&lt;It2&gt;&amp; y);
  template&lt;class It1, class It2&gt;
    constexpr bool operator!=(const reverse_iterator&lt;It1&gt;&amp; x,
                              const reverse_iterator&lt;It2&gt;&amp; y);
  template&lt;class It1, class It2&gt;
    constexpr bool operator&lt;(const reverse_iterator&lt;It1&gt;&amp; x,
                             const reverse_iterator&lt;It2&gt;&amp; y);
  template&lt;class It1, class It2&gt;
    constexpr bool operator&gt;(const reverse_iterator&lt;It1&gt;&amp; x,
                             const reverse_iterator&lt;It2&gt;&amp; y);
  template&lt;class It1, class It2&gt;
    constexpr bool operator&lt;=(const reverse_iterator&lt;It1&gt;&amp; x,
                              const reverse_iterator&lt;It2&gt;&amp; y);
  template&lt;class It1, class It2&gt;
    constexpr bool operator&gt;=(const reverse_iterator&lt;It1&gt;&amp; x,
                              const reverse_iterator&lt;It2&gt;&amp; y);
  template&lt;class It1, three_way_comparable_with&lt;It1&gt; It2&gt;
    constexpr compare_three_way_result_t&lt;It1, It2&gt;
      operator&lt;=&gt;(const reverse_iterator&lt;It1&gt;&amp; x, const reverse_iterator&lt;It2&gt;&amp; y);
 
  template&lt;class It1, class It2&gt;
    constexpr auto operator-(const reverse_iterator&lt;It1&gt;&amp; x,
                             const reverse_iterator&lt;It2&gt;&amp; y)
      -&gt; decltype(y.base() - x.base());
  template&lt;class It&gt;
    constexpr reverse_iterator&lt;It&gt; operator+(iter_difference_t&lt;It&gt; n,
                                             const reverse_iterator&lt;It&gt;&amp; x);
 
  template&lt;class It&gt;
    constexpr reverse_iterator&lt;It&gt; make_reverse_iterator(It i);
 
  template&lt;class It1, class It2&gt;
      requires (!sized_sentinel_for&lt;It1, It2&gt;)
    inline constexpr bool disable_sized_sentinel_for&lt;reverse_iterator&lt;It1&gt;,
                                                     reverse_iterator&lt;It2&gt;&gt; = true;
 
  // insert iterators
  template&lt;class Container&gt; class back_insert_iterator;
  template&lt;class Container&gt;
    constexpr back_insert_iterator&lt;Container&gt; back_inserter(Container&amp; x);
 
  template&lt;class Container&gt; class front_insert_iterator;
  template&lt;class Container&gt;
    constexpr front_insert_iterator&lt;Container&gt; front_inserter(Container&amp; x);
 
  template&lt;class Container&gt; class insert_iterator;
  template&lt;class Container&gt;
    constexpr insert_iterator&lt;Container&gt;
      inserter(Container&amp; x, ranges::iterator_t&lt;Container&gt; i);
 
  // move iterators and sentinels
  template&lt;class It&gt; class move_iterator;
 
  template&lt;class It1, class It2&gt;
    constexpr bool operator==(const move_iterator&lt;It1&gt;&amp; x, const move_iterator&lt;It2&gt;&amp; y);
  template&lt;class It1, class It2&gt;
    constexpr bool operator&lt;(const move_iterator&lt;It1&gt;&amp; x, const move_iterator&lt;It2&gt;&amp; y);
  template&lt;class It1, class It2&gt;
    constexpr bool operator&gt;(const move_iterator&lt;It1&gt;&amp; x, const move_iterator&lt;It2&gt;&amp; y);
  template&lt;class It1, class It2&gt;
    constexpr bool operator&lt;=(const move_iterator&lt;It1&gt;&amp; x, const move_iterator&lt;It2&gt;&amp; y);
  template&lt;class It1, class It2&gt;
    constexpr bool operator&gt;=(const move_iterator&lt;It1&gt;&amp; x, const move_iterator&lt;It2&gt;&amp; y);
  template&lt;class It1, three_way_comparable_with&lt;It1&gt; It2&gt;
    constexpr compare_three_way_result_t&lt;It1, It2&gt;
      operator&lt;=&gt;(const move_iterator&lt;It1&gt;&amp; x, const move_iterator&lt;It2&gt;&amp; y);
 
  template&lt;class It1, class It2&gt;
    constexpr auto operator-(const move_iterator&lt;It1&gt;&amp; x, const move_iterator&lt;It2&gt;&amp; y)
      -&gt; decltype(x.base() - y.base());
  template&lt;class It&gt;
    constexpr move_iterator&lt;It&gt;
      operator+(iter_difference_t&lt;It&gt; n, const move_iterator&lt;It&gt;&amp; x);
 
  template&lt;class It&gt;
    constexpr move_iterator&lt;It&gt; make_move_iterator(It i);
 
  template&lt;semiregular S&gt; class move_sentinel;
 
  // common iterators
  template&lt;input_or_output_iterator I, sentinel_for&lt;I&gt; S&gt;
    requires (!same_as&lt;I, S&gt; &amp;&amp; copyable&lt;I&gt;)
      class common_iterator;
 
  template&lt;class I, class S&gt;
    struct incrementable_traits&lt;common_iterator&lt;I, S&gt;&gt;;
 
  template&lt;input_iterator I, class S&gt;
    struct iterator_traits&lt;common_iterator&lt;I, S&gt;&gt;;
 
  // default sentinel
  struct default_sentinel_t;
  inline constexpr default_sentinel_t default_sentinel{};
 
  // counted iterators
  template&lt;input_or_output_iterator I&gt; class counted_iterator;
 
  template&lt;input_iterator I&gt;
    requires /* see description */
    struct iterator_traits&lt;counted_iterator&lt;I&gt;&gt;;
 
  // unreachable sentinel
  struct unreachable_sentinel_t;
  inline constexpr unreachable_sentinel_t unreachable_sentinel{};
 
  // stream iterators
  template&lt;class T, class CharT = char, class Traits = char_traits&lt;CharT&gt;,
           class Distance = ptrdiff_t&gt;
  class istream_iterator;
  template&lt;class T, class CharT, class Traits, class Distance&gt;
    bool operator==(const istream_iterator&lt;T, CharT, Traits, Distance&gt;&amp; x,
                    const istream_iterator&lt;T, CharT, Traits, Distance&gt;&amp; y);
 
  template&lt;class T, class CharT = char, class traits = char_traits&lt;CharT&gt;&gt;
      class ostream_iterator;
 
  template&lt;class CharT, class Traits = char_traits&lt;CharT&gt;&gt;
    class istreambuf_iterator;
  template&lt;class CharT, class Traits&gt;
    bool operator==(const istreambuf_iterator&lt;CharT, Traits&gt;&amp; a,
                    const istreambuf_iterator&lt;CharT, Traits&gt;&amp; b);
 
  template&lt;class CharT, class Traits = char_traits&lt;CharT&gt;&gt;
    class ostreambuf_iterator;
 
  // range access
  template&lt;class C&gt; constexpr auto begin(C&amp; c) -&gt; decltype(c.begin());
  template&lt;class C&gt; constexpr auto begin(const C&amp; c) -&gt; decltype(c.begin());
  template&lt;class C&gt; constexpr auto end(C&amp; c) -&gt; decltype(c.end());
  template&lt;class C&gt; constexpr auto end(const C&amp; c) -&gt; decltype(c.end());
  template&lt;class T, size_t N&gt; constexpr T* begin(T (&amp;a)[N]) noexcept;
  template&lt;class T, size_t N&gt; constexpr T* end(T (&amp;a)[N]) noexcept;
  template&lt;class C&gt; constexpr auto cbegin(const C&amp; c) noexcept(noexcept(std::begin(c)))
    -&gt; decltype(std::begin(c));
  template&lt;class C&gt; constexpr auto cend(const C&amp; c) noexcept(noexcept(std::end(c)))
    -&gt; decltype(std::end(c));
  template&lt;class C&gt; constexpr auto rbegin(C&amp; c) -&gt; decltype(c.rbegin());
  template&lt;class C&gt; constexpr auto rbegin(const C&amp; c) -&gt; decltype(c.rbegin());
  template&lt;class C&gt; constexpr auto rend(C&amp; c) -&gt; decltype(c.rend());
  template&lt;class C&gt; constexpr auto rend(const C&amp; c) -&gt; decltype(c.rend());
  template&lt;class T, size_t N&gt; constexpr reverse_iterator&lt;T*&gt; rbegin(T (&amp;a)[N]);
  template&lt;class T, size_t N&gt; constexpr reverse_iterator&lt;T*&gt; rend(T (&amp;a)[N]);
  template&lt;class E&gt; constexpr reverse_iterator&lt;const E*&gt; rbegin(initializer_list&lt;E&gt; il);
  template&lt;class E&gt; constexpr reverse_iterator&lt;const E*&gt; rend(initializer_list&lt;E&gt; il);
  template&lt;class C&gt; constexpr auto crbegin(const C&amp; c) -&gt; decltype(std::rbegin(c));
  template&lt;class C&gt; constexpr auto crend(const C&amp; c) -&gt; decltype(std::rend(c));
 
  template&lt;class C&gt; constexpr auto size(const C&amp; c) -&gt; decltype(c.size());
  template&lt;class T, size_t N&gt; constexpr size_t size(const T (&amp;a)[N]) noexcept;
  template&lt;class C&gt; constexpr auto ssize(const C&amp; c)
    -&gt; common_type_t&lt;ptrdiff_t, make_signed_t&lt;decltype(c.size())&gt;&gt;;
  template&lt;class T, ptrdiff_t N&gt; constexpr ptrdiff_t ssize(const T (&amp;a)[N]) noexcept;
  template&lt;class C&gt; [[nodiscard]] constexpr auto empty(const C&amp; c) -&gt; decltype(c.empty());
  template&lt;class T, size_t N&gt; [[nodiscard]] constexpr bool empty(const T (&amp;a)[N]) noexcept;
  template&lt;class E&gt; [[nodiscard]] constexpr bool empty(initializer_list&lt;E&gt; il) noexcept;
  template&lt;class C&gt; constexpr auto data(C&amp; c) -&gt; decltype(c.data());
  template&lt;class C&gt; constexpr auto data(const C&amp; c) -&gt; decltype(c.data());
  template&lt;class T, size_t N&gt; constexpr T* data(T (&amp;a)[N]) noexcept;
  template&lt;class E&gt; constexpr const E* data(initializer_list&lt;E&gt; il) noexcept;
}</pre></div> <h4 id="Concept_indirectly_readable"> Concept <a href="../iterator/indirectly_readable" title="cpp/iterator/indirectly readable"><code>indirectly_readable</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class In&gt;
    concept __indirectlyReadableImpl = // exposition only
      requires(const In in) {
        typename iter_value_t&lt;In&gt;;
        typename iter_reference_t&lt;In&gt;;
        typename iter_rvalue_reference_t&lt;In&gt;;
        { *in } -&gt; same_as&lt;iter_reference_t&lt;In&gt;&gt;
        { iter_move(in) } -&gt; same_as&lt;iter_rvalue_reference_t&lt;In&gt;&gt;
      } &amp;&amp;
      common_reference_with&lt;iter_reference_t&lt;In&gt;&amp;&amp;, iter_value_t&lt;In&gt;&amp;&gt; &amp;&amp;
      common_reference_with&lt;iter_reference_t&lt;In&gt;&amp;&amp;, iter_rvalue_reference_t&lt;In&gt;&amp;&amp;&gt; &amp;&amp;
      common_reference_with&lt;iter_rvalue_reference_t&lt;In&gt;&amp;&amp;, const iter_value_t&lt;In&gt;&amp;&gt;;
 
  template&lt;class In&gt;
    concept indirectly_readable =
      __indirectlyReadableImpl&lt;remove_cvref_t&lt;In&gt;&gt;
}</pre></div> <h4 id="Concept_indirectly_writable"> Concept <a href="../iterator/indirectly_writable" title="cpp/iterator/indirectly writable"><code>indirectly_writable</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class Out, class T&gt;
    concept indirectly_writable =
      requires(Out&amp;&amp; o, T&amp;&amp; t) {
        *o = std::forward&lt;T&gt;(t); // not required to be equality-preserving
        *std::forward&lt;Out&gt;(o) = std::forward&lt;T&gt;(t);
        // not required to be equality-preserving
        const_cast&lt;const iter_reference_t&lt;Out&gt;&amp;&amp;&gt;(*o) =
        std::forward&lt;T&gt;(t); // not required to be equality-preserving
        const_cast&lt;const iter_reference_t&lt;Out&gt;&amp;&amp;&gt;(*std::forward&lt;Out&gt;(o)) =
        std::forward&lt;T&gt;(t); // not required to be equality-preserving
      };
}</pre></div> <h4 id="Concept_weakly_incrementable"> Concept <a href="../iterator/weakly_incrementable" title="cpp/iterator/weakly incrementable"><code>weakly_incrementable</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class T&gt;
    inline constexpr bool __is_integer_like = /* see description */; // exposition only
 
  template&lt;class T&gt;
    inline constexpr bool __is_signed_integer_like =  // exposition only
      /* see description */;
 
  template&lt;class I&gt;
    concept weakly_incrementable =
      default_initializable&lt;I&gt; &amp;&amp; movable&lt;I&gt; &amp;&amp;
      requires(I i) {
        typename iter_difference_t&lt;I&gt;;
        requires __is_signed_integer_like&lt;iter_difference_t&lt;I&gt;&gt;;
        { ++i } -&gt; same_as&lt;I&amp;&gt;;   // not required to be equality-preserving
        i++;                      // not required to be equality-preserving
      };
}</pre></div> <h4 id="Concept_incrementable"> Concept <a href="../iterator/incrementable" title="cpp/iterator/incrementable"><code>incrementable</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class I&gt;
    concept incrementable =
      regular&lt;I&gt; &amp;&amp;
      weakly_incrementable&lt;I&gt; &amp;&amp;
      requires(I i) {
        { i++ } -&gt; same_as&lt;I&gt;;
      };
}</pre></div> <h4 id="Concept_input_or_output_iterator"> Concept <a href="../iterator/input_or_output_iterator" title="cpp/iterator/input or output iterator"><code>input_or_output_iterator</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class I&gt;
    concept input_or_output_iterator =
      requires(I i) {
        { *i } -&gt; can-reference;
      } &amp;&amp;
      weakly_incrementable&lt;I&gt;;
}</pre></div> <h4 id="Concept_sentinel_for"> Concept <a href="../iterator/sentinel_for" title="cpp/iterator/sentinel for"><code>sentinel_for</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class S, class I&gt;
    concept sentinel_for =
      semiregular&lt;S&gt; &amp;&amp;
      input_or_output_iterator&lt;I&gt; &amp;&amp;
      __WeaklyEqualityComparableWith&lt;S, I&gt;;
}</pre></div> <h4 id="Concept_sized_sentinel_for"> Concept <a href="../iterator/sized_sentinel_for" title="cpp/iterator/sized sentinel for"><code>sized_sentinel_for</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class S, class I&gt;
    concept sized_sentinel_for =
      sentinel_for&lt;S, I&gt; &amp;&amp;
      !disable_sized_sentinel&lt;remove_cv_t&lt;S&gt;, remove_cv_t&lt;I&gt;&gt; &amp;&amp;
      requires(const I&amp; i, const S&amp; s) {
        { s - i } -&gt; same_as&lt;iter_difference_t&lt;I&gt;&gt;;
        { i - s } -&gt; same_as&lt;iter_difference_t&lt;I&gt;&gt;;
      };
}</pre></div> <h4 id="Concept_input_iterator"> Concept <a href="../iterator/input_iterator" title="cpp/iterator/input iterator"><code>input_iterator</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class I&gt;
    concept input_iterator =
      input_or_output_iterator&lt;I&gt; &amp;&amp;
      indirectly_readable&lt;I&gt; &amp;&amp;
      requires { typename /*ITER_CONCEPT*/(I); } &amp;&amp;
      derived_from&lt;/*ITER_CONCEPT*/(I), input_iterator_tag&gt;;
}</pre></div> <h4 id="Concept_output_iterator"> Concept <a href="../iterator/output_iterator" title="cpp/iterator/output iterator"><code>output_iterator</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class I, class T&gt;
    concept output_iterator =
      input_or_output_iterator&lt;I&gt; &amp;&amp;
      indirectly_writable&lt;I, T&gt; &amp;&amp;
      requires(I i, T&amp;&amp; t) {
        *i++ = std::forward&lt;T&gt;(t); // not required to be equality-preserving
      };
}</pre></div> <h4 id="Concept_forward_iterator"> Concept <a href="../iterator/forward_iterator" title="cpp/iterator/forward iterator"><code>forward_iterator</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class I&gt;
    concept forward_iterator =
      input_iterator&lt;I&gt; &amp;&amp;
      derived_from&lt;/*ITER_CONCEPT*/(I), forward_iterator_tag&gt; &amp;&amp;
      incrementable&lt;I&gt; &amp;&amp;
      sentinel_for&lt;I, I&gt;;
}</pre></div> <h4 id="Concept_bidirectional_iterator"> Concept <a href="../iterator/bidirectional_iterator" title="cpp/iterator/bidirectional iterator"><code>bidirectional_iterator</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class I&gt;
    concept bidirectional_iterator =
      forward_iterator&lt;I&gt; &amp;&amp;
      derived_from&lt;/*ITER_CONCEPT*/(I), bidirectional_iterator_tag&gt; &amp;&amp;
      requires(I i) {
        { --i } -&gt; same_as&lt;I&amp;&gt;;
        { i-- } -&gt; same_as&lt;I&gt;;
      };
}</pre></div> <h4 id="Concept_random_access_iterator"> Concept <a href="../iterator/random_access_iterator" title="cpp/iterator/random access iterator"><code>random_access_iterator</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class I&gt;
    concept random_access_iterator =
      bidirectional_iterator&lt;I&gt; &amp;&amp;
      derived_from&lt;/*ITER_CONCEPT*/(I), random_access_iterator_tag&gt; &amp;&amp;
      totally_ordered&lt;I&gt; &amp;&amp;
      sized_sentinel_for&lt;I, I&gt; &amp;&amp;
      requires(I i, const I j, const iter_difference_t&lt;I&gt; n) {
        { i += n } -&gt; same_as&lt;I&amp;&gt;;
        { j +  n } -&gt; same_as&lt;I&gt;;
        { n +  j } -&gt; same_as&lt;I&gt;;
        { i -= n } -&gt; same_as&lt;I&amp;&gt;;
        { j -  n } -&gt; same_as&lt;I&gt;;
        {  j[n]  } -&gt; same_as&lt;iter_reference_t&lt;I&gt;&gt;;
      };
}</pre></div> <h4 id="Concept_contiguous_iterator"> Concept <a href="../iterator/contiguous_iterator" title="cpp/iterator/contiguous iterator"><code>contiguous_iterator</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class I&gt;
    concept contiguous_iterator =
      random_access_iterator&lt;I&gt; &amp;&amp;
      derived_from&lt;/*ITER_CONCEPT*/(I), contiguous_iterator_tag&gt; &amp;&amp;
      is_lvalue_reference_v&lt;iter_reference_t&lt;I&gt;&gt; &amp;&amp;
      same_as&lt;iter_value_t&lt;I&gt;, remove_cvref_t&lt;iter_reference_t&lt;I&gt;&gt;&gt; &amp;&amp;
      requires(const I&amp; i) {
        { to_address(i) } -&gt; same_as&lt;add_pointer_t&lt;iter_reference_t&lt;I&gt;&gt;&gt;;
      };
}</pre></div> <h4 id="Concept_indirectly_unary_invocable"> Concept <a href="../iterator/indirectly_unary_invocable" title="cpp/iterator/indirectly unary invocable"><code>indirectly_unary_invocable</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class F, class I&gt;
    concept indirectly_unary_invocable =
      indirectly_readable&lt;I&gt; &amp;&amp;
      copy_constructible&lt;F&gt; &amp;&amp;
      invocable&lt;F&amp;, iter_value_t&lt;I&gt;&amp;&gt; &amp;&amp;
      invocable&lt;F&amp;, iter_reference_t&lt;I&gt;&gt; &amp;&amp;
      invocable&lt;F&amp;, iter_common_reference_t&lt;I&gt;&gt; &amp;&amp;
      common_reference_with&lt;
        invoke_result_t&lt;F&amp;, iter_value_t&lt;I&gt;&amp;&gt;,
        invoke_result_t&lt;F&amp;, iter_reference_t&lt;I&gt;&gt;&gt;;
}</pre></div> <h4 id="Concept_indirectly_regular_unary_invocable"> Concept <a href="../iterator/indirectly_unary_invocable" title="cpp/iterator/indirectly unary invocable"><code>indirectly_regular_unary_invocable</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class F, class I&gt;
    concept indirectly_regular_unary_invocable =
      indirectly_readable&lt;I&gt; &amp;&amp;
      copy_constructible&lt;F&gt; &amp;&amp;
      regular_invocable&lt;F&amp;, iter_value_t&lt;I&gt;&amp;&gt; &amp;&amp;
      regular_invocable&lt;F&amp;, iter_reference_t&lt;I&gt;&gt; &amp;&amp;
      regular_invocable&lt;F&amp;, iter_common_reference_t&lt;I&gt;&gt; &amp;&amp;
      common_reference_with&lt;
        invoke_result_t&lt;F&amp;, iter_value_t&lt;I&gt;&amp;&gt;,
        invoke_result_t&lt;F&amp;, iter_reference_t&lt;I&gt;&gt;&gt;;
}</pre></div> <h4 id="Concept_indirect_unary_predicate"> Concept <a href="../iterator/indirect_unary_predicate" title="cpp/iterator/indirect unary predicate"><code>indirect_unary_predicate</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class F, class I&gt;
    concept indirect_unary_predicate =
      indirectly_readable&lt;I&gt; &amp;&amp;
      copy_constructible&lt;F&gt; &amp;&amp;
      predicate&lt;F&amp;, iter_value_t&lt;I&gt;&amp;&gt; &amp;&amp;
      predicate&lt;F&amp;, iter_reference_t&lt;I&gt;&gt; &amp;&amp;
      predicate&lt;F&amp;, iter_common_reference_t&lt;I&gt;&gt;;
}</pre></div> <h4 id="Concept_indirect_binary_predicate"> Concept <a href="../iterator/indirect_binary_predicate" title="cpp/iterator/indirect binary predicate"><code>indirect_binary_predicate</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class F, class I1, class I2 = I1&gt;
    concept indirect_binary_predicate =
      indirectly_readable&lt;I1&gt; &amp;&amp; indirectly_readable&lt;I2&gt; &amp;&amp;
      copy_constructible&lt;F&gt; &amp;&amp;
      predicate&lt;F&amp;, iter_value_t&lt;I1&gt;&amp;, iter_value_t&lt;I2&gt;&amp;&gt; &amp;&amp;
      predicate&lt;F&amp;, iter_value_t&lt;I1&gt;&amp;, iter_reference_t&lt;I2&gt;&gt; &amp;&amp;
      predicate&lt;F&amp;, iter_reference_t&lt;I1&gt;, iter_value_t&lt;I2&gt;&amp;&gt; &amp;&amp;
      predicate&lt;F&amp;, iter_reference_t&lt;I1&gt;, iter_reference_t&lt;I2&gt;&gt; &amp;&amp;
      predicate&lt;F&amp;, iter_common_reference_t&lt;I1&gt;, iter_common_reference_t&lt;I2&gt;&gt;;
}</pre></div> <h4 id="Concept_indirect_equivalence_relation"> Concept <a href="../iterator/indirect_equivalence_relation" title="cpp/iterator/indirect equivalence relation"><code>indirect_equivalence_relation</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class F, class I1, class I2 = I1&gt;
    concept indirect_equivalence_relation =
      indirectly_readable&lt;I1&gt; &amp;&amp; indirectly_readable&lt;I2&gt; &amp;&amp;
      copy_constructible&lt;F&gt; &amp;&amp;
      equivalence_relation&lt;F&amp;, iter_value_t&lt;I1&gt;&amp;, iter_value_t&lt;I2&gt;&amp;&gt; &amp;&amp;
      equivalence_relation&lt;F&amp;, iter_value_t&lt;I1&gt;&amp;, iter_reference_t&lt;I2&gt;&gt; &amp;&amp;
      equivalence_relation&lt;F&amp;, iter_reference_t&lt;I1&gt;, iter_value_t&lt;I2&gt;&amp;&gt; &amp;&amp;
      equivalence_relation&lt;F&amp;, iter_reference_t&lt;I1&gt;, iter_reference_t&lt;I2&gt;&gt; &amp;&amp;
      equivalence_relation&lt;F&amp;, iter_common_reference_t&lt;I1&gt;, iter_common_reference_t&lt;I2&gt;&gt;;
}</pre></div> <h4 id="Concept_indirect_strict_weak_order"> Concept <a href="../iterator/indirect_strict_weak_order" title="cpp/iterator/indirect strict weak order"><code>indirect_strict_weak_order</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class F, class I1, class I2 = I1&gt;
    concept indirect_strict_weak_order =
      indirectly_readable&lt;I1&gt; &amp;&amp; indirectly_readable&lt;I2&gt; &amp;&amp;
      copy_constructible&lt;F&gt; &amp;&amp;
      strict_weak_order&lt;F&amp;, iter_value_t&lt;I1&gt;&amp;, iter_value_t&lt;I2&gt;&amp;&gt; &amp;&amp;
      strict_weak_order&lt;F&amp;, iter_value_t&lt;I1&gt;&amp;, iter_reference_t&lt;I2&gt;&gt; &amp;&amp;
      strict_weak_order&lt;F&amp;, iter_reference_t&lt;I1&gt;, iter_value_t&lt;I2&gt;&amp;&gt; &amp;&amp;
      strict_weak_order&lt;F&amp;, iter_reference_t&lt;I1&gt;, iter_reference_t&lt;I2&gt;&gt; &amp;&amp;
      strict_weak_order&lt;F&amp;, iter_common_reference_t&lt;I1&gt;, iter_common_reference_t&lt;I2&gt;&gt;;
}</pre></div> <h4 id="Concept_indirectly_movable"> Concept <a href="../iterator/indirectly_movable" title="cpp/iterator/indirectly movable"><code>indirectly_movable</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class In, class Out&gt;
    concept indirectly_movable =
      indirectly_readable&lt;In&gt; &amp;&amp;
      indirectly_writable&lt;Out, iter_rvalue_reference_t&lt;In&gt;&gt;;
}</pre></div> <h4 id="Concept_indirectly_movable_storable"> Concept <a href="../iterator/indirectly_movable_storable" title="cpp/iterator/indirectly movable storable"><code>indirectly_movable_storable</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class In, class Out&gt;
    concept indirectly_movable_storable =
      indirectly_movable&lt;In, Out&gt; &amp;&amp;
      indirectly_writable&lt;Out, iter_value_t&lt;In&gt;&gt; &amp;&amp;
      movable&lt;iter_value_t&lt;In&gt;&gt; &amp;&amp;
      constructible_from&lt;iter_value_t&lt;In&gt;, iter_rvalue_reference_t&lt;In&gt;&gt; &amp;&amp;
      assignable_from&lt;iter_value_t&lt;In&gt;&amp;, iter_rvalue_reference_t&lt;In&gt;&gt;;
}</pre></div> <h4 id="Concept_indirectly_copyable"> Concept <a href="../iterator/indirectly_copyable" title="cpp/iterator/indirectly copyable"><code>indirectly_copyable</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class In, class Out&gt;
    concept indirectly_copyable =
      indirectly_readable&lt;In&gt; &amp;&amp;
      indirectly_writable&lt;Out, iter_reference_t&lt;In&gt;&gt;;
}</pre></div> <h4 id="Concept_indirectly_copyable_storable"> Concept <a href="../iterator/indirectly_copyable_storable" title="cpp/iterator/indirectly copyable storable"><code>indirectly_copyable_storable</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class In, class Out&gt;
    concept indirectly_copyable_storable =
      indirectly_copyable&lt;In, Out&gt; &amp;&amp;
      indirectly_writable&lt;Out, iter_value_t&lt;In&gt;&amp;&gt; &amp;&amp;
      indirectly_writable&lt;Out, const iter_value_t&lt;In&gt;&amp;&gt; &amp;&amp;
      indirectly_writable&lt;Out, iter_value_t&lt;In&gt;&amp;&amp;&gt; &amp;&amp;
      indirectly_writable&lt;Out, const iter_value_t&lt;In&gt;&amp;&amp;&gt; &amp;&amp;
      copyable&lt;iter_value_t&lt;In&gt;&gt; &amp;&amp;
      constructible_from&lt;iter_value_t&lt;In&gt;, iter_reference_t&lt;In&gt;&gt; &amp;&amp;
      assignable_from&lt;iter_value_t&lt;In&gt;&amp;, iter_reference_t&lt;In&gt;&gt;;
}</pre></div> <h4 id="Concept_indirectly_swappable"> Concept <a href="../iterator/indirectly_swappable" title="cpp/iterator/indirectly swappable"><code>indirectly_swappable</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class I1, class I2 = I1&gt;
    concept indirectly_swappable =
      indirectly_readable&lt;I1&gt; &amp;&amp; indirectly_readable&lt;I2&gt; &amp;&amp;
      requires(const I1 i1, const I2 i2) {
        ranges::iter_swap(i1, i1);
        ranges::iter_swap(i2, i2);
        ranges::iter_swap(i1, i2);
        ranges::iter_swap(i2, i1);
      };
}</pre></div> <h4 id="Concept_indirectly_comparable"> Concept <a href="../iterator/indirectly_comparable" title="cpp/iterator/indirectly comparable"><code>indirectly_comparable</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class I1, class I2, class R, class P1 = identity, class P2 = identity&gt;
    concept indirectly_comparable =
      indirect_predicate&lt;R, projected&lt;I1, P1&gt;, projected&lt;I2, P2&gt;&gt;;
}</pre></div> <h4 id="Concept_permutable"> Concept <a href="../iterator/permutable" title="cpp/iterator/permutable"><code>permutable</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class I&gt;
    concept permutable =
      forward_iterator&lt;I&gt; &amp;&amp;
      indirectly_movable_storable&lt;I, I&gt; &amp;&amp;
      indirectly_swappable&lt;I, I&gt;;
}</pre></div> <h4 id="Concept_mergeable"> Concept <a href="../iterator/mergeable" title="cpp/iterator/mergeable"><code>mergeable</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class I1, class I2, class Out, class R = ranges::less,
           class P1 = identity, class P2 = identity&gt;
    concept mergeable =
      input_iterator&lt;I1&gt; &amp;&amp;
      input_iterator&lt;I2&gt; &amp;&amp;
      weakly_incrementable&lt;Out&gt; &amp;&amp;
      indirectly_copyable&lt;I1, Out&gt; &amp;&amp;
      indirectly_copyable&lt;I2, Out&gt; &amp;&amp;
      indirect_strict_weak_order&lt;R, projected&lt;I1, P1&gt;, projected&lt;I2, P2&gt;&gt;;
}</pre></div> <h4 id="Concept_sortable"> Concept <a href="../iterator/sortable" title="cpp/iterator/sortable"><code>sortable</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class I, class R = ranges::less, class P = identity&gt;
    concept sortable =
      permutable&lt;I&gt; &amp;&amp;
      indirect_strict_weak_order&lt;R, projected&lt;I, P&gt;&gt;;
}</pre></div> <h4 id="Class_template_std::incrementable_traits"> Class template <code><a href="../iterator/incrementable_traits" title="cpp/iterator/incrementable traits">std::incrementable_traits</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class&gt; struct incrementable_traits { };
 
  template&lt;class T&gt;
    requires is_object_v&lt;T&gt;
  struct incrementable_traits&lt;T*&gt; {
    using difference_type = ptrdiff_t;
  };
 
  template&lt;class I&gt;
  struct incrementable_traits&lt;const I&gt;
    : incrementable_traits&lt;I&gt; { };
 
  template&lt;class T&gt;
    requires requires { typename T::difference_type; }
  struct incrementable_traits&lt;T&gt; {
    using difference_type = typename T::difference_type;
  };
 
  template&lt;class T&gt;
    requires (!requires { typename T::difference_type; } &amp;&amp;
              requires(const T&amp; a, const T&amp; b) { { a - b } -&gt; integral; })
  struct incrementable_traits&lt;T&gt; {
    using difference_type = make_signed_t&lt;decltype(declval&lt;T&gt;() - declval&lt;T&gt;())&gt;;
  };
 
  template&lt;class T&gt;
    using iter_difference_t = /* see description */;
}</pre></div> <h4 id="Class_template_std::indirectly_readable_traits"> Class template <code><a href="../iterator/indirectly_readable_traits" title="cpp/iterator/indirectly readable traits">std::indirectly_readable_traits</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class&gt; struct __cond_value_type { };   // exposition only
  template&lt;class T&gt;
    requires is_object_v&lt;T&gt;
  struct __cond_value_type {
    using value_type = remove_cv_t&lt;T&gt;;
  };
 
  template&lt;class&gt; struct indirectly_readable_traits { };
 
  template&lt;class T&gt;
  struct indirectly_readable_traits&lt;T*&gt;
    : __cond_value_type&lt;T&gt; { };
 
  template&lt;class I&gt;
    requires is_array_v&lt;I&gt;
  struct indirectly_readable_traits&lt;I&gt; {
    using value_type = remove_cv_t&lt;remove_extent_t&lt;I&gt;&gt;;
  };
 
  template&lt;class I&gt;
  struct indirectly_readable_traits&lt;const I&gt;
    : indirectly_readable_traits&lt;I&gt; { };
 
  template&lt;class T&gt;
    requires requires { typename T::value_type; }
  struct indirectly_readable_traits&lt;T&gt;
    : __cond_value_type&lt;typename T::value_type&gt; { };
 
  template&lt;class T&gt;
    requires requires { typename T::element_type; }
  struct indirectly_readable_traits&lt;T&gt;
    : __cond_value_type&lt;typename T::element_type&gt; { };
}</pre></div> <h4 id="Class_template_std::projected"> Class template <code><a href="../iterator/projected" title="cpp/iterator/projected">std::projected</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;indirectly_readable I, indirectly_regular_unary_invocable&lt;I&gt; Proj&gt;
  struct projected {
    using value_type = remove_cvref_t&lt;indirect_result_t&lt;Proj&amp;, I&gt;&gt;;
    indirect_result_t&lt;Proj&amp;, I&gt; operator*() const; // not defined
  };
 
  template&lt;weakly_incrementable I, class Proj&gt;
  struct incrementable_traits&lt;projected&lt;I, Proj&gt;&gt; {
    using difference_type = iter_difference_t&lt;I&gt;;
  };
}</pre></div> <h4 id="Class_template_std::iterator_traits"> Class template <code><a href="../iterator/iterator_traits" title="cpp/iterator/iterator traits">std::iterator_traits</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class I&gt;
  struct iterator_traits {
    using iterator_category = /* see description */;
    using value_type        = /* see description */;
    using difference_type   = /* see description */;
    using pointer           = /* see description */;
    using reference         = /* see description */;
  };
 
  template&lt;class T&gt;
    requires is_object_v&lt;T&gt;
  struct iterator_traits&lt;T*&gt; {
    using iterator_concept  = contiguous_iterator_tag;
    using iterator_category = random_access_iterator_tag;
    using value_type        = remove_cv_t&lt;T&gt;;
    using difference_type   = ptrdiff_t;
    using pointer           = T*;
    using reference         = T&amp;;
  };
}</pre></div> <h4 id="Iterator_tags"> Iterator tags</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  struct input_iterator_tag { };
  struct output_iterator_tag { };
  struct forward_iterator_tag: public input_iterator_tag { };
  struct bidirectional_iterator_tag: public forward_iterator_tag { };
  struct random_access_iterator_tag: public bidirectional_iterator_tag { };
  struct contiguous_iterator_tag: public random_access_iterator_tag { };
}</pre></div> <h4 id="Class_template_std::reverse_iterator"> Class template <code><a href="../iterator/reverse_iterator" title="cpp/iterator/reverse iterator">std::reverse_iterator</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class Iter&gt;
  class reverse_iterator {
  public:
    using iterator_type     = Iter;
    using iterator_concept  = /* see description */;
    using iterator_category = /* see description */;
    using value_type        = iter_value_t&lt;Iter&gt;;
    using difference_type   = iter_difference_t&lt;Iter&gt;;
    using pointer           = typename iterator_traits&lt;Iter&gt;::pointer;
    using reference         = iter_reference_t&lt;Iter&gt;;
 
    constexpr reverse_iterator();
    constexpr explicit reverse_iterator(Iter x);
    template&lt;class U&gt; constexpr reverse_iterator(const reverse_iterator&lt;U&gt;&amp; u);
    template&lt;class U&gt; constexpr reverse_iterator&amp; operator=(const reverse_iterator&lt;U&gt;&amp; u);
 
    constexpr Iter base() const;
    constexpr reference operator*() const;
    constexpr pointer   operator-&gt;() const requires /* see description */;
 
    constexpr reverse_iterator&amp; operator++();
    constexpr reverse_iterator  operator++(int);
    constexpr reverse_iterator&amp; operator--();
    constexpr reverse_iterator  operator--(int);
 
    constexpr reverse_iterator  operator+ (difference_type n) const;
    constexpr reverse_iterator&amp; operator+=(difference_type n);
    constexpr reverse_iterator  operator- (difference_type n) const;
    constexpr reverse_iterator&amp; operator-=(difference_type n);
    constexpr /* unspecified */ operator[](difference_type n) const;
 
    friend constexpr iter_rvalue_reference_t&lt;Iter&gt;
      iter_move(const reverse_iterator&amp; i) noexcept(/* see description */);
    template&lt;indirectly_swappable&lt;Iter&gt; Iter2&gt;
      friend constexpr void
        iter_swap(const reverse_iterator&amp; x,
                  const reverse_iterator&lt;Iter2&gt;&amp; y) noexcept(/* see description */);
 
  protected:
    Iter current;
  };
}</pre></div> <h4 id="Class_template_std::back_insert_iterator"> Class template <code><a href="../iterator/back_insert_iterator" title="cpp/iterator/back insert iterator">std::back_insert_iterator</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class Container&gt;
  class back_insert_iterator {
  protected:
    Container* container = nullptr;
 
  public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;
    using difference_type   = ptrdiff_t;
    using pointer           = void;
    using reference         = void;
    using container_type    = Container;
 
    constexpr back_insert_iterator() noexcept = default;
    constexpr explicit back_insert_iterator(Container&amp; x);
    constexpr back_insert_iterator&amp; operator=(const typename Container::value_type&amp; value);
    constexpr back_insert_iterator&amp; operator=(typename Container::value_type&amp;&amp; value);
 
    constexpr back_insert_iterator&amp; operator*();
    constexpr back_insert_iterator&amp; operator++();
    constexpr back_insert_iterator  operator++(int);
  };
}</pre></div> <h4 id="Class_template_std::front_insert_iterator"> Class template <code><a href="../iterator/front_insert_iterator" title="cpp/iterator/front insert iterator">std::front_insert_iterator</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class Container&gt;
  class front_insert_iterator {
  protected:
    Container* container = nullptr;
 
  public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;
    using difference_type   = ptrdiff_t;
    using pointer           = void;
    using reference         = void;
    using container_type    = Container;
 
    constexpr front_insert_iterator(Container&amp; x) noexcept = default;
    constexpr explicit front_insert_iterator(Container&amp; x);
    constexpr front_insert_iterator&amp;
      operator=(const typename Container::value_type&amp; value);
    constexpr front_insert_iterator&amp; operator=(typename Container::value_type&amp;&amp; value);
 
    constexpr front_insert_iterator&amp; operator*();
    constexpr front_insert_iterator&amp; operator++();
    constexpr front_insert_iterator  operator++(int);
  };
}</pre></div> <h4 id="Class_template_std::insert_iterator"> Class template <code><a href="../iterator/insert_iterator" title="cpp/iterator/insert iterator">std::insert_iterator</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class Container&gt;
  class insert_iterator {
  protected:
    Container* container = nullptr;
    ranges::iterator_t&lt;Container&gt; iter = ranges::iterator_t&lt;Container&gt;();
 
  public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;
    using difference_type   = ptrdiff_t;
    using pointer           = void;
    using reference         = void;
    using container_type    = Container;
 
    insert_iterator() = default;
    constexpr insert_iterator(Container&amp; x, ranges::iterator_t&lt;Container&gt; i);
    constexpr insert_iterator&amp; operator=(const typename Container::value_type&amp; value);
    constexpr insert_iterator&amp; operator=(typename Container::value_type&amp;&amp; value);
 
    constexpr insert_iterator&amp; operator*();
    constexpr insert_iterator&amp; operator++();
    constexpr insert_iterator&amp; operator++(int);
  };
}</pre></div> <h4 id="Class_template_std::move_iterator"> Class template <code><a href="../iterator/move_iterator" title="cpp/iterator/move iterator">std::move_iterator</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class Iter&gt;
  class move_iterator {
  public:
    using iterator_type     = Iter;
    using iterator_concept  = /* see description */;
    using iterator_category = /* see description */;
    using value_type        = iter_value_t&lt;Iter&gt;;
    using difference_type   = iter_difference_t&lt;Iter&gt;;
    using pointer           = Iter;
    using reference         = iter_rvalue_reference_t&lt;Iter&gt;;
 
    constexpr move_iterator();
    constexpr explicit move_iterator(Iter i);
    template&lt;class U&gt; constexpr move_iterator(const move_iterator&lt;U&gt;&amp; u);
    template&lt;class U&gt; constexpr move_iterator&amp; operator=(const move_iterator&lt;U&gt;&amp; u);
 
    constexpr iterator_type base() const &amp;;
    constexpr iterator_type base() &amp;&amp;;
    constexpr reference operator*() const;
    constexpr pointer operator-&gt;() const;
 
    constexpr move_iterator&amp; operator++();
    constexpr auto operator++(int);
    constexpr move_iterator&amp; operator--();
    constexpr move_iterator operator--(int);
 
    constexpr move_iterator operator+(difference_type n) const;
    constexpr move_iterator&amp; operator+=(difference_type n);
    constexpr move_iterator operator-(difference_type n) const;
    constexpr move_iterator&amp; operator-=(difference_type n);
    constexpr reference operator[](difference_type n) const;
 
    template&lt;sentinel_for&lt;Iter&gt; S&gt;
      friend constexpr bool
        operator==(const move_iterator&amp; x, const move_sentinel&lt;S&gt;&amp; y);
    template&lt;sized_sentinel_for&lt;Iter&gt; S&gt;
      friend constexpr iter_difference_t&lt;Iter&gt;
        operator-(const move_sentinel&lt;S&gt;&amp; x, const move_iterator&amp; y);
    template&lt;sized_sentinel_for&lt;Iter&gt; S&gt;
      friend constexpr iter_difference_t&lt;Iter&gt;
        operator-(const move_iterator&amp; x, const move_sentinel&lt;S&gt;&amp; y);
    friend constexpr iter_rvalue_reference_t&lt;Iter&gt;
      iter_move(const move_iterator&amp; i)
        noexcept(noexcept(ranges::iter_move(i.current)));
    template&lt;indirectly_swappable&lt;Iter&gt; Iter2&gt;
      friend constexpr void
        iter_swap(const move_iterator&amp; x, const move_iterator&lt;Iter2&gt;&amp; y)
          noexcept(noexcept(ranges::iter_swap(x.current, y.current)));
 
  private:
    Iter current;     // exposition only
  };
}</pre></div> <h4 id="Class_template_std::move_sentinel"> Class template <code><a href="../iterator/move_sentinel" title="cpp/iterator/move sentinel">std::move_sentinel</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;semiregular S&gt;
  class move_sentinel {
  public:
    constexpr move_sentinel();
    constexpr explicit move_sentinel(S s);
    template&lt;class S2&gt;
      requires convertible_to&lt;const S2&amp;, S&gt;
        constexpr move_sentinel(const move_sentinel&lt;S2&gt;&amp; s);
    template&lt;class S2&gt;
      requires assignable_from&lt;S&amp;, const S2&amp;&gt;
        constexpr move_sentinel&amp; operator=(const move_sentinel&lt;S2&gt;&amp; s);
 
    constexpr S base() const;
  private:
    S last;     // exposition only
  };
}</pre></div> <h4 id="Class_template_std::common_iterator"> Class template <code><a href="../iterator/common_iterator" title="cpp/iterator/common iterator">std::common_iterator</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;input_or_output_iterator I, sentinel_for&lt;I&gt; S&gt;
    requires (!same_as&lt;I, S&gt; &amp;&amp; copyable&lt;I&gt;)
  class common_iterator {
  public:
    constexpr common_iterator() = default;
    constexpr common_iterator(I i);
    constexpr common_iterator(S s);
    template&lt;class I2, class S2&gt;
      requires convertible_to&lt;const I2&amp;, I&gt; &amp;&amp; convertible_to&lt;const S2&amp;, S&gt;
        constexpr common_iterator(const common_iterator&lt;I2, S2&gt;&amp; x);
 
    template&lt;class I2, class S2&gt;
      requires convertible_to&lt;const I2&amp;, I&gt; &amp;&amp; convertible_to&lt;const S2&amp;, S&gt; &amp;&amp;
               assignable_from&lt;I&amp;, const I2&amp;&gt; &amp;&amp; assignable_from&lt;S&amp;, const S2&amp;&gt;
        common_iterator&amp; operator=(const common_iterator&lt;I2, S2&gt;&amp; x);
 
    decltype(auto) operator*();
    decltype(auto) operator*() const
      requires dereferenceable&lt;const I&gt;;
    decltype(auto) operator-&gt;() const
      requires /* see description */;
 
    common_iterator&amp; operator++();
    decltype(auto) operator++(int);
 
    template&lt;class I2, sentinel_for&lt;I&gt; S2&gt;
      requires sentinel_for&lt;S, I2&gt;
    friend bool operator==(
      const common_iterator&amp; x, const common_iterator&lt;I2, S2&gt;&amp; y);
    template&lt;class I2, sentinel_for&lt;I&gt; S2&gt;
      requires sentinel_for&lt;S, I2&gt; &amp;&amp; equality_comparable_with&lt;I, I2&gt;
    friend bool operator==(
      const common_iterator&amp; x, const common_iterator&lt;I2, S2&gt;&amp; y);
 
    template&lt;sized_sentinel_for&lt;I&gt; I2, sized_sentinel_for&lt;I&gt; S2&gt;
      requires sized_sentinel_for&lt;S, I2&gt;
    friend iter_difference_t&lt;I2&gt; operator-(
      const common_iterator&amp; x, const common_iterator&lt;I2, S2&gt;&amp; y);
 
    friend iter_rvalue_reference_t&lt;I&gt; iter_move(const common_iterator&amp; i)
      noexcept(noexcept(ranges::iter_move(declval&lt;const I&amp;&gt;())))
        requires input_iterator&lt;I&gt;;
    template&lt;indirectly_swappable&lt;I&gt; I2, class S2&gt;
      friend void iter_swap(const common_iterator&amp; x, const common_iterator&lt;I2, S2&gt;&amp; y)
        noexcept(noexcept(ranges::iter_swap(declval&lt;const I&amp;&gt;(), declval&lt;const I2&amp;&gt;())));
 
  private:
    variant&lt;I, S&gt; v_;   // exposition only
  };
 
  template&lt;class I, class S&gt;
  struct incrementable_traits&lt;common_iterator&lt;I, S&gt;&gt; {
    using difference_type = iter_difference_t&lt;I&gt;;
  };
 
  template&lt;input_iterator I, class S&gt;
  struct iterator_traits&lt;common_iterator&lt;I, S&gt;&gt; {
    using iterator_concept = /* see description */;
    using iterator_category = /* see description */;
    using value_type = iter_value_t&lt;I&gt;;
    using difference_type = iter_difference_t&lt;I&gt;;
    using pointer = /* see description */;
    using reference = iter_reference_t&lt;I&gt;;
  };
}</pre></div> <h4 id="Class_std::default_sentinel_t"> Class <code><a href="../iterator/default_sentinel_t" title="cpp/iterator/default sentinel t">std::default_sentinel_t</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  struct default_sentinel_t { };
}</pre></div> <h4 id="Class_template_std::counted_iterator"> Class template <code><a href="../iterator/counted_iterator" title="cpp/iterator/counted iterator">std::counted_iterator</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;input_or_output_iterator I&gt;
  class counted_iterator {
  public:
    using iterator_type = I;
 
    constexpr counted_iterator() = default;
    constexpr counted_iterator(I x, iter_difference_t&lt;I&gt; n);
    template&lt;class I2&gt;
      requires convertible_to&lt;const I2&amp;, I&gt;
        constexpr counted_iterator(const counted_iterator&lt;I2&gt;&amp; x);
 
    template&lt;class I2&gt;
      requires assignable_from&lt;I&amp;, const I2&amp;&gt;
        constexpr counted_iterator&amp; operator=(const counted_iterator&lt;I2&gt;&amp; x);
 
    constexpr I base() const &amp; requires copy_constructible&lt;I&gt;;
    constexpr I base() &amp;&amp;;
    constexpr iter_difference_t&lt;I&gt; count() const noexcept;
    constexpr decltype(auto) operator*();
    constexpr decltype(auto) operator*() const
      requires dereferenceable&lt;const I&gt;;
    constexpr auto operator-&gt;() const noexcept
      requires contiguous_iterator&lt;I&gt;;
 
    constexpr counted_iterator&amp; operator++();
    decltype(auto) operator++(int);
    constexpr counted_iterator operator++(int)
      requires forward_iterator&lt;I&gt;;
    constexpr counted_iterator&amp; operator--()
      requires bidirectional_iterator&lt;I&gt;;
    constexpr counted_iterator operator--(int)
      requires bidirectional_iterator&lt;I&gt;;
 
    constexpr counted_iterator operator+(iter_difference_t&lt;I&gt; n) const
      requires random_access_iterator&lt;I&gt;;
    friend constexpr counted_iterator operator+(
      iter_difference_t&lt;I&gt; n, const counted_iterator&amp; x)
        requires random_access_iterator&lt;I&gt;;
    constexpr counted_iterator&amp; operator+=(iter_difference_t&lt;I&gt; n)
      requires random_access_iterator&lt;I&gt;;
 
    constexpr counted_iterator operator-(iter_difference_t&lt;I&gt; n) const
      requires random_access_iterator&lt;I&gt;;
    template&lt;common_with&lt;I&gt; I2&gt;
      friend constexpr iter_difference_t&lt;I2&gt; operator-(
        const counted_iterator&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
    friend constexpr iter_difference_t&lt;I&gt; operator-(
      const counted_iterator&amp; x, default_sentinel_t);
    friend constexpr iter_difference_t&lt;I&gt; operator-(
      default_sentinel_t, const counted_iterator&amp; y);
    constexpr counted_iterator&amp; operator-=(iter_difference_t&lt;I&gt; n)
      requires random_access_iterator&lt;I&gt;;
 
    constexpr decltype(auto) operator[](iter_difference_t&lt;I&gt; n) const
      requires random_access_iterator&lt;I&gt;;
 
    template&lt;common_with&lt;I&gt; I2&gt;
      friend constexpr bool operator==(
        const counted_iterator&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
    friend constexpr bool operator==(
      const counted_iterator&amp; x, default_sentinel_t);
 
    template&lt;common_with&lt;I&gt; I2&gt;
      friend constexpr strong_ordering operator&lt;=&gt;(
        const counted_iterator&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
 
    friend constexpr iter_rvalue_reference_t&lt;I&gt; iter_move(const counted_iterator&amp; i)
      noexcept(noexcept(ranges::iter_move(i.current)))
        requires input_iterator&lt;I&gt;;
    template&lt;indirectly_swappable&lt;I&gt; I2&gt;
      friend constexpr void iter_swap(const counted_iterator&amp; x,
                                      const counted_iterator&lt;I2&gt;&amp; y)
        noexcept(noexcept(ranges::iter_swap(x.current, y.current)));
 
  private:
    I current = I();                    // exposition only
    iter_difference_t&lt;I&gt; length = 0;    // exposition only
  };
 
  template&lt;input_iterator I&gt;
  struct iterator_traits&lt;counted_iterator&lt;I&gt;&gt; : iterator_traits&lt;I&gt; {
    using pointer = void;
  };
}</pre></div> <h4 id="Class_std::unreachable_sentinel_t"> Class <code><a href="../iterator/unreachable_sentinel_t" title="cpp/iterator/unreachable sentinel t">std::unreachable_sentinel_t</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  struct unreachable_sentinel_t {
    template&lt;weakly_incrementable I&gt;
      friend constexpr bool operator==(unreachable_sentinel_t, const I&amp;) noexcept
      { return false; }
  };
}</pre></div> <h4 id="Class_template_std::istream_iterator"> Class template <code><a href="../iterator/istream_iterator" title="cpp/iterator/istream iterator">std::istream_iterator</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class T, class CharT = char, class Traits = char_traits&lt;CharT&gt;,
           class Distance = ptrdiff_t&gt;
  class istream_iterator {
  public:
    using iterator_category = input_iterator_tag;
    using value_type        = T;
    using difference_type   = Distance;
    using pointer           = const T*;
    using reference         = const T&amp;;
    using char_type         = CharT;
    using traits_type       = Traits;
    using istream_type      = basic_istream&lt;CharT, Traits&gt;;
 
    constexpr istream_iterator();
    constexpr istream_iterator(default_sentinel_t);
    istream_iterator(istream_type&amp; s);
    istream_iterator(const istream_iterator&amp; x) = default;
    ~istream_iterator() = default;
    istream_iterator&amp; operator=(const istream_iterator&amp;) = default;
 
    const T&amp; operator*() const;
    const T* operator-&gt;() const;
    istream_iterator&amp; operator++();
    istream_iterator  operator++(int);
 
    friend bool operator==(const istream_iterator&amp; i, default_sentinel_t);
 
  private:
    basic_istream&lt;CharT, Traits&gt;* in_stream; // exposition only
    T value;                                 // exposition only
  };
}</pre></div> <h4 id="Class_template_std::ostream_iterator"> Class template <code><a href="../iterator/ostream_iterator" title="cpp/iterator/ostream iterator">std::ostream_iterator</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class T, class CharT = char, classTraits = char_traits&lt;CharT&gt;&gt;
  class ostream_iterator {
  public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;
    using difference_type   = ptrdiff_t;
    using pointer           = void;
    using reference         = void;
    using char_type         = CharT;
    using traits_type       = Traits;
    using ostream_type      = basic_ostream&lt;CharT, Traits&gt;;
 
    constexpr ostreambuf_iterator() noexcept = default;
    ostream_iterator(ostream_type&amp; s);
    ostream_iterator(ostream_type&amp; s, const CharT* delimiter);
    ostream_iterator(const ostream_iterator&amp; x);
    ~ostream_iterator();
    ostream_iterator&amp; operator=(const ostream_iterator&amp;) = default;
    ostream_iterator&amp; operator=(const T&amp; value);
 
    ostream_iterator&amp; operator*();
    ostream_iterator&amp; operator++();
    ostream_iterator&amp; operator++(int);
 
  private:
    basic_ostream&lt;CharT, Traits&gt;* out_stream = nullptr;          // exposition only
    const CharT* delim = nullptr;                                // exposition only
  };
}</pre></div> <h4 id="Class_template_std::istreambuf_iterator"> Class template <code><a href="../iterator/istreambuf_iterator" title="cpp/iterator/istreambuf iterator">std::istreambuf_iterator</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class CharT, class Traits = char_traits&lt;CharT&gt;&gt;
  class istreambuf_iterator {
  public:
    using iterator_category = input_iterator_tag;
    using value_type        = CharT;
    using difference_type   = typename Traits::off_type;
    using pointer           = /* unspecified */;
    using reference         = CharT;
    using char_type         = CharT;
    using traits_type       = Traits;
    using int_type          = typename Traits::int_type;
    using streambuf_type    = basic_streambuf&lt;CharT, Traits&gt;;
    using istream_type      = basic_istream&lt;CharT, Traits&gt;;
 
    class proxy;                          // exposition only
 
    constexpr istreambuf_iterator() noexcept;
    constexpr istreambuf_iterator(default_sentinel_t) noexcept;
    istreambuf_iterator(const istreambuf_iterator&amp;) noexcept = default;
    ~istreambuf_iterator() = default;
    istreambuf_iterator(istream_type&amp; s) noexcept;
    istreambuf_iterator(streambuf_type* s) noexcept;
    istreambuf_iterator(const proxy&amp; p) noexcept;
    istreambuf_iterator&amp; operator=(const istreambuf_iterator&amp;) noexcept = default;
    CharT operator*() const;
    istreambuf_iterator&amp; operator++();
    proxy operator++(int);
    bool equal(const istreambuf_iterator&amp; b) const;
 
    friend bool operator==(const istreambuf_iterator&amp; i, default_sentinel_t s);
 
  private:
    streambuf_type* sbuf_;                // exposition only
  };
 
  template&lt;class CharT, class Traits&gt;
  class istreambuf_iterator&lt;CharT, Traits&gt;::proxy { // exposition only
    CharT keep_;
    basic_streambuf&lt;CharT, Traits&gt;* sbuf_;
    proxy(CharT c, basic_streambuf&lt;CharT, Traits&gt;* sbuf)
      : keep_(c), sbuf_(sbuf) { }
  public:
    CharT operator*() { return keep_; }
  };
}</pre></div> <h4 id="Class_template_std::ostreambuf_iterator"> Class template <code><a href="../iterator/ostreambuf_iterator" title="cpp/iterator/ostreambuf iterator">std::ostreambuf_iterator</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class CharT, class Traits = char_traits&lt;CharT&gt;&gt;
  class ostreambuf_iterator {
  public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;
    using difference_type   = ptrdiff_t;
    using pointer           = void;
    using reference         = void;
    using char_type         = CharT;
    using traits_type       = Traits;
    using streambuf_type    = basic_streambuf&lt;CharT, Traits&gt;;
    using ostream_type      = basic_ostream&lt;CharT, Traits&gt;;
 
    constexpr ostreambuf_iterator() noexcept = default;
    ostreambuf_iterator(ostream_type&amp; s) noexcept;
    ostreambuf_iterator(streambuf_type* s) noexcept;
    ostreambuf_iterator&amp; operator=(CharT c);
 
    ostreambuf_iterator&amp; operator*();
    ostreambuf_iterator&amp; operator++();
    ostreambuf_iterator&amp; operator++(int);
    bool failed() const noexcept;
 
  private:
    streambuf_type* sbuf_ = nullptr;    // exposition only
  };
}</pre></div> <h4 id="Class_template_std::iterator"> Class template <code><a href="../iterator/iterator" title="cpp/iterator/iterator">std::iterator</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class Category, class T, class Distance = ptrdiff_t,
           class Pointer = T*, class Reference = T&amp;&gt;
  struct iterator {
    typedef Category  iterator_category;
    typedef T         value_type;
    typedef Distance  difference_type;
    typedef Pointer   pointer;
    typedef Reference reference;
  };
}</pre></div> <h3 id="Defect_reports"> Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th> DR </th> <th> Applied to </th> <th> Behavior as published </th> <th> Correct behavior </th>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue349">LWG 349</a> </td> <td> C++98 </td> <td> the exposition-only member <code>delim</code> of<br><code><a href="../iterator/ostream_iterator" title="cpp/iterator/ostream iterator">std::ostream_iterator</a></code> had type <span class="kw4">const</span> <span class="kw4">char</span><span class="sy2">*</span> </td> <td> corrected to <span class="kw4">const</span> CharT<span class="sy2">*</span> </td>
</tr>
</table>           <div class="_attribution">
  <p class="_attribution-p">
    © cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/header/iterator" class="_attribution-link">https://en.cppreference.com/w/cpp/header/iterator</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
