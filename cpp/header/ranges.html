
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Ranges - C++ - W3cubDocs</title>
  
  <meta name="description" content=" This header is part of the ranges library. ">
  <meta name="keywords" content="standard, library, header, ranges, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/header/ranges.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-9c7b0d969c0ce639a6c01c2badcdd81667c7c66206aa3d0fccc5cb0585fb1b912dab72ea882101d18010680927514b4b77b107282db8f756fbf63301fe9c88b0.css">
  <script type="text/javascript" src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js"></script>
  <script src="/json/cpp.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _cppref">
				
				
<h1 id="firstHeading" class="firstHeading">Standard library header &lt;ranges&gt; <span class="t-mark-rev t-since-cxx20">(C++20)</span>
</h1>            <p>This header is part of the <a href="../ranges" title="cpp/ranges">ranges</a> library.</p>
<h3 id="Namespace_aliases"> Namespace aliases</h3> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">namespace std {
    namespace views = ranges::views;
}</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <p>The namespace alias <code>std::views</code> is provided as a shorthand for <code>std::ranges::views</code>.</p>
<table class="t-dsc-begin"> <tr> <td colspan="2"> <h3 id="Concepts"> Concepts</h3> </td>
</tr> <tr> <td colspan="2"> <h5 id="Range_concepts">  Range concepts </h5> </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in namespace <code>std::ranges</code>  </th>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/range" title="cpp/ranges/range"> <span class="t-lines"><span>ranges::range</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies that a type is a range, that is, it provides a <code>begin</code> iterator and an <code>end</code> sentinel <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/borrowed_range" title="cpp/ranges/borrowed range"> <span class="t-lines"><span>ranges::borrowed_range</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies that a type is a <a href="../ranges/range" title="cpp/ranges/range"><code>range</code></a> and iterators obtained from an expression of it can be safely returned without danger of dangling <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/sized_range" title="cpp/ranges/sized range"> <span class="t-lines"><span>ranges::sized_range</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies that a range knows its size in constant time <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/view" title="cpp/ranges/view"> <span class="t-lines"><span>ranges::view</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies that a range is a view, that is, it has constant time copy/move/assignment <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/input_range" title="cpp/ranges/input range"> <span class="t-lines"><span>ranges::input_range</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies a range whose iterator type satisfies <a href="../iterator/input_iterator" title="cpp/iterator/input iterator"><code>input_iterator</code></a> <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/output_range" title="cpp/ranges/output range"> <span class="t-lines"><span>ranges::output_range</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies a range whose iterator type satisfies <a href="../iterator/output_iterator" title="cpp/iterator/output iterator"><code>output_iterator</code></a> <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/forward_range" title="cpp/ranges/forward range"> <span class="t-lines"><span>ranges::forward_range</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies a range whose iterator type satisfies <a href="../iterator/forward_iterator" title="cpp/iterator/forward iterator"><code>forward_iterator</code></a> <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/bidirectional_range" title="cpp/ranges/bidirectional range"> <span class="t-lines"><span>ranges::bidirectional_range</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies a range whose iterator type satisfies <a href="../iterator/bidirectional_iterator" title="cpp/iterator/bidirectional iterator"><code>bidirectional_iterator</code></a> <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/random_access_range" title="cpp/ranges/random access range"> <span class="t-lines"><span>ranges::random_access_range</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies a range whose iterator type satisfies <a href="../iterator/random_access_iterator" title="cpp/iterator/random access iterator"><code>random_access_iterator</code></a> <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/contiguous_range" title="cpp/ranges/contiguous range"> <span class="t-lines"><span>ranges::contiguous_range</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies a range whose iterator type satisfies <a href="../iterator/contiguous_iterator" title="cpp/iterator/contiguous iterator"><code>contiguous_iterator</code></a> <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/common_range" title="cpp/ranges/common range"> <span class="t-lines"><span>ranges::common_range</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies that a range has identical iterator and sentinel types <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/viewable_range" title="cpp/ranges/viewable range"> <span class="t-lines"><span>ranges::viewable_range</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies the requirements for a <a href="../ranges/range" title="cpp/ranges/range"><code>range</code></a> to be safely convertible to a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/constant_range" title="cpp/ranges/constant range"> <span class="t-lines"><span>ranges::constant_range</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> specifies that a range has read-only elements <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr> <td colspan="2"> <h3 id="Functions"> Functions</h3> </td>
</tr> <tr> <td colspan="2"> <h5 id="Range_conversions">  Range conversions </h5> </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in namespace <code>std::ranges</code>  </th>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/to" title="cpp/ranges/to"> <span class="t-lines"><span>ranges::to</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> constructs a new non-view object from an input range <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr> <td colspan="2"> <h3 id="Classes"> Classes</h3> </td>
</tr> <tr> <td colspan="2"> <h5 id="Range_primitives">  Range primitives </h5> </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in namespace <code>std::ranges</code>  </th>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/iterator_t" title="cpp/ranges/iterator t"> <span class="t-lines"><span>ranges::iterator_t</span><span>ranges::const_iterator_t</span><span>ranges::sentinel_t</span><span>ranges::const_sentinel_t</span><span>ranges::range_difference_t</span><span>ranges::range_size_t </span><span>ranges::range_value_t</span><span>ranges::range_reference_t</span><span>ranges::range_const_reference_t</span><span>ranges::range_rvalue_reference_t</span><span>ranges::range_common_reference_t</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> obtains associated types of a range <br> <span class="t-mark">(alias template)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Views">  Views </h5> </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in namespace <code>std::ranges</code>  </th>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/view_interface" title="cpp/ranges/view interface"> <span class="t-lines"><span>ranges::view_interface</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> helper class template for defining a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a>, using the <a href="../language/crtp" title="cpp/language/crtp">curiously recurring template pattern</a> <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/subrange" title="cpp/ranges/subrange"> <span class="t-lines"><span>ranges::subrange</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> combines an iterator-sentinel pair into a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Dangling_iterator_handling">  Dangling iterator handling </h5> </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in namespace <code>std::ranges</code>  </th>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/dangling" title="cpp/ranges/dangling"> <span class="t-lines"><span>ranges::dangling</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> a placeholder type indicating that an iterator or a <code>subrange</code> should not be returned since it would be dangling <br> <span class="t-mark">(class)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/borrowed_iterator_t" title="cpp/ranges/borrowed iterator t"> <span class="t-lines"><span>ranges::borrowed_iterator_t</span><span>ranges::borrowed_subrange_t</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> obtains iterator type or <code>subrange</code> type of a <a href="../ranges/borrowed_range" title="cpp/ranges/borrowed range"><code>borrowed_range</code></a> <br> <span class="t-mark">(alias template)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Range_adaptor_objects_utility">  Range adaptor objects utility </h5> </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in namespace <code>std::ranges</code>  </th>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/range_adaptor_closure" title="cpp/ranges/range adaptor closure"> <span class="t-lines"><span>ranges::range_adaptor_closure</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> helper base class template for defining a range adaptor closure object <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Factories">  Factories </h5> </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in namespace <code>std::ranges</code>  </th>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/empty_view" title="cpp/ranges/empty view"> <span class="t-lines"><span>ranges::empty_view</span><span>views::empty</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> an empty <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> with no elements <br> <span class="t-mark">(class template)</span> <span class="t-mark">(variable template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/single_view" title="cpp/ranges/single view"> <span class="t-lines"><span>ranges::single_view</span><span>views::single</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> that contains a single element of a specified value <br> <span class="t-mark">(class template)</span> <span class="t-mark">(customization point object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/iota_view" title="cpp/ranges/iota view"> <span class="t-lines"><span>ranges::iota_view</span><span>views::iota</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> consisting of a sequence generated by repeatedly incrementing an initial value <br> <span class="t-mark">(class template)</span> <span class="t-mark">(customization point object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/basic_istream_view" title="cpp/ranges/basic istream view"> <span class="t-lines"><span>ranges::basic_istream_view</span><span>views::istream</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> consisting of the elements obtained by successive application of <code>operator&gt;&gt;</code> on the associated input stream <br> <span class="t-mark">(class template)</span> <span class="t-mark">(customization point object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/repeat_view" title="cpp/ranges/repeat view"> <span class="t-lines"><span>ranges::repeat_view</span><span>views::repeat</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> consisting of a generated sequence by repeatedly producing the same value <br> <span class="t-mark">(class template)</span> <span class="t-mark">(customization point object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/cartesian_product_view" title="cpp/ranges/cartesian product view"> <span class="t-lines"><span>ranges::cartesian_product_view</span><span>views::cartesian_product</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> consisting of tuples of results calculated by the n-ary cartesian product of the adapted views <br> <span class="t-mark">(class template)</span> <span class="t-mark">(customization point object)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Adaptors">  Adaptors </h5> </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in namespace <code>std::ranges</code>  </th>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/all_view" title="cpp/ranges/all view"> <span class="t-lines"><span>views::all_t</span><span>views::all</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> that includes all elements of a <a href="../ranges/range" title="cpp/ranges/range"><code>range</code></a> <br> <span class="t-mark">(alias template)</span> <span class="t-mark">(range adaptor object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/ref_view" title="cpp/ranges/ref view"> <span class="t-lines"><span>ranges::ref_view</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> of the elements of some other <a href="../ranges/range" title="cpp/ranges/range"><code>range</code></a> <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/owning_view" title="cpp/ranges/owning view"> <span class="t-lines"><span>ranges::owning_view</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> with unique ownership of some <a href="../ranges/range" title="cpp/ranges/range"><code>range</code></a> <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/filter_view" title="cpp/ranges/filter view"> <span class="t-lines"><span>ranges::filter_view</span><span>views::filter</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> that consists of the elements of a <a href="../ranges/range" title="cpp/ranges/range"><code>range</code></a> that satisfies a predicate <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/transform_view" title="cpp/ranges/transform view"> <span class="t-lines"><span>ranges::transform_view</span><span>views::transform</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> of a sequence that applies a transformation function to each element <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/take_view" title="cpp/ranges/take view"> <span class="t-lines"><span>ranges::take_view</span><span>views::take</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> consisting of the first N elements of another <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/take_while_view" title="cpp/ranges/take while view"> <span class="t-lines"><span>ranges::take_while_view</span><span>views::take_while</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> consisting of the initial elements of another <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a>, until the first element on which a predicate returns <code>false</code> <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/drop_view" title="cpp/ranges/drop view"> <span class="t-lines"><span>ranges::drop_view</span><span>views::drop</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> consisting of elements of another <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a>, skipping the first N elements <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/drop_while_view" title="cpp/ranges/drop while view"> <span class="t-lines"><span>ranges::drop_while_view</span><span>views::drop_while</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> consisting of the elements of another <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a>, skipping the initial subsequence of elements until the first element where the predicate returns <code>false</code> <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/join_view" title="cpp/ranges/join view"> <span class="t-lines"><span>ranges::join_view</span><span>views::join</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> consisting of the sequence obtained from flattening a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> of <a href="../ranges/range" title="cpp/ranges/range"><code>range</code>s</a> <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/lazy_split_view" title="cpp/ranges/lazy split view"> <span class="t-lines"><span>ranges::lazy_split_view</span><span>views::lazy_split</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> over the subranges obtained from splitting another <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> using a delimiter <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/split_view" title="cpp/ranges/split view"> <span class="t-lines"><span>ranges::split_view</span><span>views::split</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> over the subranges obtained from splitting another <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> using a delimiter <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/view_counted" title="cpp/ranges/view counted"> <span class="t-lines"><span>views::counted</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> creates a subrange from an iterator and a count <br> <span class="t-mark">(customization point object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/common_view" title="cpp/ranges/common view"> <span class="t-lines"><span>ranges::common_view</span><span>views::common</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> converts a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> into a <a href="../ranges/common_range" title="cpp/ranges/common range"><code>common_range</code></a> <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/reverse_view" title="cpp/ranges/reverse view"> <span class="t-lines"><span>ranges::reverse_view</span><span>views::reverse</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> that iterates over the elements of another bidirectional view in reverse order <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/as_const_view" title="cpp/ranges/as const view"> <span class="t-lines"><span>ranges::as_const_view</span><span>views::as_const</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> converts a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> into a <a href="../ranges/constant_range" title="cpp/ranges/constant range"><code>constant_range</code></a> <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/as_rvalue_view" title="cpp/ranges/as rvalue view"> <span class="t-lines"><span>ranges::as_rvalue_view</span><span>views::as_rvalue</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> of a sequence that casts each element to an rvalue <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/elements_view" title="cpp/ranges/elements view"> <span class="t-lines"><span>ranges::elements_view</span><span>views::elements</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> takes a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> consisting of <a href="../utility/tuple/tuple-like" title="cpp/utility/tuple/tuple-like"><code>tuple-like</code></a> values and a number N and produces a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> of N'th element of each tuple <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/keys_view" title="cpp/ranges/keys view"> <span class="t-lines"><span>ranges::keys_view</span><span>views::keys</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> takes a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> consisting of pair-like values and produces a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> of the first elements of each pair <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/values_view" title="cpp/ranges/values view"> <span class="t-lines"><span>ranges::values_view</span><span>views::values</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> takes a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> consisting of pair-like values and produces a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> of the second elements of each pair <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/enumerate_view" title="cpp/ranges/enumerate view"> <span class="t-lines"><span>ranges::enumerate_view</span><span>views::enumerate</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> that maps each element of adapted sequence to a tuple of both the element's position and its value <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/zip_view" title="cpp/ranges/zip view"> <span class="t-lines"><span>ranges::zip_view</span><span>views::zip</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> consisting of tuples of references to corresponding elements of the adapted views <br> <span class="t-mark">(class template)</span> <span class="t-mark">(customization point object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/zip_transform_view" title="cpp/ranges/zip transform view"> <span class="t-lines"><span>ranges::zip_transform_view</span><span>views::zip_transform</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> consisting of tuples of results of application of a transformation function to corresponding elements of the adapted views <br> <span class="t-mark">(class template)</span> <span class="t-mark">(customization point object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/adjacent_view" title="cpp/ranges/adjacent view"> <span class="t-lines"><span>ranges::adjacent_view</span><span>views::adjacent</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> consisting of tuples of references to adjacent elements of the adapted view <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/adjacent_transform_view" title="cpp/ranges/adjacent transform view"> <span class="t-lines"><span>ranges::adjacent_transform_view</span><span>views::adjacent_transform</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> consisting of tuples of results of application of a transformation function to adjacent elements of the adapted view <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/join_with_view" title="cpp/ranges/join with view"> <span class="t-lines"><span>ranges::join_with_view</span><span>views::join_with</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> consisting of the sequence obtained from flattening a view of ranges, with the delimiter in between elements <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/stride_view" title="cpp/ranges/stride view"> <span class="t-lines"><span>ranges::stride_view</span><span>views::stride</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> consisting of elements of another <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a>, advancing over N elements at a time <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/slide_view" title="cpp/ranges/slide view"> <span class="t-lines"><span>ranges::slide_view</span><span>views::slide</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> whose M<sup>th</sup> element is a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> over the M<sup>th</sup> through (M + N - 1)<sup>th</sup> elements of another <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/chunk_view" title="cpp/ranges/chunk view"> <span class="t-lines"><span>ranges::chunk_view</span><span>views::chunk</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> a range of <a href="../ranges/view" title="cpp/ranges/view"><code>view</code>s</a> that are <code>N</code>-sized non-overlapping successive chunks of the elements of another <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/chunk_by_view" title="cpp/ranges/chunk by view"> <span class="t-lines"><span>ranges::chunk_by_view</span><span>views::chunk_by</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> splits the <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> into subranges between each pair of adjacent elements for which the given predicate returns <code>false</code> <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span>  </td>
</tr> <tr> <td colspan="2"> <h3 id="Customization_point_objects"> Customization point objects</h3> </td>
</tr> <tr> <td colspan="2"> <h5 id="Range_access">  Range access </h5> </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in namespace <code>std::ranges</code>  </th>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/begin" title="cpp/ranges/begin"> <span class="t-lines"><span>ranges::begin</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> returns an iterator to the beginning of a range <br> <span class="t-mark">(customization point object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/end" title="cpp/ranges/end"> <span class="t-lines"><span>ranges::end</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> returns a sentinel indicating the end of a range <br> <span class="t-mark">(customization point object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/cbegin" title="cpp/ranges/cbegin"> <span class="t-lines"><span>ranges::cbegin</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> returns an iterator to the beginning of a read-only range <br> <span class="t-mark">(customization point object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/cend" title="cpp/ranges/cend"> <span class="t-lines"><span>ranges::cend</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> returns a sentinel indicating the end of a read-only range <br> <span class="t-mark">(customization point object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/rbegin" title="cpp/ranges/rbegin"> <span class="t-lines"><span>ranges::rbegin</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> returns a reverse iterator to a range <br> <span class="t-mark">(customization point object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/rend" title="cpp/ranges/rend"> <span class="t-lines"><span>ranges::rend</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> returns a reverse end iterator to a range <br> <span class="t-mark">(customization point object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/crbegin" title="cpp/ranges/crbegin"> <span class="t-lines"><span>ranges::crbegin</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> returns a reverse iterator to a read-only range <br> <span class="t-mark">(customization point object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/crend" title="cpp/ranges/crend"> <span class="t-lines"><span>ranges::crend</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> returns a reverse end iterator to a read-only range <br> <span class="t-mark">(customization point object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/size" title="cpp/ranges/size"> <span class="t-lines"><span>ranges::size</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> returns an integer equal to the size of a range <br> <span class="t-mark">(customization point object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/ssize" title="cpp/ranges/ssize"> <span class="t-lines"><span>ranges::ssize</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> returns a signed integer equal to the size of a range <br> <span class="t-mark">(customization point object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/empty" title="cpp/ranges/empty"> <span class="t-lines"><span>ranges::empty</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> checks whether a range is empty <br> <span class="t-mark">(customization point object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/data" title="cpp/ranges/data"> <span class="t-lines"><span>ranges::data</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> obtains a pointer to the beginning of a contiguous range <br> <span class="t-mark">(customization point object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/cdata" title="cpp/ranges/cdata"> <span class="t-lines"><span>ranges::cdata</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> obtains a pointer to the beginning of a read-only contiguous range <br> <span class="t-mark">(customization point object)</span>  </td>
</tr> <tr> <td colspan="2"> <h3 id="Enumerations"> Enumerations</h3> </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in namespace <code>std::ranges</code>  </th>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/subrange_kind" title="cpp/ranges/subrange kind"> <span class="t-lines"><span>ranges::subrange_kind</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies whether a <code><a href="../ranges/subrange" title="cpp/ranges/subrange">std::ranges::subrange</a></code> models <code><a href="../ranges/sized_range" title="cpp/ranges/sized range">std::ranges::sized_range</a></code> <br> <span class="t-mark">(enum)</span>  </td>
</tr> <tr> <td colspan="2"> <h3 id="Helpers"> Helpers</h3> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/subrange/tuple_size" title="cpp/ranges/subrange/tuple size"> <span class="t-lines"><span>std::tuple_size<span class="t-dsc-small">&lt;std::ranges::subrange&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> obtains the number of components of a <code><a href="../ranges/subrange" title="cpp/ranges/subrange">std::ranges::subrange</a></code> <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/subrange/tuple_element" title="cpp/ranges/subrange/tuple element"> <span class="t-lines"><span>std::tuple_element<span class="t-dsc-small">&lt;std::ranges::subrange&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> obtains the type of the iterator or the sentinel of a <code><a href="../ranges/subrange" title="cpp/ranges/subrange">std::ranges::subrange</a></code> <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/subrange/get" title="cpp/ranges/subrange/get"> <span class="t-lines"><span>get<span class="t-dsc-small">(std::ranges::subrange)</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> obtains iterator or sentinel from a <code><a href="../ranges/subrange" title="cpp/ranges/subrange">std::ranges::subrange</a></code> <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/from_range" title="cpp/ranges/from range"> <span class="t-lines"><span>from_range_t</span><span>from_range</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> from-range construction tag <br> <span class="t-mark">(class)</span> <span class="t-mark">(constant)</span>  </td>
</tr> </table> <h3 id="Synopsis"> Synopsis</h3> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;compare&gt;
#include &lt;initializer_list&gt;
#include &lt;iterator&gt;
 
namespace std::ranges {
  inline namespace /* unspecified */ {
    // range access
    inline constexpr /* unspecified */ begin =   /* unspecified */;     // freestanding
    inline constexpr /* unspecified */ end =     /* unspecified */;     // freestanding
    inline constexpr /* unspecified */ cbegin =  /* unspecified */;     // freestanding
    inline constexpr /* unspecified */ cend =    /* unspecified */;     // freestanding
    inline constexpr /* unspecified */ rbegin =  /* unspecified */;     // freestanding
    inline constexpr /* unspecified */ rend =    /* unspecified */;     // freestanding
    inline constexpr /* unspecified */ crbegin = /* unspecified */;     // freestanding
    inline constexpr /* unspecified */ crend =   /* unspecified */;     // freestanding
 
    inline constexpr /* unspecified */ size =    /* unspecified */;     // freestanding
    inline constexpr /* unspecified */ ssize =   /* unspecified */;     // freestanding
    inline constexpr /* unspecified */ empty =   /* unspecified */;     // freestanding
    inline constexpr /* unspecified */ data =    /* unspecified */;     // freestanding
    inline constexpr /* unspecified */ cdata =   /* unspecified */;     // freestanding
  }
 
  // ranges
  template&lt;class T&gt;
    concept range = /* see description */;                              // freestanding
 
  template&lt;class T&gt;
    inline constexpr bool enable_borrowed_range = false;                // freestanding
 
  template&lt;class T&gt;
    concept borrowed_range = /* see description */;                     // freestanding
 
  template&lt;class T&gt;
    using iterator_t = decltype(ranges::begin(declval&lt;T&amp;&gt;()));          // freestanding
  template&lt;range R&gt;
    using sentinel_t = decltype(ranges::end(declval&lt;R&amp;&gt;()));            // freestanding
  template&lt;range R&gt;
    using const_iterator_t = const_iterator&lt;iterator_t&lt;R&gt;&gt;;             // freestanding
  template&lt;range R&gt;
    using range_difference_t = iter_difference_t&lt;iterator_t&lt;R&gt;&gt;;        // freestanding
  template&lt;sized_range R&gt;
    using range_size_t = decltype(ranges::size(declval&lt;R&amp;&gt;()));         // freestanding
  template&lt;range R&gt;
    using range_value_t = iter_value_t&lt;iterator_t&lt;R&gt;&gt;;                  // freestanding
  template&lt;range R&gt;
    using range_reference_t = iter_reference_t&lt;iterator_t&lt;R&gt;&gt;;          // freestanding
  template&lt;range R&gt;
    using range_const_reference_t = iter_const_reference_t&lt;iterator_t&lt;R&gt;&gt;;
                                                                        // freestanding
  template&lt;range R&gt;
    using range_rvalue_reference_t = iter_rvalue_reference_t&lt;iterator_t&lt;R&gt;&gt;;
                                                                        // freestanding
  template&lt;range R&gt;
    using range_common_reference_t = iter_common_reference_t&lt;iterator_t&lt;R&gt;&gt;;
                                                                        // freestanding
 
  // sized ranges
  template&lt;class&gt;
    inline constexpr bool disable_sized_range = false;                  // freestanding
 
  template&lt;class T&gt;
    concept sized_range = /* see description */;                        // freestanding
 
  // views
  template&lt;class T&gt;
    inline constexpr bool enable_view = /* see description */;          // freestanding
 
  struct view_base {};                                                  // freestanding
 
  template&lt;class T&gt;
    concept view = /* see description */;                               // freestanding
 
  // other range refinements
  template&lt;class R, class T&gt;
    concept output_range = /* see description */;                       // freestanding
 
  template&lt;class T&gt;
    concept input_range = /* see description */;                        // freestanding
 
  template&lt;class T&gt;
    concept forward_range = /* see description */;                      // freestanding
 
  template&lt;class T&gt;
    concept bidirectional_range = /* see description */;                // freestanding
 
  template&lt;class T&gt;
    concept random_access_range = /* see description */;                // freestanding
 
  template&lt;class T&gt;
    concept contiguous_range = /* see description */;                   // freestanding
 
  template&lt;class T&gt;
    concept common_range = /* see description */;                       // freestanding
 
  template&lt;class T&gt;
    concept viewable_range = /* see description */;                     // freestanding
 
  template&lt;class T&gt;
    concept constant_range = /* see description */;                     // freestanding
 
  // class template view_interface
  template&lt;class D&gt;
    requires is_class_v&lt;D&gt; &amp;&amp; same_as&lt;D, remove_cv_t&lt;D&gt;&gt;
  class view_interface;                                                 // freestanding
 
  // sub-ranges
  enum class subrange_kind : bool { unsized, sized };                   // freestanding
 
  template&lt;input_or_output_iterator I, sentinel_for&lt;I&gt; S = I,
      subrange_kind K = /* see description */&gt;
    requires (K == subrange_kind::sized || !sized_sentinel_for&lt;S, I&gt;)
  class subrange;                                                       // freestanding
 
  template&lt;class I, class S, subrange_kind K&gt;
    inline constexpr bool enable_borrowed_range&lt;subrange&lt;I, S, K&gt;&gt; = true; // freestanding
 
  template&lt;size_t N, class I, class S, subrange_kind K&gt;
    requires ((N == 0 &amp;&amp; copyable&lt;I&gt;) || N == 1)
    constexpr auto get(const subrange&lt;I, S, K&gt;&amp; r);                     // freestanding
 
  template&lt;size_t N, class I, class S, subrange_kind K&gt;
    requires (N &lt; 2)
    constexpr auto get(subrange&lt;I, S, K&gt;&amp;&amp; r);                          // freestanding
}
 
namespace std {
  using ranges::get;                                                    // freestanding
}
 
namespace std::ranges {
  // dangling iterator handling
  struct dangling;                                                      // freestanding
 
  // class template elements_of
  template&lt;range R, class Allocator = allocator&lt;byte&gt;&gt;
    struct elements_of;
 
  template&lt;range R&gt;
    using borrowed_iterator_t = /* see description */;                  // freestanding
 
  template&lt;range R&gt;
    using borrowed_subrange_t = /* see description */;                  // freestanding
 
  // range conversions
  template&lt;class C, input_range R, class... Args&gt; requires (!view&lt;C&gt;)
    constexpr C to(R&amp;&amp; r, Args&amp;&amp;... args);                              // freestanding
  template&lt;template&lt;class...&gt; class C, input_range R, class... Args&gt;
    constexpr auto to(R&amp;&amp; r, Args&amp;&amp;... args);                           // freestanding
  template&lt;class C, class... Args&gt; requires (!view&lt;C&gt;)
    constexpr auto to(Args&amp;&amp;... args);                                  // freestanding
  template&lt;template&lt;class...&gt; class C, class... Args&gt;
    constexpr auto to(Args&amp;&amp;... args);                                  // freestanding
 
  // empty view
  template&lt;class T&gt;
    requires is_object_v&lt;T&gt;
  class empty_view;                                                     // freestanding
 
  template&lt;class T&gt;
    inline constexpr bool enable_borrowed_range&lt;empty_view&lt;T&gt;&gt; = true;  // freestanding
 
  namespace views {
    template&lt;class T&gt;
      inline constexpr empty_view&lt;T&gt; empty{};                           // freestanding
  }
 
  // single view
  template&lt;move_constructible T&gt;
    requires is_object_v&lt;T&gt;
  class single_view;                                                    // freestanding
 
  namespace views { inline constexpr /* unspecified */ single = /* unspecified */; }
                                                                        // freestanding
 
  template&lt;bool Const, class T&gt;
    using __maybe_const = conditional_t&lt;Const, const T, T&gt;;   // exposition only
 
  // iota view
  template&lt;weakly_incrementable W, semiregular Bound = unreachable_sentinel_t&gt;
    requires __weakly_equality_comparable_with&lt;W, Bound&gt; &amp;&amp; copyable&lt;W&gt;
  class iota_view;                                                      // freestanding
 
  template&lt;class W, class Bound&gt;
    inline constexpr bool enable_borrowed_range&lt;iota_view&lt;W, Bound&gt;&gt; = true;
                                                                        // freestanding
 
  namespace views { inline constexpr /* unspecified */ iota = /* unspecified */; }
                                                                        // freestanding
 
  // repeat view
  template&lt;move_constructible W, semiregular Bound = unreachable_sentinel_t&gt;
    requires (is_object_v&lt;W&gt; &amp;&amp; same_as&lt;W, remove_cv_t&lt;W&gt;&gt;
      &amp;&amp; (__is_integer_like&lt;Bound&gt; || same_as&lt;Bound, unreachable_sentinel_t&gt;))
  class repeat_view;
 
  namespace views { inline constexpr /* unspecified */ repeat = /* unspecified */; }
 
  // istream view
  template&lt;movable Val, class CharT, class Traits = char_traits&lt;CharT&gt;&gt;
    requires /* see description */
  class basic_istream_view;
  template&lt;class Val&gt;
    using istream_view = basic_istream_view&lt;Val, char&gt;;
  template&lt;class Val&gt;
    using wistream_view = basic_istream_view&lt;Val, wchar_t&gt;;
 
  namespace views { template&lt;class T&gt; inline constexpr /* unspecified */ istream =
    /* unspecified */; }
 
  // range adaptor objects
  template&lt;class D&gt;
    requires is_class_v&lt;D&gt; &amp;&amp; same_as&lt;D, remove_cv_t&lt;D&gt;&gt;
  class range_adaptor_closure { };                                      // freestanding
 
  // all view
  namespace views {
    inline constexpr /* unspecified */ all = /* unspecified */;         // freestanding
 
    template&lt;viewable_range R&gt;
      using all_t = decltype(all(declval&lt;R&gt;()));                        // freestanding
  }
 
  // ref view
  template&lt;range R&gt;
    requires is_object_v&lt;R&gt;
  class ref_view;                                                       // freestanding
 
  template&lt;class T&gt;
    inline constexpr bool enable_borrowed_range&lt;ref_view&lt;T&gt;&gt; = true;    // freestanding
 
  // owning view
  template&lt;range R&gt;
    requires /* see description */
  class owning_view;                                                    // freestanding
 
  template&lt;class T&gt;
    inline constexpr bool enable_borrowed_range&lt;owning_view&lt;T&gt;&gt; =       // freestanding
      enable_borrowed_range&lt;T&gt;;
 
  // as rvalue view
  template&lt;view V&gt;
    requires input_range&lt;V&gt;
  class as_rvalue_view;                                                 // freestanding
 
  template&lt;class T&gt;
    inline constexpr bool enable_borrowed_range&lt;as_rvalue_view&lt;T&gt;&gt; =    // freestanding
      enable_borrowed_range&lt;T&gt;;
 
  namespace views { inline constexpr /* unspecified */ as_rvalue = /* unspecified */; }
                                                                        // freestanding
 
  // filter view
  template&lt;input_range V, indirect_unary_predicate&lt;iterator_t&lt;V&gt;&gt; Pred&gt;
    requires view&lt;V&gt; &amp;&amp; is_object_v&lt;Pred&gt;
  class filter_view;                                                    // freestanding
 
  namespace views { inline constexpr /* unspecified */ filter = /* unspecified */; }
                                                                        // freestanding
 
  // transform view
  template&lt;input_range V, move_constructible F&gt;
    requires view&lt;V&gt; &amp;&amp; is_object_v&lt;F&gt; &amp;&amp;
             regular_invocable&lt;F&amp;, range_reference_t&lt;V&gt;&gt; &amp;&amp;
             __can_reference&lt;invoke_result_t&lt;F&amp;, range_reference_t&lt;V&gt;&gt;&gt;
  class transform_view;                                                 // freestanding
 
  namespace views { inline constexpr /* unspecified */ transform = /* unspecified */; }
                                                                        // freestanding
 
  // take view
  template&lt;view&gt; class take_view;                                       // freestanding
 
  template&lt;class T&gt;
    inline constexpr bool enable_borrowed_range&lt;take_view&lt;T&gt;&gt; =         // freestanding
      enable_borrowed_range&lt;T&gt;;
 
  namespace views { inline constexpr /* unspecified */ take = /* unspecified */; }
                                                                        // freestanding
 
  // take while view
  template&lt;view V, class Pred&gt;
    requires input_range&lt;V&gt; &amp;&amp; is_object_v&lt;Pred&gt; &amp;&amp;
             indirect_unary_predicate&lt;const Pred, iterator_t&lt;V&gt;&gt;
    class take_while_view;                                              // freestanding
 
  namespace views { inline constexpr /* unspecified */ take_while = /* unspecified */; }
                                                                        // freestanding
 
  // drop view
  template&lt;view V&gt;
    class drop_view;                                                    // freestanding
 
  template&lt;class T&gt;
    inline constexpr bool enable_borrowed_range&lt;drop_view&lt;T&gt;&gt; =         // freestanding
      enable_borrowed_range&lt;T&gt;;
 
  namespace views { inline constexpr /* unspecified */ drop = /* unspecified */; }
                                                                        // freestanding
 
  // drop while view
  template&lt;view V, class Pred&gt;
    requires input_range&lt;V&gt; &amp;&amp; is_object_v&lt;Pred&gt; &amp;&amp;
             indirect_unary_predicate&lt;const Pred, iterator_t&lt;V&gt;&gt;
    class drop_while_view;                                              // freestanding
 
  template&lt;class T, class Pred&gt;
    inline constexpr bool enable_borrowed_range&lt;drop_while_view&lt;T, Pred&gt;&gt; =
                                                                        // freestanding
      enable_borrowed_range&lt;T&gt;;
 
  namespace views { inline constexpr /* unspecified */ drop_while = /* unspecified */; }
                                                                        // freestanding
 
  // join view
  template&lt;input_range V&gt;
    requires view&lt;V&gt; &amp;&amp; input_range&lt;range_reference_t&lt;V&gt;&gt;
  class join_view;                                                      // freestanding
 
  namespace views { inline constexpr /* unspecified */ join = /* unspecified */; }
                                                                        // freestanding
 
  // join with view
  template&lt;class R, class P&gt;
    concept __compatible_joinable_ranges = /* see description */; // exposition only
 
  template&lt;input_range V, forward_range Pattern&gt;
    requires view&lt;V&gt; &amp;&amp; input_range&lt;range_reference_t&lt;V&gt;&gt;
          &amp;&amp; view&lt;Pattern&gt;
          &amp;&amp; __compatible_joinable_ranges&lt;range_reference_t&lt;V&gt;, Pattern&gt;
  class join_with_view;                                                 // freestanding
 
  namespace views { inline constexpr /* unspecified */ join_with = /* unspecified */; }
                                                                        // freestanding
 
  // lazy split view
  template&lt;class R&gt;
    concept __tiny_range = /* see description */;   // exposition only
 
  template&lt;input_range V, forward_range Pattern&gt;
    requires view&lt;V&gt; &amp;&amp; view&lt;Pattern&gt; &amp;&amp;
             indirectly_comparable&lt;iterator_t&lt;V&gt;, iterator_t&lt;Pattern&gt;,
             ranges::equal_to&gt; &amp;&amp;
             (forward_range&lt;V&gt; || __tiny_range&lt;Pattern&gt;)
  class lazy_split_view;                                                // freestanding
 
  // split view
 template&lt;forward_range V, forward_range Pattern&gt;
   requires view&lt;V&gt; &amp;&amp; view&lt;Pattern&gt; &amp;&amp;
            indirectly_comparable&lt;iterator_t&lt;V&gt;, iterator_t&lt;Pattern&gt;, ranges::equal_to&gt;
  class split_view;                                                     // freestanding
 
  namespace views {
    inline constexpr /* unspecified */ lazy_split = /* unspecified */;  // freestanding
    inline constexpr /* unspecified */ split = /* unspecified */;       // freestanding
  }
 
  // counted view
  namespace views { inline constexpr /* unspecified */ counted = /* unspecified */; }
                                                                        // freestanding
 
  // common view
  template&lt;view V&gt;
    requires (!common_range&lt;V&gt; &amp;&amp; copyable&lt;iterator_t&lt;V&gt;&gt;)
  class common_view;                                                    // freestanding
 
  template&lt;class T&gt;
    inline constexpr bool enable_borrowed_range&lt;common_view&lt;T&gt;&gt; =       // freestanding
      enable_borrowed_range&lt;T&gt;;
 
  namespace views { inline constexpr /* unspecified */ common = /* unspecified */; }
                                                                        // freestanding
 
  // reverse view
  template&lt;view V&gt;
    requires bidirectional_range&lt;V&gt;
  class reverse_view;                                                   // freestanding
 
  template&lt;class T&gt;
    inline constexpr bool enable_borrowed_range&lt;reverse_view&lt;T&gt;&gt; =      // freestanding
      enable_borrowed_range&lt;T&gt;;
 
  namespace views { inline constexpr /* unspecified */ reverse = /* unspecified */; }
                                                                        // freestanding
 
  // as const view
  template&lt;input_range R&gt;
    constexpr auto&amp; __possibly_const_range(R&amp; r) {          // exposition only
      if constexpr (constant_range&lt;const R&gt; &amp;&amp; !constant_range&lt;R&gt;) {
        return const_cast&lt;const R&amp;&gt;(r);
      } else {
        return r;
      }
    }
 
  template&lt;view V&gt;
    requires input_range&lt;V&gt;
  class as_const_view;                                                  // freestanding
 
  template&lt;class T&gt;
    inline constexpr bool enable_borrowed_range&lt;as_const_view&lt;T&gt;&gt; =     // freestanding
      enable_borrowed_range&lt;T&gt;;
 
  namespace views { inline constexpr /* unspecified */ as_const = /* unspecified */; }
                                                                        // freestanding
 
  // elements view
  template&lt;input_range V, size_t N&gt;
    requires /* see description */
  class elements_view;                                                  // freestanding
 
  template&lt;class T, size_t N&gt;
    inline constexpr bool enable_borrowed_range&lt;elements_view&lt;T, N&gt;&gt; =  // freestanding
      enable_borrowed_range&lt;T&gt;;
 
  template&lt;class R&gt;
    using keys_view = elements_view&lt;R, 0&gt;;                              // freestanding
  template&lt;class R&gt;
    using values_view = elements_view&lt;R, 1&gt;;                            // freestanding
 
  namespace views {
    template&lt;size_t N&gt;
      inline constexpr /* unspecified */ elements = /* unspecified */;  // freestanding
    inline constexpr auto keys = elements&lt;0&gt;;                           // freestanding
    inline constexpr auto values = elements&lt;1&gt;;                         // freestanding
  }
 
  template&lt;input_range View&gt;
    requires view&lt;View&gt;
  class enumerate_view; // freestanding
 
  template&lt;class View&gt;
    inline constexpr bool enable_borrowed_range&lt;enumerate_view&lt;View&gt;&gt; = // freestanding
      enable_borrowed_range&lt;View&gt;;
 
  namespace views {
    inline constexpr /* unspecified */ enumerate = /* unspecified */;   // freestanding
  }
 
  // zip view
  template&lt;input_range... Views&gt;
    requires (view&lt;Views&gt; &amp;&amp; ...) &amp;&amp; (sizeof...(Views) &gt; 0)
  class zip_view;                                                       // freestanding
 
  template&lt;class... Views&gt;
    inline constexpr bool enable_borrowed_range&lt;zip_view&lt;Views...&gt;&gt; =   // freestanding
      (enable_borrowed_range&lt;Views&gt; &amp;&amp; ...);
 
  namespace views { inline constexpr /* unspecified */ zip = /* unspecified */; }
                                                                        // freestanding
 
  // zip transform view
  template&lt;move_constructible F, input_range... Views&gt;
    requires (view&lt;Views&gt; &amp;&amp; ...) &amp;&amp; (sizeof...(Views) &gt; 0) &amp;&amp; is_object_v&lt;F&gt; &amp;&amp;
             regular_invocable&lt;F&amp;, range_reference_t&lt;Views&gt;...&gt; &amp;&amp;
             __can_reference&lt;invoke_result_t&lt;F&amp;, range_reference_t&lt;Views&gt;...&gt;&gt;
  class zip_transform_view;                                             // freestanding
 
  namespace views { inline constexpr /* unspecified */ zip_transform =
    /* unspecified */; }                                                // freestanding
 
  // adjacent view
  template&lt;forward_range V, size_t N&gt;
    requires view&lt;V&gt; &amp;&amp; (N &gt; 0)
  class adjacent_view;                                                  // freestanding
 
  template&lt;class V, size_t N&gt;
    inline constexpr bool enable_borrowed_range&lt;adjacent_view&lt;V, N&gt;&gt; =  // freestanding
      enable_borrowed_range&lt;V&gt;;
 
  namespace views {
    template&lt;size_t N&gt;
      inline constexpr /* unspecified */ adjacent = /* unspecified */;  // freestanding
    inline constexpr auto pairwise = adjacent&lt;2&gt;;                       // freestanding
  }
 
  // adjacent transform view
  template&lt;forward_range V, move_constructible F, size_t N&gt;
    requires /* see description */
  class adjacent_transform_view;                                        // freestanding
 
  namespace views {
    template&lt;size_t N&gt;
      inline constexpr /* unspecified */ adjacent_transform =
        /* unspecified */;                                              // freestanding
    inline constexpr auto pairwise_transform = adjacent_transform&lt;2&gt;;   // freestanding
  }
 
  // chunk view
  template&lt;view V&gt;
    requires input_range&lt;V&gt;
  class chunk_view;                                                     // freestanding
 
  template&lt;view V&gt;
    requires forward_range&lt;V&gt;
  class chunk_view&lt;V&gt;;                                                  // freestanding
 
  template&lt;class V&gt;
    inline constexpr bool enable_borrowed_range&lt;chunk_view&lt;V&gt;&gt; =        // freestanding
      forward_range&lt;V&gt; &amp;&amp; enable_borrowed_range&lt;V&gt;;
 
  namespace views { inline constexpr /* unspecified */ chunk =
    /* unspecified */; }                                                // freestanding
 
  // slide view
  template&lt;forward_range V&gt;
    requires view&lt;V&gt;
  class slide_view;                                                     // freestanding
 
  template&lt;class V&gt;
    inline constexpr bool enable_borrowed_range&lt;slide_view&lt;V&gt;&gt; =
      enable_borrowed_range&lt;V&gt;;                                         // freestanding
 
  namespace views { inline constexpr /* unspecified */ slide =
    /* unspecified */; }                                                // freestanding
 
  // chunk by view
  template&lt;forward_range V, indirect_binary_predicate&lt;iterator_t&lt;V&gt;, iterator_t&lt;V&gt;&gt; Pred&gt;
    requires view&lt;V&gt; &amp;&amp; is_object_v&lt;Pred&gt;
  class chunk_by_view;                                                  // freestanding
 
  namespace views { inline constexpr /* unspecified */ chunk_by =
    /* unspecified */; }                                                // freestanding
 
  // stride view
  template&lt;input_range V&gt;
    requires view&lt;V&gt;
  class stride_view;
 
  template&lt;class V&gt;
    inline constexpr bool enable_borrowed_range&lt;stride_view&lt;V&gt;&gt; =
      enable_borrowed_range&lt;V&gt;;
 
  namespace views { inline constexpr /* unspecified */ stride = /* unspecified */; }
 
  // cartesian product view
  template&lt;input_range First, forward_range... Vs&gt;
    requires (view&lt;First&gt; &amp;&amp; ... &amp;&amp; view&lt;Vs&gt;)
  class cartesian_product_view;
 
  namespace views { inline constexpr /* unspecified */ cartesian_product =
    /* unspecified */; }
}
 
namespace std {
  namespace views = ranges::views;                                      // freestanding
 
  template&lt;class T&gt; struct tuple_size;                                  // freestanding
  template&lt;size_t I, class T&gt; struct tuple_element;                     // freestanding
 
  template&lt;class I, class S, ranges::subrange_kind K&gt;
  struct tuple_size&lt;ranges::subrange&lt;I, S, K&gt;&gt;                          // freestanding
    : integral_constant&lt;size_t, 2&gt; {};
  template&lt;class I, class S, ranges::subrange_kind K&gt;
  struct tuple_element&lt;0, ranges::subrange&lt;I, S, K&gt;&gt; {                  // freestanding
    using type = I;                                                     // freestanding
  };
  template&lt;class I, class S, ranges::subrange_kind K&gt;
  struct tuple_element&lt;1, ranges::subrange&lt;I, S, K&gt;&gt; {                  // freestanding
    using type = S;                                                     // freestanding
  };
  template&lt;class I, class S, ranges::subrange_kind K&gt;
  struct tuple_element&lt;0, const ranges::subrange&lt;I, S, K&gt;&gt; {            // freestanding
    using type = I;                                                     // freestanding
  };
  template&lt;class I, class S, ranges::subrange_kind K&gt;
  struct tuple_element&lt;1, const ranges::subrange&lt;I, S, K&gt;&gt; {            // freestanding
    using type = S;                                                     // freestanding
  };
 
  struct from_range_t { explicit from_range_t() = default; };           // freestanding
  inline constexpr from_range_t from_range{};                           // freestanding
}</pre></div> <h4 id="Concept_range"> Concept <a href="../ranges/range" title="cpp/ranges/range"><code>range</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt; class T &gt;
    concept range = requires(T&amp; t) {
      ranges::begin(t); // equality-preserving for forward iterators
      ranges::end(t);
  };
}</pre></div> <h4 id="Concept_borrowed_range"> Concept <a href="../ranges/borrowed_range" title="cpp/ranges/borrowed range"><code>borrowed_range</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class T&gt;
    concept borrowed_range =
      range&lt;T&gt; &amp;&amp; (is_lvalue_reference_v&lt;T&gt; ||
        enable_borrowed_range&lt;remove_cvref_t&lt;T&gt;&gt;);
}</pre></div> <h4 id="Concept_sized_range"> Concept <a href="../ranges/sized_range" title="cpp/ranges/sized range"><code>sized_range</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt; class T &gt;
    concept sized_range = range&lt;T&gt; &amp;&amp;
      requires(T&amp; t) {
        ranges::size(t);
      };
}</pre></div> <h4 id="Concept_view"> Concept <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class T&gt;
    inline constexpr bool enable_view = derived_from&lt;T, view_base&gt;;
 
  template&lt;class T&gt;
    concept view = range&lt;T&gt;
                &amp;&amp; movable&lt;T&gt;
                &amp;&amp; enable_view&lt;T&gt;;
}</pre></div> <h4 id="Concept_output_range"> Concept <a href="../ranges/output_range" title="cpp/ranges/output range"><code>output_range</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class R, class T&gt;
    concept output_range =
      range&lt;R&gt; &amp;&amp; output_iterator&lt;iterator_t&lt;R&gt;, T&gt;;
}</pre></div> <h4 id="Concept_input_range"> Concept <a href="../ranges/input_range" title="cpp/ranges/input range"><code>input_range</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class T&gt;
    concept input_range =
      range&lt;T&gt; &amp;&amp; input_iterator&lt;iterator_t&lt;T&gt;&gt;;
}</pre></div> <h4 id="Concept_forward_range"> Concept <a href="../ranges/forward_range" title="cpp/ranges/forward range"><code>forward_range</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class T&gt;
    concept forward_range =
      input_range&lt;T&gt; &amp;&amp; forward_iterator&lt;iterator_t&lt;T&gt;&gt;;
}</pre></div> <h4 id="Concept_bidirectional_range"> Concept <a href="../ranges/bidirectional_range" title="cpp/ranges/bidirectional range"><code>bidirectional_range</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class T&gt;
    concept bidirectional_range =
      forward_range&lt;T&gt; &amp;&amp; bidirectional_iterator&lt;iterator_t&lt;T&gt;&gt;;
}</pre></div> <h4 id="Concept_random_access_range"> Concept <a href="../ranges/random_access_range" title="cpp/ranges/random access range"><code>random_access_range</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class T&gt;
    concept random_access_range =
      bidirectional_range&lt;T&gt; &amp;&amp; random_access_iterator&lt;iterator_t&lt;T&gt;&gt;;
}</pre></div> <h4 id="Concept_contiguous_range"> Concept <a href="../ranges/contiguous_range" title="cpp/ranges/contiguous range"><code>contiguous_range</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class T&gt;
    concept contiguous_range =
      random_access_range&lt;T&gt; &amp;&amp; contiguous_iterator&lt;iterator_t&lt;T&gt;&gt; &amp;&amp;
        requires(T&amp; t) {
          { ranges::data(t) } -&gt; same_as&lt;add_pointer_t&lt;range_reference_t&lt;T&gt;&gt;&gt;;
        };
}</pre></div> <h4 id="Concept_common_range"> Concept <a href="../ranges/common_range" title="cpp/ranges/common range"><code>common_range</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class T&gt;
    concept common_range =
      range&lt;T&gt; &amp;&amp; same_as&lt;iterator_t&lt;T&gt;, sentinel_t&lt;T&gt;&gt;;
}</pre></div> <h4 id="Concept_viewable_range"> Concept <a href="../ranges/viewable_range" title="cpp/ranges/viewable range"><code>viewable_range</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class T&gt;
    concept viewable_range =
      range&lt;T&gt; &amp;&amp; (borrowed_range&lt;T&gt; || view&lt;remove_cvref_t&lt;T&gt;&gt;);
}</pre></div> <h4 id="Helper_concepts"> Helper concepts</h4> <p>Note: The following names are only for exposition, they are not part of the interface.</p>
<div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges { // unspecified, for name lookup only
  template&lt;class R&gt;
    concept __simple_view =                                       // exposition only
      view&lt;R&gt; &amp;&amp; range&lt;const R&gt; &amp;&amp;
      same_as&lt;iterator_t&lt;R&gt;, iterator_t&lt;const R&gt;&gt; &amp;&amp;
      same_as&lt;sentinel_t&lt;R&gt;, sentinel_t&lt;const R&gt;&gt;;
 
  template&lt;class I&gt;
    concept __has_arrow =                                         // exposition only
      input_iterator&lt;I&gt; &amp;&amp;
      (is_pointer_v&lt;I&gt; || requires(I i) { i.operator-&gt;(); });
 
  template&lt;class T, class U&gt;
    concept __different_from =                                    // exposition only
      !same_as&lt;remove_cvref_t&lt;T&gt;, remove_cvref_t&lt;U&gt;&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::view_interface"> Class template <code>std::ranges::view_interface</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class D&gt;
    requires is_class_v&lt;D&gt; &amp;&amp; same_as&lt;D, remove_cv_t&lt;D&gt;&gt;
  class view_interface {
  private:
    constexpr D&amp; derived() noexcept {               // exposition only
      return static_cast&lt;D&amp;&gt;(*this);
    }
    constexpr const D&amp; derived() const noexcept {   // exposition only
      return static_cast&lt;const D&amp;&gt;(*this);
    }
 
  public:
    constexpr bool empty() requires sized_range&lt;D&gt; || forward_range&lt;D&gt; {
      if constexpr (sized_range&lt;D&gt;)
        return ranges::size(derived()) == 0;
      else
        return ranges::begin(derived()) == ranges::end(derived());
    }
    constexpr bool empty() const requires sized_range&lt;const D&gt; ||
        forward_range&lt;const D&gt; {
      if constexpr (sized_range&lt;const D&gt;)
        return ranges::size(derived()) == 0;
      else
        return ranges::begin(derived()) == ranges::end(derived());
    }
 
    constexpr auto cbegin() {
      return ranges::cbegin(derived());
    }
    constexpr auto cbegin() const requires range&lt;const D&gt; {
      return ranges::cbegin(derived());
    }
    constexpr auto cend() {
      return ranges::cend(derived());
    }
    constexpr auto cend() const requires range&lt;const D&gt; {
      return ranges::cend(derived());
    }
 
    constexpr explicit operator bool()
      requires requires { ranges::empty(derived()); } {
        return !ranges::empty(derived());
      }
    constexpr explicit operator bool() const
      requires requires { ranges::empty(derived()); } {
        return !ranges::empty(derived());
      }
 
    constexpr auto data() requires contiguous_iterator&lt;iterator_t&lt;D&gt;&gt; {
      return to_address(ranges::begin(derived()));
    }
    constexpr auto data() const
      requires range&lt;const D&gt; &amp;&amp; contiguous_iterator&lt;iterator_t&lt;const D&gt;&gt; {
        return to_address(ranges::begin(derived()));
      }
 
    constexpr auto size() requires forward_range&lt;D&gt; &amp;&amp;
      sized_sentinel_for&lt;sentinel_t&lt;D&gt;, iterator_t&lt;D&gt;&gt; {
        return ranges::end(derived()) - ranges::begin(derived());
      }
    constexpr auto size() const requires forward_range&lt;const D&gt; &amp;&amp;
      sized_sentinel_for&lt;sentinel_t&lt;const D&gt;, iterator_t&lt;const D&gt;&gt; {
        return ranges::end(derived()) - ranges::begin(derived());
      }
 
    constexpr decltype(auto) front() requires forward_range&lt;D&gt;;
    constexpr decltype(auto) front() const requires forward_range&lt;const D&gt;;
 
    constexpr decltype(auto) back() requires bidirectional_range&lt;D&gt; &amp;&amp; common_range&lt;D&gt;;
    constexpr decltype(auto) back() const
      requires bidirectional_range&lt;const D&gt; &amp;&amp; common_range&lt;const D&gt;;
 
    template&lt;random_access_range R = D&gt;
      constexpr decltype(auto) operator[](range_difference_t&lt;R&gt; n) {
        return ranges::begin(derived())[n];
      }
    template&lt;random_access_range R = const D&gt;
      constexpr decltype(auto) operator[](range_difference_t&lt;R&gt; n) const {
        return ranges::begin(derived())[n];
      }
  };
}</pre></div> <h4 id="Class_template_std::ranges::subrange"> Class template <code><a href="../ranges/subrange" title="cpp/ranges/subrange">std::ranges::subrange</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class From, class To&gt;
    concept __uses_nonqualification_pointer_conversion =      // exposition only
      is_pointer_v&lt;From&gt; &amp;&amp; is_pointer_v&lt;To&gt; &amp;&amp;
      !convertible_to&lt;remove_pointer_t&lt;From&gt;(*)[], remove_pointer_t&lt;To&gt;(*)[]&gt;;
 
  template&lt;class From, class To&gt;
    concept __convertible_to_non_slicing =                    // exposition only
      convertible_to&lt;From, To&gt; &amp;&amp;
      !__uses_nonqualification_pointer_conversion&lt;decay_t&lt;From&gt;, decay_t&lt;To&gt;&gt;;
 
  template&lt;class T, class U, class V&gt;
    concept __pair_like_convertible_from =                    // exposition only
      !range&lt;T&gt; &amp;&amp; !is_reference_v&lt;T&gt; &amp;&amp; __pair_like&lt;T&gt; &amp;&amp;
      constructible_from&lt;T, U, V&gt; &amp;&amp;
      __convertible_to_non_slicing&lt;U, tuple_element_t&lt;0, T&gt;&gt; &amp;&amp;
      convertible_to&lt;V, tuple_element_t&lt;1, T&gt;&gt;;
 
  template&lt;input_or_output_iterator I, sentinel_for&lt;I&gt; S = I, subrange_kind K =
      sized_sentinel_for&lt;S, I&gt; ? subrange_kind::sized : subrange_kind::unsized&gt;
    requires (K == subrange_kind::sized || !sized_sentinel_for&lt;S, I&gt;)
  class subrange : public view_interface&lt;subrange&lt;I, S, K&gt;&gt; {
  private:
    static constexpr bool StoreSize =                       // exposition only
      K == subrange_kind::sized &amp;&amp; !sized_sentinel_for&lt;S, I&gt;;
    I begin_ = I();                                         // exposition only
    S end_ = S();                                           // exposition only
    __make_unsigned_like_t&lt;iter_difference_t&lt;I&gt;&gt; size_ = 0;
        // exposition only; present only when StoreSize is true
  public:
    subrange() requires default_initializable&lt;I&gt; = default;
 
    constexpr subrange(__convertible_to_non_slicing&lt;I&gt; auto i, S s) requires (!StoreSize);
 
    constexpr subrange(__convertible_to_non_slicing&lt;I&gt; auto i, S s,
                       __make_unsigned_like_t&lt;iter_difference_t&lt;I&gt;&gt; n)
      requires (K == subrange_kind::sized);
 
    template&lt;__different_from&lt;subrange&gt; R&gt;
      requires borrowed_range&lt;R&gt; &amp;&amp;
               __convertible_to_non_slicing&lt;iterator_t&lt;R&gt;, I&gt; &amp;&amp;
               convertible_to&lt;sentinel_t&lt;R&gt;, S&gt;
    constexpr subrange(R&amp;&amp; r) requires (!StoreSize || sized_range&lt;R&gt;);
 
    template&lt;borrowed_range R&gt;
      requires __convertible_to_non_slicing&lt;iterator_t&lt;R&gt;, I&gt; &amp;&amp;
               convertible_to&lt;sentinel_t&lt;R&gt;, S&gt;
    constexpr subrange(R&amp;&amp; r, __make_unsigned_like_t&lt;iter_difference_t&lt;I&gt;&gt; n)
      requires (K == subrange_kind::sized)
        : subrange{ranges::begin(r), ranges::end(r), n} {}
 
    template&lt;__different_from&lt;subrange&gt; PairLike&gt;
      requires __pair_like_convertible_from&lt;PairLike, const I&amp;, const S&amp;&gt;
    constexpr operator PairLike() const;
 
    constexpr I begin() const requires copyable&lt;I&gt;;
    [[nodiscard]] constexpr I begin() requires (!copyable&lt;I&gt;);
    constexpr S end() const;
 
    constexpr bool empty() const;
    constexpr __make_unsigned_like_t&lt;iter_difference_t&lt;I&gt;&gt; size() const
      requires (K == subrange_kind::sized);
 
    [[nodiscard]] constexpr subrange next(iter_difference_t&lt;I&gt; n = 1) const &amp;
      requires forward_iterator&lt;I&gt;;
    [[nodiscard]] constexpr subrange next(iter_difference_t&lt;I&gt; n = 1) &amp;&amp;;
    [[nodiscard]] constexpr subrange prev(iter_difference_t&lt;I&gt; n = 1) const
      requires bidirectional_iterator&lt;I&gt;;
    constexpr subrange&amp; advance(iter_difference_t&lt;I&gt; n);
  };
 
  template&lt;input_or_output_iterator I, sentinel_for&lt;I&gt; S&gt;
    subrange(I, S) -&gt; subrange&lt;I, S&gt;;
 
  template&lt;input_or_output_iterator I, sentinel_for&lt;I&gt; S&gt;
    subrange(I, S, __make_unsigned_like_t&lt;iter_difference_t&lt;I&gt;&gt;) -&gt;
      subrange&lt;I, S, subrange_kind::sized&gt;;
 
  template&lt;borrowed_range R&gt;
    subrange(R&amp;&amp;) -&gt;
      subrange&lt;iterator_t&lt;R&gt;, sentinel_t&lt;R&gt;,
               (sized_range&lt;R&gt; || sized_sentinel_for&lt;sentinel_t&lt;R&gt;, iterator_t&lt;R&gt;&gt;)
                 ? subrange_kind::sized : subrange_kind::unsized&gt;;
 
  template&lt;borrowed_range R&gt;
    subrange(R&amp;&amp;, __make_unsigned_like_t&lt;range_difference_t&lt;R&gt;&gt;) -&gt;
      subrange&lt;iterator_t&lt;R&gt;, sentinel_t&lt;R&gt;, subrange_kind::sized&gt;;
}</pre></div> <h4 id="Class_std::ranges::dangling"> Class <code><a href="../ranges/dangling" title="cpp/ranges/dangling">std::ranges::dangling</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  struct dangling {
    constexpr dangling() noexcept = default;
    constexpr dangling(auto&amp;&amp;...) noexcept {}
  };
}</pre></div> <h4 id="Class_std::ranges::elements_of"> Class <code>std::ranges::elements_of</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;range R, class Allocator = allocator&lt;byte&gt;&gt;
  struct elements_of {
    [[no_unique_address]] R range;
    [[no_unique_address]] Allocator allocator = Allocator();
  };
 
  template&lt;class R, class Allocator = allocator&lt;byte&gt;&gt;
    elements_of(R&amp;&amp;, Allocator = Allocator()) -&gt; elements_of&lt;R&amp;&amp;, Allocator&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::empty_view"> Class template <code><a href="../ranges/empty_view" title="cpp/ranges/empty view">std::ranges::empty_view</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class T&gt;
    requires is_object_v&lt;T&gt;
  class empty_view : public view_interface&lt;empty_view&lt;T&gt;&gt; {
  public:
    static constexpr T* begin() noexcept { return nullptr; }
    static constexpr T* end() noexcept { return nullptr; }
    static constexpr T* data() noexcept { return nullptr; }
    static constexpr size_t size() noexcept { return 0; }
    static constexpr bool empty() noexcept { return true; }
  };
}</pre></div> <h4 id="Class_template_std::ranges::single_view"> Class template <code>std::ranges::single_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;move_constructible T&gt;
    requires is_object_v&lt;T&gt;
  class single_view : public view_interface&lt;single_view&lt;T&gt;&gt; {
  private:
    __movable_box&lt;T&gt; value_;              // exposition only
 
  public:
    single_view() requires default_initializable&lt;T&gt; = default;
    constexpr explicit single_view(const T&amp; t) requires copy_constructible&lt;T&gt;;
    constexpr explicit single_view(T&amp;&amp; t);
    template&lt;class... Args&gt;
      requires constructible_from&lt;T, Args...&gt;
    constexpr explicit single_view(in_place_t, Args&amp;&amp;... args);
 
    constexpr T* begin() noexcept;
    constexpr const T* begin() const noexcept;
    constexpr T* end() noexcept;
    constexpr const T* end() const noexcept;
    static constexpr size_t size() noexcept;
    constexpr T* data() noexcept;
    constexpr const T* data() const noexcept;
  };
 
  template&lt;class T&gt;
    single_view(T) -&gt; single_view&lt;T&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::iota_view"> Class template <code><a href="../ranges/iota_view" title="cpp/ranges/iota view">std::ranges::iota_view</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class I&gt;
    concept decrementable = /* see description */;  // exposition only
 
  template&lt;class I&gt;
    concept advanceable = /* see description */;    // exposition only
 
  template&lt;weakly_incrementable W, semiregular Bound = unreachable_sentinel_t&gt;
    requires __weakly_equality_comparable_with&lt;W, Bound&gt; &amp;&amp; copyable&lt;W&gt;
  class iota_view : public view_interface&lt;iota_view&lt;W, Bound&gt;&gt; {
  private:
    // class iota_view::iterator
    struct iterator;                    // exposition only
 
    // class iota_view::sentinel
    struct sentinel;                    // exposition only
 
    W value_ = W();                     // exposition only
    Bound bound_ = Bound();             // exposition only
 
  public:
    iota_view() requires default_initializable&lt;W&gt; = default;
    constexpr explicit iota_view(W value);
    constexpr explicit iota_view(type_identity_t&lt;W&gt; value, type_identity_t&lt;Bound&gt; bound);
    constexpr explicit iota_view(iterator first, /* see description */ last);
 
    constexpr iterator begin() const;
    constexpr auto end() const;
    constexpr iterator end() const requires same_as&lt;W, Bound&gt;;
 
    constexpr auto size() const requires /* see description */;
  };
 
  template&lt;class W, class Bound&gt;
    requires (!__is_integer_like&lt;W&gt; || !__is_integer_like&lt;Bound&gt; ||
              (__is_signed_integer_like&lt;W&gt; == __is_signed_integer_like&lt;Bound&gt;))
    iota_view(W, Bound) -&gt; iota_view&lt;W, Bound&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::iota_view::iterator"> Class template <code>std::ranges::iota_view::iterator</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;weakly_incrementable W, semiregular Bound&gt;
    requires __weakly_equality_comparable_with&lt;W, Bound&gt; &amp;&amp; copyable&lt;W&gt;
  struct iota_view&lt;W, Bound&gt;::iterator {
  private:
    W value_ = W();             // exposition only
  public:
    using iterator_concept = /* see description */;
    using iterator_category = input_iterator_tag; // present only if W models
      // __incrementable and __IOTA_DIFF_T(W) is an integral type
 
    using value_type = W;
    using difference_type = __IOTA_DIFF_T(W);
 
    iterator() requires default_initializable&lt;W&gt; = default;
    constexpr explicit iterator(W value);
 
    constexpr W operator*() const noexcept(is_nothrow_copy_constructible_v&lt;W&gt;);
 
    constexpr iterator&amp; operator++();
    constexpr void operator++(int);
    constexpr iterator operator++(int) requires incrementable&lt;W&gt;;
 
    constexpr iterator&amp; operator--() requires decrementable&lt;W&gt;;
    constexpr iterator operator--(int) requires decrementable&lt;W&gt;;
 
    constexpr iterator&amp; operator+=(difference_type n)
      requires advanceable&lt;W&gt;;
    constexpr iterator&amp; operator-=(difference_type n)
      requires advanceable&lt;W&gt;;
    constexpr W operator[](difference_type n) const
      requires advanceable&lt;W&gt;;
 
    friend constexpr bool operator==(const iterator&amp; x, const iterator&amp; y)
      requires equality_comparable&lt;W&gt;;
 
    friend constexpr bool operator&lt;(const iterator&amp; x, const iterator&amp; y)
      requires totally_ordered&lt;W&gt;;
    friend constexpr bool operator&gt;(const iterator&amp; x, const iterator&amp; y)
      requires totally_ordered&lt;W&gt;;
    friend constexpr bool operator&lt;=(const iterator&amp; x, const iterator&amp; y)
      requires totally_ordered&lt;W&gt;;
    friend constexpr bool operator&gt;=(const iterator&amp; x, const iterator&amp; y)
      requires totally_ordered&lt;W&gt;;
    friend constexpr auto operator&lt;=&gt;(const iterator&amp; x, const iterator&amp; y)
      requires totally_ordered&lt;W&gt; &amp;&amp; three_way_comparable&lt;W&gt;;
 
    friend constexpr iterator operator+(iterator i, difference_type n)
      requires advanceable&lt;W&gt;;
    friend constexpr iterator operator+(difference_type n, iterator i)
      requires advanceable&lt;W&gt;;
 
    friend constexpr iterator operator-(iterator i, difference_type n)
      requires advanceable&lt;W&gt;;
    friend constexpr difference_type operator-(const iterator&amp; x, const iterator&amp; y)
      requires advanceable&lt;W&gt;;
  };
}</pre></div> <h4 id="Class_template_std::ranges::iota_view::sentinel"> Class template <code>std::ranges::iota_view::sentinel</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;weakly_incrementable W, semiregular Bound&gt;
    requires __weakly_equality_comparable_with&lt;W, Bound&gt; &amp;&amp; copyable&lt;W&gt;
  struct iota_view&lt;W, Bound&gt;::sentinel {
  private:
    Bound bound_ = Bound();     // exposition only
  public:
    sentinel() = default;
    constexpr explicit sentinel(Bound bound);
 
    friend constexpr bool operator==(const iterator&amp; x, const sentinel&amp; y);
 
    friend constexpr iter_difference_t&lt;W&gt; operator-(const iterator&amp; x, const sentinel&amp; y)
      requires sized_sentinel_for&lt;Bound, W&gt;;
    friend constexpr iter_difference_t&lt;W&gt; operator-(const sentinel&amp; x, const iterator&amp; y)
      requires sized_sentinel_for&lt;Bound, W&gt;;
  };
}</pre></div> <h4 id="Class_template_std::ranges::repeat_view"> Class template <code>std::ranges::repeat_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;move_constructible W, semiregular Bound = unreachable_sentinel_t&gt;
    requires (is_object_v&lt;W&gt; &amp;&amp; same_as&lt;W, remove_cv_t&lt;W&gt;&gt; &amp;&amp;
              (__is_integer_like&lt;Bound&gt; || same_as&lt;Bound, unreachable_sentinel_t&gt;))
  class repeat_view : public view_interface&lt;repeat_view&lt;W, Bound&gt;&gt; {
  private:
    // class repeat_view::iterator
    struct iterator;                            // exposition only
 
    __movable_box&lt;W&gt; value_ = W();              // exposition only
    Bound bound_ = Bound();                     // exposition only
 
  public:
    repeat_view() requires default_initializable&lt;W&gt; = default;
 
    constexpr explicit repeat_view(const W&amp; value, Bound bound = Bound())
      requires copy_constructible&lt;W&gt;;
    constexpr explicit repeat_view(W&amp;&amp; value, Bound bound = Bound());
    template&lt;class... WArgs, class... BoundArgs&gt;
      requires constructible_from&lt;W, WArgs...&gt; &amp;&amp;
               constructible_from&lt;Bound, BoundArgs...&gt;
    constexpr explicit repeat_view(piecewise_construct_t,
      tuple&lt;WArgs...&gt; value_args, tuple&lt;BoundArgs...&gt; bound_args = tuple&lt;&gt;{});
 
    constexpr iterator begin() const;
    constexpr iterator end() const requires (!same_as&lt;Bound, unreachable_sentinel_t&gt;);
    constexpr unreachable_sentinel_t end() const noexcept;
 
    constexpr auto size() const requires (!same_as&lt;Bound, unreachable_sentinel_t&gt;);
  };
 
  template&lt;class W, class Bound&gt;
    repeat_view(W, Bound) -&gt; repeat_view&lt;W, Bound&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::repeat_view::iterator"> Class template <code>std::ranges::repeat_view::iterator</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;move_constructible W, semiregular Bound = unreachable_sentinel_t&gt;
    requires (is_object_v&lt;W&gt; &amp;&amp; same_as&lt;W, remove_cv_t&lt;W&gt;&gt; &amp;&amp;
              (__is_integer_like&lt;Bound&gt; || same_as&lt;Bound, unreachable_sentinel_t&gt;))
  class repeat_view&lt;W, Bound&gt;::iterator {
  private:
    using __index_type =                            // exposition only
      conditional_t&lt;same_as&lt;Bound, unreachable_sentinel_t&gt;, ptrdiff_t, Bound&gt;;
    const W* value_ = nullptr;                      // exposition only
    __index_type current_ = __index_type();         // exposition only
 
    constexpr explicit iterator(const W* value,
                                __index_type b = __index_type());   // exposition only
 
  public:
    using iterator_concept = random_access_iterator_tag;
    using iterator_category = random_access_iterator_tag;
    using value_type = W;
    using difference_type = conditional_t&lt;__is_signed_integer_like&lt;__index_type&gt;,
        __index_type,
        __IOTA_DIFF_T(__index_type)&gt;;
 
    iterator() = default;
 
    constexpr const W&amp; operator*() const noexcept;
 
    constexpr iterator&amp; operator++();
    constexpr iterator operator++(int);
 
    constexpr iterator&amp; operator--();
    constexpr iterator operator--(int);
 
    constexpr iterator&amp; operator+=(difference_type n);
    constexpr iterator&amp; operator-=(difference_type n);
    constexpr const W&amp; operator[](difference_type n) const noexcept;
 
    friend constexpr bool operator==(const iterator&amp; x, const iterator&amp; y);
    friend constexpr auto operator&lt;=&gt;(const iterator&amp; x, const iterator&amp; y);
 
    friend constexpr iterator operator+(iterator i, difference_type n);
    friend constexpr iterator operator+(difference_type n, iterator i);
 
    friend constexpr iterator operator-(iterator i, difference_type n);
    friend constexpr difference_type operator-(const iterator&amp; x, const iterator&amp; y);
  };
}</pre></div> <h4 id="Class_template_std::ranges::basic_istream_view"> Class template <code>std::ranges::basic_istream_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class Val, class CharT, class Traits&gt;
    concept __stream_extractable =                // exposition only
      requires(basic_istream&lt;CharT, Traits&gt;&amp; is, Val&amp; t) {
         is &gt;&gt; t;
      };
 
  template&lt;movable Val, class CharT, class Traits = char_traits&lt;CharT&gt;&gt;
    requires default_initializable&lt;Val&gt; &amp;&amp; __stream_extractable&lt;Val, CharT, Traits&gt;
  class basic_istream_view :
    public view_interface&lt;basic_istream_view&lt;Val, CharT, Traits&gt;&gt; {
  public:
    constexpr explicit basic_istream_view(basic_istream&lt;CharT, Traits&gt;&amp; stream);
 
    constexpr auto begin() {
      *stream_ &gt;&gt; value_;
      return iterator{*this};
    }
 
    constexpr default_sentinel_t end() const noexcept;
 
  private:
    // class basic_istream_view::iterator
    struct iterator;                            // exposition only
    basic_istream&lt;CharT, Traits&gt;* stream_;      // exposition only
    Val value_ = Val();                         // exposition only
  };
}</pre></div> <h4 id="Class_template_std::ranges::basic_istream_view::iterator"> Class template <code>std::ranges::basic_istream_view::iterator</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;movable Val, class CharT, class Traits&gt;
    requires default_initializable&lt;Val&gt; &amp;&amp;
             __stream_extractable&lt;Val, CharT, Traits&gt;
  class basic_istream_view&lt;Val, CharT, Traits&gt;::iterator {
  public:
    using iterator_concept = input_iterator_tag;
    using difference_type = ptrdiff_t;
    using value_type = Val;
 
    constexpr explicit iterator(basic_istream_view&amp; parent) noexcept;
 
    iterator(const iterator&amp;) = delete;
    iterator(iterator&amp;&amp;) = default;
 
    iterator&amp; operator=(const iterator&amp;) = delete;
    iterator&amp; operator=(iterator&amp;&amp;) = default;
 
    iterator&amp; operator++();
    void operator++(int);
 
    Val&amp; operator*() const;
 
    friend bool operator==(const iterator&amp; x, default_sentinel_t);
 
  private:
    basic_istream_view* parent_;                                // exposition only
  };
}</pre></div> <h4 id="Class_template_std::ranges::ref_view"> Class template <code><a href="../ranges/ref_view" title="cpp/ranges/ref view">std::ranges::ref_view</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;range R&gt;
    requires is_object_v&lt;R&gt;
  class ref_view : public view_interface&lt;ref_view&lt;R&gt;&gt; {
  private:
    R* r_;                      // exposition only
  public:
    template&lt;__different_from&lt;ref_view&gt; T&gt;
      requires /* see description */
    constexpr ref_view(T&amp;&amp; t);
 
    constexpr R&amp; base() const { return *r_; }
 
    constexpr iterator_t&lt;R&gt; begin() const { return ranges::begin(*r_); }
    constexpr sentinel_t&lt;R&gt; end() const { return ranges::end(*r_); }
 
    constexpr bool empty() const
      requires requires { ranges::empty(*r_); }
    { return ranges::empty(*r_); }
 
    constexpr auto size() const requires sized_range&lt;R&gt;
    { return ranges::size(*r_); }
 
    constexpr auto data() const requires contiguous_range&lt;R&gt;
    { return ranges::data(*r_); }
  };
 
  template&lt;class R&gt;
    ref_view(R&amp;) -&gt; ref_view&lt;R&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::owning_view"> Class template <code>std::ranges::owning_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;range R&gt;
    requires movable&lt;R&gt; &amp;&amp; (!__is_initializer_list&lt;R&gt;)
  class owning_view : public view_interface&lt;owning_view&lt;R&gt;&gt; {
  private:
    R r_ = R();         // exposition only
  public:
    owning_view() requires default_initializable&lt;R&gt; = default;
    constexpr owning_view(R&amp;&amp; t);
 
    owning_view(owning_view&amp;&amp;) = default;
    owning_view&amp; operator=(owning_view&amp;&amp;) = default;
 
    constexpr R&amp; base() &amp; noexcept { return r_; }
    constexpr const R&amp; base() const &amp; noexcept { return r_; }
    constexpr R&amp;&amp; base() &amp;&amp; noexcept { return std::move(r_); }
    constexpr const R&amp;&amp; base() const &amp;&amp; noexcept { return std::move(r_); }
 
    constexpr iterator_t&lt;R&gt; begin() { return ranges::begin(r_); }
    constexpr sentinel_t&lt;R&gt; end() { return ranges::end(r_); }
 
    constexpr auto begin() const requires range&lt;const R&gt;
    { return ranges::begin(r_); }
    constexpr auto end() const requires range&lt;const R&gt;
    { return ranges::end(r_); }
 
    constexpr bool empty() requires requires { ranges::empty(r_); }
    { return ranges::empty(r_); }
    constexpr bool empty() const requires requires { ranges::empty(r_); }
    { return ranges::empty(r_); }
 
    constexpr auto size() requires sized_range&lt;R&gt;
    { return ranges::size(r_); }
    constexpr auto size() const requires sized_range&lt;const R&gt;
    { return ranges::size(r_); }
 
    constexpr auto data() requires contiguous_range&lt;R&gt;
    { return ranges::data(r_); }
    constexpr auto data() const requires contiguous_range&lt;const R&gt;
    { return ranges::data(r_); }
  };
}</pre></div> <h4 id="Class_template_std::ranges::as_rvalue_view"> Class template <code>std::ranges::as_rvalue_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;view V&gt;
    requires input_range&lt;V&gt;
  class as_rvalue_view : public view_interface&lt;as_rvalue_view&lt;V&gt;&gt; {
    V base_ = V();      // exposition only
 
  public:
    as_rvalue_view() requires default_initializable&lt;V&gt; = default;
    constexpr explicit as_rvalue_view(V base);
 
    constexpr V base() const &amp; requires copy_constructible&lt;V&gt; { return base_; }
    constexpr V base() &amp;&amp; { return std::move(base_); }
 
    constexpr auto begin() requires (!__simple_view&lt;V&gt;)
    { return move_iterator(ranges::begin(base_)); }
    constexpr auto begin() const requires range&lt;const V&gt;
    { return move_iterator(ranges::begin(base_)); }
 
    constexpr auto end() requires (!__simple_view&lt;V&gt;) {
      if constexpr (common_range&lt;V&gt;) {
        return move_iterator(ranges::end(base_));
      } else {
        return move_sentinel(ranges::end(base_));
      }
    }
    constexpr auto end() const requires range&lt;const V&gt; {
      if constexpr (common_range&lt;const V&gt;) {
        return move_iterator(ranges::end(base_));
      } else {
        return move_sentinel(ranges::end(base_));
      }
    }
 
    constexpr auto size() requires sized_range&lt;V&gt; { return ranges::size(base_); }
    constexpr auto size() const requires sized_range&lt;const V&gt; {
        return ranges::size(base_);
    }
  };
 
  template&lt;class R&gt;
    as_rvalue_view(R&amp;&amp;) -&gt; as_rvalue_view&lt;views::all_t&lt;R&gt;&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::filter_view"> Class template <code><a href="../ranges/filter_view" title="cpp/ranges/filter view">std::ranges::filter_view</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;input_range V, indirect_unary_predicate&lt;iterator_t&lt;V&gt;&gt; Pred&gt;
    requires view&lt;V&gt; &amp;&amp; is_object_v&lt;Pred&gt;
  class filter_view : public view_interface&lt;filter_view&lt;V, Pred&gt;&gt; {
  private:
    V base_ = V();                              // exposition only
    __movable_box&lt;Pred&gt; pred_;                  // exposition only
 
    // class filter_view::iterator
    class iterator;                             // exposition only
 
    // class filter_view::sentinel
    class sentinel;                             // exposition only
 
  public:
    filter_view() requires default_initializable&lt;V&gt; &amp;&amp;
      default_initializable&lt;Pred&gt; = default;
    constexpr explicit filter_view(V base, Pred pred);
 
    constexpr V base() const &amp; requires copy_constructible&lt;V&gt; { return base_; }
    constexpr V base() &amp;&amp; { return std::move(base_); }
 
    constexpr const Pred&amp; pred() const;
 
    constexpr iterator begin();
    constexpr auto end() {
      if constexpr (common_range&lt;V&gt;)
        return iterator{*this, ranges::end(base_)};
      else
        return sentinel{*this};
    }
  };
 
  template&lt;class R, class Pred&gt;
    filter_view(R&amp;&amp;, Pred) -&gt; filter_view&lt;views::all_t&lt;R&gt;, Pred&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::filter_view::iterator"> Class template <code>std::ranges::filter_view::iterator</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;input_range V, indirect_unary_predicate&lt;iterator_t&lt;V&gt;&gt; Pred&gt;
    requires view&lt;V&gt; &amp;&amp; is_object_v&lt;Pred&gt;
  class filter_view&lt;V, Pred&gt;::iterator {
  private:
    iterator_t&lt;V&gt; current_ = iterator_t&lt;V&gt;();   // exposition only
    filter_view* parent_ = nullptr;             // exposition only
 
  public:
    using iterator_concept  = /* see description */;
    using iterator_category = /* see description */;        // not always present
    using value_type        = range_value_t&lt;V&gt;;
    using difference_type   = range_difference_t&lt;V&gt;;
 
    iterator() requires default_initializable&lt;iterator_t&lt;V&gt;&gt; = default;
    constexpr iterator(filter_view&amp; parent, iterator_t&lt;V&gt; current);
 
    constexpr const iterator_t&lt;V&gt;&amp; base() const &amp; noexcept;
    constexpr iterator_t&lt;V&gt; base() &amp;&amp;;
    constexpr range_reference_t&lt;V&gt; operator*() const;
    constexpr iterator_t&lt;V&gt; operator-&gt;() const
      requires __has_arrow&lt;iterator_t&lt;V&gt;&gt; &amp;&amp; copyable&lt;iterator_t&lt;V&gt;&gt;;
 
    constexpr iterator&amp; operator++();
    constexpr void operator++(int);
    constexpr iterator operator++(int) requires forward_range&lt;V&gt;;
 
    constexpr iterator&amp; operator--() requires bidirectional_range&lt;V&gt;;
    constexpr iterator operator--(int) requires bidirectional_range&lt;V&gt;;
 
    friend constexpr bool operator==(const iterator&amp; x, const iterator&amp; y)
      requires equality_comparable&lt;iterator_t&lt;V&gt;&gt;;
 
    friend constexpr range_rvalue_reference_t&lt;V&gt; iter_move(const iterator&amp; i)
      noexcept(noexcept(ranges::iter_move(i.current_)));
 
    friend constexpr void iter_swap(const iterator&amp; x, const iterator&amp; y)
      noexcept(noexcept(ranges::iter_swap(x.current_, y.current_)))
      requires indirectly_swappable&lt;iterator_t&lt;V&gt;&gt;;
  };
}</pre></div> <h4 id="Class_template_std::ranges::filter_view::sentinel"> Class template <code>std::ranges::filter_view::sentinel</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;input_range V, indirect_unary_predicate&lt;iterator_t&lt;V&gt;&gt; Pred&gt;
    requires view&lt;V&gt; &amp;&amp; is_object_v&lt;Pred&gt;
  class filter_view&lt;V, Pred&gt;::sentinel {
  private:
    sentinel_t&lt;V&gt; end_ = sentinel_t&lt;V&gt;();       // exposition only
 
  public:
    sentinel() = default;
    constexpr explicit sentinel(filter_view&amp; parent);
 
    constexpr sentinel_t&lt;V&gt; base() const;
 
    friend constexpr bool operator==(const iterator&amp; x, const sentinel&amp; y);
  };
}</pre></div> <h4 id="Class_template_std::ranges::transform_view"> Class template <code><a href="../ranges/transform_view" title="cpp/ranges/transform view">std::ranges::transform_view</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;input_range V, move_constructible F&gt;
    requires view&lt;V&gt; &amp;&amp; is_object_v&lt;F&gt; &amp;&amp;
             regular_invocable&lt;F&amp;, range_reference_t&lt;V&gt;&gt; &amp;&amp;
             __can_reference&lt;invoke_result_t&lt;F&amp;, range_reference_t&lt;V&gt;&gt;&gt;
  class transform_view : public view_interface&lt;transform_view&lt;V, F&gt;&gt; {
  private:
    // class template transform_view::iterator
    template&lt;bool&gt; struct iterator;             // exposition only
 
    // class template transform_view::sentinel
    template&lt;bool&gt; struct sentinel;             // exposition only
 
    V base_ = V();                              // exposition only
    __movable_box&lt;F&gt; fun_;                      // exposition only
 
  public:
    transform_view() requires default_initializable&lt;V&gt; &amp;&amp;
      default_initializable&lt;F&gt; = default;
    constexpr explicit transform_view(V base, F fun);
 
    constexpr V base() const &amp; requires copy_constructible&lt;V&gt; { return base_; }
    constexpr V base() &amp;&amp; { return std::move(base_); }
 
    constexpr iterator&lt;false&gt; begin();
    constexpr iterator&lt;true&gt; begin() const
      requires range&lt;const V&gt; &amp;&amp;
               regular_invocable&lt;const F&amp;, range_reference_t&lt;const V&gt;&gt;;
 
    constexpr sentinel&lt;false&gt; end();
    constexpr iterator&lt;false&gt; end() requires common_range&lt;V&gt;;
    constexpr sentinel&lt;true&gt; end() const
      requires range&lt;const V&gt; &amp;&amp;
               regular_invocable&lt;const F&amp;, range_reference_t&lt;const V&gt;&gt;;
    constexpr iterator&lt;true&gt; end() const
      requires common_range&lt;const V&gt; &amp;&amp;
               regular_invocable&lt;const F&amp;, range_reference_t&lt;const V&gt;&gt;;
 
    constexpr auto size() requires sized_range&lt;V&gt; { return ranges::size(base_); }
    constexpr auto size() const requires sized_range&lt;const V&gt;
    { return ranges::size(base_); }
  };
 
  template&lt;class R, class F&gt;
    transform_view(R&amp;&amp;, F) -&gt; transform_view&lt;views::all_t&lt;R&gt;, F&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::transform_view::iterator"> Class template <code>std::ranges::transform_view::iterator</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;input_range V, move_constructible F&gt;
    requires view&lt;V&gt; &amp;&amp; is_object_v&lt;F&gt; &amp;&amp;
             regular_invocable&lt;F&amp;, range_reference_t&lt;V&gt;&gt; &amp;&amp;
             __can_reference&lt;invoke_result_t&lt;F&amp;, range_reference_t&lt;V&gt;&gt;&gt;
  template&lt;bool Const&gt;
  class transform_view&lt;V, F&gt;::iterator {
  private:
    using Parent = __maybe_const&lt;Const, transform_view&gt;;        // exposition only
    using Base = __maybe_const&lt;Const, V&gt;;                       // exposition only
    iterator_t&lt;Base&gt; current_ = iterator_t&lt;Base&gt;();             // exposition only
    Parent* parent_ = nullptr;                                  // exposition only
 
  public:
    using iterator_concept  = /* see description */;
    using iterator_category = /* see description */;            // not always present
    using value_type        =
      remove_cvref_t&lt;invoke_result_t&lt;__maybe_const&lt;Const, F&gt;&amp;, range_reference_t&lt;Base&gt;&gt;&gt;;
    using difference_type   = range_difference_t&lt;Base&gt;;
 
    iterator() requires default_initializable&lt;iterator_t&lt;Base&gt;&gt; = default;
    constexpr iterator(Parent&amp; parent, iterator_t&lt;Base&gt; current);
    constexpr iterator(iterator&lt;!Const&gt; i)
      requires Const &amp;&amp; convertible_to&lt;iterator_t&lt;V&gt;, iterator_t&lt;Base&gt;&gt;;
 
    constexpr const iterator_t&lt;Base&gt;&amp; base() const &amp; noexcept;
    constexpr iterator_t&lt;Base&gt; base() &amp;&amp;;
 
    constexpr decltype(auto) operator*() const
      noexcept(noexcept(invoke(*parent_-&gt;fun_, *current_))) {
      return invoke(*parent_-&gt;fun_, *current_);
    }
 
    constexpr iterator&amp; operator++();
    constexpr void operator++(int);
    constexpr iterator operator++(int) requires forward_range&lt;Base&gt;;
 
    constexpr iterator&amp; operator--() requires bidirectional_range&lt;Base&gt;;
    constexpr iterator operator--(int) requires bidirectional_range&lt;Base&gt;;
 
    constexpr iterator&amp; operator+=(difference_type n)
      requires random_access_range&lt;Base&gt;;
    constexpr iterator&amp; operator-=(difference_type n)
      requires random_access_range&lt;Base&gt;;
 
    constexpr decltype(auto) operator[](difference_type n) const
      requires random_access_range&lt;Base&gt; {
      return invoke(*parent_-&gt;fun_, current_[n]);
    }
 
    friend constexpr bool operator==(const iterator&amp; x, const iterator&amp; y)
      requires equality_comparable&lt;iterator_t&lt;Base&gt;&gt;;
 
    friend constexpr bool operator&lt;(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr bool operator&gt;(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr bool operator&lt;=(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr bool operator&gt;=(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr auto operator&lt;=&gt;(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt; &amp;&amp; three_way_comparable&lt;iterator_t&lt;Base&gt;&gt;;
 
    friend constexpr iterator operator+(iterator i, difference_type n)
      requires random_access_range&lt;Base&gt;;
    friend constexpr iterator operator+(difference_type n, iterator i)
      requires random_access_range&lt;Base&gt;;
 
    friend constexpr iterator operator-(iterator i, difference_type n)
      requires random_access_range&lt;Base&gt;;
    friend constexpr difference_type operator-(const iterator&amp; x, const iterator&amp; y)
      requires sized_sentinel_for&lt;iterator_t&lt;Base&gt;, iterator_t&lt;Base&gt;&gt;;
  };
}</pre></div> <h4 id="Class_template_std::ranges::transform_view::sentinel"> Class template <code>std::ranges::transform_view::sentinel</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;input_range V, move_constructible F&gt;
    requires view&lt;V&gt; &amp;&amp; is_object_v&lt;F&gt; &amp;&amp;
             regular_invocable&lt;F&amp;, range_reference_t&lt;V&gt;&gt; &amp;&amp;
             __can_reference&lt;invoke_result_t&lt;F&amp;, range_reference_t&lt;V&gt;&gt;&gt;
  template&lt;bool Const&gt;
  class transform_view&lt;V, F&gt;::sentinel {
  private:
    using Parent = __maybe_const&lt;Const, transform_view&gt;;    // exposition only
    using Base = __maybe_const&lt;Const, V&gt;;                   // exposition only
    sentinel_t&lt;Base&gt; end_ = sentinel_t&lt;Base&gt;();             // exposition only
  public:
    sentinel() = default;
    constexpr explicit sentinel(sentinel_t&lt;Base&gt; end);
    constexpr sentinel(sentinel&lt;!Const&gt; i)
      requires Const &amp;&amp; convertible_to&lt;sentinel_t&lt;V&gt;, sentinel_t&lt;Base&gt;&gt;;
 
    constexpr sentinel_t&lt;Base&gt; base() const;
 
    template&lt;bool OtherConst&gt;
      requires sentinel_for&lt;sentinel_t&lt;Base&gt;, iterator_t&lt;__maybe_const&lt;OtherConst, V&gt;&gt;&gt;
    friend constexpr bool operator==(const iterator&lt;OtherConst&gt;&amp; x, const sentinel&amp; y);
 
    template&lt;bool OtherConst&gt;
      requires sized_sentinel_for&lt;sentinel_t&lt;Base&gt;,
        iterator_t&lt;__maybe_const&lt;OtherConst, V&gt;&gt;&gt;
    friend constexpr range_difference_t&lt;__maybe_const&lt;OtherConst, V&gt;&gt;
      operator-(const iterator&lt;OtherConst&gt;&amp; x, const sentinel&amp; y);
 
    template&lt;bool OtherConst&gt;
      requires sized_sentinel_for&lt;sentinel_t&lt;Base&gt;,
        iterator_t&lt;__maybe_const&lt;OtherConst, V&gt;&gt;&gt;
    friend constexpr range_difference_t&lt;__maybe_const&lt;OtherConst, V&gt;&gt;
      operator-(const sentinel&amp; y, const iterator&lt;OtherConst&gt;&amp; x);
  };
}</pre></div> <h4 id="Class_template_std::ranges::take_view"> Class template <code><a href="../ranges/take_view" title="cpp/ranges/take view">std::ranges::take_view</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;view V&gt;
  class take_view : public view_interface&lt;take_view&lt;V&gt;&gt; {
  private:
    V base_ = V();                                      // exposition only
    range_difference_t&lt;V&gt; count_ = 0;                   // exposition only
 
    // class template take_view::sentinel
    template&lt;bool&gt; class sentinel;                      // exposition only
 
  public:
    take_view() requires default_initializable&lt;V&gt; = default;
    constexpr explicit take_view(V base, range_difference_t&lt;V&gt; count);
 
    constexpr V base() const &amp; requires copy_constructible&lt;V&gt; { return base_; }
    constexpr V base() &amp;&amp; { return std::move(base_); }
 
    constexpr auto begin() requires (!__simple_view&lt;V&gt;) {
      if constexpr (sized_range&lt;V&gt;) {
        if constexpr (random_access_range&lt;V&gt;) {
          return ranges::begin(base_);
        } else {
          auto sz = range_difference_t&lt;V&gt;(size());
          return counted_iterator(ranges::begin(base_), sz);
        }
      } else {
        return counted_iterator(ranges::begin(base_), count_);
      }
    }
 
    constexpr auto begin() const requires range&lt;const V&gt; {
      if constexpr (sized_range&lt;const V&gt;) {
        if constexpr (random_access_range&lt;const V&gt;) {
          return ranges::begin(base_);
        } else {
          auto sz = range_difference_t&lt;const V&gt;(size());
          return counted_iterator(ranges::begin(base_), sz);
        }
      } else {
        return counted_iterator(ranges::begin(base_), count_);
      }
    }
 
    constexpr auto end() requires (!__simple_view&lt;V&gt;) {
      if constexpr (sized_range&lt;V&gt;) {
        if constexpr (random_access_range&lt;V&gt;)
          return ranges::begin(base_) + range_difference_t&lt;V&gt;(size());
        else
          return default_sentinel;
      } else {
        return sentinel&lt;false&gt;{ranges::end(base_)};
      }
    }
 
    constexpr auto end() const requires range&lt;const V&gt; {
      if constexpr (sized_range&lt;const V&gt;) {
        if constexpr (random_access_range&lt;const V&gt;)
          return ranges::begin(base_) + range_difference_t&lt;const V&gt;(size());
        else
          return default_sentinel;
      } else {
        return sentinel&lt;true&gt;{ranges::end(base_)};
      }
    }
 
    constexpr auto size() requires sized_range&lt;V&gt; {
      auto n = ranges::size(base_);
      return ranges::min(n, static_cast&lt;decltype(n)&gt;(count_));
    }
 
    constexpr auto size() const requires sized_range&lt;const V&gt; {
      auto n = ranges::size(base_);
      return ranges::min(n, static_cast&lt;decltype(n)&gt;(count_));
    }
  };
 
  template&lt;class R&gt;
    take_view(R&amp;&amp;, range_difference_t&lt;R&gt;)
      -&gt; take_view&lt;views::all_t&lt;R&gt;&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::take_view::sentinel"> Class template <code>std::ranges::take_view::sentinel</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;view V&gt;
  template&lt;bool Const&gt;
  class take_view&lt;V&gt;::sentinel {
  private:
    using Base = __maybe_const&lt;Const, V&gt;;                           // exposition only
    template&lt;bool OtherConst&gt;
      using CI = counted_iterator&lt;
        iterator_t&lt;__maybe_const&lt;OtherConst, V&gt;&gt;&gt;;                  // exposition only
    sentinel_t&lt;Base&gt; end_ = sentinel_t&lt;Base&gt;();                     // exposition only
  public:
    sentinel() = default;
    constexpr explicit sentinel(sentinel_t&lt;Base&gt; end);
    constexpr sentinel(sentinel&lt;!Const&gt; s)
      requires Const &amp;&amp; convertible_to&lt;sentinel_t&lt;V&gt;, sentinel_t&lt;Base&gt;&gt;;
 
    constexpr sentinel_t&lt;Base&gt; base() const;
 
    friend constexpr bool operator==(const CI&lt;Const&gt;&amp; y, const sentinel&amp; x);
 
    template&lt;bool OtherConst = !Const&gt;
      requires sentinel_for&lt;sentinel_t&lt;Base&gt;, iterator_t&lt;__maybe_const&lt;OtherConst, V&gt;&gt;&gt;
    friend constexpr bool operator==(const CI&lt;OtherConst&gt;&amp; y, const sentinel&amp; x);
  };
}</pre></div> <h4 id="Class_template_std::ranges::take_while_view"> Class template <code><a href="../ranges/take_while_view" title="cpp/ranges/take while view">std::ranges::take_while_view</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;view V, class Pred&gt;
    requires input_range&lt;V&gt; &amp;&amp; is_object_v&lt;Pred&gt; &amp;&amp;
             indirect_unary_predicate&lt;const Pred, iterator_t&lt;V&gt;&gt;
  class take_while_view : public view_interface&lt;take_while_view&lt;V, Pred&gt;&gt; {
    // class template take_while_view::sentinel
    template&lt;bool&gt; class sentinel;                      // exposition only
 
    V base_ = V();                                      // exposition only
    __movable_box&lt;Pred&gt; pred_;                          // exposition only
 
  public:
    take_while_view() requires default_initializable&lt;V&gt; &amp;&amp;
      default_initializable&lt;Pred&gt; = default;
    constexpr explicit take_while_view(V base, Pred pred);
 
    constexpr V base() const &amp; requires copy_constructible&lt;V&gt; { return base_; }
    constexpr V base() &amp;&amp; { return std::move(base_); }
 
    constexpr const Pred&amp; pred() const;
 
    constexpr auto begin() requires (!__simple_view&lt;V&gt;)
    { return ranges::begin(base_); }
 
    constexpr auto begin() const
      requires range&lt;const V&gt; &amp;&amp;
               indirect_unary_predicate&lt;const Pred, iterator_t&lt;const V&gt;&gt;
    { return ranges::begin(base_); }
 
    constexpr auto end() requires (!__simple_view&lt;V&gt;)
    { return sentinel&lt;false&gt;(ranges::end(base_), addressof(*pred_)); }
 
    constexpr auto end() const
      requires range&lt;const V&gt; &amp;&amp;
               indirect_unary_predicate&lt;const Pred, iterator_t&lt;const V&gt;&gt;
    { return sentinel&lt;true&gt;(ranges::end(base_), addressof(*pred_)); }
  };
 
  template&lt;class R, class Pred&gt;
    take_while_view(R&amp;&amp;, Pred) -&gt; take_while_view&lt;views::all_t&lt;R&gt;, Pred&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::take_while_view::sentinel"> Class template <code>std::ranges::take_while_view::sentinel</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;view V, class Pred&gt;
    requires input_range&lt;V&gt; &amp;&amp; is_object_v&lt;Pred&gt; &amp;&amp;
             indirect_unary_predicate&lt;const Pred, iterator_t&lt;V&gt;&gt;
  template&lt;bool Const&gt;
  class take_while_view&lt;V, Pred&gt;::sentinel {
    using Base = __maybe_const&lt;Const, V&gt;;               // exposition only
 
    sentinel_t&lt;Base&gt; end_ = sentinel_t&lt;Base&gt;();         // exposition only
    const Pred* pred_ = nullptr;                        // exposition only
 
  public:
    sentinel() = default;
    constexpr explicit sentinel(sentinel_t&lt;Base&gt; end, const Pred* pred);
    constexpr sentinel(sentinel&lt;!Const&gt; s)
      requires Const &amp;&amp; convertible_to&lt;sentinel_t&lt;V&gt;, sentinel_t&lt;Base&gt;&gt;;
 
    constexpr sentinel_t&lt;Base&gt; base() const { return end_; }
 
    friend constexpr bool operator==(const iterator_t&lt;Base&gt;&amp; x, const sentinel&amp; y);
 
    template&lt;bool OtherConst = !Const&gt;
      requires sentinel_for&lt;sentinel_t&lt;Base&gt;, iterator_t&lt;__maybe_const&lt;OtherConst, V&gt;&gt;&gt;
    friend constexpr bool operator==(const iterator_t&lt;__maybe_const&lt;OtherConst, V&gt;&gt;&amp; x,
                                     const sentinel&amp; y);
  };
}</pre></div> <h4 id="Class_template_std::ranges::drop_view"> Class template <code><a href="../ranges/drop_view" title="cpp/ranges/drop view">std::ranges::drop_view</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;view V&gt;
  class drop_view : public view_interface&lt;drop_view&lt;V&gt;&gt; {
  public:
    drop_view() requires default_initializable&lt;V&gt; = default;
    constexpr explicit drop_view(V base, range_difference_t&lt;V&gt; count);
 
    constexpr V base() const &amp; requires copy_constructible&lt;V&gt; { return base_; }
    constexpr V base() &amp;&amp; { return std::move(base_); }
 
    constexpr auto begin()
      requires (!(__simple_view&lt;V&gt; &amp;&amp;
                  random_access_range&lt;const V&gt; &amp;&amp; sized_range&lt;const V&gt;));
    constexpr auto begin() const
      requires random_access_range&lt;const V&gt; &amp;&amp; sized_range&lt;const V&gt;;
 
    constexpr auto end() requires (!__simple_view&lt;V&gt;)
    { return ranges::end(base_); }
 
    constexpr auto end() const requires range&lt;const V&gt;
    { return ranges::end(base_); }
 
    constexpr auto size() requires sized_range&lt;V&gt; {
      const auto s = ranges::size(base_);
      const auto c = static_cast&lt;decltype(s)&gt;(count_);
      return s &lt; c ? 0 : s - c;
    }
 
    constexpr auto size() const requires sized_range&lt;const V&gt; {
      const auto s = ranges::size(base_);
      const auto c = static_cast&lt;decltype(s)&gt;(count_);
      return s &lt; c ? 0 : s - c;
    }
 
  private:
    V base_ = V();                              // exposition only
    range_difference_t&lt;V&gt; count_ = 0;           // exposition only
  };
 
  template&lt;class R&gt;
    drop_view(R&amp;&amp;, range_difference_t&lt;R&gt;) -&gt; drop_view&lt;views::all_t&lt;R&gt;&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::drop_while_view"> Class template <code><a href="../ranges/drop_while_view" title="cpp/ranges/drop while view">std::ranges::drop_while_view</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;view V, class Pred&gt;
    requires input_range&lt;V&gt; &amp;&amp; is_object_v&lt;Pred&gt; &amp;&amp;
             indirect_unary_predicate&lt;const Pred, iterator_t&lt;V&gt;&gt;
  class drop_while_view : public view_interface&lt;drop_while_view&lt;V, Pred&gt;&gt; {
  public:
    drop_while_view() requires default_initializable&lt;V&gt; &amp;&amp;
      default_initializable&lt;Pred&gt; = default;
    constexpr explicit drop_while_view(V base, Pred pred);
 
    constexpr V base() const &amp; requires copy_constructible&lt;V&gt; { return base_; }
    constexpr V base() &amp;&amp; { return std::move(base_); }
 
    constexpr const Pred&amp; pred() const;
 
    constexpr auto begin();
 
    constexpr auto end() { return ranges::end(base_); }
 
  private:
    V base_ = V();                                      // exposition only
    __movable_box&lt;Pred&gt; pred_;                          // exposition only
  };
 
  template&lt;class R, class Pred&gt;
    drop_while_view(R&amp;&amp;, Pred) -&gt; drop_while_view&lt;views::all_t&lt;R&gt;, Pred&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::join_view"> Class template <code>std::ranges::join_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;input_range V&gt;
    requires view&lt;V&gt; &amp;&amp; input_range&lt;range_reference_t&lt;V&gt;&gt;
  class join_view : public view_interface&lt;join_view&lt;V&gt;&gt; {
  private:
    using InnerRng = range_reference_t&lt;V&gt;;                  // exposition only
 
    // class template join_view::iterator
    template&lt;bool Const&gt;
      struct iterator;                                      // exposition only
 
    // class template join_view::sentinel
    template&lt;bool Const&gt;
      struct sentinel;                                      // exposition only
 
    V base_ = V();                                          // exposition only
 
    __non_propagating_cache&lt;remove_cv_t&lt;InnerRng&gt;&gt; inner_;
                                                    // exposition only, present only
                                                    // when !is_reference_v&lt;InnerRng&gt;
 
  public:
    join_view() requires default_initializable&lt;V&gt; = default;
    constexpr explicit join_view(V base);
 
    constexpr V base() const &amp; requires copy_constructible&lt;V&gt; { return base_; }
    constexpr V base() &amp;&amp; { return std::move(base_); }
 
    constexpr auto begin() {
      constexpr bool use_const = __simple_view&lt;V&gt; &amp;&amp;
                                 is_reference_v&lt;InnerRng&gt;;
      return iterator&lt;use_const&gt;{*this, ranges::begin(base_)};
    }
 
    constexpr auto begin() const
      requires input_range&lt;const V&gt; &amp;&amp;
               is_reference_v&lt;range_reference_t&lt;const V&gt;&gt;
    { return iterator&lt;true&gt;{*this, ranges::begin(base_)}; }
 
    constexpr auto end() {
      if constexpr (forward_range&lt;V&gt; &amp;&amp;
                    is_reference_v&lt;InnerRng&gt; &amp;&amp; forward_range&lt;InnerRng&gt; &amp;&amp;
                    common_range&lt;V&gt; &amp;&amp; common_range&lt;InnerRng&gt;)
        return iterator&lt;__simple_view&lt;V&gt;&gt;{*this, ranges::end(base_)};
      else
        return sentinel&lt;__simple_view&lt;V&gt;&gt;{*this};
    }
 
    constexpr auto end() const
      requires input_range&lt;const V&gt; &amp;&amp;
               is_reference_v&lt;range_reference_t&lt;const V&gt;&gt; {
      if constexpr (forward_range&lt;const V&gt; &amp;&amp;
                    forward_range&lt;range_reference_t&lt;const V&gt;&gt; &amp;&amp;
                    common_range&lt;const V&gt; &amp;&amp;
                    common_range&lt;range_reference_t&lt;const V&gt;&gt;)
        return iterator&lt;true&gt;{*this, ranges::end(base_)};
      else
        return sentinel&lt;true&gt;{*this};
    }
  };
 
  template&lt;class R&gt;
    explicit join_view(R&amp;&amp;) -&gt; join_view&lt;views::all_t&lt;R&gt;&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::join_view::iterator"> Class template <code>std::ranges::join_view::iterator</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;input_range V&gt;
    requires view&lt;V&gt; &amp;&amp; input_range&lt;range_reference_t&lt;V&gt;&gt;
  template&lt;bool Const&gt;
  struct join_view&lt;V&gt;::iterator {
  private:
    using Parent    = __maybe_const&lt;Const, join_view&gt;;          // exposition only
    using Base      = __maybe_const&lt;Const, V&gt;;                  // exposition only
    using OuterIter = iterator_t&lt;Base&gt;;                         // exposition only
    using InnerIter = iterator_t&lt;range_reference_t&lt;Base&gt;&gt;;      // exposition only
 
    static constexpr bool __ref_is_glvalue =                    // exposition only
      is_reference_v&lt;range_reference_t&lt;Base&gt;&gt;;
 
    OuterIter outer_ = OuterIter();                             // exposition only
    InnerIter inner_ = InnerIter();                             // exposition only
    Parent* parent_  = nullptr;                                 // exposition only
 
    constexpr void satisfy();                                   // exposition only
 
  public:
    using iterator_concept  = /* see description */;
    using iterator_category = /* see description */;            // not always present
    using value_type        = range_value_t&lt;range_reference_t&lt;Base&gt;&gt;;
    using difference_type   = /* see description */;
 
    iterator() requires default_initializable&lt;OuterIter&gt; &amp;&amp;
                         default_initializable&lt;InnerIter&gt; = default;
    constexpr iterator(Parent&amp; parent, OuterIter outer);
    constexpr iterator(iterator&lt;!Const&gt; i)
      requires Const &amp;&amp;
               convertible_to&lt;iterator_t&lt;V&gt;, OuterIter&gt; &amp;&amp;
               convertible_to&lt;iterator_t&lt;InnerRng&gt;, InnerIter&gt;;
 
    constexpr decltype(auto) operator*() const { return *inner_; }
 
    constexpr InnerIter operator-&gt;() const
      requires __has_arrow&lt;InnerIter&gt; &amp;&amp; copyable&lt;InnerIter&gt;;
 
    constexpr iterator&amp; operator++();
    constexpr void operator++(int);
    constexpr iterator operator++(int)
      requires __ref_is_glvalue &amp;&amp; forward_range&lt;Base&gt; &amp;&amp;
               forward_range&lt;range_reference_t&lt;Base&gt;&gt;;
 
    constexpr iterator&amp; operator--()
      requires __ref_is_glvalue &amp;&amp; bidirectional_range&lt;Base&gt; &amp;&amp;
               bidirectional_range&lt;range_reference_t&lt;Base&gt;&gt; &amp;&amp;
               common_range&lt;range_reference_t&lt;Base&gt;&gt;;
 
    constexpr iterator operator--(int)
      requires __ref_is_glvalue &amp;&amp; bidirectional_range&lt;Base&gt; &amp;&amp;
               bidirectional_range&lt;range_reference_t&lt;Base&gt;&gt; &amp;&amp;
               common_range&lt;range_reference_t&lt;Base&gt;&gt;;
 
    friend constexpr bool operator==(const iterator&amp; x, const iterator&amp; y)
      requires __ref_is_glvalue &amp;&amp; equality_comparable&lt;iterator_t&lt;Base&gt;&gt; &amp;&amp;
               equality_comparable&lt;iterator_t&lt;range_reference_t&lt;Base&gt;&gt;&gt;;
 
    friend constexpr decltype(auto) iter_move(const iterator&amp; i)
    noexcept(noexcept(ranges::iter_move(i.inner_))) {
      return ranges::iter_move(i.inner_);
    }
 
    friend constexpr void iter_swap(const iterator&amp; x, const iterator&amp; y)
      noexcept(noexcept(ranges::iter_swap(x.inner_, y.inner_)))
      requires indirectly_swappable&lt;InnerIter&gt;;
  };
}</pre></div> <h4 id="Class_template_std::ranges::join_view::sentinel"> Class template <code>std::ranges::join_view::sentinel</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;input_range V&gt;
    requires view&lt;V&gt; &amp;&amp; input_range&lt;range_reference_t&lt;V&gt;&gt;
  template&lt;bool Const&gt;
  struct join_view&lt;V&gt;::sentinel {
  private:
    using Parent = __maybe_const&lt;Const, join_view&gt;;     // exposition only
    using Base = __maybe_const&lt;Const, V&gt;;               // exposition only
    sentinel_t&lt;Base&gt; end_ = sentinel_t&lt;Base&gt;();         // exposition only
 
  public:
    sentinel() = default;
 
    constexpr explicit sentinel(Parent&amp; parent);
    constexpr sentinel(sentinel&lt;!Const&gt; s)
      requires Const &amp;&amp; convertible_to&lt;sentinel_t&lt;V&gt;, sentinel_t&lt;Base&gt;&gt;;
 
    template&lt;bool OtherConst&gt;
      requires sentinel_for&lt;sentinel_t&lt;Base&gt;, iterator_t&lt;__maybe_const&lt;OtherConst, V&gt;&gt;&gt;
    friend constexpr bool operator==(const iterator&lt;OtherConst&gt;&amp; x, const sentinel&amp; y);
  };
}</pre></div> <h4 id="Class_template_std::ranges::join_with_view"> Class template <code>std::ranges::join_with_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class R, class P&gt;
  concept __compatible_joinable_ranges =            // exposition only
      common_with&lt;range_value_t&lt;R&gt;, range_value_t&lt;P&gt;&gt; &amp;&amp;
      common_reference_with&lt;range_reference_t&lt;R&gt;, range_reference_t&lt;P&gt;&gt; &amp;&amp;
      common_reference_with&lt;range_rvalue_reference_t&lt;R&gt;, range_rvalue_reference_t&lt;P&gt;&gt;;
 
  template&lt;class R&gt;
  concept __bidirectional_common = bidirectional_range&lt;R&gt; &amp;&amp;
    common_range&lt;R&gt;;                                        // exposition only
 
  template&lt;input_range V, forward_range Pattern&gt;
    requires view&lt;V&gt; &amp;&amp; input_range&lt;range_reference_t&lt;V&gt;&gt;
          &amp;&amp; view&lt;Pattern&gt;
          &amp;&amp; __compatible_joinable_ranges&lt;range_reference_t&lt;V&gt;, Pattern&gt;
  class join_with_view : public view_interface&lt;join_with_view&lt;V, Pattern&gt;&gt; {
    using InnerRng = range_reference_t&lt;V&gt;;                  // exposition only
 
    V base_ = V();                                          // exposition only
    __non_propagating_cache&lt;remove_cv_t&lt;InnerRng&gt;&gt; inner_;
        // exposition only, present only
        // when !is_reference_v&lt;InnerRng&gt;
 
    Pattern pattern_ = Pattern();                           // exposition only
 
    // class template join_with_view::iterator
    template&lt;bool Const&gt; struct iterator;                   // exposition only
 
    // class template join_with_view::sentinel
    template&lt;bool Const&gt; struct sentinel;                   // exposition only
 
  public:
    join_with_view()
      requires default_initializable&lt;V&gt; &amp;&amp; default_initializable&lt;Pattern&gt; = default;
 
    constexpr explicit join_with_view(V base, Pattern pattern);
 
    template&lt;input_range R&gt;
      requires constructible_from&lt;V, views::all_t&lt;R&gt;&gt; &amp;&amp;
               constructible_from&lt;Pattern, single_view&lt;range_value_t&lt;InnerRng&gt;&gt;&gt;
    constexpr explicit join_with_view(R&amp;&amp; r, range_value_t&lt;InnerRng&gt; e);
 
    constexpr V base() const &amp; requires copy_constructible&lt;V&gt; { return base_; }
    constexpr V base() &amp;&amp; { return std::move(base_); }
 
    constexpr auto begin() {
      constexpr bool use_const =
        __simple_view&lt;V&gt; &amp;&amp; is_reference_v&lt;InnerRng&gt; &amp;&amp; __simple_view&lt;Pattern&gt;;
      return iterator&lt;use_const&gt;{*this, ranges::begin(base_)};
    }
    constexpr auto begin() const
      requires input_range&lt;const V&gt; &amp;&amp;
               forward_range&lt;const Pattern&gt; &amp;&amp;
               is_reference_v&lt;range_reference_t&lt;const V&gt;&gt; {
      return iterator&lt;true&gt;{*this, ranges::begin(base_)};
    }
 
    constexpr auto end() {
      if constexpr (forward_range&lt;V&gt; &amp;&amp;
                    is_reference_v&lt;InnerRng&gt; &amp;&amp; forward_range&lt;InnerRng&gt; &amp;&amp;
                    common_range&lt;V&gt; &amp;&amp; common_range&lt;InnerRng&gt;)
        return iterator&lt;__simple_view&lt;V&gt; &amp;&amp;
          __simple_view&lt;Pattern&gt;&gt;{*this, ranges::end(base_)};
      else
        return sentinel&lt;__simple_view&lt;V&gt; &amp;&amp; __simple_view&lt;Pattern&gt;&gt;{*this};
    }
    constexpr auto end() const
      requires input_range&lt;const V&gt; &amp;&amp; forward_range&lt;const Pattern&gt; &amp;&amp;
               is_reference_v&lt;range_reference_t&lt;const V&gt;&gt; {
      using InnerConstRng = range_reference_t&lt;const V&gt;;
      if constexpr (forward_range&lt;const V&gt; &amp;&amp; forward_range&lt;InnerConstRng&gt; &amp;&amp;
                    common_range&lt;const V&gt; &amp;&amp; common_range&lt;InnerConstRng&gt;)
        return iterator&lt;true&gt;{*this, ranges::end(base_)};
      else
        return sentinel&lt;true&gt;{*this};
    }
  };
 
  template&lt;class R, class P&gt;
    join_with_view(R&amp;&amp;, P&amp;&amp;) -&gt; join_with_view&lt;views::all_t&lt;R&gt;, views::all_t&lt;P&gt;&gt;;
 
  template&lt;input_range R&gt;
    join_with_view(R&amp;&amp;, range_value_t&lt;range_reference_t&lt;R&gt;&gt;)
      -&gt; join_with_view&lt;views::all_t&lt;R&gt;,
            single_view&lt;range_value_t&lt;range_reference_t&lt;R&gt;&gt;&gt;&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::join_with_view::iterator"> Class template <code>std::ranges::join_with_view::iterator</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;input_range V, forward_range Pattern&gt;
    requires view&lt;V&gt; &amp;&amp; input_range&lt;range_reference_t&lt;V&gt;&gt;
          &amp;&amp; view&lt;Pattern&gt; &amp;&amp; __compatible_joinable_ranges&lt;range_reference_t&lt;V&gt;, Pattern&gt;
  template&lt;bool Const&gt;
  class join_with_view&lt;V, Pattern&gt;::iterator {
    using Parent = __maybe_const&lt;Const, join_with_view&gt;;                // exposition only
    using Base = __maybe_const&lt;Const, V&gt;;                               // exposition only
    using InnerBase = range_reference_t&lt;Base&gt;;                          // exposition only
    using PatternBase = __maybe_const&lt;Const, Pattern&gt;;                  // exposition only
 
    using OuterIter = iterator_t&lt;Base&gt;;                                 // exposition only
    using InnerIter = iterator_t&lt;InnerBase&gt;;                            // exposition only
    using PatternIter = iterator_t&lt;PatternBase&gt;;                        // exposition only
 
    static constexpr bool __ref_is_glvalue = is_reference_v&lt;InnerBase&gt;; // exposition only
 
    Parent* parent_ = nullptr;                                          // exposition only
    OuterIter outer_it_ = OuterIter();                                  // exposition only
    variant&lt;PatternIter, InnerIter&gt; inner_it_;                          // exposition only
 
    constexpr iterator(Parent&amp; parent, iterator_t&lt;Base&gt; outer);         // exposition only
    constexpr auto&amp;&amp; __update_inner(const OuterIter&amp;);                  // exposition only
    constexpr auto&amp;&amp; __get_inner(const OuterIter&amp;);                     // exposition only
    constexpr void satisfy();                                           // exposition only
 
  public:
    using iterator_concept = /* see description */;
    using iterator_category = /* see description */;            // not always present
    using value_type = /* see description */;
    using difference_type = /* see description */;
 
    iterator() requires default_initializable&lt;OuterIter&gt; = default;
    constexpr iterator(iterator&lt;!Const&gt; i)
      requires Const &amp;&amp; convertible_to&lt;iterator_t&lt;V&gt;, OuterIter&gt; &amp;&amp;
               convertible_to&lt;iterator_t&lt;InnerRng&gt;, InnerIter&gt; &amp;&amp;
               convertible_to&lt;iterator_t&lt;Pattern&gt;, PatternIter&gt;;
 
    constexpr decltype(auto) operator*() const;
 
    constexpr iterator&amp; operator++();
    constexpr void operator++(int);
    constexpr iterator operator++(int)
      requires __ref_is_glvalue &amp;&amp; forward_iterator&lt;OuterIter&gt; &amp;&amp;
               forward_iterator&lt;InnerIter&gt;;
 
    constexpr iterator&amp; operator--()
      requires __ref_is_glvalue &amp;&amp; bidirectional_range&lt;Base&gt; &amp;&amp;
               __bidirectional_common&lt;InnerBase&gt; &amp;&amp; __bidirectional_common&lt;PatternBase&gt;;
    constexpr iterator operator--(int)
      requires __ref_is_glvalue &amp;&amp; bidirectional_range&lt;Base&gt; &amp;&amp;
               __bidirectional_common&lt;InnerBase&gt; &amp;&amp; __bidirectional_common&lt;PatternBase&gt;;
 
    friend constexpr bool operator==(const iterator&amp; x, const iterator&amp; y)
      requires __ref_is_glvalue &amp;&amp; equality_comparable&lt;OuterIter&gt; &amp;&amp;
               equality_comparable&lt;InnerIter&gt;;
 
    friend constexpr decltype(auto) iter_move(const iterator&amp; x) {
      using rvalue_reference = common_reference_t&lt;
        iter_rvalue_reference_t&lt;InnerIter&gt;,
        iter_rvalue_reference_t&lt;PatternIter&gt;&gt;;
      return visit&lt;rvalue_reference&gt;(ranges::iter_move, x.inner_it_);
    }
 
    friend constexpr void iter_swap(const iterator&amp; x, const iterator&amp; y)
      requires indirectly_swappable&lt;InnerIter, PatternIter&gt; {
      visit(ranges::iter_swap, x.inner_it_, y.inner_it_);
    }
  };
}</pre></div> <h4 id="Class_template_std::ranges::join_with_view::sentinel"> Class template <code>std::ranges::join_with_view::sentinel</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;input_range V, forward_range Pattern&gt;
    requires view&lt;V&gt; &amp;&amp; input_range&lt;range_reference_t&lt;V&gt;&gt;
          &amp;&amp; view&lt;Pattern&gt; &amp;&amp; __compatible_joinable_ranges&lt;range_reference_t&lt;V&gt;, Pattern&gt;
  template&lt;bool Const&gt;
  class join_with_view&lt;V, Pattern&gt;::sentinel {
    using Parent = __maybe_const&lt;Const, join_with_view&gt;;    // exposition only
    using Base = __maybe_const&lt;Const, V&gt;;                   // exposition only
    sentinel_t&lt;Base&gt; end_ = sentinel_t&lt;Base&gt;();             // exposition only
 
    constexpr explicit sentinel(Parent&amp; parent);            // exposition only
 
  public:
    sentinel() = default;
    constexpr sentinel(sentinel&lt;!Const&gt; s)
      requires Const &amp;&amp; convertible_to&lt;sentinel_t&lt;V&gt;, sentinel_t&lt;Base&gt;&gt;;
 
    template&lt;bool OtherConst&gt;
      requires sentinel_for&lt;sentinel_t&lt;Base&gt;, iterator_t&lt;__maybe_const&lt;OtherConst, V&gt;&gt;&gt;
    friend constexpr bool operator==(const iterator&lt;OtherConst&gt;&amp; x, const sentinel&amp; y);
  };
}</pre></div> <h4 id="Class_template_std::ranges::lazy_split_view"> Class template <code>std::ranges::lazy_split_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;auto&gt; struct __require_constant;                       // exposition only
 
  template&lt;class R&gt;
  concept __tiny_range =                                          // exposition only
    sized_range&lt;R&gt; &amp;&amp;
    requires { typename __require_constant&lt;remove_reference_t&lt;R&gt;::size()&gt;; } &amp;&amp;
    (remove_reference_t&lt;R&gt;::size() &lt;= 1);
 
  template&lt;input_range V, forward_range Pattern&gt;
    requires view&lt;V&gt; &amp;&amp; view&lt;Pattern&gt; &amp;&amp;
             indirectly_comparable&lt;iterator_t&lt;V&gt;, iterator_t&lt;Pattern&gt;, ranges::equal_to&gt;
             &amp;&amp;
             (forward_range&lt;V&gt; || __tiny_range&lt;Pattern&gt;)
  class lazy_split_view : public view_interface&lt;lazy_split_view&lt;V, Pattern&gt;&gt; {
  private:
    V base_ = V();                                              // exposition only
    Pattern pattern_ = Pattern();                               // exposition only
 
    __non_propagating_cache&lt;iterator_t&lt;V&gt;&gt; current_;    // exposition only, present only
                                                        // if !forward_range&lt;V&gt;
 
    // class template lazy_split_view::outer-iterator
    template&lt;bool&gt; struct __outer_iterator;                     // exposition only
 
    // class template lazy_split_view::inner-iterator
    template&lt;bool&gt; struct __inner_iterator;                     // exposition only
 
  public:
    lazy_split_view()
      requires default_initializable&lt;V&gt; &amp;&amp; default_initializable&lt;Pattern&gt; = default;
    constexpr explicit lazy_split_view(V base, Pattern pattern);
 
    template&lt;input_range R&gt;
      requires constructible_from&lt;V, views::all_t&lt;R&gt;&gt; &amp;&amp;
               constructible_from&lt;Pattern, single_view&lt;range_value_t&lt;R&gt;&gt;&gt;
    constexpr explicit lazy_split_view(R&amp;&amp; r, range_value_t&lt;R&gt; e);
 
    constexpr V base() const &amp; requires copy_constructible&lt;V&gt; { return base_; }
    constexpr V base() &amp;&amp; { return std::move(base_); }
 
    constexpr auto begin() {
      if constexpr (forward_range&lt;V&gt;) {
        return __outer_iterator&lt;__simple_view&lt;V&gt; &amp;&amp; __simple_view&lt;Pattern&gt;&gt;
          {*this, ranges::begin(base_)};
      } else {
        current_ = ranges::begin(base_);
        return __outer_iterator&lt;false&gt;{*this};
      }
    }
 
    constexpr auto begin() const requires forward_range&lt;V&gt; &amp;&amp; forward_range&lt;const V&gt; {
      return __outer_iterator&lt;true&gt;{*this, ranges::begin(base_)};
    }
 
    constexpr auto end() requires forward_range&lt;V&gt; &amp;&amp; common_range&lt;V&gt; {
      return __outer_iterator&lt;__simple_view&lt;V&gt; &amp;&amp; __simple_view&lt;Pattern&gt;&gt;
        {*this, ranges::end(base_)};
    }
 
    constexpr auto end() const {
      if constexpr (forward_range&lt;V&gt; &amp;&amp; forward_range&lt;const V&gt; &amp;&amp; common_range&lt;const V&gt;)
        return __outer_iterator&lt;true&gt;{*this, ranges::end(base_)};
      else
        return default_sentinel;
    }
  };
 
  template&lt;class R, class P&gt;
    lazy_split_view(R&amp;&amp;, P&amp;&amp;) -&gt; lazy_split_view&lt;views::all_t&lt;R&gt;, views::all_t&lt;P&gt;&gt;;
 
  template&lt;input_range R&gt;
    lazy_split_view(R&amp;&amp;, range_value_t&lt;R&gt;)
      -&gt; lazy_split_view&lt;views::all_t&lt;R&gt;, single_view&lt;range_value_t&lt;R&gt;&gt;&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::lazy_split_view::outer_iterator"> Class template <code>std::ranges::lazy_split_view::outer_iterator</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;input_range V, forward_range Pattern&gt;
    requires view&lt;V&gt; &amp;&amp; view&lt;Pattern&gt; &amp;&amp;
             indirectly_comparable&lt;iterator_t&lt;V&gt;, iterator_t&lt;Pattern&gt;, ranges::equal_to&gt;
             &amp;&amp;
             (forward_range&lt;V&gt; || __tiny_range&lt;Pattern&gt;)
  template&lt;bool Const&gt;
  struct lazy_split_view&lt;V, Pattern&gt;::__outer_iterator {
  private:
    using Parent = __maybe_const&lt;Const, lazy_split_view&gt;;   // exposition only
    using Base = __maybe_const&lt;Const, V&gt;;                   // exposition only
    Parent* parent_ = nullptr;                              // exposition only
 
    iterator_t&lt;Base&gt; current_ = iterator_t&lt;Base&gt;();     // exposition only, present only
                                                        // if V models forward_range
 
    bool trailing_empty_ = false;                           // exposition only
 
  public:
    using iterator_concept  =
      conditional_t&lt;forward_range&lt;Base&gt;, forward_iterator_tag, input_iterator_tag&gt;;
 
    using iterator_category = input_iterator_tag;           // present only if Base
                                                            // models forward_range
 
    // class lazy_split_view::outer-iterator::value_type
    struct value_type;
    using difference_type   = range_difference_t&lt;Base&gt;;
 
    __outer_iterator() = default;
    constexpr explicit __outer_iterator(Parent&amp; parent)
      requires (!forward_range&lt;Base&gt;);
    constexpr __outer_iterator(Parent&amp; parent, iterator_t&lt;Base&gt; current)
      requires forward_range&lt;Base&gt;;
    constexpr __outer_iterator(__outer_iterator&lt;!Const&gt; i)
      requires Const &amp;&amp; convertible_to&lt;iterator_t&lt;V&gt;, iterator_t&lt;Base&gt;&gt;;
 
    constexpr value_type operator*() const;
 
    constexpr __outer_iterator&amp; operator++();
    constexpr decltype(auto) operator++(int) {
      if constexpr (forward_range&lt;Base&gt;) {
        auto tmp = *this;
        ++*this;
        return tmp;
      } else
        ++*this;
    }
 
    friend constexpr bool operator==(const __outer_iterator&amp; x, const __outer_iterator&amp; y)
      requires forward_range&lt;Base&gt;;
 
    friend constexpr bool operator==(const __outer_iterator&amp; x, default_sentinel_t);
  };
}</pre></div> <h4 id="Class_template_std::ranges::lazy_split_view::outer_iterator::value_type"> Class template <code>std::ranges::lazy_split_view::outer_iterator::value_type</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;input_range V, forward_range Pattern&gt;
    requires view&lt;V&gt; &amp;&amp; view&lt;Pattern&gt; &amp;&amp;
             indirectly_comparable&lt;iterator_t&lt;V&gt;, iterator_t&lt;Pattern&gt;, ranges::equal_to&gt;
             &amp;&amp;
             (forward_range&lt;V&gt; || __tiny_range&lt;Pattern&gt;)
  template&lt;bool Const&gt;
  struct lazy_split_view&lt;V, Pattern&gt;::__outer_iterator&lt;Const&gt;::value_type
    : view_interface&lt;value_type&gt; {
  private:
    __outer_iterator i_ = __outer_iterator();               // exposition only
  public:
    value_type() = default;
    constexpr explicit value_type(__outer_iterator i);
 
    constexpr __inner_iterator&lt;Const&gt; begin() const;
    constexpr default_sentinel_t end() const noexcept;
  };
}</pre></div> <h4 id="Class_template_std::ranges::lazy_split_view::inner_iterator"> Class template <code>std::ranges::lazy_split_view::inner_iterator</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;input_range V, forward_range Pattern&gt;
    requires view&lt;V&gt; &amp;&amp; view&lt;Pattern&gt; &amp;&amp;
             indirectly_comparable&lt;iterator_t&lt;V&gt;, iterator_t&lt;Pattern&gt;, ranges::equal_to&gt;
             &amp;&amp;
             (forward_range&lt;V&gt; || __tiny_range&lt;Pattern&gt;)
  template&lt;bool Const&gt;
  struct lazy_split_view&lt;V, Pattern&gt;::__inner_iterator {
  private:
    using Base = __maybe_const&lt;Const, V&gt;;                   // exposition only
    __outer_iterator&lt;Const&gt; i_ = __outer_iterator&lt;Const&gt;(); // exposition only
    bool incremented_ = false;                              // exposition only
 
  public:
    using iterator_concept  = typename __outer_iterator&lt;Const&gt;::iterator_concept;
 
    using iterator_category = /* see description */;        // present only if Base
                                                            // models forward_range
    using value_type        = range_value_t&lt;Base&gt;;
    using difference_type   = range_difference_t&lt;Base&gt;;
 
    __inner_iterator() = default;
    constexpr explicit __inner_iterator(__outer_iterator&lt;Const&gt; i);
 
    constexpr const iterator_t&lt;Base&gt;&amp; base() const &amp; noexcept;
    constexpr iterator_t&lt;Base&gt; base() &amp;&amp; requires forward_range&lt;V&gt;;
 
    constexpr decltype(auto) operator*() const { return *i_.current; }
 
    constexpr __inner_iterator&amp; operator++();
    constexpr decltype(auto) operator++(int) {
      if constexpr (forward_range&lt;Base&gt;) {
        auto tmp = *this;
        ++*this;
        return tmp;
      } else
        ++*this;
    }
 
    friend constexpr bool operator==(const __inner_iterator&amp; x, const __inner_iterator&amp; y)
      requires forward_range&lt;Base&gt;;
 
    friend constexpr bool operator==(const __inner_iterator&amp; x, default_sentinel_t);
 
    friend constexpr decltype(auto) iter_move(const __inner_iterator&amp; i)
    noexcept(noexcept(ranges::iter_move(i.i_.current))) {
      return ranges::iter_move(i.i_.current);
    }
 
    friend constexpr void iter_swap(const __inner_iterator&amp; x, const __inner_iterator&amp; y)
      noexcept(noexcept(ranges::iter_swap(x.i_.current, y.i_.current)))
      requires indirectly_swappable&lt;iterator_t&lt;Base&gt;&gt;;
  };
}</pre></div> <h4 id="Class_template_std::ranges::split_view"> Class template <code>std::ranges::split_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;forward_range V, forward_range Pattern&gt;
    requires view&lt;V&gt; &amp;&amp; view&lt;Pattern&gt; &amp;&amp;
             indirectly_comparable&lt;iterator_t&lt;V&gt;, iterator_t&lt;Pattern&gt;, ranges::equal_to&gt;
  class split_view : public view_interface&lt;split_view&lt;V, Pattern&gt;&gt; {
  private:
    V base_ = V();                              // exposition only
    Pattern pattern_ = Pattern();               // exposition only
 
    // class split_view::iterator
    struct iterator;                            // exposition only
 
    // class split_view::sentinel
    struct sentinel;                            // exposition only
 
  public:
    split_view()
      requires default_initializable&lt;V&gt; &amp;&amp; default_initializable&lt;Pattern&gt; = default;
    constexpr explicit split_view(V base, Pattern pattern);
 
    template&lt;forward_range R&gt;
      requires constructible_from&lt;V, views::all_t&lt;R&gt;&gt; &amp;&amp;
               constructible_from&lt;Pattern, single_view&lt;range_value_t&lt;R&gt;&gt;&gt;
    constexpr explicit split_view(R&amp;&amp; r, range_value_t&lt;R&gt; e);
 
    constexpr V base() const &amp; requires copy_constructible&lt;V&gt; { return base_; }
    constexpr V base() &amp;&amp; { return std::move(base_); }
 
    constexpr iterator begin();
 
    constexpr auto end() {
      if constexpr (common_range&lt;V&gt;) {
        return iterator{*this, ranges::end(base_), {}};
      } else {
        return sentinel{*this};
      }
    }
 
    constexpr subrange&lt;iterator_t&lt;V&gt;&gt; __find_next(iterator_t&lt;V&gt;); // exposition only
  };
 
  template&lt;class R, class P&gt;
    split_view(R&amp;&amp;, P&amp;&amp;) -&gt; split_view&lt;views::all_t&lt;R&gt;, views::all_t&lt;P&gt;&gt;;
 
  template&lt;forward_range R&gt;
    split_view(R&amp;&amp;, range_value_t&lt;R&gt;)
      -&gt; split_view&lt;views::all_t&lt;R&gt;, single_view&lt;range_value_t&lt;R&gt;&gt;&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::split_view::iterator"> Class template <code>std::ranges::split_view::iterator</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;forward_range V, forward_range Pattern&gt;
    requires view&lt;V&gt; &amp;&amp; view&lt;Pattern&gt; &amp;&amp;
             indirectly_comparable&lt;iterator_t&lt;V&gt;, iterator_t&lt;Pattern&gt;, ranges::equal_to&gt;
  class split_view&lt;V, Pattern&gt;::iterator {
  private:
    split_view* parent_ = nullptr;                              // exposition only
    iterator_t&lt;V&gt; cur_ = iterator_t&lt;V&gt;();                       // exposition only
    subrange&lt;iterator_t&lt;V&gt;&gt; next_ = subrange&lt;iterator_t&lt;V&gt;&gt;();  // exposition only
    bool trailing_empty_ = false;                               // exposition only
 
  public:
    using iterator_concept = forward_iterator_tag;
    using iterator_category = input_iterator_tag;
    using value_type = subrange&lt;iterator_t&lt;V&gt;&gt;;
    using difference_type = range_difference_t&lt;V&gt;;
 
    iterator() = default;
    constexpr iterator(split_view&amp; parent, iterator_t&lt;V&gt; current,
                       subrange&lt;iterator_t&lt;V&gt;&gt; next);
 
    constexpr iterator_t&lt;V&gt; base() const;
    constexpr value_type operator*() const;
 
    constexpr iterator&amp; operator++();
    constexpr iterator operator++(int);
 
    friend constexpr bool operator==(const iterator&amp; x, const iterator&amp; y);
  };
}</pre></div> <h4 id="Class_template_std::ranges::split_view::sentinel"> Class template <code>std::ranges::split_view::sentinel</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;forward_range V, forward_range Pattern&gt;
    requires view&lt;V&gt; &amp;&amp; view&lt;Pattern&gt; &amp;&amp;
             indirectly_comparable&lt;iterator_t&lt;V&gt;, iterator_t&lt;Pattern&gt;, ranges::equal_to&gt;
  struct split_view&lt;V, Pattern&gt;::sentinel {
  private:
    sentinel_t&lt;V&gt; end_ = sentinel_t&lt;V&gt;();               // exposition only
 
  public:
    sentinel() = default;
    constexpr explicit sentinel(split_view&amp; parent);
 
    friend constexpr bool operator==(const iterator&amp; x, const sentinel&amp; y);
  };
}</pre></div> <h4 id="Class_template_std::ranges::common_view"> Class template <code>std::ranges::common_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;view V&gt;
    requires (!common_range&lt;V&gt; &amp;&amp; copyable&lt;iterator_t&lt;V&gt;&gt;)
  class common_view : public view_interface&lt;common_view&lt;V&gt;&gt; {
  private:
    V base_ = V();  // exposition only
  public:
    common_view() requires default_initializable&lt;V&gt; = default;
 
    constexpr explicit common_view(V r);
 
    constexpr V base() const &amp; requires copy_constructible&lt;V&gt; { return base_; }
    constexpr V base() &amp;&amp; { return std::move(base_); }
 
    constexpr auto begin() {
      if constexpr (random_access_range&lt;V&gt; &amp;&amp; sized_range&lt;V&gt;)
        return ranges::begin(base_);
      else
        return common_iterator&lt;iterator_t&lt;V&gt;, sentinel_t&lt;V&gt;&gt;(ranges::begin(base_));
    }
 
    constexpr auto begin() const requires range&lt;const V&gt; {
      if constexpr (random_access_range&lt;const V&gt; &amp;&amp; sized_range&lt;const V&gt;)
        return ranges::begin(base_);
      else
        return common_iterator&lt;iterator_t&lt;const V&gt;, sentinel_t&lt;const V&gt;&gt;(
          ranges::begin(base_));
    }
 
    constexpr auto end() {
      if constexpr (random_access_range&lt;V&gt; &amp;&amp; sized_range&lt;V&gt;)
        return ranges::begin(base_) + ranges::size(base_);
      else
        return common_iterator&lt;iterator_t&lt;V&gt;, sentinel_t&lt;V&gt;&gt;(ranges::end(base_));
    }
 
    constexpr auto end() const requires range&lt;const V&gt; {
      if constexpr (random_access_range&lt;const V&gt; &amp;&amp; sized_range&lt;const V&gt;)
        return ranges::begin(base_) + ranges::size(base_);
      else
        return common_iterator&lt;iterator_t&lt;const V&gt;, sentinel_t&lt;const V&gt;&gt;(
          ranges::end(base_));
    }
 
    constexpr auto size() requires sized_range&lt;V&gt; {
      return ranges::size(base_);
    }
    constexpr auto size() const requires sized_range&lt;const V&gt; {
      return ranges::size(base_);
    }
  };
 
  template&lt;class R&gt;
    common_view(R&amp;&amp;) -&gt; common_view&lt;views::all_t&lt;R&gt;&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::reverse_view"> Class template <code><a href="../ranges/reverse_view" title="cpp/ranges/reverse view">std::ranges::reverse_view</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;view V&gt;
    requires bidirectional_range&lt;V&gt;
  class reverse_view : public view_interface&lt;reverse_view&lt;V&gt;&gt; {
  private:
    V base_ = V();  // exposition only
  public:
    reverse_view() requires default_initializable&lt;V&gt; = default;
 
    constexpr explicit reverse_view(V r);
 
    constexpr V base() const &amp; requires copy_constructible&lt;V&gt; { return base_; }
    constexpr V base() &amp;&amp; { return std::move(base_); }
 
    constexpr reverse_iterator&lt;iterator_t&lt;V&gt;&gt; begin();
    constexpr reverse_iterator&lt;iterator_t&lt;V&gt;&gt; begin() requires common_range&lt;V&gt;;
    constexpr auto begin() const requires common_range&lt;const V&gt;;
 
    constexpr reverse_iterator&lt;iterator_t&lt;V&gt;&gt; end();
    constexpr auto end() const requires common_range&lt;const V&gt;;
 
    constexpr auto size() requires sized_range&lt;V&gt; {
      return ranges::size(base_);
    }
 
    constexpr auto size() const requires sized_range&lt;const V&gt; {
      return ranges::size(base_);
    }
  };
 
  template&lt;class R&gt;
    reverse_view(R&amp;&amp;) -&gt; reverse_view&lt;views::all_t&lt;R&gt;&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::as_const_view"> Class template <code>std::ranges::as_const_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;view V&gt;
    requires input_range&lt;V&gt;
  class as_const_view : public view_interface&lt;as_const_view&lt;V&gt;&gt; {
    V base_ = V();      // exposition only
 
  public:
    as_const_view() requires default_initializable&lt;V&gt; = default;
    constexpr explicit as_const_view(V base);
 
    constexpr V base() const &amp; requires copy_constructible&lt;V&gt; { return base_; }
    constexpr V base() &amp;&amp; { return std::move(base_); }
 
    constexpr auto begin() requires (!__simple_view&lt;V&gt;) { return ranges::cbegin(base_); }
    constexpr auto begin() const requires range&lt;const V&gt; { return ranges::cbegin(base_); }
 
    constexpr auto end() requires (!__simple_view&lt;V&gt;) { return ranges::cend(base_); }
    constexpr auto end() const requires range&lt;const V&gt; { return ranges::cend(base_); }
 
    constexpr auto size() requires sized_range&lt;V&gt; { return ranges::size(base_); }
    constexpr auto size() const requires sized_range&lt;const V&gt; {
      return ranges::size(base_);
    }
  };
 
  template&lt;class R&gt;
    as_const_view(R&amp;&amp;) -&gt; as_const_view&lt;views::all_t&lt;R&gt;&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::elements_view"> Class template <code>std::ranges::elements_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class T, size_t N&gt;
  concept __has_tuple_element =                   // exposition only
    __tuple_like&lt;T&gt; &amp;&amp; N &lt; tuple_size_v&lt;T&gt;;
 
  template&lt;class T, size_t N&gt;
  concept __returnable_element =                  // exposition only
    is_reference_v&lt;T&gt; || move_constructible&lt;tuple_element_t&lt;N, T&gt;&gt;;
 
  template&lt;input_range V, size_t N&gt;
    requires view&lt;V&gt; &amp;&amp; __has_tuple_element&lt;range_value_t&lt;V&gt;, N&gt; &amp;&amp;
             __has_tuple_element&lt;remove_reference_t&lt;range_reference_t&lt;V&gt;&gt;, N&gt; &amp;&amp;
             __returnable_element&lt;range_reference_t&lt;V&gt;, N&gt;
  class elements_view : public view_interface&lt;elements_view&lt;V, N&gt;&gt; {
  public:
    elements_view() requires default_initializable&lt;V&gt; = default;
    constexpr explicit elements_view(V base);
 
    constexpr V base() const &amp; requires copy_constructible&lt;V&gt; { return base_; }
    constexpr V base() &amp;&amp; { return std::move(base_); }
 
    constexpr auto begin() requires (!__simple_view&lt;V&gt;)
    { return iterator&lt;false&gt;(ranges::begin(base_)); }
 
    constexpr auto begin() const requires range&lt;const V&gt;
    { return iterator&lt;true&gt;(ranges::begin(base_)); }
 
    constexpr auto end() requires (!__simple_view&lt;V&gt; &amp;&amp; !common_range&lt;V&gt;)
    { return sentinel&lt;false&gt;{ranges::end(base_)}; }
 
    constexpr auto end() requires (!__simple_view&lt;V&gt; &amp;&amp; common_range&lt;V&gt;)
    { return iterator&lt;false&gt;{ranges::end(base_)}; }
 
    constexpr auto end() const requires range&lt;const V&gt;
    { return sentinel&lt;true&gt;{ranges::end(base_)}; }
 
    constexpr auto end() const requires common_range&lt;const V&gt;
    { return iterator&lt;true&gt;{ranges::end(base_)}; }
 
    constexpr auto size() requires sized_range&lt;V&gt;
    { return ranges::size(base_); }
 
    constexpr auto size() const requires sized_range&lt;const V&gt;
    { return ranges::size(base_); }
 
  private:
    // class template elements_view::iterator
    template&lt;bool&gt; class iterator;                      // exposition only
 
    // class template elements_view::sentinel
    template&lt;bool&gt; class sentinel;                      // exposition only
 
    V base_ = V();                                      // exposition only
  };
}</pre></div> <h4 id="Class_template_std::ranges::elements_view::iterator"> Class template <code>std::ranges::elements_view::iterator</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;input_range V, size_t N&gt;
    requires view&lt;V&gt; &amp;&amp; __has_tuple_element&lt;range_value_t&lt;V&gt;, N&gt; &amp;&amp;
             __has_tuple_element&lt;remove_reference_t&lt;range_reference_t&lt;V&gt;&gt;, N&gt; &amp;&amp;
             __returnable_element&lt;range_reference_t&lt;V&gt;, N&gt;
  template&lt;bool Const&gt;
  class elements_view&lt;V, N&gt;::iterator {
    using Base = __maybe_const&lt;Const, V&gt;;               // exposition only
 
    iterator_t&lt;Base&gt; current_ = iterator_t&lt;Base&gt;();     // exposition only
 
    static constexpr decltype(auto)
      __get_element(const iterator_t&lt;Base&gt;&amp; i);         // exposition only
 
  public:
    using iterator_concept = /* see description */;
    using iterator_category = /* see description */;                // not always present
    using value_type = remove_cvref_t&lt;tuple_element_t&lt;N, range_value_t&lt;Base&gt;&gt;&gt;;
    using difference_type = range_difference_t&lt;Base&gt;;
 
    iterator() requires default_initializable&lt;iterator_t&lt;Base&gt;&gt; = default;
    constexpr explicit iterator(iterator_t&lt;Base&gt; current);
    constexpr iterator(iterator&lt;!Const&gt; i)
      requires Const &amp;&amp; convertible_to&lt;iterator_t&lt;V&gt;, iterator_t&lt;Base&gt;&gt;;
 
    constexpr const iterator_t&lt;Base&gt;&amp; base() const &amp; noexcept;
    constexpr iterator_t&lt;Base&gt; base() &amp;&amp;;
 
    constexpr decltype(auto) operator*() const
    { return __get_element(current_); }
 
    constexpr iterator&amp; operator++();
    constexpr void operator++(int);
    constexpr iterator operator++(int) requires forward_range&lt;Base&gt;;
 
    constexpr iterator&amp; operator--() requires bidirectional_range&lt;Base&gt;;
    constexpr iterator operator--(int) requires bidirectional_range&lt;Base&gt;;
 
    constexpr iterator&amp; operator+=(difference_type x)
      requires random_access_range&lt;Base&gt;;
    constexpr iterator&amp; operator-=(difference_type x)
      requires random_access_range&lt;Base&gt;;
 
    constexpr decltype(auto) operator[](difference_type n) const
      requires random_access_range&lt;Base&gt;
    { return __get_element(current_ + n); }
 
    friend constexpr bool operator==(const iterator&amp; x, const iterator&amp; y)
      requires equality_comparable&lt;iterator_t&lt;Base&gt;&gt;;
 
    friend constexpr bool operator&lt;(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr bool operator&gt;(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr bool operator&lt;=(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr bool operator&gt;=(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr auto operator&lt;=&gt;(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt; &amp;&amp; three_way_comparable&lt;iterator_t&lt;Base&gt;&gt;;
 
    friend constexpr iterator operator+(const iterator&amp; x, difference_type y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr iterator operator+(difference_type x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr iterator operator-(const iterator&amp; x, difference_type y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr difference_type operator-(const iterator&amp; x, const iterator&amp; y)
      requires sized_sentinel_for&lt;iterator_t&lt;Base&gt;, iterator_t&lt;Base&gt;&gt;;
  };
}</pre></div> <h4 id="Class_template_std::ranges::elements_view::sentinel"> Class template <code>std::ranges::elements_view::sentinel</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;input_range V, size_t N&gt;
    requires view&lt;V&gt; &amp;&amp; __has_tuple_element&lt;range_value_t&lt;V&gt;, N&gt; &amp;&amp;
             __has_tuple_element&lt;remove_reference_t&lt;range_reference_t&lt;V&gt;&gt;, N&gt; &amp;&amp;
             __returnable_element&lt;range_reference_t&lt;V&gt;, N&gt;
  template&lt;bool Const&gt;
  class elements_view&lt;V, N&gt;::sentinel {
  private:
    using Base = __maybe_const&lt;Const, V&gt;;               // exposition only
    sentinel_t&lt;Base&gt; end_ = sentinel_t&lt;Base&gt;();         // exposition only
  public:
    sentinel() = default;
    constexpr explicit sentinel(sentinel_t&lt;Base&gt; end);
    constexpr sentinel(sentinel&lt;!Const&gt; other)
      requires Const &amp;&amp; convertible_to&lt;sentinel_t&lt;V&gt;, sentinel_t&lt;Base&gt;&gt;;
 
    constexpr sentinel_t&lt;Base&gt; base() const;
 
    template&lt;bool OtherConst&gt;
      requires sentinel_for&lt;sentinel_t&lt;Base&gt;, iterator_t&lt;__maybe_const&lt;OtherConst, V&gt;&gt;&gt;
    friend constexpr bool operator==(const iterator&lt;OtherConst&gt;&amp; x, const sentinel&amp; y);
 
    template&lt;bool OtherConst&gt;
      requires sized_sentinel_for&lt;sentinel_t&lt;Base&gt;,
        iterator_t&lt;__maybe_const&lt;OtherConst, V&gt;&gt;&gt;
    friend constexpr range_difference_t&lt;__maybe_const&lt;OtherConst, V&gt;&gt;
      operator-(const iterator&lt;OtherConst&gt;&amp; x, const sentinel&amp; y);
 
    template&lt;bool OtherConst&gt;
      requires sized_sentinel_for&lt;sentinel_t&lt;Base&gt;,
        iterator_t&lt;__maybe_const&lt;OtherConst, V&gt;&gt;&gt;
    friend constexpr range_difference_t&lt;__maybe_const&lt;OtherConst, V&gt;&gt;
      operator-(const sentinel&amp; x, const iterator&lt;OtherConst&gt;&amp; y);
  };
}</pre></div> <h4 id="Class_template_std::ranges::enumerate_view"> Class template <code>std::ranges::enumerate_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;view V&gt;
requires __range_with_movable_references&lt;V&gt;
class enumerate_view : public view_interface&lt;enumerate_view&lt;V&gt;&gt;
{
  V base_ = V(); // exposition only
  template&lt;bool Const&gt;
  class iterator; // exposition only
  template&lt;bool Const&gt;
  class sentinel; // exposition only
public:
  constexpr enumerate_view() requires default_initializable&lt;V&gt; = default;
  constexpr explicit enumerate_view(V base);
  constexpr auto begin() requires(!__simple_view&lt;V&gt;) {
    return iterator&lt;false&gt;(ranges::begin(base_), 0);
  }
  constexpr auto begin() const requires __range_with_movable_references&lt;const V&gt; {
    return iterator&lt;true&gt;(ranges::begin(base_), 0);
  }
  constexpr auto end() requires(!__simple_view&lt;V&gt;) {
    if constexpr (common_range&lt;V&gt; &amp;&amp; sized_range&lt;V&gt;)
      return iterator&lt;false&gt;(ranges::end(base_), ranges::distance(base_));
    else
      return sentinel&lt;false&gt;(ranges::end(base_));
  }
  constexpr auto end() const requires __range_with_movable_references&lt;const V&gt; {
    if constexpr (common_range&lt;const V&gt; &amp;&amp; sized_range&lt;const V&gt;)
      return iterator&lt;true&gt;(ranges::end(base_), ranges::distance(base_));
    else
      return sentinel&lt;true&gt;(ranges::end(base_));
  }
  constexpr auto size() requires sized_range&lt;V&gt; { return ranges::size(base_); }
  constexpr auto size() const requires sized_range&lt;const V&gt; {
    return ranges::size(base_);
  }
  constexpr V base() const&amp; requires copy_constructible&lt;V&gt; { return base_; }
  constexpr V base() &amp;&amp; { return std::move(base_); }
};
template&lt;class R&gt;
  enumerate_view(R&amp;&amp;) -&gt; enumerate_view&lt;views::all_t&lt;R&gt;&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::enumerate_view::iterator"> Class template <code>std::ranges::enumerate_view::iterator</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;view V&gt;
  requires __range_with_movable_references&lt;V&gt;
  template&lt;bool Const&gt;
  class enumerate_view&lt;V&gt;::iterator
  {
    using Base = __maybe_const&lt;Const, V&gt;; // exposition only
  public:
    using iterator_category = input_iterator_tag;
    using iterator_concept  = /* see description */;
    using difference_type   = range_difference_t&lt;Base&gt;;
    using value_type        = tuple&lt;difference_type, range_value_t&lt;Base&gt;&gt;;
 
  private:
    using __reference_type = // exposition only
      tuple&lt;difference_type, range_reference_t&lt;Base&gt;&gt;;
    iterator_t&lt;Base&gt; current_ = iterator_t&lt;Base&gt;(); // exposition only
    difference_type pos_      = 0;                  // exposition only
    constexpr explicit iterator(iterator_t&lt;Base&gt; current,
                                difference_type pos); // exposition only
  public:
    iterator() requires default_initializable&lt;iterator_t&lt;Base&gt;&gt;
    = default;
    constexpr iterator(iterator&lt;!Const&gt; i) requires Const
      &amp;&amp; convertible_to&lt;iterator_t&lt;V&gt;, iterator_t&lt;Base&gt;&gt;;
    constexpr const iterator_t&lt;Base&gt;&amp; base() const&amp; noexcept;
    constexpr iterator_t&lt;Base&gt; base() &amp;&amp;;
    constexpr difference_type index() const noexcept;
    constexpr auto operator*() const { return __reference_type(pos_, *current_); }
    constexpr iterator&amp; operator++();
    constexpr void operator++(int);
    constexpr iterator operator++(int) requires forward_range&lt;Base&gt;;
    constexpr iterator&amp; operator--() requires bidirectional_range&lt;Base&gt;;
    constexpr iterator operator--(int) requires bidirectional_range&lt;Base&gt;;
    constexpr iterator&amp; operator+=(difference_type x) requires random_access_range&lt;Base&gt;;
    constexpr iterator&amp; operator-=(difference_type x) requires random_access_range&lt;Base&gt;;
    constexpr auto operator[](difference_type n) const requires random_access_range&lt;Base&gt;
    {
      return __reference_type(pos_ + n, current_[n]);
    }
    friend constexpr bool operator==(const iterator&amp; x, const iterator&amp; y) noexcept;
    friend constexpr strong_ordering operator&lt;=&gt;(const iterator&amp; x,
                                                 const iterator&amp; y) noexcept;
    friend constexpr iterator operator+(const iterator&amp; x, difference_type y) requires
      random_access_range&lt;Base&gt;;
    friend constexpr iterator operator+(difference_type x, const iterator&amp; y) requires
      random_access_range&lt;Base&gt;;
    friend constexpr iterator operator-(const iterator&amp; x, difference_type y) requires
      random_access_range&lt;Base&gt;;
    friend constexpr difference_type operator-(const iterator&amp; x, const iterator&amp; y);
    friend constexpr auto iter_move(const iterator&amp; i) noexcept(
      noexcept(ranges::iter_move(i.current_)) &amp;&amp;
      is_nothrow_move_constructible_v&lt;range_rvalue_reference_t&lt;Base&gt;&gt;)
    {
      return tuple&lt;difference_type, range_rvalue_reference_t&lt;Base&gt;&gt;(
        pos_, ranges::iter_move(i.current_));
    }
  };
}</pre></div> <h4 id="Class_template_std::ranges::enumerate_view::sentinel"> Class template <code>std::ranges::enumerate_view::sentinel</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;view V&gt;
  requires __range_with_movable_references&lt;V&gt;
  template&lt;bool Const&gt;
  class enumerate_view&lt;V&gt;::sentinel
  {                                                  // exposition only
    using Base            = __maybe_const&lt;Const, V&gt;; // exposition only
    sentinel_t&lt;Base&gt; end_ = sentinel_t&lt;Base&gt;();      // exposition only
    constexpr explicit sentinel(sentinel_t&lt;Base&gt; end);
 
  public:
    sentinel() = default;
    constexpr sentinel(sentinel&lt;!Const&gt; other) requires Const
      &amp;&amp; convertible_to&lt;sentinel_t&lt;V&gt;, sentinel_t&lt;Base&gt;&gt;;
    constexpr sentinel_t&lt;Base&gt; base() const;
    template&lt;bool OtherConst&gt;
    requires sentinel_for&lt;sentinel_t&lt;Base&gt;, iterator_t&lt;__maybe_const&lt;OtherConst, V&gt;&gt;&gt;
    friend constexpr bool operator==(const iterator&lt;OtherConst&gt;&amp; x, const sentinel&amp; y);
    template&lt;bool OtherConst&gt;
    requires sized_sentinel_for&lt;sentinel_t&lt;Base&gt;,
                                iterator_t&lt;__maybe_const&lt;OtherConst, V&gt;&gt;&gt;
    friend constexpr range_difference_t&lt;__maybe_const&lt;OtherConst, V&gt;&gt; operator-(
      const iterator&lt;OtherConst&gt;&amp; x,
      const sentinel&amp; y);
    template&lt;bool OtherConst&gt;
    requires sized_sentinel_for&lt;sentinel_t&lt;Base&gt;,
                                iterator_t&lt;__maybe_const&lt;OtherConst, V&gt;&gt;&gt;
    friend constexpr range_difference_t&lt;__maybe_const&lt;OtherConst, V&gt;&gt; operator-(
      const sentinel&amp; x,
      const iterator&lt;OtherConst&gt;&amp; y);
  };
}</pre></div> <h4 id="Class_template_std::ranges::zip_view"> Class template <code>std::ranges::zip_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class... Rs&gt;
  concept __zip_is_common =             // exposition only
    (sizeof...(Rs) == 1 &amp;&amp; (common_range&lt;Rs&gt; &amp;&amp; ...)) ||
    (!(bidirectional_range&lt;Rs&gt; &amp;&amp; ...) &amp;&amp; (common_range&lt;Rs&gt; &amp;&amp; ...)) ||
    ((random_access_range&lt;Rs&gt; &amp;&amp; ...) &amp;&amp; (sized_range&lt;Rs&gt; &amp;&amp; ...));
 
  template&lt;input_range... Views&gt;
    requires (view&lt;Views&gt; &amp;&amp; ...) &amp;&amp; (sizeof...(Views) &gt; 0)
  class zip_view : public view_interface&lt;zip_view&lt;Views...&gt;&gt; {
    tuple&lt;Views...&gt; views_;             // exposition only
 
    // class template zip_view::iterator
    template&lt;bool&gt; class iterator;      // exposition only
 
    // class template zip_view::sentinel
    template&lt;bool&gt; class sentinel;      // exposition only
 
  public:
    zip_view() = default;
    constexpr explicit zip_view(Views... views);
 
    constexpr auto begin() requires (!(__simple_view&lt;Views&gt; &amp;&amp; ...)) {
      return iterator&lt;false&gt;(__tuple_transform(ranges::begin, views_));
    }
    constexpr auto begin() const requires (range&lt;const Views&gt; &amp;&amp; ...) {
      return iterator&lt;true&gt;(__tuple_transform(ranges::begin, views_));
    }
 
    constexpr auto end() requires (!(__simple_view&lt;Views&gt; &amp;&amp; ...)) {
      if constexpr (!__zip_is_common&lt;Views...&gt;) {
        return sentinel&lt;false&gt;(__tuple_transform(ranges::end, views_));
      } else if constexpr ((random_access_range&lt;Views&gt; &amp;&amp; ...)) {
        return begin() + iter_difference_t&lt;iterator&lt;false&gt;&gt;(size());
      } else {
        return iterator&lt;false&gt;(__tuple_transform(ranges::end, views_));
      }
    }
 
    constexpr auto end() const requires (range&lt;const Views&gt; &amp;&amp; ...) {
      if constexpr (!__zip_is_common&lt;const Views...&gt;) {
        return sentinel&lt;true&gt;(__tuple_transform(ranges::end, views_));
      } else if constexpr ((random_access_range&lt;const Views&gt; &amp;&amp; ...)) {
        return begin() + iter_difference_t&lt;iterator&lt;true&gt;&gt;(size());
      } else {
        return iterator&lt;true&gt;(__tuple_transform(ranges::end, views_));
      }
    }
 
    constexpr auto size() requires (sized_range&lt;Views&gt; &amp;&amp; ...);
    constexpr auto size() const requires (sized_range&lt;const Views&gt; &amp;&amp; ...);
  };
 
  template&lt;class... Rs&gt;
    zip_view(Rs&amp;&amp;...) -&gt; zip_view&lt;views::all_t&lt;Rs&gt;...&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::zip_view::iterator"> Class template <code>std::ranges::zip_view::iterator</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;bool Const, class... Views&gt;
    concept __all_random_access =                 // exposition only
      (random_access_range&lt;__maybe_const&lt;Const, Views&gt;&gt; &amp;&amp; ...);
  template&lt;bool Const, class... Views&gt;
    concept __all_bidirectional =                 // exposition only
      (bidirectional_range&lt;__maybe_const&lt;Const, Views&gt;&gt; &amp;&amp; ...);
  template&lt;bool Const, class... Views&gt;
    concept __all_forward =                       // exposition only
      (forward_range&lt;__maybe_const&lt;Const, Views&gt;&gt; &amp;&amp; ...);
 
  template&lt;input_range... Views&gt;
    requires (view&lt;Views&gt; &amp;&amp; ...) &amp;&amp; (sizeof...(Views) &gt; 0)
  template&lt;bool Const&gt;
  class zip_view&lt;Views...&gt;::iterator {
    tuple&lt;iterator_t&lt;__maybe_const&lt;Const, Views&gt;&gt;...&gt; current_;     // exposition only
    constexpr explicit iterator(tuple&lt;iterator_t&lt;__maybe_const&lt;Const, Views&gt;&gt;...&gt;);
                                                                    // exposition only
  public:
    using iterator_category = input_iterator_tag;                   // not always present
    using iterator_concept  = /* see description */;
    using value_type = tuple&lt;range_value_t&lt;__maybe_const&lt;Const, Views&gt;&gt;...&gt;;
    using difference_type = common_type_t&lt;range_difference_t&lt;
      __maybe_const&lt;Const, Views&gt;&gt;...&gt;;
 
    iterator() = default;
    constexpr iterator(iterator&lt;!Const&gt; i)
      requires Const &amp;&amp; (convertible_to&lt;iterator_t&lt;Views&gt;, iterator_t&lt;const Views&gt;&gt;
        &amp;&amp; ...);
 
    constexpr auto operator*() const;
    constexpr iterator&amp; operator++();
    constexpr void operator++(int);
    constexpr iterator operator++(int) requires __all_forward&lt;Const, Views...&gt;;
 
    constexpr iterator&amp; operator--() requires __all_bidirectional&lt;Const, Views...&gt;;
    constexpr iterator operator--(int) requires __all_bidirectional&lt;Const, Views...&gt;;
 
    constexpr iterator&amp; operator+=(difference_type x)
      requires __all_random_access&lt;Const, Views...&gt;;
    constexpr iterator&amp; operator-=(difference_type x)
      requires __all_random_access&lt;Const, Views...&gt;;
 
    constexpr auto operator[](difference_type n) const
      requires __all_random_access&lt;Const, Views...&gt;;
 
    friend constexpr bool operator==(const iterator&amp; x, const iterator&amp; y)
      requires (equality_comparable&lt;iterator_t&lt;__maybe_const&lt;Const, Views&gt;&gt;&gt; &amp;&amp; ...);
 
    friend constexpr auto operator&lt;=&gt;(const iterator&amp; x, const iterator&amp; y)
      requires __all_random_access&lt;Const, Views...&gt;;
 
    friend constexpr iterator operator+(const iterator&amp; i, difference_type n)
      requires __all_random_access&lt;Const, Views...&gt;;
    friend constexpr iterator operator+(difference_type n, const iterator&amp; i)
      requires __all_random_access&lt;Const, Views...&gt;;
    friend constexpr iterator operator-(const iterator&amp; i, difference_type n)
      requires __all_random_access&lt;Const, Views...&gt;;
    friend constexpr difference_type operator-(const iterator&amp; x, const iterator&amp; y)
      requires (sized_sentinel_for&lt;iterator_t&lt;__maybe_const&lt;Const, Views&gt;&gt;,
                                   iterator_t&lt;__maybe_const&lt;Const, Views&gt;&gt;&gt; &amp;&amp; ...);
 
    friend constexpr auto iter_move(const iterator&amp; i) noexcept(/* see description */);
 
    friend constexpr void iter_swap(const iterator&amp; l, const iterator&amp; r)
        noexcept(/* see description */)
      requires (indirectly_swappable&lt;iterator_t&lt;__maybe_const&lt;Const, Views&gt;&gt;&gt; &amp;&amp; ...);
  };
}</pre></div> <h4 id="Class_template_std::ranges::zip_view::sentinel"> Class template <code>std::ranges::zip_view::sentinel</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;input_range... Views&gt;
    requires (view&lt;Views&gt; &amp;&amp; ...) &amp;&amp; (sizeof...(Views) &gt; 0)
  template&lt;bool Const&gt;
  class zip_view&lt;Views...&gt;::sentinel {
    tuple&lt;sentinel_t&lt;__maybe_const&lt;Const, Views&gt;&gt;...&gt; end_;         // exposition only
    constexpr explicit sentinel(tuple&lt;sentinel_t&lt;__maybe_const&lt;Const, Views&gt;&gt;...&gt; end);
                                                                    // exposition only
  public:
    sentinel() = default;
    constexpr sentinel(sentinel&lt;!Const&gt; i)
      requires Const &amp;&amp; (convertible_to&lt;sentinel_t&lt;Views&gt;,
                         sentinel_t&lt;const Views&gt;&gt; &amp;&amp; ...);
 
    template&lt;bool OtherConst&gt;
      requires (sentinel_for&lt;sentinel_t&lt;__maybe_const&lt;Const, Views&gt;&gt;,
                             iterator_t&lt;__maybe_const&lt;OtherConst, Views&gt;&gt;&gt; &amp;&amp; ...)
    friend constexpr bool operator==(const iterator&lt;OtherConst&gt;&amp; x, const sentinel&amp; y);
 
    template&lt;bool OtherConst&gt;
      requires (sized_sentinel_for&lt;sentinel_t&lt;__maybe_const&lt;Const, Views&gt;&gt;,
                                   iterator_t&lt;__maybe_const&lt;OtherConst, Views&gt;&gt;&gt; &amp;&amp; ...)
    friend
      constexpr common_type_t&lt;range_difference_t&lt;__maybe_const&lt;OtherConst, Views&gt;&gt;...&gt;
      operator-(const iterator&lt;OtherConst&gt;&amp; x, const sentinel&amp; y);
 
    template&lt;bool OtherConst&gt;
      requires (sized_sentinel_for&lt;sentinel_t&lt;__maybe_const&lt;Const, Views&gt;&gt;,
                                   iterator_t&lt;__maybe_const&lt;OtherConst, Views&gt;&gt;&gt; &amp;&amp; ...)
    friend
      constexpr common_type_t&lt;range_difference_t&lt;__maybe_const&lt;OtherConst, Views&gt;&gt;...&gt;
      operator-(const sentinel&amp; y, const iterator&lt;OtherConst&gt;&amp; x);
  };
}</pre></div> <h4 id="Class_template_std::ranges::zip_transform_view"> Class template <code>std::ranges::zip_transform_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;move_constructible F, input_range... Views&gt;
    requires (view&lt;Views&gt; &amp;&amp; ...) &amp;&amp; (sizeof...(Views) &gt; 0) &amp;&amp; is_object_v&lt;F&gt; &amp;&amp;
              regular_invocable&lt;F&amp;, range_reference_t&lt;Views&gt;...&gt; &amp;&amp;
              __can_reference&lt;invoke_result_t&lt;F&amp;, range_reference_t&lt;Views&gt;...&gt;&gt;
  class zip_transform_view : public view_interface&lt;zip_transform_view&lt;F, Views...&gt;&gt; {
    __movable_box&lt;F&gt; fun_;                    // exposition only
    zip_view&lt;Views...&gt; zip_;                // exposition only
 
    using InnerView = zip_view&lt;Views...&gt;;   // exposition only
    template&lt;bool Const&gt;
      using ziperator = iterator_t&lt;__maybe_const&lt;Const, InnerView&gt;&gt;;    // exposition only
    template&lt;bool Const&gt;
      using zentinel = sentinel_t&lt;__maybe_const&lt;Const, InnerView&gt;&gt;;     // exposition only
 
    // class template zip_transform_view::iterator
    template&lt;bool&gt; class iterator;          // exposition only
 
    // class template zip_transform_view::sentinel
    template&lt;bool&gt; class sentinel;          // exposition only
 
  public:
    zip_transform_view() = default;
 
    constexpr explicit zip_transform_view(F fun, Views... views);
 
    constexpr auto begin() { return iterator&lt;false&gt;(*this, zip_.begin()); }
 
    constexpr auto begin() const
      requires range&lt;const InnerView&gt; &amp;&amp;
               regular_invocable&lt;const F&amp;, range_reference_t&lt;const Views&gt;...&gt; {
      return iterator&lt;true&gt;(*this, zip_.begin());
    }
 
    constexpr auto end() {
      if constexpr (common_range&lt;InnerView&gt;) {
        return iterator&lt;false&gt;(*this, zip_.end());
      } else {
        return sentinel&lt;false&gt;(zip_.end());
      }
    }
 
    constexpr auto end() const
      requires range&lt;const InnerView&gt; &amp;&amp;
               regular_invocable&lt;const F&amp;, range_reference_t&lt;const Views&gt;...&gt; {
      if constexpr (common_range&lt;const InnerView&gt;) {
        return iterator&lt;true&gt;(*this, zip_.end());
      } else {
        return sentinel&lt;true&gt;(zip_.end());
      }
    }
 
    constexpr auto size() requires sized_range&lt;InnerView&gt; {
      return zip_.size();
    }
 
    constexpr auto size() const requires sized_range&lt;const InnerView&gt; {
      return zip_.size();
    }
  };
 
  template&lt;class F, class... Rs&gt;
    zip_transform_view(F, Rs&amp;&amp;...) -&gt; zip_transform_view&lt;F, views::all_t&lt;Rs&gt;...&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::zip_transform_view::iterator"> Class template <code>std::ranges::zip_transform_view::iterator</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;move_constructible F, input_range... Views&gt;
    requires (view&lt;Views&gt; &amp;&amp; ...) &amp;&amp; (sizeof...(Views) &gt; 0) &amp;&amp; is_object_v&lt;F&gt; &amp;&amp;
              regular_invocable&lt;F&amp;, range_reference_t&lt;Views&gt;...&gt; &amp;&amp;
              __can_reference&lt;invoke_result_t&lt;F&amp;, range_reference_t&lt;Views&gt;...&gt;&gt;
  template&lt;bool Const&gt;
  class zip_transform_view&lt;F, Views...&gt;::iterator {
    using Parent = __maybe_const&lt;Const, zip_transform_view&gt;;    // exposition only
    using Base = __maybe_const&lt;Const, InnerView&gt;;               // exposition only
    Parent* parent_ = nullptr;                                  // exposition only
    ziperator&lt;Const&gt; inner_;                                    // exposition only
 
    constexpr iterator(Parent&amp; parent, ziperator&lt;Const&gt; inner); // exposition only
 
  public:
    using iterator_category = /* see description */;            // not always present
    using iterator_concept  = typename ziperator&lt;Const&gt;::iterator_concept;
    using value_type =
      remove_cvref_t&lt;invoke_result_t&lt;__maybe_const&lt;Const, F&gt;&amp;,
                                     range_reference_t&lt;__maybe_const&lt;Const, Views&gt;&gt;...&gt;&gt;;
    using difference_type = range_difference_t&lt;Base&gt;;
 
    iterator() = default;
    constexpr iterator(iterator&lt;!Const&gt; i)
      requires Const &amp;&amp; convertible_to&lt;ziperator&lt;false&gt;, ziperator&lt;Const&gt;&gt;;
 
    constexpr decltype(auto) operator*() const noexcept(/* see description */);
    constexpr iterator&amp; operator++();
    constexpr void operator++(int);
    constexpr iterator operator++(int) requires forward_range&lt;Base&gt;;
 
    constexpr iterator&amp; operator--() requires bidirectional_range&lt;Base&gt;;
    constexpr iterator operator--(int) requires bidirectional_range&lt;Base&gt;;
 
    constexpr iterator&amp; operator+=(difference_type x) requires random_access_range&lt;Base&gt;;
    constexpr iterator&amp; operator-=(difference_type x) requires random_access_range&lt;Base&gt;;
 
    constexpr decltype(auto) operator[](difference_type n) const
      requires random_access_range&lt;Base&gt;;
 
    friend constexpr bool operator==(const iterator&amp; x, const iterator&amp; y)
      requires equality_comparable&lt;ziperator&lt;Const&gt;&gt;;
 
    friend constexpr auto operator&lt;=&gt;(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
 
    friend constexpr iterator operator+(const iterator&amp; i, difference_type n)
      requires random_access_range&lt;Base&gt;;
    friend constexpr iterator operator+(difference_type n, const iterator&amp; i)
      requires random_access_range&lt;Base&gt;;
    friend constexpr iterator operator-(const iterator&amp; i, difference_type n)
      requires random_access_range&lt;Base&gt;;
    friend constexpr difference_type operator-(const iterator&amp; x, const iterator&amp; y)
      requires sized_sentinel_for&lt;ziperator&lt;Const&gt;, ziperator&lt;Const&gt;&gt;;
  };
}</pre></div> <h4 id="Class_template_std::ranges::zip_transform_view::sentinel"> Class template <code>std::ranges::zip_transform_view::sentinel</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;move_constructible F, input_range... Views&gt;
    requires (view&lt;Views&gt; &amp;&amp; ...) &amp;&amp; (sizeof...(Views) &gt; 0) &amp;&amp; is_object_v&lt;F&gt; &amp;&amp;
              regular_invocable&lt;F&amp;, range_reference_t&lt;Views&gt;...&gt; &amp;&amp;
              __can_reference&lt;invoke_result_t&lt;F&amp;, range_reference_t&lt;Views&gt;...&gt;&gt;
  template&lt;bool Const&gt;
  class zip_transform_view&lt;F, Views...&gt;::sentinel {
    zentinel&lt;Const&gt; inner_;                                     // exposition only
    constexpr explicit sentinel(zentinel&lt;Const&gt; inner);         // exposition only
 
  public:
    sentinel() = default;
    constexpr sentinel(sentinel&lt;!Const&gt; i)
      requires Const &amp;&amp; convertible_to&lt;zentinel&lt;false&gt;, zentinel&lt;Const&gt;&gt;;
 
    template&lt;bool OtherConst&gt;
      requires sentinel_for&lt;zentinel&lt;Const&gt;, ziperator&lt;OtherConst&gt;&gt;
    friend constexpr bool operator==(const iterator&lt;OtherConst&gt;&amp; x, const sentinel&amp; y);
 
    template&lt;bool OtherConst&gt;
      requires sized_sentinel_for&lt;zentinel&lt;Const&gt;, ziperator&lt;OtherConst&gt;&gt;
    friend constexpr range_difference_t&lt;__maybe_const&lt;OtherConst, InnerView&gt;&gt;
      operator-(const iterator&lt;OtherConst&gt;&amp; x, const sentinel&amp; y);
 
    template&lt;bool OtherConst&gt;
      requires sized_sentinel_for&lt;zentinel&lt;Const&gt;, ziperator&lt;OtherConst&gt;&gt;
    friend constexpr range_difference_t&lt;__maybe_const&lt;OtherConst, InnerView&gt;&gt;
      operator-(const sentinel&amp; x, const iterator&lt;OtherConst&gt;&amp; y);
  };
}</pre></div> <h4 id="Class_template_std::ranges::adjacent_view"> Class template <code>std::ranges::adjacent_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;forward_range V, size_t N&gt;
    requires view&lt;V&gt; &amp;&amp; (N &gt; 0)
  class adjacent_view : public view_interface&lt;adjacent_view&lt;V, N&gt;&gt; {
    V base_ = V();                      // exposition only
 
    // class template adjacent_view::iterator
    template&lt;bool&gt; class iterator;      // exposition only
 
    // class template adjacent_view::sentinel
    template&lt;bool&gt; class sentinel;      // exposition only
 
    struct __as_sentinel{};             // exposition only
 
  public:
    adjacent_view() requires default_initializable&lt;V&gt; = default;
    constexpr explicit adjacent_view(V base);
 
    constexpr auto begin() requires (!__simple_view&lt;V&gt;) {
      return iterator&lt;false&gt;(ranges::begin(base_), ranges::end(base_));
    }
 
    constexpr auto begin() const requires range&lt;const V&gt; {
      return iterator&lt;true&gt;(ranges::begin(base_), ranges::end(base_));
    }
 
    constexpr auto end() requires (!__simple_view&lt;V&gt;) {
      if constexpr (common_range&lt;V&gt;) {
        return iterator&lt;false&gt;(__as_sentinel{}, ranges::begin(base_), ranges::end(base_));
      } else {
        return sentinel&lt;false&gt;(ranges::end(base_));
      }
    }
 
    constexpr auto end() const requires range&lt;const V&gt; {
      if constexpr (common_range&lt;const V&gt;) {
        return iterator&lt;true&gt;(__as_sentinel{}, ranges::begin(base_), ranges::end(base_));
      } else {
        return sentinel&lt;true&gt;(ranges::end(base_));
      }
    }
 
    constexpr auto size() requires sized_range&lt;V&gt;;
    constexpr auto size() const requires sized_range&lt;const V&gt;;
  };
}</pre></div> <h4 id="Class_template_std::ranges::adjacent_view::iterator"> Class template <code>std::ranges::adjacent_view::iterator</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;forward_range V, size_t N&gt;
    requires view&lt;V&gt; &amp;&amp; (N &gt; 0)
  template&lt;bool Const&gt;
  class adjacent_view&lt;V, N&gt;::iterator {
    using Base = __maybe_const&lt;Const, V&gt;;                               // exposition only
    array&lt;iterator_t&lt;Base&gt;, N&gt; current_ = array&lt;iterator_t&lt;Base&gt;, N&gt;(); // exposition only
    constexpr iterator(iterator_t&lt;Base&gt; first, sentinel_t&lt;Base&gt; last);  // exposition only
    constexpr iterator(__as_sentinel, iterator_t&lt;Base&gt; first, iterator_t&lt;Base&gt; last);
                                                                        // exposition only
  public:
    using iterator_category = input_iterator_tag;
    using iterator_concept  = /* see description */;
    using value_type = tuple&lt;__REPEAT(range_value_t&lt;Base&gt;, N)...&gt;;
    using difference_type = range_difference_t&lt;Base&gt;;
 
    iterator() = default;
    constexpr iterator(iterator&lt;!Const&gt; i)
      requires Const &amp;&amp; convertible_to&lt;iterator_t&lt;V&gt;, iterator_t&lt;Base&gt;&gt;;
 
    constexpr auto operator*() const;
    constexpr iterator&amp; operator++();
    constexpr iterator operator++(int);
 
    constexpr iterator&amp; operator--() requires bidirectional_range&lt;Base&gt;;
    constexpr iterator operator--(int) requires bidirectional_range&lt;Base&gt;;
 
    constexpr iterator&amp; operator+=(difference_type x)
      requires random_access_range&lt;Base&gt;;
    constexpr iterator&amp; operator-=(difference_type x)
      requires random_access_range&lt;Base&gt;;
 
    constexpr auto operator[](difference_type n) const
      requires random_access_range&lt;Base&gt;;
 
    friend constexpr bool operator==(const iterator&amp; x, const iterator&amp; y);
    friend constexpr bool operator&lt;(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr bool operator&gt;(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr bool operator&lt;=(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr bool operator&gt;=(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr auto operator&lt;=&gt;(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt; &amp;&amp;
               three_way_comparable&lt;iterator_t&lt;Base&gt;&gt;;
 
    friend constexpr iterator operator+(const iterator&amp; i, difference_type n)
      requires random_access_range&lt;Base&gt;;
    friend constexpr iterator operator+(difference_type n, const iterator&amp; i)
      requires random_access_range&lt;Base&gt;;
    friend constexpr iterator operator-(const iterator&amp; i, difference_type n)
      requires random_access_range&lt;Base&gt;;
    friend constexpr difference_type operator-(const iterator&amp; x, const iterator&amp; y)
      requires sized_sentinel_for&lt;iterator_t&lt;Base&gt;, iterator_t&lt;Base&gt;&gt;;
 
    friend constexpr auto iter_move(const iterator&amp; i) noexcept(/* see description */);
    friend constexpr void iter_swap(const iterator&amp; l,
                                    const iterator&amp; r) noexcept(/* see description */)
      requires indirectly_swappable&lt;iterator_t&lt;Base&gt;&gt;;
  };
}</pre></div> <h4 id="Class_template_std::ranges::adjacent_view::sentinel"> Class template <code>std::ranges::adjacent_view::sentinel</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;forward_range V, size_t N&gt;
    requires view&lt;V&gt; &amp;&amp; (N &gt; 0)
  template&lt;bool Const&gt;
  class adjacent_view&lt;V, N&gt;::sentinel {
    using Base = __maybe_const&lt;Const, V&gt;;                       // exposition only
    sentinel_t&lt;Base&gt; end_ = sentinel_t&lt;Base&gt;();                 // exposition only
    constexpr explicit sentinel(sentinel_t&lt;Base&gt; end);          // exposition only
 
  public:
    sentinel() = default;
    constexpr sentinel(sentinel&lt;!Const&gt; i)
      requires Const &amp;&amp; convertible_to&lt;sentinel_t&lt;V&gt;, sentinel_t&lt;Base&gt;&gt;;
 
    template&lt;bool OtherConst&gt;
      requires sentinel_for&lt;sentinel_t&lt;Base&gt;, iterator_t&lt;__maybe_const&lt;OtherConst, V&gt;&gt;&gt;
    friend constexpr bool operator==(const iterator&lt;OtherConst&gt;&amp; x, const sentinel&amp; y);
 
    template&lt;bool OtherConst&gt;
      requires sized_sentinel_for&lt;sentinel_t&lt;Base&gt;,
        iterator_t&lt;__maybe_const&lt;OtherConst, V&gt;&gt;&gt;
    friend constexpr range_difference_t&lt;__maybe_const&lt;OtherConst, V&gt;&gt;
      operator-(const iterator&lt;OtherConst&gt;&amp; x, const sentinel&amp; y);
 
    template&lt;bool OtherConst&gt;
      requires sized_sentinel_for&lt;sentinel_t&lt;Base&gt;,
        iterator_t&lt;__maybe_const&lt;OtherConst, V&gt;&gt;&gt;
    friend constexpr range_difference_t&lt;__maybe_const&lt;OtherConst, V&gt;&gt;
      operator-(const sentinel&amp; y, const iterator&lt;OtherConst&gt;&amp; x);
  };
}</pre></div> <h4 id="Class_template_std::ranges::adjacent_transform_view"> Class template <code>std::ranges::adjacent_transform_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;forward_range V, move_constructible F, size_t N&gt;
    requires view&lt;V&gt; &amp;&amp; (N &gt; 0) &amp;&amp; is_object_v&lt;F&gt; &amp;&amp;
             regular_invocable&lt;F&amp;, __REPEAT(range_reference_t&lt;V&gt;, N)...&gt; &amp;&amp;
             __can_reference&lt;invoke_result_t&lt;F&amp;, __REPEAT(range_reference_t&lt;V&gt;, N)...&gt;&gt;
  class adjacent_transform_view :
    public view_interface&lt;adjacent_transform_view&lt;V, F, N&gt;&gt; {
    __movable_box&lt;F&gt; fun_;                      // exposition only
    adjacent_view&lt;V, N&gt; inner_;                 // exposition only
 
    using InnerView = adjacent_view&lt;V, N&gt;;      // exposition only
    template&lt;bool Const&gt;
      using __inner_iterator =
        iterator_t&lt;__maybe_const&lt;Const, InnerView&gt;&gt;;    // exposition only
    template&lt;bool Const&gt;
      using __inner_sentinel =
        sentinel_t&lt;__maybe_const&lt;Const, InnerView&gt;&gt;;    // exposition only
 
    // class template adjacent_transform_view::iterator
    template&lt;bool&gt; class iterator;              // exposition only
 
    // class template adjacent_transform_view::sentinel
    template&lt;bool&gt; class sentinel;              // exposition only
 
  public:
    adjacent_transform_view() = default;
    constexpr explicit adjacent_transform_view(V base, F fun);
 
    constexpr auto begin() {
      return iterator&lt;false&gt;(*this, inner_.begin());
    }
 
    constexpr auto begin() const
      requires range&lt;const InnerView&gt; &amp;&amp;
               regular_invocable&lt;const F&amp;, __REPEAT(range_reference_t&lt;const V&gt;, N)...&gt; {
      return iterator&lt;true&gt;(*this, inner_.begin());
    }
 
    constexpr auto end() {
      if constexpr (common_range&lt;InnerView&gt;) {
        return iterator&lt;false&gt;(*this, inner_.end());
      } else {
        return sentinel&lt;false&gt;(inner_.end());
      }
    }
 
    constexpr auto end() const
      requires range&lt;const InnerView&gt; &amp;&amp;
               regular_invocable&lt;const F&amp;, __REPEAT(range_reference_t&lt;const V&gt;, N)...&gt; {
      if constexpr (common_range&lt;const InnerView&gt;) {
        return iterator&lt;true&gt;(*this, inner_.end());
      } else {
        return sentinel&lt;true&gt;(inner_.end());
      }
    }
 
    constexpr auto size() requires sized_range&lt;InnerView&gt; {
      return inner_.size();
    }
 
    constexpr auto size() const requires sized_range&lt;const InnerView&gt; {
      return inner_.size();
    }
  };
}</pre></div> <h4 id="Class_template_std::ranges::adjacent_transform_view::iterator"> Class template <code>std::ranges::adjacent_transform_view::iterator</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;forward_range V, move_constructible F, size_t N&gt;
    requires view&lt;V&gt; &amp;&amp; (N &gt; 0) &amp;&amp; is_object_v&lt;F&gt; &amp;&amp;
             regular_invocable&lt;F&amp;, __REPEAT(range_reference_t&lt;V&gt;, N)...&gt; &amp;&amp;
             __can_reference&lt;invoke_result_t&lt;F&amp;, __REPEAT(range_reference_t&lt;V&gt;, N)...&gt;&gt;
  template&lt;bool Const&gt;
  class adjacent_transform_view&lt;V, F, N&gt;::iterator {
    using Parent = __maybe_const&lt;Const, adjacent_transform_view&gt;;       // exposition only
    using Base = __maybe_const&lt;Const, V&gt;;                               // exposition only
    Parent* parent_ = nullptr;                                          // exposition only
    __inner_iterator&lt;Const&gt; inner_;                                     // exposition only
 
    constexpr iterator(Parent&amp; parent, __inner_iterator&lt;Const&gt; inner);  // exposition only
 
  public:
    using iterator_category = /* see description */;
    using iterator_concept  = typename __inner_iterator&lt;Const&gt;::iterator_concept;
    using value_type =
      remove_cvref_t&lt;invoke_result_t&lt;__maybe_const&lt;Const, F&gt;&amp;,
                                     __REPEAT(range_reference_t&lt;Base&gt;, N)...&gt;&gt;;
    using difference_type = range_difference_t&lt;Base&gt;;
 
    iterator() = default;
    constexpr iterator(iterator&lt;!Const&gt; i)
      requires Const &amp;&amp; convertible_to&lt;__inner_iterator&lt;false&gt;, __inner_iterator&lt;Const&gt;&gt;;
 
    constexpr decltype(auto) operator*() const noexcept(/* see description */);
    constexpr iterator&amp; operator++();
    constexpr iterator operator++(int);
    constexpr iterator&amp; operator--() requires bidirectional_range&lt;Base&gt;;
    constexpr iterator operator--(int) requires bidirectional_range&lt;Base&gt;;
    constexpr iterator&amp; operator+=(difference_type x) requires random_access_range&lt;Base&gt;;
    constexpr iterator&amp; operator-=(difference_type x) requires random_access_range&lt;Base&gt;;
 
    constexpr decltype(auto) operator[](difference_type n) const
      requires random_access_range&lt;Base&gt;;
 
    friend constexpr bool operator==(const iterator&amp; x, const iterator&amp; y);
    friend constexpr bool operator&lt;(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr bool operator&gt;(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr bool operator&lt;=(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr bool operator&gt;=(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr auto operator&lt;=&gt;(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt; &amp;&amp; three_way_comparable&lt;__inner_iterator&lt;Const&gt;&gt;;
 
    friend constexpr iterator operator+(const iterator&amp; i, difference_type n)
      requires random_access_range&lt;Base&gt;;
    friend constexpr iterator operator+(difference_type n, const iterator&amp; i)
      requires random_access_range&lt;Base&gt;;
    friend constexpr iterator operator-(const iterator&amp; i, difference_type n)
      requires random_access_range&lt;Base&gt;;
    friend constexpr difference_type operator-(const iterator&amp; x, const iterator&amp; y)
      requires sized_sentinel_for&lt;__inner_iterator&lt;Const&gt;, __inner_iterator&lt;Const&gt;&gt;;
  };
}</pre></div> <h4 id="Class_template_std::ranges::adjacent_transform_view::sentinel"> Class template <code>std::ranges::adjacent_transform_view::sentinel</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;forward_range V, move_constructible F, size_t N&gt;
    requires view&lt;V&gt; &amp;&amp; (N &gt; 0) &amp;&amp; is_object_v&lt;F&gt; &amp;&amp;
             regular_invocable&lt;F&amp;, __REPEAT(range_reference_t&lt;V&gt;, N)...&gt; &amp;&amp;
             __can_reference&lt;invoke_result_t&lt;F&amp;, __REPEAT(range_reference_t&lt;V&gt;, N)...&gt;&gt;
  template&lt;bool Const&gt;
  class adjacent_transform_view&lt;V, F, N&gt;::sentinel {
    __inner_sentinel&lt;Const&gt; inner_;                               // exposition only
    constexpr explicit sentinel(__inner_sentinel&lt;Const&gt; inner);   // exposition only
 
  public:
    sentinel() = default;
    constexpr sentinel(sentinel&lt;!Const&gt; i)
      requires Const &amp;&amp; convertible_to&lt;__inner_sentinel&lt;false&gt;, __inner_sentinel&lt;Const&gt;&gt;;
 
    template&lt;bool OtherConst&gt;
      requires sentinel_for&lt;__inner_sentinel&lt;Const&gt;, __inner_iterator&lt;OtherConst&gt;&gt;
    friend constexpr bool operator==(const iterator&lt;OtherConst&gt;&amp; x, const sentinel&amp; y);
 
    template&lt;bool OtherConst&gt;
      requires sized_sentinel_for&lt;__inner_sentinel&lt;Const&gt;, __inner_iterator&lt;OtherConst&gt;&gt;
    friend constexpr range_difference_t&lt;__maybe_const&lt;OtherConst, InnerView&gt;&gt;
      operator-(const iterator&lt;OtherConst&gt;&amp; x, const sentinel&amp; y);
 
    template&lt;bool OtherConst&gt;
      requires sized_sentinel_for&lt;__inner_sentinel&lt;Const&gt;, __inner_iterator&lt;OtherConst&gt;&gt;
    friend constexpr range_difference_t&lt;__maybe_const&lt;OtherConst, InnerView&gt;&gt;
      operator-(const sentinel&amp; x, const iterator&lt;OtherConst&gt;&amp; y);
  };
}</pre></div> <h4 id="Class_template_std::ranges::chunk_view_for_input_ranges"> Class template <code>std::ranges::chunk_view</code> for <a href="../ranges/input_range" title="cpp/ranges/input range"><code>input_range</code>s</a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class I&gt;
  constexpr I __div_ceil(I num, I denom) {                  // exposition only
    I r = num / denom;
    if (num % denom)
      ++r;
    return r;
  }
 
  template&lt;view V&gt;
    requires input_range&lt;V&gt;
  class chunk_view : public view_interface&lt;chunk_view&lt;V&gt;&gt; {
    V base_;                                                // exposition only
    range_difference_t&lt;V&gt; n_;                               // exposition only
    range_difference_t&lt;V&gt; remainder_ = 0;                   // exposition only
 
    __non_propagating_cache&lt;iterator_t&lt;V&gt;&gt; current_;        // exposition only
 
    // class chunk_view::outer-iterator
    class __outer_iterator;                                 // exposition only
 
    // class chunk_view::inner-iterator
    class __inner_iterator;                                 // exposition only
 
  public:
    constexpr explicit chunk_view(V base, range_difference_t&lt;V&gt; n);
 
    constexpr V base() const &amp; requires copy_constructible&lt;V&gt; { return base_; }
    constexpr V base() &amp;&amp; { return std::move(base_); }
 
    constexpr __outer_iterator begin();
    constexpr default_sentinel_t end() const noexcept;
 
    constexpr auto size() requires sized_range&lt;V&gt;;
    constexpr auto size() const requires sized_range&lt;const V&gt;;
  };
 
  template&lt;class R&gt;
    chunk_view(R&amp;&amp;, range_difference_t&lt;R&gt;) -&gt; chunk_view&lt;views::all_t&lt;R&gt;&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::chunk_view::outer_iterator_for_input_ranges"> Class template <code>std::ranges::chunk_view::outer_iterator</code> for <a href="../ranges/input_range" title="cpp/ranges/input range"><code>input_range</code>s</a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;view V&gt;
    requires input_range&lt;V&gt;
  class chunk_view&lt;V&gt;::__outer_iterator {
    chunk_view* parent_;                                        // exposition only
 
    constexpr explicit __outer_iterator(chunk_view&amp; parent);    // exposition only
 
  public:
    using iterator_concept = input_iterator_tag;
    using difference_type  = range_difference_t&lt;V&gt;;
 
    // class chunk_view::outer-iterator::value_type
    struct value_type;
 
    __outer_iterator(__outer_iterator&amp;&amp;) = default;
    __outer_iterator&amp; operator=(__outer_iterator&amp;&amp;) = default;
 
    constexpr value_type operator*() const;
    constexpr __outer_iterator&amp; operator++();
    constexpr void operator++(int);
 
    friend constexpr bool operator==(const __outer_iterator&amp; x, default_sentinel_t);
 
    friend constexpr difference_type operator-(default_sentinel_t y,
                                               const __outer_iterator&amp; x)
      requires sized_sentinel_for&lt;sentinel_t&lt;V&gt;, iterator_t&lt;V&gt;&gt;;
    friend constexpr difference_type operator-(const __outer_iterator&amp; x,
                                               default_sentinel_t y)
      requires sized_sentinel_for&lt;sentinel_t&lt;V&gt;, iterator_t&lt;V&gt;&gt;;
  };
}</pre></div> <h4 id="Class_template_std::ranges::chunk_view::outer_iterator::value_type_for_input_ranges"> Class template <code>std::ranges::chunk_view::outer_iterator::value_type</code> for <a href="../ranges/input_range" title="cpp/ranges/input range"><code>input_range</code>s</a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;view V&gt;
    requires input_range&lt;V&gt;
  struct chunk_view&lt;V&gt;::__outer_iterator::value_type : view_interface&lt;value_type&gt; {
  private:
    chunk_view* parent_;                                        // exposition only
 
    constexpr explicit value_type(chunk_view&amp; parent);          // exposition only
 
  public:
    constexpr __inner_iterator begin() const noexcept;
    constexpr default_sentinel_t end() const noexcept;
 
    constexpr auto size() const
      requires sized_sentinel_for&lt;sentinel_t&lt;V&gt;, iterator_t&lt;V&gt;&gt;;
  };
}</pre></div> <h4 id="Class_template_std::ranges::chunk_view::inner_iterator_for_input_ranges"> Class template <code>std::ranges::chunk_view::inner_iterator</code> for <a href="../ranges/input_range" title="cpp/ranges/input range"><code>input_range</code>s</a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;view V&gt;
    requires input_range&lt;V&gt;
  class chunk_view&lt;V&gt;::__inner_iterator {
    chunk_view* parent_;                                                // exposition only
 
    constexpr explicit __inner_iterator(chunk_view&amp; parent) noexcept;   // exposition only
 
  public:
    using iterator_concept = input_iterator_tag;
    using difference_type = range_difference_t&lt;V&gt;;
    using value_type = range_value_t&lt;V&gt;;
 
    __inner_iterator(__inner_iterator&amp;&amp;) = default;
    __inner_iterator&amp; operator=(__inner_iterator&amp;&amp;) = default;
 
    constexpr const iterator_t&lt;V&gt;&amp; base() const &amp;;
 
    constexpr range_reference_t&lt;V&gt; operator*() const;
    constexpr __inner_iterator&amp; operator++();
    constexpr void operator++(int);
 
    friend constexpr bool operator==(const __inner_iterator&amp; x, default_sentinel_t);
 
    friend constexpr difference_type operator-(default_sentinel_t y,
                                               const __inner_iterator&amp; x)
      requires sized_sentinel_for&lt;sentinel_t&lt;V&gt;, iterator_t&lt;V&gt;&gt;;
    friend constexpr difference_type operator-(const __inner_iterator&amp; x,
                                               default_sentinel_t y)
      requires sized_sentinel_for&lt;sentinel_t&lt;V&gt;, iterator_t&lt;V&gt;&gt;;
  };
}</pre></div> <h4 id="Class_template_std::ranges::chunk_view_for_forward_ranges"> Class template <code>std::ranges::chunk_view</code> for <a href="../ranges/forward_range" title="cpp/ranges/forward range"><code>forward_range</code>s</a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;view V&gt;
    requires forward_range&lt;V&gt;
  class chunk_view&lt;V&gt; : public view_interface&lt;chunk_view&lt;V&gt;&gt; {
    V base_;                            // exposition only
    range_difference_t&lt;V&gt; n_;           // exposition only
 
    // class template chunk_view::iterator
    template&lt;bool&gt; class iterator;      // exposition only
 
  public:
    constexpr explicit chunk_view(V base, range_difference_t&lt;V&gt; n);
 
    constexpr V base() const &amp; requires copy_constructible&lt;V&gt; { return base_; }
    constexpr V base() &amp;&amp; { return std::move(base_); }
 
    constexpr auto begin() requires (!__simple_view&lt;V&gt;) {
      return iterator&lt;false&gt;(this, ranges::begin(base_));
    }
 
    constexpr auto begin() const requires forward_range&lt;const V&gt; {
      return iterator&lt;true&gt;(this, ranges::begin(base_));
    }
 
    constexpr auto end() requires (!__simple_view&lt;V&gt;) {
      if constexpr (common_range&lt;V&gt; &amp;&amp; sized_range&lt;V&gt;) {
        auto missing = (n_ - ranges::distance(base_) % n_) % n_;
        return iterator&lt;false&gt;(this, ranges::end(base_), missing);
      } else if constexpr (common_range&lt;V&gt; &amp;&amp; !bidirectional_range&lt;V&gt;) {
        return iterator&lt;false&gt;(this, ranges::end(base_));
      } else {
        return default_sentinel;
      }
    }
 
    constexpr auto end() const requires forward_range&lt;const V&gt; {
      if constexpr (common_range&lt;const V&gt; &amp;&amp; sized_range&lt;const V&gt;) {
        auto missing = (n_ - ranges::distance(base_) % n_) % n_;
        return iterator&lt;true&gt;(this, ranges::end(base_), missing);
      } else if constexpr (common_range&lt;const V&gt; &amp;&amp; !bidirectional_range&lt;const V&gt;) {
        return iterator&lt;true&gt;(this, ranges::end(base_));
      } else {
        return default_sentinel;
      }
    }
 
    constexpr auto size() requires sized_range&lt;V&gt;;
    constexpr auto size() const requires sized_range&lt;const V&gt;;
  };
}</pre></div> <h4 id="Class_template_std::ranges::chunk_view::iterator_for_forward_ranges"> Class template <code>std::ranges::chunk_view::iterator</code> for <a href="../ranges/forward_range" title="cpp/ranges/forward range"><code>forward_range</code>s</a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;view V&gt;
    requires forward_range&lt;V&gt;
  template&lt;bool Const&gt;
  class chunk_view&lt;V&gt;::iterator {
    using Parent = __maybe_const&lt;Const, chunk_view&gt;;                    // exposition only
    using Base = __maybe_const&lt;Const, V&gt;;                               // exposition only
 
    iterator_t&lt;Base&gt; current_ = iterator_t&lt;Base&gt;();                     // exposition only
    sentinel_t&lt;Base&gt; end_ = sentinel_t&lt;Base&gt;();                         // exposition only
    range_difference_t&lt;Base&gt; n_ = 0;                                    // exposition only
    range_difference_t&lt;Base&gt; missing_ = 0;                              // exposition only
 
    constexpr iterator(Parent* parent, iterator_t&lt;Base&gt; current,        // exposition only
                       range_difference_t&lt;Base&gt; missing = 0);
 
  public:
    using iterator_category = input_iterator_tag;
    using iterator_concept = /* see description */;
    using value_type = decltype(views::take(subrange(current_, end_), n_));
    using difference_type = range_difference_t&lt;Base&gt;;
 
    iterator() = default;
    constexpr iterator(iterator&lt;!Const&gt; i)
      requires Const &amp;&amp; convertible_to&lt;iterator_t&lt;V&gt;, iterator_t&lt;Base&gt;&gt;
                     &amp;&amp; convertible_to&lt;sentinel_t&lt;V&gt;, sentinel_t&lt;Base&gt;&gt;;
 
    constexpr iterator_t&lt;Base&gt; base() const;
 
    constexpr value_type operator*() const;
    constexpr iterator&amp; operator++();
    constexpr iterator operator++(int);
 
    constexpr iterator&amp; operator--() requires bidirectional_range&lt;Base&gt;;
    constexpr iterator operator--(int) requires bidirectional_range&lt;Base&gt;;
 
    constexpr iterator&amp; operator+=(difference_type x)
      requires random_access_range&lt;Base&gt;;
    constexpr iterator&amp; operator-=(difference_type x)
      requires random_access_range&lt;Base&gt;;
 
    constexpr value_type operator[](difference_type n) const
      requires random_access_range&lt;Base&gt;;
 
    friend constexpr bool operator==(const iterator&amp; x, const iterator&amp; y);
    friend constexpr bool operator==(const iterator&amp; x, default_sentinel_t);
 
    friend constexpr bool operator&lt;(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr bool operator&gt;(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr bool operator&lt;=(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr bool operator&gt;=(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr auto operator&lt;=&gt;(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt; &amp;&amp;
               three_way_comparable&lt;iterator_t&lt;Base&gt;&gt;;
 
    friend constexpr iterator operator+(const iterator&amp; i, difference_type n)
      requires random_access_range&lt;Base&gt;;
    friend constexpr iterator operator+(difference_type n, const iterator&amp; i)
      requires random_access_range&lt;Base&gt;;
    friend constexpr iterator operator-(const iterator&amp; i, difference_type n)
      requires random_access_range&lt;Base&gt;;
    friend constexpr difference_type operator-(const iterator&amp; x, const iterator&amp; y)
      requires sized_sentinel_for&lt;iterator_t&lt;Base&gt;, iterator_t&lt;Base&gt;&gt;;
 
    friend constexpr difference_type operator-(default_sentinel_t y, const iterator&amp; x)
      requires sized_sentinel_for&lt;sentinel_t&lt;Base&gt;, iterator_t&lt;Base&gt;&gt;;
    friend constexpr difference_type operator-(const iterator&amp; x, default_sentinel_t y)
      requires sized_sentinel_for&lt;sentinel_t&lt;Base&gt;, iterator_t&lt;Base&gt;&gt;;
  };
}</pre></div> <h4 id="Class_template_std::ranges::slide_view"> Class template <code>std::ranges::slide_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class V&gt;
  concept __slide_caches_nothing = random_access_range&lt;V&gt; &amp;&amp;
    sized_range&lt;V&gt;;                                             // exposition only
 
  template&lt;class V&gt;
  concept __slide_caches_last =                                 // exposition only
    !__slide_caches_nothing&lt;V&gt; &amp;&amp; bidirectional_range&lt;V&gt; &amp;&amp; common_range&lt;V&gt;;
 
  template&lt;class V&gt;
  concept __slide_caches_first =                                // exposition only
    !__slide_caches_nothing&lt;V&gt; &amp;&amp; !__slide_caches_last&lt;V&gt;;
 
  template&lt;forward_range V&gt;
    requires view&lt;V&gt;
  class slide_view : public view_interface&lt;slide_view&lt;V&gt;&gt; {
    V base_;                            // exposition only
    range_difference_t&lt;V&gt; n_;           // exposition only
 
    // class template slide_view::iterator
    template&lt;bool&gt; class iterator;      // exposition only
 
    // class slide_view::sentinel
    class sentinel;                     // exposition only
 
  public:
    constexpr explicit slide_view(V base, range_difference_t&lt;V&gt; n);
 
    constexpr auto begin()
      requires (!(__simple_view&lt;V&gt; &amp;&amp; __slide_caches_nothing&lt;const V&gt;));
    constexpr auto begin() const requires __slide_caches_nothing&lt;const V&gt;;
 
    constexpr auto end()
      requires (!(__simple_view&lt;V&gt; &amp;&amp; __slide_caches_nothing&lt;const V&gt;));
    constexpr auto end() const requires __slide_caches_nothing&lt;const V&gt;;
 
    constexpr auto size() requires sized_range&lt;V&gt;;
    constexpr auto size() const requires sized_range&lt;const V&gt;;
  };
 
  template&lt;class R&gt;
    slide_view(R&amp;&amp;, range_difference_t&lt;R&gt;) -&gt; slide_view&lt;views::all_t&lt;R&gt;&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::slide_view::iterator"> Class template <code>std::ranges::slide_view::iterator</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;forward_range V&gt;
    requires view&lt;V&gt;
  template&lt;bool Const&gt;
  class slide_view&lt;V&gt;::iterator {
    using Base = __maybe_const&lt;Const, V&gt;;               // exposition only
    iterator_t&lt;Base&gt; current_   = iterator_t&lt;Base&gt;();   // exposition only
    iterator_t&lt;Base&gt; last_ele_  = iterator_t&lt;Base&gt;();   // exposition only,
                                    // present only if Base models slide-caches-first
    range_difference_t&lt;Base&gt; n_ = 0;                    // exposition only
 
    constexpr iterator(iterator_t&lt;Base&gt; current,        // exposition only
                       range_difference_t&lt;Base&gt; n)
      requires (!__slide_caches_first&lt;Base&gt;);
 
    constexpr iterator(iterator_t&lt;Base&gt; current,        // exposition only
                       iterator_t&lt;Base&gt; last_ele,
                       range_difference_t&lt;Base&gt; n)
      requires __slide_caches_first&lt;Base&gt;;
 
  public:
    using iterator_category = input_iterator_tag;
    using iterator_concept = /* see description */;
    using value_type = decltype(views::counted(current_, n_));
    using difference_type = range_difference_t&lt;Base&gt;;
 
    iterator() = default;
    constexpr iterator(iterator&lt;!Const&gt; i)
      requires Const &amp;&amp; convertible_to&lt;iterator_t&lt;V&gt;, iterator_t&lt;Base&gt;&gt;;
 
    constexpr auto operator*() const;
    constexpr iterator&amp; operator++();
    constexpr iterator operator++(int);
 
    constexpr iterator&amp; operator--() requires bidirectional_range&lt;Base&gt;;
    constexpr iterator operator--(int) requires bidirectional_range&lt;Base&gt;;
 
    constexpr iterator&amp; operator+=(difference_type x)
      requires random_access_range&lt;Base&gt;;
    constexpr iterator&amp; operator-=(difference_type x)
      requires random_access_range&lt;Base&gt;;
 
    constexpr auto operator[](difference_type n) const
      requires random_access_range&lt;Base&gt;;
 
    friend constexpr bool operator==(const iterator&amp; x, const iterator&amp; y);
 
    friend constexpr bool operator&lt;(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr bool operator&gt;(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr bool operator&lt;=(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr bool operator&gt;=(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr auto operator&lt;=&gt;(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt; &amp;&amp;
               three_way_comparable&lt;iterator_t&lt;Base&gt;&gt;;
 
    friend constexpr iterator operator+(const iterator&amp; i, difference_type n)
      requires random_access_range&lt;Base&gt;;
    friend constexpr iterator operator+(difference_type n, const iterator&amp; i)
      requires random_access_range&lt;Base&gt;;
    friend constexpr iterator operator-(const iterator&amp; i, difference_type n)
      requires random_access_range&lt;Base&gt;;
    friend constexpr difference_type operator-(const iterator&amp; x, const iterator&amp; y)
      requires sized_sentinel_for&lt;iterator_t&lt;Base&gt;, iterator_t&lt;Base&gt;&gt;;
  };
}</pre></div> <h4 id="Class_template_std::ranges::slide_view::sentinel"> Class template <code>std::ranges::slide_view::sentinel</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;forward_range V&gt;
    requires view&lt;V&gt;
  class slide_view&lt;V&gt;::sentinel {
    sentinel_t&lt;V&gt; end_ = sentinel_t&lt;V&gt;();             // exposition only
    constexpr explicit sentinel(sentinel_t&lt;V&gt; end);   // exposition only
 
  public:
    sentinel() = default;
 
    friend constexpr bool operator==(const iterator&lt;false&gt;&amp; x, const sentinel&amp; y);
 
    friend constexpr range_difference_t&lt;V&gt;
      operator-(const iterator&lt;false&gt;&amp; x, const sentinel&amp; y)
        requires sized_sentinel_for&lt;sentinel_t&lt;V&gt;, iterator_t&lt;V&gt;&gt;;
 
    friend constexpr range_difference_t&lt;V&gt;
      operator-(const sentinel&amp; y, const iterator&lt;false&gt;&amp; x)
        requires sized_sentinel_for&lt;sentinel_t&lt;V&gt;, iterator_t&lt;V&gt;&gt;;
  };
}</pre></div> <h4 id="Class_template_std::ranges::chunk_by_view"> Class template <code>std::ranges::chunk_by_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;forward_range V, indirect_binary_predicate&lt;iterator_t&lt;V&gt;, iterator_t&lt;V&gt;&gt; Pred&gt;
    requires view&lt;V&gt; &amp;&amp; is_object_v&lt;Pred&gt;
  class chunk_by_view : public view_interface&lt;chunk_by_view&lt;V, Pred&gt;&gt; {
    V base_ = V();                                          // exposition only
    __movable_box&lt;Pred&gt; pred_ = Pred();                     // exposition only
 
    // class chunk_by_view::iterator
    class iterator;                                         // exposition only
 
  public:
    chunk_by_view() requires default_initializable&lt;V&gt; &amp;&amp;
        default_initializable&lt;Pred&gt; = default;
    constexpr explicit chunk_by_view(V base, Pred pred);
 
    constexpr V base() const &amp; requires copy_constructible&lt;V&gt; { return base_; }
    constexpr V base() &amp;&amp; { return std::move(base_); }
 
    constexpr const Pred&amp; pred() const;
 
    constexpr iterator begin();
    constexpr auto end();
 
    constexpr iterator_t&lt;V&gt; __find_next(iterator_t&lt;V&gt;);       // exposition only
    constexpr iterator_t&lt;V&gt; __find_prev(iterator_t&lt;V&gt;)        // exposition only
      requires bidirectional_range&lt;V&gt;;
  };
 
  template&lt;class R, class Pred&gt;
    chunk_by_view(R&amp;&amp;, Pred) -&gt; chunk_by_view&lt;views::all_t&lt;R&gt;, Pred&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::chunk_by_view::iterator"> Class template <code>std::ranges::chunk_by_view::iterator</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;forward_range V, indirect_binary_predicate&lt;iterator_t&lt;V&gt;, iterator_t&lt;V&gt;&gt; Pred&gt;
    requires view&lt;V&gt; &amp;&amp; is_object_v&lt;Pred&gt;
  class chunk_by_view&lt;V, Pred&gt;::iterator {
    chunk_by_view* parent_ = nullptr;                                   // exposition only
    iterator_t&lt;V&gt; current_ = iterator_t&lt;V&gt;();                           // exposition only
    iterator_t&lt;V&gt; next_    = iterator_t&lt;V&gt;();                           // exposition only
 
    constexpr iterator(chunk_by_view&amp; parent, iterator_t&lt;V&gt; current,    // exposition only
                       iterator_t&lt;V&gt; next);
 
  public:
    using value_type = subrange&lt;iterator_t&lt;V&gt;&gt;;
    using difference_type  = range_difference_t&lt;V&gt;;
    using iterator_category = input_iterator_tag;
    using iterator_concept = /* see description */;
 
    iterator() = default;
 
    constexpr value_type operator*() const;
    constexpr iterator&amp; operator++();
    constexpr iterator operator++(int);
 
    constexpr iterator&amp; operator--() requires bidirectional_range&lt;V&gt;;
    constexpr iterator operator--(int) requires bidirectional_range&lt;V&gt;;
 
    friend constexpr bool operator==(const iterator&amp; x, const iterator&amp; y);
    friend constexpr bool operator==(const iterator&amp; x, default_sentinel_t);
  };
}</pre></div> <h4 id="Class_template_std::ranges::stride_view"> Class template <code>std::ranges::stride_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;input_range V&gt;
    requires view&lt;V&gt;
  class stride_view : public view_interface&lt;stride_view&lt;V&gt;&gt; {
    V base_;                                    // exposition only
    range_difference_t&lt;V&gt; stride_;              // exposition only
    // class template stride_view::iterator
    template&lt;bool&gt; class iterator;              // exposition only
  public:
    constexpr explicit stride_view(V base, range_difference_t&lt;V&gt; stride);
 
    constexpr V base() const &amp; requires copy_constructible&lt;V&gt; { return base_; }
    constexpr V base() &amp;&amp; { return std::move(base_); }
 
    constexpr range_difference_t&lt;V&gt; stride() const noexcept;
 
    constexpr auto begin() requires (!__simple_view&lt;V&gt;) {
      return iterator&lt;false&gt;(this, ranges::begin(base_));
    }
 
    constexpr auto begin() const requires range&lt;const V&gt; {
      return iterator&lt;true&gt;(this, ranges::begin(base_));
    }
 
    constexpr auto end() requires (!__simple_view&lt;V&gt;) {
      if constexpr (common_range&lt;V&gt; &amp;&amp; sized_range&lt;V&gt; &amp;&amp; forward_range&lt;V&gt;) {
        auto missing = (stride_ - ranges::distance(base_) % stride_) % stride_;
        return iterator&lt;false&gt;(this, ranges::end(base_), missing);
      } else if constexpr (common_range&lt;V&gt; &amp;&amp; !bidirectional_range&lt;V&gt;) {
        return iterator&lt;false&gt;(this, ranges::end(base_));
      } else {
        return default_sentinel;
      }
    }
 
    constexpr auto end() const requires range&lt;const V&gt; {
      if constexpr (common_range&lt;const V&gt; &amp;&amp; sized_range&lt;const V&gt; &amp;&amp;
          forward_range&lt;const V&gt;) {
        auto missing = (stride_ - ranges::distance(base_) % stride_) % stride_;
        return iterator&lt;true&gt;(this, ranges::end(base_), missing);
      } else if constexpr (common_range&lt;const V&gt; &amp;&amp; !bidirectional_range&lt;const V&gt;) {
        return iterator&lt;true&gt;(this, ranges::end(base_));
      } else {
        return default_sentinel;
      }
    }
 
    constexpr auto size() requires sized_range&lt;V&gt;;
    constexpr auto size() const requires sized_range&lt;const V&gt;;
  };
 
  template&lt;class R&gt;
    stride_view(R&amp;&amp;, range_difference_t&lt;R&gt;) -&gt; stride_view&lt;views::all_t&lt;R&gt;&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::stride_view::iterator"> Class template <code>std::ranges::stride_view::iterator</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;input_range V&gt;
    requires view&lt;V&gt;
  template&lt;bool Const&gt;
  class stride_view&lt;V&gt;::iterator {
    using Parent = __maybe_const&lt;Const, stride_view&gt;;               // exposition only
    using Base = __maybe_const&lt;Const, V&gt;;                           // exposition only
 
    iterator_t&lt;Base&gt; current_ = iterator_t&lt;Base&gt;();                 // exposition only
    sentinel_t&lt;Base&gt; end_ = sentinel_t&lt;Base&gt;();                     // exposition only
    range_difference_t&lt;Base&gt; stride_ = 0;                           // exposition only
    range_difference_t&lt;Base&gt; missing_ = 0;                          // exposition only
 
    constexpr iterator(Parent* parent, iterator_t&lt;Base&gt; current,    // exposition only
                       range_difference_t&lt;Base&gt; missing = 0);
  public:
    using difference_type = range_difference_t&lt;Base&gt;;
    using value_type = range_value_t&lt;Base&gt;;
    using iterator_concept = /* see description */;
    using iterator_category = /* see description */;    // not always present
 
    iterator() requires default_initializable&lt;iterator_t&lt;Base&gt;&gt; = default;
 
    constexpr iterator(iterator&lt;!Const&gt; other)
      requires Const &amp;&amp; convertible_to&lt;iterator_t&lt;V&gt;, iterator_t&lt;Base&gt;&gt;
                     &amp;&amp; convertible_to&lt;sentinel_t&lt;V&gt;, sentinel_t&lt;Base&gt;&gt;;
 
    constexpr iterator_t&lt;Base&gt; base() &amp;&amp;;
    constexpr const iterator_t&lt;Base&gt;&amp; base() const &amp; noexcept;
 
    constexpr decltype(auto) operator*() const { return *current_; }
 
    constexpr iterator&amp; operator++();
    constexpr void operator++(int);
    constexpr iterator operator++(int) requires forward_range&lt;Base&gt;;
 
    constexpr iterator&amp; operator--() requires bidirectional_range&lt;Base&gt;;
    constexpr iterator operator--(int) requires bidirectional_range&lt;Base&gt;;
 
    constexpr iterator&amp; operator+=(difference_type n) requires random_access_range&lt;Base&gt;;
    constexpr iterator&amp; operator-=(difference_type n) requires random_access_range&lt;Base&gt;;
 
    constexpr decltype(auto) operator[](difference_type n) const
      requires random_access_range&lt;Base&gt;
    { return *(*this + n); }
 
    friend constexpr bool operator==(const iterator&amp; x, default_sentinel_t);
 
    friend constexpr bool operator==(const iterator&amp; x, const iterator&amp; y)
      requires equality_comparable&lt;iterator_t&lt;Base&gt;&gt;;
 
    friend constexpr bool operator&lt;(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
 
    friend constexpr bool operator&gt;(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
 
    friend constexpr bool operator&lt;=(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
 
    friend constexpr bool operator&gt;=(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
 
    friend constexpr auto operator&lt;=&gt;(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt; &amp;&amp; three_way_comparable&lt;iterator_t&lt;Base&gt;&gt;;
 
    friend constexpr iterator operator+(const iterator&amp; x, difference_type n)
      requires random_access_range&lt;Base&gt;;
    friend constexpr iterator operator+(difference_type n, const iterator&amp; x)
      requires random_access_range&lt;Base&gt;;
    friend constexpr iterator operator-(const iterator&amp; x, difference_type n)
      requires random_access_range&lt;Base&gt;;
    friend constexpr difference_type operator-(const iterator&amp; x, const iterator&amp; y)
      requires sized_sentinel_for&lt;iterator_t&lt;Base&gt;, iterator_t&lt;Base&gt;&gt;;
 
    friend constexpr difference_type operator-(default_sentinel_t y, const iterator&amp; x)
      requires sized_sentinel_for&lt;sentinel_t&lt;Base&gt;, iterator_t&lt;Base&gt;&gt;;
    friend constexpr difference_type operator-(const iterator&amp; x, default_sentinel_t y)
      requires sized_sentinel_for&lt;sentinel_t&lt;Base&gt;, iterator_t&lt;Base&gt;&gt;;
 
    friend constexpr range_rvalue_reference_t&lt;Base&gt; iter_move(const iterator&amp; i)
      noexcept(noexcept(ranges::iter_move(i.current_)));
 
    friend constexpr void iter_swap(const iterator&amp; x, const iterator&amp; y)
      noexcept(noexcept(ranges::iter_swap(x.current_, y.current_)))
      requires indirectly_swappable&lt;iterator_t&lt;Base&gt;&gt;;
  };
}</pre></div> <h4 id="Class_template_std::ranges::cartesian_product_view"> Class template <code>std::ranges::cartesian_product_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;bool Const, class First, class... Vs&gt;
  concept __cartesian_product_is_random_access =          // exposition only
    (random_access_range&lt;__maybe_const&lt;Const, First&gt;&gt; &amp;&amp; ... &amp;&amp;
      (random_access_range&lt;__maybe_const&lt;Const, Vs&gt;&gt;
        &amp;&amp; sized_range&lt;__maybe_const&lt;Const, Vs&gt;&gt;));
 
  template&lt;class R&gt;
  concept __cartesian_product_common_arg =                // exposition only
    common_range&lt;R&gt; || (sized_range&lt;R&gt; &amp;&amp; random_access_range&lt;R&gt;);
 
  template&lt;bool Const, class First, class... Vs&gt;
  concept __cartesian_product_is_bidirectional =          // exposition only
    (bidirectional_range&lt;__maybe_const&lt;Const, First&gt;&gt; &amp;&amp; ... &amp;&amp;
      (bidirectional_range&lt;__maybe_const&lt;Const, Vs&gt;&gt;
        &amp;&amp; __cartesian_product_common_arg&lt;__maybe_const&lt;Const, Vs&gt;&gt;));
 
  template&lt;class First, class... Vs&gt;
  concept __cartesian_product_is_common =                 // exposition only
    __cartesian_product_common_arg&lt;First&gt;;
 
  template&lt;class... Vs&gt;
  concept __cartesian_product_is_sized =                  // exposition only
    (sized_range&lt;Vs&gt; &amp;&amp; ...);
 
  template&lt;bool Const, template&lt;class&gt; class FirstSent, class First, class... Vs&gt;
    concept __cartesian_is_sized_sentinel =               // exposition only
      (sized_sentinel_for&lt;FirstSent&lt;__maybe_const&lt;Const, First&gt;&gt;,
          iterator_t&lt;__maybe_const&lt;Const, First&gt;&gt;&gt; &amp;&amp; ...
        &amp;&amp; (sized_range&lt;__maybe_const&lt;Const, Vs&gt;&gt;
          &amp;&amp; sized_sentinel_for&lt;iterator_t&lt;__maybe_const&lt;Const, Vs&gt;&gt;,
              iterator_t&lt;__maybe_const&lt;Const, Vs&gt;&gt;&gt;));
 
  template&lt;__cartesian_product_common_arg R&gt;
  constexpr auto __cartesian_common_arg_end(R&amp; r) {       // exposition only
    if constexpr (common_range&lt;R&gt;) {
      return ranges::end(r);
    } else {
      return ranges::begin(r) + ranges::distance(r);
    }
  }
 
  template&lt;input_range First, forward_range... Vs&gt;
    requires (view&lt;First&gt; &amp;&amp; ... &amp;&amp; view&lt;Vs&gt;)
  class cartesian_product_view :
    public view_interface&lt;cartesian_product_view&lt;First, Vs...&gt;&gt; {
  private:
    tuple&lt;First, Vs...&gt; bases_;                 // exposition only
    // class template cartesian_product_view::iterator
    template&lt;bool Const&gt; class iterator;       // exposition only
  public:
    constexpr cartesian_product_view() = default;
    constexpr explicit cartesian_product_view(First first_base, Vs... bases);
 
    constexpr iterator&lt;false&gt; begin()
      requires (!__simple_view&lt;First&gt; || ... || !__simple_view&lt;Vs&gt;);
    constexpr iterator&lt;true&gt; begin() const
      requires (range&lt;const First&gt; &amp;&amp; ... &amp;&amp; range&lt;const Vs&gt;);
 
    constexpr iterator&lt;false&gt; end()
      requires ((!__simple_view&lt;First&gt; || ... || !__simple_view&lt;Vs&gt;) &amp;&amp;
        __cartesian_product_is_common&lt;First, Vs...&gt;);
    constexpr iterator&lt;true&gt; end() const
      requires __cartesian_product_is_common&lt;const First, const Vs...&gt;;
    constexpr default_sentinel_t end() const noexcept;
 
    constexpr /* see description */ size()
      requires __cartesian_product_is_sized&lt;First, Vs...&gt;;
    constexpr /* see description */ size() const
      requires __cartesian_product_is_sized&lt;const First, const Vs...&gt;;
  };
 
  template&lt;class... Vs&gt;
    cartesian_product_view(Vs&amp;&amp;...) -&gt; cartesian_product_view&lt;all_t&lt;Vs&gt;...&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::cartesian_product_view::iterator"> Class template <code>std::ranges::cartesian_product_view::iterator</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;input_range First, forward_range... Vs&gt;
    requires (view&lt;First&gt; &amp;&amp; ... &amp;&amp; view&lt;Vs&gt;)
  template&lt;bool Const&gt;
  class cartesian_product_view&lt;First, Vs...&gt;::iterator {
  public:
    using iterator_category = input_iterator_tag;
    using iterator_concept  = /* see description */;
    using value_type = tuple&lt;range_value_t&lt;__maybe_const&lt;Const, First&gt;&gt;,
      range_value_t&lt;__maybe_const&lt;Const, Vs&gt;&gt;...&gt;;
    using reference = tuple&lt;range_reference_t&lt;__maybe_const&lt;Const, First&gt;&gt;,
      range_reference_t&lt;__maybe_const&lt;Const, Vs&gt;&gt;...&gt;;
    using difference_type = /* see description */;
 
    iterator() requires forward_range&lt;__maybe_const&lt;Const, First&gt;&gt; = default;
 
    constexpr iterator(iterator&lt;!Const&gt; i) requires Const &amp;&amp;
      (convertible_to&lt;iterator_t&lt;First&gt;, iterator_t&lt;const First&gt;&gt; &amp;&amp;
        ... &amp;&amp; convertible_to&lt;iterator_t&lt;Vs&gt;, iterator_t&lt;const Vs&gt;&gt;);
 
    constexpr auto operator*() const;
    constexpr iterator&amp; operator++();
    constexpr void operator++(int);
    constexpr iterator operator++(int)
      requires forward_range&lt;__maybe_const&lt;Const, First&gt;&gt;;
 
    constexpr iterator&amp; operator--()
      requires __cartesian_product_is_bidirectional&lt;Const, First, Vs...&gt;;
    constexpr iterator operator--(int)
      requires __cartesian_product_is_bidirectional&lt;Const, First, Vs...&gt;;
 
    constexpr iterator&amp; operator+=(difference_type x)
      requires __cartesian_product_is_random_access&lt;Const, First, Vs...&gt;;
    constexpr iterator&amp; operator-=(difference_type x)
      requires __cartesian_product_is_random_access&lt;Const, First, Vs...&gt;;
 
    constexpr reference operator[](difference_type n) const
      requires __cartesian_product_is_random_access&lt;Const, First, Vs...&gt;;
 
    friend constexpr bool operator==(const iterator&amp; x, const iterator&amp; y)
      requires equality_comparable&lt;iterator_t&lt;__maybe_const&lt;Const, First&gt;&gt;&gt;;
 
    friend constexpr bool operator==(const iterator&amp; x, default_sentinel_t);
 
    friend constexpr auto operator&lt;=&gt;(const iterator&amp; x, const iterator&amp; y)
      requires __all_random_access&lt;Const, First, Vs...&gt;;
 
    friend constexpr iterator operator+(const iterator&amp; x, difference_type y)
      requires __cartesian_product_is_random_access&lt;Const, First, Vs...&gt;;
    friend constexpr iterator operator+(difference_type x, const iterator&amp; y)
      requires __cartesian_product_is_random_access&lt;Const, First, Vs...&gt;;
    friend constexpr iterator operator-(const iterator&amp; x, difference_type y)
      requires __cartesian_product_is_random_access&lt;Const, First, Vs...&gt;;
    friend constexpr difference_type operator-(const iterator&amp; x, const iterator&amp; y)
      requires __cartesian_is_sized_sentinel&lt;Const, iterator_t, First, Vs...&gt;;
 
    friend constexpr difference_type operator-(iterator i, default_sentinel_t)
      requires __cartesian_is_sized_sentinel&lt;Const, sentinel_t, First, Vs...&gt;;
    friend constexpr difference_type operator-(default_sentinel_t, iterator i)
      requires __cartesian_is_sized_sentinel&lt;Const, sentinel_t, First, Vs...&gt;;
 
    friend constexpr auto iter_move(const iterator&amp; i) noexcept(/* see description */);
 
    friend constexpr void iter_swap(const iterator&amp; l, const iterator&amp; r)
        noexcept(/* see description */)
      requires (indirectly_swappable&lt;iterator_t&lt;__maybe_const&lt;Const, First&gt;&gt;&gt; &amp;&amp; ... &amp;&amp;
        indirectly_swappable&lt;iterator_t&lt;__maybe_const&lt;Const, Vs&gt;&gt;&gt;);
 
  private:
    __maybe_const&lt;Const, cartesian_product_view&gt;* parent_ = nullptr;  // exposition only
    tuple&lt;iterator_t&lt;__maybe_const&lt;Const, First&gt;&gt;,
      iterator_t&lt;__maybe_const&lt;Const, Vs&gt;&gt;...&gt; current_;              // exposition only
 
    template&lt;size_t N = sizeof...(Vs)&gt;
      constexpr void next();                                          // exposition only
 
    template&lt;size_t N = sizeof...(Vs)&gt;
      constexpr void prev();                                          // exposition only
 
    template&lt;class Tuple&gt;
      constexpr difference_type __distance_from(Tuple t);             // exposition only
 
    constexpr explicit iterator(tuple&lt;iterator_t&lt;__maybe_const&lt;Const, First&gt;&gt;,
      iterator_t&lt;__maybe_const&lt;Const, Vs&gt;&gt;...&gt; current);              // exposition only
  };
}</pre></div>           <div class="_attribution">
  <p class="_attribution-p">
     cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/header/ranges" class="_attribution-link">https://en.cppreference.com/w/cpp/header/ranges</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
