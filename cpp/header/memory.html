
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Memory - C++ - W3cubDocs</title>
  
  <meta name="description" content=" This header is part of the dynamic memory management library. ">
  <meta name="keywords" content="standard, library, header, memory, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/header/memory.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-1810d67ab7e57be09d8247710d2feb6954566959eb82322d1fee3a0c9156f56974b78ebaa9928774f00767342bbe58b0799d91fcc336b92b319170b196f9b64b.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/cpp.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _c">
				
				
<h1 id="firstHeading" class="firstHeading">Standard library header &lt;memory&gt;</h1>            <p>This header is part of the <a href="../memory" title="cpp/memory">dynamic memory management</a> library.</p>
<table class="t-dsc-begin"> <tr> <td colspan="2">  <h3 id="Includes">  Includes</h3> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="compare" title="cpp/header/compare"> <span class="t-lines"><span>&lt;compare&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> <a href="../language/operator_comparison#Three-way_comparison" title="cpp/language/operator comparison">Three-way comparison operator</a> support  </td>
</tr> <tr> <td colspan="2"> <h3 id="Classes">  Classes</h3> </td>
</tr> <tr> <td colspan="2"> <h5 id="Pointer_traits">  Pointer traits </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/pointer_traits" title="cpp/memory/pointer traits"> <span class="t-lines"><span>pointer_traits</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> provides information about pointer-like types <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Garbage_collector_support">  Garbage collector support </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/gc/pointer_safety" title="cpp/memory/gc/pointer safety"> <span class="t-lines"><span>pointer_safety</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span><span class="t-mark-rev t-until-cxx23">(removed in C++23)</span></span></span></div> </td> <td> lists pointer safety models <br> <span class="t-mark">(enum)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Allocators">  Allocators </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/allocator" title="cpp/memory/allocator"> <span class="t-lines"><span>allocator</span></span></a></div> </td> <td> the default allocator <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/allocator_traits" title="cpp/memory/allocator traits"> <span class="t-lines"><span>allocator_traits</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> provides information about allocator types <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/allocation_result" title="cpp/memory/allocation result"> <span class="t-lines"><span>allocation_result</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> records the address and the actual size of storage allocated by <code>allocate_at_least</code> <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/allocator_arg_t" title="cpp/memory/allocator arg t" class="mw-redirect"> <span class="t-lines"><span>allocator_arg_t</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> tag type used to select allocator-aware constructor overloads <br> <span class="t-mark">(class)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/uses_allocator" title="cpp/memory/uses allocator"> <span class="t-lines"><span>uses_allocator</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> checks if the specified type supports uses-allocator construction <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Uninitialized_storage">  Uninitialized storage </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/raw_storage_iterator" title="cpp/memory/raw storage iterator"> <span class="t-lines"><span>raw_storage_iterator</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark">(deprecated in C++17)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span></span></div> </td> <td> an iterator that allows standard algorithms to store results in uninitialized memory <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Smart_pointers">  Smart pointers </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/unique_ptr" title="cpp/memory/unique ptr"> <span class="t-lines"><span>unique_ptr</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> smart pointer with unique object ownership semantics <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/shared_ptr" title="cpp/memory/shared ptr"> <span class="t-lines"><span>shared_ptr</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> smart pointer with shared object ownership semantics <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/weak_ptr" title="cpp/memory/weak ptr"> <span class="t-lines"><span>weak_ptr</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> weak reference to an object managed by <code><a href="../memory/shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code> <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/auto_ptr" title="cpp/memory/auto ptr"> <span class="t-lines"><span>auto_ptr</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark">(deprecated in C++11)</span></span><span><span class="t-mark-rev t-until-cxx17">(removed in C++17)</span></span></span></div> </td> <td> smart pointer with strict object ownership semantics <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Helper_classes">  Helper classes </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/shared_ptr/atomic2" title="cpp/memory/shared ptr/atomic2"> <span class="t-lines"><span>std::atomic<span class="t-dsc-small">&lt;std::shared_ptr&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> atomic shared pointer <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/weak_ptr/atomic2" title="cpp/memory/weak ptr/atomic2"> <span class="t-lines"><span>std::atomic<span class="t-dsc-small">&lt;std::weak_ptr&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> atomic weak pointer <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/owner_less" title="cpp/memory/owner less"> <span class="t-lines"><span>owner_less</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> provides mixed-type owner-based ordering of shared and weak pointers <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/enable_shared_from_this" title="cpp/memory/enable shared from this"> <span class="t-lines"><span>enable_shared_from_this</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> allows an object to create a <code>shared_ptr</code> referring to itself <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/bad_weak_ptr" title="cpp/memory/bad weak ptr"> <span class="t-lines"><span>bad_weak_ptr</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> exception thrown when accessing a <code>weak_ptr</code> which refers to already destroyed object <br> <span class="t-mark">(class)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/default_delete" title="cpp/memory/default delete"> <span class="t-lines"><span>default_delete</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> default deleter for <code><a href="../memory/unique_ptr" title="cpp/memory/unique ptr">unique_ptr</a></code> <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/unique_ptr/hash" title="cpp/memory/unique ptr/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::unique_ptr&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> hash support for <code><a href="../memory/unique_ptr" title="cpp/memory/unique ptr">std::unique_ptr</a></code> <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/shared_ptr/hash" title="cpp/memory/shared ptr/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::shared_ptr&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> hash support for <code><a href="../memory/shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code> <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Smart_pointer_adaptors">  Smart pointer adaptors </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/out_ptr_t" title="cpp/memory/out ptr t"> <span class="t-lines"><span>out_ptr_t</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> interoperates with foreign pointer setters and resets a smart pointer on destruction <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/inout_ptr_t" title="cpp/memory/inout ptr t"> <span class="t-lines"><span>inout_ptr_t</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> interoperates with foreign pointer setters, obtains the initial pointer value from a smart pointer, and resets it on destruction <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Forward_declarations">  Forward declarations </h5> </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in header <code><a href="functional" title="cpp/header/functional">&lt;functional&gt;</a></code>  </th>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/hash" title="cpp/utility/hash"> <span class="t-lines"><span>hash</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> hash function object <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in header <code><a href="atomic" title="cpp/header/atomic">&lt;atomic&gt;</a></code>  </th>
</tr> <tr class="t-dsc"> <td> <div><a href="../atomic/atomic" title="cpp/atomic/atomic"> <span class="t-lines"><span>atomic</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> atomic class template and specializations for bool, integral, and pointer types <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr> <td colspan="2"> <h3 id="Constants">  Constants</h3> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/allocator_arg" title="cpp/memory/allocator arg"> <span class="t-lines"><span>allocator_arg</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> an object of type <code><a href="../memory/allocator_arg_t" title="cpp/memory/allocator arg t" class="mw-redirect">std::allocator_arg_t</a></code> used to select allocator-aware constructors <br> <span class="t-mark">(constant)</span>  </td>
</tr> <tr> <td colspan="2"> <h3 id="Functions">  Functions</h3> </td>
</tr> <tr> <td colspan="2"> <h5 id="Allocators_2">  Allocators </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/allocate_at_least" title="cpp/memory/allocate at least"> <span class="t-lines"><span>allocate_at_least</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> allocates storage at least as large as the requested size via an allocator <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Miscellaneous">  Miscellaneous </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/to_address" title="cpp/memory/to address"> <span class="t-lines"><span>to_address</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> obtains a raw pointer from a pointer-like type <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/addressof" title="cpp/memory/addressof"> <span class="t-lines"><span>addressof</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> obtains actual address of an object, even if the <i>&amp;</i> operator is overloaded <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/align" title="cpp/memory/align"> <span class="t-lines"><span>align</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> aligns a pointer in a buffer <br> <span class="t-mark">(function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/assume_aligned" title="cpp/memory/assume aligned"> <span class="t-lines"><span>assume_aligned</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> informs the compiler that a pointer is aligned <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Garbage_collector_support_2">  Garbage collector support </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/gc/declare_reachable" title="cpp/memory/gc/declare reachable"> <span class="t-lines"><span>declare_reachable</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span><span class="t-mark-rev t-until-cxx23">(removed in C++23)</span></span></span></div> </td> <td> declares that an object can not be recycled <br> <span class="t-mark">(function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/gc/undeclare_reachable" title="cpp/memory/gc/undeclare reachable"> <span class="t-lines"><span>undeclare_reachable</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span><span class="t-mark-rev t-until-cxx23">(removed in C++23)</span></span></span></div> </td> <td> declares that an object can be recycled <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/gc/declare_no_pointers" title="cpp/memory/gc/declare no pointers"> <span class="t-lines"><span>declare_no_pointers</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span><span class="t-mark-rev t-until-cxx23">(removed in C++23)</span></span></span></div> </td> <td> declares that a memory area does not contain traceable pointers <br> <span class="t-mark">(function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/gc/undeclare_no_pointers" title="cpp/memory/gc/undeclare no pointers"> <span class="t-lines"><span>undeclare_no_pointers</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span><span class="t-mark-rev t-until-cxx23">(removed in C++23)</span></span></span></div> </td> <td> cancels the effect of <code><a href="../memory/gc/declare_no_pointers" title="cpp/memory/gc/declare no pointers">std::declare_no_pointers</a></code> <br> <span class="t-mark">(function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/gc/get_pointer_safety" title="cpp/memory/gc/get pointer safety"> <span class="t-lines"><span>get_pointer_safety</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span><span class="t-mark-rev t-until-cxx23">(removed in C++23)</span></span></span></div> </td> <td> returns the current pointer safety model <br> <span class="t-mark">(function)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Uninitialized_storage_2">  Uninitialized storage </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/uninitialized_copy" title="cpp/memory/uninitialized copy"> <span class="t-lines"><span>uninitialized_copy</span></span></a></div> </td> <td> copies a range of objects to an uninitialized area of memory <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/uninitialized_copy_n" title="cpp/memory/uninitialized copy n"> <span class="t-lines"><span>uninitialized_copy_n</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> copies a number of objects to an uninitialized area of memory <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/uninitialized_fill" title="cpp/memory/uninitialized fill"> <span class="t-lines"><span>uninitialized_fill</span></span></a></div> </td> <td> copies an object to an uninitialized area of memory, defined by a range <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/uninitialized_fill_n" title="cpp/memory/uninitialized fill n"> <span class="t-lines"><span>uninitialized_fill_n</span></span></a></div> </td> <td> copies an object to an uninitialized area of memory, defined by a start and a count <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/uninitialized_move" title="cpp/memory/uninitialized move"> <span class="t-lines"><span>uninitialized_move</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> moves a range of objects to an uninitialized area of memory <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/uninitialized_move_n" title="cpp/memory/uninitialized move n"> <span class="t-lines"><span>uninitialized_move_n</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> moves a number of objects to an uninitialized area of memory <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/uninitialized_default_construct" title="cpp/memory/uninitialized default construct"> <span class="t-lines"><span>uninitialized_default_construct</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> constructs objects by <a href="../language/default_initialization" title="cpp/language/default initialization">default-initialization</a> in an uninitialized area of memory, defined by a range <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/uninitialized_default_construct_n" title="cpp/memory/uninitialized default construct n"> <span class="t-lines"><span>uninitialized_default_construct_n</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> constructs objects by <a href="../language/default_initialization" title="cpp/language/default initialization">default-initialization</a> in an uninitialized area of memory, defined by a start and a count <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/uninitialized_value_construct" title="cpp/memory/uninitialized value construct"> <span class="t-lines"><span>uninitialized_value_construct</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> constructs objects by <a href="../language/value_initialization" title="cpp/language/value initialization">value-initialization</a> in an uninitialized area of memory, defined by a range <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/uninitialized_value_construct_n" title="cpp/memory/uninitialized value construct n"> <span class="t-lines"><span>uninitialized_value_construct_n</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> constructs objects by <a href="../language/value_initialization" title="cpp/language/value initialization">value-initialization</a> in an uninitialized area of memory, defined by a start and a count <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/construct_at" title="cpp/memory/construct at"> <span class="t-lines"><span>construct_at</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> creates an object at a given address <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/destroy_at" title="cpp/memory/destroy at"> <span class="t-lines"><span>destroy_at</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> destroys an object at a given address <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/destroy" title="cpp/memory/destroy"> <span class="t-lines"><span>destroy</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> destroys a range of objects <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/destroy_n" title="cpp/memory/destroy n"> <span class="t-lines"><span>destroy_n</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> destroys a number of objects in a range <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/get_temporary_buffer" title="cpp/memory/get temporary buffer"> <span class="t-lines"><span>get_temporary_buffer</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark">(deprecated in C++17)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span></span></div> </td> <td> obtains uninitialized storage <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/return_temporary_buffer" title="cpp/memory/return temporary buffer"> <span class="t-lines"><span>return_temporary_buffer</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark">(deprecated in C++17)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span></span></div> </td> <td> frees uninitialized storage <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Smart_pointer_non-member_operations">  Smart pointer non-member operations </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/unique_ptr/make_unique" title="cpp/memory/unique ptr/make unique"> <span class="t-lines"><span>make_unique</span><span>make_unique_for_overwrite</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx14">(C++14)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> creates a unique pointer that manages a new object <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/unique_ptr/operator_cmp" title="cpp/memory/unique ptr/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span><span>operator&lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> compares to another <code>unique_ptr</code> or with <code>nullptr</code> <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/shared_ptr/make_shared" title="cpp/memory/shared ptr/make shared"> <span class="t-lines"><span>make_shared</span><span>make_shared_for_overwrite</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> creates a shared pointer that manages a new object <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/shared_ptr/allocate_shared" title="cpp/memory/shared ptr/allocate shared"> <span class="t-lines"><span>allocate_shared</span><span>allocate_shared_for_overwrite</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> creates a shared pointer that manages a new object allocated using an allocator <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/shared_ptr/pointer_cast" title="cpp/memory/shared ptr/pointer cast"> <span class="t-lines"><span>static_pointer_cast</span><span>dynamic_pointer_cast</span><span>const_pointer_cast</span><span>reinterpret_pointer_cast</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> applies <a href="../language/static_cast" title="cpp/language/static cast"><code>static_cast</code></a>, <a href="../language/dynamic_cast" title="cpp/language/dynamic cast"><code>dynamic_cast</code></a>, <a href="../language/const_cast" title="cpp/language/const cast"><code>const_cast</code></a>, or <a href="../language/reinterpret_cast" title="cpp/language/reinterpret cast"><code>reinterpret_cast</code></a> to the stored pointer <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/shared_ptr/get_deleter" title="cpp/memory/shared ptr/get deleter"> <span class="t-lines"><span>get_deleter</span></span></a></div> </td> <td> returns the deleter of specified type, if owned <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/shared_ptr/operator_cmp" title="cpp/memory/shared ptr/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span><span>operator&lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> compares with another <code>shared_ptr</code> or with <code>nullptr</code> <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/shared_ptr/operator_ltlt" title="cpp/memory/shared ptr/operator ltlt"> <span class="t-lines"><span>operator&lt;&lt;</span></span></a></div> </td> <td> outputs the value of the stored pointer to an output stream <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/unique_ptr/swap2" title="cpp/memory/unique ptr/swap2"> <span class="t-lines"><span>std::swap<span class="t-dsc-small">(std::unique_ptr)</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> specializes the <code><a href="../algorithm/swap" title="cpp/algorithm/swap">std::swap</a></code> algorithm <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/shared_ptr/swap2" title="cpp/memory/shared ptr/swap2"> <span class="t-lines"><span>std::swap<span class="t-dsc-small">(std::shared_ptr)</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> specializes the <code><a href="../algorithm/swap" title="cpp/algorithm/swap">std::swap</a></code> algorithm <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/weak_ptr/swap2" title="cpp/memory/weak ptr/swap2"> <span class="t-lines"><span>std::swap<span class="t-dsc-small">(std::weak_ptr)</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> specializes the <code><a href="../algorithm/swap" title="cpp/algorithm/swap">std::swap</a></code> algorithm <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Smart_pointer_adaptor_creation">  Smart pointer adaptor creation </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/out_ptr_t/out_ptr" title="cpp/memory/out ptr t/out ptr"> <span class="t-lines"><span>out_ptr</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> creates an <code>out_ptr_t</code> with an associated smart pointer and resetting arguments <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/inout_ptr_t/inout_ptr" title="cpp/memory/inout ptr t/inout ptr"> <span class="t-lines"><span>inout_ptr</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> creates an <code>inout_ptr_t</code> with an associated smart pointer and resetting arguments <br> <span class="t-mark">(function template)</span>  </td>
</tr> </table> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../memory/shared_ptr/atomic" title="cpp/memory/shared ptr/atomic"> <span class="t-lines"><span>std::atomic_is_lock_free<span class="t-dsc-small">(std::shared_ptr)</span></span><span>std::atomic_load<span class="t-dsc-small">(std::shared_ptr)</span></span><span>std::atomic_load_explicit<span class="t-dsc-small">(std::shared_ptr)</span></span><span>std::atomic_store<span class="t-dsc-small">(std::shared_ptr)</span></span><span>std::atomic_store_explicit<span class="t-dsc-small">(std::shared_ptr)</span></span><span>std::atomic_exchange<span class="t-dsc-small">(std::shared_ptr)</span></span><span>std::atomic_exchange_explicit<span class="t-dsc-small">(std::shared_ptr)</span></span><span>std::atomic_compare_exchange_weak<span class="t-dsc-small">(std::shared_ptr)</span></span><span>std::atomic_compare_exchange_strong<span class="t-dsc-small">(std::shared_ptr)</span></span><span>std::atomic_compare_exchange_weak_explicit<span class="t-dsc-small">(std::shared_ptr)</span></span><span>std::atomic_compare_exchange_strong_explicit<span class="t-dsc-small">(std::shared_ptr)</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-deprecated-cxx20">(deprecated in C++20)</span></span></span></div> </td> <td> specializes atomic operations for <code><a href="../memory/shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code> <br> <span class="t-mark">(function template)</span>  </td>
</tr> </table> <table class="t-dsc-begin"> <tr> <td colspan="2"> <h3 id="Function-like_entities">  Function-like entities</h3> </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in namespace <code>std::ranges</code>  </th>
</tr> <tr> <td colspan="2"> <h5 id="Uninitialized_storage_3">  Uninitialized storage </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/ranges/uninitialized_copy" title="cpp/memory/ranges/uninitialized copy"> <span class="t-lines"><span>ranges::uninitialized_copy</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> copies a range of objects to an uninitialized area of memory <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/ranges/uninitialized_copy_n" title="cpp/memory/ranges/uninitialized copy n"> <span class="t-lines"><span>ranges::uninitialized_copy_n</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> copies a number of objects to an uninitialized area of memory <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/ranges/uninitialized_fill" title="cpp/memory/ranges/uninitialized fill"> <span class="t-lines"><span>ranges::uninitialized_fill</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> copies an object to an uninitialized area of memory, defined by a range <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/ranges/uninitialized_fill_n" title="cpp/memory/ranges/uninitialized fill n"> <span class="t-lines"><span>ranges::uninitialized_fill_n</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> copies an object to an uninitialized area of memory, defined by a start and a count <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/ranges/uninitialized_move" title="cpp/memory/ranges/uninitialized move"> <span class="t-lines"><span>ranges::uninitialized_move</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> moves a range of objects to an uninitialized area of memory <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/ranges/uninitialized_move_n" title="cpp/memory/ranges/uninitialized move n"> <span class="t-lines"><span>ranges::uninitialized_move_n</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> moves a number of objects to an uninitialized area of memory <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/ranges/uninitialized_default_construct" title="cpp/memory/ranges/uninitialized default construct"> <span class="t-lines"><span>ranges::uninitialized_default_construct</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> constructs objects by <a href="../language/default_initialization" title="cpp/language/default initialization">default-initialization</a> in an uninitialized area of memory, defined by a range <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/ranges/uninitialized_default_construct_n" title="cpp/memory/ranges/uninitialized default construct n"> <span class="t-lines"><span>ranges::uninitialized_default_construct_n</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> constructs objects by <a href="../language/default_initialization" title="cpp/language/default initialization">default-initialization</a> in an uninitialized area of memory, defined by a start and count <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/ranges/uninitialized_value_construct" title="cpp/memory/ranges/uninitialized value construct"> <span class="t-lines"><span>ranges::uninitialized_value_construct</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> constructs objects by <a href="../language/value_initialization" title="cpp/language/value initialization">value-initialization</a> in an uninitialized area of memory, defined by a range <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/ranges/uninitialized_value_construct_n" title="cpp/memory/ranges/uninitialized value construct n"> <span class="t-lines"><span>ranges::uninitialized_value_construct_n</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> constructs objects by <a href="../language/value_initialization" title="cpp/language/value initialization">value-initialization</a> in an uninitialized area of memory, defined by a start and a count <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/ranges/construct_at" title="cpp/memory/ranges/construct at"> <span class="t-lines"><span>ranges::construct_at</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> creates an object at a given address <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/ranges/destroy_at" title="cpp/memory/ranges/destroy at"> <span class="t-lines"><span>ranges::destroy_at</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> destroys an object at a given address <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/ranges/destroy" title="cpp/memory/ranges/destroy"> <span class="t-lines"><span>ranges::destroy</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> destroys a range of objects <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/ranges/destroy_n" title="cpp/memory/ranges/destroy n"> <span class="t-lines"><span>ranges::destroy_n</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> destroys a number of objects in a range <br> <span class="t-mark">(niebloid)</span>  </td>
</tr> </table> <h3 id="Synopsis"> Synopsis</h3> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;compare&gt;
 
namespace std {
  // pointer traits
  template&lt;class Ptr&gt; struct pointer_traits;
  template&lt;class T&gt; struct pointer_traits&lt;T*&gt;;
 
  // pointer conversion
  template&lt;class T&gt;
    constexpr T* to_address(T* p) noexcept;
  template&lt;class Ptr&gt;
    constexpr auto to_address(const Ptr&amp; p) noexcept;
 
  // pointer alignment
  void* align(size_t alignment, size_t size, void*&amp; ptr, size_t&amp; space);
  template&lt;size_t N, class T&gt;
    [[nodiscard]] constexpr T* assume_aligned(T* ptr);
 
  // allocator argument tag
  struct allocator_arg_t { explicit allocator_arg_t() = default; };
  inline constexpr allocator_arg_t allocator_arg{};
 
  // uses_allocator
  template&lt;class T, class Alloc&gt; struct uses_allocator;
 
  // uses_allocator
  template&lt;class T, class Alloc&gt;
    inline constexpr bool uses_allocator_v = uses_allocator&lt;T, Alloc&gt;::value;
 
  // uses-allocator construction
  template&lt;class T, class Alloc, class... Args&gt;
    constexpr auto uses_allocator_construction_args(const Alloc&amp; alloc,
                                                    Args&amp;&amp;... args) noexcept;
  template&lt;class T, class Alloc, class Tuple1, class Tuple2&gt;
    constexpr auto uses_allocator_construction_args(const Alloc&amp; alloc, piecewise_construct_t,
                                                    Tuple1&amp;&amp; x, Tuple2&amp;&amp; y) noexcept;
  template&lt;class T, class Alloc&gt;
    constexpr auto uses_allocator_construction_args(const Alloc&amp; alloc) noexcept;
  template&lt;class T, class Alloc, class U, class V&gt;
    constexpr auto uses_allocator_construction_args(const Alloc&amp; alloc,
                                                    U&amp;&amp; u, V&amp;&amp; v) noexcept;
  template&lt;class T, class Alloc, class U, class V&gt;
    constexpr auto uses_allocator_construction_args(const Alloc&amp; alloc,
                                                    const pair&lt;U, V&gt;&amp; pr) noexcept;
  template&lt;class T, class Alloc, class U, class V&gt;
    constexpr auto uses_allocator_construction_args(const Alloc&amp; alloc,
                                                    pair&lt;U, V&gt;&amp;&amp; pr) noexcept;
  template&lt;class T, class Alloc, class... Args&gt;
    constexpr T make_obj_using_allocator(const Alloc&amp; alloc, Args&amp;&amp;... args);
  template&lt;class T, class Alloc, class... Args&gt;
    constexpr T* uninitialized_construct_using_allocator(T* p, const Alloc&amp; alloc,
                                                         Args&amp;&amp;... args);
 
  // allocator traits
  template&lt;class Alloc&gt; struct allocator_traits;
 
  template&lt;class Pointer&gt;
  struct allocation_result {
    Pointer ptr;
    size_t count;
  };
 
  template&lt;class Allocator&gt;
    [[nodiscard]] constexpr allocation_result&lt;typename allocator_traits&lt;Allocator&gt;::pointer&gt;
      allocate_at_least(Allocator&amp; a, size_t n);
 
  // the default allocator
  template&lt;class T&gt; class allocator;
  template&lt;class T, class U&gt;
    constexpr bool operator==(const allocator&lt;T&gt;&amp;, const allocator&lt;U&gt;&amp;) noexcept;
 
  // addressof
  template&lt;class T&gt;
    constexpr T* addressof(T&amp; r) noexcept;
  template&lt;class T&gt;
    const T* addressof(const T&amp;&amp;) = delete;
 
  // specialized algorithms
  // special memory concepts
  template&lt;class I&gt;
    concept no-throw-input-iterator = /* see description */;    // exposition only
  template&lt;class I&gt;
    concept no-throw-forward-iterator = /* see description */;  // exposition only
  template&lt;class S, class I&gt;
    concept no-throw-sentinel-for = /* see description */;      // exposition only
  template&lt;class R&gt;
    concept no-throw-input-range = /* see description */;       // exposition only
  template&lt;class R&gt;
    concept no-throw-forward-range = /* see description */;     // exposition only
 
  template&lt;class NoThrowForwardIt&gt;
    void uninitialized_default_construct(NoThrowForwardIt first,
                                         NoThrowForwardIt last);
  template&lt;class ExecutionPolicy, class NoThrowForwardIt&gt;
    void uninitialized_default_construct(ExecutionPolicy&amp;&amp; exec,
                                         NoThrowForwardIt first,
                                         NoThrowForwardIt last);
  template&lt;class NoThrowForwardIt, class Size&gt;
    NoThrowForwardIt
      uninitialized_default_construct_n(NoThrowForwardIt first, Size n);
  template&lt;class ExecutionPolicy, class NoThrowForwardIt, class Size&gt;
    NoThrowForwardIt
      uninitialized_default_construct_n(ExecutionPolicy&amp;&amp; exec,
                                        NoThrowForwardIt first, Size n);
 
  namespace ranges {
    template&lt;no-throw-forward-iterator I, no-throw-sentinel-for&lt;I&gt; S&gt;
      requires default_initializable&lt;iter_value_t&lt;I&gt;&gt;
        I uninitialized_default_construct(I first, S last);
    template&lt;no-throw-forward-range R&gt;
      requires default_initializable&lt;range_value_t&lt;R&gt;&gt;
        borrowed_iterator_t&lt;R&gt; uninitialized_default_construct(R&amp;&amp; r);
 
    template&lt;no-throw-forward-iterator I&gt;
      requires default_initializable&lt;iter_value_t&lt;I&gt;&gt;
        I uninitialized_default_construct_n(I first, iter_difference_t&lt;I&gt; n);
  }
 
  template&lt;class NoThrowForwardIterator&gt;
    void uninitialized_value_construct(NoThrowForwardIterator first,
                                       NoThrowForwardIterator last);
  template&lt;class ExecutionPolicy, class NoThrowForwardIt&gt;
    void uninitialized_value_construct(ExecutionPolicy&amp;&amp; exec,
                                       NoThrowForwardIt first,
                                       NoThrowForwardIt last);
  template&lt;class NoThrowForwardIt, class Size&gt;
    NoThrowForwardIt
      uninitialized_value_construct_n(NoThrowForwardIt first, Size n);
  template&lt;class ExecutionPolicy, class NoThrowForwardIt, class Size&gt;
    NoThrowForwardIt
      uninitialized_value_construct_n(ExecutionPolicy&amp;&amp; exec,
                                      NoThrowForwardIt first, Size n);
 
  namespace ranges {
    template&lt;no-throw-forward-iterator I, no-throw-sentinel-for&lt;I&gt; S&gt;
      requires default_initializable&lt;iter_value_t&lt;I&gt;&gt;
        I uninitialized_value_construct(I first, S last);
    template&lt;no-throw-forward-range R&gt;
      requires default_initializable&lt;range_value_t&lt;R&gt;&gt;
        borrowed_iterator_t&lt;R&gt; uninitialized_value_construct(R&amp;&amp; r);
 
    template&lt;no-throw-forward-iterator I&gt;
      requires default_initializable&lt;iter_value_t&lt;I&gt;&gt;
        I uninitialized_value_construct_n(I first, iter_difference_t&lt;I&gt; n);
  }
 
  template&lt;class InputIt, class NoThrowForwardIt&gt;
    NoThrowForwardIt uninitialized_copy(InputIt first, InputIt last,
                                        NoThrowForwardIt result);
  template&lt;class ExecutionPolicy, class ForwardIt, class NoThrowForwardIt&gt;
    NoThrowForwardIt uninitialized_copy(ExecutionPolicy&amp;&amp; exec,
                                        ForwardIt first, ForwardIt last,
                                        NoThrowForwardIt result);
  template&lt;class InputIt, class Size, class NoThrowForwardIt&gt;
    NoThrowForwardIt uninitialized_copy_n(InputIt first, Size n,
                                          NoThrowForwardIt result);
  template&lt;class ExecutionPolicy, class ForwardIt, class Size,
           class NoThrowForwardIt&gt;
    NoThrowForwardIt uninitialized_copy_n(ExecutionPolicy&amp;&amp; exec,
                                          ForwardIt first, Size n,
                                          NoThrowForwardIt result);
 
  namespace ranges {
    template&lt;class I, class O&gt;
      using uninitialized_copy_result = in_out_result&lt;I, O&gt;;
    template&lt;input_iterator I, sentinel_for&lt;I&gt; S1,
             no-throw-forward-iterator O, no-throw-sentinel-for&lt;O&gt; S2&gt;
      requires constructible_from&lt;iter_value_t&lt;O&gt;, iter_reference_t&lt;I&gt;&gt;
        uninitialized_copy_result&lt;I, O&gt;
          uninitialized_copy(I ifirst, S1 ilast, O ofirst, S2 olast);
    template&lt;input_range IR, no-throw-forward-range OR&gt;
      requires constructible_from&lt;range_value_t&lt;OR&gt;, range_reference_t&lt;IR&gt;&gt;
        uninitialized_copy_result&lt;borrowed_iterator_t&lt;IR&gt;, borrowed_iterator_t&lt;OR&gt;&gt;
          uninitialized_copy(IR&amp;&amp; in_range, OR&amp;&amp; out_range);
 
    template&lt;class I, class O&gt;
      using uninitialized_copy_n_result = in_out_result&lt;I, O&gt;;
    template&lt;input_iterator I, no-throw-forward-iterator O, no-throw-sentinel-for&lt;O&gt; S&gt;
      requires constructible_from&lt;iter_value_t&lt;O&gt;, iter_reference_t&lt;I&gt;&gt;
        uninitialized_copy_n_result&lt;I, O&gt;
          uninitialized_copy_n(I ifirst, iter_difference_t&lt;I&gt; n, O ofirst, S olast);
  }
 
  template&lt;class InputIt, class NoThrowForwardIt&gt;
    NoThrowForwardIt uninitialized_move(InputIt first, InputIt last,
                                        NoThrowForwardIt result);
  template&lt;class ExecutionPolicy, class ForwardIt, class NoThrowForwardIt&gt;
    NoThrowForwardIt uninitialized_move(ExecutionPolicy&amp;&amp; exec,
                                        ForwardIt first, ForwardIt last,
                                        NoThrowForwardIt result);
  template&lt;class InputIt, class Size, class NoThrowForwardIt&gt;
    pair&lt;InputIt, NoThrowForwardIt&gt;
      uninitialized_move_n(InputIt first, Size n, NoThrowForwardIt result);
  template&lt;class ExecutionPolicy, class ForwardIt, class Size,
           class NoThrowForwardIt&gt;
    pair&lt;ForwardIt, NoThrowForwardIt&gt;
      uninitialized_move_n(ExecutionPolicy&amp;&amp; exec,
                           ForwardIt first, Size n, NoThrowForwardIt result);
 
  namespace ranges {
    template&lt;class I, class O&gt;
      using uninitialized_move_result = in_out_result&lt;I, O&gt;;
    template&lt;input_iterator I, sentinel_for&lt;I&gt; S1,
             no-throw-forward-iterator O, no-throw-sentinel-for&lt;O&gt; S2&gt;
      requires constructible_from&lt;iter_value_t&lt;O&gt;, iter_rvalue_reference_t&lt;I&gt;&gt;
        uninitialized_move_result&lt;I, O&gt;
          uninitialized_move(I ifirst, S1 ilast, O ofirst, S2 olast);
    template&lt;input_range IR, no-throw-forward-range OR&gt;
      requires constructible_from&lt;range_value_t&lt;OR&gt;, range_rvalue_reference_t&lt;IR&gt;&gt;
        uninitialized_move_result&lt;borrowed_iterator_t&lt;IR&gt;, borrowed_iterator_t&lt;OR&gt;&gt;
          uninitialized_move(IR&amp;&amp; in_range, OR&amp;&amp; out_range);
 
    template&lt;class I, class O&gt;
      using uninitialized_move_n_result = in_out_result&lt;I, O&gt;;
    template&lt;input_iterator I,
             no-throw-forward-iterator O, no-throw-sentinel-for&lt;O&gt; S&gt;
      requires constructible_from&lt;iter_value_t&lt;O&gt;, iter_rvalue_reference_t&lt;I&gt;&gt;
        uninitialized_move_n_result&lt;I, O&gt;
          uninitialized_move_n(I ifirst, iter_difference_t&lt;I&gt; n, O ofirst, S olast);
  }
 
  template&lt;class NoThrowForwardIt, class T&gt;
    void uninitialized_fill(NoThrowForwardIt first, NoThrowForwardIt last,
                            const T&amp; x);
  template&lt;class ExecutionPolicy, class NoThrowForwardIt, class T&gt;
    void uninitialized_fill(ExecutionPolicy&amp;&amp; exec,
                            NoThrowForwardIt first, NoThrowForwardIt last,
                            const T&amp; x);
  template&lt;class NoThrowForwardIt, class Size, class T&gt;
    NoThrowForwardIt
      uninitialized_fill_n(NoThrowForwardIt first, Size n, const T&amp; x);
  template&lt;class ExecutionPolicy, class NoThrowForwardIt, class Size, class T&gt;
    NoThrowForwardIt
      uninitialized_fill_n(ExecutionPolicy&amp;&amp; exec,
                           NoThrowForwardIt first, Size n, const T&amp; x);
 
  namespace ranges {
    template&lt;no-throw-forward-iterator I, no-throw-sentinel-for&lt;I&gt; S, class T&gt;
      requires constructible_from&lt;iter_value_t&lt;I&gt;, const T&amp;&gt;
        I uninitialized_fill(I first, S last, const T&amp; x);
    template&lt;no-throw-forward-range R, class T&gt;
      requires constructible_from&lt;range_value_t&lt;R&gt;, const T&amp;&gt;
        borrowed_iterator_t&lt;R&gt; uninitialized_fill(R&amp;&amp; r, const T&amp; x);
 
    template&lt;no-throw-forward-iterator I, class T&gt;
      requires constructible_from&lt;iter_value_t&lt;I&gt;, const T&amp;&gt;
        I uninitialized_fill_n(I first, iter_difference_t&lt;I&gt; n, const T&amp; x);
  }
 
  // construct_at
  template&lt;class T, class... Args&gt;
    constexpr T* construct_at(T* location, Args&amp;&amp;... args);
 
  namespace ranges {
    template&lt;class T, class... Args&gt;
      constexpr T* construct_at(T* location, Args&amp;&amp;... args);
  }
 
  // destroy
  template&lt;class T&gt;
    constexpr void destroy_at(T* location);
  template&lt;class NoThrowForwardIt&gt;
    constexpr void destroy(NoThrowForwardIt first, NoThrowForwardIt last);
  template&lt;class ExecutionPolicy, class NoThrowForwardIt&gt;
    void destroy(ExecutionPolicy&amp;&amp; exec,
                 NoThrowForwardIt first, NoThrowForwardIt last);
  template&lt;class NoThrowForwardIt, class Size&gt;
    constexpr NoThrowForwardIt destroy_n(NoThrowForwardIt first, Size n);
  template&lt;class ExecutionPolicy, class NoThrowForwardIt, class Size&gt;
    NoThrowForwardIt destroy_n(ExecutionPolicy&amp;&amp; exec,
                               NoThrowForwardIt first, Size n);
 
  namespace ranges {
    template&lt;destructible T&gt;
      constexpr void destroy_at(T* location) noexcept;
 
    template&lt;no-throw-input-iterator I, no-throw-sentinel-for&lt;I&gt; S&gt;
      requires destructible&lt;iter_value_t&lt;I&gt;&gt;
        constexpr I destroy(I first, S last) noexcept;
    template&lt;no-throw-input-range R&gt;
      requires destructible&lt;range_value_t&lt;R&gt;&gt;
        constexpr borrowed_iterator_t&lt;R&gt; destroy(R&amp;&amp; r) noexcept;
 
    template&lt;no-throw-input-iterator I&gt;
      requires destructible&lt;iter_value_t&lt;I&gt;&gt;
        constexpr I destroy_n(I first, iter_difference_t&lt;I&gt; n) noexcept;
  }
 
  // class template unique_ptr
  template&lt;class T&gt; struct default_delete;
  template&lt;class T&gt; struct default_delete&lt;T[]&gt;;
  template&lt;class T, class D = default_delete&lt;T&gt;&gt; class unique_ptr;
  template&lt;class T, class D&gt; class unique_ptr&lt;T[], D&gt;;
 
  template&lt;class T, class... Args&gt;
    unique_ptr&lt;T&gt; make_unique(Args&amp;&amp;... args);                                  // T is not array
  template&lt;class T&gt;
    unique_ptr&lt;T&gt; make_unique(size_t n);                                        // T is U[]
  template&lt;class T, class... Args&gt;
    /* unspecified */ make_unique(Args&amp;&amp;...) = delete;                          // T is U[N]
 
  template&lt;class T&gt;
    unique_ptr&lt;T&gt; make_unique_for_overwrite();                                  // T is not array
  template&lt;class T&gt;
    unique_ptr&lt;T&gt; make_unique_for_overwrite(size_t n);                          // T is U[]
  template&lt;class T, class... Args&gt;
    /* unspecified */ make_unique_for_overwrite(Args&amp;&amp;...) = delete;            // T is U[N]
 
  template&lt;class T, class D&gt;
    void swap(unique_ptr&lt;T, D&gt;&amp; x, unique_ptr&lt;T, D&gt;&amp; y) noexcept;
 
  template&lt;class T1, class D1, class T2, class D2&gt;
    bool operator==(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
  template&lt;class T1, class D1, class T2, class D2&gt;
    bool operator&lt;(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
  template&lt;class T1, class D1, class T2, class D2&gt;
    bool operator&gt;(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
  template&lt;class T1, class D1, class T2, class D2&gt;
    bool operator&lt;=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
  template&lt;class T1, class D1, class T2, class D2&gt;
    bool operator&gt;=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
  template&lt;class T1, class D1, class T2, class D2&gt;
    requires three_way_comparable_with&lt;typename unique_ptr&lt;T1, D1&gt;::pointer,
                                       typename unique_ptr&lt;T2, D2&gt;::pointer&gt;
    compare_three_way_result_t&lt;typename unique_ptr&lt;T1, D1&gt;::pointer,
                               typename unique_ptr&lt;T2, D2&gt;::pointer&gt;
      operator&lt;=&gt;(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
 
  template&lt;class T, class D&gt;
    bool operator==(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t) noexcept;
  template&lt;class T, class D&gt;
    bool operator&lt;(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);
  template&lt;class T, class D&gt;
    bool operator&lt;(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y);
  template&lt;class T, class D&gt;
    bool operator&gt;(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);
  template&lt;class T, class D&gt;
    bool operator&gt;(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y);
  template&lt;class T, class D&gt;
    bool operator&lt;=(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);
  template&lt;class T, class D&gt;
    bool operator&lt;=(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y);
  template&lt;class T, class D&gt;
    bool operator&gt;=(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);
  template&lt;class T, class D&gt;
    bool operator&gt;=(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y);
  template&lt;class T, class D&gt;
    requires three_way_comparable&lt;typename unique_ptr&lt;T, D&gt;::pointer&gt;
    compare_three_way_result_t&lt;typename unique_ptr&lt;T, D&gt;::pointer&gt;
      operator&lt;=&gt;(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);
 
  template&lt;class E, class T, class Y, class D&gt;
    basic_ostream&lt;E, T&gt;&amp; operator&lt;&lt;(basic_ostream&lt;E, T&gt;&amp; os, const unique_ptr&lt;Y, D&gt;&amp; p);
 
  // class bad_weak_ptr
  class bad_weak_ptr;
 
  // class template shared_ptr
  template&lt;class T&gt; class shared_ptr;
 
  // shared_ptr creation
  template&lt;class T, class... Args&gt;
    shared_ptr&lt;T&gt; make_shared(Args&amp;&amp;... args);                                  // T is not array
  template&lt;class T, class A, class... Args&gt;
    shared_ptr&lt;T&gt; allocate_shared(const A&amp; a, Args&amp;&amp;... args);                  // T is not array
 
  template&lt;class T&gt;
    shared_ptr&lt;T&gt; make_shared(size_t N);                                        // T is U[]
  template&lt;class T, class A&gt;
    shared_ptr&lt;T&gt; allocate_shared(const A&amp; a, size_t N);                        // T is U[]
 
  template&lt;class T&gt;
    shared_ptr&lt;T&gt; make_shared();                                                // T is U[N]
  template&lt;class T, class A&gt;
    shared_ptr&lt;T&gt; allocate_shared(const A&amp; a);                                  // T is U[N]
 
  template&lt;class T&gt;
    shared_ptr&lt;T&gt; make_shared(size_t N, const remove_extent_t&lt;T&gt;&amp; u);           // T is U[]
  template&lt;class T, class A&gt;
    shared_ptr&lt;T&gt; allocate_shared(const A&amp; a, size_t N,
                                  const remove_extent_t&lt;T&gt;&amp; u);                 // T is U[]
 
  template&lt;class T&gt;
    shared_ptr&lt;T&gt; make_shared(const remove_extent_t&lt;T&gt;&amp; u);                     // T is U[N]
  template&lt;class T, class A&gt;
    shared_ptr&lt;T&gt; allocate_shared(const A&amp; a, const remove_extent_t&lt;T&gt;&amp; u);     // T is U[N]
 
  template&lt;class T&gt;
    shared_ptr&lt;T&gt; make_shared_for_overwrite();                                  // T is not U[]
  template&lt;class T, class A&gt;
    shared_ptr&lt;T&gt; allocate_shared_for_overwrite(const A&amp; a);                    // T is not U[]
 
  template&lt;class T&gt;
    shared_ptr&lt;T&gt; make_shared_for_overwrite(size_t N);                          // T is U[]
  template&lt;class T, class A&gt;
    shared_ptr&lt;T&gt; allocate_shared_for_overwrite(const A&amp; a, size_t N);          // T is U[]
 
  // shared_ptr comparisons
  template&lt;class T, class U&gt;
    bool operator==(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
  template&lt;class T, class U&gt;
    strong_ordering operator&lt;=&gt;(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
 
  template&lt;class T&gt;
    bool operator==(const shared_ptr&lt;T&gt;&amp; x, nullptr_t) noexcept;
  template&lt;class T&gt;
    strong_ordering operator&lt;=&gt;(const shared_ptr&lt;T&gt;&amp; x, nullptr_t) noexcept;
 
  // shared_ptr specialized algorithms
  template&lt;class T&gt;
    void swap(shared_ptr&lt;T&gt;&amp; a, shared_ptr&lt;T&gt;&amp; b) noexcept;
 
  // shared_ptr casts
  template&lt;class T, class U&gt;
    shared_ptr&lt;T&gt; static_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;
  template&lt;class T, class U&gt;
    shared_ptr&lt;T&gt; static_pointer_cast(shared_ptr&lt;U&gt;&amp;&amp; r) noexcept;
  template&lt;class T, class U&gt;
    shared_ptr&lt;T&gt; dynamic_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;
  template&lt;class T, class U&gt;
    shared_ptr&lt;T&gt; dynamic_pointer_cast(shared_ptr&lt;U&gt;&amp;&amp; r) noexcept;
  template&lt;class T, class U&gt;
    shared_ptr&lt;T&gt; const_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;
  template&lt;class T, class U&gt;
    shared_ptr&lt;T&gt; const_pointer_cast(shared_ptr&lt;U&gt;&amp;&amp; r) noexcept;
  template&lt;class T, class U&gt;
    shared_ptr&lt;T&gt; reinterpret_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;
  template&lt;class T, class U&gt;
    shared_ptr&lt;T&gt; reinterpret_pointer_cast(shared_ptr&lt;U&gt;&amp;&amp; r) noexcept;
 
  // shared_ptr get_deleter
  template&lt;class D, class T&gt;
    D* get_deleter(const shared_ptr&lt;T&gt;&amp; p) noexcept;
 
  // shared_ptr I/O
  template&lt;class E, class T, class Y&gt;
    basic_ostream&lt;E, T&gt;&amp; operator&lt;&lt;(basic_ostream&lt;E, T&gt;&amp; os, const shared_ptr&lt;Y&gt;&amp; p);
 
  // class template weak_ptr
  template&lt;class T&gt; class weak_ptr;
 
  // weak_ptr specialized algorithms
  template&lt;class T&gt; void swap(weak_ptr&lt;T&gt;&amp; a, weak_ptr&lt;T&gt;&amp; b) noexcept;
 
  // class template owner_less
  template&lt;class T = void&gt; struct owner_less;
 
  // class template enable_shared_from_this
  template&lt;class T&gt; class enable_shared_from_this;
 
  // hash support
  template&lt;class T&gt; struct hash;
  template&lt;class T, class D&gt; struct hash&lt;unique_ptr&lt;T, D&gt;&gt;;
  template&lt;class T&gt; struct hash&lt;shared_ptr&lt;T&gt;&gt;;
 
  // atomic smart pointers
  template&lt;class T&gt; struct atomic;
  template&lt;class T&gt; struct atomic&lt;shared_ptr&lt;T&gt;&gt;;
  template&lt;class T&gt; struct atomic&lt;weak_ptr&lt;T&gt;&gt;;
 
  // class template out_ptr_t
  template&lt;class Smart, class Pointer, class... Args&gt;
    class out_ptr_t;
 
  // function template out_ptr
  template&lt;class Pointer = void, class Smart, class... Args&gt;
    auto out_ptr(Smart&amp; s, Args&amp;&amp;... args);
 
  // class template inout_ptr_t
  template&lt;class Smart, class Pointer, class... Args&gt;
    class inout_ptr_t;
 
  // function template inout_ptr
  template&lt;class Pointer = void, class Smart, class... Args&gt;
    auto inout_ptr(Smart&amp; s, Args&amp;&amp;... args);
}
 
// deprecated
namespace std {
  template&lt;class T&gt;
    bool atomic_is_lock_free(const shared_ptr&lt;T&gt;* p);
 
  template&lt;class T&gt;
    shared_ptr&lt;T&gt; atomic_load(const shared_ptr&lt;T&gt;* p);
  template&lt;class T&gt;
    shared_ptr&lt;T&gt; atomic_load_explicit(const shared_ptr&lt;T&gt;* p, memory_order mo);
 
  template&lt;class T&gt;
    void atomic_store(shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt; r);
  template&lt;class T&gt;
    void atomic_store_explicit(shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt; r, memory_order mo);
 
  template&lt;class T&gt;
    shared_ptr&lt;T&gt; atomic_exchange(shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt; r);
  template&lt;class T&gt;
    shared_ptr&lt;T&gt; atomic_exchange_explicit(shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt; r, memory_order mo);
 
  template&lt;class T&gt;
    bool atomic_compare_exchange_weak(shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt;* v, shared_ptr&lt;T&gt; w);
  template&lt;class T&gt;
    bool atomic_compare_exchange_strong(shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt;* v, shared_ptr&lt;T&gt; w);
  template&lt;class T&gt;
    bool atomic_compare_exchange_weak_explicit(
      shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt;* v, shared_ptr&lt;T&gt; w,
      memory_order success, memory_order failure);
  template&lt;class T&gt;
    bool atomic_compare_exchange_strong_explicit(
      shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt;* v, shared_ptr&lt;T&gt; w,
      memory_order success, memory_order failure);
}</pre></div> <h4 id="Helper_concepts"> Helper concepts</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class I&gt;
concept no-throw-input-iterator = // exposition only
  input_iterator&lt;I&gt; &amp;&amp;
  is_lvalue_reference_v&lt;iter_reference_t&lt;I&gt;&gt; &amp;&amp;
  same_as&lt;remove_cvref_t&lt;iter_reference_t&lt;I&gt;&gt;, iter_value_t&lt;I&gt;&gt;;
 
template&lt;class S, class I&gt;
concept no-throw-sentinel-for = sentinel_for&lt;S, I&gt;; // exposition only
 
template&lt;class R&gt;
concept no-throw-input-range = // exposition only
  ranges::range&lt;R&gt; &amp;&amp;
  no-throw-input-iterator&lt;ranges::iterator_t&lt;R&gt;&gt; &amp;&amp;
  no-throw-sentinel-for&lt;ranges::sentinel_t&lt;R&gt;, ranges::iterator_t&lt;R&gt;&gt;;
 
template&lt;class I&gt;
concept no-throw-forward-iterator = // exposition only
  no-throw-input-iterator&lt;I&gt; &amp;&amp;
  forward_iterator&lt;I&gt; &amp;&amp;
  no-throw-sentinel-for&lt;I, I&gt;;
 
template&lt;class R&gt;
concept no-throw-forward-range = // exposition only
  no-throw-input-range&lt;R&gt; &amp;&amp;
  no-throw-forward-iterator&lt;ranges::iterator_t&lt;R&gt;&gt;;</pre></div> <p>Note: <a href="../memory/ranges/nothrow_concepts" title="cpp/memory/ranges/nothrow concepts">These names</a> are only for exposition, they are not part of the interface.</p>
<h4 id="Class_template_std::pointer_traits"> Class template <code><a href="../memory/pointer_traits" title="cpp/memory/pointer traits">std::pointer_traits</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class Ptr&gt; struct pointer_traits {
    using pointer         = Ptr;
    using element_type    = /* see description */;
    using difference_type = /* see description */;
 
    template&lt;class U&gt; using rebind = /* see description */;
 
    static pointer pointer_to(/* see description */ r);
  };
 
  template&lt;class T&gt; struct pointer_traits&lt;T*&gt; {
    using pointer         = T*;
    using element_type    = T;
    using difference_type = ptrdiff_t;
 
    template&lt;class U&gt; using rebind = U*;
 
    static constexpr pointer pointer_to(/* see description */ r) noexcept;
  };
}</pre></div> <h4 id="Class_std::allocator_arg_t"> Class <code><a href="../memory/allocator_arg_t" title="cpp/memory/allocator arg t" class="mw-redirect">std::allocator_arg_t</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  struct allocator_arg_t { explicit allocator_arg_t() = default; };
  inline constexpr allocator_arg_t allocator_arg{};
}</pre></div> <h4 id="Class_template_std::allocator_traits"> Class template <code><a href="../memory/allocator_traits" title="cpp/memory/allocator traits">std::allocator_traits</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class Alloc&gt; struct allocator_traits {
    using allocator_type     = Alloc;
 
    using value_type         = typename Alloc::value_type;
 
    using pointer            = /* see description */;
    using const_pointer      = /* see description */;
    using void_pointer       = /* see description */;
    using const_void_pointer = /* see description */;
 
    using difference_type    = /* see description */;
    using size_type          = /* see description */;
 
    using propagate_on_container_copy_assignment = /* see description */;
    using propagate_on_container_move_assignment = /* see description */;
    using propagate_on_container_swap            = /* see description */;
    using is_always_equal                        = /* see description */;
 
    template&lt;class T&gt; using rebind_alloc = /* see description */;
    template&lt;class T&gt; using rebind_traits = allocator_traits&lt;rebind_alloc&lt;T&gt;&gt;;
 
    [[nodiscard]] static pointer allocate(Alloc&amp; a, size_type n);
    [[nodiscard]] static pointer allocate(Alloc&amp; a, size_type n,
                                          const_void_pointer hint);
 
    static void deallocate(Alloc&amp; a, pointer p, size_type n);
 
    template&lt;class T, class... Args&gt;
      static void construct(Alloc&amp; a, T* p, Args&amp;&amp;... args);
 
    template&lt;class T&gt;
      static void destroy(Alloc&amp; a, T* p);
 
    static size_type max_size(const Alloc&amp; a) noexcept;
 
    static Alloc select_on_container_copy_construction(const Alloc&amp; rhs);
  };
}</pre></div> <h4 id="Class_template_std::allocator"> Class template <code><a href="../memory/allocator" title="cpp/memory/allocator">std::allocator</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class T&gt; class allocator {
   public:
    using value_type                             = T;
    using size_type                              = size_t;
    using difference_type                        = ptrdiff_t;
    using propagate_on_container_move_assignment = true_type;
 
    constexpr allocator() noexcept;
    constexpr allocator(const allocator&amp;) noexcept;
    template&lt;class U&gt; constexpr allocator(const allocator&lt;U&gt;&amp;) noexcept;
    constexpr ~allocator();
    constexpr allocator&amp; operator=(const allocator&amp;) = default;
 
    [[nodiscard]] constexpr T* allocate(size_t n);
    [[nodiscard]] constexpr allocation_result&lt;T*&gt; allocate_at_least(size_t n);
    constexpr void deallocate(T* p, size_t n);
 
    // deprecated
    using is_always_equal = true_type;
  };
}</pre></div> <h4 id="Class_template_std::default_delete"> Class template <code><a href="../memory/default_delete" title="cpp/memory/default delete">std::default_delete</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class T&gt; struct default_delete {
    constexpr default_delete() noexcept = default;
    template&lt;class U&gt; default_delete(const default_delete&lt;U&gt;&amp;) noexcept;
    void operator()(T*) const;
  };
 
  template&lt;class T&gt; struct default_delete&lt;T[]&gt; {
    constexpr default_delete() noexcept = default;
    template&lt;class U&gt; default_delete(const default_delete&lt;U[]&gt;&amp;) noexcept;
    template&lt;class U&gt; void operator()(U* ptr) const;
  };
}</pre></div> <h4 id="Class_template_std::unique_ptr"> Class template <code><a href="../memory/unique_ptr" title="cpp/memory/unique ptr">std::unique_ptr</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class T, class D = default_delete&lt;T&gt;&gt; class unique_ptr {
  public:
    using pointer      = /* see description */;
    using element_type = T;
    using deleter_type = D;
 
    // constructors
    constexpr unique_ptr() noexcept;
    explicit unique_ptr(pointer p) noexcept;
    unique_ptr(pointer p, /* see description */ d1) noexcept;
    unique_ptr(pointer p, /* see description */ d2) noexcept;
    unique_ptr(unique_ptr&amp;&amp; u) noexcept;
    constexpr unique_ptr(nullptr_t) noexcept;
    template&lt;class U, class E&gt;
      unique_ptr(unique_ptr&lt;U, E&gt;&amp;&amp; u) noexcept;
 
    // destructor
    ~unique_ptr();
 
    // assignment
    unique_ptr&amp; operator=(unique_ptr&amp;&amp; u) noexcept;
    template&lt;class U, class E&gt;
      unique_ptr&amp; operator=(unique_ptr&lt;U, E&gt;&amp;&amp; u) noexcept;
    unique_ptr&amp; operator=(nullptr_t) noexcept;
 
    // observers
    add_lvalue_reference_t&lt;T&gt; operator*() const noexcept(/* see description */);
    pointer operator-&gt;() const noexcept;
    pointer get() const noexcept;
    deleter_type&amp; get_deleter() noexcept;
    const deleter_type&amp; get_deleter() const noexcept;
    explicit operator bool() const noexcept;
 
    // modifiers
    pointer release() noexcept;
    void reset(pointer p = pointer()) noexcept;
    void swap(unique_ptr&amp; u) noexcept;
 
    // disable copy from lvalue
    unique_ptr(const unique_ptr&amp;) = delete;
    unique_ptr&amp; operator=(const unique_ptr&amp;) = delete;
  };
 
  template&lt;class T, class D&gt; class unique_ptr&lt;T[], D&gt; {
  public:
    using pointer      = /* see description */;
    using element_type = T;
    using deleter_type = D;
 
    // constructors
    constexpr unique_ptr() noexcept;
    template&lt;class U&gt; explicit unique_ptr(U p) noexcept;
    template&lt;class U&gt; unique_ptr(U p, /* see description */ d) noexcept;
    template&lt;class U&gt; unique_ptr(U p, /* see description */ d) noexcept;
    unique_ptr(unique_ptr&amp;&amp; u) noexcept;
    template&lt;class U, class E&gt;
      unique_ptr(unique_ptr&lt;U, E&gt;&amp;&amp; u) noexcept;
    constexpr unique_ptr(nullptr_t) noexcept;
 
    // destructor
    ~unique_ptr();
 
    // assignment
    unique_ptr&amp; operator=(unique_ptr&amp;&amp; u) noexcept;
    template&lt;class U, class E&gt;
      unique_ptr&amp; operator=(unique_ptr&lt;U, E&gt;&amp;&amp; u) noexcept;
    unique_ptr&amp; operator=(nullptr_t) noexcept;
 
    // observers
    T&amp; operator[](size_t i) const;
    pointer get() const noexcept;
    deleter_type&amp; get_deleter() noexcept;
    const deleter_type&amp; get_deleter() const noexcept;
    explicit operator bool() const noexcept;
 
    // modifiers
    pointer release() noexcept;
    template&lt;class U&gt; void reset(U p) noexcept;
    void reset(nullptr_t = nullptr) noexcept;
    void swap(unique_ptr&amp; u) noexcept;
 
    // disable copy from lvalue
    unique_ptr(const unique_ptr&amp;) = delete;
    unique_ptr&amp; operator=(const unique_ptr&amp;) = delete;
  };
}</pre></div> <h4 id="Class_std::bad_weak_ptr"> Class <code><a href="../memory/bad_weak_ptr" title="cpp/memory/bad weak ptr">std::bad_weak_ptr</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  class bad_weak_ptr : public exception {
  public:
    bad_weak_ptr() noexcept;
  };
}</pre></div> <h4 id="Class_template_std::shared_ptr"> Class template <code><a href="../memory/shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class T&gt; class shared_ptr {
  public:
    using element_type = remove_extent_t&lt;T&gt;;
    using weak_type    = weak_ptr&lt;T&gt;;
 
    // constructors
    constexpr shared_ptr() noexcept;
    constexpr shared_ptr(nullptr_t) noexcept : shared_ptr() { }
    template&lt;class Y&gt;
      explicit shared_ptr(Y* p);
    template&lt;class Y, class D&gt;
      shared_ptr(Y* p, D d);
    template&lt;class Y, class D, class A&gt;
      shared_ptr(Y* p, D d, A a);
    template&lt;class D&gt;
      shared_ptr(nullptr_t p, D d);
    template&lt;class D, class A&gt;
      shared_ptr(nullptr_t p, D d, A a);
    template&lt;class Y&gt;
      shared_ptr(const shared_ptr&lt;Y&gt;&amp; r, element_type* p) noexcept;
    template&lt;class Y&gt;
      shared_ptr(shared_ptr&lt;Y&gt;&amp;&amp; r, element_type* p) noexcept;
    shared_ptr(const shared_ptr&amp; r) noexcept;
    template&lt;class Y&gt;
      shared_ptr(const shared_ptr&lt;Y&gt;&amp; r) noexcept;
    shared_ptr(shared_ptr&amp;&amp; r) noexcept;
    template&lt;class Y&gt;
      shared_ptr(shared_ptr&lt;Y&gt;&amp;&amp; r) noexcept;
    template&lt;class Y&gt;
      explicit shared_ptr(const weak_ptr&lt;Y&gt;&amp; r);
    template&lt;class Y, class D&gt;
      shared_ptr(unique_ptr&lt;Y, D&gt;&amp;&amp; r);
 
    // destructor
    ~shared_ptr();
 
    // assignment
    shared_ptr&amp; operator=(const shared_ptr&amp; r) noexcept;
    template&lt;class Y&gt;
      shared_ptr&amp; operator=(const shared_ptr&lt;Y&gt;&amp; r) noexcept;
    shared_ptr&amp; operator=(shared_ptr&amp;&amp; r) noexcept;
    template&lt;class Y&gt;
      shared_ptr&amp; operator=(shared_ptr&lt;Y&gt;&amp;&amp; r) noexcept;
    template&lt;class Y, class D&gt;
      shared_ptr&amp; operator=(unique_ptr&lt;Y, D&gt;&amp;&amp; r);
 
    // modifiers
    void swap(shared_ptr&amp; r) noexcept;
    void reset() noexcept;
    template&lt;class Y&gt;
      void reset(Y* p);
    template&lt;class Y, class D&gt;
      void reset(Y* p, D d);
    template&lt;class Y, class D, class A&gt;
      void reset(Y* p, D d, A a);
 
    // observers
    element_type* get() const noexcept;
    T&amp; operator*() const noexcept;
    T* operator-&gt;() const noexcept;
    element_type&amp; operator[](ptrdiff_t i) const;
    long use_count() const noexcept;
    explicit operator bool() const noexcept;
    template&lt;class U&gt;
      bool owner_before(const shared_ptr&lt;U&gt;&amp; b) const noexcept;
    template&lt;class U&gt;
      bool owner_before(const weak_ptr&lt;U&gt;&amp; b) const noexcept;
  };
 
  template&lt;class T&gt;
    shared_ptr(weak_ptr&lt;T&gt;) -&gt; shared_ptr&lt;T&gt;;
  template&lt;class T, class D&gt;
    shared_ptr(unique_ptr&lt;T, D&gt;) -&gt; shared_ptr&lt;T&gt;;
}</pre></div> <h4 id="Class_template_std::weak_ptr"> Class template <code><a href="../memory/weak_ptr" title="cpp/memory/weak ptr">std::weak_ptr</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class T&gt; class weak_ptr {
  public:
    using element_type = remove_extent_t&lt;T&gt;;
 
    // constructors
    constexpr weak_ptr() noexcept;
    template&lt;class Y&gt;
      weak_ptr(const shared_ptr&lt;Y&gt;&amp; r) noexcept;
    weak_ptr(const weak_ptr&amp; r) noexcept;
    template&lt;class Y&gt;
      weak_ptr(const weak_ptr&lt;Y&gt;&amp; r) noexcept;
    weak_ptr(weak_ptr&amp;&amp; r) noexcept;
    template&lt;class Y&gt;
      weak_ptr(weak_ptr&lt;Y&gt;&amp;&amp; r) noexcept;
 
    // destructor
    ~weak_ptr();
 
    // assignment
    weak_ptr&amp; operator=(const weak_ptr&amp; r) noexcept;
    template&lt;class Y&gt;
      weak_ptr&amp; operator=(const weak_ptr&lt;Y&gt;&amp; r) noexcept;
    template&lt;class Y&gt;
      weak_ptr&amp; operator=(const shared_ptr&lt;Y&gt;&amp; r) noexcept;
    weak_ptr&amp; operator=(weak_ptr&amp;&amp; r) noexcept;
    template&lt;class Y&gt;
      weak_ptr&amp; operator=(weak_ptr&lt;Y&gt;&amp;&amp; r) noexcept;
 
    // modifiers
    void swap(weak_ptr&amp; r) noexcept;
    void reset() noexcept;
 
    // observers
    long use_count() const noexcept;
    bool expired() const noexcept;
    shared_ptr&lt;T&gt; lock() const noexcept;
    template&lt;class U&gt;
      bool owner_before(const shared_ptr&lt;U&gt;&amp; b) const noexcept;
    template&lt;class U&gt;
      bool owner_before(const weak_ptr&lt;U&gt;&amp; b) const noexcept;
  };
 
  template&lt;class T&gt;
    weak_ptr(shared_ptr&lt;T&gt;) -&gt; weak_ptr&lt;T&gt;;
}</pre></div> <h4 id="Class_template_std::owner_less"> Class template <code><a href="../memory/owner_less" title="cpp/memory/owner less">std::owner_less</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class T = void&gt; struct owner_less;
 
  template&lt;class T&gt; struct owner_less&lt;shared_ptr&lt;T&gt;&gt; {
    bool operator()(const shared_ptr&lt;T&gt;&amp;, const shared_ptr&lt;T&gt;&amp;) const noexcept;
    bool operator()(const shared_ptr&lt;T&gt;&amp;, const weak_ptr&lt;T&gt;&amp;) const noexcept;
    bool operator()(const weak_ptr&lt;T&gt;&amp;, const shared_ptr&lt;T&gt;&amp;) const noexcept;
  };
 
  template&lt;class T&gt; struct owner_less&lt;weak_ptr&lt;T&gt;&gt; {
    bool operator()(const weak_ptr&lt;T&gt;&amp;, const weak_ptr&lt;T&gt;&amp;) const noexcept;
    bool operator()(const shared_ptr&lt;T&gt;&amp;, const weak_ptr&lt;T&gt;&amp;) const noexcept;
    bool operator()(const weak_ptr&lt;T&gt;&amp;, const shared_ptr&lt;T&gt;&amp;) const noexcept;
  };
 
  template&lt;&gt; struct owner_less&lt;void&gt; {
    template&lt;class T, class U&gt;
      bool operator()(const shared_ptr&lt;T&gt;&amp;, const shared_ptr&lt;U&gt;&amp;) const noexcept;
    template&lt;class T, class U&gt;
      bool operator()(const shared_ptr&lt;T&gt;&amp;, const weak_ptr&lt;U&gt;&amp;) const noexcept;
    template&lt;class T, class U&gt;
      bool operator()(const weak_ptr&lt;T&gt;&amp;, const shared_ptr&lt;U&gt;&amp;) const noexcept;
    template&lt;class T, class U&gt;
      bool operator()(const weak_ptr&lt;T&gt;&amp;, const weak_ptr&lt;U&gt;&amp;) const noexcept;
 
    using is_transparent = /* unspecified */;
  };
}</pre></div> <h4 id="Class_template_std::enable_shared_from_this"> Class template <code><a href="../memory/enable_shared_from_this" title="cpp/memory/enable shared from this">std::enable_shared_from_this</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class T&gt; class enable_shared_from_this {
  protected:
    constexpr enable_shared_from_this() noexcept;
    enable_shared_from_this(const enable_shared_from_this&amp;) noexcept;
    enable_shared_from_this&amp; operator=(const enable_shared_from_this&amp;) noexcept;
    ~enable_shared_from_this();
 
  public:
    shared_ptr&lt;T&gt; shared_from_this();
    shared_ptr&lt;T const&gt; shared_from_this() const;
    weak_ptr&lt;T&gt; weak_from_this() noexcept;
    weak_ptr&lt;T const&gt; weak_from_this() const noexcept;
 
  private:
    mutable weak_ptr&lt;T&gt; weak_this;  // exposition only
  };
}</pre></div> <h4 id="Class_template_std::atomic.27s_specialization_for_std::shared_ptr"> Class template <code><a href="../atomic/atomic" title="cpp/atomic/atomic">std::atomic</a></code>'s specialization for <code><a href="../memory/shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class T&gt; struct atomic&lt;shared_ptr&lt;T&gt;&gt; {
    using value_type = shared_ptr&lt;T&gt;;
    static constexpr bool is_always_lock_free = /* implementation-defined */;
 
    bool is_lock_free() const noexcept;
    void store(shared_ptr&lt;T&gt; desired, memory_order order = memory_order::seq_cst) noexcept;
    shared_ptr&lt;T&gt; load(memory_order order = memory_order::seq_cst) const noexcept;
    operator shared_ptr&lt;T&gt;() const noexcept;
 
    shared_ptr&lt;T&gt; exchange(shared_ptr&lt;T&gt; desired,
                           memory_order order = memory_order::seq_cst) noexcept;
 
    bool compare_exchange_weak(shared_ptr&lt;T&gt;&amp; expected, shared_ptr&lt;T&gt; desired,
                               memory_order success, memory_order failure) noexcept;
    bool compare_exchange_strong(shared_ptr&lt;T&gt;&amp; expected, shared_ptr&lt;T&gt; desired,
                                 memory_order success, memory_order failure) noexcept;
 
    bool compare_exchange_weak(shared_ptr&lt;T&gt;&amp; expected, shared_ptr&lt;T&gt; desired,
                               memory_order order = memory_order::seq_cst) noexcept;
    bool compare_exchange_strong(shared_ptr&lt;T&gt;&amp; expected, shared_ptr&lt;T&gt; desired,
                                 memory_order order = memory_order::seq_cst) noexcept;
 
    constexpr atomic() noexcept = default;
    atomic(shared_ptr&lt;T&gt; desired) noexcept;
    atomic(const atomic&amp;) = delete;
    void operator=(const atomic&amp;) = delete;
    void operator=(shared_ptr&lt;T&gt; desired) noexcept;
 
  private:
    shared_ptr&lt;T&gt; p;            // exposition only
  };
}</pre></div> <h4 id="Class_template_std::atomic.27s_specialization_for_std::weak_ptr"> Class template <code><a href="../atomic/atomic" title="cpp/atomic/atomic">std::atomic</a></code>'s specialization for <code><a href="../memory/weak_ptr" title="cpp/memory/weak ptr">std::weak_ptr</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class T&gt; struct atomic&lt;weak_ptr&lt;T&gt;&gt; {
    using value_type = weak_ptr&lt;T&gt;;
    static constexpr bool is_always_lock_free = /* implementation-defined */;
 
    bool is_lock_free() const noexcept;
    void store(weak_ptr&lt;T&gt; desired, memory_order order = memory_order::seq_cst) noexcept;
    weak_ptr&lt;T&gt; load(memory_order order = memory_order::seq_cst) const noexcept;
    operator weak_ptr&lt;T&gt;() const noexcept;
 
    weak_ptr&lt;T&gt; exchange(weak_ptr&lt;T&gt; desired,
                         memory_order order = memory_order::seq_cst) noexcept;
 
    bool compare_exchange_weak(weak_ptr&lt;T&gt;&amp; expected, weak_ptr&lt;T&gt; desired,
                               memory_order success, memory_order failure) noexcept;
    bool compare_exchange_strong(weak_ptr&lt;T&gt;&amp; expected, weak_ptr&lt;T&gt; desired,
                                 memory_order success, memory_order failure) noexcept;
 
    bool compare_exchange_weak(weak_ptr&lt;T&gt;&amp; expected, weak_ptr&lt;T&gt; desired,
                               memory_order order = memory_order::seq_cst) noexcept;
    bool compare_exchange_strong(weak_ptr&lt;T&gt;&amp; expected, weak_ptr&lt;T&gt; desired,
                                 memory_order order = memory_order::seq_cst) noexcept;
 
    constexpr atomic() noexcept = default;
    atomic(weak_ptr&lt;T&gt; desired) noexcept;
    atomic(const atomic&amp;) = delete;
    void operator=(const atomic&amp;) = delete;
    void operator=(weak_ptr&lt;T&gt; desired) noexcept;
 
  private:
    weak_ptr&lt;T&gt; p;              // exposition only
  };
}</pre></div> <h4 id="Class_template_std::out_ptr_t"> Class template <code>std::out_ptr_t</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class Smart, class Pointer, class... Args&gt;
  class out_ptr_t {
  public:
    explicit out_ptr_t(Smart&amp;, Args...);
    out_ptr_t(const out_ptr_t&amp;) = delete;
 
    ~out_ptr_t();
 
    operator Pointer*() const noexcept;
    operator void**() const noexcept;
 
  private:
    Smart&amp; s;                   // exposition only
    tuple&lt;Args...&gt; a;           // exposition only
    Pointer p;                  // exposition only
  };
}</pre></div> <h4 id="Class_template_std::in_out_ptr_t"> Class template <code>std::in_out_ptr_t</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class Smart, class Pointer, class... Args&gt;
  class inout_ptr_t {
  public:
    explicit inout_ptr_t(Smart&amp;, Args...);
    inout_ptr_t(const inout_ptr_t&amp;) = delete;
 
    ~inout_ptr_t();
 
    operator Pointer*() const noexcept;
    operator void**() const noexcept;
 
  private:
    Smart&amp; s;                   // exposition only
    tuple&lt;Args...&gt; a;           // exposition only
    Pointer p;                  // exposition only
  };
}</pre></div>           <div class="_attribution">
  <p class="_attribution-p">
     cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/header/memory" class="_attribution-link">https://en.cppreference.com/w/cpp/header/memory</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
