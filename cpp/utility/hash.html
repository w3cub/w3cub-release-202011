
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Std&#58;&#58;hash - C++ - W3cubDocs</title>
  
  <meta name="description" content=" Each specialization of this template is either enabled (&#34;untainted&#34;) or disabled (&#34;poisoned&#34;). ">
  <meta name="keywords" content="std, hash, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/utility/hash.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-9c7b0d969c0ce639a6c01c2badcdd81667c7c66206aa3d0fccc5cb0585fb1b912dab72ea882101d18010680927514b4b77b107282db8f756fbf63301fe9c88b0.css">
  <script type="text/javascript" src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js"></script>
  <script src="/json/cpp.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _cppref">
				
				
<h1 id="firstHeading" class="firstHeading">std::hash</h1>            <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th> Defined in header <code><a href="../header/functional" title="cpp/header/functional">&lt;functional&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">template&lt; class Key &gt;
struct hash;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr>  </table> <p>Each specialization of this template is either <i>enabled</i> ("untainted") or <i>disabled</i> ("poisoned").</p>
<p>The <i>enabled</i> specializations of the <code>hash</code> template defines a function object that implements a <a href="https://en.wikipedia.org/wiki/Hash_function" class="extiw" title="enwiki:Hash function">Hash function</a>. Instances of this function object satisfy <a href="../named_req/hash" title="cpp/named req/Hash">Hash</a>. In particular, they define an <code>operator() const</code> that:</p>
<ol>
<li> Accepts a single parameter of type <code>Key</code>. </li>
<li> Returns a value of type <code><a href="http://en.cppreference.com/w/cpp/types/size_t"><span class="kw107">std::<span class="me2">size_t</span></span></a></code> that represents the hash value of the parameter. </li>
<li> Does not throw exceptions when called. </li>
<li> For two parameters <code>k1</code> and <code>k2</code> that are equal, <code>std::hash&lt;Key&gt;()(k1) == std::hash&lt;Key&gt;()(k2)</code>. </li>
<li> For two different parameters <code>k1</code> and <code>k2</code> that are not equal, the probability that <code>std::hash&lt;Key&gt;()(k1) == std::hash&lt;Key&gt;()(k2)</code> should be very small, approaching <code><span class="nu16">1.0</span><span class="sy2">/</span><a href="http://en.cppreference.com/w/cpp/types/numeric_limits"><span class="kw351">std::<span class="me2">numeric_limits</span></span></a><span class="sy1">&lt;</span><a href="http://en.cppreference.com/w/cpp/types/size_t"><span class="kw107">std::<span class="me2">size_t</span></span></a><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">max</span><span class="br0">(</span><span class="br0">)</span></code>. </li>
</ol> <p>All explicit and partial specializations of <code>hash</code> provided by the standard library are <a href="../named_req/defaultconstructible" title="cpp/named req/DefaultConstructible">DefaultConstructible</a>, <a href="../named_req/copyassignable" title="cpp/named req/CopyAssignable">CopyAssignable</a>, <a href="../named_req/swappable" title="cpp/named req/Swappable">Swappable</a> and <a href="../named_req/destructible" title="cpp/named req/Destructible">Destructible</a>. User-provided specializations of <code>hash</code> also must meet those requirements.</p>
<p>The unordered associative containers <code><a href="../container/unordered_set" title="cpp/container/unordered set">std::unordered_set</a></code>, <code><a href="../container/unordered_multiset" title="cpp/container/unordered multiset">std::unordered_multiset</a></code>, <code><a href="../container/unordered_map" title="cpp/container/unordered map">std::unordered_map</a></code>, <code><a href="../container/unordered_multimap" title="cpp/container/unordered multimap">std::unordered_multimap</a></code> use specializations of the template <code>std::hash</code> as the default hash function.</p>
<p>For every type <code>Key</code> for which neither the library nor the user provides an enabled specialization <code>std::hash&lt;Key&gt;</code>, that specialization exists and is disabled. Disabled specializations do not satisfy <a href="../named_req/hash" title="cpp/named req/Hash">Hash</a>, do not satisfy <a href="../named_req/functionobject" title="cpp/named req/FunctionObject">FunctionObject</a>, and following values are all <code>false</code>:</p>
<ul>
<li> <code><a href="http://en.cppreference.com/w/cpp/types/is_default_constructible"><span class="kw533">std::<span class="me2">is_default_constructible</span></span></a><span class="sy1">&lt;</span>std<span class="sy4">::</span><span class="me2">hash</span><span class="sy1">&lt;</span>Key<span class="sy1">&gt;&gt;</span><span class="sy4">::</span><span class="me2">value</span></code> </li>
<li> <code><a href="http://en.cppreference.com/w/cpp/types/is_copy_constructible"><span class="kw539">std::<span class="me2">is_copy_constructible</span></span></a><span class="sy1">&lt;</span>std<span class="sy4">::</span><span class="me2">hash</span><span class="sy1">&lt;</span>Key<span class="sy1">&gt;&gt;</span><span class="sy4">::</span><span class="me2">value</span></code> </li>
<li> <code><a href="http://en.cppreference.com/w/cpp/types/is_move_constructible"><span class="kw545">std::<span class="me2">is_move_constructible</span></span></a><span class="sy1">&lt;</span>std<span class="sy4">::</span><span class="me2">hash</span><span class="sy1">&lt;</span>Key<span class="sy1">&gt;&gt;</span><span class="sy4">::</span><span class="me2">value</span></code> </li>
<li> <code><a href="http://en.cppreference.com/w/cpp/types/is_copy_assignable"><span class="kw557">std::<span class="me2">is_copy_assignable</span></span></a><span class="sy1">&lt;</span>std<span class="sy4">::</span><span class="me2">hash</span><span class="sy1">&lt;</span>Key<span class="sy1">&gt;&gt;</span><span class="sy4">::</span><span class="me2">value</span></code> </li>
<li> <code><a href="http://en.cppreference.com/w/cpp/types/is_move_assignable"><span class="kw563">std::<span class="me2">is_move_assignable</span></span></a><span class="sy1">&lt;</span>std<span class="sy4">::</span><span class="me2">hash</span><span class="sy1">&lt;</span>Key<span class="sy1">&gt;&gt;</span><span class="sy4">::</span><span class="me2">value</span></code> </li>
</ul> <p>In other words, they exist, but cannot be used.</p>
<h3 id="Notes"> Notes</h3> <p>The actual hash functions are implementation-dependent and are not required to fulfill any other quality criteria except those specified above. Notably, some implementations use trivial (identity) hash functions which map an integer to itself. In other words, these hash functions are designed to work with unordered associative containers, but not as cryptographic hashes, for example.</p>
<p>Hash functions are only required to produce the same result for the same input within a single execution of a program; this allows salted hashes that prevent collision denial-of-service attacks.</p>
<p>There is no specialization for C strings. <code>std::hash&lt;const char*&gt;</code> produces a hash of the value of the pointer (the memory address), it does not examine the contents of any character array.</p>
<table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <h3 id="Member_types"> Member types</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th> Member type </th> <th> Definition </th>
</tr> <tr class="t-dsc"> <td> <code>argument_type</code><span class="t-mark-rev t-deprecated-cxx17">(deprecated in C++17)</span> </td> <td> <code>Key</code> </td>
</tr> <tr class="t-dsc"> <td> <code>result_type</code><span class="t-mark-rev t-deprecated-cxx17">(deprecated in C++17)</span> </td> <td> <code><a href="../types/size_t" title="cpp/types/size t">std::size_t</a></code> </td>
</tr> </table> </td> <td><span class="t-mark-rev t-until-cxx20">(until C++20)</span></td>
</tr> </table> <h3 id="Member_functions"> Member functions</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="hash/hash" title="cpp/utility/hash/hash"> <span class="t-lines"><span>(constructor)</span></span></a></div> </td> <td> constructs a hash function object <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="hash/operator()" title="cpp/utility/hash/operator()"> <span class="t-lines"><span>operator()</span></span></a></div> </td> <td> calculates the hash of the argument <br> <span class="t-mark">(public member function)</span> </td>
</tr> </table> <h3 id="Standard_specializations_for_basic_types"> Standard specializations for basic types</h3> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th> Defined in header <code><a href="../header/functional" title="cpp/header/functional">&lt;functional&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">template&lt;&gt; struct hash&lt;bool&gt;;
template&lt;&gt; struct hash&lt;char&gt;;
template&lt;&gt; struct hash&lt;signed char&gt;;
template&lt;&gt; struct hash&lt;unsigned char&gt;;
template&lt;&gt; struct hash&lt;char8_t&gt;;        // C++20
template&lt;&gt; struct hash&lt;char16_t&gt;;
template&lt;&gt; struct hash&lt;char32_t&gt;;
template&lt;&gt; struct hash&lt;wchar_t&gt;;
template&lt;&gt; struct hash&lt;short&gt;;
template&lt;&gt; struct hash&lt;unsigned short&gt;;
template&lt;&gt; struct hash&lt;int&gt;;
template&lt;&gt; struct hash&lt;unsigned int&gt;;
template&lt;&gt; struct hash&lt;long&gt;;
template&lt;&gt; struct hash&lt;long long&gt;;
template&lt;&gt; struct hash&lt;unsigned long&gt;;
template&lt;&gt; struct hash&lt;unsigned long long&gt;;
template&lt;&gt; struct hash&lt;float&gt;;
template&lt;&gt; struct hash&lt;double&gt;;
template&lt;&gt; struct hash&lt;long double&gt;;
template&lt;&gt; struct hash&lt;std::nullptr_t&gt;;
template&lt; class T &gt; struct hash&lt;T*&gt;;</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <p>In addition to the above, the standard library provides specializations for all (scoped and unscoped) enumeration types. These may be (but are not required to be) implemented as <code>std<span class="sy4">::</span><span class="me2">hash</span><span class="sy1">&lt;</span><a href="http://en.cppreference.com/w/cpp/types/underlying_type"><span class="kw640">std::<span class="me2">underlying_type</span></span></a><span class="sy1">&lt;</span>Enum<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">type</span><span class="sy1">&gt;</span></code>.</p>
<p>The standard library provides enabled specializations of <code>std::hash</code> for <code><a href="../types/nullptr_t" title="cpp/types/nullptr t">std::nullptr_t</a></code> and all cv-unqualified arithmetic types (including any extended integer types), all enumeration types, and all pointer types.</p>
<p>Each standard library header that declares the template <code>std::hash</code> provides all enabled specializations described above. These headers include <a href="../header/string" title="cpp/header/string"><code>&lt;string&gt;</code></a>, <a href="../header/system_error" title="cpp/header/system error"><code>&lt;system_error&gt;</code></a>, <a href="../header/bitset" title="cpp/header/bitset"><code>&lt;bitset&gt;</code></a>, <a href="../header/memory" title="cpp/header/memory"><code>&lt;memory&gt;</code></a>, <a href="../header/typeindex" title="cpp/header/typeindex"><code>&lt;typeindex&gt;</code></a>, <a href="../header/vector" title="cpp/header/vector"><code>&lt;vector&gt;</code></a>, <a href="../header/thread" title="cpp/header/thread"><code>&lt;thread&gt;</code></a><span class="t-rev-inl t-since-cxx17"><span>, <a href="../header/optional" title="cpp/header/optional"><code>&lt;optional&gt;</code></a>, <a href="../header/variant" title="cpp/header/variant"><code>&lt;variant&gt;</code></a>, <a href="../header/string_view" title="cpp/header/string view"><code>&lt;string_view&gt;</code></a></span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span><span class="t-rev-inl t-since-cxx20"><span>, <a href="../header/coroutine" title="cpp/header/coroutine"><code>&lt;coroutine&gt;</code></a></span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span><span class="t-rev-inl t-since-cxx23"><span>, <a href="../header/stacktrace" title="cpp/header/stacktrace"><code>&lt;stacktrace&gt;</code></a></span> <span><span class="t-mark-rev t-since-cxx23">(since C++23)</span></span></span>.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <p>All member functions of all standard library specializations of this template are <code>noexcept</code> except for the member functions of <a href="optional/hash" title="cpp/utility/optional/hash"><code>std::hash&lt;std::optional&gt;</code></a>, <a href="variant/hash" title="cpp/utility/variant/hash"><code>std::hash&lt;std::variant&gt;</code></a>, and <a href="../memory/unique_ptr/hash" title="cpp/memory/unique ptr/hash"><code>std::hash&lt;std::unique_ptr&gt;</code></a>.</p>
</td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <h3 id="Standard_specializations_for_library_types"> Standard specializations for library types</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../coroutine/coroutine_handle/hash" title="cpp/coroutine/coroutine handle/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::coroutine_handle&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> hash support for <code><a href="../coroutine/coroutine_handle" title="cpp/coroutine/coroutine handle">std::coroutine_handle</a></code> <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../error/error_code/hash" title="cpp/error/error code/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::error_code&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> hash support for <code><a href="../error/error_code" title="cpp/error/error code">std::error_code</a></code> <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../error/error_condition/hash" title="cpp/error/error condition/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::error_condition&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> hash support for <code><a href="../error/error_condition" title="cpp/error/error condition">std::error_condition</a></code> <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="stacktrace_entry/hash" title="cpp/utility/stacktrace entry/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::stacktrace_entry&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> hash support for <code>std::stacktrace_entry</code> <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="basic_stacktrace/hash" title="cpp/utility/basic stacktrace/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::basic_stacktrace&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> hash support for <code>std::basic_stacktrace</code> <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="optional/hash" title="cpp/utility/optional/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::optional&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> specializes the <code>std::hash</code> algorithm <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="variant/hash" title="cpp/utility/variant/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::variant&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> specializes the <code>std::hash</code> algorithm <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="variant/monostate#Helper_classes" title="cpp/utility/variant/monostate"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::monostate&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> hash support for <code><a href="variant/monostate" title="cpp/utility/variant/monostate">std::monostate</a></code> <br> <span class="t-mark">(class template specialization)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="bitset/hash" title="cpp/utility/bitset/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::bitset&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> hash support for <code><a href="bitset" title="cpp/utility/bitset">std::bitset</a></code> <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/unique_ptr/hash" title="cpp/memory/unique ptr/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::unique_ptr&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> hash support for <code><a href="../memory/unique_ptr" title="cpp/memory/unique ptr">std::unique_ptr</a></code> <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/shared_ptr/hash" title="cpp/memory/shared ptr/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::shared_ptr&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> hash support for <code><a href="../memory/shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code> <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../types/type_index/hash" title="cpp/types/type index/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::type_index&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> hash support for <code><a href="../types/type_index" title="cpp/types/type index">std::type_index</a></code> <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../string/basic_string/hash" title="cpp/string/basic string/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::string&gt;</span></span><span>std::hash<span class="t-dsc-small">&lt;std::u8string&gt;</span></span><span>std::hash<span class="t-dsc-small">&lt;std::u16string&gt;</span></span><span>std::hash<span class="t-dsc-small">&lt;std::u32string&gt;</span></span><span>std::hash<span class="t-dsc-small">&lt;std::wstring&gt;</span></span><span>std::hash<span class="t-dsc-small">&lt;std::pmr::string&gt;</span></span><span>std::hash<span class="t-dsc-small">&lt;std::pmr::u8string&gt;</span></span><span>std::hash<span class="t-dsc-small">&lt;std::pmr::u16string&gt;</span></span><span>std::hash<span class="t-dsc-small">&lt;std::pmr::u32string&gt;</span></span><span>std::hash<span class="t-dsc-small">&lt;std::pmr::wstring&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> hash support for strings <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../string/basic_string_view/hash" title="cpp/string/basic string view/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::string_view&gt;</span></span><span>std::hash<span class="t-dsc-small">&lt;std::wstring_view&gt;</span></span><span>std::hash<span class="t-dsc-small">&lt;std::u8string_view&gt;</span></span><span>std::hash<span class="t-dsc-small">&lt;std::u16string_view&gt;</span></span><span>std::hash<span class="t-dsc-small">&lt;std::u32string_view&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> hash support for string views <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/vector_bool/hash" title="cpp/container/vector bool/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::vector&lt;bool&gt;&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> hash support for <code><a href="http://en.cppreference.com/w/cpp/container/vector"><span class="kw1272">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span><span class="kw4">bool</span><span class="sy1">&gt;</span></code> <br> <span class="t-mark">(class template specialization)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../filesystem/path/hash" title="cpp/filesystem/path/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::filesystem::path&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> hash support for <code><a href="../filesystem/path" title="cpp/filesystem/path">std::filesystem::path</a></code> <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../thread/thread/id/hash" title="cpp/thread/thread/id/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::thread::id&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> hash support for <code><a href="../thread/thread/id" title="cpp/thread/thread/id">std::thread::id</a></code> <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> </table> <p>Note: additional specializations for <code><a href="pair" title="cpp/utility/pair">std::pair</a></code> and the standard container types, as well as utility functions to compose hashes are available in <a rel="nofollow" class="external text" href="https://www.boost.org/doc/libs/release/libs/container_hash/doc/html/hash.html#ref"><code>boost::hash</code></a>.</p>
<h3 id="Example"> Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;functional&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;unordered_set&gt;
 
struct S
{
    std::string first_name;
    std::string last_name;
    bool operator==(const S&amp;) const = default; // since C++20
};
 
// Before C++20
// bool operator==(const S&amp; lhs, const S&amp; rhs)
// {
//     return lhs.first_name == rhs.first_name &amp;&amp; lhs.last_name == rhs.last_name;
// }
 
// custom hash can be a standalone function object:
struct MyHash
{
    std::size_t operator()(S const&amp; s) const noexcept
    {
        std::size_t h1 = std::hash&lt;std::string&gt;{}(s.first_name);
        std::size_t h2 = std::hash&lt;std::string&gt;{}(s.last_name);
        return h1 ^ (h2 &lt;&lt; 1); // or use boost::hash_combine
    }
};
 
// custom specialization of std::hash can be injected in namespace std
template&lt;&gt;
struct std::hash&lt;S&gt;
{
    std::size_t operator()(S const&amp; s) const noexcept
    {
        std::size_t h1 = std::hash&lt;std::string&gt;{}(s.first_name);
        std::size_t h2 = std::hash&lt;std::string&gt;{}(s.last_name);
        return h1 ^ (h2 &lt;&lt; 1); // or use boost::hash_combine
    }
};
 
int main()
{
    std::string str = "Meet the new boss...";
    std::size_t str_hash = std::hash&lt;std::string&gt;{}(str);
    std::cout &lt;&lt; "hash(" &lt;&lt; std::quoted(str) &lt;&lt; ") =\n\t" &lt;&lt; str_hash &lt;&lt; '\n';
 
    S obj = { "Hubert", "Farnsworth" };
    // using the standalone function object
    std::cout &lt;&lt; "hash(" &lt;&lt; std::quoted(obj.first_name) &lt;&lt; ", "
              &lt;&lt; std::quoted(obj.last_name) &lt;&lt; ") =\n\t"
              &lt;&lt; MyHash{}(obj) &lt;&lt; " (using MyHash) or\n\t"
              &lt;&lt; std::hash&lt;S&gt;{}(obj) &lt;&lt; " (using injected std::hash&lt;S&gt; specialization)\n";
 
    // Custom hash makes it possible to use custom types in unordered containers.
    // The example will use the injected std::hash&lt;S&gt; specialization above,
    // to use MyHash instead, pass it as a second template argument.
    std::unordered_set&lt;S&gt; names = { obj, {"Bender", "Rodriguez"}, {"Turanga", "Leela"} };
    for (auto const&amp; s: names)
        std::cout &lt;&lt; std::quoted(s.first_name) &lt;&lt; ' ' &lt;&lt; std::quoted(s.last_name) &lt;&lt; '\n';
}</pre></div> <p>Possible output:</p>
<div class="text source-text"><pre data-language="c">hash("Meet the new boss...") =
        1861821886482076440
hash("Hubert", "Farnsworth") = 
        17622465712001802105 (using MyHash) or
        17622465712001802105 (using injected std::hash&lt;S&gt; specialization)
"Turanga" "Leela"
"Bender" "Rodriguez"
"Hubert" "Farnsworth"</pre></div> </div> <h3 id="Defect_reports"> Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th> DR </th> <th> Applied to </th> <th> Behavior as published </th> <th> Correct behavior </th>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue2148">LWG 2148</a> </td> <td> C++11 </td> <td> specializations for enumerations were missing </td> <td> provided </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue2543">LWG 2543</a> </td> <td> C++11 </td> <td> <code>hash</code> might not be SFINAE-friendly </td> <td> made SFINAE-friendly via disabled specializations </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue2817">LWG 2817</a> </td> <td> C++11 </td> <td> specialization for <code>nullptr_t</code> was missing </td> <td> provided </td>
</tr>
</table>           <div class="_attribution">
  <p class="_attribution-p">
    Â© cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/utility/hash" class="_attribution-link">https://en.cppreference.com/w/cpp/utility/hash</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
