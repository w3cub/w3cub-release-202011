
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Std&#58;&#58;bind - C++ - W3cubDocs</title>
  
  <meta name="description" content="The function template std&#58;&#58;bind generates a forwarding call wrapper for f. Calling this wrapper is equivalent to invoking f with some of its &hellip;">
  <meta name="keywords" content="std, bind, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/utility/functional/bind.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-9c7b0d969c0ce639a6c01c2badcdd81667c7c66206aa3d0fccc5cb0585fb1b912dab72ea882101d18010680927514b4b77b107282db8f756fbf63301fe9c88b0.css">
  <script type="text/javascript" src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js"></script>
  <script src="/json/cpp.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _cppref">
				
				
<h1 id="firstHeading" class="firstHeading">std::bind</h1>            <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th> Defined in header <code><a href="../../header/functional" title="cpp/header/functional">&lt;functional&gt;</a></code> </th> <th> </th> <th> </th> </tr>  <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(1)</td> <td></td> </tr> <tr class="t-dcl t-since-cxx11 t-until-cxx20"> <td> <pre data-language="cpp">template&lt; class F, class... Args &gt;
/* unspecified */ bind( F&amp;&amp; f, Args&amp;&amp;... args );</pre>
</td>  <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> <br><span class="t-mark-rev t-until-cxx20">(until C++20)</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">template&lt; class F, class... Args &gt;
constexpr /* unspecified */ bind( F&amp;&amp; f, Args&amp;&amp;... args );</pre>
</td>  <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td> </tr>   <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(2)</td> <td></td> </tr> <tr class="t-dcl t-since-cxx11 t-until-cxx20"> <td> <pre data-language="cpp">template&lt; class R, class F, class... Args &gt;
/* unspecified */ bind( F&amp;&amp; f, Args&amp;&amp;... args );</pre>
</td>  <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> <br><span class="t-mark-rev t-until-cxx20">(until C++20)</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">template&lt; class R, class F, class... Args &gt;
constexpr /* unspecified */ bind( F&amp;&amp; f, Args&amp;&amp;... args );</pre>
</td>  <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td> </tr>   </table> <p>The function template <code>std::bind</code> generates a forwarding call wrapper for <code>f</code>. Calling this wrapper is equivalent to invoking <code>f</code> with some of its arguments <a href="#Bound_arguments">bound</a> to <code>args</code>.</p>
<p>If <code><a href="http://en.cppreference.com/w/cpp/types/is_constructible"><span class="kw527">std::<span class="me2">is_constructible</span></span></a><span class="sy1">&lt;</span><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw631">std::<span class="me2">decay</span></span></a><span class="sy1">&lt;</span>F<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">type</span>, F<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value</span></code> is <code>false</code>, or <code><a href="http://en.cppreference.com/w/cpp/types/is_constructible"><span class="kw527">std::<span class="me2">is_constructible</span></span></a><span class="sy1">&lt;</span><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw631">std::<span class="me2">decay</span></span></a><span class="sy1">&lt;</span>Arg_i<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">type</span>, Arg_i<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value</span></code> is <code>false</code> for any type <code>Arg_i</code> in <code>Args</code>, the program is ill-formed.</p>
<p>If <a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw631">std::<span class="me2">decay</span></span></a><span class="sy1">&lt;</span>Ti<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">type</span> or any type in <code>Args</code> is not <a href="../../named_req/moveconstructible" title="cpp/named req/MoveConstructible">MoveConstructible</a> or <a href="../../named_req/destructible" title="cpp/named req/Destructible">Destructible</a>, the behavior is undefined.</p>
<h3 id="Parameters"> Parameters</h3> <table class="t-par-begin"> <tr class="t-par"> <td> f </td> <td> - </td> <td> <a href="../../named_req/callable" title="cpp/named req/Callable">Callable</a> object (function object, pointer to function, reference to function, pointer to member function, or pointer to data member) that will be bound to some arguments </td>
</tr> <tr class="t-par"> <td> args </td> <td> - </td> <td> list of arguments to bind, with the unbound arguments replaced by the <a href="placeholders" title="cpp/utility/functional/placeholders">placeholders</a> <code>_1, _2, _3...</code> of namespace <code>std::placeholders</code> </td>
</tr>
</table> <h3 id="Return_value"> Return value</h3> <p>A function object <code>g</code> of unspecified type <code>T</code>, for which <code><a href="http://en.cppreference.com/w/cpp/utility/functional/is_bind_expression"><span class="kw1058">std::<span class="me2">is_bind_expression</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value</span></code> is <code>true</code>. It has the following members:</p>
<div class="t-member"> <h2 id="std::bind_return_type"> std::bind <i>return type</i>
</h2> <h4 id="Member_objects"> Member objects</h4> <p>The return type of <code>std::bind</code> holds a member object of type <a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw631">std::<span class="me2">decay</span></span></a><span class="sy1">&lt;</span>F<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">type</span> constructed from <code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>F<span class="sy1">&gt;</span><span class="br0">(</span>f<span class="br0">)</span></code>, and one object per each of <code>args...</code>, of type <a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw631">std::<span class="me2">decay</span></span></a><span class="sy1">&lt;</span>Arg_i<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">type</span>, similarly constructed from <code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>Arg_i<span class="sy1">&gt;</span><span class="br0">(</span>arg_i<span class="br0">)</span></code>.</p>
<h4 id="Constructors"> Constructors</h4> <p>The return type of <code>std::bind</code> is <a href="../../named_req/copyconstructible" title="cpp/named req/CopyConstructible">CopyConstructible</a> if all of its member objects (specified above) are CopyConstructible, and is <a href="../../named_req/moveconstructible" title="cpp/named req/MoveConstructible">MoveConstructible</a> otherwise. The type defines the following members:</p>
<table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <h4 id="Member_type_result_type"> Member type <code>result_type</code>
</h4> <span class="t-li">1)</span> <span class="t-mark-rev t-deprecated-cxx17">(deprecated in C++17)</span> If <code>F</code> is a pointer to function or a pointer to member function, <code>result_type</code> is the return type of <code>F</code>. If <code>F</code> is a class type with nested typedef <code>result_type</code>, then <code>result_type</code> is <code>F::result_type</code>. Otherwise no <code>result_type</code> is defined. <span class="t-li">2)</span> <span class="t-mark-rev t-deprecated-cxx17">(deprecated in C++17)</span> <code>result_type</code> is exactly <code>R</code>. </td> <td><span class="t-mark-rev t-until-cxx20">(until C++20)</span></td>
</tr> </table> <h4 id="Member_function_operator.28.29"> Member function <code>operator()</code>
</h4> <p>When <code>g</code> is invoked in a function call expression <code>g(u1, u2, ... uM)</code>, an invocation of the stored object takes place, as if by.</p>
<div class="t-li1">
<span class="t-li">1)</span> <code><a href="../functional" title="cpp/utility/functional"><i>INVOKE</i></a><span class="br0">(</span>fd, <a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>V1<span class="sy1">&gt;</span><span class="br0">(</span>v1<span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>V2<span class="sy1">&gt;</span><span class="br0">(</span>v2<span class="br0">)</span>, ..., <a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>VN<span class="sy1">&gt;</span><span class="br0">(</span>vN<span class="br0">)</span><span class="br0">)</span></code>, or</div> <div class="t-li1">
<span class="t-li">2)</span> <code><a href="../functional" title="cpp/utility/functional"><i>INVOKE&lt;R&gt;</i></a><span class="br0">(</span>fd, <a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>V1<span class="sy1">&gt;</span><span class="br0">(</span>v1<span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>V2<span class="sy1">&gt;</span><span class="br0">(</span>v2<span class="br0">)</span>, ..., <a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>VN<span class="sy1">&gt;</span><span class="br0">(</span>vN<span class="br0">)</span><span class="br0">)</span></code>,</div> <p>where <code>fd</code> is a value of type <code><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw631">std::<span class="me2">decay</span></span></a><span class="sy1">&lt;</span>F<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">type</span></code>, the values and types of the bound arguments <code>v1</code><code>, </code><code>v2</code><code>, ..., </code><code>vN</code> are determined as specified <a href="#Bound_arguments">below</a>.</p>
<p>If some of the arguments that are supplied in the call to <code>g()</code> are not matched by any placeholders stored in <code>g</code>, the unused arguments are evaluated and discarded.</p>
<p>An invocation of operator<span class="br0">(</span><span class="br0">)</span> is <a href="../../language/noexcept" title="cpp/language/noexcept">non-throwing</a> <span class="t-rev-inl t-since-cxx20"><span>or is a <a href="../../language/constant_expression" title="cpp/language/constant expression">constant subexpression</a></span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span> if and only if so is the underlying <code><i>INVOKE</i></code> operation. operator<span class="br0">(</span><span class="br0">)</span> participates in overload resolution only if the <code><i>INVOKE</i></code> operation is well-formed when treated as an unevaluated operand.</p>
<p>If <code>g</code> is <a href="../../language/cv" title="cpp/language/cv">volatile</a>-qualified, the program is ill-formed.</p>
<p>If <code><a href="../functional" title="cpp/utility/functional"><i>INVOKE</i></a>(fd, w1, w2, ..., wN)</code> can never be a valid expression for any possible values <code>w1</code><code>, </code><code>w2</code><code>, ..., </code><code>wN</code>, the behavior is undefined.</p>
</div> <h3 id="Bound_arguments"> Bound arguments</h3> <p>If the stored argument <code>arg</code> is of type <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper"><span class="kw1070">std::<span class="me2">reference_wrapper</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> (for example, <code><a href="ref" title="cpp/utility/functional/ref">std::ref</a></code> or <code><a href="ref" title="cpp/utility/functional/ref">std::cref</a></code> was used in the initial call to <code>std::bind</code>), then the argument <code>vn</code> in the <code><i>INVOKE</i></code> operation above is <code>arg.get()</code> and the type <code>Vn</code> in the same call is <code>T&amp;</code>: the stored argument is passed by reference into the invoked function object.</p>
<p>If the stored argument <code>arg</code> is of type <code>T</code> for which <code><a href="http://en.cppreference.com/w/cpp/utility/functional/is_bind_expression"><span class="kw1058">std::<span class="me2">is_bind_expression</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value</span></code> is <code>true</code> (for example, another <code>std::bind</code> expression was passed directly into the initial call to <code>std::bind</code>), then <code>std::bind</code> performs function composition: instead of passing the function object that the bind subexpression would return, the subexpression is invoked eagerly, and its return value is passed to the outer invokable object. If the bind subexpression has any placeholder arguments, they are shared with the outer bind (picked out of <code>u1</code><code>, </code><code>u2</code><code>, ...</code>). Specifically, the argument <code>vn</code> in the <code><i>INVOKE</i></code> operation above is <code>arg<span class="br0">(</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>Uj<span class="sy1">&gt;</span><span class="br0">(</span>uj<span class="br0">)</span>...<span class="br0">)</span></code> and the type <code>Vn</code> in the same call is <span class="t-rev-inl t-until-cxx17"><span><code><a href="http://en.cppreference.com/w/cpp/types/result_of"><span class="kw642">std::<span class="me2">result_of</span></span></a><span class="sy1">&lt;</span>T</code> <i>cv</i> ﻿<code>&amp;(Uj&amp;&amp;...)&gt;::type&amp;&amp;</code></span> <span><span class="t-mark-rev t-until-cxx17">(until C++17)</span></span></span><span class="t-rev-inl t-since-cxx17"><span><code><a href="http://en.cppreference.com/w/cpp/types/result_of"><span class="kw3222">std::<span class="me2">invoke_result_t</span></span></a><span class="sy1">&lt;</span>T</code> <i>cv</i> ﻿<code>&amp;, Uj&amp;&amp;...&gt;&amp;&amp;</code></span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> (cv-qualification is the same as that of <code>g</code>).</p>
<p>If the stored argument <code>arg</code> is of type <code>T</code>, for which <code><a href="http://en.cppreference.com/w/cpp/utility/functional/is_placeholder"><span class="kw1059">std::<span class="me2">is_placeholder</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value</span></code> is not <code>​0​</code> (meaning, a placeholder such as <code>std::placeholders::_1, _2, _3, ...</code> was used as the argument to the initial call to <code>std::bind</code>), then the argument indicated by the placeholder (<code>u1</code> for <code>_1</code>, <code>u2</code> for <code>_2</code>, etc) is passed to the invokable object: the argument <code>vn</code> in the <code><i>INVOKE</i></code> operation above is <code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>Uj<span class="sy1">&gt;</span><span class="br0">(</span>uj<span class="br0">)</span></code> and the corresponding type <code>Vn</code> in the same call is <code>Uj&amp;&amp;</code>.</p>
<p>Otherwise, the ordinary stored argument <code>arg</code> is passed to the invokable object as lvalue argument: the argument <code>vn</code> in the <code><i>INVOKE</i></code> operation above is simply <code>arg</code> and the corresponding type <code>Vn</code> is <code>T</code> <i>cv</i> ﻿<code>&amp;</code>, where <i>cv</i> is the same cv-qualification as that of <code>g</code>.</p>
<h3 id="Exceptions"> Exceptions</h3> <p>Only throws if construction of <a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw631">std::<span class="me2">decay</span></span></a><span class="sy1">&lt;</span>F<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">type</span> from <code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>F<span class="sy1">&gt;</span><span class="br0">(</span>f<span class="br0">)</span></code> throws, or any of the constructors for <a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw631">std::<span class="me2">decay</span></span></a><span class="sy1">&lt;</span>Arg_i<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">type</span> from the corresponding <code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>Arg_i<span class="sy1">&gt;</span><span class="br0">(</span>arg_i<span class="br0">)</span></code> throws where <code>Arg_i</code> is the ith type and <code>arg_i</code> is the ith argument in <code>Args... args</code>.</p>
<h3 id="Notes"> Notes</h3> <p>As described in <a href="../../named_req/callable" title="cpp/named req/Callable">Callable</a>, when invoking a pointer to non-static member function or pointer to non-static data member, the first argument has to be a reference or pointer (including, possibly, smart pointer such as <code><a href="../../memory/shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code> and <code><a href="../../memory/unique_ptr" title="cpp/memory/unique ptr">std::unique_ptr</a></code>) to an object whose member will be accessed.</p>
<p>The arguments to bind are copied or moved, and are never passed by reference unless wrapped in <code><a href="ref" title="cpp/utility/functional/ref">std::ref</a></code> or <code><a href="ref" title="cpp/utility/functional/ref">std::cref</a></code>.</p>
<p>Duplicate placeholders in the same bind expression (multiple <code>_1</code>'s for example) are allowed, but the results are only well defined if the corresponding argument (<code>u1</code>) is an lvalue or non-movable rvalue.</p>
<h3 id="Example"> Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;random&gt;
 
void f(int n1, int n2, int n3, const int&amp; n4, int n5)
{
    std::cout &lt;&lt; n1 &lt;&lt; ' ' &lt;&lt; n2 &lt;&lt; ' ' &lt;&lt; n3 &lt;&lt; ' ' &lt;&lt; n4 &lt;&lt; ' ' &lt;&lt; n5 &lt;&lt; '\n';
}
 
int g(int n1)
{
    return n1;
}
 
struct Foo
{
    void print_sum(int n1, int n2)
    {
        std::cout &lt;&lt; n1 + n2 &lt;&lt; '\n';
    }
 
    int data = 10;
};
 
int main()
{
    using namespace std::placeholders;  // for _1, _2, _3...
 
    std::cout &lt;&lt; "1) argument reordering and pass-by-reference: ";
    int n = 7;
    // (_1 and _2 are from std::placeholders, and represent future
    // arguments that will be passed to f1)
    auto f1 = std::bind(f, _2, 42, _1, std::cref(n), n);
    n = 10;
    f1(1, 2, 1001); // 1 is bound by _1, 2 is bound by _2, 1001 is unused
                    // makes a call to f(2, 42, 1, n, 7)
 
    std::cout &lt;&lt; "2) achieving the same effect using a lambda: ";
    n = 7;
    auto lambda = [&amp;ncref = n, n](auto a, auto b, auto /*unused*/)
    {
        f(b, 42, a, ncref, n);
    };
    n = 10;
    lambda(1, 2, 1001); // same as a call to f1(1, 2, 1001)
 
    std::cout &lt;&lt; "3) nested bind subexpressions share the placeholders: ";
    auto f2 = std::bind(f, _3, std::bind(g, _3), _3, 4, 5);
    f2(10, 11, 12); // makes a call to f(12, g(12), 12, 4, 5);
 
    std::cout &lt;&lt; "4) bind a RNG with a distribution: ";
    std::default_random_engine e;
    std::uniform_int_distribution&lt;&gt; d(0, 10);
    auto rnd = std::bind(d, e); // a copy of e is stored in rnd
    for (int n = 0; n &lt; 10; ++n)
        std::cout &lt;&lt; rnd() &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
 
    std::cout &lt;&lt; "5) bind to a pointer to member function: ";
    Foo foo;
    auto f3 = std::bind(&amp;Foo::print_sum, &amp;foo, 95, _1);
    f3(5);
 
    std::cout &lt;&lt; "6) bind to a mem_fn that is a pointer to member function: ";
    auto ptr_to_print_sum = std::mem_fn(&amp;Foo::print_sum);
    auto f4 = std::bind(ptr_to_print_sum, &amp;foo, 95, _1);
    f4(5);
 
    std::cout &lt;&lt; "7) bind to a pointer to data member: ";
    auto f5 = std::bind(&amp;Foo::data, _1);
    std::cout &lt;&lt; f5(foo) &lt;&lt; '\n';
 
    std::cout &lt;&lt; "8) bind to a mem_fn that is a pointer to data member: ";
    auto ptr_to_data = std::mem_fn(&amp;Foo::data);
    auto f6 = std::bind(ptr_to_data, _1);
    std::cout &lt;&lt; f6(foo) &lt;&lt; '\n';
 
    std::cout &lt;&lt; "9) use smart pointers to call members of the referenced objects: ";
    std::cout &lt;&lt; f6(std::make_shared&lt;Foo&gt;(foo)) &lt;&lt; ' '
              &lt;&lt; f6(std::make_unique&lt;Foo&gt;(foo)) &lt;&lt; '\n';
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">1) argument reordering and pass-by-reference: 2 42 1 10 7
2) achieving the same effect using a lambda: 2 42 1 10 7
3) nested bind subexpressions share the placeholders: 12 12 12 4 5
4) bind a RNG with a distribution: 0 1 8 5 5 2 0 7 7 10 
5) bind to a pointer to member function: 100
6) bind to a mem_fn that is a pointer to member function: 100
7) bind to a pointer to data member: 10
8) bind to a mem_fn that is a pointer to data member: 10
9) use smart pointers to call members of the referenced objects: 10 10</pre></div> </div> <h3 id="See_also"> See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="bind_front" title="cpp/utility/functional/bind front"> <span class="t-lines"><span>bind_front</span><span>bind_back</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> bind a variable number of arguments, in order, to a function object <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="placeholders" title="cpp/utility/functional/placeholders"> <span class="t-lines"><span>_1, _2, _3, _4, ...</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> placeholders for the unbound arguments in a <code>std::bind</code> expression <br> <span class="t-mark">(constant)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="mem_fn" title="cpp/utility/functional/mem fn"> <span class="t-lines"><span>mem_fn</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> creates a function object out of a pointer to a member <br> <span class="t-mark">(function template)</span>  </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    © cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/utility/functional/bind" class="_attribution-link">https://en.cppreference.com/w/cpp/utility/functional/bind</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
