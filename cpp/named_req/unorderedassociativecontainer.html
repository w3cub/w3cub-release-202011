
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Named Requirements&#58; UnorderedAssociativeContainer - C++ - W3cubDocs</title>
  
  <meta name="description" content="Unordered associative containers are Containers that provide fast lookup of objects based on keys. Worst case complexity is linear but on average &hellip;">
  <meta name="keywords" content="c++, named, requirements, unorderedassociativecontainer, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/named_req/unorderedassociativecontainer.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-9c7b0d969c0ce639a6c01c2badcdd81667c7c66206aa3d0fccc5cb0585fb1b912dab72ea882101d18010680927514b4b77b107282db8f756fbf63301fe9c88b0.css">
  <script type="text/javascript" src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js"></script>
  <script src="/json/cpp.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _cppref">
				
				
<h1 id="firstHeading" class="firstHeading">C++ named requirements: UnorderedAssociativeContainer <span class="t-mark-rev t-since-cxx11">(since C++11)</span>
</h1>            <p>Unordered associative containers are <a href="container" title="cpp/named req/Container">Containers</a> that provide fast lookup of objects based on keys. Worst case complexity is linear but on average much faster for most of the operations.</p>
<p>Unordered associative containers are parametrized by <code>Key</code>; <code>Hash</code>, a <a href="hash" title="cpp/named req/Hash">Hash</a> function object which acts as hash function on <code>Key</code>; and <code>Pred</code>, a <a href="binarypredicate" title="cpp/named req/BinaryPredicate">BinaryPredicate</a> evaluating equivalence between <code>Key</code>s. <code><a href="http://en.cppreference.com/w/cpp/container/unordered_map"><span class="kw1297">std::<span class="me2">unordered_map</span></span></a></code> and <code><a href="http://en.cppreference.com/w/cpp/container/unordered_multimap"><span class="kw1299">std::<span class="me2">unordered_multimap</span></span></a></code> also have a mapped type <code>T</code> associated with the <code>Key</code>.</p>
<p>If two <code>Key</code>s are equal according to <code>Pred</code>, <code>Hash</code> must return the same value for both keys.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>If both <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> exist and each names a type, member functions <code>find</code>, <code>contains</code>, <code>count</code>, and <code>equal_range</code> accept arguments of types other than <code>Key</code> and expect that <code>Hash</code> is callable with values of those types, and that <code>Pred</code> is a transparent comparison function such as <code>std::equal_to&lt;&gt;</code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <p><code><a href="http://en.cppreference.com/w/cpp/container/unordered_map"><span class="kw1297">std::<span class="me2">unordered_map</span></span></a></code> and <code><a href="http://en.cppreference.com/w/cpp/container/unordered_set"><span class="kw1293">std::<span class="me2">unordered_set</span></span></a></code> can contain at most one element with a given key, <code><a href="http://en.cppreference.com/w/cpp/container/unordered_multiset"><span class="kw1295">std::<span class="me2">unordered_multiset</span></span></a></code> and <code><a href="http://en.cppreference.com/w/cpp/container/unordered_multimap"><span class="kw1299">std::<span class="me2">unordered_multimap</span></span></a></code> instead can have multiple elements with the same key (which must always be adjacent on iterations).</p>
<p>For <code><a href="http://en.cppreference.com/w/cpp/container/unordered_set"><span class="kw1293">std::<span class="me2">unordered_set</span></span></a></code> and <code><a href="http://en.cppreference.com/w/cpp/container/unordered_multiset"><span class="kw1295">std::<span class="me2">unordered_multiset</span></span></a></code> the value type is the same as the key type and both <code>iterator</code> and <code>const_iterator</code> are constant iterators. For <code><a href="http://en.cppreference.com/w/cpp/container/unordered_map"><span class="kw1297">std::<span class="me2">unordered_map</span></span></a></code> and <code><a href="http://en.cppreference.com/w/cpp/container/unordered_multimap"><span class="kw1299">std::<span class="me2">unordered_multimap</span></span></a></code> the value type is <code><a href="http://en.cppreference.com/w/cpp/utility/pair"><span class="kw1100">std::<span class="me2">pair</span></span></a><span class="sy1">&lt;</span><span class="kw4">const</span> Key, T<span class="sy1">&gt;</span></code>.</p>
<p>Elements in an unordered associative container are organized into buckets, keys with the same hash will end up in the same bucket. The number of buckets is increased when the size of the container increases to keep the average number of elements in each bucket under a certain value.</p>
<p>Rehashing invalidates iterator and might cause the elements to be re-arranged in different buckets but it doesn't invalidate references to the elements.</p>
<p>Unordered associative containers meet the requirements of <a href="allocatorawarecontainer" title="cpp/named req/AllocatorAwareContainer">AllocatorAwareContainer</a>. For <code><a href="http://en.cppreference.com/w/cpp/container/unordered_map"><span class="kw1297">std::<span class="me2">unordered_map</span></span></a></code> and <code><a href="http://en.cppreference.com/w/cpp/container/unordered_multimap"><span class="kw1299">std::<span class="me2">unordered_multimap</span></span></a></code> the requirements of <code>value_type</code> in <a href="allocatorawarecontainer" title="cpp/named req/AllocatorAwareContainer">AllocatorAwareContainer</a> apply to <code>key_type</code> and <code>mapped_type</code> (not to <code>value_type</code>).</p>
<h3 id="Requirements"> Requirements</h3> <table class="t-dsc-begin"> <tr> <td colspan="2"> <h5 id="Legend">  Legend </h5> </td>
</tr> <tr class="t-dsc"> <td> <code>X</code> </td> <td> An unordered associative container class </td>
</tr> <tr class="t-dsc"> <td> <code>a</code> </td> <td> A value of type <code>X</code> </td>
</tr> <tr class="t-dsc"> <td> <code>a2</code> </td> <td> A value of a type with <a href="../container/node_handle" title="cpp/container/node handle">nodes compatible with type</a> <code>X</code> </td>
</tr> <tr class="t-dsc"> <td> <code>b</code> </td> <td> A value of type <code>X</code> or <code>const X</code> </td>
</tr> <tr class="t-dsc"> <td> <code>a_uniq</code> </td> <td> A value of type <code>X</code> when <code>X</code> supports unique keys </td>
</tr> <tr class="t-dsc"> <td> <code>a_eq</code> </td> <td> A value of type <code>X</code> when <code>X</code> supports equivalent keys </td>
</tr> <tr class="t-dsc"> <td> <code>a_tran</code> </td> <td> A value of type <code>X</code> or <code>const X</code> when the <span class="t-spar">qualified-id</span>s <code>X::key_equal::is_transparent</code> and <code>X::hasher::is_transparent</code> are both valid and denote <a href="../language/template_argument_deduction" title="cpp/language/template argument deduction">types</a> </td>
</tr> <tr class="t-dsc"> <td> <code>i</code>, <code>j</code> </td> <td> Input iterators that refer to <code>value_type</code> </td>
</tr> <tr class="t-dsc"> <td> <code>[</code><code>i</code><code>, </code><code>j</code><code>)</code> </td> <td> A valid range </td>
</tr> <tr class="t-dsc"> <td> <code>rg</code> <span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td> <td> A value of a type <code>R</code> that models <code><a href="../ranges/to#container_compatible_range" title="cpp/ranges/to">container-compatible-range</a>&lt;value_type&gt;</code> </td>
</tr> <tr class="t-dsc"> <td> <code>p</code>, <code>q2</code> </td> <td> Valid constant iterators to <code>a</code> </td>
</tr> <tr class="t-dsc"> <td> <code>q</code>, <code>q1</code> </td> <td> Valid dereferenceable constant iterators to <code>a</code> </td>
</tr> <tr class="t-dsc"> <td> <code>r</code> </td> <td> A valid dereferenceable iterator to <code>a</code> </td>
</tr> <tr class="t-dsc"> <td> <code>[</code><code>q1</code><code>, </code><code>q2</code><code>)</code> </td> <td> A valid range in <code>a</code> </td>
</tr> <tr class="t-dsc"> <td> <code>il</code> </td> <td> A value of type <code><a href="http://en.cppreference.com/w/cpp/utility/initializer_list"><span class="kw962">std::<span class="me2">initializer_list</span></span></a><span class="sy1">&lt;</span>value_type<span class="sy1">&gt;</span></code> </td>
</tr> <tr class="t-dsc"> <td> <code>t</code> </td> <td> A value of type <code>X::value_type</code> </td>
</tr> <tr class="t-dsc"> <td> <code>k</code> </td> <td> A value of type <code>key_type</code> </td>
</tr> <tr class="t-dsc"> <td> <code>hf</code> </td> <td> A value of type <code>hasher</code> or <code>const hasher</code> </td>
</tr> <tr class="t-dsc"> <td> <code>eq</code> </td> <td> A value of type <code>key_equal</code> or <code>const key_equal</code> </td>
</tr> <tr class="t-dsc"> <td> <code>ke</code> </td> <td> A value such that <ul>
<li> <code>eq(r1, ke) == eq(ke, r1)</code>, </li>
<li> <code>hf(r1) == hf(ke)</code> if <code>eq(r1, ke)</code> is <code>true</code>, and </li>
<li> if any two of <code>eq(r1, ke)</code>, <code>eq(r2, ke)</code>, and <code>eq(r1, r2)</code> are <code>true</code>, then all three are <code>true</code>, </li>
</ul> <p>where <code>r1</code> and <code>r2</code> are keys of elements in <code>a_tran</code>.</p>
</td>
</tr> <tr class="t-dsc"> <td> <code>kx</code> <span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td> <td> A value such that <ul>
<li> <code>eq(r1, kx) == eq(kx, r1)</code>, </li>
<li> <code>hf(r1) == hf(kx)</code> if <code>eq(r1, kx)</code> is <code>true</code>, </li>
<li> if any two of <code>eq(r1, kx)</code>, <code>eq(r2, kx)</code>, and <code>eq(r1, r2)</code> are <code>true</code>, then all three are <code>true</code>, and </li>
<li> <code>kx</code> is not convertible to either <code>iterator</code> or <code>const_iterator</code>, </li>
</ul> <p>where <code>r1</code> and <code>r2</code> are keys of elements in <code>a_tran</code>.</p>
</td>
</tr> <tr class="t-dsc"> <td> <code>n</code> </td> <td> A value of type <code>size_type</code> </td>
</tr> <tr class="t-dsc"> <td> <code>z</code> </td> <td> A value of type <code>float</code> </td>
</tr> <tr class="t-dsc"> <td> <code>nh</code> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> <td> An rvalue of type <code>X::node_type</code> </td>
</tr> </table> <h4 id="Types"> Types</h4> <table class="wikitable"> <tr> <th>Name</th> <th>Type</th> <th>Requirements</th> <th>Notes </th>
</tr> <tr> <td>
<code>X::key_type</code> </td> <td>
<code>Key</code> </td> <td> </td> <td> </td>
</tr> <tr> <td>
<code>X::mapped_type</code> </td> <td>
<code>T</code> </td> <td>
<code><a href="http://en.cppreference.com/w/cpp/container/unordered_map"><span class="kw1297">std::<span class="me2">unordered_map</span></span></a></code> and <code><a href="http://en.cppreference.com/w/cpp/container/unordered_multimap"><span class="kw1299">std::<span class="me2">unordered_multimap</span></span></a></code> only </td> <td> </td>
</tr> <tr> <td rowspan="2">
<code>X::value_type</code> </td> <td>
<code>Key</code> </td> <td>
<code><a href="http://en.cppreference.com/w/cpp/container/unordered_set"><span class="kw1293">std::<span class="me2">unordered_set</span></span></a></code> and <code><a href="http://en.cppreference.com/w/cpp/container/unordered_multiset"><span class="kw1295">std::<span class="me2">unordered_multiset</span></span></a></code> only. <a href="erasable" title="cpp/named req/Erasable">Erasable</a> in <code>X</code> </td> <td> </td>
</tr> <tr> <td>
<code><a href="http://en.cppreference.com/w/cpp/utility/pair"><span class="kw1100">std::<span class="me2">pair</span></span></a><span class="sy1">&lt;</span><span class="kw4">const</span> Key, T<span class="sy1">&gt;</span></code> </td> <td>
<code><a href="http://en.cppreference.com/w/cpp/container/unordered_map"><span class="kw1297">std::<span class="me2">unordered_map</span></span></a></code> and <code><a href="http://en.cppreference.com/w/cpp/container/unordered_multimap"><span class="kw1299">std::<span class="me2">unordered_multimap</span></span></a></code> only. <a href="erasable" title="cpp/named req/Erasable">Erasable</a> in <code>X</code> </td> <td> </td>
</tr> <tr> <td>
<code>X::hasher</code> </td> <td>
<code>Hash</code> </td> <td>
<a href="hash" title="cpp/named req/Hash">Hash</a> </td> <td> </td>
</tr> <tr> <td>
<code>X::key_equal</code> </td> <td>
<code>Pred</code> </td> <td>
<a href="copyconstructible" title="cpp/named req/CopyConstructible">CopyConstructible</a>; <a href="binarypredicate" title="cpp/named req/BinaryPredicate">BinaryPredicate</a> that takes two arguments of type <code>Key</code> and expresses an equivalence relation </td> <td> </td>
</tr> <tr> <td>
<code>X::local_iterator</code> </td> <td>
<a href="iterator" title="cpp/named req/Iterator">LegacyIterator</a> </td> <td>Category and types are the same as <code>X::iterator</code> </td> <td rowspan="2">Can be used to iterate through a single bucket, but not across buckets </td>
</tr> <tr> <td>
<code>X::const_local_iterator</code> </td> <td>
<a href="iterator" title="cpp/named req/Iterator">LegacyIterator</a> </td> <td>Category and types are the same as <code>X::const_iterator</code> </td>
</tr> <tr> <td>
<code>X::node_type</code> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> <td>A specialization of <a href="../container/node_handle" title="cpp/container/node handle">node-handle</a> class template </td> <td>The public nested types are the same as the corresponding types in <code>X</code> </td> <td> </td>
</tr>
</table> <h4 id="Member_functions_and_operators"> Member functions and operators</h4> <table class="wikitable"> <tr> <th>Expression</th> <th>Result</th> <th>Preconditions</th> <th>Effects</th> <th>Returns</th> <th>Complexity </th>
</tr> <tr> <td>
<code>X(n, hf, eq)</code> </td> <td> </td> <td> </td> <td>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function and <code>eq</code> as the key equality predicate </td> <td> </td> <td>O(<code>n</code>) </td>
</tr> <tr> <td>
<code>X(n, hf)</code> </td> <td> </td> <td>
<code>key_equal</code> is <a href="defaultconstructible" title="cpp/named req/DefaultConstructible">DefaultConstructible</a> </td> <td>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function and <code>key_equal()</code> as the key equality predicate </td> <td> </td> <td>O(<code>n</code>) </td>
</tr> <tr> <td>
<code>X(n)</code> </td> <td> </td> <td>
<code>hasher</code> and <code>key_equal</code> are <a href="defaultconstructible" title="cpp/named req/DefaultConstructible">DefaultConstructible</a> </td> <td>Constructs an empty container with at least <code>n</code> buckets, using <code>hasher()</code> as the hash function and <code>key_equal()</code> as the key equality predicate </td> <td> </td> <td>O(<code>n</code>) </td>
</tr> <tr> <td>
<code>X a = X();</code><br><code>X a;</code> </td> <td> </td> <td>
<code>hasher</code> and <code>key_equal</code> are <a href="defaultconstructible" title="cpp/named req/DefaultConstructible">DefaultConstructible</a> </td> <td>Constructs an empty container with an unspecified number of buckets, using <code>hasher()</code> as the hash function and <code>key_equal()</code> as the key equality predicate </td> <td> </td> <td>Constant </td>
</tr> <tr> <td>
<code>X(i, j, n, hf, eq)</code> </td> <td> </td> <td>
<code>value_type</code> is <a href="emplaceconstructible" title="cpp/named req/EmplaceConstructible">EmplaceConstructible</a> into <code>X</code> from <code>*i</code> </td> <td>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function and <code>eq</code> as the key equality predicate, and inserts elements from <code>[</code><code>i</code><code>, </code><code>j</code><code>)</code> into it </td> <td> </td> <td>Average case O(N) (N is <code><a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">std::<span class="me2">distance</span></span></a><span class="br0">(</span>i, j<span class="br0">)</span></code>), worst case O(N<sup>2</sup>) </td>
</tr> <tr> <td>
<code>X(i, j, n, hf)</code> </td> <td> </td> <td>
<code>key_equal</code> is the <a href="defaultconstructible" title="cpp/named req/DefaultConstructible">DefaultConstructible</a>. <code>value_type</code> is <a href="emplaceconstructible" title="cpp/named req/EmplaceConstructible">EmplaceConstructible</a> into <code>X</code> from <code>*i</code> </td> <td>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function and <code>key_equal()</code> as the key equality predicate, and inserts elements from <code>[</code><code>i</code><code>, </code><code>j</code><code>)</code> into it </td> <td> </td> <td>Average case O(N) (N is <code><a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">std::<span class="me2">distance</span></span></a><span class="br0">(</span>i, j<span class="br0">)</span></code>), worst case O(N<sup>2</sup>) </td>
</tr> <tr> <td>
<code>X(i, j, n)</code> </td> <td> </td> <td>
<code>hasher</code> and <code>key_equal</code> are <a href="defaultconstructible" title="cpp/named req/DefaultConstructible">DefaultConstructible</a>. <code>value_type</code> is <a href="emplaceconstructible" title="cpp/named req/EmplaceConstructible">EmplaceConstructible</a> into <code>X</code> from <code>*i</code> </td> <td>Constructs an empty container with at least <code>n</code> buckets, using <code>hasher()</code> as the hash function and <code>key_equal()</code> as the key equality predicate, and inserts elements from <code>[</code><code>i</code><code>, </code><code>j</code><code>)</code> into it </td> <td> </td> <td>Average case O(N) (N is <code><a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">std::<span class="me2">distance</span></span></a><span class="br0">(</span>i, j<span class="br0">)</span></code>), worst case O(N<sup>2</sup>) </td>
</tr> <tr> <td>
<code>X(i, j)</code> </td> <td> </td> <td>
<code>hasher</code> and <code>key_equal</code> are <a href="defaultconstructible" title="cpp/named req/DefaultConstructible">DefaultConstructible</a>. <code>value_type</code> is <a href="emplaceconstructible" title="cpp/named req/EmplaceConstructible">EmplaceConstructible</a> into <code>X</code> from <code>*i</code> </td> <td>Constructs an empty container with an unspecified number of buckets, using <code>hasher()</code> as the hash function and <code>key_equal()</code> as the key equality predicate, and inserts elements from <code>[</code><code>i</code><code>, </code><code>j</code><code>)</code> into it </td> <td> </td> <td>Average case O(N) (N is <code><a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">std::<span class="me2">distance</span></span></a><span class="br0">(</span>i, j<span class="br0">)</span></code>), worst case O(N<sup>2</sup>) </td>
</tr> <tr> <td>
<code>X(std::from_range, rg, n, hf, eq)</code><br><span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td> <td> </td> <td>
<code>value_type</code> is <a href="emplaceconstructible" title="cpp/named req/EmplaceConstructible">EmplaceConstructible</a> into <code>X</code> from <code><span class="sy2">*</span><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2886">ranges::<span class="me2">begin</span></span></a><span class="br0">(</span>rg<span class="br0">)</span></code> </td> <td>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function and <code>eq</code> as the key equality predicate, and inserts elements from <code>rg</code> into it </td> <td> </td> <td>Average case O(N) (N is <code><a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3146">ranges::<span class="me2">distance</span></span></a><span class="br0">(</span>rg<span class="br0">)</span></code>), worst case O(N<sup>2</sup>) </td>
</tr> <tr> <td>
<code>X(std::from_range, rg, n, hf)</code><br><span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td> <td> </td> <td>
<code>key_equal</code> is <a href="defaultconstructible" title="cpp/named req/DefaultConstructible">DefaultConstructible</a>. <code>value_type</code> is <a href="emplaceconstructible" title="cpp/named req/EmplaceConstructible">EmplaceConstructible</a> into <code>X</code> from <code><span class="sy2">*</span><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2886">ranges::<span class="me2">begin</span></span></a><span class="br0">(</span>rg<span class="br0">)</span></code> </td> <td>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function and <code>key_equal()</code> as the key equality predicate, and inserts elements from <code>rg</code> into it </td> <td> </td> <td>Average case O(N) (N is <code><a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3146">ranges::<span class="me2">distance</span></span></a><span class="br0">(</span>rg<span class="br0">)</span></code>), worst case O(N<sup>2</sup>) </td>
</tr> <tr> <td>
<code>X(std::from_range, rg, n)</code><br><span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td> <td> </td> <td>
<code>hasher</code> and <code>key_equal</code> are <a href="defaultconstructible" title="cpp/named req/DefaultConstructible">DefaultConstructible</a>. <code>value_type</code> is <a href="emplaceconstructible" title="cpp/named req/EmplaceConstructible">EmplaceConstructible</a> into <code>X</code> from <code><span class="sy2">*</span><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2886">ranges::<span class="me2">begin</span></span></a><span class="br0">(</span>rg<span class="br0">)</span></code> </td> <td>Constructs an empty container with at least <code>n</code> buckets, using <code>hasher()</code> as the hash function and <code>key_equal()</code> as the key equality predicate, and inserts elements from <code>rg</code> into it </td> <td> </td> <td>Average case O(N) (N is <code><a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3146">ranges::<span class="me2">distance</span></span></a><span class="br0">(</span>rg<span class="br0">)</span></code>), worst case O(N<sup>2</sup>) </td>
</tr> <tr> <td>
<code>X(std::from_range, rg)</code><br><span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td> <td> </td> <td>
<code>hasher</code> and <code>key_equal</code> are <a href="defaultconstructible" title="cpp/named req/DefaultConstructible">DefaultConstructible</a>. <code>value_type</code> is <a href="emplaceconstructible" title="cpp/named req/EmplaceConstructible">EmplaceConstructible</a> into <code>X</code> from <code><span class="sy2">*</span><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2886">ranges::<span class="me2">begin</span></span></a><span class="br0">(</span>rg<span class="br0">)</span></code> </td> <td>Constructs an empty container with an unspecified number of buckets, using <code>hasher()</code> as the hash function and <code>key_equal()</code> as the key equality predicate, and inserts elements from <code>rg</code> into it </td> <td> </td> <td>Average case O(N) (N is <code><a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3146">ranges::<span class="me2">distance</span></span></a><span class="br0">(</span>rg<span class="br0">)</span></code>), worst case O(N<sup>2</sup>) </td>
</tr> <tr> <td>
<code>X(il)</code> </td> <td> </td> <td> </td> <td>
<code>X(il.begin(), il.end())</code> </td> <td> </td> <td> </td>
</tr> <tr> <td>
<code>X(il, n)</code> </td> <td> </td> <td> </td> <td>
<code>X(il.begin(), il.end(), n)</code> </td> <td> </td> <td> </td>
</tr> <tr> <td>
<code>X(il, n, hf)</code> </td> <td> </td> <td> </td> <td>
<code>X(il.begin(), il.end(), n, hf)</code> </td> <td> </td> <td> </td>
</tr> <tr> <td>
<code>X(il, n, hf, eq)</code> </td> <td> </td> <td> </td> <td>
<code>X(il.begin(), il.end(), n, hf, eq)</code> </td> <td> </td> <td> </td>
</tr> <tr> <td>
<code>X(b)</code> </td> <td> </td> <td> </td> <td>
<a href="container" title="cpp/named req/Container">Container</a>; Copies the hash function, predicate, and maximum load factor </td> <td> </td> <td>Average case linear in <code>b.size()</code>, worst case O(N<sup>2</sup>) </td>
</tr> <tr> <td>
<code>a = b</code> </td> <td>
<code>X&amp;</code> </td> <td> </td> <td>
<a href="container" title="cpp/named req/Container">Container</a>; copies the hash function, predicate, and maximum load factor </td> <td> </td> <td>Average case linear in <code>b.size()</code>, worst case O(N<sup>2</sup>) </td>
</tr> <tr> <td>
<code>a = il</code> </td> <td>
<code>X&amp;</code> </td> <td>
<code>value_type</code> is <a href="copyinsertable" title="cpp/named req/CopyInsertable">CopyInsertable</a> into <code>X</code> and <a href="copyassignable" title="cpp/named req/CopyAssignable">CopyAssignable</a> </td> <td>Assigns the range <code>[</code><code>il.begin()</code><code>, </code><code>il.end()</code><code>)</code> into <code>a</code>. All existing elements of <code>a</code> are either assigned to or destroyed </td> <td> </td> <td>Average case linear in <code>il.size()</code>, worst case O(N<sup>2</sup>) </td>
</tr> <tr> <td>
<code>b.hash_function()</code> </td> <td>
<code>hasher</code> </td> <td> </td> <td> </td> <td>
<code>b</code>'s hash function </td> <td>Constant </td>
</tr> <tr> <td>
<code>b.key_eq()</code> </td> <td>
<code>key_equal</code> </td> <td> </td> <td> </td> <td>
<code>b</code>'s key equality predicate </td> <td>Constant </td>
</tr> <tr> <td>
<code>a_uniq.emplace(args)</code> </td> <td>
<code><a href="http://en.cppreference.com/w/cpp/utility/pair"><span class="kw1100">std::<span class="me2">pair</span></span></a><span class="sy1">&lt;</span><br> iterator,<br> bool&gt;</code> </td> <td>
<code>value_type</code> is <a href="emplaceconstructible" title="cpp/named req/EmplaceConstructible">EmplaceConstructible</a> into <code>X</code> from <code>args</code> </td> <td>Inserts a <code>value_type</code> object <code>t</code> constructed with <code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1121">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>Args<span class="sy1">&gt;</span><span class="br0">(</span>args<span class="br0">)</span>...</code> if and only if there is no element in the container with key equivalent to the key of <code>t</code> </td> <td>The <code>bool</code> component of the returned pair is <code>true</code> if and only if the insertion takes place, and the iterator component of the pair points to the element with key equivalent to the key of <code>t</code> </td> <td>Average case O(1), worst case O(<code>a_uniq.size()</code>) </td>
</tr> <tr> <td>
<code>a_eq.emplace(args)</code> </td> <td>
<code>iterator</code> </td> <td>
<code>value_type</code> is <a href="emplaceconstructible" title="cpp/named req/EmplaceConstructible">EmplaceConstructible</a> into <code>X</code> from <code>args</code> </td> <td>Inserts a <code>value_type</code> object <code>t</code> constructed with <code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1121">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>Args<span class="sy1">&gt;</span><span class="br0">(</span>args<span class="br0">)</span>...</code> </td> <td>An iterator pointing to the newly inserted element </td> <td>Average case O(1), worst case O(<code>a_eq.size()</code>) </td>
</tr> <tr> <td>
<code>a.emplace_hint(p, args)</code> </td> <td>
<code>iterator</code> </td> <td>
<code>value_type</code> is <a href="emplaceconstructible" title="cpp/named req/EmplaceConstructible">EmplaceConstructible</a> into <code>X</code> from <code>args</code> </td> <td>
<code>a.emplace(<br> <a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1121">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>Args<span class="sy1">&gt;</span><span class="br0">(</span>args<span class="br0">)</span>...<span class="br0">)</span></code> </td> <td>An iterator pointing to the element with the key equivalent to the newly inserted element. The <code>const_iterator</code> <code>p</code> is a hint pointing to where the search should start. Implementations are permitted to ignore the hint </td> <td>Average case O(1), worst case O(<code>a.size()</code>) </td>
</tr> <tr> <td>
<code>a_uniq.insert(t)</code> </td> <td>
<code><a href="http://en.cppreference.com/w/cpp/utility/pair"><span class="kw1100">std::<span class="me2">pair</span></span></a><span class="sy1">&lt;</span><br> iterator,<br> bool&gt;</code> </td> <td>If <code>t</code> is a non-const rvalue, <code>value_type</code> is <a href="moveinsertable" title="cpp/named req/MoveInsertable">MoveInsertable</a> into <code>X</code>; otherwise, <code>value_type</code> is <a href="copyinsertable" title="cpp/named req/CopyInsertable">CopyInsertable</a> into <code>X</code> </td> <td>Inserts <code>t</code> if and only if there is no element in the container with key equivalent to the key of <code>t</code> </td> <td>The <code>bool</code> component of the returned pair indicates whether the insertion takes place, and the <code>iterator</code> component points to the element with key equivalent to the key of <code>t</code> </td> <td>Average case O(1), worst case O(<code>a_uniq.size()</code>) </td>
</tr> <tr> <td>
<code>a_eq.insert(t)</code> </td> <td>
<code>iterator</code> </td> <td>If <code>t</code> is a non-const rvalue, <code>value_type</code> is <a href="moveinsertable" title="cpp/named req/MoveInsertable">MoveInsertable</a> into <code>X</code>; otherwise, <code>value_type</code> is <a href="copyinsertable" title="cpp/named req/CopyInsertable">CopyInsertable</a> into <code>X</code> </td> <td>Inserts <code>t</code> </td> <td>An iterator pointing to the newly inserted element </td> <td>Average case O(1), worst case O(<code>a_eq.size()</code>) </td>
</tr> <tr> <td>
<code>a.insert(p, t)</code> </td> <td>
<code>iterator</code> </td> <td>If <code>t</code> is a non-const rvalue, <code>value_type</code> is <a href="moveinsertable" title="cpp/named req/MoveInsertable">MoveInsertable</a> into <code>X</code>; otherwise, <code>value_type</code> is <a href="copyinsertable" title="cpp/named req/CopyInsertable">CopyInsertable</a> into <code>X</code> </td> <td>
<code>a.insert(t)</code>. The iterator <code>p</code> is a hint pointing to where the search should start. Implementations are permitted to ignore the hint </td> <td>An iterator pointing to the element with the key equivalent to that of <code>t</code> </td> <td>Average case O(1), worst case O(<code>a.size()</code>) </td>
</tr> <tr> <td>
<code>a.insert(i, j)</code> </td> <td>
<code>void</code> </td> <td>
<code>value_type</code> is <a href="emplaceconstructible" title="cpp/named req/EmplaceConstructible">EmplaceConstructible</a> into <code>X</code> from <code>*i</code>. Neither <code>i</code> nor <code>j</code> are iterators into <code>a</code> </td> <td>
<code>a.insert(t)</code> for each element in<br><code>[</code><code>i</code><code>, </code><code>j</code><code>)</code> </td> <td> </td> <td>Average case O(N), where N is <code><a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">std::<span class="me2">distance</span></span></a><span class="br0">(</span>i, j<span class="br0">)</span></code>, worst case O(<code>N·(a.size() + 1)</code>) </td>
</tr> <tr> <td>
<code>a.insert_range(rg)</code><br><span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td> <td>
<code>void</code> </td> <td>
<code>value_type</code> is <a href="emplaceconstructible" title="cpp/named req/EmplaceConstructible">EmplaceConstructible</a> into <code>X</code> from <code><span class="sy2">*</span><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2886">ranges::<span class="me2">begin</span></span></a><span class="br0">(</span>rg<span class="br0">)</span></code>. <code>rg</code> and <code>a</code> do not overlap </td> <td>
<code>a.insert(t)</code> for each element <code>t</code> in <code>rg</code> </td> <td> </td> <td>Average case O(N), where N is <code><a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3146">ranges::<span class="me2">distance</span></span></a><span class="br0">(</span>rg<span class="br0">)</span></code>, worst case O(<code>N·(a.size() + 1)</code>) </td>
</tr> <tr> <td>
<code>a.insert(il)</code> </td> <td> </td> <td> </td> <td>
<code>a.insert(il.begin(), il.end())</code> </td> <td> </td> <td> </td>
</tr> <tr> <td>
<code>a_uniq.insert(nh)</code><br><span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> <td>
<code>insert_return_type</code> </td> <td>
<code>nh</code> is empty or <p><code>a_uniq.get_allocator()==nh.get_allocator()</code> is <code>true</code>.</p>
</td> <td>If <code>nh</code> is empty, has no effect. Otherwise, inserts the element owned by <code>nh</code> if and only if there is no element in the container with a key equivalent to <code>nh.key()</code>. Ensures: If <code>nh</code> is empty, <code>inserted</code> is <code>false</code>, <code>position</code> is <code>end()</code>, and <code>node</code> is empty. Otherwise if the insertion took place, <code>inserted</code> is <code>true</code>, <code>position</code> points to the inserted element, and <code>node</code> is empty; if the insertion failed, <code>inserted</code> is <code>false</code>, <code>node</code> has the previous value of <code>nh</code>, and <code>position</code> points to an element with a key equivalent to <code>nh.key()</code> </td> <td> </td> <td>Average case O(1), worst case O(<code>a_uniq.size()</code>) </td>
</tr> <tr> <td>
<code>a_eq.insert(nh)</code><br><span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> <td>
<code>iterator</code> </td> <td>
<code>nh</code> is empty or <p><code>a_eq.get_allocator()==nh.get_allocator()</code> is <code>true</code>.</p>
</td> <td>If <code>nh</code> is empty, has no effect and returns <code>a_eq.end()</code>. Otherwise, inserts the element owned by <code>nh</code> and returns an iterator pointing to the newly inserted element. Ensures: <code>nh</code> is empty </td> <td> </td> <td>Average case O(1), worst case O(<code>a_eq.size()</code>) </td>
</tr> <tr> <td>
<code>a.insert(q, nh)</code><br><span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> <td>
<code>iterator</code> </td> <td>
<code>nh</code> is empty or <p><code>a.get_allocator()==nh.get_allocator()</code> is <code>true</code>.</p>
</td> <td>If <code>nh</code> is empty, has no effect and returns <code>a.end()</code>. Otherwise, inserts the element owned by <code>nh</code> if and only if there is no element with key equivalent to <code>nh.key()</code> in containers with unique keys; always inserts the element owned by <code>nh</code> in containers with equivalent keys. The iterator <code>q</code> is a hint pointing to where the search should start. Implementations are permitted to ignore the hint. Ensures: <code>nh</code> is empty if insertion succeeds, unchanged if insertion fails </td> <td>An iterator pointing to the element with key equivalent to <code>nh.key()</code> </td> <td>Average case O(1), worst case O(<code>a.size()</code>) </td>
</tr> <tr> <td>
<code>a.extract(k)</code><br><span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> <td>
<code>node_type</code> </td> <td> </td> <td>Removes an element in the container with key equivalent to <code>k</code> </td> <td>A <code>node_type</code> owning the element if found, otherwise an empty <code>node_type</code> </td> <td>Average case O(1), worst case O(<code>a.size()</code>) </td>
</tr> <tr> <td>
<code>a_tran.extract(kx)</code><br><span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td> <td>
<code>node_type</code> </td> <td> </td> <td>Removes an element in the container with key equivalent to <code>kx</code> </td> <td>A <code>node_type</code> owning the element if found, otherwise an empty <code>node_type</code> </td> <td>Average case O(1), worst case O(<code>a_tran.size()</code>) </td>
</tr> <tr> <td>
<code>a.extract(q)</code><br><span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> <td>
<code>node_type</code> </td> <td> </td> <td>Removes the element pointed to by <code>q</code> </td> <td>A <code>node_type</code> owning that element </td> <td>Average case O(1), worst case O(<code>a.size()</code>) </td>
</tr> <tr> <td>
<code>a.merge(a2)</code><br><span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> <td>
<code>void</code> </td> <td>
<code>a.get_allocator()==a2.get_allocator()</code> </td> <td>Attempts to extract each element in <code>a2</code> and insert it into <code>a</code> using the hash function and key equality predicate of <code>a</code>. In containers with unique keys, if there is an element in <code>a</code> with key equivalent to the key of an element from <code>a2</code>, then that element is not extracted from <code>a2</code>. Ensures: Pointers and references to the transferred elements of <code>a2</code> refer to those same elements but as members of <code>a</code>. Iterators referring to the transferred elements and all iterators referring to <code>a</code> will be invalidated, but iterators to elements remaining in <code>a2</code> will remain valid </td> <td> </td> <td>Average case O(N), where N is <code>a2.size()</code>, worst case O(<code>N·(a.size() + 1)</code>) </td>
</tr> <tr> <td>
<code>a.erase(k)</code> </td> <td>
<code>size_type</code> </td> <td> </td> <td>Erases all elements with key equivalent to <code>k</code> </td> <td>The number of elements erased </td> <td>Average case O(<code>a.count(k)</code>), worst case O(<code>a.size()</code>) </td>
</tr> <tr> <td>
<code>a_tran.erase(kx)</code><br><span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td> <td>
<code>size_type</code> </td> <td> </td> <td>Erases all elements with key equivalent to <code>kx</code> </td> <td>The number of elements erased </td> <td>Average case O(<code>a_tran.count(kx)</code>), worst case O(<code>a_tran.size()</code>) </td>
</tr> <tr> <td>
<code>a.erase(q)</code> </td> <td>
<code>iterator</code> </td> <td> </td> <td>Erases the element pointed to by <code>q</code> </td> <td>The iterator immediately following <code>q</code> prior to the erasure </td> <td>Average case O(1), worst case O(<code>a.size()</code>) </td>
</tr> <tr> <td>
<code>a.erase(r)</code><br><span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> <td>
<code>iterator</code> </td> <td> </td> <td>Erases the element pointed to by <code>r</code> </td> <td>The iterator immediately following <code>r</code> prior to the erasure </td> <td>Average case O(1), worst case O(<code>a.size()</code>) </td>
</tr> <tr> <td>
<code>a.erase(q1, q2)</code> </td> <td>
<code>iterator</code> </td> <td> </td> <td>Erases all elements in the range<br><code>[</code><code>q1</code><code>, </code><code>q2</code><code>)</code> </td> <td>The iterator immediately following the erased elements prior to the erasure </td> <td>Average case linear in <code><a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">std::<span class="me2">distance</span></span></a><span class="br0">(</span>q1, q2<span class="br0">)</span></code>, worst case O(<code>a.size()</code>) </td>
</tr> <tr> <td>
<code>a.clear()</code> </td> <td>
<code>void</code> </td> <td> </td> <td>Erases all elements in the container. Ensures: <code>a.empty()</code> is <code>true</code> </td> <td> </td> <td>Linear in <code>a.size()</code> </td>
</tr> <tr> <td>
<code>b.find(k)</code> </td> <td>
<code>iterator</code>; <code>const_iterator</code> for constant <code>b</code> </td> <td> </td> <td> </td> <td>An iterator pointing to an element with key equivalent to <code>k</code>, or <code>b.end()</code> if no such element exists </td> <td>Average case O(1), worst case O(<code>b.size()</code>) </td>
</tr> <tr> <td>
<code>a_tran.find(ke)</code><br><span class="t-mark-rev t-since-cxx17">(since C++17)</span>? </td> <td>
<code>iterator</code>; <code>const_iterator</code> for constant <code>a_tran</code> </td> <td> </td> <td> </td> <td>An iterator pointing to an element with key equivalent to <code>ke</code>, or <code>a_tran.end()</code> if no such element exists </td> <td>Average case O(1), worst case O(<code>a_tran.size()</code>) </td>
</tr> <tr> <td>
<code>b.count(k)</code> </td> <td>
<code>size_type</code> </td> <td> </td> <td> </td> <td>The number of elements with key equivalent to <code>k</code> </td> <td>Average case O(<code>b.count(k)</code>), worst case O(<code>b.size()</code>) </td>
</tr> <tr> <td>
<code>a_tran.count(ke)</code><br><span class="t-mark-rev t-since-cxx17">(since C++17)</span>? </td> <td>
<code>size_type</code> </td> <td> </td> <td> </td> <td>The number of elements with key equivalent to <code>ke</code> </td> <td>Average case O(<code>a_tran.count(ke)</code>), worst case O(<code>a_tran.size()</code>) </td>
</tr> <tr> <td>
<code>b.contains(k)</code><br><span class="t-mark-rev t-since-cxx20">(since C++20)</span>? </td> <td> </td> <td> </td> <td>
<code>b.find(k) != b.end()</code> </td> <td> </td> <td> </td>
</tr> <tr> <td>
<code>a_tran.contains(ke)</code><br><span class="t-mark-rev t-since-cxx20">(since C++20)</span>? </td> <td> </td> <td> </td> <td>
<code>a_tran.find(ke) != a_tran.end()</code> </td> <td> </td> <td> </td>
</tr> <tr> <td>
<code>b.equal_range(k)</code> </td> <td>
<code><a href="http://en.cppreference.com/w/cpp/utility/pair"><span class="kw1100">std::<span class="me2">pair</span></span></a><span class="sy1">&lt;</span><br> iterator,<br> iterator&gt;</code>; <p><code><a href="http://en.cppreference.com/w/cpp/utility/pair"><span class="kw1100">std::<span class="me2">pair</span></span></a><span class="sy1">&lt;</span><br> const_iterator,<br> const_iterator&gt;</code> for constant <code>b</code>.</p>
</td> <td> </td> <td> </td> <td>A range containing all elements with keys equivalent to <code>k</code>. Returns <p><code><a href="http://en.cppreference.com/w/cpp/utility/pair/make_pair"><span class="kw1101">std::<span class="me2">make_pair</span></span></a><span class="br0">(</span><br> b.end(), b.end())</code> if no such elements exist.</p>
</td> <td>Average case O(<code>b.count(k)</code>), worst case O(<code>b.size()</code>) </td>
</tr> <tr> <td>
<code>a_tran.equal_range(ke)</code><br><span class="t-mark-rev t-since-cxx20">(since C++20)</span>? </td> <td>
<code><a href="http://en.cppreference.com/w/cpp/utility/pair"><span class="kw1100">std::<span class="me2">pair</span></span></a><span class="sy1">&lt;</span><br> iterator,<br> iterator&gt;</code>; <p><code><a href="http://en.cppreference.com/w/cpp/utility/pair"><span class="kw1100">std::<span class="me2">pair</span></span></a><span class="sy1">&lt;</span><br> const_iterator,<br> const_iterator&gt;</code> for constant <code>a_tran</code>.</p>
</td> <td> </td> <td> </td> <td>A range containing all elements with keys equivalent to <code>ke</code>. Returns <p><code><a href="http://en.cppreference.com/w/cpp/utility/pair/make_pair"><span class="kw1101">std::<span class="me2">make_pair</span></span></a><span class="br0">(</span><br> a_tran.end(),<br> a_tran.end())</code> if no such elements exist.</p>
</td> <td>Average case O(<code>a_tran.count(ke)</code>), worst case O(<code>a_tran.size()</code>) </td>
</tr> <tr> <td>
<code>b.bucket_count()</code> </td> <td>
<code>size_type</code> </td> <td> </td> <td> </td> <td>The number of buckets that <code>b</code> contains </td> <td>Constant </td>
</tr> <tr> <td>
<code>b.max_bucket_count()</code> </td> <td>
<code>size_type</code> </td> <td> </td> <td> </td> <td>An upper bound on the number of buckets that <code>b</code> can ever contain </td> <td>Constant </td>
</tr> <tr> <td>
<code>b.bucket(k)</code> </td> <td>
<code>size_type</code> </td> <td>
<code>b.bucket_count() &gt; 0</code> </td> <td> </td> <td>The index of the bucket in which elements with keys equivalent to <code>k</code> would be found, if any such element existed. The return value is in <code>[</code><code>​0​</code><code>, </code><code>b.bucket_count()</code><code>)</code> </td> <td>Constant </td>
</tr> <tr> <td>
<code>b.bucket_size(n)</code> </td> <td>
<code>size_type</code> </td> <td>
<code>n</code> is in <code>[</code><code>​0​</code><code>, </code><code>b.bucket_count()</code><code>)</code> </td> <td> </td> <td>The number of elements in the <code>n</code><sup>th</sup> bucket </td> <td>O(<code>b.bucket_size(n)</code>) </td>
</tr> <tr> <td>
<code>b.begin(n)</code> </td> <td>
<code>local_iterator</code>; <code>const_local_iterator</code> for constant <code>b</code> </td> <td>
<code>n</code> is in <code>[</code><code>​0​</code><code>, </code><code>b.bucket_count()</code><code>)</code> </td> <td> </td> <td>An iterator referring to the first element in the bucket. If the bucket is empty, then <code>b.begin(n) == b.end(n)</code> </td> <td>Constant </td>
</tr> <tr> <td>
<code>b.end(n)</code> </td> <td>
<code>local_iterator</code>; <code>const_local_iterator</code> for constant <code>b</code> </td> <td>
<code>n</code> is in <code>[</code><code>​0​</code><code>, </code><code>b.bucket_count()</code><code>)</code> </td> <td> </td> <td>An iterator which is the past-the-end value for the bucket </td> <td>Constant </td>
</tr> <tr> <td>
<code>b.cbegin(n)</code> </td> <td>
<code>const_local_iterator</code> </td> <td>
<code>n</code> is in <code>[</code><code>​0​</code><code>, </code><code>b.bucket_count()</code><code>)</code> </td> <td> </td> <td>An iterator referring to the first element in the bucket. If the bucket is empty, then <code>b.cbegin(n) == b.cend(n)</code> </td> <td>Constant </td>
</tr> <tr> <td>
<code>b.cend(n)</code> </td> <td>
<code>const_local_iterator</code> </td> <td>
<code>n</code> is in <code>[</code><code>​0​</code><code>, </code><code>b.bucket_count()</code><code>)</code> </td> <td> </td> <td>An iterator which is the past-the-end value for the bucket </td> <td>Constant </td>
</tr> <tr> <td>
<code>b.load_factor()</code> </td> <td>
<code>float</code> </td> <td> </td> <td> </td> <td>The average number of elements per bucket </td> <td>Constant </td>
</tr> <tr> <td>
<code>b.max_load_factor()</code> </td> <td>
<code>float</code> </td> <td> </td> <td> </td> <td>A positive number that the container attempts to keep the load factor less than or equal to. The container automatically increases the number of buckets as necessary to keep the load factor below this number </td> <td>Constant </td>
</tr> <tr> <td>
<code>a.max_load_factor(z)</code> </td> <td>
<code>void</code> </td> <td>
<code>z</code> is positive. May change the container's maximum load factor, using <code>z</code> as a hint </td> <td> </td> <td> </td> <td>Constant </td>
</tr> <tr> <td>
<code>a.rehash(n)</code> </td> <td>
<code>void</code> </td> <td> </td> <td>Ensures: <p><code>a.bucket_count() &gt;= a.size() / a.max_load_factor()</code> and <code>a.bucket_count() &gt;= n</code>.</p>
</td> <td> </td> <td>Average case linear in <code>a.size()</code>, worst case O(N<sup>2</sup>) </td>
</tr> <tr> <td>
<code>a.reserve(n)</code> </td> <td> </td> <td> </td> <td>
<code>a.<span class="me1">rehash</span><span class="br0">(</span><a href="http://en.cppreference.com/w/cpp/numeric/math/ceil"><span class="kw1354">std::<span class="me2">ceil</span></span></a><span class="br0">(</span><br> n / a.max_load_factor()))</code> </td> <td> </td> <td> </td>
</tr> </table>  <h3 id="Unordered_associative_containers_in_the_standard_library"> Unordered associative containers in the standard library</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../container/unordered_set" title="cpp/container/unordered set"> <span class="t-lines"><span>unordered_set</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> collection of unique keys, hashed by keys <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/unordered_multiset" title="cpp/container/unordered multiset"> <span class="t-lines"><span>unordered_multiset</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> collection of keys, hashed by keys <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/unordered_map" title="cpp/container/unordered map"> <span class="t-lines"><span>unordered_map</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> collection of key-value pairs, hashed by keys, keys are unique <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/unordered_multimap" title="cpp/container/unordered multimap"> <span class="t-lines"><span>unordered_multimap</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> collection of key-value pairs, hashed by keys <br> <span class="t-mark">(class template)</span>  </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    © cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/named_req/UnorderedAssociativeContainer" class="_attribution-link">https://en.cppreference.com/w/cpp/named_req/UnorderedAssociativeContainer</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
