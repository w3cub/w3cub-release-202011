
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Named Requirements&#58; UnorderedAssociativeContainer - C++ - W3cubDocs</title>
  
  <meta name="description" content="Unordered associative containers are Containers that provide fast lookup of objects based on keys. Worst case complexity is linear but on average &hellip;">
  <meta name="keywords" content="c++, named, requirements, unorderedassociativecontainer, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/named_req/unorderedassociativecontainer.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-1810d67ab7e57be09d8247710d2feb6954566959eb82322d1fee3a0c9156f56974b78ebaa9928774f00767342bbe58b0799d91fcc336b92b319170b196f9b64b.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/cpp.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _c">
				
				
<h1 id="firstHeading" class="firstHeading">C++ named requirements: UnorderedAssociativeContainer</h1>            <p>Unordered associative containers are <a href="container" title="cpp/named req/Container">Containers</a> that provide fast lookup of objects based on keys. Worst case complexity is linear but on average much faster for most of the operations.</p>
<p>Unordered associative containers are parametrized by <code>Key</code>; <code>Hash</code>, a <a href="hash" title="cpp/named req/Hash">Hash</a> function object which acts as hash function on <code>Key</code>; and <code>Pred</code>, a <a href="binarypredicate" title="cpp/named req/BinaryPredicate">BinaryPredicate</a> evaluating equivalence between <code>Key</code>s. <code><a href="http://en.cppreference.com/w/cpp/container/unordered_map"><span class="kw1296">std::<span class="me2">unordered_map</span></span></a></code> and <code><a href="http://en.cppreference.com/w/cpp/container/unordered_multimap"><span class="kw1298">std::<span class="me2">unordered_multimap</span></span></a></code> also have a mapped type <code>T</code> associated with the <code>Key</code>.</p>
<p>If two <code>Key</code>s are equal according to <code>Pred</code>, <code>Hash</code> must return the same value for both keys.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>If both <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> exist and each names a type, member functions <code>find</code>, <code>contains</code>, <code>count</code>, and <code>equal_range</code> accept arguments of types other than <code>Key</code> and expect that <code>Hash</code> is callable with values of those types, and that <code>Pred</code> is a transparent comparison function such as <code>std::equal_to&lt;&gt;</code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <p><code><a href="http://en.cppreference.com/w/cpp/container/unordered_map"><span class="kw1296">std::<span class="me2">unordered_map</span></span></a></code> and <code><a href="http://en.cppreference.com/w/cpp/container/unordered_set"><span class="kw1292">std::<span class="me2">unordered_set</span></span></a></code> can contain at most one element with a given key, <code><a href="http://en.cppreference.com/w/cpp/container/unordered_multiset"><span class="kw1294">std::<span class="me2">unordered_multiset</span></span></a></code> and <code><a href="http://en.cppreference.com/w/cpp/container/unordered_multimap"><span class="kw1298">std::<span class="me2">unordered_multimap</span></span></a></code> instead can have multiple elements with the same key (which must always be adjacent on iterations).</p>
<p>For <code><a href="http://en.cppreference.com/w/cpp/container/unordered_set"><span class="kw1292">std::<span class="me2">unordered_set</span></span></a></code> and <code><a href="http://en.cppreference.com/w/cpp/container/unordered_multiset"><span class="kw1294">std::<span class="me2">unordered_multiset</span></span></a></code> the value type is the same as the key type and both <code>iterator</code> and <code>const_iterator</code> are constant iterators. For <code><a href="http://en.cppreference.com/w/cpp/container/unordered_map"><span class="kw1296">std::<span class="me2">unordered_map</span></span></a></code> and <code><a href="http://en.cppreference.com/w/cpp/container/unordered_multimap"><span class="kw1298">std::<span class="me2">unordered_multimap</span></span></a></code> the value type is <code><a href="http://en.cppreference.com/w/cpp/utility/pair"><span class="kw1099">std::<span class="me2">pair</span></span></a><span class="sy1">&lt;</span><span class="kw4">const</span> Key, T<span class="sy1">&gt;</span></code>.</p>
<p>Elements in an unordered associative container are organized into buckets, keys with the same hash will end up in the same bucket. The number of buckets is increased when the size of the container increases to keep the average number of elements in each bucket under a certain value.</p>
<p>Rehashing invalidates iterator and might cause the elements to be re-arranged in different buckets but it doesn't invalidate references to the elements.</p>
<p>Unordered associative containers meet the requirements of <a href="allocatorawarecontainer" title="cpp/named req/AllocatorAwareContainer">AllocatorAwareContainer</a>. For <code><a href="http://en.cppreference.com/w/cpp/container/unordered_map"><span class="kw1296">std::<span class="me2">unordered_map</span></span></a></code> and <code><a href="http://en.cppreference.com/w/cpp/container/unordered_multimap"><span class="kw1298">std::<span class="me2">unordered_multimap</span></span></a></code> the requirements of <code>value_type</code> in <a href="allocatorawarecontainer" title="cpp/named req/AllocatorAwareContainer">AllocatorAwareContainer</a> apply to <code>key_type</code> and <code>mapped_type</code> (not to <code>value_type</code>).</p>
<h3 id="Requirements"> Requirements</h3> <table class="t-dsc-begin"> <tr> <td colspan="2"> <h3 id="Legend"> Legend</h3> </td>
</tr> <tr class="t-dsc"> <td> <code>X</code> </td> <td> Container type </td>
</tr> <tr class="t-dsc"> <td> <code>a</code> </td> <td> Object of type <code>X</code> </td>
</tr> <tr class="t-dsc"> <td> <code>b</code> </td> <td> <code>const</code> Object of type <code>X</code> </td>
</tr> <tr class="t-dsc"> <td> <code>a_uniq</code> </td> <td> Object in <code>X</code> when <code>X</code> supports unique keys </td>
</tr> <tr class="t-dsc"> <td> <code>a_eq</code> </td> <td> Object in <code>X</code> when <code>X</code> supports multiple equivalent keys </td>
</tr> <tr class="t-dsc"> <td> <code>i</code>, <code>j</code> </td> <td> <a href="inputiterator" title="cpp/named req/InputIterator">LegacyInputIterators</a> denoting a valid range </td>
</tr> <tr class="t-dsc"> <td> <code>p</code>, <code>q2</code> </td> <td> valid const_iterator to <code>a</code> </td>
</tr> <tr class="t-dsc"> <td> <code>q</code>, <code>q1</code> </td> <td> dereferenceable const_iterator to <code>a</code> denoting a valid range </td>
</tr> <tr class="t-dsc"> <td> <code>il</code> </td> <td> Object of <code><a href="http://en.cppreference.com/w/cpp/utility/initializer_list"><span class="kw961">std::<span class="me2">initializer_list</span></span></a><span class="sy1">&lt;</span>X<span class="sy4">::</span><span class="me2">value_type</span><span class="sy1">&gt;</span></code> </td>
</tr> <tr class="t-dsc"> <td> <code>t</code> </td> <td> Object of type <code>X::value_type</code> </td>
</tr> <tr class="t-dsc"> <td> <code>k</code> </td> <td> Object of type <code>X::key_type</code> </td>
</tr> <tr class="t-dsc"> <td> <code>hf</code> </td> <td> <code>const</code> Object of type <code>X::hasher</code> </td>
</tr> <tr class="t-dsc"> <td> <code>eq</code> </td> <td> <code>const</code> Object of type <code>X::key_equal</code> </td>
</tr> <tr class="t-dsc"> <td> <code>n</code> </td> <td> Value of type <code>X::size_type</code> </td>
</tr> <tr class="t-dsc"> <td> <code>z</code> </td> <td> Value of type <code>float</code> </td>
</tr> </table> <table class="wikitable"> <tr> <th>expression</th> <th>return type</th> <th>pre/requirements</th> <th>post/effects</th> <th>complexity </th>
</tr> <tr> <td><code>X::key_type</code></td> <td><code>Key</code></td> <td> </td> <td> </td> <td>compile time </td>
</tr> <tr> <td><code>X::mapped_type</code></td> <td><code>T</code></td> <td>
<code><a href="http://en.cppreference.com/w/cpp/container/unordered_map"><span class="kw1296">std::<span class="me2">unordered_map</span></span></a></code> and <code><a href="http://en.cppreference.com/w/cpp/container/unordered_multimap"><span class="kw1298">std::<span class="me2">unordered_multimap</span></span></a></code> only </td> <td> </td> <td>compile time </td>
</tr> <tr> <td><code>X::value_type</code></td> <td><code>Key</code></td> <td>
<code><a href="http://en.cppreference.com/w/cpp/container/unordered_set"><span class="kw1292">std::<span class="me2">unordered_set</span></span></a></code> and <code><a href="http://en.cppreference.com/w/cpp/container/unordered_multiset"><span class="kw1294">std::<span class="me2">unordered_multiset</span></span></a></code> only. <a href="erasable" title="cpp/named req/Erasable">Erasable</a> in <code>X</code> </td> <td> </td> <td>compile time </td>
</tr> <tr> <td><code>X::value_type</code></td> <td><code><a href="http://en.cppreference.com/w/cpp/utility/pair"><span class="kw1099">std::<span class="me2">pair</span></span></a><span class="sy1">&lt;</span><span class="kw4">const</span> Key, T<span class="sy1">&gt;</span></code></td> <td>
<code><a href="http://en.cppreference.com/w/cpp/container/unordered_map"><span class="kw1296">std::<span class="me2">unordered_map</span></span></a></code> and <code><a href="http://en.cppreference.com/w/cpp/container/unordered_multimap"><span class="kw1298">std::<span class="me2">unordered_multimap</span></span></a></code> only. <a href="erasable" title="cpp/named req/Erasable">Erasable</a> in <code>X</code> </td> <td> </td> <td>compile time </td>
</tr> <tr> <td><code>X::hasher</code></td> <td><code>Hash</code></td> <td><a href="hash" title="cpp/named req/Hash">Hash</a></td> <td> </td> <td>compile time </td>
</tr> <tr> <td>
<code>X::key_equal</code> </td> <td>
<code>Pred</code> </td> <td>
<a href="binarypredicate" title="cpp/named req/BinaryPredicate">BinaryPredicate</a> taking two arguments of type <code>Key</code> and expressing an equivalence relation. </td> <td> </td> <td>compile time </td>
</tr> <tr> <td><code>X::local_iterator</code></td> <td>An <a href="iterator" title="cpp/named req/Iterator">LegacyIterator</a> whose category and types are the same as <code>X::iterator</code> </td> <td> </td> <td> Can be used to iterate through a single bucket </td> <td>compile time </td>
</tr> <tr> <td><code>X::const_local_iterator</code></td> <td>An <a href="iterator" title="cpp/named req/Iterator">LegacyIterator</a> whose category and types are the same as <code>X::const_iterator</code> </td> <td> </td> <td> Can be used to iterate through a single bucket </td> <td>compile time </td>
</tr> <tr> <td><code>X(n,hf,eq)</code></td> <td><code>X</code></td> <td>
<code>hasher</code> and <code>key_equal</code> <a href="copyconstructible" title="cpp/named req/CopyConstructible">CopyConstructible</a> </td> <td>Constructs an empty container with at least <code>n</code> buckets, using the given hash function and equality predicate</td> <td>linear in <code>n</code> </td>
</tr> <tr> <td><code>X(n,hf)</code></td> <td><code>X</code></td> <td>
<code>hasher</code> <a href="copyconstructible" title="cpp/named req/CopyConstructible">CopyConstructible</a>, <code>key_equal</code> <a href="defaultconstructible" title="cpp/named req/DefaultConstructible">DefaultConstructible</a> </td> <td>Constructs an empty container with at least <code>n</code> buckets, using the given hash function and <code>key_equal()</code> as equality predicate</td> <td>linear in <code>n</code> </td>
</tr> <tr> <td><code>X(n)</code></td> <td><code>X</code></td> <td>
<code>hasher</code> and <code>key_equal</code> <a href="defaultconstructible" title="cpp/named req/DefaultConstructible">DefaultConstructible</a> </td> <td>Constructs an empty container with at least <code>n</code> buckets, using <code>hasher()</code> as hash function and <code>key_equal()</code> as equality predicate</td> <td>linear in <code>n</code> </td>
</tr> <tr> <td><code>X()</code></td> <td><code>X</code></td> <td>
<code>hasher</code> and <code>key_equal</code> <a href="defaultconstructible" title="cpp/named req/DefaultConstructible">DefaultConstructible</a> </td> <td>Constructs an empty container with an unspecified number of buckets, using <code>hasher()</code> as hash function and <code>key_equal()</code> as equality predicate</td> <td>constant </td>
</tr> <tr> <td><code>X(i,j,n,hf,eq)</code></td> <td><code>X</code></td> <td>
<code>hasher</code> and <code>key_equal</code> <a href="copyconstructible" title="cpp/named req/CopyConstructible">CopyConstructible</a>, <code>value_type</code> <a href="emplaceconstructible" title="cpp/named req/EmplaceConstructible">EmplaceConstructible</a> into <code>X</code> from <code>*i</code> </td> <td>Constructs an empty container with at least <code>n</code> buckets, using the given hash function and equality predicate, and inserts elements from [i,j) into it.</td> <td>average linear, worst quadratin (on the distance between <code>i</code> and <code>j</code>) </td>
</tr> <tr> <td><code>X(i,j,n,hf)</code></td> <td><code>X</code></td> <td>
<code>key_equal</code> <a href="defaultconstructible" title="cpp/named req/DefaultConstructible">DefaultConstructible</a>
</td> <td>As above, with <code>eq=key_equal()</code>
</td> <td>see above </td>
</tr> <tr> <td><code>X(i,j,n)</code></td> <td><code>X</code></td> <td>
<code>hasher</code> <a href="defaultconstructible" title="cpp/named req/DefaultConstructible">DefaultConstructible</a>
</td> <td>As above, with <code>hf=hasher()</code>
</td> <td>see above </td>
</tr> <tr> <td><code>X(i,j)</code></td> <td><code>X</code></td> <td> </td> <td>As above, with an unspecified number of buckets</td> <td>see above </td>
</tr> <tr> <td><code>X(il)</code></td> <td><code>X</code></td> <td> </td> <td><code>X(il.begin(),il.end()</code></td> <td>see above </td>
</tr> <tr> <td><code>X(il,n)</code></td> <td><code>X</code></td> <td> </td> <td><code>X(il.begin(),il.end(),n</code></td> <td>see above </td>
</tr> <tr> <td><code>X(il,n,hf)</code></td> <td><code>X</code></td> <td> </td> <td><code>X(il.begin(),il.end(),n,hf</code></td> <td>see above </td>
</tr> <tr> <td><code>X(il,n,hf,eq)</code></td> <td><code>X</code></td> <td> </td> <td><code>X(il.begin(),il.end(),n,hf,eq</code></td> <td>see above </td>
</tr> <tr> <td><code>X(b)</code></td> <td><code>X</code></td> <td> </td> <td>Copy constructors, also copies the hash function, predicate and maximum load factor</td> <td>average linear, worst quadratic (in <code>b.size()</code>) </td>
</tr> <tr> <td><code>a = b</code></td> <td><code>X&amp;</code></td> <td> </td> <td>Copy assignment, also copies the hash function, predicate and maximum load factor</td> <td>average linear, worst quadratic (in <code>b.size()</code>) </td>
</tr> <tr> <td><code>a = il</code></td> <td><code>X&amp;</code></td> <td>
<code>value_type</code> <a href="copyassignable" title="cpp/named req/CopyAssignable">CopyAssignable</a> and <a href="copyinsertable" title="cpp/named req/CopyInsertable">CopyInsertable</a> into <code>X</code>
</td> <td> <code>a = X(il)</code>
</td> <td>see above </td>
</tr> </table>  <h3 id="Unordered_associative_containers_in_the_standard_library"> Unordered associative containers in the standard library</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../container/unordered_set" title="cpp/container/unordered set"> <span class="t-lines"><span>unordered_set</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> collection of unique keys, hashed by keys <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/unordered_multiset" title="cpp/container/unordered multiset"> <span class="t-lines"><span>unordered_multiset</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> collection of keys, hashed by keys <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/unordered_map" title="cpp/container/unordered map"> <span class="t-lines"><span>unordered_map</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> collection of key-value pairs, hashed by keys, keys are unique <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/unordered_multimap" title="cpp/container/unordered multimap"> <span class="t-lines"><span>unordered_multimap</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> collection of key-value pairs, hashed by keys <br> <span class="t-mark">(class template)</span>  </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    Â© cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/named_req/UnorderedAssociativeContainer" class="_attribution-link">https://en.cppreference.com/w/cpp/named_req/UnorderedAssociativeContainer</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
