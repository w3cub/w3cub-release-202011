
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Named Requirements&#58; AssociativeContainer - C++ - W3cubDocs</title>
  
  <meta name="description" content=" An AssociativeContainer is an ordered Container that provides fast lookup of objects based on keys. ">
  <meta name="keywords" content="c++, named, requirements, associativecontainer, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/named_req/associativecontainer.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-9c7b0d969c0ce639a6c01c2badcdd81667c7c66206aa3d0fccc5cb0585fb1b912dab72ea882101d18010680927514b4b77b107282db8f756fbf63301fe9c88b0.css">
  <script type="text/javascript" src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js"></script>
  <script src="/json/cpp.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _cppref">
				
				
<h1 id="firstHeading" class="firstHeading">C++ named requirements: AssociativeContainer</h1>            <p>An <strong class="selflink">AssociativeContainer</strong> is an ordered <a href="container" title="cpp/named req/Container">Container</a> that provides fast lookup of objects based on keys.</p>
<p>An associative container supports <i>unique keys</i> if it may contain at most one element for each key. Otherwise, it supports <i>equivalent keys</i>.</p>
<h3 id="Requirements"> Requirements</h3> <table class="t-dsc-begin"> <tr> <td colspan="2"> <h5 id="Legend">  Legend </h5> </td>
</tr> <tr class="t-dsc"> <td> <code>X</code> </td> <td> A associative container class </td>
</tr> <tr class="t-dsc"> <td> <code>T</code> </td> <td> The element type of <code>X</code> </td>
</tr> <tr class="t-dsc"> <td> <code>A</code> </td> <td> The allocator type of <code>X</code>: <code>X::allocator_type</code> if it exists, otherwise <a href="http://en.cppreference.com/w/cpp/memory/allocator"><span class="kw702">std::<span class="me2">allocator</span></span></a><span class="sy1">&lt;</span>X<span class="sy4">::</span><span class="me2">value_type</span><span class="sy1">&gt;</span> </td>
</tr> <tr class="t-dsc"> <td> <code>a</code> </td> <td> A value of type <code>X</code> </td>
</tr> <tr class="t-dsc"> <td> <code>a2</code> </td> <td> A value of a type <code>Y</code> whose <a href="../container/node_handle" title="cpp/container/node handle">node handles</a> are compatible with <code>X</code> </td>
</tr> <tr class="t-dsc"> <td> <code>b</code> </td> <td> A value of type <code>X</code> or <span class="kw4">const</span> X </td>
</tr> <tr class="t-dsc"> <td> <code>u</code> </td> <td> A name of a variable beging declared </td>
</tr> <tr class="t-dsc"> <td> <code>a_uniq</code> </td> <td> A value of type <code>X</code> when <code>X</code> supports unique keys </td>
</tr> <tr class="t-dsc"> <td> <code>a_eq</code> </td> <td> A value of type <code>X</code> when <code>X</code> supports equivalent keys </td>
</tr> <tr class="t-dsc"> <td> <code>a_tran</code> </td> <td> A value of type <code>X</code> or <span class="kw4">const</span> X when type <code>X::key_compare::is_transparent</code> exists </td>
</tr> <tr class="t-dsc"> <td> <code>i</code>, <code>j</code> </td> <td> The <a href="inputiterator" title="cpp/named req/InputIterator">LegacyInputIterators</a> referring to elements implicitly convertible to <code>X::value_type</code> </td>
</tr> <tr class="t-dsc"> <td> <code>[</code><code>i</code><code>, </code><code>j</code><code>)</code> </td> <td> A valid range </td>
</tr> <tr class="t-dsc"> <td> <code>rg</code><br><span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td> <td> A value of a type <code>R</code> that models <a href="../ranges/to#container_compatible_range" title="cpp/ranges/to"><code>container-compatible-range</code></a><code>&lt;value_type&gt;</code> </td>
</tr> <tr class="t-dsc"> <td> <code>p</code> </td> <td> A valid constant iterator to <code>a</code> </td>
</tr> <tr class="t-dsc"> <td> <code>q</code> </td> <td> A valid dereferenceable constant iterator to <code>a</code> </td>
</tr> <tr class="t-dsc"> <td> <code>r</code> </td> <td> A valid dereferenceable iterator to <code>a</code> </td>
</tr> <tr class="t-dsc"> <td> <code>q1</code>, <code>q2</code> </td> <td> A valid range of const iterators in <code>a</code> </td>
</tr> <tr class="t-dsc"> <td> <code>il</code> </td> <td> An object of type <a href="http://en.cppreference.com/w/cpp/utility/initializer_list"><span class="kw962">std::<span class="me2">initializer_list</span></span></a><span class="sy1">&lt;</span>X<span class="sy4">::</span><span class="me2">value_type</span><span class="sy1">&gt;</span> </td>
</tr> <tr class="t-dsc"> <td> <code>t</code> </td> <td> A value of type <code>X::value_type</code> </td>
</tr> <tr class="t-dsc"> <td> <code>k</code> </td> <td> A value of type <code>X::key_type</code> </td>
</tr> <tr class="t-dsc"> <td> <code>c</code> </td> <td> A value of type <code>X::key_compare</code> or <span class="kw4">const</span> X<span class="sy4">::</span><span class="me2">key_compare</span> </td>
</tr> <tr class="t-dsc"> <td> <code>kl</code> </td> <td> A value such that <code>a</code> is partitioned with respect to <code>c(x, kl)</code>, with <code>x</code> the key value of <code>e</code> and <code>e</code> in <code>a</code> </td>
</tr> <tr class="t-dsc"> <td> <code>ku</code> </td> <td> A value such that <code>a</code> is partitioned with respect to <code>!c(ku, x)</code>, with <code>x</code> the key value of <code>e</code> and <code>e</code> in <code>a</code> </td>
</tr> <tr class="t-dsc"> <td> <code>ke</code> </td> <td> A value such that <code>a</code> is partitioned with respect to <code>c(x, ke)</code> and <code>!c(ke, x)</code>, with <code>c(x, ke)</code> implying <code>!c(ke, x)</code> and with <code>x</code> the key value of <code>e</code> and <code>e</code> in <code>a</code> </td>
</tr> <tr class="t-dsc"> <td> <code>kx</code><br><span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td> <td> A value such that: <ul>
<li> <code>a</code> is partitioned with respect to <code>c(x, kx)</code> and <code>!c(kx, x)</code>, with <code>c(x, kx)</code> implying <code>!c(kx, x)</code> and with <code>x</code> the key value of <code>e</code> and <code>e</code> in <code>a</code>, and </li>
<li> <code>kx</code> is not convertible to either <code>X::iterator</code> or <code>X::const_iterator</code> </li>
</ul> </td>
</tr> <tr class="t-dsc"> <td> <code>m</code> </td> <td> An allocator of a type convertible to <code>A</code> </td>
</tr> <tr class="t-dsc"> <td> <code>nh</code> </td> <td> A non-const rvalue of type <code>X::node_type</code> </td>
</tr> </table> <p>The type <code>X</code> satisfies AssociativeContainer if.</p>
<ul>
<li> The type <code>X</code> satisfies <span class="t-rev-inl t-until-cxx11"><span><a href="container" title="cpp/named req/Container">Container</a></span> <span><span class="t-mark-rev t-until-cxx11">(until C++11)</span></span></span><span class="t-rev-inl t-since-cxx11"><span><a href="allocatorawarecontainer" title="cpp/named req/AllocatorAwareContainer">AllocatorAwareContainer</a></span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>, </li>
<li> Is parameterized on <code>Key</code> and an ordering relation <code>Compare</code> that induces a <a href="compare" title="cpp/named req/Compare">strict weak ordering</a> on elements of <code>Key</code>, and <ul>
<li> In addition, <code><a href="../container/map" title="cpp/container/map">std::map</a></code> and <code><a href="../container/multimap" title="cpp/container/multimap">std::multimap</a></code> associate an arbitrary <i>mapped type</i> <code>T</code> with the <code>Key</code>. </li>
<li> The object of type <code>Compare</code> is called the <i>comparison object</i> of a container of type <code>X</code>. </li>
</ul> </li>
<li> The following expressions must be valid and have their specified effects for all associative containers: </li>
</ul> <h4 id="Types"> Types</h4> <table class="wikitable"> <tr> <th>Name</th> <th>Type</th> <th>Requirements </th>
</tr> <tr> <td>
<code>key_type</code> </td> <td>
<code>Key</code> </td> <td> </td>
</tr> <tr> <td>
<code>mapped_type</code> </td> <td>
<code>T</code> (for <code><a href="../container/map" title="cpp/container/map">std::map</a></code> and <code><a href="../container/multimap" title="cpp/container/multimap">std::multimap</a></code> only) </td> <td> </td>
</tr> <tr> <td>
<code>value_type</code> </td> <td> <ul>
<li>
<code>Key</code> (for <code><a href="../container/set" title="cpp/container/set">std::set</a></code> and <code><a href="../container/multiset" title="cpp/container/multiset">std::multiset</a></code> only) </li>
<li> <a href="http://en.cppreference.com/w/cpp/utility/pair"><span class="kw1100">std::<span class="me2">pair</span></span></a><span class="sy1">&lt;</span><span class="kw4">const</span> Key, T<span class="sy1">&gt;</span>(for <code><a href="../container/map" title="cpp/container/map">std::map</a></code> and <code><a href="../container/multimap" title="cpp/container/multimap">std::multimap</a></code> only) </li>
</ul> </td> <td>
<a href="erasable" title="cpp/named req/Erasable">Erasable</a> from <code>X</code> </td>
</tr> <tr> <td>
<code>key_compare</code> </td> <td>
<code>Compare</code> </td> <td>
<a href="copyconstructible" title="cpp/named req/CopyConstructible">CopyConstructible</a> </td>
</tr> <tr> <td>
<code>value_compare</code> </td> <td> <ul>
<li> same as <code>key_compare</code> (for <code><a href="../container/set" title="cpp/container/set">std::set</a></code> and <code><a href="../container/multiset" title="cpp/container/multiset">std::multiset</a></code>) </li>
<li> an ordering relation on pairs induced by the first component (i.e. <code>Key</code>) (for <code><a href="../container/map" title="cpp/container/map">std::map</a></code> and <code><a href="../container/multimap" title="cpp/container/multimap">std::multimap</a></code>) </li>
</ul> </td> <td>
<a href="binarypredicate" title="cpp/named req/BinaryPredicate">BinaryPredicate</a> </td>
</tr> <tr> <td>
<code>node_type</code> </td> <td>A specialization of the <a href="../container/node_handle" title="cpp/container/node handle">node-handle class template</a>, such that the public nested types are the same types as the corresponding types in <code>X</code>. </td> <td> </td>
</tr>
</table> <h4 id="Member_functions_and_operators"> Member functions and operators</h4> <table class="wikitable"> <tr> <th>Expression</th> <th>Result</th> <th>Preconditions</th> <th>Effects</th> <th>Returns</th> <th>Complexity </th>
</tr> <tr> <td>
<code>X(c)</code> </td> <td> </td> <td> </td> <td>Constructs an empty container. Uses a copy of <code>c</code> as a comparison object </td> <td> </td> <td>Constant </td>
</tr> <tr> <td>
<code>X u = X();</code><br><code>X u;</code> </td> <td> </td> <td>
<code>key_compare</code> meets the <a href="defaultconstructible" title="cpp/named req/DefaultConstructible">DefaultConstructible</a> requirements </td> <td>Constructs an empty container. Uses <code>Compare()</code> as a comparison object </td> <td> </td> <td>Constant </td>
</tr> <tr> <td>
<code>X(i, j, c)</code> </td> <td> </td> <td>
<code>value_type</code> is <a href="emplaceconstructible" title="cpp/named req/EmplaceConstructible">EmplaceConstructible</a> into <code>X</code> from <code>*i</code> </td> <td>Constructs an empty container and inserts elements from the range <code>[</code><code>i</code><code>, </code><code>j</code><code>)</code> into it; uses <code>c</code> as a comparison object </td> <td> </td> <td rowspan="2">
<code>N·log(N)</code> in general, where <code>N</code> has the value <code><a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">std::<span class="me2">distance</span></span></a><span class="br0">(</span>i, j<span class="br0">)</span></code>; linear if <code>[</code><code>i</code><code>, </code><code>j</code><code>)</code> is sorted with respect to <code>value_comp()</code> </td>
</tr> <tr> <td>
<code>X(i, j)</code> </td> <td> </td> <td>
<code>key_compare</code> meets the <a href="defaultconstructible" title="cpp/named req/DefaultConstructible">DefaultConstructible</a> requirements. <code>value_type</code> is <a href="emplaceconstructible" title="cpp/named req/EmplaceConstructible">EmplaceConstructible</a> into <code>X</code> from <code>*i</code> </td> <td>Constructs an empty container and inserts elements from the range <code>[</code><code>i</code><code>, </code><code>j</code><code>)</code> into it; uses <code>Compare()</code> as a comparison object </td> <td> </td>
</tr> <tr> <td>
<code>X(from_range, rg, c)</code><br><span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td> <td> </td> <td>
<code>value_type</code> is <a href="emplaceconstructible" title="cpp/named req/EmplaceConstructible">EmplaceConstructible</a> into <code>X</code> from <code><span class="sy2">*</span><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2886">ranges::<span class="me2">begin</span></span></a><span class="br0">(</span>rg<span class="br0">)</span></code> </td> <td>Constructs an empty container and inserts each element from <code>rg</code> into it. Uses <code>c</code> as the comparison object </td> <td> </td> <td rowspan="2">
<code>N·log(N)</code> in general, where <code>N</code> has the value <code><a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3146">ranges::<span class="me2">distance</span></span></a><span class="br0">(</span>rg<span class="br0">)</span></code>; linear if <code>rg</code> is sorted with respect to <code>value_comp()</code> </td>
</tr> <tr> <td>
<code>X(from_range, rg)</code><br><span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td> <td> </td> <td>
<code>key_compare</code> meets the <a href="defaultconstructible" title="cpp/named req/DefaultConstructible">DefaultConstructible</a> requirements. <code>value_type</code> is <a href="emplaceconstructible" title="cpp/named req/EmplaceConstructible">EmplaceConstructible</a> into <code>X</code> from <code><span class="sy2">*</span><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2886">ranges::<span class="me2">begin</span></span></a><span class="br0">(</span>rg<span class="br0">)</span></code> </td> <td>Constructs an empty container and inserts each element from <code>rg</code> into it. Uses <code>Compare()</code> as the comparison object </td> <td> </td>
</tr> <tr> <td>
<code>X(il, c)</code> </td> <td> </td> <td> </td> <td>
<code>X(il.begin(), il.end(), c)</code> </td> <td> </td> <td> </td>
</tr> <tr> <td>
<code>X(il)</code> </td> <td> </td> <td> </td> <td>
<code>X(il.begin(), il.end())</code> </td> <td> </td> <td> </td>
</tr> <tr> <td>
<code>a = il</code> </td> <td>
<code>X&amp;</code> </td> <td>
<code>value_type</code> is <a href="copyinsertable" title="cpp/named req/CopyInsertable">CopyInsertable</a> into <code>X</code> and <a href="copyassignable" title="cpp/named req/CopyAssignable">CopyAssignable</a> </td> <td>Assigns the range <code>[</code><code>il.begin()</code><code>, </code><code>il.end()</code><code>)</code> into <code>a</code>. All existing elements of <code>a</code> are either assigned to or destroyed </td> <td> </td> <td>
<code>N·log(N)</code> in general, where <code>N</code> has the value <code>il.size() + a.size()</code>; linear if <code>[</code><code>il.begin()</code><code>, </code><code>il.end()</code><code>)</code> is sorted with respect to <code>value_comp()</code> </td>
</tr> <tr> <td>
<code>b.key_comp()</code> </td> <td>
<code>X::key_compare</code> </td> <td> </td> <td> </td> <td>The comparison object out of which <code>b</code> was constructed </td> <td>Constant </td>
</tr> <tr> <td>
<code>b.value_comp()</code> </td> <td>
<code>X::value_compare</code> </td> <td> </td> <td> </td> <td>An object of <code>value_compare</code> constructed out of the comparison object </td> <td>Constant </td>
</tr> <tr> <td>
<code>a_uniq.emplace(args)</code> </td> <td>
<code><a href="http://en.cppreference.com/w/cpp/utility/pair"><span class="kw1100">std::<span class="me2">pair</span></span></a><span class="sy1">&lt;</span><br> iterator,<br> bool&gt;</code> </td> <td>
<code>value_type</code> is <a href="emplaceconstructible" title="cpp/named req/EmplaceConstructible">EmplaceConstructible</a> into <code>X</code> from <code>args</code> </td> <td>Inserts a <code>value_type</code> object <code>t</code> constructed with <code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1121">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>Args<span class="sy1">&gt;</span><span class="br0">(</span>args<span class="br0">)</span>...</code> if and only if there is no element in the container with key equivalent to the key of <code>t</code> </td> <td>The <code>bool</code> component of the returned pair is <code>true</code> if and only if the insertion takes place, and the iterator component of the pair points to the element with key equivalent to the key of <code>t</code> </td> <td>Logarithmic </td>
</tr> <tr> <td>
<code>a_eq.emplace(args)</code> </td> <td>
<code>iterator</code> </td> <td>
<code>value_type</code> is <a href="emplaceconstructible" title="cpp/named req/EmplaceConstructible">EmplaceConstructible</a> into <code>X</code> from <code>args</code> </td> <td>Inserts a <code>value_type</code> object <code>t</code> constructed with <code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1121">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>Args<span class="sy1">&gt;</span><span class="br0">(</span>args<span class="br0">)</span>...</code>. If a range containing elements equivalent to <code>t</code> exists in <code>a_eq</code>, <code>t</code> is inserted at the end of that range </td> <td>An iterator pointing to the newly inserted element </td> <td>Logarithmic </td>
</tr> <tr> <td>
<code>a.emplace_hint(p, args)</code> </td> <td>
<code>iterator</code> </td> <td> </td> <td>Equivalent to <p><code>a.emplace(<br> <a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1121">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>Args<span class="sy1">&gt;</span><span class="br0">(</span>args<span class="br0">)</span>...<span class="br0">)</span></code>, except that the element is inserted as close as possible to the position just prior to <code>p</code>.</p>
</td> <td>An iterator pointing to the element with the key equivalent to the newly inserted element </td> <td>Logarithmic in general, but amortized constant if the element is inserted right before <code>p</code> </td>
</tr> <tr> <td>
<code>a_uniq.insert(t)</code> </td> <td>
<code><a href="http://en.cppreference.com/w/cpp/utility/pair"><span class="kw1100">std::<span class="me2">pair</span></span></a><span class="sy1">&lt;</span><br> iterator,<br> bool&gt;</code> </td> <td>If <code>t</code> is a non-const rvalue, <code>value_type</code> is <a href="moveinsertable" title="cpp/named req/MoveInsertable">MoveInsertable</a> into <code>X</code>; otherwise, <code>value_type</code> is <a href="copyinsertable" title="cpp/named req/CopyInsertable">CopyInsertable</a> into <code>X</code> </td> <td>Inserts <code>t</code> if and only if there is no element in the container with key equivalent to the key of <code>t</code> </td> <td>The <code>bool</code> component of the returned pair is <code>true</code> if and only if the insertion takes place, and the <code>iterator</code> component of the pair points to the element with key equivalent to the key of <code>t</code> </td> <td>Logarithmic </td>
</tr> <tr> <td>
<code>a_eq.insert(t)</code> </td> <td>
<code>iterator</code> </td> <td>If <code>t</code> is a non-const rvalue, <code>value_type</code> is <a href="moveinsertable" title="cpp/named req/MoveInsertable">MoveInsertable</a> into <code>X</code>; otherwise, <code>value_type</code> is <a href="copyinsertable" title="cpp/named req/CopyInsertable">CopyInsertable</a> into <code>X</code> </td> <td>Inserts <code>t</code> and returns the iterator pointing to the newly inserted element. If a range containing elements equivalent to <code>t</code> exists in <code>a_eq</code>, <code>t</code> is inserted at the end of that range </td> <td> </td> <td>Logarithmic </td>
</tr> <tr> <td>
<code>a.insert(p, t)</code> </td> <td>
<code>iterator</code> </td> <td>If <code>t</code> is a non-const rvalue, <code>value_type</code> is <a href="moveinsertable" title="cpp/named req/MoveInsertable">MoveInsertable</a> into <code>X</code>; otherwise, <code>value_type</code> is <a href="copyinsertable" title="cpp/named req/CopyInsertable">CopyInsertable</a> into <code>X</code> </td> <td>Inserts <code>t</code> if and only if there is no element with key equivalent to the key of <code>t</code> in containers with unique keys; always inserts <code>t</code> in containers with equivalent keys. <code>t</code> is inserted as close as possible to the position just prior to <code>p</code> </td> <td>An iterator pointing to the element with key equivalent to the key of <code>t</code> </td> <td>Logarithmic in general, but amortized constant if <code>t</code> is inserted right before <code>p</code> </td>
</tr> <tr> <td>
<code>a.insert(i, j)</code> </td> <td>
<code>void</code> </td> <td>
<code>value_type</code> is <a href="emplaceconstructible" title="cpp/named req/EmplaceConstructible">EmplaceConstructible</a> into <code>X</code> from <code>*i</code>. Neither <code>i</code> nor <code>j</code> are iterators into <code>a</code> </td> <td>Inserts each element from the range <code>[</code><code>i</code><code>, </code><code>j</code><code>)</code> if and only if there is no element with key equivalent to the key of that element in containers with unique keys; always inserts that element in containers with equivalent keys </td> <td> </td> <td>
<code>N·log(a.size() + N)</code>, where <code>N</code> has the value <code><a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">std::<span class="me2">distance</span></span></a><span class="br0">(</span>i, j<span class="br0">)</span></code> </td>
</tr> <tr> <td>
<code>a.insert_range(rg)</code><br><span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td> <td>
<code>void</code> </td> <td>
<code>value_type</code> is <a href="emplaceconstructible" title="cpp/named req/EmplaceConstructible">EmplaceConstructible</a> into <code>X</code> from <code><span class="sy2">*</span><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2886">ranges::<span class="me2">begin</span></span></a><span class="br0">(</span>rg<span class="br0">)</span></code>. <code>rg</code> and <code>a</code> do not overlap </td> <td>Inserts each element from <code>rg</code> if and only if there is no element with key equivalent to the key of that element in containers with unique keys; always inserts that element in containers with equivalent keys </td> <td> </td> <td>
<code>N·log(a.size() + N)</code>, where <code>N</code> has the value <code><a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3146">ranges::<span class="me2">distance</span></span></a><span class="br0">(</span>rg<span class="br0">)</span></code> </td>
</tr> <tr> <td>
<code>a.insert(il)</code> </td> <td> </td> <td> </td> <td>
<code>a.insert(il.begin(), il.end())</code> </td> <td> </td> <td> </td>
</tr> <tr> <td>
<code>a_uniq.insert(nh)</code> </td> <td>
<code>insert_return_type</code> </td> <td>
<code>nh</code> is empty or <p><code>a_uniq.get_allocator()==nh.get_allocator()</code> is <code>true</code>.</p>
</td> <td>If <code>nh</code> is empty, has no effect. Otherwise, inserts the element owned by <code>nh</code> if and only if there is no element in the container with a key equivalent to <code>nh.key()</code> </td> <td>If <code>nh</code> is empty, <code>inserted</code> is <code>false</code>, <code>position</code> is <code>end()</code>, and <code>node</code> is empty. Otherwise if the insertion took place, <code>inserted</code> is <code>true</code>, <code>position</code> points to the inserted element, and <code>node</code> is empty; if the insertion failed, <code>inserted</code> is <code>false</code>, <code>node</code> has the previous value of <code>nh</code>, and <code>position</code> points to an element with a key equivalent to <code>nh.key()</code> </td> <td>Logarithmic </td>
</tr> <tr> <td>
<code>a_eq.insert(nh)</code> </td> <td>
<code>iterator</code> </td> <td>
<code>nh</code> is empty or <p><code>a_eq.get_allocator()==nh.get_allocator()</code> is <code>true</code>.</p>
</td> <td>If <code>nh</code> is empty, has no effect and returns <code>a_eq.end()</code>. Otherwise, inserts the element owned by <code>nh</code> and returns an iterator pointing to the newly inserted element. If a range containing elements with keys equivalent to <code>nh.key()</code> exists in <code>a_eq</code>, the element is inserted at the end of that range. Ensures: <code>nh</code> is empty </td> <td> </td> <td>Logarithmic </td>
</tr> <tr> <td>
<code>a.insert(p, nh)</code> </td> <td>
<code>iterator</code> </td> <td>
<code>nh</code> is empty or <p><code>a.get_allocator()==nh.get_allocator()</code> is <code>true</code>.</p>
</td> <td>If <code>nh</code> is empty, has no effect and returns <code>a.end()</code>. Otherwise, inserts the element owned by <code>nh</code> if and only if there is no element with key equivalent to <code>nh.key()</code> in containers with unique keys; always inserts the element owned by <code>nh</code> in containers with equivalent keys. The element is inserted as close as possible to the position just prior to <code>p</code>. Ensures: <code>nh</code> is empty if insertion succeeds, unchanged if insertion fails </td> <td>An iterator pointing to the element with key equivalent to <code>nh.key()</code> </td> <td>Logarithmic in general, but amortized constant if the element is inserted right before <code>p</code> </td>
</tr> <tr> <td>
<code>a.extract(k)</code> </td> <td>
<code>node_type</code> </td> <td> </td> <td>Removes the first element in the container with key equivalent to <code>k</code> </td> <td>A <code>node_type</code> owning the element if found, otherwise an empty <code>node_type</code> </td> <td>
<code>log(a.size())</code> </td>
</tr> <tr> <td>
<code>a_tran.extract(kx)</code><br><span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td> <td>
<code>node_type</code> </td> <td> </td> <td>Removes the first element in the container with key <code>r</code> such that <code>!c(r, kx) &amp;&amp; !c(kx, r)</code> is <code>true</code> </td> <td>A <code>node_type</code> owning the element if found, otherwise an empty <code>node_type</code> </td> <td>
<code>log(a_tran.size())</code> </td>
</tr> <tr> <td>
<code>a.extract(q)</code> </td> <td>
<code>node_type</code> </td> <td> </td> <td>Removes the element pointed to by <code>q</code> </td> <td>A <code>node_type</code> owning that element </td> <td>Amortized constant </td>
</tr> <tr> <td>
<code>a.merge(a2)</code> </td> <td>
<code>void</code> </td> <td>
<code>a.get_allocator()==a2.get_allocator()</code> </td> <td>Attempts to extract each element in <code>a2</code> and insert it into <code>a</code> using the comparison object of <code>a</code>. In containers with unique keys, if there is an element in <code>a</code> with key equivalent to the key of an element from <code>a2</code>, then that element is not extracted from <code>a2</code>. Ensures: Pointers and references to the transferred elements of <code>a2</code> refer to those same elements but as members of <code>a</code>. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into <code>a</code>, not into <code>a2</code>. Throws: Nothing unless the comparison object throws </td> <td> </td> <td>
<code>N·log(a.size() + N)</code>, where <code>N</code> has the value <code>a2.size()</code> </td>
</tr> <tr> <td>
<code>a.erase(k)</code> </td> <td>
<code>size_type</code> </td> <td> </td> <td>Erases all elements in the container with key equivalent to <code>k</code> </td> <td>The number of erased elements </td> <td>
<code>log(a.size())+ a.count(k)</code> </td>
</tr> <tr> <td>
<code>a_tran.erase(kx)</code><br><span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td> <td>
<code>size_type</code> </td> <td> </td> <td>Erases all elements in the container with key <code>r</code> such that <code>!c(r, kx) &amp;&amp; !c(kx, r)</code> is <code>true</code> </td> <td>The number of erased elements </td> <td>
<code>log(a_tran.size())+ a_tran.count(kx)</code> </td>
</tr> <tr> <td>
<code>a.erase(q)</code> </td> <td>
<code>iterator</code> </td> <td> </td> <td>Erases the element pointed to by <code>q</code> </td> <td>An iterator pointing to the element immediately following <code>q</code> prior to the element being erased. If no such element exists, returns <code>a.end()</code> </td> <td>Amortized constant </td>
</tr> <tr> <td>
<code>a.erase(r)</code> </td> <td>
<code>iterator</code> </td> <td> </td> <td>Erases the element pointed to by <code>r</code> </td> <td>An iterator pointing to the element immediately following <code>r</code> prior to the element being erased. If no such element exists, returns <code>a.end()</code> </td> <td>Amortized constant </td>
</tr> <tr> <td>
<code>a.erase(q1, q2)</code> </td> <td>
<code>iterator</code> </td> <td> </td> <td>Erases all the elements in the range<br><code>[</code><code>q1</code><code>, </code><code>q2</code><code>)</code> </td> <td>An iterator pointing to the element pointed to by <code>q2</code> prior to any elements being erased. If no such element exists, <code>a.end()</code> is returned </td> <td>
<code>log(a.size()) + N</code>, where <code>N</code> has the value <code><a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">std::<span class="me2">distance</span></span></a><span class="br0">(</span>q1, q2<span class="br0">)</span></code> </td>
</tr> <tr> <td>
<code>a.clear()</code> </td> <td> </td> <td> </td> <td>
<code>a.erase(a.begin(), a.end())</code>. Ensures: <code>a.empty()</code> is <code>true</code> </td> <td> </td> <td>Linear in <code>a.size()</code> </td>
</tr> <tr> <td>
<code>b.find(k)</code> </td> <td>
<code>iterator</code>; <code>const_iterator</code> for constant <code>b</code> </td> <td> </td> <td> </td> <td>An iterator pointing to an element with the key equivalent to <code>k</code>, or <code>b.end()</code> if such an element is not found </td> <td>Logarithmic </td>
</tr> <tr> <td>
<code>a_tran.find(ke)</code> </td> <td>
<code>iterator</code>; <code>const_iterator</code> for constant <code>a_tran</code> </td> <td> </td> <td> </td> <td>An iterator pointing to an element with key <code>r</code> such that <code>!c(r, ke) &amp;&amp; !c(ke, r)</code> is <code>true</code>, or <code>a_tran.end()</code> if such an element is not found </td> <td>Logarithmic </td>
</tr> <tr> <td>
<code>b.count(k)</code> </td> <td>
<code>size_type</code> </td> <td> </td> <td> </td> <td>The number of elements with key equivalent to <code>k</code> </td> <td>
<code>log(b.size())+ b.count(k)</code> </td>
</tr> <tr> <td>
<code>a_tran.count(ke)</code> </td> <td>
<code>size_type</code> </td> <td> </td> <td> </td> <td>The number of elements with key <code>r</code> such that <code>!c(r, ke) &amp;&amp; !c(ke, r)</code> </td> <td>
<code>log(a_tran.size())+ a_tran.count(ke)</code> </td>
</tr> <tr> <td>
<code>b.contains(k)</code> </td> <td>
<code>bool</code> </td> <td> </td> <td>
<code>return b.find(k) != b.end();</code> </td> <td> </td> <td> </td>
</tr> <tr> <td>
<code>a_tran.contains(ke)</code> </td> <td>
<code>bool</code> </td> <td> </td> <td> <p><code>return a_tran.find(ke) != a_tran.end();</code></p>
</td> <td> </td> <td> </td>
</tr> <tr> <td>
<code>b.lower_bound(k)</code> </td> <td>
<code>iterator</code>; <code>const_iterator</code> for constant <code>b</code> </td> <td> </td> <td> </td> <td>An iterator pointing to the first element with key not less than <code>k</code>, or <code>b.end()</code> if such an element is not found </td> <td>Logarithmic </td>
</tr> <tr> <td>
<code>a_tran.lower_bound(kl)</code> </td> <td>
<code>iterator</code>; <code>const_iterator</code> for constant <code>a_tran</code> </td> <td> </td> <td> </td> <td>An iterator pointing to the first element with key <code>r</code> such that <code>!c(r, kl)</code>, or <code>a_tran.end()</code> if such an element is not found </td> <td>Logarithmic </td>
</tr> <tr> <td>
<code>b.upper_bound(k)</code> </td> <td>
<code>iterator</code>; <code>const_iterator</code> for constant <code>b</code> </td> <td> </td> <td> </td> <td>An iterator pointing to the first element with key greater than <code>k</code>, or <code>b.end()</code> if such an element is not found </td> <td>Logarithmic </td>
</tr> <tr> <td>
<code>a_tran.upper_bound(ku)</code> </td> <td>
<code>iterator</code>; <code>const_iterator</code> for constant <code>a_tran</code> </td> <td> </td> <td> </td> <td>An iterator pointing to the first element with key <code>r</code> such that <code>c(ku, r)</code>, or <code>a_tran.end()</code> if such an element is not found </td> <td>Logarithmic </td>
</tr> <tr> <td>
<code>b.equal_range(k)</code> </td> <td>
<code><a href="http://en.cppreference.com/w/cpp/utility/pair"><span class="kw1100">std::<span class="me2">pair</span></span></a><span class="sy1">&lt;</span><br> iterator,<br> iterator&gt;</code>; <p><code><a href="http://en.cppreference.com/w/cpp/utility/pair"><span class="kw1100">std::<span class="me2">pair</span></span></a><span class="sy1">&lt;</span><br> const_iterator,<br> const_iterator&gt;</code> for constant <code>b</code>.</p>
</td> <td> </td> <td>Equivalent to: <p><code>return<br> <a href="http://en.cppreference.com/w/cpp/utility/pair/make_pair"><span class="kw1101">std::<span class="me2">make_pair</span></span></a><span class="br0">(</span><br> b.lower_bound(k),<br> b.upper_bound(k));</code></p>
</td> <td> </td> <td>Logarithmic </td>
</tr> <tr> <td>
<code>a_tran.equal_range(ke)</code> </td> <td>
<code><a href="http://en.cppreference.com/w/cpp/utility/pair"><span class="kw1100">std::<span class="me2">pair</span></span></a><span class="sy1">&lt;</span><br> iterator,<br> iterator&gt;</code>; <p><code><a href="http://en.cppreference.com/w/cpp/utility/pair"><span class="kw1100">std::<span class="me2">pair</span></span></a><span class="sy1">&lt;</span><br> const_iterator,<br> const_iterator&gt;</code> for constant <code>a_tran</code>.</p>
</td> <td> </td> <td>Equivalent to: <p><code>return<br> <a href="http://en.cppreference.com/w/cpp/utility/pair/make_pair"><span class="kw1101">std::<span class="me2">make_pair</span></span></a><span class="br0">(</span><br> a_tran.lower_bound(ke),<br> a_tran.upper_bound(ke));</code></p>
</td> <td> </td> <td>Logarithmic </td>
</tr> </table> <h4 id="Iterators"> Iterators</h4> <p>Iterators of associative containers satisfy the requirements of <a href="bidirectionaliterator" title="cpp/named req/BidirectionalIterator">LegacyBidirectionalIterator</a>.</p>
<p>For associative containers where <code>value_type</code> is the same as <code>key_type</code>, both <code>iterator</code> and <code>const_iterator</code> are constant iterators. It is unspecified whether or not <code>iterator</code> and <code>const_iterator</code> are the same type.</p>
<p>Iterators of associative containers iterate through the containers in the non-descending order of keys where non-descending is defined by the comparison that was used to construct the containers. That is, given.</p>
<ul>
<li> <code>a</code>, an associative container </li>
<li> <code>i</code> and <code>j</code>, dereferenceable iterators to <code>a</code>. </li>
</ul> <p>If the distance from <code>i</code> to <code>j</code> is positive, then <code>a.value_comp()(*j, *i) == false</code>. Additionally, if <code>a</code> is an associative container with unique keys, the stronger condition <code>a.value_comp()(*i, *j) != false</code> holds.</p>
<h3 id="Associative_containers_in_the_standard_library"> Associative containers in the standard library</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../container/set" title="cpp/container/set"> <span class="t-lines"><span>set</span></span></a></div> </td> <td> collection of unique keys, sorted by keys <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/multiset" title="cpp/container/multiset"> <span class="t-lines"><span>multiset</span></span></a></div> </td> <td> collection of keys, sorted by keys <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/map" title="cpp/container/map"> <span class="t-lines"><span>map</span></span></a></div> </td> <td> collection of key-value pairs, sorted by keys, keys are unique <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/multimap" title="cpp/container/multimap"> <span class="t-lines"><span>multimap</span></span></a></div> </td> <td> collection of key-value pairs, sorted by keys <br> <span class="t-mark">(class template)</span>  </td>
</tr> </table> <h3 id="Defect_reports"> Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th> DR </th> <th> Applied to </th> <th> Behavior as published </th> <th> Correct behavior </th>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue354">LWG 354</a> </td> <td> C++98 </td> <td> <code>lower_bound</code> and <code>upper_bound</code> did not<br>return the end iterator if no element is found </td> <td> they return the end<br>iterator in this case </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue589">LWG 589</a> </td> <td> C++98 </td> <td> the elements that <code>i</code> and <code>j</code> refer<br>to had the type <code>X::value_type</code> </td> <td> the elements are implicitly<br>convertible to <code>X::value_type</code> </td>
</tr>
</table>           <div class="_attribution">
  <p class="_attribution-p">
    © cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/named_req/AssociativeContainer" class="_attribution-link">https://en.cppreference.com/w/cpp/named_req/AssociativeContainer</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
