
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Object - C++ - W3cubDocs</title>
  
  <meta name="description" content=" C++ programs create, destroy, refer to, access, and manipulate objects. ">
  <meta name="keywords" content="object, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/language/objects.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/cpp.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _c">
				
				
<h1 id="firstHeading" class="firstHeading">Object</h1>            <p>C++ programs create, destroy, refer to, access, and manipulate <i>objects</i>.</p>
<p>An object, in C++, is a <i>region of storage</i> that has.</p>
<ul>
<li> size (can be determined with <a href="sizeof" title="cpp/language/sizeof">sizeof</a>); </li>
<li> alignment requirement (can be determined with <a href="alignof" title="cpp/language/alignof">alignof</a>); </li>
<li> <a href="storage_duration" title="cpp/language/storage duration">storage duration</a> (automatic, static, dynamic, thread-local); </li>
<li> <a href="lifetime" title="cpp/language/lifetime">lifetime</a> (bounded by storage duration or temporary); </li>
<li> <a href="type-id" title="cpp/language/type">type</a>; </li>
<li> value (which may be indeterminate, e.g. for <a href="default_initialization" title="cpp/language/default initialization">default-initialized</a> non-class types); </li>
<li> optionally, a <a href="name" title="cpp/language/name" class="mw-redirect">name</a>. </li>
</ul> <p>The following entities are not objects: value, reference, function, enumerator, type, non-static class member, bit-field, template, class or function template specialization, namespace, parameter pack, and <code>this</code>.</p>
<p>A <i>variable</i> is an object or a reference that is not a non-static data member, that is introduced by a <a href="declarations" title="cpp/language/declarations">declaration</a>.</p>
<p>Objects are created by <a href="definition" title="cpp/language/definition">definitions</a>, <a href="new" title="cpp/language/new">new-expressions</a>, <a href="throw" title="cpp/language/throw">throw-expressions</a>, when changing the active member of a <a href="union" title="cpp/language/union">union</a>, and where <a href="lifetime#Temporary_object_lifetime" title="cpp/language/lifetime">temporary objects</a> are required.</p>
<h3 id="Object_representation_and_value_representation">Object representation and value representation</h3> <p>For an object of type <code>T</code>, <i>object representation</i> is the sequence of <code>sizeof(T)</code> objects of type <code>unsigned char</code> (or, equivalently, <a href="../types/byte" title="cpp/types/byte"><code>std::byte</code></a>) beginning at the same address as the <code>T</code> object.</p>
<p>The <i>value representation</i> of an object is the set of bits that hold the value of its type <code>T</code>.</p>
<p>For <a href="../named_req/triviallycopyable" title="cpp/named req/TriviallyCopyable">TriviallyCopyable</a> types, value representation is a part of the object representation, which means that copying the bytes occupied by the object in the storage is sufficient to produce another object with the same value (except if the value is a <i>trap representation</i> of its type and loading it into the CPU raises a hardware exception, such as SNaN ("signalling not-a-number") floating-point values or NaT ("not-a-thing") integers).</p>
<p>The reverse is not necessarily true: two objects of <a href="../named_req/triviallycopyable" title="cpp/named req/TriviallyCopyable">TriviallyCopyable</a> type with different object representations may represent the same value. For example, multiple floating-point bit patterns represent the same special value <a href="../numeric/math/nan" title="cpp/numeric/math/NAN">NaN</a>. More commonly, some bits of the object representation may not participate in the value representation at all; such bits may be padding introduced to satisfy <a href="objects#Alignment" title="cpp/language/object">alignment requirements</a>, <a href="bit_field" title="cpp/language/bit field">bit field</a> sizes, etc.</p>
<div class="cpp source-cpp"><pre data-language="cpp">#include &lt;cassert&gt;
struct S {
    char c;  // 1 byte value
             // 3 bytes padding (assuming alignof(float) == 4)
    float f; // 4 bytes value (assuming sizeof(float) == 4)
    bool operator==(const S&amp; arg) const { // value-based equality
        return c == arg.c &amp;&amp; f == arg.f;
    }
};
 
void f() {
    assert(sizeof(S) == 8);
    S s1 = {'a', 3.14};
    S s2 = s1;
    reinterpret_cast&lt;unsigned char*&gt;(&amp;s1)[2] = 'b'; // change 2nd byte of padding
    assert(s1 == s2); // value did not change
}</pre></div> <p>For the objects of type <code>char</code>, <code>signed char</code>, and <code>unsigned char</code> (unless they are oversize <a href="bit_field" title="cpp/language/bit field">bit fields</a>), every bit of the object representation is required to participate in the value representation and each possible bit pattern represents a distinct value (no padding, trap bits, or multiple representations allowed).</p>
<h3 id="Subobjects">Subobjects</h3> <p>An object can contain other objects, which are called <i>subobjects</i>. These include.</p>
<ul>
<li> member objects </li>
<li> base class subobjects </li>
<li> array elements </li>
</ul> <p>An object that is not a subobject of another object is called <i>complete object</i>.</p>
<p>A subobject is <i>potentially overlapping</i> if it is either.</p>
<ul>
<li> a base class subobject, or </li>
<li> a non-static data member declared with the <code>[[<a href="attributes/no_unique_address" title="cpp/language/attributes/no unique address">no_unique_address</a>]]</code> attribute. </li>
</ul> <p>Complete objects, member objects, and array elements are also known as <i>most derived objects</i>, to distinguish them from base class subobjects. The size of a <i>most derived object</i> that is not a <a href="bit_field" title="cpp/language/bit field">bit field</a> <span class="t-rev-inl t-since-cxx20"><span>and not marked <code>[[<a href="attributes/no_unique_address" title="cpp/language/attributes/no unique address">no_unique_address</a>]]</code></span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span> is required to be non-zero (the size of a base class subobject may be zero <span class="t-rev-inl t-since-cxx20"><span>even without <code>[[no_unique_address]]</code></span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span>: see <a href="ebo" title="cpp/language/ebo">empty base optimization</a>).</p>
<p>Any two objects with overlapping <a href="lifetime" title="cpp/language/lifetime">lifetimes</a> (that are not <a href="bit_field" title="cpp/language/bit field">bit fields</a>) are guaranteed to have different addresses unless one of them is a subobject of another or provides storage for another, or if they are subobjects of different type within the same complete object, and one of them is a subobject of zero size.</p>
<div class="cpp source-cpp"><pre data-language="cpp">static const char c1 = 'x';
static const char c2 = 'x';
assert(&amp;c1 != &amp;c2); // same values, different addresses</pre></div> <h3 id="Polymorphic_objects">Polymorphic objects</h3> <p>Objects of a class type that declares or inherits at least one virtual function are polymorphic objects. Within each polymorphic object, the implementation stores additional information (in every existing implementation, it is one pointer unless optimized out), which is used by <a href="virtual" title="cpp/language/virtual">virtual function</a> calls and by the RTTI features (<a href="dynamic_cast" title="cpp/language/dynamic cast">dynamic_cast</a> and <a href="typeid" title="cpp/language/typeid">typeid</a>) to determine, at run time, the type with which the object was created, regardless of the expression it is used in.</p>
<p>For non-polymorphic objects, the interpretation of the value is determined from the expression in which the object is used, and is decided at compile time.</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
#include &lt;typeinfo&gt;
struct Base1 {
    // polymorphic type: declares a virtual member
    virtual ~Base1() {}
};
struct Derived1 : Base1 {
     // polymorphic type: inherits a virtual member
};
 
struct Base2 {
     // non-polymorphic type
};
struct Derived2 : Base2 {
     // non-polymorphic type
};
 
int main()
{
    Derived1 obj1; // object1 created with type Derived1
    Derived2 obj2; // object2 created with type Derived2
 
    Base1&amp; b1 = obj1; // b1 refers to the object obj1
    Base2&amp; b2 = obj2; // b2 refers to the object obj2
 
    std::cout &lt;&lt; "Expression type of b1: " &lt;&lt; typeid(decltype(b1)).name() &lt;&lt; ' '
              &lt;&lt; "Expression type of b2: " &lt;&lt; typeid(decltype(b2)).name() &lt;&lt; '\n'
              &lt;&lt; "Object type of b1: " &lt;&lt; typeid(b1).name() &lt;&lt; ' '
              &lt;&lt; "Object type of b2: " &lt;&lt; typeid(b2).name() &lt;&lt; '\n'
              &lt;&lt; "size of b1: " &lt;&lt; sizeof b1 &lt;&lt; ' '
              &lt;&lt; "size of b2: " &lt;&lt; sizeof b2 &lt;&lt; '\n';
}</pre></div> <p>Possible output:</p>
<div class="text source-text"><pre data-language="c">Expression type of b1: Base1 Expression type of b2: Base2
Object type of b1: Derived1 Object type of b2: Base2
size of b1: 8 size of b2: 1</pre></div> </div> <h3 id="Strict_aliasing">Strict aliasing</h3> <p>Accessing an object using an expression of a type other than the type with which it was created is undefined behavior in many cases, see <a href="reinterpret_cast#Type_aliasing" title="cpp/language/reinterpret cast">reinterpret_cast</a> for the list of exceptions and examples.</p>
<h3 id="Alignment">Alignment</h3> <p>Every <a href="type-id" title="cpp/language/type">object type</a> has the property called <i>alignment requirement</i>, which is an integer value (of type <code><a href="../types/size_t" title="cpp/types/size t">std::size_t</a></code>, always a power of 2) representing the number of bytes between successive addresses at which objects of this type can be allocated. The alignment requirement of a type can be queried with <a href="alignof" title="cpp/language/alignof">alignof</a> or <code><a href="../types/alignment_of" title="cpp/types/alignment of">std::alignment_of</a></code>. The pointer alignment function <code><a href="../memory/align" title="cpp/memory/align">std::align</a></code> can be used to obtain a suitably-aligned pointer within some buffer, and <code><a href="../types/aligned_storage" title="cpp/types/aligned storage">std::aligned_storage</a></code> can be used to obtain suitably-aligned storage.</p>
<p>Each object type imposes its alignment requirement on every object of that type; stricter alignment (with larger alignment requirement) can be requested using <a href="alignas" title="cpp/language/alignas">alignas</a>.</p>
<p>In order to satisfy alignment requirements of all non-static members of a <a href="class" title="cpp/language/class">class</a>, <i>padding</i> may be inserted after some of its members.</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
 
// objects of type S can be allocated at any address
// because both S.a and S.b can be allocated at any address
struct S {
  char a; // size: 1, alignment: 1
  char b; // size: 1, alignment: 1
}; // size: 2, alignment: 1
 
// objects of type X must be allocated at 4-byte boundaries
// because X.n must be allocated at 4-byte boundaries
// because int's alignment requirement is (usually) 4
struct X {
  int n;  // size: 4, alignment: 4
  char c; // size: 1, alignment: 1
  // three bytes padding
}; // size: 8, alignment: 4 
 
int main()
{
    std::cout &lt;&lt; "sizeof(S) = " &lt;&lt; sizeof(S)
              &lt;&lt; " alignof(S) = " &lt;&lt; alignof(S) &lt;&lt; '\n';
    std::cout &lt;&lt; "sizeof(X) = " &lt;&lt; sizeof(X)
              &lt;&lt; " alignof(X) = " &lt;&lt; alignof(X) &lt;&lt; '\n';
}</pre></div> <p>Possible output:</p>
<div class="text source-text"><pre data-language="c">sizeof(S) = 2 alignof(S) = 1
sizeof(X) = 8 alignof(X) = 4</pre></div> </div> <p>The weakest alignment (the smallest alignment requirement) is the alignment of <code>char</code>, <code>signed char</code>, and <code>unsigned char</code>, which equals 1; the largest <i>fundamental alignment</i> of any type is the alignment of <code><a href="../types/max_align_t" title="cpp/types/max align t">std::max_align_t</a></code>. If a type's alignment is made stricter (larger) than <code><a href="../types/max_align_t" title="cpp/types/max align t">std::max_align_t</a></code> using <a href="alignas" title="cpp/language/alignas">alignas</a>, it is known as a type with <i>extended alignment</i> requirement. A type whose alignment is extended or a class type whose non-static data member has extended alignment is an <i>over-aligned type</i>. It is implementation-defined if <a href="new" title="cpp/language/new">new-expression</a>, <code><a href="../memory/allocator/allocate" title="cpp/memory/allocator/allocate">std::allocator::allocate</a></code>, and <code><a href="../memory/get_temporary_buffer" title="cpp/memory/get temporary buffer">std::get_temporary_buffer</a></code> support over-aligned types. <a href="../named_req/allocator" title="cpp/named req/Allocator">Allocators</a> instantiated with over-aligned types are allowed to fail to instantiate at compile time, to throw <code><a href="../memory/new/bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code> at runtime, to silently ignore unsupported alignment requirement, or to handle them correctly.</p>
<h3 id="See_also">See also</h3>           <div class="_attribution">
  <p class="_attribution-p">
    Â© cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/language/objects" class="_attribution-link">http://en.cppreference.com/w/cpp/language/objects</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
