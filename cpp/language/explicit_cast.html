
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Explicit Type Conversion - C++ - W3cubDocs</title>
  
  <meta name="description" content=" Converts between types using a combination of explicit and implicit conversions. ">
  <meta name="keywords" content="explicit, type, conversion, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/language/explicit_cast.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-1810d67ab7e57be09d8247710d2feb6954566959eb82322d1fee3a0c9156f56974b78ebaa9928774f00767342bbe58b0799d91fcc336b92b319170b196f9b64b.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/cpp.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _c">
				
				
<h1 id="firstHeading" class="firstHeading">Explicit type conversion</h1>            <p>Converts between types using a combination of explicit and implicit conversions.</p>
<h3 id="Syntax"> Syntax</h3> <table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <code>(</code> <span class="t-spar">new-type</span> <code>)</code> <span class="t-spar">expression</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">new-type</span> <code>(</code> <span class="t-spar">expression-list</span><span class="t-mark">(optional)</span> <code>)</code> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">new-type</span> <code>{</code> <span class="t-spar">expression-list</span><span class="t-mark">(optional)</span> <code>}</code> </td> <td> (3) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">template-name</span> <code>(</code> <span class="t-spar">expression-list</span><span class="t-mark">(optional)</span> <code>)</code> </td> <td> (4) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">template-name</span> <code>{</code> <span class="t-spar">expression-list</span><span class="t-mark">(optional)</span> <code>}</code> </td> <td> (5) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <code>auto</code> <code>(</code> <span class="t-spar">expression</span> <code>)</code> </td> <td> (6) </td> <td> <span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <code>auto</code> <code>{</code> <span class="t-spar">expression</span> <code>}</code> </td> <td> (7) </td> <td> <span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td>
</tr> 
</table> <p>Returns a value of type <span class="t-spar">new-type</span>.</p>
<h3 id="Explanation"> Explanation</h3> <div class="t-li1">
<span class="t-li">1)</span> When the <i>C-style cast expression</i> is encountered, the compiler attempts to interpret it as the following cast expressions, in this order:</div> <div class="t-li2">
<span class="t-li">a)</span> <code><a href="const_cast" title="cpp/language/const cast">const_cast</a>&lt;<span class="t-spar">new-type</span>&gt;(<span class="t-spar">expression</span>)</code>;</div> <div class="t-li2">
<span class="t-li">b)</span> <code><a href="static_cast" title="cpp/language/static cast">static_cast</a>&lt;<span class="t-spar">new-type</span>&gt;(<span class="t-spar">expression</span>)</code>, with extensions: pointer or reference to a <a href="derived_class" title="cpp/language/derived class">derived class</a> is additionally allowed to be cast to pointer or reference to unambiguous base class (and vice versa) even if the base class is <a href="access" title="cpp/language/access">inaccessible</a> (that is, this cast ignores the private inheritance specifier). Same applies to casting <a href="pointer" title="cpp/language/pointer">pointer to member</a> to pointer to member of unambiguous non-virtual base;</div> <div class="t-li2">
<span class="t-li">c)</span> <code>static_cast</code> (with extensions) followed by <code>const_cast</code>;</div> <div class="t-li2">
<span class="t-li">d)</span> <code><a href="reinterpret_cast" title="cpp/language/reinterpret cast">reinterpret_cast</a>&lt;<span class="t-spar">new-type</span>&gt;(<span class="t-spar">expression</span>)</code>;</div> <div class="t-li2">
<span class="t-li">e)</span> <code>reinterpret_cast</code> followed by <code>const_cast</code>.</div> <div class="t-li1">
 The first choice that satisfies the requirements of the respective cast operator is selected, even if it cannot be compiled (see example). If the cast can be interpreted in more than one way as <code>static_cast</code> followed by a <code>const_cast</code>, it cannot be compiled.</div> <div class="t-li1">
 In addition, C-style cast notation is allowed to cast from, to, and between pointers to incomplete class type. If both <span class="t-spar">expression</span> and <span class="t-spar">new-type</span> are pointers to incomplete class types, it's unspecified whether <code>static_cast</code> or <code>reinterpret_cast</code> gets selected.</div> <span class="t-li">2)</span> The <i>functional-style cast expression</i> consists of a simple type specifier or a typedef specifier (in other words, a single-word type name, that is, cases such as <code>unsigned int(expression)</code> and <code>int*(expression)</code> are not valid), followed by a comma-separated list of expressions in parentheses. <ul>
<li> If there is exactly one expression in parentheses, this cast expression is exactly equivalent to the corresponding C-style cast expression. </li>
<li> If there are more than one expression <span class="t-rev-inl t-since-cxx11"><span>or <a href="list_initialization" title="cpp/language/list initialization">braced-init-list</a></span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span> in parentheses, <span class="t-spar">new-type</span> must be a class with a suitably declared <a href="constructor" title="cpp/language/constructor">constructor</a>. This expression is a prvalue of type <span class="t-spar">new-type</span> <span class="t-rev-inl t-until-cxx17"><span>designating a temporary</span> <span><span class="t-mark-rev t-until-cxx17">(until C++17)</span></span></span><span class="t-rev-inl t-since-cxx17"><span>whose result object is</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> <a href="direct_initialization" title="cpp/language/direct initialization">direct-initialized</a> with <span class="t-spar">expression-list</span>. </li>
<li> If there's no expression in parentheses: if <span class="t-spar">new-type</span> names a non-array complete object type, this expression is an prvalue of type <span class="t-spar">new-type</span>, <span class="t-rev-inl t-until-cxx17"><span>designating a temporary</span> <span><span class="t-mark-rev t-until-cxx17">(until C++17)</span></span></span><span class="t-rev-inl t-since-cxx17"><span>whose result object is (possibly with added cv-qualifiers)</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> of that type. If <span class="t-spar">new-type</span> is an object type, the object is <a href="value_initialization" title="cpp/language/value initialization">value-initialized</a>. If <span class="t-spar">new-type</span> is (possibly <a href="cv" title="cpp/language/cv">cv-qualified</a>) <code>void</code>, the expression is a <code>void</code> prvalue <span class="t-rev-inl t-since-cxx17"><span>without a result object</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span>.</li>
</ul> <div class="t-li1">
<span class="t-li">3)</span> A single-word type name followed by a <i>braced-init-list</i> is a prvalue of the specified type <span class="t-rev-inl t-until-cxx17"><span>designating a temporary</span> <span><span class="t-mark-rev t-until-cxx17">(until C++17)</span></span></span><span class="t-rev-inl t-since-cxx17"><span>whose result object is</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> <a href="list_initialization" title="cpp/language/list initialization">direct-list-initialized</a> with the specified <i>braced-init-list</i>. If <span class="t-spar">new-type</span> is (possibly <a href="cv" title="cpp/language/cv">cv-qualified</a>) <code>void</code>, the expression is a <code>void</code> prvalue <span class="t-rev-inl t-since-cxx17"><span>without a result object</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span>. <span class="t-rev-inl t-until-cxx20"><span> This is the only cast expression that can create an <a href="array#Array_rvalues" title="cpp/language/array">array prvalue</a>.</span> <span><span class="t-mark-rev t-until-cxx20">(until C++20)</span></span></span>
</div> <div class="t-li1">
<span class="t-li">4,5)</span> Same as <span class="t-v">(2,3)</span>, except first performs <a href="class_template_argument_deduction" title="cpp/language/class template argument deduction">class template argument deduction</a>.</div> <div class="t-li1">
<span class="t-li">6,7)</span> The <a href="auto" title="cpp/language/auto"><code>auto</code></a> specifier is replaced with the deduced type of the invented variable <code>x</code> declared with <code>auto x(expression);</code> (which is never interpreted as a function declaration) or <code>auto x{expression};</code> respectively. The result is always a prvalue of an object type.</div> <p>As with all cast expressions, the result is:</p>
<table class="t-rev-begin"> <tr class="t-rev t-until-cxx11">
<td> <ul>
<li> an lvalue if <span class="t-spar">new-type</span> is a reference type; </li>
<li> an rvalue otherwise. </li>
</ul> </td> <td><span class="t-mark-rev t-until-cxx11">(until C++11)</span></td>
</tr> <tr class="t-rev t-since-cxx11">
<td> <ul>
<li> an lvalue if <span class="t-spar">new-type</span> is an lvalue reference type or an rvalue reference to function type; </li>
<li> an xvalue if <span class="t-spar">new-type</span> is an rvalue reference to object type; </li>
<li> a prvalue otherwise. </li>
</ul> </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <h3 id="Ambiguity_Resolution"> Ambiguity Resolution</h3> <p>In the case of an ambiguity between a expression statement with a function-style cast expression as its leftmost subexpression and a declaration statement, the ambiguity is resolved by treating it as a declaration. This disambiguation is purely syntactic: it does not consider the meaning of names occurring in the statement other than whether they are type names:</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct M {};
struct L { L(M&amp;); };
 
M n;
void f()
{
    M(m);    // declaration, equivalent to M m;
    L(n);    // ill-formed declaration
    L(l)(m); // still a declaration
}</pre></div> <p>The ambiguity above can also occur in the context of a declaration. In that context, the choice is between a function declaration with a redundant set of parentheses around a parameter name and an object declaration with a function-style cast as the initializer. The resolution is also to consider any construct that could possibly be a declaration a declaration:</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct S
{
    S(int);
};
 
void foo(double a)
{
    S w(int(a)); // function declaration: has a parameter `a` of type int
    S x(int());  // function declaration: has an unnamed parameter of type int
 
    // Ways to avoid ambiguity:
    S y((int(a))); // object declaration: extra pair of parentheses
    S y((int)a);   // object declaration: C-style cast
    S z = int(a);  // object declaration: no ambiguity for this syntax
}</pre></div> <p>An ambiguity can arise from the similarity between a function-style cast and a <a href="type#Type_naming" title="cpp/language/type">type-id</a>. The resolution is that any construct that could possibly be a type-id in its syntactic context shall be considered a type-id:</p>
<div class="cpp source-cpp"><pre data-language="cpp">// `int()` and `int(unsigned(a))` can both be parsed as type-id:
// `int()`            represents a function returning int
//                    and taking no argument
// `int(unsigned(a))` represents a function returning int
//                    and taking an argument of type unsigned
void foo(signed char a)
{
    sizeof(int());            // type-id (ill-formed)
    sizeof(int(a));           // expression
    sizeof(int(unsigned(a))); // type-id (ill-formed)
 
    (int()) + 1;            // type-id (ill-formed)
    (int(a)) + 1;           // expression
    (int(unsigned(a))) + 1; // type-id (ill-formed)
}</pre></div> <h3 id="Example"> Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;cassert&gt;
#include &lt;iostream&gt;
 
double f = 3.14;
unsigned int n1 = (unsigned int)f; // C-style cast
unsigned int n2 = unsigned(f);     // function-style cast
 
class C1;
class C2;
C2* foo(C1* p)
{
    return (C2*)p; // casts incomplete type to incomplete type
}
 
void cpp23_decay_copy_demo()
{
    auto inc_print = [](int&amp; x, const int&amp; y)
    {
        ++x;
        std::cout &lt;&lt; "x:" &lt;&lt; x &lt;&lt; ", y:" &lt;&lt; y &lt;&lt; '\n';
    };
 
    int p{1};
    inc_print(p, p); // prints x:2 y:2, because param y here is an alias of p
    int q{1};
    inc_print(q, auto{q}); // prints x:2 y:1, auto{q} (C++23) casts to prvalue,
                           // so the param y is a copy of q (not an alias of q)
}
 
// In this example, C-style cast is interpreted as static_cast
// even though it would work as reinterpret_cast
struct A {};
struct I1 : A {};
struct I2 : A {};
struct D : I1, I2 {};
 
int main()
{
    D* d = nullptr;
//  A* a = (A*)d;                   // compile-time error
    A* a = reinterpret_cast&lt;A*&gt;(d); // this compiles
    assert(a == nullptr);
 
    cpp23_decay_copy_demo();
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">x:2 y:2
x:2 y:1</pre></div> </div> <h3 id="References"> References</h3>  <ul>
<li> C++20 standard (ISO/IEC 14882:2020): </li>
<ul>
<li> 7.6.1.4 Explicit type conversion (functional notation) [expr.type.conv] </li>
<li> 7.6.3 Explicit type conversion (cast notation) [expr.cast] </li>
</ul>
<li> C++17 standard (ISO/IEC 14882:2017): </li>
<ul>
<li> 8.2.3 Explicit type conversion (functional notation) [expr.type.conv] </li>
<li> 8.4 Explicit type conversion (cast notation) [expr.cast] </li>
</ul>
<li> C++14 standard (ISO/IEC 14882:2014): </li>
<ul>
<li> 5.2.3 Explicit type conversion (functional notation) [expr.type.conv] </li>
<li> 5.4 Explicit type conversion (cast notation) [expr.cast] </li>
</ul>
<li> C++11 standard (ISO/IEC 14882:2011): </li>
<ul>
<li> 5.2.3 Explicit type conversion (functional notation) [expr.type.conv] </li>
<li> 5.4 Explicit type conversion (cast notation) [expr.cast] </li>
</ul>
<li> C++03 standard (ISO/IEC 14882:2003): </li>
<ul>
<li> 5.2.3 Explicit type conversion (functional notation) [expr.type.conv] </li>
<li> 5.4 Explicit type conversion (cast notation) [expr.cast] </li>
</ul>
<li> C++98 standard (ISO/IEC 14882:1998): </li>
<ul>
<li> 5.2.3 Explicit type conversion (functional notation) [expr.type.conv] </li>
<li> 5.4 Explicit type conversion (cast notation) [expr.cast] </li>
</ul>
</ul>                             <h3 id="See_also"> See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <a href="const_cast" title="cpp/language/const cast"> <code>const_cast</code> conversion </a> </td> <td> adds or removes const </td>
</tr> <tr class="t-dsc"> <td> <a href="static_cast" title="cpp/language/static cast"> <code>static_cast</code> conversion </a> </td> <td> performs basic conversions </td>
</tr> <tr class="t-dsc"> <td> <a href="dynamic_cast" title="cpp/language/dynamic cast"> <code>dynamic_cast</code> conversion </a> </td> <td> performs checked polymorphic conversions </td>
</tr> <tr class="t-dsc"> <td> <a href="reinterpret_cast" title="cpp/language/reinterpret cast"> <code>reinterpret_cast</code> conversion </a> </td> <td> performs general low-level conversions </td>
</tr> <tr class="t-dsc"> <td> <a href="implicit_cast" title="cpp/language/implicit cast" class="mw-redirect"> standard conversions </a> </td> <td> implicit conversions from one type to another </td>
</tr> <tr class="t-dsc"> <td colspan="2"> <span><a href="https://en.cppreference.com/w/c/language/cast" title="c/language/cast">C documentation</a></span> for <span class=""><span>cast operator</span></span> </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    Â© cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/language/explicit_cast" class="_attribution-link">https://en.cppreference.com/w/cpp/language/explicit_cast</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
