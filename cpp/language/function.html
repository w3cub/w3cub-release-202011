
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Function Declaration - C++ - W3cubDocs</title>
  
  <meta name="description" content="A function declaration introduces the function name and its type. A function definition associates the function name&#47;type with the function body &hellip;">
  <meta name="keywords" content="function, declaration, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/language/function.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/cpp.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _c">
				
				
<h1 id="firstHeading" class="firstHeading">Function declaration</h1>            <p>A function declaration introduces the function name and its type. A function definition associates the function name/type with the function body.</p>
<h3 id="Function_declaration">Function declaration</h3> <p>Function declarations may appear in any scope. A function declaration at class scope introduces a class member function (unless the friend specifier is used), see <a href="member_functions" title="cpp/language/member functions">member functions</a> and <a href="friend" title="cpp/language/friend">friend functions</a> for details.</p>
<p>The type of the function being declared is composed from the <i>return type</i> (provided by the <span class="t-spar">decl-specifier-seq</span> of the <a href="declarations" title="cpp/language/declarations">declaration syntax</a>) and the function <span class="t-spar">declarator</span>.</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">noptr-declarator</span> <code>(</code> <span class="t-spar">parameter-list</span> <code>)</code> <span class="t-spar">cv</span><span class="t-mark">(optional)</span> <span class="t-spar">ref</span><span class="t-mark">(optional)</span> <span class="t-spar">except</span><span class="t-mark">(optional)</span> <span class="t-spar">attr</span><span class="t-mark">(optional)</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">noptr-declarator</span> <code>(</code> <span class="t-spar">parameter-list</span> <code>)</code> <span class="t-spar">cv</span><span class="t-mark">(optional)</span> <span class="t-spar">ref</span><span class="t-mark">(optional)</span> <span class="t-spar">except</span><span class="t-mark">(optional)</span> <span class="t-spar">attr</span><span class="t-mark">(optional)</span> <code>-&gt;</code> <span class="t-spar">trailing</span> </td> <td> (2) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr> 
</table> <p>(see <a href="declarations" title="cpp/language/declarations">Declarations</a> for the other forms of the <span class="t-spar">declarator</span> syntax).</p>
<div class="t-li1">
<span class="t-li">1)</span> Regular function declarator syntax</div> <div class="t-li1">
<span class="t-li">2)</span> Trailing return type declaration: trailing return type is only allowed on the outermost function declarator. The decl-specifier-seq in this case must contain the keyword <code>auto</code> </div> <table class="t-par-begin"> <tr class="t-par"> <td> <span class="t-spar">noptr-declarator</span> </td> <td> - </td> <td> any valid <span class="t-spar">declarator</span>, but if it begins with *, &amp;, or &amp;&amp;, it has to be surrounded by parentheses. </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">parameter-list</span> </td> <td> - </td> <td> possibly empty, comma-separated list of the function parameters (see below for details) </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">attr</span><span class="t-mark-rev t-since-cxx11">(C++11)</span> </td> <td> - </td> <td> optional list of <a href="attributes" title="cpp/language/attributes">attributes</a>. These attributes are applied to the type of the function, not the function itself. The attributes for the function appear after the identifier within the declarator and are combined with the attributes that appear in the beginning of the declaration, if any. </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">cv</span> </td> <td> - </td> <td> const/volatile qualification, only allowed in non-static member function declarations </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">ref</span><span class="t-mark-rev t-since-cxx11">(C++11)</span> </td> <td> - </td> <td> ref-qualification, only allowed in non-static member function declarations </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">except</span> </td> <td> - </td> <td> either <a href="except_spec" title="cpp/language/except spec">dynamic exception specification</a><span class="t-mark-rev t-until-cxx17">(until C++17)</span> or <a href="noexcept_spec" title="cpp/language/noexcept spec">noexcept specification</a><span class="t-mark-rev t-since-cxx11">(C++11)</span> <span class="t-rev-inl t-until-cxx17"><span>Note that the exception specification is not part of the function type</span> <span><span class="t-mark-rev t-until-cxx17">(until C++17)</span></span></span> </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">trailing</span><span class="t-mark-rev t-since-cxx11">(C++11)</span> </td> <td> - </td> <td> Trailing return type, useful if the return type depends on argument names, such as <code>template &lt;class T, class U&gt; auto add(T t, U u) -&gt; decltype(t + u);</code> or is complicated, such as in <code>auto fpif(int)-&gt;int(*)(int)</code> </td>
</tr>
</table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>As mentioned in <a href="declarations#Declarators" title="cpp/language/declarations">Declarations</a>, the declarator can be followed by a <i>requires</i> clause, which declares the associated <a href="constraints" title="cpp/language/constraints">constraints</a> for the function, which must be satisfied in order for the function to be selected by <a href="overload_resolution" title="cpp/language/overload resolution">overload resolution</a>. (example: <code>void f1(int a) requires true;</code>) Note that the associated constraint is part of function signature, but not part of function type.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <p>Function declarators can be mixed with other declarators, where decl-specifier-seq allows:</p>
<div class="cpp source-cpp"><pre data-language="cpp">// declares an int, an int*, a function, and a pointer to a function
int a = 1, *p = NULL, f(), (*pf)(double);
// decl-specifier-seq is int
// declarator f() declares (but doesn't define)
//                a function taking no arguments and returning int
 
struct S
{
    virtual int f(char) const, g(int) &amp;&amp;; // declares two non-static member functions
    virtual int f(char), x; // compile-time error: virtual (in decl-specifier-seq)
                            // is only allowed in declarations of non-static
                            // member functions
};</pre></div> <p>The return type of a function cannot be a function type or an array type (but can be a pointer or reference to those).</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>As with any declaration, attributes that appear before the declaration and the attributes that appear immediately after the identifier within the declarator both apply to the entity being declared or defined (in this case, to the function).</p>
<div class="cpp source-cpp"><pre data-language="cpp">[[noreturn]] void f [[noreturn]] (); // okay: both attributes apply to the function f</pre></div> <p>However, the attributes that appear after the declarator (in the syntax above), apply to the type of the function, not to the function itself.</p>
<div class="cpp source-cpp"><pre data-language="cpp">void f() [[noreturn]]; // error: this attribute has no effect on a type</pre></div> </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <p>As with any declaration, the type of the function <code>func</code> declared as <code>ret func(params)</code> is <code>ret(params)</code> (except for parameter type rewriting described below): see <a href="type-id#Type_naming" title="cpp/language/type">type naming</a>.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx14">
<td> <h3 id="Return_type_deduction"> Return type deduction</h3> <p>If the <i>decl-specifier-seq</i> of the function declaration contains the keyword <code>auto</code>, trailing return type may be omitted, and will be deduced by the compiler from the type of the expression used in the <a href="return" title="cpp/language/return">return</a> statement. If the return type does not use <code>decltype(auto)</code>, the deduction follows the rules of <a href="template_argument_deduction#Other_contexts" title="cpp/language/template argument deduction">template argument deduction</a>.</p>
<div class="cpp source-cpp"><pre data-language="cpp">int x = 1;
auto f() { return x; }        // return type is int
const auto&amp; f() { return x; } // return type is const int&amp;</pre></div> <p>If the return type is <code>decltype(auto)</code>, the return type is as what would be obtained if the expression used in the return statement were wrapped in <a href="decltype" title="cpp/language/decltype">decltype</a>.</p>
<div class="cpp source-cpp"><pre data-language="cpp">int x = 1;
decltype(auto) f() { return x; }  // return type is int, same as decltype(x)
decltype(auto) f() { return(x); } // return type is int&amp;, same as decltype((x))</pre></div> <p>(note: "<code>const decltype(auto)&amp;</code>" is an error, <code>decltype(auto)</code> must be used on its own).</p>
<p>If there are multiple return statements, they must all deduce to the same type.</p>
<div class="cpp source-cpp"><pre data-language="cpp">auto f(bool val)
{
    if (val) return 123; // deduces return type int
    else return 3.14f;   // error: deduces return type float
}</pre></div> <p>If there is no return statement or if the argument of the return statement is a void expression, the declared return type must be either <code>decltype(auto)</code>, in which case the deduced return type is <code>void</code>, or (possibly cv-qualified) <code>auto</code> , in which case the deduced return type is then (identically cv-qualified) <code>void</code>.</p>
<div class="cpp source-cpp"><pre data-language="cpp">auto f() {}              // returns void
auto g() { return f(); } // returns void
auto* x() {}             // error: cannot deduce auto* from void</pre></div> <p>Once a return statement has been seen in a function, the return type deduced from that statement can be used in the rest of the function, including in other return statements.</p>
<div class="cpp source-cpp"><pre data-language="cpp">auto sum(int i)
{
    if (i == 1)
        return i;              // sum’s return type is int
    else
        return sum(i - 1) + i; // okay: sum’s return type is already known
}</pre></div> <p>If the return statement uses a brace-init-list, deduction is not allowed:</p>
<div class="cpp source-cpp"><pre data-language="cpp">auto func () { return {1, 2, 3}; } // error</pre></div> <p><a href="virtual" title="cpp/language/virtual">Virtual functions</a> cannot use return type deduction.</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct F
{
    virtual auto f() { return 2; } // error
};</pre></div> <p>If a function uses return type deduction, it cannot be redeclared using the type that it deduces to, or another kind of return type deduction even if it deduces to the same type.</p>
<div class="cpp source-cpp"><pre data-language="cpp">auto f();               // declared, not yet defined
auto f() { return 42; } // defined, return type is int
int f();                // error: cannot use the deduced type
decltype(auto) f();     // error: different kind of deduction
auto f();               // okay: re-declared
 
template&lt;typename T&gt;
struct A { friend T frf(T); };
auto frf(int i) { return i; } // not a friend of A&lt;int&gt;</pre></div> <p><a href="function_template" title="cpp/language/function template">Function templates</a> other than <a href="cast_operator" title="cpp/language/cast operator">user-defined conversion functions</a> can use return type deduction. The deduction takes place at instantiation even if the expression in the return statement is not <a href="dependent_name" title="cpp/language/dependent name">dependent</a>. This instantiation is not in an immediate context for the purposes of <a href="sfinae" title="cpp/language/sfinae">SFINAE</a>.</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;class T&gt; auto f(T t) { return t; }
typedef decltype(f(1)) fint_t;    // instantiates f&lt;int&gt; to deduce return type
template&lt;class T&gt; auto f(T* t) { return *t; }
void g() { int (*p)(int*) = &amp;f; } // instantiates both fs to determine return types,
                                  // chooses second template overload</pre></div> <p>Specializations of function templates that use return type deduction must use the same return type placeholders.</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename T&gt; auto g(T t) { return t; } // #1
template auto g(int);      // okay: return type is int
//template char g(char);     // error: no matching template
 
template&lt;&gt; auto g(double); // okay: forward declaration with unknown return type
template&lt;typename T&gt; T g(T t) { return t; } // okay: not equivalent to #1
template char g(char);     // okay: now there is a matching template
template auto g(float);    // still matches #1
//void h() { return g(42); } // error: ambiguous</pre></div> <p><a href="function_template#Explicit_instantiation" title="cpp/language/function template">Explicit instantiation declarations</a> do not themselves instantiate function templates that use return type deduction.</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename T&gt; auto f(T t) { return t; }
extern template auto f(int); // does not instantiate f&lt;int&gt;
int (*p)(int) = f; // instantiates f&lt;int&gt; to determine its return type,
                   // but an explicit instantiation definition 
                   // is still required somewhere in the program</pre></div> </td> <td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr> </table> <h3 id="Parameter_list">Parameter list</h3> <p>Parameter list determines the arguments that can be specified when the function is called. It is a comma-separated list of <i>parameter declarations</i>, each of which has the following syntax.</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">attr</span><span class="t-mark">(optional)</span> <span class="t-spar">decl-specifier-seq</span> <span class="t-spar">declarator</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">attr</span><span class="t-mark">(optional)</span> <span class="t-spar">decl-specifier-seq</span> <span class="t-spar">declarator</span> <code>= </code> <span class="t-spar">initializer</span> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">attr</span><span class="t-mark">(optional)</span> <span class="t-spar">decl-specifier-seq</span> <span class="t-spar">abstract-declarator</span><span class="t-mark">(optional)</span> </td> <td> (3) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">attr</span><span class="t-mark">(optional)</span> <span class="t-spar">decl-specifier-seq</span> <span class="t-spar">abstract-declarator</span><span class="t-mark">(optional)</span> <code>= </code> <span class="t-spar">initializer</span> </td> <td> (4) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>void</code> </td> <td> (5) </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <div class="t-li1">
<span class="t-li">1)</span> Declares a named (formal) parameter. For the meanings of <span class="t-spar">decl-specifier-seq</span> and <span class="t-spar">declarator</span>, see <a href="declarations" title="cpp/language/declarations">declarations</a>. <div class="cpp source-cpp"><pre data-language="cpp">int f(int a, int *p, int (*(*x)(double))[3]);</pre></div>
</div> <div class="t-li1">
<span class="t-li">2)</span> Declares a named (formal) parameter with a <a href="default_arguments" title="cpp/language/default arguments">default value</a>. <div class="cpp source-cpp"><pre data-language="cpp">int f(int a = 7, int *p = nullptr, int (*(*x)(double))[3] = nullptr);</pre></div>
</div> <div class="t-li1">
<span class="t-li">3)</span> Declares an unnamed parameter <div class="cpp source-cpp"><pre data-language="cpp">int f(int, int *, int (*(*)(double))[3]);</pre></div>
</div> <div class="t-li1">
<span class="t-li">4)</span> Declares an unnamed parameter with a <a href="default_arguments" title="cpp/language/default arguments">default value</a> <div class="cpp source-cpp"><pre data-language="cpp">int f(int = 7, int * = nullptr, int (*(*)(double))[3] = nullptr);</pre></div>
</div> <div class="t-li1">
<span class="t-li">5)</span> Indicates that the function takes no parameters, it is the exact synonym for an empty parameter list: <code>int f(void);</code> and <code>int f();</code> declare the same function. Note that the type <code>void</code> (possibly cv-qualified) cannot be used in a parameter list otherwise: <code>int f(void, int);</code> and <code>int f(const void);</code> are errors (although derived types, such as <code>void*</code> can be used). <span class="t-rev-inl t-since-cxx11"><span>In a template, only non-dependent void type can be used (a function taking a single parameter of type <code>T</code> does not become a no-parameter function if instantiated with <code>T = void</code>)</span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>
</div> <p>An ellipsis <code>...</code> may appear at the end of the parameter list; this declares a <a href="variadic_arguments" title="cpp/language/variadic arguments">variadic function</a>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">int printf(const char* fmt ...);</pre></div> <p>For compatibility with C89, an optional comma may appear before the ellipsis if the parameter list contains at least one parameter:</p>
<div class="cpp source-cpp"><pre data-language="cpp">int printf(const char* fmt, ...); // OK, same as above</pre></div> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx17">
<td> <p>Although <span class="t-spar">decl-specifier-seq</span> implies there can exist <a href="declarations#Specifiers" title="cpp/language/declarations">specifiers</a> other than type specifiers, the only other specifier allowed is <code>register</code> <span class="t-rev-inl t-until-cxx11"><span>as well as <code>auto</code> </span> <span><span class="t-mark-rev t-until-cxx11">(until C++11)</span></span></span>, and it has no effect.</p>
</td> <td><span class="t-mark-rev t-until-cxx17">(until C++17)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>If any of the function parameters uses a <i>placeholder</i> (either <code>auto</code> or a <a href="../concepts" title="cpp/concepts">Concept type</a>), the function declaration is instead an <a href="function_template#Abbreviated_function_template" title="cpp/language/function template">abbreviated function template</a> declaration:</p>
<div class="cpp source-cpp"><pre data-language="cpp">void f1(auto);    // same as template&lt;class T&gt; void f(T)
void f2(C1 auto); // same as template&lt;C1 T&gt; void f7(T), if C1 is a concept</pre></div> </td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <p>Parameter names declared in function declarations are usually for only self-documenting purposes. They are used (but remain optional) in function definitions.</p>
<p>The type of each function parameter in the parameter list is determined according to the following rules:</p>
<div class="t-li1">
<span class="t-li">1)</span> First, <span class="t-spar">decl-specifier-seq</span> and the declarator are combined as in any <a href="declarations" title="cpp/language/declarations">declaration</a> to determine the type.</div> <div class="t-li1">
<span class="t-li">2)</span> If the type is "array of T" or "array of unknown bound of T", it is replaced by the type "pointer to T"</div> <div class="t-li1">
<span class="t-li">3)</span> If the type is a function type F, it is replaced by the type "pointer to F"</div> <div class="t-li1">
<span class="t-li">4)</span> Top-level cv-qualifiers are dropped from the parameter type (This adjustment only affects the function type, but doesn't modify the property of the parameter: <code>int f(const int p, decltype(p)*);</code> and <code>int f(int, const int*);</code> declare the same function) </div> <p>Because of these rules, the following function declarations declare exactly the same function:</p>
<div class="cpp source-cpp"><pre data-language="cpp">int f(char s[3]);
int f(char[]);
int f(char* s);
int f(char* const);
int f(char* volatile s);</pre></div> <p>The following declarations also declare exactly the same function.</p>
<div class="cpp source-cpp"><pre data-language="cpp">int f(int());
int f(int (*g)());</pre></div> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx14">
<td> <p>Parameter type cannot be a type that includes a reference or a pointer to array of unknown bound, including a multi-level pointers/arrays of such types, or a pointer to functions whose parameters are such types.</p>
</td> <td><span class="t-mark-rev t-until-cxx14">(until C++14)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>The ellipsis that indicates <a href="variadic_arguments" title="cpp/language/variadic arguments">variadic arguments</a> need not be preceded by a comma, even if it follows the ellipsis that indicates a <a href="parameter_pack" title="cpp/language/parameter pack">parameter pack</a> expansion, so the following function templates are exactly the same:</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename ...Args&gt; void f(Args..., ...);
template&lt;typename ...Args&gt; void f(Args... ...);
template&lt;typename ...Args&gt; void f(Args......);</pre></div> <p>An example of when such declaration is used is the implementation of <code><a href="../types/is_function"><span class="kw478">std::<span class="me2">is_function</span></span></a></code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <h3 id="Function_definition">Function definition</h3> <p>A non-member function definition may appear at namespace scope only (there are no nested functions). A <a href="member_functions" title="cpp/language/member functions">member function</a> definition may also appear in the body of a <a href="class" title="cpp/language/class">class definition</a>. They have the following syntax:</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td class="t-sdsc-nopad"> <span class="t-spar">attr</span><span class="t-mark">(optional)</span> <span class="t-spar">decl-specifier-seq</span><span class="t-mark">(optional)</span> <span class="t-spar">declarator</span> <span class="t-spar">virt-specifier-seq</span><span class="t-mark">(optional)</span> <span class="t-spar">function-body</span> </td> <td class="t-sdsc-nopad"> </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <p>where <span class="t-spar">function-body</span> is one of the following.</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">ctor-initializer</span><span class="t-mark">(optional)</span> <span class="t-spar">compound-statement</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">function-try-block</span> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>=</code> <code>delete</code> <code>;</code> </td> <td> (3) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <code>=</code> <code>default</code> <code>;</code> </td> <td> (4) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr> 
</table> <div class="t-li1">
<span class="t-li">1)</span> regular function body</div> <div class="t-li1">
<span class="t-li">2)</span> <a href="function-try-block" title="cpp/language/function-try-block">function-try-block</a> (which is a regular function body wrapped in a try/catch block)</div> <div class="t-li1">
<span class="t-li">3)</span> explicitly deleted function definition</div> <div class="t-li1">
<span class="t-li">4)</span> explicitly defaulted function definition, only allowed for <a href="member_functions#Special_member_functions" title="cpp/language/member functions">special member functions</a> <table class="t-par-begin"> <tr class="t-par"> <td> <span class="t-spar">attr</span><span class="t-mark-rev t-since-cxx11">(C++11)</span> </td> <td> - </td> <td> optional list of <a href="attributes" title="cpp/language/attributes">attributes</a>. These attributes are combined with the attributes after the identifier in the <span class="t-spar">declarator</span> (see top of this page), if any. </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">decl-specifier-seq</span> </td> <td> - </td> <td> the return type with specifiers, as in the <a href="declarations" title="cpp/language/declarations">declaration grammar</a> </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">declarator</span> </td> <td> - </td> <td> function declarator, same as in the function declaration grammar above. <span class="t-rev-inl t-since-cxx20"><span>as with function declaration, it may be followed by a <span class="t-spar">requires-clause</span></span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span> </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">virt-specifier-seq</span><span class="t-mark-rev t-since-cxx11">(C++11)</span> </td> <td> - </td> <td> <a href="override" title="cpp/language/override">override</a>, <a href="final" title="cpp/language/final">final</a>, or their combination in any order (only allowed for member functions) </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">ctor-initializer</span> </td> <td> - </td> <td> <a href="constructor" title="cpp/language/initializer list">member initializer list</a>, only allowed in constructors </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">compound-statement</span> </td> <td> - </td> <td> the brace-enclosed <a href="statements#Compound_statements" title="cpp/language/statements">sequence of statements</a> that constututes the body of a function </td>
</tr>
</table>
</div> <div class="cpp source-cpp"><pre data-language="cpp">int max(int a, int b, int c)
{
    int m = (a &gt; b)? a : b;
    return (m &gt; c)? m : c;
}
// decl-specifier-seq is "int"
// declarator is "max(int a, int b, int c)"
// body is { ... }</pre></div> <p>The function body is a <a href="statements#Compound_statements" title="cpp/language/statements">compound statement</a> (sequence of zero or more statements surrounded by a pair of curly braces), which is executed when the function call is made.</p>
<p>The parameter types, as well as the return type of a function cannot be <a href="incomplete_type" title="cpp/language/incomplete type" class="mw-redirect">incomplete</a> <a href="class" title="cpp/language/class">class types</a>, <span class="t-rev-inl t-since-cxx11"><span>except for deleted functions</span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>. The completeness check is made in the context of the function <i>body</i>, which allows <a href="member_functions" title="cpp/language/member functions">member functions</a> to return the class in which they are defined (or its enclosing class), even if it's incomplete at the point of definition (it is complete in the function body).</p>
<p>The parameters declared in the <span class="t-spar">declarator</span> of a function definition are <a href="scope" title="cpp/language/scope">in scope</a> within the body. If a parameter is not used in the function body, it does not need to be named (it's sufficient to use an abstract declarator).</p>
<div class="cpp source-cpp"><pre data-language="cpp">void print(int a, int) // second parameter is not used
{
    std::printf("a = %d\n",a);
}</pre></div> <p>Even though top-level <a href="cv" title="cpp/language/cv">cv-qualifiers</a> on the parameters are discarded in function declarations, they modify the type of the parameter as visible in the body of a function:</p>
<div class="cpp source-cpp"><pre data-language="cpp">void f(const int n) // declares function of type void(int)
{
    // but in the body, the type of n is const int
}</pre></div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <h3 id="Deleted_functions"> Deleted functions</h3> <p>If, instead of a function body, the special syntax <code>= delete ;</code> is used, the function is defined as <i>deleted</i>. Any use of a deleted function is ill-formed (the program will not compile). This includes calls, both explicit (with a function call operator) and implicit (a call to deleted overloaded operator, special member function, allocation function etc), constructing a pointer or pointer-to-member to a deleted function, and even the use of a deleted function in an unevaluated expression. However, implicit <a href="definition#ODR-use" title="cpp/language/definition">ODR-use</a> of a non-pure virtual member function that happens to be deleted is allowed.</p>
<p>If the function is overloaded, <a href="overload_resolution" title="cpp/language/overload resolution">overload resolution</a> takes place first, and the program is only ill-formed if the deleted function was selected.</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct sometype
{
    void* operator new(std::size_t) = delete;
    void* operator new[](std::size_t) = delete;
};
sometype* p = new sometype; // error: attempts to call deleted sometype::operator new</pre></div> <p>The deleted definition of a function must be the first declaration in a translation unit: a previously-declared function cannot be redeclared as deleted:</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct sometype { sometype(); };
sometype::sometype() = delete; // error: must be deleted on the first declaration</pre></div> <h3 id="func"> __func__</h3> <p>Within the function body, the function-local predefined variable <code>__func__</code> is defined as if by.</p>
<div class="cpp source-cpp"><pre data-language="cpp">static const char __func__[] = "function-name";</pre></div> <p>This variable has block scope and static storage duration:</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct S
{
    S(): s(__func__) {} // okay: initializer-list is part of function body
    const char* s;
};
void f(const char* s = __func__); // error: parameter-list is part of declarator</pre></div> </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <h3 id="Notes">Notes</h3> <p>In case of ambiguity between a variable declaration using the direct-initialization syntax and a function declaration, the compiler always chooses function declaration; see <a href="direct_initialization#Notes" title="cpp/language/direct initialization">direct-initialization</a>.</p>
<h3 id="Example">Example</h3>  <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
 
// declaration in namespace(file) scope
// (the definition is provided later)
int f1();
 
// simple function with a default argument, returning nothing
void f0(const std::string&amp; arg = "world")
{
    std::cout &lt;&lt; "Hello, " &lt;&lt; arg &lt;&lt; '\n';
}
 
// function returning a pointer to f0
auto fp11() -&gt; void(*)(const std::string&amp;)
{
    return f0;
}
 
// function returning a pointer to f0, pre-C++11 style
void (*fp03())(const std::string&amp;)
{
    return f0;
}
 
int main()
{
    f0();
    fp11()("test");
    fp03()("again");
    int f2(std::string); // declaration in function scope
    std::cout &lt;&lt; f2("bad12") &lt;&lt; '\n';
}
 
// simple non-member function returning int
int f1()
{
    return 42;
}
 
// function with an exception specification and a function try block
int f2(std::string str) noexcept try
{ 
    return std::stoi(str);
}
catch(const std::exception&amp; e)
{
    std::cerr &lt;&lt; "stoi() failed!\n";
    return 0;
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">Hello, world
Hello, test
Hello, again
stoi() failed!
0</pre></div> </div> <h3 id="Defect_reports">Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th> DR </th> <th> Applied to </th> <th> Behavior as published </th> <th> Correct behavior </th>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://wg21.link/cwg1394">CWG 1394</a> </td> <td> C++11 </td> <td> deleted function could not return an incomplete type </td> <td> incomplete return type allowed </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://wg21.link/cwg577">CWG 577</a> </td> <td> C++11 </td> <td> dependent type <code>void</code> could be used to declare a no-parameter function </td> <td> only non-dependent void is allowed </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://wg21.link/cwg393">CWG 393</a> </td> <td> C++14 </td> <td> types that include pointers/references to array of unknown bound can't be parameters </td> <td> such types are allowed </td>
</tr>
</table>          <div class="_attribution">
  <p class="_attribution-p">
    © cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/language/function" class="_attribution-link">http://en.cppreference.com/w/cpp/language/function</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
