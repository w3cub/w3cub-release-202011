
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Storage Class Specifiers - C++ - W3cubDocs</title>
  
  <meta name="description" content="The storage class specifiers are a part of the decl-specifier-seq of a name&#39;s declaration syntax. Together with the scope of the name, they &hellip;">
  <meta name="keywords" content="storage, class, specifiers, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/language/storage_duration.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/cpp.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _c">
				
				
<h1 id="firstHeading" class="firstHeading">Storage class specifiers</h1>            <p>The storage class specifiers are a part of the <span class="t-spar">decl-specifier-seq</span> of a name's <a href="declarations" title="cpp/language/declarations">declaration syntax</a>. Together with the <a href="scope" title="cpp/language/scope">scope</a> of the name, they control two independent properties of the name: its <i>storage duration</i> and its <i>linkage</i>.</p>
<table class="t-rev-begin"> <tr class="t-rev t-until-cxx11">
<td> <ul><li>
<code>auto</code> - <i>automatic</i> storage duration. </li></ul> </td> <td><span class="t-mark-rev t-until-cxx11">(until C++11)</span></td>
</tr> <tr class="t-rev t-until-cxx17">
<td> <ul><li>
<code>register</code> - <i>automatic</i> storage duration. Also hints to the compiler to place the object in the processor's register. <span class="t-mark">(deprecated)</span> </li></ul> </td> <td><span class="t-mark-rev t-until-cxx17">(until C++17)</span></td>
</tr> </table> <ul>
<li>
<code>static</code> - <i>static</i> or <i>thread</i> storage duration and <i>internal</i> linkage. </li>
<li>
<code>extern</code> - <i>static</i> or <i>thread</i> storage duration and <i>external</i> linkage. </li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul><li>
<code>thread_local</code> - <i>thread</i> storage duration. </li></ul> </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <ul><li>
<code>mutable</code> - does not affect storage duration or linkage. See <a href="cv" title="cpp/language/cv">const/volatile</a> for the explanation. </li></ul> <p><br> Only one storage class specifier may appear in a declaration <span class="t-rev-inl t-since-cxx11"><span>except that <code>thread_local</code> may be combined with <code>static</code> or with <code>extern</code> </span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>.</p>
<h3 id="Explanation">Explanation</h3> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx11">
<td> <span class="t-li">1)</span> The <code>auto</code> specifier was only allowed for objects declared at block scope or in function parameter lists. It indicated automatic storage duration, which is the default for these kinds of declarations. The meaning of this keyword was changed in C++11. </td> <td><span class="t-mark-rev t-until-cxx11">(until C++11)</span></td>
</tr> <tr class="t-rev t-until-cxx17">
<td> <span class="t-li">2)</span> The <code>register</code> specifier is only allowed for objects declared at block scope and in function parameter lists. It indicates automatic storage duration, which is the default for these kinds of declarations. Additionally, the presence of this keyword may be used as a hint for the optimizer to store the value of this variable in a CPU register. This keyword was deprecated in C++11. </td> <td><span class="t-mark-rev t-until-cxx17">(until C++17)</span></td>
</tr> </table> <div class="t-li1">
<span class="t-li">3)</span> The <code>static</code> specifier is only allowed in the declarations of objects (except in function parameter lists), declarations of functions (except at block scope), and declarations of anonymous unions. When used in a declaration of a class member, it declares a <a href="static" title="cpp/language/static">static member</a>. When used in a declaration of an object, it specifies static storage duration (except if accompanied by <code>thread_local</code>). When used in a declaration at namespace scope, it specifies internal linkage.</div> <div class="t-li1">
<span class="t-li">4)</span> The <code>extern</code> specifier is only allowed in the declarations of variables and functions (except class members or function parameters). It specifies external linkage, and does not technically affect storage duration, but it cannot be used in a definition of an automatic storage duration object, so all <code>extern</code> objects have static or thread durations. In addition, a variable declaration that uses <code>extern</code> and has no initializer is not a <a href="definition" title="cpp/language/definition">definition</a>.</div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <span class="t-li">5)</span> The <code>thread_local</code> keyword is only allowed for objects declared at namespace scope, objects declared at block scope, and static data members. It indicates that the object has thread storage duration. It can be combined with <code>static</code> or <code>extern</code> to specify internal or external linkage (except for static data members which always have external linkage), respectively, but that additional <code>static</code> doesn't affect the storage duration. </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <h4 id="Storage_duration">Storage duration</h4> <p>All <a href="objects" title="cpp/language/object">objects</a> in a program have one of the following storage durations:</p>
<ul>
<li>
<i><b>automatic</b></i> storage duration. The storage for the object is allocated at the beginning of the enclosing code block and deallocated at the end. All local objects have this storage duration, except those declared <code>static</code>, <code>extern</code> or <code>thread_local</code>. </li>
<ul><li>
<i><b>static</b></i> storage duration. The storage for the object is allocated when the program begins and deallocated when the program ends. Only one instance of the object exists. All objects declared at namespace scope (including global namespace) have this storage duration, plus those declared with <code>static</code> or <code>extern</code>. See <a href="initialization#Non-local_variables" title="cpp/language/initialization">Non-local variables</a> and <a href="storage_duration#Static_local_variables">Static local variables</a> for details on initialization of objects with this storage duration. </li></ul>
</ul>  <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul><li>
<i><b>thread</b></i> storage duration. The storage for the object is allocated when the thread begins and deallocated when the thread ends. Each thread has its own instance of the object. Only objects declared <code>thread_local</code> have this storage duration. <code>thread_local</code> can appear together with <code>static</code> or <code>extern</code> to adjust linkage. See <a href="initialization#Non-local_variables" title="cpp/language/initialization">Non-local variables</a> for details on initialization of objects with this storage duration. </li></ul> </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <ul><li>
<i><b>dynamic</b></i> storage duration. The storage for the object is allocated and deallocated per request by using <a href="../memory" title="cpp/memory">dynamic memory allocation</a> functions. See <a href="new" title="cpp/language/new">new-expression</a> for details on initialization of objects with this storage duration. </li></ul> <h4 id="Linkage">Linkage</h4> <p>A name that denotes object, reference, function, type, template, namespace, or value, may have <i>linkage</i>. If a name has linkage, it refers to the same entity as the same name introduced by a declaration in another scope. If a variable, function, or another entity with the same name is declared in several scopes, but does not have sufficient linkage, then several instances of the entity are generated.</p>
<p>The following linkages are recognized:</p>
<ul>
<li>
<i><b>no linkage</b></i>. The name can be referred to only from the scope it is in. </li>
<ul>
<li> variables that aren't explicitly declared <code>extern</code> (regardless of the <code>static</code> modifier); </li>
<li> <a href="class#Local_classes" title="cpp/language/class">local classes</a> and their member functions; </li>
<li> other names declared at block scope such as typedefs, enumerations, and enumerators. </li>
</ul>
<li>
<i><b>internal linkage</b></i>. The name can be referred to from all scopes in the current translation unit. </li>
<ul>
<li> variables<span class="t-rev-inl t-since-cxx14"><span>, variable templates</span> <span><span class="t-mark-rev t-since-cxx14">(since C++14)</span></span></span>, functions, or function templates declared <code>static</code>; </li>
<li> non-volatile <span class="t-rev-inl t-since-cxx14"><span>non-template</span> <span><span class="t-mark-rev t-since-cxx14">(since C++14)</span></span></span><span class="t-rev-inl t-since-cxx17"><span>non-inline</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> <a href="cv" title="cpp/language/cv">const-qualified</a> variables (including <a href="constexpr" title="cpp/language/constexpr">constexpr</a>) that aren't declared <code>extern</code> and aren't previously declared to have external linkage; </li>
<li> data members of <a href="union" title="cpp/language/union">anonymous unions</a>. </li>
</ul>
</ul>      <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td>  In addition, all names declared in <a href="namespace" title="cpp/language/namespace">unnamed namespace</a> or a namespace within an unnamed namespace, even ones explicitly declared <code>extern</code>, have internal linkage.   </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <ul><li>
<i><b>external linkage</b></i>. The name can be referred to from the scopes in the other translation units. Variables and functions with external linkage also have <a href="language_linkage" title="cpp/language/language linkage">language linkage</a>, which makes it possible to link translation units written in different programming languages. </li></ul> <dl>
<dd> Any of the following names declared at namespace scope have external linkage <span class="t-rev-inl t-since-cxx11"><span>unless the namespace is unnamed or is contained within an unnamed namespace</span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>: <ul>
<li> variables and functions not listed above (that is, functions not declared <code>static</code>, namespace-scope non-const variables not declared <code>static</code>, and any variables declared <code>extern</code>); </li>
<li> enumerations; </li>
<li> names of classes, their member functions, static data members (const or not), nested classes and enumerations, and functions first introduced with <a href="friend" title="cpp/language/friend">friend</a> declarations inside class bodies; </li>
<li> names of all templates not listed above (that is, not function templates declared <code>static</code>). </li>
</ul> </dd>
<dd> Any of the following names first declared at block scope have external linkage: <ul>
<li> names of variables declared <code>extern</code>; </li>
<li> names of functions. </li>
</ul> </dd>
</dl>  <h3 id="Static_local_variables">Static local variables</h3> <p>Variables declared at block scope with the specifier <code>static</code> have static storage duration but are initialized the first time control passes through their declaration (unless their initialization is <a href="zero_initialization" title="cpp/language/zero initialization">zero-</a> or <a href="constant_initialization" title="cpp/language/constant initialization">constant-initialization</a>, which can be performed before the block is first entered). On all further calls, the declaration is skipped.</p>
<p>If the initialization <a href="throw" title="cpp/language/throw">throws an exception</a>, the variable is not considered to be initialized, and initialization will be attempted again the next time control passes through the declaration.</p>
<p>If the initialization recursively enters the block in which the variable is being initialized, the behavior is undefined.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>If multiple threads attempt to initialize the same static local variable concurrently, the initialization occurs exactly once (similar behavior can be obtained for arbitrary functions with <code><a href="../thread/call_once" title="cpp/thread/call once">std::call_once</a></code>).</p>
<p>Note: usual implementations of this feature use variants of the double-checked locking pattern, which reduces runtime overhead for already-initialized local statics to a single non-atomic boolean comparison.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <p>The destructor for a block-scope static variable <a href="../utility/program/exit" title="cpp/utility/program/exit">is called at program exit</a>, but only if the initialization took place successfully.</p>
<p>Function-local static objects in all definitions of the same <a href="inline" title="cpp/language/inline">inline function</a> (which may be implicitly inline) all refer to the same object defined in one translation unit.</p>
<h3 id="Notes">Notes</h3> <p>Names at the top-level namespace scope (file scope in C) that are <code>const</code> and not <code>extern</code> have external linkage in C, but internal linkage in C++.</p>
<p>Since C++11, <code>auto</code> is no longer a storage class specifier; it is used to indicate type deduction.</p>
<table class="t-rev-begin"> <tr class="t-rev t-until-cxx17">
<td> <p>In C, the address of a <code>register</code> variable cannot be taken, but in C++, a variable declared <code>register</code> is semantically indistinguishable from a variable declared without any storage class specifiers.</p>
</td> <td><span class="t-mark-rev t-until-cxx17">(until C++17)</span></td>
</tr> <tr class="t-rev t-since-cxx17">
<td> <p>In C++, unlike C, variables cannot be declared <code>register</code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <p>Names of <code>thread_local</code> variables with internal or external linkage referred from different scopes may refer to the same or to different instances depending on whether the code is executing in the same or in different threads.</p>
<p>The <code>extern</code> keyword can also be used to specify <a href="language_linkage" title="cpp/language/language linkage">language linkage</a> and <a href="class_template" title="cpp/language/class template">explicit template instantiation declarations</a>, but it's not a storage class specifier in those cases (except when a declaration is directly contained in a language linkage specification, in which case the declaration is treated as if it contains the <code>extern</code> specifier).</p>
<p><a href="cv" title="cpp/language/cv">The keyword <code>mutable</code></a> is a storage class specifier in the C++ language grammar, although it doesn't affect storage duration or linkage.</p>
<p>Storage class specifiers, except for <code>thread_local</code>, are not allowed on <a href="template_specialization" title="cpp/language/template specialization">explicit specializations</a> and <a href="class_template#Explicit_instantiation" title="cpp/language/class template">explicit instantiations</a>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">template &lt;class T&gt; struct S {
    thread_local static int tlm;
};
template &lt;&gt; thread_local int S&lt;float&gt;::tlm = 0; // "static" does not appear here</pre></div> <h3 id="Keywords">Keywords</h3> <p><a href="../keyword/auto" title="cpp/keyword/auto"><code>auto</code></a>, <a href="../keyword/register" title="cpp/keyword/register"><code>register</code></a>, <a href="../keywords/static" title="cpp/keyword/static"><code>static</code></a>, <a href="../keyword/extern" title="cpp/keyword/extern"><code>extern</code></a>, <a href="../keyword/thread_local" title="cpp/keyword/thread local"><code>thread_local</code></a>, <a href="../keyword/mutable" title="cpp/keyword/mutable"><code>mutable</code></a>.</p>
<h3 id="Example">Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
 
thread_local unsigned int rage = 1; 
std::mutex cout_mutex;
 
void increase_rage(const std::string&amp; thread_name)
{
    ++rage; // modifying outside a lock is okay; this is a thread-local variable
    std::lock_guard&lt;std::mutex&gt; lock(cout_mutex);
    std::cout &lt;&lt; "Rage counter for " &lt;&lt; thread_name &lt;&lt; ": " &lt;&lt; rage &lt;&lt; '\n';
}
 
int main()
{
    std::thread a(increase_rage, "a"), b(increase_rage, "b");
 
    {
        std::lock_guard&lt;std::mutex&gt; lock(cout_mutex);
        std::cout &lt;&lt; "Rage counter for main: " &lt;&lt; rage &lt;&lt; '\n';
    }
 
    a.join();
    b.join();
}</pre></div> <p>Possible output:</p>
<div class="text source-text"><pre data-language="c">Rage counter for a: 2
Rage counter for main: 1
Rage counter for b: 2</pre></div> </div> <h3 id="Defect_reports">Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th> DR </th> <th> Applied to </th> <th> Behavior as published </th> <th> Correct behavior </th>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://wg21.link/p1359r0#2387">CWG 2387</a> </td> <td> C++14 </td> <td> unclear whether const-qualified variable template<br>have internal linkage by default </td> <td> const qualifier does not affect the linkage of<br>variable templates or their instances </td>
</tr>
</table> <h3 id="See_also">See also</h3>           <div class="_attribution">
  <p class="_attribution-p">
    Â© cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/language/storage_duration" class="_attribution-link">http://en.cppreference.com/w/cpp/language/storage_duration</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
