
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Enumeration Declaration - C++ - W3cubDocs</title>
  
  <meta name="description" content="An enumeration is a distinct type whose value is restricted to a range of values (see below for details), which may include several explicitly named &hellip;">
  <meta name="keywords" content="enumeration, declaration, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/language/enum.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-9c7b0d969c0ce639a6c01c2badcdd81667c7c66206aa3d0fccc5cb0585fb1b912dab72ea882101d18010680927514b4b77b107282db8f756fbf63301fe9c88b0.css">
  <script type="text/javascript" src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js"></script>
  <script src="/json/cpp.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _cppref">
				
				
<h1 id="firstHeading" class="firstHeading">Enumeration declaration</h1>            <p>An <i>enumeration</i> is a distinct type whose value is restricted to a range of values (see below for details), which may include several explicitly named constants ("<i>enumerators</i>").</p>
<p>The values of the constants are values of an integral type known as the <i>underlying type</i> of the enumeration. An enumeration has the same <a href="sizeof" title="cpp/language/sizeof">size</a>, <a href="object#Object_representation_and_value_representation" title="cpp/language/object">value representation</a>, and <a href="object#Alignment" title="cpp/language/object">alignment requirements</a> as its underlying type. Furthermore, each value of an enumeration has the same representation as the corresponding value of the underlying type.</p>
<p>An enumeration is (re)declared using the following syntax:</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">enum-key attr</span><span class="t-mark">(optional)</span> <span class="t-spar">enum-head-name</span><span class="t-mark">(optional)</span> <span class="t-spar">enum-base</span><span class="t-mark">(optional)</span><br><code>{</code> <span class="t-spar">enumerator-list</span><span class="t-mark">(optional)</span> <code>}</code> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">enum-key attr</span><span class="t-mark">(optional)</span> <span class="t-spar">enum-head-name</span><span class="t-mark">(optional)</span> <span class="t-spar">enum-base</span><span class="t-mark">(optional)</span><br><code>{</code> <span class="t-spar">enumerator-list</span> <code>, }</code> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">enum-key attr</span><span class="t-mark">(optional)</span> <span class="t-spar">enum-head-name enum-base</span><span class="t-mark">(optional)</span> <code>;</code> </td> <td> (3) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr> 
</table> <div class="t-li1">
<span class="t-li">1)</span> <i>enum-specifier</i>, which appears in <span class="t-spar">decl-specifier-seq</span> of the <a href="declarations" title="cpp/language/declarations">declaration</a> syntax: defines the enumeration type and its enumerators.</div> <div class="t-li1">
<span class="t-li">2)</span> A trailing comma can follow the <span class="t-spar">enumerator-list</span>.</div> <div class="t-li1">
<span class="t-li">3)</span> <i>Opaque enum declaration</i>: defines the enumeration type but not its enumerators: after this declaration, the type is a complete type and its size is known.</div> <table class="t-par-begin"> <tr class="t-par"> <td> <span class="t-spar">enum-key</span> </td> <td> - </td> <td> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx11">
<td> <p><code>enum</code>.</p>
</td> <td><span class="t-mark-rev t-until-cxx11">(until C++11)</span></td>
</tr> <tr class="t-rev t-since-cxx11">
<td> <p>one of <code>enum</code>, <code>enum class</code>, or <code>enum struct</code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">attr</span> </td> <td> - </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> optional sequence of any number of <a href="attributes" title="cpp/language/attributes">attributes</a> </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">enum-head-name</span> </td> <td> - </td> <td> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx11">
<td> <p>the name of the enumeration that's being declared, it can be omitted.</p>
</td> <td><span class="t-mark-rev t-until-cxx11">(until C++11)</span></td>
</tr> <tr class="t-rev t-since-cxx11">
<td> <p>the name of the enumeration that's being declared, optionally preceded by a <span class="t-spar">nested-name-specifier</span>: sequence of names and scope-resolution operators <code>::</code>, ending with scope-resolution operator. It can only be omitted in unscoped non-opaque enumeration declarations.<br> <span class="t-spar">nested-name-specifier</span> may only appear if the enumeration name is present and this declaration is a redeclaration. For opaque enumeration declarations, <span class="t-spar">nested-name-specifier</span> can only appear before the name of the enumeration in <a href="template_specialization" title="cpp/language/template specialization">explicit specialization declarations</a>.<br> If <span class="t-spar">nested-name-specifier</span> is present, the <i>enum-specifier</i> cannot refer to an enumeration merely inherited or introduced by a <a href="using_declaration" title="cpp/language/using declaration">using-declaration</a>, and the <i>enum-specifier</i> can only appear in a namespace enclosing the previous declaration. In such cases, <span class="t-spar">nested-name-specifier</span> cannot begin with a <a href="decltype" title="cpp/language/decltype">decltype</a> specifier.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">enum-base</span> </td> <td> - </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> colon (<code>:</code>), followed by a <span class="t-spar">type-specifier-seq</span> that names an integral type (if it is cv-qualified, qualifications are ignored) that will serve as the fixed underlying type for this enumeration type </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">enumerator-list</span> </td> <td> - </td> <td> comma-separated list of enumerator definitions, each of which is either simply a unique <span class="t-spar">identifier</span>, which becomes the name of the enumerator, or a unique identifier with an initializer: <span class="t-spar">identifier</span> <code>=</code> <span class="t-spar">constexpr</span>. <span class="t-rev-inl t-since-cxx17"><span>In either case, the <span class="t-spar">identifier</span> can be directly followed by an optional <a href="attributes" title="cpp/language/attributes">attribute specifier sequence</a>.</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> </td>
</tr>
</table> <p>There are two distinct kinds of enumerations: <i>unscoped enumeration</i> (declared with the <span class="t-spar">enum-key</span> <code>enum</code>) and <i>scoped enumeration</i> (declared with the <span class="t-spar">enum-key</span> <code>enum class</code> or <code>enum struct</code>).</p>
<h3 id="Unscoped_enumerations"> Unscoped enumerations</h3> <table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <code>enum</code> <span class="t-spar">name</span><span class="t-mark">(optional)</span> <code>{</code> <span class="t-spar">enumerator</span> <code>=</code> <span class="t-spar">constexpr</span> <code>,</code> <span class="t-spar">enumerator</span> <code>=</code> <span class="t-spar">constexpr</span> <code>,</code> ... <code>}</code> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>enum</code> <span class="t-spar">name</span><span class="t-mark">(optional)</span> <code>:</code> <span class="t-spar">type</span> <code>{</code> <span class="t-spar">enumerator</span> <code>=</code> <span class="t-spar">constexpr</span> <code>,</code> <span class="t-spar">enumerator</span> <code>=</code> <span class="t-spar">constexpr</span> <code>,</code> ... <code>}</code> </td> <td> (2) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <code>enum</code> <span class="t-spar">name</span> <code>:</code> <span class="t-spar">type</span> <code>;</code> </td> <td> (3) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr> 
</table> <div class="t-li1">
<span class="t-li">1)</span> Declares an unscoped enumeration type whose underlying type is not fixed (in this case, the underlying type is an implementation-defined integral type that can represent all enumerator values; this type is not larger than <code>int</code> unless the value of an enumerator cannot fit in an <code>int</code> or <code>unsigned int</code>. If the <span class="t-spar">enumerator-list</span> is empty, the underlying type is as if the enumeration had a single enumerator with value 0. If no integral type can represent all the enumerator values, the enumeration is ill-formed).</div> <div class="t-li1">
<span class="t-li">2)</span> Declares an unscoped enumeration type whose underlying type is fixed.</div> <div class="t-li1">
<span class="t-li">3)</span> Opaque enum declaration for an unscoped enumeration must specify the name and the underlying type.</div> <p>Each <span class="t-spar">enumerator</span> becomes a named constant of the enumeration's type (that is, <span class="t-spar">name</span>), visible in the enclosing scope, and can be used whenever constants are required.</p>
<div class="cpp source-cpp"><pre data-language="cpp">enum Color { red, green, blue };
Color r = red;
 
switch(r)
{
    case red  : std::cout &lt;&lt; "red\n";   break;
    case green: std::cout &lt;&lt; "green\n"; break;
    case blue : std::cout &lt;&lt; "blue\n";  break;
}</pre></div> <p>Each enumerator is associated with a value of the underlying type. When initializers are provided in the <span class="t-spar">enumerator-list</span>, the values of enumerators are defined by those initializers. If the first enumerator does not have an initializer, the associated value is zero. For any other enumerator whose definition does not have an initializer, the associated value is the value of the previous enumerator plus one.</p>
<div class="cpp source-cpp"><pre data-language="cpp">enum Foo { a, b, c = 10, d, e = 1, f, g = f + c };
//a = 0, b = 1, c = 10, d = 11, e = 1, f = 2, g = 12</pre></div> <p>Values of unscoped enumeration type are <a href="implicit_conversion#Integral_promotion" title="cpp/language/implicit conversion">implicitly-convertible</a> to integral types. If the underlying type is not fixed, the value is convertible to the first type from the following list able to hold their entire value range: <code>int</code>, <code>unsigned int</code>, <code>long</code>, <code>unsigned long</code>, <span class="t-rev-inl t-since-cxx11"><span><code>long long</code>, or <code>unsigned long long</code>, extended integer types with higher conversion rank (in rank order, signed given preference over unsigned)</span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>. If the underlying type is fixed, the values can be converted to their underlying type (preferred in <a href="overload_resolution" title="cpp/language/overload resolution">overload resolution</a>), which can then be <a href="implicit_conversion#Integral_promotion" title="cpp/language/implicit conversion">promoted</a>.</p>
<div class="cpp source-cpp"><pre data-language="cpp">enum color { red, yellow, green = 20, blue };
color col = red;
int n = blue; // n == 21</pre></div> <p>Values of integer, floating-point, and enumeration types can be converted by <a href="static_cast" title="cpp/language/static cast"><code>static_cast</code></a> or <a href="explicit_cast" title="cpp/language/explicit cast">explicit cast</a>, to any enumeration type. If the underlying type is not fixed and the source value is out of range, the behavior is undefined. (The source value, as converted to the enumeration's underlying type if floating-point, is in range if it would fit in the smallest <a href="bit_field" title="cpp/language/bit field">bit-field</a> large enough to hold all enumerators of the target enumeration.) Otherwise, the result is the same as the result of <a href="implicit_conversion" title="cpp/language/implicit conversion">implicit conversion</a> to the underlying type.</p>
<p>Note that the value after such conversion may not necessarily equal any of the named enumerators defined for the enumeration.</p>
<div class="cpp source-cpp"><pre data-language="cpp">enum access_t { read = 1, write = 2, exec = 4 }; // enumerators: 1, 2, 4 range: 0..7
access_t rwe = static_cast&lt;access_t&gt;(7);
assert((rwe &amp; read) &amp;&amp; (rwe &amp; write) &amp;&amp; (rwe &amp; exec));
 
access_t x = static_cast&lt;access_t&gt;(8.0); // undefined behavior since CWG 1766
access_t y = static_cast&lt;access_t&gt;(8);   // undefined behavior since CWG 1766
 
enum foo { a = 0, b = UINT_MAX }; // range: [0, UINT_MAX]
foo x = foo(-1); // undefined behavior since CWG 1766,
                 // even if foo's underlying type is unsigned int</pre></div> <p>The <span class="t-spar">name</span> of an unscoped enumeration may be omitted: such declaration only introduces the enumerators into the enclosing scope:</p>
<div class="cpp source-cpp"><pre data-language="cpp">enum { a, b, c = 0, d = a + 2 }; // defines a = 0, b = 1, c = 0, d = 2</pre></div> <p>When an unscoped enumeration is a class member, its enumerators may be accessed using class member access operators <code>.</code> and <code>-&gt;</code>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct X
{
    enum direction { left = 'l', right = 'r' };
};
X x;
X* p = &amp;x;
 
int a = X::direction::left; // allowed only in C++11 and later
int b = X::left;
int c = x.left;
int d = p-&gt;left;</pre></div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>In the <a href="declarations#Specifiers" title="cpp/language/declarations">declaration specifiers</a> of a <a href="class#Member_specification" title="cpp/language/class">member declaration</a>, the sequence  <code>enum</code>.</p>
<span class="t-spar">enum-head-name</span> <code>:</code>  <p>is always parsed as a part of enumeration declaration:</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct S
{
    enum E1 : int {};
    enum E1 : int {}; // error: redeclaration of enumeration,
                      // NOT parsed as a zero-length bit-field of type enum E1
};
 
enum E2 { e1 };
 
void f()
{
    false ? new enum E2 : int(); // OK: 'int' is NOT parsed as the underlying type
}</pre></div> </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <h3 id="Scoped_enumerations"> Scoped enumerations</h3> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <code>enum struct|class</code> <span class="t-spar">name</span> <code>{</code> <span class="t-spar">enumerator</span> <code>=</code> <span class="t-spar">constexpr</span> <code>,</code> <span class="t-spar">enumerator</span> <code>=</code> <span class="t-spar">constexpr</span> <code>,</code> ... <code>}</code> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>enum struct|class</code> <span class="t-spar">name</span> <code>:</code> <span class="t-spar">type</span> <code>{</code> <span class="t-spar">enumerator</span> <code>=</code> <span class="t-spar">constexpr</span> <code>,</code> <span class="t-spar">enumerator</span> <code>=</code> <span class="t-spar">constexpr</span> <code>,</code> ... <code>}</code> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>enum struct|class</code> <span class="t-spar">name</span> <code>;</code> </td> <td> (3) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>enum struct|class</code> <span class="t-spar">name</span> <code>:</code> <span class="t-spar">type</span> <code>;</code> </td> <td> (4) </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <span class="t-li">1)</span> declares a scoped enumeration type whose underlying type is <code>int</code> (the keywords <code>class</code> and <code>struct</code> are exactly equivalent) <span class="t-li">2)</span> declares a scoped enumeration type whose underlying type is <span class="t-spar">type</span> <span class="t-li">3)</span> opaque enum declaration for a scoped enumeration whose underlying type is <code>int</code> <span class="t-li">4)</span> opaque enum declaration for a scoped enumeration whose underlying type is <span class="t-spar">type</span> <p>Each <span class="t-spar">enumerator</span> becomes a named constant of the enumeration's type (that is, <span class="t-spar">name</span>), which is contained within the scope of the enumeration, and can be accessed using scope resolution operator. There are no implicit conversions from the values of a scoped enumerator to integral types, although <a href="static_cast" title="cpp/language/static cast"><code>static_cast</code></a> may be used to obtain the numeric value of the enumerator.</p>
<div class="cpp source-cpp"><pre data-language="cpp">enum class Color { red, green = 20, blue };
Color r = Color::blue;
 
switch(r)
{
    case Color::red  : std::cout &lt;&lt; "red\n";   break;
    case Color::green: std::cout &lt;&lt; "green\n"; break;
    case Color::blue : std::cout &lt;&lt; "blue\n";  break;
}
 
// int n = r; // error: no implicit conversion from scoped enum to int
int n = static_cast&lt;int&gt;(r); // OK, n = 21</pre></div> </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <p>An enumeration can be initialized from an integer without a cast, using <a href="list_initialization" title="cpp/language/list initialization">list initialization</a>, if all of the following are true:</p>
<ul>
<li> the initialization is direct-list-initialization </li>
<li> the initializer list has only a single element </li>
<li> the enumeration is either scoped or unscoped with underlying type fixed </li>
<li> the conversion is non-narrowing </li>
</ul> <p>This makes it possible to introduce new integer types (e.g. <code>SafeInt</code>) that enjoy the same existing calling conventions as their underlying integer types, even on ABIs that penalize passing/returning structures by value.</p>
<div class="cpp source-cpp"><pre data-language="cpp">enum byte : unsigned char {}; // byte is a new integer type; see also std::byte (C++17)
byte b{42};        // OK as of C++17 (direct-list-initialization)
byte c = {42};     // error
byte d = byte{42}; // OK as of C++17; same value as b
byte e{-1};        // error
 
struct A { byte b; };
A a1 = {{42}};     // error (copy-list-initialization of a constructor parameter)
A a2 = {byte{42}}; // OK as of C++17
 
void f(byte);
f({42}); // error (copy-list-initialization of a function parameter)
 
enum class Handle : std::uint32_t { Invalid = 0 };
Handle h{42}; // OK as of C++17</pre></div> </td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <h3 id="Using-enum-declaration"> Using-enum-declaration</h3> <table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <code>using enum</code> <span class="t-spar">nested-name-specifier</span><span class="t-mark">(optional)</span> <span class="t-spar">name</span> <code>;</code> </td> <td class="t-sdsc-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td>
</tr> 
</table> <p><span class="t-spar">nested-name-specifier</span><span class="t-mark">(optional)</span> <span class="t-spar">name</span> must name a non-<a href="dependent_name#Dependent_types" title="cpp/language/dependent name">dependent</a> enumeration type. The enumeration declarations are found by ordinary <a href="qualified_lookup" title="cpp/language/qualified lookup">qualified</a> or <a href="unqualified_lookup" title="cpp/language/unqualified lookup">unqualified</a> lookup, depending on whether <span class="t-spar">nested-name-specifier</span> is present.</p>
<p>A using-enum-declaration introduces the enumerator names of the named enumeration as if by a <a href="using_declaration" title="cpp/language/using declaration">using-declaration</a> for each enumerator. When in class scope, a using-enum-declaration adds the enumerators of the named enumeration as members to the scope, making them accessible for member lookup.</p>
<div class="cpp source-cpp"><pre data-language="cpp">enum class fruit { orange, apple };
 
struct S
{
    using enum fruit; // OK: introduces orange and apple into S
};
 
void f()
{
    S s;
    s.orange;  // OK: names fruit::orange
    S::orange; // OK: names fruit::orange
}</pre></div> <p>Two using-enum-declarations that introduce two enumerators of the same name conflict.</p>
<div class="cpp source-cpp"><pre data-language="cpp">enum class fruit { orange, apple };
enum class color { red, orange };
 
void f()
{
    using enum fruit;    // OK
    // using enum color; // error: color::orange and fruit::orange conflict
}</pre></div> </td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <h3 id="Notes"> Notes</h3> <table class="wikitable ftm-begin ftm-has-value"> <tr> <th>Feature-test macro</th> <th>Value</th> <th><span title="Standard in which the feature is introduced">Std</span></th> <th>Comment </th>
</tr> <tr> <td><a href="../feature_test#Language_features" title="cpp/feature test"><code>__cpp_enumerator_attributes</code></a></td> <td><span class="nu0">201411L</span></td> <td><span class="t-mark">(C++17)</span></td> <td>
<a href="attributes" title="cpp/language/attributes">Attributes</a> for enumerators </td>
</tr> <tr> <td><a href="../feature_test#Language_features" title="cpp/feature test"><code>__cpp_using_enum</code></a></td> <td><span class="nu0">201907L</span></td> <td><span class="t-mark">(C++20)</span></td> <td>
<a href="#Using-enum-declaration"><code>using enum</code></a> </td>
</tr>
</table> <h3 id="Example"> Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;cstdint&gt;
#include &lt;iostream&gt;
 
// enum that takes 16 bits
enum smallenum: std::int16_t
{
    a,
    b,
    c
};
 
// color may be red (value 0), yellow (value 1), green (value 20), or blue (value 21)
enum color
{
    red,
    yellow,
    green = 20,
    blue
};
 
// altitude may be altitude::high or altitude::low
enum class altitude: char
{
    high = 'h',
    low = 'l', // trailing comma only allowed after CWG 518
}; 
 
// the constant d is 0, the constant e is 1, the constant f is 3
enum
{
    d,
    e,
    f = e + 2
};
 
// enumeration types (both scoped and unscoped) can have overloaded operators
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, color c)
{
    switch(c)
    {
        case red   : os &lt;&lt; "red";    break;
        case yellow: os &lt;&lt; "yellow"; break;
        case green : os &lt;&lt; "green";  break;
        case blue  : os &lt;&lt; "blue";   break;
        default    : os.setstate(std::ios_base::failbit);
    }
    return os;
}
 
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, altitude al)
{
    return os &lt;&lt; static_cast&lt;char&gt;(al);
}
 
// The scoped enum (C++11) can be partially emulated in earlier C++ revisions:
 
enum struct E11 { x, y }; // since C++11
 
struct E98 { enum { x, y }; }; // OK in pre-C++11
 
namespace N98 { enum { x, y }; } // OK in pre-C++11
 
struct S98 { static const int x = 0, y = 1; }; // OK in pre-C++11
 
void emu()
{
    std::cout &lt;&lt; (static_cast&lt;int&gt;(E11::y) + E98::y + N98::y + S98::y) &lt;&lt; '\n'; // 4
}
 
namespace cxx20
{
    enum class long_long_long_name { x, y };
 
    void using_enum_demo()
    {
        std::cout &lt;&lt; "C++20 `using enum`: __cpp_using_enum == ";
        switch (auto rnd = []{return long_long_long_name::x;}; rnd())
        {
#if defined(__cpp_using_enum)
            using enum long_long_long_name;
            case x: std::cout &lt;&lt; __cpp_using_enum &lt;&lt; "; x\n"; break;
            case y: std::cout &lt;&lt; __cpp_using_enum &lt;&lt; "; y\n"; break;
#else
            case long_long_long_name::x: std::cout &lt;&lt; "?; x\n"; break;
            case long_long_long_name::y: std::cout &lt;&lt; "?; y\n"; break;
#endif
        }
    }
}
 
int main()
{
    color col = red;
    altitude a;
    a = altitude::low;
 
    std::cout &lt;&lt; "col = " &lt;&lt; col &lt;&lt; '\n'
              &lt;&lt; "a = "   &lt;&lt; a   &lt;&lt; '\n'
              &lt;&lt; "f = "   &lt;&lt; f   &lt;&lt; '\n';
 
    cxx20::using_enum_demo();
}</pre></div> <p>Possible output:</p>
<div class="text source-text"><pre data-language="c">col = red
a = l
f = 3
C++20 `using enum`: __cpp_using_enum == 201907; x</pre></div> </div> <h3 id="Defect_reports"> Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th> DR </th> <th> Applied to </th> <th> Behavior as published </th> <th> Correct behavior </th>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/377.html">CWG 377</a> </td> <td> C++98 </td> <td> the behavior was unspecified when no integral<br>type can represent all the enumerator values </td> <td> the enumeration is ill-<br>formed in this case </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/518.html">CWG 518</a> </td> <td> C++98 </td> <td> a trailing comma was not allowed after the enumerator list </td> <td> allowed </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1514.html">CWG 1514</a> </td> <td> C++11 </td> <td> a redefinition of enumeration with fixed underlying type<br>could be parsed as a bit-field in a class member declaration </td> <td> always parsed as a redefinition </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1638.html">CWG 1638</a> </td> <td> C++11 </td> <td> grammar of opaque enumeration declaration<br>prohibited use for template specializations </td> <td> nested-name-specifier<br>permitted </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1766.html">CWG 1766</a> </td> <td> C++98 </td> <td> casting an out-of-range value to an enumeration<br>without fixed underlying type had an unspecified result </td> <td> the behavior is undefined </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1966.html">CWG 1966</a> </td> <td> C++11 </td> <td> the resolution of <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1514.html">CWG issue 1514</a> made the <code>:</code><br>of a conditional expression part of <span class="t-spar">enum-base</span> </td> <td> only apply the resolution to<br>member declaration specifiers </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2156.html">CWG 2156</a> </td> <td> C++11 </td> <td> enum definitions could define<br>enumeration types by using-declarations </td> <td> prohibited </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2157.html">CWG 2157</a> </td> <td> C++11 </td> <td> the resolution of <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1966.html">CWG issue 1966</a> did<br>not cover qualified enumeration names </td> <td> covered </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2530.html">CWG 2530</a> </td> <td> C++98 </td> <td> an enumerator list could contain multiple<br>enumerators with the same identifier </td> <td> prohibited </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2590.html">CWG 2590</a> </td> <td> C++98 </td> <td> the size, value representation and alignment requirements<br>of an enumeration did not depend on its underlying type </td> <td> all of them are identical to<br>those of the underlying type </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2621.html">CWG 2621</a> </td> <td> C++20 </td> <td> it was unclear how the enumeration names<br>are found in using-enum-declarations </td> <td> they are found using<br>ordinary name lookup </td>
</tr>
</table> <h3 id="See_also"> See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../types/is_enum" title="cpp/types/is enum"> <span class="t-lines"><span>is_enum</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> checks if a type is an enumeration type <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../types/is_scoped_enum" title="cpp/types/is scoped enum"> <span class="t-lines"><span>is_scoped_enum</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> checks if a type is a scoped enumeration type <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../types/underlying_type" title="cpp/types/underlying type"> <span class="t-lines"><span>underlying_type</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> obtains the underlying integer type for a given enumeration type <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/to_underlying" title="cpp/utility/to underlying"> <span class="t-lines"><span>to_underlying</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> converts an enumeration to its underlying type <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td colspan="2"> <span><a href="https://en.cppreference.com/w/c/language/enum" title="c/language/enum">C documentation</a></span> for <span class=""><span>Enumerations</span></span> </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    © cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/language/enum" class="_attribution-link">https://en.cppreference.com/w/cpp/language/enum</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
