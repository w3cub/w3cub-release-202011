
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Aggregate Initialization - C++ - W3cubDocs</title>
  
  <meta name="description" content=" Initializes an aggregate from an initializer list. It is a form of list-initialization. (since C++11). ">
  <meta name="keywords" content="aggregate, initialization, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/language/aggregate_initialization.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-9c7b0d969c0ce639a6c01c2badcdd81667c7c66206aa3d0fccc5cb0585fb1b912dab72ea882101d18010680927514b4b77b107282db8f756fbf63301fe9c88b0.css">
  <script type="text/javascript" src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js"></script>
  <script src="/json/cpp.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _cppref">
				
				
<h1 id="firstHeading" class="firstHeading">Aggregate initialization</h1>            <p>Initializes an aggregate from an initializer list. <span class="t-rev-inl t-since-cxx11"><span>It is a form of <a href="list_initialization" title="cpp/language/list initialization">list-initialization</a>.</span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>.</p>
<h3 id="Syntax"> Syntax</h3> <table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">T object</span> <code>= {</code> <span class="t-spar">arg1, arg2, ...</span> <code>};</code> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">T object</span> <code>{</code> <span class="t-spar">arg1, arg2, ...</span> <code>};</code> </td> <td> (2) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">T object</span> <code>= { .</code><span class="t-spar">des1</span> <code>=</code> <span class="t-spar">arg1</span> <code>, .</code><span class="t-spar">des2</span> <code>{</code> <span class="t-spar">arg2</span> <code>}</code> <span class="t-spar">...</span> <code>};</code> </td> <td> (3) </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">T object</span> <code>{ .</code><span class="t-spar">des1</span> <code>=</code> <span class="t-spar">arg1</span> <code>, .</code><span class="t-spar">des2</span> <code>{</code> <span class="t-spar">arg2</span> <code>}</code> <span class="t-spar">...</span> <code>};</code> </td> <td> (4) </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td>
</tr> 
</table> <div class="t-li1">
<span class="t-li">1,2)</span> Initializing an aggregate with an ordinary initializer list.</div> <div class="t-li1">
<span class="t-li">3,4)</span> Initializing an aggregate with <a href="#Designated_initializers">designated initializers</a> (aggregate class only).</div> <h3 id="Explanation"> Explanation</h3> <h4 id="Definitions"> Definitions</h4> <p>An <i>aggregate</i> is one of the following types:</p>
<ul>
<li> array type </li>
<li> class type (typically, <code>struct</code> or <code>union</code>), that has </li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx11">
<td> <ul><li> no user-declared constructors </li></ul> </td> <td><span class="t-mark-rev t-until-cxx11">(until C++11)</span></td>
</tr> <tr class="t-rev t-since-cxx11 t-until-cxx20">
<td> <ul><li> no <a href="function#User-provided_functions" title="cpp/language/function">user-provided</a>, <a href="using_declaration#Inheriting_constructors" title="cpp/language/using declaration">inherited</a>, or <a href="explicit" title="cpp/language/explicit">explicit</a> constructors </li></ul> </td> <td>
<span class="t-mark-rev t-since-cxx11">(since C++11)</span><br><span class="t-mark-rev t-until-cxx20">(until C++20)</span>
</td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <ul><li> no user-declared or inherited constructors </li></ul> </td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <ul><li> no private or protected <span class="t-rev-inl t-since-cxx17"><span>direct</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> non-static data members </li></ul> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx17">
<td> <ul><li> no <a href="derived_class" title="cpp/language/derived class">base classes</a> </li></ul> </td> <td><span class="t-mark-rev t-until-cxx17">(until C++17)</span></td>
</tr> <tr class="t-rev t-since-cxx17">
<td> <ul>
<li> no <a href="derived_class#Virtual_base_classes" title="cpp/language/derived class">virtual base classes</a> </li>
<li> no <a href="derived_class#Private_inheritance" title="cpp/language/derived class">private</a> or <a href="derived_class#Protected_inheritance" title="cpp/language/derived class">protected</a> direct base classes </li>
</ul> </td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <ul><li> no virtual member functions </li></ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11 t-until-cxx14">
<td> <ul><li> no <a href="data_members#Member_initialization" title="cpp/language/data members">default member initializers</a> </li></ul> </td> <td>
<span class="t-mark-rev t-since-cxx11">(since C++11)</span><br><span class="t-mark-rev t-until-cxx14">(until C++14)</span>
</td>
</tr> </table> <p><br> The <i>elements</i> of an aggregate are:</p>
<ul><li> for an array, the array elements in increasing subscript order, or </li></ul> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx17">
<td> <ul><li> for a class, the non-static data members that are not anonymous <a href="bit_field" title="cpp/language/bit field">bit-fields</a>, in declaration order. </li></ul> </td> <td><span class="t-mark-rev t-until-cxx17">(until C++17)</span></td>
</tr> <tr class="t-rev t-since-cxx17">
<td> <ul><li> for a class, the direct base classes in declaration order, followed by the direct non-static data members that are neither anonymous <a href="bit_field" title="cpp/language/bit field">bit-fields</a> nor members of an <a href="union#Anonymous_unions" title="cpp/language/union">anonymous union</a>, in declaration order. </li></ul> </td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <h4 id="Process"> Process</h4> <p>The effects of aggregate initialization are:</p>
<div class="t-li1">
<span class="t-li">1)</span> Reject the following ill-formed cases: <ul>
<li> the number of initializer clauses in the initializer list exceeds the number of elements of the aggregate, or </li>
<li> initialize an array of unknown bound with an empty initializer list (<code>{}</code>).</li>
</ul>
</div> <div class="cpp source-cpp"><pre data-language="cpp">char cv[4] = {'a', 's', 'd', 'f', 0}; // error
int x[] = {}                          // error</pre></div> <div class="t-li1">
<span class="t-li">2)</span> Determine the <i>explicitly initialized elements</i> of the aggregate as follows:</div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <ul><li> If the initializer list is a <a href="#Designated_initializers">designated initializer list</a> (the aggregate can only be of class type), the identifier in each designator shall name a direct non-static data member of the class, and the explicitly initialized elements of the aggregate are the elements that are, or contain, those members. </li></ul> </td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <ul>
<li> Otherwise, if the initializer list is non-empty, the explicitly initialized elements of the aggregate are the first <i>n</i> elements of the aggregate, where <i>n</i> is the number of elements in the initializer list. </li>
<li> Otherwise, the initializer list must be empty (<code>{}</code>), and there are no explicitly initialized elements. </li>
</ul> The program is ill-formed if the aggregate is a union and there are two or more explicitly initialized elements:  <div class="cpp source-cpp"><pre data-language="cpp">union u { int a; const char* b; };
 
u a = {1};                   // OK: explicitly initializes member `a`
u b = {0, "asdf"};           // error: explicitly initializes two members
u c = {"asdf"};              // error: int cannot be initialized by "asdf"
 
// C++20 designated initializer lists
u d = {.b = "asdf"};         // OK: can explicitly initialize a non-initial member
u e = {.a = 1, .b = "asdf"}; // error: explicitly initializes two members</pre></div> <div class="t-li1">
<span class="t-li">3)</span> Initialize each element of the aggregate <span class="t-rev-inl t-since-cxx11"><span>in the element order. That is, all value computations and side effects associated with a given element are <a href="eval_order" title="cpp/language/eval order">sequenced before</a> those of any element that follows it in order</span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>.</div> <h4 id="Initializing_Elements"> Initializing Elements</h4> <p>For each explicitly initialized element:</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <ul><li> If the element is an anonymous union member and the initializer list is a <a href="#Designated_initializers">designated initializer list</a>, the element is initialized by the designated initializer list <code>{D}</code>, where <code>D</code> is the designated initializer clause naming a member of the anonymous union member. There shall be only one such designated initializer clause. </li></ul> <div class="cpp source-cpp"><pre data-language="cpp">struct C
{
    union
    {
        int a;
        const char* p;
    };
 
    int x;
} c = {.a = 1, .x = 3}; // initializes c.a with 1 and c.x with 3</pre></div> </td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <ul><li> Otherwise, the element is <a href="copy_initialization" title="cpp/language/copy initialization">copy-initialized</a> from the corresponding initializer clause of the initializer list: </li></ul> </td> <td><span class="t-mark-rev t-until-cxx20">(until C++20)</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <ul><li> Otherwise, the element is initialized from the corresponding initializer clause of the initializer list. The initialization is <a href="direct_initialization" title="cpp/language/direct initialization">direct-initialization</a> if the initializer list is a designated initializer list and the initializer begins with <code>=</code>, otherwise the initialization is <a href="copy_initialization" title="cpp/language/copy initialization">copy-initialization</a>: </li></ul> </td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <ul>
<li> If the initializer clause is an expression, <a href="implicit_cast" title="cpp/language/implicit cast" class="mw-redirect">implicit conversions</a> are allowed as per copy-initialization<span class="t-rev-inl t-since-cxx11"><span>, except that narrowing conversions are prohibited</span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>. </li>
<li> If the initializer clause is a nested <span class="t-spar">braced-init-list</span> (which is not an expression), <span class="t-rev-inl t-since-cxx11"><span><a href="list_initialization" title="cpp/language/list initialization">list-initialize</a> the corresponding element from that clause, which will</span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span> recursively apply the rule if the corresponding element is a subaggregate. </li>
</ul> <div class="cpp source-cpp"><pre data-language="cpp">struct A
{
    int x;
 
    struct B
    {
        int i;
        int j;
    } b;
} a = {1, {2, 3}}; // initializes a.x with 1, a.b.i with 2, a.b.j with 3
 
struct base1 { int b1, b2 = 42; };
 
struct base2
{
    base2()
    {
        b3 = 42;
    }
 
    int b3;
};
 
struct derived : base1, base2
{
    int d;
};
 
derived d1{{1, 2}, {}, 4}; // initializes d1.b1 with 1, d1.b2 with 2,
                           //             d1.b3 with 42, d1.d with 4
derived d2{{}, {}, 4};     // initializes d2.b1 with 0, d2.b2 with 42,
                           //             d2.b3 with 42, d2.d with 4</pre></div> <p><br> For a non-union aggregate, each element that is not an explicitly initialized element is initialized as follows:</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul><li> If the element has a <a href="data_members#Member_initialization" title="cpp/language/data members">default member initializer</a>, the element is initialized from that initializer. </li></ul> </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <ul>
<li> Otherwise, if the element is not a reference, the element is copy-initialized from an empty initializer list. </li>
<li> Otherwise, the program is ill-formed. </li>
</ul> <div class="cpp source-cpp"><pre data-language="cpp">struct S
{
    int a;
    const char* b;
    int c;
    int d = b[a];
};
 
// initializes ss.a with 1,
//             ss.b with "asdf",
//             ss.c with the value of an expression of the form int{} (that is, 0),
//         and ss.d with the value of ss.b[ss.a] (that is, 's')
S ss = {1, "asdf"};</pre></div> <p><br> If the aggregate is a union and the initializer list is empty, then.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul><li> If any variant member has a default member initializer, that member is initialized from its default member initializer. </li></ul> </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <ul><li> Otherwise, the first member of the union (if any) is copy-initialized from an empty initializer list. </li></ul> <h4 id="Brace_elision"> Brace elision</h4> <p>The braces around the nested initializer lists may be elided (omitted), in which case as many initializer clauses as necessary are used to initialize every member or element of the corresponding subaggregate, and the subsequent initializer clauses are used to initialize the following members of the object. However, if the object has a sub-aggregate without any members (an empty struct, or a struct holding only static members), brace elision is not allowed, and an empty nested list <code>{}</code> must be used.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <h3 id="Designated_initializers"> Designated initializers</h3> <p>The syntax forms <span class="t-v">(3,4)</span> are known as designated initializers: each <span class="t-spar">designator</span> must name a direct non-static data member of T, and all <span class="t-spar">designator</span> ﻿s used in the expression must appear in the same order as the data members of T.</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct A { int x; int y; int z; };
 
A a{.y = 2, .x = 1}; // error; designator order does not match declaration order
A b{.x = 1, .z = 2}; // ok, b.y initialized to 0</pre></div> <p>Each direct non-static data member named by the designated initializer is initialized from the corresponding brace-or-equals initializer that follows the designator. Narrowing conversions are prohibited.</p>
<p>Designated initializer can be used to initialize a <a href="union" title="cpp/language/union">union</a> into the state other than the first. Only one initializer may be provided for a union.</p>
<div class="cpp source-cpp"><pre data-language="cpp">union u { int a; const char* b; };
 
u f = {.b = "asdf"};         // OK, active member of the union is b
u g = {.a = 1, .b = "asdf"}; // Error, only one initializer may be provided</pre></div> <p>For a non-union aggregate, elements for which a designated initializer is not provided are initialized the same as described above for when the number of initializer clauses is less than the number of members (default member initializers where provided, empty list-initialization otherwise):</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct A
{
    string str;
    int n = 42;
    int m = -1;
};
 
A{.m = 21} // Initializes str with {}, which calls the default constructor
           // then initializes n with = 42
           // then initializes m with = 21</pre></div> <p>If the aggregate that is initialized with a designated initializer clause has an anonymous union member, the corresponding designated initializer must name one of the members of that anonymous union.</p>
<p>Note: out-of-order designated initialization, nested designated initialization, mixing of designated initializers and regular initializers, and designated initialization of arrays are all supported in the <a href="https://en.cppreference.com/w/c/language/struct_initialization" title="c/language/struct initialization">C programming language</a>, but are not allowed in C++.</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct A { int x, y; };
struct B { struct A a; };
 
struct A a = {.y = 1, .x = 2}; // valid C, invalid C++ (out of order)
int arr[3] = {[1] = 5};        // valid C, invalid C++ (array)
struct B b = {.a.x = 0};       // valid C, invalid C++ (nested)
struct A a = {.x = 1, 2};      // valid C, invalid C++ (mixed)</pre></div> </td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <h3 id="Character_arrays"> Character arrays</h3> <p>Arrays of ordinary character types (<code>char</code>, <code>signed char</code>, <code>unsigned char</code>)<span class="t-rev-inl t-since-cxx20"><span>, <code>char8_t</code></span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span><span class="t-rev-inl t-since-cxx11"><span>, <code>char16_t</code>, <code>char32_t</code></span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>, or <code>wchar_t</code> can be initialized from ordinary <a href="string_literal" title="cpp/language/string literal">string literals</a><span class="t-rev-inl t-since-cxx20"><span>, UTF-8 string literals</span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span><span class="t-rev-inl t-since-cxx11"><span>, UTF-16 string literals, UTF-32 string literals</span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>, or wide string literals, respectively, optionally enclosed in braces. <span class="t-rev-inl t-since-cxx20"><span>Additionally, an array of <code>char</code> or <code>unsigned char</code> may be initialized by a UTF-8 string literal, optionally enclosed in braces.</span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span> Successive characters of the string literal (which includes the implicit terminating null character) initialize the elements of the array<span class="t-rev-inl t-since-cxx20"><span>, with an <a href="implicit_conversion#Integral_conversions" title="cpp/language/implicit conversion">integral conversion</a> if necessary for the source and destination value</span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span>. If the size of the array is specified and it is larger than the number of characters in the string literal, the remaining characters are zero-initialized.</p>
<div class="cpp source-cpp"><pre data-language="cpp">char a[] = "abc";
// equivalent to char a[4] = {'a', 'b', 'c', '\0'};
 
//  unsigned char b[3] = "abc"; // Error: initializer string too long
unsigned char b[5]{"abc"};
// equivalent to unsigned char b[5] = {'a', 'b', 'c', '\0', '\0'};
 
wchar_t c[] = {L"кошка"}; // optional braces
// equivalent to wchar_t c[6] = {L'к', L'о', L'ш', L'к', L'а', L'\0'};</pre></div> <h3 id="Notes"> Notes</h3> <p>An aggregate class or array may include non-aggregate <span class="t-rev-inl t-since-cxx17"><span>public bases</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span>, members, or elements, which are initialized as described above (e.g. copy-initialization from the corresponding initializer clause).</p>
<p>Until C++11, narrowing conversions were permitted in aggregate initialization, but they are no longer allowed.</p>
<p>Until C++11, aggregate initialization could only be used in variable definition, and could not be used in a <a href="constructor" title="cpp/language/constructor">constructor initializer list</a>, a <a href="new" title="cpp/language/new">new-expression</a>, or temporary object creation due to syntax restrictions.</p>
<p>In C, character array of size one less than the size of the string literal may be initialized from a string literal; the resulting array is not null-terminated. This is not allowed in C++.</p>
<table class="wikitable sortable ftm-begin ftm-has-value"> <tr> <th>Feature-test macro</th> <th>Value</th> <th><span title="Standard in which the feature is introduced">Std</span></th> <th>Comment </th>
</tr> <tr> <td><a href="../feature_test#Language_features" title="cpp/feature test"><code>__cpp_aggregate_bases</code></a></td> <td><span class="nu0">201603L</span></td> <td><span class="t-mark">(C++17)</span></td> <td>Aggregate classes with base classes </td>
</tr> <tr> <td><a href="../feature_test#Language_features" title="cpp/feature test"><code>__cpp_aggregate_nsdmi</code></a></td> <td><span class="nu0">201304L</span></td> <td><span class="t-mark">(C++14)</span></td> <td>Aggregate classes with default member initializers </td>
</tr> <tr> <td><a href="../feature_test#Language_features" title="cpp/feature test"><code>__cpp_aggregate_paren_init</code></a></td> <td><span class="nu0">201902L</span></td> <td><span class="t-mark">(C++20)</span></td> <td>Aggregate initialization in the form of <a href="direct_initialization" title="cpp/language/direct initialization">direct initialization</a> </td>
</tr> <tr> <td><a href="../feature_test#Language_features" title="cpp/feature test"><code>__cpp_char8_t</code></a></td> <td><span class="nu0">202207L</span></td> <td>
<span class="t-mark">(C++20)</span><br><span class="t-mark">(DR)</span>
</td> <td>
<code>char8_t</code> compatibility and portability fix (<a href="#Character_arrays">allow initialization of (<code>unsigned</code>) <code>char</code> arrays</a> from <a href="string_literal" title="cpp/language/string literal">UTF-8 string literals</a>) </td>
</tr> <tr> <td><a href="../feature_test#Language_features" title="cpp/feature test"><code>__cpp_designated_initializers</code></a></td> <td><span class="nu0">201707L</span></td> <td><span class="t-mark">(C++20)</span></td> <td>
<a href="#Designated_initializers">Designated initializer</a> </td>
</tr>
</table> <h3 id="Example"> Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;array&gt;
#include &lt;cstdio&gt;
#include &lt;string&gt;
 
struct S
{
    int x;
 
    struct Foo
    {
        int i;
        int j;
        int a[3];
    } b;
};
 
int main()
{
    S s1 = {1, {2, 3, {4, 5, 6}}};
    S s2 = {1, 2, 3, 4, 5, 6};  // same, but with brace elision
    S s3{1, {2, 3, {4, 5, 6}}}; // same, using direct-list-initialization syntax
    S s4{1, 2, 3, 4, 5, 6}; // error until CWG 1270:
                            // brace elision only allowed with equals sign
 
    int ar[] = {1, 2, 3}; // ar is int[3]
//  char cr[3] = {'a', 'b', 'c', 'd'}; // too many initializer clauses
    char cr[3] = {'a'}; // array initialized as {'a', '\0', '\0'}
 
    int ar2d1[2][2] = {{1, 2}, {3, 4}}; // fully-braced 2D array: {1, 2}
                                        //                        {3, 4}
    int ar2d2[2][2] = {1, 2, 3, 4}; // brace elision: {1, 2}
                                    //                {3, 4}
    int ar2d3[2][2] = {{1}, {2}};   // only first column: {1, 0}
                                    //                    {2, 0}
 
    std::array&lt;int, 3&gt; std_ar2{{1, 2, 3}};  // std::array is an aggregate
    std::array&lt;int, 3&gt; std_ar1 = {1, 2, 3}; // brace-elision okay
 
//  int ai[] = {1, 2.0}; // narrowing conversion from double to int:
                         // error in C++11, okay in C++03
 
    std::string ars[] = {std::string("one"), // copy-initialization
                         "two",              // conversion, then copy-initialization
                         {'t', 'h', 'r', 'e', 'e'}}; // list-initialization
    union U
    {
        int a;
        const char* b;
    };
    U u1 = {1};         // OK, first member of the union
//  U u2 = {0, "asdf"}; // error: too many initializers for union
//  U u3 = {"asdf"};    // error: invalid conversion to int
 
    [](...) { std::puts("Garbage unused variables... Done."); }
    (
        s1, s2, s3, s4, ar, cr, ar2d1, ar2d2, ar2d3, std_ar2, std_ar1, u1
    );
}
 
// aggregate
struct base1 { int b1, b2 = 42; };
 
// non-aggregate
struct base2
{
    base2() : b3(42) {}
 
    int b3;
};
 
// aggregate in C++17
struct derived : base1, base2 { int d; };
 
derived d1{{1, 2}, {}, 4}; // d1.b1 = 1, d1.b2 = 2,  d1.b3 = 42, d1.d = 4
derived d2{{}, {}, 4};     // d2.b1 = 0, d2.b2 = 42, d2.b3 = 42, d2.d = 4</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">Garbage unused variables... Done.</pre></div> </div> <h3 id="Defect_reports"> Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th> DR </th> <th> Applied to </th> <th> Behavior as published </th> <th> Correct behavior </th>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/413.html">CWG 413</a> </td> <td> C++98 </td> <td> anonymous bit-fields were initialized in aggregate initialization </td> <td> they are ignored </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/737.html">CWG 737</a> </td> <td> C++98 </td> <td> when a character array is initialized with a string literal<br>having fewer characters than the array size, the character<br>elements after the trailing <code>'\0'</code> was uninitialized </td> <td> they are zero-initialized </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1270.html">CWG 1270</a> </td> <td> C++11 </td> <td> brace elision was only allowed to be used in copy-list-initialization </td> <td> allowed elsewhere </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1518.html">CWG 1518</a> </td> <td> C++11 </td> <td> a class that declares an explicit default constructor or<br>has inherited constructors should could be an aggregate </td> <td> it is not an aggregate </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1622.html">CWG 1622</a> </td> <td> C++98 </td> <td> a union could not be initialized with <code>{}</code> </td> <td> allowed </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2272.html">CWG 2272</a> </td> <td> C++98 </td> <td> a non-static reference member that is not explicitly<br>initialized was copy-initialized from an empty initializer list </td> <td> the program is ill-<br>formed in this case </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2610.html">CWG 2610</a> </td> <td> C++17 </td> <td> aggregate types could not have private or protected indirect base classes </td> <td> allowed </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2619.html">CWG 2619</a> </td> <td> C++20 </td> <td> the kind of the initialization from designated initializers was unclear </td> <td> it depends on the kind of the initializer </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://wg21.link/P2513R4">P2513R4</a> </td> <td> C++20 </td> <td> a UTF-8 string literal could not initialize an array of <code>char</code><br>or <code>unsigned char</code>, which was incompatible with C or C++17 </td> <td> such initialization is valid </td>
</tr>
</table> <h3 id="See_also"> See also</h3> <ul>
<li> <a href="copy_elision" title="cpp/language/copy elision">copy elision</a> </li>
<li> <a href="initialization" title="cpp/language/initialization">initialization</a> <ul>
<li> <a href="constant_initialization" title="cpp/language/constant initialization">constant initialization</a> </li>
<li> <a href="list_initialization" title="cpp/language/list initialization">list initialization</a> </li>
<li> <a href="reference_initialization" title="cpp/language/reference initialization">reference initialization</a> </li>
<li> <a href="value_initialization" title="cpp/language/value initialization">value initialization</a> </li>
<li> <a href="zero_initialization" title="cpp/language/zero initialization">zero initialization</a> </li>
</ul> </li>
</ul> <table class="t-dsc-begin"> <tr class="t-dsc"> <td colspan="2"> <span><a href="https://en.cppreference.com/w/c/language/struct_initialization" title="c/language/struct initialization">C documentation</a></span> for <span class=""><span>Struct and union initialization</span></span> </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    © cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/language/aggregate_initialization" class="_attribution-link">https://en.cppreference.com/w/cpp/language/aggregate_initialization</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
