
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Template Argument Deduction - C++ - W3cubDocs</title>
  
  <meta name="description" content="In order to instantiate a function template, every template argument must be known, but not every template argument has to be specified. When &hellip;">
  <meta name="keywords" content="template, argument, deduction, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/language/template_argument_deduction.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-9c7b0d969c0ce639a6c01c2badcdd81667c7c66206aa3d0fccc5cb0585fb1b912dab72ea882101d18010680927514b4b77b107282db8f756fbf63301fe9c88b0.css">
  <script type="text/javascript" src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js"></script>
  <script src="/json/cpp.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _cppref">
				
				
<h1 id="firstHeading" class="firstHeading">Template argument deduction</h1>            <p>In order to instantiate a <a href="function_template" title="cpp/language/function template">function template</a>, every template argument must be known, but not every template argument has to be specified. When possible, the compiler will deduce the missing template arguments from the function arguments. This occurs when a function call is attempted, when an address of a function template is taken, and in some <a href="#Other_contexts">other contexts</a>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename To, typename From&gt;
To convert(From f);
 
void g(double d) 
{
    int i = convert&lt;int&gt;(d);    // calls convert&lt;int, double&gt;(double)
    char c = convert&lt;char&gt;(d);  // calls convert&lt;char, double&gt;(double)
    int(*ptr)(float) = convert; // instantiates convert&lt;int, float&gt;(float) 
                                // and stores its address in ptr
}</pre></div> <p>This mechanism makes it possible to use template operators, since there is no syntax to specify template arguments for an operator other than by re-writing it as a function call expression:</p>
<div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
 
int main() 
{
    std::cout &lt;&lt; "Hello, world" &lt;&lt; std::endl;
    // operator&lt;&lt; is looked up via ADL as std::operator&lt;&lt;,
    // then deduced to operator&lt;&lt;&lt;char, std::char_traits&lt;char&gt;&gt; both times
    // std::endl is deduced to &amp;std::endl&lt;char, std::char_traits&lt;char&gt;&gt;
}</pre></div> <p>Template argument deduction takes place after the function template <a href="lookup" title="cpp/language/lookup">name lookup</a> (which may involve <a href="adl" title="cpp/language/adl">argument-dependent lookup</a>) and before <a href="function_template#Template_argument_substitution" title="cpp/language/function template">template argument substitution</a> (which may involve <a href="sfinae" title="cpp/language/sfinae">SFINAE</a>) and <a href="overload_resolution" title="cpp/language/overload resolution">overload resolution</a>.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <p>Template argument deduction is also performed when the name of a class template is used as the type of an object being constructed:</p>
<div class="cpp source-cpp"><pre data-language="cpp">std::pair p(2, 4.5);
std::tuple t(4, 3, 2.5);
std::copy_n(vi1, 3, std::back_insert_iterator(vi2));
std::for_each(vi.begin(), vi.end(), Foo([&amp;](int i) {...}));
auto lck = std::lock_guard(foo.mtx);
std::lock_guard lck2(foo.mtx, ul);</pre></div> <p>Template argument deduction for class templates takes place in declarations and in explicit cast expressions; see <a href="class_template_argument_deduction" title="cpp/language/class template argument deduction">class template argument deduction</a> for details.</p>
</td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table>  <h3 id="Deduction_from_a_function_call"> Deduction from a function call</h3> <p>Template argument deduction attempts to determine template arguments (types for type template parameters <code>T</code>i, templates for template template parameters <code>TT</code>i, and values for non-type template parameters <code>I</code>i), which can be substituted into each parameter <code>P</code> to produce the type <i>deduced</i> <code>A</code>, which is the same as the type of the argument <code>A</code>, after adjustments listed below.</p>
<p>If there are multiple parameters, each <code>P</code>/<code>A</code> pair is deduced separately and the deduced template arguments are then combined. If deduction fails or is ambiguous for any <code>P</code>/<code>A</code> pair or if different pairs yield different deduced template arguments, or if any template argument remains neither deduced nor explicitly specified, compilation fails.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>If removing references and cv-qualifiers from <code>P</code> gives <code><a href="http://en.cppreference.com/w/cpp/utility/initializer_list"><span class="kw962">std::<span class="me2">initializer_list</span></span></a><span class="sy1">&lt;</span>P<span class="st0">'&gt;</span></code> and <code>A</code> is a <a href="list_initialization" title="cpp/language/list initialization">braced-init-list</a>, then deduction is performed for every element of the initializer list, taking <code>P'</code> as the parameter and the list element <code>A'</code> as the argument:</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;class T&gt;
void f(std::initializer_list&lt;T&gt;);
 
f({1, 2, 3});  // P = std::initializer_list&lt;T&gt;, A = {1, 2, 3}
               // P'1 = T, A'1 = 1: deduced T = int
               // P'2 = T, A'2 = 2: deduced T = int
               // P'3 = T, A'3 = 3: deduced T = int
               // OK: deduced T = int
 
f({1, "abc"}); // P = std::initializer_list&lt;T&gt;, A = {1, "abc"}
               // P'1 = T, A'1 = 1: deduced T = int
               // P'2 = T, A'2 = "abc": deduced T = const char*
               // error: deduction fails, T is ambiguous</pre></div> <p>If removing references and cv-qualifiers from <code>P</code> gives <code>P'</code>[<code>N</code>], and <code>A</code> is a non-empty braced-init-list, then deduction is performed as above, except if <code>N</code> is a non-type template parameter, it is deduced from the length of the initializer list:</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;class T, int N&gt;
void h(T const(&amp;)[N]);
h({1, 2, 3}); // deduced T = int, deduced N = 3
 
template&lt;class T&gt;
void j(T const(&amp;)[3]);
j({42}); // deduced T = int, array bound is not a parameter, not considered
 
struct Aggr
{
    int i;
    int j;
};
 
template&lt;int N&gt;
void k(Aggr const(&amp;)[N]);
k({1, 2, 3});       // error: deduction fails, no conversion from int to Aggr
k({{1}, {2}, {3}}); // OK: deduced N = 3
 
template&lt;int M, int N&gt;
void m(int const(&amp;)[M][N]);
m({{1, 2}, {3, 4}}); // deduced M = 2, deduced N = 2
 
template&lt;class T, int N&gt;
void n(T const(&amp;)[N], T);
n({{1}, {2}, {3}}, Aggr()); // deduced T = Aggr, deduced N = 3</pre></div> <p>If a <a href="parameter_pack" title="cpp/language/parameter pack">parameter pack</a> appears as the last <code>P</code>, then the type <code>P</code> is matched against the type <code>A</code> of each remaining argument of the call. Each match deduces the template arguments for the next position in the pack expansion:</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;class... Types&gt;
void f(Types&amp;...);
 
void h(int x, float&amp; y)
{
    const int z = x;
    f(x, y, z); // P = Types&amp;..., A1 = x: deduced first member of Types... = int
                // P = Types&amp;..., A2 = y: deduced second member of Types... = float
                // P = Types&amp;..., A3 = z: deduced third member of Types... = const int
                // calls f&lt;int, float, const int&gt;
}</pre></div> </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <p>If <code>P</code> is a function type, pointer to function type, or pointer to member function type and if <code>A</code> is a <a href="overloaded_address" title="cpp/language/overloaded address">set of overloaded functions</a> not containing function templates, template argument deduction is attempted with each overload. If only one succeeds, that successful deduction is used. If none or more than one succeeds, the template parameter is non-deduced context (see below):</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;class T&gt;
int f(T(*p)(T));
 
int g(int);
int g(char);
 
f(g); // P = T(*)(T), A = overload set
      // P = T(*)(T), A1 = int(int): deduced T = int
      // P = T(*)(T), A2 = int(char): fails to deduce T
      // only one overload works, deduction succeeds</pre></div> <p>Before deduction begins, the following adjustments to <code>P</code> and <code>A</code> are made:</p>
<div class="t-li1">
<span class="t-li">1)</span> If <code>P</code> is not a reference type, </div> <div class="t-li2">
<span class="t-li">a)</span> if <code>A</code> is an array type, <code>A</code> is replaced by the pointer type obtained from array-to-pointer conversion;</div> <div class="t-li2">
<span class="t-li">b)</span> otherwise, if <code>A</code> is a function type, <code>A</code> is replaced by the pointer type obtained from function-to-pointer conversion;</div> <div class="t-li2">
<span class="t-li">c)</span> otherwise, if <code>A</code> is a cv-qualified type, the top-level cv-qualifiers are ignored for deduction: <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class T&gt;
void f(T);
 
int a[3];
f(a); // P = T, A = int[3], adjusted to int*: deduced T = int*
 
void b(int);
f(b); // P = T, A = void(int), adjusted to void(*)(int): deduced T = void(*)(int)
 
const int c = 13;
f(c); // P = T, A = const int, adjusted to int: deduced T = int</pre></div>
</div> <div class="t-li1">
<span class="t-li">2)</span> If <code>P</code> is a cv-qualified type, the top-level cv-qualifiers are ignored for deduction.</div> <div class="t-li1">
<span class="t-li">3)</span> If <code>P</code> is a reference type, the referenced type is used for deduction.</div> <div class="t-li1">
<span class="t-li">4)</span> If <code>P</code> is an rvalue reference to a cv-unqualified template parameter (so-called <a href="reference#Forwarding_references" title="cpp/language/reference">forwarding reference</a>), and the corresponding function call argument is an lvalue, the type lvalue reference to <code>A</code> is used in place of <code>A</code> for deduction (Note: this is the basis for the action of <code><a href="../utility/forward" title="cpp/utility/forward">std::forward</a></code> <span class="t-rev-inl t-since-cxx17"><span>Note: in <a href="class_template_argument_deduction" title="cpp/language/class template argument deduction">class template argument deduction</a>, template parameter of a class template is never a forwarding reference</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span>): <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class T&gt;
int f(T&amp;&amp;);       // P is an rvalue reference to cv-unqualified T (forwarding reference)
 
template&lt;class T&gt;
int g(const T&amp;&amp;); // P is an rvalue reference to cv-qualified T (not special)
 
int main()
{
    int i;
    int n1 = f(i); // argument is lvalue: calls f&lt;int&amp;&gt;(int&amp;) (special case)
    int n2 = f(0); // argument is not lvalue: calls f&lt;int&gt;(int&amp;&amp;)
 
//  int n3 = g(i); // error: deduces to g&lt;int&gt;(const int&amp;&amp;), which
                   // cannot bind an rvalue reference to an lvalue
}</pre></div>
</div> <p>After these transformations, the deduction processes as described below (cf. section <a href="#Deduction_from_a_type">Deduction from a type</a>) and attempts to find such template arguments that would make the deduced <code>A</code> (that is, <code>P</code> after adjustments listed above and the substitution of the deduced template parameters) identical to the <i>transformed</i> <code>A</code>, that is <code>A</code> after the adjustments listed above.</p>
<p>If the usual deduction from <code>P</code> and <code>A</code> fails, the following alternatives are additionally considered:</p>
<div class="t-li1">
<span class="t-li">1)</span> If <code>P</code> is a reference type, the deduced <code>A</code> (i.e., the type referred to by the reference) can be more cv-qualified than the transformed <code>A</code>: <div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename T&gt;
void f(const T&amp; t);
 
bool a = false;
f(a); // P = const T&amp;, adjusted to const T, A = bool:
      // deduced T = bool, deduced A = const bool
      // deduced A is more cv-qualified than A</pre></div>
</div> <div class="t-li1">
<span class="t-li">2)</span> The transformed <code>A</code> can be another pointer or pointer to member type that can be converted to the deduced <code>A</code> via a <a href="implicit_cast#Qualification_conversions" title="cpp/language/implicit cast" class="mw-redirect">qualification conversions</a> <span class="t-rev-inl t-since-cxx17"><span>or a function pointer conversion</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span>: <div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename T&gt;
void f(const T*);
 
int* p;
f(p); // P = const T*, A = int*:
      // deduced T = int, deduced A = const int*
      // qualification conversion applies (from int* to const int*)</pre></div>
</div> <div class="t-li1">
<span class="t-li">3)</span> If <code>P</code> is a class and <code>P</code> has the form <a href="templates#template-id" title="cpp/language/templates">simple-template-id</a>, then the transformed <code>A</code> can be a derived class of the deduced <code>A</code>. Likewise, if <code>P</code> is a pointer to a class of the form <i>simple-template-id</i>, the transformed <code>A</code> can be a pointer to a derived class pointed to by the deduced <code>A</code>: <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class T&gt;
struct B {};
 
template&lt;class T&gt;
struct D : public B&lt;T&gt; {};
 
template&lt;class T&gt;
void f(B&lt;T&gt;&amp;) {}
 
void f()
{
    D&lt;int&gt; d;
    f(d); // P = B&lt;T&gt;&amp;, adjusted to P = B&lt;T&gt; (a simple-template-id), A = D&lt;int&gt;:
          // deduced T = int, deduced A = B&lt;int&gt;
          // A is derived from deduced A
}</pre></div>
</div> <h4 id="Non-deduced_contexts"> Non-deduced contexts</h4> <p>In the following cases, the types, templates, and non-type values that are used to compose <code>P</code> do not participate in template argument deduction, but instead <i>use</i> the template arguments that were either deduced elsewhere or explicitly specified. If a template parameter is used only in non-deduced contexts and is not explicitly specified, template argument deduction fails.</p>
<div class="t-li1">
<span class="t-li">1)</span> The <span class="t-spar">nested-name-specifier</span> (everything to the left of the scope resolution operator <code>::</code>) of a type that was specified using a <a href="identifiers#Qualified_identifiers" title="cpp/language/identifiers">qualified-id</a>: <div class="cpp source-cpp"><pre data-language="cpp">// the identity template, often used to exclude specific arguments from deduction
// (available as std::type_identity as of C++20)
template&lt;typename T&gt;
struct identity { typedef T type; };
 
template&lt;typename T&gt;
void bad(std::vector&lt;T&gt; x, T value = 1);
 
template&lt;typename T&gt;
void good(std::vector&lt;T&gt; x, typename identity&lt;T&gt;::type value = 1);
 
std::vector&lt;std::complex&lt;double&gt;&gt; x;
 
bad(x, 1.2);  // P1 = std::vector&lt;T&gt;, A1 = std::vector&lt;std::complex&lt;double&gt;&gt;
              // P1/A1: deduced T = std::complex&lt;double&gt;
              // P2 = T, A2 = double
              // P2/A2: deduced T = double
              // error: deduction fails, T is ambiguous
 
good(x, 1.2); // P1 = std::vector&lt;T&gt;, A1 = std::vector&lt;std::complex&lt;double&gt;&gt;
              // P1/A1: deduced T = std::complex&lt;double&gt;
              // P2 = identity&lt;T&gt;::type, A2 = double
              // P2/A2: uses T deduced by P1/A1 because T is to the left of :: in P2
              // OK: T = std::complex&lt;double&gt;</pre></div>
</div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <span class="t-li">2)</span> The expression of a <a href="decltype" title="cpp/language/decltype">decltype</a>-specifier: <div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename T&gt;
void f(decltype(*std::declval&lt;T&gt;()) arg);
 
int n;
f&lt;int*&gt;(n); // P = decltype(*declval&lt;T&gt;()), A = int: T is in non-deduced context</pre></div> </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <div class="t-li1">
<span class="t-li">3)</span> A non-type template argument or an array bound in which a subexpression references a template parameter: <div class="cpp source-cpp"><pre data-language="cpp">template&lt;std::size_t N&gt;
void f(std::array&lt;int, 2 * N&gt; a);
 
std::array&lt;int, 10&gt; a;
f(a); // P = std::array&lt;int, 2 * N&gt;, A = std::array&lt;int, 10&gt;:
      // 2 * N is non-deduced context, N cannot be deduced
      // note: f(std::array&lt;int, N&gt; a) would be able to deduce N</pre></div>
</div> <div class="t-li1">
<span class="t-li">4)</span> A template parameter used in the parameter type of a function parameter that has a default argument that is being used in the call for which argument deduction is being done: <div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename T, typename F&gt;
void f(const std::vector&lt;T&gt;&amp; v, const F&amp; comp = std::less&lt;T&gt;());
 
std::vector&lt;std::string&gt; v(3);
f(v); // P1 = const std::vector&lt;T&gt;&amp;, A1 = std::vector&lt;std::string&gt; lvalue
      // P1/A1 deduced T = std::string
      // P2 = const F&amp;, A2 = std::less&lt;std::string&gt; rvalue
      // P2 is non-deduced context for F (template parameter) used in the
      // parameter type (const F&amp;) of the function parameter comp,
      // that has a default argument that is being used in the call f(v)</pre></div>
</div> <div class="t-li1">
<span class="t-li">5)</span> The parameter <code>P</code>, whose <code>A</code> is a function or a set of overloads such that more than one function matches <code>P</code> or no function matches <code>P</code> or the set of overloads includes one or more function templates: <div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename T&gt;
void out(const T&amp; value) { std::cout &lt;&lt; value; }
 
out("123");     // P = const T&amp;, A = const char[4] lvalue: deduced T = char[4]
out(std::endl); // P = const T&amp;, A = function template: T is in non-deduced context</pre></div>
</div> <div class="t-li1">
<span class="t-li">6)</span> The parameter <code>P</code>, whose <code>A</code> is a braced-init-list, but <code>P</code> is not <code><a href="../utility/initializer_list" title="cpp/utility/initializer list">std::initializer_list</a></code>, a reference to one (possibly cv-qualified)<span class="t-rev-inl t-since-cxx17"><span>, or a reference to an array</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span>: <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class T&gt;
void g1(std::vector&lt;T&gt;);
 
template&lt;class T&gt;
void g2(std::vector&lt;T&gt;, T x);
 
g1({1, 2, 3});     // P = std::vector&lt;T&gt;, A = {1, 2, 3}: T is in non-deduced context
                   // error: T is not explicitly specified or deduced from another P/A
 
g2({1, 2, 3}, 10); // P1 = std::vector&lt;T&gt;, A1 = {1, 2, 3}: T is in non-deduced context
                   // P2 = T, A2 = int: deduced T = int</pre></div>
</div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <span class="t-li">7)</span> The parameter <code>P</code> which is a parameter pack and does not occur at the end of the parameter list: <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class... Ts, class T&gt;
void f1(T n, Ts... args);
 
template&lt;class... Ts, class T&gt;
void f2(Ts... args, T n);
 
f1(1, 2, 3, 4); // P1 = T, A1 = 1: deduced T = int
                // P2 = Ts..., A2 = 2, A3 = 3, A4 = 4: deduced Ts = [int, int, int]
 
f2(1, 2, 3, 4); // P1 = Ts...: Ts is non-deduced context</pre></div> <span class="t-li">8)</span> The template parameter list that appears within the parameter <code>P</code>, and which includes a pack expansion that is not at the very end of the template parameter list: <div class="cpp source-cpp"><pre data-language="cpp">template&lt;int...&gt;
struct T {};
 
template&lt;int... Ts1, int N, int... Ts2&gt;
void good(const T&lt;N, Ts1...&gt;&amp; arg1, const T&lt;N, Ts2...&gt;&amp;);
 
template&lt;int... Ts1, int N, int... Ts2&gt;
void bad(const T&lt;Ts1..., N&gt;&amp; arg1, const T&lt;Ts2..., N&gt;&amp;);
 
T&lt;1, 2&gt; t1;
T&lt;1, -1, 0&gt; t2;
 
good(t1, t2); // P1 = const T&lt;N, Ts1...&gt;&amp;, A1 = T&lt;1, 2&gt;:
              // deduced N = 1, deduced Ts1 = [2]
              // P2 = const T&lt;N, Ts2...&gt;&amp;, A2 = T&lt;1, -1, 0&gt;:
              // deduced N = 1, deduced Ts2 = [-1, 0]
 
bad(t1, t2);  // P1 = const T&lt;Ts1..., N&gt;&amp;, A1 = T&lt;1, 2&gt;:
              // &lt;Ts1..., N&gt; is non-deduced context
              // P2 = const T&lt;Ts2..., N&gt;&amp;, A2 = T&lt;1, -1, 0&gt;:
              // &lt;Ts2..., N&gt; is non-deduced context</pre></div> </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <div class="t-li1">
<span class="t-li">9)</span> For <code>P</code> of array type (but not reference to array or pointer to array), the major array bound: <div class="cpp source-cpp"><pre data-language="cpp">template&lt;int i&gt;
void f1(int a[10][i]);
 
template&lt;int i&gt;
void f2(int a[i][20]);    // P = int[i][20], array type
 
template&lt;int i&gt;
void f3(int (&amp;a)[i][20]); // P = int(&amp;)[i][20], reference to array
 
void g()
{
    int a[10][20];
    f1(a);     // OK: deduced i = 20
    f1&lt;20&gt;(a); // OK
    f2(a);     // error: i is non-deduced context
    f2&lt;10&gt;(a); // OK
    f3(a);     // OK: deduced i = 10
    f3&lt;10&gt;(a); // OK
}</pre></div>
</div> <p>In any case, if any part of a type name is non-deduced, the entire type name is non-deduced context. However, compound types can include both deduced and non-deduced type names. For example, in <code>A&lt;T&gt;::B&lt;T2&gt;</code>, <code>T</code> is non-deduced because of rule #1 (nested name specifier), and <code>T2</code> is non-deduced because it is part of the same type name, but in <code>void(*f)(typename A&lt;T&gt;::B, A&lt;T&gt;)</code>, the <code>T</code> in <code>A&lt;T&gt;::B</code> is non-deduced (because of the same rule), while the <code>T</code> in <code>A&lt;T&gt;</code> is deduced.</p>
<h4 id="Deduction_from_a_type"> Deduction from a type</h4> <p>Given a function parameter <code>P</code> that depends on one or more type template parameters <code>T</code>i, template template parameters <code>TT</code>i, or non-type template parameters <code>I</code>i, and the corresponding argument <code>A</code>, deduction takes place if <code>P</code> has one of the following forms:</p>
<ul>
<li> <code><i>cv</i></code><span class="t-mark">(optional)</span> <code>T</code>; </li>
<li> <code>T*</code>; </li>
<li> <code>T&amp;</code>; </li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul><li> <code>T&amp;&amp;</code>; </li></ul> </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <ul><li> <code>T</code><span class="t-mark">(optional)</span> <code>[</code><code>I</code><span class="t-mark">(optional)</span><code>]</code>; </li></ul> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx17">
<td> <ul><li> <code>T</code><span class="t-mark">(optional)</span> <code>(</code><code>U</code><span class="t-mark">(optional)</span><code>)</code>; </li></ul> </td> <td><span class="t-mark-rev t-until-cxx17">(until C++17)</span></td>
</tr> <tr class="t-rev t-since-cxx17">
<td> <ul><li> <code>T</code><span class="t-mark">(optional)</span> <code>(</code><code>U</code><span class="t-mark">(optional)</span><code>)</code> <code>noexcept(</code><code>I</code><span class="t-mark">(optional)</span><code>)</code>; </li></ul> </td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <ul>
<li> <code>T</code><span class="t-mark">(optional)</span> <code>U</code><span class="t-mark">(optional)</span><code>::*</code>; </li>
<li> <code>TT</code><span class="t-mark">(optional)</span><code>&lt;T&gt;</code>; </li>
<li> <code>TT</code><span class="t-mark">(optional)</span><code>&lt;I&gt;</code>; </li>
<li> <code>TT</code><span class="t-mark">(optional)</span><code>&lt;TU&gt;</code>; </li>
<li> <code>TT</code><span class="t-mark">(optional)</span><code>&lt;&gt;</code>. </li>
</ul> <p>In the above forms,</p>
<ul>
<li> <code>T</code><span class="t-mark">(optional)</span> or <code>U</code><span class="t-mark">(optional)</span> represents a type or <span class="t-spar">parameter-type-list</span> that either satisfies these rules recursively, is a non-deduced context in <code>P</code> or <code>A</code>, or is the same non-dependent type in <code>P</code> and <code>A</code>. </li>
<li> <code>TT</code><span class="t-mark">(optional)</span> or <code>TU</code><span class="t-mark">(optional)</span> represents either a class template or a template template parameter. </li>
<li> <code>I</code><span class="t-mark">(optional)</span> represents an expression that either is an <code>I</code>, is value-dependent in <code>P</code> or <code>A</code>, or has the same constant value in <code>P</code> and <code>A</code>. </li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <ul><li> <code>noexcept(</code><code>I</code><span class="t-mark">(optional)</span><code>)</code> represents an <a href="noexcept_spec" title="cpp/language/noexcept spec">exception specification</a> in which the possibly-implicit <code>noexcept</code> specifier's operand satisfies the rules for an <code>I</code><span class="t-mark">(optional)</span> above. </li></ul> </td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <p>If <code>P</code> has one of the forms that include a template parameter list <code>&lt;T&gt;</code> or <code>&lt;I&gt;</code>, then each element <code>P</code>i of that template argument list is matched against the corresponding template argument <code>A</code>i of its <code>A</code>. If the last <code>P</code>i is a pack expansion, then its pattern is compared against each remaining argument in the template argument list of <code>A</code>. A trailing parameter pack that is not otherwise deduced, is deduced to an empty parameter pack.</p>
<p>If <code>P</code> has one of the forms that include a function parameter list <code>(T)</code>, then each parameter <code>P</code>i from that list is compared with the corresponding argument <code>A</code>i from <code>A</code>'s function parameter list. If the last <code>P</code>i is a pack expansion, then its declarator is compared with each remaining <code>A</code>i in the parameter type list of <code>A</code>.</p>
<p>Forms can be nested and processed recursively:</p>
<ul><li> <code>X&lt;int&gt;(*)(char[6])</code> is an example of <code>T*</code>, where <code>T</code> is <code>X&lt;int&gt;(char[6])</code>; </li></ul> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx17">
<td> <ul><li> <code>X&lt;int&gt;(char[6])</code> is an example of <code>T</code><span class="t-mark">(optional)</span> <code>(</code><code>U</code><span class="t-mark">(optional)</span><code>)</code>, where <code>T</code> is <code>X&lt;int&gt;</code> and <code>U</code> is <code>char[6]</code>; </li></ul> </td> <td><span class="t-mark-rev t-until-cxx17">(until C++17)</span></td>
</tr> <tr class="t-rev t-since-cxx17">
<td> <ul><li> <code>X&lt;int&gt;(char[6])</code> is an example of <code>T</code><span class="t-mark">(optional)</span> <code>(</code><code>U</code><span class="t-mark">(optional)</span><code>)</code> <code>noexcept(</code><code>I</code><span class="t-mark">(optional)</span><code>)</code>, where <code>T</code> is <code>X&lt;int&gt;</code>, <code>U</code> is <code>char[6]</code>, and <code>I</code> in the implicit <code>noexcept</code> specifier is <code>false</code>; </li></ul> </td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <ul>
<li> <code>X&lt;int&gt;</code> is an example of <code>TT</code><span class="t-mark">(optional)</span><code>&lt;T&gt;</code>, where <code>TT</code> is <code>X</code> and <code>T</code> is <code>int</code>, and </li>
<li> <code>char[6]</code> is an example of <code>T</code><span class="t-mark">(optional)</span> <code>[</code><code>I</code><span class="t-mark">(optional)</span><code>]</code>, where <code>T</code> is <code>char</code> and <code>I</code> is <code><a href="http://en.cppreference.com/w/cpp/types/size_t"><span class="kw107">std::<span class="me2">size_t</span></span></a><span class="br0">(</span><span class="nu0">6</span><span class="br0">)</span></code>. </li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx17">
<td> <p>Type template argument cannot be deduced from the type of a non-type template argument:</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename T, T i&gt;
void f(double a[10][i]);
 
double v[10][20];
f(v); // P = double[10][i], A = double[10][20]:
      // i can be deduced to equal 20
      // but T cannot be deduced from the type of i</pre></div> </td> <td><span class="t-mark-rev t-until-cxx17">(until C++17)</span></td>
</tr> <tr class="t-rev t-since-cxx17">
<td> <p>When the value of the argument corresponding to a non-type template parameter P that is declared with a dependent type is deduced from an expression, the template parameters in the type of P are deduced from the type of the value.</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;long n&gt;
struct A {};
 
template&lt;class T&gt;
struct C;
 
template&lt;class T, T n&gt;
struct C&lt;A&lt;n&gt;&gt; { using Q = T; };
 
typedef long R;
 
typedef C&lt;A&lt;2&gt;&gt;::Q R; // OK: T was deduced to long 
                      // from the template argument value in the type A&lt;2&gt;
 
template&lt;auto X&gt;
class bar {};
 
template&lt;class T, T n&gt;
void f(bar&lt;n&gt; x);
 
f(bar&lt;3&gt;{}); // OK: T was deduced to int (and n to 3)
             // from the template argument value in the type bar&lt;3&gt;</pre></div> <p>The type of <code>N</code> in the type <code>T[N]</code> is <code><a href="../types/size_t" title="cpp/types/size t">std::size_t</a></code>.</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;class T, T i&gt;
void f(int (&amp;a)[i]);
 
int v[10];
f(v); // OK: T is std::size_t</pre></div> <p>The type of <code>B</code> in <code>noexcept(B)</code> specifier of a function type is <code>bool</code>.</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;bool&gt;
struct A {};
 
template&lt;auto&gt;
struct B;
template&lt;auto X, void (*F)() noexcept(X)&gt;
struct B&lt;F&gt; { A&lt;X&gt; ax; };
 
void f_nothrow() noexcept;
B&lt;f_nothrow&gt; bn; // OK: X is deduced as true and the type of X is deduced as bool.</pre></div> </td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <p>If a non-type template parameter of function template is used in the template parameter list of function parameter (which is also a template), and the corresponding template argument is deduced, the type of the deduced template argument ( as specified in its enclosing template parameter list, meaning references are preserved) must match the type of the non-type template parameter exactly, except that cv-qualifiers are dropped, and except where the template argument is deduced from an array bound—in that case any integral type is allowed, even <code>bool</code> though it would always become <code>true</code>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;int i&gt;
class A {};
 
template&lt;short s&gt;
void f(A&lt;s&gt;); // the type of the non-type template param is short
 
void k1()
{
    A&lt;1&gt; a;  // the type of the non-type template param of a is int
 
    f(a);    // P = A&lt;(short)s&gt;, A = A&lt;(int)1&gt;
             // error: deduced non-type template argument does not have the same
             // type as its corresponding template argument
 
    f&lt;1&gt;(a); // OK: the template argument is not deduced, 
             // this calls f&lt;(short)1&gt;(A&lt;(short)1&gt;)
}
 
template&lt;int&amp;&gt;
struct X;
 
template&lt;int&amp; R&gt;
void k2(X&lt;R&gt;&amp;);
 
int n;
void g(X&lt;n&gt; &amp;x)
{
    k2(x); // P = X&lt;R&gt;, A = X&lt;n&gt;
           // parameter type is int&amp;
           // argument type is int&amp; in struct X's template declaration
           // OK (with CWG 2091): deduces R to refer to n
}</pre></div> <p>Type template parameter cannot be deduced from the type of a function default argument:</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename T&gt;
void f(T = 5, T = 7);
 
void g()
{
    f(1);     // OK: calls f&lt;int&gt;(1, 7)
    f();      // error: cannot deduce T
    f&lt;int&gt;(); // OK: calls f&lt;int&gt;(5, 7)
}</pre></div> <p>Deduction of template template parameter can use the type used in the template specialization used in the function call:</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;template&lt;typename&gt; class X&gt;
struct A {}; // A is a template with a TT param
 
template&lt;template&lt;typename&gt; class TT&gt;
void f(A&lt;TT&gt;) {}
 
template&lt;class T&gt;
struct B {};
 
A&lt;B&gt; ab;
f(ab); // P = A&lt;TT&gt;, A = A&lt;B&gt;: deduced TT = B, calls f(A&lt;B&gt;)</pre></div> <h3 id="Other_contexts"> Other contexts</h3> <p>Besides function calls and operator expressions, template argument deduction is used in the following situations:</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <h4 id="auto_type_deduction"> auto type deduction</h4> <p>Template argument deduction is used in <a href="declarations" title="cpp/language/declarations">declarations</a> of variables, when deducing the meaning of the <b><a href="auto" title="cpp/language/auto">auto specifier</a></b> from the variable's initializer.</p>
<p>The parameter <code>P</code> is obtained as follows: in <code>T</code>, the declared type of the variable that includes <code>auto</code>, every occurrence of <code>auto</code> is replaced with an imaginary type template parameter <code>U</code> or, if the initialization is copy-list-initialization, with <code>std::initializer_list&lt;U&gt;</code>. The argument <code>A</code> is the initializer expression. After deduction of <code>U</code> from <code>P</code> and <code>A</code> following the rules described above, the deduced <code>U</code> is substituted into <code>P</code> to get the actual variable type:</p>
<div class="cpp source-cpp"><pre data-language="cpp">const auto&amp; x = 1 + 2; // P = const U&amp;, A = 1 + 2:
                       // same rules as for calling f(1 + 2) where f is
                       // template&lt;class U&gt; void f(const U&amp; u)
                       // deduced U = int, the type of x is const int&amp;
 
auto l = {13}; // P = std::initializer_list&lt;U&gt;, A = {13}:
               // deduced U = int, the type of l is std::initializer_list&lt;int&gt;</pre></div> <p>In direct-list-initialization (but not in copy-list-initialization), when deducing the meaning of the <a href="auto" title="cpp/language/auto">auto</a> from a braced-init-list, the braced-init-list must contain only one element, and the type of auto will be the type of that element:</p>
<div class="cpp source-cpp"><pre data-language="cpp">auto x1 = {3}; // x1 is std::initializer_list&lt;int&gt;
auto x2{1, 2}; // error: not a single element
auto x3{3};    // x3 is int
               // (before N3922 x2 and x3 were both std::initializer_list&lt;int&gt;)</pre></div> </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx14">
<td> <h4 id="auto-returning_functions"> auto-returning functions</h4> <p>Template argument deduction is used in declarations of <a href="functions" title="cpp/language/functions">functions</a>, when deducing the meaning of the <a href="auto" title="cpp/language/auto">auto</a> specifier in the function's return type, from the return statement.</p>
<p>For auto-returning functions, the parameter <code>P</code> is obtained as follows: in <code>T</code>, the declared return type of the function that includes <code>auto</code>, every occurrence of <code>auto</code> is replaced with an imaginary type template parameter <code>U</code>. The argument <code>A</code> is the expression of the <a href="return" title="cpp/language/return">return</a> statement, and if the return statement has no operand, <code>A</code> is <code>void()</code>. After deduction of <code>U</code> from <code>P</code> and <code>A</code> following the rules described above, the deduced <code>U</code> is substituted into <code>T</code> to get the actual return type:</p>
<div class="cpp source-cpp"><pre data-language="cpp">auto f() { return 42; } // P = auto, A = 42:
                        // deduced U = int, the return type of f is int</pre></div> <p>If such function has multiple return statements, the deduction is performed for each return statement. All the resulting types must be the same and become the actual return type.</p>
<p>If such function has no return statement, <code>A</code> is <code>void()</code> when deducing.</p>
<p>Note: the meaning of <code>decltype(auto)</code> placeholder in variable and function declarations does not use template argument deduction.</p>
</td> <td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr> </table> <h4 id="Overload_resolution"> Overload resolution</h4> <p>Template argument deduction is used during <a href="overload_resolution" title="cpp/language/overload resolution">overload resolution</a>, when generating specializations from a candidate template function. <code>P</code> and <code>A</code> are the same as in a regular function call:</p>
<div class="cpp source-cpp"><pre data-language="cpp">std::string s;
std::getline(std::cin, s);
 
// "std::getline" names 4 function templates, 
// 2 of which are candidate functions (correct number of parameters)
 
// 1st candidate template:
// P1 = std::basic_istream&lt;CharT, Traits&gt;&amp;, A1 = std::cin
// P2 = std::basic_string&lt;CharT, Traits, Allocator&gt;&amp;, A2 = s
// deduction determines the type template parameters CharT, Traits, and Allocator
// specialization std::getline&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt;&gt;
 
// 2nd candidate template:
// P1 = std::basic_istream&lt;CharT, Traits&gt;&amp;&amp;, A1 = std::cin
// P2 = std::basic_string&lt;CharT, Traits, Allocator&gt;&amp;, A2 = s
// deduction determines the type template parameters CharT, Traits, and Allocator
// specialization std::getline&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt;&gt;
 
// overload resolution ranks reference binding from lvalue std::cin
// and picks the first of the two candidate specializations</pre></div> <p>If deduction fails, or if deduction succeeds, but the specialization it produces would be invalid (for example, an overloaded operator whose parameters are neither class nor enumeration types), the specialization is not included in the overload set, similar to <a href="sfinae" title="cpp/language/sfinae">SFINAE</a>.</p>
<h4 id="Address_of_an_overload_set"> Address of an overload set</h4> <p>Template argument deduction is used when taking an <a href="overloaded_address" title="cpp/language/overloaded address">address of an overload set</a>, which includes function templates.</p>
<p>The function type of the function template is <code>P</code>. The <a href="overloaded_address" title="cpp/language/overloaded address">target type</a> is the type of <code>A</code>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">std::cout &lt;&lt; std::endl;
 
// std::endl names a function template
// type of endl P =
// std::basic_ostream&lt;CharT, Traits&gt;&amp; (std::basic_ostream&lt;CharT, Traits&gt;&amp;)
// operator&lt;&lt; parameter A =
// std::basic_ostream&lt;char, std::char_traits&lt;char&gt;&gt;&amp; (*)(
//   std::basic_ostream&lt;char, std::char_traits&lt;char&gt;&gt;&amp;
// )
// (other overloads of operator&lt;&lt; are not viable) 
// deduction determines the type template parameters CharT and Traits</pre></div> <p>An additional rule is applied to the deduction in this case: when comparing function parameters <code>P</code>i and <code>A</code>i, if any <code>P</code>i is an rvalue reference to cv-unqualified template parameter (a "forwarding reference") and the corresponding <code>A</code>i is an lvalue reference, then <code>P</code>i is adjusted to the template parameter type (T&amp;&amp; becomes T).</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx14">
<td> <p>If the return type of the function template is a placeholder (<code>auto</code> or <code>decltype(auto)</code>), that return type is a non-deduced context and is determined from the instantiation.</p>
</td> <td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr> </table> <h4 id="Partial_ordering"> Partial ordering</h4> <p>Template argument deduction is used during <a href="function_template" title="cpp/language/function template">partial ordering of overloaded function templates</a>.</p>
<h4 id="Conversion_function_template"> Conversion function template</h4> <p>Template argument deduction is used when selecting <a href="cast_operator" title="cpp/language/cast operator">user-defined conversion function</a> template arguments.</p>
<p><code>A</code> is the type that is required as the result of the conversion. <code>P</code> is the return type of the conversion function template. If <code>P</code> is a reference type, then the referred type is used in place of <code>P</code> for the following parts of the section.</p>
<p>If <code>A</code> is not a reference type:</p>
<div class="t-li1">
<span class="t-li">a)</span> if the <code>P</code> is an array type, then the pointer type obtained by array-to-pointer conversion is used in place of <code>P</code>;</div> <div class="t-li1">
<span class="t-li">b)</span> if the <code>P</code> is a function type, then the function pointer type obtained by function-to-pointer conversion is used in place of <code>P</code>;</div> <div class="t-li1">
<span class="t-li">c)</span> if <code>P</code> is cv-qualified, the top-level cv-qualifiers are ignored.</div> <p>If <code>A</code> is cv-qualified, the top-level cv-qualifiers are ignored. If <code>A</code> is a reference type, the referred type is used by deduction.</p>
<p>If the usual deduction from <code>P</code> and <code>A</code> (as described above) fails, the following alternatives are additionally considered:</p>
<div class="t-li1">
<span class="t-li">a)</span> if <code>A</code> is a reference type, <code>A</code> can be more cv-qualified than the deduced <code>A</code>;</div> <div class="t-li1">
<span class="t-li">b)</span> if <code>A</code> is a pointer or pointer to member type, the deduced <code>A</code> is allowed to be any pointer that can be converted to <code>A</code> by qualification conversion: <div class="cpp source-cpp"><pre data-language="cpp">struct C
{
    template&lt;class T&gt;
    operator T***();
};
C c;
 
const int* const* const* p1 = c;
 
// P = T***, A = const int* const* const*
// regular function-call deduction for 
// template&lt;class T&gt; void f(T*** p) as if called with the argument
// of type const int* const* const* fails
// additional deduction for conversion functions determines T = int 
// (deduced A is int***, convertible to const int* const* const*)</pre></div>
</div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <span class="t-li">c)</span> if <code>A</code> is a function pointer type, the deduced <code>A</code> is allowed to be pointer to noexcept function, convertible to <code>A</code> by function pointer conversion; <span class="t-li">d)</span> if <code>A</code> is a pointer to member function, the deduced <code>A</code> is allowed to be a pointer to noexcept member function, convertible to <code>A</code> by function pointer conversion. </td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <p>See <a href="member_template#Conversion_function_templates" title="cpp/language/member template">member template</a> for other rules regarding conversion function templates.</p>
<h4 id="Explicit_instantiation"> Explicit instantiation</h4> <p>Template argument deduction is used in <a href="function_template#Explicit_instantiation" title="cpp/language/function template">explicit instantiations</a>, <a href="template_specialization" title="cpp/language/template specialization">explicit specializations</a>, and those <a href="friend#Template_friends" title="cpp/language/friend">friend declarations</a> where the declarator-id happens to refer to a specialization of a function template (for example, <code>friend ostream&amp; operator&lt;&lt; &lt;&gt; (...)</code>), if not all template arguments are explicitly specified or defaulted, template argument deduction is used to determine which template's specialization is referred to.</p>
<p><code>P</code> is the type of the function template that is being considered as a potential match, and <code>A</code> is the function type from the declaration. If there are no matches or more than one match (after partial ordering), the function declaration is ill-formed:</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;class X&gt;
void f(X a);        // 1st template f
template&lt;class X&gt;
void f(X* a);       // 2nd template f
template&lt;&gt;
void f&lt;&gt;(int* a) {} // explicit specialization of f
 
// P1 = void(X), A1 = void(int*): deduced X = int*, f&lt;int*&gt;(int*)
// P2 = void(X*), A2 = void(int*): deduced X = int, f&lt;int&gt;(int*)
// f&lt;int*&gt;(int*) and f&lt;int&gt;(int*) are then submitted to partial ordering
// which selects f&lt;int&gt;(int*) as the more specialized template</pre></div> <p>An additional rule is applied to the deduction in this case: when comparing function parameters <code>P</code>i and <code>A</code>i, if any <code>P</code>i is an rvalue reference to cv-unqualified template parameter (a "forwarding reference") and the corresponding <code>A</code>i is an lvalue reference, then <code>P</code>i is adjusted to the template parameter type (T&amp;&amp; becomes T).</p>
<h4 id="Deallocation_function_template"> Deallocation function template</h4> <p>Template argument deduction is used when determining if a <a href="../memory/new/operator_delete" title="cpp/memory/new/operator delete">deallocation function</a> template specialization matches a given placement form of <code>operator new</code>.</p>
<p><code>P</code> is the type of the function template that is being considered as a potential match, and <code>A</code> is the function type of the deallocation function that would be the match for the placement operator new under consideration. If there is no match or more than one match (after overload resolution), the placement deallocation function is not called (memory leak may occur):</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct X
{
    X() { throw std::runtime_error(""); }
 
    static void* operator new(std::size_t sz, bool b)   { return ::operator new(sz); }
    static void* operator new(std::size_t sz, double f) { return ::operator new(sz); }
 
    template&lt;typename T&gt;
    static void operator delete(void* ptr, T arg)
    {
        ::operator delete(ptr);
    }
};
 
int main()
{
    try
    {
        X* p1 = new (true) X; // when X() throws, operator delete is looked up
                              // P1 = void(void*, T), A1 = void(void*, bool):
                              // deduced T = bool
                              // P2 = void(void*, T), A2 = void(void*, double):
                              // deduced T = double
                              // overload resolution picks operator delete&lt;bool&gt;
    }
    catch(const std::exception&amp;) {}
 
    try
    {
        X* p1 = new (13.2) X; // same lookup, picks operator delete&lt;double&gt;
    }
    catch(const std::exception&amp;) {}
}</pre></div> <h3 id="Alias_templates"> Alias templates</h3> <p><a href="type_alias" title="cpp/language/type alias">Alias templates</a> are not deduced <span class="t-rev-inl t-since-cxx20"><span>, except in <a href="class_template_argument_deduction#Deduction_for_alias_templates" title="cpp/language/class template argument deduction">class template argument deduction</a></span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;class T&gt;
struct Alloc {};
 
template&lt;class T&gt;
using Vec = vector&lt;T, Alloc&lt;T&gt;&gt;;
Vec&lt;int&gt; v;
 
template&lt;template&lt;class, class&gt; class TT&gt;
void g(TT&lt;int, Alloc&lt;int&gt;&gt;);
g(v); // OK: deduced TT = vector
 
template&lt;template&lt;class&gt; class TT&gt;
void f(TT&lt;int&gt;);
f(v); // error: TT cannot be deduced as "Vec" because Vec is an alias template</pre></div> <h3 id="Implicit_conversions"> Implicit conversions</h3> <p>Type deduction does not consider implicit conversions (other than type adjustments listed above): that's the job for <a href="overload_resolution" title="cpp/language/overload resolution">overload resolution</a>, which happens later. However, if deduction succeeds for all parameters that participate in template argument deduction, and all template arguments that aren't deduced are explicitly specified or defaulted, then the remaining function parameters are compared with the corresponding function arguments. For each remaining parameter <code>P</code> with a type that was non-dependent before substitution of any explicitly-specified template arguments, if the corresponding argument <code>A</code> cannot be implicitly converted to <code>P</code>, deduction fails.</p>
<p>Parameters with dependent types in which no template-parameters participate in template argument deduction, and parameters that became non-dependent due to substitution of explicitly-specified template arguments will be checked during overload resolution:</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;class T&gt;
struct Z { typedef typename T::x xx; };
 
template&lt;class T&gt;
typename Z&lt;T&gt;::xx f(void*, T); // #1
 
template&lt;class T&gt;
void f(int, T);                // #2
 
struct A {} a;
 
int main()
{
    f(1, a); // for #1, deduction determines T = struct A, but the remaining argument 1
             // cannot be implicitly converted to its parameter void*: deduction fails
             // instantiation of the return type is not requested
             // for #2, deduction determines T = struct A, and the remaining argument 1
             // can be implicitly converted to its parameter int: deduction succeeds
             // the function call compiles as a call to #2 (deduction failure is SFINAE)
}</pre></div> <h3 id="Defect_reports"> Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th> DR </th> <th> Applied to </th> <th> Behavior as published </th> <th> Correct behavior </th>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/70.html">CWG 70</a> </td> <td> C++98 </td> <td> whether array bounds would be deduced was not specified </td> <td> specified as non-deduced </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/300.html">CWG 300</a> </td> <td> C++98 </td> <td> deduction took place for function parameters of form<br><code>type(*)(T)/T(*)()/T(*)(T)</code>, function pointers<br>match these forms but function references do not </td> <td> change these forms to<br><code>type(T)/T()/T(T)</code> so they<br>can also cover references </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/322.html">CWG 322</a> </td> <td> C++98 </td> <td> type parameters of reference types were not<br>adjusted to use the referenced type for deduction </td> <td> adjustment added </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/976.html">CWG 976</a> </td> <td> C++98 </td> <td> in the deduction for conversion operator templates,<br><code>const T&amp;</code> return type could never match <code>T</code> result type </td> <td> rules adjusted to<br>allow such matches </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1387.html">CWG 1387</a> </td> <td> C++11 </td> <td> the expression of a decltype-specifier was not a non-deduced context </td> <td> it is </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1391.html">CWG 1391</a> </td> <td> C++98 </td> <td> effect of implicit conversions of the arguments<br>that aren't involved in deduction were not specified </td> <td> specified as described above </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1591.html">CWG 1591</a> </td> <td> C++11 </td> <td> cannot deduce array bound and element type from a <i>braced-init-list</i> </td> <td> deduction allowed </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2052.html">CWG 2052</a> </td> <td> C++98 </td> <td> deducing an operator with non-class<br>non-enum arguments was a hard error </td> <td> soft error if there<br>are other overloads </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2091.html">CWG 2091</a> </td> <td> C++98 </td> <td> deducing a reference non-type parameter did not<br>work due to type mismatch against the argument </td> <td> type mismatch avoided </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://wg21.link/N3922">N3922</a> </td> <td> C++11 </td> <td> direct-list-initialization of <code>auto</code> deduces <code><a href="../utility/initializer_list" title="cpp/utility/initializer list">std::initializer_list</a></code> </td> <td> ill-formed for more than one<br>elements, deduce element<br>type for single element </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2355.html">CWG 2355</a> </td> <td> C++17 </td> <td> value in a <code>noexcept</code> specifier of a function type was not deducible </td> <td> made deducible </td>
</tr>
</table>           <div class="_attribution">
  <p class="_attribution-p">
    © cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/language/template_argument_deduction" class="_attribution-link">https://en.cppreference.com/w/cpp/language/template_argument_deduction</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
