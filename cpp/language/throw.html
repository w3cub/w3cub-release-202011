
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Throw Expression - C++ - W3cubDocs</title>
  
  <meta name="description" content=" Signals an erroneous condition and executes an error handler. ">
  <meta name="keywords" content="throw, expression, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/language/throw.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/cpp.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _c">
				
				
<h1 id="firstHeading" class="firstHeading">throw expression</h1>            <p>Signals an erroneous condition and executes an error handler.</p>
<h3 id="Syntax">Syntax</h3> <table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <code>throw</code> <span class="t-spar">expression</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>throw</code> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <h3 id="Explanation">Explanation</h3> See <a href="try_catch" title="cpp/language/try catch"> try-catch block</a> for more information about <i>try</i> and <i>catch</i> (exception handler) blocks  <div class="t-li1">
<span class="t-li">1)</span> First, <a href="copy_initialization" title="cpp/language/copy initialization">copy-initializes</a> the <i>exception object</i> from <span class="t-spar">expression</span> (this may call the move constructor for rvalue expression, and the copy/move may be subject to <a href="copy_elision" title="cpp/language/copy elision">copy elision</a>), then transfers control to the <a href="try_catch" title="cpp/language/try catch">exception handler</a> with the matching type whose compound statement or member initializer list was most recently entered and not exited by this thread of execution. <span class="t-rev-inl t-since-cxx14"><span> Even if copy initialization selects the move constructor, copy initialization from lvalue must be well-formed, and the destructor must be accessible</span> <span><span class="t-mark-rev t-since-cxx14">(since C++14)</span></span></span>
</div> <div class="t-li1">
<span class="t-li">2)</span> Rethrows the currently handled exception. Abandons the execution of the current catch block and passes control to the next matching exception handler (but not to another catch clause after the same try block: its compound-statement is considered to have been 'exited'), reusing the existing exception object: no new objects are made. This form is only allowed when an exception is presently being handled (it calls <code><a href="../error/terminate" title="cpp/error/terminate">std::terminate</a></code> if used otherwise). The catch clause associated with a <a href="function-try-block" title="cpp/language/function-try-block">function-try-block</a> must exit via rethrowing if used on a constructor.</div> <p>See <code><a href="../error/terminate" title="cpp/error/terminate">std::terminate</a></code> and <code><a href="../error/exception/unexpected" title="cpp/error/unexpected">std::unexpected</a></code> for the handling of errors that arise during exception handling.</p>
<h3 id="The_exception_object">The exception object</h3> <p>The exception object is a temporary object in unspecified storage that is constructed by the <code>throw</code> expression.</p>
<p>The type of the <i>exception object</i> is the static type of <span class="t-spar">expression</span> with top-level <a href="cv" title="cpp/language/cv">cv-qualifiers</a> removed. Array and function types are adjusted to pointer and pointer to function types, respectively. If the type of the exception object would be an <a href="incomplete_type" title="cpp/language/incomplete type" class="mw-redirect">incomplete type</a>, an <a href="abstract_class" title="cpp/language/abstract class">abstract class</a> type, or pointer to incomplete type other than pointer to (cv-qualified) void, the throw-expression is a compile-time error. If the type of <span class="t-spar">expression</span> is a class type, its copy/move constructor and destructor must be accessible even if <a href="copy_elision" title="cpp/language/copy elision">copy elision</a> takes place.</p>
<p>Unlike other temporary objects, the exception object is considered to be an lvalue argument when initializing the catch clause parameters, so it can be caught by lvalue reference, modified, and rethrown.</p>
<p>The exception object persists until the last catch clause exits other than by rethrowing (if not by rethrowing, it is destroyed immediately after the destruction of the catch clause's parameter), or until the last <code><a href="../error/exception_ptr" title="cpp/error/exception ptr">std::exception_ptr</a></code> that references this object is destroyed (in which case the exception object is destroyed just before the destructor of <code><a href="../error/exception_ptr" title="cpp/error/exception ptr">std::exception_ptr</a></code> returns.</p>
<h3 id="Stack_unwinding">Stack unwinding</h3> <p>Once the exception object is constructed, the control flow works backwards (up the call stack) until it reaches the start of a <a href="try_catch" title="cpp/language/try catch">try block</a>, at which point the parameters of all associated <code>catch</code> blocks are compared, in order of appearance, with the type of the exception object to find a match (see <a href="try_catch" title="cpp/language/try catch">try-catch</a> for details on this process). If no match is found, the control flow continues to unwind the stack until the next <code>try</code> block, and so on. If a match is found, the control flow jumps to the matching <code>catch</code> block.</p>
<p>As the control flow moves up the call stack, destructors are invoked for all objects with <a href="storage_duration" title="cpp/language/storage duration">automatic storage duration</a> constructed, but not yet destroyed, since the corresponding try-block was entered, in reverse order of completion of their constructors. <span class="t-rev-inl t-since-cxx14"><span> If an exception is thrown from a destructor of a local variable or of a temporary used in a <a href="return" title="cpp/language/return">return</a> statement, the destructor for the object returned from the function is also invoked.</span> <span><span class="t-mark-rev t-since-cxx14">(since C++14)</span></span></span>.</p>
<p>If an exception is thrown from a constructor or (rare) from a destructor of an object (regardless of the object's storage duration), destructors are called for all fully-constructed non-static <span class="t-rev-inl t-until-cxx14"><span>non-variant </span> <span><span class="t-mark-rev t-until-cxx14">(until C++14)</span></span></span>members and base classes, in reverse order of completion of their constructors. <span class="t-rev-inl t-since-cxx14"><span> Variant members of union-like classes are only destroyed in the case of unwinding from constructor, and if the active member changed between initialization and destruction, the behavior is undefined.</span> <span><span class="t-mark-rev t-since-cxx14">(since C++14)</span></span></span>.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> If a delegating constructor exits with an exception after the non-delegating constructor successfully completed, the destructor for this object is called.</td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <p>If the exception is thrown from a constructor that is invoked by a <a href="new" title="cpp/language/new">new-expression</a>, the matching <a href="../memory/new/operator_delete" title="cpp/memory/new/operator delete">deallocation function</a> is called, if available.</p>
<p>This process is called <i>stack unwinding</i>.</p>
<p>If any function that is called directly by the stack unwinding mechanism, after initialization of the exception object and before the start of the exception handler, exits with an exception, <code><a href="../error/terminate" title="cpp/error/terminate">std::terminate</a></code> is called. Such functions include <a href="destructor" title="cpp/language/destructor">destructors</a> of objects with automatic storage duration whose scopes are exited, and the copy constructor of the exception object that is called (<a href="copy_elision" title="cpp/language/copy elision">if not elided</a>) to initialize catch-by-value arguments.</p>
<p>If an exception is thrown and not caught, including exceptions that escape the initial function of <code><a href="../thread/thread" title="cpp/thread/thread">std::thread</a></code>, the main function, and the constructor or destructor of any static or thread-local objects, then <code><a href="../error/terminate" title="cpp/error/terminate">std::terminate</a></code> is called. It is implementation-defined whether any stack unwinding takes place for uncaught exceptions.</p>
<h3 id="Notes">Notes</h3> <p>When rethrowing exceptions, the second form must be used to avoid object slicing in the (typical) case where exception objects use inheritance:</p>
<div class="cpp source-cpp"><pre data-language="cpp">try {
    std::string("abc").substr(10); // throws std::length_error
} catch(const std::exception&amp; e) {
    std::cout &lt;&lt; e.what() &lt;&lt; '\n';
//  throw e; // copy-initializes a new exception object of type std::exception
    throw;   // rethrows the exception object of type std::length_error
}</pre></div> <p>The throw-expression is classified as <a href="value_category" title="cpp/language/value category">prvalue expression</a> of type <code>void</code>. Like any other expression, it may be a sub-expression in another expression, most commonly in the <a href="operator_other#Conditional_operator" title="cpp/language/operator other">conditional operator</a>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">double f(double d)
{
    return d &gt; 1e7 ? throw std::overflow_error("too big") : d;
}
int main()  
{
    try {
        std::cout &lt;&lt; f(1e10) &lt;&lt; '\n';
    } catch (const std::overflow_error&amp; e) {
        std::cout &lt;&lt; e.what() &lt;&lt; '\n';
    }
}</pre></div> <h3 id="Keywords">Keywords</h3> <p><a href="../keyword/throw" title="cpp/keyword/throw"><code>throw</code></a>.</p>
<h3 id="Example">Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
 
struct A {
    int n;
    A(int n = 0): n(n) { std::cout &lt;&lt; "A(" &lt;&lt; n &lt;&lt; ") constructed successfully\n"; }
    ~A() { std::cout &lt;&lt; "A(" &lt;&lt; n &lt;&lt; ") destroyed\n"; }
};
 
int foo()
{
    throw std::runtime_error("error");
}
 
struct B {
    A a1, a2, a3;
    B() try : a1(1), a2(foo()), a3(3) {
        std::cout &lt;&lt; "B constructed successfully\n";
    } catch(...) {
            std::cout &lt;&lt; "B::B() exiting with exception\n";
    }
    ~B() { std::cout &lt;&lt; "B destroyed\n"; }
};
 
struct C : A, B {
    C() try {
        std::cout &lt;&lt; "C::C() completed successfully\n";
    } catch(...) {
        std::cout &lt;&lt; "C::C() exiting with exception\n";
    }
    ~C() { std::cout &lt;&lt; "C destroyed\n"; }
};
 
int main () try
{
    // creates the A base subobject
    // creates the a1 member of B
    // fails to create the a2 member of B
    // unwinding destroys the a1 member of B
    // unwinding destroys the A base subobject
    C c;
} catch (const std::exception&amp; e) {
    std::cout &lt;&lt; "main() failed to create C with: " &lt;&lt; e.what();
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">A(0) constructed successfully
A(1) constructed successfully
A(1) destroyed
B::B() exiting with exception
A(0) destroyed
C::C() exiting with exception
main() failed to create C with: error</pre></div> </div> <h3 id="Defect_reports">Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th> DR </th> <th> Applied to </th> <th> Behavior as published </th> <th> Correct behavior </th>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://wg21.link/cwg1866">CWG 1866</a> </td> <td> C++14 </td> <td> variant members were leaked on stack unwinding from constructor </td> <td> variant members destroyed </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://wg21.link/cwg1863">CWG 1863</a> </td> <td> C++14 </td> <td> copy constructor was not required for move-only exception objects when thrown, but copying allowed later </td> <td> copy constructor required </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://wg21.link/cwg2176">CWG 2176</a> </td> <td> C++14 </td> <td> throw from a local variable dtor could skip return value destructor </td> <td> function return value added to unwinding </td>
</tr>
</table> <h3 id="See_also">See also</h3> <ul>
<li> <a href="try_catch" title="cpp/language/try catch"> try-catch block</a> </li>
<li> <a href="noexcept_spec" title="cpp/language/noexcept spec"> noexcept specifier</a> </li>
<li> <a href="except_spec" title="cpp/language/except spec"> exception specifications</a> </li>
</ul>          <div class="_attribution">
  <p class="_attribution-p">
    Â© cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/language/throw" class="_attribution-link">http://en.cppreference.com/w/cpp/language/throw</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
