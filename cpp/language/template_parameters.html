
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Template Parameters and Template Arguments - C++ - W3cubDocs</title>
  
  <meta name="description" content=" Every template is parameterized by one or more template parameters, indicated in the parameter-list of the template declaration syntax&#58; ">
  <meta name="keywords" content="template, parameters, and, arguments, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/language/template_parameters.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-1810d67ab7e57be09d8247710d2feb6954566959eb82322d1fee3a0c9156f56974b78ebaa9928774f00767342bbe58b0799d91fcc336b92b319170b196f9b64b.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/cpp.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _c">
				
				
<h1 id="firstHeading" class="firstHeading">Template parameters and template arguments</h1>             <h3 id="Template_parameters"> Template parameters</h3> <p>Every <a href="templates" title="cpp/language/templates">template</a> is parameterized by one or more template parameters, indicated in the <span class="t-spar">parameter-list</span> of the template declaration syntax:</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td class="t-sdsc-nopad"> <code>template</code> <code>&lt;</code> <span class="t-spar">parameter-list</span> <code>&gt;</code> <span class="t-spar">declaration</span> </td> <td class="t-sdsc-nopad"> </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <p>Each parameter in <span class="t-spar">parameter-list</span> may be:</p>
<ul>
<li> a non-type template parameter; </li>
<li> a type template parameter; </li>
<li> a template template parameter. </li>
</ul> <h4 id="Non-type_template_parameter"> Non-type template parameter</h4> <table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">type</span> <span class="t-spar">name</span><span class="t-mark">(optional)</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">type</span> <span class="t-spar">name</span><span class="t-mark">(optional)</span> <code>=</code> <span class="t-spar">default</span> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">type</span> <code>...</code> <span class="t-spar">name</span><span class="t-mark">(optional)</span> </td> <td> (3) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">placeholder</span> <span class="t-spar">name</span> </td> <td> (4) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td>
</tr> 
</table> <div class="t-li1">
<span class="t-li">1)</span> A non-type template parameter with an optional name.</div> <div class="t-li1">
<span class="t-li">2)</span> A non-type template parameter with an optional name and a default value.</div> <div class="t-li1">
<span class="t-li">3)</span> A non-type template <a href="parameter_pack" title="cpp/language/parameter pack">parameter pack</a> with an optional name.</div> <div class="t-li1">
<span class="t-li">4)</span> A non-type template parameter with a placeholder type. <span class="t-spar">placeholder</span> may be any type that includes the placeholder <a href="auto" title="cpp/language/auto"><code>auto</code></a> (such as plain <code>auto</code>, <code>auto **</code> or <code>auto &amp;</code>)<span class="t-rev-inl t-since-cxx20"><span>, a <a href="class_template_argument_deduction" title="cpp/language/class template argument deduction">placeholder for a deduced class type</a></span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span>, or <code>decltype(auto)</code>.</div> <p>A non-type template parameter must have a <i>structural type</i>, which is one of the following types (optionally cv-qualified, the qualifiers are ignored):</p>
<ul>
<li> <a href="reference#lvalue_references" title="cpp/language/reference">lvalue reference type</a> (to object or to function); </li>
<li> an <a href="type" title="cpp/language/type">integral type</a>; </li>
<li> a <a href="pointer" title="cpp/language/pointer">pointer type</a> (to object or to function); </li>
<li> a <a href="pointer#Pointers_to_members" title="cpp/language/pointer">pointer to member type</a> (to member object or to member function); </li>
<li> an <a href="enum" title="cpp/language/enum">enumeration type</a>; </li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul><li> <code><a href="../types/nullptr_t" title="cpp/types/nullptr t">std::nullptr_t</a></code>; </li></ul> </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <ul>
<li> a <a href="type" title="cpp/language/type">floating-point type</a>; </li>
<li> a <a href="../named_req/literaltype" title="cpp/named req/LiteralType">literal class type</a> with the following properties: </li>
<ul>
<li> all base classes and non-static data members are public and non-mutable and </li>
<li> the types of all base classes and non-static data members are structural types or (possibly multi-dimensional) array thereof. </li>
</ul>
</ul>  </td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <p>Array and function types may be written in a template declaration, but they are automatically replaced by pointer to object and pointer to function as appropriate.</p>
<p>When the name of a non-type template parameter is used in an expression within the body of the class template, it is an unmodifiable <a href="value_category" title="cpp/language/value category">prvalue</a> unless its type was an lvalue reference type<span class="t-rev-inl t-since-cxx20"><span>, or unless its type is a class type</span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span>.</p>
<p>A template parameter of the form <code>class Foo</code> is not an unnamed non-type template parameter of type <code>Foo</code>, even if otherwise <code>class Foo</code> is an <a href="elaborated_type_specifier" title="cpp/language/elaborated type specifier">elaborated type specifier</a> and <code>class Foo x;</code> declares <code>x</code> to be of type <code>Foo</code>.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <p>The type of a non-type template parameter may be deduced if it includes a placeholder type (<code>auto</code><span class="t-rev-inl t-since-cxx20"><span>, a placeholder for a deduced class type</span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span>, or <code>decltype(auto)</code>). The deduction is performed as if by deducing the type of the variable <code>x</code> in the invented declaration <code>T x = template-argument;</code>, where <code>T</code> is the declared type of the template parameter. If the deduced type is not permitted for a non-type template parameter, the program is ill-formed.</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;auto n&gt;
struct B { /* ... */ };
 
B&lt;5&gt; b1;   // OK: non-type template parameter type is int
B&lt;'a'&gt; b2; // OK: non-type template parameter type is char
B&lt;2.5&gt; b3; // error (until C++20): non-type template parameter type cannot be double
 
// C++20 deduced class type placeholder, class template arguments are deduced at the call site
template&lt;std::array arr&gt;
void f();
 
f&lt;std::array&lt;double, 8&gt;{}&gt;();</pre></div> <p>For non-type template parameter packs whose type uses a placeholder type, the type is independently deduced for each template argument and need not match:</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;auto...&gt;
struct C {};
 
C&lt;'C', 0, 2L, nullptr&gt; x; // OK</pre></div> </td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>An <a href="identifiers" title="cpp/language/identifiers">identifier</a> that names a non-type template parameter of class type <code>T</code> denotes a static storage duration object of type <code>const T</code>, called a <i>template parameter object</i>, whose value is that of the corresponding template argument after it has been converted to the type of the template parameter. All such template parameters in the program of the same type with the same value denote the same template parameter object. A template parameter object shall have <a href="constexpr#Constant_destruction" title="cpp/language/constexpr">constant destruction</a>.</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct A
{
    friend bool operator==(const A&amp;, const A&amp;) = default;
};
 
template&lt;A a&gt;
void f()
{
    &amp;a;                       // OK
    const A&amp; ra = a, &amp;rb = a; // Both bound to the same template parameter object
    assert(&amp;ra == &amp;rb);       // passes
}</pre></div> </td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <h4 id="Type_template_parameter"> Type template parameter</h4> <table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">type-parameter-key</span> <span class="t-spar">name</span><span class="t-mark">(optional)</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">type-parameter-key</span> <span class="t-spar">name</span><span class="t-mark">(optional)</span> <code>=</code> <span class="t-spar">default</span> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">type-parameter-key</span> <code>...</code> <span class="t-spar">name</span><span class="t-mark">(optional)</span> </td> <td> (3) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">type-constraint</span> <span class="t-spar">name</span><span class="t-mark">(optional)</span> </td> <td> (4) </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">type-constraint</span> <span class="t-spar">name</span><span class="t-mark">(optional)</span> <code>=</code> <span class="t-spar">default</span> </td> <td> (5) </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">type-constraint</span> <code>...</code> <span class="t-spar">name</span><span class="t-mark">(optional)</span> </td> <td> (6) </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td>
</tr> 
</table> <table class="t-par-begin"> <tr class="t-par"> <td> <span class="t-spar">type-parameter-key</span> </td> <td> - </td> <td> either <code>typename</code> or <code>class</code>. There is no difference between these keywords in a type template parameter declaration </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">type-constraint</span> </td> <td> - </td> <td> either the name of a <a href="constraints" title="cpp/language/constraints">concept</a> or the name of a concept followed by a list of template arguments (in angle brackets). Either way, the concept name may be optionally qualified </td>
</tr>
</table> <div class="t-li1">
<span class="t-li">1)</span> A type template parameter without a default. <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class T&gt;
class My_vector { /* ... */ };</pre></div>
</div> <div class="t-li1">
<span class="t-li">2)</span> A type template parameter with a default. <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class T = void&gt;
struct My_op_functor { /* ... */ };</pre></div>
</div> <div class="t-li1">
<span class="t-li">3)</span> A type template <a href="parameter_pack" title="cpp/language/parameter pack">parameter pack</a>. <div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename... Ts&gt;
class My_tuple { /* ... */ };</pre></div>
</div> <div class="t-li1">
<span class="t-li">4)</span> A constrained type template parameter without a default. <div class="cpp source-cpp"><pre data-language="cpp">template&lt;My_concept T&gt;
class My_constrained_vector { /* ... */ };</pre></div>
</div> <div class="t-li1">
<span class="t-li">5)</span> A constrained type template parameter with a default. <div class="cpp source-cpp"><pre data-language="cpp">template&lt;My_concept T = void&gt;
class My_constrained_op_functor { /* ... */ };</pre></div>
</div> <div class="t-li1">
<span class="t-li">6)</span> A constrained type template <a href="parameter_pack" title="cpp/language/parameter pack">parameter pack</a>. <div class="cpp source-cpp"><pre data-language="cpp">template&lt;My_concept... Ts&gt;
class My_constrained_tuple { /* ... */ };</pre></div>
</div> <p>The name of the parameter is optional:</p>
<div class="cpp source-cpp"><pre data-language="cpp">// Declarations of the templates shown above:
template&lt;class&gt;
class My_vector;
template&lt;class = void&gt;
struct My_op_functor;
template&lt;typename...&gt;
class My_tuple;</pre></div> <p>In the body of the template declaration, the name of a type parameter is a typedef-name which aliases the type supplied when the template is instantiated.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p> Each constrained parameter <code>P</code> whose <span class="t-spar">type-constraint</span> is Q designating the concept <code>C</code> introduces a <a href="constraints" title="cpp/language/constraints">constraint-expression</a> <code>E</code> according to the following rules:</p>
<ul>
<li> if <code>Q</code> is <code>C</code> (without an argument list), </li>
<ul>
<li> if <code>P</code> is not a parameter pack, <code>E</code> is simply <code>C&lt;P&gt;</code> </li>
<li> otherwise, <code>P</code> is a parameter pack, <code>E</code> is a fold-expression <code>(C&lt;P&gt; &amp;&amp; ...)</code> </li>
</ul>
<li> if <code>Q</code> is <code>C&lt;A1,A2...,AN&gt;</code>, then <code>E</code> is <code>C&lt;P,A1,A2,...AN&gt;</code> or <code>(C&lt;P,A1,A2,...AN&gt; &amp;&amp; ...)</code>, respectively. </li>
</ul>   <div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename T&gt;
concept C1 = true;
template&lt;typename... Ts&gt; // variadic concept
concept C2 = true;
template&lt;typename T, typename U&gt;
concept C3 = true;
 
template&lt;C1 T&gt;         struct s1; // constraint-expression is C1&lt;T&gt;
template&lt;C1... T&gt;      struct s2; // constraint-expression is (C1&lt;T&gt; &amp;&amp; ...)
template&lt;C2... T&gt;      struct s3; // constraint-expression is (C2&lt;T&gt; &amp;&amp; ...)
template&lt;C3&lt;int&gt; T&gt;    struct s4; // constraint-expression is C3&lt;T, int&gt;
template&lt;C3&lt;int&gt;... T&gt; struct s5; // constraint-expression is (C3&lt;T, int&gt; &amp;&amp; ...)</pre></div> </td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <h4 id="Template_template_parameter"> Template template parameter</h4> <table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <code>template</code> <code>&lt;</code> <span class="t-spar">parameter-list</span> <code>&gt;</code> <span class="t-spar">type-parameter-key</span> <span class="t-spar">name</span><span class="t-mark">(optional)</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>template</code> <code>&lt;</code> <span class="t-spar">parameter-list</span> <code>&gt;</code> <span class="t-spar">type-parameter-key</span> <span class="t-spar">name</span><span class="t-mark">(optional)</span> <code>=</code> <span class="t-spar">default</span> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>template</code> <code>&lt;</code> <span class="t-spar">parameter-list</span> <code>&gt;</code> <span class="t-spar">type-parameter-key</span> <code>...</code> <span class="t-spar">name</span><span class="t-mark">(optional)</span> </td> <td> (3) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr> 
</table> <table class="t-par-begin"> <tr class="t-par"> <td> <span class="t-spar">type-parameter-key</span> </td> <td> - </td> <td> <code>class</code> <span class="t-rev-inl t-since-cxx17"><span>or <code>typename</code></span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> </td>
</tr>
</table> <div class="t-li1">
<span class="t-li">1)</span> A template template parameter with an optional name.</div> <div class="t-li1">
<span class="t-li">2)</span> A template template parameter with an optional name and a default.</div> <div class="t-li1">
<span class="t-li">3)</span> A template template <a href="parameter_pack" title="cpp/language/parameter pack">parameter pack</a> with an optional name.</div> <p>In the body of the template declaration, the name of this parameter is a template-name (and needs arguments to be instantiated).</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename T&gt;
class my_array {};
 
// two type template parameters and one template template parameter:
template&lt;typename K, typename V, template&lt;typename&gt; typename C = my_array&gt;
class Map
{
    C&lt;K&gt; key;
    C&lt;V&gt; value;
};</pre></div> <h4 id="Name_resolution_for_template_parameters"> Name resolution for template parameters</h4> <p>The name of a template parameter is not allowed to be redeclared within its scope (including nested scopes). A template parameter is not allowed to have the same name as the template name.</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;class T, int N&gt;
class Y
{
    int T;      // error: template parameter redeclared
    void f()
    {
        char T; // error: template parameter redeclared
    }
};
 
template&lt;class X&gt;
class X; // error: template parameter redeclared</pre></div> <p>In the definition of a member of a class template that appears outside of the class template definition, the name of a member of the class template hides the name of a template parameter of any enclosing class templates, but not a template parameter of the member if the member is a class or function template.</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;class T&gt;
struct A
{
    struct B {};
    typedef void C;
    void f();
 
    template&lt;class U&gt;
    void g(U);
};
 
template&lt;class B&gt;
void A&lt;B&gt;::f()
{
    B b; // A's B, not the template parameter
}
 
template&lt;class B&gt;
template&lt;class C&gt;
void A&lt;B&gt;::g(C)
{
    B b; // A's B, not the template parameter
    C c; // the template parameter C, not A's C
}</pre></div> <p>In the definition of a member of a class template that appears outside of the namespace containing the class template definition, the name of a template parameter hides the name of a member of this namespace.</p>
<div class="cpp source-cpp"><pre data-language="cpp">namespace N
{
    class C {};
 
    template&lt;class T&gt;
    class B
    {
        void f(T);
    };
}
 
template&lt;class C&gt;
void N::B&lt;C&gt;::f(C)
{
    C b; // C is the template parameter, not N::C
}</pre></div> <p>In the definition of a class template or in the definition of a member of such a template that appears outside of the template definition, for each non-<a href="dependent_name#Dependent_types" title="cpp/language/dependent name">dependent</a> base class, if the name of the base class or the name of a member of the base class is the same as the name of a template parameter, the base class name or member name hides the template parameter name.</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct A
{
    struct B {};
    int C;
    int Y;
};
 
template&lt;class B, class C&gt;
struct X : A
{
    B b; // A's B
    C b; // error: A's C isn't a type name
};</pre></div> <h3 id="Template_arguments"> Template arguments</h3> <p>In order for a template to be instantiated, every template parameter (type, non-type, or template) must be replaced by a corresponding template argument. For <a href="class_template" title="cpp/language/class template">class templates</a>, the arguments are either explicitly provided<span class="t-rev-inl t-since-cxx17"><span>, <a href="class_template_argument_deduction" title="cpp/language/class template argument deduction">deduced from the initializer</a>, </span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> or defaulted. For <a href="function_template" title="cpp/language/function template">function templates</a>, the arguments are explicitly provided, <a href="template_argument_deduction" title="cpp/language/template argument deduction">deduced from the context</a>, or defaulted.</p>
<p>If an argument can be interpreted as both a <a href="type-id" title="cpp/language/type-id" class="mw-redirect">type-id</a> and an expression, it is always interpreted as a type-id, even if the corresponding template parameter is non-type:</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;class T&gt;
void f(); // #1
 
template&lt;int I&gt;
void f(); // #2
 
void g()
{
    f&lt;int()&gt;(); // "int()" is both a type and an expression,
                // calls #1 because it is interpreted as a type
}</pre></div> <h4 id="Template_non-type_arguments"> Template non-type arguments</h4> <p>The following limitations apply when instantiating templates that have non-type template parameters:</p>
<table class="t-rev-begin"> <tr class="t-rev t-until-cxx17">
<td> <ul>
<li> For integral and arithmetic types, the template argument provided during instantiation must be a <a href="constant_expression" title="cpp/language/constant expression">converted constant expression</a> of the template parameter's type (so certain implicit conversion applies). </li>
<li> For pointers to objects, the template arguments have to designate the address of a complete object with static <a href="storage_duration" title="cpp/language/storage duration">storage duration</a> and a <a href="storage_duration#Linkage" title="cpp/language/storage duration">linkage</a> (either internal or external), or a constant expression that evaluates to the appropriate null pointer<span class="t-rev-inl t-since-cxx11"><span> or <code><a href="../types/nullptr_t" title="cpp/types/nullptr t">std::nullptr_t</a></code></span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span> value. </li>
<li> For pointers to functions, the valid arguments are pointers to functions with linkage (or constant expressions that evaluate to null pointer values). </li>
<li> For lvalue reference parameters, the argument provided at instantiation cannot be a temporary, an unnamed lvalue, or a named lvalue with no linkage (in other words, the argument must have linkage). </li>
<li> For pointers to members, the argument has to be a pointer to member expressed as <code>&amp;Class::Member</code> or a constant expression that evaluates to null pointer<span class="t-rev-inl t-since-cxx11"><span> or <code><a href="../types/nullptr_t" title="cpp/types/nullptr t">std::nullptr_t</a></code></span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span> value. </li>
</ul> <p>In particular, this implies that string literals, addresses of array elements, and addresses of non-static members cannot be used as template arguments to instantiate templates whose corresponding non-type template parameters are pointers to objects.</p>
</td> <td><span class="t-mark-rev t-until-cxx17">(until C++17)</span></td>
</tr> <tr class="t-rev t-since-cxx17">
<td> <p>The template argument that can be used with a non-type template parameter can be any <a href="constant_expression" title="cpp/language/constant expression">converted constant expression</a> of the type of the template parameter.</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;const int* pci&gt;
struct X {};
 
int ai[10];
X&lt;ai&gt; xi; // OK: array to pointer conversion and cv-qualification conversion
 
struct Y {};
 
template&lt;const Y&amp; b&gt;
struct Z {};
 
Y y;
Z&lt;y&gt; z;   // OK: no conversion
 
template&lt;int (&amp;pa)[5]&gt;
struct W {};
 
int b[5];
W&lt;b&gt; w;   // OK: no conversion
 
void f(char);
void f(int);
 
template&lt;void (*pf)(int)&gt;
struct A {};
 
A&lt;&amp;f&gt; a;  // OK: overload resolution selects f(int)</pre></div> <p>The only exceptions are that non-type template parameters of <i>reference</i> or <i>pointer</i> type <span class="t-rev-inl t-since-cxx20"><span>and non-static data members of reference or pointer type in a non-type template parameter of class type and its subobjects</span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span> cannot refer to/be the address of.</p>
<ul>
<li> a temporary object (including one created during <a href="reference_initialization" title="cpp/language/reference initialization">reference initialization</a>); </li>
<li> a <a href="string_literal" title="cpp/language/string literal">string literal</a>; </li>
<li> the result of <a href="typeid" title="cpp/language/typeid"><code>typeid</code></a>; </li>
<li> the predefined variable <code>__func__</code>; </li>
<li> or a subobject (including non-static class member, base subobject, or array element)<span class="t-rev-inl t-since-cxx20"><span> of one of the above</span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span>. </li>
</ul> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class T, const char* p&gt;
class X {};
 
X&lt;int, "Studebaker"&gt; x1; // error: string literal as template-argument
 
template&lt;int* p&gt;
class X {};
 
int a[10];
 
struct S
{
    int m;
    static int s;
} s;
 
X&lt;&amp;a[2]&gt; x3; // error (until C++20): address of array element
X&lt;&amp;s.m&gt; x4;  // error (until C++20): address of non-static member
X&lt;&amp;s.s&gt; x5;  // OK: address of static member
X&lt;&amp;S::s&gt; x6; // OK: address of static member
 
template&lt;const int&amp; CRI&gt;
struct B {};
 
B&lt;1&gt; b2;     // error: temporary would be required for template argument
int c = 1;
B&lt;c&gt; b1;     // OK</pre></div> </td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <h4 id="Template_type_arguments"> Template type arguments</h4> <p>A template argument for a type template parameter must be a <a href="type#Type_naming" title="cpp/language/type">type-id</a>, which may name an incomplete type:</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename T&gt;
class X {}; // class template
 
struct A;            // incomplete type
typedef struct {} B; // type alias to an unnamed type
 
int main()
{
    X&lt;A&gt; x1;  // OK: 'A' names a type
    X&lt;A*&gt; x2; // OK: 'A*' names a type
    X&lt;B&gt; x3;  // OK: 'B' names a type
}</pre></div> <h4 id="Template_template_arguments"> Template template arguments</h4> <p>A template argument for a template template parameter must be an <a href="identifiers#In_expressions" title="cpp/language/identifiers">id-expression</a> which names a class template or a template alias.</p>
<p>When the argument is a class template, only the primary template is considered when matching the parameter. The partial specializations, if any, are only considered when a specialization based on this template template parameter happens to be instantiated.</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename T&gt; // primary template
class A { int x; };
 
template&lt;typename T&gt; // partial specialization
class A&lt;T*&gt; { long x; };
 
// class template with a template template parameter V
template&lt;template&lt;typename&gt; class V&gt;
class C
{
    V&lt;int&gt; y;  // uses the primary template
    V&lt;int*&gt; z; // uses the partial specialization
};
 
C&lt;A&gt; c; // c.y.x has type int, c.z.x has type long</pre></div> <p>To match a template template argument <code>A</code> to a template template parameter <code>P</code>, <code>P</code> must be <i>at least as specialized</i> as <code>A</code> (see below).<span class="t-rev-inl t-since-cxx11"><span> If <code>P</code>'s parameter list includes a <a href="parameter_pack" title="cpp/language/parameter pack">parameter pack</a>, zero or more template parameters (or parameter packs) from <code>A</code>'s template parameter list are matched by it.</span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>.</p>
<p>Formally, a template template-parameter <code>P</code> is <i>at least as specialized</i> as a template template argument <code>A</code> if, given the following rewrite to two function templates, the function template corresponding to <code>P</code> is at least as specialized as the function template corresponding to <code>A</code> according to the partial ordering rules for <a href="function_template" title="cpp/language/function template">function templates</a>. Given an invented class template <code>X</code> with the template parameter list of <code>A</code> (including default arguments):</p>
<ul>
<li> Each of the two function templates has the same template parameters, respectively, as <code>P</code> or <code>A</code>. </li>
<li> Each function template has a single function parameter whose type is a specialization of <code>X</code> with template arguments corresponding to the template parameters from the respective function template where, for each template parameter <code>PP</code> in the template parameter list of the function template, a corresponding template argument <code>AA</code> is formed.<span class="t-rev-inl t-since-cxx11"><span> If <code>PP</code> declares a parameter pack, then <code>AA</code> is the pack expansion <code>PP...</code>; otherwise,</span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span> <code>AA</code> is the id-expression <code>PP</code>. </li>
</ul> <p>If the rewrite produces an invalid type, then <code>P</code> is not at least as specialized as <code>A</code>.</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename T&gt;
struct eval;                     // primary template
 
template&lt;template&lt;typename, typename...&gt; class TT, typename T1, typename... Rest&gt;
struct eval&lt;TT&lt;T1, Rest...&gt;&gt; {}; // partial specialization of eval
 
template&lt;typename T1&gt; struct A;
template&lt;typename T1, typename T2&gt; struct B;
template&lt;int N&gt; struct C;
template&lt;typename T1, int N&gt; struct D;
template&lt;typename T1, typename T2, int N = 17&gt; struct E;
 
eval&lt;A&lt;int&gt;&gt; eA;        // OK: matches partial specialization of eval
eval&lt;B&lt;int, float&gt;&gt; eB; // OK: matches partial specialization of eval
eval&lt;C&lt;17&gt;&gt; eC;         // error: C does not match TT in partial specialization
                        // because TT's first parameter is a
                        // type template parameter, while 17 does not name a type
eval&lt;D&lt;int, 17&gt;&gt; eD;    // error: D does not match TT in partial specialization
                        // because TT's second parameter is a
                        // type parameter pack, while 17 does not name a type
eval&lt;E&lt;int, float&gt;&gt; eE; // error: E does not match TT in partial specialization
                        // because E's third (default) parameter is a non-type</pre></div> <p>Before the adoption of <a rel="nofollow" class="external text" href="https://wg21.link/p0522r0">P0522R0</a>, each of the template parameters of <code>A</code> must match corresponding template parameters of <code>P</code> exactly. This hinders many reasonable template argument from being accepted.</p>
<p>Although it was pointed out very early (<a rel="nofollow" class="external text" href="https://wg21.cmeerw.net/cwg/issue150">CWG#150</a>), by the time it was resolved, the changes were applied to the C++17 working paper and the resolution became a de facto C++17 feature. Many compilers disable it by default:</p>
<ul>
<li> <a rel="nofollow" class="external text" href="https://gcc.gnu.org/gcc-7/changes.html#cxx">GCC</a> disables it in all language modes prior to C++17 by default, it can only be enabled by setting a compiler flag in these modes. </li>
<li> <a rel="nofollow" class="external text" href="https://clang.llvm.org/cxx_status.html#p0522">Clang</a> disables it in all language modes by default, it can only be enabled by setting a compiler flag. </li>
<li> <a rel="nofollow" class="external text" href="https://docs.microsoft.com/en-us/cpp/overview/visual-cpp-language-conformance">Microsoft Visual Studio</a> treats it as a normal C++17 feature and only enables it in C++17 and later language modes (i.e. no support in C++14 language mode, which is the default mode). </li>
</ul> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class T&gt; class A { /* ... */ };
template&lt;class T, class U = T&gt; class B { /* ... */ };
template&lt;class... Types&gt; class C { /* ... */ };
 
template&lt;template&lt;class&gt; class P&gt; class X { /* ... */ };
X&lt;A&gt; xa; // OK
X&lt;B&gt; xb; // OK after P0522R0
         // Error earlier: not an exact match
X&lt;C&gt; xc; // OK after P0522R0
         // Error earlier: not an exact match
 
template&lt;template&lt;class...&gt; class Q&gt; class Y { /* ... */ };
Y&lt;A&gt; ya; // OK
Y&lt;B&gt; yb; // OK
Y&lt;C&gt; yc; // OK
 
template&lt;auto n&gt; class D { /* ... */ };   // note: C++17
template&lt;template&lt;int&gt; class R&gt; class Z { /* ... */ };
Z&lt;D&gt; zd; // OK after P0522R0: the template parameter
         // is more specialized than the template argument
 
template&lt;int&gt; struct SI { /* ... */ };
template&lt;template&lt;auto&gt; class&gt; void FA(); // note: C++17
FA&lt;SI&gt;(); // Error</pre></div> <h4 id="Default_template_arguments"> Default template arguments</h4> <p>Default template arguments are specified in the parameter lists after the <code>=</code> sign. Defaults can be specified for any kind of template parameter (type, non-type, or template)<span class="t-rev-inl t-since-cxx11"><span>, but not to parameter packs</span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>.</p>
<p>If the default is specified for a template parameter of a primary class template<span class="t-rev-inl t-since-cxx14"><span>, primary variable template,</span> <span><span class="t-mark-rev t-since-cxx14">(since C++14)</span></span></span> or alias template, each subsequent template parameter must have a default argument<span class="t-rev-inl t-since-cxx11"><span>, except the very last one may be a template parameter pack</span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>. In a function template, there are no restrictions on the parameters that follow a default<span class="t-rev-inl t-since-cxx11"><span>, and a parameter pack may be followed by more type parameters only if they have defaults or can be deduced from the function arguments</span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>.</p>
<p>Default parameters are not allowed.</p>
<ul>
<li> in the out-of-class definition of a member of a <a href="class_template" title="cpp/language/class template">class template</a> (they have to be provided in the declaration inside the class body). Note that <a href="member_template" title="cpp/language/member template">member templates</a> of non-template classes can use default parameters in their out-of-class definitions (see <a rel="nofollow" class="external text" href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=53856">GCC bug 53856</a>) </li>
<li> in <a href="friend#Template_friends" title="cpp/language/friend">friend class template</a> declarations </li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx11">
<td> <ul><li> in any <a href="function_template" title="cpp/language/function template">function template</a> declaration or definition </li></ul> </td> <td><span class="t-mark-rev t-until-cxx11">(until C++11)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>On a friend function template declaration, default template arguments are allowed only if the declaration is a definition, and no other declarations of this function appear in this translation unit.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <p>Default template arguments that appear in the declarations are merged similarly to default function arguments:</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename T1, typename T2 = int&gt; class A;
template&lt;typename T1 = int, typename T2&gt; class A;
 
// the above is the same as the following:
template&lt;typename T1 = int, typename T2 = int&gt; class A;</pre></div> <p>But the same parameter cannot be given default arguments twice in the same scope:</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename T = int&gt; class X;
template&lt;typename T = int&gt; class X {}; // error</pre></div> <p>When parsing a default template argument for a non-type template parameter, the first non-nested <code>&gt;</code> is taken as the end of the template parameter list rather than a greater-than operator:</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;int i = 3 &gt; 4&gt;   // syntax error
class X { /* ... */ };
 
template&lt;int i = (3 &gt; 4)&gt; // OK
class Y { /* ... */ };</pre></div> <p>The template parameter lists of template template parameters can have their own default arguments, which are only in effect where the template template parameter itself is in scope:</p>
<div class="cpp source-cpp"><pre data-language="cpp">// class template, with a type template parameter with a default
template&lt;typename T = float&gt;
struct B {};
 
// template template parameter T has a parameter list, which
// consists of one type template parameter with a default
template&lt;template&lt;typename = float&gt; typename T&gt;
struct A
{
    void f();
    void g();
};
 
// out-of-body member function template definitions
 
template&lt;template&lt;typename TT&gt; class T&gt;
void A&lt;T&gt;::f()
{
    T&lt;&gt; t; // error: TT has no default in scope
}
 
template&lt;template&lt;typename TT = char&gt; class T&gt;
void A&lt;T&gt;::g()
{
    T&lt;&gt; t; // OK: t is T&lt;char&gt;
}</pre></div> <p><a href="access" title="cpp/language/access">Member access</a> for the names used in a default template parameter is checked at the declaration, not at the point of use:</p>
<div class="cpp source-cpp"><pre data-language="cpp">class B {};
 
template&lt;typename T&gt;
class C
{
protected:
    typedef T TT;
};
 
template&lt;typename U, typename V = typename U::TT&gt;
class D: public U {};
 
D&lt;C&lt;B&gt;&gt;* d; // error: C::TT is protected</pre></div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx14">
<td> <p>The default template argument is implicitly instantiated when the value of that default argument is needed, except if the template is used to name a function:</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename T, typename U = int&gt;
struct S {};
 
S&lt;bool&gt;* p; // The default argument for U is instantiated at this point
            // the type of p is S&lt;bool, int&gt;*</pre></div> </td> <td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr> </table> <h4 id="Template_argument_equivalence"> Template argument equivalence</h4> <p>Template argument equivalence is used to determine whether two <a href="templates#template-id" title="cpp/language/templates">template-ids</a> are same.</p>
<p>Two values are <i>template-argument-equivalent</i> if they are of the same type and.</p>
<ul>
<li> they are of integral or enumeration type and their values are the same </li>
<li> or they are of pointer type and they have the same pointer value </li>
<li> or they are of pointer-to-member type and they refer to the same class member or are both the null member pointer value </li>
<li> or they are of lvalue reference type and they refer to the same object or function </li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul><li> or they are of type <code>std::nullptr_t</code> </li></ul> </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <ul>
<li> or they are of floating-point type and their values are identical </li>
<li> or they are of array type (in which case the arrays must be member objects of some class/union) and their corresponding elements are template-argument-equivalent </li>
<li> or they are of union type and either they both have no active member or they have the same active member and their active members are template-argument-equivalent </li>
<li> or they are of non-union class type and their corresponding direct subobjects and reference members are template-argument-equivalent </li>
</ul> </td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <h3 id="Examples"> Examples</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;array&gt;
#include &lt;iostream&gt;
#include &lt;numeric&gt;
 
// simple non-type template parameter
template&lt;int N&gt;
struct S { int a[N]; };
 
template&lt;const char*&gt;
struct S2 {};
 
// complicated non-type example
template
&lt;
    char c,             // integral type
    int (&amp;ra)[5],       // lvalue reference to object (of array type)
    int (*pf)(int),     // pointer to function
    int (S&lt;10&gt;::*a)[10] // pointer to member object (of type int[10])
&gt;
struct Complicated
{
    // calls the function selected at compile time
    // and stores the result in the array selected at compile time
    void foo(char base)
    {
        ra[4] = pf(c - base);
    }
};
 
//  S2&lt;"fail"&gt; s2;        // error: string literal cannot be used
    char okay[] = "okay"; // static object with linkage
//  S2&lt;&amp;okay[0]&gt; s3;      // error: array element has no linkage
    S2&lt;okay&gt; s4;          // works
 
int a[5];
int f(int n) { return n; }
 
// C++20: NTTP can be a literal class type
template&lt;std::array arr&gt;
constexpr
auto sum() { return std::accumulate(arr.cbegin(), arr.cend(), 0); }
 
// C++20: class template arguments are deduced at the call site
static_assert(sum&lt;std::array&lt;double, 8&gt;{3, 1, 4, 1, 5, 9, 2, 6}&gt;() == 31.0);
// C++20: NTTP argument deduction and CTAD
static_assert(sum&lt;std::array{2, 7, 1, 8, 2, 8}&gt;() == 28);
 
int main()
{
    S&lt;10&gt; s; // s.a is an array of 10 int
    s.a[9] = 4;
 
    Complicated&lt;'2', a, f, &amp;S&lt;10&gt;::a&gt; c;
    c.foo('0');
 
    std::cout &lt;&lt; s.a[9] &lt;&lt; a[4] &lt;&lt; '\n';
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">42</pre></div> </div>  <h3 id="Defect_reports"> Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th> DR </th> <th> Applied to </th> <th> Behavior as published </th> <th> Correct behavior </th>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/150.html">CWG 150</a> </td> <td> C++98 </td> <td> template-template arguments had to match parameter<br>lists of template-template parameters exactly </td> <td> more specialized also allowed<br>(resolved by <a rel="nofollow" class="external text" href="https://wg21.link/p0522r0">P0522R0</a>) </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/184.html">CWG 184</a> </td> <td> C++98 </td> <td> whether the template parameters of template template<br>parameters are allowed to have default arguments is unspecified </td> <td> specification added </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/354.html">CWG 354</a> </td> <td> C++98 </td> <td> null pointer values could not be non-type template arguments </td> <td> allowed </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1398.html">CWG 1398</a> </td> <td> C++11 </td> <td> template non-type arguments could not have type <code>std::nullptr_t</code> </td> <td> allowed </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1570.html">CWG 1570</a> </td> <td> C++98 </td> <td> template non-type arguments could designate addresses of subobjects </td> <td> not allowed </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1922.html">CWG 1922</a> </td> <td> C++98 </td> <td> it was unclear whether a class template whose name is an<br>injected-class-name can use the default arguments in prior declarations </td> <td> allowed </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2032.html">CWG 2032</a> </td> <td> C++14 </td> <td> for variable templates, there was no restriction on the template<br>parameters after a template parameter with a default argument </td> <td> apply the same restriction as on<br>class templates and alias templates </td>
</tr>
</table>           <div class="_attribution">
  <p class="_attribution-p">
    Â© cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/language/template_parameters" class="_attribution-link">https://en.cppreference.com/w/cpp/language/template_parameters</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
