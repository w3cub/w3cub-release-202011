
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>User-defined Literals - C++ - W3cubDocs</title>
  
  <meta name="description" content=" Allows integer, floating-point, character, and string literals to produce objects of user-defined type by defining a user-defined suffix. ">
  <meta name="keywords" content="user-defined, literals, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/language/user_literal.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-9c7b0d969c0ce639a6c01c2badcdd81667c7c66206aa3d0fccc5cb0585fb1b912dab72ea882101d18010680927514b4b77b107282db8f756fbf63301fe9c88b0.css">
  <script type="text/javascript" src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js"></script>
  <script src="/json/cpp.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _cppref">
				
				
<h1 id="firstHeading" class="firstHeading">User-defined literals <span class="t-mark-rev t-since-cxx11">(since C++11)</span>
</h1>            <p>Allows integer, floating-point, character, and string literals to produce objects of user-defined type by defining a user-defined suffix.</p>
<h3 id="Syntax"> Syntax</h3> <p>A user-defined literal is an expression of any of the following forms.</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">decimal-literal</span> <span class="t-spar">ud-suffix</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">octal-literal</span> <span class="t-spar">ud-suffix</span> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">hex-literal</span> <span class="t-spar">ud-suffix</span> </td> <td> (3) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">binary-literal</span> <span class="t-spar">ud-suffix</span> </td> <td> (4) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">fractional-constant</span> <span class="t-spar">exponent-part</span> ﻿<span class="t-mark">(optional)</span> <span class="t-spar">ud-suffix</span> </td> <td> (5) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">digit-sequence</span> <span class="t-spar">exponent-part</span> <span class="t-spar">ud-suffix</span> </td> <td> (6) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">character-literal</span> <span class="t-spar">ud-suffix</span> </td> <td> (7) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">string-literal</span> <span class="t-spar">ud-suffix</span> </td> <td> (8) </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <div class="t-li1">
<span class="t-li">1-4)</span> user-defined integer literals, such as <code>12_km</code>
</div> <div class="t-li1">
<span class="t-li">5-6)</span> user-defined floating-point literals, such as <code>0.5_Pa</code>
</div> <div class="t-li1">
<span class="t-li">7)</span> user-defined character literal, such as <code>'c'_X</code>
</div> <div class="t-li1">
<span class="t-li">8)</span> user-defined string literal, such as <code>"abd"_L</code> or <code>u"xyz"_M</code>
</div> <table class="t-par-begin"> <tr class="t-par"> <td> <span class="t-spar">decimal-literal</span> </td> <td> - </td> <td> same as in <a href="integer_literal" title="cpp/language/integer literal">integer literal</a>, a non-zero decimal digit followed by zero or more decimal digits </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">octal-literal</span> </td> <td> - </td> <td> same as in <a href="integer_literal" title="cpp/language/integer literal">integer literal</a>, a zero followed by zero or more octal digits </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">hex-literal</span> </td> <td> - </td> <td> same as in <a href="integer_literal" title="cpp/language/integer literal">integer literal</a>, <code>0x</code> or <code>0X</code> followed by one or more hexadecimal digits </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">binary-literal</span> </td> <td> - </td> <td> same as in <a href="integer_literal" title="cpp/language/integer literal">integer literal</a>, <code>0b</code> or <code>0B</code> followed by one or more binary digits </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">digit-sequence</span> </td> <td> - </td> <td> same as in <a href="floating_literal" title="cpp/language/floating literal">floating literal</a>, a sequence of decimal digits </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">fractional-constant</span> </td> <td> - </td> <td> same as in <a href="floating_literal" title="cpp/language/floating literal">floating literal</a>, either a <span class="t-spar">digit-sequence</span> followed by a dot (<code>123.</code>) or an optional <span class="t-spar">digit-sequence</span> followed by a dot and another <span class="t-spar">digit-sequence</span> (<code>1.0</code> or <code>.12</code>) </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">exponent-part</span> </td> <td> - </td> <td> same as in <a href="floating_literal" title="cpp/language/floating literal">floating literal</a>, the letter <code>e</code> or the letter <code>E</code> followed by optional sign, followed by <span class="t-spar">digit-sequence</span> </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">character-literal</span> </td> <td> - </td> <td> same as in <a href="character_literal" title="cpp/language/character literal">character literal</a> </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">string-literal</span> </td> <td> - </td> <td> same as in <a href="string_literal" title="cpp/language/string literal">string literal</a>, including raw string literals </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">ud-suffix</span> </td> <td> - </td> <td> an identifier, introduced by a <i>literal operator</i> or a <i>literal operator template</i> declaration (see <a href="#Literal_operators">below</a>) </td>
</tr>
</table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx14">
<td> <p>In the <a href="integer_literal#Single_quote" title="cpp/language/integer literal">integer</a> and <a href="floating_literal#Single_quote" title="cpp/language/floating literal">floating-point</a> digit sequences, optional separators <code>'</code> are allowed between any two digits.</p>
</td> <td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr> </table> <p>If a token matches a user-defined literal syntax and a regular literal syntax, it is assumed to be a regular literal (that is, it's impossible to overload <code>LL</code> in <code>123LL</code>).</p>
<p>When the compiler encounters a user-defined literal with <span class="t-spar">ud-suffix</span> <code>X</code>, it performs <a href="lookup#Unqualified_name_lookup" title="cpp/language/lookup">unqualified name lookup</a>, looking for a function with the name operator<span class="st0">""</span>X. If the lookup does not find a declaration, the program is ill-formed. Otherwise,</p>
<div class="t-li1">
<span class="t-li">1)</span> For user-defined integer literals,</div> <pre data-language="cpp">unsigned long long</pre> <div class="t-li2">
<span class="t-li">b)</span> otherwise, the overload set must include either, but not both, a raw literal operator or a numeric literal operator template. If the overload set includes a raw literal operator, the user-defined literal expression is treated as a function call <code>operator""X("n ﻿")</code>;</div> <div class="t-li2">
<span class="t-li">c)</span> otherwise, if the overload set includes a numeric literal operator template, the user-defined literal expression is treated as a function call <code>operator""X&lt;'c1 ﻿', 'c2 ﻿', 'c3 ﻿'..., 'ck ﻿'&gt;()</code>, where <span class="t-spar">c1</span>..<span class="t-spar">ck</span> are the individual characters of <span class="t-spar">n</span> and all of them are from the <a href="charset#Basic_character_set" title="cpp/language/charset">basic character set</a>.</div> <div class="t-li1">
<span class="t-li">2)</span> For user-defined floating-point literals,</div> <pre data-language="cpp">long double</pre> <div class="t-li2">
<span class="t-li">b)</span> otherwise, the overload set must include either, but not both, a raw literal operator or a numeric literal operator template. If the overload set includes a raw literal operator, the user-defined literal expression is treated as a function call <code>operator ""X("f ﻿ ﻿")</code>;</div> <div class="t-li2">
<span class="t-li">c)</span> otherwise, if the overload set includes a numeric literal operator template, the user-defined literal expression is treated as a function call <code>operator""X&lt;'c1 ﻿', 'c2 ﻿', 'c3 ﻿'..., 'ck ﻿'&gt;()</code>, where <span class="t-spar">c1</span>..<span class="t-spar">ck</span> are the individual characters of <span class="t-spar">f</span> and all of them are from the <a href="charset#Basic_character_set" title="cpp/language/charset">basic character set</a>.</div> <div class="t-li1">
<span class="t-li">3)</span> For user-defined string literals, let <code>str</code> be the literal without <span class="t-spar">ud-suffix</span>:</div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <span class="t-li">a)</span> If the overload set includes a string literal operator template with a non-type template parameter for which <code>str</code> is a well-formed template argument, then the user-defined literal expression is treated as a function call <code>operator ""X&lt;str&gt;()</code>; </td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <div class="t-li2">
<span class="t-li">b)</span> otherwise, the user-defined literal expression is treated as a function call <code>operator ""X (str, len)</code>, where <code>len</code> is the length of the string literal, excluding the terminating null character.</div> <div class="t-li1">
<span class="t-li">4)</span> For user-defined character literals, the user-defined literal expression is treated as a function call <code>operator ""X(ch)</code>, where <code>ch</code> is the literal without <span class="t-spar">ud-suffix</span>.</div> <div class="cpp source-cpp"><pre data-language="cpp">long double operator ""_w(long double);
std::string operator ""_w(const char16_t*, size_t);
unsigned    operator ""_w(const char*);
 
int main()
{
    1.2_w;    // calls operator ""_w(1.2L)
    u"one"_w; // calls operator ""_w(u"one", 3)
    12_w;     // calls operator ""_w("12")
    "two"_w;  // error: no applicable literal operator
}</pre></div> <p>When string literal concatenation takes place in <a href="translation_phases#Phase_6" title="cpp/language/translation phases">translation phase 6</a>, user-defined string literals are concatenated as well, and their <span class="t-spar">ud-suffix</span>es are ignored for the purpose of concatenation, except that only one suffix may appear on all concatenated literals:</p>
<div class="cpp source-cpp"><pre data-language="cpp">int main()
{
    L"A" "B" "C"_x;  // OK: same as L"ABC"_x
    "P"_x "Q" "R"_y; // error: two different ud-suffixes (_x and _y)
}</pre></div> <h3 id="Literal_operators"> Literal operators</h3> <p>The function called by a user-defined literal is known as <i>literal operator</i> (or, if it's a template, <i>literal operator template</i>). It is declared just like any other <a href="function" title="cpp/language/function">function</a> or <a href="function_template" title="cpp/language/function template">function template</a> at namespace scope (it may also be a friend function, an explicit instantiation or specialization of a function template, or introduced by a using-declaration), except for the following restrictions:</p>
<p>The name of this function can have one of the two forms:</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <code>operator ""</code> <span class="t-spar">identifier</span> </td> <td> (1) </td> <td> <span class="t-mark">(deprecated)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <code>operator</code> <span class="t-spar">user-defined-string-literal</span> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <table class="t-par-begin"> <tr class="t-par"> <td> <span class="t-spar">identifier</span> </td> <td> - </td> <td> the <a href="identifiers" title="cpp/language/identifiers">identifier</a> to use as the <span class="t-spar">ud-suffix</span> for the user-defined literals that will call this function </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">user-defined-string-literal</span> </td> <td> - </td> <td> the character sequence <code>""</code> followed, without a space, by the character sequence that becomes the <span class="t-spar">ud-suffix</span> </td>
</tr>
</table> <div class="t-li1">
<span class="t-li">1)</span> Declares a literal operator.</div> <pre data-language="cpp">operator ""if</pre> <p><span class="t-spar">ud-suffix</span> must begin with the underscore <code>_</code>: the suffixes that do not begin with the underscore are reserved for the literal operators provided by the standard library. It cannot contain double underscores <code>__</code> as well: such suffixes are also reserved.</p>
<p>If the literal operator is a template, it must have an empty parameter list and can have only one template parameter, which must be a non-type template parameter pack with element type <span class="kw4">char</span> (in which case it is known as a <i>numeric literal operator template</i>):</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;char...&gt;
double operator ""_x();</pre></div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>or a non-type template parameter of class type (in which case it is known as a <i>string literal operator template</i>):</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct A { constexpr A(const char*); };
 
template&lt;A a&gt;
A operator ""_a();</pre></div> </td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <p>Only the following parameter lists are allowed on literal operators:</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <code>(</code> <span class="kw4">const</span> <span class="kw4">char</span><span class="sy2">*</span> <code>)</code> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>(</code> <span class="kw4">unsigned</span> <span class="kw4">long</span> <span class="kw4">long</span> <span class="kw4">int</span> <code>)</code> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>(</code> <span class="kw4">long</span> <span class="kw4">double</span> <code>)</code> </td> <td> (3) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>(</code> <span class="kw4">char</span> <code>)</code> </td> <td> (4) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>(</code> <span class="kw4">wchar_t</span> <code>)</code> </td> <td> (5) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>(</code> char8_t <code>)</code> </td> <td> (6) </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <code>(</code> <span class="kw4">char16_t</span> <code>)</code> </td> <td> (7) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>(</code> <span class="kw4">char32_t</span> <code>)</code> </td> <td> (8) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>(</code> <span class="kw4">const</span> <span class="kw4">char</span><span class="sy2">*</span><code>,</code> <code><a href="../types/size_t" title="cpp/types/size t">std::size_t</a></code> <code>)</code> </td> <td> (9) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>(</code> <span class="kw4">const</span> <span class="kw4">wchar_t</span><span class="sy2">*</span><code>,</code> <code><a href="../types/size_t" title="cpp/types/size t">std::size_t</a></code> <code>)</code> </td> <td> (10) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>(</code> <span class="kw4">const</span> char8_t<span class="sy2">*</span><code>,</code> <code><a href="../types/size_t" title="cpp/types/size t">std::size_t</a></code> <code>)</code> </td> <td> (11) </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <code>(</code> <span class="kw4">const</span> <span class="kw4">char16_t</span><span class="sy2">*</span><code>,</code> <code><a href="../types/size_t" title="cpp/types/size t">std::size_t</a></code> <code>)</code> </td> <td> (12) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>(</code> <span class="kw4">const</span> <span class="kw4">char32_t</span><span class="sy2">*</span><code>,</code> <code><a href="../types/size_t" title="cpp/types/size t">std::size_t</a></code> <code>)</code> </td> <td> (13) </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <div class="t-li1">
<span class="t-li">1)</span> Literal operators with this parameter list are the <i>raw literal operators</i>, used as fallbacks for integer and floating-point user-defined literals (see above)</div> <div class="t-li1">
<span class="t-li">2)</span> Literal operators with these parameter lists are the first-choice literal operator for user-defined integer literals</div> <div class="t-li1">
<span class="t-li">3)</span> Literal operators with these parameter lists are the first-choice literal operator for user-defined floating-point literals</div> <div class="t-li1">
<span class="t-li">4-8)</span> Literal operators with these parameter lists are called by user-defined character literals</div> <div class="t-li1">
<span class="t-li">9-13)</span> Literal operators with these parameter lists are called by user-defined string literals</div> <p><a href="default_arguments" title="cpp/language/default arguments">Default arguments</a> are not allowed.</p>
<p>C <a href="language_linkage" title="cpp/language/language linkage">language linkage</a> is not allowed.</p>
<p>Other than the restrictions above, literal operators and literal operator templates are normal functions (and function templates), they can be declared inline or constexpr, they may have internal or external linkage, they can be called explicitly, their addresses can be taken, etc.</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;string&gt;
 
void        operator ""_km(long double); // OK, will be called for 1.0_km
void        operator "" _km(long double); // same as above, deprecated
std::string operator ""_i18n(const char*, std::size_t); // OK
 
template&lt;char...&gt;
double operator ""_π(); // OK
float  operator ""_e(const char*); // OK
 
// error: suffix must begin with underscore
float operator ""Z(const char*);
 
// error: all names that begin with underscore followed by uppercase
// letter are reserved (NOTE: a space between "" and _).
double operator"" _Z(long double);
 
// OK. NOTE: no space between "" and _.
double operator""_Z(long double);
 
// OK: literal operators can be overloaded
double operator ""_Z(const char* args);
 
int main() {}</pre></div> </div> <h3 id="Notes"> Notes</h3> <p>Since the introduction of user-defined literals, the code that uses <a href="https://en.cppreference.com/w/c/types/integer" title="c/types/integer">format macro constants for fixed-width integer types</a> with no space after the preceding string literal became invalid: <code><a href="http://en.cppreference.com/w/cpp/io/c/fprintf"><span class="kw1850">std::<span class="me2">printf</span></span></a><span class="br0">(</span><span class="st0">"%"</span><a href="http://en.cppreference.com/w/cpp/types/integer"><span class="kw186">PRId64</span></a><span class="st0">"<span class="es1">\n</span>"</span>,<a href="http://en.cppreference.com/w/cpp/types/integer"><span class="kw144">INT64_MIN</span></a><span class="br0">)</span><span class="sy4">;</span></code> has to be replaced by <code><a href="http://en.cppreference.com/w/cpp/io/c/fprintf"><span class="kw1850">std::<span class="me2">printf</span></span></a><span class="br0">(</span><span class="st0">"%"</span> <a href="http://en.cppreference.com/w/cpp/types/integer"><span class="kw186">PRId64</span></a><span class="st0">"<span class="es1">\n</span>"</span>,<a href="http://en.cppreference.com/w/cpp/types/integer"><span class="kw144">INT64_MIN</span></a><span class="br0">)</span><span class="sy4">;</span></code>.</p>
<p>Due to <a href="translation_phases#maximal_munch" title="cpp/language/translation phases">maximal munch</a>, user-defined integer and floating point literals ending in <span class="t-rev-inl t-since-cxx17"><span><code>p</code>, <code>P</code>,</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> <code>e</code> and <code>E</code>, when followed by the operators <code>+</code> or <code>-</code>, must be separated from the operator with whitespace or parentheses in the source:</p>
<div class="cpp source-cpp"><pre data-language="cpp">long double operator""_E(long double);
long double operator""_a(long double);
int operator""_p(unsigned long long);
 
auto x = 1.0_E+2.0;   // error
auto y = 1.0_a+2.0;   // OK
auto z = 1.0_E +2.0;  // OK
auto q = (1.0_E)+2.0; // OK
auto w = 1_p+2;       // error
auto u = 1_p +2;      // OK</pre></div> <p>Same applies to dot operator following an integer or floating-point user-defined literal:</p>
<div class="cpp source-cpp"><pre data-language="cpp">#include &lt;chrono&gt;
 
using namespace std::literals;
 
auto a = 4s.count();   // Error
auto b = 4s .count();  // OK
auto c = (4s).count(); // OK</pre></div> <p>Otherwise, a single invalid preprocessing number token (e.g., <code>1.0_E+2.0</code> or <code>4s.count</code>) is formed, which causes compilation to fail.</p>
<table class="wikitable ftm-begin ftm-has-value"> <tr> <th>Feature-test macro</th> <th>Value</th> <th><span title="Standard in which the feature is introduced">Std</span></th> <th>Comment </th>
</tr> <tr> <td><a href="../feature_test#Language_features" title="cpp/feature test"><code>__cpp_user_defined_literals</code></a></td> <td><span class="nu0">200809L</span></td> <td><span class="t-mark">(C++11)</span></td> <td>User-defined literals </td>
</tr>
</table> <h3 id="Examples"> Examples</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;algorithm&gt;
#include &lt;cstddef&gt;
#include &lt;iostream&gt;
#include &lt;numbers&gt;
#include &lt;string&gt;
 
// used as conversion from degrees (input param) to radians (returned output)
constexpr long double operator""_deg_to_rad(long double deg)
{
    long double radians = deg * std::numbers::pi_v&lt;long double&gt; / 180;
    return radians;
}
 
// used with custom type
struct mytype
{
    unsigned long long m;
};
 
constexpr mytype operator""_mytype(unsigned long long n)
{
    return mytype{n};
}
 
// used for side-effects
void operator""_print(const char* str)
{
    std::cout &lt;&lt; str &lt;&lt; '\n';
}
 
#if __cpp_nontype_template_args &lt; 201911
 
std::string operator""_x2 (const char* str, std::size_t)
{
    return std::string{str} + str;
}
 
#else // C++20 string literal operator template
 
template&lt;std::size_t N&gt;
struct DoubleString
{
    char p[N + N - 1]{};
 
    constexpr DoubleString(char const(&amp;pp)[N])
    {
        std::ranges::copy(pp, p);
        std::ranges::copy(pp, p + N - 1);
    };
};
 
template&lt;DoubleString A&gt;
constexpr auto operator""_x2()
{
    return A.p;
}
 
#endif // C++20
 
int main()
{
    double x_rad = 90.0_deg_to_rad;
    std::cout &lt;&lt; std::fixed &lt;&lt; x_rad &lt;&lt; '\n';
 
    mytype y = 123_mytype;
    std::cout &lt;&lt; y.m &lt;&lt; '\n';
 
    0x123ABC_print;
    std::cout &lt;&lt; "abc"_x2 &lt;&lt; '\n';
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">1.570796
123
0x123ABC
abcabc</pre></div> </div> <h3 id="Standard_library"> Standard library</h3> <p>The following literal operators are defined in the standard library:</p>
<table class="t-dsc-begin"> <tr class="t-dsc-header"> <th colspan="2"> Defined in inline namespace <code>std::literals::complex_literals</code>  </th>
</tr> <tr class="t-dsc"> <td> <div><a href="../numeric/complex/operator%22%22i" title='cpp/numeric/complex/operator""i'> <span class="t-lines"><span>operator""if</span><span>operator""i</span><span>operator""il</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx14">(C++14)</span></span></span></div> </td> <td> a <code><a href="../numeric/complex" title="cpp/numeric/complex">std::complex</a></code> literal representing purely imaginary number <br> <span class="t-mark">(function)</span>  </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in inline namespace <code>std::literals::chrono_literals</code>  </th>
</tr> <tr class="t-dsc"> <td> <div><a href="../chrono/operator%22%22h" title='cpp/chrono/operator""h'> <span class="t-lines"><span>operator""h</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx14">(C++14)</span></span></span></div> </td> <td> a <code><a href="../chrono/duration" title="cpp/chrono/duration">std::chrono::duration</a></code> literal representing hours <br> <span class="t-mark">(function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../chrono/operator%22%22min" title='cpp/chrono/operator""min'> <span class="t-lines"><span>operator""min</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx14">(C++14)</span></span></span></div> </td> <td> a <code><a href="../chrono/duration" title="cpp/chrono/duration">std::chrono::duration</a></code> literal representing minutes <br> <span class="t-mark">(function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../chrono/operator%22%22s" title='cpp/chrono/operator""s'> <span class="t-lines"><span>operator""s</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx14">(C++14)</span></span></span></div> </td> <td> a <code><a href="../chrono/duration" title="cpp/chrono/duration">std::chrono::duration</a></code> literal representing seconds <br> <span class="t-mark">(function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../chrono/operator%22%22ms" title='cpp/chrono/operator""ms'> <span class="t-lines"><span>operator""ms</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx14">(C++14)</span></span></span></div> </td> <td> a <code><a href="../chrono/duration" title="cpp/chrono/duration">std::chrono::duration</a></code> literal representing milliseconds <br> <span class="t-mark">(function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../chrono/operator%22%22us" title='cpp/chrono/operator""us'> <span class="t-lines"><span>operator""us</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx14">(C++14)</span></span></span></div> </td> <td> a <code><a href="../chrono/duration" title="cpp/chrono/duration">std::chrono::duration</a></code> literal representing microseconds <br> <span class="t-mark">(function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../chrono/operator%22%22ns" title='cpp/chrono/operator""ns'> <span class="t-lines"><span>operator""ns</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx14">(C++14)</span></span></span></div> </td> <td> a <code><a href="../chrono/duration" title="cpp/chrono/duration">std::chrono::duration</a></code> literal representing nanoseconds <br> <span class="t-mark">(function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../chrono/operator%22%22y" title='cpp/chrono/operator""y'> <span class="t-lines"><span>operator""y</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> a <code>std::chrono::year</code> literal representing a particular year <br> <span class="t-mark">(function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../chrono/operator%22%22d" title='cpp/chrono/operator""d'> <span class="t-lines"><span>operator""d</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> a <code>std::chrono::day</code> literal representing a day of a month <br> <span class="t-mark">(function)</span>  </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in inline namespace <code>std::literals::string_literals</code>  </th>
</tr> <tr class="t-dsc"> <td> <div><a href="../string/basic_string/operator%22%22s" title='cpp/string/basic string/operator""s'> <span class="t-lines"><span>operator""s</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx14">(C++14)</span></span></span></div> </td> <td> converts a character array literal to <code>basic_string</code> <br> <span class="t-mark">(function)</span>  </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in inline namespace <code>std::literals::string_view_literals</code>  </th>
</tr> <tr class="t-dsc"> <td> <div><a href="../string/basic_string_view/operator%22%22sv" title='cpp/string/basic string view/operator""sv'> <span class="t-lines"><span>operator""sv</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> creates a string view of a character array literal <br> <span class="t-mark">(function)</span>  </td>
</tr> </table> <h3 id="Defect_reports"> Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th> DR </th> <th> Applied to </th> <th> Behavior as published </th> <th> Correct behavior </th>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1473.html">CWG 1473</a> </td> <td> C++11 </td> <td> whitespace between <span class="st0">""</span> and <span class="t-spar">ud-suffix</span> was<br>required in the declaration of literal operators </td> <td> made optional </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1479.html">CWG 1479</a> </td> <td> C++11 </td> <td> literal operators could have default arguments </td> <td> prohibited </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2521.html">CWG 2521</a> </td> <td> C++11 </td> <td> operator<span class="st0">""</span> _Bq was ill-formed (no diagnostic<br>required) because it uses the reserved identifier <code>_Bq</code> </td> <td> deprecated the literal operator syntax<br>with whitespace between <span class="st0">""</span> and <span class="t-spar">ud-suffix</span> </td>
</tr>
</table>           <div class="_attribution">
  <p class="_attribution-p">
    © cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/language/user_literal" class="_attribution-link">https://en.cppreference.com/w/cpp/language/user_literal</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
