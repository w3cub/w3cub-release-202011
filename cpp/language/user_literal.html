
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>User-defined Literals - C++ - W3cubDocs</title>
  
  <meta name="description" content=" Allows integer, floating-point, character, and string literals to produce objects of user-defined type by defining a user-defined suffix. ">
  <meta name="keywords" content="user-defined, literals, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/language/user_literal.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/cpp.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _c">
				
				
<h1 id="firstHeading" class="firstHeading">User-defined literals <span class="t-mark-rev t-since-cxx11">(since C++11)</span>
</h1>            <p>Allows integer, floating-point, character, and string literals to produce objects of user-defined type by defining a user-defined suffix.</p>
<h3 id="Syntax">Syntax</h3> <p>A user-defined literal is an expression of any of the following forms.</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">decimal-literal</span> <span class="t-spar">ud-suffix</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">octal-literal</span> <span class="t-spar">ud-suffix</span> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">hex-literal</span> <span class="t-spar">ud-suffix</span> </td> <td> (3) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">binary-literal</span> <span class="t-spar">ud-suffix</span> </td> <td> (4) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">fractional-constant</span> <span class="t-spar">exponent-part</span><span class="t-mark">(optional)</span> <span class="t-spar">ud-suffix</span> </td> <td> (5) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">digit-sequence</span> <span class="t-spar">exponent-part</span> <span class="t-spar">ud-suffix</span> </td> <td> (6) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">character-literal</span> <span class="t-spar">ud-suffix</span> </td> <td> (7) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">string-literal</span> <span class="t-spar">ud-suffix</span> </td> <td> (8) </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <div class="t-li1">
<span class="t-li">1-4)</span> user-defined integer literals, such as <code>12_km</code>
</div> <div class="t-li1">
<span class="t-li">5-6)</span> user-defined floating-point literals, such as <code>0.5_Pa</code>
</div> <div class="t-li1">
<span class="t-li">7)</span> user-defined character literal, such as <code>'c'_X</code>
</div> <div class="t-li1">
<span class="t-li">8)</span> user-defined string literal, such as <code>"abd"_L</code> or <code>u"xyz"_M</code>
</div> <table class="t-par-begin"> <tr class="t-par"> <td> <span class="t-spar">decimal-literal</span> </td> <td> - </td> <td> same as in <a href="integer_literal" title="cpp/language/integer literal">integer literal</a>, a non-zero decimal digit followed by zero or more decimal digits </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">octal-literal</span> </td> <td> - </td> <td> same as in <a href="integer_literal" title="cpp/language/integer literal">integer literal</a>, a zero followed by zero or more octal digits </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">hex-literal</span> </td> <td> - </td> <td> same as in <a href="integer_literal" title="cpp/language/integer literal">integer literal</a>, <code>0x</code> or <code>0X</code> followed by one or more hexadecimal digits </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">binary-literal</span> </td> <td> - </td> <td> same as in <a href="integer_literal" title="cpp/language/integer literal">integer literal</a>, <code>0b</code> or <code>0B</code> followed by one or more binary digits </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">digit-sequence</span> </td> <td> - </td> <td> same as in <a href="floating_literal" title="cpp/language/floating literal">floating literal</a>, a sequence of decimal digits </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">fractional-constant</span> </td> <td> - </td> <td> same as in <a href="floating_literal" title="cpp/language/floating literal">floating literal</a>, either a <span class="t-spar">digit-sequence</span> followed by a dot (<code>123.</code>) or an optional <span class="t-spar">digit-sequence</span> followed by a dot and another <span class="t-spar">digit-sequence</span> (<code>1.0</code> or <code>.12</code>) </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">exponent-part</span> </td> <td> - </td> <td> same as in <a href="floating_literal" title="cpp/language/floating literal">floating literal</a>, the letter <code>e</code> or the letter <code>E</code> followed by optional sign, followed by <span class="t-spar">digit-sequence</span> </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">character-literal</span> </td> <td> - </td> <td> same as in <a href="character_literal" title="cpp/language/character literal">character literal</a> </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">string-literal</span> </td> <td> - </td> <td> same as in <a href="string_literal" title="cpp/language/string literal">string literal</a>, including raw string literals </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">ud-suffix</span> </td> <td> - </td> <td> an identifier, introduced by a <i>literal operator</i> or a <i>literal operator template</i> declaration (see below). All <span class="t-spar">ud-suffix</span>es introduced by a program must begin with the underscore character <code>_</code>. The standard library <span class="t-spar">ud-suffix</span>es do not begin with underscores. </td>
</tr>
</table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx14">
<td> In the integer and floating-point digit sequences, optional separators <code>'</code> are allowed between any two digits and are ignored</td> <td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr> </table> <p>If a token matches a user-defined literal syntax and a regular literal syntax, it is assumed to be a regular literal (that is, it's impossible to overload <code>LL</code> in <code>123LL</code>).</p>
<p>When the compiler encounters a user-defined literal with <span class="t-spar">ud-suffix</span> <code>X</code>, it performs <a href="lookup#Unqualified_name_lookup" title="cpp/language/lookup">unqualified name lookup</a>, looking for a function with the name <code>operator "" X</code>. If the lookup does not find a declaration, the program is ill-formed. Otherwise,</p>
<div class="t-li1">
<span class="t-li">1)</span> For user-defined integer literals</div> <div class="t-li2">
<span class="t-li">a)</span> if the overload set includes a literal operator with the parameter type <code>unsigned long long</code>, the user-defined literal expression is treated as a function call <code>operator "" X(nULL)</code>, where n is the literal without <span class="t-spar">ud-suffix</span>
</div> <div class="t-li2">
<span class="t-li">b)</span> otherwise, the overload set must include either, but not both, a raw literal operator or a numeric literal operator template. If the overload set includes a raw literal operator, the user-defined literal expression is treated as a function call <code>operator "" X("n")</code>
</div> <div class="t-li2">
<span class="t-li">c)</span> otherwise, if the overload set includes a numeric literal operator template, the user-defined literal expression is treated as a function call <code>operator "" X&lt;'c1', 'c2', 'c3'..., 'ck'&gt;()</code>, where c1..ck are the individual characters of <code>n</code>.</div> <div class="t-li1">
<span class="t-li">2)</span> For user-defined floating-point literals,</div> <div class="t-li2">
<span class="t-li">a)</span> If the overload set includes a literal operator with the parameter type <code>long double</code>, the user-defined literal expression is treated as a function call <code>operator "" X(fL)</code>, where <code>f</code> is the literal without <span class="t-spar">ud-suffix</span>
</div> <div class="t-li2">
<span class="t-li">b)</span> otherwise, the overload set must include either, but not both, a raw literal operator or a numeric literal operator template. If the overload set includes a raw literal operator, the user-defined literal expression is treated as a function call <code>operator "" X("f")</code>
</div> <div class="t-li2">
<span class="t-li">c)</span> otherwise, if the overload set includes a numeric literal operator template, the user-defined literal expression is treated as a function call <code>operator "" X&lt;'c1', 'c2', 'c3'..., 'ck'&gt;()</code>, where c1..ck are the individual characters of <code>f</code>.</div> <div class="t-li1">
<span class="t-li">3)</span> For user-defined string literals, let <code>str</code> be the literal without <span class="t-spar">ud-suffix</span>:</div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <span class="t-li">a)</span> If the overload set includes a string literal operator template with a non-type template parameter for which <code>str</code> is a well-formed template argument, then the user-defined literal expression is treated as a function call <code>operator "" X&lt;str&gt;()</code>, </td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <div class="t-li2">
<span class="t-li">b)</span> otherwise, the user-defined literal expression is treated as a function call <code>operator "" X (str, len)</code>, where <code>len</code> is the length of the string literal, excluding the terminating null character</div> <div class="t-li1">
<span class="t-li">4)</span> For user-defined character literals, the user-defined literal expression is treated as a function call <code>operator "" X(ch)</code>, where <code>ch</code> is the literal without <span class="t-spar">ud-suffix</span>
</div> <div class="cpp source-cpp"><pre data-language="cpp">long double operator "" _w(long double);
std::string operator "" _w(const char16_t*, size_t);
unsigned operator "" _w(const char*);
int main() {
    1.2_w; // calls operator "" _w(1.2L)
    u"one"_w; // calls operator "" _w(u"one", 3)
    12_w; // calls operator "" _w("12")
    "two"_w; // error: no applicable literal operator
}</pre></div> <p>When string literal concatenation takes place in <a href="translation_phases" title="cpp/language/translation phases">translation phase 6</a>, user-defined string literals are concatenated as well, and their <span class="t-spar">ud-suffix</span>es are ignored for the purpose of concatenation, except that only one suffix may appear on all concatenated literals:</p>
<div class="cpp source-cpp"><pre data-language="cpp">int main() {
    L"A" "B" "C"_x; // OK: same as L"ABC"_x
    "P"_x "Q" "R"_y;// error: two different ud-suffixes (_x and _y)
}</pre></div> <h3 id="Literal_operators">Literal operators</h3> <p>The function called by a user-defined literal is known as <i>literal operator</i> (or, if it's a template, <i>literal operator template</i>). It is declared just like any other <a href="function" title="cpp/language/function">function</a> or <a href="function_template" title="cpp/language/function template">function template</a> at namespace scope (it may also be a friend function, an explicit instantiation or specialization of a function template, or introduced by a using-declaration), except for the following restrictions:</p>
<p>The name of this function can have one of the two forms:</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td class="t-sdsc-nopad"> <code>operator</code> <code>""</code> <span class="t-spar">identifier</span> </td> <td class="t-sdsc-nopad"> </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td class="t-sdsc-nopad"> <code>operator</code> <span class="t-spar">user-defined-string-literal</span> <span class="t-mark-rev t-since-cxx14">(since C++14)</span> </td> <td class="t-sdsc-nopad"> </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <table class="t-par-begin"> <tr class="t-par"> <td> <span class="t-spar">identifier</span> </td> <td> - </td> <td> the identifier to use as the <span class="t-spar">ud-suffix</span> for the user-defined literals that will call this function. Must begin with the underscore <code>_</code>: the suffixes that do not begin with the underscore are reserved for the literal operators provided by the standard library. </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">user-defined-string-literal</span> </td> <td> - </td> <td> the character sequence <code>""</code> followed, without a space, by the character sequence that becomes the <span class="t-spar">ud-suffix</span>. This special syntax makes it possible to use language keywords and <a href="../keywords" title="cpp/keywords" class="mw-redirect">reserved identifiers</a> as ud-suffixes, and is used by the declaration of <code>operator ""if</code> from the header <code>&lt;complex&gt;</code>. Note that using this form does not change the rules that user-defined literal operators must begin with an underscore: declarations such as <code>operator ""if</code> may only appear as part of a standard library header. However, it allows the use of an underscore followed by a capital letter (which is otherwise a <a href="name" title="cpp/language/identifiers">reserved identifier</a>) </td>
</tr>
</table> <p>If the literal operator is a template, it must have an empty parameter list and can have only one template parameter, which must be a non-type template parameter pack with element type <code>char</code> (in which case it is known as a <i>numeric literal operator template</i>).</p>
<div class="cpp source-cpp"><pre data-language="cpp">template &lt;char...&gt; double operator "" _x();</pre></div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>or a non-type template parameter of class type (in which case it is known as a <i>string literal operator template</i>).</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct A { A(const char *); auto operator&lt;=&gt;(const A&amp;) const = default; };
 
template&lt;A a&gt; A operator ""_a();</pre></div> </td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <p>Only the following parameter lists are allowed on literal operators :</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <code>(</code> <code>const char *</code> <code>)</code> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>(</code> <code>unsigned long long int</code> <code>)</code> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>(</code> <code>long double</code> <code>)</code> </td> <td> (3) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>(</code> <code>char</code> <code>)</code> </td> <td> (4) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>(</code> <code>wchar_t</code> <code>)</code> </td> <td> (5) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>(</code> <code>char8_t</code> <code>)</code> </td> <td> (6) </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <code>(</code> <code>char16_t</code> <code>)</code> </td> <td> (7) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>(</code> <code>char32_t</code> <code>)</code> </td> <td> (8) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>(</code> <code>const char *</code> <code>,</code> <code><a href="../types/size_t"><span class="kw100">std::<span class="me2">size_t</span></span></a></code> <code>)</code> </td> <td> (9) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>(</code> <code>const wchar_t *</code> <code>,</code> <code><a href="../types/size_t"><span class="kw100">std::<span class="me2">size_t</span></span></a></code> <code>)</code> </td> <td> (10) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>(</code> <code>const char8_t *</code> <code>,</code> <code><a href="../types/size_t"><span class="kw100">std::<span class="me2">size_t</span></span></a></code> <code>)</code> </td> <td> (11) </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <code>(</code> <code>const char16_t *</code> <code>,</code> <code><a href="../types/size_t"><span class="kw100">std::<span class="me2">size_t</span></span></a></code> <code>)</code> </td> <td> (12) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>(</code> <code>const char32_t *</code> <code>,</code> <code><a href="../types/size_t"><span class="kw100">std::<span class="me2">size_t</span></span></a></code> <code>)</code> </td> <td> (13) </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <div class="t-li1">
<span class="t-li">1)</span> Literal operators with this parameter list are the <i>raw literal operators</i>, used as fallbacks for integer and floating-point user-defined literals (see above)</div> <div class="t-li1">
<span class="t-li">2)</span> Literal operators with these parameter lists are the first-choice literal operator for user-defined integer literals</div> <div class="t-li1">
<span class="t-li">3)</span> Literal operators with these parameter lists are the first-choice literal operator for user-defined floating-point literals</div> <div class="t-li1">
<span class="t-li">4-8)</span> Literal operators with these parameter lists are called by user-defined character literals</div> <div class="t-li1">
<span class="t-li">9-13)</span> Literal operators with these parameter lists are called by user-defined string literals</div> <p><a href="default_arguments" title="cpp/language/default arguments">Default arguments</a> are not allowed.</p>
<p>C <a href="language_linkage" title="cpp/language/language linkage">language linkage</a> is not allowed.</p>
<p>Other than the restrictions above, literal operators and literal operator templates are normal functions (and function templates), they can be declared inline or constexpr, they may have internal or external linkage, they can be called explicitly, their addresses can be taken, etc.</p>
<div class="cpp source-cpp"><pre data-language="cpp">void operator "" _km(long double); // OK, will be called for 1.0_km
std::string operator "" _i18n(const char*, std::size_t); // OK
template &lt;char...&gt; double operator "" _π(); // OK
float operator ""_e(const char*); // OK
 
float operator ""Z(const char*); // error: suffix must begin with underscore
double operator"" _Z(long double); // error: all names that begin with underscore
                                   // followed by uppercase letter are reserved
double operator""_Z(long double); // OK: even though _Z is reserved ""_Z is allowed</pre></div> <h3 id="Notes">Notes</h3> <p>Since the introduction of user-defined literals, the code that uses <a href="http://en.cppreference.com/w/c/types/integer.html" title="c/types/integer">format macro constants for fixed-width integer types</a> with no space after the preceding string literal became invalid: <code><a href="../io/c/fprintf"><span class="kw1842">std::<span class="me2">printf</span></span></a><span class="br0">(</span><span class="st0">"%"</span><a href="../types/integer"><span class="kw179">PRId64</span></a><span class="st0">"<span class="es1">\n</span>"</span>,<a href="../types/integer"><span class="kw137">INT64_MIN</span></a><span class="br0">)</span><span class="sy4">;</span></code> has to be replaced by <code><a href="../io/c/fprintf"><span class="kw1842">std::<span class="me2">printf</span></span></a><span class="br0">(</span><span class="st0">"%"</span> <a href="../types/integer"><span class="kw179">PRId64</span></a><span class="st0">"<span class="es1">\n</span>"</span>,<a href="../types/integer"><span class="kw137">INT64_MIN</span></a><span class="br0">)</span><span class="sy4">;</span></code></p>
<p>Due to <a href="translation_phases#maximal_munch" title="cpp/language/translation phases">maximal munch</a>, user-defined integer and floating point literals ending in <span class="t-rev-inl t-since-cxx17"><span><code>p</code>, <code>P</code>,</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> <code>e</code> and <code>E</code>, when followed by the operators <code>+</code> or <code>-</code>, must be separated from the operator with whitespace or parentheses in the source:</p>
<div class="cpp source-cpp"><pre data-language="cpp">long double operator""_E(long double);
long double operator""_a(long double);
int operator""_p(unsigned long long);
 
auto x = 1.0_E+2.0;   // error
auto y = 1.0_a+2.0;   // OK
auto z = 1.0_E +2.0;  // OK
auto q = (1.0_E)+2.0; // OK
auto w = 1_p+2;       // error
auto u = 1_p +2;      // OK</pre></div> <p>Same applies to dot operator following an integer or floating-point user-defined literal:</p>
<div class="cpp source-cpp"><pre data-language="cpp">#include &lt;chrono&gt;
using namespace std::literals;
auto a = 4s.count();   // Error
auto b = 4s .count();  // OK
auto c = (4s).count(); // OK</pre></div> <p>Otherwise, a single invalid preprocessing number token (e.g., <code>1.0_E+2.0</code> or <code>4s.count</code>) is formed, which causes compilation to fail.</p>
<h3 id="Examples">Examples</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
 
// used as conversion
constexpr long double operator"" _deg ( long double deg )
{
    return deg * 3.14159265358979323846264L / 180;
}
 
// used with custom type
struct mytype
{
    unsigned long long m;
};
constexpr mytype operator"" _mytype ( unsigned long long n )
{
    return mytype{n};
}
 
// used for side-effects
void operator"" _print ( const char* str )
{
    std::cout &lt;&lt; str;
}
 
int main(){
    double x = 90.0_deg;
    std::cout &lt;&lt; std::fixed &lt;&lt; x &lt;&lt; '\n';
    mytype y = 123_mytype;
    std::cout &lt;&lt; y.m &lt;&lt; '\n';
    0x123ABC_print;
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">1.570796
123
0x123ABC</pre></div> </div> <h3 id="Standard_library">Standard library</h3> <p>The following literal operators are defined in the standard library.</p>
<table class="t-dsc-begin"> <tr class="t-dsc-header"> <th colspan="2"> Defined in inline namespace <code>std::literals::complex_literals</code>  </th>
</tr> <tr class="t-dsc"> <td> <div><a href="../numeric/complex/operator_q__q_i" title='cpp/numeric/complex/operator""i'> <span class="t-lines"><span>operator""if</span><span>operator""i</span><span>operator""il</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx14">(C++14)</span></span></span></div> </td> <td> A <code><a href="../numeric/complex" title="cpp/numeric/complex">std::complex</a></code> literal representing pure imaginary number <br> <span class="t-mark">(function)</span> </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in inline namespace <code>std::literals::chrono_literals</code>  </th>
</tr> <tr class="t-dsc"> <td> <div><a href="../chrono/operator_q__q_h" title='cpp/chrono/operator""h'> <span class="t-lines"><span>operator""h</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx14">(C++14)</span></span></span></div> </td> <td> A <code><a href="../chrono/duration" title="cpp/chrono/duration">std::chrono::duration</a></code> literal representing hours <br> <span class="t-mark">(function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../chrono/operator_q__q_min" title='cpp/chrono/operator""min'> <span class="t-lines"><span>operator""min</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx14">(C++14)</span></span></span></div> </td> <td> A <code><a href="../chrono/duration" title="cpp/chrono/duration">std::chrono::duration</a></code> literal representing minutes <br> <span class="t-mark">(function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../chrono/operator_q__q_s" title='cpp/chrono/operator""s'> <span class="t-lines"><span>operator""s</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx14">(C++14)</span></span></span></div> </td> <td> A <code><a href="../chrono/duration" title="cpp/chrono/duration">std::chrono::duration</a></code> literal representing seconds <br> <span class="t-mark">(function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../chrono/operator_q__q_ms" title='cpp/chrono/operator""ms'> <span class="t-lines"><span>operator""ms</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx14">(C++14)</span></span></span></div> </td> <td> A <code><a href="../chrono/duration" title="cpp/chrono/duration">std::chrono::duration</a></code> literal representing milliseconds <br> <span class="t-mark">(function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../chrono/operator_q__q_us" title='cpp/chrono/operator""us'> <span class="t-lines"><span>operator""us</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx14">(C++14)</span></span></span></div> </td> <td> A <code><a href="../chrono/duration" title="cpp/chrono/duration">std::chrono::duration</a></code> literal representing microseconds <br> <span class="t-mark">(function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../chrono/operator_q__q_ns" title='cpp/chrono/operator""ns'> <span class="t-lines"><span>operator""ns</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx14">(C++14)</span></span></span></div> </td> <td> A <code><a href="../chrono/duration" title="cpp/chrono/duration">std::chrono::duration</a></code> literal representing nanoseconds <br> <span class="t-mark">(function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../chrono/operator_q__q_y" title='cpp/chrono/operator""y'> <span class="t-lines"><span>operator""y</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> A <code>std::chrono::year</code> literal representing a particular year <br> <span class="t-mark">(function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../chrono/operator_q__q_d" title='cpp/chrono/operator""d'> <span class="t-lines"><span>operator""d</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> A <code>std::chrono::day</code> literal representing a day of a month <br> <span class="t-mark">(function)</span> </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in inline namespace <code>std::literals::string_literals</code>  </th>
</tr> <tr class="t-dsc"> <td> <div><a href="../string/basic_string/operator_q__q_s" title='cpp/string/basic string/operator""s'> <span class="t-lines"><span>operator""s</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx14">(C++14)</span></span></span></div> </td> <td> Converts a character array literal to <code>basic_string</code> <br> <span class="t-mark">(function)</span> </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in inline namespace <code>std::literals::string_view_literals</code>  </th>
</tr> <tr class="t-dsc"> <td> <div><a href="../string/basic_string_view/operator_q__q_sv" title='cpp/string/basic string view/operator""sv'> <span class="t-lines"><span>operator""sv</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> Creates a string view of a character array literal <br> <span class="t-mark">(function)</span> </td>
</tr> </table>          <div class="_attribution">
  <p class="_attribution-p">
    © cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/language/user_literal" class="_attribution-link">http://en.cppreference.com/w/cpp/language/user_literal</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
