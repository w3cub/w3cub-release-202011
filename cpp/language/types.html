
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Fundamental Types - C++ - W3cubDocs</title>
  
  <meta name="description" content=" (See also type for type system overview and the list of type-related utilities that are provided by the C++ library). ">
  <meta name="keywords" content="fundamental, types, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/language/types.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-1810d67ab7e57be09d8247710d2feb6954566959eb82322d1fee3a0c9156f56974b78ebaa9928774f00767342bbe58b0799d91fcc336b92b319170b196f9b64b.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/cpp.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _c">
				
				
<h1 id="firstHeading" class="firstHeading">Fundamental types</h1>            <p><small>(See also <a href="type" title="cpp/language/type">type</a> for type system overview and <a href="../types" title="cpp/types"> the list of type-related utilities</a> that are provided by the C++ library)</small>.</p>
<h3 id="Void_type"> Void type</h3> <code>void</code> - type with an empty set of values. It is an <a href="incomplete_type" title="cpp/language/incomplete type" class="mw-redirect">incomplete type</a> that cannot be completed (consequently, objects of type <code>void</code> are disallowed). There are no <a href="array" title="cpp/language/array">arrays</a> of <code>void</code>, nor <a href="reference" title="cpp/language/reference">references</a> to <code>void</code>. However, <a href="pointer#Pointers_to_void" title="cpp/language/pointer">pointers to <code>void</code></a> and <a href="function" title="cpp/language/function">functions</a> returning type <code>void</code> (<i>procedures</i> in other languages) are permitted.  <h3 id="std::nullptr_t"> <code><a href="../types/nullptr_t" title="cpp/types/nullptr t">std::nullptr_t</a></code>
</h3> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th> Defined in header <code><a href="../header/cstddef" title="cpp/header/cstddef">&lt;cstddef&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">typedef decltype(nullptr) nullptr_t;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr>  </table> <p><code><a href="../types/nullptr_t" title="cpp/types/nullptr t">std::nullptr_t</a></code> is the type of the null pointer literal, <a href="nullptr" title="cpp/language/nullptr"><code>nullptr</code></a>. It is a distinct type that is not itself a pointer type or a pointer to member type. Its values are <i>null pointer constant</i> (see <code><a href="../types/null" title="cpp/types/NULL">NULL</a></code>), and may be <a href="implicit_cast" title="cpp/language/implicit cast" class="mw-redirect">implicitly converted</a> to any pointer and pointer to member type.</p>
<p><code>sizeof<span class="br0">(</span><a href="http://en.cppreference.com/w/cpp/types/nullptr_t"><span class="kw108">std::<span class="me2">nullptr_t</span></span></a><span class="br0">)</span></code> is equal to <code>sizeof(void *)</code>.</p>
<h3 id="Data_models"> Data models</h3> <p>The choices made by each implementation about the sizes of the fundamental types are collectively known as <i>data model</i>. Four data models found wide acceptance:</p>
<p>32 bit systems:</p>
<ul>
<li>
<b>LP32</b> or <b>2/4/4</b> (int is 16-bit, long and pointer are 32-bit) </li>
<ul><li> Win16 API </li></ul>
<li>
<b>ILP32</b> or <b>4/4/4</b> (int, long, and pointer are 32-bit); </li>
<ul>
<li> Win32 API </li>
<li> Unix and Unix-like systems (Linux, macOS) </li>
</ul>
</ul>     <p>64 bit systems:</p>
<ul>
<li> <b>LLP64</b> or <b>4/4/8</b> (int and long are 32-bit, pointer is 64-bit) </li>
<ul><li> Win64 API </li></ul>
<li> <b>LP64</b> or <b>4/8/8</b> (int is 32-bit, long and pointer are 64-bit) </li>
<ul><li> Unix and Unix-like systems (Linux, macOS) </li></ul>
</ul>     <p>Other models are very rare. For example, <b>ILP64</b> (<b>8/8/8</b>: int, long, and pointer are 64-bit) only appeared in some early 64-bit Unix systems (e.g. <a href="https://en.wikipedia.org/wiki/UNICOS" class="extiw" title="enwiki:UNICOS">UNICOS on Cray</a>).</p>
<h3 id="Signed_and_unsigned_integer_types"> Signed and unsigned integer types</h3> <code>int</code> - basic integer type. The keyword <code>int</code> may be omitted if any of the modifiers listed below are used. If no length modifiers are present, it's guaranteed to have a width of at least 16 bits. However, on 32/64 bit systems it is almost exclusively guaranteed to have width of at least 32 bits (see below).  <h4 id="Modifiers"> Modifiers</h4> <p>Modifies the basic integer type. Can be mixed in any order. Only one of each group can be present in type name.</p>
<p><b>Signedness</b>.</p>
<dl>
<dd>
<code>signed</code> - target type will have signed representation (this is the default if omitted) </dd>
<dd>
<code>unsigned</code> - target type will have unsigned representation </dd>
</dl> <p><b>Size</b>.</p>
<dl>
<dd>
<code>short</code> - target type will be optimized for space and will have width of at least 16 bits. </dd>
<dd>
<code>long</code> - target type will have width of at least 32 bits. </dd>
</dl> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>  <code>long long</code> - target type will have width of at least 64 bits.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <p>Note: as with all type specifiers, any order is permitted: <code>unsigned long long int</code> and <code>long int unsigned long</code> name the same type.</p>
<h4 id="Properties"> Properties</h4> <p>The following table summarizes all available integer types and their properties in various common data models:</p>
<table class="wikitable"> <tr> <th rowspan="2"> Type specifier </th> <th rowspan="2"> Equivalent type </th> <th colspan="5"> Width in bits by data model </th>
</tr> <tr> <th> C++ standard </th> <th> LP32 </th> <th> ILP32 </th> <th> LLP64 </th> <th> LP64 </th>
</tr> <tr> <td> <code>short</code> </td> <td rowspan="4"> <code>short int</code> </td> <td rowspan="6"> at least<br> <b>16</b> </td> <td rowspan="6"> <b>16</b> </td> <td rowspan="6"> <b>16</b> </td> <td rowspan="6"> <b>16</b> </td> <td rowspan="6"> <b>16</b> </td>
</tr> <tr> <td> <code>short int</code> </td>
</tr> <tr> <td> <code>signed short</code> </td>
</tr> <tr> <td> <code>signed short int</code> </td>
</tr> <tr> <td> <code>unsigned short</code> </td> <td rowspan="2"> <code>unsigned short int</code> </td>
</tr> <tr> <td> <code>unsigned short int</code> </td>
</tr> <tr> <td> <code>int</code> </td> <td rowspan="3"> <code>int</code> </td> <td rowspan="5"> at least<br> <b>16</b> </td> <td rowspan="5"> <b>16</b> </td> <td rowspan="5"> <b>32</b> </td> <td rowspan="5"> <b>32</b> </td> <td rowspan="5"> <b>32</b> </td>
</tr> <tr> <td> <code>signed</code> </td>
</tr> <tr> <td> <code>signed int</code> </td>
</tr> <tr> <td> <code>unsigned</code> </td> <td rowspan="2"> <code>unsigned int</code> </td>
</tr> <tr> <td> <code>unsigned int</code> </td>
</tr> <tr> <td> <code>long</code> </td> <td rowspan="4"> <code>long int</code> </td> <td rowspan="6"> at least<br> <b>32</b> </td> <td rowspan="6"> <b>32</b> </td> <td rowspan="6"> <b>32</b> </td> <td rowspan="6"> <b>32</b> </td> <td rowspan="6"> <b>64</b> </td>
</tr> <tr> <td> <code>long int</code> </td>
</tr> <tr> <td> <code>signed long</code> </td>
</tr> <tr> <td> <code>signed long int</code> </td>
</tr> <tr> <td> <code>unsigned long</code> </td> <td rowspan="2"> <code>unsigned long int</code> </td>
</tr> <tr> <td> <code>unsigned long int</code> </td>
</tr> <tr> <td> <code>long long</code> </td> <td rowspan="4"> <code>long long int</code> <br> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td> <td rowspan="6"> at least<br> <b>64</b> </td> <td rowspan="6"> <b>64</b> </td> <td rowspan="6"> <b>64</b> </td> <td rowspan="6"> <b>64</b> </td> <td rowspan="6"> <b>64</b> </td>
</tr> <tr> <td> <code>long long int</code> </td>
</tr> <tr> <td> <code>signed long long</code> </td>
</tr> <tr> <td> <code>signed long long int</code> </td>
</tr> <tr> <td> <code>unsigned long long</code> </td> <td rowspan="2"> <code>unsigned long long int</code> <br> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td>
</tr> <tr> <td> <code>unsigned long long int</code> </td>
</tr>
</table> <p>Note: integer arithmetic is defined differently for the signed and unsigned integer types. See <a href="operator_arithmetic" title="cpp/language/operator arithmetic">arithmetic operators</a>, in particular <a href="operator_arithmetic#Overflows" title="cpp/language/operator arithmetic">integer overflows</a>.</p>
<p><code><a href="../types/size_t" title="cpp/types/size t">std::size_t</a></code> is the unsigned integer type of the result of the <a href="sizeof" title="cpp/language/sizeof"><code>sizeof</code></a> operator <span class="t-rev-inl t-since-cxx11"><span>as well as the <a href="sizeof..." title="cpp/language/sizeof..."><code>sizeof...</code></a> operator and the <a href="alignof" title="cpp/language/alignof"><code>alignof</code></a> operator</span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>See also <a href="../types/integer" title="cpp/types/integer">Fixed width integer types</a>.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <h3 id="Boolean_type"> Boolean type</h3> <code>bool</code> - type, capable of holding one of the two values: <a href="bool_literal" title="cpp/language/bool literal"><code>true</code></a> or <a href="bool_literal" title="cpp/language/bool literal"><code>false</code></a>. The value of <code>sizeof(bool)</code> is implementation defined and might differ from 1.  <h3 id="Character_types"> Character types</h3> <dl>
<dd>
<code>signed char</code> - type for signed character representation. </dd>
<dd>
<code>unsigned char</code> - type for unsigned character representation. Also used to inspect <a href="object" title="cpp/language/object">object representations</a> (raw memory). </dd>
<dd>
<code>char</code> - type for character representation which can be most efficiently processed on the target system (has the same representation and alignment as either <code>signed char</code> or <code>unsigned char</code>, but is always a distinct type). <a href="../string/multibyte" title="cpp/string/multibyte">Multibyte characters strings</a> use this type to represent code units. <span class="t-rev-inl t-since-cxx11"><span>For every value of type <code>unsigned char</code> in range [0, 255], converting the value to <code>char</code> and then back to <code>unsigned char</code> produces the original value.</span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span> The signedness of <code>char</code> depends on the compiler and the target platform: the defaults for ARM and PowerPC are typically unsigned, the defaults for x86 and x64 are typically signed. </dd>
<dd>
<code>wchar_t</code> - type for wide character representation (see <a href="../string/wide" title="cpp/string/wide">wide strings</a>). It has the same size, signedness, and alignment as one of the integer types, but is a distinct type. In practice, it is 32 bits and holds UTF-32 on Linux and many other non-Windows systems, but 16 bits and holds UTF-16 code units on Windows. The standard used to require <code>wchar_t</code> to be large enough to represent any supported character code point. However, such requirement cannot be fulfilled on Windows, and thus it is considered as a defect and removed by <a rel="nofollow" class="external text" href="https://wg21.link/P2460R2">P2460R2</a>. </dd>
</dl> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>  <code>char16_t</code> - type for UTF-16 character representation, required to be large enough to represent any UTF-16 code unit (16 bits). It has the same size, signedness, and alignment as <code><a href="../types/integer" title="cpp/types/integer">std::uint_least16_t</a></code>, but is a distinct type.</p>
<p>  <code>char32_t</code> - type for UTF-32 character representation, required to be large enough to represent any UTF-32 code unit (32 bits). It has the same size, signedness, and alignment as <code><a href="../types/integer" title="cpp/types/integer">std::uint_least32_t</a></code>, but is a distinct type.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>  <code>char8_t</code> - type for UTF-8 character representation, required to be large enough to represent any UTF-8 code unit (8 bits). It has the same size, signedness, and alignment as <code>unsigned char</code> (and therefore, the same size and alignment as <code>char</code> and <code>signed char</code>), but is a distinct type.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <p>Besides the minimal bit counts, the C++ Standard guarantees that  <code>1 == sizeof(char) &lt;= sizeof(short) &lt;= sizeof(int) &lt;= sizeof(long) &lt;= sizeof(long long)</code>.</p>
<p>Note: this allows the extreme case in which <a href="https://en.wikipedia.org/wiki/Byte" class="extiw" title="enwiki:Byte">bytes</a> are sized 64 bits, all types (including <code>char</code>) are 64 bits wide, and <code>sizeof</code> returns 1 for every type.</p>
<h3 id="Floating-point_types"> Floating-point types</h3> <p>The following three types and their cv-qualified versions are collectively called floating-point types.</p>
<dl>
<dd>
<code>float</code> - single precision floating-point type. Matches <a href="https://en.wikipedia.org/wiki/Single-precision_floating-point_format" class="extiw" title="enwiki:Single-precision floating-point format">IEEE-754 binary32 format</a> if supported. </dd>
<dd>
<code>double</code> - double precision floating-point type. Matches <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format" class="extiw" title="enwiki:Double-precision floating-point format">IEEE-754 binary64 format</a> if supported. </dd>
<dd>
<code>long double</code> - extended precision floating-point type. Matches <a href="https://en.wikipedia.org/wiki/Quadruple-precision_floating-point_format" class="extiw" title="enwiki:Quadruple-precision floating-point format">IEEE-754 binary128 format</a> if supported, otherwise matches <a href="https://en.wikipedia.org/wiki/Extended_precision" class="extiw" title="enwiki:Extended precision">IEEE-754 binary64-extended format</a> if supported, otherwise matches some non-IEEE-754 extended floating-point format as long as its precision is better than binary64 and range is at least as good as binary64, otherwise matches IEEE-754 binary64 format. <ul>
<li> binary128 format is used by some HP-UX, SPARC, MIPS, ARM64, and z/OS implementations. </li>
<li> The most well known IEEE-754 binary64-extended format is 80-bit x87 extended precision format. It is used by many x86 and x86-64 implementations (a notable exception is MSVC, which implements <code>long double</code> in the same format as <code>double</code>, i.e. binary64). </li>
</ul> </dd>
</dl> <h4 id="Properties_2"> Properties</h4> <p>Floating-point types may support <a href="../types/numeric_limits" title="cpp/types/numeric limits">special values</a>:</p>
<ul>
<li> <i>infinity</i> (positive and negative), see <code><a href="../numeric/math/infinity" title="cpp/numeric/math/INFINITY">INFINITY</a></code> </li>
<li> the <i>negative zero</i>, <code>-0.0</code>. It compares equal to the positive zero, but is meaningful in some arithmetic operations, e.g. <code><span class="nu16">1.0</span><span class="sy2">/</span><span class="nu16">0.0</span> <span class="sy1">==</span> <a href="http://en.cppreference.com/w/cpp/numeric/math/INFINITY"><span class="kw1380">INFINITY</span></a></code>, but <code><span class="nu16">1.0</span><span class="sy2">/-</span><span class="nu16">0.0</span> <span class="sy1">==</span> <span class="sy2">-</span><a href="http://en.cppreference.com/w/cpp/numeric/math/INFINITY"><span class="kw1380">INFINITY</span></a></code>), and for some mathematical functions, e.g. <a href="../numeric/complex/sqrt" title="cpp/numeric/complex/sqrt"><code>sqrt(std::complex)</code></a> </li>
<li> <i>not-a-number</i> (NaN), which does not compare equal with anything (including itself). Multiple bit patterns represent NaNs, see <code><a href="../numeric/math/nan" title="cpp/numeric/math/nan">std::nan</a></code>, <code><a href="../numeric/math/nan" title="cpp/numeric/math/NAN">NAN</a></code>. Note that C++ takes no special notice of signalling NaNs other than detecting their support by <code><a href="../types/numeric_limits/has_signaling_nan" title="cpp/types/numeric limits/has signaling NaN">std::numeric_limits::has_signaling_NaN</a></code>, and treats all NaNs as quiet. </li>
</ul> <p>Real floating-point numbers may be used with <a href="operator_arithmetic" title="cpp/language/operator arithmetic">arithmetic operators</a> + - / * and various mathematical functions from <a href="../header/cmath" title="cpp/header/cmath"><code>&lt;cmath&gt;</code></a>. Both built-in operators and library functions may raise floating-point exceptions and set <code><a href="../error/errno" title="cpp/error/errno">errno</a></code> as described in <a href="../numeric/math/math_errhandling" title="cpp/numeric/math/math errhandling"><code>math errhandling</code></a>.</p>
<p>Floating-point expressions may have greater range and precision than indicated by their types, see <code><a href="../types/climits/flt_eval_method" title="cpp/types/climits/FLT EVAL METHOD">FLT_EVAL_METHOD</a></code>. Floating-point expressions may also be <i>contracted</i>, that is, calculated as if all intermediate values have infinite range and precision, see <a href="../preprocessor/impl#.23pragma_STDC" title="cpp/preprocessor/impl"><code> #pragma STDC FP_CONTRACT</code></a>. Standard C++ does not restrict the accuracy of floating-point operations.</p>
<p>Some operations on floating-point numbers are affected by and modify the state of <a href="../numeric/fenv" title="cpp/numeric/fenv">the floating-point environment</a> (most notably, the rounding direction).</p>
<p><a href="implicit_conversion" title="cpp/language/implicit conversion">Implicit conversions</a> are defined between real floating types and integer types.</p>
<p>See <a href="../types/climits#Limits_of_floating_point_types" title="cpp/types/climits">Limits of floating-point types</a> and <code><a href="../types/numeric_limits" title="cpp/types/numeric limits">std::numeric_limits</a></code> for additional details, limits, and properties of the floating-point types.</p>
<h3 id="Range_of_values"> Range of values</h3> <p>The following table provides a reference for the limits of common numeric representations.</p>
<p>Prior to C++20, the C++ Standard allowed any signed integer representation, and the minimum guaranteed range of N-bit signed integers was from \(\scriptsize -(2^{N-1}-1)\)-(2<span class="t-su">N-1<br></span>-1) to \(\scriptsize +2^{N-1}-1\)+2<span class="t-su">N-1<br></span>-1 (e.g. <b>-127</b> to <b>127</b> for a signed 8-bit type), which corresponds to the limits of <a href="https://en.wikipedia.org/wiki/Ones%27_complement" class="extiw" title="enwiki:Ones' complement">ones' complement</a> or <a href="https://en.wikipedia.org/wiki/Signed_number_representations#Sign-and-magnitude_method" class="extiw" title="enwiki:Signed number representations">sign-and-magnitude</a>.</p>
<p>However, all C++ compilers use <a href="https://en.wikipedia.org/wiki/Two%27s_complement" class="extiw" title="enwiki:Two's complement">two's complement</a> representation, and as of C++20, it is the only representation allowed by the standard, with the guaranteed range from \(\scriptsize -2^{N-1}\)-2<span class="t-su">N-1<br></span> to \(\scriptsize +2^{N-1}-1\)+2<span class="t-su">N-1<br></span>-1 (e.g. <b>-128</b> to <b>127</b> for a signed 8-bit type).</p>
<p>8-bit ones' complement and sign-and-magnitude representations for <code>char</code> have been disallowed since C++11 (via <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1759.html">CWG 1759</a>), because a UTF-8 code unit of value 0x80 used in a <a href="string_literal" title="cpp/language/string literal">UTF-8 string literal</a> must be storable in a <code>char</code> element object.</p>
<table class="wikitable"> <tr> <th rowspan="2"> Type </th> <th rowspan="2"> Size in bits </th> <th rowspan="2"> Format </th> <th colspan="2"> Value range </th>
</tr> <tr> <th> Approximate </th> <th> Exact </th>
</tr> <tr> <th rowspan="4"> character </th> <td rowspan="2"> 8 </td> <td> signed </td> <td> </td> <td> <b>-128</b> to <b>127</b> </td>
</tr> <tr> <td> unsigned </td> <td> </td> <td> <b>0</b> to <b>255</b> </td>
</tr> <tr> <td> 16 </td> <td> UTF-16 </td> <td> </td> <td> <b>0</b> to <b>65535</b> </td>
</tr> <tr> <td> 32 </td> <td> UTF-32 </td> <td> </td> <td> <b>0</b> to <b>1114111</b> (<b>0x10ffff</b>) </td>
</tr> <tr> <th rowspan="6"> integer </th> <td rowspan="2"> 16 </td> <td> signed </td> <td> <b>± 3.27 · 10<sup>4</sup></b> </td> <td> <b>-32768</b> to <b>32767</b> </td>
</tr> <tr> <td> unsigned </td> <td> <b>0</b> to <b>6.55 · 10<sup>4</sup></b> </td> <td> <b>0</b> to <b>65535</b> </td>
</tr> <tr> <td rowspan="2"> 32 </td> <td> signed </td> <td> <b>± 2.14 · 10<sup>9</sup></b> </td> <td> <b>-2,147,483,648</b> to <b>2,147,483,647</b> </td>
</tr> <tr> <td> unsigned </td> <td> <b>0</b> to <b>4.29 · 10<sup>9</sup></b> </td> <td> <b>0</b> to <b>4,294,967,295</b> </td>
</tr> <tr> <td rowspan="2"> 64 </td> <td> signed </td> <td> <b>± 9.22 · 10<sup>18</sup></b> </td> <td> <b>-9,223,372,036,854,775,808</b> to <b>9,223,372,036,854,775,807</b> </td>
</tr> <tr> <td> unsigned </td> <td> <b>0</b> to <b>1.84 · 10<sup>19</sup></b> </td> <td> <b>0</b> to <b>18,446,744,073,709,551,615</b> </td>
</tr> <tr> <th rowspan="4"> binary<br> floating<br> point </th> <td> 32 </td> <td> <a href="https://en.wikipedia.org/wiki/Single-precision_floating-point_format" class="extiw" title="enwiki:Single-precision floating-point format">IEEE-754</a> </td> <td> <ul>
<li>min subnormal:<br><b>± 1.401,298,4 · 10<sup>-45</sup></b> </li>
<li>min normal:<br><b>± 1.175,494,3 · 10<sup>-38</sup></b> </li>
<li>max:<br><b>± 3.402,823,4 · 10<sup>38</sup></b> </li>
</ul>  </td> <td> <ul>
<li>min subnormal:<br><b>±0x1p-149</b> </li>
<li>min normal:<br><b>±0x1p-126</b> </li>
<li>max:<br><b>±0x1.fffffep+127</b> </li>
</ul>  </td>
</tr> <tr> <td> 64 </td> <td> <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format" class="extiw" title="enwiki:Double-precision floating-point format">IEEE-754</a> </td> <td>  <ul>
<li>min subnormal:<br><b>± 4.940,656,458,412 · 10<sup>-324</sup></b> </li>
<li>min normal:<br><b>± 2.225,073,858,507,201,4 · 10<sup>-﻿308</sup></b> </li>
<li>max:<br><b>± 1.797,693,134,862,315,7 · 10<sup>308</sup></b> </li>
</ul>  </td> <td>  <ul>
<li>min subnormal:<br><b>±0x1p-1074</b> </li>
<li>min normal:<br><b>±0x1p-1022</b> </li>
<li>max:<br><b>±0x1.fffffffffffffp+1023</b> </li>
</ul>  </td>
</tr> <tr> <td> 80<sup id="cite_ref-1" class="reference"><a href="#cite_note-1">[note 1]</a></sup> </td> <td> <a href="https://en.wikipedia.org/wiki/Extended_precision" class="extiw" title="enwiki:Extended precision">x86</a> </td> <td>  <ul>
<li>min subnormal:<br><b>± 3.645,199,531,882,474,602,528<br> · 10<sup>-4951</sup></b> </li>
<li>min normal:<br><b>± 3.362,103,143,112,093,506,263<br> · 10<sup>-4932</sup></b> </li>
<li>max:<br><b>± 1.189,731,495,357,231,765,021<br> · 10<sup>4932</sup></b> </li>
</ul>  </td> <td>  <ul>
<li>min subnormal:<br><b>±0x1p-16446</b> </li>
<li>min normal:<br><b>±0x1p-16382</b> </li>
<li>max:<br><b>±0x1.fffffffffffffffep+16383</b> </li>
</ul>  </td>
</tr> <tr> <td> 128 </td> <td> <a href="https://en.wikipedia.org/wiki/Quadruple-precision_floating-point_format" class="extiw" title="enwiki:Quadruple-precision floating-point format">IEEE-754</a> </td> <td>  <ul>
<li>min subnormal:<br><b>± 6.475,175,119,438,025,110,924,<br>438,958,227,646,552,5 · 10<sup>-4966</sup></b> </li>
<li>min normal:<br><b>± 3.362,103,143,112,093,506,262,<br>677,817,321,752,602,6 · 10<sup>-4932</sup></b> </li>
<li>max:<br><b>± 1.189,731,495,357,231,765,085,<br>759,326,628,007,016,2 · 10<sup>4932</sup></b> </li>
</ul>  </td> <td>  <ul>
<li>min subnormal:<br><b>±0x1p-16494</b> </li>
<li>min normal:<br><b>±0x1p-16382</b> </li>
<li>max:<br><b>±0x1.ffffffffffffffffffffffffffff<br>p+16383</b> </li>
</ul>  </td>
</tr>
</table> <ol class="references"> <li id="cite_note-1"> <span class="reference-text">The object representation usually occupies 96/128 bits on 32/64-bit platforms respectively.</span> </li> </ol> <p>Note: actual (as opposed to guaranteed minimal) limits on the values representable by these types are available in <a href="../types/climits" title="cpp/types/climits">C numeric limits interface</a> and <code><a href="../types/numeric_limits" title="cpp/types/numeric limits">std::numeric_limits</a></code>.</p>
<h3 id="Keywords"> Keywords</h3> <p><a href="../keyword/void" title="cpp/keyword/void"><code>void</code></a>, <a href="../keyword/bool" title="cpp/keyword/bool"><code>bool</code></a>, <a href="../keyword/true" title="cpp/keyword/true"><code>true</code></a>, <a href="../keyword/false" title="cpp/keyword/false"><code>false</code></a>, <a href="../keyword/char" title="cpp/keyword/char"><code>char</code></a>, <a href="../keyword/wchar_t" title="cpp/keyword/wchar t"><code>wchar_t</code></a>, <span class="t-rev-inl t-since-cxx20"><span><a href="../keyword/char8_t" title="cpp/keyword/char8 t"><code>char8_t</code></a>, </span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span> <span class="t-rev-inl t-since-cxx11"><span><a href="../keyword/char16_t" title="cpp/keyword/char16 t"><code>char16_t</code></a>, <a href="../keyword/char32_t" title="cpp/keyword/char32 t"><code>char32_t</code></a>, </span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span> <a href="../keyword/int" title="cpp/keyword/int"><code>int</code></a>, <a href="../keyword/short" title="cpp/keyword/short"><code>short</code></a>, <a href="../keyword/long" title="cpp/keyword/long"><code>long</code></a>, <a href="../keyword/signed" title="cpp/keyword/signed"><code>signed</code></a>, <a href="../keyword/unsigned" title="cpp/keyword/unsigned"><code>unsigned</code></a>, <a href="../keyword/float" title="cpp/keyword/float"><code>float</code></a>, <a href="../keyword/double" title="cpp/keyword/double"><code>double</code></a>.</p>
<h3 id="Defect_reports"> Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th> DR </th> <th> Applied to </th> <th> Behavior as published </th> <th> Correct behavior </th>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/238.html">CWG 238</a> </td> <td> C++98 </td> <td> the constraints placed on a floating-point implementation was unspecified </td> <td> specified as no constraint </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1759.html">CWG 1759</a> </td> <td> C++11 </td> <td> <code>char</code> is not guaranteed to be able to represent UTF-8 code unit 0x80 </td> <td> guaranteed </td>
</tr>
</table> <h3 id="See_also"> See also</h3> <ul>
<li> <a href="type" title="cpp/language/type">the C++ type system overview</a> </li>
<li> <a href="cv" title="cpp/language/cv">const-volatility (cv) specifiers and qualifiers</a> </li>
<li> <a href="storage_duration" title="cpp/language/storage duration">storage duration specifiers</a> </li>
</ul> <table class="t-dsc-begin"> <tr class="t-dsc"> <td colspan="2"> <span><a href="https://en.cppreference.com/w/c/language/arithmetic_types" title="c/language/arithmetic types">C documentation</a></span> for <span class=""><span>arithmetic types</span></span> </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    © cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/language/types" class="_attribution-link">https://en.cppreference.com/w/cpp/language/types</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
