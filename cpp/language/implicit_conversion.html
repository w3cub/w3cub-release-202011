
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Implicit Conversions - C++ - W3cubDocs</title>
  
  <meta name="description" content="Implicit conversions are performed whenever an expression of some type T1 is used in context that does not accept that type, but accepts some other &hellip;">
  <meta name="keywords" content="implicit, conversions, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/language/implicit_conversion.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-9c7b0d969c0ce639a6c01c2badcdd81667c7c66206aa3d0fccc5cb0585fb1b912dab72ea882101d18010680927514b4b77b107282db8f756fbf63301fe9c88b0.css">
  <script type="text/javascript" src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js"></script>
  <script src="/json/cpp.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _cppref">
				
				
<h1 id="firstHeading" class="firstHeading">Implicit conversions</h1>            <p>Implicit conversions are performed whenever an expression of some type <code>T1</code> is used in context that does not accept that type, but accepts some other type <code>T2</code>; in particular:</p>
<ul>
<li> when the expression is used as the argument when calling a function that is declared with <code>T2</code> as parameter; </li>
<li> when the expression is used as an operand with an operator that expects <code>T2</code>; </li>
<li> when initializing a new object of type <code>T2</code>, including <code>return</code> statement in a function returning <code>T2</code>; </li>
<li> when the expression is used in a <code>switch</code> statement (<code>T2</code> is integral type); </li>
<li> when the expression is used in an <code>if</code> statement or a loop (<code>T2</code> is <span class="kw4">bool</span>). </li>
</ul> <p>The program is well-formed (compiles) only if there exists one unambiguous <i>implicit conversion sequence</i> from <code>T1</code> to <code>T2</code>.</p>
<p>If there are multiple overloads of the function or operator being called, after the implicit conversion sequence is built from <code>T1</code> to each available <code>T2</code>, <a href="overload_resolution" title="cpp/language/overload resolution">overload resolution</a> rules decide which overload is compiled.</p>
<p>Note: in arithmetic expressions, the destination type for the implicit conversions on the operands to binary operators is determined by a separate set of rules: <a href="usual_arithmetic_conversions" title="cpp/language/usual arithmetic conversions">usual arithmetic conversions</a>.</p>
<h3 id="Order_of_the_conversions"> Order of the conversions</h3> <p>Implicit conversion sequence consists of the following, in this order:</p>
<div class="t-li1">
<span class="t-li">1)</span> zero or one <i>standard conversion sequence</i>;</div> <div class="t-li1">
<span class="t-li">2)</span> zero or one <i>user-defined conversion</i>;</div> <div class="t-li1">
<span class="t-li">3)</span> zero or one <i>standard conversion sequence</i> (only if a user-defined conversion is used).</div> <p>When considering the argument to a constructor or to a user-defined conversion function, only one standard conversion sequence is allowed (otherwise user-defined conversions could be effectively chained). When converting from one non-class type to another non-class type, only a standard conversion sequence is allowed.</p>
<p>A standard conversion sequence consists of the following, in this order:</p>
<div class="t-li1">
<span class="t-li">1)</span> zero or one conversion from the following set: <i>lvalue-to-rvalue conversion</i>, <i>array-to-pointer conversion</i>, and <i>function-to-pointer conversion</i>;</div> <div class="t-li1">
<span class="t-li">2)</span> zero or one <i>numeric promotion</i> or <i>numeric conversion</i>;</div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <span class="t-li">3)</span> zero or one <i>function pointer conversion</i>; </td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <div class="t-li1">
<span class="t-li">4)</span> zero or one <i>qualification conversion</i>.</div> <p>A user-defined conversion consists of zero or one non-explicit single-argument <a href="converting_constructor" title="cpp/language/converting constructor">converting constructor</a> or non-explicit <a href="cast_operator" title="cpp/language/cast operator">conversion function</a> call.</p>
<p>An expression <code>e</code> is said to be <i>implicitly convertible to <code>T2</code></i> if and only if <code>T2</code> can be <a href="copy_initialization" title="cpp/language/copy initialization">copy-initialized</a> from <code>e</code>, that is the declaration <code>T2 t = e;</code> is well-formed (can be compiled), for some invented temporary <code>t</code>. Note that this is different from <a href="direct_initialization" title="cpp/language/direct initialization">direct initialization</a> (<code>T2 t(e)</code>), where explicit constructors and conversion functions would additionally be considered.</p>
<h4 id="Contextual_conversions"> Contextual conversions</h4> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>In the following contexts, the type <span class="kw4">bool</span> is expected and the implicit conversion is performed if the declaration <code>bool t(e);</code> is well-formed (that is, an explicit conversion function such as <code>explicit T::operator bool() const;</code> is considered). Such expression <code>e</code> is said to be <i>contextually converted to <span class="kw4">bool</span></i>.</p>
<ul>
<li> the controlling expression of <span class="kw1">if</span>, <span class="kw1">while</span>, <span class="kw1">for</span>; </li>
<li> the operands of the built-in logical operators <code>!</code>, <code>&amp;&amp;</code> and <code>||</code>; </li>
<li> the first operand of the conditional operator <code>?:</code>; </li>
<li> the predicate in a <a href="static_assert" title="cpp/language/static assert"><code>static_assert</code></a> declaration; </li>
<li> the expression in a <a href="noexcept_spec" title="cpp/language/noexcept spec"><code>noexcept</code></a> specifier; </li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <ul><li> the expression in an <a href="explicit" title="cpp/language/explicit"><code>explicit</code></a> specifier; </li></ul> </td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <p>In the following contexts, a context-specific type <code>T</code> is expected, and the expression <code>e</code> of class type <code>E</code> is only allowed if.</p>
<table class="t-rev-begin"> <tr class="t-rev t-until-cxx14">
<td> <ul><li> <code>E</code> has a single <span class="t-rev-inl t-since-cxx11"><span>non-explicit</span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span> <a href="cast_operator" title="cpp/language/cast operator">user-defined conversion function</a> to an allowable type. </li></ul> </td> <td><span class="t-mark-rev t-until-cxx14">(until C++14)</span></td>
</tr> <tr class="t-rev t-since-cxx14">
<td> <ul>
<li> there is exactly one type <code>T</code> among the allowable types such that <code>E</code> has non-explicit conversion functions whose return types are (possibly cv-qualified) <code>T</code> or reference to (possibly cv-qualified) <code>T</code>, and </li>
<li> <code>e</code> is implicitly convertible to <code>T</code>. </li>
</ul> </td> <td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr> </table> <p>Such expression <code>e</code> is said to be <i>contextually implicitly converted</i> to the specified type <code>T</code>. <span class="t-rev-inl t-since-cxx11"><span>Note that explicit conversion functions are not considered, even though they are considered in contextual conversions to <code>bool</code>.</span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>.</p>
<ul>
<li> the argument of the <a href="delete" title="cpp/language/delete">delete-expression</a> (<code>T</code> is any object pointer type); </li>
<li> <a href="constant_expression#Integral_constant_expression" title="cpp/language/constant expression">integral constant expression</a>, where a literal class is used (<code>T</code> is any integral or unscoped enumeration type, the selected user-defined conversion function must be <a href="constexpr" title="cpp/language/constexpr">constexpr</a>); </li>
<li> the controlling expression of the <a href="switch" title="cpp/language/switch"><code>switch</code></a> statement (<code>T</code> is any integral or enumeration type). </li>
</ul> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;cassert&gt;
 
template&lt;typename T&gt;
class zero_init
{
    T val;
public:
    zero_init() : val(static_cast&lt;T&gt;(0)) {}
    zero_init(T val) : val(val) {}
    operator T&amp;() { return val; }
    operator T() const { return val; }
};
 
int main()
{
    zero_init&lt;int&gt; i;
    assert(i == 0);
 
    i = 7;
    assert(i == 7);
 
    switch (i) {}     // error until C++14 (more than one conversion function)
                      // OK since C++14 (both functions convert to the same type int)
    switch (i + 0) {} // always okay (implicit conversion)
}</pre></div> <h3 id="Value_transformations"> Value transformations</h3> <p>Value transformations are conversions that change the <a href="value_category" title="cpp/language/value category">value category</a> of an expression. They take place whenever an expression appears as an operand of an operator that expects an expression of a different value category.</p>
<h4 id="Lvalue-to-rvalue_conversion"> Lvalue-to-rvalue conversion</h4> <p> <span class="t-rev-inl t-until-cxx11"><span>An <a href="value_category#lvalue" title="cpp/language/value category">lvalue</a></span> <span><span class="t-mark-rev t-until-cxx11">(until C++11)</span></span></span><span class="t-rev-inl t-since-cxx11"><span>A <a href="value_category#glvalue" title="cpp/language/value category">glvalue</a></span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span> of any non-function, non-array type <code>T</code> can be implicitly converted to <span class="t-rev-inl t-until-cxx11"><span>an <a href="value_category#rvalue" title="cpp/language/value category">rvalue</a></span> <span><span class="t-mark-rev t-until-cxx11">(until C++11)</span></span></span><span class="t-rev-inl t-since-cxx11"><span>a <a href="value_category#prvalue" title="cpp/language/value category">prvalue</a></span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>:</p>
<ul>
<li> If <code>T</code> is not a class type, the type of the <span class="t-rev-inl t-until-cxx11"><span>rvalue</span> <span><span class="t-mark-rev t-until-cxx11">(until C++11)</span></span></span><span class="t-rev-inl t-since-cxx11"><span>prvalue</span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span> is the cv-unqualified version of <code>T</code>. </li>
<li> Otherwise, the type of the <span class="t-rev-inl t-until-cxx11"><span>rvalue</span> <span><span class="t-mark-rev t-until-cxx11">(until C++11)</span></span></span><span class="t-rev-inl t-since-cxx11"><span>prvalue</span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span> is <code>T</code>. </li>
</ul> <p>If an lvalue-to-rvalue conversion from an <a href="type#Incomplete_type" title="cpp/language/type">incomplete type</a> is required by a program, that program is ill-formed.</p>
<table class="t-rev-begin"> <tr class="t-rev t-until-cxx11">
<td> <p>When an lvalue-to-rvalue conversion occurs within the operand of <a href="sizeof" title="cpp/language/sizeof"><code>sizeof</code></a>, the value contained in the referenced object is not accessed, since that operator <a href="expressions#Potentially-evaluated_expressions" title="cpp/language/expressions">does not evaluate</a> its operand.</p>
</td> <td><span class="t-mark-rev t-until-cxx11">(until C++11)</span></td>
</tr> <tr class="t-rev t-since-cxx11">
<td> <p>When an lvalue-to-rvalue conversion is applied to an expression <code>E</code>, the value contained in the referenced object is not accessed if:</p>
<ul>
<li> <code>E</code> is not <a href="expressions#Potentially-evaluated_expressions" title="cpp/language/expressions">potentially evaluated</a>, or </li>
<li> the evaluation of <code>E</code> results in the evaluation of a member <code>Ex</code> of the set of <a href="definition#ODR-use" title="cpp/language/definition">potential results</a> of <code>E</code>, and <code>Ex</code> names a variable <code>x</code> that is not <a href="definition#ODR-use" title="cpp/language/definition">odr-used</a> by <code>Ex</code>. </li>
</ul> </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx11">
<td> <p>The result of the conversion is the value contained in the object indicated by the lvalue.</p>
</td> <td><span class="t-mark-rev t-until-cxx11">(until C++11)</span></td>
</tr> <tr class="t-rev t-since-cxx11">
<td> <p>The result of the conversion is determined according to the following rules:</p>
<ul>
<li> If <code>T</code> is (possibly cv-qualified) <code><a href="../types/nullptr_t" title="cpp/types/nullptr t">std::nullptr_t</a></code>, the result is a <a href="pointer#Null_pointers" title="cpp/language/pointer">null pointer constant</a>. The object to which the glvalue refers is not accessed by the conversion, so there is no side effect even if <code>T</code> is volatile-qualified, and the glvalue can refer to an inactive member of a union. </li>
<li> Otherwise, if T has a class type, </li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx17">
<td> <ul><li> the conversion <a href="copy_initialization" title="cpp/language/copy initialization">copy-initializes</a> a <a href="lifetime#Temporary_object_lifetime" title="cpp/language/lifetime">temporary</a> of type <code>T</code> from the glvalue, and the result of the conversion is a prvalue for the temporary. </li></ul> </td> <td><span class="t-mark-rev t-until-cxx17">(until C++17)</span></td>
</tr> <tr class="t-rev t-since-cxx17">
<td> <ul><li> the conversion <a href="copy_initialization" title="cpp/language/copy initialization">copy-initializes</a> the <a href="#Temporary_materialization">result object</a> from the glvalue. </li></ul> </td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <ul>
<li> Otherwise, if the object to which the glvalue refers contains an invalid pointer value, the behavior is implementation-defined. </li>
<li> Otherwise, <span class="t-rev-inl t-since-cxx20"><span>the object indicated by the glvalue is read, and</span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span> the result is the value contained in the object. </li>
</ul> </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <p>This conversion models the act of reading a value from a memory location into a CPU register.</p>
<h4 id="Array-to-pointer_conversion"> Array-to-pointer conversion</h4> <p> An <a href="value_category#lvalue" title="cpp/language/value category">lvalue</a> or <a href="value_category#rvalue" title="cpp/language/value category">rvalue</a> of type "array of <code>N</code> <code>T</code>" or "array of unknown bound of <code>T</code>" can be implicitly converted to a <a href="value_category#prvalue" title="cpp/language/value category">prvalue</a> of type "pointer to <code>T</code>". <span class="t-rev-inl t-since-cxx17"><span>If the array is a prvalue, <a href="#Temporary_materialization">temporary materialization</a> occurs.</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> The resulting pointer refers to the first element of the array (see <a href="array#Array-to-pointer_decay" title="cpp/language/array">array to pointer decay</a> for details).</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <h4 id="Temporary_materialization"> Temporary materialization</h4> <p>A <a href="value_category#prvalue" title="cpp/language/value category">prvalue</a> of any complete type <code>T</code> can be converted to an xvalue of the same type <code>T</code>. This conversion initializes a <a href="lifetime#Temporary_object_lifetime" title="cpp/language/lifetime">temporary object</a> of type T from the prvalue by evaluating the prvalue with the temporary object as its result object, and produces an xvalue denoting the temporary object. If <code>T</code> is a class or array of class type, it must have an accessible and non-deleted destructor.</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct S { int m; };
int i = S().m; // member access expects glvalue as of C++17;
               // S() prvalue is converted to xvalue</pre></div> <p>Temporary materialization occurs in the following situations:</p>
<ul>
<li> when <a href="reference_initialization" title="cpp/language/reference initialization">binding a reference</a> to a prvalue; </li>
<li> when performing a <a href="operator_member_access" title="cpp/language/operator member access">member access</a> on a class prvalue; </li>
<li> when performing an array-to-pointer conversion (see above) or <a href="operator_member_access#Built-in_subscript_operator" title="cpp/language/operator member access">subscripting</a> on an array prvalue; </li>
<li> when initializing an object of type <code>std::initializer_list&lt;T&gt;</code> from a <a href="list_initialization" title="cpp/language/list initialization">braced-init-list</a>; </li>
<li> when <a href="typeid" title="cpp/language/typeid"><code>typeid</code></a> is applied to a prvalue (this is part of an unevaluated expression); </li>
<li> when <a href="sizeof" title="cpp/language/sizeof"><code>sizeof</code></a> is applied to a prvalue (this is part of an unevaluated expression); </li>
<li> when a prvalue appears as a <a href="expressions#Discarded-value_expressions" title="cpp/language/expressions">discarded-value expression</a>. </li>
</ul> <p>Note that temporary materialization does <i>not</i> occur when initializing an object from a prvalue of the same type (by <a href="direct_initialization" title="cpp/language/direct initialization">direct-initialization</a> or <a href="copy_initialization" title="cpp/language/copy initialization">copy-initialization</a>): such object is initialized directly from the initializer. This ensures "guaranteed copy elision".</p>
</td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <h4 id="Function-to-pointer_conversion"> Function-to-pointer conversion</h4> <p> An <a href="value_category#lvalue" title="cpp/language/value category">lvalue</a> of function type <code>T</code> can be implicitly converted to a <a href="value_category#prvalue" title="cpp/language/value category">prvalue</a> <a href="pointer#Pointers_to_functions" title="cpp/language/pointer">pointer to that function</a>. This does not apply to non-static member functions because lvalues that refer to non-static member functions do not exist.</p>
<h3 id="Numeric_promotions"> Numeric promotions</h3> <h4 id="Integral_promotion"> Integral promotion</h4> <p><a href="value_category#prvalue" title="cpp/language/value category">prvalues</a> of small integral types (such as <span class="kw4">char</span>) may be converted to prvalues of larger integral types (such as <span class="kw4">int</span>). In particular, <a href="operator_arithmetic" title="cpp/language/operator arithmetic">arithmetic operators</a> do not accept types smaller than <span class="kw4">int</span> as arguments, and integral promotions are automatically applied after lvalue-to-rvalue conversion, if applicable. This conversion always preserves the value.</p>
<p>The following implicit conversions are classified as integral promotions:</p>
<ul>
<li> <span class="kw4">char</span>, <span class="kw4">signed</span> <span class="kw4">char</span>, <span class="kw4">unsigned</span> <span class="kw4">char</span>, <span class="kw4">short</span> and <span class="kw4">unsigned</span> <span class="kw4">short</span> can be converted to <span class="kw4">int</span> if their respective entire value range can be held by the type <span class="kw4">int</span>, or <span class="kw4">unsigned</span> <span class="kw4">int</span> otherwise; </li>
<li> <span class="kw4">wchar_t</span><span class="t-rev-inl t-since-cxx20"><span>, <code>char8_t</code></span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span><span class="t-rev-inl t-since-cxx11"><span>, <code>char16_t</code>, and <code>char32_t</code></span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span> can be converted to the first type from the following list able to hold their entire value range: </li>
<ul>
<li> <span class="kw4">int</span> </li>
<li> <span class="kw4">unsigned</span> <span class="kw4">int</span> </li>
<li> <span class="kw4">long</span> </li>
<li> <span class="kw4">unsigned</span> <span class="kw4">long</span> </li>
</ul>
</ul>   <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul>
<li> <span class="kw4">long</span> <span class="kw4">long</span> </li>
<li> <span class="kw4">unsigned</span> <span class="kw4">long</span> <span class="kw4">long</span> </li>
</ul>  </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td>  If none of the types in the list can represent all the values of its underlying type, <span class="kw4">wchar_t</span><span class="t-rev-inl t-since-cxx20"><span>, <code>char8_t</code></span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span>, <span class="kw4">char16_t</span>, and <span class="kw4">char32_t</span> can be converted to its underlying type.   </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <ul>
<li> an unscoped <a href="enum" title="cpp/language/enum">enumeration</a> type whose underlying type is not fixed can be converted to the first type from the following list able to hold their entire value range: </li>
<ul>
<li> <span class="kw4">int</span> </li>
<li> <span class="kw4">unsigned</span> <span class="kw4">int</span> </li>
<li> <span class="kw4">long</span> </li>
<li> <span class="kw4">unsigned</span> <span class="kw4">long</span> </li>
</ul>
</ul>   <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul>
<li> <span class="kw4">long</span> <span class="kw4">long</span> </li>
<li> <span class="kw4">unsigned</span> <span class="kw4">long</span> <span class="kw4">long</span> </li>
</ul>  </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td>  If none of the types in the list can represent all the values of the enumeration, the unscoped enumeration type can be converted to the <a href="types#Extended_integer_types" title="cpp/language/types">extended integer type</a> with lowest <a href="usual_arithmetic_conversions#Integer_conversion_rank" title="cpp/language/usual arithmetic conversions">integer conversion rank</a> greater than the rank of <span class="kw4">long</span> <span class="kw4">long</span> in which all the values of the enumeration can be represented. If there are two such extended types, the signed one is chosen.   </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <ul>
<li> an unscoped enumeration type whose underlying type is fixed can be converted to its underlying type, and, if the underlying type is also subject to integral promotion, to the promoted underlying type. Conversion to the unpromoted underlying type is better for the purposes of <a href="overload_resolution" title="cpp/language/overload resolution">overload resolution</a>; </li>
<li> a <a href="bit_field" title="cpp/language/bit field">bit-field</a> type can be converted to <span class="kw4">int</span> if it can represent entire value range of the bit-field, otherwise to <span class="kw4">unsigned</span> <span class="kw4">int</span> if it can represent entire value range of the bit-field, otherwise no integral promotions apply; </li>
<li> the type <span class="kw4">bool</span> can be converted to <span class="kw4">int</span> with the value <code>false</code> becoming <code>​0​</code> and <code>true</code> becoming <code>1</code>. </li>
</ul> <p>Note that all other conversions are not promotions; for example, <a href="overload_resolution" title="cpp/language/overload resolution">overload resolution</a> chooses <span class="kw4">char</span> -&gt; <span class="kw4">int</span> (promotion) over <span class="kw4">char</span> -&gt; <span class="kw4">short</span> (conversion).</p>
<h4 id="Floating-point_promotion"> Floating-point promotion</h4> <p>A <a href="value_category#prvalue" title="cpp/language/value category">prvalue</a> of type <span class="kw4">float</span> can be converted to a prvalue of type <span class="kw4">double</span>. The value does not change.</p>
<h3 id="Numeric_conversions"> Numeric conversions</h3> <p>Unlike the promotions, numeric conversions may change the values, with potential loss of precision.</p>
<h4 id="Integral_conversions"> Integral conversions</h4> <p>A <a href="value_category#prvalue" title="cpp/language/value category">prvalue</a> of an integer type or of an unscoped enumeration type can be converted to any other integer type. If the conversion is listed under integral promotions, it is a promotion and not a conversion.</p>
<ul><li> If the destination type is unsigned, the resulting value is the smallest unsigned value equal to the source value <a href="https://en.wikipedia.org/wiki/Modular_arithmetic" class="extiw" title="enwiki:Modular arithmetic">modulo</a> 2<span class="t-su">n<br></span> where n is the number of bits used to represent the destination type. </li></ul>  That is, depending on whether the destination type is wider or narrower, signed integers are sign-extended<sup id="cite_ref-1" class="reference"><a href="#cite_note-1">[footnote 1]</a></sup> or truncated and unsigned integers are zero-extended or truncated respectively.  <ul>
<li> If the destination type is signed, the value does not change if the source integer can be represented in the destination type. Otherwise the result is <span class="t-rev-inl t-until-cxx20"><span>implementation-defined</span> <span><span class="t-mark-rev t-until-cxx20">(until C++20)</span></span></span><span class="t-rev-inl t-since-cxx20"><span>the unique value of the destination type equal to the source value modulo 2<span class="t-su">n<br></span> where n is the number of bits used to represent the destination type</span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span> (note that this is different from <a href="operator_arithmetic#Overflows" title="cpp/language/operator arithmetic">signed integer arithmetic overflow</a>, which is undefined). </li>
<li> If the source type is <span class="kw4">bool</span>, the value <code>false</code> is converted to zero and the value <code>true</code> is converted to the value one of the destination type (note that if the destination type is <span class="kw4">int</span>, this is an integer promotion, not an integer conversion). </li>
<li> If the destination type is <span class="kw4">bool</span>, this is a <a href="#Boolean_conversions">boolean conversion</a> (see below). </li>
</ul>  <h4 id="Floating-point_conversions"> Floating-point conversions</h4> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx23">
<td> <p>A <a href="value_category#prvalue" title="cpp/language/value category">prvalue</a> of a floating-point type can be converted to a prvalue of any other floating-point type.</p>
</td> <td><span class="t-mark-rev t-until-cxx23">(until C++23)</span></td>
</tr> <tr class="t-rev t-since-cxx23">
<td> <p>A <a href="value_category#prvalue" title="cpp/language/value category">prvalue</a> of a floating-point type can be converted to a prvalue of any other floating-point type with a greater or equal <a href="usual_arithmetic_conversions#Floating-point_conversion_rank" title="cpp/language/usual arithmetic conversions">floating-point conversion rank</a>.</p>
<p>A <a href="value_category#prvalue" title="cpp/language/value category">prvalue</a> of a standard floating-point type can be converted to a prvalue of any other standard floating-point type.</p>
<p><a href="static_cast" title="cpp/language/static cast"><code>static_cast</code></a> can be used to explicitly convert a prvalue of floating-point type to any other floating-point type.</p>
</td> <td><span class="t-mark-rev t-since-cxx23">(since C++23)</span></td>
</tr> </table> <p>If the conversion is listed under floating-point promotions, it is a promotion and not a conversion.</p>
<ul>
<li> If the source value can be represented exactly in the destination type, it does not change. </li>
<li> If the source value is between two representable values of the destination type, the result is one of those two values (it is implementation-defined which one, although if IEEE arithmetic is supported, rounding defaults <a href="../numeric/fenv/fe_round" title="cpp/numeric/fenv/FE round">to nearest</a>). </li>
<li> Otherwise, the behavior is undefined. </li>
</ul> <h4 id="Floating.E2.80.93integral_conversions"> Floating–integral conversions</h4> <ul>
<li> A <a href="value_category#prvalue" title="cpp/language/value category">prvalue</a> of floating-point type can be converted to a prvalue of any integer type. The fractional part is truncated, that is, the fractional part is discarded. If the value cannot fit into the destination type, the behavior is undefined (even when the destination type is unsigned, modulo arithmetic does not apply). If the destination type is <span class="kw4">bool</span>, this is a boolean conversion (see below). </li>
<li> A prvalue of integer or unscoped enumeration type can be converted to a prvalue of any floating-point type. The result is exact if possible. If the value can fit into the destination type but cannot be represented exactly, it is implementation defined whether the closest higher or the closest lower representable value will be selected, although if IEEE arithmetic is supported, rounding defaults <a href="../numeric/fenv/fe_round" title="cpp/numeric/fenv/FE round">to nearest</a>. If the value cannot fit into the destination type, the behavior is undefined. If the source type is <span class="kw4">bool</span>, the value <code>false</code> is converted to zero, and the value <code>true</code> is converted to one. </li>
</ul> <h4 id="Pointer_conversions"> Pointer conversions</h4> <ul>
<li> A <i>null pointer constant</i> (see <code><a href="../types/null" title="cpp/types/NULL">NULL</a></code>), can be converted to any pointer type, and the result is the null pointer value of that type. Such conversion (known as <i>null pointer conversion</i>) is allowed to convert to a cv-qualified type as a single conversion, that is, it's not considered a combination of numeric and qualifying conversions. </li>
<li> A <a href="value_category#prvalue" title="cpp/language/value category">prvalue</a> pointer to any (optionally cv-qualified) object type <code>T</code> can be converted to a prvalue pointer to (identically cv-qualified) <span class="kw4">void</span>. The resulting pointer represents the same location in memory as the original pointer value. If the original pointer is a null pointer value, the result is a null pointer value of the destination type. </li>
<li> A prvalue pointer to a (optionally cv-qualified) derived complete class type can be converted to a prvalue pointer to its (identically cv-qualified) base class. If the base class is inaccessible or ambiguous, the conversion is ill-formed (won't compile). The result of the conversion is a pointer to the base class subobject within the pointed-to object. The null pointer value is converted to the null pointer value of the destination type. </li>
</ul> <h4 id="Pointer-to-member_conversions"> Pointer-to-member conversions</h4> <ul>
<li> A <i>null pointer constant</i> (see <code><a href="../types/null" title="cpp/types/NULL">NULL</a></code>) can be converted to any pointer-to-member type, and the result is the null member pointer value of that type. Such conversion (known as <i>null member pointer conversion</i>) is allowed to convert to a cv-qualified type as a single conversion, that is, it's not considered a combination of numeric and qualifying conversions. </li>
<li> A <a href="value_category#prvalue" title="cpp/language/value category">prvalue</a> pointer to member of some type <code>T</code> in a base class <code>B</code> can be converted to a <a href="value_category#prvalue" title="cpp/language/value category">prvalue</a> pointer to member of the same type <code>T</code> in its derived complete class <code>D</code>. If <code>B</code> is inaccessible, ambiguous, or virtual base of <code>D</code> or is a base of some intermediate virtual base of <code>D</code>, the conversion is ill-formed (won't compile). The resulting pointer can be dereferenced with a <code>D</code> object, and it will access the member within the <code>B</code> base subobject of that <code>D</code> object. The null pointer value is converted to the null pointer value of the destination type. </li>
</ul> <h4 id="Boolean_conversions"> Boolean conversions</h4> <p>A <a href="value_category#prvalue" title="cpp/language/value category">prvalue</a> of integral, floating-point, unscoped enumeration, pointer, and pointer-to-member types can be converted to a prvalue of type <span class="kw4">bool</span>.</p>
<p>The value zero (for integral, floating-point, and unscoped enumeration) and the null pointer and the null pointer-to-member values become <code>false</code>. All other values become <code>true</code>.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>In the context of a <a href="direct_initialization" title="cpp/language/direct initialization">direct-initialization</a>, a <span class="kw4">bool</span> object may be initialized from a prvalue of type <code><a href="../types/nullptr_t" title="cpp/types/nullptr t">std::nullptr_t</a></code>, including <code>nullptr</code>. The resulting value is <code>false</code>. However, this is not considered to be an implicit conversion.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <h3 id="Qualification_conversions"> Qualification conversions</h3> <ul>
<li> A <a href="value_category#prvalue" title="cpp/language/value category">prvalue</a> of type pointer to <a href="cv" title="cpp/language/cv">cv-qualified</a> type <code>T</code> can be converted to a prvalue pointer to a more cv-qualified same type <code>T</code> (in other words, constness and volatility can be added). </li>
<li> A prvalue of type pointer to member of cv-qualified type <code>T</code> in class <code>X</code> can be converted to a prvalue pointer to member of more cv-qualified type <code>T</code> in class <code>X</code>. </li>
</ul> <p>"More" cv-qualified means that.</p>
<ul>
<li> a pointer to <i>unqualified</i> type can be converted to a pointer to <span class="kw4">const</span>; </li>
<li> a pointer to <i>unqualified</i> type can be converted to a pointer to <span class="kw4">volatile</span>; </li>
<li> a pointer to <i>unqualified</i> type can be converted to a pointer to <span class="kw4">const</span> <span class="kw4">volatile</span>; </li>
<li> a pointer to <span class="kw4">const</span> type can be converted to a pointer to <span class="kw4">const</span> <span class="kw4">volatile</span>; </li>
<li> a pointer to <span class="kw4">volatile</span> type can be converted to a pointer to <span class="kw4">const</span> <span class="kw4">volatile</span>. </li>
</ul> <p>For multi-level pointers, the following restrictions apply: a multilevel pointer <code>P1</code> which is cv<span class="t-su t-su-b">1<br>0</span>-qualified pointer to cv<span class="t-su t-su-b">1<br>1</span>-qualified pointer to ... cv<span class="t-su t-su-b">1<br>n-1</span>-qualified pointer to cv<span class="t-su t-su-b">1<br>n</span>-qualified <code>T</code> is convertible to a multilevel pointer <code>P2</code> which is cv<span class="t-su t-su-b">2<br>0</span>-qualified pointer to cv<span class="t-su t-su-b">2<br>1</span>-qualified pointer to ... cv<span class="t-su t-su-b">2<br>n-1</span>-qualified pointer to cv<span class="t-su t-su-b">2<br>n</span>-qualified <code>T</code> only if.</p>
<ul><li> the number of levels <code>n</code> is the same for both pointers; </li></ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <ul><li> at every level that array type is involved in, at least one array type has unknown bound, or both array types have same size; </li></ul> </td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <ul>
<li> if there is a <span class="kw4">const</span> in the cv<span class="t-su t-su-b">1<br>k</span> qualification at some level (other than level zero) of <code>P1</code>, there is a <span class="kw4">const</span> in the same level cv<span class="t-su t-su-b">2<br>k</span> of <code>P2</code>; </li>
<li> if there is a <span class="kw4">volatile</span> in the cv<span class="t-su t-su-b">1<br>k</span> qualification at some level (other than level zero) of <code>P1</code>, there is a <span class="kw4">volatile</span> in the same cv<span class="t-su t-su-b">2<br>k</span> level of <code>P2</code>; </li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <ul><li> if there is an array type of unknown bound at some level (other than level zero) of <code>P1</code>, there is an array type of unknown bound in the same level of <code>P2</code>; </li></ul> </td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <ul>
<li> if at some level <code>k</code> the <code>P2</code> is <i>more</i> cv-qualified than <code>P1</code><span class="t-rev-inl t-since-cxx20"><span> or there is an array type of known bound in <code>P1</code> and an array type of unknown bound in <code>P2</code></span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span>, then there must be a <span class="kw4">const</span> at every single level (other than level zero) of <code>P2</code> up until k: cv<span class="t-su t-su-b">2<br>1</span>, cv<span class="t-su t-su-b">2<br>2</span> ... cv<span class="t-su t-su-b">2<br>k</span>. </li>
<li> same rules apply to multi-level pointers to members and multi-level mixed pointers to objects and pointers to members; </li>
<li> same rules apply to multi-level pointers that include pointers to array of known or unknown bound at any level (arrays of cv-qualified elements are considered to be identically cv-qualified themselves); </li>
<li> level zero is addressed by the rules for non-multilevel qualification conversions. </li>
</ul> <div class="cpp source-cpp"><pre data-language="cpp">char** p = 0;
const char** p1 = p; // error: level 2 more cv-qualified but level 1 is not const
const char* const * p2 = p; // OK: level 2 more cv-qualified and const added at level 1
volatile char * const * p3 = p; // OK: level 2 more cv-qual and const added at level 1
volatile const char* const* p4 = p2; // OK: 2 more cv-qual and const was already at 1
 
double *a[2][3];
double const * const (*ap)[3] = a; // OK
double * const (*ap1)[] = a;       // OK since C++20</pre></div> <p>Note that in the C programming language, const/volatile can be added to the first level only:</p>
<div class="cpp source-cpp"><pre data-language="cpp">char** p = 0;
char * const* p1 = p;       // OK in C and C++
const char* const * p2 = p; // error in C, OK in C++</pre></div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <h4 id="Function_pointer_conversions"> Function pointer conversions</h4> <ul>
<li> A <a href="value_category#prvalue" title="cpp/language/value category">prvalue</a> of type pointer to non-throwing function can be converted to a prvalue pointer to potentially-throwing function. </li>
<li> A prvalue of type pointer to non-throwing member function can be converted to a prvalue pointer to potentially-throwing member function. </li>
</ul> <div class="cpp source-cpp"><pre data-language="cpp">void (*p)();
void (**pp)() noexcept = &amp;p; // error: cannot convert to pointer to noexcept function
 
struct S
{
    typedef void (*p)();
    operator p();
};
void (*q)() noexcept = S(); // error: cannot convert to pointer to noexcept function</pre></div> </td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <h3 id="The_safe_bool_problem"> The safe bool problem</h3> <p>Until the introduction of explicit conversion functions in C++11, designing a class that should be usable in boolean contexts (e.g. <code>if (obj) { ... }</code>) presented a problem: given a user-defined conversion function, such as <code>T::operator bool() const;</code>, the implicit conversion sequence allowed one additional standard conversion sequence after that function call, which means the resultant <span class="kw4">bool</span> could be converted to <span class="kw4">int</span>, allowing such code as <code>obj &lt;&lt; 1;</code> or <code>int i = obj;</code>.</p>
<p>One early solution for this can be seen in <code><a href="../io/basic_ios" title="cpp/io/basic ios">std::basic_ios</a></code>, which initially defines <code>operator void*</code>, so that the code such as <code><span class="kw1">if</span> <span class="br0">(</span><a href="http://en.cppreference.com/w/cpp/io/cin"><span class="kw1761">std::<span class="me2">cin</span></span></a><span class="br0">)</span> <span class="br0">{</span>...<span class="br0">}</span></code> compiles because <span class="kw4">void</span><span class="sy2">*</span> is convertible to <span class="kw4">bool</span>, but <code><span class="kw4">int</span> n <span class="sy1">=</span> <a href="http://en.cppreference.com/w/cpp/io/cout"><span class="kw1763">std::<span class="me2">cout</span></span></a><span class="sy4">;</span></code> does not compile because <span class="kw4">void</span><span class="sy2">*</span> is not convertible to <span class="kw4">int</span>. This still allows nonsense code such as <code>delete <a href="http://en.cppreference.com/w/cpp/io/cout"><span class="kw1763">std::<span class="me2">cout</span></span></a><span class="sy4">;</span></code> to compile.</p>
<p>Many pre-C++11 third party libraries were designed with a more elaborate solution, known as the <a rel="nofollow" class="external text" href="https://en.wikibooks.org/wiki/More_C++_Idioms/Safe_bool">Safe Bool idiom</a>. <code><a href="../io/basic_ios" title="cpp/io/basic ios">std::basic_ios</a></code> also allowed this idiom via <a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue468">LWG issue 468</a>, and <code>operator void*</code> was replaced (see <a href="../io/basic_ios/operator_bool#Notes" title="cpp/io/basic ios/operator bool">notes</a>).</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>The <a href="explicit" title="cpp/language/explicit">explicit bool conversion</a> can also be used to resolve the safe bool problem:</p>
<div class="cpp source-cpp"><pre data-language="cpp">explicit operator bool() const { ... }</pre></div> </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <h3 id="Footnotes"> Footnotes</h3> <ol class="references"> <li id="cite_note-1"> <span class="reference-text">This only applies if the arithmetic is two's complement which is only required for the <a href="../types/integer" title="cpp/types/integer">exact-width integer types</a>. Note, however, that at the moment all platforms with a C++ compiler use two's complement arithmetic</span> </li> </ol> <h3 id="Defect_reports"> Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th> DR </th> <th> Applied to </th> <th> Behavior as published </th> <th> Correct behavior </th>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/172.html">CWG 172</a> </td> <td> C++98 </td> <td> enumeration type is promoted based on its underlying type </td> <td> based on its value range instead </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/330.html">CWG 330</a> </td> <td> C++98 </td> <td> conversion from <span class="kw4">double</span> <span class="sy2">*</span> <span class="kw4">const</span> <span class="br0">(</span><span class="sy2">*</span>p<span class="br0">)</span><span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span><br>to <span class="kw4">double</span> <span class="kw4">const</span> <span class="sy2">*</span> <span class="kw4">const</span> <span class="br0">(</span><span class="sy2">*</span>p<span class="br0">)</span><span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span> invalid </td> <td> conversion valid </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/519.html">CWG 519</a> </td> <td> C++98 </td> <td> null pointer values were not guaranteed to be<br>preserved when converting to another pointer type </td> <td> always preserved </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/616.html">CWG 616</a> </td> <td> C++98 </td> <td> the behavior of lvalue to rvalue conversion of<br>any uninitialized object and pointer objects<br>of invalid values was always undefined </td> <td> indeterminate <span class="kw4">unsigned</span> <span class="kw4">char</span><br>is allowed; use of invalid pointers<br>is implementation-defined </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/685.html">CWG 685</a> </td> <td> C++98 </td> <td> the underlying type of an enumeration type was<br>not prioritized in integral promotion if it is fixed </td> <td> prioritized </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/707.html">CWG 707</a> </td> <td> C++98 </td> <td> integer to floating point conversion<br>had defined behavior in all cases </td> <td> the behavior is undefined if<br>the value being converted is<br>out of the destination range </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1423.html">CWG 1423</a> </td> <td> C++11 </td> <td> <code><a href="../types/nullptr_t" title="cpp/types/nullptr t">std::nullptr_t</a></code> is convertible to <span class="kw4">bool</span><br>in both direct- and copy-initialization </td> <td> direct-initialization only </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1773.html">CWG 1773</a> </td> <td> C++11 </td> <td> a name expression that appears in a potentially-evaluated<br>expression such that the object named is not odr-used might<br>still be evaluated during an lvalue-to-rvalue conversion </td> <td> not evaluated </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1781.html">CWG 1781</a> </td> <td> C++11 </td> <td> <code><a href="../types/nullptr_t" title="cpp/types/nullptr t">std::nullptr_t</a></code> to <span class="kw4">bool</span> is considered an implicit<br>conversion even though it is only valid for direct-initialization </td> <td> no longer considered<br>an implicit conversion </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1787.html">CWG 1787</a> </td> <td> C++98 </td> <td> the behavior of reading from an indeterminate<br><span class="kw4">unsigned</span> <span class="kw4">char</span> cached in a register was undefined </td> <td> made well-defined </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1981.html">CWG 1981</a> </td> <td> C++11 </td> <td> contextual conversions considered explicit conversion functions </td> <td> not considered </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2140.html">CWG 2140</a> </td> <td> C++11 </td> <td> it was unclear whether lvalue-to-rvalue conversions from<br><code><a href="../types/nullptr_t" title="cpp/types/nullptr t">std::nullptr_t</a></code> lvalues fetch these lvalues from memory </td> <td> not fetched </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2310.html">CWG 2310</a> </td> <td> C++98 </td> <td> for derived-to-base pointer conversions and<br>base-to-derived pointer-to-member conversions,<br>the derived class type could be incomplete </td> <td> must be complete </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2484.html">CWG 2484</a> </td> <td> C++20 </td> <td> char8_t and <span class="kw4">char16_t</span> have different integral<br>promotion strategies, but they can fit both of them </td> <td> char8_t should be promoted<br>in the same way as <span class="kw4">char16_t</span> </td>
</tr>
</table> <h3 id="See_also"> See also</h3> <ul>
<li> <a href="const_cast" title="cpp/language/const cast"><code>const_cast</code></a> </li>
<li> <a href="static_cast" title="cpp/language/static cast"><code>static_cast</code></a> </li>
<li> <a href="dynamic_cast" title="cpp/language/dynamic cast"><code>dynamic_cast</code></a> </li>
<li> <a href="reinterpret_cast" title="cpp/language/reinterpret cast"><code>reinterpret_cast</code></a> </li>
<li> <a href="explicit_cast" title="cpp/language/explicit cast">explicit cast</a> </li>
<li> <a href="cast_operator" title="cpp/language/cast operator">user-defined conversion</a> </li>
</ul> <table class="t-dsc-begin"> <tr class="t-dsc"> <td colspan="2"> <span><a href="https://en.cppreference.com/w/c/language/conversion" title="c/language/conversion">C documentation</a></span> for <span class=""><span>Implicit conversions</span></span> </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    © cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/language/implicit_conversion" class="_attribution-link">https://en.cppreference.com/w/cpp/language/implicit_conversion</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
