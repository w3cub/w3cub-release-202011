
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Type - C++ - W3cubDocs</title>
  
  <meta name="description" content="Objects, references, functions including function template specializations, and expressions have a property called type, which both restricts the &hellip;">
  <meta name="keywords" content="type, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/language/type-id.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/cpp.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _c">
				
				
<h1 id="firstHeading" class="firstHeading">Type</h1>            <p><a href="objects" title="cpp/language/object">Objects</a>, <a href="reference" title="cpp/language/reference">references</a>, <a href="functions" title="cpp/language/functions">functions</a> including <a href="template_specialization" title="cpp/language/template specialization">function template specializations</a>, and <a href="expressions" title="cpp/language/expressions">expressions</a> have a property called <i>type</i>, which both restricts the operations that are permitted for those entities and provides semantic meaning to the otherwise generic sequences of bits.</p>
<h3 id="Type_classification">Type classification</h3> <p>The C++ type system consists of the following types:</p>
<ul>
<li> <a href="types" title="cpp/language/types">fundamental types</a> (see also <code><a href="../types/is_fundamental" title="cpp/types/is fundamental">std::is_fundamental</a></code>): </li>
<li> the type <code>void</code> (see also <code><a href="../types/is_void" title="cpp/types/is void">std::is_void</a></code>); </li>
<li> the type <code><a href="../types/nullptr_t"><span class="kw102">std::<span class="me2">nullptr_t</span></span></a></code> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> (see also <code><a href="../types/is_null_pointer" title="cpp/types/is null pointer">std::is_null_pointer</a></code>); </li>
<li> arithmetic types (see also <code><a href="../types/is_arithmetic" title="cpp/types/is arithmetic">std::is_arithmetic</a></code>): </li>
<li> floating-point types (<code>float</code>, <code>double</code>, <code>long double</code>) (see also <code><a href="../types/is_floating_point" title="cpp/types/is floating point">std::is_floating_point</a></code>); </li>
<li> integral types (see also <code><a href="../types/is_integral" title="cpp/types/is integral">std::is_integral</a></code>): </li>
<li> the type <code>bool</code>; </li>
<li> character types: </li>
<li> narrow character types: </li>
<ul>
<li> ordinary character types (<code>char</code>, <code>signed char</code>, <code>unsigned char</code>) </li>
<li> the type <code>char8_t</code> </li>
</ul>
<li> wide character types (<code>char16_t</code>, <code>char32_t</code>, <code>wchar_t</code>); </li>
<li> signed integer types (<code>short int</code>, <code>int</code>, <code>long int</code>, <code>long long int</code>); </li>
<li> unsigned integer types (<code>unsigned short int</code>, <code>unsigned int</code>, <code>unsigned long int</code>, <code>unsigned long long int</code>); </li>
<li> compound types (see also <code><a href="../types/is_compound" title="cpp/types/is compound">std::is_compound</a></code>): </li>
<li> <a href="reference" title="cpp/language/reference">reference types</a> (see also <code><a href="../types/is_reference" title="cpp/types/is reference">std::is_reference</a></code>): </li>
<li> <a href="reference#Lvalue_references" title="cpp/language/reference">lvalue reference types</a> (see also <code><a href="../types/is_lvalue_reference" title="cpp/types/is lvalue reference">std::is_lvalue_reference</a></code>): </li>
<ul>
<li> lvalue reference to object types; </li>
<li> lvalue reference to function types; </li>
</ul>
<li> <a href="reference#Rvalue_references" title="cpp/language/reference">rvalue reference types</a> (see also <code><a href="../types/is_rvalue_reference" title="cpp/types/is rvalue reference">std::is_rvalue_reference</a></code>): </li>
<ul>
<li> rvalue reference to object types; </li>
<li> rvalue reference to function types; </li>
</ul>
<li> <a href="pointer#Pointers" title="cpp/language/pointer">pointer types</a> (see also <code><a href="../types/is_pointer" title="cpp/types/is pointer">std::is_pointer</a></code>): </li>
<ul>
<li> <a href="pointer#Pointers_to_objects" title="cpp/language/pointer">pointer-to-object types</a>; </li>
<li> <a href="pointer#Pointers_to_functions" title="cpp/language/pointer">pointer-to-function types</a>; </li>
</ul>
<li> <a href="pointer#Pointers_to_members" title="cpp/language/pointer">pointer-to-member types</a> (see also <code><a href="../types/is_member_pointer" title="cpp/types/is member pointer">std::is_member_pointer</a></code>): </li>
<ul>
<li> <a href="pointer#Pointers_to_data_members" title="cpp/language/pointer">pointer-to-data-member</a> types (see also <code><a href="../types/is_member_object_pointer" title="cpp/types/is member object pointer">std::is_member_object_pointer</a></code>); </li>
<li> <a href="pointer#Pointers_to_member_functions" title="cpp/language/pointer">pointer-to-member-function</a> types (see also <code><a href="../types/is_member_function_pointer" title="cpp/types/is member function pointer">std::is_member_function_pointer</a></code>); </li>
</ul>
<li> <a href="array" title="cpp/language/array">array types</a> (see also <code><a href="../types/is_array" title="cpp/types/is array">std::is_array</a></code>); </li>
<li> <a href="function" title="cpp/language/function">function types</a> (see also <code><a href="../types/is_function" title="cpp/types/is function">std::is_function</a></code>); </li>
<li> <a href="enum" title="cpp/language/enum">enumeration types</a> (see also <code><a href="../types/is_enum" title="cpp/types/is enum">std::is_enum</a></code>); </li>
<li> <a href="class" title="cpp/language/class">class types</a>: </li>
<ul>
<li> non-union types (see also <code><a href="../types/is_class" title="cpp/types/is class">std::is_class</a></code>); </li>
<li> <a href="union" title="cpp/language/union">union types</a> (see also <code><a href="../types/is_union" title="cpp/types/is union">std::is_union</a></code>). </li>
</ul>
</ul>                          <p>For every type other than reference and function, the type system supports three additional <a href="cv" title="cpp/language/cv">cv-qualified versions</a> of that type (<code>const</code>, <code>volatile</code>, and <code>const volatile</code>).</p>
<p>Types are grouped in various categories based on their properties:</p>
<ul>
<li> object types are (possibly cv-qualified) types that are not function types, reference types, or the type <code>void</code> (see also <code><a href="../types/is_object" title="cpp/types/is object">std::is_object</a></code>); </li>
<li> scalar types are (possibly cv-qualified) object types that are not array types or class types (see also <code><a href="../types/is_scalar" title="cpp/types/is scalar">std::is_scalar</a></code>); </li>
<li> trivial types (see also <code><a href="../types/is_trivial" title="cpp/types/is trivial">std::is_trivial</a></code>), POD types (see also <code><a href="../types/is_pod" title="cpp/types/is pod">std::is_pod</a></code>), literal types (see also <code><a href="../types/is_literal_type" title="cpp/types/is literal type">std::is_literal_type</a></code>), and other categories listed in the <a href="../types" title="cpp/types"> the type traits library</a> or as <a href="../named_req" title="cpp/named req">named type requirements</a>. </li>
</ul> <h3 id="Type_naming">Type naming</h3> <p>A <a href="name" title="cpp/language/name" class="mw-redirect">name</a> can be declared to refer to a type by means of:</p>
<ul>
<li> <a href="class" title="cpp/language/class">class</a> declaration; </li>
<li> <a href="enum" title="cpp/language/enum">enum</a> declaration; </li>
<li> <a href="typedef" title="cpp/language/typedef">typedef</a> declaration; </li>
<li> <a href="type_alias" title="cpp/language/type alias">type alias</a> declaration. </li>
</ul> <p>Types that do not have names often need to be referred to in C++ programs; the syntax for that is known as <i>type-id</i>. The syntax of the type-id that names type T is exactly the syntax of a <a href="declarations" title="cpp/language/declarations">declaration</a> of a variable or function of type T, with the identifier omitted, except that <i>decl-specifier-seq</i> of the declaration grammar is constrained to <i>type-specifier-seq</i>, and that new types may be defined only if the type-id appears on the right-hand side of a non-template type alias declaration.</p>
<div class="cpp source-cpp"><pre data-language="cpp">int* p;               // declaration of a pointer to int
static_cast&lt;int*&gt;(p); // type-id is "int*"
 
int a[3];   // declaration of an array of 3 int
new int[3]; // type-id is "int[3]" (called new-type-id)
 
int (*(*x[2])())[3];      // declaration of an array of 2 pointers to functions
                          // returning pointer to array of 3 int
new (int (*(*[2])())[3]); // type-id is "int (*(*[2])())[3]"
 
void f(int);                    // declaration of a function taking int and returning void
std::function&lt;void(int)&gt; x = f; // type template parameter is a type-id "void(int)"
std::function&lt;auto(int) -&gt; void&gt; y = f; // same
 
std::vector&lt;int&gt; v;       // declaration of a vector of int
sizeof(std::vector&lt;int&gt;); // type-id is "std::vector&lt;int&gt;"
 
struct { int x; } b;         // creates a new type and declares an object b of that type
sizeof(struct{ int x; });    // error: cannot define new types in a sizeof expression
using t = struct { int x; }; // creates a new type and declares t as an alias of that type
 
sizeof(static int); // error: storage class specifiers not part of type-specifier-seq
std::function&lt;inline void(int)&gt; f; // error: neither are function specifiers</pre></div> <p>The <i>declarator</i> part of the declaration grammar with the name removed is referred to as <i>abstract-declarator</i>.</p>
<p><i>Type-id</i> may be used in the following situations:</p>
<ul>
<li> to specify the target type in <a href="expressions#Conversions" title="cpp/language/expressions">cast expressions</a>; </li>
<li> as arguments to <a href="sizeof" title="cpp/language/sizeof">sizeof</a>, <a href="alignof" title="cpp/language/alignof">alignof</a>, <a href="alignas" title="cpp/language/alignas">alignas</a>, <a href="new" title="cpp/language/new">new</a>, and <a href="typeid" title="cpp/language/typeid">typeid</a>; </li>
<li> on the right-hand side of a <a href="type_alias" title="cpp/language/type alias">type alias</a> declaration; </li>
<li> as the trailing return type of a <a href="function" title="cpp/language/function">function</a> declaration; </li>
<li> as the default argument of a <a href="template_parameters#Type_template_parameter" title="cpp/language/template parameters">template type parameter</a>; </li>
<li> as the template argument for a <a href="template_parameters#Template_type_arguments" title="cpp/language/template parameters">template type parameter</a>; </li>
<li> in <a href="except_spec" title="cpp/language/except spec">dynamic exception specification</a>. </li>
</ul> <p><i>Type-id</i> can be used with some modifications in the following situations:</p>
<ul>
<li> in the parameter list of a <a href="function#Parameter_list" title="cpp/language/function">function</a> (when the parameter name is omitted), type-id uses <i>decl-specifier-seq</i> instead of <i>type-specifier-seq</i> (in particular, some storage class specifiers are allowed); </li>
<li> in the name of a <a href="cast_operator" title="cpp/language/cast operator">user-defined conversion function</a>, the abstract declarator cannot include function or array operators. </li>
</ul>   <h3 id="Elaborated_type_specifier">Elaborated type specifier</h3> <p>Elaborated type specifiers may be used to refer to a previously-declared class name (class, struct, or union) or to a previously-declared enum name even if the name was <a href="lookup" title="cpp/language/lookup">hidden by a non-type declaration</a>. They may also be used to declare new class names.</p>
<p>See <a href="elaborated_type_specifier" title="cpp/language/elaborated type specifier">elaborated type specifier</a> for details.</p>
<h3 id="Static_type">Static type</h3> <p>The type of an expression that results from the compile-time analysis of the program is known as the <i>static type</i> of the expression. The static type does not change while the program is executing.</p>
<h3 id="Dynamic_type">Dynamic type</h3> <p>If some <a href="value_category" title="cpp/language/value category">glvalue expression</a> refers to a <a href="objects" title="cpp/language/object">polymorphic object</a>, the type of its most derived object is known as the dynamic type.</p>
<div class="cpp source-cpp"><pre data-language="cpp">// given
struct B { virtual ~B() {} }; // polymorphic type
struct D: B {}; // polymorphic type
D d; // most-derived object
B* ptr = &amp;d;
// the static type of (*ptr) is B
// the dynamic type of (*ptr) is D</pre></div> <p>For prvalue expressions, the dynamic type is always the same as the static type.</p>
<h3 id="Incomplete_type">Incomplete type</h3> <p>The following types are <i>incomplete types</i>:</p>
<ul>
<li> the type <code>void</code> (possibly <a href="cv" title="cpp/language/cv">cv</a>-qualified); </li>
<li> class type that has been declared (e.g. by <a href="class#Forward_declaration" title="cpp/language/class">forward declaration</a>) but not defined; </li>
<li> <a href="array#Arrays_of_unknown_bound" title="cpp/language/array">array of unknown bound</a>; </li>
<li> array of elements of incomplete type; </li>
<li> <a href="enum" title="cpp/language/enum">enumeration type</a> from the point of declaration until its underlying type is determined. </li>
</ul> <p>Any of the following contexts requires class <code>T</code> to be complete:</p>
<ul>
<li> <a href="function" title="cpp/language/function">definition</a> or function call to a function with return type <code>T</code> or argument type <code>T</code>; </li>
<li> <a href="definition" title="cpp/language/definition">definition</a> of an object of type <code>T</code>; </li>
<li> declaration of a <a href="data_members" title="cpp/language/data members">non-static class data member</a> of type <code>T</code>; </li>
<li> <a href="new" title="cpp/language/new">new-expression</a> for an object of type <code>T</code> or an array whose element type is <code>T</code>; </li>
<li> <a href="implicit_cast#Lvalue_to_rvalue_conversion" title="cpp/language/implicit cast" class="mw-redirect">lvalue-to-rvalue conversion</a> applied to a glvalue of type <code>T</code>; </li>
<li> an <a href="implicit_cast" title="cpp/language/implicit cast" class="mw-redirect">implicit</a> or <a href="explicit_cast" title="cpp/language/explicit cast">explicit</a> conversion to type <code>T</code>; </li>
<li> a <a href="implicit_cast" title="cpp/language/implicit cast" class="mw-redirect">standard conversion</a>, <a href="dynamic_cast" title="cpp/language/dynamic cast">dynamic_cast</a>, or <a href="static_cast" title="cpp/language/static cast">static_cast</a> to type <code>T*</code> or <code>T&amp;</code>, except when converting from the <a href="../types/null" title="cpp/types/NULL">null pointer constant</a> or from a <a href="pointer#Pointers_to_void" title="cpp/language/pointer">pointer to void</a>; </li>
<li> <a href="operator_member_access" title="cpp/language/operator member access">class member access operator</a> applied to an expression of type <code>T</code>; </li>
<li> <a href="typeid" title="cpp/language/typeid">typeid</a>, <a href="sizeof" title="cpp/language/sizeof">sizeof</a>, or <a href="alignof" title="cpp/language/alignof">alignof</a> operator applied to type <code>T</code>; </li>
<li> <a href="operator_arithmetic" title="cpp/language/operator arithmetic">arithmetic operator</a> applied to a pointer to <code>T</code>; </li>
<li> definition of a class with base class <code>T</code>; </li>
<li> assignment to an lvalue of type <code>T</code>; </li>
<li> a <a href="try_catch" title="cpp/language/try catch">catch-clause</a> for an exception of type <code>T</code>, <code>T&amp;</code>, or <code>T*</code>. </li>
</ul> <p>(In general, when the size and layout of <code>T</code> must be known.).</p>
<p>If any of these situations occur in a translation unit, the definition of the type must appear in the same translation unit. Otherwise, it is not required.</p>
<p>An incompletely-defined object type can be completed:</p>
<ul><li> A class type (such as <code>class X</code>) might be incomplete at one point in a translation unit and complete later on; the type <code>class X</code> is the same type at both points: </li></ul> <div class="cpp source-cpp"><pre data-language="cpp">class X;              // X is an incomplete type
extern X* xp;         // xp is a pointer to an incomplete type
 
void foo() {
  xp++;               // ill-formed: X is incomplete
}
 
struct X { int i; };  // now X is a complete type
 
X x;
void bar() {
  xp = &amp;x;            // OK: type is “pointer to X”
  xp++;               // OK: X is complete
}</pre></div> <ul>
<li> The declared type of an array object might be an array of incomplete class type and therefore incomplete; if the class type is completed later on in the translation unit, the array type becomes complete; the array type at those two points is the same type. </li>
<li> The declared type of an array object might be an array of unknown bound and therefore be incomplete at one point in a translation unit and complete later on; the array types at those two points ("array of unknown bound of <code>T</code>" and "array of <code>N</code> <code>T</code>") are different types. </li>
</ul>   <p>The type of a pointer to array of unknown bound, or of a type defined by a <code>typedef</code> declaration to be an array of unknown bound, cannot be completed.</p>
<h3 id="See_also">See also</h3>           <div class="_attribution">
  <p class="_attribution-p">
    © cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/language/type-id" class="_attribution-link">http://en.cppreference.com/w/cpp/language/type-id</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
