
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Dependent Names - C++ - W3cubDocs</title>
  
  <meta name="description" content="Inside the definition of a template (both class template and function template), the meaning of some constructs may differ from one instantiation to &hellip;">
  <meta name="keywords" content="dependent, names, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/language/dependent_name.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-9c7b0d969c0ce639a6c01c2badcdd81667c7c66206aa3d0fccc5cb0585fb1b912dab72ea882101d18010680927514b4b77b107282db8f756fbf63301fe9c88b0.css">
  <script type="text/javascript" src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js"></script>
  <script src="/json/cpp.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _cppref">
				
				
<h1 id="firstHeading" class="firstHeading">Dependent names</h1>            <p>Inside the definition of a <a href="templates" title="cpp/language/templates">template</a> (both <a href="class_template" title="cpp/language/class template">class template</a> and <a href="function_template" title="cpp/language/function template">function template</a>), the meaning of some constructs may differ from one instantiation to another. In particular, types and expressions may depend on types of type template parameters and values of non-type template parameters.</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename T&gt;
struct X : B&lt;T&gt; // "B&lt;T&gt;" is dependent on T
{
    typename T::A* pa; // "T::A" is dependent on T
                       // (see below for the meaning of this use of "typename")
 
    void f(B&lt;T&gt;* pb)
    {
        static int i = B&lt;T&gt;::i; // "B&lt;T&gt;::i" is dependent on T
        pb-&gt;j++; // "pb-&gt;j" is dependent on T
    }
};</pre></div> <p>Name lookup and binding are different for <i>dependent names</i> and non-<i>dependent names</i>.</p>
<h3 id="Binding_rules"> Binding rules</h3> <p>Non-dependent names are looked up and bound at the point of template definition. This binding holds even if at the point of template instantiation there is a better match:</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
 
void g(double) { std::cout &lt;&lt; "g(double)\n"; }
 
template&lt;class T&gt;
struct S
{
    void f() const
    {
        g(1); // "g" is a non-dependent name, bound now
    }
};
 
void g(int) { std::cout &lt;&lt; "g(int)\n"; }
 
int main()
{
    g(1);  // calls g(int)
 
    S&lt;int&gt; s;
    s.f(); // calls g(double)
}</pre></div> </div> <p>If the meaning of a <i>non-dependent name</i> changes between the definition context and the point of instantiation of a specialization of the template, the program is ill-formed, no diagnostic required. This is possible in the following situations:</p>
<ul><li> a type used in a non-dependent name is <a href="incomplete_type" title="cpp/language/incomplete type" class="mw-redirect">incomplete</a> at the point of definition but complete at the point of instantiation </li></ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <ul><li> lookup for a name in the template definition found a <a href="using_declaration" title="cpp/language/using declaration">using-declaration</a>, but the lookup in the corresponding scope in the instantiation does not find any declarations because the using-declaration was a pack expansion and the corresponding pack is empty </li></ul> </td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <ul>
<li> an instantiation uses a default argument or default template argument that had not been defined at the point of definition </li>
<li> a <a href="constant_expression" title="cpp/language/constant expression">constant expression</a> at the point of instantiation uses the value of a const object of integral or unscoped enum type<span class="t-rev-inl t-since-cxx11"><span>, the value of a constexpr object, the value of a reference, or the definition of a constexpr function</span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>, and that object<span class="t-rev-inl t-since-cxx11"><span>/reference/function</span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span> was not defined at the point of definition </li>
<li> the template uses a non-dependent class template specialization <span class="t-rev-inl t-since-cxx14"><span>or variable template specialization</span> <span><span class="t-mark-rev t-since-cxx14">(since C++14)</span></span></span> at the point of instantiation, and this template it uses is either instantiated from a partial specialization that was not defined at the point of definition or names an explicit specialization that was not declared at the point of definition </li>
</ul> <p>Binding of <i>dependent names</i> is postponed until lookup takes place.</p>
<h3 id="Lookup_rules"> Lookup rules</h3> <p>As discussed in <a href="lookup" title="cpp/language/lookup">lookup</a>, the lookup of a dependent name used in a template is postponed until the template arguments are known, at which time.</p>
<ul>
<li> non-ADL lookup examines function declarations with external linkage that are visible from the <i>template definition</i> context </li>
<li> <a href="adl" title="cpp/language/adl">ADL</a> examines function declarations with external linkage that are visible from either the <i>template definition</i> context or the <i>template instantiation</i> context </li>
</ul> <p>(in other words, adding a new function declaration after template definition does not make it visible, except via ADL).</p>
<p>The purpose of this rule is to help guard against violations of the <a href="definition#One_Definition_Rule" title="cpp/language/definition">ODR</a> for template instantiations:</p>
<div class="cpp source-cpp"><pre data-language="cpp">// an external library
namespace E
{
    template&lt;typename T&gt;
    void writeObject(const T&amp; t)
    {
        std::cout &lt;&lt; "Value = " &lt;&lt; t &lt;&lt; '\n';
    }
}
 
// translation unit 1:
// Programmer 1 wants to allow E::writeObject to work with vector&lt;int&gt;
namespace P1
{
    std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const std::vector&lt;int&gt;&amp; v)
    {
        for (int n : v)
            os &lt;&lt; n &lt;&lt; ' ';
        return os;
    }
 
    void doSomething()
    {
        std::vector&lt;int&gt; v;
        E::writeObject(v); // error: will not find P1::operator&lt;&lt;
    }
}
 
// translation unit 2:
// Programmer 2 wants to allow E::writeObject to work with vector&lt;int&gt;
namespace P2
{
    std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const std::vector&lt;int&gt;&amp; v)
    {
        for (int n : v)
            os &lt;&lt; n &lt;&lt; ':';
        return os &lt;&lt; "[]";
    }
 
    void doSomethingElse()
    {
        std::vector&lt;int&gt; v;
        E::writeObject(v); // error: will not find P2::operator&lt;&lt;
    }
}</pre></div> <p>In the above example, if non-ADL lookup for <code>operator&lt;&lt;</code> were allowed from the instantiation context, the instantiation of <code>E::writeObject&lt;vector&lt;int&gt;&gt;</code> would have two different definitions: one using <code>P1::operator&lt;&lt;</code> and one using <code>P2::operator&lt;&lt;</code>. Such ODR violation may not be detected by the linker, leading to one or the other being used in both instances.</p>
<p>To make ADL examine a user-defined namespace, either <code>std::vector</code> should be replaced by a user-defined class or its element type should be a user-defined class:</p>
<div class="cpp source-cpp"><pre data-language="cpp">namespace P1
{
    // if C is a class defined in the P1 namespace
    std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const std::vector&lt;C&gt;&amp; v)
    {
        for (C n : v)
            os &lt;&lt; n;
        return os;
    }
 
    void doSomething()
    {
        std::vector&lt;C&gt; v;
        E::writeObject(v); // OK: instantiates writeObject(std::vector&lt;P1::C&gt;)
                           //     which finds P1::operator&lt;&lt; via ADL
    }
}</pre></div> <p>Note: this rule makes it impractical to overload operators for standard library types:</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;
 
// Bad idea: operator in global namespace, but its arguments are in std::
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, std::pair&lt;int, double&gt; p)
{
    return os &lt;&lt; p.first &lt;&lt; ',' &lt;&lt; p.second;
}
 
int main()
{
    typedef std::pair&lt;int, double&gt; elem_t;
    std::vector&lt;elem_t&gt; v(10);
    std::cout &lt;&lt; v[0] &lt;&lt; '\n'; // OK, ordinary lookup finds ::operator&lt;&lt;
    std::copy(v.begin(), v.end(),
              std::ostream_iterator&lt;elem_t&gt;(std::cout, " "));
    // Error: both ordinary lookup from the point of definition of
    // std::ostream_iterator and ADL will only consider the std namespace,
    // and will find many overloads of std::operator&lt;&lt;, so the lookup will be done.
    // Overload resolution will then fail to find operator&lt;&lt; for elem_t
    // in the set found by the lookup.
}</pre></div> </div> <p>Note: limited lookup (but not binding) of dependent names also takes place at template definition time, as needed to distinguish them from non-dependent names and also to determine whether they are members of the current instantiation or members of unknown specialization. The information obtained by this lookup can be used to detect errors, see below.</p>
<h3 id="Dependent_types"> Dependent types</h3> <p>The following types are dependent types:</p>
<ul>
<li> template parameter </li>
<li> a member of an <i>unknown specialization</i> (see below) </li>
<li> a nested class/enum that is a dependent member of <i>unknown specialization</i> (see below) </li>
<li> a cv-qualified version of a dependent type </li>
<li> a compound type constructed from a dependent type </li>
<li> an array type whose element type is dependent or whose bound (if any) is value-dependent </li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul><li> a function type whose parameters include one or more function <a href="parameter_pack" title="cpp/language/parameter pack">parameter packs</a> </li></ul> </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <ul>
<li> a function type whose exception specification is value-dependent </li>
<li> a <a href="templates#template-id" title="cpp/language/templates">template-id</a> where either </li>
<ul>
<li> the template name is a template parameter, or </li>
<li> any of template arguments is type-dependent, or value-dependent<span class="t-rev-inl t-since-cxx11"><span>, or is a pack expansion</span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span> (even if the template-id is used without its argument list, as <a href="injected-class-name" title="cpp/language/injected-class-name">injected-class-name</a>) </li>
</ul>
</ul>  <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul><li> the result of <a href="decltype" title="cpp/language/decltype"><code>decltype</code></a> applied to a type-dependent expression </li></ul> <p>The result of <code>decltype</code> applied to a type-dependent expression is a unique dependent type. Two such results refer to the same type only if their expressions are <a href="function_template#Function_template_overloading" title="cpp/language/function template">equivalent</a>.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <p>Note: a typedef member of a current instantiation is only dependent when the type it refers to is.</p>
<h3 id="Type-dependent_expressions"> Type-dependent expressions</h3> <p>The following expressions are type-dependent:</p>
<ul>
<li> an expression whose any subexpression is a type-dependent expression </li>
<li> <code>this</code>, if the class is a dependent type. </li>
<li> an <a href="identifiers" title="cpp/language/identifiers">id-expression</a> that <span class="t-rev-inl t-since-cxx20"><span>is not a <a href="constraints" title="cpp/language/constraints">concept-id</a> and</span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span> </li>
<ul>
<li> contains an identifier for which name lookup finds at least one dependent declaration </li>
<li> contains a dependent <a href="templates#template-id" title="cpp/language/templates">template-id</a> </li>
</ul>
</ul>  <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul><li> contains the special identifier <code>__func__</code> (if some enclosing function is a template, a non-template member of a class template<span class="t-rev-inl t-since-cxx14"><span>, or a generic lambda</span> <span><span class="t-mark-rev t-since-cxx14">(since C++14)</span></span></span>) </li></ul> </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <ul>
<li> contains the name of <a href="cast_operator" title="cpp/language/cast operator">conversion function</a> to a dependent type </li>
<li> contains a nested name specifier or <a href="identifiers" title="cpp/language/identifiers">qualified-id</a> that is a member of <i>unknown specialization</i> </li>
<li> names a dependent member of the <i>current instantiation</i> which is a static data member of type "array of unknown bound" </li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx14">
<td> <ul><li> contains an identifier for which name lookup finds one or more declarations of member functions of the current instantiation declared with <a href="function#Return_type_deduction" title="cpp/language/function">return type deduction</a> </li></ul> </td> <td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr> <tr class="t-rev t-since-cxx17">
<td> <ul>
<li> contains an identifier for which name lookup finds a <a href="structured_binding" title="cpp/language/structured binding">structured binding declaration</a> whose initializer is type-dependent </li>
<li> contains an identifier for which name lookup finds a non-type template parameter whose type contains the placeholder <code>auto</code> </li>
<li> contains an identifier for which by name lookup finds a variable declared with a type that contains a placeholder type (e.g., <code>auto</code> static data member), where the initializer is type-dependent, </li>
</ul> </td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <ul>
<li> any cast expression to a dependent type </li>
<li> <a href="new" title="cpp/language/new">new-expression</a> that creates an object of a dependent type </li>
<li> member access expression that refers to a member of the <i>current instantiation</i> whose type is dependent </li>
<li> member access expression that refers to a member of <i>unknown specialization</i> </li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <ul><li> <a href="fold" title="cpp/language/fold">fold-expression</a> </li></ul> </td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <p>Note: literals, pseudo-destructor calls<span class="t-rev-inl t-since-cxx11"><span>, <a href="alignof" title="cpp/language/alignof"><code>alignof</code></a>, <a href="noexcept" title="cpp/language/noexcept"><code>noexcept</code></a></span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>, <a href="sizeof" title="cpp/language/sizeof"><code>sizeof</code></a>, <a href="typeid" title="cpp/language/typeid"><code>typeid</code></a>, <a href="delete" title="cpp/language/delete"><code>delete</code></a>, and <a href="throw" title="cpp/language/throw"><code>throw</code></a>-expressions are never type-dependent because the types of these expressions cannot be.</p>
<h3 id="Value-dependent_expressions"> Value-dependent expressions</h3> <ul>
<li> an expression used in context where <a href="constant_expression" title="cpp/language/constant expression">constant expression</a> is required, and whose any subexpression is value-dependent </li>
<li> an <a href="identifiers" title="cpp/language/identifiers">id-expression</a> that </li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <ul><li> is a <a href="constraints" title="cpp/language/constraints">concept-id</a> and any of its arguments are dependent </li></ul> </td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <ul>
<li> is type-dependent </li>
<li> is a name of a non-type template parameter </li>
<li> names a static data member that is a dependent member of the <i>current instantiation</i> and is not initialized. </li>
<li> names a static member function that is a dependent member of the <i>current instantiation</i> </li>
<li> is a constant with a <span class="t-rev-inl t-until-cxx11"><span>integer or enumeration</span> <span><span class="t-mark-rev t-until-cxx11">(until C++11)</span></span></span><span class="t-rev-inl t-since-cxx11"><span>literal</span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span> type, initialized from a value-dependent expression </li>
<li> <span class="t-rev-inl t-since-cxx11"><span><a href="alignof" title="cpp/language/alignof"><code>alignof</code></a>, <a href="noexcept" title="cpp/language/noexcept"><code>noexcept</code></a>,</span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span><a href="sizeof" title="cpp/language/sizeof"><code>sizeof</code></a>, <a href="typeid" title="cpp/language/typeid"><code>typeid</code></a>-expressions where the argument is a type-dependent expression or a dependent type-id </li>
<li> any cast expression to a dependent type or from a value-dependent expression </li>
<li> address-of expression where the argument is <a href="identifiers" title="cpp/language/identifiers">qualified-id</a> that names a dependent member of the <i>current instantiation</i> </li>
<li> address-of expression where the argument is any expression which, evaluated as a core <a href="constant_expression" title="cpp/language/constant expression">constant expression</a>, refers to a <a href="templates#Templated_entity" title="cpp/language/templates">templated entity</a> that is an object with static <span class="t-rev-inl t-since-cxx11"><span>or thread storage</span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span> duration or a member function. </li>
</ul>  <table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <ul><li> <a href="fold" title="cpp/language/fold">fold-expression</a> </li></ul> </td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <h3 id="Dependent_names"> Dependent names</h3>   <h3 id="Current_instantiation"> Current instantiation</h3> <p>Within a class template definition (including its member functions and nested classes) some names may be deduced to refer to the <i>current instantiation</i>. This allows certain errors to be detected at the point of definition, rather than instantiation, and removes the requirement on the <code>typename</code> and <code>template</code> disambiguators for dependent names, see below.</p>
<p>Only the following names can refer to the current instantiation:</p>
<ul>
<li> in a class template definition: </li>
<ul><li> a nested class, a member of class template, a member of a nested class, the injected-class-name of the template, the injected-class-name of a nested class. </li></ul>
<li> in a primary class template definition or in the definition of its member: </li>
<ul><li> name of the class template followed by template argument list (or an equivalent alias template specialization) for the primary template where each argument is equivalent (defined below) to its corresponding parameter. </li></ul>
<li> in the definition of a nested class or class template: </li>
<ul><li> name of the nested class used as a member of the current instantiation. </li></ul>
<li> in the definition of a partial specialization or of a member of a partial specialization: </li>
<ul><li> the name of the class template followed by template argument list for the partial specialization, where each argument is equivalent to its corresponding parameter. </li></ul>
</ul>        <p>A template argument is equivalent to a template parameter if.</p>
<ul>
<li> for a <a href="template_parameters#Type_template_parameter" title="cpp/language/template parameters">type parameter</a>, the template argument denotes the same type as the template parameter. </li>
<li> for a <a href="template_parameters#Non-type_template_parameter" title="cpp/language/template parameters">non-type parameter</a>, the template argument is an <a href="identifiers" title="cpp/language/identifiers">identifier</a> that names a variable that is equivalent to the template parameter. A variable is equivalent to a template parameter if </li>
<ul>
<li> it has the same type as the template parameter (ignoring cv-qualification) and </li>
<li> its initializer consists of a single identifier that names the template parameter or, recursively, such a variable. </li>
</ul>
</ul>  <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class T&gt;
class A
{
    A* p1;      // A is the current instantiation
    A&lt;T&gt;* p2;   // A&lt;T&gt; is the current instantiation
    ::A&lt;T&gt;* p4; // ::A&lt;T&gt; is the current instantiation
    A&lt;T*&gt; p3;   // A&lt;T*&gt; is not the current instantiation
 
    class B
    {
        B* p1;                 // B is the current instantiation
        A&lt;T&gt;::B* p2;           // A&lt;T&gt;::B is the current instantiation
        typename A&lt;T*&gt;::B* p3; // A&lt;T*&gt;::B is not the current instantiation
    };
};
 
template&lt;class T&gt;
class A&lt;T*&gt;
{
    A&lt;T*&gt;* p1; // A&lt;T*&gt; is the current instantiation
    A&lt;T&gt;* p2;  // A&lt;T&gt; is not the current instantiation
};
 
template&lt;int I&gt;
struct B
{
    static const int my_I = I;
    static const int my_I2 = I + 0;
    static const int my_I3 = my_I;
    static const long my_I4 = I;
    static const int my_I5 = (I);
 
    B&lt;my_I&gt;* b1;  // B&lt;my_I&gt; is the current instantiation:
                  //   my_I has the same type as I,
                  //   and it is initialized with only I
    B&lt;my_I2&gt;* b2; // B&lt;my_I2&gt; is not the current instantiation:
                  //   I + 0 is not a single identifier
    B&lt;my_I3&gt;* b3; // B&lt;my_I3&gt; is the current instantiation:
                  //   my_I3 has the same type as I,
                  //   and it is initialized with only my_I (which is equivalent to I)
    B&lt;my_I4&gt;* b4; // B&lt;my_I4&gt; is not the current instantiation:
                  //   the type of my_I4 (long) is not the same as the type of I (int)
    B&lt;my_I5&gt;* b5; // B&lt;my_I5&gt; is not the current instantiation:
                  //   (I) is not a single identifier
};</pre></div> <p>Note that a base class can be the current instantiation if a nested class derives from its enclosing class template. Base classes that are dependent types but aren't the current instantiation are <i>dependent base classes</i>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;class T&gt;
struct A
{
    typedef int M;
 
    struct B
    {
        typedef void M;
 
        struct C;
    };
};
 
template&lt;class T&gt;
struct A&lt;T&gt;::B::C : A&lt;T&gt;
{
    M m; // OK, A&lt;T&gt;::M
};</pre></div> <p>A name is classified as a member of the current instantiation if it is.</p>
<ul>
<li> an unqualified name that is found by <a href="unqualified_lookup" title="cpp/language/unqualified lookup">unqualified lookup</a> in the current instantiation or in its non-dependent base. </li>
<li> <a href="qualified_lookup" title="cpp/language/qualified lookup">qualified name</a>, if the qualifier (the name to the left of <code>::</code>) names the current instantiation and lookup finds the name in the current instantiation or in its non-dependent base </li>
<li> a name used in a class member access expression (<code>y</code> in <code>x.y</code> or <code>xp-&gt;y</code>), where the object expression (<code>x</code> or <code>*xp</code>) is the current instantiation and lookup finds the name in the current instantiation or in its non-dependent base </li>
</ul> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class T&gt;
class A
{
    static const int i = 5;
 
    int n1[i];       // i refers to a member of the current instantiation
    int n2[A::i];    // A::i refers to a member of the current instantiation
    int n3[A&lt;T&gt;::i]; // A&lt;T&gt;::i refers to a member of the current instantiation
 
    int f();
};
 
template&lt;class T&gt;
int A&lt;T&gt;::f()
{
    return i; // i refers to a member of the current instantiation
}</pre></div> <p>Members of the current instantiation may be both dependent and non-dependent.</p>
<p>If the lookup of a member of current instantiation gives a different result between the point of instantiation and the point of definition, the lookup is ambiguous. Note however that when a member name is used, it is not automatically converted to a class member access expression, only explicit member access expressions indicate members of current instantiation:</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct A { int m; };
struct B { int m; };
 
template&lt;typename T&gt;
struct C : A, T
{
    int f() { return this-&gt;m; } // finds A::m in the template definition context
    int g() { return m; }       // finds A::m in the template definition context
};
 
template int C&lt;B&gt;::f(); // error: finds both A::m and B::m
 
template int C&lt;B&gt;::g(); // OK: transformation to class member access syntax
                        // does not occur in the template definition context</pre></div> <h3 id="Unknown_specializations"> Unknown specializations</h3> <p>Within a template definition, certain names are deduced to belong to an <i>unknown specialization</i>, in particular,</p>
<ul>
<li> a <a href="qualified_lookup" title="cpp/language/qualified lookup">qualified name</a>, if any name that appears to the left of <code>::</code> is a <i>dependent type</i> that is not a member of the <i>current instantiation</i> </li>
<li> a <a href="qualified_lookup" title="cpp/language/qualified lookup">qualified name</a>, whose qualifier is the <i>current instantiation</i>, and the name is not found in the current instantiation or any of its non-dependent base classes, and there is a dependent base class </li>
<li> a name of a member in a class member access expression (the <code>y</code> in <code>x.y</code> or <code>xp-&gt;y</code>), if the type of the object expression (<code>x</code> or <code>*xp</code>) is a <i>dependent type</i> and is not the <i>current instantiation</i> </li>
<li> a name of a member in a class member access expression (the <code>y</code> in <code>x.y</code> or <code>xp-&gt;y</code>), if the type of the object expression (<code>x</code> or <code>*xp</code>) is the <i>current instantiation</i>, and the name is not found in the current instantiation or any of its non-dependent base classes, and there is a dependent base class </li>
</ul> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename T&gt;
struct Base {};
 
template&lt;typename T&gt;
struct Derived : Base&lt;T&gt;
{
    void f()
    {
        // Derived&lt;T&gt; refers to current instantiation
        // there is no 'unknown_type' in the current instantiation
        // but there is a dependent base (Base&lt;T&gt;)
        // Therefore, unknown_type is a member of unknown specialization
        typename Derived&lt;T&gt;::unknown_type z;
    }
};
 
template&lt;&gt;
struct Base&lt;int&gt; // this specialization provides it
{
    typedef int unknown_type;
};</pre></div> <p><br> This classification allows the following errors to be detected at the point of template definition (rather than instantiation):</p>
<ul><li> If any template definition has a <a href="qualified_lookup" title="cpp/language/qualified lookup">qualified name</a> in which the qualifier refers to the <i>current instantiation</i> and the name is neither a member of <i>current instantiation</i> nor a member of <i>unknown specialization</i>, the program is ill-formed (no diagnostic required) even if the template is never instantiated. </li></ul> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class T&gt;
class A
{
    typedef int type;
 
    void f()
    {
        A&lt;T&gt;::type i; // OK: 'type' is a member of the current instantiation
        typename A&lt;T&gt;::other j; // Error:
 
        // 'other' is not a member of the current instantiation
        // and it is not a member of an unknown specialization
        // because A&lt;T&gt; (which names the current instantiation),
        // has no dependent bases for 'other' to hide in.
    }
};</pre></div> <ul><li> If any template definition has a member access expression where the object expression is the <i>current instantiation</i>, but the name is neither a member of <i>current instantiation</i> nor a member of <i>unknown specialization</i>, the program is ill-formed even if the template is never instantiated. </li></ul> <p>Members of unknown specialization are always dependent, and are looked up and bound at the point of instantiation as all dependent names (see above).</p>
<h3 id="The_typename_disambiguator_for_dependent_names"> The <span class="kw1">typename</span> disambiguator for dependent names</h3> <p>In a declaration or a definition of a template, including alias template, a name that is not a member of the <i>current instantiation</i> and is dependent on a template parameter is not considered to be a type unless the keyword <code>typename</code> is used or unless it was already established as a type name, e.g. with a typedef declaration or by being used to name a base class.</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
 
int p = 1;
 
template&lt;typename T&gt;
void foo(const std::vector&lt;T&gt; &amp;v)
{
    // std::vector&lt;T&gt;::const_iterator is a dependent name,
    typename std::vector&lt;T&gt;::const_iterator it = v.begin();
 
    // without 'typename', the following is parsed as multiplication
    // of the type-dependent member variable 'const_iterator'
    // and some variable 'p'. Since there is a global 'p' visible
    // at this point, this template definition compiles.
    std::vector&lt;T&gt;::const_iterator* p;
 
    typedef typename std::vector&lt;T&gt;::const_iterator iter_t;
    iter_t * p2; // iter_t is a dependent name, but it's known to be a type name
}
 
template&lt;typename T&gt;
struct S
{
    typedef int value_t; // member of current instantiation
 
    void f()
    {
        S&lt;T&gt;::value_t n{}; // S&lt;T&gt; is dependent, but 'typename' not needed
        std::cout &lt;&lt; n &lt;&lt; '\n';
    }
};
 
int main()
{
    std::vector&lt;int&gt; v;
    foo(v); // template instantiation fails: there is no member variable
            // called 'const_iterator' in the type std::vector&lt;int&gt;
    S&lt;int&gt;().f();
}</pre></div> </div> <p>The keyword <code>typename</code> may only be used in this way before qualified names (e.g. <code>T::x</code>), but the names need not be dependent.</p>
<p>Usual <a href="qualified_lookup" title="cpp/language/qualified lookup">qualified name lookup</a> is used for the identifier prefixed by <code>typename</code>. Unlike the case with <a href="elaborated_type_specifier" title="cpp/language/elaborated type specifier">elaborated type specifier</a>, the lookup rules do not change despite the qualifier:</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct A // A has a nested variable X and a nested type struct X
{
    struct X {};
    int X;
};
 
struct B
{
    struct X {}; // B has a nested type struct X
};
 
template&lt;class T&gt;
void f(T t)
{
    typename T::X x;
}
 
void foo()
{
    A a;
    B b;
    f(b); // OK: instantiates f&lt;B&gt;, T::X refers to B::X
    f(a); // error: cannot instantiate f&lt;A&gt;:
          // because qualified name lookup for A::X finds the data member
}</pre></div> <p>The keyword <code>typename</code> can be used even outside of templates.</p>
<div class="cpp source-cpp"><pre data-language="cpp">#include &lt;vector&gt;
 
int main()
{
    // Both OK (after resolving CWG 382)
    typedef typename std::vector&lt;int&gt;::const_iterator iter_t;
    typename std::vector&lt;int&gt; v;
}</pre></div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>In some contexts, only type names can validly appear. In these contexts, a dependent qualified name is assumed to name a type and no <code>typename</code> is required:</p>
<ul>
<li> A qualified name that is used as a <a href="declarations#Specifiers" title="cpp/language/declarations">declaration specifier</a> in the (top-level) <span class="t-spar">decl-specifier-seq</span> of: </li>
<ul>
<li> a <a href="declarations#Simple_declaration" title="cpp/language/declarations">simple declaration</a> or <a href="function#Function_definition" title="cpp/language/function">function definition</a> at namespace scope; </li>
<li> a <a href="class#Member_specification" title="cpp/language/class">class member declaration</a>; </li>
<li> a <a href="function#Parameter_list" title="cpp/language/function">parameter declaration</a> in a <a href="class#Member_specification" title="cpp/language/class">class member declaration</a> (including friend function declarations), outside of default arguments; </li>
<li> a <a href="function#Parameter_list" title="cpp/language/function">parameter declaration</a> of a <a href="function" title="cpp/language/function">declarator for a function or function template</a> whose name is qualified, outside of default arguments; </li>
<li> a <a href="function#Parameter_list" title="cpp/language/function">parameter declaration</a> of a <a href="lambda" title="cpp/language/lambda">lambda expression</a> outside of default arguments; </li>
<li> a parameter declaration of a <a href="constraints#Requires_expressions" title="cpp/language/constraints">requires-expression</a>; </li>
<li> the type in the declaration of a <a href="template_parameters#Non-type_template_parameter" title="cpp/language/template parameters">non-type template parameter</a>; </li>
</ul>
<li> A qualified name that appears in <i><a href="type#Type_naming" title="cpp/language/type">type-id</a></i>, where the smallest enclosing <i>type-id</i> is: </li>
<ul>
<li> the <span class="t-spar">type</span> in a <a href="new" title="cpp/language/new">new expression</a> that does not parenthesize its type; </li>
<li> the <span class="t-spar">type-id</span> in an <a href="type_alias" title="cpp/language/type alias">alias declaration</a>; </li>
<li> a <a href="function" title="cpp/language/function">trailing return type</a>, </li>
<li> a <a href="template_parameters#Type_template_parameter" title="cpp/language/template parameters">default argument of a type template parameter</a>, or </li>
<li> the <span class="t-spar">type-id</span> of a <a href="static_cast" title="cpp/language/static cast"><code>static_cast</code></a>, <a href="dynamic_cast" title="cpp/language/dynamic cast"><code>dynamic_cast</code></a>, <a href="const_cast" title="cpp/language/const cast"><code>const_cast</code></a>, or <a href="reinterpret_cast" title="cpp/language/reinterpret cast"><code>reinterpret_cast</code></a>. </li>
</ul>
</ul>    </td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <h3 id="The_template_disambiguator_for_dependent_names"> The <span class="kw1">template</span> disambiguator for dependent names</h3> <p>Similarly, in a template definition, a dependent name that is not a member of the <i>current instantiation</i> is not considered to be a template name unless the disambiguation keyword <code>template</code> is used or unless it was already established as a template name:</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename T&gt;
struct S
{
    template&lt;typename U&gt;
    void foo() {}
};
 
template&lt;typename T&gt;
void bar()
{
    S&lt;T&gt; s;
    s.foo&lt;T&gt;();          // error: &lt; parsed as less than operator
    s.template foo&lt;T&gt;(); // OK
}</pre></div> </div> <p>The keyword <code>template</code> may only be used in this way after operators <code>::</code> (scope resolution), <code>-&gt;</code> (member access through pointer), and <code>.</code> (member access), the following are all valid examples:</p>
<ul>
<li> <code>T::template foo&lt;X&gt;();</code> </li>
<li> <code>s.template foo&lt;X&gt;();</code> </li>
<li> <code>this-&gt;template foo&lt;X&gt;();</code> </li>
<li> <code>typename T::template iterator&lt;int&gt;::value_type v;</code> </li>
</ul> <p>As is the case with <code>typename</code>, the <code>template</code> prefix is allowed even if the name is not dependent or the use does not appear in the scope of a template.</p>
<p>Even if the name to the left of <code>::</code> refers to a namespace, the template disambiguator is allowed:</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename&gt;
struct S {};
 
::template S&lt;void&gt; q; // allowed, but unnecessary</pre></div> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx23">
<td> <p>Due to the special rules for <a href="unqualified_lookup" title="cpp/language/unqualified lookup">unqualified name lookup</a> for template names in member access expressions, when a non-dependent template name appears in a member access expression (after <code>-&gt;</code> or after <code>.</code>), the disambiguator is unnecessary if there is a <span class="t-rev-inl t-since-cxx11"><span>class or alias</span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span> template with the same name found by ordinary lookup in the context of the expression. <span class="t-rev-inl t-until-cxx11"><span>However, if the template found by lookup in the context of the expression differs from the one found in the context of the class, the program is ill-formed</span> <span><span class="t-mark-rev t-until-cxx11">(until C++11)</span></span></span>.</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;int&gt;
struct A { int value; };
 
template&lt;class T&gt;
void f(T t)
{
    t.A&lt;0&gt;::value; // Ordinary lookup of A finds a class template.
                   // A&lt;0&gt;::value names member of class A&lt;0&gt;
    // t.A &lt; 0;    // Error: '&lt;' is treated as the start of template argument list
}</pre></div> </td> <td><span class="t-mark-rev t-until-cxx23">(until C++23)</span></td>
</tr> </table> <h3 id="Defect_reports"> Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th> DR </th> <th> Applied to </th> <th> Behavior as published </th> <th> Correct behavior </th>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/206.html">CWG 206</a> </td> <td> C++98 </td> <td> it was unspecified at what point semantic constraints are<br>applied when a type used in a non-dependent name is<br>incomplete at the point at which a template is defined but is<br>complete at the point at which an instantiation is performed </td> <td> the program is ill-formed<br>and no diagnostic is<br>required in this case </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/224.html">CWG 224</a> </td> <td> C++98 </td> <td> the definition of dependent types was based<br>on the form of the name rather than lookup </td> <td> definition revamped </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/382.html">CWG 382</a> </td> <td> C++98 </td> <td> the <code>typename</code> disambiguator was only allowed in template scope </td> <td> also allowed outside<br>of templates </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/468.html">CWG 468</a> </td> <td> C++98 </td> <td> the <code>template</code> disambiguator was only allowed in template scope </td> <td> also allowed outside<br>of templates </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/502.html">CWG 502</a> </td> <td> C++98 </td> <td> it was unspecified whether nested enumerations are dependent </td> <td> dependent as nested classes </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1047.html">CWG 1047</a> </td> <td> C++98 </td> <td> <code>typeid</code> expressions were never value-dependent </td> <td> value-dependent if the<br>operand is type-dependent </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1160.html">CWG 1160</a> </td> <td> C++98 </td> <td> it was unspecified whether a name refers to the current instantiation<br>when a template-id matching a primary template or partial<br>specialization appears in the definition of a member of the template </td> <td> specified </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1413.html">CWG 1413</a> </td> <td> C++98 </td> <td> uninitialized static data member, static member function, and address<br>of member of a class template weren't listed as value-dependent </td> <td> listed </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1471.html">CWG 1471</a> </td> <td> C++98 </td> <td> a nested type of a non-dependent base of<br>the current instantiation was dependent </td> <td> it is not dependent </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1850.html">CWG 1850</a> </td> <td> C++98 </td> <td> the list of cases that meaning may change between the<br>definition context and the point of instantiation was incomplete </td> <td> made complete </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1929.html">CWG 1929</a> </td> <td> C++98 </td> <td> it was not clear whether the <code>template</code> disambiguator can<br>follow a <code>::</code> where the name to its left refers to a namespace </td> <td> allowed </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2100.html">CWG 2100</a> </td> <td> C++98 </td> <td> address of a static data member of class<br>template wasn't listed as value-dependent </td> <td> listed </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2276.html">CWG 2276</a> </td> <td> C++98 </td> <td> a function type whose exception specification<br>is value-dependent was not a dependent type </td> <td> it is </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2307.html">CWG 2307</a> </td> <td> C++98 </td> <td> a parenthesized non-type template parameter used as a<br>template argument was equivalent to that template parameter </td> <td> not equivalent anymore </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2457.html">CWG 2457</a> </td> <td> C++11 </td> <td> a function type with function parameter pack was not a dependent type </td> <td> it is </td>
</tr>
</table>           <div class="_attribution">
  <p class="_attribution-p">
    © cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/language/dependent_name" class="_attribution-link">https://en.cppreference.com/w/cpp/language/dependent_name</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
