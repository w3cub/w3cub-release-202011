
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Virtual Function Specifier - C++ - W3cubDocs</title>
  
  <meta name="description" content="The virtual specifier specifies that a non-static member function is virtual and supports dynamic dispatch. It may only appear in the decl-specifier &hellip;">
  <meta name="keywords" content="virtual, function, specifier, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/language/virtual.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/cpp.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _c">
				
				
<h1 id="firstHeading" class="firstHeading">virtual function specifier</h1>            <p>The <code>virtual</code> specifier specifies that a non-static <a href="member_functions" title="cpp/language/member functions">member function</a> is <i>virtual</i> and supports dynamic dispatch. It may only appear in the <span class="t-spar">decl-specifier-seq</span> of the initial declaration of a non-static member function (i.e., when it is declared in the class definition).</p>
<h3 id="Explanation">Explanation</h3> <p>Virtual functions are member functions whose behavior can be overridden in derived classes. As opposed to non-virtual functions, the overridden behavior is preserved even if there is no compile-time information about the actual type of the class. If a derived class is handled using pointer or reference to the base class, a call to an overridden virtual function would invoke the behavior defined in the derived class. This behavior is suppressed if the function is selected using <a href="lookup" title="cpp/language/lookup">qualified name lookup</a> (that is, if the function's name appears to the right of the scope resolution operator <code>::</code>).</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
struct Base {
   virtual void f() {
       std::cout &lt;&lt; "base\n";
   }
};
struct Derived : Base {
    void f() override { // 'override' is optional
        std::cout &lt;&lt; "derived\n";
    }
};
int main()
{
    Base b;
    Derived d;
 
    // virtual function call through reference
    Base&amp; br = b; // the type of br is Base&amp;
    Base&amp; dr = d; // the type of dr is Base&amp; as  well
    br.f(); // prints "base"
    dr.f(); // prints "derived"
 
    // virtual function call through pointer
    Base* bp = &amp;b; // the type of bp is Base*
    Base* dp = &amp;d; // the type of dp is Base* as  well
    bp-&gt;f(); // prints "base"
    dp-&gt;f(); // prints "derived"
 
    // non-virtual function call
    br.Base::f(); // prints "base"
    dr.Base::f(); // prints "base"
}</pre></div> </div> <h3 id="In_detail">In detail</h3> <p>If some member function <code>vf</code> is declared as <code>virtual</code> in a class <code>Base</code>, and some class <code>Derived</code>, which is derived, directly or indirectly, from <code>Base</code>, has a declaration for member function with the same.</p>
<ul>
<li> name </li>
<li> parameter type list (but not the return type) </li>
<li> cv-qualifiers </li>
<li> ref-qualifiers </li>
</ul> <p>Then this function in the class <code>Derived</code> is also <i>virtual</i> (whether or not the keyword <code>virtual</code> is used in its declaration) and <i>overrides</i> Base::vf (whether or not the word <code>override</code> is used in its declaration).</p>
<p><code>Base::vf</code> does not need to be visible (can be declared private, or inherited using private inheritance) to be overridden.</p>
<div class="cpp source-cpp"><pre data-language="cpp">class B {
    virtual void do_f(); // private member
 public:
    void f() { do_f(); } // public interface
};
struct D : public B {
    void do_f() override; // overrides B::do_f
};
 
int main()
{
    D d;
    B* bp = &amp;d;
    bp-&gt;f(); // internally calls D::do_f();
}</pre></div> <p>For every virtual function, there is the <i>final overrider</i>, which is executed when a virtual function call is made. A virtual member function <code>vf</code> of a base class <code>Base</code> is the final overrider unless the derived class declares or inherits (through multiple inheritance) another function that overrides <code>vf</code>.</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct A { virtual void f(); };     // A::f is virtual
struct B : A { void f(); };         // B::f overrides A::f in B
struct C : virtual B { void f(); }; // C::f overrides A::f in C
struct D : virtual B {}; // D does not introduce an overrider, B::f is final in D
struct E : C, D  {       // E does not introduce an overrider, C::f is final in E
    using A::f; // not a function declaration, just makes A::f visible to lookup
};
int main() {
   E e;
   e.f();    // virtual call calls C::f, the final overrider in e
   e.E::f(); // non-virtual call calls A::f, which is visible in E
}</pre></div> <p>If a function has more than one final overrider, the program is ill-formed:</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct A {
    virtual void f();
};
struct VB1 : virtual A {
    void f(); // overrides A::f
};
struct VB2 : virtual A {
    void f(); // overrides A::f
};
// struct Error : VB1, VB2 {
//     // Error: A::f has two final overriders in Error
// };
struct Okay : VB1, VB2 {
    void f(); // OK: this is the final overrider for A::f
};
struct VB1a : virtual A {}; // does not declare an overrider
struct Da : VB1a, VB2 {
    // in Da, the final overrider of A::f is VB2::f
};</pre></div> <p>A function with the same name but different parameter list does not override the base function of the same name, but <i>hides</i> it: when <a href="lookup" title="cpp/language/lookup">unqualified name lookup</a> examines the scope of the derived class, the lookup finds the declaration and does not examine the base class.</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct B {
    virtual void f();
};
struct D : B {
    void f(int); // D::f hides B::f (wrong parameter list)
};
struct D2 : D {
    void f(); // D2::f overrides B::f (doesn't matter that it's not visible)
};
 
int main()
{
    B b;   B&amp; b_as_b   = b;
    D d;   B&amp; d_as_b   = d;    D&amp; d_as_d = d;
    D2 d2; B&amp; d2_as_b  = d2;   D&amp; d2_as_d = d2;
 
    b_as_b.f(); // calls B::f()
    d_as_b.f(); // calls B::f()
    d2_as_b.f(); // calls D2::f()
 
    d_as_d.f(); // Error: lookup in D finds only f(int)
    d2_as_d.f(); // Error: lookup in D finds only f(int)
}</pre></div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>If a function is declared with the specifier <code>override</code>, but does not override a virtual function, the program is ill-formed:</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct B {
    virtual void f(int);
};
struct D : B {
    virtual void f(int) override; // OK, D::f(int) overrides B::f(int)
    virtual void f(long) override; // Error: f(long) does not override B::f(int)
};</pre></div> <p>If a function is declared with the specifier <code>final</code>, and another function attempts to override it, the program is ill-formed:</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct B {
    virtual void f() const final;
};
struct D : B {
    void f() const; // Error: D::f attempts to override final B::f
};</pre></div> </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <p>Non-member functions and static member functions cannot be virtual.</p>
<p>Functions templates cannot be declared <code>virtual</code>. This applies only to functions that are themselves templates - a regular member function of a class template can be declared virtual.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>Virtual functions (whether declared virtual or overriding one) cannot have any associated constraints.</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct A {
    virtual void f() requires true; // Error: constrained virtual function
};</pre></div> <p>A <a href="consteval" title="cpp/language/consteval"><code>consteval</code></a> virtual function must not override or be overidden by a non-<code>consteval</code> virtual function.</p>
<p>If an overriding function specifies <a href="attributes/contract" title="cpp/language/attributes/contract">contract conditions</a>, it must specify the same list contract conditions as the functions it overrides; no diagnostic is required if corresponding conditions will always evaluate to the same value. Otherwise, it is considered to have the list of contract conditions from one of its overriden functions; the names in the contract conditions are bound and the semantic constraints are checked at the point where the contract conditions appear.</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct A {
    virtual void f(int i) [[expects: i &gt; x]];
    virtual void g(int i) [[expects: i &lt; x]];
    virtual void h(int i) [[expects: i &lt; 0]];
    int x;
};
 
struct B : A {
    virtual void f(int i); // OK, 'x' in precondition means A::x
    virtual void g(int i) [[expects: i &lt; x]]; // error
    virtual void h(int i) [[expects: i &lt; 1]]; // error
    std::string x;
};
 
struct C : A {
    virtual void f(int i) [[expects: i &gt; x]]; // OK
    virtual void g(int i) [[expects: i &lt; A::x]]; // ill-formed, no diagnostic required
};</pre></div> <p>If a contract condition of a virtual function <code>f</code> odr-uses <code>*this</code>, the class of which <code>f</code> is a direct member must be an unambiguous and accessible base class of any class in which <code>f</code> is overridden.</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct A {
    virtual void g() [[expects: x == 0]]; // odr-uses *this
    int x = 42;
};
struct B : A { };
 
struct C : A, B {
    virtual void g(); //error, A is an ambiguous base
};</pre></div> <p>If a function overrides more than one function, all of the overridden functions must have the same list of contract conditions; no diagnostic is required if corresponding conditions will always evaluate to the same value.</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct A {
    virtual void g() [[expects: x == 0]]; // x means A::x
    int x = 42;
};
 
int x = 42;
struct B {
  virtual void g() [[expects: x == 0]]; // x means ::x
}
 
struct C : A, B {
    virtual void g(); //error
};</pre></div> </td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <p><a href="default_arguments" title="cpp/language/default arguments">Default arguments</a> for virtual functions are substituted at the compile time.</p>
<h4 id="Covariant_return_types">Covariant return types</h4> <p>If the function <code>Derived::f</code> overrides a function <code>Base::f</code>, their return types must either be the same or be <i>covariant</i>. Two types are covariant if they satisfy all of the following requirements:</p>
<ul>
<li> both types are pointers or references (lvalue or rvalue) to classes. Multi-level pointers or references are not allowed. </li>
<li> the referenced/pointed-to class in the return type of <code>Base::f()</code> must be a unambiguous and accessible direct or indirect base class of the referenced/pointed-to class of the return type of <code>Derived::f()</code>. </li>
<li> the return type of <code>Derived::f()</code> must be equally or less <a href="cv" title="cpp/language/cv"> cv-qualified</a> than the return type of <code>Base::f()</code>. </li>
</ul> <p>The class in the return type of <code>Derived::f</code> must be either <code>Derived</code> itself, or must be a <a href="incomplete_type" title="cpp/language/incomplete type" class="mw-redirect">complete type</a> at the point of declaration of <code>Derived::f</code>.</p>
<p>When a virtual function call is made, the type returned by the final overrider is <a href="implicit_cast" title="cpp/language/implicit cast" class="mw-redirect">implicitly converted</a> to the return type of the overridden function that was called:</p>
<div class="cpp source-cpp"><pre data-language="cpp">class B {};
 
struct Base {
    virtual void vf1();
    virtual void vf2();
    virtual void vf3();
    virtual B* vf4();
    virtual B* vf5();
};
 
class D : private B {
    friend struct Derived; // in Derived, B is an accessible base of D
};
 
class A; // forward-declared class is an incomplete type
 
struct Derived : public Base {
    void vf1();    // virtual, overrides Base::vf1()
    void vf2(int); // non-virtual, hides Base::vf2()
//  char vf3();    // Error: overrides Base::vf3, but has different
                   // and non-covariant return type
    D* vf4();      // overrides Base::vf4() and has covariant return type
//  A* vf5();      // Error: A is incomplete type
};
 
int main()
{
    Derived d;
    Base&amp; br = d;
    Derived&amp; dr = d;
 
    br.vf1(); // calls Derived::vf1()
    br.vf2(); // calls Base::vf2()
//  dr.vf2(); // Error: vf2(int) hides vf2()
 
    B* p = br.vf4(); // calls Derived::vf4() and converts the result to B*
    D* q = dr.vf4(); // calls Derived::vf4() and does not convert
                     //  the result to B*
 
}</pre></div> <h4 id="Virtual_destructor">Virtual destructor</h4> <p>Even though destructors are not inherited, if a base class declares its destructor <code>virtual</code>, the derived destructor always overrides it. This makes it possible to delete dynamically allocated objects of polymorphic type through pointers to base.</p>
<div class="cpp source-cpp"><pre data-language="cpp">class Base {
 public:
    virtual ~Base() { /* releases Base's resources */ }
};
 
class Derived : public Base {
    ~Derived() { /* releases Derived's resources */ }
};
 
int main()
{
    Base* b = new Derived;
    delete b; // Makes a virtual function call to Base::~Base()
              // since it is virtual, it calls Derived::~Derived() which can
              // release resources of the derived class, and then calls
              // Base::~Base() following the usual order of destruction
}</pre></div> <p>Moreover, if a class is <i>polymorphic</i> (declares or inherits at least one virtual function), and its destructor is not virtual, deleting it is <i>undefined behavior</i> regardless of whether there are resources that would be leaked if the derived destructor is not invoked.</p>
<p>A useful guideline is that the destructor of any base class must be <a rel="nofollow" class="external text" href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#discussion-make-base-class-destructors-public-and-virtual-or-protected-and-nonvirtual">public and virtual or protected and non-virtual</a>.</p>
<h3 id="During_construction_and_destruction">During construction and destruction</h3> <p>When a virtual function is called directly or indirectly from a constructor or from a destructor (including during the construction or destruction of the class’s non-static data members, e.g. in a member <a href="constructor" title="cpp/language/initializer list">initializer list</a>), and the object to which the call applies is the object under construction or destruction, the function called is the final overrider in the constructor’s or destructor’s class and not one overriding it in a more-derived class. In other words, during construction or destruction, the more-derived classes do not exist.</p>
<p>When constructing a complex class with multiple branches, within a constructor that belongs to one branch, polymorphism is restricted to that class and its bases: if it obtains a pointer or reference to a base subobject outside this subhierarchy, and attempts to invoke a virtual function call (e.g. using explicit member access), the behavior is undefined:</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct V {
    virtual void f();
    virtual void g();
};
 
struct A : virtual V {
    virtual void f(); // A::f is the final overrider of V::f in A
};
struct B : virtual V {
    virtual void g(); // B::g is the final overrider of V::g in B
    B(V*, A*);
};
struct D : A, B {
    virtual void f(); // D::f is the final overrider of V::f in D
    virtual void g(); // D::g is the final overrider of V::g in D
 
    // note: A is initialized before B
    D() : B((A*)this, this) 
    {
    }
};
 
// the constructor of B, called from the constructor of D 
B::B(V* v, A* a)
{
    f(); // virtual call to V::f (although D has the final overrider, D doesn't exist)
    g(); // virtual call to B::g, which is the final overrider in B 
 
    v-&gt;g(); // v's type V is base of B, virtual call calls B::g as before
 
    a-&gt;f(); // a’s type A is not a base of B. it belongs to a different branch of the
            // hierarchy. Attempting a virtual call through that branch causes
            // undefined behavior even though A was already fully constructed in this
            // case (it was constructed before B since it appears before B in the list
            // of the bases of D). In practice, the virtual call to A::f will be
            // attempted using B's virtual member function table, since that's what
            // is active during B's construction)
}</pre></div> <h3 id="See_also">See also</h3> <ul>
<li> <a href="derived_class" title="cpp/language/derived class"> derived classes and modes of inheritance </a> </li>
<li> <a href="override" title="cpp/language/override"> override specifier</a> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </li>
<li> <a href="final" title="cpp/language/final"> final specifier</a> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </li>
</ul>          <div class="_attribution">
  <p class="_attribution-p">
    © cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/language/virtual" class="_attribution-link">http://en.cppreference.com/w/cpp/language/virtual</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
