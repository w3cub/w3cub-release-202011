
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Parameter Pack(since C++11) - C++ - W3cubDocs</title>
  
  <meta name="description" content="A template parameter pack is a template parameter that accepts zero or more template arguments (non-types, types, or templates). A function &hellip;">
  <meta name="keywords" content="parameter, pack, since, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/language/parameter_pack.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/cpp.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _c">
				
				
<h1 id="firstHeading" class="firstHeading">Parameter pack<span class="t-mark-rev t-since-cxx11">(since C++11)</span>
</h1>            <p>A template parameter pack is a template parameter that accepts zero or more template arguments (non-types, types, or templates). A function parameter pack is a function parameter that accepts zero or more function arguments.</p>
<p>A template with at least one parameter pack is called a <i>variadic template</i>.</p>
<h3 id="Syntax">Syntax</h3> <p>Template parameter pack (appears in <a href="type_alias" title="cpp/language/type alias">alias template</a>, <a href="class_template" title="cpp/language/class template">class template</a> and <a href="function_template" title="cpp/language/function template">function template</a> parameter lists).</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">type</span> <code>...</code> <span class="t-spar">Args</span><span class="t-mark">(optional)</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>typename|class</code> <code>...</code> <span class="t-spar">Args</span><span class="t-mark">(optional)</span> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>template</code> <code>&lt;</code> <span class="t-spar">parameter-list</span> <code>&gt;</code> <code>typename<span class="t-mark-rev t-since-cxx17">(C++17)</span>|class</code> <code>...</code> <span class="t-spar">Args</span><span class="t-mark">(optional)</span> </td> <td> (3) </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <p>Function parameter pack (a form of <a href="declarations" title="cpp/language/declarations">declarator</a>, appears in a function parameter list of a variadic function template).</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">Args</span> <code>...</code> <span class="t-spar">args</span><span class="t-mark">(optional)</span> </td> <td> (4) </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <p>Parameter pack expansion (appears in a body of a variadic template).</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">pattern</span> <code>...</code> </td> <td> (5) </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <div class="t-li1">
<span class="t-li">1)</span> A non-type template parameter pack with an optional name</div> <div class="t-li1">
<span class="t-li">2)</span> A type template parameter pack with an optional name</div> <div class="t-li1">
<span class="t-li">3)</span> A template template parameter pack with an optional name</div> <div class="t-li1">
<span class="t-li">4)</span> A function parameter pack with an optional name</div> <div class="t-li1">
<span class="t-li">5)</span> Parameter pack expansion: expands to comma-separated list of zero or more <code>pattern</code>s. Pattern must include at least one parameter pack.</div> <h3 id="Explanation">Explanation</h3> <p>A variadic class template can be instantiated with any number of template arguments:</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;class ... Types&gt; struct Tuple {};
Tuple&lt;&gt; t0;           // Types contains no arguments
Tuple&lt;int&gt; t1;        // Types contains one argument: int
Tuple&lt;int, float&gt; t2; // Types contains two arguments: int and float
Tuple&lt;0&gt; error;       // error: 0 is not a type</pre></div> <p>A variadic function template can be called with any number of function arguments (the template arguments are deduced through <a href="template_argument_deduction" title="cpp/language/template argument deduction">template argument deduction</a>):</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;class ... Types&gt; void f(Types ... args);
f();       // OK: args contains no arguments
f(1);      // OK: args contains one argument: int
f(2, 1.0); // OK: args contains two arguments: int and double</pre></div> <p>In a primary class template, the template parameter pack must be the final parameter in the template parameter list. In a function template, the template parameter pack may appear earlier in the list provided that all following parameters can be deduced from the function arguments, or have default arguments:</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename... Ts, typename U&gt; struct Invalid; // Error: Ts.. not at the end
 
template&lt;typename ...Ts, typename U, typename=void&gt;
void valid(U, Ts...);     // OK: can deduce U
// void valid(Ts..., U);  // Can't be used: Ts... is a non-deduced context in this position
 
valid(1.0, 1, 2, 3);      // OK: deduces U as double, Ts as {int,int,int}</pre></div> <h3 id="Pack_expansion">Pack expansion</h3> <p>A pattern followed by an ellipsis, in which the name of at least one parameter pack appears at least once, is <i>expanded</i> into zero or more comma-separated instantiations of the pattern, where the name of the parameter pack is replaced by each of the elements from the pack, in order.</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;class ...Us&gt; void f(Us... pargs) {}
template&lt;class ...Ts&gt; void g(Ts... args) {
    f(&amp;args...); // “&amp;args...” is a pack expansion
                 // “&amp;args” is its pattern
}
g(1, 0.2, "a"); // Ts... args expand to int E1, double E2, const char* E3
                // &amp;args... expands to &amp;E1, &amp;E2, &amp;E3
                // Us... pargs expand to int* E1, double* E2, const char** E3</pre></div> <p>If the names of two parameter packs appear in the same pattern, they are expanded simultaneously, and they must have the same length:</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename...&gt; struct Tuple {};
template&lt;typename T1, typename T2&gt; struct Pair {};
 
template&lt;class ...Args1&gt; struct zip {
    template&lt;class ...Args2&gt; struct with {
        typedef Tuple&lt;Pair&lt;Args1, Args2&gt;...&gt; type;
//        Pair&lt;Args1, Args2&gt;... is the pack expansion
//        Pair&lt;Args1, Args2&gt; is the pattern
    };
};
 
typedef zip&lt;short, int&gt;::with&lt;unsigned short, unsigned&gt;::type T1;
// Pair&lt;Args1, Args2&gt;... expands to
// Pair&lt;short, unsigned short&gt;, Pair&lt;int, unsigned int&gt; 
// T1 is Tuple&lt;Pair&lt;short, unsigned short&gt;, Pair&lt;int, unsigned&gt;&gt;
 
typedef zip&lt;short&gt;::with&lt;unsigned short, unsigned&gt;::type T2;
// error: pack expansion contains parameter packs of different lengths</pre></div> <p>If a pack expansion is nested within another pack expansion, the parameter packs that appear inside the innermost pack expansion are expanded by it, and there must be another pack mentioned in the enclosing pack expansion, but not in the innermost one:</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;class ...Args&gt;
    void g(Args... args) {
        f(const_cast&lt;const Args*&gt;(&amp;args)...); 
 // const_cast&lt;const Args*&gt;(&amp;args) is the pattern, it expands two packs
 // (Args and args) simultaneously
 
        f(h(args...) + args...); // Nested pack expansion:
   // inner pack expansion is "args...", it is expanded first
   // outer pack expansion is h(E1, E2, E3) + args..., it is expanded
   // second (as h(E1,E2,E3) + E1, h(E1,E2,E3) + E2, h(E1,E2,E3) + E3)
}</pre></div> <h3 id="Expansion_loci">Expansion loci</h3> <p>Depending on where the expansion takes place, the resulting comma-separated list is a different kind of list: function parameter list, member initializer list, attribute list, etc. The following is the list of all allowed contexts.</p>
<h4 id="Function_argument_lists">Function argument lists</h4> <p>A pack expansion may appear inside the parentheses of a function call operator, in which case the largest expression or braced-init-list to the left of the ellipsis is the pattern that is expanded.</p>
<div class="cpp source-cpp"><pre data-language="cpp">f(&amp;args...); // expands to f(&amp;E1, &amp;E2, &amp;E3)
f(n, ++args...); // expands to f(n, ++E1, ++E2, ++E3);
f(++args..., n); // expands to f(++E1, ++E2, ++E3, n);
f(const_cast&lt;const Args*&gt;(&amp;args)...);
// f(const_cast&lt;const E1*&gt;(&amp;X1), const_cast&lt;const E2*&gt;(&amp;X2), const_cast&lt;const E3*&gt;(&amp;X3))
f(h(args...) + args...); // expands to 
// f(h(E1,E2,E3) + E1, h(E1,E2,E3) + E2, h(E1,E2,E3) + E3)</pre></div> <p>Formally, the <i>expression-list</i> in a function call expression is classified as <i>initializer-list</i>, and the pattern is the <i>initializer-clause</i>, which is either an <i>assignment-expression</i> or a <i>braced-init-list</i>.</p>
<h4 id="Parenthesized_initializers">Parenthesized initializers</h4> <p>A pack expansion may appear inside the parentheses of a <a href="direct_initialization" title="cpp/language/direct initialization">direct initializer</a>, a <a href="explicit_cast" title="cpp/language/explicit cast">function-style cast</a>, and other contexts (<a href="constructor" title="cpp/language/initializer list">member initializer</a>, <a href="new" title="cpp/language/new">new-expression</a>, etc) in which case the rules are identical to the rules for a function call expression above.</p>
<div class="cpp source-cpp"><pre data-language="cpp">Class c1(&amp;args...);             // calls Class::Class(&amp;E1, &amp;E2, &amp;E3)
Class c2 = Class(n, ++args...); // calls Class::Class(n, ++E1, ++E2, ++E3);
::new((void *)p) U(std::forward&lt;Args&gt;(args)...) // std::allocator::allocate</pre></div> <h4 id="Brace-enclosed_initializers">Brace-enclosed initializers</h4> <p>In a <i>braced-init-list</i> (brace-enclosed list of initializers and other <i>braced-init-list</i>s, used in <a href="list_initialization" title="cpp/language/list initialization">list-initialization</a> and some other contexts), a pack expansion may appear as well:</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename... Ts&gt; void func(Ts... args){
    const int size = sizeof...(args) + 2;
    int res[size] = {1,args...,2};
    // since initializer lists guarantee sequencing, this can be used to
    // call a function on each element of a pack, in order:
    int dummy[sizeof...(Ts)] = { (std::cout &lt;&lt; args, 0)... };
}</pre></div> <h4 id="Template_argument_lists">Template argument lists</h4> <p>Pack expansions can be used anywhere in a template argument list, provided the template has the parameters to match the expansion.</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;class A, class B, class...C&gt; void func(A arg1, B arg2, C...arg3)
{
    container&lt;A,B,C...&gt; t1;  // expands to container&lt;A,B,E1,E2,E3&gt; 
    container&lt;C...,A,B&gt; t2;  // expands to container&lt;E1,E2,E3,A,B&gt; 
    container&lt;A,C...,B&gt; t3;  // expands to container&lt;A,E1,E2,E3,B&gt; 
}</pre></div> <h4 id="Function_parameter_list">Function parameter list</h4> <p>In a function parameter list, if an ellipsis appears in a parameter declaration (whether it names a function parameter pack (as in, <span class="t-spar">Args</span> <code>...</code> <span class="t-spar">args</span>) or not) the parameter declaration is the pattern:</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename ...Ts&gt; void f(Ts...) {}
f('a', 1);  // Ts... expands to void f(char, int)
f(0.1);     // Ts... expands to void f(double)
 
template&lt;typename ...Ts, int... N&gt; void g(Ts (&amp;...arr)[N]) {}
int n[1];
g&lt;const char, int&gt;("a", n); // Ts (&amp;...arr)[N] expands to 
                            // const char (&amp;)[2], int(&amp;)[1]</pre></div> <p>Note: In the pattern <code>Ts (&amp;...arr)[N]</code>, the ellipsis is the innermost element, not the last element as in all other pack expansions.</p>
<p>Note: <code>Ts (&amp;...)[N]</code> is not allowed because the C++11 grammar requires the parenthesized ellipsis to have a name: <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1488">CWG #1488</a>.</p>
<h4 id="Template_parameter_list">Template parameter list</h4> <p>Pack expansion may appear in a template parameter list:</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename... T&gt; struct value_holder
{
    template&lt;T... Values&gt; // expands to a non-type template parameter 
    struct apply { };     // list, such as &lt;int, char, int(&amp;)[5]&gt;
};</pre></div> <h4 id="Base_specifiers_and_member_initializer_lists">Base specifiers and member initializer lists</h4> <p>A pack expansion may designate the list of base classes in a <a href="class" title="cpp/language/class">class declaration</a>. Typically, this also means that the constructor needs to use a pack expansion in the <a href="constructor" title="cpp/language/initializer list">member initializer list</a> to call the constructors of these bases:</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;class... Mixins&gt;
class X : public Mixins... {
 public:
    X(const Mixins&amp;... mixins) : Mixins(mixins)... { }
};</pre></div> <h4 id="Lambda_captures">Lambda captures</h4> <p>A parameter pack may appear in the capture clause of a <a href="lambda" title="cpp/language/lambda">lambda</a> expression.</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;class ...Args&gt;
void f(Args... args) {
    auto lm = [&amp;, args...] { return g(args...); };
    lm();
}</pre></div> <h4 id="The_sizeof..._operator">The sizeof... operator</h4> <p>The <a href="sizeof..." title="cpp/language/sizeof...">sizeof...</a> operator is classified as a pack expansion as well.</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;class... Types&gt;
struct count {
    static const std::size_t value = sizeof...(Types);
};</pre></div> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx17">
<td> <h4 id="Dynamic_exception_specifications"> Dynamic exception specifications</h4> <p>The list of exceptions in a <a href="except_spec" title="cpp/language/except spec">dynamic exception specification</a> may also be a pack expansion.</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;class...X&gt; void func(int arg) throw(X...)
{
 // ... throw different Xs in different situations
}</pre></div> </td> <td><span class="t-mark-rev t-until-cxx17">(until C++17)</span></td>
</tr> </table> <h4 id="Alignment_specifier">Alignment specifier</h4> <p>Pack expansions are allowed in both the lists of types and the lists of expressions used by the keyword <a href="alignas" title="cpp/language/alignas">alignas</a>.</p>
<h4 id="Attribute_list">Attribute list</h4> <p>Pack expansions are allowed in the lists of <a href="attributes" title="cpp/language/attributes">attributes</a>, as in <code>[[attributes...]]</code>. For example: <code>void [[attributes...]] function()</code>.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <h4 id="Fold-expressions"> Fold-expressions</h4> <p>In <a href="fold" title="cpp/language/fold">fold-expressions</a>, the pattern is the entire subexpression that does not contain an unexpanded parameter pack.</p>
<h4 id="Using-declarations"> Using-declarations</h4> <p>In <a href="using_declaration" title="cpp/language/using declaration">using declaration</a>, ellipsis may appear in the list of declarators, this is useful when deriving from a parameter pack:</p>
<div class="cpp source-cpp"><pre data-language="cpp">template &lt;typename... bases&gt;
struct X : bases... {
        using bases::g...;
};
X&lt;B, D&gt; x; // OK: B::g and D::g introduced</pre></div> </td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <h3 id="Notes">Notes</h3>  <h3 id="Example">Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
 
void tprintf(const char* format) // base function
{
    std::cout &lt;&lt; format;
}
 
template&lt;typename T, typename... Targs&gt;
void tprintf(const char* format, T value, Targs... Fargs) // recursive variadic function
{
    for ( ; *format != '\0'; format++ ) {
        if ( *format == '%' ) {
           std::cout &lt;&lt; value;
           tprintf(format+1, Fargs...); // recursive call
           return;
        }
        std::cout &lt;&lt; *format;
    }
}
 
int main()
{
    tprintf("% world% %\n","Hello",'!',123);
    return 0;
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">Hello world! 123</pre></div> </div> <p>The above example defines a function similar to <code><a href="../io/c/printf" title="cpp/io/c/fprintf">std::printf</a></code>, that replace each occurrence of the character % in the format string with a value.</p>
<p>The first overload is called when only the format string is passed and there is no parameter expansion.</p>
<p>The second overload contains a separate template parameter for the head of the arguments and a parameter pack, this allows the recursive call to pass only the tail of the parameters until it becomes empty.</p>
<p><code>Targs</code> is the template parameter pack and <code>Fargs</code> is the function parameter pack.</p>
<h3 id="See_also">See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td colspan="2"> <a href="function_template" title="cpp/language/function template">function template</a> </td>
</tr> <tr class="t-dsc"> <td colspan="2"> <a href="class_template" title="cpp/language/class template">class template</a> </td>
</tr> <tr class="t-dsc"> <td> <a href="sizeof..." title="cpp/language/sizeof..."><code>sizeof...</code></a> </td> <td> Queries the number of elements in a parameter pack. </td>
</tr> <tr class="t-dsc"> <td colspan="2"> <a href="../utility/variadic" title="cpp/utility/variadic">C-style variadic functions</a> </td>
</tr> <tr class="t-dsc"> <td> <a href="../preprocessor/replace" title="cpp/preprocessor/replace"> Preprocessor macros</a> </td> <td> Can be variadic as well </td>
</tr> </table>          <div class="_attribution">
  <p class="_attribution-p">
    © cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/language/parameter_pack" class="_attribution-link">http://en.cppreference.com/w/cpp/language/parameter_pack</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
