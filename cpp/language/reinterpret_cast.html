
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Reinterpret_cast Conversion - C++ - W3cubDocs</title>
  
  <meta name="description" content=" Converts between types by reinterpreting the underlying bit pattern. ">
  <meta name="keywords" content="reinterpret, cast, conversion, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/language/reinterpret_cast.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/cpp.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _c">
				
				
<h1 id="firstHeading" class="firstHeading">reinterpret_cast conversion</h1>            <p>Converts between types by reinterpreting the underlying bit pattern.</p>
<h3 id="Syntax">Syntax</h3> <table class="t-sdsc-begin">  <tr class="t-sdsc"> <td class="t-sdsc-nopad"> <code>reinterpret_cast &lt;</code> <span class="t-spar">new_type</span> <code>&gt; (</code> <span class="t-spar">expression</span> <code>)</code> </td> <td class="t-sdsc-nopad"> </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <p>Returns a value of type <code>new_type</code>.</p>
<h3 id="Explanation">Explanation</h3> <p>Unlike <code>static_cast</code>, but like <code>const_cast</code>, the <code>reinterpret_cast</code> expression does not compile to any CPU instructions (except when converting between integers and pointers or on obscure architectures where pointer representation depends on its type). It is purely a compile-time directive which instructs the compiler to treat <span class="t-spar">expression</span> as if it had the type <span class="t-spar">new_type</span>.</p>
<p>Only the following conversions can be done with <code>reinterpret_cast</code>, except when such conversions would cast away <i>constness</i> or <i>volatility</i>.</p>
<div class="t-li1">
<span class="t-li">1)</span> An expression of integral, enumeration, pointer, or pointer-to-member type can be converted to its own type. The resulting value is the same as the value of <code>expression</code>. <span class="t-mark-rev t-since-cxx11">(since C++11)</span>
</div> <div class="t-li1">
<span class="t-li">2)</span> A pointer can be converted to any integral type large enough to hold all values of its type (e.g. to <code><a href="../types/integer" title="cpp/types/integer">std::uintptr_t</a></code>)</div> <div class="t-li1">
<span class="t-li">3)</span> A value of any integral or enumeration type can be converted to a pointer type. A pointer converted to an integer of sufficient size and back to the same pointer type is guaranteed to have its original value, otherwise the resulting pointer cannot be dereferenced safely (the round-trip conversion in the opposite direction is not guaranteed; the same pointer may have multiple integer representations) The null pointer constant <code><a href="../types/null" title="cpp/types/NULL">NULL</a></code> or integer zero is not guaranteed to yield the null pointer value of the target type; <a href="static_cast" title="cpp/language/static cast">static_cast</a> or <a href="implicit_cast" title="cpp/language/implicit cast" class="mw-redirect">implicit conversion</a> should be used for this purpose.</div> <div class="t-li1">
<span class="t-li">4)</span> Any value of type <code><a href="../types/nullptr_t" title="cpp/types/nullptr t">std::nullptr_t</a></code>, including <code>nullptr</code> can be converted to any integral type as if it were <code>(void*)0</code>, but no value, not even <code>nullptr</code> can be converted to <code><a href="../types/nullptr_t" title="cpp/types/nullptr t">std::nullptr_t</a></code>: <code>static_cast</code> should be used for that purpose. <span class="t-mark-rev t-since-cxx11">(since C++11)</span>
</div> <div class="t-li1">
<span class="t-li">5)</span> Any object pointer type <code>T1*</code> can be converted to another object pointer type <code><i>cv</i> T2*</code>. This is exactly equivalent to <code>static_cast&lt;cv T2*&gt;(static_cast&lt;cv void*&gt;(expression))</code> (which implies that if <code>T2</code>'s alignment requirement is not stricter than <code>T1</code>'s, the value of the pointer does not change and conversion of the resulting pointer back to its original type yields the original value). In any case, the resulting pointer may only be dereferenced safely if allowed by the <i>type aliasing</i> rules (see below) </div> <div class="t-li1">
<span class="t-li">6)</span> An lvalue expression of type <code>T1</code> can be converted to reference to another type <code>T2</code>. The result is an lvalue or xvalue referring to the same object as the original lvalue, but with a different type. No temporary is created, no copy is made, no constructors or conversion functions are called. The resulting reference can only be accessed safely if allowed by the <i>type aliasing</i> rules (see below)</div> <div class="t-li1">
<span class="t-li">7)</span> Any pointer to function can be converted to a pointer to a different function type. Calling the function through a pointer to a different function type is undefined, but converting such pointer back to pointer to the original function type yields the pointer to the original function.</div> <div class="t-li1">
<span class="t-li">8)</span> On some implementations (in particular, on any POSIX compatible system as required by <a rel="nofollow" class="external text" href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/dlsym.html">dlsym</a>), a function pointer can be converted to <code>void*</code> or any other object pointer, or vice versa. If the implementation supports conversion in both directions, conversion to the original type yields the original value, otherwise the resulting pointer cannot be dereferenced or called safely. </div> <div class="t-li1">
<span class="t-li">9)</span> The null pointer value of any pointer type can be converted to any other pointer type, resulting in the null pointer value of that type. Note that the null pointer constant <code>nullptr</code> or any other value of type <code><a href="../types/nullptr_t" title="cpp/types/nullptr t">std::nullptr_t</a></code> cannot be converted to a pointer with <code>reinterpret_cast</code>: implicit conversion or <code>static_cast</code> should be used for this purpose.</div> <div class="t-li1">
<span class="t-li">10)</span> A pointer to member function can be converted to pointer to a different member function of a different type. Conversion back to the original type yields the original value, otherwise the resulting pointer cannot be used safely.</div> <div class="t-li1">
<span class="t-li">11)</span> A pointer to member object of some class <code>T1</code> can be converted to a pointer to another member object of another class <code>T2</code>. If <code>T2</code>'s alignment is not stricter than <code>T1</code>'s, conversion back to the original type <code>T1</code> yields the original value, otherwise the resulting pointer cannot be used safely.</div> <p>As with all cast expressions, the result is:</p>
<ul>
<li> an lvalue if <span class="t-spar">new_type</span> is an lvalue reference type or an rvalue reference to function type; </li>
<li> an xvalue if <span class="t-spar">new_type</span> is an rvalue reference to object type; </li>
<li> a prvalue otherwise. </li>
</ul> <h3 id="Keywords">Keywords</h3> <p><a href="../keyword/reinterpret_cast" title="cpp/keyword/reinterpret cast"><code>reinterpret_cast</code></a>.</p>
<h3 id="Type_aliasing"> Type aliasing </h3> <p>Whenever an attempt is made to read or modify the stored value of an object of type <code>DynamicType</code> through a glvalue of type <code>AliasedType</code>, the behavior is undefined unless one of the following is true:</p>
<ul>
<li> <code>AliasedType</code> and <code>DynamicType</code> are <i>similar</i>. </li>
<li> <code>AliasedType</code> is the (possibly <a href="cv" title="cpp/language/cv">cv</a>-qualified) signed or unsigned variant of <code>DynamicType</code>. </li>
<li> <code>AliasedType</code> is <span class="t-rev-inl t-since-cxx17"><span><a href="../types/byte" title="cpp/types/byte"><code>std::byte</code></a>, </span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span><code>char</code>, or <code>unsigned char</code>: this permits examination of the <a href="objects#Object_representation_and_value_representation" title="cpp/language/object">object representation</a> of any object as an array of bytes. </li>
</ul> <p>Informally, two types are <i>similar</i> if, ignoring top-level cv-qualification:</p>
<ul>
<li> they are the same type; or </li>
<li> they are both pointers, and the pointed-to types are similar; or </li>
<li> they are both pointers to member of the same class, and the types of the pointed-to members are similar; or </li>
<li> they are both arrays of the same size or both arrays of unknown bound, and the array element types are similar. </li>
</ul> <p>For example:</p>
<ul>
<li>
<code>const int * volatile *</code> and <code>int * * const</code> are similar; </li>
<li>
<code>const int (* volatile S::* const)[20]</code> and <code>int (* const S::* volatile)[20]</code> are similar; </li>
<li>
<code>int (* const *)(int *)</code> and <code>int (* volatile *)(int *)</code> are similar; </li>
<li>
<code>int (S::*)() const</code> and <code>int (S::*)()</code> are <i>not</i> similar; </li>
<li>
<code>int (*)(int *)</code> and <code>int (*)(const int *)</code> are <i>not</i> similar; </li>
<li>
<code>const int (*)(int *)</code> and <code>int (*)(int *)</code> are <i>not</i> similar; </li>
<li>
<code>int (*)(int * const)</code> and <code>int (*)(int *)</code> are similar (they are the same type); </li>
<li>
<code><a href="../utility/pair"><span class="kw1093">std::<span class="me2">pair</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span>, <span class="kw4">int</span><span class="sy1">&gt;</span></code> and <code><a href="../utility/pair"><span class="kw1093">std::<span class="me2">pair</span></span></a><span class="sy1">&lt;</span><span class="kw4">const</span> <span class="kw4">int</span>, <span class="kw4">int</span><span class="sy1">&gt;</span></code> are <i>not</i> similar. </li>
</ul> <p>This rule enables type-based alias analysis, in which a compiler assumes that the value read through a glvalue of one type is not modified by a write to a glvalue of a different type (subject to the exceptions noted above).</p>
<p>Note that many C++ compilers relax this rule, as a non-standard language extension, to allow wrong-type access through the inactive member of a <a href="union" title="cpp/language/union">union</a> (such access is not undefined in C).</p>
<h3 id="Notes"> Notes </h3> <p>The paragraph defining the strict aliasing rule in the standard contains two additional bullets partially inherited from C:</p>
<ul>
<li> <code>AliasedType</code> is an <a href="aggregate_initialization" title="cpp/language/aggregate initialization">aggregate type</a> or a <a href="union" title="cpp/language/union">union</a> type which holds one of the aforementioned types as an element or non-static member (including, recursively, elements of subaggregates and non-static data members of the contained unions). </li>
<li> <code>AliasedType</code> is a (possibly <a href="cv" title="cpp/language/cv">cv</a>-qualified) <a href="derived_class" title="cpp/language/derived class">base class</a> of <code>DynamicType</code>. </li>
</ul> <p>These bullets describe situations that cannot arise in C++ and therefore are omitted from the discussion above. In C, aggregate copy and assignment access the aggregate object as a whole. But in C++ such actions are always performed through a member function call, which accesses the individual subobjects rather than the entire object (or, in the case of unions, copies the object representation, i.e., via <code>unsigned char</code>). See <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#2051">core issue 2051</a>.</p>
<p>Assuming that alignment requirements are met, a <code>reinterpret_cast</code> does not change the <a href="pointer#Pointers" title="cpp/language/pointer">value of a pointer</a> outside of a few limited cases dealing with <a href="static_cast#pointer-interconvertible" title="cpp/language/static cast"><i>pointer-interconvertible</i></a> objects:</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct S1 { int a; } s1;
struct S2 { int a; private: int b; } s2; // not standard-layout
union U { int a; double b; } u = {0};
int arr[2];
 
int* p1 = reinterpret_cast&lt;int*&gt;(&amp;s1); // value of p1 is "pointer to s1.a" because s1.a
                                       // and s1 are pointer-interconvertible
 
int* p2 = reinterpret_cast&lt;int*&gt;(&amp;s2); // value of p2 is unchanged by reinterpret_cast and
                                       // is "pointer to s2". 
 
int* p3 = reinterpret_cast&lt;int*&gt;(&amp;u);  // value of p3 is "pointer to u.a": u.a and u are
                                       // pointer-interconvertible
 
double* p4 = reinterpret_cast&lt;double*&gt;(p3); // value of p4 is "pointer to u.b": u.a and u.b
                                            // are pointer-interconvertible because both
                                            // are pointer-interconvertible with u
 
int* p5 = reinterpret_cast&lt;int*&gt;(&amp;arr); // value of p5 is unchanged by reinterpret_cast and
                                        // is "pointer to arr"</pre></div> <p>Performing a class member access that designates a non-static data member or a non-static member function on a glvalue that does not actually designate an object of the appropriate type - such as one obtained through a <code>reinterpret_cast</code> - results in undefined behavior:</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct S { int x; };
struct T { int x; int f(); };
struct S1 : S {}; // standard-layout
struct ST : S, T {}; // not standard-layout
 
S s = {};
auto p = reinterpret_cast&lt;T*&gt;(&amp;s); // value of p is "pointer to s"
auto i = p-&gt;x; // class member access expression is undefined behavior; s is not a T object
p-&gt;x = 1; // undefined behavior
p-&gt;f();   // undefined behavior
 
S1 s1 = {};
auto p1 = reinterpret_cast&lt;S*&gt;(&amp;s1); // value of p1 is "pointer to the S subobject of s1"
auto i = p1-&gt;x; // OK
p1-&gt;x = 1; // OK
 
ST st = {};
auto p2 = reinterpret_cast&lt;S*&gt;(&amp;st); // value of p2 is "pointer to st"
auto i = p2-&gt;x; // undefined behavior
p2-&gt;x = 1; // undefined behavior</pre></div> <p>Many compilers issue "strict aliasing" warnings in such cases, even though technically such constructs run afoul of something other than the paragraph commonly known as the "strict aliasing rule".</p>
<p>The purpose of strict aliasing and related rules is to enable type-based alias analysis, which would be decimated if a program can validly create a situation where two pointers to unrelated types (e.g., an <code>int*</code> and a <code>float*</code>) could simultaneously exist and both can be used to load or store the same memory (see <a rel="nofollow" class="external text" href="http://www.open-std.org/pipermail/ub/2016-February/000565.html">this email on SG12 reflector</a>). Thus, any technique that is seemingly capable of creating such a situation necessarily invokes undefined behavior.</p>
<p>When it is needed to interpret the bytes of an object as a value of a different type, <code><a href="../string/byte/memcpy" title="cpp/string/byte/memcpy">std::memcpy</a></code> <span class="t-rev-inl t-since-cxx20"><span>or <a href="../numeric/bit_cast" title="cpp/numeric/bit cast"><code>std::bit_cast</code></a> </span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span>can be used:</p>
<div class="cpp source-cpp"><pre data-language="cpp">double d = 0.1;
std::int64_t n;
static_assert(sizeof n == sizeof d);
// n = *reinterpret_cast&lt;std::int64_t*&gt;(&amp;d); // Undefined behavior
std::memcpy(&amp;n, &amp;d, sizeof d); // OK
n = std::bit_cast&lt;std::int64_t&gt;(d); // also OK</pre></div> <h3 id="Defect_reports"> Defect reports </h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th> DR </th> <th> Applied to </th> <th> Behavior as published </th> <th> Correct behavior </th>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://wg21.link/cwg195">CWG 195</a> </td> <td> C++98 </td> <td> conversion between function pointers and object pointers not allowed </td> <td> made conditionally-supported </td>
</tr>
</table> <h3 id="Example">Example</h3> <div class="t-example">
<p>Demonstrates some uses of reinterpret_cast:</p>
<div class="cpp source-cpp"><pre data-language="cpp">#include &lt;cstdint&gt;
#include &lt;cassert&gt;
#include &lt;iostream&gt;
int f() { return 42; }
int main()
{
    int i = 7;
 
    // pointer to integer and back
    std::uintptr_t v1 = reinterpret_cast&lt;std::uintptr_t&gt;(&amp;i); // static_cast is an error
    std::cout &lt;&lt; "The value of &amp;i is 0x" &lt;&lt; std::hex &lt;&lt; v1 &lt;&lt; '\n';
    int* p1 = reinterpret_cast&lt;int*&gt;(v1);
    assert(p1 == &amp;i);
 
    // pointer to function to another and back
    void(*fp1)() = reinterpret_cast&lt;void(*)()&gt;(f);
    // fp1(); undefined behavior
    int(*fp2)() = reinterpret_cast&lt;int(*)()&gt;(fp1);
    std::cout &lt;&lt; std::dec &lt;&lt; fp2() &lt;&lt; '\n'; // safe
 
    // type aliasing through pointer
    char* p2 = reinterpret_cast&lt;char*&gt;(&amp;i);
    if(p2[0] == '\x7')
        std::cout &lt;&lt; "This system is little-endian\n";
    else
        std::cout &lt;&lt; "This system is big-endian\n";
 
    // type aliasing through reference
    reinterpret_cast&lt;unsigned int&amp;&gt;(i) = 42;
    std::cout &lt;&lt; i &lt;&lt; '\n';
 
    [[maybe_unused]] const int &amp;const_iref = i;
    //int &amp;iref = reinterpret_cast&lt;int&amp;&gt;(const_iref); //compiler error - can't get rid of const
    //Must use const_cast instead:  int &amp;iref = const_cast&lt;int&amp;&gt;(const_iref);
}</pre></div> <p>Possible output:</p>
<div class="text source-text"><pre data-language="c">The value of &amp;i is 0x7fff352c3580
42
This system is little-endian
42</pre></div> </div> <h3 id="See_also">See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <a href="const_cast" title="cpp/language/const cast"> const_cast conversion </a> </td> <td> adds or removes const</td>
</tr> <tr class="t-dsc"> <td> <a href="static_cast" title="cpp/language/static cast"> static_cast conversion </a> </td> <td> performs basic conversions</td>
</tr> <tr class="t-dsc"> <td> <a href="dynamic_cast" title="cpp/language/dynamic cast"> dynamic_cast conversion </a> </td> <td> performs checked polymorphic conversions</td>
</tr> <tr class="t-dsc"> <td> <a href="explicit_cast" title="cpp/language/explicit cast"> explicit casts </a> </td> <td> permissive conversions between types </td>
</tr> <tr class="t-dsc"> <td> <a href="implicit_cast" title="cpp/language/implicit cast" class="mw-redirect"> standard conversions </a> </td> <td> implicit conversions from one type to another</td>
</tr> </table>          <div class="_attribution">
  <p class="_attribution-p">
    Â© cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/language/reinterpret_cast" class="_attribution-link">http://en.cppreference.com/w/cpp/language/reinterpret_cast</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
