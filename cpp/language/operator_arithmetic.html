
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Arithmetic Operators - C++ - W3cubDocs</title>
  
  <meta name="description" content=" Returns the result of specific arithmetic operation. ">
  <meta name="keywords" content="arithmetic, operators, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/language/operator_arithmetic.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-9c7b0d969c0ce639a6c01c2badcdd81667c7c66206aa3d0fccc5cb0585fb1b912dab72ea882101d18010680927514b4b77b107282db8f756fbf63301fe9c88b0.css">
  <script type="text/javascript" src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js"></script>
  <script src="/json/cpp.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _cppref">
				
				
<h1 id="firstHeading" class="firstHeading">Arithmetic operators</h1>            <p>Returns the result of specific arithmetic operation.</p>
<table class="wikitable"> <tr> <th rowspan="2">Operator name </th> <th rowspan="2">Syntax </th> <th rowspan="2">
<a href="operators" title="cpp/language/operators">Over​load​able</a> </th> <th colspan="2">Prototype examples (for <span class="kw1">class</span> T) </th>
</tr> <tr> <th>Inside class definition </th> <th>Outside class definition </th>
</tr> <tr> <td>unary plus </td> <td>
<code>+a</code> </td> <td class="table-yes">Yes </td> <td>
<code>T T::operator+() const;</code> </td> <td>
<code>T operator+(const T &amp;a);</code> </td>
</tr> <tr> <td>unary minus </td> <td>
<code>-a</code> </td> <td class="table-yes">Yes </td> <td>
<code>T T::operator-() const;</code> </td> <td>
<code>T operator-(const T &amp;a);</code> </td>
</tr> <tr> <td>addition </td> <td>
<code>a + b</code> </td> <td class="table-yes">Yes </td> <td>
<code>T T::operator+(const T2 &amp;b) const;</code> </td> <td>
<code>T operator+(const T &amp;a, const T2 &amp;b);</code> </td>
</tr> <tr> <td>subtraction </td> <td>
<code>a - b</code> </td> <td class="table-yes">Yes </td> <td>
<code>T T::operator-(const T2 &amp;b) const;</code> </td> <td>
<code>T operator-(const T &amp;a, const T2 &amp;b);</code> </td>
</tr> <tr> <td>multiplication </td> <td>
<code>a * b</code> </td> <td class="table-yes">Yes </td> <td>
<code>T T::operator*(const T2 &amp;b) const;</code> </td> <td>
<code>T operator*(const T &amp;a, const T2 &amp;b);</code> </td>
</tr> <tr> <td>division </td> <td>
<code>a / b</code> </td> <td class="table-yes">Yes </td> <td>
<code>T T::operator/(const T2 &amp;b) const;</code> </td> <td>
<code>T operator/(const T &amp;a, const T2 &amp;b);</code> </td>
</tr> <tr> <td>remainder </td> <td>
<code>a % b</code> </td> <td class="table-yes">Yes </td> <td>
<code>T T::operator%(const T2 &amp;b) const;</code> </td> <td>
<code>T operator%(const T &amp;a, const T2 &amp;b);</code> </td>
</tr> <tr> <td>bitwise NOT </td> <td>
<code>~a</code> </td> <td class="table-yes">Yes </td> <td>
<code>T T::operator~() const;</code> </td> <td>
<code>T operator~(const T &amp;a);</code> </td>
</tr> <tr> <td>bitwise AND </td> <td>
<code>a &amp; b</code> </td> <td class="table-yes">Yes </td> <td>
<code>T T::operator&amp;(const T2 &amp;b) const;</code> </td> <td>
<code>T operator&amp;(const T &amp;a, const T2 &amp;b);</code> </td>
</tr> <tr> <td>bitwise OR </td> <td>
<code>a | b</code> </td> <td class="table-yes">Yes </td> <td>
<code>T T::operator|(const T2 &amp;b) const;</code> </td> <td>
<code>T operator|(const T &amp;a, const T2 &amp;b);</code> </td>
</tr> <tr> <td>bitwise XOR </td> <td>
<code>a ^ b</code> </td> <td class="table-yes">Yes </td> <td>
<code>T T::operator^(const T2 &amp;b) const;</code> </td> <td>
<code>T operator^(const T &amp;a, const T2 &amp;b);</code> </td>
</tr> <tr> <td>bitwise left shift </td> <td>
<code>a &lt;&lt; b</code> </td> <td class="table-yes">Yes </td> <td>
<code>T T::operator&lt;&lt;(const T2 &amp;b) const;</code> </td> <td>
<code>T operator&lt;&lt;(const T &amp;a, const T2 &amp;b);</code> </td>
</tr> <tr> <td>bitwise right shift </td> <td>
<code>a &gt;&gt; b</code> </td> <td class="table-yes">Yes </td> <td>
<code>T T::operator&gt;&gt;(const T2 &amp;b) const;</code> </td> <td>
<code>T operator&gt;&gt;(const T &amp;a, const T2 &amp;b);</code> </td>
</tr> <tr> <td colspan="5"> <b>Notes</b><br>  <ul>
<li> All built-in operators return values, and most <a href="operators" title="cpp/language/operators">user-defined overloads</a> also return values so that the user-defined operators can be used in the same manner as the built-ins. However, in a user-defined operator overload, any type can be used as return type (including <span class="kw4">void</span>). In particular, stream insertion and stream extraction overloads of operator<span class="sy1">&lt;&lt;</span> and operator<span class="sy1">&gt;&gt;</span> return <code>T&amp;</code>. </li>
<li> <code>T2</code> can be any type including <code>T</code>. </li>
</ul> </td>
</tr>
</table>  <h3 id="Explanation"> Explanation</h3> <p>All arithmetic operators compute the result of specific arithmetic operation and returns its result. The arguments are not modified.</p>
<h4 id="Conversions"> Conversions</h4> <p>If the operand passed to an arithmetic operator is integral or unscoped enumeration type, then before any other action (but after lvalue-to-rvalue conversion, if applicable), the operand undergoes <a href="implicit_conversion#Integral_promotion" title="cpp/language/implicit conversion">integral promotion</a>. If an operand has array or function type, <a href="implicit_conversion#array_to_pointer_conversion" title="cpp/language/implicit conversion">array-to-pointer</a> and <a href="implicit_conversion#function_to_pointer" title="cpp/language/implicit conversion">function-to-pointer</a> conversions are applied.</p>
<p>For the binary operators (except shifts), if the promoted operands have different types, <a href="usual_arithmetic_conversions" title="cpp/language/usual arithmetic conversions">usual arithmetic conversions</a> are applied.</p>
<h4 id="Overflows"> Overflows</h4> <p>Unsigned integer arithmetic is always performed modulo 2<span class="t-su">n<br></span> where n is the number of bits in that particular integer. E.g. for <span class="kw4">unsigned</span> <span class="kw4">int</span>, adding one to <code><a href="../types/climits" title="cpp/types/climits">UINT_MAX</a></code> gives <code>​0​</code>, and subtracting one from <code>​0​</code> gives <code><a href="../types/climits" title="cpp/types/climits">UINT_MAX</a></code>.</p>
<p>When signed integer arithmetic operation overflows (the result does not fit in the result type), the behavior is undefined, — the possible manifestations of such an operation include:</p>
<ul>
<li> it wraps around according to the rules of the representation (typically 2's complement), </li>
<li> it traps — on some platforms or due to compiler options (e.g. <code>-ftrapv</code> in GCC and Clang), </li>
<li> it saturates to minimal or maximal value (on many DSPs), </li>
<li> it is completely <a rel="nofollow" class="external text" href="http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html">optimized out by the compiler</a>. </li>
</ul> <h4 id="Floating-point_environment"> Floating-point environment</h4> <p>If <a href="../preprocessor/impl" title="cpp/preprocessor/impl"><code> #pragma STDC FENV_ACCESS</code></a> is supported and set to <code>ON</code>, all floating-point arithmetic operators obey the current floating-point <a href="../numeric/fenv/fe_round" title="cpp/numeric/fenv/FE round">rounding direction</a> and report floating-point arithmetic errors as specified in <a href="../numeric/math/math_errhandling" title="cpp/numeric/math/math errhandling"><code>math_errhandling</code></a> unless part of a <a href="initialization#Non-local_variables" title="cpp/language/initialization">static initializer</a> (in which case floating-point exceptions are not raised and the rounding mode is to nearest).</p>
<h4 id="Floating-point_contraction"> Floating-point contraction</h4> <p>Unless <a href="../preprocessor/impl" title="cpp/preprocessor/impl"><code> #pragma STDC FP_CONTRACT</code></a> is supported and set to <code>OFF</code>, all floating-point arithmetic may be performed as if the intermediate results have infinite range and precision, that is, optimizations that omit rounding errors and floating-point exceptions are allowed. For example, C++ allows the implementation of <code>(x * y) + z</code> with a single fused multiply-add CPU instruction or optimization of <code>a = x * x * x * x;</code> as <code>tmp = x * x; a = tmp * tmp</code>.</p>
<p>Unrelated to contracting, intermediate results of floating-point arithmetic may have range and precision that is different from the one indicated by its type, see <code><a href="../types/climits/flt_eval_method" title="cpp/types/climits/FLT EVAL METHOD">FLT_EVAL_METHOD</a></code>.</p>
<p>Formally, the C++ standard makes no guarantee on the accuracy of floating-point operations.</p>
<h4 id="Unary_arithmetic_operators"> Unary arithmetic operators</h4> <p>The unary arithmetic operator expressions have the form.</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <code>+</code> <span class="t-spar">expression</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>-</code> <span class="t-spar">expression</span> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <div class="t-li1">
<span class="t-li">1)</span> unary plus (promotion).</div> <div class="t-li1">
 For the built-in operator, <span class="t-spar">expression</span> must have arithmetic, unscoped enumeration, or pointer type. Integral promotion is performed on the operand if it has integral or unscoped enumeration type and determines the type of the result.</div> <div class="t-li1">
<span class="t-li">2)</span> unary minus (negation).</div> <div class="t-li1">
 For the built-in operator, <span class="t-spar">expression</span> must have arithmetic or unscoped enumeration type. Integral promotion is performed on the operand and determines the type of the result.</div> <p>The built-in unary plus operator returns the value of its operand. The only situation where it is not a no-op is when the operand has integral type or unscoped enumeration type, which is changed by integral promotion, e.g, it converts <span class="kw4">char</span> to <span class="kw4">int</span> or if the operand is subject to lvalue-to-rvalue, array-to-pointer, or function-to-pointer conversion.</p>
<p>The builtin unary minus operator calculates the negative of its promoted operand. For unsigned <code>a</code>, the value of <code>-a</code> is 2<span class="t-su">b<br></span>-a, where <code>b</code> is the number of bits after promotion.</p>
<p>In <a href="overload_resolution#Call_to_an_overloaded_operator" title="cpp/language/overload resolution">overload resolution against user-defined operators</a>, for every cv-unqualified promoted arithmetic type <code>A</code> and for every type <code>T</code>, the following function signatures participate in overload resolution:</p>
<table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">A operator+(A)</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">T* operator+(T*)</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">A operator-(A)</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
 
int main()
{
    char c = 0x6a;
    int n1 = 1;
    unsigned char n2 = 1;
    unsigned int n3 = 1;
    std::cout &lt;&lt; "char: " &lt;&lt; c &lt;&lt; " int: " &lt;&lt; +c &lt;&lt; '\n'
              &lt;&lt; "-1, where 1 is signed: " &lt;&lt; -n1 &lt;&lt; '\n'
              &lt;&lt; "-1, where 1 is unsigned char: " &lt;&lt; -n2 &lt;&lt; '\n'
              &lt;&lt; "-1, where 1 is unsigned int: " &lt;&lt; -n3 &lt;&lt; '\n';
    char a[3];
    std::cout &lt;&lt; "size of array: " &lt;&lt; sizeof a &lt;&lt; '\n'
              &lt;&lt; "size of pointer: " &lt;&lt; sizeof +a &lt;&lt; '\n';
}</pre></div> <p>Possible output:</p>
<div class="text source-text"><pre data-language="c">char: j int: 106
-1, where 1 is signed: -1
-1, where 1 is unsigned char: -1
-1, where 1 is unsigned int: 4294967295
size of array: 3
size of pointer: 8</pre></div> </div> <h4 id="Additive_operators"> Additive operators</h4> <p>The binary additive arithmetic operator expressions have the form.</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">lhs</span> <code>+</code> <span class="t-spar">rhs</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">lhs</span> <code>-</code> <span class="t-spar">rhs</span> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <div class="t-li1">
<span class="t-li">1)</span> addition</div> <div class="t-li1">
 For the built-in operator, <span class="t-spar">lhs</span> and <span class="t-spar">rhs</span> must be one of the following: <ul>
<li> both have arithmetic or unscoped enumeration type. In this case, the <a href="usual_arithmetic_conversions" title="cpp/language/usual arithmetic conversions">usual arithmetic conversions</a> are performed on both operands and determine the type of the result. </li>
<li> one is a pointer to completely-defined object type, the other has integral or unscoped enumeration type. In this case, the result type has the type of the pointer.</li>
</ul>
</div> <div class="t-li1">
<span class="t-li">2)</span> subtraction</div> <div class="t-li1">
 For the built-in operator, <span class="t-spar">lhs</span> and <span class="t-spar">rhs</span> must be one of the following: <ul>
<li> both have arithmetic or unscoped enumeration type. In this case, the <a href="usual_arithmetic_conversions" title="cpp/language/usual arithmetic conversions">usual arithmetic conversions</a> are performed on both operands and determine the type of the result. </li>
<li> <span class="t-spar">lhs</span> is a pointer to completely-defined object type, <span class="t-spar">rhs</span> has integral or unscoped enumeration type. In this case, the result type has the type of the pointer. </li>
<li> both are pointers to the same completely-defined object types, ignoring cv-qualifiers. In this case, the result type is <code><a href="../types/ptrdiff_t" title="cpp/types/ptrdiff t">std::ptrdiff_t</a></code>.</li>
</ul>
</div> <p>With operands of arithmetic or enumeration type, the result of binary plus is the sum of the operands (after <a href="usual_arithmetic_conversions" title="cpp/language/usual arithmetic conversions">usual arithmetic conversions</a>), and the result of the binary minus operator is the result of subtracting the second operand from the first (after <a href="usual_arithmetic_conversions" title="cpp/language/usual arithmetic conversions">usual arithmetic conversions</a>), except that, if the type supports IEEE floating-point arithmetic (see <code><a href="../types/numeric_limits/is_iec559" title="cpp/types/numeric limits/is iec559">std::numeric_limits::is_iec559</a></code>),</p>
<ul>
<li> if one operand is NaN, the result is NaN </li>
<li> infinity minus infinity is NaN and <code><a href="../numeric/fenv/fe_exceptions" title="cpp/numeric/fenv/FE exceptions">FE_INVALID</a></code> is raised </li>
<li> infinity plus the negative infinity is NaN and <code><a href="../numeric/fenv/fe_exceptions" title="cpp/numeric/fenv/FE exceptions">FE_INVALID</a></code> is raised </li>
</ul> <p>If any of the operands is a pointer, the following rules apply:</p>
<ul>
<li> A pointer to non-array object is treated as a pointer to the first element of an array with size 1. </li>
<li> If the pointer <code>P</code> points to the <code>i</code>th element of an array, then the expressions <code>P + n</code>, <code>n + P</code>, and <code>P - n</code> are pointers of the same type that point to the <code>i+n</code>th, <code>i+n</code>th, and <code>i-n</code>th element of the same array, respectively. The result of pointer addition may also be a one-past-the-end pointer (that is, pointer <code>P</code> such that the expression <code>P - 1</code> points to the last element of the array). Any other situations (that is, attempts to generate a pointer that isn't pointing at an element of the same array or one past the end) invoke undefined behavior. </li>
<li> If the pointer <code>P</code> points to the <code>i</code>th element of an array, and the pointer <code>Q</code> points at the <code>j</code>th element of the same array, the expression <code>P - Q</code> has the value <code>i - j</code>, if the value fits in <code><a href="../types/ptrdiff_t" title="cpp/types/ptrdiff t">std::ptrdiff_t</a></code>. Both operands must point to the elements of the same array (or one past the end), otherwise the behavior is undefined. If the result does not fit in <code><a href="../types/ptrdiff_t" title="cpp/types/ptrdiff t">std::ptrdiff_t</a></code>, the behavior is undefined. </li>
<li> In any case, if the pointed-to type is different from the array element type, disregarding cv-qualifications, at every level if the elements are themselves pointers, the behavior of pointer arithmetic is undefined. In particular, pointer arithmetic with pointer to base, which is pointing at an element of an array of derived objects is undefined. </li>
<li> If the value <code>​0​</code> is added or subtracted from a pointer, the result is the pointer, unchanged. If two pointers point at the same object or are both one past the end of the same array, or both are null pointers, then the result of subtraction is equal to <code><span class="br0">(</span><a href="http://en.cppreference.com/w/cpp/types/ptrdiff_t"><span class="kw108">std::<span class="me2">ptrdiff_t</span></span></a><span class="br0">)</span><span class="nu0">0</span></code>. </li>
</ul> <p>These pointer arithmetic operators allow pointers to satisfy the <a href="../named_req/randomaccessiterator" title="cpp/named req/RandomAccessIterator">LegacyRandomAccessIterator</a> requirements.</p>
<p>In <a href="overload_resolution#Call_to_an_overloaded_operator" title="cpp/language/overload resolution">overload resolution against user-defined operators</a>, for every pair of promoted arithmetic types <code>L</code> and <code>R</code> and for every object type <code>T</code>, the following function signatures participate in overload resolution:</p>
<table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">LR operator+(L, R)</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">LR operator-(L, R)</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">T* operator+(T*, std::ptrdiff_t)</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">T* operator+(std::ptrdiff_t, T*)</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">T* operator-(T*, std::ptrdiff_t)</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">std::ptrdiff_t operator-(T*, T*)</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <p>where <code>LR</code> is the result of <a href="usual_arithmetic_conversions" title="cpp/language/usual arithmetic conversions">usual arithmetic conversions</a> on <code>L</code> and <code>R</code>.</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
 
int main()
{
    char c = 2;
    unsigned int un = 2;
    int  n = -10;
    std::cout &lt;&lt;  " 2 + (-10), where 2 is a char    = " &lt;&lt; c + n &lt;&lt; '\n'
              &lt;&lt;  " 2 + (-10), where 2 is unsigned  = " &lt;&lt; un + n &lt;&lt; '\n'
              &lt;&lt;  " -10 - 2.12  = " &lt;&lt; n - 2.12 &lt;&lt; '\n';
 
    char a[4] = {'a', 'b', 'c', 'd'};
    char* p = &amp;a[1];
    std::cout &lt;&lt; "Pointer addition examples: " &lt;&lt; *p &lt;&lt; *(p + 2)
              &lt;&lt; *(2 + p) &lt;&lt; *(p - 1) &lt;&lt; '\n';
    char* p2 = &amp;a[4];
    std::cout &lt;&lt; "Pointer difference: " &lt;&lt; p2 - p &lt;&lt; '\n';
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">
 2 + (-10), where 2 is a char    = -8
 2 + (-10), where 2 is unsigned  = 4294967288
 -10 - 2.12  = -12.12
Pointer addition examples: bdda
Pointer difference: 3</pre></div> </div> <h4 id="Multiplicative_operators"> Multiplicative operators</h4> <p>The binary multiplicative arithmetic operator expressions have the form.</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">lhs</span> <code>*</code> <span class="t-spar">rhs</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">lhs</span> <code>/</code> <span class="t-spar">rhs</span> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">lhs</span> <code>%</code> <span class="t-spar">rhs</span> </td> <td> (3) </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <div class="t-li1">
<span class="t-li">1)</span> multiplication</div> <div class="t-li1">
 For the built-in operator, <span class="t-spar">lhs</span> and <span class="t-spar">rhs</span> must both have arithmetic or unscoped enumeration type. </div> <div class="t-li1">
<span class="t-li">2)</span> division</div> <div class="t-li1">
 For the built-in operator, <span class="t-spar">lhs</span> and <span class="t-spar">rhs</span> must both have arithmetic or unscoped enumeration type. </div> <div class="t-li1">
<span class="t-li">3)</span> remainder</div> <div class="t-li1">
 For the built-in operator, <span class="t-spar">lhs</span> and <span class="t-spar">rhs</span> must both have integral or unscoped enumeration type.</div> <p>For all three operators, the <a href="usual_arithmetic_conversions" title="cpp/language/usual arithmetic conversions">usual arithmetic conversions</a> are performed on both operands and determine the type of the result.</p>
<p>The binary operator * performs multiplication of its operands (after <a href="usual_arithmetic_conversions" title="cpp/language/usual arithmetic conversions">usual arithmetic conversions</a>), except that, for floating-point multiplication,</p>
<ul>
<li> multiplication of a NaN by any number gives NaN </li>
<li> multiplication of infinity by zero gives NaN and <code><a href="../numeric/fenv/fe_exceptions" title="cpp/numeric/fenv/FE exceptions">FE_INVALID</a></code> is raised </li>
</ul> <p>The binary operator / divides the first operand by the second (after <a href="usual_arithmetic_conversions" title="cpp/language/usual arithmetic conversions">usual arithmetic conversions</a>).</p>
<p>For integral operands, it yields the algebraic quotient. The quotient is truncated towards zero (fractional part is discarded).</p>
<p>If the second operand is zero, the behavior is undefined, except that if floating-point division is taking place and the type supports IEEE floating-point arithmetic (see <code><a href="../types/numeric_limits/is_iec559" title="cpp/types/numeric limits/is iec559">std::numeric_limits::is_iec559</a></code>), then:</p>
<ul>
<li> if one operand is NaN, the result is NaN </li>
<li> dividing a non-zero number by ±0.0 gives the correctly-signed infinity and <code><a href="../numeric/fenv/fe_exceptions" title="cpp/numeric/fenv/FE exceptions">FE_DIVBYZERO</a></code> is raised </li>
<li> dividing 0.0 by 0.0 gives NaN and <code><a href="../numeric/fenv/fe_exceptions" title="cpp/numeric/fenv/FE exceptions">FE_INVALID</a></code> is raised </li>
</ul> <p>The binary operator % yields the remainder of the integer division of the first operand by the second (after <a href="usual_arithmetic_conversions" title="cpp/language/usual arithmetic conversions">usual arithmetic conversions</a>; note that the operand types must be integral types). If the quotient <code>a / b</code> is representable in the result type, <code>(a / b) * b + a % b == a</code>. If the second operand is zero, the behavior is undefined. If the quotient <code>a / b</code> is not representable in the result type, the behavior of both <code>a / b</code> and <code>a % b</code> is undefined (that means <code><a href="http://en.cppreference.com/w/cpp/types/climits"><span class="kw400">INT_MIN</span></a> <span class="sy2">%</span> <span class="sy2">-</span><span class="nu0">1</span></code> is undefined on 2's complement systems).</p>
<p>Note: Until <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/614.html">CWG issue 614</a> was resolved (<a rel="nofollow" class="external text" href="https://wg21.link/n2757">N2757</a>), if one or both operands to binary operator % were negative, the sign of the remainder was implementation-defined, as it depends on the rounding direction of integer division. The function <code><a href="../numeric/math/div" title="cpp/numeric/math/div">std::div</a></code> provided well-defined behavior in that case.</p>
<p>Note: for floating-point remainder, see <code><a href="../numeric/math/remainder" title="cpp/numeric/math/remainder">std::remainder</a></code> and <code><a href="../numeric/math/fmod" title="cpp/numeric/math/fmod">std::fmod</a></code>.</p>
<p>In <a href="overload_resolution#Call_to_an_overloaded_operator" title="cpp/language/overload resolution">overload resolution against user-defined operators</a>, for every pair of promoted arithmetic types <code>LA</code> and <code>RA</code> and for every pair of promoted integral types <code>LI</code> and <code>RI</code> the following function signatures participate in overload resolution:</p>
<table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">LRA operator*(LA, RA)</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">LRA operator/(LA, RA)</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">LRI operator%(LI, RI)</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <p>where <code>LRx</code> is the result of <a href="usual_arithmetic_conversions" title="cpp/language/usual arithmetic conversions">usual arithmetic conversions</a> on <code>Lx</code> and <code>Rx</code>.</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
 
int main()
{
    char c = 2;
    unsigned int un = 2;
    int  n = -10;
    std::cout &lt;&lt;  "2 * (-10), where 2 is a char    = " &lt;&lt; c * n &lt;&lt; '\n'
              &lt;&lt;  "2 * (-10), where 2 is unsigned  = " &lt;&lt; un * n &lt;&lt; '\n'
              &lt;&lt;  "-10 / 2.12  = " &lt;&lt; n / 2.12 &lt;&lt; '\n'
              &lt;&lt;  "-10 / 21  = " &lt;&lt; n / 21 &lt;&lt; '\n'
              &lt;&lt;  "-10 % 21  = " &lt;&lt; n % 21 &lt;&lt; '\n';
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">2 * (-10), where 2 is a char    = -20
2 * (-10), where 2 is unsigned  = 4294967276
-10 / 2.12  = -4.71698
-10 / 21  = 0
-10 % 21  = -10</pre></div> </div> <h4 id="Bitwise_logic_operators"> Bitwise logic operators</h4> <p>The bitwise arithmetic operator expressions have the form.</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <code>~</code> <span class="t-spar">rhs</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">lhs</span> <code>&amp;</code> <span class="t-spar">rhs</span> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">lhs</span> <code>|</code> <span class="t-spar">rhs</span> </td> <td> (3) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">lhs</span> <code>^</code> <span class="t-spar">rhs</span> </td> <td> (4) </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <div class="t-li1">
<span class="t-li">1)</span> bitwise NOT</div> <div class="t-li1">
<span class="t-li">2)</span> bitwise AND</div> <div class="t-li1">
<span class="t-li">3)</span> bitwise OR</div> <div class="t-li1">
<span class="t-li">4)</span> bitwise XOR</div> <div class="t-li1">
 For the built-in operators, <span class="t-spar">lhs</span> and <span class="t-spar">rhs</span> must both have integral or unscoped enumeration type. <a href="usual_arithmetic_conversions" title="cpp/language/usual arithmetic conversions">Usual arithmetic conversions</a> are performed on both operands and determine the type of the result.</div> <p>The result of operator~ is the bitwise NOT (all zero-bits become one-bits, all one-bits become zero-bits) value of the argument (after promotion). The result of operator&amp; is the bitwise AND value of the operands (after <a href="usual_arithmetic_conversions" title="cpp/language/usual arithmetic conversions">usual arithmetic conversions</a>). The result of operator| is the bitwise OR value of the operands (after <a href="usual_arithmetic_conversions" title="cpp/language/usual arithmetic conversions">usual arithmetic conversions</a>). The result of operator^ is the bitwise XOR value of the operands (after <a href="usual_arithmetic_conversions" title="cpp/language/usual arithmetic conversions">usual arithmetic conversions</a>).</p>
<p>There is an ambiguity in the grammar when <code>~</code> is followed by a <a href="type#type_naming" title="cpp/language/type">type name</a> <span class="t-rev-inl t-since-cxx11"><span>or <a href="decltype" title="cpp/language/decltype">decltype</a> specifier</span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>: it can either be operator~ or start a <a href="destructor" title="cpp/language/destructor">destructor</a> identifier). The ambiguity is resolved by treating <code>~</code> as operator~. <code>~</code> can start a destructor identifier only in places where forming an operator~ is syntactically invalid.</p>
<p>In <a href="overload_resolution#Call_to_an_overloaded_operator" title="cpp/language/overload resolution">overload resolution against user-defined operators</a>, for every pair of promoted integral types <code>L</code> and <code>R</code> the following function signatures participate in overload resolution:</p>
<table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">R operator~(R)</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">LR operator&amp;(L, R)</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">LR operator^(L, R)</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">LR operator|(L, R)</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <p>where <code>LR</code> is the result of <a href="usual_arithmetic_conversions" title="cpp/language/usual arithmetic conversions">usual arithmetic conversions</a> on <code>L</code> and <code>R</code>.</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;bitset&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
 
int main()
{
    uint16_t mask = 0x00f0;
    uint32_t x0 = 0x12345678;
    uint32_t x1 = x0 | mask;
    uint32_t x2 = x0 &amp; ~mask;
    uint32_t x3 = x0 &amp; mask;
    uint32_t x4 = x0 ^ mask;
    uint32_t x5 = ~x0;
    using bin16 = std::bitset&lt;16&gt;;
    using bin32 = std::bitset&lt;32&gt;;
    std::cout &lt;&lt; std::hex &lt;&lt; std::showbase
              &lt;&lt; "Mask: " &lt;&lt; mask &lt;&lt; std::setw(49) &lt;&lt; bin16(mask) &lt;&lt; '\n'
              &lt;&lt; "Value: " &lt;&lt; x0 &lt;&lt; std::setw(42) &lt;&lt; bin32(x0) &lt;&lt; '\n'
              &lt;&lt; "Setting bits: " &lt;&lt; x1 &lt;&lt; std::setw(35) &lt;&lt; bin32(x1) &lt;&lt; '\n'
              &lt;&lt; "Clearing bits: " &lt;&lt; x2 &lt;&lt; std::setw(34) &lt;&lt; bin32(x2) &lt;&lt; '\n'
              &lt;&lt; "Selecting bits: " &lt;&lt; x3 &lt;&lt; std::setw(39) &lt;&lt; bin32(x3) &lt;&lt; '\n'
              &lt;&lt; "XOR-ing bits: " &lt;&lt; x4 &lt;&lt; std::setw(35) &lt;&lt; bin32(x4) &lt;&lt; '\n'
              &lt;&lt; "Inverting bits: " &lt;&lt; x5 &lt;&lt; std::setw(33) &lt;&lt; bin32(x5) &lt;&lt; '\n';
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">Mask: 0xf0                                 0000000011110000
Value: 0x12345678          00010010001101000101011001111000
Setting bits: 0x123456f8   00010010001101000101011011111000
Clearing bits: 0x12345608  00010010001101000101011000001000
Selecting bits: 0x70       00000000000000000000000001110000
XOR-ing bits: 0x12345688   00010010001101000101011010001000
Inverting bits: 0xedcba987 11101101110010111010100110000111</pre></div> </div> <h4 id="Bitwise_shift_operators"> Bitwise shift operators</h4> <p>The bitwise shift operator expressions have the form.</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">lhs</span> <code>&lt;&lt;</code> <span class="t-spar">rhs</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">lhs</span> <code>&gt;&gt;</code> <span class="t-spar">rhs</span> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <div class="t-li1">
<span class="t-li">1)</span> left shift of <span class="t-spar">lhs</span> by <span class="t-spar">rhs</span> bits</div> <div class="t-li1">
<span class="t-li">2)</span> right shift of <span class="t-spar">lhs</span> by <span class="t-spar">rhs</span> bits</div> <div class="t-li1">
 For the built-in operators, <span class="t-spar">lhs</span> and <span class="t-spar">rhs</span> must both have integral or unscoped enumeration type. Integral promotions are performed on both operands.</div> <p>The return type is the type of the left operand after integral promotions.</p>
<table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <p>For unsigned <code>a</code>, the value of <code>a &lt;&lt; b</code> is the value of a * 2<span class="t-su">b<br></span>, reduced modulo 2<span class="t-su">N<br></span> where N is the number of bits in the return type (that is, bitwise left shift is performed and the bits that get shifted out of the destination type are discarded).</p>
<p>For signed and non-negative <code>a</code>, if a * 2<span class="t-su">b<br></span> is representable in the unsigned version of the return type, then that value, <a href="implicit_conversion#Integral_conversions" title="cpp/language/implicit conversion">converted</a> to signed, is the value of <code>a &lt;&lt; b</code> (this makes it legal to create <code><a href="../types/climits" title="cpp/types/climits">INT_MIN</a></code> as <code>1 &lt;&lt; 31</code>); otherwise the behavior is undefined.</p>
<p>For negative <code>a</code>, the behavior of <code>a &lt;&lt; b</code> is undefined.</p>
<p>For unsigned <code>a</code> and for signed and non-negative <code>a</code>, the value of <code>a &gt;&gt; b</code> is the integer part of a/2<span class="t-su">b<br></span>.</p>
<p>For negative <code>a</code>, the value of <code>a &gt;&gt; b</code> is implementation-defined (in most implementations, this performs arithmetic right shift, so that the result remains negative).</p>
</td> <td><span class="t-mark-rev t-until-cxx20">(until C++20)</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <p>The value of <code>a &lt;&lt; b</code> is the unique value congruent to a * 2<span class="t-su">b<br></span> modulo 2<span class="t-su">N<br></span> where N is the number of bits in the return type (that is, bitwise left shift is performed and the bits that get shifted out of the destination type are discarded).</p>
<p>The value of <code>a &gt;&gt; b</code> is a/2<span class="t-su">b<br></span>, rounded down (in other words, right shift on signed <code>a</code> is arithmetic right shift).</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <p>In any case, if the value of the right operand is negative or is greater or equal to the number of bits in the promoted left operand, the behavior is undefined.</p>
<p>In <a href="overload_resolution#Call_to_an_overloaded_operator" title="cpp/language/overload resolution">overload resolution against user-defined operators</a>, for every pair of promoted integral types <code>L</code> and <code>R</code>, the following function signatures participate in overload resolution:</p>
<table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">L operator&lt;&lt;(L, R)</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">L operator&gt;&gt;(L, R)</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
 
enum { ONE = 1, TWO = 2 };
 
int main()
{
    std::cout &lt;&lt; std::hex &lt;&lt; std::showbase;
    char c = 0x10;
    unsigned long long ull = 0x123;
    std::cout &lt;&lt; "0x123 &lt;&lt; 1 = " &lt;&lt; (ull &lt;&lt; 1) &lt;&lt; '\n'
              &lt;&lt; "0x123 &lt;&lt; 63 = " &lt;&lt; (ull &lt;&lt; 63) &lt;&lt; '\n' // overflow in unsigned
              &lt;&lt; "0x10 &lt;&lt; 10 = " &lt;&lt; (c &lt;&lt; 10) &lt;&lt; '\n';   // char is promoted to int
    long long ll = -1000;
    std::cout &lt;&lt; std::dec &lt;&lt; "-1000 &gt;&gt; 1 = " &lt;&lt; (ll &gt;&gt; ONE) &lt;&lt; '\n';
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">0x123 &lt;&lt; 1 = 0x246
0x123 &lt;&lt; 63 = 0x8000000000000000
0x10 &lt;&lt; 10 = 0x4000
-1000 &gt;&gt; 1 = -500</pre></div> </div> <h3 id="Standard_library"> Standard library</h3> <p>Arithmetic operators are overloaded for many standard library types.</p>
<h4 id="Unary_arithmetic_operators_2"> Unary arithmetic operators</h4> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../chrono/duration/operator_arith" title="cpp/chrono/duration/operator arith"> <span class="t-lines"><span>operator+</span><span>operator-</span></span></a></div> </td> <td> implements unary + and unary - <br> <span class="t-mark">(public member function of <code>std::chrono::duration&lt;Rep,Period&gt;</code>)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../numeric/complex/operator_arith2" title="cpp/numeric/complex/operator arith2"> <span class="t-lines"><span>operator+</span><span>operator-</span></span></a></div> </td> <td> applies unary operators to complex numbers <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../numeric/valarray/operator_arith" title="cpp/numeric/valarray/operator arith"> <span class="t-lines"><span>operator+</span><span>operator-</span><span>operator~</span><span>operator!</span></span></a></div> </td> <td> applies a unary arithmetic operator to each element of the valarray <br> <span class="t-mark">(public member function of <code>std::valarray&lt;T&gt;</code>)</span>  </td>
</tr> </table> <h4 id="Additive_operators_2"> Additive operators</h4> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../chrono/time_point/operator_arith2" title="cpp/chrono/time point/operator arith2"> <span class="t-lines"><span>operator+</span><span>operator-</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> performs add and subtract operations involving a time point <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../chrono/duration/operator_arith4" title="cpp/chrono/duration/operator arith4"> <span class="t-lines"><span>operator+</span><span>operator-</span><span>operator*</span><span>operator/</span><span>operator%</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> implements arithmetic operations with durations as arguments <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../chrono/year_month_day/operator_arith_2" title="cpp/chrono/year month day/operator arith 2"> <span class="t-lines"><span>operator+</span><span>operator-</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> adds or subtracts a <code>year_month_day</code> and some number of years or months <br> <span class="t-mark">(function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../string/basic_string/operator_plus_" title="cpp/string/basic string/operator+"> <span class="t-lines"><span>operator+</span></span></a></div> </td> <td> concatenates two strings or a string and a char <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/reverse_iterator/operator_arith" title="cpp/iterator/reverse iterator/operator arith"> <span class="t-lines"><span>operator+</span><span>operator-</span></span></a></div> </td> <td> advances or decrements the iterator <br> <span class="t-mark">(public member function of <code>std::reverse_iterator&lt;Iter&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/move_iterator/operator_arith" title="cpp/iterator/move iterator/operator arith"> <span class="t-lines"><span>operator+</span><span>operator-</span></span></a></div> </td> <td> advances or decrements the iterator <br> <span class="t-mark">(public member function of <code>std::move_iterator&lt;Iter&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../numeric/complex/operator_arith3" title="cpp/numeric/complex/operator arith3"> <span class="t-lines"><span>operator+</span><span>operator-</span><span>operator*</span><span>operator/</span></span></a></div> </td> <td> performs complex number arithmetic on two complex values or a complex and a scalar <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../numeric/valarray/operator_arith3" title="cpp/numeric/valarray/operator arith3"> <span class="t-lines"><span>operator+</span><span>operator-</span><span>operator*</span><span>operator/</span><span>operator%</span><span>operator&amp;</span><span>operator|</span><span>operator^</span><span>operator&lt;&lt;</span><span>operator&gt;&gt;</span><span>operator&amp;&amp;</span><span>operator||</span></span></a></div> </td> <td> applies binary operators to each element of two valarrays, or a valarray and a value <br> <span class="t-mark">(function template)</span>  </td>
</tr> </table> <h4 id="Multiplicative_operators_2"> Multiplicative operators</h4> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../chrono/duration/operator_arith4" title="cpp/chrono/duration/operator arith4"> <span class="t-lines"><span>operator+</span><span>operator-</span><span>operator*</span><span>operator/</span><span>operator%</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> implements arithmetic operations with durations as arguments <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../numeric/complex/operator_arith3" title="cpp/numeric/complex/operator arith3"> <span class="t-lines"><span>operator+</span><span>operator-</span><span>operator*</span><span>operator/</span></span></a></div> </td> <td> performs complex number arithmetic on two complex values or a complex and a scalar <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../numeric/valarray/operator_arith3" title="cpp/numeric/valarray/operator arith3"> <span class="t-lines"><span>operator+</span><span>operator-</span><span>operator*</span><span>operator/</span><span>operator%</span><span>operator&amp;</span><span>operator|</span><span>operator^</span><span>operator&lt;&lt;</span><span>operator&gt;&gt;</span><span>operator&amp;&amp;</span><span>operator||</span></span></a></div> </td> <td> applies binary operators to each element of two valarrays, or a valarray and a value <br> <span class="t-mark">(function template)</span>  </td>
</tr> </table> <h4 id="Bitwise_logic_operators_2"> Bitwise logic operators</h4> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../utility/bitset/operator_logic" title="cpp/utility/bitset/operator logic"> <span class="t-lines"><span>operator&amp;=</span><span>operator|=</span><span>operator^=</span><span>operator~</span></span></a></div> </td> <td> performs binary AND, OR, XOR and NOT <br> <span class="t-mark">(public member function of <code>std::bitset&lt;N&gt;</code>)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/bitset/operator_logic2" title="cpp/utility/bitset/operator logic2"> <span class="t-lines"><span>operator&amp;</span><span>operator|</span><span>operator^</span></span></a></div> </td> <td> performs binary logic operations on bitsets <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../numeric/valarray/operator_arith" title="cpp/numeric/valarray/operator arith"> <span class="t-lines"><span>operator~</span></span></a></div> </td> <td> applies a unary arithmetic operator to each element of the valarray <br> <span class="t-mark">(public member function of <code>std::valarray&lt;T&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../numeric/valarray/operator_arith3" title="cpp/numeric/valarray/operator arith3"> <span class="t-lines"><span>operator^</span><span>operator&amp;</span><span>operator|</span></span></a></div> </td> <td> applies binary operators to each element of two valarrays, or a valarray and a value <br> <span class="t-mark">(function template)</span> </td>
</tr> </table> <h4 id="Bitwise_shift_operators_2"> Bitwise shift operators</h4> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../numeric/valarray/operator_arith3" title="cpp/numeric/valarray/operator arith3"> <span class="t-lines"><span>operator&lt;&lt;</span><span>operator&gt;&gt;</span></span></a></div> </td> <td> applies binary operators to each element of two valarrays, or a valarray and a value <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/bitset/operator_ltltgtgt" title="cpp/utility/bitset/operator ltltgtgt"> <span class="t-lines"><span>operator&lt;&lt;</span><span>operator&gt;&gt;</span></span></a></div> </td> <td> performs binary shift left and shift right <br> <span class="t-mark">(public member function of <code>std::bitset&lt;N&gt;</code>)</span> </td>
</tr> </table> <h4 id="Stream_insertion.2Fextraction_operators"> Stream insertion/extraction operators</h4> <p>Throughout the standard library, bitwise shift operators are commonly overloaded with I/O stream (<a href="http://en.cppreference.com/w/cpp/io/ios_base"><span class="kw1674">std::<span class="me2">ios_base</span></span></a><span class="sy3">&amp;</span> or one of the classes derived from it) as both the left operand and return type. Such operators are known as <i>stream insertion</i> and <i>stream extraction</i> operators:</p>
<table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../io/basic_istream/operator_gtgt" title="cpp/io/basic istream/operator gtgt"> <span class="t-lines"><span>operator&gt;&gt;</span></span></a></div> </td> <td> extracts formatted data <br> <span class="t-mark">(public member function of <code>std::basic_istream&lt;CharT,Traits&gt;</code>)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../io/basic_istream/operator_gtgt2" title="cpp/io/basic istream/operator gtgt2"> <span class="t-lines"><span>operator&gt;&gt;<span class="t-dsc-small">(std::basic_istream)</span></span></span></a></div> </td> <td> extracts characters and character arrays <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../io/basic_ostream/operator_ltlt" title="cpp/io/basic ostream/operator ltlt"> <span class="t-lines"><span>operator&lt;&lt;</span></span></a></div> </td> <td> inserts formatted data <br> <span class="t-mark">(public member function of <code>std::basic_ostream&lt;CharT,Traits&gt;</code>)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../io/basic_ostream/operator_ltlt2" title="cpp/io/basic ostream/operator ltlt2"> <span class="t-lines"><span>operator&lt;&lt;<span class="t-dsc-small">(std::basic_ostream)</span></span></span></a></div> </td> <td> inserts character data or insert into rvalue stream <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../numeric/complex/operator_ltltgtgt" title="cpp/numeric/complex/operator ltltgtgt"> <span class="t-lines"><span>operator&lt;&lt;</span><span>operator&gt;&gt;</span></span></a></div> </td> <td> serializes and deserializes a complex number <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/bitset/operator_ltltgtgt2" title="cpp/utility/bitset/operator ltltgtgt2"> <span class="t-lines"><span>operator&lt;&lt;</span><span>operator&gt;&gt;</span></span></a></div> </td> <td> performs stream input and output of bitsets <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../string/basic_string/operator_ltltgtgt" title="cpp/string/basic string/operator ltltgtgt"> <span class="t-lines"><span>operator&lt;&lt;</span><span>operator&gt;&gt;</span></span></a></div> </td> <td> performs stream input and output on strings <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../numeric/random/linear_congruential_engine/operator_ltltgtgt" title="cpp/numeric/random/linear congruential engine/operator ltltgtgt"> <span class="t-lines"><span>operator&lt;&lt;</span><span>operator&gt;&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> performs stream input and output on pseudo-random number engine <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../numeric/random/uniform_int_distribution/operator_ltltgtgt" title="cpp/numeric/random/uniform int distribution/operator ltltgtgt"> <span class="t-lines"><span>operator&lt;&lt;</span><span>operator&gt;&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> performs stream input and output on pseudo-random number distribution <br> <span class="t-mark">(function template)</span>  </td>
</tr> </table> <h3 id="Defect_reports"> Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th> DR </th> <th> Applied to </th> <th> Behavior as published </th> <th> Correct behavior </th>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/614.html">CWG 614</a> </td> <td> C++98 </td> <td> the algebraic quotient of integer division was<br>rounded in implementation-defined direction </td> <td> the algebraic quotient of integer<br>division is truncated towards zero<br>(fractional part is discarded) </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1450.html">CWG 1450</a> </td> <td> C++98 </td> <td> the result of <code>a / b</code> was unspecified if<br>it is not representable in the result type </td> <td> the behavior of both <code>a / b</code> and<br><code>a % b</code> is undefined in this case </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1457.html">CWG 1457</a> </td> <td> C++98 </td> <td> the behavior of shifting the leftmost <code>1</code> bit of a<br>positive signed value into the sign bit was undefined </td> <td> made well-defined </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1504.html">CWG 1504</a> </td> <td> C++98 </td> <td> a pointer to a base class subobject of an array<br>element could be used in pointer arithmetic </td> <td> the behavior is<br>undefined in this case </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1515.html">CWG 1515</a> </td> <td> C++98 </td> <td> only unsigned integers which declared <span class="kw4">unsigned</span> <br>should obey the laws of arithmetic modulo 2<span class="t-su">n<br></span> </td> <td> applies to all unsigned integers </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1865.html">CWG 1865</a> </td> <td> C++98 </td> <td> the resolution of <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1504.html">CWG issue 1504</a> made the behaviors<br>of pointer arithmetic involving pointers to array element<br>undefined if the pointed-to type and the array element<br>type have different cv-qualifications in non-top levels </td> <td> made well-defined </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1971.html">CWG 1971</a> </td> <td> C++98 </td> <td> it was unclear whether the rule resolving the<br>ambiguity of <code>~</code> applies to cases such as <code>~X(0)</code> </td> <td> the rule applies to such cases </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2419.html">CWG 2419</a> </td> <td> C++98 </td> <td> a pointer to non-array object was only treated as a<br>pointer to the first element of an array with size 1<br>in pointer arithmetic if the pointer is obtained by <code>&amp;</code> </td> <td> applies to all pointers<br>to non-array objects </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2626.html">CWG 2626</a> </td> <td> C++98 </td> <td> the result of built-in <code>operator~</code> was simply<br>'one's complement' without proper definition </td> <td> the result is phrased in terms<br>of the base-2 representation </td>
</tr>
</table> <h3 id="See_also"> See also</h3> <p><a href="operator_precedence" title="cpp/language/operator precedence">Operator precedence</a>.</p>
<p><a href="operators" title="cpp/language/operators">Operator overloading</a>.</p>
<table class="wikitable"> <tr style="text-align:center"> <th colspan="7">Common operators </th>
</tr> <tr style="text-align:center"> <td>
<a href="operator_assignment" title="cpp/language/operator assignment">assignment</a> </td> <td>
<a href="operator_incdec" title="cpp/language/operator incdec">increment<br>decrement</a> </td> <td>
<strong class="selflink">arithmetic</strong> </td> <td>
<a href="operator_logical" title="cpp/language/operator logical">logical</a> </td> <td>
<a href="operator_comparison" title="cpp/language/operator comparison">comparison</a> </td> <td>
<a href="operator_member_access" title="cpp/language/operator member access">member<br>access</a> </td> <td>
<a href="operator_other" title="cpp/language/operator other">other</a> </td>
</tr> <tr style="text-align:center"> <td rowspan="6"> <p><code>a = b a += b a -= b a *= b a /= b a %= b a &amp;= b a |= b a ^= b a &lt;&lt;= b a &gt;&gt;= b</code>.</p>
</td> <td rowspan="6"> <p><code>++a --a a++ a--</code></p>
</td> <td rowspan="6"> <p><code>+a -a a + b a - b a * b a / b a % b ~a a &amp; b a | b a ^ b a &lt;&lt; b a &gt;&gt; b</code>.</p>
</td> <td rowspan="6"> <p><code>!a a &amp;&amp; b a || b</code>.</p>
</td> <td rowspan="6"> <p><code>a == b a != b a &lt; b a &gt; b a &lt;= b a &gt;= b a &lt;=&gt; b</code>.</p>
</td> <td rowspan="6"> <p><code>a[...] *a &amp;a a-&gt;b a.b a-&gt;*b a.*b</code>.</p>
</td> <td>function call </td>
</tr> <tr style="text-align:center"> <td>
<code>a(...)</code> </td>
</tr> <tr style="text-align:center"> <td>comma </td>
</tr> <tr style="text-align:center"> <td>
<code>a, b</code> </td>
</tr> <tr style="text-align:center"> <td>conditional </td>
</tr> <tr style="text-align:center"> <td>
<code>a ? b : c</code> </td>
</tr> <tr> <th colspan="7">Special operators </th>
</tr> <tr> <td colspan="7"> <p><a href="static_cast" title="cpp/language/static cast"><code>static_cast</code></a> converts one type to another related type <br> <a href="dynamic_cast" title="cpp/language/dynamic cast"><code>dynamic_cast</code></a> converts within inheritance hierarchies <br> <a href="const_cast" title="cpp/language/const cast"><code>const_cast</code></a> adds or removes <a href="cv" title="cpp/language/cv">cv</a>-qualifiers<br> <a href="reinterpret_cast" title="cpp/language/reinterpret cast"><code>reinterpret_cast</code></a> converts type to unrelated type<br> <a href="explicit_cast" title="cpp/language/explicit cast">C-style cast</a> converts one type to another by a mix of <code>static_cast</code>, <code>const_cast</code>, and <code>reinterpret_cast</code> <br> <a href="new" title="cpp/language/new"><code>new</code></a> creates objects with dynamic storage duration<br> <a href="delete" title="cpp/language/delete"><code>delete</code></a> destructs objects previously created by the new expression and releases obtained memory area<br> <a href="sizeof" title="cpp/language/sizeof"><code>sizeof</code></a> queries the size of a type<br> <a href="sizeof..." title="cpp/language/sizeof..."><code>sizeof...</code></a> queries the size of a <a href="parameter_pack" title="cpp/language/parameter pack">parameter pack</a> <span class="t-mark-rev t-since-cxx11">(since C++11)</span><br> <a href="typeid" title="cpp/language/typeid"><code>typeid</code></a> queries the type information of a type<br> <a href="noexcept" title="cpp/language/noexcept"><code>noexcept</code></a> checks if an expression can throw an exception <span class="t-mark-rev t-since-cxx11">(since C++11)</span><br> <a href="alignof" title="cpp/language/alignof"><code>alignof</code></a> queries alignment requirements of a type <span class="t-mark-rev t-since-cxx11">(since C++11)</span>.</p>
</td>
</tr>
</table> <table class="t-dsc-begin"> <tr class="t-dsc"> <td colspan="2"> <span><a href="https://en.cppreference.com/w/c/language/operator_arithmetic" title="c/language/operator arithmetic">C documentation</a></span> for <span class=""><span>Arithmetic operators</span></span> </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    © cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/language/operator_arithmetic" class="_attribution-link">https://en.cppreference.com/w/cpp/language/operator_arithmetic</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
