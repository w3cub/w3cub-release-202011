
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Copy Constructors - C++ - W3cubDocs</title>
  
  <meta name="description" content="A copy constructor of class T is a non-template constructor whose first parameter is T&#38;‍, const T&#38;‍, volatile T&#38;‍, or const volatile T&# &hellip;">
  <meta name="keywords" content="copy, constructors, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/language/copy_constructor.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-9c7b0d969c0ce639a6c01c2badcdd81667c7c66206aa3d0fccc5cb0585fb1b912dab72ea882101d18010680927514b4b77b107282db8f756fbf63301fe9c88b0.css">
  <script type="text/javascript" src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js"></script>
  <script src="/json/cpp.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _cppref">
				
				
<h1 id="firstHeading" class="firstHeading">Copy constructors</h1>            <p>A copy constructor of class <code>T</code> is a non-template <a href="initializer_list" title="cpp/language/initializer list" class="mw-redirect">constructor</a> whose first parameter is <code>T&amp;</code>‍, <code>const T&amp;</code>‍, <code>volatile T&amp;</code>‍, or <code>const volatile T&amp;</code>‍, and either there are no other parameters, or the rest of the parameters all have default values.</p>
<h3 id="Syntax"> Syntax</h3> <table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">class-name</span> <code>(</code> <code>const</code> <span class="t-spar">class-name</span> <code>&amp;</code> <code>)</code> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">class-name</span> <code>(</code> <code>const</code> <span class="t-spar">class-name</span> <code>&amp;</code> <code>) = default;</code> </td> <td> (2) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">class-name</span> <code>(</code> <code>const</code> <span class="t-spar">class-name</span> <code>&amp;</code> <code>) = delete;</code> </td> <td> (3) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr> 
</table> <p>Where <span class="t-spar">class-name</span> must name the current class (or current instantiation of a class template), or, when declared at namespace scope or in a friend declaration, it must be a qualified class name.</p>
<h3 id="Explanation"> Explanation</h3> <div class="t-li1">
<span class="t-li">1)</span> Typical declaration of a copy constructor.</div> <div class="t-li1">
<span class="t-li">2)</span> Forcing a copy constructor to be generated by the compiler.</div> <div class="t-li1">
<span class="t-li">3)</span> Avoiding implicit generation of the copy constructor.</div> <p>The copy constructor is called whenever an object is <a href="initialization" title="cpp/language/initialization">initialized</a> (by <a href="direct_initialization" title="cpp/language/direct initialization">direct-initialization</a> or <a href="copy_initialization" title="cpp/language/copy initialization">copy-initialization</a>) from another object of the same type (unless <a href="overload_resolution" title="cpp/language/overload resolution">overload resolution</a> selects a better match or the call is <a href="copy_elision" title="cpp/language/copy elision">elided</a>), which includes.</p>
<ul>
<li> initialization: <code>T a = b;</code> or <code>T a(b);</code>, where <code>b</code> is of type <code>T</code>; </li>
<li> function argument passing: <code>f(a);</code>, where <code>a</code> is of type <code>T</code> and <code>f</code> is <code>void f(T t)</code>; </li>
<li> function return: <code>return a;</code> inside a function such as <code>T f()</code>, where <code>a</code> is of type <code>T</code>, which has no <a href="move_constructor" title="cpp/language/move constructor">move constructor</a>. </li>
</ul> <h3 id="Implicitly-declared_copy_constructor"> Implicitly-declared copy constructor</h3> <p>If no user-defined copy constructors are provided for a class type (<code>struct</code>, <code>class</code>, or <code>union</code>), the compiler will always declare a copy constructor as a non-<a href="explicit" title="cpp/language/explicit">explicit</a> <code>inline public</code> member of its class. This implicitly-declared copy constructor has the form <code>T::T(const T&amp;)</code> if all of the following are true:</p>
<ul>
<li> each direct and virtual base <code>B</code> of <code>T</code> has a copy constructor whose parameters are <code>const B&amp;</code> or <code>const volatile B&amp;</code>; </li>
<li> each non-static data member <code>M</code> of <code>T</code> of class type or array of class type has a copy constructor whose parameters are <code>const M&amp;</code> or <code>const volatile M&amp;</code>. </li>
</ul> <p>Otherwise, the implicitly-declared copy constructor is <code>T::T(T&amp;)</code>. (Note that due to these rules, the implicitly-declared copy constructor cannot bind to a volatile lvalue argument.).</p>
<p>A class can have multiple copy constructors, e.g. both <code>T::T(const T&amp;)</code> and <code>T::T(T&amp;)</code>.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>If some user-defined copy constructors are present, the user may still force the generation of the implicitly declared copy constructor with the keyword <code>default</code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <p>The implicitly-declared (or defaulted on its first declaration) copy constructor has an exception specification as described in <span class="t-rev-inl t-until-cxx17"><span><a href="except_spec" title="cpp/language/except spec">dynamic exception specification</a></span> <span><span class="t-mark-rev t-until-cxx17">(until C++17)</span></span></span><span class="t-rev-inl t-since-cxx17"><span><a href="noexcept_spec" title="cpp/language/noexcept spec">noexcept specification</a></span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span>.</p>
<h3 id="Deleted_implicitly-declared_copy_constructor"> Deleted implicitly-declared copy constructor</h3> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx11">
<td> <p>The implicitly-declared copy constructor for class <code>T</code> is undefined if any of the following conditions are true:</p>
</td> <td><span class="t-mark-rev t-until-cxx11">(until C++11)</span></td>
</tr> <tr class="t-rev t-since-cxx11">
<td> <p>The implicitly-declared or defaulted copy constructor for class <code>T</code> is defined as <i>deleted</i> if any of the following conditions are true:</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <ul>
<li> <code>T</code> has non-static data members that cannot be copied (have deleted, inaccessible, or ambiguous copy constructors); </li>
<li> <code>T</code> has direct or virtual base class that cannot be copied (has deleted, inaccessible, or ambiguous copy constructors); </li>
<li> <code>T</code> has direct or virtual base class or a non-static data member with a deleted or inaccessible destructor; </li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul>
<li> <code>T</code> is a union-like class and has a variant member with non-trivial copy constructor; </li>
<li> <code>T</code> has a data member of rvalue reference type; </li>
<li> <code>T</code> has a user-defined <a href="move_constructor" title="cpp/language/move constructor">move constructor</a> or <a href="move_assignment" title="cpp/language/move assignment">move assignment operator</a> (this condition only causes the implicitly-declared, not the defaulted, copy constructor to be deleted). </li>
</ul> </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <h3 id="Trivial_copy_constructor"> Trivial copy constructor</h3> <p>The copy constructor for class <code>T</code> is trivial if all of the following are true:</p>
<ul>
<li> it is not user-provided (that is, it is implicitly-defined or defaulted); </li>
<li> <code>T</code> has no virtual member functions; </li>
<li> <code>T</code> has no virtual base classes; </li>
<li> the copy constructor selected for every direct base of <code>T</code> is trivial; </li>
<li> the copy constructor selected for every non-static class type (or array of class type) member of <code>T</code> is trivial; </li>
</ul> <p>A trivial copy constructor for a non-union class effectively copies every scalar subobject (including, recursively, subobject of subobjects and so forth) of the argument and performs no other action. However, padding bytes need not be copied, and even the object representations of the copied subobjects need not be the same as long as their values are identical.</p>
<p><a href="../named_req/triviallycopyable" title="cpp/named req/TriviallyCopyable">TriviallyCopyable</a> objects can be copied by copying their object representations manually, e.g. with <code><a href="../string/byte/memmove" title="cpp/string/byte/memmove">std::memmove</a></code>. All data types compatible with the C language (POD types) are trivially copyable.</p>
<h3 id="Eligible_copy_constructor"> Eligible copy constructor</h3> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx11">
<td> <p>A copy constructor is eligible if it is either user-declared or both implicitly-declared and definable.</p>
</td> <td><span class="t-mark-rev t-until-cxx11">(until C++11)</span></td>
</tr> <tr class="t-rev t-since-cxx11 t-until-cxx20">
<td> <p>A copy constructor is eligible if it is not deleted.</p>
</td> <td>
<span class="t-mark-rev t-since-cxx11">(since C++11)</span><br><span class="t-mark-rev t-until-cxx20">(until C++20)</span>
</td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <p>A copy constructor is eligible if.</p>
<ul>
<li> it is not deleted, and </li>
<li> its <a href="constraints" title="cpp/language/constraints">associated constraints</a>, if any, are satisfied, and </li>
<li> no copy constructor with the same first parameter type is <a href="constraints#Partial_ordering_of_constraints" title="cpp/language/constraints">more constrained</a> than it. </li>
</ul> </td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <p>Triviality of eligible copy constructors determines whether the class is an <a href="lifetime#Implicit-lifetime_types" title="cpp/language/lifetime">implicit-lifetime type</a>, and whether the class is a <a href="../named_req/triviallycopyable" title="cpp/named req/TriviallyCopyable">trivially copyable type</a>.</p>
<h3 id="Implicitly-defined_copy_constructor"> Implicitly-defined copy constructor</h3> <p>If the implicitly-declared copy constructor is not deleted, it is defined (that is, a function body is generated and compiled) by the compiler if <a href="definition#ODR-use" title="cpp/language/definition">odr-used</a><span class="t-rev-inl t-since-cxx11"><span> or <a href="constant_expression#Functions_and_variables_needed_for_constant_evaluation" title="cpp/language/constant expression">needed for constant evaluation</a></span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>. For union types, the implicitly-defined copy constructor copies the object representation (as by <code><a href="../string/byte/memmove" title="cpp/string/byte/memmove">std::memmove</a></code>). For non-union class types (<code>class</code> and <code>struct</code>), the constructor performs full member-wise copy of the object's bases and non-static members, in their initialization order, using direct initialization.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>If this satisfies the requirements of a <span class="t-rev-inl t-until-cxx23"><span><a href="constexpr#constexpr_constructor" title="cpp/language/constexpr">constexpr constructor</a></span> <span><span class="t-mark-rev t-until-cxx23">(until C++23)</span></span></span><span class="t-rev-inl t-since-cxx23"><span><a href="constexpr#constexpr_function" title="cpp/language/constexpr">constexpr function</a></span> <span><span class="t-mark-rev t-since-cxx23">(since C++23)</span></span></span>, the generated copy constructor is <code>constexpr</code>.</p>
<p>The generation of the implicitly-defined copy constructor is deprecated if <code>T</code> has a user-defined destructor or user-defined copy assignment operator.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <h3 id="Notes"> Notes</h3> <p>In many situations, copy constructors are optimized out even if they would produce observable side-effects, see <a href="copy_elision" title="cpp/language/copy elision">copy elision</a>.</p>
<h3 id="Example"> Example</h3> <div class="cpp source-cpp"><pre data-language="cpp">struct A
{
    int n;
    A(int n = 1) : n(n) {}
    A(const A&amp; a) : n(a.n) {} // user-defined copy constructor
};
 
struct B : A
{
    // implicit default constructor B::B()
    // implicit copy constructor B::B(const B&amp;)
};
 
struct C : B
{
    C() : B() {}
private:
    C(const C&amp;); // non-copyable, C++98 style
};
 
int main()
{
    A a1(7);
    A a2(a1); // calls the copy constructor
 
    B b;
    B b2 = b;
    A a3 = b; // conversion to A&amp; and copy constructor
 
    volatile A va(10);
    // A a4 = va; // compile error
 
    C c;
    // C c2 = c; // compile error
}</pre></div> <h3 id="Defect_reports"> Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th> DR </th> <th> Applied to </th> <th> Behavior as published </th> <th> Correct behavior </th>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2094.html">CWG 2094</a> </td> <td> C++11 </td> <td> volatile members make copy non-trivial (<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/496.html">CWG issue 496</a>) </td> <td> triviality not affected </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2171.html">CWG 2171</a> </td> <td> C++11 </td> <td> <code>X(X&amp;) = default</code> was non-trivial </td> <td> made trivial </td>
</tr>
</table> <h3 id="See_also"> See also</h3> <ul>
<li> <a href="converting_constructor" title="cpp/language/converting constructor">converting constructor</a> </li>
<li> <a href="copy_assignment" title="cpp/language/copy assignment">copy assignment</a> </li>
<li> <a href="copy_elision" title="cpp/language/copy elision">copy elision</a> </li>
<li> <a href="default_constructor" title="cpp/language/default constructor">default constructor</a> </li>
<li> <a href="destructor" title="cpp/language/destructor">destructor</a> </li>
<li> <a href="explicit" title="cpp/language/explicit"><code>explicit</code></a> </li>
<li> <a href="initialization" title="cpp/language/initialization">initialization</a> <ul>
<li> <a href="aggregate_initialization" title="cpp/language/aggregate initialization">aggregate initialization</a> </li>
<li> <a href="constant_initialization" title="cpp/language/constant initialization">constant initialization</a> </li>
<li> <a href="copy_initialization" title="cpp/language/copy initialization">copy initialization</a> </li>
<li> <a href="default_initialization" title="cpp/language/default initialization">default initialization</a> </li>
<li> <a href="direct_initialization" title="cpp/language/direct initialization">direct initialization</a> </li>
<li> <a href="initializer_list" title="cpp/language/initializer list" class="mw-redirect">initializer list</a> </li>
<li> <a href="list_initialization" title="cpp/language/list initialization">list initialization</a> </li>
<li> <a href="reference_initialization" title="cpp/language/reference initialization">reference initialization</a> </li>
<li> <a href="value_initialization" title="cpp/language/value initialization">value initialization</a> </li>
<li> <a href="zero_initialization" title="cpp/language/zero initialization">zero initialization</a> </li>
</ul> </li>
<li> <a href="move_assignment" title="cpp/language/move assignment">move assignment</a> </li>
<li> <a href="move_constructor" title="cpp/language/move constructor">move constructor</a> </li>
<li> <a href="new" title="cpp/language/new"><code>new</code></a> </li>
</ul>           <div class="_attribution">
  <p class="_attribution-p">
    © cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/language/copy_constructor" class="_attribution-link">https://en.cppreference.com/w/cpp/language/copy_constructor</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
