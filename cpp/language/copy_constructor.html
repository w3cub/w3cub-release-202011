
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Copy Constructors - C++ - W3cubDocs</title>
  
  <meta name="description" content="A copy constructor of class T is a non-template constructor whose first parameter is T&#38;‍, const T&#38;‍, volatile T&#38;‍, or const volatile T&# &hellip;">
  <meta name="keywords" content="copy, constructors, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/language/copy_constructor.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/cpp.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _c">
				
				
<h1 id="firstHeading" class="firstHeading">Copy constructors</h1>            <p>A copy constructor of class <code>T</code> is a non-template <a href="constructor" title="cpp/language/initializer list">constructor</a> whose first parameter is <code>T&amp;</code>‍, <code>const T&amp;</code>‍, <code>volatile T&amp;</code>‍, or <code>const volatile T&amp;</code>‍, and either there are no other parameters, or the rest of the parameters all have default values.</p>
<h3 id="Syntax">Syntax</h3> <table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">class_name</span> ( <code>const</code> <span class="t-spar">class_name</span> <code>&amp;</code> ) </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">class_name</span> ( <code>const</code> <span class="t-spar">class_name</span> <code>&amp;</code> ) = <code>default;</code> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">class_name</span> ( <code>const</code> <span class="t-spar">class_name</span> <code>&amp;</code> ) = <code>delete;</code> </td> <td> (3) </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <p>Where <span class="t-spar">class_name</span> must name the current class (or current instantiation of a class template), or, when declared at namespace scope or in a friend declaration, it must be a qualified class name.</p>
<h3 id="Explanation">Explanation</h3> <ol>
<li> Typical declaration of a copy constructor. </li>
<li> Forcing a copy constructor to be generated by the compiler. </li>
<li> Avoiding implicit generation of the copy constructor. </li>
</ol> <p>The copy constructor is called whenever an object is <a href="initialization" title="cpp/language/initialization">initialized</a> (by <a href="direct_initialization" title="cpp/language/direct initialization">direct-initialization</a> or <a href="copy_initialization" title="cpp/language/copy initialization">copy-initialization</a>) from another object of the same type (unless <a href="overload_resolution" title="cpp/language/overload resolution">overload resolution</a> selects a better match or the call is <a href="copy_elision" title="cpp/language/copy elision">elided</a>), which includes.</p>
<ul>
<li> initialization: <code>T a = b;</code> or <code>T a(b);</code>, where b is of type <code>T</code>; </li>
<li> function argument passing: <code>f(a);</code>, where <code>a</code> is of type <code>T</code> and <code>f</code> is <code>void f(T t)</code>; </li>
<li> function return: <code>return a;</code> inside a function such as <code>T f()</code>, where <code>a</code> is of type <code>T</code>, which has no <a href="move_constructor" title="cpp/language/move constructor">move constructor</a>. </li>
</ul> <h3 id="Implicitly-declared_copy_constructor">Implicitly-declared copy constructor</h3> <p>If no user-defined copy constructors are provided for a class type (<code>struct</code>, <code>class</code>, or <code>union</code>), the compiler will always declare a copy constructor as a non-<a href="explicit" title="cpp/language/explicit">explicit</a> <code>inline public</code> member of its class. This implicitly-declared copy constructor has the form <code>T::T(const T&amp;)</code> if all of the following are true:</p>
<ul>
<li> each direct and virtual base <code>B</code> of <code>T</code> has a copy constructor whose parameters are <code>const B&amp;</code> or <code>const volatile B&amp;</code>; </li>
<li> each non-static data member <code>M</code> of <code>T</code> of class type or array of class type has a copy constructor whose parameters are <code>const M&amp;</code> or <code>const volatile M&amp;</code>. </li>
</ul> <p>Otherwise, the implicitly-declared copy constructor is <code>T::T(T&amp;)</code>. (Note that due to these rules, the implicitly-declared copy constructor cannot bind to a volatile lvalue argument.).</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>A class can have multiple copy constructors, e.g. both <code>T::T(const T&amp;)</code> and <code>T::T(T&amp;)</code>. If some user-defined copy constructors are present, the user may still force the generation of the implicitly declared copy constructor with the keyword <code>default</code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <p>The implicitly-declared (or defaulted on its first declaration) copy constructor has an exception specification as described in <span class="t-rev-inl t-until-cxx17"><span><a href="except_spec" title="cpp/language/except spec">dynamic exception specification</a></span> <span><span class="t-mark-rev t-until-cxx17">(until C++17)</span></span></span><span class="t-rev-inl t-since-cxx17"><span><a href="noexcept_spec" title="cpp/language/noexcept spec">exception specification</a></span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span>.</p>
<h3 id="Deleted_implicitly-declared_copy_constructor">Deleted implicitly-declared copy constructor</h3> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx11">
<td> The implicitly-declared copy constructor for class <code>T</code> is undefined if any of the following conditions are true: </td> <td><span class="t-mark-rev t-until-cxx11">(until C++11)</span></td>
</tr> <tr class="t-rev t-since-cxx11">
<td> The implicitly-declared or defaulted copy constructor for class <code>T</code> is defined as <i>deleted</i> if any of the following conditions are true: </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <ul>
<li> <code>T</code> has non-static data members that cannot be copied (have deleted, inaccessible, or ambiguous copy constructors); </li>
<li> <code>T</code> has direct or virtual base class that cannot be copied (has deleted, inaccessible, or ambiguous copy constructors); </li>
<li> <code>T</code> has direct or virtual base class with a deleted or inaccessible destructor; </li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul>
<li> <code>T</code> is a union-like class and has a variant member with non-trivial copy constructor; </li>
<li> <code>T</code> has a data member of rvalue reference type; </li>
<li> <code>T</code> has a user-defined <a href="move_constructor" title="cpp/language/move constructor">move constructor</a> or <a href="move_operator" title="cpp/language/move assignment">move assignment operator</a> (this condition only causes the implicitly-declared, not the defaulted, copy constructor to be deleted). </li>
</ul> </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <h3 id="Trivial_copy_constructor">Trivial copy constructor</h3> <p>The copy constructor for class <code>T</code> is trivial if all of the following are true:</p>
<ul>
<li> it is not user-provided (that is, it is implicitly-defined or defaulted)<span class="t-rev-inl t-until-cxx14"><span> , and if it is defaulted, its signature is the same as implicitly-defined</span> <span><span class="t-mark-rev t-until-cxx14">(until C++14)</span></span></span>; </li>
<li> <code>T</code> has no virtual member functions; </li>
<li> <code>T</code> has no virtual base classes; </li>
<li> the copy constructor selected for every direct base of <code>T</code> is trivial; </li>
<li> the copy constructor selected for every non-static class type (or array of class type) member of <code>T</code> is trivial; </li>
</ul> <p>A trivial copy constructor for a non-union class effectively copies every scalar subobject (including, recursively, subobject of subobjects and so forth) of the argument and performs no other action. However, padding bytes need not be copied, and even the object representations of the copied subobjects need not be the same as long as their values are identical.</p>
<p><a href="../named_req/triviallycopyable" title="cpp/named req/TriviallyCopyable">TriviallyCopyable</a> objects can be copied by copying their object representations manually, e.g. with <code><a href="../string/byte/memmove" title="cpp/string/byte/memmove">std::memmove</a></code>. All data types compatible with the C language (POD types) are trivially copyable.</p>
<h3 id="Implicitly-defined_copy_constructor">Implicitly-defined copy constructor</h3> <p>If the implicitly-declared copy constructor is not deleted, it is defined (that is, a function body is generated and compiled) by the compiler if <a href="definition#ODR-use" title="cpp/language/definition">odr-used</a>. For <code>union</code> types, the implicitly-defined copy constructor copies the object representation (as by <code><a href="../string/byte/memmove" title="cpp/string/byte/memmove">std::memmove</a></code>). For non-union class types (<code>class</code> and <code>struct</code>), the constructor performs full member-wise copy of the object's bases and non-static members, in their initialization order, using direct initialization. <span class="t-rev-inl t-since-cxx11"><span>If this satisfies the requirements of a <a href="constexpr" title="cpp/language/constexpr">constexpr constructor</a>, the generated copy constructor is <code>constexpr</code>.</span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>The generation of the implicitly-defined copy constructor is deprecated if <code>T</code> has a user-defined destructor or user-defined copy assignment operator.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <h3 id="Notes">Notes</h3> <p>In many situations, copy constructors are optimized out even if they would produce observable side-effects, see <a href="copy_elision" title="cpp/language/copy elision">copy elision</a>.</p>
<h3 id="Example">Example</h3> <div class="cpp source-cpp"><pre data-language="cpp">struct A
{
    int n;
    A(int n = 1) : n(n) { }
    A(const A&amp; a) : n(a.n) { } // user-defined copy ctor
};
 
struct B : A
{
    // implicit default ctor B::B()
    // implicit copy ctor B::B(const B&amp;)
};
 
struct C : B
{
     C() : B() { }
 private:
     C(const C&amp;); // non-copyable, C++98 style
};
 
int main()
{
    A a1(7);
    A a2(a1); // calls the copy ctor
    B b;
    B b2 = b;
    A a3 = b; // conversion to A&amp; and copy ctor
    volatile A va(10);
    // A a4 = va; // compile error
 
    C c;
    // C c2 = c; // compile error
}</pre></div> <h3 id="Defect_reports">Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th> DR </th> <th> Applied to </th> <th> Behavior as published </th> <th> Correct behavior </th>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://wg21.link/cwg2171">CWG 2171</a> </td> <td> C++14 </td> <td> <code>X(X&amp;) = default</code> was non-trivial </td> <td> made trivial </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://wg21.link/cwg496">CWG 496</a> </td> <td> C++11 </td> <td> structs with volatile members were trivially copyable </td> <td> volatile members make copy non-trivial </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://wg21.link/cwg2094">CWG 2094</a> </td> <td> C++14 </td> <td> volatile members make copy non-trivial </td> <td> structs with volatile members are trivially copyable </td>
</tr>
</table>          <div class="_attribution">
  <p class="_attribution-p">
    © cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/language/copy_constructor" class="_attribution-link">http://en.cppreference.com/w/cpp/language/copy_constructor</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
