
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Copy Assignment Operator - C++ - W3cubDocs</title>
  
  <meta name="description" content="A copy assignment operator of class T is a non-template non-static member function with the name operator&#61; that takes exactly one parameter of &hellip;">
  <meta name="keywords" content="copy, assignment, operator, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/language/as_operator.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/cpp.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _c">
				
				
<h1 id="firstHeading" class="firstHeading">Copy assignment operator</h1>            <p>A copy assignment operator of class <code>T</code> is a non-template <a href="member_functions" title="cpp/language/member functions">non-static member function</a> with the name <code>operator=</code> that takes exactly one parameter of type <code>T</code>, <code>T&amp;</code>, <code>const T&amp;</code>, <code>volatile T&amp;</code>, or <code>const volatile T&amp;</code>. For a type to be <a href="../named_req/copyassignable" title="cpp/named req/CopyAssignable">CopyAssignable</a>, it must have a public copy assignment operator.</p>
<h3 id="Syntax">Syntax</h3> <table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">class_name</span> <code>&amp;</code> <span class="t-spar">class_name</span> <code>:: operator=</code> ( <span class="t-spar">class_name</span> ) </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">class_name</span> <code>&amp;</code> <span class="t-spar">class_name</span> <code>:: operator=</code> ( const <span class="t-spar">class_name</span> <code>&amp;</code> ) </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">class_name</span> <code>&amp;</code> <span class="t-spar">class_name</span> <code>:: operator=</code> ( const <span class="t-spar">class_name</span> <code>&amp;</code> ) = <code>default;</code> </td> <td> (3) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">class_name</span> <code>&amp;</code> <span class="t-spar">class_name</span> <code>:: operator=</code> ( const <span class="t-spar">class_name</span> <code>&amp;</code> ) = <code>delete;</code> </td> <td> (4) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr> 
</table> <h3 id="Explanation">Explanation</h3> <ol>
<li> Typical declaration of a copy assignment operator when <a href="operators#Assignment_operator" title="cpp/language/operators">copy-and-swap idiom</a> can be used. </li>
<li> Typical declaration of a copy assignment operator when copy-and-swap idiom cannot be used (non-swappable type or degraded performance). </li>
<li> Forcing a copy assignment operator to be generated by the compiler. </li>
<li> Avoiding implicit copy assignment. </li>
</ol> <p>The copy assignment operator is called whenever selected by <a href="overload_resolution" title="cpp/language/overload resolution">overload resolution</a>, e.g. when an object appears on the left side of an assignment expression.</p>
<h3 id="Implicitly-declared_copy_assignment_operator">Implicitly-declared copy assignment operator</h3> <p>If no user-defined copy assignment operators are provided for a class type (<code>struct</code>, <code>class</code>, or <code>union</code>), the compiler will always declare one as an inline public member of the class. This implicitly-declared copy assignment operator has the form <code>T&amp; T::operator=(const T&amp;)</code> if all of the following is true:</p>
<ul>
<li> each direct base <code>B</code> of <code>T</code> has a copy assignment operator whose parameters are <code>B</code> or <code>const B&amp;</code> or <code>const volatile B&amp;</code>; </li>
<li> each non-static data member <code>M</code> of <code>T</code> of class type or array of class type has a copy assignment operator whose parameters are <code>M</code> or <code>const M&amp;</code> or <code>const volatile M&amp;</code>. </li>
</ul> <p>Otherwise the implicitly-declared copy assignment operator is declared as <code>T&amp; T::operator=(T&amp;)</code>. (Note that due to these rules, the implicitly-declared copy assignment operator cannot bind to a volatile lvalue argument.).</p>
<p>A class can have multiple copy assignment operators, e.g. both <code>T&amp; T::operator=(const T&amp;)</code> and <code>T&amp; T::operator=(T)</code>. <span class="t-rev-inl t-since-cxx11"><span>If some user-defined copy assignment operators are present, the user may still force the generation of the implicitly declared copy assignment operator with the keyword <code>default</code>.</span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>.</p>
<p>The implicitly-declared (or defaulted on its first declaration) copy assignment operator has an exception specification as described in <span class="t-rev-inl t-until-cxx17"><span><a href="except_spec" title="cpp/language/except spec">dynamic exception specification</a></span> <span><span class="t-mark-rev t-until-cxx17">(until C++17)</span></span></span><span class="t-rev-inl t-since-cxx17"><span><a href="noexcept_spec" title="cpp/language/noexcept spec">exception specification</a></span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span>.</p>
<p>Because the copy assignment operator is always declared for any class, the base class assignment operator is always hidden. If a <a href="using_declaration#In_class_definition" title="cpp/language/using declaration">using-declaration</a> is used to bring in the assignment operator from the base class, and its argument type could be the same as the argument type of the implicit assignment operator of the derived class, the using-declaration is also hidden by the implicit declaration.</p>
<h3 id="Deleted_implicitly-declared_copy_assignment_operator">Deleted implicitly-declared copy assignment operator</h3> <p>A implicitly-declared copy assignment operator for class <code>T</code> is defined as <i>deleted</i> if any of the following is true:</p>
<ul>
<li> <code>T</code> has a user-declared move constructor; </li>
<li> <code>T</code> has a user-declared move assignment operator. </li>
</ul> <p>Otherwise, it is defined as defaulted.</p>
<p>A defaulted copy assignment operator for class <code>T</code> is defined as <i>deleted</i> if any of the following is true:</p>
<ul>
<li> <code>T</code> has a non-static data member of non-class type (or array thereof) that is <code>const</code>; </li>
<li> <code>T</code> has a non-static data member of a reference type; </li>
<li> <code>T</code> has a non-static data member or a direct or virtual base class that cannot be copy-assigned (overload resolution for the copy assignment fails, or selects a deleted or inaccessible function); </li>
<li> <code>T</code> is a <a href="union#Union-like_classes" title="cpp/language/union">union-like class</a>, and has a variant member whose corresponding assignment operator is non-trivial. </li>
</ul> <h3 id="Trivial_copy_assignment_operator">Trivial copy assignment operator</h3> <p>The copy assignment operator for class <code>T</code> is trivial if all of the following is true:</p>
<ul>
<li> it is not user-provided (meaning, it is implicitly-defined or defaulted)<span class="t-rev-inl t-until-cxx14"><span> , , and if it is defaulted, its signature is the same as implicitly-defined</span> <span><span class="t-mark-rev t-until-cxx14">(until C++14)</span></span></span>; </li>
<li> <code>T</code> has no virtual member functions; </li>
<li> <code>T</code> has no virtual base classes; </li>
<li> the copy assignment operator selected for every direct base of <code>T</code> is trivial; </li>
<li> the copy assignment operator selected for every non-static class type (or array of class type) member of <code>T</code> is trivial; </li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx14">
<td> <ul><li> <code>T</code> has no non-static data members of <a href="cv" title="cpp/language/cv">volatile</a>-qualified type. </li></ul> </td> <td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr> </table> <p>A trivial copy assignment operator makes a copy of the object representation as if by <code><a href="../string/byte/memmove" title="cpp/string/byte/memmove">std::memmove</a></code>. All data types compatible with the C language (POD types) are trivially copy-assignable.</p>
<h3 id="Implicitly-defined_copy_assignment_operator">Implicitly-defined copy assignment operator</h3> <p>If the implicitly-declared copy assignment operator is neither deleted nor trivial, it is defined (that is, a function body is generated and compiled) by the compiler if <a href="definition#ODR-use" title="cpp/language/definition">odr-used</a>. For <code>union</code> types, the implicitly-defined copy assignment copies the object representation (as by <code><a href="../string/byte/memmove" title="cpp/string/byte/memmove">std::memmove</a></code>). For non-union class types (<code>class</code> and <code>struct</code>), the operator performs member-wise copy assignment of the object's bases and non-static members, in their initialization order, using built-in assignment for the scalars and copy assignment operator for class types.</p>
<p>The generation of the implicitly-defined copy assignment operator is deprecated<span class="t-mark-rev t-since-cxx11">(since C++11)</span> if <code>T</code> has a user-declared destructor or user-declared copy constructor.</p>
<h3 id="Notes">Notes</h3> <p>If both copy and move assignment operators are provided, overload resolution selects the move assignment if the argument is an <a href="value_category" title="cpp/language/value category"><i>rvalue</i></a> (either a <a href="value_category" title="cpp/language/value category"><i>prvalue</i></a> such as a nameless temporary or an <a href="value_category" title="cpp/language/value category"><i>xvalue</i></a> such as the result of <code>std::move</code>), and selects the copy assignment if the argument is an <a href="value_category" title="cpp/language/value category"><i>lvalue</i></a> (named object or a function/operator returning lvalue reference). If only the copy assignment is provided, all argument categories select it (as long as it takes its argument by value or as reference to const, since rvalues can bind to const references), which makes copy assignment the fallback for move assignment, when move is unavailable.</p>
<p>It is unspecified whether virtual base class subobjects that are accessible through more than one path in the inheritance lattice, are assigned more than once by the implicitly-defined copy assignment operator (same applies to <a href="move_operator" title="cpp/language/move assignment">move assignment</a>).</p>
<p>See <a href="operators#Assignment_operator" title="cpp/language/operators">assignment operator overloading</a> for additional detail on the expected behavior of a user-defined copy-assignment operator.</p>
<h3 id="Example">Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
 
struct A
{
    int n;
    std::string s1;
    // user-defined copy assignment, copy-and-swap form
    A&amp; operator=(A other)
    {
        std::cout &lt;&lt; "copy assignment of A\n";
        std::swap(n, other.n);
        std::swap(s1, other.s1);
        return *this;
    }
};
 
struct B : A
{
    std::string s2;
    // implicitly-defined copy assignment
};
 
struct C
{
    std::unique_ptr&lt;int[]&gt; data;
    std::size_t size;
    // non-copy-and-swap assignment
    C&amp; operator=(const C&amp; other)
    {
        // check for self-assignment
        if(&amp;other == this)
            return *this;
        // reuse storage when possible
        if(size != other.size)
        {
            data.reset(new int[other.size]);
            size = other.size;
        }
        std::copy(&amp;other.data[0], &amp;other.data[0] + size, &amp;data[0]);
        return *this;
    }
    // note: copy-and-swap would always cause a reallocation
};
 
int main()
{
    A a1, a2;
    std::cout &lt;&lt; "a1 = a2 calls ";
    a1 = a2; // user-defined copy assignment
 
    B b1, b2;
    b2.s1 = "foo";
    b2.s2 = "bar";
    std::cout &lt;&lt; "b1 = b2 calls ";
    b1 = b2; // implicitly-defined copy assignment
    std::cout &lt;&lt; "b1.s1 = " &lt;&lt; b1.s1 &lt;&lt; " b1.s2 = " &lt;&lt; b1.s2 &lt;&lt; '\n';
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">a1 = a2 calls copy assignment of A
b1 = b2 calls copy assignment of A
b1.s1 = foo b1.s2 = bar</pre></div> </div> <h3 id="Defect_reports">Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th> DR </th> <th> Applied to </th> <th> Behavior as published </th> <th> Correct behavior </th>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://wg21.link/cwg2171">CWG 2171</a> </td> <td> C++14 </td> <td> <code>operator=(X&amp;) = default</code> was non-trivial </td> <td> made trivial </td>
</tr>
</table>          <div class="_attribution">
  <p class="_attribution-p">
    Â© cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/language/as_operator" class="_attribution-link">http://en.cppreference.com/w/cpp/language/as_operator</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
