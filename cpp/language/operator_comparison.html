
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Comparison Operators - C++ - W3cubDocs</title>
  
  <meta name="description" content=" Compares the arguments. ">
  <meta name="keywords" content="comparison, operators, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/language/operator_comparison.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/cpp.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _c">
				
				
<h1 id="firstHeading" class="firstHeading">Comparison operators</h1>            <p>Compares the arguments.</p>
<table class="wikitable"> <tr> <th rowspan="2"> Operator name </th> <th rowspan="2"> Syntax </th> <th rowspan="2"> <a href="operators" title="cpp/language/operators">Over​load​able</a> </th> <th colspan="2"> Prototype examples (for <code>class T</code>) </th>
</tr> <tr> <th> As member function </th> <th> As free (namespace) function </th>
</tr> <tr> <td> equal to </td> <td> <code>a == b</code> </td> <td class="table-yes">Yes </td> <td> <code>bool T::operator ==(const T2 &amp;b) const;</code> </td> <td> <code>bool operator ==(const T &amp;a, const T2 &amp;b);</code> </td>
</tr> <tr> <td> not equal to </td> <td> <code>a != b</code> </td> <td class="table-yes">Yes </td> <td> <code>bool T::operator !=(const T2 &amp;b) const;</code> </td> <td> <code>bool operator !=(const T &amp;a, const T2 &amp;b);</code> </td>
</tr> <tr> <td> less than </td> <td> <code>a &lt; b</code> </td> <td class="table-yes">Yes </td> <td> <code>bool T::operator &lt;(const T2 &amp;b) const;</code> </td> <td> <code>bool operator &lt;(const T &amp;a, const T2 &amp;b);</code> </td>
</tr> <tr> <td> greater than </td> <td> <code>a &gt; b</code> </td> <td class="table-yes">Yes </td> <td> <code>bool T::operator &gt;(const T2 &amp;b) const;</code> </td> <td> <code>bool operator &gt;(const T &amp;a, const T2 &amp;b);</code> </td>
</tr> <tr> <td> less than or equal to </td> <td> <code>a &lt;= b</code> </td> <td class="table-yes">Yes </td> <td> <code>bool T::operator &lt;=(const T2 &amp;b) const;</code> </td> <td> <code>bool operator &lt;=(const T &amp;a, const T2 &amp;b);</code> </td>
</tr> <tr> <td> greater than or equal to </td> <td> <code>a &gt;= b</code> </td> <td class="table-yes">Yes </td> <td> <code>bool T::operator &gt;=(const T2 &amp;b) const;</code> </td> <td> <code>bool operator &gt;=(const T &amp;a, const T2 &amp;b);</code> </td>
</tr> <tr> <td> three-way comparison <span class="t-mark-rev t-since-cxx20">(C++20)</span> </td> <td> <code>a &lt;=&gt; b</code> </td> <td class="table-yes">Yes </td> <td> <code>/*see description*/ T::operator &lt;=&gt;(const T2 &amp;b) const;</code> </td> <td> <code>/*see description*/ operator &lt;=&gt;(const T &amp;a, const T2 &amp;b);</code> </td>
</tr> <tr> <td colspan="5"> <b>Notes</b><br>  <ul>
<li> Where built-in operators return <code>bool</code>, most <a href="operators" title="cpp/language/operators">user-defined overloads</a> also return <code>bool</code> so that the user-defined operators can be used in the same manner as the built-ins. However, in a user-defined operator overload, any type can be used as return type (including <code>void</code>). </li>
<li> <code>T2</code> can be any type including <code>T</code> </li>
</ul> </td>
</tr>
</table> <h3 id="Two-way_comparison">Two-way comparison</h3> <p>The two-way comparison operator expressions have the form.</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">lhs</span> <code>&lt;</code> <span class="t-spar">rhs</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">lhs</span> <code>&gt;</code> <span class="t-spar">rhs</span> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">lhs</span> <code>&lt;=</code> <span class="t-spar">rhs</span> </td> <td> (3) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">lhs</span> <code>&gt;=</code> <span class="t-spar">rhs</span> </td> <td> (4) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">lhs</span> <code>==</code> <span class="t-spar">rhs</span> </td> <td> (5) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">lhs</span> <code>!=</code> <span class="t-spar">rhs</span> </td> <td> (6) </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <div class="t-li1">
<span class="t-li">1)</span> Returns <code>true</code> if <span class="t-spar">lhs</span> is less than <span class="t-spar">rhs</span>, <code>false</code> otherwise.</div> <div class="t-li1">
<span class="t-li">2)</span> Returns <code>true</code> if <span class="t-spar">lhs</span> is greater than <span class="t-spar">rhs</span>, <code>false</code> otherwise.</div> <div class="t-li1">
<span class="t-li">3)</span> Returns <code>true</code> if <span class="t-spar">lhs</span> is less than or equal to <span class="t-spar">rhs</span>, <code>false</code> otherwise.</div> <div class="t-li1">
<span class="t-li">4)</span> Returns <code>true</code> if <span class="t-spar">lhs</span> is greater than or equal to <span class="t-spar">rhs</span>, <code>false</code> otherwise.</div> <div class="t-li1">
<span class="t-li">5)</span> Returns <code>true</code> if <span class="t-spar">lhs</span> is equal to <span class="t-spar">rhs</span>, <code>false</code> otherwise.</div> <div class="t-li1">
<span class="t-li">6)</span> Returns <code>true</code> if <span class="t-spar">lhs</span> is not equal to <span class="t-spar">rhs</span>, <code>false</code> otherwise.</div> <p>In all cases, for the built-in operators, <span class="t-spar">lhs</span> and <span class="t-spar">rhs</span> must have either.</p>
<ul>
<li> arithmetic or enumeration type (see arithmetic comparison operators below) </li>
<li> pointer type (see pointer comparison operators below) </li>
</ul> <p>after the application of the <a href="implicit_cast#Lvalue_to_rvalue_conversion" title="cpp/language/implicit conversion">lvalue-to-rvalue</a>, <a href="implicit_cast#Array_to_pointer_conversion" title="cpp/language/implicit conversion">array-to-pointer</a> and <a href="implicit_cast#Function_to_pointer" title="cpp/language/implicit conversion">function-to-pointer</a> standard conversions. <span class="t-rev-inl t-since-cxx20"><span>The comparison is deprecated if both operands have array type prior to the application of these conversions.</span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span>.</p>
<p>In any case, the result is a <code>bool</code> prvalue.</p>
<h4 id="Arithmetic_comparison_operators">Arithmetic comparison operators</h4> <p>If the operands has arithmetic or enumeration type (scoped or unscoped), <i>usual arithmetic conversions</i> are performed on both operands following the rules for <a href="operator_arithmetic" title="cpp/language/operator arithmetic">arithmetic operators</a>. The values are compared after conversions:</p>
<h3 id="Example">Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
int main()
{
    std::cout &lt;&lt; std::boolalpha;
    int n = -1;
 
    int n2 = 1;
    std::cout &lt;&lt; " -1 == 1? " &lt;&lt; (n == n2) &lt;&lt; '\n'
              &lt;&lt; "Comparing two signed values:\n"
              &lt;&lt; " -1  &lt; 1? " &lt;&lt; (n &lt; n2) &lt;&lt; '\n'
              &lt;&lt; " -1  &gt; 1? " &lt;&lt; (n &gt; n2) &lt;&lt; '\n';
 
    unsigned int u = 1;
    std::cout &lt;&lt; "Comparing signed and unsigned:\n"
              &lt;&lt; " -1  &lt; 1? " &lt;&lt; (n &lt; u) &lt;&lt; '\n'
              &lt;&lt; " -1  &gt; 1? " &lt;&lt; (n &gt; u) &lt;&lt; '\n';
 
    unsigned char uc = 1;
    std::cout &lt;&lt; "Comparing signed and smaller unsigned:\n"
              &lt;&lt; " -1  &lt; 1? " &lt;&lt; (n &lt; uc) &lt;&lt; '\n'
              &lt;&lt; " -1  &gt; 1? " &lt;&lt; (n &gt; uc) &lt;&lt; '\n';
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">
 -1 == 1? false
Comparing two signed values:
 -1  &lt; 1? true
 -1  &gt; 1? false
Comparing signed and unsigned:
 -1  &lt; 1? false
 -1  &gt; 1? true
Comparing signed and smaller unsigned:
 -1  &lt; 1? true
 -1  &gt; 1? false</pre></div> </div> <h4 id="Pointer_comparison_operators">Pointer comparison operators</h4> <p>Comparison operators can be used to compare two pointers (or pointers-to-members, for <code>operator==</code> and <code>operator!=</code> only), or a pointer <span class="t-rev-inl t-since-cxx14"><span>to member</span> <span><span class="t-mark-rev t-since-cxx14">(since C++14)</span></span></span> and a null pointer constant<span class="t-rev-inl t-until-cxx14"><span>, or two null pointer constants (but only as long as at least one of them is <code><a href="../types/nullptr_t" title="cpp/types/nullptr t">std::nullptr_t</a></code>: comparison of NULL and NULL follows arithmetic comparison rules)</span> <span><span class="t-mark-rev t-until-cxx14">(until C++14)</span></span></span>.</p>
<p>First, <a href="implicit_cast" title="cpp/language/implicit cast" class="mw-redirect">Pointer conversions</a> (pointer to member conversions if the arguments are pointers to members)<span class="t-rev-inl t-since-cxx17"><span>, function pointer conversions,</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> and <a href="implicit_cast" title="cpp/language/implicit cast" class="mw-redirect">qualification conversions</a> are applied to both operands to obtain the <i>composite pointer type</i>, as follows.</p>
<div class="t-li1">
<span class="t-li">1)</span> If both operands are null pointer constants, the composite pointer type is <code><a href="../types/nullptr_t" title="cpp/types/nullptr t">std::nullptr_t</a></code>
</div> <div class="t-li1">
<span class="t-li">2)</span> If one operand is a null pointer constant, and the other is a pointer, the composite type is exactly the pointer type</div> <div class="t-li1">
<span class="t-li">3)</span> If one operand is pointer to <i>cv1</i> <code>void</code> and the other is a pointer to <i>cv2</i> <code>T</code> for some type <code>T</code>, where <code>T</code> is an object type or <code>void</code>, the composite type is "pointer to <i>cv12</i> <code>void</code>", where <i>cv12</i> is the union of <i>cv1</i> and <i>cv2</i>
</div> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx14">
<td> <span class="t-li">4)</span> If both operands are pointers to the same type, with different cv-qualification, the composite is pointer to the same type with cv-qualification that is a union of the cv-qualifications of the arguments. </td> <td><span class="t-mark-rev t-until-cxx14">(until C++14)</span></td>
</tr> <tr class="t-rev t-since-cxx14">
<td> <span class="t-li">4)</span> If the types of the operands are P1, a pointer to (possibly cv-qualified) T1, and P2, a pointer to (possibly cv-qualified) T2, and if T1 is the same as T2 or is a base class of T2, then the composite pointer type is the <i>cv-combined</i> type of P1 and P2. Otherwise, if T2 is a base class of T1, then the composite pointer type is the <i>cv-combined</i> type of P2 and P1. <span class="t-li">5)</span> If the types of the operands are MP1, pointer to member of T1 of type (possibly cv-qualified) U1 and MP2, pointer to member of T2 of type (possibly cv-qualified) U2, and if T1 is the same as or derived from T2, then the composite pointer type is the <i>cv-combined</i> type of MP1 and MP2. Otherwise, if T2 is derived from T1, then the composite pointer type is the cv-combined type of MP2 and MP1. <span class="t-li">6)</span> if the types of the operands P1 and P2 are multi-level mixed pointer and pointer to member types with the same number of levels that only differ by cv-qualifications at any of the levels, the composite pointer type is the cv-combined type of P1 and P2 <p>In the definition above, <i>cv-combined</i> type of two pointer types P1 and P2 is a type P3 that has the same number of levels and type at every level as P1, except that cv-qualifications at every level are set as follows:</p>
<span class="t-li">a)</span> at every level other than top level, the union of the cv-qualifications of P1 and P2 at that level <span class="t-li">b)</span> if the resulting cv-qualification at any level is different from P1's or P2's cv-qualification at the same level, then const is added to every level between the top level and this one. <p>For example, the composite pointer type of <code>void*</code> and <code>const int*</code> is <code>const void*</code>. The composite pointer type of <code>int**</code> and <code>const int**</code> is <code>const int* const*</code>. Note that until C++14, <code>int**</code> and <code>const int**</code> could not be compared.</p>
</td> <td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr> <tr class="t-rev t-since-cxx17">
<td> <p>In addition to the above, the composite pointer type between pointer to function and pointer to noexcept function (as long as the function type is the same) is pointer to function.</p>
</td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <p>Note that this implies that any pointer can be compared with <code>void*</code>.</p>
<p>The result of comparing two pointers to objects (after conversions) is defined as follows:</p>
<div class="t-li1">
<span class="t-li">1)</span> If two pointers point to different elements of the same array, or to subobjects within different elements of the same array, the pointer to the element with the higher subscript <i>compares greater</i>. In other words, they results of comparing the pointers is the same as the result of comparing the indexes of the elements they point to.</div> <div class="t-li1">
<span class="t-li">2)</span> If one pointer points to an element of an array, or to a subobject of the element of the array, and another pointer points one past the last element of the array, the latter pointer <i>compares greater</i>. <span class="t-rev-inl t-since-cxx17"><span>Pointers to single objects are treated as pointers to arrays of one: <code>&amp;obj+1</code> compares greater than <code>&amp;obj</code></span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span>
</div> <div class="t-li1">
<span class="t-li">3)</span> If, within an object of non-union class type, two pointers point to different non-static data members with the same <a href="access" title="cpp/language/access">member access</a>, or to subobjects or array elements of such members, recursively, the pointer to the later declared member <i>compares greater</i>. In other words, class members in each of the three member access modes are positioned in memory in order of declaration.</div> <p>The result of equality comparison of two pointers (after conversions) is defined as follows:</p>
<div class="t-li1">
<span class="t-li">1)</span> If the pointers are both null pointer values, they <i>compare equal</i>
</div> <div class="t-li1">
<span class="t-li">2)</span> If the pointers are pointers to function and point to the same function, then <i>compare equal</i>
</div> <div class="t-li1">
<span class="t-li">3)</span> If the pointers are pointers to object and represent the same address, they <i>compare equal</i> (this includes two pointers to non-static members of the same union, pointers to standard-layout struct and to its first member, pointers related by reinterpret_cast, etc)</div> <div class="t-li1">
<span class="t-li">4)</span> All other pointers compare unequal</div> <p>The result of comparing two pointers to members (after conversions) is defined as follows:</p>
<div class="t-li1">
<span class="t-li">1)</span> If both pointers to member are null member pointer values, they <i>compare equal</i>.</div> <div class="t-li1">
<span class="t-li">2)</span> Otherwise, if only one of two pointers to member is the null member pointer value, they compare unequal.</div> <div class="t-li1">
<span class="t-li">3)</span> Otherwise, if either is a pointer to a virtual member function, the result is unspecified.</div> <div class="t-li1">
<span class="t-li">4)</span> Otherwise, two pointers to member compare equal if and only if they would refer to the same member of the same most derived object or the same subobject if they were dereferenced with a hypothetical object of the associated class type</div> <div class="t-li1">
<span class="t-li">5)</span> Otherwise they compare unequal.</div> <p>If a pointer <code>p</code> <i>compare equal</i> to pointer <code>q</code>, <code>p&lt;=q</code> and <code>p&gt;=q</code> both yield <code>true</code> and <code>p&lt;q</code> and <code>p&gt;q</code> both yield <code>false</code>.</p>
<p>If a pointer <code>p</code> <i>compares greater</i> than a pointer <code>q</code>, then <code>p&gt;=q</code>, <code>p&gt;q</code>, <code>q&lt;=p</code>, and <code>q&lt;p</code> all yield <code>true</code> and <code>p&lt;=q</code>, <code>p&lt;q</code>, <code>q&gt;=p</code>, and <code>q&gt;p</code> all yield <code>false</code>.</p>
<p>If two pointers are not specified to compare greater or compare equal, the result of the comparison is unspecified. The result may be nondeterministic, and need not be consistent even for multiple evaluations of the same expression with the same operands in the same execution of the program:</p>
<div class="cpp source-cpp"><pre data-language="cpp">int x, y;
 
bool f(int* p, int* q) { return p &lt; q; }
 
assert(f(&amp;x, &amp;y) == f(&amp;x, &amp;y)); // may fire in a conforming implementation</pre></div> <p>In <a href="overload_resolution#Call_to_an_overloaded_operator" title="cpp/language/overload resolution">overload resolution against user-defined operators</a>, for every pair of promoted arithmetic types <code>L</code> and <code>R</code>, including enumeration types, the following function signatures participate in overload resolution:</p>
<table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">bool operator&lt;(L, R);</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">bool operator&gt;(L, R);</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">bool operator&lt;=(L, R);</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">bool operator&gt;=(L, R);</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">bool operator==(L, R);</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">bool operator!=(L, R);</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <p>For every type <code>P</code> which is either pointer to object or pointer to function <span class="t-rev-inl t-until-cxx14"><span>or <code><a href="../types/nullptr_t" title="cpp/types/nullptr t">std::nullptr_t</a></code></span> <span><span class="t-mark-rev t-until-cxx14">(until C++14)</span></span></span>, the following function signatures participate in overload resolution:</p>
<table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">bool operator&lt;(P, P);</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">bool operator&gt;(P, P);</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">bool operator&lt;=(P, P);</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">bool operator&gt;=(P, P);</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">bool operator==(P, P);</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">bool operator!=(P, P);</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <p>For every type <code>MP</code> that is a pointer to member object or pointer to member function or <code><a href="../types/nullptr_t" title="cpp/types/nullptr t">std::nullptr_t</a></code>, the following function signatures participate in overload resolution:</p>
<table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">bool operator==(MP, MP);</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">bool operator!=(MP, MP);</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <h3 id="Example_2">Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
struct Foo  { int n1; int n2; };
union Union { int n; double d; };
int main()
{
    std::cout &lt;&lt; std::boolalpha;
 
    char a[4] = "abc";
 
    char* p1 = &amp;a[1];
    char* p2 = &amp;a[2];
    std::cout &lt;&lt; "Pointers to array elements: p1 == p2 " &lt;&lt; (p1 == p2)
              &lt;&lt; ", p1 &lt; p2 "  &lt;&lt; (p1 &lt; p2) &lt;&lt; '\n';
 
    Foo f;
    int* p3 = &amp;f.n1;
    int* p4 = &amp;f.n2;
    std::cout &lt;&lt; "Pointers to members of a class: p3 == p4 " &lt;&lt; (p3 == p4)
              &lt;&lt; ", p3 &lt; p4 "  &lt;&lt; (p3 &lt; p4) &lt;&lt; '\n';
 
    Union u;
    int* p5 = &amp;u.n;
    double* p6 = &amp;u.d;
    std::cout &lt;&lt; "Pointers to members of a union: p5 == (void*)p6 " &lt;&lt; (p5 == (void*)p6)
              &lt;&lt; ", p5 &lt; p6 "  &lt;&lt; (p5 &lt; (void*)p6) &lt;&lt; '\n';
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">Pointers to array elements: p1 == p2 false, p1 &lt; p2 true
Pointers to members of a class: p3 == p4 false, p3 &lt; p4 true
Pointers to members of a union: p5 == (void*)p6 true, p5 &lt; p6 false</pre></div> </div> <h3 id="Notes">Notes</h3> <p>Because these operators group left-to-right, the expression <code>a&lt;b&lt;c</code> is parsed <code>(a&lt;b)&lt;c</code>, and not <code>a&lt;(b&lt;c)</code> or <code>(a&lt;b)&amp;&amp;(b&lt;c)</code>.</p>
<p>A common requirement for <a href="operators#Relational_operators" title="cpp/language/operators">user-defined operator&lt;</a> is <a href="https://en.wikipedia.org/wiki/Strict_weak_ordering" class="extiw" title="enwiki:Strict weak ordering">strict weak ordering</a>. In particular, this is required by the standard algorithms and containers that work with <a href="../named_req/compare" title="cpp/named req/Compare">Compare</a> types: <code><a href="../algorithm/sort" title="cpp/algorithm/sort">std::sort</a></code>, <code><a href="../algorithm/max_element" title="cpp/algorithm/max element">std::max_element</a></code>, <code><a href="../container/map" title="cpp/container/map">std::map</a></code>, etc.</p>
<p>Although the results of comparing pointers of random origin (e.g. not all pointing to members of the same array) is unspecified, many implementations provide <a href="https://en.wikipedia.org/wiki/Total_order#Strict_total_order" class="extiw" title="enwiki:Total order">strict total ordering</a> of pointers, e.g. if they are implemented as addresses within continuous virtual address space. Those implementations that do not (e.g. where not all bits of the pointer are part of a memory address and have to be ignored for comparison, or an additional calculation is required or otherwise pointer and integer is not a 1 to 1 relationship), provide a specialization of <code><a href="../utility/functional/less" title="cpp/utility/functional/less">std::less</a></code> for pointers that has that guarantee. This makes it possible to use all pointers of random origin as keys in standard associative containers such as <code><a href="../container/set" title="cpp/container/set">std::set</a></code> or <code><a href="../container/map" title="cpp/container/map">std::map</a></code>.</p>
<p>For the types that are both <a href="../named_req/equalitycomparable" title="cpp/named req/EqualityComparable">EqualityComparable</a> and <a href="../named_req/lessthancomparable" title="cpp/named req/LessThanComparable">LessThanComparable</a>, the C++ standard library makes a distinction between <i>equality</i>, which is the value of the expression <code>a == b</code> and <i>equivalence</i>, which is the value of the expression <code>!(a &lt; b) &amp;&amp; !(b &lt; a)</code>.</p>
<p>Comparison between pointers and null pointer constants was removed in C++14.</p>
<div class="cpp source-cpp"><pre data-language="cpp">void f(char * p)
{
  if (p &gt; 0) { ... } // OK in C++98..C++11, does not compile in C++14
  if (p &gt; nullptr) { ... } // OK in C++11, does not compile in C++14
}</pre></div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <h3 id="Three-way_comparison"> Three-way comparison</h3> <p>The three-way comparison operator expressions have the form.</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">lhs</span> <code>&lt;=&gt;</code> <span class="t-spar">rhs</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <p>The expression returns an object such that.</p>
<ul>
<li> <code>(a &lt;=&gt; b) &lt; 0</code> if <code>lhs &lt; rhs</code> </li>
<li> <code>(a &lt;=&gt; b) &gt; 0</code> if <code>lhs &gt; rhs</code> </li>
<li> <code>(a &lt;=&gt; b) == 0</code> if <code>lhs</code> and <code>rhs</code> are equal/equivalent. </li>
</ul> <p>If one of the operands is of type <code>bool</code> and the other is not, the program is ill-formed.</p>
<p>If both operands have arithmetic types, or if one operand has unscoped enumeration type and the other has integral type, the usual arithmetic conversions are applied to the operands, and then.</p>
<ul>
<li> If a narrowing conversion is required, other than from an integral type to a floating point type, the program is ill-formed. </li>
<li> Otherwise, if the operands have integral type, the operator yields a prvalue of type <a href="../utility/compare/strong_ordering" title="cpp/utility/compare/strong ordering"><code>std::strong_ordering</code></a>: </li>
<ul>
<li> <code>std::strong_ordering::equal</code> if both operands are arithmetically equal, </li>
<li> <code>std::strong_ordering::less</code> if the first operand is arithmetically less than the second </li>
<li> <code>std::strong_ordering::greater</code> otherwise. </li>
</ul>
<li> Otherwise, the operands have floating-point type, and the operator yields a prvalue of type <a href="../utility/compare/partial_ordering" title="cpp/utility/compare/partial ordering"><code>std::partial_ordering</code></a>. The expression <code>a &lt;=&gt; b</code> yields </li>
<ul>
<li> <code>std::partial_ordering::less</code> if <code>a</code> is less than <code>b</code> </li>
<li> <code>std::partial_ordering::greater</code> if <code>a</code> is greater than <code>b</code> </li>
<li> <code>std::partial_ordering::equivalent</code> if <code>a</code> is equivalent to <code>b</code> (<code>-0 &lt;=&gt; +0</code> is equivalent) </li>
<li> <code>std::partial_ordering::unordered</code> (<code>NaN &lt;=&gt; anything</code> is unordered) </li>
</ul>
</ul>    <p>If both operands have the same enumeration type E, the operator yields the result of converting the operands to the underlying type of E and applying <code>&lt;=&gt;</code> to the converted operands.</p>
<p>If at least one of the operands is a pointer or pointer-to-member, array-to-pointer conversions, derived-to-base pointer conversions, function pointer conversions, and qualification conversions are applied as necessary to convert both operands to the same pointer type.</p>
<p>If the resulting pointer type is a function pointer, a pointer to member, or <code><a href="../types/nullptr_t" title="cpp/types/nullptr t">std::nullptr_t</a></code>, <code>p &lt;=&gt; q</code> returns a prvalue of type <a href="../utility/compare/strong_equality" title="cpp/utility/compare/strong equality"><code>std::strong_equality</code></a>:</p>
<ul>
<li> <code>std::strong_equality::equal</code> if <code>p == q</code> </li>
<li> <code>std::strong_equality::unequal</code> if <code>p != q</code> </li>
<li> unspecified result if the equality comparison is unspecified for these pointer values </li>
</ul> <p>If the resulting pointer type is an object pointer type, <code>p &lt;=&gt; q</code> returns a prvalue of type <a href="../utility/compare/strong_ordering" title="cpp/utility/compare/strong ordering"><code>strong_ordering</code></a>:</p>
<ul>
<li> <code>std::strong_ordering::equal</code> if <code>p == q</code> </li>
<li> <code>std::strong_ordering::less</code> if <code>q &gt; p</code> </li>
<li> <code>std::strong_ordering::greater</code> if <code>p &gt; q</code>. </li>
<li> unspecified result if comparison is unspecified for these pointer values (such as when they do not point into the same object or array) </li>
</ul> <p>In <a href="overload_resolution#Call_to_an_overloaded_operator" title="cpp/language/overload resolution">overload resolution against user-defined operators</a>, for pointer or enumeration type <code>T</code>, the following function signature participates in overload resolution:</p>
<table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">R operator&lt;=&gt;(T, T);</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <p>Where R is the ordering category type defined above.</p>
<p>For every T that is a pointer-to-member type or the type <code><a href="../types/nullptr_t" title="cpp/types/nullptr t">std::nullptr_t</a></code>, the following function signature participates in overload resolution:</p>
<table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">std::strong_equality operator&lt;=&gt;(T, T);</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <h3 id="Notes_2"> Notes</h3> <p>Three-way comparison can be automatically generated for class types, see <a href="default_comparisons" title="cpp/language/default comparisons">default comparisons</a>.</p>
<p>If both of the operands are arrays, three-way comparison is ill-formed except when comparing class members of array type.</p>
<div class="cpp source-cpp"><pre data-language="cpp">unsigned int i = 1;
auto r = -1 &lt; i; // existing pitfall: returns ‘false’
auto r2 = -1 &lt;=&gt; i; // Error: narrowing conversion required</pre></div> </td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <h3 id="Standard_library">Standard library</h3> <p>Comparison operators are overloaded for many classes in the standard library.</p>
<table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../types/type_info/operator_cmp" title="cpp/types/type info/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span></span></a></div> </td> <td> checks whether the objects refer to the same type <br> <span class="t-mark">(public member function of <code>std::type_info</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../error/error_code/operator_cmp" title="cpp/error/error code/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span></span></a></div> </td> <td> compares two <code>error_code</code>s <br> <span class="t-mark">(function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../error/error_condition/operator_cmp" title="cpp/error/error condition/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span></span></a></div> </td> <td> compares error_conditions and error_codes <br> <span class="t-mark">(function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/pair/operator_cmp" title="cpp/utility/pair/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span></span></a></div> </td> <td> lexicographically compares the values in the pair <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/tuple/operator_cmp" title="cpp/utility/tuple/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span></span></a></div> </td> <td> lexicographically compares the values in the tuple <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/bitset/operator_cmp" title="cpp/utility/bitset/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span></span></a></div> </td> <td> compares the contents <br> <span class="t-mark">(public member function of <code>std::bitset&lt;N&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/allocator/operator_cmp" title="cpp/memory/allocator/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span></span></a></div> </td> <td> compares two allocator instances <br> <span class="t-mark">(public member function of <code>std::allocator&lt;T&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/unique_ptr/operator_cmp" title="cpp/memory/unique ptr/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span></span></a></div> </td> <td> compares to another <code>unique_ptr</code> or with <code>nullptr</code> <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/shared_ptr/operator_cmp" title="cpp/memory/shared ptr/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span></span></a></div> </td> <td> compares with another <code>shared_ptr</code> or with <code>nullptr</code> <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/functional/function/operator_cmp" title="cpp/utility/functional/function/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span></span></a></div> </td> <td> compares a <code><a href="../utility/functional/function" title="cpp/utility/functional/function">std::function</a></code> with <code>nullptr</code> <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../chrono/duration/operator_cmp" title="cpp/chrono/duration/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span></span></a></div> </td> <td> compares two durations <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../chrono/time_point/operator_cmp" title="cpp/chrono/time point/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span></span></a></div> </td> <td> compares two time points <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/scoped_allocator_adaptor/operator_cmp" title="cpp/memory/scoped allocator adaptor/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span></span></a></div> </td> <td> compares two scoped_allocator_adaptor instances <br> <span class="t-mark">(public member function of <code>std::scoped_allocator_adaptor&lt;OuterAlloc,InnerAlloc...&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../types/type_index/operator_cmp" title="cpp/types/type index/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span></span></a></div> </td> <td> compares the underlying <code><a href="../types/type_info" title="cpp/types/type info">std::type_info</a></code> objects <br> <span class="t-mark">(public member function of <code>std::type_index</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../string/basic_string/operator_cmp" title="cpp/string/basic string/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&gt;</span><span>operator&lt;=</span><span>operator&gt;=</span></span></a></div> </td> <td> lexicographically compares two strings <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../locale/locale/operator_cmp" title="cpp/locale/locale/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span></span></a></div> </td> <td> equality comparison between locale objects <br> <span class="t-mark">(public member function of <code>std::locale</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/array/operator_cmp" title="cpp/container/array/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span></span></a></div> </td> <td> lexicographically compares the values in the array <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/deque/operator_cmp" title="cpp/container/deque/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span></span></a></div> </td> <td> lexicographically compares the values in the deque <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/forward_list/operator_cmp" title="cpp/container/forward list/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span></span></a></div> </td> <td> lexicographically compares the values in the forward_list <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/list/operator_cmp" title="cpp/container/list/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span></span></a></div> </td> <td> lexicographically compares the values in the list <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/vector/operator_cmp" title="cpp/container/vector/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span></span></a></div> </td> <td> lexicographically compares the values in the vector <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/map/operator_cmp" title="cpp/container/map/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span></span></a></div> </td> <td> lexicographically compares the values in the map <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/multimap/operator_cmp" title="cpp/container/multimap/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span></span></a></div> </td> <td> lexicographically compares the values in the multimap <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/set/operator_cmp" title="cpp/container/set/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span></span></a></div> </td> <td> lexicographically compares the values in the set <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/multiset/operator_cmp" title="cpp/container/multiset/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span></span></a></div> </td> <td> lexicographically compares the values in the multiset <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/unordered_map/operator_cmp" title="cpp/container/unordered map/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span></span></a></div> </td> <td> compares the values in the unordered_map <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/unordered_multimap/operator_cmp" title="cpp/container/unordered multimap/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span></span></a></div> </td> <td> compares the values in the unordered_multimap <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/unordered_set/operator_cmp" title="cpp/container/unordered set/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span></span></a></div> </td> <td> compares the values in the unordered_set <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/unordered_multiset/operator_cmp" title="cpp/container/unordered multiset/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span></span></a></div> </td> <td> compares the values in the unordered_multiset <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/queue/operator_cmp" title="cpp/container/queue/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span></span></a></div> </td> <td> lexicographically compares the values in the queue <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/stack/operator_cmp" title="cpp/container/stack/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span></span></a></div> </td> <td> lexicographically compares the values in the stack <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/reverse_iterator/operator_cmp" title="cpp/iterator/reverse iterator/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span></span></a></div> </td> <td> compares the underlying iterators <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/move_iterator/operator_cmp" title="cpp/iterator/move iterator/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span></span></a></div> </td> <td> compares the underlying iterators <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/istream_iterator/operator_cmp" title="cpp/iterator/istream iterator/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span></span></a></div> </td> <td> compares two <code>istream_iterator</code>s <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/istreambuf_iterator/operator_cmp" title="cpp/iterator/istreambuf iterator/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span></span></a></div> </td> <td> compares two <code>istreambuf_iterator</code>s <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../numeric/complex/operator_cmp" title="cpp/numeric/complex/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span></span></a></div> </td> <td> compares two complex numbers or a complex and a scalar <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../numeric/valarray/operator_cmp" title="cpp/numeric/valarray/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span></span></a></div> </td> <td> compares two valarrays or a valarray with a value <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../numeric/random/linear_congruential_engine/operator_cmp" title="cpp/numeric/random/linear congruential engine/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span></span></a></div> </td> <td> compares the internal states of two pseudo-random number engines <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../numeric/random/poisson_distribution/operator_cmp" title="cpp/numeric/random/poisson distribution/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span></span></a></div> </td> <td> compares two distribution objects <br> <span class="t-mark">(function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../regex/sub_match/operator_cmp" title="cpp/regex/sub match/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span></span></a></div> </td> <td> compares two <code>sub_match</code> objects <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../regex/match_results/operator_cmp" title="cpp/regex/match results/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span></span></a></div> </td> <td> lexicographically compares the values in the two match result <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../regex/regex_iterator/operator_cmp" title="cpp/regex/regex iterator/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span></span></a></div> </td> <td> compares two <code>regex_iterator</code>s <br> <span class="t-mark">(public member function of <code>std::regex_iterator&lt;BidirIt,CharT,Traits&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="http://en.cppreference.com/w/cpp/regex/regex_token_iterator/operator_cmp" title="cpp/regex/regex token iterator/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span></span></a></div> </td> <td> compares two <code>regex_token_iterator</code>s <br> <span class="t-mark">(public member function of <code>std::regex_token_iterator&lt;BidirIt,CharT,Traits&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../thread/thread/id/operator_cmp" title="cpp/thread/thread/id/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt; </span><span> operator&lt;= </span><span> operator&gt; </span><span> operator&gt;=</span></span></a></div> </td> <td> compares two <code>thread::id</code> objects <br> <span class="t-mark">(function)</span> </td>
</tr> </table> <p>The namespace <a href="../utility/rel_ops/operator_cmp" title="cpp/utility/rel ops/operator cmp">rel_ops</a> provides generic operators <code>!=</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code></p>
<table class="t-dsc-begin"> <tr class="t-dsc-header"> <th colspan="2"> Defined in header <code>&lt;utility&gt;</code>  </th>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in namespace <code>std::rel_ops</code>  </th>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/rel_ops/operator_cmp" title="cpp/utility/rel ops/operator cmp"> <span class="t-lines"><span>operator!=</span><span>operator&gt;</span><span>operator&lt;=</span><span>operator&gt;=</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark">(deprecated in C++20)</span></span></span></div> </td> <td> automatically generates comparison operators based on user-defined <code>operator==</code> and <code>operator&lt;</code> <br> <span class="t-mark">(function template)</span> </td>
</tr> </table> <h3 id="See_also">See also</h3> <p><a href="operator_precedence" title="cpp/language/operator precedence"> Operator precedence</a>.</p>
<p><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/cpp/language/operators&amp;action=edit&amp;redlink=1" class="new" title="cpp/language/cpp/language/operators (page does not exist)"> Operator overloading</a>.</p>
<table class="wikitable"> <tr style="text-align:center"> <th colspan="7"> Common operators </th>
</tr> <tr style="text-align:center"> <td> <a href="operator_assignment" title="cpp/language/operator assignment"> assignment</a> </td> <td> <a href="operator_incdec" title="cpp/language/operator incdec"> increment<br>decrement</a> </td> <td> <a href="operator_arithmetic" title="cpp/language/operator arithmetic"> arithmetic</a> </td> <td> <a href="operator_logical" title="cpp/language/operator logical"> logical</a> </td> <td> <strong class="selflink"> comparison</strong> </td> <td> <a href="operator_member_access" title="cpp/language/operator member access"> member<br>access</a> </td> <td> <a href="operator_other" title="cpp/language/operator other"> other</a> </td>
</tr> <tr style="text-align:center"> <td> <p><code>a = b a += b a -= b a *= b a /= b a %= b a &amp;= b a |= b a ^= b a &lt;&lt;= b a &gt;&gt;= b</code>.</p>
</td> <td> <p><code>++a --a a++ a--</code></p>
</td> <td> <p><code>+a -a a + b a - b a * b a / b a % b ~a a &amp; b a | b a ^ b a &lt;&lt; b a &gt;&gt; b</code>.</p>
</td> <td> <p><code>!a a &amp;&amp; b a || b</code>.</p>
</td> <td> <p><code>a == b a != b a &lt; b a &gt; b a &lt;= b a &gt;= b a &lt;=&gt; b</code>.</p>
</td> <td> <p><code>a[b] *a &amp;a a-&gt;b a.b a-&gt;*b a.*b</code>.</p>
</td> <td> <p><code>a(...) a, b ? :</code></p>
</td>
</tr> <tr> <th colspan="7"> Special operators </th>
</tr> <tr> <td colspan="7"> <p><a href="static_cast" title="cpp/language/static cast"><code>static_cast</code></a> converts one type to another related type <br> <a href="dynamic_cast" title="cpp/language/dynamic cast"><code>dynamic_cast</code></a> converts within inheritance hierarchies <br> <a href="const_cast" title="cpp/language/const cast"><code>const_cast</code></a> adds or removes <a href="cv" title="cpp/language/cv">cv</a> qualifiers<br> <a href="reinterpret_cast" title="cpp/language/reinterpret cast"><code>reinterpret_cast</code></a> converts type to unrelated type<br> <a href="explicit_cast" title="cpp/language/explicit cast">C-style cast</a> converts one type to another by a mix of <code>static_cast</code>, <code>const_cast</code>, and <code>reinterpret_cast</code> <br> <a href="new" title="cpp/language/new"><code>new</code></a> creates objects with dynamic storage duration<br> <a href="delete" title="cpp/language/delete"><code>delete</code></a> destructs objects previously created by the new expression and releases obtained memory area<br> <a href="sizeof" title="cpp/language/sizeof"><code>sizeof</code></a> queries the size of a type<br> <a href="sizeof..." title="cpp/language/sizeof..."><code>sizeof...</code></a> queries the size of a <a href="parameter_pack" title="cpp/language/parameter pack">parameter pack</a> <span class="t-mark-rev t-since-cxx11">(since C++11)</span><br> <a href="typeid" title="cpp/language/typeid"><code>typeid</code></a> queries the type information of a type<br> <a href="noexcept" title="cpp/language/noexcept"><code>noexcept</code></a> checks if an expression can throw an exception <span class="t-mark-rev t-since-cxx11">(since C++11)</span><br> <a href="alignof" title="cpp/language/alignof"><code>alignof</code></a> queries alignment requirements of a type <span class="t-mark-rev t-since-cxx11">(since C++11)</span>.</p>
</td>
</tr>
</table>           <div class="_attribution">
  <p class="_attribution-p">
    © cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/language/operator_comparison" class="_attribution-link">http://en.cppreference.com/w/cpp/language/operator_comparison</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
