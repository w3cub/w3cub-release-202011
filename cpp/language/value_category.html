
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Value Categories - C++ - W3cubDocs</title>
  
  <meta name="description" content="Each C++ expression (an operator with its operands, a literal, a variable name, etc.) is characterized by two independent properties&#58; a type and &hellip;">
  <meta name="keywords" content="value, categories, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/language/value_category.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-1810d67ab7e57be09d8247710d2feb6954566959eb82322d1fee3a0c9156f56974b78ebaa9928774f00767342bbe58b0799d91fcc336b92b319170b196f9b64b.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/cpp.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _c">
				
				
<h1 id="firstHeading" class="firstHeading">Value categories</h1>            <p>Each C++ <a href="expressions" title="cpp/language/expressions">expression</a> (an operator with its operands, a literal, a variable name, etc.) is characterized by two independent properties: a <i><a href="type" title="cpp/language/type">type</a></i> and a <i>value category</i>. Each expression has some non-reference type, and each expression belongs to exactly one of the three primary value categories: <i>prvalue</i>, <i>xvalue</i>, and <i>lvalue</i>.</p>
<ul>
<li> a glvalue (“generalized” lvalue) is an expression whose evaluation determines the identity of an object or function; </li>
<li> a prvalue (“pure” rvalue) is an expression whose evaluation </li>
<li> computes the value of an operand of a built-in operator (such prvalue has no <i>result object</i>), or </li>
<li> initializes an object (such prvalue is said to have a <i>result object</i>). </li>
</ul>   The result object may be a variable, an object created by <a href="new" title="cpp/language/new">new-expression</a>, a temporary created by <a href="implicit_conversion#Temporary_materialization" title="cpp/language/implicit conversion">temporary materialization</a>, or a member thereof. Note that non-<code>void</code> <a href="expressions#Discarded-value_expressions" title="cpp/language/expressions">discarded</a> expressions have a result object (the materialized temporary). Also, every class and array prvalue has a result object except when it is the operand of <a href="decltype" title="cpp/language/decltype">decltype</a>;   <ul>
<li> an xvalue (an “eXpiring” value) is a glvalue that denotes an object whose resources can be reused; </li>
<li> an lvalue (so-called, historically, because lvalues could appear on the left-hand side of an assignment expression) is a glvalue that is not an xvalue; </li>
<li> an rvalue (so-called, historically, because rvalues could appear on the right-hand side of an assignment expression) is a prvalue or an xvalue. </li>
</ul> <p>Note: this taxonomy went through significant changes with past C++ standard revisions, see <a href="#History">History</a> below for details.</p>
<h3 id="Primary_categories"> Primary categories</h3> <h4 id="lvalue"> lvalue</h4> <p>The following expressions are <i>lvalue expressions</i>:</p>
<ul>
<li> the name of a variable, a function<span class="t-rev-inl t-since-cxx20"><span>, a <a href="template_parameters#Non-type_template_parameter" title="cpp/language/template parameters">template parameter object</a></span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span>, or a data member, regardless of type, such as <code><a href="http://en.cppreference.com/w/cpp/io/cin"><span class="kw1760">std::<span class="me2">cin</span></span></a></code> or <code><a href="http://en.cppreference.com/w/cpp/io/manip/endl"><span class="kw1795">std::<span class="me2">endl</span></span></a></code>. Even if the variable's type is rvalue reference, the expression consisting of its name is an lvalue expression; </li>
<li> a function call or an overloaded operator expression, whose return type is lvalue reference, such as <code><a href="http://en.cppreference.com/w/cpp/string/basic_string/getline"><span class="kw1259">std::<span class="me2">getline</span></span></a><span class="br0">(</span><a href="http://en.cppreference.com/w/cpp/io/cin"><span class="kw1760">std::<span class="me2">cin</span></span></a>, str<span class="br0">)</span></code>, <code><a href="http://en.cppreference.com/w/cpp/io/cout"><span class="kw1762">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="nu0">1</span></code>, <code>str1 = str2</code>, or <code>++it</code>; </li>
<li> <code>a = b</code>, <code>a += b</code>, <code>a %= b</code>, and all other built-in <a href="operator_assignment" title="cpp/language/operator assignment">assignment and compound assignment</a> expressions; </li>
<li> <code>++a</code> and <code>--a</code>, the built-in <a href="operator_incdec#Built-in_prefix_operators" title="cpp/language/operator incdec">pre-increment and pre-decrement</a> expressions; </li>
<li> <code>*p</code>, the built-in <a href="operator_member_access#Built-in_indirection_operator" title="cpp/language/operator member access">indirection</a> expression; </li>
<li> <code>a[n]</code> and <code>p[n]</code>, the built-in <a href="operator_member_access#Built-in_subscript_operator" title="cpp/language/operator member access">subscript</a> expressions<span class="t-rev-inl t-since-cxx11"><span>, where one operand in <code>a[n]</code> is an array lvalue</span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>; </li>
<li> <code>a.m</code>, the <a href="operator_member_access#Built-in_member_access_operators" title="cpp/language/operator member access">member of object</a> expression, except where <code>m</code> is a member enumerator or a non-static member function, or where <code>a</code> is an rvalue and <code>m</code> is a non-static data member of object type; </li>
<li> <code>p-&gt;m</code>, the built-in <a href="operator_member_access#Built-in_member_access_operators" title="cpp/language/operator member access">member of pointer</a> expression, except where <code>m</code> is a member enumerator or a non-static member function; </li>
<li> <code>a.*mp</code>, the <a href="operator_member_access#Built-in_pointer-to-member_access_operators" title="cpp/language/operator member access">pointer to member of object</a> expression, where <code>a</code> is an lvalue and <code>mp</code> is a pointer to data member; </li>
<li> <code>p-&gt;*mp</code>, the built-in <a href="operator_member_access#Built-in_pointer-to-member_access_operators" title="cpp/language/operator member access">pointer to member of pointer</a> expression, where <code>mp</code> is a pointer to data member; </li>
<li> <code>a, b</code>, the built-in <a href="operator_other#Built-in_comma_operator" title="cpp/language/operator other">comma</a> expression, where <code>b</code> is an lvalue; </li>
<li> <code>a ? b : c</code>, the <a href="operator_other#Conditional_operator" title="cpp/language/operator other">ternary conditional</a> expression for certain <code>b</code> and <code>c</code> (e.g., when both are lvalues of the same type, but see <a href="operator_other#Conditional_operator" title="cpp/language/operator other">definition</a> for detail); </li>
<li> a <a href="string_literal" title="cpp/language/string literal">string literal</a>, such as <code>"Hello, world!"</code>; </li>
<li> a cast expression to lvalue reference type, such as <code>static_cast&lt;int&amp;&gt;(x)</code>; </li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul>
<li> a function call or an overloaded operator expression, whose return type is rvalue reference to function; </li>
<li> a cast expression to rvalue reference to function type, such as <code>static_cast&lt;void (&amp;&amp;)(int)&gt;(x)</code>. </li>
</ul> </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <p>Properties:</p>
<ul>
<li> Same as glvalue (below). </li>
<li> Address of an lvalue may be taken by built-in address-of operator: <code>&amp;++i</code><sup id="cite_ref-1" class="reference"><a href="#cite_note-1">[1]</a></sup> and <code><span class="sy3">&amp;</span><a href="http://en.cppreference.com/w/cpp/io/manip/endl"><span class="kw1795">std::<span class="me2">endl</span></span></a></code> are valid expressions. </li>
<li> A modifiable lvalue may be used as the left-hand operand of the built-in assignment and compound assignment operators. </li>
<li> An lvalue may be used to <a href="reference_initialization" title="cpp/language/reference initialization">initialize an lvalue reference</a>; this associates a new name with the object identified by the expression. </li>
</ul> <h4 id="prvalue"> prvalue</h4> <p>The following expressions are <i>prvalue expressions</i>:</p>
<ul>
<li> a <a href="expressions#Literals" title="cpp/language/expressions">literal</a> (except for <a href="string_literal" title="cpp/language/string literal">string literal</a>), such as <code>42</code>, <code>true</code> or <code>nullptr</code>; </li>
<li> a function call or an overloaded operator expression, whose return type is non-reference, such as <code>str.substr(1, 2)</code>, <code>str1 + str2</code>, or <code>it++</code>; </li>
<li> <code>a++</code> and <code>a--</code>, the built-in <a href="operator_incdec#Built-in_postfix_operators" title="cpp/language/operator incdec">post-increment and post-decrement</a> expressions; </li>
<li> <code>a + b</code>, <code>a % b</code>, <code>a &amp; b</code>, <code>a &lt;&lt; b</code>, and all other built-in <a href="operator_arithmetic" title="cpp/language/operator arithmetic">arithmetic</a> expressions; </li>
<li> <code>a &amp;&amp; b</code>, <code>a || b</code>, <code>!a</code>, the built-in <a href="operator_logical" title="cpp/language/operator logical">logical</a> expressions; </li>
<li> <code>a &lt; b</code>, <code>a == b</code>, <code>a &gt;= b</code>, and all other built-in <a href="operator_comparison" title="cpp/language/operator comparison">comparison</a> expressions; </li>
<li> <code>&amp;a</code>, the built-in <a href="operator_member_access#Built-in_address-of_operator" title="cpp/language/operator member access">address-of</a> expression; </li>
<li> <code>a.m</code>, the <a href="operator_member_access#Built-in_member_access_operators" title="cpp/language/operator member access">member of object</a> expression, where <code>m</code> is a member enumerator or a non-static member function<sup id="cite_ref-pmfc_2-0" class="reference"><a href="#cite_note-pmfc-2">[2]</a></sup><span class="t-rev-inl t-until-cxx11"><span>, or where <code>a</code> is an rvalue and <code>m</code> is a non-static data member of non-reference type</span> <span><span class="t-mark-rev t-until-cxx11">(until C++11)</span></span></span>; </li>
<li> <code>p-&gt;m</code>, the built-in <a href="operator_member_access#Built-in_member_access_operators" title="cpp/language/operator member access">member of pointer</a> expression, where <code>m</code> is a member enumerator or a non-static member function<sup id="cite_ref-pmfc_2-1" class="reference"><a href="#cite_note-pmfc-2">[2]</a></sup>; </li>
<li> <code>a.*mp</code>, the <a href="operator_member_access#Built-in_pointer-to-member_access_operators" title="cpp/language/operator member access">pointer to member of object</a> expression, where <code>mp</code> is a pointer to member function<sup id="cite_ref-pmfc_2-2" class="reference"><a href="#cite_note-pmfc-2">[2]</a></sup><span class="t-rev-inl t-until-cxx11"><span>, or where <code>a</code> is an rvalue and <code>mp</code> is a pointer to data member</span> <span><span class="t-mark-rev t-until-cxx11">(until C++11)</span></span></span>; </li>
<li> <code>p-&gt;*mp</code>, the built-in <a href="operator_member_access#Built-in_pointer-to-member_access_operators" title="cpp/language/operator member access">pointer to member of pointer</a> expression, where <code>mp</code> is a pointer to member function<sup id="cite_ref-pmfc_2-3" class="reference"><a href="#cite_note-pmfc-2">[2]</a></sup>; </li>
<li> <code>a, b</code>, the built-in <a href="operator_other#Built-in_comma_operator" title="cpp/language/operator other">comma</a> expression, where <code>b</code> is an rvalue; </li>
<li> <code>a ? b : c</code>, the <a href="operator_other#Conditional_operator" title="cpp/language/operator other">ternary conditional</a> expression for certain <code>b</code> and <code>c</code> (see <a href="operator_other#Conditional_operator" title="cpp/language/operator other">definition</a> for detail); </li>
<li> a cast expression to non-reference type, such as <code>static_cast&lt;double&gt;(x)</code>, <code><a href="http://en.cppreference.com/w/cpp/string/basic_string"><span class="kw1233">std::<span class="me2">string</span></span></a><span class="br0">{</span><span class="br0">}</span></code>, or <code>(int)42</code>; </li>
<li> the <a href="this" title="cpp/language/this"><code>this</code></a> pointer; </li>
<li> an <a href="enum" title="cpp/language/enum">enumerator</a>; </li>
<li> non-type <a href="template_parameters" title="cpp/language/template parameters">template parameter</a> unless its type is <span class="t-rev-inl t-since-cxx20"><span>a class or</span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span> an lvalue reference type; </li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul><li> a <a href="lambda" title="cpp/language/lambda">lambda expression</a>, such as <code>[](int x){ return x * x; }</code>; </li></ul> </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <ul>
<li> a <a href="constraints" title="cpp/language/constraints">requires-expression</a>, such as <code>requires (T i) { typename T::type; }</code>; </li>
<li> a specialization of a <a href="constraints" title="cpp/language/constraints">concept</a>, such as <code><a href="http://en.cppreference.com/w/cpp/concepts/equality_comparable"><span class="kw2953">std::<span class="me2">equality_comparable</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span></code>. </li>
</ul> </td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <p>Properties:</p>
<ul>
<li> Same as rvalue (below). </li>
<li> A prvalue cannot be <a href="object#Polymorphic_objects" title="cpp/language/object">polymorphic</a>: the <a href="type#Dynamic_type" title="cpp/language/type">dynamic type</a> of the object it denotes is always the type of the expression. </li>
<li> A non-class non-array prvalue cannot be <a href="cv" title="cpp/language/cv">cv-qualified</a><span class="t-rev-inl t-since-cxx17"><span>, unless it is <a href="implicit_conversion#Temporary_materialization" title="cpp/language/implicit conversion">materialized</a> in order to be <a href="reference_initialization" title="cpp/language/reference initialization">bound to a reference</a> to a cv-qualified type</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span>. (Note: a function call or cast expression may result in a prvalue of non-class cv-qualified type, but the cv-qualifier is generally immediately stripped out.) </li>
<li> A prvalue cannot have <a href="type#Incomplete_type" title="cpp/language/type">incomplete type</a> (except for type <code>void</code>, see below, or when used in <a href="decltype" title="cpp/language/decltype"><code>decltype</code> specifier</a>) </li>
<li> A prvalue cannot have <a href="abstract_class" title="cpp/language/abstract class">abstract class type</a> or an array thereof. </li>
</ul> <h4 id="xvalue"> xvalue</h4> <p>The following expressions are <i>xvalue expressions</i>:</p>
<ul>
<li> a function call or an overloaded operator expression, whose return type is rvalue reference to object, such as <code>std::move(x)</code>; </li>
<li> <code>a[n]</code>, the built-in <a href="operator_member_access#Built-in_subscript_operator" title="cpp/language/operator member access">subscript</a> expression, where one operand is an array rvalue; </li>
<li> <code>a.m</code>, the <a href="operator_member_access#Built-in_member_access_operators" title="cpp/language/operator member access">member of object</a> expression, where <code>a</code> is an rvalue and <code>m</code> is a non-static data member of non-reference type; </li>
<li> <code>a.*mp</code>, the <a href="operator_member_access#Built-in_pointer-to-member_access_operators" title="cpp/language/operator member access">pointer to member of object</a> expression, where <code>a</code> is an rvalue and <code>mp</code> is a pointer to data member; </li>
<li> <code>a ? b : c</code>, the <a href="operator_other#Conditional_operator" title="cpp/language/operator other">ternary conditional</a> expression for certain <code>b</code> and <code>c</code> (see <a href="operator_other#Conditional_operator" title="cpp/language/operator other">definition</a> for detail); </li>
<li> a cast expression to rvalue reference to object type, such as <code>static_cast&lt;char&amp;&amp;&gt;(x)</code>; </li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <ul><li> any expression that designates a temporary object, after <a href="implicit_conversion#Temporary_materialization" title="cpp/language/implicit conversion">temporary materialization</a>. </li></ul> </td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <p>Properties:</p>
<ul>
<li> Same as rvalue (below). </li>
<li> Same as glvalue (below). </li>
</ul> <p>In particular, like all rvalues, xvalues bind to rvalue references, and like all glvalues, xvalues may be <a href="object#Polymorphic_objects" title="cpp/language/object">polymorphic</a>, and non-class xvalues may be <a href="cv" title="cpp/language/cv">cv-qualified</a>.</p>
<h3 id="Mixed_categories"> Mixed categories</h3> <h4 id="glvalue"> glvalue</h4> <p>A <i>glvalue expression</i> is either lvalue or xvalue.</p>
<p>Properties:</p>
<ul>
<li> A glvalue may be implicitly converted to a prvalue with lvalue-to-rvalue, array-to-pointer, or function-to-pointer <a href="implicit_conversion" title="cpp/language/implicit conversion">implicit conversion</a>. </li>
<li> A glvalue may be <a href="object#Polymorphic_objects" title="cpp/language/object">polymorphic</a>: the <a href="type#Dynamic_type" title="cpp/language/type">dynamic type</a> of the object it identifies is not necessarily the static type of the expression. </li>
<li> A glvalue can have <a href="type#Incomplete_type" title="cpp/language/type">incomplete type</a>, where permitted by the expression. </li>
</ul> <h4 id="rvalue"> rvalue</h4> <p>An <i>rvalue expression</i> is either prvalue or xvalue.</p>
<p>Properties:</p>
<ul>
<li> Address of an rvalue cannot be taken by built-in address-of operator: <code>&amp;int()</code>, <code>&amp;i++</code><sup id="cite_ref-3" class="reference"><a href="#cite_note-3">[3]</a></sup>, <code>&amp;42</code>, and <code>&amp;std::move(x)</code> are invalid. </li>
<li> An rvalue can't be used as the left-hand operand of the built-in assignment or compound assignment operators. </li>
<li> An rvalue may be used to <a href="reference_initialization" title="cpp/language/reference initialization">initialize a const lvalue reference</a>, in which case the lifetime of the object identified by the rvalue is <a href="reference_initialization#Lifetime_of_a_temporary" title="cpp/language/reference initialization">extended</a> until the scope of the reference ends. </li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul>
<li> An rvalue may be used to <a href="reference_initialization" title="cpp/language/reference initialization">initialize an rvalue reference</a>, in which case the lifetime of the object identified by the rvalue is <a href="reference_initialization#Lifetime_of_a_temporary" title="cpp/language/reference initialization">extended</a> until the scope of the reference ends. </li>
<li> When used as a function argument and when <a href="overload_resolution" title="cpp/language/overload resolution">two overloads</a> of the function are available, one taking rvalue reference parameter and the other taking lvalue reference to const parameter, an rvalue binds to the rvalue reference overload (thus, if both copy and move constructors are available, an rvalue argument invokes the <a href="move_constructor" title="cpp/language/move constructor">move constructor</a>, and likewise with copy and move assignment operators). </li>
</ul> </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <h3 id="Special_categories"> Special categories</h3> <h4 id="Pending_member_function_call"> Pending member function call</h4> <p>The expressions <code>a.mf</code> and <code>p-&gt;mf</code>, where <code>mf</code> is a <a href="member_functions" title="cpp/language/member functions">non-static member function</a>, and the expressions <code>a.*pmf</code> and <code>p-&gt;*pmf</code>, where <code>pmf</code> is a <a href="pointer#Pointers_to_member_functions" title="cpp/language/pointer">pointer to member function</a>, are classified as prvalue expressions, but they cannot be used to initialize references, as function arguments, or for any purpose at all, except as the left-hand argument of the function call operator, e.g. <code>(p-&gt;*pmf)(args)</code>.</p>
<h4 id="Void_expressions"> Void expressions</h4> <p>Function call expressions returning <code>void</code>, cast expressions to <code>void</code>, and <a href="throw" title="cpp/language/throw">throw-expressions</a> are classified as prvalue expressions, but they cannot be used to initialize references or as function arguments. They can be used in discarded-value contexts (e.g. on a line of its own, as the left-hand operand of the comma operator, etc.) and in the <code>return</code> statement in a function returning <code>void</code>. In addition, throw-expressions may be used as the second and the third operands of the <a href="operator_other" title="cpp/language/operator other">conditional operator ?:</a>.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <p>Void expressions have no <i>result object</i>.</p>
</td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <h4 id="Bit_fields"> Bit fields</h4> <p>An expression that designates a <a href="bit_field" title="cpp/language/bit field">bit field</a> (e.g. <code>a.m</code>, where <code>a</code> is an lvalue of type <code>struct A { int m: 3; }</code>) is a glvalue expression: it may be used as the left-hand operand of the assignment operator, but its address cannot be taken and a non-const lvalue reference cannot be bound to it. A const lvalue reference or rvalue reference can be initialized from a bit-field glvalue, but a temporary copy of the bit-field will be made: it won't bind to the bit field directly.</p>
<h3 id="History"> History</h3> <h4 id="CPL"> CPL</h4> <p>The programming language <a href="https://en.wikipedia.org/wiki/CPL_(programming_language)" class="extiw" title="enwiki:CPL (programming language)">CPL</a> was first to introduce value categories for expressions: all CPL expressions can be evaluated in "right-hand mode", but only certain kinds of expression are meaningful in "left-hand mode". When evaluated in right-hand mode, an expression is regarded as being a rule for the computation of a value (the right-hand value, or <i>rvalue</i>). When evaluated in left-hand mode an expression effectively gives an address (the left-hand value, or <i>lvalue</i>). "Left" and "Right" here stood for "left of assignment" and "right of assignment".</p>
<h4 id="C"> C</h4> <p>The C programming language followed a similar taxonomy, except that the role of assignment was no longer significant: C expressions are categorized between "lvalue expressions" and others (functions and non-object values), where "lvalue" means an expression that identifies an object, a "locator value"<sup id="cite_ref-4" class="reference"><a href="#cite_note-4">[4]</a></sup>.</p>
<h4 id="C.2B.2B98"> C++98</h4> <p>Pre-2011 C++ followed the C model, but restored the name "rvalue" to non-lvalue expressions, made functions into lvalues, and added the rule that references can bind to lvalues, but only references to const can bind to rvalues. Several non-lvalue C expressions became lvalue expressions in C++.</p>
<h4 id="C.2B.2B11"> C++11</h4> <p>With the introduction of move semantics in C++11, value categories were redefined to characterize two independent properties of expressions<sup id="cite_ref-5" class="reference"><a href="#cite_note-5">[5]</a></sup>:</p>
<ul>
<li> <i>has identity</i>: it's possible to determine whether the expression refers to the same entity as another expression, such as by comparing addresses of the objects or the functions they identify (obtained directly or indirectly); </li>
<li> <i>can be moved from</i>: <a href="move_constructor" title="cpp/language/move constructor">move constructor</a>, <a href="move_assignment" title="cpp/language/move assignment">move assignment operator</a>, or another function overload that implements move semantics can bind to the expression. </li>
</ul> <p>In C++11, expressions that:</p>
<ul>
<li> have identity and cannot be moved from are called <i>lvalue</i> expressions; </li>
<li> have identity and can be moved from are called <i>xvalue</i> expressions; </li>
<li> do not have identity and can be moved from are called <i>prvalue</i> ("pure rvalue") expressions; </li>
<li> do not have identity and cannot be moved from are not used<sup id="cite_ref-6" class="reference"><a href="#cite_note-6">[6]</a></sup>. </li>
</ul> <p>The expressions that have identity are called "glvalue expressions" (glvalue stands for "generalized lvalue"). Both lvalues and xvalues are glvalue expressions.</p>
<p>The expressions that can be moved from are called "rvalue expressions". Both prvalues and xvalues are rvalue expressions.</p>
<h4 id="C.2B.2B17"> C++17</h4> <p>In C++17, <a href="copy_elision" title="cpp/language/copy elision">copy elision</a> was made mandatory in some situations, and that required separation of prvalue expressions from the temporary objects initialized by them, resulting in the system we have today. Note that, in contrast with the C++11 scheme, prvalues are no longer moved from.</p>
<h3 id="Footnotes"> Footnotes</h3> <ol class="references"> <li id="cite_note-1"> <span class="reference-text">Assuming <code>i</code> has built-in type or the pre-increment operator is <a href="operators" title="cpp/language/operators">overloaded</a> to return by lvalue reference.</span> </li> <li id="cite_note-pmfc-2"> <span class="reference-text">Special rvalue category, see <a href="#Pending_member_function_call">pending member function call</a>.</span> </li> <li id="cite_note-3"> <span class="reference-text">Assuming <code>i</code> has built-in type or the postincrement operator is not <a href="operators" title="cpp/language/operators">overloaded</a> to return by lvalue reference.</span> </li> <li id="cite_note-4"> <span class="reference-text">"A difference of opinion within the C community centered around the meaning of lvalue, one group considering an lvalue to be any kind of object locator, another group holding that an lvalue is meaningful on the left side of an assigning operator. The C89 Committee adopted the definition of lvalue as an object locator." -- ANSI C Rationale, 6.3.2.1/10.</span> </li> <li id="cite_note-5"> <span class="reference-text"><a rel="nofollow" class="external text" href="http://www.stroustrup.com/terminology.pdf">"New" Value Terminology</a> by Bjarne Stroustrup, 2010.</span> </li> <li id="cite_note-6"> <span class="reference-text">const prvalues (only allowed for class types) and const xvalues do not bind to T&amp;&amp; overloads, but they bind to the const T&amp;&amp; overloads, which are also classified as "move constructor" and "move assignment operator" by the standard, satisfying the definition of "can be moved from" for the purpose of this classification. However, such overloads cannot modify their arguments and are not used in practice; in their absence const prvalues and const xvalues bind to const T&amp; overloads.</span> </li> </ol> <h3 id="Defect_reports"> Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th> DR </th> <th> Applied to </th> <th> Behavior as published </th> <th> Correct behavior </th>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/616.html">CWG 616</a> </td> <td> C++11 </td> <td> member access and member access through<br>pointer to member of an rvalue resulted in prvalue </td> <td> reclassified as xvalue </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1059.html">CWG 1059</a> </td> <td> C++11 </td> <td> array prvalues could not be cv-qualified </td> <td> allowed </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1213.html">CWG 1213</a> </td> <td> C++11 </td> <td> subscripting an array rvalue resulted in lvalue </td> <td> reclassified as xvalue </td>
</tr>
</table> <h3 id="See_also"> See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td colspan="2"> <span><a href="https://en.cppreference.com/w/c/language/value_category" title="c/language/value category">C documentation</a></span> for <span class=""><span>value categories</span></span> </td>
</tr> </table> <h3 id="External_links">  External links </h3> <ul><li> David Mazières, 2021 - <a rel="nofollow" class="external text" href="https://www.scs.stanford.edu/~dm/blog/decltype.html">C++ value categories and decltype demystified</a> </li></ul>           <div class="_attribution">
  <p class="_attribution-p">
    © cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/language/value_category" class="_attribution-link">https://en.cppreference.com/w/cpp/language/value_category</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
