
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Type - C++ - W3cubDocs</title>
  
  <meta name="description" content="Objects, references, functions including function template specializations, and expressions have a property called type, which both restricts the &hellip;">
  <meta name="keywords" content="type, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/language/type.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-9c7b0d969c0ce639a6c01c2badcdd81667c7c66206aa3d0fccc5cb0585fb1b912dab72ea882101d18010680927514b4b77b107282db8f756fbf63301fe9c88b0.css">
  <script type="text/javascript" src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js"></script>
  <script src="/json/cpp.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _cppref">
				
				
<h1 id="firstHeading" class="firstHeading">Type</h1>            <p><a href="object" title="cpp/language/object">Objects</a>, <a href="reference" title="cpp/language/reference">references</a>, <a href="functions" title="cpp/language/functions">functions</a> including <a href="template_specialization" title="cpp/language/template specialization">function template specializations</a>, and <a href="expressions" title="cpp/language/expressions">expressions</a> have a property called <i>type</i>, which both restricts the operations that are permitted for those entities and provides semantic meaning to the otherwise generic sequences of bits.</p>
<h3 id="Type_classification"> Type classification</h3> <p>The C++ type system consists of the following types:</p>
<ul>
<li> <a href="types" title="cpp/language/types">fundamental types</a> (see also <code><a href="../types/is_fundamental" title="cpp/types/is fundamental">std::is_fundamental</a></code>): </li>
<ul><li> the type <span class="kw4">void</span> (see also <code><a href="../types/is_void" title="cpp/types/is void">std::is_void</a></code>); </li></ul>
</ul>  <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul><li> the type <code><a href="../types/nullptr_t" title="cpp/types/nullptr t">std::nullptr_t</a></code> (see also <code><a href="../types/is_null_pointer" title="cpp/types/is null pointer">std::is_null_pointer</a></code>); </li></ul> </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <ul>
<li> arithmetic types (see also <code><a href="../types/is_arithmetic" title="cpp/types/is arithmetic">std::is_arithmetic</a></code>): </li>
<li> integral types / integer types (including <a href="cv" title="cpp/language/cv">cv-qualified versions</a>, see also <code><a href="../types/is_integral" title="cpp/types/is integral">std::is_integral</a></code>): </li>
<li> the type <span class="kw4">bool</span>; </li>
<li> character types: </li>
<li> narrow character types: </li>
<ul><li> ordinary character types: <span class="kw4">char</span>, <span class="kw4">signed</span> <span class="kw4">char</span>, <span class="kw4">unsigned</span> <span class="kw4">char</span><sup id="cite_ref-1" class="reference"><a href="#cite_note-1">[1]</a></sup> </li></ul>
</ul>         <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <ul><li> the type char8_t </li></ul>     </td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <ul>
<li> wide character types: <span class="t-rev-inl t-since-cxx11"><span><code>char16_t</code>, <code>char32_t</code>, </span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span><span class="kw4">wchar_t</span>; </li>
<li> signed integer types: </li>
<ul><li> standard signed integer types: <span class="kw4">signed</span> <span class="kw4">char</span>, <span class="kw4">short</span>, <span class="kw4">int</span>, <span class="kw4">long</span>, <span class="kw4">long</span> <span class="kw4">long</span>; </li></ul>
</ul>      <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul><li> extended signed integer types (implementation-defined); </li></ul>    </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <ul>
<li> unsigned integer types: </li>
<ul><li> standard unsigned integer types: <span class="kw4">unsigned</span> <span class="kw4">char</span>, <span class="kw4">unsigned</span> <span class="kw4">short</span>, <span class="kw4">unsigned</span>, <span class="kw4">unsigned</span> <span class="kw4">long</span>, <span class="kw4">unsigned</span> <span class="kw4">long</span> <span class="kw4">long</span>; </li></ul>
</ul>     <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul><li> extended unsigned integer types (each corresponds to an extended signed integer type, and vice versa); </li></ul>    </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <ul>
<li> floating-point types (see also <code><a href="../types/is_floating_point" title="cpp/types/is floating point">std::is_floating_point</a></code>): </li>
<ul><li> standard floating-point types: <span class="kw4">float</span>, <span class="kw4">double</span>, <span class="kw4">long</span> <span class="kw4">double</span> and their <a href="cv" title="cpp/language/cv">cv-qualified versions</a>; </li></ul>
</ul>    <table class="t-rev-begin"> <tr class="t-rev t-since-cxx23">
<td> <ul>
<li> extended floating-point types (including <a href="cv" title="cpp/language/cv">cv-qualified versions</a>): </li>
<ul>
<li> <a href="../types/floating-point" title="cpp/types/floating-point">fixed width floating-point types</a>; </li>
<li> other implementation-defined extended floating-point types; </li>
</ul>
</ul>     </td> <td><span class="t-mark-rev t-since-cxx23">(since C++23)</span></td>
</tr> </table> <ul>
<li> compound types (see also <code><a href="../types/is_compound" title="cpp/types/is compound">std::is_compound</a></code>): </li>
<li> <a href="reference" title="cpp/language/reference">reference types</a> (see also <code><a href="../types/is_reference" title="cpp/types/is reference">std::is_reference</a></code>): </li>
<li> <a href="reference#Lvalue_references" title="cpp/language/reference">lvalue reference types</a> (see also <code><a href="../types/is_lvalue_reference" title="cpp/types/is lvalue reference">std::is_lvalue_reference</a></code>): </li>
<ul>
<li> lvalue reference to object types; </li>
<li> lvalue reference to function types; </li>
</ul>
</ul>      <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul>
<li> <a href="reference#Rvalue_references" title="cpp/language/reference">rvalue reference types</a> (see also <code><a href="../types/is_rvalue_reference" title="cpp/types/is rvalue reference">std::is_rvalue_reference</a></code>): </li>
<ul>
<li> rvalue reference to object types; </li>
<li> rvalue reference to function types; </li>
</ul>
</ul>    </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <ul>
<li> <a href="pointer#Pointers" title="cpp/language/pointer">pointer types</a> (see also <code><a href="../types/is_pointer" title="cpp/types/is pointer">std::is_pointer</a></code>): </li>
<ul>
<li> <a href="pointer#Pointers_to_objects" title="cpp/language/pointer">pointer-to-object types</a>; </li>
<li> <a href="pointer#Pointers_to_functions" title="cpp/language/pointer">pointer-to-function types</a>; </li>
</ul>
<li> <a href="pointer#Pointers_to_members" title="cpp/language/pointer">pointer-to-member types</a> (see also <code><a href="../types/is_member_pointer" title="cpp/types/is member pointer">std::is_member_pointer</a></code>): </li>
<ul>
<li> <a href="pointer#Pointers_to_data_members" title="cpp/language/pointer">pointer-to-data-member</a> types (see also <code><a href="../types/is_member_object_pointer" title="cpp/types/is member object pointer">std::is_member_object_pointer</a></code>); </li>
<li> <a href="pointer#Pointers_to_member_functions" title="cpp/language/pointer">pointer-to-member-function</a> types (see also <code><a href="../types/is_member_function_pointer" title="cpp/types/is member function pointer">std::is_member_function_pointer</a></code>); </li>
</ul>
<li> <a href="array" title="cpp/language/array">array types</a> (see also <code><a href="../types/is_array" title="cpp/types/is array">std::is_array</a></code>); </li>
<li> <a href="function" title="cpp/language/function">function types</a> (see also <code><a href="../types/is_function" title="cpp/types/is function">std::is_function</a></code>); </li>
<li> <a href="enum" title="cpp/language/enum">enumeration types</a> (see also <code><a href="../types/is_enum" title="cpp/types/is enum">std::is_enum</a></code>); </li>
<ul><li> <a href="enum#Unscoped_enumerations" title="cpp/language/enum">unscoped enumeration types</a>; </li></ul>
</ul>       <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul><li> <a href="enum#Scoped_enumerations" title="cpp/language/enum">scoped enumeration types</a> (see also <a href="../types/is_scoped_enum" title="cpp/types/is scoped enum"><code>std::is_scoped_enum</code></a>); </li></ul>  </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <ul>
<li> <a href="class" title="cpp/language/class">class types</a>: </li>
<ul>
<li> non-union types (see also <code><a href="../types/is_class" title="cpp/types/is class">std::is_class</a></code>); </li>
<li> <a href="union" title="cpp/language/union">union types</a> (see also <code><a href="../types/is_union" title="cpp/types/is union">std::is_union</a></code>). </li>
</ul>
</ul>   <ol class="references"> <li id="cite_note-1"> <span class="reference-text"><code>signed char</code> and <code>unsigned char</code> are narrow character types, but they are not character types. In other words, the set of narrow character types is not a subset of the set of character types.</span> </li> </ol> <p>For every non-cv-qualified type other than reference and function, the type system supports three additional <a href="cv" title="cpp/language/cv">cv-qualified versions</a> of that type (<span class="kw4">const</span>, <span class="kw4">volatile</span>, and <span class="kw4">const</span> <span class="kw4">volatile</span>).</p>
<p>Types are grouped in various categories based on their properties:</p>
<ul>
<li> object types are (possibly cv-qualified) types that are not function types, reference types, or possibly cv-qualified <span class="kw4">void</span> (see also <code><a href="../types/is_object" title="cpp/types/is object">std::is_object</a></code>); </li>
<li> <a href="../named_req/scalartype" title="cpp/named req/ScalarType">scalar types</a> are (possibly cv-qualified) object types that are not array types or class types (see also <code><a href="../types/is_scalar" title="cpp/types/is scalar">std::is_scalar</a></code>); </li>
<li> <a href="../named_req/trivialtype" title="cpp/named req/TrivialType">trivial types</a> (see also <code><a href="../types/is_trivial" title="cpp/types/is trivial">std::is_trivial</a></code>), <a href="../named_req/podtype" title="cpp/named req/PODType">POD types</a> (see also <code><a href="../types/is_pod" title="cpp/types/is pod">std::is_pod</a></code>), <a href="../named_req/literaltype" title="cpp/named req/LiteralType">literal types</a> (see also <code><a href="../types/is_literal_type" title="cpp/types/is literal type">std::is_literal_type</a></code>), and other categories listed in the <a href="../types" title="cpp/types">type traits library</a> or as <a href="../named_req" title="cpp/named req">named type requirements</a>. </li>
</ul> <p>Constructing a complete object type such that the number of bytes in its object representation is not representable in the type <code><a href="../types/size_t" title="cpp/types/size t">std::size_t</a></code> (i.e. the result type of <a href="sizeof" title="cpp/language/sizeof"><code>sizeof</code></a> operator) is ill-formed.</p>
<h3 id="Type_naming"> Type naming</h3> <p>A <a href="name" title="cpp/language/name" class="mw-redirect">name</a> can be declared to refer to a type by means of:</p>
<ul>
<li> <a href="class" title="cpp/language/class">class</a> declaration; </li>
<li> <a href="union" title="cpp/language/union">union</a> declaration; </li>
<li> <a href="enum" title="cpp/language/enum">enum</a> declaration; </li>
<li> <a href="typedef" title="cpp/language/typedef">typedef</a> declaration; </li>
<li> <a href="type_alias" title="cpp/language/type alias">type alias</a> declaration. </li>
</ul> <p>Types that do not have names often need to be referred to in C++ programs; the syntax for that is known as <span class="t-spar">type-id</span>. The syntax of the type-id that names type <code>T</code> is exactly the syntax of a <a href="declarations" title="cpp/language/declarations">declaration</a> of a variable or function of type <code>T</code>, with the identifier omitted, except that <span class="t-spar">decl-specifier-seq</span> of the declaration grammar is constrained to <span class="t-spar">type-specifier-seq</span>, and that new types may be defined only if the type-id appears on the right-hand side of a non-template type alias declaration.</p>
<div class="cpp source-cpp"><pre data-language="cpp">int* p;               // declaration of a pointer to int
static_cast&lt;int*&gt;(p); // type-id is "int*"
 
int a[3];   // declaration of an array of 3 int
new int[3]; // type-id is "int[3]" (called new-type-id)
 
int (*(*x[2])())[3];      // declaration of an array of 2 pointers to functions
                          // returning pointer to array of 3 int
new (int (*(*[2])())[3]); // type-id is "int (*(*[2])())[3]"
 
void f(int);                    // declaration of a function taking int and returning void
std::function&lt;void(int)&gt; x = f; // type template parameter is a type-id "void(int)"
std::function&lt;auto(int) -&gt; void&gt; y = f; // same
 
std::vector&lt;int&gt; v;       // declaration of a vector of int
sizeof(std::vector&lt;int&gt;); // type-id is "std::vector&lt;int&gt;"
 
struct { int x; } b;         // creates a new type and declares an object b of that type
sizeof(struct { int x; });   // error: cannot define new types in a sizeof expression
using t = struct { int x; }; // creates a new type and declares t as an alias of that type
 
sizeof(static int); // error: storage class specifiers not part of type-specifier-seq
std::function&lt;inline void(int)&gt; f; // error: neither are function specifiers</pre></div> <p>The <span class="t-spar">declarator</span> part of the declaration grammar with the name removed is referred to as <span class="t-spar">abstract-declarator</span>.</p>
<p>Type-id may be used in the following situations:</p>
<ul>
<li> to specify the target type in <a href="expressions#Conversions" title="cpp/language/expressions">cast expressions</a>; </li>
<li> as arguments to <a href="sizeof" title="cpp/language/sizeof">sizeof</a>, <a href="alignof" title="cpp/language/alignof">alignof</a>, <a href="alignas" title="cpp/language/alignas">alignas</a>, <a href="new" title="cpp/language/new">new</a>, and <a href="typeid" title="cpp/language/typeid">typeid</a>; </li>
<li> on the right-hand side of a <a href="type_alias" title="cpp/language/type alias">type alias</a> declaration; </li>
<li> as the trailing return type of a <a href="function" title="cpp/language/function">function</a> declaration; </li>
<li> as the default argument of a <a href="template_parameters#Type_template_parameter" title="cpp/language/template parameters">template type parameter</a>; </li>
<li> as the template argument for a <a href="template_parameters#Template_type_arguments" title="cpp/language/template parameters">template type parameter</a>; </li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx17">
<td> <ul><li> in <a href="except_spec" title="cpp/language/except spec">dynamic exception specification</a>. </li></ul> </td> <td><span class="t-mark-rev t-until-cxx17">(until C++17)</span></td>
</tr> </table> <p>Type-id can be used with some modifications in the following situations:</p>
<ul>
<li> in the parameter list of a <a href="function#Parameter_list" title="cpp/language/function">function</a> (when the parameter name is omitted), type-id uses <span class="t-spar">decl-specifier-seq</span> instead of <span class="t-spar">type-specifier-seq</span> (in particular, some storage class specifiers are allowed); </li>
<li> in the name of a <a href="cast_operator" title="cpp/language/cast operator">user-defined conversion function</a>, the abstract declarator cannot include function or array operators. </li>
</ul>   <h3 id="Elaborated_type_specifier"> Elaborated type specifier</h3> <p>Elaborated type specifiers may be used to refer to a previously-declared class name (class, struct, or union) or to a previously-declared enum name even if the name was <a href="lookup" title="cpp/language/lookup">hidden by a non-type declaration</a>. They may also be used to declare new class names.</p>
<p>See <a href="elaborated_type_specifier" title="cpp/language/elaborated type specifier">elaborated type specifier</a> for details.</p>
<h3 id="Static_type"> Static type</h3> <p>The type of an expression that results from the compile-time analysis of the program is known as the <i>static type</i> of the expression. The static type does not change while the program is executing.</p>
<h3 id="Dynamic_type"> Dynamic type</h3> <p>If some <a href="value_category" title="cpp/language/value category">glvalue expression</a> refers to a <a href="object" title="cpp/language/object">polymorphic object</a>, the type of its most derived object is known as the dynamic type.</p>
<div class="cpp source-cpp"><pre data-language="cpp">// given
struct B { virtual ~B() {} }; // polymorphic type
struct D : B {};               // polymorphic type
 
D d; // most-derived object
B* ptr = &amp;d;
 
// the static type of (*ptr) is B
// the dynamic type of (*ptr) is D</pre></div> <p>For prvalue expressions, the dynamic type is always the same as the static type.</p>
<h3 id="Incomplete_type"> Incomplete type</h3> <p>The following types are <i>incomplete types</i>:</p>
<ul>
<li> the type <span class="kw4">void</span> (possibly <a href="cv" title="cpp/language/cv">cv</a>-qualified); </li>
<li> <i>incompletely-defined object types</i>: <ul>
<li> class type that has been declared (e.g. by <a href="class#Forward_declaration" title="cpp/language/class">forward declaration</a>) but not defined; </li>
<li> <a href="array#Arrays_of_unknown_bound" title="cpp/language/array">array of unknown bound</a>; </li>
<li> array of elements of incomplete type; </li>
<li> <a href="enum" title="cpp/language/enum">enumeration type</a> from the point of declaration until its underlying type is determined. </li>
</ul> </li>
</ul> <p>All other types are complete.</p>
<p>Any of the following contexts requires type <code>T</code> to be complete:</p>
<ul>
<li> <a href="function" title="cpp/language/function">definition</a> of or call to a function with return type <code>T</code> or argument type <code>T</code>; </li>
<li> <a href="definition" title="cpp/language/definition">definition</a> of an object of type <code>T</code>; </li>
<li> declaration of a <a href="data_members" title="cpp/language/data members">non-static class data member</a> of type <code>T</code>; </li>
<li> <a href="new" title="cpp/language/new">new-expression</a> for an object of type <code>T</code> or an array whose element type is <code>T</code>; </li>
<li> <a href="implicit_cast#Lvalue_to_rvalue_conversion" title="cpp/language/implicit cast" class="mw-redirect">lvalue-to-rvalue conversion</a> applied to a glvalue of type <code>T</code>; </li>
<li> an <a href="implicit_cast" title="cpp/language/implicit cast" class="mw-redirect">implicit</a> or <a href="explicit_cast" title="cpp/language/explicit cast">explicit</a> conversion to type <code>T</code>; </li>
<li> a <a href="implicit_cast" title="cpp/language/implicit cast" class="mw-redirect">standard conversion</a>, <a href="dynamic_cast" title="cpp/language/dynamic cast">dynamic_cast</a>, or <a href="static_cast" title="cpp/language/static cast">static_cast</a> to type <code>T*</code> or <code>T&amp;</code>, except when converting from the <a href="pointer#Null_pointers" title="cpp/language/pointer">null pointer constant</a> or from a <a href="pointer#Pointers_to_void" title="cpp/language/pointer">pointer to possibly cv-qualified void</a>; </li>
<li> <a href="operator_member_access" title="cpp/language/operator member access">class member access operator</a> applied to an expression of type <code>T</code>; </li>
<li> <a href="typeid" title="cpp/language/typeid">typeid</a>, <a href="sizeof" title="cpp/language/sizeof">sizeof</a>, or <a href="alignof" title="cpp/language/alignof">alignof</a> operator applied to type <code>T</code>; </li>
<li> <a href="operator_arithmetic" title="cpp/language/operator arithmetic">arithmetic operator</a> applied to a pointer to <code>T</code>; </li>
<li> definition of a class with base class <code>T</code>; </li>
<li> assignment to an lvalue of type <code>T</code>; </li>
<li> a <a href="try_catch" title="cpp/language/try catch">catch-clause</a> for an exception of type <code>T</code>, <code>T&amp;</code>, or <code>T*</code>. </li>
</ul> <p>(In general, when the size and layout of <code>T</code> must be known.).</p>
<p>If any of these situations occur in a translation unit, the definition of the type must appear in the same translation unit. Otherwise, it is not required.</p>
<p>An incompletely-defined object type can be completed:</p>
<ul><li> A class type (such as <span class="kw1">class</span> X) might be regarded as incomplete at one point in a translation unit and regarded as complete later on; the type <span class="kw1">class</span> X is the same type at both points: </li></ul> <div class="cpp source-cpp"><pre data-language="cpp">struct X;            // declaration of X, no definition provided yet
extern X* xp;        // xp is a pointer to an incomplete type:
                     // the definition of X is not reachable
 
void foo()
{
    xp++;            // ill-formed: X is incomplete
}
 
struct X { int i; }; // definition of X
X x;                 // OK: the definition of X is reachable
 
void bar()
{
    xp = &amp;x;         // OK: type is “pointer to X”
    xp++;            // OK: X is complete
}</pre></div> <ul>
<li> The declared type of an array object might be an array of incomplete class type and therefore incomplete; if the class type is completed later on in the translation unit, the array type becomes complete; the array type at those two points is the same type. </li>
<li> The declared type of an array object might be an array of unknown bound and therefore be incomplete at one point in a translation unit and complete later on; the array types at those two points ("array of unknown bound of <code>T</code>" and "array of <code>N T</code>") are different types. </li>
</ul> <p>The type of a pointer or reference to array of unknown bound permanently points to or refers to an incomplete type. An array of unknown bound named by a <a href="typedef" title="cpp/language/typedef"><code>typedef</code></a> declaration permanently refers to an incomplete type. In either case, the array type cannot be completed:</p>
<div class="cpp source-cpp"><pre data-language="cpp">extern int arr[];   // the type of arr is incomplete
typedef int UNKA[]; // UNKA is an incomplete type
 
UNKA* arrp;         // arrp is a pointer to an incomplete type
UNKA** arrpp;
 
void foo()
{
    arrp++;         // error: UNKA is an incomplete type
    arrpp++;        // OK: sizeof UNKA* is known
}
 
int arr[10];        // now the type of arr is complete
 
void bar()
{
    arrp = &amp;arr;    // error: different types
    arrp++;         // error: UNKA cannot be completed
}</pre></div> <h3 id="Defect_Reports"> Defect Reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th> DR </th> <th> Applied to </th> <th> Behavior as published </th> <th> Correct behavior </th>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/328.html">CWG 328</a> </td> <td> C++98 </td> <td> class members of incomplete type were not prohibited<br>if an object of the class type was never created </td> <td> non-static class data members<br>need to be complete </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/977.html">CWG 977</a> </td> <td> C++98 </td> <td> the point when an enumeration type becomes<br>complete in its definition was unclear </td> <td> the type is complete once the<br>underlying type is determined </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1362.html">CWG 1362</a> </td> <td> C++98 </td> <td> user-defined conversions to type <code>T*</code> or <code>T&amp;</code> required <code>T</code> to be complete </td> <td> not required </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1464.html">CWG 1464</a> </td> <td> C++98 </td> <td> object size might be not representable in <code><a href="../types/size_t" title="cpp/types/size t">std::size_t</a></code> </td> <td> such type is ill-formed </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2006.html">CWG 2006</a> </td> <td> C++98 </td> <td> cv-qualified <span class="kw4">void</span> types were object type and complete type </td> <td> excluded from both categories </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2448.html">CWG 2448</a> </td> <td> C++98 </td> <td> only cv-unqualified types could be integral and floating-point types </td> <td> allowed cv-qualified types </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2630.html">CWG 2630</a> </td> <td> C++98 </td> <td> it was unclear whether a class is considered complete outside<br>the translation unit where the definition of the class appears </td> <td> the class is complete<br>if its definition is<br>reachable in this case </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2643.html">CWG 2643</a> </td> <td> C++98 </td> <td> the type of a pointer to array of unknown bound<br>could not be completed (but it is already complete) </td> <td> the pointed-to array type<br>cannot be completed </td>
</tr>
</table> <h3 id="See_also"> See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td colspan="2"> <span><a href="https://en.cppreference.com/w/c/language/type" title="c/language/type">C documentation</a></span> for <span class=""><span>Type</span></span> </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    © cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/language/type" class="_attribution-link">https://en.cppreference.com/w/cpp/language/type</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
