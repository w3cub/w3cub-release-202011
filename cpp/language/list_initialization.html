
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>List-initialization - C++ - W3cubDocs</title>
  
  <meta name="description" content=" Initializes an object from braced-init-list. ">
  <meta name="keywords" content="list-initialization, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/language/list_initialization.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-9c7b0d969c0ce639a6c01c2badcdd81667c7c66206aa3d0fccc5cb0585fb1b912dab72ea882101d18010680927514b4b77b107282db8f756fbf63301fe9c88b0.css">
  <script type="text/javascript" src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js"></script>
  <script src="/json/cpp.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _cppref">
				
				
<h1 id="firstHeading" class="firstHeading">List-initialization <span class="t-mark-rev t-since-cxx11">(since C++11)</span>
</h1>            <p>Initializes an object from <span class="t-spar">braced-init-list</span>.</p>
<h3 id="Syntax"> Syntax</h3> <h4 id="Direct-list-initialization"> Direct-list-initialization</h4> <table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">T object</span> <code>{</code> <span class="t-spar">arg1, arg2, ...</span> <code>};</code> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p><span class="t-spar">T object</span><code>{.</code><span class="t-spar">des1</span> <code>=</code> <span class="t-spar">arg1</span> <code>, .</code><span class="t-spar">des2</span> <code>{</code> <span class="t-spar">arg2</span> <code>}</code> <span class="t-spar">...</span> <code>};</code></p>
</td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">T</span> <code>{</code> <span class="t-spar">arg1, arg2, ...</span> <code>}</code> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p><span class="t-spar">T</span> <code>{.</code><span class="t-spar">des1</span> <code>=</code> <span class="t-spar">arg1</span> <code>, .</code><span class="t-spar">des2</span> <code>{</code> <span class="t-spar">arg2</span> <code>}</code> <span class="t-spar">...</span> <code>}</code></p>
</td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>new</code> <span class="t-spar">T</span> <code>{</code> <span class="t-spar">arg1, arg2, ...</span> <code>}</code> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p><code>new</code> <span class="t-spar">T</span> <code>{.</code><span class="t-spar">des1</span> <code>=</code> <span class="t-spar">arg1</span> <code>, .</code><span class="t-spar">des2</span> <code>{</code> <span class="t-spar">arg2</span> <code>}</code> <span class="t-spar">...</span> <code>}</code></p>
</td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> </td> <td> (3) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">Class</span> <code>{</code> <span class="t-spar">T member</span> <code>{</code> <span class="t-spar">arg1, arg2, ...</span> <code>}; };</code> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p><span class="t-spar">Class</span> <code>{</code> <span class="t-spar">T member</span> <code>{.</code><span class="t-spar">des1</span> <code>=</code> <span class="t-spar">arg1</span> <code>, .</code><span class="t-spar">des2</span> <code>{</code> <span class="t-spar">arg2</span> <code>}</code> <span class="t-spar">...</span> <code>}; };</code></p>
</td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> </td> <td> (4) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">Class</span><code>::</code><span class="t-spar">Class</span><code>() :</code> <span class="t-spar">member</span> <code>{</code> <span class="t-spar">arg1, arg2, ...</span> <code>} {...</code> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p><span class="t-spar">Class</span><code>::</code><span class="t-spar">Class</span><code>() :</code> <span class="t-spar">member</span> <code>{.</code><span class="t-spar">des1</span> <code>=</code> <span class="t-spar">arg1</span> <code>, .</code><span class="t-spar">des2</span> <code>{</code> <span class="t-spar">arg2</span> <code>}</code> <span class="t-spar">...</span><code>} {...</code></p>
</td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> </td> <td> (5) </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <h4 id="Copy-list-initialization"> Copy-list-initialization</h4> <table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">T object</span> <code>= {</code> <span class="t-spar">arg1, arg2, ...</span> <code>};</code> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p><span class="t-spar">T object</span> <code>= {.</code><span class="t-spar">des1</span> <code>=</code> <span class="t-spar">arg1</span> <code>, .</code><span class="t-spar">des2</span> <code>{</code> <span class="t-spar">arg2</span> <code>}</code> <span class="t-spar">...</span> <code>};</code></p>
</td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> </td> <td> (6) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">function</span> <code>({</code> <span class="t-spar">arg1, arg2, ...</span> <code>})</code> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p><span class="t-spar">function</span> <code>({.</code><span class="t-spar">des1</span> <code>=</code> <span class="t-spar">arg1</span> <code>, .</code><span class="t-spar">des2</span> <code>{</code> <span class="t-spar">arg2</span> <code>}</code> <span class="t-spar">...</span> <code>})</code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> </td> <td> (7) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>return {</code> <span class="t-spar">arg1, arg2, ...</span> <code>};</code> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p><code>return </code><code>{.</code><span class="t-spar">des1</span> <code>=</code> <span class="t-spar">arg1</span> <code>, .</code><span class="t-spar">des2</span> <code>{</code> <span class="t-spar">arg2</span> <code>}</code> <span class="t-spar">...</span> <code>};</code></p>
</td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> </td> <td> (8) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">object</span> <code>[{</code> <span class="t-spar">arg1, arg2, ...</span> <code>}]</code> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p><span class="t-spar">object</span> <code>[{.</code><span class="t-spar">des1</span> <code>=</code> <span class="t-spar">arg1</span> <code>, .</code><span class="t-spar">des2</span> <code>{</code> <span class="t-spar">arg2</span> <code>}</code> <span class="t-spar">...</span> <code>}]</code></p>
</td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> </td> <td> (9) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">object</span> <code>= {</code> <span class="t-spar">arg1, arg2, ...</span> <code>}</code> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p><span class="t-spar">object</span> <code>= {.</code><span class="t-spar">des1</span> <code>=</code> <span class="t-spar">arg1</span> <code>, .</code><span class="t-spar">des2</span> <code>{</code> <span class="t-spar">arg2</span> <code>}</code> <span class="t-spar">...</span> <code>}</code></p>
</td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> </td> <td> (10) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">U</span> <code>({</code> <span class="t-spar">arg1, arg2, ...</span> <code>})</code> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p><span class="t-spar">U</span> <code>({.</code><span class="t-spar">des1</span> <code>=</code> <span class="t-spar">arg1</span> <code>, .</code><span class="t-spar">des2</span> <code>{</code> <span class="t-spar">arg2</span> <code>}</code> <span class="t-spar">...</span> <code>})</code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> </td> <td> (11) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">Class</span> <code>{</code> <span class="t-spar">T member</span> <code>= {</code> <span class="t-spar">arg1, arg2, ...</span> <code>}; };</code> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p><span class="t-spar">Class</span> <code>{</code> <span class="t-spar">T member</span> <code>= {.</code><span class="t-spar">des1</span> <code>=</code> <span class="t-spar">arg1</span> <code>, .</code><span class="t-spar">des2</span> <code>{</code> <span class="t-spar">arg2</span> <code>}</code> <span class="t-spar">...</span> <code>}; };</code></p>
</td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> </td> <td> (12) </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <p>List initialization is performed in the following situations:</p>
<ul><li> direct-list-initialization (both explicit and non-explicit constructors are considered) </li></ul> <div class="t-li1">
<span class="t-li">1)</span> initialization of a named variable with a <span class="t-spar">braced-init-list</span> (that is, a possibly empty brace-enclosed list of expressions or nested braced-init-lists)</div> <div class="t-li1">
<span class="t-li">2)</span> initialization of an unnamed temporary with a <span class="t-spar">braced-init-list</span>
</div> <div class="t-li1">
<span class="t-li">3)</span> initialization of an object with dynamic storage duration with a <a href="new" title="cpp/language/new">new-expression</a>, where the initializer is a <span class="t-spar">braced-init-list</span>
</div> <div class="t-li1">
<span class="t-li">4)</span> in a non-static <a href="data_members#Member_initialization" title="cpp/language/data members">data member initializer</a> that does not use the equals sign</div> <div class="t-li1">
<span class="t-li">5)</span> in a <a href="initializer_list" title="cpp/language/initializer list" class="mw-redirect">member initializer list</a> of a constructor if <span class="t-spar">braced-init-list</span> is used</div> <ul><li> copy-list-initialization (both explicit and non-explicit constructors are considered, but only non-explicit constructors may be called) </li></ul> <div class="t-li1">
<span class="t-li">6)</span> initialization of a named variable with a <span class="t-spar">braced-init-list</span> after an equals sign</div> <div class="t-li1">
<span class="t-li">7)</span> in a function call expression, with <span class="t-spar">braced-init-list</span> used as an argument and list-initialization initializes the function parameter</div> <pre data-language="cpp">return</pre> <div class="t-li1">
<span class="t-li">9)</span> in a <a href="operator_member_access#Built-in_subscript_operator" title="cpp/language/operator member access">subscript expression</a> with a user-defined <code>operator[]</code>, where list-initialization initializes the parameter of the overloaded operator</div> <div class="t-li1">
<span class="t-li">10)</span> in an <a href="operator_assignment" title="cpp/language/operator assignment">assignment expression</a>, where list-initialization initializes the parameter of the overloaded operator</div> <div class="t-li1">
<span class="t-li">11)</span> <a href="explicit_cast" title="cpp/language/explicit cast">functional cast expression</a> or other constructor invocations, where <span class="t-spar">braced-init-list</span> is used in place of a constructor argument. Copy-list-initialization initializes the constructor's parameter (note; the type U in this example is not the type that's being list-initialized; U's constructor's parameter is)</div> <div class="t-li1">
<span class="t-li">12)</span> in a non-static <a href="data_members#Member_initialization" title="cpp/language/data members">data member initializer</a> that uses the equals sign</div> <h3 id="Explanation"> Explanation</h3> <p>The effects of list-initialization of an object of type <code>T</code> are:</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <ul><li> If the <span class="t-spar">braced-init-list</span> contains a <a href="aggregate_initialization#Designated_initializers" title="cpp/language/aggregate initialization"><span class="t-spar">designated-initializer-list</span></a>, <code>T</code> shall be an aggregate class. The ordered identifiers in the designators of the <span class="t-spar">designated-initializer-list</span> shall form a subsequence of the ordered identifiers in the direct non-static data members of <code>T</code>. <a href="aggregate_initialization" title="cpp/language/aggregate initialization">Aggregate initialization</a> is performed. </li></ul> </td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <ul>
<li> If <code>T</code> is an aggregate class and the <span class="t-spar">braced-init-list</span> has a single element of the same or derived type (possibly cv-qualified), the object is initialized from that element (by <a href="copy_initialization" title="cpp/language/copy initialization">copy-initialization</a> for copy-list-initialization, or by <a href="direct_initialization" title="cpp/language/direct initialization">direct-initialization</a> for direct-list-initialization). </li>
<li> Otherwise, if <code>T</code> is a character array and the <span class="t-spar">braced-init-list</span> has a single element that is an appropriately-typed string literal, the array is <a href="aggregate_initialization#Character_arrays" title="cpp/language/aggregate initialization">initialized from the string literal as usual</a>. </li>
<li> Otherwise, if <code>T</code> is an <a href="aggregate_initialization" title="cpp/language/aggregate initialization">aggregate type</a>, <a href="aggregate_initialization" title="cpp/language/aggregate initialization">aggregate initialization</a> is performed. </li>
<li> Otherwise, if the <span class="t-spar">braced-init-list</span> is empty and <code>T</code> is a class type with a default constructor, <a href="value_initialization" title="cpp/language/value initialization">value-initialization</a> is performed. </li>
<li> Otherwise, if <code>T</code> is a specialization of <code><a href="../utility/initializer_list" title="cpp/utility/initializer list">std::initializer_list</a></code>, the <code>T</code> object is direct-initialized or copy-initialized, depending on context, from <span class="t-rev-inl t-until-cxx17"><span>a prvalue of the same type initialized from</span> <span><span class="t-mark-rev t-until-cxx17">(until C++17)</span></span></span> the <span class="t-spar">braced-init-list</span>. </li>
<li> Otherwise, the constructors of <code>T</code> are considered, in two phases: </li>
<ul>
<li> All constructors that take <code><a href="../utility/initializer_list" title="cpp/utility/initializer list">std::initializer_list</a></code> as the only argument, or as the first argument if the remaining arguments have default values, are examined, and matched by <a href="overload_resolution" title="cpp/language/overload resolution">overload resolution</a> against a single argument of type <code><a href="../utility/initializer_list" title="cpp/utility/initializer list">std::initializer_list</a></code> </li>
<li> If the previous stage does not produce a match, all constructors of <code>T</code> participate in <a href="overload_resolution#Implicit_conversion_sequence_in_list-initialization" title="cpp/language/overload resolution">overload resolution</a> against the set of arguments that consists of the elements of the <span class="t-spar">braced-init-list</span>, with the restriction that only non-narrowing conversions are allowed. If this stage produces an explicit constructor as the best match for a copy-list-initialization, compilation fails (note, in simple copy-initialization, explicit constructors are not considered at all). </li>
</ul>
</ul>       <table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <ul><li> Otherwise, if： <ul>
<li> <code>T</code> is an <a href="enum" title="cpp/language/enum">enumeration type</a> that with fixed underlying type <code>U</code> (which is <span class="kw4">int</span> if the enumeration is scoped and its underlying type is not manually specified), and </li>
<li> the initialization is direct-list-initialization, and </li>
<li> the <span class="t-spar">braced-init-list</span> has only one initializer <code>v</code> that is implicitly convertible to <code>U</code>, and </li>
<li> the conversion from <code>v</code> to <code>U</code> is non-narrowing, </li>
</ul> </li></ul>  then the enumeration is initialized with the result of converting <code>v</code> to <code>U</code>.  </td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <ul>
<li> Otherwise (if <code>T</code> is not a class type), if the <span class="t-spar">braced-init-list</span> has only one element and either <code>T</code> is not a reference type or is a reference type whose referenced type is same as or is a base class of the type of the element, <code>T</code> is <a href="direct_initialization" title="cpp/language/direct initialization">direct-initialized</a> (in direct-list-initialization) or <a href="copy_initialization" title="cpp/language/copy initialization">copy-initialized</a> (in copy-list-initialization), except that narrowing conversions are not allowed. </li>
<li> Otherwise, if <code>T</code> is a reference type that is not compatible with the type of the element: </li>
</ul>  <table class="t-rev-begin"> <tr class="t-rev t-until-cxx17">
<td> <ul><li> a prvalue temporary of the type referenced by <code>T</code> is copy-list-initialized, and the reference is bound to that temporary (this fails if the reference is a non-const lvalue reference). </li></ul> </td> <td><span class="t-mark-rev t-until-cxx17">(until C++17)</span></td>
</tr> <tr class="t-rev t-since-cxx17">
<td> <ul><li> a prvalue is generated. The prvalue initializes its result object by copy-list-initialization. The prvalue is then used to direct-initialize the reference (this fails if the reference is a non-const lvalue reference). The type of the temporary is the type referenced by <code>T</code><span class="t-rev-inl t-since-cxx20"><span>, unless <code>T</code> is “reference to array of unknown bound of <code>U</code>”, in which case the type of the temporary is the type of <code>x</code> in the declaration <code>U x[] H</code>, where <code>H</code> is the initializer list</span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span>. </li></ul> </td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <ul><li> Otherwise, if the <span class="t-spar">braced-init-list</span> has no elements, <code>T</code> is <a href="value_initialization" title="cpp/language/value initialization">value-initialized</a>. </li></ul> <h3 id="Narrowing_conversions"> Narrowing conversions</h3> <p>List-initialization limits the allowed <a href="implicit_conversion" title="cpp/language/implicit conversion">implicit conversions</a> by prohibiting the following:</p>
<ul><li> conversion from a floating-point type to an integer type </li></ul> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx23">
<td> <ul><li> conversion from a <span class="kw4">long</span> <span class="kw4">double</span> to <span class="kw4">double</span> or to <span class="kw4">float</span> and conversion from <span class="kw4">double</span> to <span class="kw4">float</span>, except where the source is a <a href="constant_expression" title="cpp/language/constant expression">constant expression</a> and overflow does not occur </li></ul> </td> <td><span class="t-mark-rev t-until-cxx23">(until C++23)</span></td>
</tr> <tr class="t-rev t-since-cxx23">
<td> <ul><li> conversion from a floating-point type <code>T</code> to another floating-point type whose <a href="usual_arithmetic_conversions#Floating-point_conversion_rank" title="cpp/language/usual arithmetic conversions">floating-point conversion rank</a> is neither greater than nor equal to that of <code>T</code>, except where the source is a <a href="constant_expression" title="cpp/language/constant expression">constant expression</a> and overflow does not occur </li></ul> </td> <td><span class="t-mark-rev t-since-cxx23">(since C++23)</span></td>
</tr> </table> <ul>
<li> conversion from an integer type to a floating-point type, except where the source is a constant expression whose value can be stored exactly in the target type </li>
<li> conversion from integer or unscoped enumeration type to integer type that cannot represent all values of the original, except where <ul>
<li> the source is a <a href="bit_field" title="cpp/language/bit field">bit-field</a> whose width <code>w</code> is less than that of its type (or, for an <a href="enum" title="cpp/language/enum">enumeration type</a>, its underlying type) and the target type can represent all the values of a hypothetical extended integer type with width <code>w</code> and with the same signedness as the original type, or </li>
<li> the source is a constant expression whose value can be stored exactly in the target type </li>
</ul> </li>
<li> conversion from a pointer type or pointer-to-member type to <span class="kw4">bool</span> </li>
</ul>   <h3 id="Notes"> Notes</h3> <p>Every initializer clause is <a href="eval_order" title="cpp/language/eval order">sequenced before</a> any initializer clause that follows it in the <span class="t-spar">braced-init-list</span>. This is in contrast with the arguments of a <a href="operator_other#Built-in_function_call_operator" title="cpp/language/operator other">function call expression</a>, which are <span class="t-rev-inl t-until-cxx17"><span><a href="eval_order" title="cpp/language/eval order">unsequenced</a></span> <span><span class="t-mark-rev t-until-cxx17">(until C++17)</span></span></span><span class="t-rev-inl t-since-cxx17"><span><a href="eval_order" title="cpp/language/eval order">indeterminately sequenced</a></span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span>.</p>
<p>A <span class="t-spar">braced-init-list</span> is not an expression and therefore has no type, e.g. decltype<span class="br0">(</span><span class="br0">{</span><span class="nu0">1</span>, <span class="nu0">2</span><span class="br0">}</span><span class="br0">)</span> is ill-formed. Having no type implies that template type deduction cannot deduce a type that matches a <span class="t-spar">braced-init-list</span>, so given the declaration <code>template&lt;class T&gt; void f(T);</code> the expression <code>f({1, 2, 3})</code> is ill-formed. However, the template parameter can otherwise be deduced, as is the case for <code><a href="http://en.cppreference.com/w/cpp/container/vector"><span class="kw1273">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> v<span class="br0">(</span><a href="http://en.cppreference.com/w/cpp/iterator/istream_iterator"><span class="kw671">std::<span class="me2">istream_iterator</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span><span class="br0">(</span><a href="http://en.cppreference.com/w/cpp/io/cin"><span class="kw1761">std::<span class="me2">cin</span></span></a><span class="br0">)</span>, <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span></code>, where the iterator type is deduced by the first argument but also used in the second parameter position. A special exception is made for <a href="template_argument_deduction#Other_contexts" title="cpp/language/template argument deduction">type deduction using the keyword <span class="kw4">auto</span></a>, which deduces any <span class="t-spar">braced-init-list</span> as <code><a href="../utility/initializer_list" title="cpp/utility/initializer list">std::initializer_list</a></code> in copy-list-initialization.</p>
<p>Also because a <span class="t-spar">braced-init-list</span> has no type, <a href="overload_resolution#Implicit_conversion_sequence_in_list-initialization" title="cpp/language/overload resolution">special rules for overload resolution</a> apply when it is used as an argument to an overloaded function call.</p>
<p>Aggregates copy/move initialize directly from single-element <span class="t-spar">braced-init-list</span> of the same type, but non-aggregates consider initializer_list constructors first:</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct X {}; // aggregate
 
struct Q     // non-aggregate
{
    Q() = default;
    Q(Q const&amp;) = default;
    Q(std::initializer_list&lt;Q&gt;) {}
};
 
int main()
{
    X x;
    X x2 = X{x}; // copy-constructor (not aggregate initialization)
 
    Q q;
    Q q2 = Q{q}; // initializer-list constructor (not copy constructor)
}</pre></div> <p>Some compilers (e.g., gcc 10) only consider conversion from a pointer or a pointer-to-member to <span class="kw4">bool</span> narrowing in C++20 mode.</p>
<table class="wikitable ftm-begin ftm-has-value"> <tr> <th>Feature-test macro</th> <th>Value</th> <th><span title="Standard in which the feature is introduced">Std</span></th> <th>Comment </th>
</tr> <tr> <td><a href="../feature_test#Language_features" title="cpp/feature test"><code>__cpp_initializer_lists</code></a></td> <td><span class="nu0">200806L</span></td> <td><span class="t-mark">(C++11)</span></td> <td>List-initialization and <code><a href="../utility/initializer_list" title="cpp/utility/initializer list">std::initializer_list</a></code> </td>
</tr>
</table> <h3 id="Example"> Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
 
struct Foo
{
    std::vector&lt;int&gt; mem = {1, 2, 3}; // list-initialization of a non-static member
    std::vector&lt;int&gt; mem2;
 
    Foo() : mem2{-1, -2, -3} {} // list-initialization of a member in constructor
};
 
std::pair&lt;std::string, std::string&gt; f(std::pair&lt;std::string, std::string&gt; p)
{
    return {p.second, p.first}; // list-initialization in return statement
}
 
int main()
{
    int n0{};  // value-initialization (to zero)
    int n1{1}; // direct-list-initialization
 
    std::string s1{'a', 'b', 'c', 'd'}; // initializer-list constructor call
    std::string s2{s1, 2, 2};           // regular constructor call
    std::string s3{0x61, 'a'}; // initializer-list ctor is preferred to (int, char)
 
    int n2 = {1}; // copy-list-initialization
    double d = double{1.2}; // list-initialization of a prvalue, then copy-init
    auto s4 = std::string{"HelloWorld"}; // same as above, no temporary
                                         // created since C++17
 
    std::map&lt;int, std::string&gt; m = // nested list-initialization
    {
        {1, "a"},
        {2, {'a', 'b', 'c'}},
        {3, s1}
    };
 
    std::cout &lt;&lt; f({"hello", "world"}).first // list-initialization in function call
              &lt;&lt; '\n';
 
    const int (&amp;ar)[2] = {1, 2}; // binds an lvalue reference to a temporary array
    int&amp;&amp; r1 = {1}; // binds an rvalue reference to a temporary int
//  int&amp; r2 = {2}; // error: cannot bind rvalue to a non-const lvalue ref
 
//  int bad{1.0}; // error: narrowing conversion
    unsigned char uc1{10}; // okay
//  unsigned char uc2{-1}; // error: narrowing conversion
 
    Foo f;
 
    std::cout &lt;&lt; n0 &lt;&lt; ' ' &lt;&lt; n1 &lt;&lt; ' ' &lt;&lt; n2 &lt;&lt; '\n'
              &lt;&lt; s1 &lt;&lt; ' ' &lt;&lt; s2 &lt;&lt; ' ' &lt;&lt; s3 &lt;&lt; '\n';
    for (auto p : m)
        std::cout &lt;&lt; p.first &lt;&lt; ' ' &lt;&lt; p.second &lt;&lt; '\n';
    for (auto n : f.mem)
        std::cout &lt;&lt; n &lt;&lt; ' ';
    for (auto n : f.mem2)
        std::cout &lt;&lt; n &lt;&lt; ' ';
 
    [](...){}(d, ar, r1, uc1); // has effect of [[maybe_unused]]
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">world
0 1 1
abcd cd aa
1 a
2 abc
3 abcd
1 2 3 -1 -2 -3</pre></div> </div> <h3 id="Defect_reports"> Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th> DR </th> <th> Applied to </th> <th> Behavior as published </th> <th> Correct behavior </th>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1288.html">CWG 1288</a> </td> <td> C++11 </td> <td> list-initializing a reference with a single-element<br><span class="t-spar">braced-init-list</span> always bound the reference to a temporary </td> <td> bind to that<br>element if valid </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1324.html">CWG 1324</a> </td> <td> C++11 </td> <td> initialization considered first for initialization from <code>{}</code> </td> <td> aggregate initialization<br>considered first </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1467.html">CWG 1467</a> </td> <td> C++11 </td> <td> same-type initialization of aggregates and character<br>arrays was prohibited; initializer-list constructors had<br>priority over copy constructors for single-element lists </td> <td> same-type initialization<br>allowed; single-element<br>lists initialize directly </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1494.html">CWG 1494</a> </td> <td> C++11 </td> <td> when list-initializing a reference with an element of an<br>incompatible type, it was unspecified whether the temporary<br>created is direct-list-initialized or copy-list-initialized </td> <td> it depends on the<br>kind of initialization<br>for the reference </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2137.html">CWG 2137</a> </td> <td> C++11 </td> <td> initializer-list constructors lost to copy<br>constructors when list-initializing <code>X</code> from <code>{X}</code> </td> <td> non-aggregates consider<br>initializer-lists first </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2267.html">CWG 2267</a> </td> <td> C++11 </td> <td> the resolution of <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1494.html">CWG issue 1494</a> made clear<br>that temporaries could be direct-list-initialized </td> <td> they are copy-list-initialized<br>when list-initializing references </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2374.html">CWG 2374</a> </td> <td> C++17 </td> <td> direct-list-initialization of an enum allowed too many source types </td> <td> restricted </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2627.html">CWG 2627</a> </td> <td> C++11 </td> <td> a narrow bit-field of a larger integer type can be promoted to<br>a smaller integer type, but it was still a narrowing conversion </td> <td> it is not a<br>narrowing conversion </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://wg21.link/P1957R2">P1957R2</a> </td> <td> C++11 </td> <td> conversion from a pointer/pointer-to<br>-member to <span class="kw4">bool</span> was not narrowing </td> <td> made narrowing </td>
</tr>
</table> <h3 id="See_also"> See also</h3> <ul>
<li> <a href="constructor" title="cpp/language/constructor">constructor</a> </li>
<li> <a href="converting_constructor" title="cpp/language/converting constructor">converting constructor</a> </li>
<li> <a href="copy_assignment" title="cpp/language/copy assignment">copy assignment</a> </li>
<li> <a href="copy_constructor" title="cpp/language/copy constructor">copy constructor</a> </li>
<li> <a href="copy_elision" title="cpp/language/copy elision">copy elision</a> </li>
<li> <a href="default_constructor" title="cpp/language/default constructor">default constructor</a> </li>
<li> <a href="explicit" title="cpp/language/explicit"><code>explicit</code></a> </li>
<li> <a href="initialization" title="cpp/language/initialization">initialization</a> <ul>
<li> <a href="aggregate_initialization" title="cpp/language/aggregate initialization">aggregate initialization</a> </li>
<li> <a href="constant_initialization" title="cpp/language/constant initialization">constant initialization</a> </li>
<li> <a href="copy_initialization" title="cpp/language/copy initialization">copy initialization</a> </li>
<li> <a href="direct_initialization" title="cpp/language/direct initialization">direct initialization</a> </li>
<li> <a href="reference_initialization" title="cpp/language/reference initialization">reference initialization</a> </li>
<li> <a href="value_initialization" title="cpp/language/value initialization">value initialization</a> </li>
<li> <a href="zero_initialization" title="cpp/language/zero initialization">zero initialization</a> </li>
</ul> </li>
<li> <a href="move_assignment" title="cpp/language/move assignment">move assignment</a> </li>
<li> <a href="move_constructor" title="cpp/language/move constructor">move constructor</a> </li>
<li> <a href="new" title="cpp/language/new"><code>new</code></a> </li>
</ul>           <div class="_attribution">
  <p class="_attribution-p">
    © cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/language/list_initialization" class="_attribution-link">https://en.cppreference.com/w/cpp/language/list_initialization</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
