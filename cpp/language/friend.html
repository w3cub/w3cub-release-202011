
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Friend Declaration - C++ - W3cubDocs</title>
  
  <meta name="description" content="The friend declaration appears in a class body and grants a function or another class access to private and protected members of the class where the &hellip;">
  <meta name="keywords" content="friend, declaration, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/language/friend.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-9c7b0d969c0ce639a6c01c2badcdd81667c7c66206aa3d0fccc5cb0585fb1b912dab72ea882101d18010680927514b4b77b107282db8f756fbf63301fe9c88b0.css">
  <script type="text/javascript" src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js"></script>
  <script src="/json/cpp.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _cppref">
				
				
<h1 id="firstHeading" class="firstHeading">Friend declaration</h1>            <p>The friend declaration appears in a <a href="class" title="cpp/language/class">class body</a> and grants a function or another class access to private and protected members of the class where the friend declaration appears.</p>
<h3 id="Syntax"> Syntax</h3> <table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <code>friend</code> <span class="t-spar">function-declaration</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>friend</code> <span class="t-spar">function-definition</span> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>friend</code> <span class="t-spar">elaborated-class-specifier</span> <code>;</code> </td> <td> (3) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>friend</code> <span class="t-spar">simple-type-specifier</span> <code>;</code> <p><code>friend</code> <span class="t-spar">typename-specifier</span> <code>;</code></p>
</td> <td> (4) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr> 
</table> <h3 id="Description"> Description</h3> <div class="t-li1">
<span class="t-li">1)</span> Designates a function or several functions as friends of this class: <div class="cpp source-cpp"><pre data-language="cpp">class Y
{
    int data; // private member
 
    // the non-member function operator&lt;&lt; will have access to Y's private members
    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Y&amp; o);
    friend char* X::foo(int); // members of other classes can be friends too
    friend X::X(char), X::~X(); // constructors and destructors can be friends
};
 
// friend declaration does not declare a member function
// this operator&lt;&lt; still needs to be defined, as a non-member
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Y&amp; y)
{
    return out &lt;&lt; y.data; // can access private member Y::data
}</pre></div>
</div> <div class="t-li1">
<span class="t-li">2)</span> (only allowed in non-<a href="class#Local_classes" title="cpp/language/class">local</a> class definitions) Defines a non-member function, and makes it a friend of this class at the same time. Such non-member function is always <a href="inline" title="cpp/language/inline">inline</a><span class="t-rev-inl t-since-cxx20"><span>, unless it is attached to a <a href="modules" title="cpp/language/modules">named module</a></span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span>. <div class="cpp source-cpp"><pre data-language="cpp">class X
{
    int a;
 
    friend void friend_set(X&amp; p, int i)
    {
        p.a = i; // this is a non-member function
    }
public:
    void member_set(int i)
    {
        a = i; // this is a member function
    }
};</pre></div>
</div> <div class="t-li1">
<span class="t-li">3)</span> Designates the class, struct, or union named by the <span class="t-spar">elaborated-class-specifier</span> (see <a href="elaborated_type_specifier" title="cpp/language/elaborated type specifier">elaborated type specifier</a>) as a friend of this class. This means that the friend's member declarations and definitions can access private and protected members of this class and also that the friend can inherit from private and protected members of this class. The name of the class that is used in this <code>friend</code> declaration does not need to be previously declared.</div> <div class="t-li1">
<span class="t-li">4)</span> Designates the type named by the <span class="t-spar">simple-type-specifier</span> or <span class="t-spar">typename-specifier</span> as a friend of this class if that type is a (possibly <a href="cv" title="cpp/language/cv">cv-qualified</a>) class, struct, or union; otherwise the <code>friend</code> declaration is ignored. This declaration will not forward declare a new type. <div class="cpp source-cpp"><pre data-language="cpp">class Y {};
 
class A
{
    int data; // private data member
 
    class B {}; // private nested type
 
    enum { a = 100 }; // private enumerator
 
    friend class X; // friend class forward declaration (elaborated class specifier)
    friend Y; // friend class declaration (simple type specifier) (since c++11)
};
 
class X : A::B // OK: A::B accessible to friend
{
    A::B mx; // OK: A::B accessible to member of friend
 
    class Y
    {
        A::B my; // OK: A::B accessible to nested member of friend
    };
 
    int v[A::a]; // OK: A::a accessible to member of friend
};</pre></div>
</div> <h3 id="Notes"> Notes</h3> <p>Friendship is not transitive (a friend of your friend is not your friend).</p>
<p>Friendship is not inherited (your friend's children are not your friends, and your friends are not your children's friends).</p>
<p>Storage class specifiers are not allowed in friend function declarations. A function that is defined in the friend declaration has external linkage, a function that was previously defined, keeps the linkage it was defined with.</p>
<p><a href="access" title="cpp/language/access">Access specifiers</a> have no effect on the meaning of friend declarations (they can appear in <code>private:</code> or in <code>public:</code> sections, with no difference).</p>
<p>A friend class declaration cannot define a new class (<code>friend class X {};</code> is an error).</p>
<p>When a local class declares an unqualified function or class as a friend, only functions and classes in the innermost non-class scope are <a href="lookup" title="cpp/language/lookup">looked up</a>, not the global functions:</p>
<div class="cpp source-cpp"><pre data-language="cpp">class F {};
 
int f();
 
int main()
{
    extern int g();
 
    class Local // Local class in the main() function
    {
        friend int f(); // Error, no such function declared in main()
        friend int g(); // OK, there is a declaration for g in main()
        friend class F; // friends a local F (defined later)
        friend class ::F; // friends the global F
    };
 
    class F {}; // local F
}</pre></div> <p>A name first declared in a friend declaration within a class or class template <code>X</code> becomes a member of the innermost enclosing namespace of <code>X</code>, but is not visible for lookup (except argument-dependent lookup that considers <code>X</code>) unless a matching declaration at namespace scope is provided - see <a href="namespace#Namespaces" title="cpp/language/namespace">namespaces</a> for details.</p>
<h3 id="Template_friends"> Template friends</h3> <p>Both <a href="function_template" title="cpp/language/function template">function template</a> and <a href="class_template" title="cpp/language/class template">class template</a> declarations may appear with the <code>friend</code> specifier in any non-local class or class template (although only function templates may be defined within the class or class template that is granting friendship). In this case, every specialization of the template becomes a friend, whether it is implicitly instantiated, partially specialized, or explicitly specialized.</p>
<div class="cpp source-cpp"><pre data-language="cpp">class A
{
    template&lt;typename T&gt;
    friend class B; // every B&lt;T&gt; is a friend of A
 
    template&lt;typename T&gt;
    friend void f(T) {} // every f&lt;T&gt; is a friend of A
};</pre></div> <p>Friend declarations cannot refer to partial specializations, but can refer to full specializations:</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;class T&gt;
class A {};      // primary
 
template&lt;class T&gt;
class A&lt;T*&gt; {};  // partial
 
template&lt;&gt;
class A&lt;int&gt; {}; // full
 
class X
{
    template&lt;class T&gt;
    friend class A&lt;T*&gt;;  // error!
 
    friend class A&lt;int&gt;; // OK
};</pre></div> <p>When a friend declaration refers to a full specialization of a function template, the keywords <code>inline</code><span class="t-rev-inl t-since-cxx11"><span>/<code>constexpr</code></span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span><span class="t-rev-inl t-since-cxx20"><span>/<code>consteval</code></span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span> and default arguments cannot be used:</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;class T&gt;
void f(int);
 
template&lt;&gt;
void f&lt;int&gt;(int);
 
class X
{
    friend void f&lt;int&gt;(int x = 1); // error: default args not allowed
};</pre></div> <p>A template friend declaration can name a member of a class template A, which can be either a member function or a member type (the type must use <a href="elaborated_type_specifier" title="cpp/language/elaborated type specifier">elaborated-type-specifier</a>). Such declaration is only well-formed if the last component in its nested-name-specifier (the name to the left of the last <code>::</code>) is a simple-template-id (template name followed by argument list in angle brackets) that names the class template. The template parameters of such template friend declaration must be deducible from the simple-template-id.</p>
<p>In this case, the member of any specialization of either A or partial specializations of A becomes a friend. This does not involve instantiating the primary template A or partial specializations of A: the only requirements are that the deduction of the template parameters of A from that specialization succeeds, and that substitution of the deduced template arguments into the friend declaration produces a declaration that would be a valid redeclaration of the member of the specialization:</p>
<div class="cpp source-cpp"><pre data-language="cpp">// primary template
template&lt;class T&gt;
struct A
{ 
    struct B {};
 
    void f();
 
    struct D { void g(); };
 
    T h();
 
    template&lt;T U&gt;
    T i();
};
 
// full specialization
template&lt;&gt;
struct A&lt;int&gt;
{
    struct B {};
 
    int f();
 
    struct D { void g(); };
 
    template&lt;int U&gt;
    int i();
};
 
// another full specialization
template&lt;&gt;
struct A&lt;float*&gt;
{
    int *h();
};
 
// the non-template class granting friendship to members of class template A
class X
{
    template&lt;class T&gt;
    friend struct A&lt;T&gt;::B; // all A&lt;T&gt;::B are friends, including A&lt;int&gt;::B
 
    template&lt;class T&gt;
    friend void A&lt;T&gt;::f(); // A&lt;int&gt;::f() is not a friend because its signature
                           // does not match, but e.g. A&lt;char&gt;::f() is a friend
 
//  template&lt;class T&gt;
//  friend void A&lt;T&gt;::D::g(); // ill-formed, the last part of the nested-name-specifier,
//                            // D in A&lt;T&gt;::D::, is not simple-template-id
 
    template&lt;class T&gt;
    friend int* A&lt;T*&gt;::h(); // all A&lt;T*&gt;::h are friends:
                            // A&lt;float*&gt;::h(), A&lt;int*&gt;::h(), etc
 
    template&lt;class T&gt; 
    template&lt;T U&gt;       // all instantiations of A&lt;T&gt;::i() and A&lt;int&gt;::i() are friends, 
    friend T A&lt;T&gt;::i(); // and thereby all specializations of those function templates
};</pre></div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p><a href="template_parameters#Default_template_arguments" title="cpp/language/template parameters">Default template arguments</a> are only allowed on template friend declarations if the declaration is a definition and no other declarations of this function template appear in this translation unit.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <h3 id="Template_friend_operators"> Template friend operators</h3> <p>A common use case for template friends is declaration of a non-member operator overload that acts on a class template, e.g. <code>operator<span class="sy1">&lt;&lt;</span><span class="br0">(</span><a href="http://en.cppreference.com/w/cpp/io/basic_ostream"><span class="kw1734">std::<span class="me2">ostream</span></span></a><span class="sy3">&amp;</span>, <span class="kw4">const</span> Foo<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy3">&amp;</span><span class="br0">)</span></code> for some user-defined <code>Foo&lt;T&gt;</code>.</p>
<p>Such operator can be defined in the class body, which has the effect of generating a separate non-template <code>operator&lt;&lt;</code> for each <code>T</code> and makes that non-template <code>operator&lt;&lt;</code> a friend of its <code>Foo&lt;T&gt;</code>:</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
 
template&lt;typename T&gt;
class Foo
{
public:
    Foo(const T&amp; val) : data(val) {}
private:
    T data;
 
    // generates a non-template operator&lt;&lt; for this T
    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Foo&amp; obj)
    {
        return os &lt;&lt; obj.data;
    }
};
 
int main()
{
    Foo&lt;double&gt; obj(1.23);
    std::cout &lt;&lt; obj &lt;&lt; '\n';
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">1.23</pre></div> </div> <p>or the function template has to be declared as a template before the class body, in which case the friend declaration within <code>Foo&lt;T&gt;</code> can refer to the full specialization of <code>operator&lt;&lt;</code> for its <code>T</code>:</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
 
template&lt;typename T&gt;
class Foo; // forward declare to make function declaration possible
 
template&lt;typename T&gt; // declaration
std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, const Foo&lt;T&gt;&amp;);
 
template&lt;typename T&gt;
class Foo
{
public:
    Foo(const T&amp; val) : data(val) {}
private:
    T data;
 
    // refers to a full specialization for this particular T 
    friend std::ostream&amp; operator&lt;&lt; &lt;&gt; (std::ostream&amp;, const Foo&amp;);
 
    // note: this relies on template argument deduction in declarations
    // can also specify the template argument with operator&lt;&lt; &lt;T&gt;"
};
 
// definition
template&lt;typename T&gt;
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Foo&lt;T&gt;&amp; obj)
{
    return os &lt;&lt; obj.data;
}
 
int main()
{
    Foo&lt;double&gt; obj(1.23);
    std::cout &lt;&lt; obj &lt;&lt; '\n';
}</pre></div> </div> <h3 id="Example"> Example</h3> <div class="t-example">
<p>Stream insertion and extraction operators are often declared as non-member friends:</p>
<div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
#include &lt;sstream&gt;
 
class MyClass
{
    int i;                   // friends have access to non-public, non-static
    static inline int id{6}; // and static (possibly inline) members
 
    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const MyClass&amp;);
    friend std::istream&amp; operator&gt;&gt;(std::istream&amp; in, MyClass&amp;);
    friend void change_id(int);
public:
    MyClass(int i = 0) : i(i) {}
};
 
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const MyClass&amp; mc)
{
    return out &lt;&lt; "MyClass::id = " &lt;&lt; MyClass::id &lt;&lt; "; i = " &lt;&lt; mc.i;
}
 
std::istream&amp; operator&gt;&gt;(std::istream&amp; in, MyClass&amp; mc)
{
    return in &gt;&gt; mc.i;
}
 
void change_id(int id) { MyClass::id = id; }
 
int main()
{
    MyClass mc(7);
    std::cout &lt;&lt; mc &lt;&lt; '\n';
//  mc.i = 333*2;  // error: i is a private member
    std::istringstream("100") &gt;&gt; mc;
    std::cout &lt;&lt; mc &lt;&lt; '\n';
//  MyClass::id = 222*3;  // error: id is a private member
    change_id(9);
    std::cout &lt;&lt; mc &lt;&lt; '\n';
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">MyClass::id = 6; i = 7
MyClass::id = 6; i = 100
MyClass::id = 9; i = 100</pre></div> </div> <h3 id="Defect_reports"> Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th> DR </th> <th> Applied to </th> <th> Behavior as published </th> <th> Correct behavior </th>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/45.html">CWG 45</a> </td> <td> C++98 </td> <td> members of a class nested in a friend<br>class of <code>T</code> have no special access to <code>T</code> </td> <td> a nested class has the same<br>access as the enclosing class </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/500.html">CWG 500</a> </td> <td> C++98 </td> <td> friend class of <code>T</code> cannot inherit from private or<br>protected members of <code>T</code>, but its nested class can </td> <td> both can inherit<br>from such members </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1439.html">CWG 1439</a> </td> <td> C++98 </td> <td> the rule targeting friend declarations in non-local<br>classes did not cover template declarations </td> <td> covered </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1477.html">CWG 1477</a> </td> <td> C++98 </td> <td> a name first declared in a friend declaration within a class<br>or class template was not visible for lookup if the matching<br>declaration is provided in another namespace scope </td> <td> it is visible for<br>lookup in this case </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1804.html">CWG 1804</a> </td> <td> C++98 </td> <td> when a member of a class template is friended, the corresponding<br>member of specializations of partial specializations of the class<br>template was not a friend of the class granting friendship </td> <td> such members<br>are also friends </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2379.html">CWG 2379</a> </td> <td> C++11 </td> <td> friend declarations referring to full specializations<br>of function templates could be declared constexpr </td> <td> prohibited </td>
</tr>
</table> <h3 id="References"> References</h3>  <ul>
<li> C++23 standard (ISO/IEC 14882:2023): </li>
<ul>
<li> 11.8.4 Friends [class.friend] </li>
<li> 13.7.5 Friends [temp.friend] </li>
</ul>
<li> C++20 standard (ISO/IEC 14882:2020): </li>
<ul>
<li> 11.9.3 Friends [class.friend] </li>
<li> 13.7.4 Friends [temp.friend] </li>
</ul>
<li> C++17 standard (ISO/IEC 14882:2017): </li>
<ul>
<li> 14.3 Friends [class.friend] </li>
<li> 17.5.4 Friends [temp.friend] </li>
</ul>
<li> C++14 standard (ISO/IEC 14882:2014): </li>
<ul>
<li> 11.3 Friends [class.friend] </li>
<li> 14.5.4 Friends [temp.friend] </li>
</ul>
<li> C++11 standard (ISO/IEC 14882:2011): </li>
<ul>
<li> 11.3 Friends [class.friend] </li>
<li> 14.5.4 Friends [temp.friend] </li>
</ul>
<li> C++98 standard (ISO/IEC 14882:1998): </li>
<ul>
<li> 11.3 Friends [class.friend] </li>
<li> 14.5.3 Friends [temp.friend] </li>
</ul>
</ul>                             <h3 id="See_also"> See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <a href="class" title="cpp/language/class"> Class types </a> </td> <td> defines types holding several data members  </td>
</tr> <tr class="t-dsc"> <td> <a href="access" title="cpp/language/access"> Access specifiers </a> </td> <td> defines visibility of class members </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    © cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/language/friend" class="_attribution-link">https://en.cppreference.com/w/cpp/language/friend</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
