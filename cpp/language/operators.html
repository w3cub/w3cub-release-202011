
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Operator Overloading - C++ - W3cubDocs</title>
  
  <meta name="description" content=" Customizes the C++ operators for operands of user-defined types. ">
  <meta name="keywords" content="operator, overloading, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/language/operators.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/cpp.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _c">
				
				
<h1 id="firstHeading" class="firstHeading">operator overloading</h1>            <p>Customizes the C++ operators for operands of user-defined types.</p>
<h3 id="Syntax">Syntax</h3> <p>Overloaded operators are <a href="functions" title="cpp/language/functions">functions</a> with special function names:</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <code>operator</code> <span class="t-spar">op</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>operator</code> <span class="t-spar">type</span> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>operator</code> <code>new</code> <br> <code>operator</code> <code>new []</code> </td> <td> (3) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>operator</code> <code>delete</code> <br> <code>operator</code> <code>delete []</code> </td> <td> (4) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>operator</code> <code>""</code> <span class="t-spar">suffix-identifier</span> </td> <td> (5) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr> 
</table> <table class="t-par-begin"> <tr class="t-par"> <td> <span class="t-spar">op</span> </td> <td> - </td> <td> any of the following <span class="t-rev-inl t-until-cxx20"><span>38</span> <span><span class="t-mark-rev t-until-cxx20">(until C++20)</span></span></span><span class="t-rev-inl t-since-cxx20"><span>40</span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span> operators:<code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>%</code> <code>^</code> <code>&amp;</code> <code>|</code> <code>~</code> <code>!</code> <code>=</code> <code>&lt;</code> <code>&gt;</code> <code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code> <code>^=</code> <code>&amp;=</code> <code>|=</code> <code>&lt;&lt;</code> <code>&gt;&gt;</code> <code>&gt;&gt;=</code> <code>&lt;&lt;=</code> <code>==</code> <code>!=</code> <code>&lt;=</code> <code>&gt;=</code> <span class="t-rev-inl t-since-cxx20"><span><code>&lt;=&gt;</code></span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span> <code>&amp;&amp;</code> <code>||</code> <code>++</code> <code>--</code> <code>,</code> <code>-&gt;*</code> <code>-&gt;</code> <code>( )</code> <code>[ ]</code> <span class="t-rev-inl t-since-cxx20"><span>co_await</span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span> </td>
</tr>
</table> <div class="t-li1">
<span class="t-li">1)</span> overloaded operator;</div> <div class="t-li1">
<span class="t-li">2)</span> <a href="cast_operator" title="cpp/language/cast operator">user-defined conversion function</a>;</div> <div class="t-li1">
<span class="t-li">3)</span> <a href="../memory/new/operator_new" title="cpp/memory/new/operator new">allocation function</a>;</div> <div class="t-li1">
<span class="t-li">4)</span> <a href="../memory/new/operator_delete" title="cpp/memory/new/operator delete">deallocation function</a>;</div> <div class="t-li1">
<span class="t-li">5)</span> <a href="user_literal" title="cpp/language/user literal">user-defined literal</a>.</div> <h3 id="Overloaded_operators">Overloaded operators</h3> <p>When an operator appears in an <a href="expressions" title="cpp/language/expressions">expression</a>, and at least one of its operands has a <a href="class" title="cpp/language/class">class type</a> or an <a href="enum" title="cpp/language/enum">enumeration type</a>, then <a href="overload_resolution" title="cpp/language/overload resolution">overload resolution</a> is used to determine the user-defined function to be called among all the functions whose signatures match the following:</p>
<table class="wikitable"> <tr> <th> Expression </th> <th> As member function </th> <th> As non-member function </th> <th> Example </th>
</tr> <tr> <td> @a </td> <td> (a).operator@ ( ) </td> <td> operator@ (a) </td> <td> <code><span class="sy3">!</span><a href="../io/cin"><span class="kw1753">std::<span class="me2">cin</span></span></a></code> calls <code><a href="../io/cin"><span class="kw1753">std::<span class="me2">cin</span></span></a>.<span class="me1">operator</span><span class="sy3">!</span><span class="br0">(</span><span class="br0">)</span></code> </td>
</tr> <tr> <td> a@b </td> <td> (a).operator@ (b) </td> <td> operator@ (a, b) </td> <td> <code><a href="../io/cout"><span class="kw1755">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="nu0">42</span></code> calls <code><a href="../io/cout"><span class="kw1755">std::<span class="me2">cout</span></span></a>.<span class="me1">operator</span><span class="sy1">&lt;&lt;</span><span class="br0">(</span><span class="nu0">42</span><span class="br0">)</span></code> </td>
</tr> <tr> <td> a=b </td> <td> (a).operator= (b) </td> <td class="table-no"> cannot be non-member </td> <td> <code><a href="../string/basic_string"><span class="kw1227">std::<span class="me2">string</span></span></a> s<span class="sy4">;</span> s <span class="sy1">=</span> <span class="st0">"abc"</span><span class="sy4">;</span></code> calls <code>s.operator=("abc")</code> </td>
</tr> <tr> <td> a(b...) </td> <td> (a).operator()(b...) </td> <td class="table-no"> cannot be non-member </td> <td> <code><a href="../numeric/random/random_device"><span class="kw1483">std::<span class="me2">random_device</span></span></a> r<span class="sy4">;</span> <span class="kw4">auto</span> n <span class="sy1">=</span> r<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span></code> calls <code>r.operator()()</code> </td>
</tr> <tr> <td> a[b] </td> <td> (a).operator[](b) </td> <td class="table-no"> cannot be non-member </td> <td> <code><a href="../container/map"><span class="kw1278">std::<span class="me2">map</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span>, <span class="kw4">int</span><span class="sy1">&gt;</span> m<span class="sy4">;</span> m<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy1">=</span> <span class="nu0">2</span><span class="sy4">;</span></code> calls <code>m.operator[](1)</code> </td>
</tr> <tr> <td> a-&gt; </td> <td> (a).operator-&gt; ( ) </td> <td class="table-no"> cannot be non-member </td> <td> <code><span class="kw4">auto</span> p <span class="sy1">=</span> <a href="../memory/unique_ptr/make_unique"><span class="kw730">std::<span class="me2">make_unique</span></span></a><span class="sy1">&lt;</span>S<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> p<span class="sy2">-</span><span class="sy1">&gt;</span>bar<span class="br0">(</span><span class="br0">)</span></code> calls <code>p.operator-&gt;()</code> </td>
</tr> <tr> <td> a@ </td> <td> (a).operator@ (0) </td> <td> operator@ (a, 0) </td> <td> <code><a href="../container/vector"><span class="kw1266">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">iterator</span> i <span class="sy1">=</span> v.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> i<span class="sy2">++</span></code> calls <code>i.operator++(0)</code> </td>
</tr> <tr> <td colspan="4"> <p>in this table, <code>@</code> is a placeholder representing all matching operators: all prefix operators in @a, all postfix operators other than -&gt; in a@, all infix operators other than = in a@b.</p>
</td>
</tr>
</table> <p>Note: for overloading <a href="cast_operator" title="cpp/language/cast operator">user-defined conversion functions</a>, <a href="user_literal" title="cpp/language/user literal">user-defined literals</a>, <a href="../memory/new/operator_new" title="cpp/memory/new/operator new">allocation</a> and <a href="../memory/new/operator_delete" title="cpp/memory/new/operator delete">deallocation</a> see their respective articles.</p>
<p>Overloaded operators (but not the built-in operators) can be called using function notation:</p>
<div class="cpp source-cpp"><pre data-language="cpp">std::string str = "Hello, ";
str.operator+=("world");                       // same as str += "world";
operator&lt;&lt;(operator&lt;&lt;(std::cout, str) , '\n'); // same as std::cout &lt;&lt; str &lt;&lt; '\n';
                                               // (since C++17) except for sequencing</pre></div> <h3 id="Restrictions">Restrictions</h3> <ul>
<li> The operators <code>::</code> (scope resolution), <code>.</code> (member access), <code>.*</code> (member access through pointer to member), and <code>?:</code> (ternary conditional) cannot be overloaded. </li>
<li> New operators such as <code>**</code>, <code>&lt;&gt;</code>, or <code>&amp;|</code> cannot be created. </li>
<li> The overloads of operators <code>&amp;&amp;</code> and <code>||</code> lose short-circuit evaluation. </li>
<li> The overload of operator <code>-&gt;</code> must either return a raw pointer, or return an object (by reference or by value) for which operator <code>-&gt;</code> is in turn overloaded. </li>
<li> It is not possible to change the precedence, grouping, or number of operands of operators. </li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx17">
<td> <ul><li> <code>&amp;&amp;</code>, <code>||</code>, and <code>,</code> (comma) lose their special <a href="eval_order" title="cpp/language/eval order">sequencing properties</a> when overloaded and behave like regular function calls even when they are used without function-call notation.</li></ul>
</td> <td><span class="t-mark-rev t-until-cxx17">(until C++17)</span></td>
</tr> </table> <h3 id="Canonical_implementations">Canonical implementations</h3> <p>Other than the restrictions above, the language puts no other constraints on what the overloaded operators do, or on the return type (it does not participate in overload resolution), but in general, overloaded operators are expected to behave as similar as possible to the built-in operators: <code>operator+</code> is expected to add, rather than multiply its arguments, <code>operator=</code> is expected to assign, etc. The related operators are expected to behave similarly (<code>operator+</code> and <code>operator+=</code> do the same addition-like operation). The return types are limited by the expressions in which the operator is expected to be used: for example, assignment operators return by reference to make it possible to write <code>a = b = c = d</code>, because the built-in operators allow that.</p>
<p>Commonly overloaded operators have the following typical, canonical forms:<sup id="cite_ref-1" class="reference"><a href="operators#cite_note-1">[1]</a></sup></p>
<h4 id="Assignment_operator">Assignment operator</h4> <p>The assignment operator (<code>operator=</code>) has special properties: see <a href="as_operator" title="cpp/language/copy assignment">copy assignment</a> and <a href="move_operator" title="cpp/language/move assignment">move assignment</a> for details.</p>
<p>The canonical copy-assignment operator is expected to <a rel="nofollow" class="external text" href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#c62-make-copy-assignment-safe-for-self-assignment">perform no action on self-assignment</a>, and to return the lhs by reference:</p>
<div class="cpp source-cpp"><pre data-language="cpp">// assume the object holds reusable storage, such as a heap-allocated buffer mArray
T&amp; operator=(const T&amp; other) // copy assignment
{
    if (this != &amp;other) { // self-assignment check expected
        if (other.size != size) {         // storage cannot be reused
            delete[] mArray;              // destroy storage in this
            size = 0;
            mArray = nullptr;             // preserve invariants in case next line throws
            mArray = new int[other.size]; // create storage in this
            size = other.size;
        } 
        std::copy(other.mArray, other.mArray + other.size, mArray);
    }
    return *this;
}</pre></div> <p>The canonical move assignment is expected to <a rel="nofollow" class="external text" href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#c64-a-move-operation-should-move-and-leave-its-source-in-a-valid-state">leave the moved-from object in valid state</a> (that is, a state with class invariants intact), and either <a rel="nofollow" class="external text" href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#c65-make-move-assignment-safe-for-self-assignment">do nothing</a> or at least leave the object in a valid state on self-assignment, and return the lhs by reference to non-const, and be noexcept:</p>
<div class="cpp source-cpp"><pre data-language="cpp">T&amp; operator=(T&amp;&amp; other) noexcept // move assignment
{
    if(this != &amp;other) { // no-op on self-move-assignment (delete[]/size=0 also ok)
        delete[] mArray;                               // delete this storage
        mArray = std::exchange(other.mArray, nullptr); // leave moved-from in valid state
        size = std::exchange(other.size, 0);
    }
    return *this;
}</pre></div> <p>In those situations where copy assignment cannot benefit from resource reuse (it does not manage a heap-allocated array and does not have a (possibly transitive) member that does, such as a member <code><a href="../container/vector" title="cpp/container/vector">std::vector</a></code> or <code><a href="../string/basic_string" title="cpp/string/basic string">std::string</a></code>), there is a popular convenient shorthand: the copy-and-swap assignment operator, which takes its parameter by value (thus working as both copy- and move-assignment depending on the value category of the argument), swaps with the parameter, and lets the destructor clean it up.</p>
<div class="cpp source-cpp"><pre data-language="cpp">T&amp; T::operator=(T arg) noexcept // copy/move constructor is called to construct arg
{
    std::swap(size, arg.size); // resources are exchanged between *this and arg
    std::swap(mArray, arg.mArray);
    return *this;
} // destructor of arg is called to release the resources formerly held by *this</pre></div> <p>This form automatically provides <a href="exceptions" title="cpp/language/exceptions">strong exception guarantee</a>, but prohibits resource reuse.</p>
<h4 id="Stream_extraction_and_insertion">Stream extraction and insertion</h4> <p>The overloads of <code>operator&gt;&gt;</code> and <code>operator&lt;&lt;</code> that take a <code><a href="../io/basic_istream"><span class="kw1724">std::<span class="me2">istream</span></span></a><span class="sy3">&amp;</span></code> or <code><a href="../io/basic_ostream"><span class="kw1726">std::<span class="me2">ostream</span></span></a><span class="sy3">&amp;</span></code> as the left hand argument are known as insertion and extraction operators. Since they take the user-defined type as the right argument (<code>b</code> in <span class="t-spar">a@b</span>), they must be implemented as non-members.</p>
<div class="cpp source-cpp"><pre data-language="cpp">std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const T&amp; obj)
{
    // write obj to stream
    return os;
}
std::istream&amp; operator&gt;&gt;(std::istream&amp; is, T&amp; obj)
{
    // read obj from stream
    if( /* T could not be constructed */ )
        is.setstate(std::ios::failbit);
    return is;
}</pre></div> <p>These operators are sometimes implemented as <a href="friend" title="cpp/language/friend">friend functions</a>.</p>
<h4 id="Function_call_operator">Function call operator</h4> <p>When a user-defined class overloads the function call operator, <code>operator()</code>, it becomes a <a href="../named_req/functionobject" title="cpp/named req/FunctionObject">FunctionObject</a> type. Many standard algorithms, from <code><a href="../algorithm/sort"><span class="kw1615">std::<span class="me2">sort</span></span></a></code> to <code><a href="../algorithm/accumulate"><span class="kw1648">std::<span class="me2">accumulate</span></span></a></code> accept objects of such types to customize behavior. There are no particularly notable canonical forms of <code>operator()</code>, but to illustrate the usage.</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct Sum
{
    int sum;
    Sum() : sum(0) { }
    void operator()(int n) { sum += n; }
};
Sum s = std::for_each(v.begin(), v.end(), Sum());</pre></div> <h4 id="Increment_and_decrement">Increment and decrement</h4> <p>When the postfix increment and decrement appear in an expression, the corresponding user-defined function (<code>operator++</code> or <code>operator--</code>) is called with an integer argument <code>0</code>. Typically, it is implemented as <code>T operator++(int)</code>, where the argument is ignored. The postfix increment and decrement operator is usually implemented in terms of the prefix version:</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct X
{
    X&amp; operator++()
    {
        // actual increment takes place here
        return *this;
    }
    X operator++(int)
    {
        X tmp(*this); // copy
        operator++(); // pre-increment
        return tmp;   // return old value
    }
};</pre></div> <p>Although canonical form of pre-increment/pre-decrement returns a reference, as with any operator overload, the return type is user-defined; for example the overloads of these operators for <code><a href="../atomic/atomic" title="cpp/atomic/atomic">std::atomic</a></code> return by value.</p>
<h4 id="Binary_arithmetic_operators">Binary arithmetic operators</h4> <p>Binary operators are typically implemented as non-members to maintain symmetry (for example, when adding a complex number and an integer, if <code>operator+</code> is a member function of the complex type, then only <code>complex+integer</code> would compile, and not <code>integer+complex</code>). Since for every binary arithmetic operator there exists a corresponding compound assignment operator, canonical forms of binary operators are implemented in terms of their compound assignments:</p>
<div class="cpp source-cpp"><pre data-language="cpp">class X
{
 public:
  X&amp; operator+=(const X&amp; rhs) // compound assignment (does not need to be a member,
  {                           // but often is, to modify the private members)
    /* addition of rhs to *this takes place here */
    return *this; // return the result by reference
  }
 
  // friends defined inside class body are inline and are hidden from non-ADL lookup
  friend X operator+(X lhs,        // passing lhs by value helps optimize chained a+b+c
                     const X&amp; rhs) // otherwise, both parameters may be const references
  {
    lhs += rhs; // reuse compound assignment
    return lhs; // return the result by value (uses move constructor)
  }
};</pre></div> <h4 id="Relational_operators">Relational operators</h4> <p>Standard algorithms such as <code><a href="../algorithm/sort"><span class="kw1615">std::<span class="me2">sort</span></span></a></code> and containers such as <code><a href="../container/set"><span class="kw1274">std::<span class="me2">set</span></span></a></code> expect <code>operator&lt;</code> to be defined, by default, for the user-provided types, and expect it to implement strict weak ordering (thus satisfying the <a href="../named_req/compare" title="cpp/named req/Compare">Compare</a> requirements). An idiomatic way to implement strict weak ordering for a structure is to use lexicographical comparison provided by <code><a href="../utility/tuple/tie" title="cpp/utility/tuple/tie">std::tie</a></code>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct Record
{
    std::string name;
    unsigned int floor;
    double weight;
    friend bool operator&lt;(const Record&amp; l, const Record&amp; r)
    {
        return std::tie(l.name, l.floor, l.weight)
             &lt; std::tie(r.name, r.floor, r.weight); // keep the same order
    }
};</pre></div> <p>Typically, once <code>operator&lt;</code> is provided, the other relational operators are implemented in terms of <code>operator&lt;</code>.</p>
<div class="cpp source-cpp"><pre data-language="cpp">inline bool operator&lt; (const X&amp; lhs, const X&amp; rhs){ /* do actual comparison */ }
inline bool operator&gt; (const X&amp; lhs, const X&amp; rhs){ return rhs &lt; lhs; }
inline bool operator&lt;=(const X&amp; lhs, const X&amp; rhs){ return !(lhs &gt; rhs); }
inline bool operator&gt;=(const X&amp; lhs, const X&amp; rhs){ return !(lhs &lt; rhs); }</pre></div> <p>Likewise, the inequality operator is typically implemented in terms of <code>operator==</code>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">inline bool operator==(const X&amp; lhs, const X&amp; rhs){ /* do actual comparison */ }
inline bool operator!=(const X&amp; lhs, const X&amp; rhs){ return !(lhs == rhs); }</pre></div> <p>When three-way comparison (such as <code><a href="../string/byte/memcmp" title="cpp/string/byte/memcmp">std::memcmp</a></code> or <code><a href="../string/basic_string/compare" title="cpp/string/basic string/compare">std::string::compare</a></code>) is provided, all six relational operators may be expressed through that:</p>
<div class="cpp source-cpp"><pre data-language="cpp">inline bool operator==(const X&amp; lhs, const X&amp; rhs){ return cmp(lhs,rhs) == 0; }
inline bool operator!=(const X&amp; lhs, const X&amp; rhs){ return cmp(lhs,rhs) != 0; }
inline bool operator&lt; (const X&amp; lhs, const X&amp; rhs){ return cmp(lhs,rhs) &lt;  0; }
inline bool operator&gt; (const X&amp; lhs, const X&amp; rhs){ return cmp(lhs,rhs) &gt;  0; }
inline bool operator&lt;=(const X&amp; lhs, const X&amp; rhs){ return cmp(lhs,rhs) &lt;= 0; }
inline bool operator&gt;=(const X&amp; lhs, const X&amp; rhs){ return cmp(lhs,rhs) &gt;= 0; }</pre></div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>All six relational operators are automatically generated by the compiler if the three-way comparison operator <code>operator&lt;=&gt;</code> is defined, and that operator, in turn, is generated by the compiler if it is defined as defaulted:</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct Record
{
    std::string name;
    unsigned int floor;
    double weight;
    auto operator&lt;=&gt;(const Record&amp;) = default;
};
// records can now be compared with ==, !=, &lt;, &lt;=, &gt;, and &gt;=</pre></div> <p>See <a href="default_comparisons" title="cpp/language/default comparisons">default comparisons</a> for details.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <h4 id="Array_subscript_operator">Array subscript operator</h4> <p>User-defined classes that provide array-like access that allows both reading and writing typically define two overloads for <code>operator[]</code>: const and non-const variants:</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct T
{
          value_t&amp; operator[](std::size_t idx)       { return mVector[idx]; }
    const value_t&amp; operator[](std::size_t idx) const { return mVector[idx]; }
};</pre></div> <p>If the value type is known to be a built-in type, the const variant should return by value.</p>
<p>Where direct access to the elements of the container is not wanted or not possible or distinguishing between lvalue <code>c[i] = v;</code> and rvalue <code>v = c[i];</code> usage, operator[] may return a proxy. see for example <code><a href="../utility/bitset/operator_at" title="cpp/utility/bitset/operator at">std::bitset::operator[]</a></code>.</p>
<p>To provide multidimensional array access semantics, e.g. to implement a 3D array access <code>a[i][j][k] = x;</code>, operator[] has to return a reference to a 2D plane, which has to have its own operator[] which returns a reference to a 1D row, which has to have operator[] which returns a reference to the element. To avoid this complexity, some libraries opt for overloading <code>operator()</code> instead, so that 3D access expressions have the Fortran-like syntax <code>a(i, j, k) = x;</code></p>
<h4 id="Bitwise_arithmetic_operators">Bitwise arithmetic operators</h4> <p>User-defined classes and enumerations that implement the requirements of <a href="../named_req/bitmasktype" title="cpp/named req/BitmaskType">BitmaskType</a> are required to overload the bitwise arithmetic operators <code>operator&amp;</code>, <code>operator|</code>, <code>operator^</code>, <code>operator~</code>, <code>operator&amp;=</code>, <code>operator|=</code>, and <code>operator^=</code>, and may optionally overload the shift operators <code>operator&lt;&lt;</code> <code>operator&gt;&gt;</code>, <code>operator&gt;&gt;=</code>, and <code>operator&lt;&lt;=</code>. The canonical implementations usually follow the pattern for binary arithmetic operators described above.</p>
<h4 id="Boolean_negation_operator">Boolean negation operator</h4> <p>The operator <code>operator!</code> is commonly overloaded by the user-defined classes that are intended to be used in boolean contexts. Such classes also provide a user-defined conversion function <code>explicit operator bool()</code> (see <code><a href="../io/basic_ios" title="cpp/io/basic ios">std::basic_ios</a></code> for the standard library example), and the expected behavior of <code>operator!</code> is to return the value opposite of <code>operator bool</code>.</p>
<h4 id="Rarely_overloaded_operators">Rarely overloaded operators</h4> <p>The following operators are rarely overloaded:</p>
<ul>
<li> The address-of operator, <code>operator&amp;</code>. If the unary &amp; is applied to an lvalue of incomplete type and the complete type declares an overloaded <code>operator&amp;</code>, <span class="t-rev-inl t-until-cxx11"><span>the behavior is undefined</span> <span><span class="t-mark-rev t-until-cxx11">(until C++11)</span></span></span><span class="t-rev-inl t-since-cxx11"><span> it is unspecified whether the operator has the built-in meaning or the operator function is called</span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>. Because this operator may be overloaded, generic libraries use <code><a href="../memory/addressof" title="cpp/memory/addressof">std::addressof</a></code> to obtain addresses of objects of user-defined types. The best known example of a canonical overloaded operator&amp; is the Microsoft class <a rel="nofollow" class="external text" href="https://msdn.microsoft.com/en-us/library/31k6d0k7(v=vs.140).aspx">CComPtr</a>. An example of its use in EDSL can be found in <a rel="nofollow" class="external text" href="http://www.boost.org/doc/libs/release/libs/spirit/doc/html/spirit/qi/reference/operator/and_predicate.html">boost.spirit</a>. </li>
<li> The boolean logic operators, <code>operator&amp;&amp;</code> and <code>operator||</code>. Unlike the built-in versions, the overloads cannot implement short-circuit evaluation. <span class="t-rev-inl t-until-cxx17"><span>Also unlike the built-in versions, they do not sequence their left operand before the right one.</span> <span><span class="t-mark-rev t-until-cxx17">(until C++17)</span></span></span> In the standard library, these operators are only overloaded for <code><a href="../numeric/valarray" title="cpp/numeric/valarray">std::valarray</a></code>. </li>
<li> The comma operator, <code>operator,</code>. <span class="t-rev-inl t-until-cxx17"><span>Unlike the built-in version, the overloads do not sequence their left operand before the right one.</span> <span><span class="t-mark-rev t-until-cxx17">(until C++17)</span></span></span> Because this operator may be overloaded, generic libraries use expressions such as <code>a,void(),b</code> instead of <code>a,b</code> to sequence execution of expressions of user-defined types. The boost library uses <code>operator,</code> in <a rel="nofollow" class="external text" href="http://www.boost.org/doc/libs/release/libs/assign/doc/index.html#intro">boost.assign</a>, <a rel="nofollow" class="external text" href="https://github.com/boostorg/spirit/blob/develop/include/boost/spirit/home/qi/string/symbols.hpp#L317">boost.spirit</a>, and other libraries. The database access library <a rel="nofollow" class="external text" href="http://soci.sourceforge.net/doc.html">SOCI</a> also overloads <code>operator,</code>. </li>
<li> The member access through pointer to member <code>operator-&gt;*</code>. There are no specific downsides to overloading this operator, but it is rarely used in practice. It was suggested that it could be part of <a rel="nofollow" class="external text" href="http://www.aristeia.com/Papers/DDJ_Oct_1999.pdf">smart pointer interface</a>, and in fact is used in that capacity by actors in <a rel="nofollow" class="external text" href="http://www.boost.org/doc/libs/release/libs/phoenix/doc/html/phoenix/modules/operator.html#phoenix.modules.operator.member_pointer_operator">boost.phoenix</a>. It is more common in EDSLs such as <a rel="nofollow" class="external text" href="https://github.com/schlangster/cpp.react/blob/master/include/react/Signal.h#L557">cpp.react</a>. </li>
</ul> <h3 id="Example">Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
 
class Fraction
{
    int gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); }
    int n, d;
public:
    Fraction(int n, int d = 1) : n(n/gcd(n, d)), d(d/gcd(n, d)) { }
    int num() const { return n; }
    int den() const { return d; }
    Fraction&amp; operator*=(const Fraction&amp; rhs)
    {
        int new_n = n * rhs.n/gcd(n * rhs.n, d * rhs.d);
        d = d * rhs.d/gcd(n * rhs.n, d * rhs.d);
        n = new_n;
        return *this;
    }
};
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f)
{
   return out &lt;&lt; f.num() &lt;&lt; '/' &lt;&lt; f.den() ;
}
bool operator==(const Fraction&amp; lhs, const Fraction&amp; rhs)
{
    return lhs.num() == rhs.num() &amp;&amp; lhs.den() == rhs.den();
}
bool operator!=(const Fraction&amp; lhs, const Fraction&amp; rhs)
{
    return !(lhs == rhs);
}
Fraction operator*(Fraction lhs, const Fraction&amp; rhs)
{
    return lhs *= rhs;
}
 
int main()
{
   Fraction f1(3, 8), f2(1, 2), f3(10, 2);
   std::cout &lt;&lt; f1 &lt;&lt; " * " &lt;&lt; f2 &lt;&lt; " = " &lt;&lt; f1 * f2 &lt;&lt; '\n'
             &lt;&lt; f2 &lt;&lt; " * " &lt;&lt; f3 &lt;&lt; " = " &lt;&lt; f2 * f3 &lt;&lt; '\n'
             &lt;&lt;  2 &lt;&lt; " * " &lt;&lt; f1 &lt;&lt; " = " &lt;&lt;  2 * f1 &lt;&lt; '\n';
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">3/8 * 1/2 = 3/16
1/2 * 5/1 = 5/2
2 * 3/8 = 3/4</pre></div> </div> <h3 id="Defect_reports">Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th> DR </th> <th> Applied to </th> <th> Behavior as published </th> <th> Correct behavior </th>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://wg21.link/cwg1458">CWG 1458</a> </td> <td> C++11 </td> <td> taking address of incomplete type that overloads address-of was undefined behavior </td> <td> the behavior is only unspecified </td>
</tr>
</table> <h3 id="See_Also">See Also</h3> <ul>
<li> <a href="operator_precedence" title="cpp/language/operator precedence"> Operator precedence</a> </li>
<li> <a href="operator_alternative" title="cpp/language/operator alternative"> Alternative operator syntax</a> </li>
</ul> <table class="wikitable"> <tr style="text-align:center"> <th colspan="7"> Common operators </th>
</tr> <tr style="text-align:center"> <td> <a href="operator_assignment" title="cpp/language/operator assignment"> assignment</a> </td> <td> <a href="operator_incdec" title="cpp/language/operator incdec"> increment<br>decrement</a> </td> <td> <a href="operator_arithmetic" title="cpp/language/operator arithmetic"> arithmetic</a> </td> <td> <a href="operator_logical" title="cpp/language/operator logical"> logical</a> </td> <td> <a href="operator_comparison" title="cpp/language/operator comparison"> comparison</a> </td> <td> <a href="operator_member_access" title="cpp/language/operator member access"> member<br>access</a> </td> <td> <a href="operator_other" title="cpp/language/operator other"> other</a> </td>
</tr> <tr style="text-align:center"> <td> <p><code>a = b a += b a -= b a *= b a /= b a %= b a &amp;= b a |= b a ^= b a &lt;&lt;= b a &gt;&gt;= b</code>.</p>
</td> <td> <p><code>++a --a a++ a--</code></p>
</td> <td> <p><code>+a -a a + b a - b a * b a / b a % b ~a a &amp; b a | b a ^ b a &lt;&lt; b a &gt;&gt; b</code>.</p>
</td> <td> <p><code>!a a &amp;&amp; b a || b</code>.</p>
</td> <td> <p><code>a == b a != b a &lt; b a &gt; b a &lt;= b a &gt;= b a &lt;=&gt; b</code>.</p>
</td> <td> <p><code>a[b] *a &amp;a a-&gt;b a.b a-&gt;*b a.*b</code>.</p>
</td> <td> <p><code>a(...) a, b ? :</code></p>
</td>
</tr> <tr> <th colspan="7"> Special operators </th>
</tr> <tr> <td colspan="7"> <p><a href="static_cast" title="cpp/language/static cast"><code>static_cast</code></a> converts one type to another related type <br> <a href="dynamic_cast" title="cpp/language/dynamic cast"><code>dynamic_cast</code></a> converts within inheritance hierarchies <br> <a href="const_cast" title="cpp/language/const cast"><code>const_cast</code></a> adds or removes <a href="cv" title="cpp/language/cv">cv</a> qualifiers<br> <a href="reinterpret_cast" title="cpp/language/reinterpret cast"><code>reinterpret_cast</code></a> converts type to unrelated type<br> <a href="explicit_cast" title="cpp/language/explicit cast">C-style cast</a> converts one type to another by a mix of <code>static_cast</code>, <code>const_cast</code>, and <code>reinterpret_cast</code> <br> <a href="new" title="cpp/language/new"><code>new</code></a> creates objects with dynamic storage duration<br> <a href="delete" title="cpp/language/delete"><code>delete</code></a> destructs objects previously created by the new expression and releases obtained memory area<br> <a href="sizeof" title="cpp/language/sizeof"><code>sizeof</code></a> queries the size of a type<br> <a href="sizeof..." title="cpp/language/sizeof..."><code>sizeof...</code></a> queries the size of a <a href="parameter_pack" title="cpp/language/parameter pack">parameter pack</a> <span class="t-mark-rev t-since-cxx11">(since C++11)</span><br> <a href="typeid" title="cpp/language/typeid"><code>typeid</code></a> queries the type information of a type<br> <a href="noexcept" title="cpp/language/noexcept"><code>noexcept</code></a> checks if an expression can throw an exception <span class="t-mark-rev t-since-cxx11">(since C++11)</span><br> <a href="alignof" title="cpp/language/alignof"><code>alignof</code></a> queries alignment requirements of a type <span class="t-mark-rev t-since-cxx11">(since C++11)</span>.</p>
</td>
</tr>
</table> <h3 id="References">References</h3> <ol class="references"> <li id="cite_note-1"> <span class="reference-text"><a rel="nofollow" class="external text" href="http://stackoverflow.com/questions/4421706/operator-overloading/4421708#4421708">Operator Overloading</a> on StackOverflow C++ FAQ</span> </li> </ol>          <div class="_attribution">
  <p class="_attribution-p">
    Â© cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/language/operators" class="_attribution-link">http://en.cppreference.com/w/cpp/language/operators</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
