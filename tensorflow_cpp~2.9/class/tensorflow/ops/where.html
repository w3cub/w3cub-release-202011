
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>tensorflow&#58;&#58;ops&#58;&#58;Where - TensorFlow C++ 2.9 - W3cubDocs</title>
  
  <meta name="description" content=" #include &#60;array_ops.h&#62; ">
  <meta name="keywords" content="tensorflow, ops, where&#39;t&#39;, is, shape, tensor, &#39;t&#39;, has, pass, &#39;, flatten, &#39;t&#39;-, can, also, be, used, infer, shape-, inferred, reshapes, scalargiven, this, then, slices, input, are, reversed, on, seq, dim, only, up, lengths, while, entries, past, lens, copied, through, given, &#39;dims&#39;, or, &#39;x&#39;, represent, hypothetical, indices, for, each, entry, from, &#39;indices&#39;, operation, returnsits, coordinates, marked, with, &#39;&#42;&#39;, such, &#39;input&#39;, true, false, two, values, so, output, rank, have, three, nonzero, +, j, magnitude, where, c++, tensorflow_cpp~2.9">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/tensorflow_cpp~2.9/class/tensorflow/ops/where.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-f16eecbe420d8b2925d31ffbb21d05646497ecbd9515f08ffe69e9bba7332f5657accc7003c7f6c72cb4a132171acf171b359ae3bae4ae5660ddfb1718f88c67.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/tensorflow_cpp~2.9.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/tensorflow_cpp~2.9/" class="_nav-link" title="" style="margin-left:0;">TensorFlow C++ 2.9</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _tensorflow">
				
				
<devsite-bookmark></devsite-bookmark>   <devsite-mathjax config="TeX-AMS-MML_SVG"></devsite-mathjax>  <h1 id="tensorflow::ops::where" data-text="tensorflow::ops::Where">tensorflow::ops::Where</h1> <p><code translate="no" dir="ltr">#include &lt;array_ops.h&gt;</code></p> <p>Reshapes a quantized tensor as per the Reshape op. </p> <h2 id="summary" data-text="Summary">Summary</h2> 
 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Args:
* scope: A Scope object
* shape: Defines the shape of the output tensor.
* input_min: The minimum value of the input.
* input_max: The maximum value of the input.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">    Returns:
    * `Output` output
    * `Output` output_min: This value is copied from input_min.
    * `Output` output_max: This value is copied from input_max. */
class QuantizedReshape {
 public:
  QuantizedReshape(const tensorflow::Scope&amp; scope, tensorflow::Input tensor,
                 tensorflow::Input shape, tensorflow::Input input_min,
                 tensorflow::Input input_max);</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Operation operation;
  tensorflow::Output output;
  tensorflow::Output output_min;
  tensorflow::Output output_max;
};</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/** Returns the rank of a tensor.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">This operation returns an integer representing the rank of `input`.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">For example:</pre> 
 <h1 id="t-is-[[[1,-1,-1],-[2,-2,-2]],-[[3,-3,-3],-[4,-4,-4]]]" data-text="'t' is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]">'t' is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]</h1> 
<h1 id="shape-of-tensor-t-is-[2,-2,-3]" data-text="shape of tensor 't' is [2, 2, 3]">shape of tensor 't' is [2, 2, 3]</h1> <p>rank(t) ==&gt; 3 </p>
 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">**Note**: The rank of a tensor is not the same as the rank of a matrix. The rank
of a tensor is the number of indices required to uniquely select each element
of the tensor. Rank is also known as "order", "degree", or "ndims."</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Args:
* scope: A Scope object</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">    Returns:
    * `Output`: The output tensor. */
class Rank {
 public:
  Rank(const ::tensorflow::Scope&amp; scope, ::tensorflow::Input input);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/** Reshapes a tensor.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Given `tensor`, this operation returns a tensor that has the same values
as `tensor` with shape `shape`.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">If one component of 1-D tensor `shape` is the special value -1, the size of that
dimension is computed so that the total size remains constant.  In particular, a
`shape` of `[-1]` flattens into 1-D.  At most one component of `shape` may be
unknown.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">The `shape` must be 1-D and the operation returns a tensor with shape
`shape` filled with the values of `tensor`. In this case, the number of elements
implied by `shape` must be the same as the number of elements in `tensor`.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">It is an error if `shape` is not 1-D.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">For example:</pre> 
 <h1 id="tensor-t-is-[1,-2,-3,-4,-5,-6,-7,-8,-9]" data-text="tensor 't' is [1, 2, 3, 4, 5, 6, 7, 8, 9]">tensor 't' is [1, 2, 3, 4, 5, 6, 7, 8, 9]</h1> 
<h1 id="tensor-t-has-shape-[9]" data-text="tensor 't' has shape [9]">tensor 't' has shape [9]</h1> <p>reshape(t, [3, 3]) ==&gt; [[1, 2, 3], [4, 5, 6], [7, 8, 9]]</p> 
<h1 id="tensor-t-is-[[[1,-1],-[2,-2]]," data-text="tensor 't' is [[[1, 1], [2, 2]],">tensor 't' is [[[1, 1], [2, 2]],</h1> 
<h1 id="[[3,-3],-[4,-4]]]" data-text="[[3, 3], [4, 4]]]">[[3, 3], [4, 4]]]</h1> 
<h1 id="tensor-t-has-shape-[2,-2,-2]" data-text="tensor 't' has shape [2, 2, 2]">tensor 't' has shape [2, 2, 2]</h1> <p>reshape(t, [2, 4]) ==&gt; [[1, 1, 2, 2], [3, 3, 4, 4]]</p> 
<h1 id="tensor-t-is-[[[1,-1,-1]," data-text="tensor 't' is [[[1, 1, 1],">tensor 't' is [[[1, 1, 1],</h1> 
<h1 id="[2,-2,-2]]," data-text="[2, 2, 2]],">[2, 2, 2]],</h1> 
<h1 id="[[3,-3,-3]," data-text="[[3, 3, 3],">[[3, 3, 3],</h1> 
<h1 id="[4,-4,-4]]," data-text="[4, 4, 4]],">[4, 4, 4]],</h1> 
<h1 id="[[5,-5,-5]," data-text="[[5, 5, 5],">[[5, 5, 5],</h1> 
<h1 id="[6,-6,-6]]]" data-text="[6, 6, 6]]]">[6, 6, 6]]]</h1> 
<h1 id="tensor-t-has-shape-[3,-2,-3]" data-text="tensor 't' has shape [3, 2, 3]">tensor 't' has shape [3, 2, 3]</h1> 
<h1 id="pass-[-1]-to-flatten-t" data-text="pass '[-1]' to flatten 't'">pass '[-1]' to flatten 't'</h1> <p>reshape(t, [-1]) ==&gt; [1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6]</p> 
<h1 id="-1-can-also-be-used-to-infer-the-shape" data-text="-1 can also be used to infer the shape">-1 can also be used to infer the shape</h1> 
<h1 id="-1-is-inferred-to-be-9:" data-text="-1 is inferred to be 9:">-1 is inferred to be 9:</h1> <p>reshape(t, [2, -1]) ==&gt; [[1, 1, 1, 2, 2, 2, 3, 3, 3], [4, 4, 4, 5, 5, 5, 6, 6, 6]] </p>
<h1 id="-1-is-inferred-to-be-2:" data-text="-1 is inferred to be 2:">-1 is inferred to be 2:</h1> <p>reshape(t, [-1, 9]) ==&gt; [[1, 1, 1, 2, 2, 2, 3, 3, 3], [4, 4, 4, 5, 5, 5, 6, 6, 6]] </p>
<h1 id="-1-is-inferred-to-be-3:" data-text="-1 is inferred to be 3:">-1 is inferred to be 3:</h1> <p>reshape(t, [ 2, -1, 3]) ==&gt; [[[1, 1, 1], [2, 2, 2], [3, 3, 3]], [[4, 4, 4], [5, 5, 5], [6, 6, 6]]]</p> 
<h1 id="tensor-t-is-[7]" data-text="tensor 't' is [7]">tensor 't' is [7]</h1> 
<h1 id="shape-[]-reshapes-to-a-scalar" data-text="shape [] reshapes to a scalar">shape <code translate="no" dir="ltr">[]</code> reshapes to a scalar</h1> <p>reshape(t, []) ==&gt; 7 </p>
 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Args:
* scope: A Scope object
* shape: Defines the shape of the output tensor.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">    Returns:
    * `Output`: The output tensor. */
class Reshape {
 public:
  Reshape(const tensorflow::Scope&amp; scope, tensorflow::Input tensor,
        tensorflow::Input shape);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/** Assign `value` to the sliced l-value reference of `ref`.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">The values of `value` are assigned to the positions in the variable
`ref` that are selected by the slice parameters. The slice parameters
`begin, `end`, `strides`, etc. work exactly as in `StridedSlice`.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">NOTE this op currently does not support broadcasting and so `value`'s
shape must be exactly the shape produced by the slice of `ref`.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Args:
* scope: A Scope object</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">    Returns:
    * the created `Operation` */
class ResourceStridedSliceAssign {
 public:
  /// Optional attribute setters for ResourceStridedSliceAssign
  struct Attrs {
    /// Defaults to 0
    TF_MUST_USE_RESULT Attrs BeginMask(int64 x) {
      Attrs ret = *this;
      ret.begin_mask_ = x;
      return ret;
    }</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/// Defaults to 0
TF_MUST_USE_RESULT Attrs EndMask(int64 x) {
  Attrs ret = *this;
  ret.end_mask_ = x;
  return ret;
}</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/// Defaults to 0
TF_MUST_USE_RESULT Attrs EllipsisMask(int64 x) {
  Attrs ret = *this;
  ret.ellipsis_mask_ = x;
  return ret;
}</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/// Defaults to 0
TF_MUST_USE_RESULT Attrs NewAxisMask(int64 x) {
  Attrs ret = *this;
  ret.new_axis_mask_ = x;
  return ret;
}</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/// Defaults to 0
TF_MUST_USE_RESULT Attrs ShrinkAxisMask(int64 x) {
  Attrs ret = *this;
  ret.shrink_axis_mask_ = x;
  return ret;
}</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">  int64 begin_mask_ = 0;
  int64 end_mask_ = 0;
  int64 ellipsis_mask_ = 0;
  int64 new_axis_mask_ = 0;
  int64 shrink_axis_mask_ = 0;
};
ResourceStridedSliceAssign(const tensorflow::Scope&amp; scope,
                         tensorflow::Input ref, tensorflow::Input begin,
                         tensorflow::Input end, tensorflow::Input
                         strides, tensorflow::Input value);
ResourceStridedSliceAssign(const tensorflow::Scope&amp; scope,
                         tensorflow::Input ref, tensorflow::Input begin,
                         tensorflow::Input end, tensorflow::Input
                         strides, tensorflow::Input value, const
                         ResourceStridedSliceAssign::Attrs&amp; attrs);
operator ::tensorflow::Operation() const { return operation; }</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">static Attrs BeginMask(int64 x) {
  return Attrs().BeginMask(x);
}
static Attrs EndMask(int64 x) {
  return Attrs().EndMask(x);
}
static Attrs EllipsisMask(int64 x) {
  return Attrs().EllipsisMask(x);
}
static Attrs NewAxisMask(int64 x) {
  return Attrs().NewAxisMask(x);
}
static Attrs ShrinkAxisMask(int64 x) {
  return Attrs().ShrinkAxisMask(x);
}</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Operation operation;
};</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/** Reverses variable length slices.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">This op first slices `input` along the dimension `batch_dim`, and for each
slice `i`, reverses the first `seq_lengths[i]` elements along
the dimension `seq_dim`.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">The elements of `seq_lengths` must obey `seq_lengths[i] &lt;= input.dims[seq_dim]`,
and `seq_lengths` must be a vector of length `input.dims[batch_dim]`.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">The output slice `i` along dimension `batch_dim` is then given by input
slice `i`, with the first `seq_lengths[i]` slices along dimension
`seq_dim` reversed.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">For example:</pre> 
 <h1 id="given-this:" data-text="Given this:">Given this:</h1> <p>batch_dim = 0 seq_dim = 1 input.dims = (4, 8, ...) seq_lengths = [7, 2, 3, 5]</p> 
<h1 id="then-slices-of-input-are-reversed-on-seq_dim,-but-only-up-to-seq_lengths:" data-text="then slices of input are reversed on seq_dim, but only up to seq_lengths:">then slices of input are reversed on seq_dim, but only up to seq_lengths:</h1> <p>output[0, 0:7, :, ...] = input[0, 7:0:-1, :, ...] output[1, 0:2, :, ...] = input[1, 2:0:-1, :, ...] output[2, 0:3, :, ...] = input[2, 3:0:-1, :, ...] output[3, 0:5, :, ...] = input[3, 5:0:-1, :, ...]</p> 
<h1 id="while-entries-past-seq_lens-are-copied-through:" data-text="while entries past seq_lens are copied through:">while entries past seq_lens are copied through:</h1> <p>output[0, 7:, :, ...] = input[0, 7:, :, ...] output[1, 2:, :, ...] = input[1, 2:, :, ...] output[2, 3:, :, ...] = input[2, 3:, :, ...] output[3, 2:, :, ...] = input[3, 2:, :, ...] </p>
 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">In contrast, if:</pre> 
 <h1 id="given-this:_1" data-text="Given this:">Given this:</h1> <p>batch_dim = 2 seq_dim = 0 input.dims = (8, ?, 4, ...) seq_lengths = [7, 2, 3, 5]</p> 
<h1 id="then-slices-of-input-are-reversed-on-seq_dim,-but-only-up-to-seq_lengths:_1" data-text="then slices of input are reversed on seq_dim, but only up to seq_lengths:">then slices of input are reversed on seq_dim, but only up to seq_lengths:</h1> <p>output[0:7, :, 0, :, ...] = input[7:0:-1, :, 0, :, ...] output[0:2, :, 1, :, ...] = input[2:0:-1, :, 1, :, ...] output[0:3, :, 2, :, ...] = input[3:0:-1, :, 2, :, ...] output[0:5, :, 3, :, ...] = input[5:0:-1, :, 3, :, ...]</p> 
<h1 id="while-entries-past-seq_lens-are-copied-through:_1" data-text="while entries past seq_lens are copied through:">while entries past seq_lens are copied through:</h1> <p>output[7:, :, 0, :, ...] = input[7:, :, 0, :, ...] output[2:, :, 1, :, ...] = input[2:, :, 1, :, ...] output[3:, :, 2, :, ...] = input[3:, :, 2, :, ...] output[2:, :, 3, :, ...] = input[2:, :, 3, :, ...] </p>
 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Args:
* scope: A Scope object
* input: The input to reverse.
* seq_lengths: 1-D with length `input.dims(batch_dim)` and
`max(seq_lengths) &lt;= input.dims(seq_dim)`
* seq_dim: The dimension which is partially reversed.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Optional attributes (see `Attrs`):
* batch_dim: The dimension along which reversal is performed.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">    Returns:
    * `Output`: The partially reversed input. It has the same shape as `input`. */
class ReverseSequence {
 public:
  /// Optional attribute setters for ReverseSequence
  struct Attrs {
    /** The dimension along which reversal is performed.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">    Defaults to 0 */
TF_MUST_USE_RESULT Attrs BatchDim(int64 x) {
  Attrs ret = *this;
  ret.batch_dim_ = x;
  return ret;
}</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">  int64 batch_dim_ = 0;
};
ReverseSequence(const tensorflow::Scope&amp; scope, tensorflow::Input input,
              tensorflow::Input seq_lengths, int64 seq_dim);
ReverseSequence(const tensorflow::Scope&amp; scope, tensorflow::Input input,
              tensorflow::Input seq_lengths, int64 seq_dim, const
              ReverseSequence::Attrs&amp; attrs);
operator ::tensorflow::Output() const { return output; }
operator ::tensorflow::Input() const { return output; }
::tensorflow::Node* node() const { return output.node(); }</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">static Attrs BatchDim(int64 x) {
  return Attrs().BatchDim(x);
}</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/** Reverses specific dimensions of a tensor.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Given a `tensor`, and a `int32` tensor `axis` representing the set of
dimensions of `tensor` to reverse. This operation reverses each dimension
`i` for which there exists `j` s.t. `axis[j] == i`.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">`tensor` can have up to 8 dimensions. The number of dimensions specified
in `axis` may be 0 or more entries. If an index is specified more than
once, a InvalidArgument error is raised.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">For example:</pre> 
 <h1 id="tensor-t-is-[[[[-0,-1,-2,-3]," data-text="tensor 't' is [[[[ 0, 1, 2, 3],">tensor 't' is [[[[ 0, 1, 2, 3],</h1> 
<h1 id="[-4,-5,-6,-7]," data-text="[ 4, 5, 6, 7],">[ 4, 5, 6, 7],</h1> 
<h1 id="[-8,-9,-10,-11]]," data-text="[ 8, 9, 10, 11]],">[ 8, 9, 10, 11]],</h1> 
<h1 id="[[12,-13,-14,-15]," data-text="[[12, 13, 14, 15],">[[12, 13, 14, 15],</h1> 
<h1 id="[16,-17,-18,-19]," data-text="[16, 17, 18, 19],">[16, 17, 18, 19],</h1> 
<h1 id="[20,-21,-22,-23]]]]" data-text="[20, 21, 22, 23]]]]">[20, 21, 22, 23]]]]</h1> 
<h1 id="tensor-t-shape-is-[1,-2,-3,-4]" data-text="tensor 't' shape is [1, 2, 3, 4]">tensor 't' shape is [1, 2, 3, 4]</h1> 
<h1 id="dims-is-[3]-or-dims-is-[-1]" data-text="'dims' is [3] or 'dims' is [-1]">'dims' is [3] or 'dims' is [-1]</h1> <p>reverse(t, dims) ==&gt; [[[[ 3, 2, 1, 0], [ 7, 6, 5, 4], [ 11, 10, 9, 8]], [[15, 14, 13, 12], [19, 18, 17, 16], [23, 22, 21, 20]]]]</p> 
<h1 id="dims-is-[1]-or-dims-is-[-3]" data-text="'dims' is '[1]' (or 'dims' is '[-3]')">'dims' is '[1]' (or 'dims' is '[-3]')</h1> <p>reverse(t, dims) ==&gt; [[[[12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23] [[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]]]</p> 
<h1 id="dims-is-[2]-or-dims-is-[-2]" data-text="'dims' is '[2]' (or 'dims' is '[-2]')">'dims' is '[2]' (or 'dims' is '[-2]')</h1> <p>reverse(t, dims) ==&gt; [[[[8, 9, 10, 11], [4, 5, 6, 7], [0, 1, 2, 3]] [[20, 21, 22, 23], [16, 17, 18, 19], [12, 13, 14, 15]]]] </p>
 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Args:
* scope: A Scope object
* tensor: Up to 8-D.
* axis: 1-D. The indices of the dimensions to reverse. Must be in the range
`[-rank(tensor), rank(tensor))`.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">    Returns:
    * `Output`: The same shape as `tensor`. */
class Reverse {
 public:
  Reverse(const tensorflow::Scope&amp; scope, tensorflow::Input tensor,
        tensorflow::Input axis);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/** Scatters `updates` into a tensor of shape `shape` according to `indices`.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Update the input tensor by scattering sparse `updates` according to individual values at the specified `indices`.
This op returns an `output` tensor with the `shape` you specify. This op is the
inverse of the tf.gather_nd operator which extracts values or slices from a
given tensor.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">This operation is similar to tf.tensor_scatter_nd_add, except that the tensor
is zero-initialized. Calling tf.scatter_nd(indices, values, shape)
is identical to calling
`tf.tensor_scatter_nd_add(tf.zeros(shape, values.dtype), indices, values)`</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">If `indices` contains duplicates, the duplicate `values` are accumulated
(summed).</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">**WARNING**: The order in which updates are applied is nondeterministic, so the
output will be nondeterministic if `indices` contains duplicates;
numbers summed in different order may yield different results because of some
numerical approximation issues.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">`indices` is an integer tensor of shape `shape`. The last dimension
of `indices` can be at most the rank of `shape`:</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">indices.shape[-1] &lt;= shape.rank</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">The last dimension of `indices` corresponds to indices of elements
(if `indices.shape[-1] = shape.rank`) or slices
(if `indices.shape[-1] &lt; shape.rank`) along dimension `indices.shape[-1]` of
`shape`.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">`updates` is a tensor with shape:</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">indices.shape[:-1] + shape[indices.shape[-1]:]</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">The simplest form of the scatter op is to insert individual elements in
a tensor by index. Consider an example where you want to insert 4 scattered
elements in a rank-1 tensor with 8 elements.</pre> 
 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">In Python, this scatter operation would look like this:</pre> 
python indices = tf.constant([[4], [3], [1], [7]]) updates = tf.constant([9, 10, 11, 12]) shape = tf.constant([8]) scatter = tf.scatter_nd(indices, updates, shape) print(scatter)  
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">The resulting tensor would look like this:</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">[0, 11, 0, 10, 9, 0, 0, 12]</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">You can also insert entire slices of a higher rank tensor all at once. For
example, you can insert two slices in the first dimension of a rank-3 tensor
with two matrices of new values.</pre> 
 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">In Python, this scatter operation would look like this:</pre> 
python indices = tf.constant([[0], [2]]) updates = tf.constant([[[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]], [[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]]]) shape = tf.constant([4, 4, 4]) scatter = tf.scatter_nd(indices, updates, shape) print(scatter)  
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">The resulting tensor would look like this:</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">[[[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]],
 [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]],
 [[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]],
 [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]]</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Note that on CPU, if an out of bound index is found, an error is returned.
On GPU, if an out of bound index is found, the index is ignored.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Args:
* scope: A Scope object
* indices: Tensor of indices.
* updates: Values to scatter into the output tensor.
* shape: 1-D. The shape of the output tensor.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">    Returns:
    * `Output`: A new tensor with the given shape and updates applied according
    to the indices. */
class ScatterNd {
 public:
  ScatterNd(const tensorflow::Scope&amp; scope, tensorflow::Input indices,
          tensorflow::Input updates, tensorflow::Input shape);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/** Applies sparse addition to `input` using individual values or slices</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">from `updates` according to indices `indices`.  The updates are non-aliasing:
`input` is only modified in-place if no other operations will use it.
Otherwise, a copy of `input` is made.  This operation has a gradient with
respect to both `input` and `updates`.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">`input` is a `Tensor` with rank `P` and `indices` is a `Tensor` of rank `Q`.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">`indices` must be integer tensor, containing indices into `input`.
It must be shape \([d_0, ..., d_{Q-2}, K]\) where `0 &lt; K &lt;= P`.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">The innermost dimension of `indices` (with length `K`) corresponds to
indices into elements (if `K = P`) or `(P-K)`-dimensional slices
(if `K &lt; P`) along the `K`th dimension of `input`.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">`updates` is `Tensor` of rank `Q-1+P-K` with shape:</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">$$[d_0, ..., d_{Q-2}, input.shape[K], ..., input.shape[P-1]].$$</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">For example, say we want to add 4 scattered elements to a rank-1 tensor to 8
elements. In Python, that addition would look like this:</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">input = tf.constant([1, 2, 3, 4, 5, 6, 7, 8])
indices = tf.constant([[4], [3], [1], [7]])
updates = tf.constant([9, 10, 11, 12])
output = tf.scatter_nd_non_aliasing_add(input, indices, updates)
with tf.Session() as sess:
  print(sess.run(output))</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">The resulting value `output` would look like this:</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">[1, 13, 3, 14, 14, 6, 7, 20]</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">See tf.scatter_nd for more details about how to make updates to slices.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Args:
* scope: A Scope object
* input: A Tensor.
* indices: A Tensor. Must be one of the following types: `int32`, `int64`.
A tensor of indices into `input`.
* updates: A Tensor. Must have the same type as ref. A tensor of updated values
to add to `input`.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">    Returns:
    * `Output`: A `Tensor` with the same shape as `input`, containing values of `input`
    updated with `updates`. */
class ScatterNdNonAliasingAdd {
 public:
  ScatterNdNonAliasingAdd(const tensorflow::Scope&amp; scope, tensorflow::Input
                        input, tensorflow::Input indices, tensorflow::Input
                        updates);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/** Returns the shape of a tensor.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">This operation returns a 1-D integer tensor representing the shape of `input`.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">For example:</pre> 
 <h1 id="t-is-[[[1,-1,-1],-[2,-2,-2]],-[[3,-3,-3],-[4,-4,-4]]]_1" data-text="'t' is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]">'t' is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]</h1> <p>shape(t) ==&gt; [2, 2, 3] </p>
 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Args:
* scope: A Scope object</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">    Returns:
    * `Output`: The output tensor. */
class Shape {
 public:
  /// Optional attribute setters for Shape
  struct Attrs {
    /// Defaults to DT_INT32
    TF_MUST_USE_RESULT Attrs OutType(DataType x) {
      Attrs ret = *this;
      ret.out_type_ = x;
      return ret;
    }</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">  DataType out_type_ = DT_INT32;
};
Shape(const ::tensorflow::Scope&amp; scope, ::tensorflow::Input input);
Shape(const tensorflow::Scope&amp; scope, tensorflow::Input input, const
    Shape::Attrs&amp; attrs);
operator ::tensorflow::Output() const { return output; }
operator ::tensorflow::Input() const { return output; }
::tensorflow::Node* node() const { return output.node(); }</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">static Attrs OutType(DataType x) {
  return Attrs().OutType(x);
}</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/** Returns shape of tensors.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">This operation returns N 1-D integer tensors representing shape of `input[i]s`.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Args:
* scope: A Scope object</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">    Returns:
    * `OutputList`: The output tensor. */
class ShapeN {
 public:
  /// Optional attribute setters for ShapeN
  struct Attrs {
    /// Defaults to DT_INT32
    TF_MUST_USE_RESULT Attrs OutType(DataType x) {
      Attrs ret = *this;
      ret.out_type_ = x;
      return ret;
    }</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">  DataType out_type_ = DT_INT32;
};
ShapeN(const ::tensorflow::Scope&amp; scope, ::tensorflow::InputList input);
ShapeN(const tensorflow::Scope&amp; scope, tensorflow::InputList input, const
     ShapeN::Attrs&amp; attrs);
tensorflow::Output operator[](size_t index) const { return output[index]; }</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">static Attrs OutType(DataType x) {
  return Attrs().OutType(x);
}</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Operation operation;
  ::tensorflow::OutputList output;
};</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/** Returns the size of a tensor.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">This operation returns an integer representing the number of elements in
`input`.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">For example:</pre> 
 <h1 id="t-is-[[[1,-1,,-1],-[2,-2,-2]],-[[3,-3,-3],-[4,-4,-4]]]]" data-text="'t' is [[[1, 1,, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]]">'t' is [[[1, 1,, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]]</h1> <p>size(t) ==&gt; 12 </p>
 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Args:
* scope: A Scope object</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">    Returns:
    * `Output`: The output tensor. */
class Size {
 public:
  /// Optional attribute setters for Size
  struct Attrs {
    /// Defaults to DT_INT32
    TF_MUST_USE_RESULT Attrs OutType(DataType x) {
      Attrs ret = *this;
      ret.out_type_ = x;
      return ret;
    }</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">  DataType out_type_ = DT_INT32;
};
Size(const ::tensorflow::Scope&amp; scope, ::tensorflow::Input input);
Size(const tensorflow::Scope&amp; scope, tensorflow::Input input, const
   Size::Attrs&amp; attrs);
operator ::tensorflow::Output() const { return output; }
operator ::tensorflow::Input() const { return output; }
::tensorflow::Node* node() const { return output.node(); }</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">static Attrs OutType(DataType x) {
  return Attrs().OutType(x);
}</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/** Return a slice from 'input'.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">The output tensor is a tensor with dimensions described by 'size'
whose values are extracted from 'input' starting at the offsets in
'begin'.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">*Requirements*:
  0 &lt;= begin[i] &lt;= begin[i] + size[i] &lt;= Di  for i in [0, n)</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Args:
* scope: A Scope object
* begin: begin[i] specifies the offset into the 'i'th dimension of
'input' to slice from.
* size: size[i] specifies the number of elements of the 'i'th dimension
of 'input' to slice. If size[i] is -1, all remaining elements in dimension
i are included in the slice (i.e. this is equivalent to setting
size[i] = input.dim_size(i) - begin[i]).</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">    Returns:
    * `Output`: The output tensor. */
class Slice {
 public:
  Slice(const tensorflow::Scope&amp; scope, tensorflow::Input input,
      tensorflow::Input begin, tensorflow::Input size);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/** Returns a copy of the input tensor.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Args:
* scope: A Scope object</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">    Returns:
    * `Output`: The output tensor. */
class Snapshot {
 public:
  Snapshot(const ::tensorflow::Scope&amp; scope, ::tensorflow::Input input);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/** SpaceToBatch for 4-D tensors of type T.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">This is a legacy version of the more general SpaceToBatchND.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Zero-pads and then rearranges (permutes) blocks of spatial data into batch.
More specifically, this op outputs a copy of the input tensor where values from
the `height` and `width` dimensions are moved to the `batch` dimension. After
the zero-padding, both `height` and `width` of the input must be divisible by the
block size.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">The attr `block_size` must be greater than one. It indicates the block size.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">* Non-overlapping blocks of size `block_size x block size` in the height and
  width dimensions are rearranged into the batch dimension at each location.
* The batch of the output tensor is `batch * block_size * block_size`.
* Both height_pad and width_pad must be divisible by block_size.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">The shape of the output will be:</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">[batch*block_size*block_size, height_pad/block_size, width_pad/block_size,
 depth]</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Some examples:</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">(1) For the following input of shape `[1, 2, 2, 1]` and block_size of 2:</pre> 
 x = [[[[1], [2]], [[3], [4]]]]  
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">The output tensor has shape `[4, 1, 1, 1]` and value:</pre> 
 [[[[1]]], [[[2]]], [[[3]]], [[[4]]]]  
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">(2) For the following input of shape `[1, 2, 2, 3]` and block_size of 2:</pre> 
 x = [[[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]]]  
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">The output tensor has shape `[4, 1, 1, 3]` and value:</pre> 
 [[[[1, 2, 3]]], [[[4, 5, 6]]], [[[7, 8, 9]]], [[[10, 11, 12]]]]  
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">(3) For the following input of shape `[1, 4, 4, 1]` and block_size of 2:</pre> 
 x = [[[[1], [2], [3], [4]], [[5], [6], [7], [8]], [[9], [10], [11], [12]], [[13], [14], [15], [16]]]]  
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">The output tensor has shape `[4, 2, 2, 1]` and value:</pre> 
 x = [[[[1], [3]], [[9], [11]]], [[[2], [4]], [[10], [12]]], [[[5], [7]], [[13], [15]]], [[[6], [8]], [[14], [16]]]]  
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">(4) For the following input of shape `[2, 2, 4, 1]` and block_size of 2:</pre> 
 x = [[[[1], [2], [3], [4]], [[5], [6], [7], [8]]], [[[9], [10], [11], [12]], [[13], [14], [15], [16]]]]  
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">The output tensor has shape `[8, 1, 2, 1]` and value:</pre> 
 x = [[[[1], [3]]], [[[9], [11]]], [[[2], [4]]], [[[10], [12]]], [[[5], [7]]], [[[13], [15]]], [[[6], [8]]], [[[14], [16]]]]  
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Among others, this operation is useful for reducing atrous convolution into
regular convolution.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Args:
* scope: A Scope object
* input: 4-D with shape `[batch, height, width, depth]`.
* paddings: 2-D tensor of non-negative integers with shape `[2, 2]`. It specifies
  the padding of the input with zeros across the spatial dimensions as follows:</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">paddings = [[pad_top, pad_bottom], [pad_left, pad_right]]</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">The effective spatial dimensions of the zero-padded input tensor will be:</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">height_pad = pad_top + height + pad_bottom
width_pad = pad_left + width + pad_right</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">    Returns:
    * `Output`: The output tensor. */
class SpaceToBatch {
 public:
  SpaceToBatch(const tensorflow::Scope&amp; scope, tensorflow::Input input,
             tensorflow::Input paddings, int64 block_size);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/** SpaceToBatch for N-D tensors of type T.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">This operation divides "spatial" dimensions `[1, ..., M]` of the input into a
grid of blocks of shape `block_shape`, and interleaves these blocks with the
"batch" dimension (0) such that in the output, the spatial dimensions
`[1, ..., M]` correspond to the position within the grid, and the batch
dimension combines both the position within a spatial block and the original
batch position.  Prior to division into blocks, the spatial dimensions of the
input are optionally zero padded according to `paddings`. See below for a
precise description.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">This operation is equivalent to the following steps:</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">1. Zero-pad the start and end of dimensions `[1, ..., M]` of the
   input according to `paddings` to produce `padded` of shape `padded_shape`.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">2. Reshape `padded` to `reshaped_padded` of shape:</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">[batch] +
[padded_shape[1] / block_shape[0],
  block_shape[0],
 ...,
 padded_shape[M] / block_shape[M-1],
 block_shape[M-1]] +
remaining_shape</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">3. Permute dimensions of `reshaped_padded` to produce
   `permuted_reshaped_padded` of shape:</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">block_shape +
[batch] +
[padded_shape[1] / block_shape[0],
 ...,
 padded_shape[M] / block_shape[M-1]] +
remaining_shape</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">4. Reshape `permuted_reshaped_padded` to flatten `block_shape` into the batch
   dimension, producing an output tensor of shape:</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">[batch * prod(block_shape)] +
[padded_shape[1] / block_shape[0],
 ...,
 padded_shape[M] / block_shape[M-1]] +
remaining_shape</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Some examples:</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">(1) For the following input of shape `[1, 2, 2, 1]`, `block_shape = [2, 2]`, and
    `paddings = [[0, 0], [0, 0]]`:</pre> 
 x = [[[[1], [2]], [[3], [4]]]]  
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">The output tensor has shape `[4, 1, 1, 1]` and value:</pre> 
 [[[[1]]], [[[2]]], [[[3]]], [[[4]]]]  
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">(2) For the following input of shape `[1, 2, 2, 3]`, `block_shape = [2, 2]`, and
    `paddings = [[0, 0], [0, 0]]`:</pre> 
 x = [[[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]]]  
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">The output tensor has shape `[4, 1, 1, 3]` and value:</pre> 
 [[[[1, 2, 3]]], [[[4, 5, 6]]], [[[7, 8, 9]]], [[[10, 11, 12]]]]  
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">(3) For the following input of shape `[1, 4, 4, 1]`, `block_shape = [2, 2]`, and
    `paddings = [[0, 0], [0, 0]]`:</pre> 
 x = [[[[1], [2], [3], [4]], [[5], [6], [7], [8]], [[9], [10], [11], [12]], [[13], [14], [15], [16]]]]  
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">The output tensor has shape `[4, 2, 2, 1]` and value:</pre> 
 x = [[[[1], [3]], [[9], [11]]], [[[2], [4]], [[10], [12]]], [[[5], [7]], [[13], [15]]], [[[6], [8]], [[14], [16]]]]  
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">(4) For the following input of shape `[2, 2, 4, 1]`, block_shape = `[2, 2]`, and
    paddings = `[[0, 0], [2, 0]]`:</pre> 
 x = [[[[1], [2], [3], [4]], [[5], [6], [7], [8]]], [[[9], [10], [11], [12]], [[13], [14], [15], [16]]]]  
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">The output tensor has shape `[8, 1, 3, 1]` and value:</pre> 
 x = [[[[0], [1], [3]]], [[[0], [9], [11]]], [[[0], [2], [4]]], [[[0], [10], [12]]], [[[0], [5], [7]]], [[[0], [13], [15]]], [[[0], [6], [8]]], [[[0], [14], [16]]]]  
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Among others, this operation is useful for reducing atrous convolution into
regular convolution.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Args:
* scope: A Scope object
* input: N-D with shape `input_shape = [batch] + spatial_shape + remaining_shape`,
where spatial_shape has `M` dimensions.
* block_shape: 1-D with shape `[M]`, all values must be &gt;= 1.
* paddings: 2-D with shape `[M, 2]`, all values must be &gt;= 0.
  `paddings[i] = [pad_start, pad_end]` specifies the padding for input dimension
  `i + 1`, which corresponds to spatial dimension `i`.  It is required that
  `block_shape[i]` divides `input_shape[i + 1] + pad_start + pad_end`.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">    Returns:
    * `Output`: The output tensor. */
class SpaceToBatchND {
 public:
  SpaceToBatchND(const tensorflow::Scope&amp; scope, tensorflow::Input input,
               tensorflow::Input block_shape, tensorflow::Input paddings);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/** SpaceToDepth for tensors of type T.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Rearranges blocks of spatial data, into depth. More specifically,
this op outputs a copy of the input tensor where values from the `height`
and `width` dimensions are moved to the `depth` dimension.
The attr `block_size` indicates the input block size.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">* Non-overlapping blocks of size `block_size x block size` are rearranged
  into depth at each location.
* The depth of the output tensor is `block_size * block_size * input_depth`.
* The Y, X coordinates within each block of the input become the high order
  component of the output channel index.
* The input tensor's height and width must be divisible by block_size.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">The `data_format` attr specifies the layout of the input and output tensors
with the following options:
  "NHWC": `[ batch, height, width, channels ]`
  "NCHW": `[ batch, channels, height, width ]`
  "NCHW_VECT_C":
      `qint8 [ batch, channels / 4, height, width, 4 ]`</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">It is useful to consider the operation as transforming a 6-D Tensor.
e.g. for data_format = NHWC,
     Each element in the input tensor can be specified via 6 coordinates,
     ordered by decreasing memory layout significance as:
     n,oY,bY,oX,bX,iC  (where n=batch index, oX, oY means X or Y coordinates
                        within the output image, bX, bY means coordinates
                        within the input block, iC means input channels).
     The output would be a transpose to the following layout:
     n,oY,oX,bY,bX,iC</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">This operation is useful for resizing the activations between convolutions
(but keeping all data), e.g. instead of pooling. It is also useful for training
purely convolutional models.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">For example, given an input of shape `[1, 2, 2, 1]`, data_format = "NHWC" and
block_size = 2:</pre> 
 x = [[[[1], [2]], [[3], [4]]]]  
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">This operation will output a tensor of shape `[1, 1, 1, 4]`:</pre> 
 [[[[1, 2, 3, 4]]]]  
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Here, the input has a batch of 1 and each batch element has shape `[2, 2, 1]`,
the corresponding output will have a single element (i.e. width and height are
both 1) and will have a depth of 4 channels (1 * block_size * block_size).
The output element shape is `[1, 1, 4]`.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">For an input tensor with larger depth, here of shape `[1, 2, 2, 3]`, e.g.</pre> 
 x = [[[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]]]  
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">This operation, for block_size of 2, will return the following tensor of shape
`[1, 1, 1, 12]`</pre> 
 [[[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]]]]  
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Similarly, for the following input of shape `[1 4 4 1]`, and a block size of 2:</pre> 
 x = [[[[1], [2], [5], [6]], [[3], [4], [7], [8]], [[9], [10], [13], [14]], [[11], [12], [15], [16]]]]  
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">the operator will return the following tensor of shape `[1 2 2 4]`:</pre> 
 x = [[[[1, 2, 3, 4], [5, 6, 7, 8]], [[9, 10, 11, 12], [13, 14, 15, 16]]]]  
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Args:
* scope: A Scope object
* block_size: The size of the spatial block.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">    Returns:
    * `Output`: The output tensor. */
class SpaceToDepth {
 public:
  /// Optional attribute setters for SpaceToDepth
  struct Attrs {
    /// Defaults to "NHWC"
    TF_MUST_USE_RESULT Attrs DataFormat(StringPiece x) {
      Attrs ret = *this;
      ret.data_format_ = x;
      return ret;
    }</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">  StringPiece data_format_ = "NHWC";
};
SpaceToDepth(const tensorflow::Scope&amp; scope, tensorflow::Input input, int64
           block_size);
SpaceToDepth(const tensorflow::Scope&amp; scope, tensorflow::Input input, int64
           block_size, const SpaceToDepth::Attrs&amp; attrs);
operator ::tensorflow::Output() const { return output; }
operator ::tensorflow::Input() const { return output; }
::tensorflow::Node* node() const { return output.node(); }</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">static Attrs DataFormat(StringPiece x) {
  return Attrs().DataFormat(x);
}</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/** Splits a tensor into `num_split` tensors along one dimension.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Args:
* scope: A Scope object
* axis: 0-D.  The dimension along which to split.  Must be in the range
`[-rank(value), rank(value))`.
* value: The tensor to split.
* num_split: The number of ways to split.  Must evenly divide
`value.shape[split_dim]`.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">    Returns:
    * `OutputList`: They are identically shaped tensors, whose shape matches that of `value`
    except along `axis`, where their sizes are
    `values.shape[split_dim] / num_split`. */
class Split {
 public:
  Split(const tensorflow::Scope&amp; scope, tensorflow::Input axis,
      tensorflow::Input value, int64 num_split);
  tensorflow::Output operator[](size_t index) const { return output[index]; }</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Operation operation;
  ::tensorflow::OutputList output;
};</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/** Splits a tensor into `num_split` tensors along one dimension.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Args:
* scope: A Scope object
* value: The tensor to split.
* size_splits: list containing the sizes of each output tensor along the split
dimension. Must sum to the dimension of value along split_dim.
Can contain one -1 indicating that dimension is to be inferred.
* axis: 0-D.  The dimension along which to split.  Must be in the range
`[-rank(value), rank(value))`.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">    Returns:
    * `OutputList`: Tensors whose shape matches that of `value`
    except along `axis`, where their sizes are
    `size_splits[i]`. */
class SplitV {
 public:
  SplitV(const tensorflow::Scope&amp; scope, tensorflow::Input value,
       tensorflow::Input size_splits, tensorflow::Input axis, int64
       num_split);
  tensorflow::Output operator[](size_t index) const { return output[index]; }</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Operation operation;
  ::tensorflow::OutputList output;
};</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/** Removes dimensions of size 1 from the shape of a tensor.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Given a tensor `input`, this operation returns a tensor of the same type with
all dimensions of size 1 removed. If you don't want to remove all size 1
dimensions, you can remove specific size 1 dimensions by specifying
`axis`.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">For example:</pre> 
 <h1 id="t-is-a-tensor-of-shape-[1,-2,-1,-3,-1,-1]" data-text="'t' is a tensor of shape [1, 2, 1, 3, 1, 1]">'t' is a tensor of shape [1, 2, 1, 3, 1, 1]</h1> <p>shape(squeeze(t)) ==&gt; [2, 3] </p>
 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Or, to remove specific size 1 dimensions:</pre> 
 <h1 id="t-is-a-tensor-of-shape-[1,-2,-1,-3,-1,-1]_1" data-text="'t' is a tensor of shape [1, 2, 1, 3, 1, 1]">'t' is a tensor of shape [1, 2, 1, 3, 1, 1]</h1> <p>shape(squeeze(t, [2, 4])) ==&gt; [1, 2, 3, 1] </p>
 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Args:
* scope: A Scope object
* input: The `input` to squeeze.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Optional attributes (see `Attrs`):
* axis: If specified, only squeezes the dimensions listed. The dimension
index starts at 0. It is an error to squeeze a dimension that is not 1. Must
be in the range `[-rank(input), rank(input))`.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">    Returns:
    * `Output`: Contains the same data as `input`, but has one or more dimensions of
    size 1 removed. */
class Squeeze {
 public:
  /// Optional attribute setters for Squeeze
  struct Attrs {
    /** If specified, only squeezes the dimensions listed. The dimension
        index starts at 0. It is an error to squeeze a dimension that is not 1. Must
        be in the range `[-rank(input), rank(input))`.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">    Defaults to [] */
TF_MUST_USE_RESULT Attrs Axis(const gtl::ArraySlice&amp; x) {
  Attrs ret = *this;
  ret.axis_ = x;
  return ret;
}</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">  gtl::ArraySlice axis_ = {};
};
Squeeze(const ::tensorflow::Scope&amp; scope, ::tensorflow::Input input);
Squeeze(const tensorflow::Scope&amp; scope, tensorflow::Input input, const
      Squeeze::Attrs&amp; attrs);
operator ::tensorflow::Output() const { return output; }
operator ::tensorflow::Input() const { return output; }
::tensorflow::Node* node() const { return output.node(); }</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">static Attrs Axis(const gtl::ArraySlice&amp; x) {
  return Attrs().Axis(x);
}</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/** Stops gradient computation.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">When executed in a graph, this op outputs its input tensor as-is.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">When building ops to compute gradients, this op prevents the contribution of
its inputs to be taken into account.  Normally, the gradient generator adds ops
to a graph to compute the derivatives of a specified 'loss' by recursively
finding out inputs that contributed to its computation.  If you insert this op
in the graph it inputs are masked from the gradient generator.  They are not
taken into account for computing gradients.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">This is useful any time you want to compute a value with TensorFlow but need
to pretend that the value was a constant. For example, the softmax function
for a vector x can be written as</pre> 
python <p>def softmax(x): numerator = tf.exp(x) denominator = tf.reduce_sum(numerator) return numerator / denominator </p>
 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">This however is susceptible to overflow if the values in x are large. An
alternative more stable way is to subtract the maximum of x from each of the
values.</pre> 
python <p>def stable_softmax(x): z = x - tf.reduce_max(x) numerator = tf.exp(z) denominator = tf.reduce_sum(numerator) return numerator / denominator </p>
 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">However, when we backprop through the softmax to x, we dont want to backprop
through the tf.reduce_max(x) (if the max values are not unique then the
gradient could flow to the wrong input) calculation and treat that as a
constant. Therefore, we should write this out as</pre> 
python <p>def stable_softmax(x): z = x - tf.stop_gradient(tf.reduce_max(x)) numerator = tf.exp(z) denominator = tf.reduce_sum(numerator) return numerator / denominator </p>
 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Some other examples include:</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">*  The *EM* algorithm where the *M-step* should not involve backpropagation
   through the output of the *E-step*.
*  Contrastive divergence training of Boltzmann machines where, when
   differentiating the energy function, the training must not backpropagate
   through the graph that generated the samples from the model.
*  Adversarial training, where no backprop should happen through the adversarial
   example generation process.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Args:
* scope: A Scope object</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">    Returns:
    * `Output`: The output tensor. */
class StopGradient {
 public:
  StopGradient(const ::tensorflow::Scope&amp; scope, ::tensorflow::Input input);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/** Return a strided slice from `input`.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Note, most python users will want to use the Python Tensor.__getitem__
or Variable.__getitem__ rather than this op directly.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">The goal of this op is to produce a new tensor with a subset of
the elements from the `n` dimensional `input` tensor. The subset is chosen using
a sequence of `m` sparse range specifications encoded into the arguments
of this function. Note, in some cases
`m` could be equal to `n`, but this need not be the case. Each
range specification entry can be one of the following:</pre> 

<ul><li>An ellipsis (...). Ellipses are used to imply zero or more dimensions of full-dimension selection and are produced using `ellipsis_mask`. For example, `foo[...]` is the identity slice.</li></ul> 

<ul><li>A new axis. This is used to insert a new shape=1 dimension and is produced using `new_axis_mask`. For example, `foo[:, ...]` where `foo` is shape `(3, 4)` produces a `(1, 3, 4)` tensor.</li></ul> 

<ul><li>A range `begin:end:stride`. This is used to specify how much to choose from a given dimension. `stride` can be any integer but 0. `begin` is an integer which represents the index of the first value to select while `end` represents the index of the last value to select. The number of values selected in each dimension is `end - begin` if `stride &gt; 0` and `begin - end` if `stride &lt; 0`. `begin` and `end` can be negative where `-1` is the last element, `-2` is the second to last. `begin_mask` controls whether to replace the explicitly given `begin` with an implicit effective value of `0` if `stride &gt; 0` and `-1` if `stride &lt; 0`. `end_mask` is analogous but produces the number required to create the largest open interval. For example, given a shape `(3,)` tensor `foo[:]`, the effective `begin` and `end` are `0` and `3`. Do not assume this is equivalent to `foo[0:-1]` which has an effective `begin` and `end` of `0` and `2`. Another example is `foo[-2::-1]` which reverses the first dimension of a tensor while dropping the last two (in the original order elements). For example `foo = [1,2,3,4]; foo[-2::-1]` is `[4,3]`.</li></ul> 

<ul><li>A single index. This is used to keep only elements that have a given index. For example (`foo[2, :]` on a shape `(5,6)` tensor produces a shape `(6,)` tensor. This is encoded in `begin` and `end` and `shrink_axis_mask`.</li></ul> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Each conceptual range specification is encoded in the op's argument. This
encoding is best understand by considering a non-trivial example. In
particular,
`foo[1, 2:4, None, ..., :-3:-1, :]` will be encoded as</pre> 
 begin = [1, 2, x, x, 0, x] # x denotes don't care (usually 0) end = [2, 4, x, x, -3, x] strides = [1, 1, x, x, -1, 1] begin_mask = 1&lt;&lt;4 | 1&lt;&lt;5 = 48 end_mask = 1&lt;&lt;5 = 32 ellipsis_mask = 1&lt;&lt;3 = 8 new_axis_mask = 1&lt;&lt;2 = 4 shrink_axis_mask = 1&lt;&lt;0 = 1  
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">In this case if foo.shape is (5, 5, 5, 5, 5, 5) the final shape of
the slice becomes (2, 1, 5, 5, 2, 5).
Let us walk step by step through each argument specification.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">1.  The first argument in the example slice is turned into begin = 1 and
end = begin + 1 = 2. To disambiguate from the original spec 2:4 we
also set the appropriate bit in shrink_axis_mask.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">2. 2:4 is contributes 2, 4, 1 to begin, end, and stride. All masks have
zero bits contributed.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">3. None is a synonym for tf.newaxis. This means insert a dimension of size 1
dimension in the final shape. Dummy values are contributed to begin,
end and stride, while the new_axis_mask bit is set.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">4. ... grab the full ranges from as many dimensions as needed to
fully specify a slice for every dimension of the input shape.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">5. :-3:-1 shows the use of negative indices. A negative index i associated
with a dimension that has shape s is converted to a positive index
s + i. So -1 becomes s-1 (i.e. the last element). This conversion
is done internally so begin, end and strides receive x, -3, and -1.
The appropriate begin_mask bit is set to indicate the start range is the
full range (ignoring the x).</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">6. : indicates that the entire contents of the corresponding dimension
is selected. This is equivalent to :: or 0::1. begin, end, and strides
receive 0, 0, and 1, respectively. The appropriate bits in begin_mask and
end_mask are also set.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Requirements:
      0 != strides[i] for i in [0, m)ellipsis_mask must be a power of two (only one ellipsis)</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Args:
* scope: A Scope object
* begin: begin[k] specifies the offset into the kth range specification.
The exact dimension this corresponds to will be determined by context.
Out-of-bounds values will be silently clamped. If the kth bit of
begin_mask then begin[k] is ignored and the full range of the
appropriate dimension is used instead. Negative values causes indexing
to start from the highest element e.g. If foo==[1,2,3] then foo[-1]==3.
* end: end[i] is like begin with the exception that end_mask is
used to determine full ranges.
* strides: strides[i] specifies the increment in the ith specification
after extracting a given element. Negative indices will reverse
the original order. Out or range values are
clamped to [0,dim[i]) if slice[i]&gt;0 or [-1,dim[i]-1] if slice[i] &lt; 0</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Optional attributes (see Attrs):
* begin_mask: a bitmask where a bit i being 1 means to ignore the begin
value and instead use the largest interval possible. At runtime
begin[i] will be replaced with [0, n-1) if stride[i] &gt; 0 or
[-1, n-1] if stride[i] &lt; 0
* end_mask: analogous to begin_mask
* ellipsis_mask: a bitmask where bit i being 1 means the ith
position is actually an ellipsis. One bit at most can be 1.
If ellipsis_mask == 0, then an implicit ellipsis mask of 1 &lt;&lt; (m+1)
is provided. This means that foo[3:5] == foo[3:5, ...]. An ellipsis
implicitly creates as many range specifications as necessary to fully
specify the sliced range for every dimension. For example for a 4-dimensional
tensor foo the slice foo[2, ..., 5:8] implies foo[2, :, :, 5:8].
* new_axis_mask: a bitmask where bit i being 1 means the ith
specification creates a new shape 1 dimension. For example
foo[:4, tf.newaxis, :2] would produce a shape (4, 1, 2) tensor.
* shrink_axis_mask: a bitmask where bit i implies that the ith
specification should shrink the dimensionality. begin and end
must imply a slice of size 1 in the dimension. For example in
python one might do foo[:, 3, :] which would result in
shrink_axis_mask being 2.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">    Returns:
    * Output: The output tensor. */
class StridedSlice {
 public:
  /// Optional attribute setters for StridedSlice
  struct Attrs {
    /** a bitmask where a bit i being 1 means to ignore the begin
        value and instead use the largest interval possible. At runtime
        begin[i] will be replaced with [0, n-1) if stride[i] &gt; 0 or
        [-1, n-1] if stride[i] &lt; 0</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">    Defaults to 0 */
TF_MUST_USE_RESULT Attrs BeginMask(int64 x) {
  Attrs ret = *this;
  ret.begin_mask_ = x;
  return ret;
}</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/** analogous to begin_mask</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">    Defaults to 0 */
TF_MUST_USE_RESULT Attrs EndMask(int64 x) {
  Attrs ret = *this;
  ret.end_mask_ = x;
  return ret;
}</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/** a bitmask where bit i being 1 means the ith
    position is actually an ellipsis. One bit at most can be 1.
    If ellipsis_mask == 0, then an implicit ellipsis mask of 1 &lt;&lt; (m+1)
    is provided. This means that foo[3:5] == foo[3:5, ...]. An ellipsis
    implicitly creates as many range specifications as necessary to fully
    specify the sliced range for every dimension. For example for a 4-dimensional
    tensor foo the slice foo[2, ..., 5:8] implies foo[2, :, :, 5:8].</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">    Defaults to 0 */
TF_MUST_USE_RESULT Attrs EllipsisMask(int64 x) {
  Attrs ret = *this;
  ret.ellipsis_mask_ = x;
  return ret;
}</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/** a bitmask where bit i being 1 means the ith
    specification creates a new shape 1 dimension. For example
    foo[:4, tf.newaxis, :2] would produce a shape (4, 1, 2) tensor.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">    Defaults to 0 */
TF_MUST_USE_RESULT Attrs NewAxisMask(int64 x) {
  Attrs ret = *this;
  ret.new_axis_mask_ = x;
  return ret;
}</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/** a bitmask where bit i implies that the ith
    specification should shrink the dimensionality. begin and end
    must imply a slice of size 1 in the dimension. For example in
    python one might do foo[:, 3, :] which would result in
    shrink_axis_mask being 2.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">    Defaults to 0 */
TF_MUST_USE_RESULT Attrs ShrinkAxisMask(int64 x) {
  Attrs ret = *this;
  ret.shrink_axis_mask_ = x;
  return ret;
}</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">  int64 begin_mask_ = 0;
  int64 end_mask_ = 0;
  int64 ellipsis_mask_ = 0;
  int64 new_axis_mask_ = 0;
  int64 shrink_axis_mask_ = 0;
};
StridedSlice(const tensorflow::Scope&amp; scope, tensorflow::Input input,
           tensorflow::Input begin, tensorflow::Input end,
           tensorflow::Input strides);
StridedSlice(const tensorflow::Scope&amp; scope, tensorflow::Input input,
           tensorflow::Input begin, tensorflow::Input end,
           tensorflow::Input strides, const StridedSlice::Attrs&amp; attrs);
operator ::tensorflow::Output() const { return output; }
operator ::tensorflow::Input() const { return output; }
::tensorflow::Node* node() const { return output.node(); }</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">static Attrs BeginMask(int64 x) {
  return Attrs().BeginMask(x);
}
static Attrs EndMask(int64 x) {
  return Attrs().EndMask(x);
}
static Attrs EllipsisMask(int64 x) {
  return Attrs().EllipsisMask(x);
}
static Attrs NewAxisMask(int64 x) {
  return Attrs().NewAxisMask(x);
}
static Attrs ShrinkAxisMask(int64 x) {
  return Attrs().ShrinkAxisMask(x);
}</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/** Assignvalue to the sliced l-value reference of ref.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">The values of value are assigned to the positions in the variable
ref that are selected by the slice parameters. The slice parameters
begin, end, strides, etc. work exactly as in StridedSlice.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">NOTE this op currently does not support broadcasting and so value's
shape must be exactly the shape produced by the slice of ref.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Args:
* scope: A Scope object</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">    Returns:
    * Output: The output_ref tensor. */
class StridedSliceAssign {
 public:
  /// Optional attribute setters for StridedSliceAssign
  struct Attrs {
    /// Defaults to 0
    TF_MUST_USE_RESULT Attrs BeginMask(int64 x) {
      Attrs ret = *this;
      ret.begin_mask_ = x;
      return ret;
    }</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/// Defaults to 0
TF_MUST_USE_RESULT Attrs EndMask(int64 x) {
  Attrs ret = *this;
  ret.end_mask_ = x;
  return ret;
}</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/// Defaults to 0
TF_MUST_USE_RESULT Attrs EllipsisMask(int64 x) {
  Attrs ret = *this;
  ret.ellipsis_mask_ = x;
  return ret;
}</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/// Defaults to 0
TF_MUST_USE_RESULT Attrs NewAxisMask(int64 x) {
  Attrs ret = *this;
  ret.new_axis_mask_ = x;
  return ret;
}</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/// Defaults to 0
TF_MUST_USE_RESULT Attrs ShrinkAxisMask(int64 x) {
  Attrs ret = *this;
  ret.shrink_axis_mask_ = x;
  return ret;
}</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">  int64 begin_mask_ = 0;
  int64 end_mask_ = 0;
  int64 ellipsis_mask_ = 0;
  int64 new_axis_mask_ = 0;
  int64 shrink_axis_mask_ = 0;
};
StridedSliceAssign(const tensorflow::Scope&amp; scope, tensorflow::Input ref,
                 tensorflow::Input begin, tensorflow::Input end,
                 tensorflow::Input strides, tensorflow::Input value);
StridedSliceAssign(const tensorflow::Scope&amp; scope, tensorflow::Input ref,
                 tensorflow::Input begin, tensorflow::Input end,
                 tensorflow::Input strides, tensorflow::Input value,
                 const StridedSliceAssign::Attrs&amp; attrs);
operator ::tensorflow::Output() const { return output_ref; }
operator ::tensorflow::Input() const { return output_ref; }
::tensorflow::Node* node() const { return output_ref.node(); }</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">static Attrs BeginMask(int64 x) {
  return Attrs().BeginMask(x);
}
static Attrs EndMask(int64 x) {
  return Attrs().EndMask(x);
}
static Attrs EllipsisMask(int64 x) {
  return Attrs().EllipsisMask(x);
}
static Attrs NewAxisMask(int64 x) {
  return Attrs().NewAxisMask(x);
}
static Attrs ShrinkAxisMask(int64 x) {
  return Attrs().ShrinkAxisMask(x);
}</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Operation operation;
  tensorflow::Output output_ref;
};</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/** Returns the gradient of StridedSlice.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Since StridedSlice cuts out pieces of its input which is size
shape, its gradient will have the same shape (which is passed here
as shape). The gradient will be zero in any element that the slice
does not select.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Arguments are the same as StridedSliceGrad with the exception that
dy is the input gradient to be propagated and shape is the
shape of StridedSlice's input.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Args:
* scope: A Scope object</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">    Returns:
    * Output: The output tensor. */
class StridedSliceGrad {
 public:
  /// Optional attribute setters for StridedSliceGrad
  struct Attrs {
    /// Defaults to 0
    TF_MUST_USE_RESULT Attrs BeginMask(int64 x) {
      Attrs ret = *this;
      ret.begin_mask_ = x;
      return ret;
    }</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/// Defaults to 0
TF_MUST_USE_RESULT Attrs EndMask(int64 x) {
  Attrs ret = *this;
  ret.end_mask_ = x;
  return ret;
}</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/// Defaults to 0
TF_MUST_USE_RESULT Attrs EllipsisMask(int64 x) {
  Attrs ret = *this;
  ret.ellipsis_mask_ = x;
  return ret;
}</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/// Defaults to 0
TF_MUST_USE_RESULT Attrs NewAxisMask(int64 x) {
  Attrs ret = *this;
  ret.new_axis_mask_ = x;
  return ret;
}</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/// Defaults to 0
TF_MUST_USE_RESULT Attrs ShrinkAxisMask(int64 x) {
  Attrs ret = *this;
  ret.shrink_axis_mask_ = x;
  return ret;
}</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">  int64 begin_mask_ = 0;
  int64 end_mask_ = 0;
  int64 ellipsis_mask_ = 0;
  int64 new_axis_mask_ = 0;
  int64 shrink_axis_mask_ = 0;
};
StridedSliceGrad(const tensorflow::Scope&amp; scope, tensorflow::Input shape,
               tensorflow::Input begin, tensorflow::Input end,
               tensorflow::Input strides, tensorflow::Input dy);
StridedSliceGrad(const tensorflow::Scope&amp; scope, tensorflow::Input shape,
               tensorflow::Input begin, tensorflow::Input end,
               tensorflow::Input strides, tensorflow::Input dy, const
               StridedSliceGrad::Attrs&amp; attrs);
operator ::tensorflow::Output() const { return output; }
operator ::tensorflow::Input() const { return output; }
::tensorflow::Node* node() const { return output.node(); }</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">static Attrs BeginMask(int64 x) {
  return Attrs().BeginMask(x);
}
static Attrs EndMask(int64 x) {
  return Attrs().EndMask(x);
}
static Attrs EllipsisMask(int64 x) {
  return Attrs().EllipsisMask(x);
}
static Attrs NewAxisMask(int64 x) {
  return Attrs().NewAxisMask(x);
}
static Attrs ShrinkAxisMask(int64 x) {
  return Attrs().ShrinkAxisMask(x);
}</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/** Adds sparse updates to an existing tensor according to indices.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">This operation creates a new tensor by adding sparse updates to the passed
in tensor.
This operation is very similar to tf.compat.v1.scatter_nd_add, except that the
updates are added onto an existing tensor (as opposed to a variable). If the
memory for the existing tensor cannot be re-used, a copy is made and updated.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">indices is an integer tensor containing indices into a new tensor of shape
    tensor.shape.  The last dimension of indices can be at most the rank of
    tensor.shape:</pre> 
 indices.shape[-1] &lt;= tensor.shape.rank  
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">The last dimension of `indices` corresponds to indices into elements
(if `indices.shape[-1] = tensor.shape.rank`) or slices
(if `indices.shape[-1] &lt; tensor.shape.rank`) along dimension
`indices.shape[-1]` of `tensor.shape`.  `updates` is a tensor with shape</pre> 
 indices.shape[:-1] + tensor.shape[indices.shape[-1]:]  
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">The simplest form of `tensor_scatter_nd_add` is to add individual elements to a
tensor by index. For example, say we want to add 4 elements in a rank-1
tensor with 8 elements.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">In Python, this scatter add operation would look like this:</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">&gt;&gt;&gt; indices = tf.constant([[4], [3], [1], [7]])
&gt;&gt;&gt; updates = tf.constant([9, 10, 11, 12])
&gt;&gt;&gt; tensor = tf.ones([8], dtype=tf.int32)
&gt;&gt;&gt; updated = tf.tensor_scatter_nd_add(tensor, indices, updates)
&gt;&gt;&gt; updated
</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">We can also, insert entire slices of a higher rank tensor all at once. For
example, if we wanted to insert two slices in the first dimension of a
rank-3 tensor with two matrices of new values.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">In Python, this scatter add operation would look like this:</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">&gt;&gt;&gt; indices = tf.constant([[0], [2]])
&gt;&gt;&gt; updates = tf.constant([[[5, 5, 5, 5], [6, 6, 6, 6],
...                         [7, 7, 7, 7], [8, 8, 8, 8]],
...                        [[5, 5, 5, 5], [6, 6, 6, 6],
...                         [7, 7, 7, 7], [8, 8, 8, 8]]])
&gt;&gt;&gt; tensor = tf.ones([4, 4, 4],dtype=tf.int32)
&gt;&gt;&gt; updated = tf.tensor_scatter_nd_add(tensor, indices, updates)
&gt;&gt;&gt; updated
</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Note: on CPU, if an out of bound index is found, an error is returned.
On GPU, if an out of bound index is found, the index is ignored.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Args:
* scope: A Scope object
* tensor: Tensor to copy/update.
* indices: Index tensor.
* updates: Updates to scatter into output.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">    Returns:
    * `Output`: A new tensor copied from tensor and updates added according to the indices. */
class TensorScatterAdd {
 public:
  TensorScatterAdd(const tensorflow::Scope&amp; scope, tensorflow::Input tensor,
                 tensorflow::Input indices, tensorflow::Input updates);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/** Apply a sparse update to a tensor taking the element-wise maximum.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Returns a new tensor copied from `tensor` whose values are element-wise maximum between
tensor and updates according to the indices.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">&gt;&gt;&gt; tensor = [0, 0, 0, 0, 0, 0, 0, 0]
&gt;&gt;&gt; indices = [[1], [4], [5]]
&gt;&gt;&gt; updates = [1, -1, 1]
&gt;&gt;&gt; tf.tensor_scatter_nd_max(tensor, indices, updates).numpy()
array([0, 1, 0, 0, 0, 1, 0, 0], dtype=int32)</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Refer to tf.tensor_scatter_nd_update for more details.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Args:
* scope: A Scope object
* tensor: Tensor to update.
* indices: Index tensor.
* updates: Updates to scatter into output.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">    Returns:
    * `Output`: A new tensor copied from tensor whose values are element-wise maximum between tensor and updates according to the indices. */
class TensorScatterMax {
 public:
  TensorScatterMax(const tensorflow::Scope&amp; scope, tensorflow::Input tensor,
                 tensorflow::Input indices, tensorflow::Input updates);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/** TODO: add doc.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Args:
* scope: A Scope object
* tensor: Tensor to update.
* indices: Index tensor.
* updates: Updates to scatter into output.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">    Returns:
    * `Output`: A new tensor copied from tensor whose values are element-wise minimum between tensor and updates according to the indices. */
class TensorScatterMin {
 public:
  TensorScatterMin(const tensorflow::Scope&amp; scope, tensorflow::Input tensor,
                 tensorflow::Input indices, tensorflow::Input updates);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/** Subtracts sparse `updates` from an existing tensor according to `indices`.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">This operation creates a new tensor by subtracting sparse `updates` from the
passed in `tensor`.
This operation is very similar to `tf.scatter_nd_sub`, except that the updates
are subtracted from an existing tensor (as opposed to a variable). If the memory
for the existing tensor cannot be re-used, a copy is made and updated.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">`indices` is an integer tensor containing indices into a new tensor of shape
`shape`.  The last dimension of `indices` can be at most the rank of `shape`:</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">indices.shape[-1] &lt;= shape.rank</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">The last dimension of `indices` corresponds to indices into elements
(if `indices.shape[-1] = shape.rank`) or slices
(if `indices.shape[-1] &lt; shape.rank`) along dimension `indices.shape[-1]` of
`shape`.  `updates` is a tensor with shape</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">indices.shape[:-1] + shape[indices.shape[-1]:]</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">The simplest form of tensor_scatter_sub is to subtract individual elements
from a tensor by index. For example, say we want to insert 4 scattered elements
in a rank-1 tensor with 8 elements.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">In Python, this scatter subtract operation would look like this:</pre> 
python indices = tf.constant([[4], [3], [1], [7]]) updates = tf.constant([9, 10, 11, 12]) tensor = tf.ones([8], dtype=tf.int32) updated = tf.tensor_scatter_nd_sub(tensor, indices, updates) print(updated)  
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">The resulting tensor would look like this:</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">[1, -10, 1, -9, -8, 1, 1, -11]</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">We can also, insert entire slices of a higher rank tensor all at once. For
example, if we wanted to insert two slices in the first dimension of a
rank-3 tensor with two matrices of new values.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">In Python, this scatter add operation would look like this:</pre> 
python indices = tf.constant([[0], [2]]) updates = tf.constant([[[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]], [[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]]]) tensor = tf.ones([4, 4, 4],dtype=tf.int32) updated = tf.tensor_scatter_nd_sub(tensor, indices, updates) print(updated)  
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">The resulting tensor would look like this:</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">[[[-4, -4, -4, -4], [-5, -5, -5, -5], [-6, -6, -6, -6], [-7, -7, -7, -7]],
 [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],
 [[-4, -4, -4, -4], [-5, -5, -5, -5], [-6, -6, -6, -6], [-7, -7, -7, -7]],
 [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]]</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Note that on CPU, if an out of bound index is found, an error is returned.
On GPU, if an out of bound index is found, the index is ignored.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Args:
* scope: A Scope object
* tensor: Tensor to copy/update.
* indices: Index tensor.
* updates: Updates to scatter into output.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">    Returns:
    * `Output`: A new tensor copied from tensor and updates subtracted according to the indices. */
class TensorScatterSub {
 public:
  TensorScatterSub(const tensorflow::Scope&amp; scope, tensorflow::Input tensor,
                 tensorflow::Input indices, tensorflow::Input updates);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/** Scatter `updates` into an existing tensor according to `indices`.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">This operation creates a new tensor by applying sparse `updates` to the passed
in `tensor`.
This operation is very similar to tf.scatter_nd, except that the updates are
scattered onto an existing tensor (as opposed to a zero-tensor). If the memory
for the existing tensor cannot be re-used, a copy is made and updated.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">If `indices` contains duplicates, then we pick the last update for the index.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">If an out of bound index is found on CPU, an error is returned.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">**WARNING**: There are some GPU specific semantics for this operation.</pre>
<ul>
<li>If an out of bound index is found, the index is ignored.</li>
<li>The order in which updates are applied is nondeterministic, so the output will be nondeterministic if `indices` contains duplicates.</li>
</ul> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">`indices` is an integer tensor containing indices into a new tensor of shape
`shape`.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">* `indices` must have at least 2 axes: `(num_updates, index_depth)`.
* The last axis of `indices` is how deep to index into `tensor` so  this index
  depth must be less than the rank of `tensor`: `indices.shape[-1] &lt;= tensor.ndim`</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">if `indices.shape[-1] = tensor.rank` this Op indexes and updates scalar elements.
if `indices.shape[-1] &lt; tensor.rank` it indexes and updates slices of the input
`tensor`.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Each `update` has a rank of `tensor.rank - indices.shape[-1]`.
The overall shape of `updates` is:</pre> 
 indices.shape[:-1] + tensor.shape[indices.shape[-1]:]  
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">For usage examples see the python [tf.tensor_scatter_nd_update](
https://www.tensorflow.org/api_docs/python/tf/tensor_scatter_nd_update) function</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Args:
* scope: A Scope object
* tensor: Tensor to copy/update.
* indices: Index tensor.
* updates: Updates to scatter into output.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">    Returns:
    * `Output`: A new tensor with the given shape and updates applied according
    to the indices. */
class TensorScatterUpdate {
 public:
  TensorScatterUpdate(const tensorflow::Scope&amp; scope, tensorflow::Input
                    tensor, tensorflow::Input indices, tensorflow::Input
                    updates);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/** Assign `value` to the sliced l-value reference of `input`.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">The values of `value` are assigned to the positions in the tensor `input` that
are selected by the slice parameters. The slice parameters `begin` `end`
`strides` etc. work exactly as in `StridedSlice`.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">NOTE this op currently does not support broadcasting and so `value`'s shape
must be exactly the shape produced by the slice of `input`.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Args:
* scope: A Scope object</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">    Returns:
    * `Output`: The output tensor. */
class TensorStridedSliceUpdate {
 public:
  /// Optional attribute setters for TensorStridedSliceUpdate
  struct Attrs {
    /// Defaults to 0
    TF_MUST_USE_RESULT Attrs BeginMask(int64 x) {
      Attrs ret = *this;
      ret.begin_mask_ = x;
      return ret;
    }</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/// Defaults to 0
TF_MUST_USE_RESULT Attrs EndMask(int64 x) {
  Attrs ret = *this;
  ret.end_mask_ = x;
  return ret;
}</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/// Defaults to 0
TF_MUST_USE_RESULT Attrs EllipsisMask(int64 x) {
  Attrs ret = *this;
  ret.ellipsis_mask_ = x;
  return ret;
}</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/// Defaults to 0
TF_MUST_USE_RESULT Attrs NewAxisMask(int64 x) {
  Attrs ret = *this;
  ret.new_axis_mask_ = x;
  return ret;
}</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/// Defaults to 0
TF_MUST_USE_RESULT Attrs ShrinkAxisMask(int64 x) {
  Attrs ret = *this;
  ret.shrink_axis_mask_ = x;
  return ret;
}</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">  int64 begin_mask_ = 0;
  int64 end_mask_ = 0;
  int64 ellipsis_mask_ = 0;
  int64 new_axis_mask_ = 0;
  int64 shrink_axis_mask_ = 0;
};
TensorStridedSliceUpdate(const tensorflow::Scope&amp; scope, tensorflow::Input
                       input, tensorflow::Input begin, tensorflow::Input
                       end, tensorflow::Input strides, tensorflow::Input
                       value);
TensorStridedSliceUpdate(const tensorflow::Scope&amp; scope, tensorflow::Input
                       input, tensorflow::Input begin, tensorflow::Input
                       end, tensorflow::Input strides, tensorflow::Input
                       value, const TensorStridedSliceUpdate::Attrs&amp; attrs);
operator ::tensorflow::Output() const { return output; }
operator ::tensorflow::Input() const { return output; }
::tensorflow::Node* node() const { return output.node(); }</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">static Attrs BeginMask(int64 x) {
  return Attrs().BeginMask(x);
}
static Attrs EndMask(int64 x) {
  return Attrs().EndMask(x);
}
static Attrs EllipsisMask(int64 x) {
  return Attrs().EllipsisMask(x);
}
static Attrs NewAxisMask(int64 x) {
  return Attrs().NewAxisMask(x);
}
static Attrs ShrinkAxisMask(int64 x) {
  return Attrs().ShrinkAxisMask(x);
}</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/** Constructs a tensor by tiling a given tensor.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">This operation creates a new tensor by replicating `input` `multiples` times.
The output tensor's i'th dimension has `input.dims(i) * multiples[i]` elements,
and the values of `input` are replicated `multiples[i]` times along the 'i'th
dimension. For example, tiling `[a b c d]` by `[2]` produces
`[a b c d a b c d]`.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">&gt;&gt;&gt; a = tf.constant([[1,2,3],[4,5,6]], tf.int32)
&gt;&gt;&gt; b = tf.constant([1,2], tf.int32)
&gt;&gt;&gt; tf.tile(a, b)

&gt;&gt;&gt; c = tf.constant([2,1], tf.int32)
&gt;&gt;&gt; tf.tile(a, c)

&gt;&gt;&gt; d = tf.constant([2,2], tf.int32)
&gt;&gt;&gt; tf.tile(a, d)
</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Args:
* scope: A Scope object
* input: 1-D or higher.
* multiples: 1-D. Length must be the same as the number of dimensions in `input`</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">    Returns:
    * `Output`: The output tensor. */
class Tile {
 public:
  Tile(const tensorflow::Scope&amp; scope, tensorflow::Input input,
     tensorflow::Input multiples);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/** Shuffle dimensions of x according to a permutation.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">The output `y` has the same rank as `x`. The shapes of `x` and `y` satisfy:
  `y.shape[i] == x.shape[perm[i]] for i in [0, 1, ..., rank(x) - 1]`</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Args:
* scope: A Scope object</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">    Returns:
    * `Output`: The y tensor. */
class Transpose {
 public:
  Transpose(const tensorflow::Scope&amp; scope, tensorflow::Input x,
          tensorflow::Input perm);
  operator ::tensorflow::Output() const { return y; }
  operator ::tensorflow::Input() const { return y; }
  ::tensorflow::Node* node() const { return y.node(); }</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Operation operation;
  tensorflow::Output y;
};</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/** Finds unique elements in a 1-D tensor.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">This operation returns a tensor `y` containing all of the unique elements of `x`
sorted in the same order that they occur in `x`; `x` does not need to be sorted.
This operation also returns a tensor `idx` the same size as `x` that contains
the index of each value of `x` in the unique output `y`. In other words:</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">`y[idx[i]] = x[i] for i in [0, 1,...,rank(x) - 1]`</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Examples:</pre> 
 <h1 id="tensor-x-is-[1,-1,-2,-4,-4,-4,-7,-8,-8]" data-text="tensor 'x' is [1, 1, 2, 4, 4, 4, 7, 8, 8]">tensor 'x' is [1, 1, 2, 4, 4, 4, 7, 8, 8]</h1> <p>y, idx = unique(x) y ==&gt; [1, 2, 4, 7, 8] idx ==&gt; [0, 0, 1, 2, 2, 2, 3, 4, 4] </p>
 
 <h1 id="tensor-x-is-[4,-5,-1,-2,-3,-3,-4,-5]" data-text="tensor 'x' is [4, 5, 1, 2, 3, 3, 4, 5]">tensor 'x' is [4, 5, 1, 2, 3, 3, 4, 5]</h1> <p>y, idx = unique(x) y ==&gt; [4, 5, 1, 2, 3] idx ==&gt; [0, 1, 2, 3, 4, 4, 0, 1] </p>
 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Args:
* scope: A Scope object
* x: 1-D.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">    Returns:
    * `Output` y: 1-D.
    * `Output` idx: 1-D. */
class Unique {
 public:
  /// Optional attribute setters for Unique
  struct Attrs {
    /// Defaults to DT_INT32
    TF_MUST_USE_RESULT Attrs OutIdx(DataType x) {
      Attrs ret = *this;
      ret.out_idx_ = x;
      return ret;
    }</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">  DataType out_idx_ = DT_INT32;
};
Unique(const ::tensorflow::Scope&amp; scope, ::tensorflow::Input x);
Unique(const tensorflow::Scope&amp; scope, tensorflow::Input x, const
     Unique::Attrs&amp; attrs);</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">static Attrs OutIdx(DataType x) {
  return Attrs().OutIdx(x);
}</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Operation operation;
  tensorflow::Output y;
  tensorflow::Output idx;
};</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/** Finds unique elements along an axis of a tensor.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">This operation either returns a tensor `y` containing unique elements
along the `axis` of a tensor. The returned unique elements is sorted
in the same order as they occur along `axis` in `x`.
This operation also returns a tensor `idx` that is the same size as
the number of the elements in `x` along the `axis` dimension. It
contains the index in the unique output `y`.
In other words, for an `1-D` tensor `x` with `axis = None:</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">`y[idx[i]] = x[i] for i in [0, 1,...,rank(x) - 1]`</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">For example:</pre> 
 <h1 id="tensor-x-is-[1,-1,-2,-4,-4,-4,-7,-8,-8]_1" data-text="tensor 'x' is [1, 1, 2, 4, 4, 4, 7, 8, 8]">tensor 'x' is [1, 1, 2, 4, 4, 4, 7, 8, 8]</h1> <p>y, idx = unique(x) y ==&gt; [1, 2, 4, 7, 8] idx ==&gt; [0, 0, 1, 2, 2, 2, 3, 4, 4] </p>
 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">For an `2-D` tensor `x` with `axis = 0`:</pre> 
 <h1 id="tensor-x-is-[[1,-0,-0]," data-text="tensor 'x' is [[1, 0, 0],">tensor 'x' is [[1, 0, 0],</h1> 
<h1 id="[1,-0,-0]," data-text="[1, 0, 0],">[1, 0, 0],</h1> 
<h1 id="[2,-0,-0]]" data-text="[2, 0, 0]]">[2, 0, 0]]</h1> <p>y, idx = unique(x, axis=0) y ==&gt; [[1, 0, 0], [2, 0, 0]] idx ==&gt; [0, 0, 1] </p>
 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">For an `2-D` tensor `x` with `axis = 1`:</pre> 
 <h1 id="tensor-x-is-[[1,-0,-0],_1" data-text="tensor 'x' is [[1, 0, 0],">tensor 'x' is [[1, 0, 0],</h1> 
<h1 id="[1,-0,-0],_1" data-text="[1, 0, 0],">[1, 0, 0],</h1> 
<h1 id="[2,-0,-0]]_1" data-text="[2, 0, 0]]">[2, 0, 0]]</h1> <p>y, idx = unique(x, axis=1) y ==&gt; [[1, 0], [1, 0], [2, 0]] idx ==&gt; [0, 1, 1] </p>
 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Args:
* scope: A Scope object
* x: A `Tensor`.
* axis: A `Tensor` of type `int32` (default: None). The axis of the Tensor to
find the unique elements.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">    Returns:
    * `Output` y: A `Tensor`. Unique elements along the `axis` of `Tensor` x.
    * `Output` idx: A 1-D Tensor. Has the same type as x that contains the index of each
    value of x in the output y. */
class UniqueV2 {
 public:
  /// Optional attribute setters for UniqueV2
  struct Attrs {
    /// Defaults to DT_INT32
    TF_MUST_USE_RESULT Attrs OutIdx(DataType x) {
      Attrs ret = *this;
      ret.out_idx_ = x;
      return ret;
    }</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">  DataType out_idx_ = DT_INT32;
};
UniqueV2(const tensorflow::Scope&amp; scope, tensorflow::Input x,
       tensorflow::Input axis);
UniqueV2(const tensorflow::Scope&amp; scope, tensorflow::Input x,
       tensorflow::Input axis, const UniqueV2::Attrs&amp; attrs);</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">static Attrs OutIdx(DataType x) {
  return Attrs().OutIdx(x);
}</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Operation operation;
  tensorflow::Output y;
  tensorflow::Output idx;
};</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/** Finds unique elements in a 1-D tensor.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">This operation returns a tensor `y` containing all of the unique elements of `x`
sorted in the same order that they occur in `x`. This operation also returns a
tensor `idx` the same size as `x` that contains the index of each value of `x`
in the unique output `y`. Finally, it returns a third tensor `count` that
contains the count of each element of `y` in `x`. In other words:</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">`y[idx[i]] = x[i] for i in [0, 1,...,rank(x) - 1]`</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">For example:</pre> 
 <h1 id="tensor-x-is-[1,-1,-2,-4,-4,-4,-7,-8,-8]_2" data-text="tensor 'x' is [1, 1, 2, 4, 4, 4, 7, 8, 8]">tensor 'x' is [1, 1, 2, 4, 4, 4, 7, 8, 8]</h1> <p>y, idx, count = unique_with_counts(x) y ==&gt; [1, 2, 4, 7, 8] idx ==&gt; [0, 0, 1, 2, 2, 2, 3, 4, 4] count ==&gt; [2, 1, 3, 1, 2] </p>
 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Args:
* scope: A Scope object
* x: 1-D.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">    Returns:
    * `Output` y: 1-D.
    * `Output` idx: 1-D.
    * `Output` count: 1-D. */
class UniqueWithCounts {
 public:
  /// Optional attribute setters for UniqueWithCounts
  struct Attrs {
    /// Defaults to DT_INT32
    TF_MUST_USE_RESULT Attrs OutIdx(DataType x) {
      Attrs ret = *this;
      ret.out_idx_ = x;
      return ret;
    }</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">  DataType out_idx_ = DT_INT32;
};
UniqueWithCounts(const ::tensorflow::Scope&amp; scope, ::tensorflow::Input x);
UniqueWithCounts(const tensorflow::Scope&amp; scope, tensorflow::Input x, const
               UniqueWithCounts::Attrs&amp; attrs);</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">static Attrs OutIdx(DataType x) {
  return Attrs().OutIdx(x);
}</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Operation operation;
  tensorflow::Output y;
  tensorflow::Output idx;
  tensorflow::Output count;
};</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/** Finds unique elements along an axis of a tensor.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">This operation either returns a tensor `y` containing unique elements
along the `axis` of a tensor. The returned unique elements is sorted
in the same order as they occur along `axis` in `x`.
This operation also returns a tensor `idx` and a tensor `count`
that are the same size as the number of the elements in `x` along the
`axis` dimension. The `idx` contains the index in the unique output `y`
and the `count` contains the count in the unique output `y`.
In other words, for an `1-D` tensor `x` with `axis = None:</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">`y[idx[i]] = x[i] for i in [0, 1,...,rank(x) - 1]`</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">For example:</pre> 
 x = tf.constant([1, 1, 2, 4, 4, 4, 7, 8, 8]) y, idx, count = UniqueWithCountsV2(x, axis = [0]) y ==&gt; [1, 2, 4, 7, 8] idx ==&gt; [0, 0, 1, 2, 2, 2, 3, 4, 4] count ==&gt; [2, 1, 3, 1, 2]  
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">For a `2-D` tensor `x` with `axis = 0`:</pre> 
 x = tf.constant([[1, 0, 0], [1, 0, 0], [2, 0, 0]]) y, idx, count = UniqueWithCountsV2(x, axis=[0]) y ==&gt; [[1, 0, 0], [2, 0, 0]] idx ==&gt; [0, 0, 1] count ==&gt; [2, 1]  
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">For a `2-D` tensor `x` with `axis = 1`:</pre> 
 x = tf.constant([[1, 0, 0], [1, 0, 0], [2, 0, 0]]) y, idx, count = UniqueWithCountsV2(x, axis=[1]) y ==&gt; [[1, 0], [1, 0], [2, 0]] idx ==&gt; [0, 1, 1] count ==&gt; [1, 2]  
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Args:
* scope: A Scope object
* x: A `Tensor`.
* axis: A `Tensor` of type `int32` (default: None). The axis of the Tensor to
find the unique elements.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">    Returns:
    * `Output` y: A `Tensor`. Unique elements along the `axis` of `Tensor` x.
    * `Output` idx: A 1-D Tensor. Has the same type as x that contains the index of each
    value of x in the output y.
    * `Output` count: A 1-D Tensor. The count of each value of x in the output y. */
class UniqueWithCountsV2 {
 public:
  /// Optional attribute setters for UniqueWithCountsV2
  struct Attrs {
    /// Defaults to DT_INT32
    TF_MUST_USE_RESULT Attrs OutIdx(DataType x) {
      Attrs ret = *this;
      ret.out_idx_ = x;
      return ret;
    }</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">  DataType out_idx_ = DT_INT32;
};
UniqueWithCountsV2(const tensorflow::Scope&amp; scope, tensorflow::Input x,
                 tensorflow::Input axis);
UniqueWithCountsV2(const tensorflow::Scope&amp; scope, tensorflow::Input x,
                 tensorflow::Input axis, const UniqueWithCountsV2::Attrs&amp;
                 attrs);</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">static Attrs OutIdx(DataType x) {
  return Attrs().OutIdx(x);
}</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Operation operation;
  tensorflow::Output y;
  tensorflow::Output idx;
  tensorflow::Output count;
};</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/** Unpacks a given dimension of a rank-`R` tensor into `num` rank-`(R-1)` tensors.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Unpacks `num` tensors from `value` by chipping it along the `axis` dimension.
For example, given a tensor of shape `(A, B, C, D)`;</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">If `axis == 0` then the i'th tensor in `output` is the slice `value[i, :, :, :]`
  and each tensor in `output` will have shape `(B, C, D)`. (Note that the
  dimension unpacked along is gone, unlike `split`).</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">If `axis == 1` then the i'th tensor in `output` is the slice `value[:, i, :, :]`
  and each tensor in `output` will have shape `(A, C, D)`.
Etc.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">This is the opposite of `pack`.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Args:
* scope: A Scope object
* value: 1-D or higher, with `axis` dimension size equal to `num`.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Optional attributes (see `Attrs`):
* axis: Dimension along which to unpack.  Negative values wrap around, so the
valid range is `[-R, R)`.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">    Returns:
    * `OutputList`: The list of tensors unpacked from `value`. */
class Unstack {
 public:
  /// Optional attribute setters for Unstack
  struct Attrs {
    /** Dimension along which to unpack.  Negative values wrap around, so the
        valid range is `[-R, R)`.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">    Defaults to 0 */
TF_MUST_USE_RESULT Attrs Axis(int64 x) {
  Attrs ret = *this;
  ret.axis_ = x;
  return ret;
}</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">  int64 axis_ = 0;
};
Unstack(const ::tensorflow::Scope&amp; scope, ::tensorflow::Input value, int64 num);
Unstack(const tensorflow::Scope&amp; scope, tensorflow::Input value, int64 num,
      const Unstack::Attrs&amp; attrs);
tensorflow::Output operator[](size_t index) const { return output[index]; }</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">static Attrs Axis(int64 x) {
  return Attrs().Axis(x);
}</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Operation operation;
  ::tensorflow::OutputList output;
};</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/** Converts an array of flat indices into a tuple of coordinate arrays.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Example:</pre> 
 y = tf.unravel_index(indices=[2, 5, 7], dims=[3, 3]) <h1 id="dims-represent-a-hypothetical-3,-3-tensor-of-indices:" data-text="'dims' represent a hypothetical (3, 3) tensor of indices:">'dims' represent a hypothetical (3, 3) tensor of indices:</h1> 
<h1 id="[[0,-1,-2]," data-text="[[0, 1, 2],">[[0, 1, <i>2</i>],</h1> 
<h1 id="[3,-4,-5]," data-text="[3, 4, 5],">[3, 4, <i>5</i>],</h1> 
<h1 id="[6,-7,-8]]" data-text="[6, 7, 8]]">[6, <i>7</i>, 8]]</h1> 
<h1 id="for-each-entry-from-indices,-this-operation-returns" data-text="For each entry from 'indices', this operation returns">For each entry from 'indices', this operation returns</h1> 
<h1 id="its-coordinates-marked-with-,-such-as" data-text="its coordinates (marked with '*'), such as">its coordinates (marked with '*'), such as</h1> 
<h1 id="2-==-0,-2" data-text="2 ==&gt; (0, 2)">2 ==&gt; (0, 2)</h1> 
<h1 id="5-==-1,-2" data-text="5 ==&gt; (1, 2)">5 ==&gt; (1, 2)</h1> 
<h1 id="7-==-2,-1" data-text="7 ==&gt; (2, 1)">7 ==&gt; (2, 1)</h1> <p>y ==&gt; [[0, 1, 2], [2, 2, 1]] </p>
 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">(numpy)
Equivalent to np.unravel_index
</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Args:
* scope: A Scope object
* indices: An 0-D or 1-D `int` Tensor whose elements are indices into the
flattened version of an array of dimensions dims.
* dims: An 1-D `int` Tensor. The shape of the array to use for unraveling
indices.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">    Returns:
    * `Output`: An 2-D (or 1-D if indices is 0-D) tensor where each row has the
    same shape as the indices array. */
class UnravelIndex {
 public:
  UnravelIndex(const tensorflow::Scope&amp; scope, tensorflow::Input indices,
             tensorflow::Input dims);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">/** Returns locations of nonzero / true values in a tensor.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">This operation returns the coordinates of true elements in `condition`. The
coordinates are returned in a 2-D tensor where the first dimension (rows)
represents the number of true elements, and the second dimension (columns)
represents the coordinates of the true elements. Keep in mind, the shape of
the output tensor can vary depending on how many true values there are in
`condition`. Indices are output in row-major order.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">For example:</pre> 
 <h1 id="input-tensor-is-[[true,-false]" data-text="'input' tensor is [[True, False]">'input' tensor is [[True, False]</h1> 
<h1 id="[true,-false]]" data-text="[True, False]]">[True, False]]</h1> 
<h1 id="input-has-two-true-values,-so-output-has-two-coordinates." data-text="'input' has two true values, so output has two coordinates.">'input' has two true values, so output has two coordinates.</h1> 
<h1 id="input-has-rank-of-2,-so-coordinates-have-two-indices." data-text="'input' has rank of 2, so coordinates have two indices.">'input' has rank of 2, so coordinates have two indices.</h1> <p>where(input) ==&gt; [[0, 0], [1, 0]]</p> 
<h1 id="condition-tensor-is-[[[true,-false]" data-text="condition tensor is [[[True, False]">
<code translate="no" dir="ltr">condition</code> tensor is [[[True, False]</h1> 
<h1 id="[true,-false]]_1" data-text="[True, False]]">[True, False]]</h1> 
<h1 id="[[false,-true]" data-text="[[False, True]">[[False, True]</h1> 
<h1 id="[false,-true]]" data-text="[False, True]]">[False, True]]</h1> 
<h1 id="[[false,-false]" data-text="[[False, False]">[[False, False]</h1> 
<h1 id="[false,-true]]]" data-text="[False, True]]]">[False, True]]]</h1> 
<h1 id="input-has-5-true-values,-so-output-has-5-coordinates." data-text="'input' has 5 true values, so output has 5 coordinates.">'input' has 5 true values, so output has 5 coordinates.</h1> 
<h1 id="input-has-rank-of-3,-so-coordinates-have-three-indices." data-text="'input' has rank of 3, so coordinates have three indices.">'input' has rank of 3, so coordinates have three indices.</h1> <p>where(input) ==&gt; [[0, 0, 0], [0, 1, 0], [1, 0, 1], [1, 1, 1], [2, 1, 1]]</p> 
<h1 id="condition-tensor-is-[[[1.5,-0.0]" data-text="condition tensor is [[[1.5, 0.0]">
<code translate="no" dir="ltr">condition</code> tensor is [[[1.5, 0.0]</h1> 
<h1 id="[-0.5,-0.0]]" data-text="[-0.5, 0.0]]">[-0.5, 0.0]]</h1> 
<h1 id="[[0.0,-0.25]" data-text="[[0.0, 0.25]">[[0.0, 0.25]</h1> 
<h1 id="[0.0,-0.75]]" data-text="[0.0, 0.75]]">[0.0, 0.75]]</h1> 
<h1 id="[[0.0,-0.0]" data-text="[[0.0, 0.0]">[[0.0, 0.0]</h1> 
<h1 id="[0.0,-0.01]]]" data-text="[0.0, 0.01]]]">[0.0, 0.01]]]</h1> 
<h1 id="input-has-5-nonzero-values,-so-output-has-5-coordinates." data-text="'input' has 5 nonzero values, so output has 5 coordinates.">'input' has 5 nonzero values, so output has 5 coordinates.</h1> 
<h1 id="input-has-rank-of-3,-so-coordinates-have-three-indices._1" data-text="'input' has rank of 3, so coordinates have three indices.">'input' has rank of 3, so coordinates have three indices.</h1> <p>where(input) ==&gt; [[0, 0, 0], [0, 1, 0], [1, 0, 1], [1, 1, 1], [2, 1, 1]]</p> 
<h1 id="condition-tensor-is-[[[1.5-+-0.0j,-0.0-+-0.0j]" data-text="condition tensor is [[[1.5 + 0.0j, 0.0 + 0.0j]">
<code translate="no" dir="ltr">condition</code> tensor is [[[1.5 + 0.0j, 0.0 + 0.0j]</h1> 
<h1 id="[0.0-+-0.5j,-0.0-+-0.0j]]" data-text="[0.0 + 0.5j, 0.0 + 0.0j]]">[0.0 + 0.5j, 0.0 + 0.0j]]</h1> 
<h1 id="[[0.0-+-0.0j,-0.25-+-1.5j]" data-text="[[0.0 + 0.0j, 0.25 + 1.5j]">[[0.0 + 0.0j, 0.25 + 1.5j]</h1> 
<h1 id="[0.0-+-0.0j,-0.75-+-0.0j]]" data-text="[0.0 + 0.0j, 0.75 + 0.0j]]">[0.0 + 0.0j, 0.75 + 0.0j]]</h1> 
<h1 id="[[0.0-+-0.0j,-0.0-+-0.0j]" data-text="[[0.0 + 0.0j, 0.0 + 0.0j]">[[0.0 + 0.0j, 0.0 + 0.0j]</h1> 
<h1 id="[0.0-+-0.0j,-0.01-+-0.0j]]]" data-text="[0.0 + 0.0j, 0.01 + 0.0j]]]">[0.0 + 0.0j, 0.01 + 0.0j]]]</h1> 
<h1 id="input-has-5-nonzero-magnitude-values,-so-output-has-5-coordinates." data-text="'input' has 5 nonzero magnitude values, so output has 5 coordinates.">'input' has 5 nonzero magnitude values, so output has 5 coordinates.</h1> 
<h1 id="input-has-rank-of-3,-so-coordinates-have-three-indices._2" data-text="'input' has rank of 3, so coordinates have three indices.">'input' has rank of 3, so coordinates have three indices.</h1> <p>where(input) ==&gt; [[0, 0, 0], [0, 1, 0], [1, 0, 1], [1, 1, 1], [2, 1, 1]] ```</p> <p>Args:</p>
<ul> <li>scope: A <a href="../scope#classtensorflow_1_1_scope">Scope</a> object</li> </ul> <p>Returns:</p>
<ul> <li>
<code translate="no" dir="ltr"><a href="../output#classtensorflow_1_1_output">Output</a></code>: The index tensor. </li> </ul> <table class="constructors responsive"> <tr> <th colspan="2"> Constructors and Destructors </th> </tr> <tr> <td colspan="2"> <code translate="no" dir="ltr"><a href="#classtensorflow_1_1ops_1_1_where_1a3e4c07125f4b04d6f3a0f99a616273de">Where</a>(const ::<a href="../scope#classtensorflow_1_1_scope">tensorflow::Scope</a> &amp; scope, ::<a href="../input#classtensorflow_1_1_input">tensorflow::Input</a> condition)</code> <br> </td> </tr> </table> <table class="properties responsive"> <tr> <th colspan="2"> Public attributes </th> </tr> <tr> <td> <code translate="no" dir="ltr"><a href="#classtensorflow_1_1ops_1_1_where_1aa3b91b7d267d5cee38568a7d1f97647d">index</a></code> </td> <td> <div> <code translate="no" dir="ltr">::<a href="../output#classtensorflow_1_1_output">tensorflow::Output</a></code> </div> </td> </tr> <tr> <td> <code translate="no" dir="ltr"><a href="#classtensorflow_1_1ops_1_1_where_1ad713509ff4e38a2f5241d9b2cee7b296">operation</a></code> </td> <td> <div> <code translate="no" dir="ltr"><a href="../operation#classtensorflow_1_1_operation">Operation</a></code> </div> </td> </tr> </table> <table class="methods responsive"> <tr> <th colspan="2"> Public functions </th> </tr> <tr> <td> <code translate="no" dir="ltr"><a href="#classtensorflow_1_1ops_1_1_where_1a76eb69d2e854554e8ae583dba19f1df4">node</a>() const </code> </td> <td> <div> <code translate="no" dir="ltr">::tensorflow::Node *</code> </div> </td> </tr> <tr> <td> <code translate="no" dir="ltr"><a href="#classtensorflow_1_1ops_1_1_where_1a80da544c59726a48be37767fb8fe3c91">operator::tensorflow::Input</a>() const </code> </td> <td>  </td> </tr> <tr> <td> <code translate="no" dir="ltr"><a href="#classtensorflow_1_1ops_1_1_where_1a5662e0fc5b2303a6072fb9aba2cec345">operator::tensorflow::Output</a>() const </code> </td> <td>  </td> </tr> </table> <h2 id="public-attributes_1" data-text="Public attributes">Public attributes</h2> <div id="classtensorflow_1_1ops_1_1_where_1aa3b91b7d267d5cee38568a7d1f97647d"> <h3 id="index" data-text="index">index</h3> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">::tensorflow::Output index</pre>  </div> <div id="classtensorflow_1_1ops_1_1_where_1ad713509ff4e38a2f5241d9b2cee7b296"> <h3 id="operation" data-text="operation">operation</h3> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Operation operation</pre>  </div> <h2 id="public-functions_1" data-text="Public functions">Public functions</h2> <div id="classtensorflow_1_1ops_1_1_where_1a3e4c07125f4b04d6f3a0f99a616273de"> <h3 id="where" data-text="Where">Where</h3> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp"> Where(
  const ::tensorflow::Scope &amp; scope,
  ::tensorflow::Input condition
)</pre>  </div> <div id="classtensorflow_1_1ops_1_1_where_1a76eb69d2e854554e8ae583dba19f1df4"> <h3 id="node" data-text="node">node</h3> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">::tensorflow::Node * node() const </pre>  </div> <div id="classtensorflow_1_1ops_1_1_where_1a80da544c59726a48be37767fb8fe3c91"> <h3 id="operator::tensorflow::input" data-text="operator::tensorflow::Input">operator::tensorflow::Input</h3> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">operator::tensorflow::Input() const </pre>  </div> <div id="classtensorflow_1_1ops_1_1_where_1a5662e0fc5b2303a6072fb9aba2cec345"> <h3 id="operator::tensorflow::output" data-text="operator::tensorflow::Output">operator::tensorflow::Output</h3> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">operator::tensorflow::Output() const </pre>  </div>  <devsite-thumb-rating position="footer"> </devsite-thumb-rating><div class="_attribution">
  <p class="_attribution-p">
     2022 The TensorFlow Authors. All rights reserved.<br>Licensed under the Creative Commons Attribution License 4.0.<br>Code samples licensed under the Apache 2.0 License.<br>
    <a href="https://www.tensorflow.org/versions/r2.9/api_docs/cc/class/tensorflow/ops/where" class="_attribution-link">https://www.tensorflow.org/versions/r2.9/api_docs/cc/class/tensorflow/ops/where</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
