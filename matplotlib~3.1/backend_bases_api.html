
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Backend_bases - Matplotlib 3.1 - W3cubDocs</title>
  
  <meta name="description" content=" Abstract base classes define the primitives that renderers and graphics contexts must implement to serve as a matplotlib backend ">
  <meta name="keywords" content="matplotlib, backend, bases, matplotlib~3.1">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/matplotlib~3.1/backend_bases_api.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/matplotlib~3.1.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/matplotlib~3.1/" class="_nav-link" title="" style="margin-left:0;">Matplotlib 3.1</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _sphinx">
				
				
<h1 id="matplotlib-backend-bases">matplotlib.backend_bases</h1> <p id="module-matplotlib.backend_bases">Abstract base classes define the primitives that renderers and graphics contexts must implement to serve as a matplotlib backend</p> <dl class="docutils"> <dt>
 <a class="reference internal" href="#matplotlib.backend_bases.RendererBase" title="matplotlib.backend_bases.RendererBase"><code>RendererBase</code></a>
</dt> <dd>An abstract base class to handle drawing/rendering operations.</dd> <dt>
 <a class="reference internal" href="#matplotlib.backend_bases.FigureCanvasBase" title="matplotlib.backend_bases.FigureCanvasBase"><code>FigureCanvasBase</code></a>
</dt> <dd>The abstraction layer that separates the <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>matplotlib.figure.Figure</code></a> from the backend specific details like a user interface drawing area</dd> <dt>
 <a class="reference internal" href="#matplotlib.backend_bases.GraphicsContextBase" title="matplotlib.backend_bases.GraphicsContextBase"><code>GraphicsContextBase</code></a>
</dt> <dd>An abstract base class that provides color, line styles, etc...</dd> <dt>
 <a class="reference internal" href="#matplotlib.backend_bases.Event" title="matplotlib.backend_bases.Event"><code>Event</code></a>
</dt> <dd>The base class for all of the matplotlib event handling. Derived classes such as <a class="reference internal" href="#matplotlib.backend_bases.KeyEvent" title="matplotlib.backend_bases.KeyEvent"><code>KeyEvent</code></a> and <a class="reference internal" href="#matplotlib.backend_bases.MouseEvent" title="matplotlib.backend_bases.MouseEvent"><code>MouseEvent</code></a> store the meta data like keys and buttons pressed, x and y locations in pixel and <a class="reference internal" href="axes_api#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code>Axes</code></a> coordinates.</dd> <dt>
 <a class="reference internal" href="#matplotlib.backend_bases.ShowBase" title="matplotlib.backend_bases.ShowBase"><code>ShowBase</code></a>
</dt> <dd>The base class for the Show class of each interactive backend; the 'show' callable is then set to Show.__call__, inherited from ShowBase.</dd> <dt>
 <a class="reference internal" href="#matplotlib.backend_bases.ToolContainerBase" title="matplotlib.backend_bases.ToolContainerBase"><code>ToolContainerBase</code></a>
</dt> <dd>The base class for the Toolbar class of each interactive backend.</dd> <dt>
 <a class="reference internal" href="#matplotlib.backend_bases.StatusbarBase" title="matplotlib.backend_bases.StatusbarBase"><code>StatusbarBase</code></a>
</dt> <dd>The base class for the messaging area.</dd> </dl> <dl class="class"> <dt id="matplotlib.backend_bases.CloseEvent">
<code>class matplotlib.backend_bases.CloseEvent(name, canvas, guiEvent=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#CloseEvent"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.backend_bases.Event" title="matplotlib.backend_bases.Event"><code>matplotlib.backend_bases.Event</code></a></p> <p>An event triggered by a figure being closed.</p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backend_bases.DrawEvent">
<code>class matplotlib.backend_bases.DrawEvent(name, canvas, renderer)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#DrawEvent"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.backend_bases.Event" title="matplotlib.backend_bases.Event"><code>matplotlib.backend_bases.Event</code></a></p> <p>An event triggered by a draw operation on the canvas</p> <p>In most backends callbacks subscribed to this callback will be fired after the rendering is complete but before the screen is updated. Any extra artists drawn to the canvas's renderer will be reflected without an explicit call to <code>blit</code>.</p> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">Calling <code>canvas.draw</code> and <code>canvas.blit</code> in these callbacks may not be safe with all backends and may cause infinite recursion.</p> </div> <p>In addition to the <a class="reference internal" href="#matplotlib.backend_bases.Event" title="matplotlib.backend_bases.Event"><code>Event</code></a> attributes, the following event attributes are defined:</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Attributes:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>renderer : RendererBase</code> </dt> <dd>
<p class="first last">the renderer for the draw event</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backend_bases.Event">
<code>class matplotlib.backend_bases.Event(name, canvas, guiEvent=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#Event"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code>object</code></a></p> <p>A matplotlib event. Attach additional attributes as defined in <a class="reference internal" href="#matplotlib.backend_bases.FigureCanvasBase.mpl_connect" title="matplotlib.backend_bases.FigureCanvasBase.mpl_connect"><code>FigureCanvasBase.mpl_connect()</code></a>. The following attributes are defined and shown with their default values</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Attributes:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>name : str</code> </dt> <dd>
<p class="first last">the event name</p> </dd> <dt>
<code>canvas : FigureCanvasBase</code> </dt> <dd>
<p class="first last">the backend-specific canvas instance generating the event</p> </dd> <dt><strong>guiEvent</strong></dt> <dd>
<p class="first last">the GUI event that triggered the matplotlib event</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backend_bases.FigureCanvasBase">
<code>class matplotlib.backend_bases.FigureCanvasBase(figure)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureCanvasBase"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code>object</code></a></p> <p>The canvas the figure renders into.</p> <p>Public attributes</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Attributes:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>figure : matplotlib.figure.Figure</code> </dt> <dd>
<p class="first last">A high-level figure instance</p> </dd> </dl> </td> </tr>  </table> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.blit">
<code>blit(self, bbox=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureCanvasBase.blit"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Blit the canvas in bbox (default entire canvas).</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.button_press_event">
<code>button_press_event(self, x, y, button, dblclick=False, guiEvent=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureCanvasBase.button_press_event"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Backend derived classes should call this function on any mouse button press. x,y are the canvas coords: 0,0 is lower, left. button and key are as defined in <a class="reference internal" href="#matplotlib.backend_bases.MouseEvent" title="matplotlib.backend_bases.MouseEvent"><code>MouseEvent</code></a>.</p> <p>This method will be call all functions connected to the 'button_press_event' with a <a class="reference internal" href="#matplotlib.backend_bases.MouseEvent" title="matplotlib.backend_bases.MouseEvent"><code>MouseEvent</code></a> instance.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.button_release_event">
<code>button_release_event(self, x, y, button, guiEvent=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureCanvasBase.button_release_event"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Backend derived classes should call this function on any mouse button release.</p> <p>This method will call all functions connected to the 'button_release_event' with a <a class="reference internal" href="#matplotlib.backend_bases.MouseEvent" title="matplotlib.backend_bases.MouseEvent"><code>MouseEvent</code></a> instance.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>x : scalar</code> </dt> <dd>
<p class="first last">the canvas coordinates where 0=left</p> </dd> <dt>
<code>y : scalar</code> </dt> <dd>
<p class="first last">the canvas coordinates where 0=bottom</p> </dd> <dt><strong>guiEvent</strong></dt> <dd>
<p class="first last">the native UI event that generated the mpl event</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.close_event">
<code>close_event(self, guiEvent=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureCanvasBase.close_event"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Pass a <a class="reference internal" href="#matplotlib.backend_bases.CloseEvent" title="matplotlib.backend_bases.CloseEvent"><code>CloseEvent</code></a> to all functions connected to <code>close_event</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.draw">
<code>draw(self, *args, **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureCanvasBase.draw"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Render the <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>Figure</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.draw_cursor">
<code>draw_cursor(self, event)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureCanvasBase.draw_cursor"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Draw a cursor in the event.axes if inaxes is not None. Use native GUI drawing for efficiency if possible</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.draw_event">
<code>draw_event(self, renderer)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureCanvasBase.draw_event"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Pass a <a class="reference internal" href="#matplotlib.backend_bases.DrawEvent" title="matplotlib.backend_bases.DrawEvent"><code>DrawEvent</code></a> to all functions connected to <code>draw_event</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.draw_idle">
<code>draw_idle(self, *args, **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureCanvasBase.draw_idle"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Request a widget redraw once control returns to the GUI event loop.</p> <p>Even if multiple calls to <a class="reference internal" href="#matplotlib.backend_bases.FigureCanvasBase.draw_idle" title="matplotlib.backend_bases.FigureCanvasBase.draw_idle"><code>draw_idle</code></a> occur before control returns to the GUI event loop, the figure will only be rendered once.</p> <h4 class="rubric">Notes</h4> <p>Backends may choose to override the method and implement their own strategy to prevent multiple renderings.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.enter_notify_event">
<code>enter_notify_event(self, guiEvent=None, xy=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureCanvasBase.enter_notify_event"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Backend derived classes should call this function when entering canvas</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt><strong>guiEvent</strong></dt> <dd>
<p class="first last">the native UI event that generated the mpl event</p> </dd> <dt>
<code>xy : (float, float)</code> </dt> <dd>
<p class="first last">the coordinate location of the pointer when the canvas is entered</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.backend_bases.FigureCanvasBase.events">
<code>events = ['resize_event', 'draw_event', 'key_press_event', 'key_release_event', 'button_press_event', 'button_release_event', 'scroll_event', 'motion_notify_event', 'pick_event', 'idle_event', 'figure_enter_event', 'figure_leave_event', 'axes_enter_event', 'axes_leave_event', 'close_event']</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.backend_bases.FigureCanvasBase.filetypes">
<code>filetypes = {'eps': 'Encapsulated Postscript', 'jpeg': 'Joint Photographic Experts Group', 'jpg': 'Joint Photographic Experts Group', 'pdf': 'Portable Document Format', 'pgf': 'PGF code for LaTeX', 'png': 'Portable Network Graphics', 'ps': 'Postscript', 'raw': 'Raw RGBA bitmap', 'rgba': 'Raw RGBA bitmap', 'svg': 'Scalable Vector Graphics', 'svgz': 'Scalable Vector Graphics', 'tif': 'Tagged Image File Format', 'tiff': 'Tagged Image File Format'}</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.backend_bases.FigureCanvasBase.fixed_dpi">
<code>fixed_dpi = None</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.flush_events">
<code>flush_events(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureCanvasBase.flush_events"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Flush the GUI events for the figure.</p> <p>Interactive backends need to reimplement this method.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.get_default_filename">
<code>get_default_filename(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureCanvasBase.get_default_filename"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a string, which includes extension, suitable for use as a default filename.</p> </dd>
</dl> <dl class="classmethod"> <dt id="matplotlib.backend_bases.FigureCanvasBase.get_default_filetype">
<code>classmethod get_default_filetype()</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureCanvasBase.get_default_filetype"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the default savefig file format as specified in rcParam <code>savefig.format</code>. Returned string excludes period. Overridden in backends that only support a single file type.</p> </dd>
</dl> <dl class="classmethod"> <dt id="matplotlib.backend_bases.FigureCanvasBase.get_supported_filetypes">
<code>classmethod get_supported_filetypes()</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureCanvasBase.get_supported_filetypes"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return dict of savefig file formats supported by this backend</p> </dd>
</dl> <dl class="classmethod"> <dt id="matplotlib.backend_bases.FigureCanvasBase.get_supported_filetypes_grouped">
<code>classmethod get_supported_filetypes_grouped()</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureCanvasBase.get_supported_filetypes_grouped"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a dict of savefig file formats supported by this backend, where the keys are a file type name, such as 'Joint Photographic Experts Group', and the values are a list of filename extensions used for that filetype, such as ['jpg', 'jpeg'].</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.get_width_height">
<code>get_width_height(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureCanvasBase.get_width_height"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the figure width and height in points or pixels (depending on the backend), truncated to integers</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.get_window_title">
<code>get_window_title(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureCanvasBase.get_window_title"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the title text of the window containing the figure. Return None if there is no window (e.g., a PS backend).</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.grab_mouse">
<code>grab_mouse(self, ax)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureCanvasBase.grab_mouse"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the child axes which are currently grabbing the mouse events. Usually called by the widgets themselves. It is an error to call this if the mouse is already grabbed by another axes.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.inaxes">
<code>inaxes(self, xy)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureCanvasBase.inaxes"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Check if a point is in an axes.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>xy : tuple or list</code> </dt> <dd>
<p class="first last">(x,y) coordinates. x position - pixels from left of canvas. y position - pixels from bottom of canvas.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>axes: topmost axes containing the point, or None if no axes.</dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.is_saving">
<code>is_saving(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureCanvasBase.is_saving"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns whether the renderer is in the process of saving to a file, rather than rendering for an on-screen buffer.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.key_press_event">
<code>key_press_event(self, key, guiEvent=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureCanvasBase.key_press_event"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Pass a <a class="reference internal" href="#matplotlib.backend_bases.KeyEvent" title="matplotlib.backend_bases.KeyEvent"><code>KeyEvent</code></a> to all functions connected to <code>key_press_event</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.key_release_event">
<code>key_release_event(self, key, guiEvent=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureCanvasBase.key_release_event"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Pass a <a class="reference internal" href="#matplotlib.backend_bases.KeyEvent" title="matplotlib.backend_bases.KeyEvent"><code>KeyEvent</code></a> to all functions connected to <code>key_release_event</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.leave_notify_event">
<code>leave_notify_event(self, guiEvent=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureCanvasBase.leave_notify_event"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Backend derived classes should call this function when leaving canvas</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt><strong>guiEvent</strong></dt> <dd>
<p class="first last">the native UI event that generated the mpl event</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.motion_notify_event">
<code>motion_notify_event(self, x, y, guiEvent=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureCanvasBase.motion_notify_event"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Backend derived classes should call this function on any motion-notify-event.</p> <p>This method will call all functions connected to the 'motion_notify_event' with a <a class="reference internal" href="#matplotlib.backend_bases.MouseEvent" title="matplotlib.backend_bases.MouseEvent"><code>MouseEvent</code></a> instance.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>x : scalar</code> </dt> <dd>
<p class="first last">the canvas coordinates where 0=left</p> </dd> <dt>
<code>y : scalar</code> </dt> <dd>
<p class="first last">the canvas coordinates where 0=bottom</p> </dd> <dt><strong>guiEvent</strong></dt> <dd>
<p class="first last">the native UI event that generated the mpl event</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.mpl_connect">
<code>mpl_connect(self, s, func)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureCanvasBase.mpl_connect"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Connect event with string <em>s</em> to <em>func</em>. The signature of <em>func</em> is:</p> <pre data-language="python">def func(event)
</pre> <p>where event is a <a class="reference internal" href="#matplotlib.backend_bases.Event" title="matplotlib.backend_bases.Event"><code>matplotlib.backend_bases.Event</code></a>. The following events are recognized</p> <ul class="simple"> <li>'button_press_event'</li> <li>'button_release_event'</li> <li>'draw_event'</li> <li>'key_press_event'</li> <li>'key_release_event'</li> <li>'motion_notify_event'</li> <li>'pick_event'</li> <li>'resize_event'</li> <li>'scroll_event'</li> <li>'figure_enter_event',</li> <li>'figure_leave_event',</li> <li>'axes_enter_event',</li> <li>'axes_leave_event'</li> <li>'close_event'</li> </ul> <p>For the location events (button and key press/release), if the mouse is over the axes, the variable <code>event.inaxes</code> will be set to the <a class="reference internal" href="axes_api#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code>Axes</code></a> the event occurs is over, and additionally, the variables <code>event.xdata</code> and <code>event.ydata</code> will be defined. This is the mouse location in data coords. See <a class="reference internal" href="#matplotlib.backend_bases.KeyEvent" title="matplotlib.backend_bases.KeyEvent"><code>KeyEvent</code></a> and <a class="reference internal" href="#matplotlib.backend_bases.MouseEvent" title="matplotlib.backend_bases.MouseEvent"><code>MouseEvent</code></a> for more info.</p> <p>Return value is a connection id that can be used with <code>mpl_disconnect()</code>.</p> <h4 class="rubric">Examples</h4> <p>Usage:</p> <pre data-language="python">def on_press(event):
    print('you pressed', event.button, event.xdata, event.ydata)

cid = canvas.mpl_connect('button_press_event', on_press)
</pre> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.mpl_disconnect">
<code>mpl_disconnect(self, cid)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureCanvasBase.mpl_disconnect"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Disconnect callback id cid</p> <h4 class="rubric">Examples</h4> <p>Usage:</p> <pre data-language="python">cid = canvas.mpl_connect('button_press_event', on_press)
#...later
canvas.mpl_disconnect(cid)
</pre> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.new_timer">
<code>new_timer(self, *args, **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureCanvasBase.new_timer"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Creates a new backend-specific subclass of <code>backend_bases.Timer</code>. This is useful for getting periodic events through the backend's native event loop. Implemented only for backends with GUIs.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Other Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>interval : scalar</code> </dt> <dd>
<p class="first last">Timer interval in milliseconds</p> </dd> <dt>
<code>callbacks : List[Tuple[callable, Tuple, Dict]]</code> </dt> <dd>
<p class="first">Sequence of (func, args, kwargs) where <code>func(*args, **kwargs)</code> will be executed by the timer every <em>interval</em>.</p> <p class="last">callbacks which return <code>False</code> or <code>0</code> will be removed from the timer.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; timer = fig.canvas.new_timer(callbacks=[(f1, (1, ), {'a': 3}),])
</pre> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.pick">
<code>pick(self, mouseevent)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureCanvasBase.pick"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.pick_event">
<code>pick_event(self, mouseevent, artist, **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureCanvasBase.pick_event"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>This method will be called by artists who are picked and will fire off <a class="reference internal" href="#matplotlib.backend_bases.PickEvent" title="matplotlib.backend_bases.PickEvent"><code>PickEvent</code></a> callbacks registered listeners</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.print_figure">
<code>print_figure(self, filename, dpi=None, facecolor=None, edgecolor=None, orientation='portrait', format=None, *, bbox_inches=None, **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureCanvasBase.print_figure"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Render the figure to hardcopy. Set the figure patch face and edge colors. This is useful because some of the GUIs have a gray figure face color background and you'll probably want to override this on hardcopy.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt><strong>filename</strong></dt> <dd>
<p class="first last">can also be a file object on image backends</p> </dd> <dt>
<code>orientation : {'landscape', 'portrait'}, optional</code> </dt> <dd>
<p class="first last">only currently applies to PostScript printing.</p> </dd> <dt>
<code>dpi : scalar, optional</code> </dt> <dd>
<p class="first last">the dots per inch to save the figure in; if None, use savefig.dpi</p> </dd> <dt>
<code>facecolor : color or None, optional</code> </dt> <dd>
<p class="first last">the facecolor of the figure; if None, defaults to savefig.facecolor</p> </dd> <dt>
<code>edgecolor : color or None, optional</code> </dt> <dd>
<p class="first last">the edgecolor of the figure; if None, defaults to savefig.edgecolor</p> </dd> <dt>
<code>format : str, optional</code> </dt> <dd>
<p class="first last">when set, forcibly set the file format to save to</p> </dd> <dt>
<code>bbox_inches : str or Bbox, optional</code> </dt> <dd>
<p class="first last">Bbox in inches. Only the given portion of the figure is saved. If 'tight', try to figure out the tight bbox of the figure. If None, use savefig.bbox</p> </dd> <dt>
<code>pad_inches : scalar, optional</code> </dt> <dd>
<p class="first last">Amount of padding around the figure when bbox_inches is 'tight'. If None, use savefig.pad_inches</p> </dd> <dt>
<code>bbox_extra_artists : list of Artist, optional</code> </dt> <dd>
<p class="first last">A list of extra artists that will be considered when the tight bbox is calculated.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.release_mouse">
<code>release_mouse(self, ax)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureCanvasBase.release_mouse"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Release the mouse grab held by the axes, ax. Usually called by the widgets. It is ok to call this even if you ax doesn't have the mouse grab currently.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.resize">
<code>resize(self, w, h)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureCanvasBase.resize"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the canvas size in pixels.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.resize_event">
<code>resize_event(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureCanvasBase.resize_event"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Pass a <a class="reference internal" href="#matplotlib.backend_bases.ResizeEvent" title="matplotlib.backend_bases.ResizeEvent"><code>ResizeEvent</code></a> to all functions connected to <code>resize_event</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.scroll_event">
<code>scroll_event(self, x, y, step, guiEvent=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureCanvasBase.scroll_event"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Backend derived classes should call this function on any scroll wheel event. x,y are the canvas coords: 0,0 is lower, left. button and key are as defined in MouseEvent.</p> <p>This method will be call all functions connected to the 'scroll_event' with a <a class="reference internal" href="#matplotlib.backend_bases.MouseEvent" title="matplotlib.backend_bases.MouseEvent"><code>MouseEvent</code></a> instance.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.set_window_title">
<code>set_window_title(self, title)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureCanvasBase.set_window_title"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the title text of the window containing the figure. Note that this has no effect if there is no window (e.g., a PS backend).</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.start_event_loop">
<code>start_event_loop(self, timeout=0)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureCanvasBase.start_event_loop"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Start a blocking event loop.</p> <p>Such an event loop is used by interactive functions, such as <code>ginput</code> and <code>waitforbuttonpress</code>, to wait for events.</p> <p>The event loop blocks until a callback function triggers <a class="reference internal" href="#matplotlib.backend_bases.FigureCanvasBase.stop_event_loop" title="matplotlib.backend_bases.FigureCanvasBase.stop_event_loop"><code>stop_event_loop</code></a>, or <em>timeout</em> is reached.</p> <p>If <em>timeout</em> is negative, never timeout.</p> <p>Only interactive backends need to reimplement this method and it relies on <a class="reference internal" href="#matplotlib.backend_bases.FigureCanvasBase.flush_events" title="matplotlib.backend_bases.FigureCanvasBase.flush_events"><code>flush_events</code></a> being properly implemented.</p> <p>Interactive backends should implement this in a more native way.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.stop_event_loop">
<code>stop_event_loop(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureCanvasBase.stop_event_loop"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Stop the current blocking event loop.</p> <p>Interactive backends need to reimplement this to match <a class="reference internal" href="#matplotlib.backend_bases.FigureCanvasBase.start_event_loop" title="matplotlib.backend_bases.FigureCanvasBase.start_event_loop"><code>start_event_loop</code></a></p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.backend_bases.FigureCanvasBase.supports_blit">
<code>supports_blit = True</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.switch_backends">
<code>switch_backends(self, FigureCanvasClass)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureCanvasBase.switch_backends"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Instantiate an instance of FigureCanvasClass</p> <p>This is used for backend switching, e.g., to instantiate a FigureCanvasPS from a FigureCanvasGTK. Note, deep copying is not done, so any changes to one of the instances (e.g., setting figure size or line props), will be reflected in the other</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backend_bases.FigureManagerBase">
<code>class matplotlib.backend_bases.FigureManagerBase(canvas, num)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureManagerBase"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code>object</code></a></p> <p>Helper class for pyplot mode, wraps everything up into a neat bundle</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Attributes:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>canvas : FigureCanvasBase</code> </dt> <dd>
<p class="first last">The backend-specific canvas instance</p> </dd> <dt>
<code>num : int or str</code> </dt> <dd>
<p class="first last">The figure number</p> </dd> <dt>
<code>key_press_handler_id : int</code> </dt> <dd>
<p class="first">The default key handler cid, when using the toolmanager. To disable the default key press handling use:</p> <pre data-language="python">figure.canvas.mpl_disconnect(
    figure.canvas.manager.key_press_handler_id)
</pre> </dd> <dt>
<code>button_press_handler_id : int</code> </dt> <dd>
<p class="first">The default mouse button handler cid, when using the toolmanager. To disable the default button press handling use:</p> <pre data-language="python">figure.canvas.mpl_disconnect(
    figure.canvas.manager.button_press_handler_id)
</pre> </dd> </dl> </td> </tr>  </table> <dl class="method"> <dt id="matplotlib.backend_bases.FigureManagerBase.button_press">
<code>button_press(self, event)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureManagerBase.button_press"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>The default Matplotlib button actions for extra mouse buttons.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureManagerBase.destroy">
<code>destroy(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureManagerBase.destroy"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureManagerBase.full_screen_toggle">
<code>full_screen_toggle(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureManagerBase.full_screen_toggle"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureManagerBase.get_window_title">
<code>get_window_title(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureManagerBase.get_window_title"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the title text of the window containing the figure.</p> <p>Return None for non-GUI (e.g., PS) backends.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureManagerBase.key_press">
<code>key_press(self, event)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureManagerBase.key_press"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Implement the default mpl key bindings defined at <a class="reference internal" href="https://matplotlib.org/3.1.1/users/navigation_toolbar.html#key-event-handling"><span class="std std-ref">Navigation Keyboard Shortcuts</span></a></p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureManagerBase.resize">
<code>resize(self, w, h)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureManagerBase.resize"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>"For GUI backends, resize the window (in pixels).</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureManagerBase.set_window_title">
<code>set_window_title(self, title)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureManagerBase.set_window_title"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the title text of the window containing the figure.</p> <p>This has no effect for non-GUI (e.g., PS) backends.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureManagerBase.show">
<code>show(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#FigureManagerBase.show"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>For GUI backends, show the figure window and redraw. For non-GUI backends, raise an exception to be caught by <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure.show" title="matplotlib.figure.Figure.show"><code>show()</code></a>, for an optional warning.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backend_bases.GraphicsContextBase">
<code>class matplotlib.backend_bases.GraphicsContextBase</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#GraphicsContextBase"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code>object</code></a></p> <p>An abstract base class that provides color, line styles, etc.</p> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.copy_properties">
<code>copy_properties(self, gc)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#GraphicsContextBase.copy_properties"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Copy properties from gc to self</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.get_alpha">
<code>get_alpha(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#GraphicsContextBase.get_alpha"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the alpha value used for blending - not supported on all backends.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.get_antialiased">
<code>get_antialiased(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#GraphicsContextBase.get_antialiased"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return whether the object should try to do antialiased rendering.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.get_capstyle">
<code>get_capstyle(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#GraphicsContextBase.get_capstyle"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the capstyle as a string in ('butt', 'round', 'projecting').</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.get_clip_path">
<code>get_clip_path(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#GraphicsContextBase.get_clip_path"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the clip path in the form (path, transform), where path is a <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance, and transform is an affine transform to apply to the path before clipping.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.get_clip_rectangle">
<code>get_clip_rectangle(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#GraphicsContextBase.get_clip_rectangle"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the clip rectangle as a <a class="reference internal" href="transformations#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> instance.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.get_dashes">
<code>get_dashes(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#GraphicsContextBase.get_dashes"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the dash information as an offset dashlist tuple.</p> <p>The dash list is a even size list that gives the ink on, ink off in pixels.</p> <p>See p107 of to PostScript <a class="reference external" href="https://www-cdf.fnal.gov/offline/PostScript/BLUEBOOK.PDF">BLUEBOOK</a> for more info.</p> <p>Default value is None</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.get_forced_alpha">
<code>get_forced_alpha(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#GraphicsContextBase.get_forced_alpha"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return whether the value given by get_alpha() should be used to override any other alpha-channel values.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.get_gid">
<code>get_gid(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#GraphicsContextBase.get_gid"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the object identifier if one is set, None otherwise.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.get_hatch">
<code>get_hatch(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#GraphicsContextBase.get_hatch"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the current hatch style.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.get_hatch_color">
<code>get_hatch_color(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#GraphicsContextBase.get_hatch_color"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the hatch color.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.get_hatch_linewidth">
<code>get_hatch_linewidth(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#GraphicsContextBase.get_hatch_linewidth"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the hatch linewidth.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.get_hatch_path">
<code>get_hatch_path(self, density=6.0)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#GraphicsContextBase.get_hatch_path"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a <code>Path</code> for the current hatch.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.get_joinstyle">
<code>get_joinstyle(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#GraphicsContextBase.get_joinstyle"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the line join style as one of ('miter', 'round', 'bevel').</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.get_linewidth">
<code>get_linewidth(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#GraphicsContextBase.get_linewidth"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the line width in points.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.get_rgb">
<code>get_rgb(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#GraphicsContextBase.get_rgb"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a tuple of three or four floats from 0-1.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.get_sketch_params">
<code>get_sketch_params(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#GraphicsContextBase.get_sketch_params"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the sketch parameters for the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>sketch_params : tuple or None</code> </dt> <dd>
<p class="first">A 3-tuple with the following elements:</p> <ul class="simple"> <li>
<code>scale</code>: The amplitude of the wiggle perpendicular to the source line.</li> <li>
<code>length</code>: The length of the wiggle along the line.</li> <li>
<code>randomness</code>: The scale factor by which the length is shrunken or expanded.</li> </ul> <p class="last">May return <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)"><code>None</code></a> if no sketch parameters were set.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.get_snap">
<code>get_snap(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#GraphicsContextBase.get_snap"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns the snap setting, which can be:</p> <ul class="simple"> <li>True: snap vertices to the nearest pixel center</li> <li>False: leave vertices as-is</li> <li>None: (auto) If the path contains only rectilinear line segments, round to the nearest pixel center</li> </ul> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.get_url">
<code>get_url(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#GraphicsContextBase.get_url"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a url if one is set, None otherwise.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.restore">
<code>restore(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#GraphicsContextBase.restore"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Restore the graphics context from the stack - needed only for backends that save graphics contexts on a stack.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.set_alpha">
<code>set_alpha(self, alpha)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#GraphicsContextBase.set_alpha"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the alpha value used for blending - not supported on all backends.</p> <p>If <code>alpha=None</code> (the default), the alpha components of the foreground and fill colors will be used to set their respective transparencies (where applicable); otherwise, <code>alpha</code> will override them.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.set_antialiased">
<code>set_antialiased(self, b)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#GraphicsContextBase.set_antialiased"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set whether object should be drawn with antialiased rendering.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.set_capstyle">
<code>set_capstyle(self, cs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#GraphicsContextBase.set_capstyle"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the capstyle to be one of ('butt', 'round', 'projecting').</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.set_clip_path">
<code>set_clip_path(self, path)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#GraphicsContextBase.set_clip_path"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the clip path and transformation. Path should be a <a class="reference internal" href="transformations#matplotlib.transforms.TransformedPath" title="matplotlib.transforms.TransformedPath"><code>TransformedPath</code></a> instance.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.set_clip_rectangle">
<code>set_clip_rectangle(self, rectangle)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#GraphicsContextBase.set_clip_rectangle"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the clip rectangle with sequence (left, bottom, width, height)</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.set_dashes">
<code>set_dashes(self, dash_offset, dash_list)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#GraphicsContextBase.set_dashes"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the dash style for the gc.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>dash_offset : float</code> </dt> <dd>
<p class="first last">is the offset (usually 0).</p> </dd> <dt>
<code>dash_list : array_like</code> </dt> <dd>
<p class="first last">specifies the on-off sequence as points. <code>(None, None)</code> specifies a solid line</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.set_foreground">
<code>set_foreground(self, fg, isRGBA=False)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#GraphicsContextBase.set_foreground"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the foreground color.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>fg : color</code> </dt>  <dt>
<code>isRGBA : bool</code> </dt> <dd>
<p class="first last">If <em>fg</em> is known to be an <code>(r, g, b, a)</code> tuple, <em>isRGBA</em> can be set to True to improve performance.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.set_gid">
<code>set_gid(self, id)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#GraphicsContextBase.set_gid"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the id.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.set_hatch">
<code>set_hatch(self, hatch)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#GraphicsContextBase.set_hatch"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the hatch style (for fills).</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.set_hatch_color">
<code>set_hatch_color(self, hatch_color)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#GraphicsContextBase.set_hatch_color"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the hatch color.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.set_joinstyle">
<code>set_joinstyle(self, js)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#GraphicsContextBase.set_joinstyle"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the join style to be one of ('miter', 'round', 'bevel').</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.set_linewidth">
<code>set_linewidth(self, w)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#GraphicsContextBase.set_linewidth"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the linewidth in points.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.set_sketch_params">
<code>set_sketch_params(self, scale=None, length=None, randomness=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#GraphicsContextBase.set_sketch_params"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the sketch parameters.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>scale : float, optional</code> </dt> <dd>
<p class="first last">The amplitude of the wiggle perpendicular to the source line, in pixels. If scale is <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)"><code>None</code></a>, or not provided, no sketch filter will be provided.</p> </dd> <dt>
<code>length : float, optional</code> </dt> <dd>
<p class="first last">The length of the wiggle along the line, in pixels (default 128).</p> </dd> <dt>
<code>randomness : float, optional</code> </dt> <dd>
<p class="first last">The scale factor by which the length is shrunken or expanded (default 16).</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.set_snap">
<code>set_snap(self, snap)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#GraphicsContextBase.set_snap"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the snap setting which may be:</p> <ul class="simple"> <li>True: snap vertices to the nearest pixel center</li> <li>False: leave vertices as-is</li> <li>None: (auto) If the path contains only rectilinear line segments, round to the nearest pixel center</li> </ul> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.set_url">
<code>set_url(self, url)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#GraphicsContextBase.set_url"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the url for links in compatible backends.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backend_bases.KeyEvent">
<code>class matplotlib.backend_bases.KeyEvent(name, canvas, key, x=0, y=0, guiEvent=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#KeyEvent"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.backend_bases.LocationEvent" title="matplotlib.backend_bases.LocationEvent"><code>matplotlib.backend_bases.LocationEvent</code></a></p> <p>A key event (key press, key release).</p> <p>Attach additional attributes as defined in <a class="reference internal" href="#matplotlib.backend_bases.FigureCanvasBase.mpl_connect" title="matplotlib.backend_bases.FigureCanvasBase.mpl_connect"><code>FigureCanvasBase.mpl_connect()</code></a>.</p> <p>In addition to the <a class="reference internal" href="#matplotlib.backend_bases.Event" title="matplotlib.backend_bases.Event"><code>Event</code></a> and <a class="reference internal" href="#matplotlib.backend_bases.LocationEvent" title="matplotlib.backend_bases.LocationEvent"><code>LocationEvent</code></a> attributes, the following attributes are defined:</p> <h4 class="rubric">Notes</h4> <p>Modifier keys will be prefixed to the pressed key and will be in the order "ctrl", "alt", "super". The exception to this rule is when the pressed key is itself a modifier key, therefore "ctrl+alt" and "alt+control" can both be valid key values.</p> <h4 class="rubric">Examples</h4> <p>Usage:</p> <pre data-language="python">def on_key(event):
    print('you pressed', event.key, event.xdata, event.ydata)

cid = fig.canvas.mpl_connect('key_press_event', on_key)
</pre> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Attributes:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>key : None or str</code> </dt> <dd>
<p class="first last">the key(s) pressed. Could be <strong>None</strong>, a single case sensitive ascii character ("g", "G", "#", etc.), a special key ("control", "shift", "f1", "up", etc.) or a combination of the above (e.g., "ctrl+alt+g", "ctrl+alt+G").</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backend_bases.LocationEvent">
<code>class matplotlib.backend_bases.LocationEvent(name, canvas, x, y, guiEvent=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#LocationEvent"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.backend_bases.Event" title="matplotlib.backend_bases.Event"><code>matplotlib.backend_bases.Event</code></a></p> <p>An event that has a screen location.</p> <p>The following additional attributes are defined and shown with their default values.</p> <p>In addition to the <a class="reference internal" href="#matplotlib.backend_bases.Event" title="matplotlib.backend_bases.Event"><code>Event</code></a> attributes, the following event attributes are defined:</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Attributes:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>x : scalar</code> </dt> <dd>
<p class="first last">x position - pixels from left of canvas</p> </dd> <dt>
<code>y : scalar</code> </dt> <dd>
<p class="first last">y position - pixels from bottom of canvas</p> </dd> <dt>
<code>inaxes : bool</code> </dt> <dd>
<p class="first last">the <a class="reference internal" href="axes_api#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code>Axes</code></a> instance if mouse is over axes</p> </dd> <dt>
<code>xdata : scalar</code> </dt> <dd>
<p class="first last">x coord of mouse in data coords</p> </dd> <dt>
<code>ydata : scalar</code> </dt> <dd>
<p class="first last">y coord of mouse in data coords</p> </dd> </dl> </td> </tr>  </table> <p><em>x</em>, <em>y</em> in figure coords, 0,0 = bottom, left</p> <dl class="attribute"> <dt id="matplotlib.backend_bases.LocationEvent.lastevent">
<code>lastevent = None</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backend_bases.MouseButton">
<code>class matplotlib.backend_bases.MouseButton</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#MouseButton"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/3/library/enum.html#enum.IntEnum" title="(in Python v3.7)"><code>enum.IntEnum</code></a></p> <p>An enumeration.</p> <dl class="attribute"> <dt id="matplotlib.backend_bases.MouseButton.BACK">
<code>BACK = 8</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.backend_bases.MouseButton.FORWARD">
<code>FORWARD = 9</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.backend_bases.MouseButton.LEFT">
<code>LEFT = 1</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.backend_bases.MouseButton.MIDDLE">
<code>MIDDLE = 2</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.backend_bases.MouseButton.RIGHT">
<code>RIGHT = 3</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backend_bases.MouseEvent">
<code>class matplotlib.backend_bases.MouseEvent(name, canvas, x, y, button=None, key=None, step=0, dblclick=False, guiEvent=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#MouseEvent"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.backend_bases.LocationEvent" title="matplotlib.backend_bases.LocationEvent"><code>matplotlib.backend_bases.LocationEvent</code></a></p> <dl class="docutils"> <dt>A mouse event ('button_press_event',</dt> <dd>'button_release_event', 'scroll_event', 'motion_notify_event').</dd> </dl> <p>In addition to the <a class="reference internal" href="#matplotlib.backend_bases.Event" title="matplotlib.backend_bases.Event"><code>Event</code></a> and <a class="reference internal" href="#matplotlib.backend_bases.LocationEvent" title="matplotlib.backend_bases.LocationEvent"><code>LocationEvent</code></a> attributes, the following attributes are defined:</p> <h4 class="rubric">Examples</h4> <p>Usage:</p> <pre data-language="python">def on_press(event):
    print('you pressed', event.button, event.xdata, event.ydata)

cid = fig.canvas.mpl_connect('button_press_event', on_press)
</pre> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Attributes:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>button : {None, MouseButton.LEFT, MouseButton.MIDDLE, MouseButton.RIGHT, 'up', 'down'}</code> </dt> <dd>
<p class="first last">The button pressed. 'up' and 'down' are used for scroll events. Note that in the nbagg backend, both the middle and right clicks return RIGHT since right clicking will bring up the context menu in some browsers. Note that LEFT and RIGHT actually refer to the "primary" and "secondary" buttons, i.e. if the user inverts their left and right buttons ("left-handed setting") then the LEFT button will be the one physically on the right.</p> </dd> <dt>
<code>key : None or str</code> </dt> <dd>
<p class="first last">The key pressed when the mouse event triggered, e.g. 'shift'. See <a class="reference internal" href="#matplotlib.backend_bases.KeyEvent" title="matplotlib.backend_bases.KeyEvent"><code>KeyEvent</code></a>.</p> </dd> <dt>
<code>step : scalar</code> </dt> <dd>
<p class="first last">The number of scroll steps (positive for 'up', negative for 'down'). This applies only to 'scroll_event' and defaults to 0 otherwise.</p> </dd> <dt>
<code>dblclick : bool</code> </dt> <dd>
<p class="first last">Whether the event is a double-click. This applies only to 'button_press_event' and is False otherwise. In particular, it's not used in 'button_release_event'.</p> </dd> </dl> </td> </tr>  </table> <p>x, y in figure coords, 0,0 = bottom, left button pressed None, 1, 2, 3, 'up', 'down'</p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backend_bases.NavigationToolbar2">
<code>class matplotlib.backend_bases.NavigationToolbar2(canvas)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#NavigationToolbar2"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code>object</code></a></p> <p>Base class for the navigation cursor, version 2</p> <p>backends must implement a canvas that handles connections for 'button_press_event' and 'button_release_event'. See <a class="reference internal" href="#matplotlib.backend_bases.FigureCanvasBase.mpl_connect" title="matplotlib.backend_bases.FigureCanvasBase.mpl_connect"><code>FigureCanvasBase.mpl_connect()</code></a> for more information</p> <p>They must also define</p>  <dl class="docutils"> <dt>
 <a class="reference internal" href="#matplotlib.backend_bases.NavigationToolbar2.save_figure" title="matplotlib.backend_bases.NavigationToolbar2.save_figure"><code>save_figure()</code></a>
</dt> <dd>save the current figure</dd> <dt>
 <a class="reference internal" href="#matplotlib.backend_bases.NavigationToolbar2.set_cursor" title="matplotlib.backend_bases.NavigationToolbar2.set_cursor"><code>set_cursor()</code></a>
</dt> <dd>if you want the pointer icon to change</dd> <dt>
<code>_init_toolbar()</code> </dt> <dd>create your toolbar widget</dd> <dt>
<code>draw_rubberband() (optional)</code> </dt> <dd>draw the zoom to rect "rubberband" rectangle</dd> <dt>
<code>press() (optional)</code> </dt> <dd>whenever a mouse button is pressed, you'll be notified with the event</dd> <dt>
<code>release() (optional)</code> </dt> <dd>whenever a mouse button is released, you'll be notified with the event</dd> <dt>
<code>set_message() (optional)</code> </dt> <dd>display message</dd> <dt>
<code>set_history_buttons() (optional)</code> </dt> <dd>you can change the history back / forward buttons to indicate disabled / enabled state.</dd> </dl>  <p>That's it, we'll do the rest!</p> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.back">
<code>back(self, *args)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#NavigationToolbar2.back"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>move back up the view lim stack</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.drag_pan">
<code>drag_pan(self, event)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#NavigationToolbar2.drag_pan"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Callback for dragging in pan/zoom mode.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.drag_zoom">
<code>drag_zoom(self, event)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#NavigationToolbar2.drag_zoom"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Callback for dragging in zoom mode.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.draw">
<code>draw(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#NavigationToolbar2.draw"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Redraw the canvases, update the locators.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.draw_rubberband">
<code>draw_rubberband(self, event, x0, y0, x1, y1)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#NavigationToolbar2.draw_rubberband"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Draw a rectangle rubberband to indicate zoom limits.</p> <p>Note that it is not guaranteed that <code>x0 &lt;= x1</code> and <code>y0 &lt;= y1</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.forward">
<code>forward(self, *args)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#NavigationToolbar2.forward"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Move forward in the view lim stack.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.home">
<code>home(self, *args)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#NavigationToolbar2.home"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Restore the original view.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.mouse_move">
<code>mouse_move(self, event)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#NavigationToolbar2.mouse_move"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.pan">
<code>pan(self, *args)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#NavigationToolbar2.pan"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Activate the pan/zoom tool. pan with left button, zoom with right</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.press">
<code>press(self, event)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#NavigationToolbar2.press"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Called whenever a mouse button is pressed.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.press_pan">
<code>press_pan(self, event)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#NavigationToolbar2.press_pan"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Callback for mouse button press in pan/zoom mode.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.press_zoom">
<code>press_zoom(self, event)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#NavigationToolbar2.press_zoom"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Callback for mouse button press in zoom to rect mode.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.push_current">
<code>push_current(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#NavigationToolbar2.push_current"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Push the current view limits and position onto the stack.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.release">
<code>release(self, event)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#NavigationToolbar2.release"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Callback for mouse button release.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.release_pan">
<code>release_pan(self, event)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#NavigationToolbar2.release_pan"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Callback for mouse button release in pan/zoom mode.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.release_zoom">
<code>release_zoom(self, event)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#NavigationToolbar2.release_zoom"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Callback for mouse button release in zoom to rect mode.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.remove_rubberband">
<code>remove_rubberband(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#NavigationToolbar2.remove_rubberband"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Remove the rubberband.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.save_figure">
<code>save_figure(self, *args)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#NavigationToolbar2.save_figure"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Save the current figure.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.set_cursor">
<code>set_cursor(self, cursor)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#NavigationToolbar2.set_cursor"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the current cursor to one of the <code>Cursors</code> enums values.</p> <p>If required by the backend, this method should trigger an update in the backend event loop after the cursor is set, as this method may be called e.g. before a long-running task during which the GUI is not updated.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.set_history_buttons">
<code>set_history_buttons(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#NavigationToolbar2.set_history_buttons"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Enable or disable the back/forward button.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.set_message">
<code>set_message(self, s)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#NavigationToolbar2.set_message"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Display a message on toolbar or in status bar.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.backend_bases.NavigationToolbar2.toolitems">
<code>toolitems = (('Home', 'Reset original view', 'home', 'home'), ('Back', 'Back to previous view', 'back', 'back'), ('Forward', 'Forward to next view', 'forward', 'forward'), (None, None, None, None), ('Pan', 'Pan axes with left mouse, zoom with right', 'move', 'pan'), ('Zoom', 'Zoom to rectangle', 'zoom_to_rect', 'zoom'), ('Subplots', 'Configure subplots', 'subplots', 'configure_subplots'), (None, None, None, None), ('Save', 'Save the figure', 'filesave', 'save_figure'))</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.update">
<code>update(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#NavigationToolbar2.update"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Reset the axes stack.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.zoom">
<code>zoom(self, *args)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#NavigationToolbar2.zoom"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Activate zoom to rect mode.</p> </dd>
</dl> </dd>
</dl> <dl class="exception"> <dt id="matplotlib.backend_bases.NonGuiException">
<code>exception matplotlib.backend_bases.NonGuiException</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#NonGuiException"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#Exception" title="(in Python v3.7)"><code>Exception</code></a></p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backend_bases.PickEvent">
<code>class matplotlib.backend_bases.PickEvent(name, canvas, mouseevent, artist, guiEvent=None, **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#PickEvent"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.backend_bases.Event" title="matplotlib.backend_bases.Event"><code>matplotlib.backend_bases.Event</code></a></p> <p>a pick event, fired when the user picks a location on the canvas sufficiently close to an artist.</p> <p>Attrs: all the <a class="reference internal" href="#matplotlib.backend_bases.Event" title="matplotlib.backend_bases.Event"><code>Event</code></a> attributes plus</p> <h4 class="rubric">Examples</h4> <p>Usage:</p> <pre data-language="python">ax.plot(np.rand(100), 'o', picker=5)  # 5 points tolerance

def on_pick(event):
    line = event.artist
    xdata, ydata = line.get_data()
    ind = event.ind
    print('on pick line:', np.array([xdata[ind], ydata[ind]]).T)

cid = fig.canvas.mpl_connect('pick_event', on_pick)
</pre> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Attributes:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>mouseevent : MouseEvent</code> </dt> <dd>
<p class="first last">the mouse event that generated the pick</p> </dd> <dt>
<code>artist : matplotlib.artist.Artist</code> </dt> <dd>
<p class="first last">the picked artist</p> </dd> <dt><strong>other</strong></dt> <dd>
<p class="first last">extra class dependent attrs -- e.g., a <a class="reference internal" href="_as_gen/matplotlib.lines.line2d#matplotlib.lines.Line2D" title="matplotlib.lines.Line2D"><code>Line2D</code></a> pick may define different extra attributes than a <a class="reference internal" href="collections_api#matplotlib.collections.PatchCollection" title="matplotlib.collections.PatchCollection"><code>PatchCollection</code></a> pick event</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backend_bases.RendererBase">
<code>class matplotlib.backend_bases.RendererBase</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#RendererBase"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code>object</code></a></p> <p>An abstract base class to handle drawing/rendering operations.</p> <p>The following methods must be implemented in the backend for full functionality (though just implementing <a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_path" title="matplotlib.backend_bases.RendererBase.draw_path"><code>draw_path()</code></a> alone would give a highly capable backend):</p> <ul class="simple"> <li><a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_path" title="matplotlib.backend_bases.RendererBase.draw_path"><code>draw_path()</code></a></li> <li><a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_image" title="matplotlib.backend_bases.RendererBase.draw_image"><code>draw_image()</code></a></li> <li><a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_gouraud_triangle" title="matplotlib.backend_bases.RendererBase.draw_gouraud_triangle"><code>draw_gouraud_triangle()</code></a></li> </ul> <p>The following methods <em>should</em> be implemented in the backend for optimization reasons:</p> <ul class="simple"> <li><a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_text" title="matplotlib.backend_bases.RendererBase.draw_text"><code>draw_text()</code></a></li> <li><a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_markers" title="matplotlib.backend_bases.RendererBase.draw_markers"><code>draw_markers()</code></a></li> <li><a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_path_collection" title="matplotlib.backend_bases.RendererBase.draw_path_collection"><code>draw_path_collection()</code></a></li> <li><a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_quad_mesh" title="matplotlib.backend_bases.RendererBase.draw_quad_mesh"><code>draw_quad_mesh()</code></a></li> </ul> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.close_group">
<code>close_group(self, s)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#RendererBase.close_group"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Close a grouping element with label <em>s</em></p> <p>Only used by the SVG renderer.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.draw_gouraud_triangle">
<code>draw_gouraud_triangle(self, gc, points, colors, transform)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#RendererBase.draw_gouraud_triangle"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Draw a Gouraud-shaded triangle.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>points : array_like, shape=(3, 2)</code> </dt> <dd>
<p class="first last">Array of (x, y) points for the triangle.</p> </dd> <dt>
<code>colors : array_like, shape=(3, 4)</code> </dt> <dd>
<p class="first last">RGBA colors for each point of the triangle.</p> </dd> <dt>
<code>transform : matplotlib.transforms.Transform</code> </dt> <dd>
<p class="first last">An affine transform to apply to the points.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.draw_gouraud_triangles">
<code>draw_gouraud_triangles(self, gc, triangles_array, colors_array, transform)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#RendererBase.draw_gouraud_triangles"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Draws a series of Gouraud triangles.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>points : array_like, shape=(N, 3, 2)</code> </dt> <dd>
<p class="first last">Array of <em>N</em> (x, y) points for the triangles.</p> </dd> <dt>
<code>colors : array_like, shape=(N, 3, 4)</code> </dt> <dd>
<p class="first last">Array of <em>N</em> RGBA colors for each point of the triangles.</p> </dd> <dt>
<code>transform : matplotlib.transforms.Transform</code> </dt> <dd>
<p class="first last">An affine transform to apply to the points.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.draw_image">
<code>draw_image(self, gc, x, y, im, transform=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#RendererBase.draw_image"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Draw an RGBA image.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>gc : GraphicsContextBase</code> </dt> <dd>
<p class="first last">a graphics context with clipping information.</p> </dd> <dt>
<code>x : scalar</code> </dt> <dd>
<p class="first last">the distance in physical units (i.e., dots or pixels) from the left hand side of the canvas.</p> </dd> <dt>
<code>y : scalar</code> </dt> <dd>
<p class="first last">the distance in physical units (i.e., dots or pixels) from the bottom side of the canvas.</p> </dd> <dt>
<code>im : array_like, shape=(N, M, 4), dtype=np.uint8</code> </dt> <dd>
<p class="first last">An array of RGBA pixels.</p> </dd> <dt>
<code>transform : matplotlib.transforms.Affine2DBase</code> </dt> <dd>
<p class="first last">If and only if the concrete backend is written such that <a class="reference internal" href="#matplotlib.backend_bases.RendererBase.option_scale_image" title="matplotlib.backend_bases.RendererBase.option_scale_image"><code>option_scale_image()</code></a> returns <code>True</code>, an affine transformation <em>may</em> be passed to <a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_image" title="matplotlib.backend_bases.RendererBase.draw_image"><code>draw_image()</code></a>. It takes the form of a <a class="reference internal" href="transformations#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code>Affine2DBase</code></a> instance. The translation vector of the transformation is given in physical units (i.e., dots or pixels). Note that the transformation does not override <code>x</code> and <code>y</code>, and has to be applied <em>before</em> translating the result by <code>x</code> and <code>y</code> (this can be accomplished by adding <code>x</code> and <code>y</code> to the translation vector defined by <code>transform</code>).</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.draw_markers">
<code>draw_markers(self, gc, marker_path, marker_trans, path, trans, rgbFace=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#RendererBase.draw_markers"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Draws a marker at each of the vertices in path. This includes all vertices, including control points on curves. To avoid that behavior, those vertices should be removed before calling this function.</p> <p>This provides a fallback implementation of draw_markers that makes multiple calls to <a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_path" title="matplotlib.backend_bases.RendererBase.draw_path"><code>draw_path()</code></a>. Some backends may want to override this method in order to draw the marker only once and reuse it multiple times.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>gc : GraphicsContextBase</code> </dt> <dd>
<p class="first last">The graphics context</p> </dd> <dt>
<code>marker_trans : matplotlib.transforms.Transform</code> </dt> <dd>
<p class="first last">An affine transform applied to the marker.</p> </dd> <dt>
<code>trans : matplotlib.transforms.Transform</code> </dt> <dd>
<p class="first last">An affine transform applied to the path.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.draw_path">
<code>draw_path(self, gc, path, transform, rgbFace=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#RendererBase.draw_path"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Draws a <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance using the given affine transform.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.draw_path_collection">
<code>draw_path_collection(self, gc, master_transform, paths, all_transforms, offsets, offsetTrans, facecolors, edgecolors, linewidths, linestyles, antialiaseds, urls, offset_position)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#RendererBase.draw_path_collection"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Draws a collection of paths selecting drawing properties from the lists <em>facecolors</em>, <em>edgecolors</em>, <em>linewidths</em>, <em>linestyles</em> and <em>antialiaseds</em>. <em>offsets</em> is a list of offsets to apply to each of the paths. The offsets in <em>offsets</em> are first transformed by <em>offsetTrans</em> before being applied. <em>offset_position</em> may be either "screen" or "data" depending on the space that the offsets are in.</p> <p>This provides a fallback implementation of <a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_path_collection" title="matplotlib.backend_bases.RendererBase.draw_path_collection"><code>draw_path_collection()</code></a> that makes multiple calls to <a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_path" title="matplotlib.backend_bases.RendererBase.draw_path"><code>draw_path()</code></a>. Some backends may want to override this in order to render each set of path data only once, and then reference that path multiple times with the different offsets, colors, styles etc. The generator methods <code>_iter_collection_raw_paths()</code> and <code>_iter_collection()</code> are provided to help with (and standardize) the implementation across backends. It is highly recommended to use those generators, so that changes to the behavior of <a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_path_collection" title="matplotlib.backend_bases.RendererBase.draw_path_collection"><code>draw_path_collection()</code></a> can be made globally.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.draw_quad_mesh">
<code>draw_quad_mesh(self, gc, master_transform, meshWidth, meshHeight, coordinates, offsets, offsetTrans, facecolors, antialiased, edgecolors)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#RendererBase.draw_quad_mesh"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>This provides a fallback implementation of <a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_quad_mesh" title="matplotlib.backend_bases.RendererBase.draw_quad_mesh"><code>draw_quad_mesh()</code></a> that generates paths and then calls <a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_path_collection" title="matplotlib.backend_bases.RendererBase.draw_path_collection"><code>draw_path_collection()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.draw_tex">
<code>draw_tex(self, gc, x, y, s, prop, angle, ismath='TeX!', mtext=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#RendererBase.draw_tex"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.draw_text">
<code>draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#RendererBase.draw_text"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Draw the text instance.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>gc : GraphicsContextBase</code> </dt> <dd>
<p class="first last">The graphics context.</p> </dd> <dt>
<code>x : scalar</code> </dt> <dd>
<p class="first last">The x location of the text in display coords.</p> </dd> <dt>
<code>y : scalar</code> </dt> <dd>
<p class="first last">The y location of the text baseline in display coords.</p> </dd> <dt>
<code>s : str</code> </dt> <dd>
<p class="first last">The text string.</p> </dd> <dt>
<code>prop : matplotlib.font_manager.FontProperties</code> </dt> <dd>
<p class="first last">The font properties.</p> </dd> <dt>
<code>angle : scalar</code> </dt> <dd>
<p class="first last">The rotation angle in degrees.</p> </dd> <dt>
<code>mtext : matplotlib.text.Text</code> </dt> <dd>
<p class="first last">The original text object to be rendered.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p><strong>backend implementers note</strong></p> <p>When you are trying to determine if you have gotten your bounding box right (which is what enables the text layout/alignment to work properly), it helps to change the line in text.py:</p> <pre data-language="python">if 0: bbox_artist(self, renderer)
</pre> <p>to if 1, and then the actual bounding box will be plotted along with your text.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.flipy">
<code>flipy(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#RendererBase.flipy"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return whether y values increase from top to bottom.</p> <p>Note that this only affects drawing of texts and images.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.get_canvas_width_height">
<code>get_canvas_width_height(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#RendererBase.get_canvas_width_height"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the canvas width and height in display coords.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.get_image_magnification">
<code>get_image_magnification(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#RendererBase.get_image_magnification"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the factor by which to magnify images passed to <a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_image" title="matplotlib.backend_bases.RendererBase.draw_image"><code>draw_image()</code></a>. Allows a backend to have images at a different resolution to other artists.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.get_texmanager">
<code>get_texmanager(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#RendererBase.get_texmanager"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the <code>TexManager</code> instance.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.get_text_width_height_descent">
<code>get_text_width_height_descent(self, s, prop, ismath)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#RendererBase.get_text_width_height_descent"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the width, height, and descent (offset from the bottom to the baseline), in display coords, of the string <em>s</em> with <a class="reference internal" href="font_manager_api#matplotlib.font_manager.FontProperties" title="matplotlib.font_manager.FontProperties"><code>FontProperties</code></a> <em>prop</em></p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.new_gc">
<code>new_gc(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#RendererBase.new_gc"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return an instance of a <a class="reference internal" href="#matplotlib.backend_bases.GraphicsContextBase" title="matplotlib.backend_bases.GraphicsContextBase"><code>GraphicsContextBase</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.open_group">
<code>open_group(self, s, gid=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#RendererBase.open_group"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Open a grouping element with label <em>s</em> and <em>gid</em> (if set) as id.</p> <p>Only used by the SVG renderer.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.option_image_nocomposite">
<code>option_image_nocomposite(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#RendererBase.option_image_nocomposite"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return whether image composition by Matplotlib should be skipped.</p> <p>Raster backends should usually return False (letting the C-level rasterizer take care of image composition); vector backends should usually return <code>not rcParams["image.composite_image"]</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.option_scale_image">
<code>option_scale_image(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#RendererBase.option_scale_image"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return whether arbitrary affine transformations in <a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_image" title="matplotlib.backend_bases.RendererBase.draw_image"><code>draw_image()</code></a> are supported (True for most vector backends).</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.points_to_pixels">
<code>points_to_pixels(self, points)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#RendererBase.points_to_pixels"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Convert points to display units.</p> <p>You need to override this function (unless your backend doesn't have a dpi, e.g., postscript or svg). Some imaging systems assume some value for pixels per inch:</p> <pre data-language="python">points to pixels = points * pixels_per_inch/72.0 * dpi/72.0
</pre> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>points : scalar or array_like</code> </dt> <dd>
<p class="first last">a float or a numpy array of float</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>Points converted to pixels</dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.start_filter">
<code>start_filter(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#RendererBase.start_filter"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Switch to a temporary renderer for image filtering effects.</p> <p>Currently only supported by the agg renderer.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.start_rasterizing">
<code>start_rasterizing(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#RendererBase.start_rasterizing"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Switch to the raster renderer.</p> <p>Used by <code>MixedModeRenderer</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.stop_filter">
<code>stop_filter(self, filter_func)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#RendererBase.stop_filter"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Switch back to the original renderer. The contents of the temporary renderer is processed with the <em>filter_func</em> and is drawn on the original renderer as an image.</p> <p>Currently only supported by the agg renderer.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.stop_rasterizing">
<code>stop_rasterizing(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#RendererBase.stop_rasterizing"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Switch back to the vector renderer and draw the contents of the raster renderer as an image on the vector renderer.</p> <p>Used by <code>MixedModeRenderer</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.strip_math">
<code>strip_math(self, s)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#RendererBase.strip_math"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>[<em>Deprecated</em>]</p> <h4 class="rubric">Notes</h4> <div class="deprecated"> <p><span class="versionmodified">Deprecated since version 3.1: </span></p> </div> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backend_bases.ResizeEvent">
<code>class matplotlib.backend_bases.ResizeEvent(name, canvas)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#ResizeEvent"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.backend_bases.Event" title="matplotlib.backend_bases.Event"><code>matplotlib.backend_bases.Event</code></a></p> <p>An event triggered by a canvas resize</p> <p>In addition to the <a class="reference internal" href="#matplotlib.backend_bases.Event" title="matplotlib.backend_bases.Event"><code>Event</code></a> attributes, the following event attributes are defined:</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Attributes:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>width : scalar</code> </dt> <dd>
<p class="first last">width of the canvas in pixels</p> </dd> <dt>
<code>height : scalar</code> </dt> <dd>
<p class="first last">height of the canvas in pixels</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backend_bases.ShowBase">
<code>class matplotlib.backend_bases.ShowBase</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#ShowBase"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <code>matplotlib.backend_bases._Backend</code></p> <p>Simple base class to generate a show() callable in backends.</p> <p>Subclass must override mainloop() method.</p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backend_bases.StatusbarBase">
<code>class matplotlib.backend_bases.StatusbarBase(toolmanager)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#StatusbarBase"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code>object</code></a></p> <p>Base class for the statusbar</p> <dl class="method"> <dt id="matplotlib.backend_bases.StatusbarBase.set_message">
<code>set_message(self, s)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#StatusbarBase.set_message"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Display a message on toolbar or in status bar</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>s : str</code> </dt> <dd>
<p class="first last">Message text</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backend_bases.TimerBase">
<code>class matplotlib.backend_bases.TimerBase(interval=None, callbacks=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#TimerBase"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code>object</code></a></p> <p>A base class for providing timer events, useful for things animations. Backends need to implement a few specific methods in order to use their own timing mechanisms so that the timer events are integrated into their event loops.</p> <p>Mandatory functions that must be implemented:</p>  <ul class="simple"> <li>
<code>_timer_start</code>: Contains backend-specific code for starting the timer</li> <li>
<code>_timer_stop</code>: Contains backend-specific code for stopping the timer</li> </ul>  <p>Optional overrides:</p>  <ul class="simple"> <li>
<code>_timer_set_single_shot</code>: Code for setting the timer to single shot operating mode, if supported by the timer object. If not, the <code>Timer</code> class itself will store the flag and the <code>_on_timer</code> method should be overridden to support such behavior.</li> <li>
<code>_timer_set_interval</code>: Code for setting the interval on the timer, if there is a method for doing so on the timer object.</li> <li>
<code>_on_timer</code>: This is the internal function that any timer object should call, which will handle the task of running all callbacks that have been set.</li> </ul>  <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Attributes:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>interval : scalar</code> </dt> <dd>
<p class="first last">The time between timer events in milliseconds. Default is 1000 ms.</p> </dd> <dt>
<code>single_shot : bool</code> </dt> <dd>
<p class="first last">Boolean flag indicating whether this timer should operate as single shot (run once and then stop). Defaults to <a class="reference external" href="https://docs.python.org/3/library/constants.html#False" title="(in Python v3.7)"><code>False</code></a>.</p> </dd> <dt>
<code>callbacks : List[Tuple[callable, Tuple, Dict]]</code> </dt> <dd>
<p class="first last">Stores list of (func, args, kwargs) tuples that will be called upon timer events. This list can be manipulated directly, or the functions <a class="reference internal" href="#matplotlib.backend_bases.TimerBase.add_callback" title="matplotlib.backend_bases.TimerBase.add_callback"><code>add_callback</code></a> and <a class="reference internal" href="#matplotlib.backend_bases.TimerBase.remove_callback" title="matplotlib.backend_bases.TimerBase.remove_callback"><code>remove_callback</code></a> can be used.</p> </dd> </dl> </td> </tr>  </table> <dl class="method"> <dt id="matplotlib.backend_bases.TimerBase.add_callback">
<code>add_callback(self, func, *args, **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#TimerBase.add_callback"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Register <em>func</em> to be called by timer when the event fires. Any additional arguments provided will be passed to <em>func</em>.</p> <p>This function returns <em>func</em>, which makes it possible to use it as a decorator.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.backend_bases.TimerBase.interval">
<code>interval</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.TimerBase.remove_callback">
<code>remove_callback(self, func, *args, **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#TimerBase.remove_callback"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Remove <em>func</em> from list of callbacks.</p> <p><em>args</em> and <em>kwargs</em> are optional and used to distinguish between copies of the same function registered to be called with different arguments. This behavior is deprecated. In the future, <code>*args, **kwargs</code> won't be considered anymore; to keep a specific callback removable by itself, pass it to <a class="reference internal" href="#matplotlib.backend_bases.TimerBase.add_callback" title="matplotlib.backend_bases.TimerBase.add_callback"><code>add_callback</code></a> as a <a class="reference external" href="https://docs.python.org/3/library/functools.html#functools.partial" title="(in Python v3.7)"><code>functools.partial</code></a> object.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.backend_bases.TimerBase.single_shot">
<code>single_shot</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.TimerBase.start">
<code>start(self, interval=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#TimerBase.start"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Start the timer object.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>interval : int, optional</code> </dt> <dd>
<p class="first last">Timer interval in milliseconds; overrides a previously set interval if provided.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.TimerBase.stop">
<code>stop(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#TimerBase.stop"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Stop the timer.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backend_bases.ToolContainerBase">
<code>class matplotlib.backend_bases.ToolContainerBase(toolmanager)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#ToolContainerBase"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code>object</code></a></p> <p>Base class for all tool containers, e.g. toolbars.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Attributes:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>toolmanager : ToolManager</code> </dt> <dd>
<p class="first last">The tools with which this <code>ToolContainer</code> wants to communicate.</p> </dd> </dl> </td> </tr>  </table> <dl class="method"> <dt id="matplotlib.backend_bases.ToolContainerBase.add_tool">
<code>add_tool(self, tool, group, position=-1)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#ToolContainerBase.add_tool"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Adds a tool to this container</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>tool : tool_like</code> </dt> <dd>
<p class="first last">The tool to add, see <code>ToolManager.get_tool</code>.</p> </dd> <dt>
<code>group : str</code> </dt> <dd>
<p class="first last">The name of the group to add this tool to.</p> </dd> <dt>
<code>position : int (optional)</code> </dt> <dd>
<p class="first last">The position within the group to place this tool. Defaults to end.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.ToolContainerBase.add_toolitem">
<code>add_toolitem(self, name, group, position, image, description, toggle)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#ToolContainerBase.add_toolitem"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Add a toolitem to the container</p> <p>This method must get implemented per backend</p> <p>The callback associated with the button click event, must be <strong>EXACTLY</strong> <code>self.trigger_tool(name)</code></p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>name : string</code> </dt> <dd>
<p class="first last">Name of the tool to add, this gets used as the tool's ID and as the default label of the buttons</p> </dd> <dt>
<code>group : String</code> </dt> <dd>
<p class="first last">Name of the group that this tool belongs to</p> </dd> <dt>
<code>position : Int</code> </dt> <dd>
<p class="first last">Position of the tool within its group, if -1 it goes at the End</p> </dd> <dt>
<code>image_file : String</code> </dt> <dd>
<p class="first last">Filename of the image for the button or <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)"><code>None</code></a></p> </dd> <dt>
<code>description : String</code> </dt> <dd>
<p class="first last">Description of the tool, used for the tooltips</p> </dd> <dt>
<code>toggle : Bool</code> </dt> <dd>
<ul class="first last simple"> <li>
<a class="reference external" href="https://docs.python.org/3/library/constants.html#True" title="(in Python v3.7)"><code>True</code></a> : The button is a toggle (change the pressed/unpressed state between consecutive clicks)</li> <li>
<a class="reference external" href="https://docs.python.org/3/library/constants.html#False" title="(in Python v3.7)"><code>False</code></a> : The button is a normal button (returns to unpressed state after release)</li> </ul> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.ToolContainerBase.remove_toolitem">
<code>remove_toolitem(self, name)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#ToolContainerBase.remove_toolitem"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Remove a toolitem from the <code>ToolContainer</code></p> <p>This method must get implemented per backend</p> <p>Called when <code>ToolManager</code> emits a <code>tool_removed_event</code></p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>name : string</code> </dt> <dd>
<p class="first last">Name of the tool to remove</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.ToolContainerBase.toggle_toolitem">
<code>toggle_toolitem(self, name, toggled)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#ToolContainerBase.toggle_toolitem"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Toggle the toolitem without firing event</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>name : String</code> </dt> <dd>
<p class="first last">Id of the tool to toggle</p> </dd> <dt>
<code>toggled : bool</code> </dt> <dd>
<p class="first last">Whether to set this tool as toggled or not.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.ToolContainerBase.trigger_tool">
<code>trigger_tool(self, name)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#ToolContainerBase.trigger_tool"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Trigger the tool</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>name : string</code> </dt> <dd>
<p class="first last">Name (id) of the tool triggered from within the container</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> </dd>
</dl> <dl class="function"> <dt id="matplotlib.backend_bases.button_press_handler">
<code>matplotlib.backend_bases.button_press_handler(event, canvas, toolbar=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#button_press_handler"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>The default Matplotlib button actions for extra mouse buttons.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.backend_bases.get_registered_canvas_class">
<code>matplotlib.backend_bases.get_registered_canvas_class(format)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#get_registered_canvas_class"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the registered default canvas for given file format. Handles deferred import of required backend.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.backend_bases.key_press_handler">
<code>matplotlib.backend_bases.key_press_handler(event, canvas, toolbar=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#key_press_handler"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Implement the default mpl key bindings for the canvas and toolbar described at <a class="reference internal" href="https://matplotlib.org/3.1.1/users/navigation_toolbar.html#key-event-handling"><span class="std std-ref">Navigation Keyboard Shortcuts</span></a></p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>event : KeyEvent</code> </dt> <dd>
<p class="first last">a key press/release event</p> </dd> <dt>
<code>canvas : FigureCanvasBase</code> </dt> <dd>
<p class="first last">the backend-specific canvas instance</p> </dd> <dt>
<code>toolbar : NavigationToolbar2</code> </dt> <dd>
<p class="first last">the navigation cursor toolbar</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="matplotlib.backend_bases.register_backend">
<code>matplotlib.backend_bases.register_backend(format, backend, description=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backend_bases.html#register_backend"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Register a backend for saving to a given file format.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>format : str</code> </dt> <dd>
<p class="first last">File extension</p> </dd> <dt>
<code>backend : module string or canvas class</code> </dt> <dd>
<p class="first last">Backend for handling file output</p> </dd> <dt>
<code>description : str, optional</code> </dt> <dd>
<p class="first last">Description of the file type. Defaults to an empty string</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
     20122018 Matplotlib Development Team. All rights reserved.<br>Licensed under the Matplotlib License Agreement.<br>
    <a href="https://matplotlib.org/3.1.1/api/backend_bases_api.html" class="_attribution-link">https://matplotlib.org/3.1.1/api/backend_bases_api.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
