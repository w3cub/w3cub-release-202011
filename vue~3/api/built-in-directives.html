
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Built-in Directives - Vue 3 - W3cubDocs</title>
  
  <meta name="description" content=" Update the element&#39;s text content. ">
  <meta name="keywords" content="built-in, directives, vue, vue~3">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/vue~3/api/built-in-directives.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-9c7b0d969c0ce639a6c01c2badcdd81667c7c66206aa3d0fccc5cb0585fb1b912dab72ea882101d18010680927514b4b77b107282db8f756fbf63301fe9c88b0.css">
  <script type="text/javascript" src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js"></script>
  <script src="/json/vue~3.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/vue~3/" class="_nav-link" title="" style="margin-left:0;">Vue 3</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _vue">
				
				
<h1 id="built-in-directives" tabindex="-1">Built-in Directives </h1>
<h2 id="v-text" tabindex="-1">v-text </h2>
<p>Update the element's text content.</p>
<ul>
<li><p><strong>Expects:</strong> <code>string</code></p></li>
<li>
<p><strong>Details</strong></p>
<p><code>v-text</code> works by setting the element's <a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent" target="_blank" rel="noreferrer">textContent</a> property, so it will overwrite any existing content inside the element. If you need to update the part of <code>textContent</code>, you should use <a href="../guide/essentials/template-syntax#text-interpolation">mustache interpolations</a> instead.</p>
</li>
<li>
<p><strong>Example</strong></p>
<pre data-language="template">&lt;span v-text="msg"&gt;&lt;/span&gt;
&lt;!-- same as --&gt;
&lt;span&gt;{{msg}}&lt;/span&gt;</pre>
</li>
<li><p><strong>See also:</strong> <a href="../guide/essentials/template-syntax#text-interpolation">Template Syntax - Text Interpolation</a></p></li>
</ul>
<h2 id="v-html" tabindex="-1">v-html </h2>
<p>Update the element's <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML" target="_blank" rel="noreferrer">innerHTML</a>.</p>
<ul>
<li><p><strong>Expects:</strong> <code>string</code></p></li>
<li>
<p><strong>Details:</strong></p>
<p>Contents of <code>v-html</code> are inserted as plain HTML - Vue template syntax will not be processed. If you find yourself trying to compose templates using <code>v-html</code>, try to rethink the solution by using components instead.</p>
<div class="warning custom-block">
<strong class="custom-block-title">Security Note</strong><p>Dynamically rendering arbitrary HTML on your website can be very dangerous because it can easily lead to <a href="https://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank" rel="noreferrer">XSS attacks</a>. Only use <code>v-html</code> on trusted content and <strong>never</strong> on user-provided content.</p>
</div>
<p>In <a href="../guide/scaling-up/sfc">Single-File Components</a>, <code>scoped</code> styles will not apply to content inside <code>v-html</code>, because that HTML is not processed by Vue's template compiler. If you want to target <code>v-html</code> content with scoped CSS, you can instead use <a href="sfc-css-features#css-modules">CSS modules</a> or an additional, global <code>&lt;style&gt;</code> element with a manual scoping strategy such as BEM.</p>
</li>
<li>
<p><strong>Example:</strong></p>
<pre data-language="template">&lt;div v-html="html"&gt;&lt;/div&gt;</pre>
</li>
<li><p><strong>See also:</strong> <a href="../guide/essentials/template-syntax#raw-html">Template Syntax - Raw HTML</a></p></li>
</ul>
<h2 id="v-show" tabindex="-1">v-show </h2>
<p>Toggle the element's visibility based on the truthy-ness of the expression value.</p>
<ul>
<li><p><strong>Expects:</strong> <code>any</code></p></li>
<li>
<p><strong>Details</strong></p>
<p><code>v-show</code> works by setting the <code>display</code> CSS property via inline styles, and will try to respect the initial <code>display</code> value when the element is visible. It also triggers transitions when its condition changes.</p>
</li>
<li><p><strong>See also:</strong> <a href="../guide/essentials/conditional#v-show">Conditional Rendering - v-show</a></p></li>
</ul>
<h2 id="v-if" tabindex="-1">v-if </h2>
<p>Conditionally render an element or a template fragment based on the truthy-ness of the expression value.</p>
<ul>
<li><p><strong>Expects:</strong> <code>any</code></p></li>
<li>
<p><strong>Details</strong></p>
<p>When a <code>v-if</code> element is toggled, the element and its contained directives / components are destroyed and re-constructed. If the initial condition is falsy, then the inner content won't be rendered at all.</p>
<p>Can be used on <code>&lt;template&gt;</code> to denote a conditional block containing only text or multiple elements.</p>
<p>This directive triggers transitions when its condition changes.</p>
<p>When used together, <code>v-if</code> has a higher priority than <code>v-for</code>. We don't recommend using these two directives together on one element — see the <a href="../guide/essentials/list#v-for-with-v-if">list rendering guide</a> for details.</p>
</li>
<li><p><strong>See also:</strong> <a href="../guide/essentials/conditional#v-if">Conditional Rendering - v-if</a></p></li>
</ul>
<h2 id="v-else" tabindex="-1">v-else </h2>
<p>Denote the "else block" for <code>v-if</code> or a <code>v-if</code> / <code>v-else-if</code> chain.</p>
<ul>
<li><p><strong>Does not expect expression</strong></p></li>
<li>
<p><strong>Details</strong></p>
<ul>
<li><p>Restriction: previous sibling element must have <code>v-if</code> or <code>v-else-if</code>.</p></li>
<li><p>Can be used on <code>&lt;template&gt;</code> to denote a conditional block containing only text or multiple elements.</p></li>
</ul>
</li>
<li>
<p><strong>Example</strong></p>
<pre data-language="template">&lt;div v-if="Math.random() &gt; 0.5"&gt;
  Now you see me
&lt;/div&gt;
&lt;div v-else&gt;
  Now you don't
&lt;/div&gt;</pre>
</li>
<li><p><strong>See also:</strong> <a href="../guide/essentials/conditional#v-else">Conditional Rendering - v-else</a></p></li>
</ul>
<h2 id="v-else-if" tabindex="-1">v-else-if </h2>
<p>Denote the "else if block" for <code>v-if</code>. Can be chained.</p>
<ul>
<li><p><strong>Expects:</strong> <code>any</code></p></li>
<li>
<p><strong>Details</strong></p>
<ul>
<li><p>Restriction: previous sibling element must have <code>v-if</code> or <code>v-else-if</code>.</p></li>
<li><p>Can be used on <code>&lt;template&gt;</code> to denote a conditional block containing only text or multiple elements.</p></li>
</ul>
</li>
<li>
<p><strong>Example</strong></p>
<pre data-language="template">&lt;div v-if="type === 'A'"&gt;
  A
&lt;/div&gt;
&lt;div v-else-if="type === 'B'"&gt;
  B
&lt;/div&gt;
&lt;div v-else-if="type === 'C'"&gt;
  C
&lt;/div&gt;
&lt;div v-else&gt;
  Not A/B/C
&lt;/div&gt;</pre>
</li>
<li><p><strong>See also:</strong> <a href="../guide/essentials/conditional#v-else-if">Conditional Rendering - v-else-if</a></p></li>
</ul>
<h2 id="v-for" tabindex="-1">v-for </h2>
<p>Render the element or template block multiple times based on the source data.</p>
<ul>
<li><p><strong>Expects:</strong> <code>Array | Object | number | string | Iterable</code></p></li>
<li>
<p><strong>Details</strong></p>
<p>The directive's value must use the special syntax <code>alias in expression</code> to provide an alias for the current element being iterated on:</p>
<pre data-language="template">&lt;div v-for="item in items"&gt;
  {{ item.text }}
&lt;/div&gt;</pre>
<p>Alternatively, you can also specify an alias for the index (or the key if used on an Object):</p>
<pre data-language="template">&lt;div v-for="(item, index) in items"&gt;&lt;/div&gt;
&lt;div v-for="(value, key) in object"&gt;&lt;/div&gt;
&lt;div v-for="(value, name, index) in object"&gt;&lt;/div&gt;</pre>
<p>The default behavior of <code>v-for</code> will try to patch the elements in-place without moving them. To force it to reorder elements, you should provide an ordering hint with the <code>key</code> special attribute:</p>
<pre data-language="template">&lt;div v-for="item in items" :key="item.id"&gt;
  {{ item.text }}
&lt;/div&gt;</pre>
<p><code>v-for</code> can also work on values that implement the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol" target="_blank" rel="noreferrer">Iterable Protocol</a>, including native <code>Map</code> and <code>Set</code>.</p>
</li>
<li>
<p><strong>See also:</strong></p>
<ul><li><a href="../guide/essentials/list">List Rendering</a></li></ul>
</li>
</ul>
<h2 id="v-on" tabindex="-1">v-on </h2>
<p>Attach an event listener to the element.</p>
<ul>
<li><p><strong>Shorthand:</strong> <code>@</code></p></li>
<li><p><strong>Expects:</strong> <code>Function | Inline Statement | Object (without argument)</code></p></li>
<li><p><strong>Argument:</strong> <code>event</code> (optional if using Object syntax)</p></li>
<li>
<p><strong>Modifiers:</strong></p>
<ul>
<li>
<code>.stop</code> - call <code>event.stopPropagation()</code>.</li>
<li>
<code>.prevent</code> - call <code>event.preventDefault()</code>.</li>
<li>
<code>.capture</code> - add event listener in capture mode.</li>
<li>
<code>.self</code> - only trigger handler if event was dispatched from this element.</li>
<li>
<code>.{keyAlias}</code> - only trigger handler on certain keys.</li>
<li>
<code>.once</code> - trigger handler at most once.</li>
<li>
<code>.left</code> - only trigger handler for left button mouse events.</li>
<li>
<code>.right</code> - only trigger handler for right button mouse events.</li>
<li>
<code>.middle</code> - only trigger handler for middle button mouse events.</li>
<li>
<code>.passive</code> - attaches a DOM event with <code>{ passive: true }</code>.</li>
</ul>
</li>
<li>
<p><strong>Details</strong></p>
<p>The event type is denoted by the argument. The expression can be a method name, an inline statement, or omitted if there are modifiers present.</p>
<p>When used on a normal element, it listens to <a href="https://developer.mozilla.org/en-US/docs/Web/Events" target="_blank" rel="noreferrer"><strong>native DOM events</strong></a> only. When used on a custom element component, it listens to <strong>custom events</strong> emitted on that child component.</p>
<p>When listening to native DOM events, the method receives the native event as the only argument. If using inline statement, the statement has access to the special <code>$event</code> property: <code>v-on:click="handle('ok', $event)"</code>.</p>
<p><code>v-on</code> also supports binding to an object of event / listener pairs without an argument. Note when using the object syntax, it does not support any modifiers.</p>
</li>
<li>
<p><strong>Example:</strong></p>
<pre data-language="template">&lt;!-- method handler --&gt;
&lt;button v-on:click="doThis"&gt;&lt;/button&gt;

&lt;!-- dynamic event --&gt;
&lt;button v-on:[event]="doThis"&gt;&lt;/button&gt;

&lt;!-- inline statement --&gt;
&lt;button v-on:click="doThat('hello', $event)"&gt;&lt;/button&gt;

&lt;!-- shorthand --&gt;
&lt;button @click="doThis"&gt;&lt;/button&gt;

&lt;!-- shorthand dynamic event --&gt;
&lt;button @[event]="doThis"&gt;&lt;/button&gt;

&lt;!-- stop propagation --&gt;
&lt;button @click.stop="doThis"&gt;&lt;/button&gt;

&lt;!-- prevent default --&gt;
&lt;button @click.prevent="doThis"&gt;&lt;/button&gt;

&lt;!-- prevent default without expression --&gt;
&lt;form @submit.prevent&gt;&lt;/form&gt;

&lt;!-- chain modifiers --&gt;
&lt;button @click.stop.prevent="doThis"&gt;&lt;/button&gt;

&lt;!-- key modifier using keyAlias --&gt;
&lt;input @keyup.enter="onEnter" /&gt;

&lt;!-- the click event will be triggered at most once --&gt;
&lt;button v-on:click.once="doThis"&gt;&lt;/button&gt;

&lt;!-- object syntax --&gt;
&lt;button v-on="{ mousedown: doThis, mouseup: doThat }"&gt;&lt;/button&gt;</pre>
<p>Listening to custom events on a child component (the handler is called when "my-event" is emitted on the child):</p>
<pre data-language="template">&lt;MyComponent @my-event="handleThis" /&gt;

&lt;!-- inline statement --&gt;
&lt;MyComponent @my-event="handleThis(123, $event)" /&gt;</pre>
</li>
<li>
<p><strong>See also:</strong></p>
<ul>
<li><a href="../guide/essentials/event-handling">Event Handling</a></li>
<li><a href="../guide/essentials/component-basics#listening-to-events">Components - Custom Events</a></li>
</ul>
</li>
</ul>
<h2 id="v-bind" tabindex="-1">v-bind </h2>
<p>Dynamically bind one or more attributes, or a component prop to an expression.</p>
<ul>
<li><p><strong>Shorthand:</strong> <code>:</code> or <code>.</code> (when using <code>.prop</code> modifier)</p></li>
<li><p><strong>Expects:</strong> <code>any (with argument) | Object (without argument)</code></p></li>
<li><p><strong>Argument:</strong> <code>attrOrProp (optional)</code></p></li>
<li>
<p><strong>Modifiers:</strong></p>
<ul>
<li>
<code>.camel</code> - transform the kebab-case attribute name into camelCase.</li>
<li>
<code>.prop</code> - force a binding to be set as a DOM property. <sup class="vt-badge">3.2+</sup>
</li>
<li>
<code>.attr</code> - force a binding to be set as a DOM attribute. <sup class="vt-badge">3.2+</sup>
</li>
</ul>
</li>
<li>
<p><strong>Usage:</strong></p>
<p>When used to bind the <code>class</code> or <code>style</code> attribute, <code>v-bind</code> supports additional value types such as Array or Objects. See linked guide section below for more details.</p>
<p>When setting a binding on an element, Vue by default checks whether the element has the key defined as a property using an <code>in</code> operator check. If the property is defined, Vue will set the value as a DOM property instead of an attribute. This should work in most cases, but you can override this behavior by explicitly using <code>.prop</code> or <code>.attr</code> modifiers. This is sometimes necessary, especially when <a href="../guide/extras/web-components#passing-dom-properties">working with custom elements</a>.</p>
<p>When used for component prop binding, the prop must be properly declared in the child component.</p>
<p>When used without an argument, can be used to bind an object containing attribute name-value pairs.</p>
</li>
<li>
<p><strong>Example:</strong></p>
<pre data-language="template">&lt;!-- bind an attribute --&gt;
&lt;img v-bind:src="imageSrc" /&gt;

&lt;!-- dynamic attribute name --&gt;
&lt;button v-bind:[key]="value"&gt;&lt;/button&gt;

&lt;!-- shorthand --&gt;
&lt;img :src="imageSrc" /&gt;

&lt;!-- shorthand dynamic attribute name --&gt;
&lt;button :[key]="value"&gt;&lt;/button&gt;

&lt;!-- with inline string concatenation --&gt;
&lt;img :src="'/path/to/images/' + fileName" /&gt;

&lt;!-- class binding --&gt;
&lt;div :class="{ red: isRed }"&gt;&lt;/div&gt;
&lt;div :class="[classA, classB]"&gt;&lt;/div&gt;
&lt;div :class="[classA, { classB: isB, classC: isC }]"&gt;&lt;/div&gt;

&lt;!-- style binding --&gt;
&lt;div :style="{ fontSize: size + 'px' }"&gt;&lt;/div&gt;
&lt;div :style="[styleObjectA, styleObjectB]"&gt;&lt;/div&gt;

&lt;!-- binding an object of attributes --&gt;
&lt;div v-bind="{ id: someProp, 'other-attr': otherProp }"&gt;&lt;/div&gt;

&lt;!-- prop binding. "prop" must be declared in the child component. --&gt;
&lt;MyComponent :prop="someThing" /&gt;

&lt;!-- pass down parent props in common with a child component --&gt;
&lt;MyComponent v-bind="$props" /&gt;

&lt;!-- XLink --&gt;
&lt;svg&gt;&lt;a :xlink:special="foo"&gt;&lt;/a&gt;&lt;/svg&gt;</pre>
<p>The <code>.prop</code> modifier also has a dedicated shorthand, <code>.</code>:</p>
<pre data-language="template">&lt;div :someProperty.prop="someObject"&gt;&lt;/div&gt;

&lt;!-- equivalent to --&gt;
&lt;div .someProperty="someObject"&gt;&lt;/div&gt;</pre>
<p>The <code>.camel</code> modifier allows camelizing a <code>v-bind</code> attribute name when using in-DOM templates, e.g. the SVG <code>viewBox</code> attribute:</p>
<pre data-language="template">&lt;svg :view-box.camel="viewBox"&gt;&lt;/svg&gt;</pre>
<p><code>.camel</code> is not needed if you are using string templates, or pre-compiling the template with a build step.</p>
</li>
<li>
<p><strong>See also:</strong></p>
<ul>
<li><a href="../guide/essentials/class-and-style">Class and Style Bindings</a></li>
<li><a href="../guide/components/props#prop-passing-details">Components - Prop Passing Details</a></li>
</ul>
</li>
</ul>
<h2 id="v-model" tabindex="-1">v-model </h2>
<p>Create a two-way binding on a form input element or a component.</p>
<ul>
<li><p><strong>Expects:</strong> varies based on value of form inputs element or output of components</p></li>
<li>
<p><strong>Limited to:</strong></p>
<ul>
<li><code>&lt;input&gt;</code></li>
<li><code>&lt;select&gt;</code></li>
<li><code>&lt;textarea&gt;</code></li>
<li>components</li>
</ul>
</li>
<li>
<p><strong>Modifiers:</strong></p>
<ul>
<li>
<a href="../guide/essentials/forms#lazy"><code>.lazy</code></a> - listen to <code>change</code> events instead of <code>input</code>
</li>
<li>
<a href="../guide/essentials/forms#number"><code>.number</code></a> - cast valid input string to numbers</li>
<li>
<a href="../guide/essentials/forms#trim"><code>.trim</code></a> - trim input</li>
</ul>
</li>
<li>
<p><strong>See also:</strong></p>
<ul>
<li><a href="../guide/essentials/forms">Form Input Bindings</a></li>
<li><a href="../guide/components/v-model">Component Events - Usage with <code>v-model</code></a></li>
</ul>
</li>
</ul>
<h2 id="v-slot" tabindex="-1">v-slot </h2>
<p>Denote named slots or scoped slots that expect to receive props.</p>
<ul>
<li><p><strong>Shorthand:</strong> <code>#</code></p></li>
<li><p><strong>Expects:</strong> JavaScript expression that is valid in a function argument position, including support for destructuring. Optional - only needed if expecting props to be passed to the slot.</p></li>
<li><p><strong>Argument:</strong> slot name (optional, defaults to <code>default</code>)</p></li>
<li>
<p><strong>Limited to:</strong></p>
<ul>
<li><code>&lt;template&gt;</code></li>
<li>
<a href="../guide/components/slots#scoped-slots">components</a> (for a lone default slot with props)</li>
</ul>
</li>
<li>
<p><strong>Example:</strong></p>
<pre data-language="template">&lt;!-- Named slots --&gt;
&lt;BaseLayout&gt;
  &lt;template v-slot:header&gt;
    Header content
  &lt;/template&gt;

  &lt;template v-slot:default&gt;
    Default slot content
  &lt;/template&gt;

  &lt;template v-slot:footer&gt;
    Footer content
  &lt;/template&gt;
&lt;/BaseLayout&gt;

&lt;!-- Named slot that receives props --&gt;
&lt;InfiniteScroll&gt;
  &lt;template v-slot:item="slotProps"&gt;
    &lt;div class="item"&gt;
      {{ slotProps.item.text }}
    &lt;/div&gt;
  &lt;/template&gt;
&lt;/InfiniteScroll&gt;

&lt;!-- Default slot that receive props, with destructuring --&gt;
&lt;Mouse v-slot="{ x, y }"&gt;
  Mouse position: {{ x }}, {{ y }}
&lt;/Mouse&gt;</pre>
</li>
<li>
<p><strong>See also:</strong></p>
<ul><li><a href="../guide/components/slots">Components - Slots</a></li></ul>
</li>
</ul>
<h2 id="v-pre" tabindex="-1">v-pre </h2>
<p>Skip compilation for this element and all its children.</p>
<ul>
<li><p><strong>Does not expect expression</strong></p></li>
<li>
<p><strong>Details</strong></p>
<p>Inside the element with <code>v-pre</code>, all Vue template syntax will be preserved and rendered as-is. The most common use case of this is displaying raw mustache tags.</p>
</li>
<li>
<p><strong>Example:</strong></p>
<pre data-language="template">&lt;span v-pre&gt;{{ this will not be compiled }}&lt;/span&gt;</pre>
</li>
</ul>
<h2 id="v-once" tabindex="-1">v-once </h2>
<p>Render the element and component once only, and skip future updates.</p>
<ul>
<li><p><strong>Does not expect expression</strong></p></li>
<li>
<p><strong>Details</strong></p>
<p>On subsequent re-renders, the element/component and all its children will be treated as static content and skipped. This can be used to optimize update performance.</p>
<pre data-language="template">&lt;!-- single element --&gt;
&lt;span v-once&gt;This will never change: {{msg}}&lt;/span&gt;
&lt;!-- the element have children --&gt;
&lt;div v-once&gt;
  &lt;h1&gt;comment&lt;/h1&gt;
  &lt;p&gt;{{msg}}&lt;/p&gt;
&lt;/div&gt;
&lt;!-- component --&gt;
&lt;MyComponent v-once :comment="msg"&gt;&lt;/MyComponent&gt;
&lt;!-- `v-for` directive --&gt;
&lt;ul&gt;
  &lt;li v-for="i in list" v-once&gt;{{i}}&lt;/li&gt;
&lt;/ul&gt;</pre>
<p>Since 3.2, you can also memoize part of the template with invalidation conditions using <a href="#v-memo"><code>v-memo</code></a>.</p>
</li>
<li>
<p><strong>See also:</strong></p>
<ul>
<li><a href="../guide/essentials/template-syntax#text-interpolation">Data Binding Syntax - interpolations</a></li>
<li><a href="#v-memo">v-memo</a></li>
</ul>
</li>
</ul>
<h2 id="v-memo" tabindex="-1">v-memo  </h2>
<ul>
<li><p><strong>Expects:</strong> <code>any[]</code></p></li>
<li>
<p><strong>Details</strong></p>
<p>Memoize a sub-tree of the template. Can be used on both elements and components. The directive expects a fixed-length array of dependency values to compare for the memoization. If every value in the array was the same as last render, then updates for the entire sub-tree will be skipped. For example:</p>
<pre data-language="template">&lt;div v-memo="[valueA, valueB]"&gt;
  ...
&lt;/div&gt;</pre>
<p>When the component re-renders, if both <code>valueA</code> and <code>valueB</code> remain the same, all updates for this <code>&lt;div&gt;</code> and its children will be skipped. In fact, even the Virtual DOM VNode creation will also be skipped since the memoized copy of the sub-tree can be reused.</p>
<p>It is important to specify the memoization array correctly, otherwise we may skip updates that should indeed be applied. <code>v-memo</code> with an empty dependency array (<code>v-memo="[]"</code>) would be functionally equivalent to <code>v-once</code>.</p>
<p><strong>Usage with <code>v-for</code></strong></p>
<p><code>v-memo</code> is provided solely for micro optimizations in performance-critical scenarios and should be rarely needed. The most common case where this may prove helpful is when rendering large <code>v-for</code> lists (where <code>length &gt; 1000</code>):</p>
<pre data-language="template">&lt;div v-for="item in list" :key="item.id" v-memo="[item.id === selected]"&gt;
  &lt;p&gt;ID: {{ item.id }} - selected: {{ item.id === selected }}&lt;/p&gt;
  &lt;p&gt;...more child nodes&lt;/p&gt;
&lt;/div&gt;</pre>
<p>When the component's <code>selected</code> state changes, a large amount of VNodes will be created even though most of the items remained exactly the same. The <code>v-memo</code> usage here is essentially saying "only update this item if it went from non-selected to selected, or the other way around". This allows every unaffected item to reuse its previous VNode and skip diffing entirely. Note we don't need to include <code>item.id</code> in the memo dependency array here since Vue automatically infers it from the item's <code>:key</code>.</p>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>When using <code>v-memo</code> with <code>v-for</code>, make sure they are used on the same element. <strong><code>v-memo</code> does not work inside <code>v-for</code>.</strong></p>
</div>
<p><code>v-memo</code> can also be used on components to manually prevent unwanted updates in certain edge cases where the child component update check has been de-optimized. But again, it is the developer's responsibility to specify correct dependency arrays to avoid skipping necessary updates.</p>
</li>
<li>
<p><strong>See also:</strong></p>
<ul><li><a href="#v-once">v-once</a></li></ul>
</li>
</ul>
<h2 id="v-cloak" tabindex="-1">v-cloak </h2>
<p>Used to hide un-compiled template until it is ready.</p>
<ul>
<li><p><strong>Does not expect expression</strong></p></li>
<li>
<p><strong>Details</strong></p>
<p><strong>This directive is only needed in no-build-step setups.</strong></p>
<p>When using in-DOM templates, there can be a "flash of un-compiled templates": the user may see raw mustache tags until the mounted component replaces them with rendered content.</p>
<p><code>v-cloak</code> will remain on the element until the associated component instance is mounted. Combined with CSS rules such as <code>[v-cloak] { display: none }</code>, it can be used to hide the raw templates until the component is ready.</p>
</li>
<li>
<p><strong>Example:</strong></p>
<pre data-language="css">[v-cloak] {
  display: none;
}</pre>
<pre data-language="template">&lt;div v-cloak&gt;
  {{ message }}
&lt;/div&gt;</pre>
<p>The <code>&lt;div&gt;</code> will not be visible until the compilation is done.</p>
</li>
</ul>
<div class="_attribution">
  <p class="_attribution-p">
    © 2013–present Yuxi Evan You<br>Licensed under the MIT License.<br>
    <a href="https://vuejs.org/api/built-in-directives.html" class="_attribution-link">https://vuejs.org/api/built-in-directives.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
