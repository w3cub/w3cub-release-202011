
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Options&#58; State - Vue 3 - W3cubDocs</title>
  
  <meta name="description" content=" A function that returns the initial reactive state for the component instance. ">
  <meta name="keywords" content="options, state, vue, vue~3">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/vue~3/api/options-state.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-9c7b0d969c0ce639a6c01c2badcdd81667c7c66206aa3d0fccc5cb0585fb1b912dab72ea882101d18010680927514b4b77b107282db8f756fbf63301fe9c88b0.css">
  <script type="text/javascript" src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js"></script>
  <script src="/json/vue~3.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/vue~3/" class="_nav-link" title="" style="margin-left:0;">Vue 3</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _vue">
				
				
<h1 id="options-state" tabindex="-1">Options: State </h1>
<h2 id="data" tabindex="-1">data </h2>
<p>A function that returns the initial reactive state for the component instance.</p>
<ul>
<li>
<p><strong>Type</strong></p>
<pre data-language="ts">interface ComponentOptions {
  data?(
    this: ComponentPublicInstance,
    vm: ComponentPublicInstance
  ): object
}</pre>
</li>
<li>
<p><strong>Details</strong></p>
<p>The function is expected to return a plain JavaScript object, which will be made reactive by Vue. After the instance is created, the reactive data object can be accessed as <code>this.$data</code>. The component instance also proxies all the properties found on the data object, so <code>this.a</code> will be equivalent to <code>this.$data.a</code>.</p>
<p>All top-level data properties must be included in the returned data object. Adding new properties to <code>this.$data</code> is possible, but it is <strong>not</strong> recommended. If the desired value of a property is not yet available then an empty value such as <code>undefined</code> or <code>null</code> should be included as a placeholder to ensure that Vue knows that the property exists.</p>
<p>Properties that start with <code>_</code> or <code>$</code> will <strong>not</strong> be proxied on the component instance because they may conflict with Vue's internal properties and API methods. You will have to access them as <code>this.$data._property</code>.</p>
<p>It is <strong>not</strong> recommended to return objects with their own stateful behavior like browser API objects and prototype properties. The returned object should ideally be a plain object that only represents the state of the component.</p>
</li>
<li>
<p><strong>Example</strong></p>
<pre data-language="js">export default {
  data() {
    return { a: 1 }
  },
  created() {
    console.log(this.a) // 1
    console.log(this.$data) // { a: 1 }
  }
}</pre>
<p>Note that if you use an arrow function with the <code>data</code> property, <code>this</code> won't be the component's instance, but you can still access the instance as the function's first argument:</p>
<pre data-language="js">data: (vm) =&gt; ({ a: vm.myProp })</pre>
</li>
<li><p><strong>See also:</strong> <a href="../guide/extras/reactivity-in-depth">Reactivity in Depth</a></p></li>
</ul>
<h2 id="props" tabindex="-1">props </h2>
<p>Declare the props of a component.</p>
<ul>
<li>
<p><strong>Type</strong></p>
<pre data-language="ts">interface ComponentOptions {
  props?: ArrayPropsOptions | ObjectPropsOptions
}

type ArrayPropsOptions = string[]

type ObjectPropsOptions = { [key: string]: Prop }

type Prop&lt;T = any&gt; = PropOptions&lt;T&gt; | PropType&lt;T&gt; | null

interface PropOptions&lt;T&gt; {
  type?: PropType&lt;T&gt;
  required?: boolean
  default?: T | ((rawProps: object) =&gt; T)
  validator?: (value: unknown) =&gt; boolean
}

type PropType&lt;T&gt; = { new (): T } | { new (): T }[]</pre>
<blockquote><p>Types are simplified for readability.</p></blockquote>
</li>
<li>
<p><strong>Details</strong></p>
<p>In Vue, all component props need to be explicitly declared. Component props can be declared in two forms:</p>
<ul>
<li>Simple form using an array of strings</li>
<li>Full form using an object where each property key is the name of the prop, and the value is the prop's type (a constructor function) or advanced options.</li>
</ul>
<p>With object-based syntax, each prop can further define the following options:</p>
<ul>
<li>
<p><strong><code>type</code></strong>: Can be one of the following native constructors: <code>String</code>, <code>Number</code>, <code>Boolean</code>, <code>Array</code>, <code>Object</code>, <code>Date</code>, <code>Function</code>, <code>Symbol</code>, any custom constructor function or an array of those. In development mode, Vue will check if a prop's value matches the declared type, and will throw a warning if it doesn't. See <a href="../guide/components/props#prop-validation">Prop Validation</a> for more details.</p>
<p>Also note that a prop with <code>Boolean</code> type affects its value casting behavior in both development and production. See <a href="../guide/components/props#boolean-casting">Boolean Casting</a> for more details.</p>
</li>
<li><p><strong><code>default</code></strong>: Specifies a default value for the prop when it is not passed by the parent or has <code>undefined</code> value. Object or array defaults must be returned using a factory function. The factory function also receives the raw props object as the argument.</p></li>
<li><p><strong><code>required</code></strong>: Defines if the prop is required. In a non-production environment, a console warning will be thrown if this value is truthy and the prop is not passed.</p></li>
<li><p><strong><code>validator</code></strong>: Custom validator function that takes the prop value as the sole argument. In development mode, a console warning will be thrown if this function returns a falsy value (i.e. the validation fails).</p></li>
</ul>
</li>
<li>
<p><strong>Example</strong></p>
<p>Simple declaration:</p>
<pre data-language="js">export default {
  props: ['size', 'myMessage']
}</pre>
<p>Object declaration with validations:</p>
<pre data-language="js">export default {
  props: {
    // type check
    height: Number,
    // type check plus other validations
    age: {
      type: Number,
      default: 0,
      required: true,
      validator: (value) =&gt; {
        return value &gt;= 0
      }
    }
  }
}</pre>
</li>
<li>
<p><strong>See also:</strong></p>
<ul>
<li><a href="../guide/components/props">Guide - Props</a></li>
<li>
<a href="../guide/typescript/options-api#typing-component-props">Guide - Typing Component Props</a> 
</li>
</ul>
</li>
</ul>
<h2 id="computed" tabindex="-1">computed </h2>
<p>Declare computed properties to be exposed on the component instance.</p>
<ul>
<li>
<p><strong>Type</strong></p>
<pre data-language="ts">interface ComponentOptions {
  computed?: {
    [key: string]: ComputedGetter&lt;any&gt; | WritableComputedOptions&lt;any&gt;
  }
}

type ComputedGetter&lt;T&gt; = (
  this: ComponentPublicInstance,
  vm: ComponentPublicInstance
) =&gt; T

type ComputedSetter&lt;T&gt; = (
  this: ComponentPublicInstance,
  value: T
) =&gt; void

type WritableComputedOptions&lt;T&gt; = {
  get: ComputedGetter&lt;T&gt;
  set: ComputedSetter&lt;T&gt;
}</pre>
</li>
<li>
<p><strong>Details</strong></p>
<p>The option accepts an object where the key is the name of the computed property, and the value is either a computed getter, or an object with <code>get</code> and <code>set</code> methods (for writable computed properties).</p>
<p>All getters and setters have their <code>this</code> context automatically bound to the component instance.</p>
<p>Note that if you use an arrow function with a computed property, <code>this</code> won't point to the component's instance, but you can still access the instance as the function's first argument:</p>
<pre data-language="js">export default {
  computed: {
    aDouble: (vm) =&gt; vm.a * 2
  }
}</pre>
</li>
<li>
<p><strong>Example</strong></p>
<pre data-language="js">export default {
  data() {
    return { a: 1 }
  },
  computed: {
    // readonly
    aDouble() {
      return this.a * 2
    },
    // writable
    aPlus: {
      get() {
        return this.a + 1
      },
      set(v) {
        this.a = v - 1
      }
    }
  },
  created() {
    console.log(this.aDouble) // =&gt; 2
    console.log(this.aPlus) // =&gt; 2

    this.aPlus = 3
    console.log(this.a) // =&gt; 2
    console.log(this.aDouble) // =&gt; 4
  }
}</pre>
</li>
<li>
<p><strong>See also:</strong></p>
<ul>
<li><a href="../guide/essentials/computed">Guide - Computed Properties</a></li>
<li>
<a href="../guide/typescript/options-api#typing-computed-properties">Guide - Typing Computed Properties</a> 
</li>
</ul>
</li>
</ul>
<h2 id="methods" tabindex="-1">methods </h2>
<p>Declare methods to be mixed into the component instance.</p>
<ul>
<li>
<p><strong>Type</strong></p>
<pre data-language="ts">interface ComponentOptions {
  methods?: {
    [key: string]: (this: ComponentPublicInstance, ...args: any[]) =&gt; any
  }
}</pre>
</li>
<li>
<p><strong>Details</strong></p>
<p>Declared methods can be directly accessed on the component instance, or used in template expressions. All methods have their <code>this</code> context automatically bound to the component instance, even when passed around.</p>
<p>Avoid using arrow functions when declaring methods, as they will not have access to the component instance via <code>this</code>.</p>
</li>
<li>
<p><strong>Example</strong></p>
<pre data-language="js">export default {
  data() {
    return { a: 1 }
  },
  methods: {
    plus() {
      this.a++
    }
  },
  created() {
    this.plus()
    console.log(this.a) // =&gt; 2
  }
}</pre>
</li>
<li><p><strong>See also:</strong> <a href="../guide/essentials/event-handling">Event Handling</a></p></li>
</ul>
<h2 id="watch" tabindex="-1">watch </h2>
<p>Declare watch callbacks to be invoked on data change.</p>
<ul>
<li>
<p><strong>Type</strong></p>
<pre data-language="ts">interface ComponentOptions {
  watch?: {
    [key: string]: WatchOptionItem | WatchOptionItem[]
  }
}

type WatchOptionItem = string | WatchCallback | ObjectWatchOptionItem

type WatchCallback&lt;T&gt; = (
  value: T,
  oldValue: T,
  onCleanup: (cleanupFn: () =&gt; void) =&gt; void
) =&gt; void

type ObjectWatchOptionItem = {
  handler: WatchCallback | string
  immediate?: boolean // default: false
  deep?: boolean // default: false
  flush?: 'pre' | 'post' | 'sync' // default: 'pre'
  onTrack?: (event: DebuggerEvent) =&gt; void
  onTrigger?: (event: DebuggerEvent) =&gt; void
}</pre>
<blockquote><p>Types are simplified for readability.</p></blockquote>
</li>
<li>
<p><strong>Details</strong></p>
<p>The <code>watch</code> option expects an object where keys are the reactive component instance properties to watch (e.g. properties declared via <code>data</code> or <code>computed</code>) — and values are the corresponding callbacks. The callback receives the new value and the old value of the watched source.</p>
<p>In addition to a root-level property, the key can also be a simple dot-delimited path, e.g. <code>a.b.c</code>. Note that this usage does <strong>not</strong> support complex expressions - only dot-delimited paths are supported. If you need to watch complex data sources, use the imperative <a href="component-instance#watch"><code>$watch()</code></a> API instead.</p>
<p>The value can also be a string of a method name (declared via <code>methods</code>), or an object that contains additional options. When using the object syntax, the callback should be declared under the <code>handler</code> field. Additional options include:</p>
<ul>
<li>
<strong><code>immediate</code></strong>: trigger the callback immediately on watcher creation. Old value will be <code>undefined</code> on the first call.</li>
<li>
<strong><code>deep</code></strong>: force deep traversal of the source if it is an object or an array, so that the callback fires on deep mutations. See <a href="../guide/essentials/watchers#deep-watchers">Deep Watchers</a>.</li>
<li>
<strong><code>flush</code></strong>: adjust the callback's flush timing. See <a href="../guide/essentials/watchers#callback-flush-timing">Callback Flush Timing</a> and <a href="reactivity-core#watcheffect"><code>watchEffect()</code></a>.</li>
<li>
<strong><code>onTrack / onTrigger</code></strong>: debug the watcher's dependencies. See <a href="../guide/extras/reactivity-in-depth#watcher-debugging">Watcher Debugging</a>.</li>
</ul>
<p>Avoid using arrow functions when declaring watch callbacks as they will not have access to the component instance via <code>this</code>.</p>
</li>
<li>
<p><strong>Example</strong></p>
<pre data-language="js">export default {
  data() {
    return {
      a: 1,
      b: 2,
      c: {
        d: 4
      },
      e: 5,
      f: 6
    }
  },
  watch: {
    // watching top-level property
    a(val, oldVal) {
      console.log(`new: ${val}, old: ${oldVal}`)
    },
    // string method name
    b: 'someMethod',
    // the callback will be called whenever any of the watched object properties change regardless of their nested depth
    c: {
      handler(val, oldVal) {
        console.log('c changed')
      },
      deep: true
    },
    // watching a single nested property:
    'c.d': function (val, oldVal) {
      // do something
    },
    // the callback will be called immediately after the start of the observation
    e: {
      handler(val, oldVal) {
        console.log('e changed')
      },
      immediate: true
    },
    // you can pass array of callbacks, they will be called one-by-one
    f: [
      'handle1',
      function handle2(val, oldVal) {
        console.log('handle2 triggered')
      },
      {
        handler: function handle3(val, oldVal) {
          console.log('handle3 triggered')
        }
        /* ... */
      }
    ]
  },
  methods: {
    someMethod() {
      console.log('b changed')
    },
    handle1() {
      console.log('handle 1 triggered')
    }
  },
  created() {
    this.a = 3 // =&gt; new: 3, old: 1
  }
}</pre>
</li>
<li><p><strong>See also:</strong> <a href="../guide/essentials/watchers">Watchers</a></p></li>
</ul>
<h2 id="emits" tabindex="-1">emits </h2>
<p>Declare the custom events emitted by the component.</p>
<ul>
<li>
<p><strong>Type</strong></p>
<pre data-language="ts">interface ComponentOptions {
  emits?: ArrayEmitsOptions | ObjectEmitsOptions
}

type ArrayEmitsOptions = string[]

type ObjectEmitsOptions = { [key: string]: EmitValidator | null }

type EmitValidator = (...args: unknown[]) =&gt; boolean</pre>
</li>
<li>
<p><strong>Details</strong></p>
<p>Emitted events can be declared in two forms:</p>
<ul>
<li>Simple form using an array of strings</li>
<li>Full form using an object where each property key is the name of the event, and the value is either <code>null</code> or a validator function.</li>
</ul>
<p>The validation function will receive the additional arguments passed to the component's <code>$emit</code> call. For example, if <code>this.$emit('foo', 1)</code> is called, the corresponding validator for <code>foo</code> will receive the argument <code>1</code>. The validator function should return a boolean to indicate whether the event arguments are valid.</p>
<p>Note that the <code>emits</code> option affects which event listeners are considered component event listeners, rather than native DOM event listeners. The listeners for declared events will be removed from the component's <code>$attrs</code> object, so they will not be passed through to the component's root element. See <a href="../guide/components/attrs">Fallthrough Attributes</a> for more details.</p>
</li>
<li>
<p><strong>Example</strong></p>
<p>Array syntax:</p>
<pre data-language="js">export default {
  emits: ['check'],
  created() {
    this.$emit('check')
  }
}</pre>
<p>Object syntax:</p>
<pre data-language="js">export default {
  emits: {
    // no validation
    click: null,

    // with validation
    submit: (payload) =&gt; {
      if (payload.email &amp;&amp; payload.password) {
        return true
      } else {
        console.warn(`Invalid submit event payload!`)
        return false
      }
    }
  }
}</pre>
</li>
<li>
<p><strong>See also:</strong></p>
<ul>
<li><a href="../guide/components/attrs">Guide - Fallthrough Attributes</a></li>
<li>
<a href="../guide/typescript/options-api#typing-component-emits">Guide - Typing Component Emits</a> 
</li>
</ul>
</li>
</ul>
<h2 id="expose" tabindex="-1">expose </h2>
<p>Declare exposed public properties when the component instance is accessed by a parent via template refs.</p>
<ul>
<li>
<p><strong>Type</strong></p>
<pre data-language="ts">interface ComponentOptions {
  expose?: string[]
}</pre>
</li>
<li>
<p><strong>Details</strong></p>
<p>By default, a component instance exposes all instance properties to the parent when accessed via <code>$parent</code>, <code>$root</code>, or template refs. This can be undesirable, since a component most likely has internal state or methods that should be kept private to avoid tight coupling.</p>
<p>The <code>expose</code> option expects a list of property name strings. When <code>expose</code> is used, only the properties explicitly listed will be exposed on the component's public instance.</p>
<p><code>expose</code> only affects user-defined properties - it does not filter out built-in component instance properties.</p>
</li>
<li>
<p><strong>Example</strong></p>
<pre data-language="js">export default {
  // only `publicMethod` will be available on the public instance
  expose: ['publicMethod'],
  methods: {
    publicMethod() {
      // ...
    },
    privateMethod() {
      // ...
    }
  }
}</pre>
</li>
</ul>
<div class="_attribution">
  <p class="_attribution-p">
    © 2013–present Yuxi Evan You<br>Licensed under the MIT License.<br>
    <a href="https://vuejs.org/api/options-state.html" class="_attribution-link">https://vuejs.org/api/options-state.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
