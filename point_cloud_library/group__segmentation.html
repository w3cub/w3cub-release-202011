
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Module Segmentation - PointCloudLibrary - W3cubDocs</title>
  
  <meta name="description" content="The pcl_segmentation library contains algorithms for segmenting a point cloud into distinct clusters. These algorithms are best suited to processing &hellip;">
  <meta name="keywords" content="overview, requirements, module, segmentation, pointcloudlibrary, point_cloud_library">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/point_cloud_library/group__segmentation.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-60a6449bb52e9968d95c133a29f066ffcb8dbe4f077d4022e51c991ce30bf256c8e19c508207a4193c414ffd0414826564317669b0f27f9f85c1cb21b84e097e.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/point_cloud_library.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/point_cloud_library/" class="_nav-link" title="" style="margin-left:0;">PointCloudLibrary</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _point_cloud_library">
				
				
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2> <h1>
<a class="anchor" id="secSegmentationPresentation"></a> Overview</h1> <p>The <b>pcl_segmentation</b> library contains algorithms for segmenting a point cloud into distinct clusters. These algorithms are best suited to processing a point cloud that is composed of a number of spatially isolated regions. In such cases, clustering is often used to break the cloud down into its constituent parts, which can then be processed independently.</p> <h1>
<a class="anchor" id="secSegmentationRequirements"></a> Requirements</h1> <ul> <li><a class="el" href="group__common">common</a></li> <li><a class="el" href="https://pointclouds.org/documentation/group__search.html">search</a></li> <li><a class="el" href="group__sample__consensus">sample_consensus</a></li> <li><a class="el" href="group__kdtree">kdtree</a></li> <li>
<a class="el" href="group__octree">octree</a> </li> </ul> <table class="memberdecls"> <tr class="heading"><td colspan="2"><h2 class="groupheader">
<a name="nested-classes"></a> Classes</h2></td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1gpu_1_1_euclidean_cluster_extraction">pcl::gpu::EuclideanClusterExtraction&lt; PointT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<b><a class="el" href="classpcl_1_1gpu_1_1_euclidean_cluster_extraction" title="EuclideanClusterExtraction represents a segmentation class for cluster extraction in an Euclidean sen...">EuclideanClusterExtraction</a></b> represents a segmentation class for cluster extraction in an Euclidean sense, depending on pcl::gpu::octree <a href="classpcl_1_1gpu_1_1_euclidean_cluster_extraction#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1gpu_1_1_euclidean_labeled_cluster_extraction">pcl::gpu::EuclideanLabeledClusterExtraction&lt; PointT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<b><a class="el" href="classpcl_1_1gpu_1_1_euclidean_labeled_cluster_extraction" title="EuclideanLabeledClusterExtraction represents a segmentation class for cluster extraction in an Euclid...">EuclideanLabeledClusterExtraction</a></b> represents a segmentation class for cluster extraction in an Euclidean sense, depending on pcl::gpu::octree <a href="classpcl_1_1gpu_1_1_euclidean_labeled_cluster_extraction#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_conditional_euclidean_clustering">pcl::ConditionalEuclideanClustering&lt; PointT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<b><a class="el" href="classpcl_1_1_conditional_euclidean_clustering" title="ConditionalEuclideanClustering performs segmentation based on Euclidean distance and a user-defined c...">ConditionalEuclideanClustering</a></b> performs segmentation based on Euclidean distance and a user-defined clustering condition. <a href="classpcl_1_1_conditional_euclidean_clustering#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_c_p_c_segmentation">pcl::CPCSegmentation&lt; PointT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">A segmentation algorithm partitioning a supervoxel graph. <a href="classpcl_1_1_c_p_c_segmentation#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_euclidean_cluster_extraction">pcl::EuclideanClusterExtraction&lt; PointT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<b><a class="el" href="classpcl_1_1_euclidean_cluster_extraction" title="EuclideanClusterExtraction represents a segmentation class for cluster extraction in an Euclidean sen...">EuclideanClusterExtraction</a></b> represents a segmentation class for cluster extraction in an Euclidean sense. <a href="classpcl_1_1_euclidean_cluster_extraction#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_labeled_euclidean_cluster_extraction">pcl::LabeledEuclideanClusterExtraction&lt; PointT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<b><a class="el" href="classpcl_1_1_labeled_euclidean_cluster_extraction" title="LabeledEuclideanClusterExtraction represents a segmentation class for cluster extraction in an Euclid...">LabeledEuclideanClusterExtraction</a></b> represents a segmentation class for cluster extraction in an Euclidean sense, with label info. <a href="classpcl_1_1_labeled_euclidean_cluster_extraction#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_extract_polygonal_prism_data">pcl::ExtractPolygonalPrismData&lt; PointT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<b><a class="el" href="classpcl_1_1_extract_polygonal_prism_data" title="ExtractPolygonalPrismData uses a set of point indices that represent a planar model,...">ExtractPolygonalPrismData</a></b> uses a set of point indices that represent a planar model, and together with a given height, generates a 3D polygonal prism. <a href="classpcl_1_1_extract_polygonal_prism_data#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grab_cut">pcl::GrabCut&lt; PointT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">Implementation of the <a class="el" href="classpcl_1_1_grab_cut" title='Implementation of the GrabCut segmentation in "GrabCut — Interactive Foreground Extraction using Iter...'>GrabCut</a> segmentation in "GrabCut — Interactive Foreground Extraction using Iterated Graph Cuts" by Carsten Rother, Vladimir Kolmogorov and Andrew Blake. <a href="classpcl_1_1_grab_cut#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1segmentation_1_1detail_1_1_random_walker">pcl::segmentation::detail::RandomWalker&lt; Graph, EdgeWeightMap, VertexColorMap &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">Multilabel graph segmentation using random walks. <a href="classpcl_1_1segmentation_1_1detail_1_1_random_walker#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_l_c_c_p_segmentation">pcl::LCCPSegmentation&lt; PointT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">A simple segmentation algorithm partitioning a supervoxel graph into groups of locally convex connected supervoxels separated by concave borders. <a href="classpcl_1_1_l_c_c_p_segmentation#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_region_growing">pcl::RegionGrowing&lt; PointT, NormalT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">Implements the well known Region Growing algorithm used for segmentation. <a href="classpcl_1_1_region_growing#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_region_growing_r_g_b">pcl::RegionGrowingRGB&lt; PointT, NormalT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">Implements the well known Region Growing algorithm used for segmentation based on color of points. <a href="classpcl_1_1_region_growing_r_g_b#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_s_a_c_segmentation">pcl::SACSegmentation&lt; PointT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<b><a class="el" href="classpcl_1_1_s_a_c_segmentation" title="SACSegmentation represents the Nodelet segmentation class for Sample Consensus methods and models,...">SACSegmentation</a></b> represents the Nodelet segmentation class for Sample Consensus methods and models, in the sense that it just creates a Nodelet wrapper for generic-purpose SAC-based segmentation. <a href="classpcl_1_1_s_a_c_segmentation#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_s_a_c_segmentation_from_normals">pcl::SACSegmentationFromNormals&lt; PointT, PointNT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<b><a class="el" href="classpcl_1_1_s_a_c_segmentation_from_normals" title="SACSegmentationFromNormals represents the PCL nodelet segmentation class for Sample Consensus methods...">SACSegmentationFromNormals</a></b> represents the PCL nodelet segmentation class for Sample Consensus methods and models that require the use of surface normals for estimation. <a href="classpcl_1_1_s_a_c_segmentation_from_normals#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_seeded_hue_segmentation">pcl::SeededHueSegmentation</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<a class="el" href="classpcl_1_1_seeded_hue_segmentation" title="SeededHueSegmentation.">SeededHueSegmentation</a>. <a href="classpcl_1_1_seeded_hue_segmentation#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_segment_differences">pcl::SegmentDifferences&lt; PointT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<b><a class="el" href="classpcl_1_1_segment_differences" title="SegmentDifferences obtains the difference between two spatially aligned point clouds and returns the ...">SegmentDifferences</a></b> obtains the difference between two spatially aligned point clouds and returns the difference between them for a maximum given distance threshold. <a href="classpcl_1_1_segment_differences#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_supervoxel_clustering">pcl::SupervoxelClustering&lt; PointT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">Implements a supervoxel algorithm based on voxel structure, normals, and rgb values. <a href="classpcl_1_1_supervoxel_clustering#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> </table>
<table class="memberdecls"> <tr class="heading"><td colspan="2"><h2 class="groupheader">
<a name="func-members"></a> Functions</h2></td></tr> <tr class="memitem:gae8009f1bbb6b65afe5c188c3c30618d9">
<td class="memItemLeft" align="right" valign="top">bool </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="group__segmentation#gae8009f1bbb6b65afe5c188c3c30618d9">pcl::gpu::comparePointClusters</a> (const <a class="el" href="structpcl_1_1_point_indices">pcl::PointIndices</a> &amp;a, const <a class="el" href="structpcl_1_1_point_indices">pcl::PointIndices</a> &amp;b)</td>
</tr> <tr class="memdesc:gae8009f1bbb6b65afe5c188c3c30618d9">
<td class="mdescLeft"> </td>
<td class="mdescRight">Sort clusters method (for std::sort). <a href="group__segmentation#gae8009f1bbb6b65afe5c188c3c30618d9">More...</a><br>
</td>
</tr> <tr class="separator:gae8009f1bbb6b65afe5c188c3c30618d9"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:ga76ed0e67a2f63c49f8488dda17104c3e">
<td class="memItemLeft" align="right" valign="top">bool </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="group__segmentation#ga76ed0e67a2f63c49f8488dda17104c3e">pcl::gpu::compareLabeledPointClusters</a> (const <a class="el" href="structpcl_1_1_point_indices">pcl::PointIndices</a> &amp;a, const <a class="el" href="structpcl_1_1_point_indices">pcl::PointIndices</a> &amp;b)</td>
</tr> <tr class="memdesc:ga76ed0e67a2f63c49f8488dda17104c3e">
<td class="mdescLeft"> </td>
<td class="mdescRight">Sort clusters method (for std::sort). <a href="group__segmentation#ga76ed0e67a2f63c49f8488dda17104c3e">More...</a><br>
</td>
</tr> <tr class="separator:ga76ed0e67a2f63c49f8488dda17104c3e"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:ga40c5f0a1d0ca0dac743de3bf976834c1"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr> <tr class="memitem:ga40c5f0a1d0ca0dac743de3bf976834c1">
<td class="memTemplItemLeft" align="right" valign="top">void </td>
<td class="memTemplItemRight" valign="bottom">
<a class="el" href="group__segmentation#ga40c5f0a1d0ca0dac743de3bf976834c1">pcl::extractEuclideanClusters</a> (const <a class="el" href="classpcl_1_1_point_cloud">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &gt; &amp;cloud, const typename <a class="el" href="https://pointclouds.org/documentation/classpcl_1_1search_1_1_search.html">search::Search</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &gt;::Ptr &amp;tree, float tolerance, std::vector&lt; <a class="el" href="structpcl_1_1_point_indices">PointIndices</a> &gt; &amp;clusters, unsigned int min_pts_per_cluster=1, unsigned int max_pts_per_cluster=(std::numeric_limits&lt; int &gt;::max)())</td>
</tr> <tr class="memdesc:ga40c5f0a1d0ca0dac743de3bf976834c1">
<td class="mdescLeft"> </td>
<td class="mdescRight">Decompose a region of space into clusters based on the Euclidean distance between points. <a href="group__segmentation#ga40c5f0a1d0ca0dac743de3bf976834c1">More...</a><br>
</td>
</tr> <tr class="separator:ga40c5f0a1d0ca0dac743de3bf976834c1"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:ga4a5613948fdab8df82a4566f7c6d0fae"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr> <tr class="memitem:ga4a5613948fdab8df82a4566f7c6d0fae">
<td class="memTemplItemLeft" align="right" valign="top">void </td>
<td class="memTemplItemRight" valign="bottom">
<a class="el" href="group__segmentation#ga4a5613948fdab8df82a4566f7c6d0fae">pcl::extractEuclideanClusters</a> (const <a class="el" href="classpcl_1_1_point_cloud">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &gt; &amp;cloud, const <a class="el" href="https://pointclouds.org/documentation/namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, const typename <a class="el" href="https://pointclouds.org/documentation/classpcl_1_1search_1_1_search.html">search::Search</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &gt;::Ptr &amp;tree, float tolerance, std::vector&lt; <a class="el" href="structpcl_1_1_point_indices">PointIndices</a> &gt; &amp;clusters, unsigned int min_pts_per_cluster=1, unsigned int max_pts_per_cluster=(std::numeric_limits&lt; int &gt;::max)())</td>
</tr> <tr class="memdesc:ga4a5613948fdab8df82a4566f7c6d0fae">
<td class="mdescLeft"> </td>
<td class="mdescRight">Decompose a region of space into clusters based on the Euclidean distance between points. <a href="group__segmentation#ga4a5613948fdab8df82a4566f7c6d0fae">More...</a><br>
</td>
</tr> <tr class="separator:ga4a5613948fdab8df82a4566f7c6d0fae"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:gac2906d5886306876c13c6d31a02d30c8"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Normal &gt; </td></tr> <tr class="memitem:gac2906d5886306876c13c6d31a02d30c8">
<td class="memTemplItemLeft" align="right" valign="top">void </td>
<td class="memTemplItemRight" valign="bottom">
<a class="el" href="group__segmentation#gac2906d5886306876c13c6d31a02d30c8">pcl::extractEuclideanClusters</a> (const <a class="el" href="classpcl_1_1_point_cloud">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &gt; &amp;cloud, const <a class="el" href="classpcl_1_1_point_cloud">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_normal">Normal</a> &gt; &amp;normals, float tolerance, const typename <a class="el" href="classpcl_1_1_kd_tree">KdTree</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &gt;::Ptr &amp;tree, std::vector&lt; <a class="el" href="structpcl_1_1_point_indices">PointIndices</a> &gt; &amp;clusters, double eps_angle, unsigned int min_pts_per_cluster=1, unsigned int max_pts_per_cluster=(std::numeric_limits&lt; int &gt;::max)())</td>
</tr> <tr class="memdesc:gac2906d5886306876c13c6d31a02d30c8">
<td class="mdescLeft"> </td>
<td class="mdescRight">Decompose a region of space into clusters based on the euclidean distance between points, and the normal angular deviation between points. <a href="group__segmentation#gac2906d5886306876c13c6d31a02d30c8">More...</a><br>
</td>
</tr> <tr class="separator:gac2906d5886306876c13c6d31a02d30c8"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:ga5f9be0f498de04de362c2ca97f949318"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Normal &gt; </td></tr> <tr class="memitem:ga5f9be0f498de04de362c2ca97f949318">
<td class="memTemplItemLeft" align="right" valign="top">void </td>
<td class="memTemplItemRight" valign="bottom">
<a class="el" href="group__segmentation#ga5f9be0f498de04de362c2ca97f949318">pcl::extractEuclideanClusters</a> (const <a class="el" href="classpcl_1_1_point_cloud">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &gt; &amp;cloud, const <a class="el" href="classpcl_1_1_point_cloud">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_normal">Normal</a> &gt; &amp;normals, const <a class="el" href="https://pointclouds.org/documentation/namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, const typename <a class="el" href="classpcl_1_1_kd_tree">KdTree</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &gt;::Ptr &amp;tree, float tolerance, std::vector&lt; <a class="el" href="structpcl_1_1_point_indices">PointIndices</a> &gt; &amp;clusters, double eps_angle, unsigned int min_pts_per_cluster=1, unsigned int max_pts_per_cluster=(std::numeric_limits&lt; int &gt;::max)())</td>
</tr> <tr class="memdesc:ga5f9be0f498de04de362c2ca97f949318">
<td class="mdescLeft"> </td>
<td class="mdescRight">Decompose a region of space into clusters based on the euclidean distance between points, and the normal angular deviation between points. <a href="group__segmentation#ga5f9be0f498de04de362c2ca97f949318">More...</a><br>
</td>
</tr> <tr class="separator:ga5f9be0f498de04de362c2ca97f949318"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:gae88095505f2cbfbef301795b0f4cf5c6">
<td class="memItemLeft" align="right" valign="top">bool </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="group__segmentation#gae88095505f2cbfbef301795b0f4cf5c6">pcl::comparePointClusters</a> (const <a class="el" href="structpcl_1_1_point_indices">pcl::PointIndices</a> &amp;a, const <a class="el" href="structpcl_1_1_point_indices">pcl::PointIndices</a> &amp;b)</td>
</tr> <tr class="memdesc:gae88095505f2cbfbef301795b0f4cf5c6">
<td class="mdescLeft"> </td>
<td class="mdescRight">Sort clusters method (for std::sort). <a href="group__segmentation#gae88095505f2cbfbef301795b0f4cf5c6">More...</a><br>
</td>
</tr> <tr class="separator:gae88095505f2cbfbef301795b0f4cf5c6"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:ga0005eb1be52751d0ba5fffbef78745c3"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr> <tr class="memitem:ga0005eb1be52751d0ba5fffbef78745c3">
<td class="memTemplItemLeft" align="right" valign="top">void </td>
<td class="memTemplItemRight" valign="bottom">
<a class="el" href="group__segmentation#ga0005eb1be52751d0ba5fffbef78745c3">pcl::extractLabeledEuclideanClusters</a> (const <a class="el" href="classpcl_1_1_point_cloud">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &gt; &amp;cloud, const typename <a class="el" href="https://pointclouds.org/documentation/classpcl_1_1search_1_1_search.html">search::Search</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &gt;::Ptr &amp;tree, float tolerance, std::vector&lt; std::vector&lt; <a class="el" href="structpcl_1_1_point_indices">PointIndices</a> &gt;&gt; &amp;labeled_clusters, unsigned int min_pts_per_cluster, unsigned int max_pts_per_cluster, unsigned int max_label)</td>
</tr> <tr class="memdesc:ga0005eb1be52751d0ba5fffbef78745c3">
<td class="mdescLeft"> </td>
<td class="mdescRight">Decompose a region of space into clusters based on the Euclidean distance between points. <a href="group__segmentation#ga0005eb1be52751d0ba5fffbef78745c3">More...</a><br>
</td>
</tr> <tr class="separator:ga0005eb1be52751d0ba5fffbef78745c3"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:ga59b61d55ba8ad18ed71d68b14572b961"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr> <tr class="memitem:ga59b61d55ba8ad18ed71d68b14572b961">
<td class="memTemplItemLeft" align="right" valign="top">void </td>
<td class="memTemplItemRight" valign="bottom">
<a class="el" href="group__segmentation#ga59b61d55ba8ad18ed71d68b14572b961">pcl::extractLabeledEuclideanClusters</a> (const <a class="el" href="classpcl_1_1_point_cloud">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &gt; &amp;cloud, const typename <a class="el" href="https://pointclouds.org/documentation/classpcl_1_1search_1_1_search.html">search::Search</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &gt;::Ptr &amp;tree, float tolerance, std::vector&lt; std::vector&lt; <a class="el" href="structpcl_1_1_point_indices">PointIndices</a> &gt;&gt; &amp;labeled_clusters, unsigned int min_pts_per_cluster=1, unsigned int max_pts_per_cluster=std::numeric_limits&lt; unsigned int &gt;::max())</td>
</tr> <tr class="memdesc:ga59b61d55ba8ad18ed71d68b14572b961">
<td class="mdescLeft"> </td>
<td class="mdescRight">Decompose a region of space into clusters based on the Euclidean distance between points. <a href="group__segmentation#ga59b61d55ba8ad18ed71d68b14572b961">More...</a><br>
</td>
</tr> <tr class="separator:ga59b61d55ba8ad18ed71d68b14572b961"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:ga45d36abe92bc812f65d08618fda89123">
<td class="memItemLeft" align="right" valign="top">bool </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="group__segmentation#ga45d36abe92bc812f65d08618fda89123">pcl::compareLabeledPointClusters</a> (const <a class="el" href="structpcl_1_1_point_indices">pcl::PointIndices</a> &amp;a, const <a class="el" href="structpcl_1_1_point_indices">pcl::PointIndices</a> &amp;b)</td>
</tr> <tr class="memdesc:ga45d36abe92bc812f65d08618fda89123">
<td class="mdescLeft"> </td>
<td class="mdescRight">Sort clusters method (for std::sort). <a href="group__segmentation#ga45d36abe92bc812f65d08618fda89123">More...</a><br>
</td>
</tr> <tr class="separator:ga45d36abe92bc812f65d08618fda89123"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:ga0a21f5679b1644a7894f2f14ee1bbe37"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr> <tr class="memitem:ga0a21f5679b1644a7894f2f14ee1bbe37">
<td class="memTemplItemLeft" align="right" valign="top">bool </td>
<td class="memTemplItemRight" valign="bottom">
<a class="el" href="group__segmentation#ga0a21f5679b1644a7894f2f14ee1bbe37">pcl::isPointIn2DPolygon</a> (const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &amp;point, const <a class="el" href="classpcl_1_1_point_cloud">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &gt; &amp;polygon)</td>
</tr> <tr class="memdesc:ga0a21f5679b1644a7894f2f14ee1bbe37">
<td class="mdescLeft"> </td>
<td class="mdescRight">General purpose method for checking if a 3D point is inside or outside a given 2D polygon. <a href="group__segmentation#ga0a21f5679b1644a7894f2f14ee1bbe37">More...</a><br>
</td>
</tr> <tr class="separator:ga0a21f5679b1644a7894f2f14ee1bbe37"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:ga5c5f766262ec4eae1af76df2bc0afc64"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr> <tr class="memitem:ga5c5f766262ec4eae1af76df2bc0afc64">
<td class="memTemplItemLeft" align="right" valign="top">bool </td>
<td class="memTemplItemRight" valign="bottom">
<a class="el" href="group__segmentation#ga5c5f766262ec4eae1af76df2bc0afc64">pcl::isXYPointIn2DXYPolygon</a> (const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &amp;point, const <a class="el" href="classpcl_1_1_point_cloud">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &gt; &amp;polygon)</td>
</tr> <tr class="memdesc:ga5c5f766262ec4eae1af76df2bc0afc64">
<td class="mdescLeft"> </td>
<td class="mdescRight">Check if a 2d point (X and Y coordinates considered only!) is inside or outside a given polygon. <a href="group__segmentation#ga5c5f766262ec4eae1af76df2bc0afc64">More...</a><br>
</td>
</tr> <tr class="separator:ga5c5f766262ec4eae1af76df2bc0afc64"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:ga8ce6ea49099c7bf2de825f3f5ee61152"><td class="memTemplParams" colspan="2">template&lt;class Graph &gt; </td></tr> <tr class="memitem:ga8ce6ea49099c7bf2de825f3f5ee61152">
<td class="memTemplItemLeft" align="right" valign="top">bool </td>
<td class="memTemplItemRight" valign="bottom">
<a class="el" href="group__segmentation#ga8ce6ea49099c7bf2de825f3f5ee61152">pcl::segmentation::randomWalker</a> (Graph &amp;graph)</td>
</tr> <tr class="memdesc:ga8ce6ea49099c7bf2de825f3f5ee61152">
<td class="mdescLeft"> </td>
<td class="mdescRight">Multilabel graph segmentation using random walks. <a href="group__segmentation#ga8ce6ea49099c7bf2de825f3f5ee61152">More...</a><br>
</td>
</tr> <tr class="separator:ga8ce6ea49099c7bf2de825f3f5ee61152"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:ga60d903133e1043dbaf9dc1764bb6c457"><td class="memTemplParams" colspan="2">template&lt;class Graph , class EdgeWeightMap , class VertexColorMap &gt; </td></tr> <tr class="memitem:ga60d903133e1043dbaf9dc1764bb6c457">
<td class="memTemplItemLeft" align="right" valign="top">bool </td>
<td class="memTemplItemRight" valign="bottom">
<a class="el" href="group__segmentation#ga60d903133e1043dbaf9dc1764bb6c457">pcl::segmentation::randomWalker</a> (Graph &amp;graph, EdgeWeightMap weights, VertexColorMap colors)</td>
</tr> <tr class="memdesc:ga60d903133e1043dbaf9dc1764bb6c457">
<td class="mdescLeft"> </td>
<td class="mdescRight">Multilabel graph segmentation using random walks. <a href="group__segmentation#ga60d903133e1043dbaf9dc1764bb6c457">More...</a><br>
</td>
</tr> <tr class="separator:ga60d903133e1043dbaf9dc1764bb6c457"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:ga941c995a5d4e8a4e31500d272ae43740"><td class="memTemplParams" colspan="2">template&lt;class Graph , class EdgeWeightMap , class VertexColorMap &gt; </td></tr> <tr class="memitem:ga941c995a5d4e8a4e31500d272ae43740">
<td class="memTemplItemLeft" align="right" valign="top">bool </td>
<td class="memTemplItemRight" valign="bottom">
<a class="el" href="group__segmentation#ga941c995a5d4e8a4e31500d272ae43740">pcl::segmentation::randomWalker</a> (Graph &amp;graph, EdgeWeightMap weights, VertexColorMap colors, Eigen::Matrix&lt; typename boost::property_traits&lt; EdgeWeightMap &gt;::value_type, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;potentials, std::map&lt; typename boost::property_traits&lt; VertexColorMap &gt;::value_type, std::size_t &gt; &amp;colors_to_columns_map)</td>
</tr> <tr class="memdesc:ga941c995a5d4e8a4e31500d272ae43740">
<td class="mdescLeft"> </td>
<td class="mdescRight">Multilabel graph segmentation using random walks. <a href="group__segmentation#ga941c995a5d4e8a4e31500d272ae43740">More...</a><br>
</td>
</tr> <tr class="separator:ga941c995a5d4e8a4e31500d272ae43740"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:ga5891c20fc0abc04063e117afaa8554d6">
<td class="memItemLeft" align="right" valign="top">void </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="group__segmentation#ga5891c20fc0abc04063e117afaa8554d6">pcl::seededHueSegmentation</a> (const <a class="el" href="classpcl_1_1_point_cloud">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointXYZRGB</a> &gt; &amp;cloud, const <a class="el" href="https://pointclouds.org/documentation/classpcl_1_1search_1_1_search.html">search::Search</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointXYZRGB</a> &gt;::Ptr &amp;tree, float tolerance, <a class="el" href="structpcl_1_1_point_indices">PointIndices</a> &amp;indices_in, <a class="el" href="structpcl_1_1_point_indices">PointIndices</a> &amp;indices_out, float delta_hue=0.0)</td>
</tr> <tr class="memdesc:ga5891c20fc0abc04063e117afaa8554d6">
<td class="mdescLeft"> </td>
<td class="mdescRight">Decompose a region of space into clusters based on the Euclidean distance between points. <a href="group__segmentation#ga5891c20fc0abc04063e117afaa8554d6">More...</a><br>
</td>
</tr> <tr class="separator:ga5891c20fc0abc04063e117afaa8554d6"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:gaf25653016cc78d6cf7adad3651b0d7ed">
<td class="memItemLeft" align="right" valign="top">void </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="group__segmentation#gaf25653016cc78d6cf7adad3651b0d7ed">pcl::seededHueSegmentation</a> (const <a class="el" href="classpcl_1_1_point_cloud">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointXYZRGB</a> &gt; &amp;cloud, const <a class="el" href="https://pointclouds.org/documentation/classpcl_1_1search_1_1_search.html">search::Search</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b_l">PointXYZRGBL</a> &gt;::Ptr &amp;tree, float tolerance, <a class="el" href="structpcl_1_1_point_indices">PointIndices</a> &amp;indices_in, <a class="el" href="structpcl_1_1_point_indices">PointIndices</a> &amp;indices_out, float delta_hue=0.0)</td>
</tr> <tr class="memdesc:gaf25653016cc78d6cf7adad3651b0d7ed">
<td class="mdescLeft"> </td>
<td class="mdescRight">Decompose a region of space into clusters based on the Euclidean distance between points. <a href="group__segmentation#gaf25653016cc78d6cf7adad3651b0d7ed">More...</a><br>
</td>
</tr> <tr class="separator:gaf25653016cc78d6cf7adad3651b0d7ed"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:ga5fd433527a00085583fa1e8eb31cba0f"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr> <tr class="memitem:ga5fd433527a00085583fa1e8eb31cba0f">
<td class="memTemplItemLeft" align="right" valign="top">void </td>
<td class="memTemplItemRight" valign="bottom">
<a class="el" href="group__segmentation#ga5fd433527a00085583fa1e8eb31cba0f">pcl::getPointCloudDifference</a> (const <a class="el" href="classpcl_1_1_point_cloud">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &gt; &amp;src, double threshold, const typename <a class="el" href="https://pointclouds.org/documentation/classpcl_1_1search_1_1_search.html">pcl::search::Search</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &gt;::Ptr &amp;tree, <a class="el" href="classpcl_1_1_point_cloud">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &gt; &amp;output)</td>
</tr> <tr class="memdesc:ga5fd433527a00085583fa1e8eb31cba0f">
<td class="mdescLeft"> </td>
<td class="mdescRight">Obtain the difference between two aligned point clouds as another point cloud, given a distance threshold. <a href="group__segmentation#ga5fd433527a00085583fa1e8eb31cba0f">More...</a><br>
</td>
</tr> <tr class="separator:ga5fd433527a00085583fa1e8eb31cba0f"><td class="memSeparator" colspan="2"> </td></tr> </table> <h2 class="groupheader">Function Documentation</h2> <a id="ga76ed0e67a2f63c49f8488dda17104c3e"></a> <h2 class="memtitle">compareLabeledPointClusters() <span class="overload">[1/2]</span>
</h2> <div class="memitem"> <div class="memproto"> <table class="mlabels"> <tr> <td class="mlabels-left"> <table class="memname"> <tr> <td class="memname">bool pcl::gpu::compareLabeledPointClusters </td> <td>(</td> <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices">pcl::PointIndices</a> &amp; </td> <td class="paramname">
<em>a</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices">pcl::PointIndices</a> &amp; </td> <td class="paramname">
<em>b</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </td> <td class="mlabels-right"> <span class="mlabels"><span class="mlabel">inline</span></span> </td> </tr> </table> </div>
<div class="memdoc"> <p><code>#include &lt;/__w/1/s/gpu/segmentation/include/pcl/gpu/segmentation/gpu_extract_labeled_clusters.h&gt;</code></p> <p>Sort clusters method (for std::sort). </p> <p class="definition">Definition at line <a class="el" href="https://pointclouds.org/documentation/gpu__extract__labeled__clusters_8h_source.html#l00206">206</a> of file <a class="el" href="https://pointclouds.org/documentation/gpu__extract__labeled__clusters_8h_source.html">gpu_extract_labeled_clusters.h</a>.</p> <p class="reference">References <a class="el" href="https://pointclouds.org/documentation/_point_indices_8h_source.html#l00021">pcl::PointIndices::indices</a>.</p> <p class="reference">Referenced by <a class="el" href="https://pointclouds.org/documentation/gpu__extract__labeled__clusters_8hpp_source.html#l00152">pcl::gpu::EuclideanLabeledClusterExtraction&lt; PointT &gt;::extract()</a>.</p> </div> </div> <a id="ga45d36abe92bc812f65d08618fda89123"></a> <h2 class="memtitle">compareLabeledPointClusters() <span class="overload">[2/2]</span>
</h2> <div class="memitem"> <div class="memproto"> <table class="mlabels"> <tr> <td class="mlabels-left"> <table class="memname"> <tr> <td class="memname">bool pcl::compareLabeledPointClusters </td> <td>(</td> <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices">pcl::PointIndices</a> &amp; </td> <td class="paramname">
<em>a</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices">pcl::PointIndices</a> &amp; </td> <td class="paramname">
<em>b</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </td> <td class="mlabels-right"> <span class="mlabels"><span class="mlabel">inline</span></span> </td> </tr> </table> </div>
<div class="memdoc"> <p><code>#include &lt;pcl/segmentation/extract_labeled_clusters.h&gt;</code></p> <p>Sort clusters method (for std::sort). </p> <p class="definition">Definition at line <a class="el" href="https://pointclouds.org/documentation/extract__labeled__clusters_8h_source.html#l00254">254</a> of file <a class="el" href="https://pointclouds.org/documentation/extract__labeled__clusters_8h_source.html">extract_labeled_clusters.h</a>.</p> <p class="reference">References <a class="el" href="https://pointclouds.org/documentation/_point_indices_8h_source.html#l00021">pcl::PointIndices::indices</a>.</p> </div> </div> <a id="gae8009f1bbb6b65afe5c188c3c30618d9"></a> <h2 class="memtitle">comparePointClusters() <span class="overload">[1/2]</span>
</h2> <div class="memitem"> <div class="memproto"> <table class="mlabels"> <tr> <td class="mlabels-left"> <table class="memname"> <tr> <td class="memname">bool pcl::gpu::comparePointClusters </td> <td>(</td> <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices">pcl::PointIndices</a> &amp; </td> <td class="paramname">
<em>a</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices">pcl::PointIndices</a> &amp; </td> <td class="paramname">
<em>b</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </td> <td class="mlabels-right"> <span class="mlabels"><span class="mlabel">inline</span></span> </td> </tr> </table> </div>
<div class="memdoc"> <p><code>#include &lt;/__w/1/s/gpu/segmentation/include/pcl/gpu/segmentation/gpu_extract_clusters.h&gt;</code></p> <p>Sort clusters method (for std::sort). </p> <p class="definition">Definition at line <a class="el" href="https://pointclouds.org/documentation/gpu__extract__clusters_8h_source.html#l00212">212</a> of file <a class="el" href="https://pointclouds.org/documentation/gpu__extract__clusters_8h_source.html">gpu_extract_clusters.h</a>.</p> <p class="reference">References <a class="el" href="https://pointclouds.org/documentation/_point_indices_8h_source.html#l00021">pcl::PointIndices::indices</a>.</p> <p class="reference">Referenced by <a class="el" href="https://pointclouds.org/documentation/extract__labeled__clusters_8hpp_source.html#l00148">pcl::LabeledEuclideanClusterExtraction&lt; PointT &gt;::extract()</a>, and <a class="el" href="https://pointclouds.org/documentation/extract__clusters_8hpp_source.html#l00228">pcl::EuclideanClusterExtraction&lt; PointT &gt;::extract()</a>.</p> </div> </div> <a id="gae88095505f2cbfbef301795b0f4cf5c6"></a> <h2 class="memtitle">comparePointClusters() <span class="overload">[2/2]</span>
</h2> <div class="memitem"> <div class="memproto"> <table class="mlabels"> <tr> <td class="mlabels-left"> <table class="memname"> <tr> <td class="memname">bool pcl::comparePointClusters </td> <td>(</td> <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices">pcl::PointIndices</a> &amp; </td> <td class="paramname">
<em>a</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices">pcl::PointIndices</a> &amp; </td> <td class="paramname">
<em>b</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </td> <td class="mlabels-right"> <span class="mlabels"><span class="mlabel">inline</span></span> </td> </tr> </table> </div>
<div class="memdoc"> <p><code>#include &lt;pcl/segmentation/extract_clusters.h&gt;</code></p> <p>Sort clusters method (for std::sort). </p> <p class="definition">Definition at line <a class="el" href="https://pointclouds.org/documentation/extract__clusters_8h_source.html#l00448">448</a> of file <a class="el" href="https://pointclouds.org/documentation/extract__clusters_8h_source.html">extract_clusters.h</a>.</p> <p class="reference">References <a class="el" href="https://pointclouds.org/documentation/_point_indices_8h_source.html#l00021">pcl::PointIndices::indices</a>.</p> </div> </div> <a id="ga4a5613948fdab8df82a4566f7c6d0fae"></a> <h2 class="memtitle">extractEuclideanClusters() <span class="overload">[1/4]</span>
</h2> <div class="memitem"> <div class="memproto"> <div class="memtemplate"> template&lt;typename PointT &gt; </div> <table class="memname"> <tr> <td class="memname">void pcl::extractEuclideanClusters </td> <td>(</td> <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &gt; &amp; </td> <td class="paramname">
<em>cloud</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">const <a class="el" href="https://pointclouds.org/documentation/namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp; </td> <td class="paramname">
<em>indices</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">const typename <a class="el" href="https://pointclouds.org/documentation/classpcl_1_1search_1_1_search.html">search::Search</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &gt;::Ptr &amp; </td> <td class="paramname">
<em>tree</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">float </td> <td class="paramname">
<em>tolerance</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">std::vector&lt; <a class="el" href="structpcl_1_1_point_indices">PointIndices</a> &gt; &amp; </td> <td class="paramname">
<em>clusters</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">unsigned int </td> <td class="paramname">
<em>min_pts_per_cluster</em> = <code>1</code>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">unsigned int </td> <td class="paramname">
<em>max_pts_per_cluster</em> = <code>(std::numeric_limits&lt;int&gt;::max) ()</code> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </div>
<div class="memdoc"> <p><code>#include &lt;pcl/segmentation/extract_clusters.h&gt;</code></p> <p>Decompose a region of space into clusters based on the Euclidean distance between points. </p> <dl class="params">
<dt>Parameters</dt>
<dd> <table class="params"> <tr>
<td class="paramname">cloud</td>
<td>the point cloud message </td>
</tr> <tr>
<td class="paramname">indices</td>
<td>a list of point indices to use from <em>cloud</em> </td>
</tr> <tr>
<td class="paramname">tree</td>
<td>the spatial locator (e.g., kd-tree) used for nearest neighbors searching </td>
</tr> </table> </dd> </dl> <dl class="section note">
<dt>Note</dt>
<dd>the tree has to be created as a spatial locator on <em>cloud</em> and <em>indices</em> </dd>
</dl> <dl class="params">
<dt>Parameters</dt>
<dd> <table class="params"> <tr>
<td class="paramname">tolerance</td>
<td>the spatial cluster tolerance as a measure in L2 Euclidean space </td>
</tr> <tr>
<td class="paramname">clusters</td>
<td>the resultant clusters containing point indices (as a vector of <a class="el" href="structpcl_1_1_point_indices">PointIndices</a>) </td>
</tr> <tr>
<td class="paramname">min_pts_per_cluster</td>
<td>minimum number of points that a cluster may contain (default: 1) </td>
</tr> <tr>
<td class="paramname">max_pts_per_cluster</td>
<td>maximum number of points that a cluster may contain (default: max int)</td>
</tr> </table> </dd> </dl> <dl class="todo">
<dt><b><a class="el" href="todo#_todo000039">Todo:</a></b></dt>
<dd>: fix the return value, make sure the exit is not needed anymore </dd>
</dl> <p class="definition">Definition at line <a class="el" href="https://pointclouds.org/documentation/extract__clusters_8hpp_source.html#l00127">127</a> of file <a class="el" href="https://pointclouds.org/documentation/extract__clusters_8hpp_source.html">extract_clusters.hpp</a>.</p> <p class="reference">References <a class="el" href="https://pointclouds.org/documentation/search_8h_source.html#l00132">pcl::search::Search&lt; PointT &gt;::getIndices()</a>, <a class="el" href="https://pointclouds.org/documentation/search_8h_source.html#l00125">pcl::search::Search&lt; PointT &gt;::getInputCloud()</a>, <a class="el" href="https://pointclouds.org/documentation/search_8hpp_source.html#l00068">pcl::search::Search&lt; PointT &gt;::getSortedResults()</a>, <a class="el" href="https://pointclouds.org/documentation/_point_indices_8h_source.html#l00019">pcl::PointIndices::header</a>, <a class="el" href="https://pointclouds.org/documentation/common_2include_2pcl_2point__cloud_8h_source.html#l00392">pcl::PointCloud&lt; PointT &gt;::header</a>, <a class="el" href="https://pointclouds.org/documentation/_point_indices_8h_source.html#l00021">pcl::PointIndices::indices</a>, <a class="el" href="https://pointclouds.org/documentation/classpcl_1_1search_1_1_search.html#af803bbb855706159fa2cd36e4e8f0c58">pcl::search::Search&lt; PointT &gt;::radiusSearch()</a>, and <a class="el" href="https://pointclouds.org/documentation/common_2include_2pcl_2point__cloud_8h_source.html#l00443">pcl::PointCloud&lt; PointT &gt;::size()</a>.</p> </div> </div> <a id="ga5f9be0f498de04de362c2ca97f949318"></a> <h2 class="memtitle">extractEuclideanClusters() <span class="overload">[2/4]</span>
</h2> <div class="memitem"> <div class="memproto"> <div class="memtemplate"> template&lt;typename PointT , typename Normal &gt; </div> <table class="memname"> <tr> <td class="memname">void pcl::extractEuclideanClusters </td> <td>(</td> <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &gt; &amp; </td> <td class="paramname">
<em>cloud</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_normal">Normal</a> &gt; &amp; </td> <td class="paramname">
<em>normals</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">const <a class="el" href="https://pointclouds.org/documentation/namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp; </td> <td class="paramname">
<em>indices</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">const typename <a class="el" href="classpcl_1_1_kd_tree">KdTree</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &gt;::Ptr &amp; </td> <td class="paramname">
<em>tree</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">float </td> <td class="paramname">
<em>tolerance</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">std::vector&lt; <a class="el" href="structpcl_1_1_point_indices">PointIndices</a> &gt; &amp; </td> <td class="paramname">
<em>clusters</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">double </td> <td class="paramname">
<em>eps_angle</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">unsigned int </td> <td class="paramname">
<em>min_pts_per_cluster</em> = <code>1</code>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">unsigned int </td> <td class="paramname">
<em>max_pts_per_cluster</em> = <code>(std::numeric_limits&lt;int&gt;::max) ()</code> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </div>
<div class="memdoc"> <p><code>#include &lt;pcl/segmentation/extract_clusters.h&gt;</code></p> <p>Decompose a region of space into clusters based on the euclidean distance between points, and the normal angular deviation between points. </p> <p>Each point added to the cluster is origin to another radius search. Each point within radius range will be compared to the origin in respect to normal angle and euclidean distance. If both are under their respective threshold the point will be added to the cluster. Generally speaking the cluster algorithm will not stop on smooth surfaces but on surfaces with sharp edges. </p>
<dl class="params">
<dt>Parameters</dt>
<dd> <table class="params"> <tr>
<td class="paramname">cloud</td>
<td>the point cloud message </td>
</tr> <tr>
<td class="paramname">normals</td>
<td>the point cloud message containing normal information </td>
</tr> <tr>
<td class="paramname">indices</td>
<td>a list of point indices to use from <em>cloud</em> </td>
</tr> <tr>
<td class="paramname">tree</td>
<td>the spatial locator (e.g., kd-tree) used for nearest neighbors searching </td>
</tr> </table> </dd> </dl> <dl class="section note">
<dt>Note</dt>
<dd>the tree has to be created as a spatial locator on <em>cloud</em> </dd>
</dl> <dl class="params">
<dt>Parameters</dt>
<dd> <table class="params"> <tr>
<td class="paramname">tolerance</td>
<td>the spatial cluster tolerance as a measure in the L2 Euclidean space </td>
</tr> <tr>
<td class="paramname">clusters</td>
<td>the resultant clusters containing point indices (as <a class="el" href="structpcl_1_1_point_indices">PointIndices</a>) </td>
</tr> <tr>
<td class="paramname">eps_angle</td>
<td>the maximum allowed difference between normals in radians for cluster/region growing </td>
</tr> <tr>
<td class="paramname">min_pts_per_cluster</td>
<td>minimum number of points that a cluster may contain (default: 1) </td>
</tr> <tr>
<td class="paramname">max_pts_per_cluster</td>
<td>maximum number of points that a cluster may contain (default: max int) </td>
</tr> </table> </dd> </dl> <p class="definition">Definition at line <a class="el" href="https://pointclouds.org/documentation/extract__clusters_8h_source.html#l00217">217</a> of file <a class="el" href="https://pointclouds.org/documentation/extract__clusters_8h_source.html">extract_clusters.h</a>.</p> <p class="reference">References <a class="el" href="https://pointclouds.org/documentation/kdtree_2include_2pcl_2kdtree_2kdtree_8h_source.html#l00093">pcl::KdTree&lt; PointT &gt;::getIndices()</a>, <a class="el" href="https://pointclouds.org/documentation/kdtree_2include_2pcl_2kdtree_2kdtree_8h_source.html#l00100">pcl::KdTree&lt; PointT &gt;::getInputCloud()</a>, <a class="el" href="https://pointclouds.org/documentation/_point_indices_8h_source.html#l00019">pcl::PointIndices::header</a>, <a class="el" href="https://pointclouds.org/documentation/common_2include_2pcl_2point__cloud_8h_source.html#l00392">pcl::PointCloud&lt; PointT &gt;::header</a>, <a class="el" href="https://pointclouds.org/documentation/_point_indices_8h_source.html#l00021">pcl::PointIndices::indices</a>, <a class="el" href="https://pointclouds.org/documentation/common_2include_2pcl_2point__cloud_8h_source.html#l00652">pcl::PointCloud&lt; PointT &gt;::push_back()</a>, <a class="el" href="classpcl_1_1_kd_tree#ae1210c2a4a33886d25248a6d7950bf4c">pcl::KdTree&lt; PointT &gt;::radiusSearch()</a>, and <a class="el" href="https://pointclouds.org/documentation/common_2include_2pcl_2point__cloud_8h_source.html#l00443">pcl::PointCloud&lt; PointT &gt;::size()</a>.</p> </div> </div> <a id="gac2906d5886306876c13c6d31a02d30c8"></a> <h2 class="memtitle">extractEuclideanClusters() <span class="overload">[3/4]</span>
</h2> <div class="memitem"> <div class="memproto"> <div class="memtemplate"> template&lt;typename PointT , typename Normal &gt; </div> <table class="memname"> <tr> <td class="memname">void pcl::extractEuclideanClusters </td> <td>(</td> <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &gt; &amp; </td> <td class="paramname">
<em>cloud</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_normal">Normal</a> &gt; &amp; </td> <td class="paramname">
<em>normals</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">float </td> <td class="paramname">
<em>tolerance</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">const typename <a class="el" href="classpcl_1_1_kd_tree">KdTree</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &gt;::Ptr &amp; </td> <td class="paramname">
<em>tree</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">std::vector&lt; <a class="el" href="structpcl_1_1_point_indices">PointIndices</a> &gt; &amp; </td> <td class="paramname">
<em>clusters</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">double </td> <td class="paramname">
<em>eps_angle</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">unsigned int </td> <td class="paramname">
<em>min_pts_per_cluster</em> = <code>1</code>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">unsigned int </td> <td class="paramname">
<em>max_pts_per_cluster</em> = <code>(std::numeric_limits&lt;int&gt;::max) ()</code> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </div>
<div class="memdoc"> <p><code>#include &lt;pcl/segmentation/extract_clusters.h&gt;</code></p> <p>Decompose a region of space into clusters based on the euclidean distance between points, and the normal angular deviation between points. </p> <p>Each point added to the cluster is origin to another radius search. Each point within radius range will be compared to the origin in respect to normal angle and euclidean distance. If both are under their respective threshold the point will be added to the cluster. Generally speaking the cluster algorithm will not stop on smooth surfaces but on surfaces with sharp edges. </p>
<dl class="params">
<dt>Parameters</dt>
<dd> <table class="params"> <tr>
<td class="paramname">cloud</td>
<td>the point cloud message </td>
</tr> <tr>
<td class="paramname">normals</td>
<td>the point cloud message containing normal information </td>
</tr> <tr>
<td class="paramname">tree</td>
<td>the spatial locator (e.g., kd-tree) used for nearest neighbors searching </td>
</tr> </table> </dd> </dl> <dl class="section note">
<dt>Note</dt>
<dd>the tree has to be created as a spatial locator on <em>cloud</em> </dd>
</dl> <dl class="params">
<dt>Parameters</dt>
<dd> <table class="params"> <tr>
<td class="paramname">tolerance</td>
<td>the spatial cluster tolerance as a measure in the L2 Euclidean space </td>
</tr> <tr>
<td class="paramname">clusters</td>
<td>the resultant clusters containing point indices (as a vector of <a class="el" href="structpcl_1_1_point_indices">PointIndices</a>) </td>
</tr> <tr>
<td class="paramname">eps_angle</td>
<td>the maximum allowed difference between normals in radians for cluster/region growing </td>
</tr> <tr>
<td class="paramname">min_pts_per_cluster</td>
<td>minimum number of points that a cluster may contain (default: 1) </td>
</tr> <tr>
<td class="paramname">max_pts_per_cluster</td>
<td>maximum number of points that a cluster may contain (default: max int) </td>
</tr> </table> </dd> </dl> <p class="definition">Definition at line <a class="el" href="https://pointclouds.org/documentation/extract__clusters_8h_source.html#l00103">103</a> of file <a class="el" href="https://pointclouds.org/documentation/extract__clusters_8h_source.html">extract_clusters.h</a>.</p> <p class="reference">References <a class="el" href="https://pointclouds.org/documentation/kdtree_2include_2pcl_2kdtree_2kdtree_8h_source.html#l00100">pcl::KdTree&lt; PointT &gt;::getInputCloud()</a>, <a class="el" href="https://pointclouds.org/documentation/_point_indices_8h_source.html#l00019">pcl::PointIndices::header</a>, <a class="el" href="https://pointclouds.org/documentation/common_2include_2pcl_2point__cloud_8h_source.html#l00392">pcl::PointCloud&lt; PointT &gt;::header</a>, <a class="el" href="https://pointclouds.org/documentation/_point_indices_8h_source.html#l00021">pcl::PointIndices::indices</a>, <a class="el" href="https://pointclouds.org/documentation/common_2include_2pcl_2point__cloud_8h_source.html#l00652">pcl::PointCloud&lt; PointT &gt;::push_back()</a>, <a class="el" href="classpcl_1_1_kd_tree#ae1210c2a4a33886d25248a6d7950bf4c">pcl::KdTree&lt; PointT &gt;::radiusSearch()</a>, and <a class="el" href="https://pointclouds.org/documentation/common_2include_2pcl_2point__cloud_8h_source.html#l00443">pcl::PointCloud&lt; PointT &gt;::size()</a>.</p> </div> </div> <a id="ga40c5f0a1d0ca0dac743de3bf976834c1"></a> <h2 class="memtitle">extractEuclideanClusters() <span class="overload">[4/4]</span>
</h2> <div class="memitem"> <div class="memproto"> <div class="memtemplate"> template&lt;typename PointT &gt; </div> <table class="memname"> <tr> <td class="memname">void pcl::extractEuclideanClusters </td> <td>(</td> <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &gt; &amp; </td> <td class="paramname">
<em>cloud</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">const typename <a class="el" href="https://pointclouds.org/documentation/classpcl_1_1search_1_1_search.html">search::Search</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &gt;::Ptr &amp; </td> <td class="paramname">
<em>tree</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">float </td> <td class="paramname">
<em>tolerance</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">std::vector&lt; <a class="el" href="structpcl_1_1_point_indices">PointIndices</a> &gt; &amp; </td> <td class="paramname">
<em>clusters</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">unsigned int </td> <td class="paramname">
<em>min_pts_per_cluster</em> = <code>1</code>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">unsigned int </td> <td class="paramname">
<em>max_pts_per_cluster</em> = <code>(std::numeric_limits&lt;int&gt;::max) ()</code> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </div>
<div class="memdoc"> <p><code>#include &lt;pcl/segmentation/extract_clusters.h&gt;</code></p> <p>Decompose a region of space into clusters based on the Euclidean distance between points. </p> <dl class="params">
<dt>Parameters</dt>
<dd> <table class="params"> <tr>
<td class="paramname">cloud</td>
<td>the point cloud message </td>
</tr> <tr>
<td class="paramname">tree</td>
<td>the spatial locator (e.g., kd-tree) used for nearest neighbors searching </td>
</tr> </table> </dd> </dl> <dl class="section note">
<dt>Note</dt>
<dd>the tree has to be created as a spatial locator on <em>cloud</em> </dd>
</dl> <dl class="params">
<dt>Parameters</dt>
<dd> <table class="params"> <tr>
<td class="paramname">tolerance</td>
<td>the spatial cluster tolerance as a measure in L2 Euclidean space </td>
</tr> <tr>
<td class="paramname">clusters</td>
<td>the resultant clusters containing point indices (as a vector of <a class="el" href="structpcl_1_1_point_indices">PointIndices</a>) </td>
</tr> <tr>
<td class="paramname">min_pts_per_cluster</td>
<td>minimum number of points that a cluster may contain (default: 1) </td>
</tr> <tr>
<td class="paramname">max_pts_per_cluster</td>
<td>maximum number of points that a cluster may contain (default: max int) </td>
</tr> </table> </dd> </dl> <p class="definition">Definition at line <a class="el" href="https://pointclouds.org/documentation/extract__clusters_8hpp_source.html#l00046">46</a> of file <a class="el" href="https://pointclouds.org/documentation/extract__clusters_8hpp_source.html">extract_clusters.hpp</a>.</p> <p class="reference">References <a class="el" href="https://pointclouds.org/documentation/search_8h_source.html#l00125">pcl::search::Search&lt; PointT &gt;::getInputCloud()</a>, <a class="el" href="https://pointclouds.org/documentation/search_8hpp_source.html#l00068">pcl::search::Search&lt; PointT &gt;::getSortedResults()</a>, <a class="el" href="https://pointclouds.org/documentation/_point_indices_8h_source.html#l00019">pcl::PointIndices::header</a>, <a class="el" href="https://pointclouds.org/documentation/common_2include_2pcl_2point__cloud_8h_source.html#l00392">pcl::PointCloud&lt; PointT &gt;::header</a>, <a class="el" href="https://pointclouds.org/documentation/_point_indices_8h_source.html#l00021">pcl::PointIndices::indices</a>, <a class="el" href="https://pointclouds.org/documentation/classpcl_1_1search_1_1_search.html#af803bbb855706159fa2cd36e4e8f0c58">pcl::search::Search&lt; PointT &gt;::radiusSearch()</a>, and <a class="el" href="https://pointclouds.org/documentation/common_2include_2pcl_2point__cloud_8h_source.html#l00443">pcl::PointCloud&lt; PointT &gt;::size()</a>.</p> <p class="reference">Referenced by <a class="el" href="https://pointclouds.org/documentation/extract__clusters_8hpp_source.html#l00228">pcl::EuclideanClusterExtraction&lt; PointT &gt;::extract()</a>.</p> </div> </div> <a id="ga0005eb1be52751d0ba5fffbef78745c3"></a> <h2 class="memtitle">extractLabeledEuclideanClusters() <span class="overload">[1/2]</span>
</h2> <div class="memitem"> <div class="memproto"> <div class="memtemplate"> template&lt;typename PointT &gt; </div> <table class="memname"> <tr> <td class="memname">void pcl::extractLabeledEuclideanClusters </td> <td>(</td> <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &gt; &amp; </td> <td class="paramname">
<em>cloud</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">const typename <a class="el" href="https://pointclouds.org/documentation/classpcl_1_1search_1_1_search.html">search::Search</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &gt;::Ptr &amp; </td> <td class="paramname">
<em>tree</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">float </td> <td class="paramname">
<em>tolerance</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="structpcl_1_1_point_indices">PointIndices</a> &gt;&gt; &amp; </td> <td class="paramname">
<em>labeled_clusters</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">unsigned int </td> <td class="paramname">
<em>min_pts_per_cluster</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">unsigned int </td> <td class="paramname">
<em>max_pts_per_cluster</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">unsigned int </td> <td class="paramname">
<em>max_label</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </div>
<div class="memdoc"> <p><code>#include &lt;pcl/segmentation/extract_labeled_clusters.h&gt;</code></p> <p>Decompose a region of space into clusters based on the Euclidean distance between points. </p> <dl class="params">
<dt>Parameters</dt>
<dd> <table class="params"> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">cloud</td>
<td>the point cloud message </td>
</tr> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">tree</td>
<td>the spatial locator (e.g., kd-tree) used for nearest neighbors searching </td>
</tr> </table> </dd> </dl> <dl class="section note">
<dt>Note</dt>
<dd>the tree has to be created as a spatial locator on <em>cloud</em> </dd>
</dl> <dl class="params">
<dt>Parameters</dt>
<dd> <table class="params"> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">tolerance</td>
<td>the spatial cluster tolerance as a measure in L2 Euclidean space </td>
</tr> <tr>
<td class="paramdir">[out]</td>
<td class="paramname">labeled_clusters</td>
<td>the resultant clusters containing point indices (as a vector of <a class="el" href="structpcl_1_1_point_indices">PointIndices</a>) </td>
</tr> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">min_pts_per_cluster</td>
<td>minimum number of points that a cluster may contain (default: 1) </td>
</tr> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">max_pts_per_cluster</td>
<td>maximum number of points that a cluster may contain (default: max int) </td>
</tr> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">max_label</td>
<td></td>
</tr> </table> </dd> </dl> <dl class="deprecated">
<dt><b><a class="el" href="deprecated#_deprecated000012">Deprecated:</a></b></dt>
<dd>Scheduled for removal in version 1 . 14 : "Use of max_label is deprecated" <br> </dd>
</dl> <p class="definition">Definition at line <a class="el" href="https://pointclouds.org/documentation/extract__labeled__clusters_8hpp_source.html#l00045">45</a> of file <a class="el" href="https://pointclouds.org/documentation/extract__labeled__clusters_8hpp_source.html">extract_labeled_clusters.hpp</a>.</p> <p class="reference">Referenced by <a class="el" href="https://pointclouds.org/documentation/extract__labeled__clusters_8hpp_source.html#l00148">pcl::LabeledEuclideanClusterExtraction&lt; PointT &gt;::extract()</a>.</p> </div> </div> <a id="ga59b61d55ba8ad18ed71d68b14572b961"></a> <h2 class="memtitle">extractLabeledEuclideanClusters() <span class="overload">[2/2]</span>
</h2> <div class="memitem"> <div class="memproto"> <div class="memtemplate"> template&lt;typename PointT &gt; </div> <table class="memname"> <tr> <td class="memname">void pcl::extractLabeledEuclideanClusters </td> <td>(</td> <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &gt; &amp; </td> <td class="paramname">
<em>cloud</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">const typename <a class="el" href="https://pointclouds.org/documentation/classpcl_1_1search_1_1_search.html">search::Search</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &gt;::Ptr &amp; </td> <td class="paramname">
<em>tree</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">float </td> <td class="paramname">
<em>tolerance</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="structpcl_1_1_point_indices">PointIndices</a> &gt;&gt; &amp; </td> <td class="paramname">
<em>labeled_clusters</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">unsigned int </td> <td class="paramname">
<em>min_pts_per_cluster</em> = <code>1</code>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">unsigned int </td> <td class="paramname">
<em>max_pts_per_cluster</em> = <code>std::numeric_limits&lt;unsigned int&gt;::max()</code> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </div>
<div class="memdoc"> <p><code>#include &lt;pcl/segmentation/extract_labeled_clusters.h&gt;</code></p> <p>Decompose a region of space into clusters based on the Euclidean distance between points. </p> <dl class="params">
<dt>Parameters</dt>
<dd> <table class="params"> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">cloud</td>
<td>the point cloud message </td>
</tr> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">tree</td>
<td>the spatial locator (e.g., kd-tree) used for nearest neighbors searching </td>
</tr> </table> </dd> </dl> <dl class="section note">
<dt>Note</dt>
<dd>the tree has to be created as a spatial locator on <em>cloud</em> </dd>
</dl> <dl class="params">
<dt>Parameters</dt>
<dd> <table class="params"> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">tolerance</td>
<td>the spatial cluster tolerance as a measure in L2 Euclidean space </td>
</tr> <tr>
<td class="paramdir">[out]</td>
<td class="paramname">labeled_clusters</td>
<td>the resultant clusters containing point indices (as a vector of <a class="el" href="structpcl_1_1_point_indices">PointIndices</a>) </td>
</tr> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">min_pts_per_cluster</td>
<td>minimum number of points that a cluster may contain (default: 1) </td>
</tr> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">max_pts_per_cluster</td>
<td>maximum number of points that a cluster may contain (default: max int) </td>
</tr> </table> </dd> </dl> <p class="definition">Definition at line <a class="el" href="https://pointclouds.org/documentation/extract__labeled__clusters_8hpp_source.html#l00064">64</a> of file <a class="el" href="https://pointclouds.org/documentation/extract__labeled__clusters_8hpp_source.html">extract_labeled_clusters.hpp</a>.</p> <p class="reference">References <a class="el" href="https://pointclouds.org/documentation/search_8h_source.html#l00125">pcl::search::Search&lt; PointT &gt;::getInputCloud()</a>, <a class="el" href="https://pointclouds.org/documentation/_point_indices_8h_source.html#l00019">pcl::PointIndices::header</a>, <a class="el" href="https://pointclouds.org/documentation/common_2include_2pcl_2point__cloud_8h_source.html#l00392">pcl::PointCloud&lt; PointT &gt;::header</a>, <a class="el" href="https://pointclouds.org/documentation/_point_indices_8h_source.html#l00021">pcl::PointIndices::indices</a>, <a class="el" href="https://pointclouds.org/documentation/classpcl_1_1search_1_1_search.html#af803bbb855706159fa2cd36e4e8f0c58">pcl::search::Search&lt; PointT &gt;::radiusSearch()</a>, and <a class="el" href="https://pointclouds.org/documentation/common_2include_2pcl_2point__cloud_8h_source.html#l00443">pcl::PointCloud&lt; PointT &gt;::size()</a>.</p> </div> </div> <a id="ga5fd433527a00085583fa1e8eb31cba0f"></a> <h2 class="memtitle">getPointCloudDifference()</h2> <div class="memitem"> <div class="memproto"> <div class="memtemplate"> template&lt;typename PointT &gt; </div> <table class="memname"> <tr> <td class="memname">void pcl::getPointCloudDifference </td> <td>(</td> <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &gt; &amp; </td> <td class="paramname">
<em>src</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">double </td> <td class="paramname">
<em>threshold</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">const typename <a class="el" href="https://pointclouds.org/documentation/classpcl_1_1search_1_1_search.html">pcl::search::Search</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &gt;::Ptr &amp; </td> <td class="paramname">
<em>tree</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">
<a class="el" href="classpcl_1_1_point_cloud">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &gt; &amp; </td> <td class="paramname">
<em>output</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </div>
<div class="memdoc"> <p><code>#include &lt;pcl/segmentation/segment_differences.h&gt;</code></p> <p>Obtain the difference between two aligned point clouds as another point cloud, given a distance threshold. </p> <dl class="params">
<dt>Parameters</dt>
<dd> <table class="params"> <tr>
<td class="paramname">src</td>
<td>the input point cloud source </td>
</tr> <tr>
<td class="paramname">threshold</td>
<td>the distance threshold (tolerance) for point correspondences. (e.g., check if f a point p1 from src has a correspondence &gt; threshold than a point p2 from tgt) </td>
</tr> <tr>
<td class="paramname">tree</td>
<td>the spatial locator (e.g., kd-tree) used for nearest neighbors searching built over the target cloud </td>
</tr> <tr>
<td class="paramname">output</td>
<td>the resultant output point cloud difference </td>
</tr> </table> </dd> </dl> <p class="definition">Definition at line <a class="el" href="https://pointclouds.org/documentation/segment__differences_8hpp_source.html#l00050">50</a> of file <a class="el" href="https://pointclouds.org/documentation/segment__differences_8hpp_source.html">segment_differences.hpp</a>.</p> <p class="reference">References <a class="el" href="https://pointclouds.org/documentation/common_2include_2pcl_2common_2impl_2io_8hpp_source.html#l00144">pcl::copyPointCloud()</a>, <a class="el" href="https://pointclouds.org/documentation/common_2include_2pcl_2point__cloud_8h_source.html#l00403">pcl::PointCloud&lt; PointT &gt;::is_dense</a>, <a class="el" href="https://pointclouds.org/documentation/point__tests_8h_source.html#l00055">pcl::isFinite()</a>, <a class="el" href="https://pointclouds.org/documentation/classpcl_1_1search_1_1_search.html#add1a92f91475abd5530d26c7be1eb410">pcl::search::Search&lt; PointT &gt;::nearestKSearch()</a>, and <a class="el" href="https://pointclouds.org/documentation/common_2include_2pcl_2point__cloud_8h_source.html#l00443">pcl::PointCloud&lt; PointT &gt;::size()</a>.</p> <p class="reference">Referenced by <a class="el" href="https://pointclouds.org/documentation/segment__differences_8hpp_source.html#l00091">pcl::SegmentDifferences&lt; PointT &gt;::segment()</a>.</p> </div> </div> <a id="ga0a21f5679b1644a7894f2f14ee1bbe37"></a> <h2 class="memtitle">isPointIn2DPolygon()</h2> <div class="memitem"> <div class="memproto"> <div class="memtemplate"> template&lt;typename PointT &gt; </div> <table class="memname"> <tr> <td class="memname">bool pcl::isPointIn2DPolygon </td> <td>(</td> <td class="paramtype">const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &amp; </td> <td class="paramname">
<em>point</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &gt; &amp; </td> <td class="paramname">
<em>polygon</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </div>
<div class="memdoc"> <p><code>#include &lt;pcl/segmentation/extract_polygonal_prism_data.h&gt;</code></p> <p>General purpose method for checking if a 3D point is inside or outside a given 2D polygon. </p> <dl class="section note">
<dt>Note</dt>
<dd>this method accepts any general 3D point that is projected onto the 2D polygon, but performs an internal XY projection of both the polygon and the point. </dd>
</dl> <dl class="params">
<dt>Parameters</dt>
<dd> <table class="params"> <tr>
<td class="paramname">point</td>
<td>a 3D point projected onto the same plane as the polygon </td>
</tr> <tr>
<td class="paramname">polygon</td>
<td>a polygon </td>
</tr> </table> </dd> </dl> <p class="definition">Definition at line <a class="el" href="https://pointclouds.org/documentation/extract__polygonal__prism__data_8hpp_source.html#l00048">48</a> of file <a class="el" href="https://pointclouds.org/documentation/extract__polygonal__prism__data_8hpp_source.html">extract_polygonal_prism_data.hpp</a>.</p> <p class="reference">References <a class="el" href="https://pointclouds.org/documentation/centroid_8hpp_source.html#l00485">pcl::computeMeanAndCovarianceMatrix()</a>, <a class="el" href="https://pointclouds.org/documentation/common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00296">pcl::eigen33()</a>, <a class="el" href="https://pointclouds.org/documentation/extract__polygonal__prism__data_8hpp_source.html#l00108">pcl::isXYPointIn2DXYPolygon()</a>, <a class="el" href="https://pointclouds.org/documentation/common_2include_2pcl_2point__cloud_8h_source.html#l00462">pcl::PointCloud&lt; PointT &gt;::resize()</a>, and <a class="el" href="https://pointclouds.org/documentation/common_2include_2pcl_2point__cloud_8h_source.html#l00443">pcl::PointCloud&lt; PointT &gt;::size()</a>.</p> </div> </div> <a id="ga5c5f766262ec4eae1af76df2bc0afc64"></a> <h2 class="memtitle">isXYPointIn2DXYPolygon()</h2> <div class="memitem"> <div class="memproto"> <div class="memtemplate"> template&lt;typename PointT &gt; </div> <table class="memname"> <tr> <td class="memname">bool pcl::isXYPointIn2DXYPolygon </td> <td>(</td> <td class="paramtype">const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &amp; </td> <td class="paramname">
<em>point</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &gt; &amp; </td> <td class="paramname">
<em>polygon</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </div>
<div class="memdoc"> <p><code>#include &lt;pcl/segmentation/extract_polygonal_prism_data.h&gt;</code></p> <p>Check if a 2d point (X and Y coordinates considered only!) is inside or outside a given polygon. </p> <p>This method assumes that both the point and the polygon are projected onto the XY plane.</p> <dl class="section note">
<dt>Note</dt>
<dd>(This is highly optimized code taken from <a href="http://www.visibone.com/inpoly/">http://www.visibone.com/inpoly/</a>) Copyright (c) 1995-1996 Galacticomm, Inc. Freeware source code. </dd>
</dl> <dl class="params">
<dt>Parameters</dt>
<dd> <table class="params"> <tr>
<td class="paramname">point</td>
<td>a 2D point projected onto the same plane as the polygon </td>
</tr> <tr>
<td class="paramname">polygon</td>
<td>a polygon </td>
</tr> </table> </dd> </dl> <p class="definition">Definition at line <a class="el" href="https://pointclouds.org/documentation/extract__polygonal__prism__data_8hpp_source.html#l00108">108</a> of file <a class="el" href="https://pointclouds.org/documentation/extract__polygonal__prism__data_8hpp_source.html">extract_polygonal_prism_data.hpp</a>.</p> <p class="reference">References <a class="el" href="https://pointclouds.org/documentation/common_2include_2pcl_2point__cloud_8h_source.html#l00443">pcl::PointCloud&lt; PointT &gt;::size()</a>.</p> <p class="reference">Referenced by <a class="el" href="https://pointclouds.org/documentation/extract__polygonal__prism__data_8hpp_source.html#l00048">pcl::isPointIn2DPolygon()</a>, and <a class="el" href="https://pointclouds.org/documentation/extract__polygonal__prism__data_8hpp_source.html#l00149">pcl::ExtractPolygonalPrismData&lt; PointT &gt;::segment()</a>.</p> </div> </div> <a id="ga8ce6ea49099c7bf2de825f3f5ee61152"></a> <h2 class="memtitle">randomWalker() <span class="overload">[1/3]</span>
</h2> <div class="memitem"> <div class="memproto"> <div class="memtemplate"> template&lt;class Graph &gt; </div> <table class="memname"> <tr> <td class="memname">bool pcl::segmentation::randomWalker </td> <td>(</td> <td class="paramtype">Graph &amp; </td> <td class="paramname"><em>graph</em></td>
<td>)</td> <td></td> </tr> </table> </div>
<div class="memdoc"> <p><code>#include &lt;pcl/segmentation/impl/random_walker.hpp&gt;</code></p> <p>Multilabel graph segmentation using random walks. </p> <p>This is an implementation of the algorithm described in "Random Walks for Image Segmentation" by Leo Grady.</p> <p>Given a weighted undirected graph and a small number of user-defined labels this algorithm analytically determines the probability that a random walker starting at each unlabeled vertex will first reach one of the prelabeled vertices. The unlabeled vertices are then assigned to the label for which the greatest probability is calculated.</p> <p>The input is a BGL graph, a property map that associates a weight to each edge of the graph, and a property map that contains initial vertex colors (the term "color" is used interchangeably with "label").</p> <dl class="section note">
<dt>Note</dt>
<dd>The colors of unlabeled vertices should be set to 0, the colors of labeled vetices could be any positive numbers.</dd> <dd> This is the responsibility of the user to make sure that every connected component of the graph has at least one colored vertex. If the user failed to do so, then the behavior of the algorithm is undefined, i.e. it may or may not succeed, and also may or may not report failure.</dd>
</dl> <p>The output of the algorithm (i.e. label assignment) is written back to the color map.</p> <dl class="params">
<dt>Parameters</dt>
<dd> <table class="params"> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">graph</td>
<td>an undirected graph with internal edge weight and vertex color property maps</td>
</tr> </table> </dd> </dl> <p>Several overloads of <a class="el" href="group__segmentation#ga8ce6ea49099c7bf2de825f3f5ee61152" title="Multilabel graph segmentation using random walks.">randomWalker()</a> function are provided for convenience.</p> <dl class="section see">
<dt>See also</dt>
<dd>
<a class="el" href="group__segmentation#ga60d903133e1043dbaf9dc1764bb6c457" title="Multilabel graph segmentation using random walks.">randomWalker(Graph&amp;, EdgeWeightMap, VertexColorMap)</a> </dd> <dd> <a class="el" href="group__segmentation#ga941c995a5d4e8a4e31500d272ae43740" title="Multilabel graph segmentation using random walks.">randomWalker(Graph&amp;, EdgeWeightMap, VertexColorMap, Eigen::Matrix &lt;typename boost::property_traits&lt;EdgeWeightMap&gt;::value_type, Eigen::Dynamic, Eigen::Dynamic&gt;&amp;, std::map&lt;typename boost::property_traits &lt;VertexColorMap&gt;::value_type, std::size_t&gt;&amp;)</a>
</dd>
</dl> <dl class="section author">
<dt>Author</dt>
<dd>Sergey Alexandrov </dd>
</dl> <p class="definition">Definition at line <a class="el" href="https://pointclouds.org/documentation/random__walker_8hpp_source.html#l00280">280</a> of file <a class="el" href="https://pointclouds.org/documentation/random__walker_8hpp_source.html">random_walker.hpp</a>.</p> </div> </div> <a id="ga60d903133e1043dbaf9dc1764bb6c457"></a> <h2 class="memtitle">randomWalker() <span class="overload">[2/3]</span>
</h2> <div class="memitem"> <div class="memproto"> <div class="memtemplate"> template&lt;class Graph , class EdgeWeightMap , class VertexColorMap &gt; </div> <table class="memname"> <tr> <td class="memname">bool pcl::segmentation::randomWalker </td> <td>(</td> <td class="paramtype">Graph &amp; </td> <td class="paramname">
<em>graph</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">EdgeWeightMap </td> <td class="paramname">
<em>weights</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">VertexColorMap </td> <td class="paramname">
<em>colors</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </div>
<div class="memdoc"> <p><code>#include &lt;pcl/segmentation/impl/random_walker.hpp&gt;</code></p> <p>Multilabel graph segmentation using random walks. </p> <p>This is an overloaded function provided for convenience. See the documentation for <a class="el" href="group__segmentation#ga8ce6ea49099c7bf2de825f3f5ee61152" title="Multilabel graph segmentation using random walks.">randomWalker()</a>.</p> <dl class="params">
<dt>Parameters</dt>
<dd> <table class="params"> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">graph</td>
<td>an undirected graph </td>
</tr> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">weights</td>
<td>an external edge weight property map </td>
</tr> <tr>
<td class="paramdir">[in,out]</td>
<td class="paramname">colors</td>
<td>an external vertex color property map</td>
</tr> </table> </dd> </dl> <dl class="section author">
<dt>Author</dt>
<dd>Sergey Alexandrov </dd>
</dl> <p class="definition">Definition at line <a class="el" href="https://pointclouds.org/documentation/random__walker_8hpp_source.html#l00288">288</a> of file <a class="el" href="https://pointclouds.org/documentation/random__walker_8hpp_source.html">random_walker.hpp</a>.</p> </div> </div> <a id="ga941c995a5d4e8a4e31500d272ae43740"></a> <h2 class="memtitle">randomWalker() <span class="overload">[3/3]</span>
</h2> <div class="memitem"> <div class="memproto"> <div class="memtemplate"> template&lt;class Graph , class EdgeWeightMap , class VertexColorMap &gt; </div> <table class="memname"> <tr> <td class="memname">bool pcl::segmentation::randomWalker </td> <td>(</td> <td class="paramtype">Graph &amp; </td> <td class="paramname">
<em>graph</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">EdgeWeightMap </td> <td class="paramname">
<em>weights</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">VertexColorMap </td> <td class="paramname">
<em>colors</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">Eigen::Matrix&lt; typename boost::property_traits&lt; EdgeWeightMap &gt;::value_type, Eigen::Dynamic, Eigen::Dynamic &gt; &amp; </td> <td class="paramname">
<em>potentials</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">std::map&lt; typename boost::property_traits&lt; VertexColorMap &gt;::value_type, std::size_t &gt; &amp; </td> <td class="paramname">
<em>colors_to_columns_map</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </div>
<div class="memdoc"> <p><code>#include &lt;pcl/segmentation/impl/random_walker.hpp&gt;</code></p> <p>Multilabel graph segmentation using random walks. </p> <p>This is an overloaded function provided for convenience. See the documentation for <a class="el" href="group__segmentation#ga8ce6ea49099c7bf2de825f3f5ee61152" title="Multilabel graph segmentation using random walks.">randomWalker()</a>.</p> <dl class="params">
<dt>Parameters</dt>
<dd> <table class="params"> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">graph</td>
<td>an undirected graph </td>
</tr> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">weights</td>
<td>an external edge weight property map </td>
</tr> <tr>
<td class="paramdir">[in,out]</td>
<td class="paramname">colors</td>
<td>an external vertex color property map </td>
</tr> <tr>
<td class="paramdir">[out]</td>
<td class="paramname">potentials</td>
<td>a matrix with calculated probabilities, where rows correspond to vertices, and columns correspond to colors </td>
</tr> <tr>
<td class="paramdir">[out]</td>
<td class="paramname">colors_to_columns_map</td>
<td>a mapping between colors and columns in <em>potentials</em> matrix</td>
</tr> </table> </dd> </dl> <dl class="section author">
<dt>Author</dt>
<dd>Sergey Alexandrov </dd>
</dl> <p class="definition">Definition at line <a class="el" href="https://pointclouds.org/documentation/random__walker_8hpp_source.html#l00314">314</a> of file <a class="el" href="https://pointclouds.org/documentation/random__walker_8hpp_source.html">random_walker.hpp</a>.</p> </div> </div> <a id="ga5891c20fc0abc04063e117afaa8554d6"></a> <h2 class="memtitle">seededHueSegmentation() <span class="overload">[1/2]</span>
</h2> <div class="memitem"> <div class="memproto"> <table class="memname"> <tr> <td class="memname">void pcl::seededHueSegmentation </td> <td>(</td> <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointXYZRGB</a> &gt; &amp; </td> <td class="paramname">
<em>cloud</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">const <a class="el" href="https://pointclouds.org/documentation/classpcl_1_1search_1_1_search.html">search::Search</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointXYZRGB</a> &gt;::Ptr &amp; </td> <td class="paramname">
<em>tree</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">float </td> <td class="paramname">
<em>tolerance</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">
<a class="el" href="structpcl_1_1_point_indices">PointIndices</a> &amp; </td> <td class="paramname">
<em>indices_in</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">
<a class="el" href="structpcl_1_1_point_indices">PointIndices</a> &amp; </td> <td class="paramname">
<em>indices_out</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">float </td> <td class="paramname">
<em>delta_hue</em> = <code>0.0</code> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </div>
<div class="memdoc"> <p><code>#include &lt;pcl/segmentation/seeded_hue_segmentation.h&gt;</code></p> <p>Decompose a region of space into clusters based on the Euclidean distance between points. </p> <dl class="params">
<dt>Parameters</dt>
<dd> <table class="params"> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">cloud</td>
<td>the point cloud message </td>
</tr> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">tree</td>
<td>the spatial locator (e.g., kd-tree) used for nearest neighbors searching </td>
</tr> </table> </dd> </dl> <dl class="section note">
<dt>Note</dt>
<dd>the tree has to be created as a spatial locator on <em>cloud</em> </dd>
</dl> <dl class="params">
<dt>Parameters</dt>
<dd> <table class="params"> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">tolerance</td>
<td>the spatial cluster tolerance as a measure in L2 Euclidean space </td>
</tr> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">indices_in</td>
<td>the cluster containing the seed point indices (as a vector of <a class="el" href="structpcl_1_1_point_indices">PointIndices</a>) </td>
</tr> <tr>
<td class="paramdir">[out]</td>
<td class="paramname">indices_out</td>
<td></td>
</tr> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">delta_hue</td>
<td></td>
</tr> </table> </dd> </dl> <dl class="todo">
<dt><b><a class="el" href="todo#_todo000040">Todo:</a></b></dt>
<dd>look how to make this templated! </dd>
</dl> <p class="definition">Definition at line <a class="el" href="https://pointclouds.org/documentation/seeded__hue__segmentation_8hpp_source.html#l00049">49</a> of file <a class="el" href="https://pointclouds.org/documentation/seeded__hue__segmentation_8hpp_source.html">seeded_hue_segmentation.hpp</a>.</p> <p class="reference">References <a class="el" href="https://pointclouds.org/documentation/search_8h_source.html#l00125">pcl::search::Search&lt; PointT &gt;::getInputCloud()</a>, <a class="el" href="https://pointclouds.org/documentation/point__types_8hpp_source.html#l00791">pcl::_PointXYZHSV::h</a>, <a class="el" href="https://pointclouds.org/documentation/_point_indices_8h_source.html#l00021">pcl::PointIndices::indices</a>, <a class="el" href="https://pointclouds.org/documentation/point__types__conversion_8h_source.html#l00107">pcl::PointXYZRGBtoXYZHSV()</a>, <a class="el" href="https://pointclouds.org/documentation/classpcl_1_1search_1_1_search.html#af803bbb855706159fa2cd36e4e8f0c58">pcl::search::Search&lt; PointT &gt;::radiusSearch()</a>, and <a class="el" href="https://pointclouds.org/documentation/common_2include_2pcl_2point__cloud_8h_source.html#l00443">pcl::PointCloud&lt; PointT &gt;::size()</a>.</p> <p class="reference">Referenced by <a class="el" href="https://pointclouds.org/documentation/seeded__hue__segmentation_8hpp_source.html#l00206">pcl::SeededHueSegmentation::segment()</a>.</p> </div> </div> <a id="gaf25653016cc78d6cf7adad3651b0d7ed"></a> <h2 class="memtitle">seededHueSegmentation() <span class="overload">[2/2]</span>
</h2> <div class="memitem"> <div class="memproto"> <table class="memname"> <tr> <td class="memname">void pcl::seededHueSegmentation </td> <td>(</td> <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointXYZRGB</a> &gt; &amp; </td> <td class="paramname">
<em>cloud</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">const <a class="el" href="https://pointclouds.org/documentation/classpcl_1_1search_1_1_search.html">search::Search</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b_l">PointXYZRGBL</a> &gt;::Ptr &amp; </td> <td class="paramname">
<em>tree</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">float </td> <td class="paramname">
<em>tolerance</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">
<a class="el" href="structpcl_1_1_point_indices">PointIndices</a> &amp; </td> <td class="paramname">
<em>indices_in</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">
<a class="el" href="structpcl_1_1_point_indices">PointIndices</a> &amp; </td> <td class="paramname">
<em>indices_out</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">float </td> <td class="paramname">
<em>delta_hue</em> = <code>0.0</code> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </div>
<div class="memdoc"> <p><code>#include &lt;pcl/segmentation/seeded_hue_segmentation.h&gt;</code></p> <p>Decompose a region of space into clusters based on the Euclidean distance between points. </p> <dl class="params">
<dt>Parameters</dt>
<dd> <table class="params"> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">cloud</td>
<td>the point cloud message </td>
</tr> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">tree</td>
<td>the spatial locator (e.g., kd-tree) used for nearest neighbors searching </td>
</tr> </table> </dd> </dl> <dl class="section note">
<dt>Note</dt>
<dd>the tree has to be created as a spatial locator on <em>cloud</em> </dd>
</dl> <dl class="params">
<dt>Parameters</dt>
<dd> <table class="params"> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">tolerance</td>
<td>the spatial cluster tolerance as a measure in L2 Euclidean space </td>
</tr> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">indices_in</td>
<td>the cluster containing the seed point indices (as a vector of <a class="el" href="structpcl_1_1_point_indices">PointIndices</a>) </td>
</tr> <tr>
<td class="paramdir">[out]</td>
<td class="paramname">indices_out</td>
<td></td>
</tr> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">delta_hue</td>
<td></td>
</tr> </table> </dd> </dl> <dl class="todo">
<dt><b><a class="el" href="todo#_todo000041">Todo:</a></b></dt>
<dd>look how to make this templated! </dd>
</dl> <p class="definition">Definition at line <a class="el" href="https://pointclouds.org/documentation/seeded__hue__segmentation_8hpp_source.html#l00127">127</a> of file <a class="el" href="https://pointclouds.org/documentation/seeded__hue__segmentation_8hpp_source.html">seeded_hue_segmentation.hpp</a>.</p> <p class="reference">References <a class="el" href="https://pointclouds.org/documentation/search_8h_source.html#l00125">pcl::search::Search&lt; PointT &gt;::getInputCloud()</a>, <a class="el" href="https://pointclouds.org/documentation/point__types_8hpp_source.html#l00791">pcl::_PointXYZHSV::h</a>, <a class="el" href="https://pointclouds.org/documentation/_point_indices_8h_source.html#l00021">pcl::PointIndices::indices</a>, <a class="el" href="https://pointclouds.org/documentation/point__types__conversion_8h_source.html#l00107">pcl::PointXYZRGBtoXYZHSV()</a>, <a class="el" href="https://pointclouds.org/documentation/classpcl_1_1search_1_1_search.html#af803bbb855706159fa2cd36e4e8f0c58">pcl::search::Search&lt; PointT &gt;::radiusSearch()</a>, and <a class="el" href="https://pointclouds.org/documentation/common_2include_2pcl_2point__cloud_8h_source.html#l00443">pcl::PointCloud&lt; PointT &gt;::size()</a>.</p> </div> </div> <div class="_attribution">
  <p class="_attribution-p">
    © 2009–2012, Willow Garage, Inc.<br>© 2012–, Open Perception, Inc.<br>Licensed under the BSD License.<br>
    <a href="https://pointclouds.org/documentation/group__segmentation.html" class="_attribution-link">https://pointclouds.org/documentation/group__segmentation.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
