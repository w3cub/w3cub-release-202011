
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Eigen&#58;&#58;Transform - Eigen3 - W3cubDocs</title>
  
  <meta name="description" content=" Represents an homogeneous transformation in a N dimensional space. ">
  <meta name="keywords" content="eigen, transform, eigen3">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/eigen3/classeigen_1_1transform.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-f16eecbe420d8b2925d31ffbb21d05646497ecbd9515f08ffe69e9bba7332f5657accc7003c7f6c72cb4a132171acf171b359ae3bae4ae5660ddfb1718f88c67.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/eigen3.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/eigen3/" class="_nav-link" title="" style="margin-left:0;">Eigen3</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _eigen3">
				
				
<h1>Eigen::Transform</h1>      <div>  <div>
<h3>template&lt;typename _Scalar, int _Dim, int _Mode, int _Options&gt;<br> class Eigen::Transform&lt; _Scalar, _Dim, _Mode, _Options &gt;</h3> <p>Represents an homogeneous transformation in a N dimensional space. </p> <p>This is defined in the Geometry module.</p>
<pre data-language="cpp"><span>#include &lt;Eigen/Geometry&gt;</span> 
</pre>
<dl>
<dt>Template Parameters</dt>
<dd> <table> <tr>
<td>_Scalar</td>
<td>the scalar type, i.e., the type of the coefficients </td>
</tr> <tr>
<td>_Dim</td>
<td>the dimension of the space </td>
</tr> <tr>
<td>_Mode</td>
<td>the type of the transformation. Can be:<ul> <li>
<a href="group__enums#ggaee59a86102f150923b0cac6d4ff05107a0872f0a82453aaae40339c33acbb31fb">Affine</a>: the transformation is stored as a (Dim+1)^2 matrix, where the last row is assumed to be [0 ... 0 1].</li> <li>
<a href="group__enums#ggaee59a86102f150923b0cac6d4ff05107a8192e8fdb2ec3ec46d92956cc83ef490">AffineCompact</a>: the transformation is stored as a (Dim)x(Dim+1) matrix.</li> <li>
<a href="group__enums#ggaee59a86102f150923b0cac6d4ff05107a0f7338b8672884554e8642bce9e44183">Projective</a>: the transformation is stored as a (Dim+1)^2 matrix without any assumption.</li> <li>
<a href="group__enums#ggaee59a86102f150923b0cac6d4ff05107a84413028615d2d718bafd2dfb93dafef">Isometry</a>: same as <a href="group__enums#ggaee59a86102f150923b0cac6d4ff05107a0872f0a82453aaae40339c33acbb31fb">Affine</a> with the additional assumption that the linear part represents a rotation. This assumption is exploited to speed up some functions such as <a href="classeigen_1_1transform#ab8dbcd157bf194efca1a5413c0945211">inverse()</a> and <a href="classeigen_1_1transform#ad73300a550f878bb7f34485c3d132746">rotation()</a>. </li> </ul> </td>
</tr> <tr>
<td>_Options</td>
<td>has the same meaning as in class <a href="classeigen_1_1matrix" title="The matrix class, also used for vectors and row-vectors.">Matrix</a>. It allows to specify DontAlign and/or RowMajor. These Options are passed directly to the underlying matrix type.</td>
</tr> </table> </dd> </dl> <p>The homography is internally represented and stored by a matrix which is available through the <a href="classeigen_1_1transform#a758fbaf6aa41a5493659aa0c9bfe0dcf">matrix()</a> method. To understand the behavior of this class you have to think a <a href="classeigen_1_1transform" title="Represents an homogeneous transformation in a N dimensional space.">Transform</a> object as its internal matrix representation. The chosen convention is right multiply:</p> <pre data-language="cpp">v<span>' = T * v </span>
</pre>
<p>Therefore, an affine transformation matrix M is shaped like this:</p> <p>\( \left( \begin{array}{cc} linear &amp; translation\\ 0 ... 0 &amp; 1 \end{array} \right) \)</p> <p>Note that for a projective transformation the last row can be anything, and then the interpretation of different parts might be slightly different.</p> <p>However, unlike a plain matrix, the <a href="classeigen_1_1transform" title="Represents an homogeneous transformation in a N dimensional space.">Transform</a> class provides many features simplifying both its assembly and usage. In particular, it can be composed with any other transformations (<a href="classeigen_1_1transform" title="Represents an homogeneous transformation in a N dimensional space.">Transform</a>,<a href="classeigen_1_1translation" title="Represents a translation transformation.">Translation</a>,<a href="classeigen_1_1rotationbase" title="Common base class for compact rotation representations.">RotationBase</a>,<a href="classeigen_1_1diagonalmatrix" title="Represents a diagonal matrix with its storage.">DiagonalMatrix</a>) and can be directly used to transform implicit homogeneous vectors. All these operations are handled via the operator*. For the composition of transformations, its principle consists to first convert the right/left hand sides of the product to a compatible (Dim+1)^2 matrix and then perform a pure matrix product. Of course, internally, operator* tries to perform the minimal number of operations according to the nature of each terms. Likewise, when applying the transform to points, the latters are automatically promoted to homogeneous vectors before doing the matrix product. The conventions to homogeneous representations are performed as follow:</p> <p><b><a href="classeigen_1_1translation" title="Represents a translation transformation.">Translation</a></b> t (Dim)x(1): \( \left( \begin{array}{cc} I &amp; t \\ 0\,...\,0 &amp; 1 \end{array} \right) \)</p> <p><b>Rotation</b> R (Dim)x(Dim): \( \left( \begin{array}{cc} R &amp; 0\\ 0\,...\,0 &amp; 1 \end{array} \right) \)</p> <p><b>Scaling</b> <b><a href="classeigen_1_1diagonalmatrix" title="Represents a diagonal matrix with its storage.">DiagonalMatrix</a></b> S (Dim)x(Dim): \( \left( \begin{array}{cc} S &amp; 0\\ 0\,...\,0 &amp; 1 \end{array} \right) \)</p> <p><b>Column</b> <b>point</b> v (Dim)x(1): \( \left( \begin{array}{c} v\\ 1 \end{array} \right) \)</p> <p><b>Set</b> <b>of</b> <b>column</b> <b>points</b> V1...Vn (Dim)x(n): \( \left( \begin{array}{ccc} v_1 &amp; ... &amp; v_n\\ 1 &amp; ... &amp; 1 \end{array} \right) \)</p> <p>The concatenation of a <a href="classeigen_1_1transform" title="Represents an homogeneous transformation in a N dimensional space.">Transform</a> object with any kind of other transformation always returns a <a href="classeigen_1_1transform" title="Represents an homogeneous transformation in a N dimensional space.">Transform</a> object.</p> <p>A little exception to the "as pure matrix product" rule is the case of the transformation of non homogeneous vectors by an affine transformation. In that case the last matrix row can be ignored, and the product returns non homogeneous vectors.</p> <p>Since, for instance, a Dim x Dim matrix is interpreted as a linear transformation, it is not possible to directly transform Dim vectors stored in a Dim x Dim matrix. The solution is either to use a Dim x Dynamic matrix or explicitly request a vector transformation by making the vector homogeneous: </p>
<pre data-language="cpp">m<span>' = T * m.colwise().homogeneous();</span>
</pre>
<p> Note that there is zero overhead.</p> <p>Conversion methods from/to Qt's QMatrix and QTransform are available if the preprocessor token EIGEN_QT_SUPPORT is defined.</p> <p>This class can be extended with the help of the plugin mechanism described on the page <a href="topiccustomizing_plugins">Extending MatrixBase (and other classes)</a> by defining the preprocessor symbol <code>EIGEN_TRANSFORM_PLUGIN</code>.</p> <dl>
<dt>See also</dt>
<dd>class <a href="classeigen_1_1matrix" title="The matrix class, also used for vectors and row-vectors.">Matrix</a>, class <a href="classeigen_1_1quaternion" title="The quaternion class used to represent 3D orientations and rotations.">Quaternion</a> </dd>
</dl> </div>
<table> <tr><td colspan="2"></td></tr> <tr>
<td align="right" valign="top">typedef internal::conditional&lt; int(Mode)==int(<a href="group__enums#ggaee59a86102f150923b0cac6d4ff05107a8192e8fdb2ec3ec46d92956cc83ef490">AffineCompact</a>), <a href="classeigen_1_1transform#a30f72ba46abc2bb3c7fa919c1078fc9c">MatrixType</a> &amp;, <a href="classeigen_1_1block">Block</a>&lt; <a href="classeigen_1_1transform#a30f72ba46abc2bb3c7fa919c1078fc9c">MatrixType</a>, Dim, HDim &gt; &gt;::type </td>
<td valign="bottom"><a href="classeigen_1_1transform#a8319bad977b0dabf2dfaf2e2dc30f13e">AffinePart</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">typedef internal::conditional&lt; int(Mode)==int(<a href="group__enums#ggaee59a86102f150923b0cac6d4ff05107a8192e8fdb2ec3ec46d92956cc83ef490">AffineCompact</a>), const <a href="classeigen_1_1transform#a30f72ba46abc2bb3c7fa919c1078fc9c">MatrixType</a> &amp;, const <a href="classeigen_1_1block">Block</a>&lt; const <a href="classeigen_1_1transform#a30f72ba46abc2bb3c7fa919c1078fc9c">MatrixType</a>, Dim, HDim &gt; &gt;::type </td>
<td valign="bottom"><a href="classeigen_1_1transform#adfa0bf2d9504548cdc9b9051b2fa9673">ConstAffinePart</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">typedef const <a href="classeigen_1_1block">Block</a>&lt; <a href="classeigen_1_1transform#aed436d14b16bd862bac5367990085795">ConstMatrixType</a>, Dim, Dim, int(Mode)==(<a href="group__enums#ggaee59a86102f150923b0cac6d4ff05107a8192e8fdb2ec3ec46d92956cc83ef490">AffineCompact</a>) &amp;&amp;(int(Options)&amp;<a href="group__enums#ggaacded1a18ae58b0f554751f6cdf9eb13a77c993a8d9f6efe5c1159fb2ab07dd4f">RowMajor</a>)==0 &gt; </td>
<td valign="bottom"><a href="classeigen_1_1transform#a75810d3f0d098e00b43a5531f33d78e1">ConstLinearPart</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">typedef const <a href="classeigen_1_1transform#a30f72ba46abc2bb3c7fa919c1078fc9c">MatrixType</a> </td>
<td valign="bottom"><a href="classeigen_1_1transform#aed436d14b16bd862bac5367990085795">ConstMatrixType</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">typedef const <a href="classeigen_1_1block">Block</a>&lt; <a href="classeigen_1_1transform#aed436d14b16bd862bac5367990085795">ConstMatrixType</a>, Dim, 1,!(internal::traits&lt; <a href="classeigen_1_1transform#a30f72ba46abc2bb3c7fa919c1078fc9c">MatrixType</a> &gt;::Flags &amp;<a href="group__flags#gae4f56c2a60bbe4bd2e44c5b19cbe8762">RowMajorBit</a>)&gt; </td>
<td valign="bottom"><a href="classeigen_1_1transform#a3eab3259d3fac8106eb3139bc96ba852">ConstTranslationPart</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">typedef <a href="namespaceeigen#a62e77e0933482dafde8fe197d9a2cfde">Eigen::Index</a> </td>
<td valign="bottom"><a href="classeigen_1_1transform#a49df3689ac2b736bcb564dec47d6486c">Index</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">typedef <a href="classeigen_1_1matrix">Matrix</a>&lt; <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Dim, Options &gt; </td>
<td valign="bottom"><a href="classeigen_1_1transform#a48138c0370e55371b95946c90d69e25c">LinearMatrixType</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">typedef <a href="classeigen_1_1block">Block</a>&lt; <a href="classeigen_1_1transform#a30f72ba46abc2bb3c7fa919c1078fc9c">MatrixType</a>, Dim, Dim, int(Mode)==(<a href="group__enums#ggaee59a86102f150923b0cac6d4ff05107a8192e8fdb2ec3ec46d92956cc83ef490">AffineCompact</a>) &amp;&amp;(int(Options)&amp;<a href="group__enums#ggaacded1a18ae58b0f554751f6cdf9eb13a77c993a8d9f6efe5c1159fb2ab07dd4f">RowMajor</a>)==0 &gt; </td>
<td valign="bottom"><a href="classeigen_1_1transform#a2195bd42561e691a8f6e7d989e77f328">LinearPart</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">typedef internal::make_proper_matrix_type&lt; <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Rows, HDim, Options &gt;::type </td>
<td valign="bottom"><a href="classeigen_1_1transform#a30f72ba46abc2bb3c7fa919c1078fc9c">MatrixType</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">typedef _Scalar </td>
<td valign="bottom"><a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">typedef <a href="classeigen_1_1transform">Transform</a>&lt; <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, TransformTimeDiagonalMode &gt; </td>
<td valign="bottom"><a href="classeigen_1_1transform#a51af5e8d8d9d9bfec091ff8aa5b7845a">TransformTimeDiagonalReturnType</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">typedef <a href="classeigen_1_1block">Block</a>&lt; <a href="classeigen_1_1transform#a30f72ba46abc2bb3c7fa919c1078fc9c">MatrixType</a>, Dim, 1,!(internal::traits&lt; <a href="classeigen_1_1transform#a30f72ba46abc2bb3c7fa919c1078fc9c">MatrixType</a> &gt;::Flags &amp;<a href="group__flags#gae4f56c2a60bbe4bd2e44c5b19cbe8762">RowMajorBit</a>)&gt; </td>
<td valign="bottom"><a href="classeigen_1_1transform#aabeaa2d375bf1b6b1d5cb5d1904fbd06">TranslationPart</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">typedef <a href="classeigen_1_1translation">Translation</a>&lt; <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim &gt; </td>
<td valign="bottom"><a href="classeigen_1_1transform#a6b463d14d8be4c0eda2eed6e943b831f">TranslationType</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">typedef <a href="classeigen_1_1matrix">Matrix</a>&lt; <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, 1 &gt; </td>
<td valign="bottom"><a href="classeigen_1_1transform#aaeb4ae2f95c8edb0655fd84ab3f89e79">VectorType</a></td>
</tr> <tr><td colspan="2"> </td></tr> </table>
<table> <tr><td colspan="2"></td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1transform#a8319bad977b0dabf2dfaf2e2dc30f13e">AffinePart</a> </td>
<td valign="bottom">
<a href="classeigen_1_1transform#a9795374292c085bca4d123397d6b37d9">affine</a> ()</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1transform#adfa0bf2d9504548cdc9b9051b2fa9673">ConstAffinePart</a> </td>
<td valign="bottom">
<a href="classeigen_1_1transform#a761a9c20fd5eefa58ca2f9babdf4c5d8">affine</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename NewScalarType &gt; </td></tr> <tr>
<td align="right" valign="top">internal::cast_return_type&lt; <a href="classeigen_1_1transform">Transform</a>, <a href="classeigen_1_1transform">Transform</a>&lt; NewScalarType, Dim, Mode, Options &gt; &gt;::type </td>
<td valign="bottom">
<a href="classeigen_1_1transform#a86a66867b2a9ee0c9c4e920baf2bdacd">cast</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename RotationMatrixType , typename ScalingMatrixType &gt; </td></tr> <tr>
<td align="right" valign="top">void </td>
<td valign="bottom">
<a href="classeigen_1_1transform#a7213fd78501c1185c4a1441e33c812d3">computeRotationScaling</a> (RotationMatrixType *<a href="classeigen_1_1transform#ad73300a550f878bb7f34485c3d132746">rotation</a>, ScalingMatrixType *scaling) const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename ScalingMatrixType , typename RotationMatrixType &gt; </td></tr> <tr>
<td align="right" valign="top">void </td>
<td valign="bottom">
<a href="classeigen_1_1transform#a247b079c63f46bb652b3776484838216">computeScalingRotation</a> (ScalingMatrixType *scaling, RotationMatrixType *<a href="classeigen_1_1transform#ad73300a550f878bb7f34485c3d132746">rotation</a>) const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> * </td>
<td valign="bottom">
<a href="classeigen_1_1transform#aefd183e4e0ca89c39b78d5ad7cf3e014">data</a> ()</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> * </td>
<td valign="bottom">
<a href="classeigen_1_1transform#a432669c64a0d6925ee5ea54f76d24a32">data</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top"> </td>
<td valign="bottom">
<a href="classeigen_1_1transform#a30c94c2156e9345f4bdb6cc9661e275b">EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF_VECTORIZABLE_FIXED_SIZE</a> (_Scalar, _Dim==<a href="namespaceeigen#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a> ? <a href="namespaceeigen#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a> :(_Dim+1) *(_Dim+1)) enum</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename PositionDerived , typename OrientationType , typename ScaleDerived &gt; </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1transform">Transform</a>&lt; <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt; &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1transform#afac1e7bd782e5cc92cbf70128809d5d1">fromPositionOrientationScale</a> (const <a href="classeigen_1_1matrixbase">MatrixBase</a>&lt; PositionDerived &gt; &amp;position, const OrientationType &amp;orientation, const <a href="classeigen_1_1matrixbase">MatrixBase</a>&lt; ScaleDerived &gt; &amp;scale)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1transform">Transform</a> </td>
<td valign="bottom">
<a href="classeigen_1_1transform#ab8dbcd157bf194efca1a5413c0945211">inverse</a> (<a href="group__enums#gaee59a86102f150923b0cac6d4ff05107">TransformTraits</a> traits=(<a href="group__enums#gaee59a86102f150923b0cac6d4ff05107">TransformTraits</a>) Mode) const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">bool </td>
<td valign="bottom">
<a href="classeigen_1_1transform#abd1696d9bb754e5c8734e691e03243f9">isApprox</a> (const <a href="classeigen_1_1transform">Transform</a> &amp;other, const typename <a href="structeigen_1_1numtraits">NumTraits</a>&lt; <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> &gt;::Real &amp;prec=<a href="structeigen_1_1numtraits">NumTraits</a>&lt; <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> &gt;::dummy_precision()) const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1transform#a2195bd42561e691a8f6e7d989e77f328">LinearPart</a> </td>
<td valign="bottom">
<a href="classeigen_1_1transform#ad36538ee2c2970722eff343ee1bbfc7c">linear</a> ()</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1transform#a75810d3f0d098e00b43a5531f33d78e1">ConstLinearPart</a> </td>
<td valign="bottom">
<a href="classeigen_1_1transform#af8c38249632146453785add778dc1081">linear</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">void </td>
<td valign="bottom">
<a href="classeigen_1_1transform#abef09a0e86261aeba4e10227fa3fa26b">makeAffine</a> ()</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1transform#a30f72ba46abc2bb3c7fa919c1078fc9c">MatrixType</a> &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1transform#a758fbaf6aa41a5493659aa0c9bfe0dcf">matrix</a> ()</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const <a href="classeigen_1_1transform#a30f72ba46abc2bb3c7fa919c1078fc9c">MatrixType</a> &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1transform#a0ac079dc1995058cbbded553b8d4485c">matrix</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1transform#a09fce82b9bdedb5deb2b223a3d716d3f">operator()</a> (<a href="classeigen_1_1transform#a49df3689ac2b736bcb564dec47d6486c">Index</a> row, <a href="classeigen_1_1transform#a49df3689ac2b736bcb564dec47d6486c">Index</a> col)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> </td>
<td valign="bottom">
<a href="classeigen_1_1transform#a9672c84cb1477eee118be144e7e5d581">operator()</a> (<a href="classeigen_1_1transform#a49df3689ac2b736bcb564dec47d6486c">Index</a> row, <a href="classeigen_1_1transform#a49df3689ac2b736bcb564dec47d6486c">Index</a> col) const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename DiagonalDerived &gt; </td></tr> <tr>
<td align="right" valign="top">const <a href="classeigen_1_1transform#a51af5e8d8d9d9bfec091ff8aa5b7845a">TransformTimeDiagonalReturnType</a> </td>
<td valign="bottom">
<a href="classeigen_1_1transform#ab3d93a2aba9d06e7d134798f92617da7">operator*</a> (const DiagonalBase&lt; DiagonalDerived &gt; &amp;b) const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename OtherDerived &gt; </td></tr> <tr>
<td align="right" valign="top">const internal::transform_right_product_impl&lt; <a href="classeigen_1_1transform">Transform</a>, OtherDerived &gt;::ResultType </td>
<td valign="bottom">
<a href="classeigen_1_1transform#a257ab8b9141982bd6f56771ba822526f">operator*</a> (const <a href="structeigen_1_1eigenbase">EigenBase</a>&lt; OtherDerived &gt; &amp;other) const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const <a href="classeigen_1_1transform">Transform</a> </td>
<td valign="bottom">
<a href="classeigen_1_1transform#a7e75d983600d35b603f740a3a28bbc6c">operator*</a> (const <a href="classeigen_1_1transform">Transform</a> &amp;other) const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;int OtherMode, int OtherOptions&gt; </td></tr> <tr>
<td align="right" valign="top">internal::transform_transform_product_impl&lt; <a href="classeigen_1_1transform">Transform</a>, <a href="classeigen_1_1transform">Transform</a>&lt; <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, OtherMode, OtherOptions &gt; &gt;::ResultType </td>
<td valign="bottom">
<a href="classeigen_1_1transform#ad4fc26aef2abfb9fdadb7d64aaf58c31">operator*</a> (const <a href="classeigen_1_1transform">Transform</a>&lt; <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, OtherMode, OtherOptions &gt; &amp;other) const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename OtherDerived &gt; </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1transform">Transform</a> &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1transform#a826047489741a19b81c6552f8257b1cf">operator=</a> (const <a href="structeigen_1_1eigenbase">EigenBase</a>&lt; OtherDerived &gt; &amp;other)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1transform">Transform</a> &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1transform#a8ed8318285ccc7498197da7df1273bd5">operator=</a> (const QMatrix &amp;other)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1transform">Transform</a> &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1transform#a54986164dcb1d0f7bfa216b8ef5272f6">operator=</a> (const QTransform &amp;other)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename RotationType &gt; </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1transform">Transform</a>&lt; <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt; &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1transform#ac5d65c2387e8d8b8f1526fc2c8443661">prerotate</a> (const RotationType &amp;<a href="classeigen_1_1transform#ad73300a550f878bb7f34485c3d132746">rotation</a>)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename OtherDerived &gt; </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1transform">Transform</a>&lt; <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt; &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1transform#a0d87009c9449d1920c037eb58468e757">prescale</a> (const <a href="classeigen_1_1matrixbase">MatrixBase</a>&lt; OtherDerived &gt; &amp;other)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1transform">Transform</a> &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1transform#a96c5e49e1d779299f4975dfef93e14b3">prescale</a> (const <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> &amp;s)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1transform">Transform</a> &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1transform#a17c40209cfd2d094cf654504aca95bf1">preshear</a> (const <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> &amp;sx, const <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> &amp;sy)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename OtherDerived &gt; </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1transform">Transform</a>&lt; <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt; &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1transform#ae9be55c2f6f4d56b0878c983c0ff9cc6">pretranslate</a> (const <a href="classeigen_1_1matrixbase">MatrixBase</a>&lt; OtherDerived &gt; &amp;other)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename RotationType &gt; </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1transform">Transform</a>&lt; <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt; &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1transform#a992087c44abac402a90e48218632d435">rotate</a> (const RotationType &amp;<a href="classeigen_1_1transform#ad73300a550f878bb7f34485c3d132746">rotation</a>)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">RotationReturnType </td>
<td valign="bottom">
<a href="classeigen_1_1transform#ad73300a550f878bb7f34485c3d132746">rotation</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename OtherDerived &gt; </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1transform">Transform</a>&lt; <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt; &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1transform#a8eea19fd9f6a6966a1a810acda22f93d">scale</a> (const <a href="classeigen_1_1matrixbase">MatrixBase</a>&lt; OtherDerived &gt; &amp;other)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1transform">Transform</a> &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1transform#a7757f5d9e708e625cbd936b19269b2c8">scale</a> (const <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> &amp;s)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">void </td>
<td valign="bottom">
<a href="classeigen_1_1transform#accf8eb8ac609d20cf099c62124c0505a">setIdentity</a> ()</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1transform">Transform</a> &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1transform#ae93a25d5e15af9446d7e5bc0e7a959d0">shear</a> (const <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> &amp;sx, const <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> &amp;sy)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">QMatrix </td>
<td valign="bottom">
<a href="classeigen_1_1transform#adaa35139dce9e7e8e144bbdecf97f63f">toQMatrix</a> (void) const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">QTransform </td>
<td valign="bottom">
<a href="classeigen_1_1transform#ae954e369a06472f44b72b199beb83cd2">toQTransform</a> (void) const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top"> </td>
<td valign="bottom">
<a href="classeigen_1_1transform#a19d71151dfbbe89db15961c93726dd70">Transform</a> ()</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename OtherDerived &gt; </td></tr> <tr>
<td align="right" valign="top"> </td>
<td valign="bottom">
<a href="classeigen_1_1transform#aec37de6bc74c0769dc4e47ba759bf9ec">Transform</a> (const <a href="structeigen_1_1eigenbase">EigenBase</a>&lt; OtherDerived &gt; &amp;other)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top"> </td>
<td valign="bottom">
<a href="classeigen_1_1transform#a83d61d4a1bd1c502c97ad67f87d55006">Transform</a> (const QMatrix &amp;other)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top"> </td>
<td valign="bottom">
<a href="classeigen_1_1transform#a63e9a5b9cf964921c24023dd680dee6d">Transform</a> (const QTransform &amp;other)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename OtherScalarType &gt; </td></tr> <tr>
<td align="right" valign="top"> </td>
<td valign="bottom">
<a href="classeigen_1_1transform#a2c3e732625ec300ef4e4cb1e17a82d35">Transform</a> (const <a href="classeigen_1_1transform">Transform</a>&lt; OtherScalarType, Dim, Mode, Options &gt; &amp;other)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename OtherDerived &gt; </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1transform">Transform</a>&lt; <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt; &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1transform#aa28c8ebe8367243653e8fb151670b24b">translate</a> (const <a href="classeigen_1_1matrixbase">MatrixBase</a>&lt; OtherDerived &gt; &amp;other)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1transform#aabeaa2d375bf1b6b1d5cb5d1904fbd06">TranslationPart</a> </td>
<td valign="bottom">
<a href="classeigen_1_1transform#aa3e4201cc8d1fd98136af66544148dc7">translation</a> ()</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1transform#a3eab3259d3fac8106eb3139bc96ba852">ConstTranslationPart</a> </td>
<td valign="bottom">
<a href="classeigen_1_1transform#adf4c6d97bd3f10edfa95bb04331ec8ed">translation</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> </table>
<table> <tr><td colspan="2"></td></tr> <tr>
<td align="right" valign="top">static const <a href="classeigen_1_1transform">Transform</a> </td>
<td valign="bottom">
<a href="classeigen_1_1transform#a5897c4cba8d6d19ea8711496fe75836f">Identity</a> ()</td>
</tr> <tr>
<td> </td>
<td>Returns an identity transformation. <a href="classeigen_1_1transform#a5897c4cba8d6d19ea8711496fe75836f">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> </table>  <a id="a8319bad977b0dabf2dfaf2e2dc30f13e"></a> <h2>AffinePart</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <table> <tr> <td>typedef internal::conditional&lt;int(Mode)==int(<a href="group__enums#ggaee59a86102f150923b0cac6d4ff05107a8192e8fdb2ec3ec46d92956cc83ef490">AffineCompact</a>), <a href="classeigen_1_1transform#a30f72ba46abc2bb3c7fa919c1078fc9c">MatrixType</a>&amp;, <a href="classeigen_1_1block">Block</a>&lt;<a href="classeigen_1_1transform#a30f72ba46abc2bb3c7fa919c1078fc9c">MatrixType</a>,Dim,HDim&gt; &gt;::type <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::<a href="classeigen_1_1transform#a8319bad977b0dabf2dfaf2e2dc30f13e">AffinePart</a>
</td> </tr> </table> </div>
<div> <p>type of read/write reference to the affine part of the transformation </p> </div> </div> <a id="adfa0bf2d9504548cdc9b9051b2fa9673"></a> <h2>ConstAffinePart</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <table> <tr> <td>typedef internal::conditional&lt;int(Mode)==int(<a href="group__enums#ggaee59a86102f150923b0cac6d4ff05107a8192e8fdb2ec3ec46d92956cc83ef490">AffineCompact</a>), const <a href="classeigen_1_1transform#a30f72ba46abc2bb3c7fa919c1078fc9c">MatrixType</a>&amp;, const <a href="classeigen_1_1block">Block</a>&lt;const <a href="classeigen_1_1transform#a30f72ba46abc2bb3c7fa919c1078fc9c">MatrixType</a>,Dim,HDim&gt; &gt;::type <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::<a href="classeigen_1_1transform#adfa0bf2d9504548cdc9b9051b2fa9673">ConstAffinePart</a>
</td> </tr> </table> </div>
<div> <p>type of read reference to the affine part of the transformation </p> </div> </div> <a id="a75810d3f0d098e00b43a5531f33d78e1"></a> <h2>ConstLinearPart</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <table> <tr> <td>typedef const <a href="classeigen_1_1block">Block</a>&lt;<a href="classeigen_1_1transform#aed436d14b16bd862bac5367990085795">ConstMatrixType</a>,Dim,Dim,int(Mode)==(<a href="group__enums#ggaee59a86102f150923b0cac6d4ff05107a8192e8fdb2ec3ec46d92956cc83ef490">AffineCompact</a>) &amp;&amp; (int(Options)&amp;<a href="group__enums#ggaacded1a18ae58b0f554751f6cdf9eb13a77c993a8d9f6efe5c1159fb2ab07dd4f">RowMajor</a>)==0&gt; <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::<a href="classeigen_1_1transform#a75810d3f0d098e00b43a5531f33d78e1">ConstLinearPart</a>
</td> </tr> </table> </div>
<div> <p>type of read reference to the linear part of the transformation </p> </div> </div> <a id="aed436d14b16bd862bac5367990085795"></a> <h2>ConstMatrixType</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <table> <tr> <td>typedef const <a href="classeigen_1_1transform#a30f72ba46abc2bb3c7fa919c1078fc9c">MatrixType</a> <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::<a href="classeigen_1_1transform#aed436d14b16bd862bac5367990085795">ConstMatrixType</a>
</td> </tr> </table> </div>
<div> <p>constified MatrixType </p> </div> </div> <a id="a3eab3259d3fac8106eb3139bc96ba852"></a> <h2>ConstTranslationPart</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <table> <tr> <td>typedef const <a href="classeigen_1_1block">Block</a>&lt;<a href="classeigen_1_1transform#aed436d14b16bd862bac5367990085795">ConstMatrixType</a>,Dim,1,!(internal::traits&lt;<a href="classeigen_1_1transform#a30f72ba46abc2bb3c7fa919c1078fc9c">MatrixType</a>&gt;::Flags &amp; <a href="group__flags#gae4f56c2a60bbe4bd2e44c5b19cbe8762">RowMajorBit</a>)&gt; <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::<a href="classeigen_1_1transform#a3eab3259d3fac8106eb3139bc96ba852">ConstTranslationPart</a>
</td> </tr> </table> </div>
<div> <p>type of a read reference to the translation part of the rotation </p> </div> </div> <a id="a49df3689ac2b736bcb564dec47d6486c"></a> <h2>Index</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <table> <tr> <td>typedef <a href="namespaceeigen#a62e77e0933482dafde8fe197d9a2cfde">Eigen::Index</a> <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::<a href="classeigen_1_1transform#a49df3689ac2b736bcb564dec47d6486c">Index</a>
</td> </tr> </table> </div>
<div> <dl>
<dt><b><a href="deprecated#_deprecated000031">Deprecated:</a></b></dt>
<dd>since <a href="namespaceeigen" title="Namespace containing all symbols from the Eigen library.">Eigen</a> 3.3 </dd>
</dl> </div> </div> <a id="a48138c0370e55371b95946c90d69e25c"></a> <h2>LinearMatrixType</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <table> <tr> <td>typedef <a href="classeigen_1_1matrix">Matrix</a>&lt;<a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>,Dim,Dim,Options&gt; <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::<a href="classeigen_1_1transform#a48138c0370e55371b95946c90d69e25c">LinearMatrixType</a>
</td> </tr> </table> </div>
<div> <p>type of the matrix used to represent the linear part of the transformation </p> </div> </div> <a id="a2195bd42561e691a8f6e7d989e77f328"></a> <h2>LinearPart</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <table> <tr> <td>typedef <a href="classeigen_1_1block">Block</a>&lt;<a href="classeigen_1_1transform#a30f72ba46abc2bb3c7fa919c1078fc9c">MatrixType</a>,Dim,Dim,int(Mode)==(<a href="group__enums#ggaee59a86102f150923b0cac6d4ff05107a8192e8fdb2ec3ec46d92956cc83ef490">AffineCompact</a>) &amp;&amp; (int(Options)&amp;<a href="group__enums#ggaacded1a18ae58b0f554751f6cdf9eb13a77c993a8d9f6efe5c1159fb2ab07dd4f">RowMajor</a>)==0&gt; <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::<a href="classeigen_1_1transform#a2195bd42561e691a8f6e7d989e77f328">LinearPart</a>
</td> </tr> </table> </div>
<div> <p>type of read/write reference to the linear part of the transformation </p> </div> </div> <a id="a30f72ba46abc2bb3c7fa919c1078fc9c"></a> <h2>MatrixType</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <table> <tr> <td>typedef internal::make_proper_matrix_type&lt;<a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>,Rows,HDim,Options&gt;::type <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::<a href="classeigen_1_1transform#a30f72ba46abc2bb3c7fa919c1078fc9c">MatrixType</a>
</td> </tr> </table> </div>
<div> <p>type of the matrix used to represent the transformation </p> </div> </div> <a id="a4e69ced9d651745b8ed4eda46f41795d"></a> <h2>Scalar</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <table> <tr> <td>typedef _Scalar <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::<a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>
</td> </tr> </table> </div>
<div> <p>the scalar type of the coefficients </p> </div> </div> <a id="a51af5e8d8d9d9bfec091ff8aa5b7845a"></a> <h2>TransformTimeDiagonalReturnType</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <table> <tr> <td>typedef <a href="classeigen_1_1transform">Transform</a>&lt;<a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>,Dim,TransformTimeDiagonalMode&gt; <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::<a href="classeigen_1_1transform#a51af5e8d8d9d9bfec091ff8aa5b7845a">TransformTimeDiagonalReturnType</a>
</td> </tr> </table> </div>
<div> <p>The return type of the product between a diagonal matrix and a transform </p> </div> </div> <a id="aabeaa2d375bf1b6b1d5cb5d1904fbd06"></a> <h2>TranslationPart</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <table> <tr> <td>typedef <a href="classeigen_1_1block">Block</a>&lt;<a href="classeigen_1_1transform#a30f72ba46abc2bb3c7fa919c1078fc9c">MatrixType</a>,Dim,1,!(internal::traits&lt;<a href="classeigen_1_1transform#a30f72ba46abc2bb3c7fa919c1078fc9c">MatrixType</a>&gt;::Flags &amp; <a href="group__flags#gae4f56c2a60bbe4bd2e44c5b19cbe8762">RowMajorBit</a>)&gt; <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::<a href="classeigen_1_1transform#aabeaa2d375bf1b6b1d5cb5d1904fbd06">TranslationPart</a>
</td> </tr> </table> </div>
<div> <p>type of a read/write reference to the translation part of the rotation </p> </div> </div> <a id="a6b463d14d8be4c0eda2eed6e943b831f"></a> <h2>TranslationType</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <table> <tr> <td>typedef <a href="classeigen_1_1translation">Translation</a>&lt;<a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>,Dim&gt; <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::<a href="classeigen_1_1transform#a6b463d14d8be4c0eda2eed6e943b831f">TranslationType</a>
</td> </tr> </table> </div>
<div> <p>corresponding translation type </p> </div> </div> <a id="aaeb4ae2f95c8edb0655fd84ab3f89e79"></a> <h2>VectorType</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <table> <tr> <td>typedef <a href="classeigen_1_1matrix">Matrix</a>&lt;<a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>,Dim,1&gt; <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::<a href="classeigen_1_1transform#aaeb4ae2f95c8edb0655fd84ab3f89e79">VectorType</a>
</td> </tr> </table> </div>
<div> <p>type of a vector </p> </div> </div>  <a id="a19d71151dfbbe89db15961c93726dd70"></a> <h2>Transform() <span>[1/5]</span>
</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::<a href="classeigen_1_1transform">Transform</a> </td> <td>(</td> <td></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Default constructor without initialization of the meaningful coefficients. If Mode==Affine or Mode==Isometry, then the last row is set to [0 ... 0 1] </p> </div> </div> <a id="aec37de6bc74c0769dc4e47ba759bf9ec"></a> <h2>Transform() <span>[2/5]</span>
</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <div> template&lt;typename OtherDerived &gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::<a href="classeigen_1_1transform">Transform</a> </td> <td>(</td> <td>const <a href="structeigen_1_1eigenbase">EigenBase</a>&lt; OtherDerived &gt; &amp; </td> <td><em>other</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span><span>explicit</span></span> </td> </tr> </table> </div>
<div> <p>Constructs and initializes a transformation from a Dim^2 or a (Dim+1)^2 matrix. </p> </div> </div> <a id="a83d61d4a1bd1c502c97ad67f87d55006"></a> <h2>Transform() <span>[3/5]</span>
</h2> <div> <div> <div> template&lt;typename Scalar , int Dim, int Mode, int Options&gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1transform">Eigen::Transform</a>&lt; <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt;::<a href="classeigen_1_1transform">Transform</a> </td> <td>(</td> <td>const QMatrix &amp; </td> <td><em>other</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Initializes <code>*this</code> from a QMatrix assuming the dimension is 2.</p> <p>This function is available only if the token EIGEN_QT_SUPPORT is defined. </p> </div> </div> <a id="a63e9a5b9cf964921c24023dd680dee6d"></a> <h2>Transform() <span>[4/5]</span>
</h2> <div> <div> <div> template&lt;typename Scalar , int Dim, int Mode, int Options&gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1transform">Eigen::Transform</a>&lt; <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt;::<a href="classeigen_1_1transform">Transform</a> </td> <td>(</td> <td>const QTransform&lt; _Scalar, _Dim, _Mode, _Options &gt; &amp; </td> <td><em>other</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Initializes <code>*this</code> from a QTransform assuming the dimension is 2.</p> <p>This function is available only if the token EIGEN_QT_SUPPORT is defined. </p> </div> </div> <a id="a2c3e732625ec300ef4e4cb1e17a82d35"></a> <h2>Transform() <span>[5/5]</span>
</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <div> template&lt;typename OtherScalarType &gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::<a href="classeigen_1_1transform">Transform</a> </td> <td>(</td> <td>const <a href="classeigen_1_1transform">Transform</a>&lt; OtherScalarType, Dim, Mode, Options &gt; &amp; </td> <td><em>other</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span><span>explicit</span></span> </td> </tr> </table> </div>
<div> <p>Copy constructor with scalar type conversion </p> </div> </div>  <a id="a9795374292c085bca4d123397d6b37d9"></a> <h2>affine() <span>[1/2]</span>
</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1transform#a8319bad977b0dabf2dfaf2e2dc30f13e">AffinePart</a> <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::affine </td> <td>(</td> <td></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>a writable expression of the Dim x HDim affine part of the transformation </dd>
</dl> </div> </div> <a id="a761a9c20fd5eefa58ca2f9babdf4c5d8"></a> <h2>affine() <span>[2/2]</span>
</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1transform#adfa0bf2d9504548cdc9b9051b2fa9673">ConstAffinePart</a> <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::affine </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>a read-only expression of the Dim x HDim affine part of the transformation </dd>
</dl> </div> </div> <a id="a86a66867b2a9ee0c9c4e920baf2bdacd"></a> <h2>cast()</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <div> template&lt;typename NewScalarType &gt; </div> <table> <tr> <td> <table> <tr> <td>internal::cast_return_type&lt;<a href="classeigen_1_1transform">Transform</a>,<a href="classeigen_1_1transform">Transform</a>&lt;NewScalarType,Dim,Mode,Options&gt; &gt;::type <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::cast </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>
<code>*this</code> with scalar type casted to <em>NewScalarType</em> </dd>
</dl> <p>Note that if <em>NewScalarType</em> is equal to the current scalar type of <code>*this</code> then this function smartly returns a const reference to <code>*this</code>. </p> </div> </div> <a id="a7213fd78501c1185c4a1441e33c812d3"></a> <h2>computeRotationScaling()</h2> <div> <div> <div> template&lt;typename Scalar , int Dim, int Mode, int Options&gt; </div> <div> template&lt;typename RotationMatrixType , typename ScalingMatrixType &gt; </div> <table> <tr> <td>void <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt;::computeRotationScaling </td> <td>(</td> <td>RotationMatrixType * </td> <td>
<em>rotation</em>, </td> </tr> <tr> <td></td> <td></td> <td>ScalingMatrixType * </td> <td>
<em>scaling</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td> const</td> </tr> </table> </div>
<div> <p>decomposes the linear part of the transformation as a product rotation x scaling, the scaling being not necessarily positive.</p> <p>If either pointer is zero, the corresponding computation is skipped.</p> <p>This is defined in the SVD module.</p>
<pre data-language="cpp"><span>#include &lt;Eigen/SVD&gt;</span> 
</pre>
<dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1transform#a247b079c63f46bb652b3776484838216">computeScalingRotation()</a>, <a href="classeigen_1_1transform#ad73300a550f878bb7f34485c3d132746">rotation()</a>, class SVD </dd>
</dl> </div> </div> <a id="a247b079c63f46bb652b3776484838216"></a> <h2>computeScalingRotation()</h2> <div> <div> <div> template&lt;typename Scalar , int Dim, int Mode, int Options&gt; </div> <div> template&lt;typename ScalingMatrixType , typename RotationMatrixType &gt; </div> <table> <tr> <td>void <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt;::computeScalingRotation </td> <td>(</td> <td>ScalingMatrixType * </td> <td>
<em>scaling</em>, </td> </tr> <tr> <td></td> <td></td> <td>RotationMatrixType * </td> <td>
<em>rotation</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td> const</td> </tr> </table> </div>
<div> <p>decomposes the linear part of the transformation as a product scaling x rotation, the scaling being not necessarily positive.</p> <p>If either pointer is zero, the corresponding computation is skipped.</p> <p>This is defined in the SVD module.</p>
<pre data-language="cpp"><span>#include &lt;Eigen/SVD&gt;</span> 
</pre>
<dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1transform#a7213fd78501c1185c4a1441e33c812d3">computeRotationScaling()</a>, <a href="classeigen_1_1transform#ad73300a550f878bb7f34485c3d132746">rotation()</a>, class SVD </dd>
</dl> </div> </div> <a id="aefd183e4e0ca89c39b78d5ad7cf3e014"></a> <h2>data() <span>[1/2]</span>
</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>* <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::data </td> <td>(</td> <td></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>a non-const pointer to the column major internal matrix </dd>
</dl> </div> </div> <a id="a432669c64a0d6925ee5ea54f76d24a32"></a> <h2>data() <span>[2/2]</span>
</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>* <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::data </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>a const pointer to the column major internal matrix </dd>
</dl> </div> </div> <a id="a30c94c2156e9345f4bdb6cc9661e275b"></a> <h2>EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF_VECTORIZABLE_FIXED_SIZE()</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF_VECTORIZABLE_FIXED_SIZE </td> <td>(</td> <td>_Scalar </td> <td>, </td> </tr> <tr> <td></td> <td></td> <td>_Dim </td> <td> = <code>=<a href="namespaceeigen#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a>?<a href="namespaceeigen#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a>:(_Dim+1)*(_Dim+1)</code> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>&lt; space dimension in which the transformation holds</p> <p>&lt; size of a respective homogeneous vector</p> </div> </div> <a id="afac1e7bd782e5cc92cbf70128809d5d1"></a> <h2>fromPositionOrientationScale()</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <div> template&lt;typename PositionDerived , typename OrientationType , typename ScaleDerived &gt; </div> <table> <tr> <td>
<a href="classeigen_1_1transform">Transform</a>&lt;<a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>,Dim,Mode,Options&gt;&amp; <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::fromPositionOrientationScale </td> <td>(</td> <td>const <a href="classeigen_1_1matrixbase">MatrixBase</a>&lt; PositionDerived &gt; &amp; </td> <td>
<em>position</em>, </td> </tr> <tr> <td></td> <td></td> <td>const OrientationType &amp; </td> <td>
<em>orientation</em>, </td> </tr> <tr> <td></td> <td></td> <td>const <a href="classeigen_1_1matrixbase">MatrixBase</a>&lt; ScaleDerived &gt; &amp; </td> <td>
<em>scale</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </div>
<div> <p>Convenient method to set <code>*this</code> from a position, orientation and scale of a 3D object. </p> </div> </div> <a id="a5897c4cba8d6d19ea8711496fe75836f"></a> <h2>Identity()</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <table> <tr> <td> <table> <tr> <td>static const <a href="classeigen_1_1transform">Transform</a> <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::Identity </td> <td>(</td> <td></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span><span>static</span></span> </td> </tr> </table> </div>
<div> <p>Returns an identity transformation. </p> </div> </div> <a id="ab8dbcd157bf194efca1a5413c0945211"></a> <h2>inverse()</h2> <div> <div> <div> template&lt;typename Scalar , int Dim, int Mode, int Options&gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1transform">Transform</a>&lt; <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt; <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt;::inverse </td> <td>(</td> <td>
<a href="group__enums#gaee59a86102f150923b0cac6d4ff05107">TransformTraits</a> </td> <td>
<em>hint</em> = <code>(<a href="group__enums#gaee59a86102f150923b0cac6d4ff05107">TransformTraits</a>)Mode</code>
</td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>the inverse transformation according to some given knowledge on <code>*this</code>.</dd>
</dl> <dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>hint</td>
<td>allows to optimize the inversion process when the transformation is known to be not a general transformation (optional). The possible values are:<ul> <li>
<a href="group__enums#ggaee59a86102f150923b0cac6d4ff05107a0f7338b8672884554e8642bce9e44183">Projective</a> if the transformation is not necessarily affine, i.e., if the last row is not guaranteed to be [0 ... 0 1]</li> <li>
<a href="group__enums#ggaee59a86102f150923b0cac6d4ff05107a0872f0a82453aaae40339c33acbb31fb">Affine</a> if the last row can be assumed to be [0 ... 0 1]</li> <li>
<a href="group__enums#ggaee59a86102f150923b0cac6d4ff05107a84413028615d2d718bafd2dfb93dafef">Isometry</a> if the transformation is only a concatenations of translations and rotations. The default is the template class parameter <code>Mode</code>.</li> </ul> </td>
</tr> </table> </dd> </dl> <dl>
<dt>Warning</dt>
<dd>unless <em>traits</em> is always set to NoShear or NoScaling, this function requires the generic inverse method of <a href="classeigen_1_1matrixbase" title="Base class for all dense matrices, vectors, and expressions.">MatrixBase</a> defined in the LU module. If you forget to include this module, then you will get hard to debug linking errors.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1matrixbase#a7712eb69e8ea3c8f7b8da1c44dbdeebf">MatrixBase::inverse()</a> </dd>
</dl> </div> </div> <a id="abd1696d9bb754e5c8734e691e03243f9"></a> <h2>isApprox()</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <table> <tr> <td> <table> <tr> <td>bool <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::isApprox </td> <td>(</td> <td>const <a href="classeigen_1_1transform">Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt; &amp; </td> <td>
<em>other</em>, </td> </tr> <tr> <td></td> <td></td> <td>const typename <a href="structeigen_1_1numtraits">NumTraits</a>&lt; <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> &gt;::Real &amp; </td> <td>
<em>prec</em> = <code><a href="structeigen_1_1numtraits">NumTraits</a>&lt;<a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>&gt;::dummy_precision()</code> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>
<code>true</code> if <code>*this</code> is approximately equal to <em>other</em>, within the precision determined by <em>prec</em>.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1densebase#ae8443357b808cd393be1b51974213f9c">MatrixBase::isApprox()</a> </dd>
</dl> </div> </div> <a id="ad36538ee2c2970722eff343ee1bbfc7c"></a> <h2>linear() <span>[1/2]</span>
</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1transform#a2195bd42561e691a8f6e7d989e77f328">LinearPart</a> <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::linear </td> <td>(</td> <td></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>a writable expression of the linear part of the transformation </dd>
</dl> </div> </div> <a id="af8c38249632146453785add778dc1081"></a> <h2>linear() <span>[2/2]</span>
</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1transform#a75810d3f0d098e00b43a5531f33d78e1">ConstLinearPart</a> <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::linear </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>a read-only expression of the linear part of the transformation </dd>
</dl> </div> </div> <a id="abef09a0e86261aeba4e10227fa3fa26b"></a> <h2>makeAffine()</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <table> <tr> <td> <table> <tr> <td>void <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::makeAffine </td> <td>(</td> <td></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Sets the last row to [0 ... 0 1] </p> </div> </div> <a id="a758fbaf6aa41a5493659aa0c9bfe0dcf"></a> <h2>matrix() <span>[1/2]</span>
</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1transform#a30f72ba46abc2bb3c7fa919c1078fc9c">MatrixType</a>&amp; <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::matrix </td> <td>(</td> <td></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>a writable expression of the transformation matrix </dd>
</dl> </div> </div> <a id="a0ac079dc1995058cbbded553b8d4485c"></a> <h2>matrix() <span>[2/2]</span>
</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="classeigen_1_1transform#a30f72ba46abc2bb3c7fa919c1078fc9c">MatrixType</a>&amp; <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::matrix </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>a read-only expression of the transformation matrix </dd>
</dl> </div> </div> <a id="a09fce82b9bdedb5deb2b223a3d716d3f"></a> <h2>operator()() <span>[1/2]</span>
</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>&amp; <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::operator() </td> <td>(</td> <td>
<a href="classeigen_1_1transform#a49df3689ac2b736bcb564dec47d6486c">Index</a> </td> <td>
<em>row</em>, </td> </tr> <tr> <td></td> <td></td> <td>
<a href="classeigen_1_1transform#a49df3689ac2b736bcb564dec47d6486c">Index</a> </td> <td>
<em>col</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>shortcut for m_matrix(row,col); </p>
<dl>
<dt>See also</dt>
<dd>MatrixBase::operator(Index,Index) </dd>
</dl> </div> </div> <a id="a9672c84cb1477eee118be144e7e5d581"></a> <h2>operator()() <span>[2/2]</span>
</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::operator() </td> <td>(</td> <td>
<a href="classeigen_1_1transform#a49df3689ac2b736bcb564dec47d6486c">Index</a> </td> <td>
<em>row</em>, </td> </tr> <tr> <td></td> <td></td> <td>
<a href="classeigen_1_1transform#a49df3689ac2b736bcb564dec47d6486c">Index</a> </td> <td>
<em>col</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>shortcut for m_matrix(row,col); </p>
<dl>
<dt>See also</dt>
<dd>MatrixBase::operator(Index,Index) const </dd>
</dl> </div> </div> <a id="ab3d93a2aba9d06e7d134798f92617da7"></a> <h2>operator*() <span>[1/4]</span>
</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <div> template&lt;typename DiagonalDerived &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="classeigen_1_1transform#a51af5e8d8d9d9bfec091ff8aa5b7845a">TransformTimeDiagonalReturnType</a> <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::operator* </td> <td>(</td> <td>const DiagonalBase&lt; DiagonalDerived &gt; &amp; </td> <td><em>b</em></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>The product expression of a transform <em>a</em> times a diagonal matrix <em>b</em> </dd>
</dl> <p>The rhs diagonal matrix is interpreted as an affine scaling transformation. The product results in a <a href="classeigen_1_1transform" title="Represents an homogeneous transformation in a N dimensional space.">Transform</a> of the same type (mode) as the lhs only if the lhs mode is no isometry. In that case, the returned transform is an affinity. </p> </div> </div> <a id="a257ab8b9141982bd6f56771ba822526f"></a> <h2>operator*() <span>[2/4]</span>
</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <div> template&lt;typename OtherDerived &gt; </div> <table> <tr> <td> <table> <tr> <td>const internal::transform_right_product_impl&lt;<a href="classeigen_1_1transform">Transform</a>, OtherDerived&gt;::ResultType <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::operator* </td> <td>(</td> <td>const <a href="structeigen_1_1eigenbase">EigenBase</a>&lt; OtherDerived &gt; &amp; </td> <td><em>other</em></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>an expression of the product between the transform <code>*this</code> and a matrix expression <em>other</em>.</dd>
</dl> <p>The right-hand-side <em>other</em> can be either: </p>
<ul> <li>an homogeneous vector of size Dim+1, </li> <li>a set of homogeneous vectors of size Dim+1 x N, </li> <li>a transformation matrix of size Dim+1 x Dim+1.</li> </ul> <p>Moreover, if <code>*this</code> represents an affine transformation (i.e., Mode!=Projective), then <em>other</em> can also be: </p>
<ul> <li>a point of size Dim (computes:<pre data-language="cpp">this-&gt;<a href="classeigen_1_1transform#af8c38249632146453785add778dc1081">linear</a>() * other + this-&gt;<a href="classeigen_1_1transform#adf4c6d97bd3f10edfa95bb04331ec8ed">translation</a>()</pre>), </li> <li>a set of N points as a Dim x N matrix (computes:<pre data-language="cpp">(this-&gt;<a href="classeigen_1_1transform#af8c38249632146453785add778dc1081">linear</a>() * other).colwise() + this-&gt;<a href="classeigen_1_1transform#adf4c6d97bd3f10edfa95bb04331ec8ed">translation</a>()
</pre>),</li> </ul> <p>In all cases, the return type is a matrix or vector of same sizes as the right-hand-side <em>other</em>.</p> <p>If you want to interpret <em>other</em> as a linear or affine transformation, then first convert it to a Transform&lt;&gt; type, or do your own cooking.</p> <p>Finally, if you want to apply Affine transformations to vectors, then explicitly apply the linear part only: </p>
<pre data-language="cpp">Affine3f A;
Vector3f v1, v2;
v2 = A.linear() * v1;
</pre> </div> </div> <a id="a7e75d983600d35b603f740a3a28bbc6c"></a> <h2>operator*() <span>[3/4]</span>
</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="classeigen_1_1transform">Transform</a> <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::operator* </td> <td>(</td> <td>const <a href="classeigen_1_1transform">Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt; &amp; </td> <td><em>other</em></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Concatenates two transformations </p> </div> </div> <a id="ad4fc26aef2abfb9fdadb7d64aaf58c31"></a> <h2>operator*() <span>[4/4]</span>
</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <div> template&lt;int OtherMode, int OtherOptions&gt; </div> <table> <tr> <td> <table> <tr> <td>internal::transform_transform_product_impl&lt;<a href="classeigen_1_1transform">Transform</a>,<a href="classeigen_1_1transform">Transform</a>&lt;<a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>,Dim,OtherMode,OtherOptions&gt; &gt;::ResultType <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::operator* </td> <td>(</td> <td>const <a href="classeigen_1_1transform">Transform</a>&lt; <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, OtherMode, OtherOptions &gt; &amp; </td> <td><em>other</em></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Concatenates two different transformations </p> </div> </div> <a id="a826047489741a19b81c6552f8257b1cf"></a> <h2>operator=() <span>[1/3]</span>
</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <div> template&lt;typename OtherDerived &gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1transform">Transform</a>&amp; <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::operator= </td> <td>(</td> <td>const <a href="structeigen_1_1eigenbase">EigenBase</a>&lt; OtherDerived &gt; &amp; </td> <td><em>other</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Set <code>*this</code> from a Dim^2 or (Dim+1)^2 matrix. </p> </div> </div> <a id="a8ed8318285ccc7498197da7df1273bd5"></a> <h2>operator=() <span>[2/3]</span>
</h2> <div> <div> <div> template&lt;typename Scalar , int Dim, int Mode, int Options&gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1transform">Transform</a>&lt; <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt; &amp; <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt;::operator= </td> <td>(</td> <td>const QMatrix &amp; </td> <td><em>other</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Set <code>*this</code> from a QMatrix assuming the dimension is 2.</p> <p>This function is available only if the token EIGEN_QT_SUPPORT is defined. </p> </div> </div> <a id="a54986164dcb1d0f7bfa216b8ef5272f6"></a> <h2>operator=() <span>[3/3]</span>
</h2> <div> <div> <div> template&lt;typename Scalar , int Dim, int Mode, int Options&gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1transform">Transform</a>&lt; <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt; &amp; <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt;::operator= </td> <td>(</td> <td>const QTransform&lt; _Scalar, _Dim, _Mode, _Options &gt; &amp; </td> <td><em>other</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Set <code>*this</code> from a QTransform assuming the dimension is 2.</p> <p>This function is available only if the token EIGEN_QT_SUPPORT is defined. </p> </div> </div> <a id="ac5d65c2387e8d8b8f1526fc2c8443661"></a> <h2>prerotate()</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <div> template&lt;typename RotationType &gt; </div> <table> <tr> <td>
<a href="classeigen_1_1transform">Transform</a>&lt;<a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>,Dim,Mode,Options&gt;&amp; <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::prerotate </td> <td>(</td> <td>const RotationType &amp; </td> <td><em>rotation</em></td>
<td>)</td> <td></td> </tr> </table> </div>
<div> <p>Applies on the left the rotation represented by the rotation <em>rotation</em> to <code>*this</code> and returns a reference to <code>*this</code>.</p> <p>See rotate() for further details.</p> <dl>
<dt>See also</dt>
<dd>rotate() </dd>
</dl> </div> </div> <a id="a0d87009c9449d1920c037eb58468e757"></a> <h2>prescale() <span>[1/2]</span>
</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <div> template&lt;typename OtherDerived &gt; </div> <table> <tr> <td>
<a href="classeigen_1_1transform">Transform</a>&lt;<a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>,Dim,Mode,Options&gt;&amp; <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::prescale </td> <td>(</td> <td>const <a href="classeigen_1_1matrixbase">MatrixBase</a>&lt; OtherDerived &gt; &amp; </td> <td><em>other</em></td>
<td>)</td> <td></td> </tr> </table> </div>
<div> <p>Applies on the left the non uniform scale transformation represented by the vector <em>other</em> to <code>*this</code> and returns a reference to <code>*this</code>. </p>
<dl>
<dt>See also</dt>
<dd>scale() </dd>
</dl> </div> </div> <a id="a96c5e49e1d779299f4975dfef93e14b3"></a> <h2>prescale() <span>[2/2]</span>
</h2> <div> <div> <div> template&lt;typename Scalar , int Dim, int Mode, int Options&gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1transform">Transform</a>&lt; <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt; &amp; <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt;::prescale </td> <td>(</td> <td>const <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> &amp; </td> <td><em>s</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Applies on the left a uniform scale of a factor <em>c</em> to <code>*this</code> and returns a reference to <code>*this</code>. </p>
<dl>
<dt>See also</dt>
<dd>scale(Scalar) </dd>
</dl> </div> </div> <a id="a17c40209cfd2d094cf654504aca95bf1"></a> <h2>preshear()</h2> <div> <div> <div> template&lt;typename Scalar , int Dim, int Mode, int Options&gt; </div> <table> <tr> <td>
<a href="classeigen_1_1transform">Transform</a>&lt; <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt; &amp; <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt;::preshear </td> <td>(</td> <td>const <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> &amp; </td> <td>
<em>sx</em>, </td> </tr> <tr> <td></td> <td></td> <td>const <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> &amp; </td> <td>
<em>sy</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </div>
<div> <p>Applies on the left the shear transformation represented by the vector <em>other</em> to <code>*this</code> and returns a reference to <code>*this</code>. </p>
<dl>
<dt>Warning</dt>
<dd>2D only. </dd>
</dl> <dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1transform#ae93a25d5e15af9446d7e5bc0e7a959d0">shear()</a> </dd>
</dl> </div> </div> <a id="ae9be55c2f6f4d56b0878c983c0ff9cc6"></a> <h2>pretranslate()</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <div> template&lt;typename OtherDerived &gt; </div> <table> <tr> <td>
<a href="classeigen_1_1transform">Transform</a>&lt;<a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>,Dim,Mode,Options&gt;&amp; <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::pretranslate </td> <td>(</td> <td>const <a href="classeigen_1_1matrixbase">MatrixBase</a>&lt; OtherDerived &gt; &amp; </td> <td><em>other</em></td>
<td>)</td> <td></td> </tr> </table> </div>
<div> <p>Applies on the left the translation matrix represented by the vector <em>other</em> to <code>*this</code> and returns a reference to <code>*this</code>. </p>
<dl>
<dt>See also</dt>
<dd>translate() </dd>
</dl> </div> </div> <a id="a992087c44abac402a90e48218632d435"></a> <h2>rotate()</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <div> template&lt;typename RotationType &gt; </div> <table> <tr> <td>
<a href="classeigen_1_1transform">Transform</a>&lt;<a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>,Dim,Mode,Options&gt;&amp; <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::rotate </td> <td>(</td> <td>const RotationType &amp; </td> <td><em>rotation</em></td>
<td>)</td> <td></td> </tr> </table> </div>
<div> <p>Applies on the right the rotation represented by the rotation <em>rotation</em> to <code>*this</code> and returns a reference to <code>*this</code>.</p> <p>The template parameter <em>RotationType</em> is the type of the rotation which must be known by internal::toRotationMatrix&lt;&gt;.</p> <p>Natively supported types includes:</p>
<ul> <li>any scalar (2D),</li> <li>a Dim x Dim matrix expression,</li> <li>a <a href="classeigen_1_1quaternion" title="The quaternion class used to represent 3D orientations and rotations.">Quaternion</a> (3D),</li> <li>a <a href="classeigen_1_1angleaxis" title="Represents a 3D rotation as a rotation angle around an arbitrary 3D axis.">AngleAxis</a> (3D)</li> </ul> <p>This mechanism is easily extendable to support user types such as Euler angles, or a pair of <a href="classeigen_1_1quaternion" title="The quaternion class used to represent 3D orientations and rotations.">Quaternion</a> for 4D rotations.</p> <dl>
<dt>See also</dt>
<dd>rotate(Scalar), class <a href="classeigen_1_1quaternion" title="The quaternion class used to represent 3D orientations and rotations.">Quaternion</a>, class <a href="classeigen_1_1angleaxis" title="Represents a 3D rotation as a rotation angle around an arbitrary 3D axis.">AngleAxis</a>, prerotate(RotationType) </dd>
</dl> </div> </div> <a id="ad73300a550f878bb7f34485c3d132746"></a> <h2>rotation()</h2> <div> <div> <div> template&lt;typename Scalar , int Dim, int Mode, int Options&gt; </div> <table> <tr> <td>
<a href="classeigen_1_1transform">Transform</a>&lt; <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt;::RotationReturnType <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt;::rotation</td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>the rotation part of the transformation</dd>
</dl> <p>If Mode==Isometry, then this method is an alias for <a href="classeigen_1_1transform#ad36538ee2c2970722eff343ee1bbfc7c">linear()</a>, otherwise it calls <a href="classeigen_1_1transform#a7213fd78501c1185c4a1441e33c812d3">computeRotationScaling()</a> to extract the rotation through a SVD decomposition.</p> <p>This is defined in the SVD module.</p>
<pre data-language="cpp"><span>#include &lt;Eigen/SVD&gt;</span> 
</pre>
<dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1transform#a7213fd78501c1185c4a1441e33c812d3">computeRotationScaling()</a>, <a href="classeigen_1_1transform#a247b079c63f46bb652b3776484838216">computeScalingRotation()</a>, class SVD </dd>
</dl> </div> </div> <a id="a8eea19fd9f6a6966a1a810acda22f93d"></a> <h2>scale() <span>[1/2]</span>
</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <div> template&lt;typename OtherDerived &gt; </div> <table> <tr> <td>
<a href="classeigen_1_1transform">Transform</a>&lt;<a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>,Dim,Mode,Options&gt;&amp; <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::scale </td> <td>(</td> <td>const <a href="classeigen_1_1matrixbase">MatrixBase</a>&lt; OtherDerived &gt; &amp; </td> <td><em>other</em></td>
<td>)</td> <td></td> </tr> </table> </div>
<div> <p>Applies on the right the non uniform scale transformation represented by the vector <em>other</em> to <code>*this</code> and returns a reference to <code>*this</code>. </p>
<dl>
<dt>See also</dt>
<dd>prescale() </dd>
</dl> </div> </div> <a id="a7757f5d9e708e625cbd936b19269b2c8"></a> <h2>scale() <span>[2/2]</span>
</h2> <div> <div> <div> template&lt;typename Scalar , int Dim, int Mode, int Options&gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1transform">Transform</a>&lt; <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt; &amp; <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt;::scale </td> <td>(</td> <td>const <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> &amp; </td> <td><em>s</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Applies on the right a uniform scale of a factor <em>c</em> to <code>*this</code> and returns a reference to <code>*this</code>. </p>
<dl>
<dt>See also</dt>
<dd>prescale(Scalar) </dd>
</dl> </div> </div> <a id="accf8eb8ac609d20cf099c62124c0505a"></a> <h2>setIdentity()</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <table> <tr> <td> <table> <tr> <td>void <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::setIdentity </td> <td>(</td> <td></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1matrixbase#a18e969adfdf2db4ac44c47fbdc854683">MatrixBase::setIdentity()</a> </dd>
</dl> </div> </div> <a id="ae93a25d5e15af9446d7e5bc0e7a959d0"></a> <h2>shear()</h2> <div> <div> <div> template&lt;typename Scalar , int Dim, int Mode, int Options&gt; </div> <table> <tr> <td>
<a href="classeigen_1_1transform">Transform</a>&lt; <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt; &amp; <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt;::shear </td> <td>(</td> <td>const <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> &amp; </td> <td>
<em>sx</em>, </td> </tr> <tr> <td></td> <td></td> <td>const <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a> &amp; </td> <td>
<em>sy</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </div>
<div> <p>Applies on the right the shear transformation represented by the vector <em>other</em> to <code>*this</code> and returns a reference to <code>*this</code>. </p>
<dl>
<dt>Warning</dt>
<dd>2D only. </dd>
</dl> <dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1transform#a17c40209cfd2d094cf654504aca95bf1">preshear()</a> </dd>
</dl> </div> </div> <a id="adaa35139dce9e7e8e144bbdecf97f63f"></a> <h2>toQMatrix()</h2> <div> <div> <div> template&lt;typename Scalar , int Dim, int Mode, int Options&gt; </div> <table> <tr> <td> <table> <tr> <td>QMatrix <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt;::toQMatrix </td> <td>(</td> <td>void </td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>a QMatrix from <code>*this</code> assuming the dimension is 2.</dd>
</dl> <dl>
<dt>Warning</dt>
<dd>this conversion might loss data if <code>*this</code> is not affine</dd>
</dl> <p>This function is available only if the token EIGEN_QT_SUPPORT is defined. </p> </div> </div> <a id="ae954e369a06472f44b72b199beb83cd2"></a> <h2>toQTransform()</h2> <div> <div> <div> template&lt;typename Scalar , int Dim, int Mode, int Options&gt; </div> <table> <tr> <td> <table> <tr> <td>QTransform <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; <a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>, Dim, Mode, Options &gt;::toQTransform </td> <td>(</td> <td>void </td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>a QTransform from <code>*this</code> assuming the dimension is 2.</dd>
</dl> <p>This function is available only if the token EIGEN_QT_SUPPORT is defined. </p> </div> </div> <a id="aa28c8ebe8367243653e8fb151670b24b"></a> <h2>translate()</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <div> template&lt;typename OtherDerived &gt; </div> <table> <tr> <td>
<a href="classeigen_1_1transform">Transform</a>&lt;<a href="classeigen_1_1transform#a4e69ced9d651745b8ed4eda46f41795d">Scalar</a>,Dim,Mode,Options&gt;&amp; <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::translate </td> <td>(</td> <td>const <a href="classeigen_1_1matrixbase">MatrixBase</a>&lt; OtherDerived &gt; &amp; </td> <td><em>other</em></td>
<td>)</td> <td></td> </tr> </table> </div>
<div> <p>Applies on the right the translation matrix represented by the vector <em>other</em> to <code>*this</code> and returns a reference to <code>*this</code>. </p>
<dl>
<dt>See also</dt>
<dd>pretranslate() </dd>
</dl> </div> </div> <a id="aa3e4201cc8d1fd98136af66544148dc7"></a> <h2>translation() <span>[1/2]</span>
</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1transform#aabeaa2d375bf1b6b1d5cb5d1904fbd06">TranslationPart</a> <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::translation </td> <td>(</td> <td></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>a writable expression of the translation vector of the transformation </dd>
</dl> </div> </div> <a id="adf4c6d97bd3f10edfa95bb04331ec8ed"></a> <h2>translation() <span>[2/2]</span>
</h2> <div> <div> <div> template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1transform#a3eab3259d3fac8106eb3139bc96ba852">ConstTranslationPart</a> <a href="classeigen_1_1transform">Eigen::Transform</a>&lt; _Scalar, _Dim, _Mode, _Options &gt;::translation </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>a read-only expression of the translation vector of the transformation </dd>
</dl> </div> </div> <hr>The documentation for this class was generated from the following file:<ul> <li><a href="https://eigen.tuxfamily.org/dox/Transform_8h_source.html">Transform.h</a></li> </ul> </div> <div class="_attribution">
  <p class="_attribution-p">
     Eigen.<br>Licensed under the MPL2 License.<br>
    <a href="https://eigen.tuxfamily.org/dox/classEigen_1_1Transform.html" class="_attribution-link">https://eigen.tuxfamily.org/dox/classEigen_1_1Transform.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
