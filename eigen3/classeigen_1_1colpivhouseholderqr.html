
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Eigen&#58;&#58;ColPivHouseholderQR - Eigen3 - W3cubDocs</title>
  
  <meta name="description" content=" Householder rank-revealing QR decomposition of a matrix with column-pivoting. ">
  <meta name="keywords" content="eigen, colpivhouseholderqr, eigen3">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/eigen3/classeigen_1_1colpivhouseholderqr.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-f16eecbe420d8b2925d31ffbb21d05646497ecbd9515f08ffe69e9bba7332f5657accc7003c7f6c72cb4a132171acf171b359ae3bae4ae5660ddfb1718f88c67.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/eigen3.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/eigen3/" class="_nav-link" title="" style="margin-left:0;">Eigen3</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _eigen3">
				
				
<h1>Eigen::ColPivHouseholderQR</h1>      <div>  <div>
<h3>template&lt;typename _MatrixType&gt;<br> class Eigen::ColPivHouseholderQR&lt; _MatrixType &gt;</h3> <p>Householder rank-revealing QR decomposition of a matrix with column-pivoting. </p> <dl>
<dt>Template Parameters</dt>
<dd> <table> <tr>
<td>_MatrixType</td>
<td>the type of the matrix of which we are computing the QR decomposition</td>
</tr> </table> </dd> </dl> <p>This class performs a rank-revealing QR decomposition of a matrix <b>A</b> into matrices <b>P</b>, <b>Q</b> and <b>R</b> such that </p>
<p> \[ \mathbf{A} \, \mathbf{P} = \mathbf{Q} \, \mathbf{R} \] </p> <p> by using Householder transformations. Here, <b>P</b> is a permutation matrix, <b>Q</b> a unitary matrix and <b>R</b> an upper triangular matrix.</p> <p>This decomposition performs column pivoting in order to be rank-revealing and improve numerical stability. It is slower than <a href="classeigen_1_1householderqr" title="Householder QR decomposition of a matrix.">HouseholderQR</a>, and faster than <a href="classeigen_1_1fullpivhouseholderqr" title="Householder rank-revealing QR decomposition of a matrix with full pivoting.">FullPivHouseholderQR</a>.</p> <p>This class supports the <a href="group__inplacedecomposition">inplace decomposition </a> mechanism.</p> <dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1matrixbase#adee8c19c833245bbb00a591dce68e8a4">MatrixBase::colPivHouseholderQr()</a> </dd>
</dl> </div> <div id="dynsection-0-summary" style="display:block;"> </div> <div id="dynsection-0-content" style="display:none;"> <div><img src="data:image/png;base64,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" border="0" usemap="#aEigen_1_1ColPivHouseholderQR_3_01__MatrixType_01_4_inherit__map" alt="Inheritance graph"></div> <map name="aEigen_1_1ColPivHouseholderQR_3_01__MatrixType_01_4_inherit__map" id="aEigen_1_1ColPivHouseholderQR_3_01__MatrixType_01_4_inherit__map"> <area shape="rect" title="Householder rank-revealing QR decomposition of a matrix with column-pivoting." alt="" coords="5,549,211,993"> <area shape="rect" href="classEigen_1_1SolverBase.html" title=" " alt="" coords="17,292,199,501"> <area shape="rect" href="structEigen_1_1EigenBase.html" title=" " alt="" coords="11,5,205,244"> </map> </div> <table> <tr><td colspan="2"></td></tr> <tr>
<td align="right" valign="top">MatrixType::RealScalar </td>
<td valign="bottom">
<a href="classeigen_1_1colpivhouseholderqr#ac87c3bf42098d6f7324dafbc50fa83f7">absDeterminant</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top"> </td>
<td valign="bottom">
<a href="classeigen_1_1colpivhouseholderqr#a9d8a92c2a2f0debe5454812372237ed4">ColPivHouseholderQR</a> ()</td>
</tr> <tr>
<td> </td>
<td>Default Constructor. <a href="classeigen_1_1colpivhouseholderqr#a9d8a92c2a2f0debe5454812372237ed4">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename InputType &gt; </td></tr> <tr>
<td align="right" valign="top"> </td>
<td valign="bottom">
<a href="classeigen_1_1colpivhouseholderqr#a1aa6a5b95380df0ceb224cb833316d4f">ColPivHouseholderQR</a> (const <a href="structeigen_1_1eigenbase">EigenBase</a>&lt; InputType &gt; &amp;matrix)</td>
</tr> <tr>
<td> </td>
<td>Constructs a QR factorization from a given matrix. <a href="classeigen_1_1colpivhouseholderqr#a1aa6a5b95380df0ceb224cb833316d4f">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename InputType &gt; </td></tr> <tr>
<td align="right" valign="top"> </td>
<td valign="bottom">
<a href="classeigen_1_1colpivhouseholderqr#a65782010a93a4c9ef4a9191ac8fe30bc">ColPivHouseholderQR</a> (<a href="structeigen_1_1eigenbase">EigenBase</a>&lt; InputType &gt; &amp;matrix)</td>
</tr> <tr>
<td> </td>
<td>Constructs a QR factorization from a given matrix. <a href="classeigen_1_1colpivhouseholderqr#a65782010a93a4c9ef4a9191ac8fe30bc">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top"> </td>
<td valign="bottom">
<a href="classeigen_1_1colpivhouseholderqr#a5965d4fdebc04b2df71d67ff0b2d0c2c">ColPivHouseholderQR</a> (<a href="structeigen_1_1eigenbase#a554f30542cc2316add4b1ea0a492ff02">Index</a> rows, <a href="structeigen_1_1eigenbase#a554f30542cc2316add4b1ea0a492ff02">Index</a> cols)</td>
</tr> <tr>
<td> </td>
<td>Default Constructor with memory preallocation. <a href="classeigen_1_1colpivhouseholderqr#a5965d4fdebc04b2df71d67ff0b2d0c2c">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const <a href="classeigen_1_1permutationmatrix">PermutationType</a> &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1colpivhouseholderqr#ab6ad43e6a6fb75726eae0d5499948f4a">colsPermutation</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename InputType &gt; </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1colpivhouseholderqr">ColPivHouseholderQR</a>&lt; MatrixType &gt; &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1colpivhouseholderqr#a608016776319abe8fe96b85f83c8dd3d">compute</a> (const <a href="structeigen_1_1eigenbase">EigenBase</a>&lt; InputType &gt; &amp;matrix)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="structeigen_1_1eigenbase#a554f30542cc2316add4b1ea0a492ff02">Index</a> </td>
<td valign="bottom">
<a href="classeigen_1_1colpivhouseholderqr#a7c9294565d179226133770160b827be1">dimensionOfKernel</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const HCoeffsType &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1colpivhouseholderqr#ac5943d19aa5fd96340c7df6874fcb1b9">hCoeffs</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1householdersequence">HouseholderSequenceType</a> </td>
<td valign="bottom">
<a href="classeigen_1_1colpivhouseholderqr#a28ab9d8916ca609c5469c4c192fbfa28">householderQ</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="group__enums#ga85fad7b87587764e5cf6b513a9e0ee5e">ComputationInfo</a> </td>
<td valign="bottom">
<a href="classeigen_1_1colpivhouseholderqr#a5c756a789175197cab3eff3a3e479ef2">info</a> () const</td>
</tr> <tr>
<td> </td>
<td>Reports whether the QR factorization was successful. <a href="classeigen_1_1colpivhouseholderqr#a5c756a789175197cab3eff3a3e479ef2">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const <a href="classeigen_1_1inverse">Inverse</a>&lt; <a href="classeigen_1_1colpivhouseholderqr">ColPivHouseholderQR</a> &gt; </td>
<td valign="bottom">
<a href="classeigen_1_1colpivhouseholderqr#a31c45402e74774d9cd13af0e57a6b72f">inverse</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">bool </td>
<td valign="bottom">
<a href="classeigen_1_1colpivhouseholderqr#a0031998053c9c7345c9458f7443aa263">isInjective</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">bool </td>
<td valign="bottom">
<a href="classeigen_1_1colpivhouseholderqr#a945720f8d683f8ebe97fa807edd3142a">isInvertible</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">bool </td>
<td valign="bottom">
<a href="classeigen_1_1colpivhouseholderqr#a87a7d06e0b0479e5b56b19c2a4f56365">isSurjective</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">MatrixType::RealScalar </td>
<td valign="bottom">
<a href="classeigen_1_1colpivhouseholderqr#afdc29438a335871f67449c253369ce12">logAbsDeterminant</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const MatrixType &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1colpivhouseholderqr#aa572ac050c8d4fadd4f08a87f6b1e62b">matrixQR</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const MatrixType &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1colpivhouseholderqr#a44c534d47bde6b67ce4b5247d142ef30">matrixR</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">RealScalar </td>
<td valign="bottom">
<a href="classeigen_1_1colpivhouseholderqr#aac8c43d720170980f582d01494df9e8f">maxPivot</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="structeigen_1_1eigenbase#a554f30542cc2316add4b1ea0a492ff02">Index</a> </td>
<td valign="bottom">
<a href="classeigen_1_1colpivhouseholderqr#a796610bab81f0527aa1ae440c71f58a4">nonzeroPivots</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="structeigen_1_1eigenbase#a554f30542cc2316add4b1ea0a492ff02">Index</a> </td>
<td valign="bottom">
<a href="classeigen_1_1colpivhouseholderqr#a2a59aaa689613ce5ef0c9130ad33940e">rank</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1colpivhouseholderqr">ColPivHouseholderQR</a> &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1colpivhouseholderqr#ae712cdc9f0e521cfc8061bee58ff55ee">setThreshold</a> (const RealScalar &amp;<a href="classeigen_1_1colpivhouseholderqr#a72276adb1aa11f870f50d0bd58af014d">threshold</a>)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1colpivhouseholderqr">ColPivHouseholderQR</a> &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1colpivhouseholderqr#a648df14c457ceceb09d933d06d3bdded">setThreshold</a> (Default_t)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename Rhs &gt; </td></tr> <tr>
<td align="right" valign="top">const <a href="classeigen_1_1solve">Solve</a>&lt; <a href="classeigen_1_1colpivhouseholderqr">ColPivHouseholderQR</a>, Rhs &gt; </td>
<td valign="bottom">
<a href="classeigen_1_1colpivhouseholderqr#aaa9c4af89930ab3bb7612ed9ae33d3f5">solve</a> (const <a href="classeigen_1_1matrixbase">MatrixBase</a>&lt; Rhs &gt; &amp;b) const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">RealScalar </td>
<td valign="bottom">
<a href="classeigen_1_1colpivhouseholderqr#a72276adb1aa11f870f50d0bd58af014d">threshold</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classEigen_1_1SolverBase')">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJAQMAAADaX5RTAAAABlBMVEVHcEx6k8V3LoYxAAAAAXRSTlMAQObYZgAAABxJREFUCNdj4GBg4GFg4GNg4AeiBhDJBxbhYAAADMkA8rytjikAAAAASUVORK5CYII=" alt="-"> Public Member Functions inherited from <a href="classeigen_1_1solverbase">Eigen::SolverBase&lt; ColPivHouseholderQR&lt; _MatrixType &gt; &gt;</a>
</td></tr> <tr>
<td align="right" valign="top">AdjointReturnType </td>
<td valign="bottom">
<a href="classeigen_1_1solverbase#a05a3686a89888681c8e0c2bcab6d1ce5">adjoint</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1colpivhouseholderqr">ColPivHouseholderQR</a>&lt; _MatrixType &gt; &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1solverbase#a1fbabe7f12bcbfba3b9a448b1f5e46fa">derived</a> ()</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const <a href="classeigen_1_1colpivhouseholderqr">ColPivHouseholderQR</a>&lt; _MatrixType &gt; &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1solverbase#afd4f3f1c57b7594b96a7e30f2974ea2e">derived</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const <a href="classeigen_1_1solve">Solve</a>&lt; <a href="classeigen_1_1colpivhouseholderqr">ColPivHouseholderQR</a>&lt; _MatrixType &gt;, Rhs &gt; </td>
<td valign="bottom">
<a href="classeigen_1_1solverbase#a7fd647d110487799205df6f99547879d">solve</a> (const <a href="classeigen_1_1matrixbase">MatrixBase</a>&lt; Rhs &gt; &amp;b) const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top"> </td>
<td valign="bottom">
<a href="classeigen_1_1solverbase#a4d5e5baddfba3790ab1a5f247dcc4dc1">SolverBase</a> ()</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1diagonal">ConstTransposeReturnType</a> </td>
<td valign="bottom">
<a href="classeigen_1_1solverbase#a732e75b5132bb4db3775916927b0e86c">transpose</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structEigen_1_1EigenBase')">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJAQMAAADaX5RTAAAABlBMVEVHcEx6k8V3LoYxAAAAAXRSTlMAQObYZgAAABxJREFUCNdj4GBg4GFg4GNg4AeiBhDJBxbhYAAADMkA8rytjikAAAAASUVORK5CYII=" alt="-"> Public Member Functions inherited from <a href="structeigen_1_1eigenbase">Eigen::EigenBase&lt; Derived &gt;</a>
</td></tr> <tr>
<td align="right" valign="top">EIGEN_CONSTEXPR <a href="structeigen_1_1eigenbase#a554f30542cc2316add4b1ea0a492ff02">Index</a> </td>
<td valign="bottom">
<a href="structeigen_1_1eigenbase#a2d768a9877f5f69f49432d447b552bfe">cols</a> () const EIGEN_NOEXCEPT</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">Derived &amp; </td>
<td valign="bottom">
<a href="structeigen_1_1eigenbase#a1fbabe7f12bcbfba3b9a448b1f5e46fa">derived</a> ()</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const Derived &amp; </td>
<td valign="bottom">
<a href="structeigen_1_1eigenbase#afd4f3f1c57b7594b96a7e30f2974ea2e">derived</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">EIGEN_CONSTEXPR <a href="structeigen_1_1eigenbase#a554f30542cc2316add4b1ea0a492ff02">Index</a> </td>
<td valign="bottom">
<a href="structeigen_1_1eigenbase#ac22eb0695d00edd7d4a3b2d0a98b81c2">rows</a> () const EIGEN_NOEXCEPT</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">EIGEN_CONSTEXPR <a href="structeigen_1_1eigenbase#a554f30542cc2316add4b1ea0a492ff02">Index</a> </td>
<td valign="bottom">
<a href="structeigen_1_1eigenbase#ae106171b6fefd3f7af108a8283de36c9">size</a> () const EIGEN_NOEXCEPT</td>
</tr> <tr><td colspan="2"> </td></tr> </table>
<table> <tr><td colspan="2"></td></tr> <tr><td colspan="2" onclick="javascript:toggleInherit('pub_types_structEigen_1_1EigenBase')">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJAQMAAADaX5RTAAAABlBMVEVHcEx6k8V3LoYxAAAAAXRSTlMAQObYZgAAABxJREFUCNdj4GBg4GFg4GNg4AeiBhDJBxbhYAAADMkA8rytjikAAAAASUVORK5CYII=" alt="-"> Public Types inherited from <a href="structeigen_1_1eigenbase">Eigen::EigenBase&lt; Derived &gt;</a>
</td></tr> <tr>
<td align="right" valign="top">typedef <a href="namespaceeigen#a62e77e0933482dafde8fe197d9a2cfde">Eigen::Index</a> </td>
<td valign="bottom"><a href="structeigen_1_1eigenbase#a554f30542cc2316add4b1ea0a492ff02">Index</a></td>
</tr> <tr>
<td> </td>
<td>The interface type of indices. <a href="structeigen_1_1eigenbase#a554f30542cc2316add4b1ea0a492ff02">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> </table>  <a id="a9d8a92c2a2f0debe5454812372237ed4"></a> <h2>ColPivHouseholderQR() <span>[1/4]</span>
</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1colpivhouseholderqr">Eigen::ColPivHouseholderQR</a>&lt; _MatrixType &gt;::<a href="classeigen_1_1colpivhouseholderqr">ColPivHouseholderQR</a> </td> <td>(</td> <td></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Default Constructor. </p> <p>The default constructor is useful in cases in which the user intends to perform decompositions via ColPivHouseholderQR::compute(const MatrixType&amp;). </p> </div> </div> <a id="a5965d4fdebc04b2df71d67ff0b2d0c2c"></a> <h2>ColPivHouseholderQR() <span>[2/4]</span>
</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1colpivhouseholderqr">Eigen::ColPivHouseholderQR</a>&lt; _MatrixType &gt;::<a href="classeigen_1_1colpivhouseholderqr">ColPivHouseholderQR</a> </td> <td>(</td> <td>
<a href="structeigen_1_1eigenbase#a554f30542cc2316add4b1ea0a492ff02">Index</a> </td> <td>
<em>rows</em>, </td> </tr> <tr> <td></td> <td></td> <td>
<a href="structeigen_1_1eigenbase#a554f30542cc2316add4b1ea0a492ff02">Index</a> </td> <td>
<em>cols</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Default Constructor with memory preallocation. </p> <p>Like the default constructor but with preallocation of the internal data according to the specified problem <em>size</em>. </p>
<dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1colpivhouseholderqr#a9d8a92c2a2f0debe5454812372237ed4" title="Default Constructor.">ColPivHouseholderQR()</a> </dd>
</dl> </div> </div> <a id="a1aa6a5b95380df0ceb224cb833316d4f"></a> <h2>ColPivHouseholderQR() <span>[3/4]</span>
</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <div> template&lt;typename InputType &gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1colpivhouseholderqr">Eigen::ColPivHouseholderQR</a>&lt; _MatrixType &gt;::<a href="classeigen_1_1colpivhouseholderqr">ColPivHouseholderQR</a> </td> <td>(</td> <td>const <a href="structeigen_1_1eigenbase">EigenBase</a>&lt; InputType &gt; &amp; </td> <td><em>matrix</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span><span>explicit</span></span> </td> </tr> </table> </div>
<div> <p>Constructs a QR factorization from a given matrix. </p> <p>This constructor computes the QR factorization of the matrix <em>matrix</em> by calling the method compute(). It is a short cut for:</p> <pre data-language="cpp">ColPivHouseholderQR&lt;MatrixType&gt; qr(matrix.rows(), matrix.cols());
qr.compute(matrix);
</pre>
<dl>
<dt>See also</dt>
<dd>compute() </dd>
</dl> </div> </div> <a id="a65782010a93a4c9ef4a9191ac8fe30bc"></a> <h2>ColPivHouseholderQR() <span>[4/4]</span>
</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <div> template&lt;typename InputType &gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1colpivhouseholderqr">Eigen::ColPivHouseholderQR</a>&lt; _MatrixType &gt;::<a href="classeigen_1_1colpivhouseholderqr">ColPivHouseholderQR</a> </td> <td>(</td> <td>
<a href="structeigen_1_1eigenbase">EigenBase</a>&lt; InputType &gt; &amp; </td> <td><em>matrix</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span><span>explicit</span></span> </td> </tr> </table> </div>
<div> <p>Constructs a QR factorization from a given matrix. </p> <p>This overloaded constructor is provided for <a href="group__inplacedecomposition">inplace decomposition </a> when <code>MatrixType</code> is a <a href="classeigen_1_1ref" title="A matrix or vector expression mapping an existing expression.">Eigen::Ref</a>.</p> <dl>
<dt>See also</dt>
<dd>ColPivHouseholderQR(const EigenBase&amp;) </dd>
</dl> </div> </div>  <a id="ac87c3bf42098d6f7324dafbc50fa83f7"></a> <h2>absDeterminant()</h2> <div> <div> <div> template&lt;typename MatrixType &gt; </div> <table> <tr> <td>MatrixType::RealScalar <a href="classeigen_1_1colpivhouseholderqr">Eigen::ColPivHouseholderQR</a>&lt; MatrixType &gt;::absDeterminant</td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>the absolute value of the determinant of the matrix of which *this is the QR decomposition. It has only linear complexity (that is, O(n) where n is the dimension of the square matrix) as the QR decomposition has already been computed.</dd>
</dl> <dl>
<dt>Note</dt>
<dd>This is only for square matrices.</dd>
</dl> <dl>
<dt>Warning</dt>
<dd>a determinant can be very big or small, so for matrices of large enough dimension, there is a risk of overflow/underflow. One way to work around that is to use <a href="classeigen_1_1colpivhouseholderqr#afdc29438a335871f67449c253369ce12">logAbsDeterminant()</a> instead.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1colpivhouseholderqr#afdc29438a335871f67449c253369ce12">logAbsDeterminant()</a>, <a href="classeigen_1_1matrixbase#a7ad8f77004bb956b603bb43fd2e3c061">MatrixBase::determinant()</a> </dd>
</dl> </div> </div> <a id="ab6ad43e6a6fb75726eae0d5499948f4a"></a> <h2>colsPermutation()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="classeigen_1_1permutationmatrix">PermutationType</a>&amp; <a href="classeigen_1_1colpivhouseholderqr">Eigen::ColPivHouseholderQR</a>&lt; _MatrixType &gt;::colsPermutation </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>a const reference to the column permutation matrix </dd>
</dl> </div> </div> <a id="a608016776319abe8fe96b85f83c8dd3d"></a> <h2>compute()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <div> template&lt;typename InputType &gt; </div> <table> <tr> <td>
<a href="classeigen_1_1colpivhouseholderqr">ColPivHouseholderQR</a>&lt;MatrixType&gt;&amp; <a href="classeigen_1_1colpivhouseholderqr">Eigen::ColPivHouseholderQR</a>&lt; _MatrixType &gt;::compute </td> <td>(</td> <td>const <a href="structeigen_1_1eigenbase">EigenBase</a>&lt; InputType &gt; &amp; </td> <td><em>matrix</em></td>
<td>)</td> <td></td> </tr> </table> </div>
<div> <p>Performs the QR factorization of the given matrix <em>matrix</em>. The result of the factorization is stored into <code>*this</code>, and a reference to <code>*this</code> is returned.</p> <dl>
<dt>See also</dt>
<dd>class <a href="classeigen_1_1colpivhouseholderqr" title="Householder rank-revealing QR decomposition of a matrix with column-pivoting.">ColPivHouseholderQR</a>, ColPivHouseholderQR(const MatrixType&amp;) </dd>
</dl> </div> </div> <a id="a7c9294565d179226133770160b827be1"></a> <h2>dimensionOfKernel()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="structeigen_1_1eigenbase#a554f30542cc2316add4b1ea0a492ff02">Index</a> <a href="classeigen_1_1colpivhouseholderqr">Eigen::ColPivHouseholderQR</a>&lt; _MatrixType &gt;::dimensionOfKernel </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>the dimension of the kernel of the matrix of which *this is the QR decomposition.</dd>
</dl> <dl>
<dt>Note</dt>
<dd>This method has to determine which pivots should be considered nonzero. For that, it uses the threshold value that you can control by calling <a href="classeigen_1_1colpivhouseholderqr#ae712cdc9f0e521cfc8061bee58ff55ee">setThreshold(const RealScalar&amp;)</a>. </dd>
</dl> </div> </div> <a id="ac5943d19aa5fd96340c7df6874fcb1b9"></a> <h2>hCoeffs()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>const HCoeffsType&amp; <a href="classeigen_1_1colpivhouseholderqr">Eigen::ColPivHouseholderQR</a>&lt; _MatrixType &gt;::hCoeffs </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>a const reference to the vector of Householder coefficients used to represent the factor <code>Q</code>.</dd>
</dl> <p>For advanced uses only. </p> </div> </div> <a id="a28ab9d8916ca609c5469c4c192fbfa28"></a> <h2>householderQ()</h2> <div> <div> <div> template&lt;typename MatrixType &gt; </div> <table> <tr> <td>
<a href="classeigen_1_1colpivhouseholderqr">ColPivHouseholderQR</a>&lt; MatrixType &gt;::<a href="classeigen_1_1householdersequence">HouseholderSequenceType</a> <a href="classeigen_1_1colpivhouseholderqr">Eigen::ColPivHouseholderQR</a>&lt; MatrixType &gt;::householderQ</td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>the matrix Q as a sequence of householder transformations. You can extract the meaningful part only by using: <pre data-language="cpp">qr.householderQ().setLength(qr.nonzeroPivots()) 
</pre> </dd>
</dl> </div> </div> <a id="a5c756a789175197cab3eff3a3e479ef2"></a> <h2>info()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="group__enums#ga85fad7b87587764e5cf6b513a9e0ee5e">ComputationInfo</a> <a href="classeigen_1_1colpivhouseholderqr">Eigen::ColPivHouseholderQR</a>&lt; _MatrixType &gt;::info </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Reports whether the QR factorization was successful. </p> <dl>
<dt>Note</dt>
<dd>This function always returns <code>Success</code>. It is provided for compatibility with other factorization routines. </dd>
</dl> <dl>
<dt>Returns</dt>
<dd>
<code>Success</code> </dd>
</dl> </div> </div> <a id="a31c45402e74774d9cd13af0e57a6b72f"></a> <h2>inverse()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="classeigen_1_1inverse">Inverse</a>&lt;<a href="classeigen_1_1colpivhouseholderqr">ColPivHouseholderQR</a>&gt; <a href="classeigen_1_1colpivhouseholderqr">Eigen::ColPivHouseholderQR</a>&lt; _MatrixType &gt;::inverse </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>the inverse of the matrix of which *this is the QR decomposition.</dd>
</dl> <dl>
<dt>Note</dt>
<dd>If this matrix is not invertible, the returned matrix has undefined coefficients. Use <a href="classeigen_1_1colpivhouseholderqr#a945720f8d683f8ebe97fa807edd3142a">isInvertible()</a> to first determine whether this matrix is invertible. </dd>
</dl> </div> </div> <a id="a0031998053c9c7345c9458f7443aa263"></a> <h2>isInjective()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>bool <a href="classeigen_1_1colpivhouseholderqr">Eigen::ColPivHouseholderQR</a>&lt; _MatrixType &gt;::isInjective </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>true if the matrix of which *this is the QR decomposition represents an injective linear map, i.e. has trivial kernel; false otherwise.</dd>
</dl> <dl>
<dt>Note</dt>
<dd>This method has to determine which pivots should be considered nonzero. For that, it uses the threshold value that you can control by calling <a href="classeigen_1_1colpivhouseholderqr#ae712cdc9f0e521cfc8061bee58ff55ee">setThreshold(const RealScalar&amp;)</a>. </dd>
</dl> </div> </div> <a id="a945720f8d683f8ebe97fa807edd3142a"></a> <h2>isInvertible()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>bool <a href="classeigen_1_1colpivhouseholderqr">Eigen::ColPivHouseholderQR</a>&lt; _MatrixType &gt;::isInvertible </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>true if the matrix of which *this is the QR decomposition is invertible.</dd>
</dl> <dl>
<dt>Note</dt>
<dd>This method has to determine which pivots should be considered nonzero. For that, it uses the threshold value that you can control by calling <a href="classeigen_1_1colpivhouseholderqr#ae712cdc9f0e521cfc8061bee58ff55ee">setThreshold(const RealScalar&amp;)</a>. </dd>
</dl> </div> </div> <a id="a87a7d06e0b0479e5b56b19c2a4f56365"></a> <h2>isSurjective()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>bool <a href="classeigen_1_1colpivhouseholderqr">Eigen::ColPivHouseholderQR</a>&lt; _MatrixType &gt;::isSurjective </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>true if the matrix of which *this is the QR decomposition represents a surjective linear map; false otherwise.</dd>
</dl> <dl>
<dt>Note</dt>
<dd>This method has to determine which pivots should be considered nonzero. For that, it uses the threshold value that you can control by calling <a href="classeigen_1_1colpivhouseholderqr#ae712cdc9f0e521cfc8061bee58ff55ee">setThreshold(const RealScalar&amp;)</a>. </dd>
</dl> </div> </div> <a id="afdc29438a335871f67449c253369ce12"></a> <h2>logAbsDeterminant()</h2> <div> <div> <div> template&lt;typename MatrixType &gt; </div> <table> <tr> <td>MatrixType::RealScalar <a href="classeigen_1_1colpivhouseholderqr">Eigen::ColPivHouseholderQR</a>&lt; MatrixType &gt;::logAbsDeterminant</td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>the natural log of the absolute value of the determinant of the matrix of which *this is the QR decomposition. It has only linear complexity (that is, O(n) where n is the dimension of the square matrix) as the QR decomposition has already been computed.</dd>
</dl> <dl>
<dt>Note</dt>
<dd>This is only for square matrices.</dd> <dd> This method is useful to work around the risk of overflow/underflow that's inherent to determinant computation.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1colpivhouseholderqr#ac87c3bf42098d6f7324dafbc50fa83f7">absDeterminant()</a>, <a href="classeigen_1_1matrixbase#a7ad8f77004bb956b603bb43fd2e3c061">MatrixBase::determinant()</a> </dd>
</dl> </div> </div> <a id="aa572ac050c8d4fadd4f08a87f6b1e62b"></a> <h2>matrixQR()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>const MatrixType&amp; <a href="classeigen_1_1colpivhouseholderqr">Eigen::ColPivHouseholderQR</a>&lt; _MatrixType &gt;::matrixQR </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>a reference to the matrix where the Householder QR decomposition is stored </dd>
</dl> </div> </div> <a id="a44c534d47bde6b67ce4b5247d142ef30"></a> <h2>matrixR()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>const MatrixType&amp; <a href="classeigen_1_1colpivhouseholderqr">Eigen::ColPivHouseholderQR</a>&lt; _MatrixType &gt;::matrixR </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>a reference to the matrix where the result Householder QR is stored </dd>
</dl> <dl>
<dt>Warning</dt>
<dd>The strict lower part of this matrix contains internal values. Only the upper triangular part should be referenced. To get it, use <pre data-language="cpp"><a href="classeigen_1_1colpivhouseholderqr#a44c534d47bde6b67ce4b5247d142ef30">matrixR</a>().template triangularView&lt;Upper&gt;() </pre> For rank-deficient matrices, use <pre data-language="cpp"><a href="classeigen_1_1colpivhouseholderqr#a44c534d47bde6b67ce4b5247d142ef30">matrixR</a>().topLeftCorner(<a href="classeigen_1_1colpivhouseholderqr#a2a59aaa689613ce5ef0c9130ad33940e">rank</a>(), <a href="classeigen_1_1colpivhouseholderqr#a2a59aaa689613ce5ef0c9130ad33940e">rank</a>()).template triangularView&lt;Upper&gt;()</pre> </dd>
</dl> </div> </div> <a id="aac8c43d720170980f582d01494df9e8f"></a> <h2>maxPivot()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>RealScalar <a href="classeigen_1_1colpivhouseholderqr">Eigen::ColPivHouseholderQR</a>&lt; _MatrixType &gt;::maxPivot </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>the absolute value of the biggest pivot, i.e. the biggest diagonal coefficient of R. </dd>
</dl> </div> </div> <a id="a796610bab81f0527aa1ae440c71f58a4"></a> <h2>nonzeroPivots()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="structeigen_1_1eigenbase#a554f30542cc2316add4b1ea0a492ff02">Index</a> <a href="classeigen_1_1colpivhouseholderqr">Eigen::ColPivHouseholderQR</a>&lt; _MatrixType &gt;::nonzeroPivots </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>the number of nonzero pivots in the QR decomposition. Here nonzero is meant in the exact sense, not in a fuzzy sense. So that notion isn't really intrinsically interesting, but it is still useful when implementing algorithms.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1colpivhouseholderqr#a2a59aaa689613ce5ef0c9130ad33940e">rank()</a> </dd>
</dl> </div> </div> <a id="a2a59aaa689613ce5ef0c9130ad33940e"></a> <h2>rank()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="structeigen_1_1eigenbase#a554f30542cc2316add4b1ea0a492ff02">Index</a> <a href="classeigen_1_1colpivhouseholderqr">Eigen::ColPivHouseholderQR</a>&lt; _MatrixType &gt;::rank </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>the rank of the matrix of which *this is the QR decomposition.</dd>
</dl> <dl>
<dt>Note</dt>
<dd>This method has to determine which pivots should be considered nonzero. For that, it uses the threshold value that you can control by calling <a href="classeigen_1_1colpivhouseholderqr#ae712cdc9f0e521cfc8061bee58ff55ee">setThreshold(const RealScalar&amp;)</a>. </dd>
</dl> </div> </div> <a id="ae712cdc9f0e521cfc8061bee58ff55ee"></a> <h2>setThreshold() <span>[1/2]</span>
</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1colpivhouseholderqr">ColPivHouseholderQR</a>&amp; <a href="classeigen_1_1colpivhouseholderqr">Eigen::ColPivHouseholderQR</a>&lt; _MatrixType &gt;::setThreshold </td> <td>(</td> <td>const RealScalar &amp; </td> <td><em>threshold</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Allows to prescribe a threshold to be used by certain methods, such as <a href="classeigen_1_1colpivhouseholderqr#a2a59aaa689613ce5ef0c9130ad33940e">rank()</a>, who need to determine when pivots are to be considered nonzero. This is not used for the QR decomposition itself.</p> <p>When it needs to get the threshold value, <a href="namespaceeigen" title="Namespace containing all symbols from the Eigen library.">Eigen</a> calls <a href="classeigen_1_1colpivhouseholderqr#a72276adb1aa11f870f50d0bd58af014d">threshold()</a>. By default, this uses a formula to automatically determine a reasonable threshold. Once you have called the present method <a href="classeigen_1_1colpivhouseholderqr#ae712cdc9f0e521cfc8061bee58ff55ee">setThreshold(const RealScalar&amp;)</a>, your value is used instead.</p> <dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>threshold</td>
<td>The new value to use as the threshold.</td>
</tr> </table> </dd> </dl> <p>A pivot will be considered nonzero if its absolute value is strictly greater than \( \vert pivot \vert \leqslant threshold \times \vert maxpivot \vert \) where maxpivot is the biggest pivot.</p> <p>If you want to come back to the default behavior, call <a href="classeigen_1_1colpivhouseholderqr#a648df14c457ceceb09d933d06d3bdded">setThreshold(Default_t)</a> </p> </div> </div> <a id="a648df14c457ceceb09d933d06d3bdded"></a> <h2>setThreshold() <span>[2/2]</span>
</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1colpivhouseholderqr">ColPivHouseholderQR</a>&amp; <a href="classeigen_1_1colpivhouseholderqr">Eigen::ColPivHouseholderQR</a>&lt; _MatrixType &gt;::setThreshold </td> <td>(</td> <td>Default_t </td> <td></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Allows to come back to the default behavior, letting <a href="namespaceeigen" title="Namespace containing all symbols from the Eigen library.">Eigen</a> use its default formula for determining the threshold.</p> <p>You should pass the special object Eigen::Default as parameter here. </p>
<pre data-language="cpp">qr.setThreshold(Eigen::Default); 
</pre>
<p>See the documentation of <a href="classeigen_1_1colpivhouseholderqr#ae712cdc9f0e521cfc8061bee58ff55ee">setThreshold(const RealScalar&amp;)</a>. </p> </div> </div> <a id="aaa9c4af89930ab3bb7612ed9ae33d3f5"></a> <h2>solve()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <div> template&lt;typename Rhs &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="classeigen_1_1solve">Solve</a>&lt;<a href="classeigen_1_1colpivhouseholderqr">ColPivHouseholderQR</a>, Rhs&gt; <a href="classeigen_1_1colpivhouseholderqr">Eigen::ColPivHouseholderQR</a>&lt; _MatrixType &gt;::solve </td> <td>(</td> <td>const <a href="classeigen_1_1matrixbase">MatrixBase</a>&lt; Rhs &gt; &amp; </td> <td><em>b</em></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>This method finds a solution x to the equation Ax=b, where A is the matrix of which *this is the QR decomposition, if any exists.</p> <dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>b</td>
<td>the right-hand-side of the equation to solve.</td>
</tr> </table> </dd> </dl> <dl>
<dt>Returns</dt>
<dd>a solution.</dd>
</dl> <p>This method just tries to find as good a solution as possible. If you want to check whether a solution exists or if it is accurate, just call this function to get a result and then compute the error of this result, or use <a href="classeigen_1_1densebase#ae8443357b808cd393be1b51974213f9c">MatrixBase::isApprox()</a> directly, for instance like this:</p>
<pre data-language="cpp"><span>bool</span> a_solution_exists = (A*result).isApprox(b, precision); 
</pre>
<p> This method avoids dividing by zero, so that the non-existence of a solution doesn't by itself mean that you'll get <code>inf</code> or <code>nan</code> values.</p> <p>If there exists more than one solution, this method will arbitrarily choose one.</p> <p>Example: </p>
<pre data-language="cpp">Matrix3f m = <a href="classeigen_1_1densebase#ae814abb451b48ed872819192dc188c19">Matrix3f::Random</a>();
Matrix3f y = <a href="classeigen_1_1densebase#ae814abb451b48ed872819192dc188c19">Matrix3f::Random</a>();
cout &lt;&lt; <span>"Here is the matrix m:"</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
cout &lt;&lt; <span>"Here is the matrix y:"</span> &lt;&lt; endl &lt;&lt; y &lt;&lt; endl;
Matrix3f x;
x = m.colPivHouseholderQr().solve(y);
assert(y.isApprox(m*x));
cout &lt;&lt; <span>"Here is a solution x to the equation mx=y:"</span> &lt;&lt; endl &lt;&lt; x &lt;&lt; endl;</pre>
<p> Output: </p>
<pre>Here is the matrix m:
  0.68  0.597  -0.33
-0.211  0.823  0.536
 0.566 -0.605 -0.444
Here is the matrix y:
  0.108   -0.27   0.832
-0.0452  0.0268   0.271
  0.258   0.904   0.435
Here is a solution x to the equation mx=y:
 0.609   2.68   1.67
-0.231  -1.57 0.0713
  0.51   3.51   1.05
</pre> </div> </div> <a id="a72276adb1aa11f870f50d0bd58af014d"></a> <h2>threshold()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>RealScalar <a href="classeigen_1_1colpivhouseholderqr">Eigen::ColPivHouseholderQR</a>&lt; _MatrixType &gt;::threshold </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Returns the threshold that will be used by certain methods such as <a href="classeigen_1_1colpivhouseholderqr#a2a59aaa689613ce5ef0c9130ad33940e">rank()</a>.</p> <p>See the documentation of <a href="classeigen_1_1colpivhouseholderqr#ae712cdc9f0e521cfc8061bee58ff55ee">setThreshold(const RealScalar&amp;)</a>. </p> </div> </div> <hr>The documentation for this class was generated from the following file:<ul> <li><a href="https://eigen.tuxfamily.org/dox/ColPivHouseholderQR_8h_source.html">ColPivHouseholderQR.h</a></li> </ul> </div> <div class="_attribution">
  <p class="_attribution-p">
     Eigen.<br>Licensed under the MPL2 License.<br>
    <a href="https://eigen.tuxfamily.org/dox/classEigen_1_1ColPivHouseholderQR.html" class="_attribution-link">https://eigen.tuxfamily.org/dox/classEigen_1_1ColPivHouseholderQR.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
