
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Eigen&#58;&#58;VectorwiseOp - Eigen3 - W3cubDocs</title>
  
  <meta name="description" content=" Pseudo expression providing broadcasting and partial reduction operations. ">
  <meta name="keywords" content="eigen, vectorwiseop, eigen3">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/eigen3/classeigen_1_1vectorwiseop.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-f16eecbe420d8b2925d31ffbb21d05646497ecbd9515f08ffe69e9bba7332f5657accc7003c7f6c72cb4a132171acf171b359ae3bae4ae5660ddfb1718f88c67.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/eigen3.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/eigen3/" class="_nav-link" title="" style="margin-left:0;">Eigen3</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _eigen3">
				
				
<h1>Eigen::VectorwiseOp</h1>      <div>  <div>
<h3>template&lt;typename ExpressionType, int Direction&gt;<br> class Eigen::VectorwiseOp&lt; ExpressionType, Direction &gt;</h3> <p>Pseudo expression providing broadcasting and partial reduction operations. </p> <dl>
<dt>Template Parameters</dt>
<dd> <table> <tr>
<td>ExpressionType</td>
<td>the type of the object on which to do partial reductions </td>
</tr> <tr>
<td>Direction</td>
<td>indicates whether to operate on columns (<a href="group__enums#ggad49a7b3738e273eb00932271b36127f7ae2efac6e74ecab5e3b0b1561c5ddf83e">Vertical</a>) or rows (<a href="group__enums#ggad49a7b3738e273eb00932271b36127f7a961c62410157b64033839488f4d7f7e4">Horizontal</a>)</td>
</tr> </table> </dd> </dl> <p>This class represents a pseudo expression with broadcasting and partial reduction features. It is the return type of <a href="classeigen_1_1densebase#a1c0e1b6067ec1de6cb8799da55aa7d30">DenseBase::colwise()</a> and <a href="classeigen_1_1densebase#a6daa3a3156ca0e0722bf78638e1c7f28">DenseBase::rowwise()</a> and most of the time this is the only way it is explicitly used.</p> <p>To understand the logic of rowwise/colwise expression, let's consider a generic case <code>A.colwise().foo()</code> where <code>foo</code> is any method of <code><a href="classeigen_1_1vectorwiseop" title="Pseudo expression providing broadcasting and partial reduction operations.">VectorwiseOp</a></code>. This expression is equivalent to applying <code>foo()</code> to each column of <code>A</code> and then re-assemble the outputs in a matrix expression: </p>
<pre data-language="cpp">[A.col(0).foo(), A.col(1).foo(), ..., A.col(A.cols()-1).foo()] 
</pre>
<p>Example: </p>
<pre data-language="cpp">Matrix3d m = <a href="classeigen_1_1densebase#ae814abb451b48ed872819192dc188c19">Matrix3d::Random</a>();
cout &lt;&lt; <span>"Here is the matrix m:"</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
cout &lt;&lt; <span>"Here is the sum of each column:"</span> &lt;&lt; endl &lt;&lt; m.colwise().sum() &lt;&lt; endl;
cout &lt;&lt; <span>"Here is the maximum absolute value of each column:"</span>
     &lt;&lt; endl &lt;&lt; m.cwiseAbs().colwise().maxCoeff() &lt;&lt; endl;</pre>
<p> Output: </p>
<pre>Here is the matrix m:
  0.68  0.597  -0.33
-0.211  0.823  0.536
 0.566 -0.605 -0.444
Here is the sum of each column:
  1.04  0.815 -0.238
Here is the maximum absolute value of each column:
 0.68 0.823 0.536
</pre>
<p>The <a href="classeigen_1_1vectorwiseop#abbf3325f535ac011ed61f14ed4330618">begin()</a> and <a href="classeigen_1_1vectorwiseop#a9d189042b8322e40772d41c63b9d3bb5">end()</a> methods are obviously exceptions to the previous rule as they return STL-compatible begin/end iterators to the rows or columns of the nested expression. Typical use cases include for-range-loop and calls to STL algorithms:</p> <p>Example: </p>
<pre data-language="cpp">Matrix3i m = <a href="classeigen_1_1densebase#ae814abb451b48ed872819192dc188c19">Matrix3i::Random</a>();
cout &lt;&lt; <span>"Here is the initial matrix m:"</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
<span>int</span> i = -1;
<span>for</span>(<span>auto</span> c: m.colwise()) {
  c *= i;
  ++i;
}
cout &lt;&lt; <span>"Here is the matrix m after the for-range-loop:"</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
<span>auto</span> cols = m.colwise();
<span>auto</span> it = std::find_if(cols.cbegin(), cols.cend(),
                       [](Matrix3i::ConstColXpr x) { return x.squaredNorm() == 0; });
cout &lt;&lt; <span>"The first empty column is: "</span> &lt;&lt; distance(cols.cbegin(),it) &lt;&lt; endl;
</pre>
<p> Output: </p>
<pre>Here is the initial matrix m:
 7  6 -3
-2  9  6
 6 -6 -5
Here is the matrix m after the for-range-loop:
-7  0 -3
 2  0  6
-6  0 -5
The first empty column is: 1
</pre>
<p>For a partial reduction on an empty input, some rules apply. For the sake of clarity, let's consider a vertical reduction:</p>
<ul> <li>If the number of columns is zero, then a 1x0 row-major vector expression is returned.</li> <li>Otherwise, if the number of rows is zero, then<ul> <li>a row vector of zeros is returned for sum-like reductions (sum, squaredNorm, norm, etc.)</li> <li>a row vector of ones is returned for a product reduction (e.g., <code>MatrixXd(n,0).colwise().<a href="classeigen_1_1vectorwiseop#a01bcd17504f30b55b4910ddb75598f79">prod()</a></code>)</li> <li>an assert is triggered for all other reductions (minCoeff,maxCoeff,redux(bin_op))</li> </ul> </li> </ul> <dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1densebase#a1c0e1b6067ec1de6cb8799da55aa7d30">DenseBase::colwise()</a>, <a href="classeigen_1_1densebase#a6daa3a3156ca0e0722bf78638e1c7f28">DenseBase::rowwise()</a>, class <a href="classeigen_1_1partialreduxexpr" title="Generic expression of a partially reduxed matrix.">PartialReduxExpr</a> </dd>
</dl> </div>
<table> <tr><td colspan="2"></td></tr> <tr>
<td align="right" valign="top">typedef <a href="namespaceeigen#a62e77e0933482dafde8fe197d9a2cfde">Eigen::Index</a> </td>
<td valign="bottom"><a href="classeigen_1_1vectorwiseop#a4907c654e5810edd98e4162093b19532">Index</a></td>
</tr> <tr><td colspan="2"> </td></tr> </table>
<table> <tr><td colspan="2"></td></tr> <tr>
<td align="right" valign="top">const <a href="classeigen_1_1partialreduxexpr">AllReturnType</a> </td>
<td valign="bottom">
<a href="classeigen_1_1vectorwiseop#a9c2b4740bf190492bf231d8e244b25c1">all</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const <a href="classeigen_1_1partialreduxexpr">AnyReturnType</a> </td>
<td valign="bottom">
<a href="classeigen_1_1vectorwiseop#a96210c9f83bd375f8ce862bd62ab70e6">any</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1vectorwiseop#a9fb8aaf24528efcdac1782aacf99b8dd">iterator</a> </td>
<td valign="bottom">
<a href="classeigen_1_1vectorwiseop#abbf3325f535ac011ed61f14ed4330618">begin</a> ()</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1vectorwiseop#a595c33d2a82427a1159568b0b8438554">const_iterator</a> </td>
<td valign="bottom">
<a href="classeigen_1_1vectorwiseop#aaf91f2a57a26e88e7131fcd9c194f93f">begin</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const <a href="classeigen_1_1partialreduxexpr">BlueNormReturnType</a> </td>
<td valign="bottom">
<a href="classeigen_1_1vectorwiseop#a4d2fbc5296470a94379cbcb33bb9c24d">blueNorm</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1vectorwiseop#a595c33d2a82427a1159568b0b8438554">const_iterator</a> </td>
<td valign="bottom">
<a href="classeigen_1_1vectorwiseop#a7b237a2b46479de5c905d2bcc54f34c4">cbegin</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1vectorwiseop#a595c33d2a82427a1159568b0b8438554">const_iterator</a> </td>
<td valign="bottom">
<a href="classeigen_1_1vectorwiseop#a57859b88a32b8b393a427c4cab3581a7">cend</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const <a href="classeigen_1_1partialreduxexpr">CountReturnType</a> </td>
<td valign="bottom">
<a href="classeigen_1_1vectorwiseop#a5c6b797457895f11a7682b3a16f263bb">count</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const_reverse_iterator </td>
<td valign="bottom">
<a href="classeigen_1_1vectorwiseop#aec95725eed4adb5ccf65fbb6e907d12e">crbegin</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const_reverse_iterator </td>
<td valign="bottom">
<a href="classeigen_1_1vectorwiseop#a23fa202916349d11e476f459543395ef">crend</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename OtherDerived &gt; </td></tr> <tr>
<td align="right" valign="top">const CrossReturnType </td>
<td valign="bottom">
<a href="group__geometry__module#ga2fe1a2a012ce0ab0e8da6af134073039">cross</a> (const <a href="classeigen_1_1matrixbase">MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1vectorwiseop#a9fb8aaf24528efcdac1782aacf99b8dd">iterator</a> </td>
<td valign="bottom">
<a href="classeigen_1_1vectorwiseop#a9d189042b8322e40772d41c63b9d3bb5">end</a> ()</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1vectorwiseop#a595c33d2a82427a1159568b0b8438554">const_iterator</a> </td>
<td valign="bottom">
<a href="classeigen_1_1vectorwiseop#ad3b0dcb34bb4903ffa1ab3634188ecff">end</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const <a href="classeigen_1_1cwisebinaryop">HNormalizedReturnType</a> </td>
<td valign="bottom">
<a href="group__geometry__module#ga1f220045efa302626c287088b63b6ba9">hnormalized</a> () const</td>
</tr> <tr>
<td> </td>
<td>column or row-wise homogeneous normalization <a href="group__geometry__module#ga1f220045efa302626c287088b63b6ba9">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1homogeneous">HomogeneousReturnType</a> </td>
<td valign="bottom">
<a href="group__geometry__module#gaf99305a3d7432318236df7b80022df37">homogeneous</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const <a href="classeigen_1_1partialreduxexpr">HypotNormReturnType</a> </td>
<td valign="bottom">
<a href="classeigen_1_1vectorwiseop#a00c44e033eec33586ae8093a6366da75">hypotNorm</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;int p&gt; </td></tr> <tr>
<td align="right" valign="top">const LpNormReturnType&lt; p &gt;::Type </td>
<td valign="bottom">
<a href="classeigen_1_1vectorwiseop#aa9c2cad38085e7f5f9bc2598eff249f1">lpNorm</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const <a href="classeigen_1_1partialreduxexpr">MaxCoeffReturnType</a> </td>
<td valign="bottom">
<a href="classeigen_1_1vectorwiseop#a6646b584db116c1661b5bb56750bd6f6">maxCoeff</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const MeanReturnType </td>
<td valign="bottom">
<a href="classeigen_1_1vectorwiseop#aaf7d867f9e6b74a1bc7f108d646cfa85">mean</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const <a href="classeigen_1_1partialreduxexpr">MinCoeffReturnType</a> </td>
<td valign="bottom">
<a href="classeigen_1_1vectorwiseop#a7d7b8c03d180b126fde0ac212e2b0b76">minCoeff</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const <a href="classeigen_1_1cwiseunaryop">NormReturnType</a> </td>
<td valign="bottom">
<a href="classeigen_1_1vectorwiseop#af726d1dfd9a7a67b76e639db1a9f352e">norm</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">void </td>
<td valign="bottom">
<a href="classeigen_1_1vectorwiseop#adb1084153780dc8d2c062fee97651a45">normalize</a> ()</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1cwisebinaryop">CwiseBinaryOp</a>&lt; internal::scalar_quotient_op&lt; Scalar &gt;, const ExpressionTypeNestedCleaned, const typename OppositeExtendedType&lt; <a href="classeigen_1_1cwiseunaryop">NormReturnType</a> &gt;::Type &gt; </td>
<td valign="bottom">
<a href="classeigen_1_1vectorwiseop#aca6ac44a9bf819d5d64c2cb54bf38095">normalized</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename OtherDerived &gt; </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1cwisebinaryop">CwiseBinaryOp</a>&lt; internal::scalar_product_op&lt; Scalar &gt;, const ExpressionTypeNestedCleaned, const typename ExtendedType&lt; OtherDerived &gt;::Type &gt; </td>
<td valign="bottom">
<a href="classeigen_1_1vectorwiseop#a25ca4c1e409897feca669dee811533c9">operator*</a> (const <a href="classeigen_1_1densebase">DenseBase</a>&lt; OtherDerived &gt; &amp;other) const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename OtherDerived &gt; </td></tr> <tr>
<td align="right" valign="top">ExpressionType &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1vectorwiseop#acef518a77a8947c6726ba30d56dd67cb">operator*=</a> (const <a href="classeigen_1_1densebase">DenseBase</a>&lt; OtherDerived &gt; &amp;other)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename OtherDerived &gt; </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1cwisebinaryop">CwiseBinaryOp</a>&lt; internal::scalar_sum_op&lt; Scalar, typename OtherDerived::Scalar &gt;, const ExpressionTypeNestedCleaned, const typename ExtendedType&lt; OtherDerived &gt;::Type &gt; </td>
<td valign="bottom">
<a href="classeigen_1_1vectorwiseop#a713694459d81b76e4f2a78e4d169f8d6">operator+</a> (const <a href="classeigen_1_1densebase">DenseBase</a>&lt; OtherDerived &gt; &amp;other) const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename OtherDerived &gt; </td></tr> <tr>
<td align="right" valign="top">ExpressionType &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1vectorwiseop#a23ce2522d11c3362ca22252b2876812b">operator+=</a> (const <a href="classeigen_1_1densebase">DenseBase</a>&lt; OtherDerived &gt; &amp;other)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename OtherDerived &gt; </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1cwisebinaryop">CwiseBinaryOp</a>&lt; internal::scalar_difference_op&lt; Scalar, typename OtherDerived::Scalar &gt;, const ExpressionTypeNestedCleaned, const typename ExtendedType&lt; OtherDerived &gt;::Type &gt; </td>
<td valign="bottom">
<a href="classeigen_1_1vectorwiseop#a5e60616620df132d665b301bb9a304c4">operator-</a> (const <a href="classeigen_1_1densebase">DenseBase</a>&lt; OtherDerived &gt; &amp;other) const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename OtherDerived &gt; </td></tr> <tr>
<td align="right" valign="top">ExpressionType &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1vectorwiseop#a6bb3a7315617f86f0c28ac05816cf6e3">operator-=</a> (const <a href="classeigen_1_1densebase">DenseBase</a>&lt; OtherDerived &gt; &amp;other)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename OtherDerived &gt; </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1cwisebinaryop">CwiseBinaryOp</a>&lt; internal::scalar_quotient_op&lt; Scalar &gt;, const ExpressionTypeNestedCleaned, const typename ExtendedType&lt; OtherDerived &gt;::Type &gt; </td>
<td valign="bottom">
<a href="classeigen_1_1vectorwiseop#aa154a8407885a9ad51504180f6d7a163">operator/</a> (const <a href="classeigen_1_1densebase">DenseBase</a>&lt; OtherDerived &gt; &amp;other) const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename OtherDerived &gt; </td></tr> <tr>
<td align="right" valign="top">ExpressionType &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1vectorwiseop#a9efa0b81915c31535a929a46a79cab2b">operator/=</a> (const <a href="classeigen_1_1densebase">DenseBase</a>&lt; OtherDerived &gt; &amp;other)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename OtherDerived &gt; </td></tr> <tr>
<td align="right" valign="top">ExpressionType &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1vectorwiseop#a7999eb8f50bb19ade54f3212d3c79680">operator=</a> (const <a href="classeigen_1_1densebase">DenseBase</a>&lt; OtherDerived &gt; &amp;other)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const <a href="classeigen_1_1partialreduxexpr">ProdReturnType</a> </td>
<td valign="bottom">
<a href="classeigen_1_1vectorwiseop#a01bcd17504f30b55b4910ddb75598f79">prod</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">reverse_iterator </td>
<td valign="bottom">
<a href="classeigen_1_1vectorwiseop#a91a8087eb76e210b07192c81d362dd1e">rbegin</a> ()</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const_reverse_iterator </td>
<td valign="bottom">
<a href="classeigen_1_1vectorwiseop#aa73e8a0230fcc049346057ef1a6efe02">rbegin</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename BinaryOp &gt; </td></tr> <tr>
<td align="right" valign="top">const ReduxReturnType&lt; BinaryOp &gt;::Type </td>
<td valign="bottom">
<a href="classeigen_1_1vectorwiseop#ae92babb33ed5a91eb0c4de80a97eafca">redux</a> (const BinaryOp &amp;func=BinaryOp()) const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">reverse_iterator </td>
<td valign="bottom">
<a href="classeigen_1_1vectorwiseop#aa9592e93b704f7712e8f33631a2efe8f">rend</a> ()</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const_reverse_iterator </td>
<td valign="bottom">
<a href="classeigen_1_1vectorwiseop#afeb3e3ceca37ae0a6e313f80743f767a">rend</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const <a href="classeigen_1_1replicate">ReplicateReturnType</a> </td>
<td valign="bottom">
<a href="classeigen_1_1vectorwiseop#a5f0c8dc9e9c4aeaa2057f15800f5c18c">replicate</a> (<a href="classeigen_1_1vectorwiseop#a4907c654e5810edd98e4162093b19532">Index</a> factor) const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;int Factor&gt; </td></tr> <tr>
<td align="right" valign="top">const <a href="classeigen_1_1replicate">Replicate</a>&lt; ExpressionType, isVertical *Factor+isHorizontal, isHorizontal *Factor+isVertical &gt; </td>
<td valign="bottom">
<a href="classeigen_1_1vectorwiseop#a81bfb88fe6415c7bfd9bdf15ef608aaa">replicate</a> (<a href="classeigen_1_1vectorwiseop#a4907c654e5810edd98e4162093b19532">Index</a> factor=Factor) const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1reverse">ReverseReturnType</a> </td>
<td valign="bottom">
<a href="classeigen_1_1vectorwiseop#ab8caf5367e2bd636536c8a0e0c89fe15">reverse</a> ()</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const <a href="classeigen_1_1reverse">ConstReverseReturnType</a> </td>
<td valign="bottom">
<a href="classeigen_1_1vectorwiseop#aeb0428f561b5757e2c85e8d72022eec1">reverse</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">void </td>
<td valign="bottom">
<a href="classeigen_1_1vectorwiseop#ab9dd7c273eb2ba8defaab2d55156936b">reverseInPlace</a> ()</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const <a href="classeigen_1_1partialreduxexpr">SquaredNormReturnType</a> </td>
<td valign="bottom">
<a href="classeigen_1_1vectorwiseop#a01474cf971473a73c919f6a99323d4f5">squaredNorm</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const <a href="classeigen_1_1partialreduxexpr">StableNormReturnType</a> </td>
<td valign="bottom">
<a href="classeigen_1_1vectorwiseop#add48fd836be98ed280cac23518db0916">stableNorm</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const <a href="classeigen_1_1partialreduxexpr">SumReturnType</a> </td>
<td valign="bottom">
<a href="classeigen_1_1vectorwiseop#a7030fc687c24d687ed7cd70733ba611c">sum</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> </table>
<table> <tr><td colspan="2"></td></tr> <tr>
<td align="right" valign="top">random_access_iterator_type </td>
<td valign="bottom"><a href="classeigen_1_1vectorwiseop#a595c33d2a82427a1159568b0b8438554">const_iterator</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">random_access_iterator_type </td>
<td valign="bottom"><a href="classeigen_1_1vectorwiseop#a9fb8aaf24528efcdac1782aacf99b8dd">iterator</a></td>
</tr> <tr><td colspan="2"> </td></tr> </table>  <a id="a4907c654e5810edd98e4162093b19532"></a> <h2>Index</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <table> <tr> <td>typedef <a href="namespaceeigen#a62e77e0933482dafde8fe197d9a2cfde">Eigen::Index</a> <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::<a href="classeigen_1_1vectorwiseop#a4907c654e5810edd98e4162093b19532">Index</a>
</td> </tr> </table> </div>
<div> <dl>
<dt><b><a href="deprecated#_deprecated000011">Deprecated:</a></b></dt>
<dd>since <a href="namespaceeigen" title="Namespace containing all symbols from the Eigen library.">Eigen</a> 3.3 </dd>
</dl> </div> </div>  <a id="a9c2b4740bf190492bf231d8e244b25c1"></a> <h2>all()</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="classeigen_1_1partialreduxexpr">AllReturnType</a> <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::all </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>a row (or column) vector expression representing whether <b>all</b> coefficients of each respective column (or row) are <code>true</code>. This expression can be assigned to a vector with entries of type <code>bool</code>.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1densebase#ae42ab60296c120e9f45ce3b44e1761a4">DenseBase::all()</a> </dd>
</dl> </div> </div> <a id="a96210c9f83bd375f8ce862bd62ab70e6"></a> <h2>any()</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="classeigen_1_1partialreduxexpr">AnyReturnType</a> <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::any </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>a row (or column) vector expression representing whether <b>at</b> <b>least</b> one coefficient of each respective column (or row) is <code>true</code>. This expression can be assigned to a vector with entries of type <code>bool</code>.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1densebase#abfbf4cb72dd577e62fbe035b1c53e695">DenseBase::any()</a> </dd>
</dl> </div> </div> <a id="abbf3325f535ac011ed61f14ed4330618"></a> <h2>begin() <span>[1/2]</span>
</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1vectorwiseop#a9fb8aaf24528efcdac1782aacf99b8dd">iterator</a> <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::begin </td> <td>(</td> <td></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>returns an iterator to the first row (rowwise) or column (colwise) of the nested expression. </p>
<dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1vectorwiseop#a9d189042b8322e40772d41c63b9d3bb5">end()</a>, <a href="classeigen_1_1vectorwiseop#a7b237a2b46479de5c905d2bcc54f34c4">cbegin()</a> </dd>
</dl> </div> </div> <a id="aaf91f2a57a26e88e7131fcd9c194f93f"></a> <h2>begin() <span>[2/2]</span>
</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1vectorwiseop#a595c33d2a82427a1159568b0b8438554">const_iterator</a> <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::begin </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>const version of <a href="classeigen_1_1vectorwiseop#abbf3325f535ac011ed61f14ed4330618">begin()</a> </p> </div> </div> <a id="a4d2fbc5296470a94379cbcb33bb9c24d"></a> <h2>blueNorm()</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="classeigen_1_1partialreduxexpr">BlueNormReturnType</a> <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::blueNorm </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>a row (or column) vector expression of the norm of each column (or row) of the referenced expression, using Blue's algorithm. This is a vector with real entries, even if the original matrix has complex entries.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>DenseBase::blueNorm() </dd>
</dl> </div> </div> <a id="a7b237a2b46479de5c905d2bcc54f34c4"></a> <h2>cbegin()</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1vectorwiseop#a595c33d2a82427a1159568b0b8438554">const_iterator</a> <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::cbegin </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>const version of <a href="classeigen_1_1vectorwiseop#abbf3325f535ac011ed61f14ed4330618">begin()</a> </p> </div> </div> <a id="a57859b88a32b8b393a427c4cab3581a7"></a> <h2>cend()</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1vectorwiseop#a595c33d2a82427a1159568b0b8438554">const_iterator</a> <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::cend </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>const version of <a href="classeigen_1_1vectorwiseop#a9d189042b8322e40772d41c63b9d3bb5">end()</a> </p> </div> </div> <a id="a5c6b797457895f11a7682b3a16f263bb"></a> <h2>count()</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="classeigen_1_1partialreduxexpr">CountReturnType</a> <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::count </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>a row (or column) vector expression representing the number of <code>true</code> coefficients of each respective column (or row). This expression can be assigned to a vector whose entries have the same type as is used to index entries of the original matrix; for dense matrices, this is <code>std::ptrdiff_t</code> .</dd>
</dl> <p>Example: </p>
<pre data-language="cpp">Matrix3d m = <a href="classeigen_1_1densebase#ae814abb451b48ed872819192dc188c19">Matrix3d::Random</a>();
cout &lt;&lt; <span>"Here is the matrix m:"</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
Matrix&lt;ptrdiff_t, 3, 1&gt; res = (m.array() &gt;= 0.5).rowwise().count();
cout &lt;&lt; <span>"Here is the count of elements larger or equal than 0.5 of each row:"</span> &lt;&lt; endl;
cout &lt;&lt; res &lt;&lt; endl;
</pre>
<p> Output: </p>
<pre>Here is the matrix m:
  0.68  0.597  -0.33
-0.211  0.823  0.536
 0.566 -0.605 -0.444
Here is the count of elements larger or equal than 0.5 of each row:
2
2
1
</pre>
<dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1densebase#a229be090c665b9bf7d1fcdfd1ab6e0c1">DenseBase::count()</a> </dd>
</dl> </div> </div> <a id="aec95725eed4adb5ccf65fbb6e907d12e"></a> <h2>crbegin()</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <table> <tr> <td> <table> <tr> <td>const_reverse_iterator <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::crbegin </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>const version of <a href="classeigen_1_1vectorwiseop#a91a8087eb76e210b07192c81d362dd1e">rbegin()</a> </p> </div> </div> <a id="a23fa202916349d11e476f459543395ef"></a> <h2>crend()</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <table> <tr> <td> <table> <tr> <td>const_reverse_iterator <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::crend </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>const version of <a href="classeigen_1_1vectorwiseop#aa9592e93b704f7712e8f33631a2efe8f">rend()</a> </p> </div> </div> <a id="a9d189042b8322e40772d41c63b9d3bb5"></a> <h2>end() <span>[1/2]</span>
</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1vectorwiseop#a9fb8aaf24528efcdac1782aacf99b8dd">iterator</a> <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::end </td> <td>(</td> <td></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>returns an iterator to the row (resp. column) following the last row (resp. column) of the nested expression </p>
<dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1vectorwiseop#abbf3325f535ac011ed61f14ed4330618">begin()</a>, <a href="classeigen_1_1vectorwiseop#a57859b88a32b8b393a427c4cab3581a7">cend()</a> </dd>
</dl> </div> </div> <a id="ad3b0dcb34bb4903ffa1ab3634188ecff"></a> <h2>end() <span>[2/2]</span>
</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1vectorwiseop#a595c33d2a82427a1159568b0b8438554">const_iterator</a> <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::end </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>const version of <a href="classeigen_1_1vectorwiseop#a9d189042b8322e40772d41c63b9d3bb5">end()</a> </p> </div> </div> <a id="a00c44e033eec33586ae8093a6366da75"></a> <h2>hypotNorm()</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="classeigen_1_1partialreduxexpr">HypotNormReturnType</a> <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::hypotNorm </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>a row (or column) vector expression of the norm of each column (or row) of the referenced expression, avoiding underflow and overflow using a concatenation of hypot() calls. This is a vector with real entries, even if the original matrix has complex entries.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>DenseBase::hypotNorm() </dd>
</dl> </div> </div> <a id="aa9c2cad38085e7f5f9bc2598eff249f1"></a> <h2>lpNorm()</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <div> template&lt;int p&gt; </div> <table> <tr> <td> <table> <tr> <td>const LpNormReturnType&lt;p&gt;::Type <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::lpNorm </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>a row (or column) vector expression of the norm of each column (or row) of the referenced expression. This is a vector with real entries, even if the original matrix has complex entries.</dd>
</dl> <p>Example: </p>
<pre data-language="cpp">Matrix3d m = <a href="classeigen_1_1densebase#ae814abb451b48ed872819192dc188c19">Matrix3d::Random</a>();
cout &lt;&lt; <span>"Here is the matrix m:"</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
cout &lt;&lt; <span>"Here is the norm of each column:"</span> &lt;&lt; endl &lt;&lt; m.colwise().norm() &lt;&lt; endl;
</pre>
<p> Output: </p>
<pre>Here is the matrix m:
  0.68  0.597  -0.33
-0.211  0.823  0.536
 0.566 -0.605 -0.444
Here is the norm of each column:
 0.91  1.18 0.771
</pre>
<dl>
<dt>See also</dt>
<dd>DenseBase::norm() </dd>
</dl> </div> </div> <a id="a6646b584db116c1661b5bb56750bd6f6"></a> <h2>maxCoeff()</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="classeigen_1_1partialreduxexpr">MaxCoeffReturnType</a> <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::maxCoeff </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>a row (or column) vector expression of the largest coefficient of each column (or row) of the referenced expression.</dd>
</dl> <dl>
<dt>Warning</dt>
<dd>the size along the reduction direction must be strictly positive, otherwise an assertion is triggered.</dd> <dd> the result is undefined if <code>*this</code> contains NaN.</dd>
</dl> <p>Example: </p>
<pre data-language="cpp">Matrix3d m = <a href="classeigen_1_1densebase#ae814abb451b48ed872819192dc188c19">Matrix3d::Random</a>();
cout &lt;&lt; <span>"Here is the matrix m:"</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
cout &lt;&lt; <span>"Here is the maximum of each column:"</span> &lt;&lt; endl &lt;&lt; m.colwise().maxCoeff() &lt;&lt; endl;
</pre>
<p> Output: </p>
<pre>Here is the matrix m:
  0.68  0.597  -0.33
-0.211  0.823  0.536
 0.566 -0.605 -0.444
Here is the maximum of each column:
 0.68 0.823 0.536
</pre>
<dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1densebase#a7e6987d106f1cca3ac6ab36d288cc8e1">DenseBase::maxCoeff()</a> </dd>
</dl> </div> </div> <a id="aaf7d867f9e6b74a1bc7f108d646cfa85"></a> <h2>mean()</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <table> <tr> <td> <table> <tr> <td>const MeanReturnType <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::mean </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>a row (or column) vector expression of the mean of each column (or row) of the referenced expression.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1densebase#a21ac6c0419a72ad7a88ea0bc189017d7">DenseBase::mean()</a> </dd>
</dl> </div> </div> <a id="a7d7b8c03d180b126fde0ac212e2b0b76"></a> <h2>minCoeff()</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="classeigen_1_1partialreduxexpr">MinCoeffReturnType</a> <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::minCoeff </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>a row (or column) vector expression of the smallest coefficient of each column (or row) of the referenced expression.</dd>
</dl> <dl>
<dt>Warning</dt>
<dd>the size along the reduction direction must be strictly positive, otherwise an assertion is triggered.</dd> <dd> the result is undefined if <code>*this</code> contains NaN.</dd>
</dl> <p>Example: </p>
<pre data-language="cpp">Matrix3d m = <a href="classeigen_1_1densebase#ae814abb451b48ed872819192dc188c19">Matrix3d::Random</a>();
cout &lt;&lt; <span>"Here is the matrix m:"</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
cout &lt;&lt; <span>"Here is the minimum of each column:"</span> &lt;&lt; endl &lt;&lt; m.colwise().minCoeff() &lt;&lt; endl;
</pre>
<p> Output: </p>
<pre>Here is the matrix m:
  0.68  0.597  -0.33
-0.211  0.823  0.536
 0.566 -0.605 -0.444
Here is the minimum of each column:
-0.211 -0.605 -0.444
</pre>
<dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1densebase#a0739f9c868c331031c7810e21838dcb2">DenseBase::minCoeff()</a> </dd>
</dl> </div> </div> <a id="af726d1dfd9a7a67b76e639db1a9f352e"></a> <h2>norm()</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="classeigen_1_1cwiseunaryop">NormReturnType</a> <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::norm </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>a row (or column) vector expression of the norm of each column (or row) of the referenced expression. This is a vector with real entries, even if the original matrix has complex entries.</dd>
</dl> <p>Example: </p>
<pre data-language="cpp">Matrix3d m = <a href="classeigen_1_1densebase#ae814abb451b48ed872819192dc188c19">Matrix3d::Random</a>();
cout &lt;&lt; <span>"Here is the matrix m:"</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
cout &lt;&lt; <span>"Here is the norm of each column:"</span> &lt;&lt; endl &lt;&lt; m.colwise().norm() &lt;&lt; endl;
</pre>
<p> Output: </p>
<pre>Here is the matrix m:
  0.68  0.597  -0.33
-0.211  0.823  0.536
 0.566 -0.605 -0.444
Here is the norm of each column:
 0.91  1.18 0.771
</pre>
<dl>
<dt>See also</dt>
<dd>DenseBase::norm() </dd>
</dl> </div> </div> <a id="adb1084153780dc8d2c062fee97651a45"></a> <h2>normalize()</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <table> <tr> <td> <table> <tr> <td>void <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::normalize </td> <td>(</td> <td></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Normalize in-place each row or columns of the referenced matrix. </p>
<dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1matrixbase#ad16303c47ba36f7a41ea264cb26bceb6">MatrixBase::normalize()</a>, <a href="classeigen_1_1vectorwiseop#aca6ac44a9bf819d5d64c2cb54bf38095">normalized()</a> </dd>
</dl> </div> </div> <a id="aca6ac44a9bf819d5d64c2cb54bf38095"></a> <h2>normalized()</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1cwisebinaryop">CwiseBinaryOp</a>&lt;internal::scalar_quotient_op&lt;Scalar&gt;, const ExpressionTypeNestedCleaned, const typename OppositeExtendedType&lt;<a href="classeigen_1_1cwiseunaryop">NormReturnType</a>&gt;::Type&gt; <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::normalized </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>an expression where each column (or row) of the referenced matrix are normalized. The referenced matrix is <b>not</b> modified. </dd>
</dl> <dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1matrixbase#a5cf2fd4c57e59604fd4116158fd34308">MatrixBase::normalized()</a>, <a href="classeigen_1_1vectorwiseop#adb1084153780dc8d2c062fee97651a45">normalize()</a> </dd>
</dl> </div> </div> <a id="a25ca4c1e409897feca669dee811533c9"></a> <h2>operator*()</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <div> template&lt;typename OtherDerived &gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1cwisebinaryop">CwiseBinaryOp</a>&lt;internal::scalar_product_op&lt;Scalar&gt;, const ExpressionTypeNestedCleaned, const typename ExtendedType&lt;OtherDerived&gt;::Type&gt; <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::operator* </td> <td>(</td> <td>const <a href="classeigen_1_1densebase">DenseBase</a>&lt; OtherDerived &gt; &amp; </td> <td><em>other</em></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Returns the expression where each subvector is the product of the vector <em>other</em> by the corresponding subvector of <code>*this</code> </p> </div> </div> <a id="acef518a77a8947c6726ba30d56dd67cb"></a> <h2>operator*=()</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <div> template&lt;typename OtherDerived &gt; </div> <table> <tr> <td> <table> <tr> <td>ExpressionType&amp; <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::operator*= </td> <td>(</td> <td>const <a href="classeigen_1_1densebase">DenseBase</a>&lt; OtherDerived &gt; &amp; </td> <td><em>other</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Multiples each subvector of <code>*this</code> by the vector <em>other</em> </p> </div> </div> <a id="a713694459d81b76e4f2a78e4d169f8d6"></a> <h2>operator+()</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <div> template&lt;typename OtherDerived &gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1cwisebinaryop">CwiseBinaryOp</a>&lt;internal::scalar_sum_op&lt;Scalar,typename OtherDerived::Scalar&gt;, const ExpressionTypeNestedCleaned, const typename ExtendedType&lt;OtherDerived&gt;::Type&gt; <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::operator+ </td> <td>(</td> <td>const <a href="classeigen_1_1densebase">DenseBase</a>&lt; OtherDerived &gt; &amp; </td> <td><em>other</em></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Returns the expression of the sum of the vector <em>other</em> to each subvector of <code>*this</code> </p> </div> </div> <a id="a23ce2522d11c3362ca22252b2876812b"></a> <h2>operator+=()</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <div> template&lt;typename OtherDerived &gt; </div> <table> <tr> <td> <table> <tr> <td>ExpressionType&amp; <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::operator+= </td> <td>(</td> <td>const <a href="classeigen_1_1densebase">DenseBase</a>&lt; OtherDerived &gt; &amp; </td> <td><em>other</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Adds the vector <em>other</em> to each subvector of <code>*this</code> </p> </div> </div> <a id="a5e60616620df132d665b301bb9a304c4"></a> <h2>operator-()</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <div> template&lt;typename OtherDerived &gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1cwisebinaryop">CwiseBinaryOp</a>&lt;internal::scalar_difference_op&lt;Scalar,typename OtherDerived::Scalar&gt;, const ExpressionTypeNestedCleaned, const typename ExtendedType&lt;OtherDerived&gt;::Type&gt; <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::operator- </td> <td>(</td> <td>const <a href="classeigen_1_1densebase">DenseBase</a>&lt; OtherDerived &gt; &amp; </td> <td><em>other</em></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Returns the expression of the difference between each subvector of <code>*this</code> and the vector <em>other</em> </p> </div> </div> <a id="a6bb3a7315617f86f0c28ac05816cf6e3"></a> <h2>operator-=()</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <div> template&lt;typename OtherDerived &gt; </div> <table> <tr> <td> <table> <tr> <td>ExpressionType&amp; <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::operator-= </td> <td>(</td> <td>const <a href="classeigen_1_1densebase">DenseBase</a>&lt; OtherDerived &gt; &amp; </td> <td><em>other</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Substracts the vector <em>other</em> to each subvector of <code>*this</code> </p> </div> </div> <a id="aa154a8407885a9ad51504180f6d7a163"></a> <h2>operator/()</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <div> template&lt;typename OtherDerived &gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1cwisebinaryop">CwiseBinaryOp</a>&lt;internal::scalar_quotient_op&lt;Scalar&gt;, const ExpressionTypeNestedCleaned, const typename ExtendedType&lt;OtherDerived&gt;::Type&gt; <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::operator/ </td> <td>(</td> <td>const <a href="classeigen_1_1densebase">DenseBase</a>&lt; OtherDerived &gt; &amp; </td> <td><em>other</em></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Returns the expression where each subvector is the quotient of the corresponding subvector of <code>*this</code> by the vector <em>other</em> </p> </div> </div> <a id="a9efa0b81915c31535a929a46a79cab2b"></a> <h2>operator/=()</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <div> template&lt;typename OtherDerived &gt; </div> <table> <tr> <td> <table> <tr> <td>ExpressionType&amp; <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::operator/= </td> <td>(</td> <td>const <a href="classeigen_1_1densebase">DenseBase</a>&lt; OtherDerived &gt; &amp; </td> <td><em>other</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Divides each subvector of <code>*this</code> by the vector <em>other</em> </p> </div> </div> <a id="a7999eb8f50bb19ade54f3212d3c79680"></a> <h2>operator=()</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <div> template&lt;typename OtherDerived &gt; </div> <table> <tr> <td> <table> <tr> <td>ExpressionType&amp; <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::operator= </td> <td>(</td> <td>const <a href="classeigen_1_1densebase">DenseBase</a>&lt; OtherDerived &gt; &amp; </td> <td><em>other</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Copies the vector <em>other</em> to each subvector of <code>*this</code> </p> </div> </div> <a id="a01bcd17504f30b55b4910ddb75598f79"></a> <h2>prod()</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="classeigen_1_1partialreduxexpr">ProdReturnType</a> <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::prod </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>a row (or column) vector expression of the product of each column (or row) of the referenced expression.</dd>
</dl> <p>Example: </p>
<pre data-language="cpp">Matrix3d m = <a href="classeigen_1_1densebase#ae814abb451b48ed872819192dc188c19">Matrix3d::Random</a>();
cout &lt;&lt; <span>"Here is the matrix m:"</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
cout &lt;&lt; <span>"Here is the product of each row:"</span> &lt;&lt; endl &lt;&lt; m.rowwise().prod() &lt;&lt; endl;
</pre>
<p> Output: </p>
<pre>Here is the matrix m:
  0.68  0.597  -0.33
-0.211  0.823  0.536
 0.566 -0.605 -0.444
Here is the product of each row:
 -0.134
-0.0933
  0.152
</pre>
<dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1densebase#af119d9a4efe5a15cd83c1ccdf01b3a4f">DenseBase::prod()</a> </dd>
</dl> </div> </div> <a id="a91a8087eb76e210b07192c81d362dd1e"></a> <h2>rbegin() <span>[1/2]</span>
</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <table> <tr> <td> <table> <tr> <td>reverse_iterator <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::rbegin </td> <td>(</td> <td></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>returns a reverse iterator to the last row (rowwise) or column (colwise) of the nested expression. </p>
<dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1vectorwiseop#aa9592e93b704f7712e8f33631a2efe8f">rend()</a>, <a href="classeigen_1_1vectorwiseop#aec95725eed4adb5ccf65fbb6e907d12e">crbegin()</a> </dd>
</dl> </div> </div> <a id="aa73e8a0230fcc049346057ef1a6efe02"></a> <h2>rbegin() <span>[2/2]</span>
</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <table> <tr> <td> <table> <tr> <td>const_reverse_iterator <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::rbegin </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>const version of <a href="classeigen_1_1vectorwiseop#a91a8087eb76e210b07192c81d362dd1e">rbegin()</a> </p> </div> </div> <a id="ae92babb33ed5a91eb0c4de80a97eafca"></a> <h2>redux()</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <div> template&lt;typename BinaryOp &gt; </div> <table> <tr> <td> <table> <tr> <td>const ReduxReturnType&lt;BinaryOp&gt;::Type <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::redux </td> <td>(</td> <td>const BinaryOp &amp; </td> <td>
<em>func</em> = <code>BinaryOp()</code>
</td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>a row or column vector expression of <code>*this</code> reduxed by <em>func</em> </dd>
</dl> <p>The template parameter <em>BinaryOp</em> is the type of the functor of the custom redux operator. Note that func must be an associative operator.</p> <dl>
<dt>Warning</dt>
<dd>the size along the reduction direction must be strictly positive, otherwise an assertion is triggered.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>class <a href="classeigen_1_1vectorwiseop" title="Pseudo expression providing broadcasting and partial reduction operations.">VectorwiseOp</a>, <a href="classeigen_1_1densebase#a1c0e1b6067ec1de6cb8799da55aa7d30">DenseBase::colwise()</a>, <a href="classeigen_1_1densebase#a6daa3a3156ca0e0722bf78638e1c7f28">DenseBase::rowwise()</a> </dd>
</dl> </div> </div> <a id="aa9592e93b704f7712e8f33631a2efe8f"></a> <h2>rend() <span>[1/2]</span>
</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <table> <tr> <td> <table> <tr> <td>reverse_iterator <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::rend </td> <td>(</td> <td></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>returns a reverse iterator to the row (resp. column) before the first row (resp. column) of the nested expression </p>
<dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1vectorwiseop#abbf3325f535ac011ed61f14ed4330618">begin()</a>, <a href="classeigen_1_1vectorwiseop#a57859b88a32b8b393a427c4cab3581a7">cend()</a> </dd>
</dl> </div> </div> <a id="afeb3e3ceca37ae0a6e313f80743f767a"></a> <h2>rend() <span>[2/2]</span>
</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <table> <tr> <td> <table> <tr> <td>const_reverse_iterator <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::rend </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>const version of <a href="classeigen_1_1vectorwiseop#aa9592e93b704f7712e8f33631a2efe8f">rend()</a> </p> </div> </div> <a id="a5f0c8dc9e9c4aeaa2057f15800f5c18c"></a> <h2>replicate() <span>[1/2]</span>
</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <table> <tr> <td>const <a href="classeigen_1_1vectorwiseop">VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::<a href="classeigen_1_1replicate">ReplicateReturnType</a> <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::replicate </td> <td>(</td> <td>
<a href="classeigen_1_1vectorwiseop#a4907c654e5810edd98e4162093b19532">Index</a> </td> <td><em>factor</em></td>
<td>)</td> <td> const</td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>an expression of the replication of each column (or row) of <code>*this</code> </dd>
</dl> <p>Example: </p>
<pre data-language="cpp">Vector3i v = <a href="classeigen_1_1densebase#ae814abb451b48ed872819192dc188c19">Vector3i::Random</a>();
cout &lt;&lt; <span>"Here is the vector v:"</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;
cout &lt;&lt; <span>"v.rowwise().replicate(5) = ..."</span> &lt;&lt; endl;
cout &lt;&lt; v.rowwise().replicate(5) &lt;&lt; endl;
</pre>
<p> Output: </p>
<pre>Here is the vector v:
 7
-2
 6
v.rowwise().replicate(5) = ...
 7  7  7  7  7
-2 -2 -2 -2 -2
 6  6  6  6  6
</pre>
<dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1vectorwiseop#a5f0c8dc9e9c4aeaa2057f15800f5c18c">VectorwiseOp::replicate()</a>, <a href="classeigen_1_1densebase#a60dadfe80b813d808e91e4521c722a8e">DenseBase::replicate()</a>, class <a href="classeigen_1_1replicate" title="Expression of the multiple replication of a matrix or vector.">Replicate</a> </dd>
</dl> </div> </div> <a id="a81bfb88fe6415c7bfd9bdf15ef608aaa"></a> <h2>replicate() <span>[2/2]</span>
</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <div> template&lt;int Factor&gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="classeigen_1_1replicate">Replicate</a>&lt;ExpressionType,isVertical*Factor+isHorizontal,isHorizontal*Factor+isVertical&gt; <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::replicate </td> <td>(</td> <td>
<a href="classeigen_1_1vectorwiseop#a4907c654e5810edd98e4162093b19532">Index</a> </td> <td>
<em>factor</em> = <code>Factor</code>
</td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>an expression of the replication of each column (or row) of <code>*this</code> </dd>
</dl> <p>Example: </p>
<pre data-language="cpp">MatrixXi m = <a href="classeigen_1_1densebase#ae814abb451b48ed872819192dc188c19">MatrixXi::Random</a>(2,3);
cout &lt;&lt; <span>"Here is the matrix m:"</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
cout &lt;&lt; <span>"m.colwise().replicate&lt;3&gt;() = ..."</span> &lt;&lt; endl;
cout &lt;&lt; m.colwise().replicate&lt;3&gt;() &lt;&lt; endl;
</pre>
<p> Output: </p>
<pre>Here is the matrix m:
 7  6  9
-2  6 -6
m.colwise().replicate&lt;3&gt;() = ...
 7  6  9
-2  6 -6
 7  6  9
-2  6 -6
 7  6  9
-2  6 -6
</pre>
<dl>
<dt>See also</dt>
<dd>VectorwiseOp::replicate(Index), <a href="classeigen_1_1densebase#a60dadfe80b813d808e91e4521c722a8e">DenseBase::replicate()</a>, class <a href="classeigen_1_1replicate" title="Expression of the multiple replication of a matrix or vector.">Replicate</a> </dd>
</dl> </div> </div> <a id="ab8caf5367e2bd636536c8a0e0c89fe15"></a> <h2>reverse() <span>[1/2]</span>
</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1reverse">ReverseReturnType</a> <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::reverse </td> <td>(</td> <td></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>a writable matrix expression where each column (or row) are reversed.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1vectorwiseop#aeb0428f561b5757e2c85e8d72022eec1">reverse() const </a> </dd>
</dl> </div> </div> <a id="aeb0428f561b5757e2c85e8d72022eec1"></a> <h2>reverse() <span>[2/2]</span>
</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="classeigen_1_1reverse">ConstReverseReturnType</a> <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::reverse </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>a matrix expression where each column (or row) are reversed.</dd>
</dl> <p>Example: </p>
<pre data-language="cpp">MatrixXi m = <a href="classeigen_1_1densebase#ae814abb451b48ed872819192dc188c19">MatrixXi::Random</a>(3,4);
cout &lt;&lt; <span>"Here is the matrix m:"</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
cout &lt;&lt; <span>"Here is the rowwise reverse of m:"</span> &lt;&lt; endl &lt;&lt; m.rowwise().reverse() &lt;&lt; endl;
cout &lt;&lt; <span>"Here is the colwise reverse of m:"</span> &lt;&lt; endl &lt;&lt; m.colwise().reverse() &lt;&lt; endl;
 
cout &lt;&lt; <span>"Here is the coefficient (1,0) in the rowise reverse of m:"</span> &lt;&lt; endl
&lt;&lt; m.rowwise().reverse()(1,0) &lt;&lt; endl;
cout &lt;&lt; <span>"Let us overwrite this coefficient with the value 4."</span> &lt;&lt; endl;
<span>//m.colwise().reverse()(1,0) = 4;</span>
cout &lt;&lt; <span>"Now the matrix m is:"</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
</pre>
<p> Output: </p>
<pre>Here is the matrix m:
 7  6 -3  1
-2  9  6  0
 6 -6 -5  3
Here is the rowwise reverse of m:
 1 -3  6  7
 0  6  9 -2
 3 -5 -6  6
Here is the colwise reverse of m:
 6 -6 -5  3
-2  9  6  0
 7  6 -3  1
Here is the coefficient (1,0) in the rowise reverse of m:
0
Let us overwrite this coefficient with the value 4.
Now the matrix m is:
 7  6 -3  1
-2  9  6  0
 6 -6 -5  3
</pre>
<dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1densebase#a38ea394036d8b096abf322469c80198f">DenseBase::reverse()</a> </dd>
</dl> </div> </div> <a id="ab9dd7c273eb2ba8defaab2d55156936b"></a> <h2>reverseInPlace()</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <table> <tr> <td> <table> <tr> <td>void <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::reverseInPlace</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>This is the "in place" version of <a href="classeigen_1_1vectorwiseop#aeb0428f561b5757e2c85e8d72022eec1">VectorwiseOp::reverse</a>: it reverses each column or row of <code>*this</code>.</p> <p>In most cases it is probably better to simply use the reversed expression of a matrix. However, when reversing the matrix data itself is really needed, then this "in-place" version is probably the right choice because it provides the following additional benefits:</p>
<ul> <li>less error prone: doing the same operation with .<a href="classeigen_1_1vectorwiseop#ab8caf5367e2bd636536c8a0e0c89fe15">reverse()</a> requires special care: <pre data-language="cpp">m = m.reverse().eval(); 
</pre>
</li> <li>this API enables reverse operations without the need for a temporary</li> </ul> <dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1densebase#adb8045155ea45f7961fc2a5170e1d921">DenseBase::reverseInPlace()</a>, <a href="classeigen_1_1vectorwiseop#ab8caf5367e2bd636536c8a0e0c89fe15">reverse()</a> </dd>
</dl> </div> </div> <a id="a01474cf971473a73c919f6a99323d4f5"></a> <h2>squaredNorm()</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="classeigen_1_1partialreduxexpr">SquaredNormReturnType</a> <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::squaredNorm </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>a row (or column) vector expression of the squared norm of each column (or row) of the referenced expression. This is a vector with real entries, even if the original matrix has complex entries.</dd>
</dl> <p>Example: </p>
<pre data-language="cpp">Matrix3d m = <a href="classeigen_1_1densebase#ae814abb451b48ed872819192dc188c19">Matrix3d::Random</a>();
cout &lt;&lt; <span>"Here is the matrix m:"</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
cout &lt;&lt; <span>"Here is the square norm of each row:"</span> &lt;&lt; endl &lt;&lt; m.rowwise().squaredNorm() &lt;&lt; endl;
</pre>
<p> Output: </p>
<pre>Here is the matrix m:
  0.68  0.597  -0.33
-0.211  0.823  0.536
 0.566 -0.605 -0.444
Here is the square norm of each row:
0.928
 1.01
0.884
</pre>
<dl>
<dt>See also</dt>
<dd>DenseBase::squaredNorm() </dd>
</dl> </div> </div> <a id="add48fd836be98ed280cac23518db0916"></a> <h2>stableNorm()</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="classeigen_1_1partialreduxexpr">StableNormReturnType</a> <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::stableNorm </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>a row (or column) vector expression of the norm of each column (or row) of the referenced expression, avoiding underflow and overflow. This is a vector with real entries, even if the original matrix has complex entries.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>DenseBase::stableNorm() </dd>
</dl> </div> </div> <a id="a7030fc687c24d687ed7cd70733ba611c"></a> <h2>sum()</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="classeigen_1_1partialreduxexpr">SumReturnType</a> <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::sum </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>a row (or column) vector expression of the sum of each column (or row) of the referenced expression.</dd>
</dl> <p>Example: </p>
<pre data-language="cpp">Matrix3d m = <a href="classeigen_1_1densebase#ae814abb451b48ed872819192dc188c19">Matrix3d::Random</a>();
cout &lt;&lt; <span>"Here is the matrix m:"</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
cout &lt;&lt; <span>"Here is the sum of each row:"</span> &lt;&lt; endl &lt;&lt; m.rowwise().sum() &lt;&lt; endl;
</pre>
<p> Output: </p>
<pre>Here is the matrix m:
  0.68  0.597  -0.33
-0.211  0.823  0.536
 0.566 -0.605 -0.444
Here is the sum of each row:
 0.948
  1.15
-0.483
</pre>
<dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1densebase#addd7080d5c202795820e361768d0140c">DenseBase::sum()</a> </dd>
</dl> </div> </div>  <a id="a595c33d2a82427a1159568b0b8438554"></a> <h2>const_iterator</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <table> <tr> <td>random_access_iterator_type <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::const_iterator</td> </tr> </table> </div>
<div> <p>This is the const version of iterator (aka read-only) </p> </div> </div> <a id="a9fb8aaf24528efcdac1782aacf99b8dd"></a> <h2>iterator</h2> <div> <div> <div> template&lt;typename ExpressionType , int Direction&gt; </div> <table> <tr> <td>random_access_iterator_type <a href="classeigen_1_1vectorwiseop">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::iterator</td> </tr> </table> </div>
<div> <p>STL-like <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator">RandomAccessIterator</a> iterator type over the columns or rows as returned by the <a href="classeigen_1_1vectorwiseop#abbf3325f535ac011ed61f14ed4330618">begin()</a> and <a href="classeigen_1_1vectorwiseop#a9d189042b8322e40772d41c63b9d3bb5">end()</a> methods. </p> </div> </div> <hr>The documentation for this class was generated from the following files:<ul> <li><a href="https://eigen.tuxfamily.org/dox/VectorwiseOp_8h_source.html">VectorwiseOp.h</a></li> <li><a href="https://eigen.tuxfamily.org/dox/Replicate_8h_source.html">Replicate.h</a></li> <li><a href="https://eigen.tuxfamily.org/dox/Reverse_8h_source.html">Reverse.h</a></li> <li><a href="https://eigen.tuxfamily.org/dox/Homogeneous_8h_source.html">Homogeneous.h</a></li> <li><a href="https://eigen.tuxfamily.org/dox/OrthoMethods_8h_source.html">OrthoMethods.h</a></li> </ul> </div> <div class="_attribution">
  <p class="_attribution-p">
     Eigen.<br>Licensed under the MPL2 License.<br>
    <a href="https://eigen.tuxfamily.org/dox/classEigen_1_1VectorwiseOp.html" class="_attribution-link">https://eigen.tuxfamily.org/dox/classEigen_1_1VectorwiseOp.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
