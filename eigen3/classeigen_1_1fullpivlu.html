
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Eigen&#58;&#58;FullPivLU - Eigen3 - W3cubDocs</title>
  
  <meta name="description" content=" LU decomposition of a matrix with complete pivoting, and related features. ">
  <meta name="keywords" content="eigen, fullpivlu, eigen3">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/eigen3/classeigen_1_1fullpivlu.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-f16eecbe420d8b2925d31ffbb21d05646497ecbd9515f08ffe69e9bba7332f5657accc7003c7f6c72cb4a132171acf171b359ae3bae4ae5660ddfb1718f88c67.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/eigen3.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/eigen3/" class="_nav-link" title="" style="margin-left:0;">Eigen3</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _eigen3">
				
				
<h1>Eigen::FullPivLU</h1>      <div>  <div>
<h3>template&lt;typename _MatrixType&gt;<br> class Eigen::FullPivLU&lt; _MatrixType &gt;</h3> <p>LU decomposition of a matrix with complete pivoting, and related features. </p> <dl>
<dt>Template Parameters</dt>
<dd> <table> <tr>
<td>_MatrixType</td>
<td>the type of the matrix of which we are computing the LU decomposition</td>
</tr> </table> </dd> </dl> <p>This class represents a LU decomposition of any matrix, with complete pivoting: the matrix A is decomposed as \( A = P^{-1} L U Q^{-1} \) where L is unit-lower-triangular, U is upper-triangular, and P and Q are permutation matrices. This is a rank-revealing LU decomposition. The eigenvalues (diagonal coefficients) of U are sorted in such a way that any zeros are at the end.</p> <p>This decomposition provides the generic approach to solving systems of linear equations, computing the rank, invertibility, inverse, kernel, and determinant.</p> <p>This LU decomposition is very stable and well tested with large matrices. However there are use cases where the SVD decomposition is inherently more stable and/or flexible. For example, when computing the kernel of a matrix, working with the SVD allows to select the smallest singular values of the matrix, something that the LU decomposition doesn't see.</p> <p>The data of the LU decomposition can be directly accessed through the methods <a href="classeigen_1_1fullpivlu#afea0b8fc707a9097d46fe358cb18bbff">matrixLU()</a>, <a href="classeigen_1_1fullpivlu#ad8f1d7266a434c524d3e0dbcc7a0f588">permutationP()</a>, <a href="classeigen_1_1fullpivlu#a8d18190c7618de271cba7293f0493a36">permutationQ()</a>.</p> <p>As an example, here is how the original matrix can be retrieved: </p>
<pre data-language="cpp"><span>typedef</span> Matrix&lt;double, 5, 3&gt; Matrix5x3;
<span>typedef</span> Matrix&lt;double, 5, 5&gt; Matrix5x5;
Matrix5x3 m = Matrix5x3::Random();
cout &lt;&lt; <span>"Here is the matrix m:"</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
<a href="classeigen_1_1fullpivlu">Eigen::FullPivLU&lt;Matrix5x3&gt;</a> lu(m);
cout &lt;&lt; <span>"Here is, up to permutations, its LU decomposition matrix:"</span>
     &lt;&lt; endl &lt;&lt; lu.matrixLU() &lt;&lt; endl;
cout &lt;&lt; <span>"Here is the L part:"</span> &lt;&lt; endl;
Matrix5x5 l = Matrix5x5::Identity();
l.block&lt;5,3&gt;(0,0).triangularView&lt;StrictlyLower&gt;() = lu.matrixLU();
cout &lt;&lt; l &lt;&lt; endl;
cout &lt;&lt; <span>"Here is the U part:"</span> &lt;&lt; endl;
Matrix5x3 u = lu.matrixLU().triangularView&lt;<a href="group__enums#gga39e3366ff5554d731e7dc8bb642f83cdafca2ccebb604f171656deb53e8c083c1">Upper</a>&gt;();
cout &lt;&lt; u &lt;&lt; endl;
cout &lt;&lt; <span>"Let us now reconstruct the original matrix m:"</span> &lt;&lt; endl;
cout &lt;&lt; lu.permutationP().inverse() * l * u * lu.permutationQ().inverse() &lt;&lt; endl;</pre>
<p> Output: </p>
<pre>Here is the matrix m:
   0.68  -0.605 -0.0452
 -0.211   -0.33   0.258
  0.566   0.536   -0.27
  0.597  -0.444  0.0268
  0.823   0.108   0.904
Here is, up to permutations, its LU decomposition matrix:
 0.904  0.823  0.108
-0.299  0.812  0.569
 -0.05  0.888   -1.1
0.0296  0.705  0.768
 0.285 -0.549 0.0436
Here is the L part:
     1      0      0      0      0
-0.299      1      0      0      0
 -0.05  0.888      1      0      0
0.0296  0.705  0.768      1      0
 0.285 -0.549 0.0436      0      1
Here is the U part:
0.904 0.823 0.108
    0 0.812 0.569
    0     0  -1.1
    0     0     0
    0     0     0
Let us now reconstruct the original matrix m:
   0.68  -0.605 -0.0452
 -0.211   -0.33   0.258
  0.566   0.536   -0.27
  0.597  -0.444  0.0268
  0.823   0.108   0.904
</pre>
<p>This class supports the <a href="group__inplacedecomposition">inplace decomposition </a> mechanism.</p> <dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1matrixbase#a25da97d31acab0ee5d9d13bdbb0569da">MatrixBase::fullPivLu()</a>, <a href="classeigen_1_1matrixbase#a7ad8f77004bb956b603bb43fd2e3c061">MatrixBase::determinant()</a>, <a href="classeigen_1_1matrixbase#a7712eb69e8ea3c8f7b8da1c44dbdeebf">MatrixBase::inverse()</a> </dd>
</dl> </div> <div id="dynsection-0-summary" style="display:block;"> </div> <div id="dynsection-0-content" style="display:none;"> <div><img src="data:image/png;base64,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" border="0" usemap="#aEigen_1_1FullPivLU_3_01__MatrixType_01_4_inherit__map" alt="Inheritance graph"></div> <map name="aEigen_1_1FullPivLU_3_01__MatrixType_01_4_inherit__map" id="aEigen_1_1FullPivLU_3_01__MatrixType_01_4_inherit__map"> <area shape="rect" title="LU decomposition of a matrix with complete pivoting, and related features." alt="" coords="5,535,211,964"> <area shape="rect" href="classEigen_1_1SolverBase.html" title=" " alt="" coords="13,292,203,487"> <area shape="rect" href="structEigen_1_1EigenBase.html" title=" " alt="" coords="11,5,205,244"> </map> </div> <table> <tr><td colspan="2"></td></tr> <tr><td colspan="2">template&lt;typename InputType &gt; </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1fullpivlu">FullPivLU</a> &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivlu#a0a3c3b1bbafa31a03567a4573ebabc79">compute</a> (const <a href="structeigen_1_1eigenbase">EigenBase</a>&lt; InputType &gt; &amp;matrix)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">internal::traits&lt; MatrixType &gt;::Scalar </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivlu#a71654e5c60a26407ecccfaa5b34bb0aa">determinant</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="structeigen_1_1eigenbase#a554f30542cc2316add4b1ea0a492ff02">Index</a> </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivlu#a64e191225834e91161ea53ad4b78167b">dimensionOfKernel</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top"> </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivlu#af225528d1c6e623a2b1dce091907d13e">FullPivLU</a> ()</td>
</tr> <tr>
<td> </td>
<td>Default Constructor. <a href="classeigen_1_1fullpivlu#af225528d1c6e623a2b1dce091907d13e">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename InputType &gt; </td></tr> <tr>
<td align="right" valign="top"> </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivlu#a31a6a984478a9f721f367667fe4c5ab1">FullPivLU</a> (const <a href="structeigen_1_1eigenbase">EigenBase</a>&lt; InputType &gt; &amp;matrix)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename InputType &gt; </td></tr> <tr>
<td align="right" valign="top"> </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivlu#a3e903b9f401e3fc5d1ca7c6951c76185">FullPivLU</a> (<a href="structeigen_1_1eigenbase">EigenBase</a>&lt; InputType &gt; &amp;matrix)</td>
</tr> <tr>
<td> </td>
<td>Constructs a LU factorization from a given matrix. <a href="classeigen_1_1fullpivlu#a3e903b9f401e3fc5d1ca7c6951c76185">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top"> </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivlu#ae83ebd2a24088f04e3ac835b0dc001e1">FullPivLU</a> (<a href="structeigen_1_1eigenbase#a554f30542cc2316add4b1ea0a492ff02">Index</a> rows, <a href="structeigen_1_1eigenbase#a554f30542cc2316add4b1ea0a492ff02">Index</a> cols)</td>
</tr> <tr>
<td> </td>
<td>Default Constructor with memory preallocation. <a href="classeigen_1_1fullpivlu#ae83ebd2a24088f04e3ac835b0dc001e1">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const internal::image_retval&lt; <a href="classeigen_1_1fullpivlu">FullPivLU</a> &gt; </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivlu#a0893985d2dab367baa6e57c6fd0c4956">image</a> (const MatrixType &amp;originalMatrix) const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const <a href="classeigen_1_1inverse">Inverse</a>&lt; <a href="classeigen_1_1fullpivlu">FullPivLU</a> &gt; </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivlu#ae6f4bb55f859f6353f99cf15ecff4b25">inverse</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">bool </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivlu#ab13992c852aa593461d9b81790b56667">isInjective</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">bool </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivlu#afdf2579c93473650f2ef2a47a376c4a0">isInvertible</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">bool </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivlu#a1f6222875fc3a181ee1544b9b36dfda5">isSurjective</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const internal::kernel_retval&lt; <a href="classeigen_1_1fullpivlu">FullPivLU</a> &gt; </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivlu#a70f52eeb2cd07dfbf790fce106fb4015">kernel</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const MatrixType &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivlu#afea0b8fc707a9097d46fe358cb18bbff">matrixLU</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">RealScalar </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivlu#abced9f280f5fc49c2e62605c782b237b">maxPivot</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="structeigen_1_1eigenbase#a554f30542cc2316add4b1ea0a492ff02">Index</a> </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivlu#aa71132a751ad3c78178e33d6b2987400">nonzeroPivots</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const <a href="classeigen_1_1permutationmatrix">PermutationPType</a> &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivlu#ad8f1d7266a434c524d3e0dbcc7a0f588">permutationP</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const <a href="classeigen_1_1permutationmatrix">PermutationQType</a> &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivlu#a8d18190c7618de271cba7293f0493a36">permutationQ</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="structeigen_1_1eigenbase#a554f30542cc2316add4b1ea0a492ff02">Index</a> </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivlu#a67a870aa69e699e058d04802ba0bdad9">rank</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">RealScalar </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivlu#a0bc63f910960dc3e35acecc8442025b6">rcond</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">MatrixType </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivlu#a191a4f598b0c192a83ab48984e87ee51">reconstructedMatrix</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1fullpivlu">FullPivLU</a> &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivlu#a414592d82de98f5bd075965caf56d681">setThreshold</a> (const RealScalar &amp;<a href="classeigen_1_1fullpivlu#ad77539203694f2d85ff7d11616e5a0a5">threshold</a>)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1fullpivlu">FullPivLU</a> &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivlu#a1b5e30add3dfb6625da1213d68418f44">setThreshold</a> (Default_t)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename Rhs &gt; </td></tr> <tr>
<td align="right" valign="top">const <a href="classeigen_1_1solve">Solve</a>&lt; <a href="classeigen_1_1fullpivlu">FullPivLU</a>, Rhs &gt; </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivlu#af563471f6f3283fd10779ef02dd0b748">solve</a> (const <a href="classeigen_1_1matrixbase">MatrixBase</a>&lt; Rhs &gt; &amp;b) const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">RealScalar </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivlu#ad77539203694f2d85ff7d11616e5a0a5">threshold</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classEigen_1_1SolverBase')">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJAQMAAADaX5RTAAAABlBMVEVHcEx6k8V3LoYxAAAAAXRSTlMAQObYZgAAABxJREFUCNdj4GBg4GFg4GNg4AeiBhDJBxbhYAAADMkA8rytjikAAAAASUVORK5CYII=" alt="-"> Public Member Functions inherited from <a href="classeigen_1_1solverbase">Eigen::SolverBase&lt; FullPivLU&lt; _MatrixType &gt; &gt;</a>
</td></tr> <tr>
<td align="right" valign="top">AdjointReturnType </td>
<td valign="bottom">
<a href="classeigen_1_1solverbase#a05a3686a89888681c8e0c2bcab6d1ce5">adjoint</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1fullpivlu">FullPivLU</a>&lt; _MatrixType &gt; &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1solverbase#a1fbabe7f12bcbfba3b9a448b1f5e46fa">derived</a> ()</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const <a href="classeigen_1_1fullpivlu">FullPivLU</a>&lt; _MatrixType &gt; &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1solverbase#afd4f3f1c57b7594b96a7e30f2974ea2e">derived</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const <a href="classeigen_1_1solve">Solve</a>&lt; <a href="classeigen_1_1fullpivlu">FullPivLU</a>&lt; _MatrixType &gt;, Rhs &gt; </td>
<td valign="bottom">
<a href="classeigen_1_1solverbase#a7fd647d110487799205df6f99547879d">solve</a> (const <a href="classeigen_1_1matrixbase">MatrixBase</a>&lt; Rhs &gt; &amp;b) const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top"> </td>
<td valign="bottom">
<a href="classeigen_1_1solverbase#a4d5e5baddfba3790ab1a5f247dcc4dc1">SolverBase</a> ()</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1diagonal">ConstTransposeReturnType</a> </td>
<td valign="bottom">
<a href="classeigen_1_1solverbase#a732e75b5132bb4db3775916927b0e86c">transpose</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structEigen_1_1EigenBase')">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJAQMAAADaX5RTAAAABlBMVEVHcEx6k8V3LoYxAAAAAXRSTlMAQObYZgAAABxJREFUCNdj4GBg4GFg4GNg4AeiBhDJBxbhYAAADMkA8rytjikAAAAASUVORK5CYII=" alt="-"> Public Member Functions inherited from <a href="structeigen_1_1eigenbase">Eigen::EigenBase&lt; Derived &gt;</a>
</td></tr> <tr>
<td align="right" valign="top">EIGEN_CONSTEXPR <a href="structeigen_1_1eigenbase#a554f30542cc2316add4b1ea0a492ff02">Index</a> </td>
<td valign="bottom">
<a href="structeigen_1_1eigenbase#a2d768a9877f5f69f49432d447b552bfe">cols</a> () const EIGEN_NOEXCEPT</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">Derived &amp; </td>
<td valign="bottom">
<a href="structeigen_1_1eigenbase#a1fbabe7f12bcbfba3b9a448b1f5e46fa">derived</a> ()</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const Derived &amp; </td>
<td valign="bottom">
<a href="structeigen_1_1eigenbase#afd4f3f1c57b7594b96a7e30f2974ea2e">derived</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">EIGEN_CONSTEXPR <a href="structeigen_1_1eigenbase#a554f30542cc2316add4b1ea0a492ff02">Index</a> </td>
<td valign="bottom">
<a href="structeigen_1_1eigenbase#ac22eb0695d00edd7d4a3b2d0a98b81c2">rows</a> () const EIGEN_NOEXCEPT</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">EIGEN_CONSTEXPR <a href="structeigen_1_1eigenbase#a554f30542cc2316add4b1ea0a492ff02">Index</a> </td>
<td valign="bottom">
<a href="structeigen_1_1eigenbase#ae106171b6fefd3f7af108a8283de36c9">size</a> () const EIGEN_NOEXCEPT</td>
</tr> <tr><td colspan="2"> </td></tr> </table>
<table> <tr><td colspan="2"></td></tr> <tr><td colspan="2" onclick="javascript:toggleInherit('pub_types_structEigen_1_1EigenBase')">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJAQMAAADaX5RTAAAABlBMVEVHcEx6k8V3LoYxAAAAAXRSTlMAQObYZgAAABxJREFUCNdj4GBg4GFg4GNg4AeiBhDJBxbhYAAADMkA8rytjikAAAAASUVORK5CYII=" alt="-"> Public Types inherited from <a href="structeigen_1_1eigenbase">Eigen::EigenBase&lt; Derived &gt;</a>
</td></tr> <tr>
<td align="right" valign="top">typedef <a href="namespaceeigen#a62e77e0933482dafde8fe197d9a2cfde">Eigen::Index</a> </td>
<td valign="bottom"><a href="structeigen_1_1eigenbase#a554f30542cc2316add4b1ea0a492ff02">Index</a></td>
</tr> <tr>
<td> </td>
<td>The interface type of indices. <a href="structeigen_1_1eigenbase#a554f30542cc2316add4b1ea0a492ff02">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> </table>  <a id="af225528d1c6e623a2b1dce091907d13e"></a> <h2>FullPivLU() <span>[1/4]</span>
</h2> <div> <div> <div> template&lt;typename MatrixType &gt; </div> <table> <tr> <td>
<a href="classeigen_1_1fullpivlu">Eigen::FullPivLU</a>&lt; MatrixType &gt;::<a href="classeigen_1_1fullpivlu">FullPivLU</a>
</td> </tr> </table> </div>
<div> <p>Default Constructor. </p> <p>The default constructor is useful in cases in which the user intends to perform decompositions via LU::compute(const MatrixType&amp;). </p> </div> </div> <a id="ae83ebd2a24088f04e3ac835b0dc001e1"></a> <h2>FullPivLU() <span>[2/4]</span>
</h2> <div> <div> <div> template&lt;typename MatrixType &gt; </div> <table> <tr> <td>
<a href="classeigen_1_1fullpivlu">Eigen::FullPivLU</a>&lt; MatrixType &gt;::<a href="classeigen_1_1fullpivlu">FullPivLU</a> </td> <td>(</td> <td>
<a href="structeigen_1_1eigenbase#a554f30542cc2316add4b1ea0a492ff02">Index</a> </td> <td>
<em>rows</em>, </td> </tr> <tr> <td></td> <td></td> <td>
<a href="structeigen_1_1eigenbase#a554f30542cc2316add4b1ea0a492ff02">Index</a> </td> <td>
<em>cols</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </div>
<div> <p>Default Constructor with memory preallocation. </p> <p>Like the default constructor but with preallocation of the internal data according to the specified problem <em>size</em>. </p>
<dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1fullpivlu#af225528d1c6e623a2b1dce091907d13e" title="Default Constructor.">FullPivLU()</a> </dd>
</dl> </div> </div> <a id="a31a6a984478a9f721f367667fe4c5ab1"></a> <h2>FullPivLU() <span>[3/4]</span>
</h2> <div> <div> <div> template&lt;typename MatrixType &gt; </div> <div> template&lt;typename InputType &gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1fullpivlu">Eigen::FullPivLU</a>&lt; MatrixType &gt;::<a href="classeigen_1_1fullpivlu">FullPivLU</a> </td> <td>(</td> <td>const <a href="structeigen_1_1eigenbase">EigenBase</a>&lt; InputType &gt; &amp; </td> <td><em>matrix</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>explicit</span></span> </td> </tr> </table> </div>
<div> <p>Constructor.</p> <dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>matrix</td>
<td>the matrix of which to compute the LU decomposition. It is required to be nonzero. </td>
</tr> </table> </dd> </dl> </div> </div> <a id="a3e903b9f401e3fc5d1ca7c6951c76185"></a> <h2>FullPivLU() <span>[4/4]</span>
</h2> <div> <div> <div> template&lt;typename MatrixType &gt; </div> <div> template&lt;typename InputType &gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1fullpivlu">Eigen::FullPivLU</a>&lt; MatrixType &gt;::<a href="classeigen_1_1fullpivlu">FullPivLU</a> </td> <td>(</td> <td>
<a href="structeigen_1_1eigenbase">EigenBase</a>&lt; InputType &gt; &amp; </td> <td><em>matrix</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>explicit</span></span> </td> </tr> </table> </div>
<div> <p>Constructs a LU factorization from a given matrix. </p> <p>This overloaded constructor is provided for <a href="group__inplacedecomposition">inplace decomposition </a> when <code>MatrixType</code> is a <a href="classeigen_1_1ref" title="A matrix or vector expression mapping an existing expression.">Eigen::Ref</a>.</p> <dl>
<dt>See also</dt>
<dd>FullPivLU(const EigenBase&amp;) </dd>
</dl> </div> </div>  <a id="a0a3c3b1bbafa31a03567a4573ebabc79"></a> <h2>compute()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <div> template&lt;typename InputType &gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1fullpivlu">FullPivLU</a>&amp; <a href="classeigen_1_1fullpivlu">Eigen::FullPivLU</a>&lt; _MatrixType &gt;::compute </td> <td>(</td> <td>const <a href="structeigen_1_1eigenbase">EigenBase</a>&lt; InputType &gt; &amp; </td> <td><em>matrix</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Computes the LU decomposition of the given matrix.</p> <dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>matrix</td>
<td>the matrix of which to compute the LU decomposition. It is required to be nonzero.</td>
</tr> </table> </dd> </dl> <dl>
<dt>Returns</dt>
<dd>a reference to *this </dd>
</dl> </div> </div> <a id="a71654e5c60a26407ecccfaa5b34bb0aa"></a> <h2>determinant()</h2> <div> <div> <div> template&lt;typename MatrixType &gt; </div> <table> <tr> <td>internal::traits&lt; MatrixType &gt;::Scalar <a href="classeigen_1_1fullpivlu">Eigen::FullPivLU</a>&lt; MatrixType &gt;::determinant</td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>the determinant of the matrix of which *this is the LU decomposition. It has only linear complexity (that is, O(n) where n is the dimension of the square matrix) as the LU decomposition has already been computed.</dd>
</dl> <dl>
<dt>Note</dt>
<dd>This is only for square matrices.</dd> <dd> For fixed-size matrices of size up to 4, <a href="classeigen_1_1matrixbase#a7ad8f77004bb956b603bb43fd2e3c061">MatrixBase::determinant()</a> offers optimized paths.</dd>
</dl> <dl>
<dt>Warning</dt>
<dd>a determinant can be very big or small, so for matrices of large enough dimension, there is a risk of overflow/underflow.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1matrixbase#a7ad8f77004bb956b603bb43fd2e3c061">MatrixBase::determinant()</a> </dd>
</dl> </div> </div> <a id="a64e191225834e91161ea53ad4b78167b"></a> <h2>dimensionOfKernel()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="structeigen_1_1eigenbase#a554f30542cc2316add4b1ea0a492ff02">Index</a> <a href="classeigen_1_1fullpivlu">Eigen::FullPivLU</a>&lt; _MatrixType &gt;::dimensionOfKernel </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>the dimension of the kernel of the matrix of which *this is the LU decomposition.</dd>
</dl> <dl>
<dt>Note</dt>
<dd>This method has to determine which pivots should be considered nonzero. For that, it uses the threshold value that you can control by calling <a href="classeigen_1_1fullpivlu#a414592d82de98f5bd075965caf56d681">setThreshold(const RealScalar&amp;)</a>. </dd>
</dl> </div> </div> <a id="a0893985d2dab367baa6e57c6fd0c4956"></a> <h2>image()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>const internal::image_retval&lt;<a href="classeigen_1_1fullpivlu">FullPivLU</a>&gt; <a href="classeigen_1_1fullpivlu">Eigen::FullPivLU</a>&lt; _MatrixType &gt;::image </td> <td>(</td> <td>const MatrixType &amp; </td> <td><em>originalMatrix</em></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>the image of the matrix, also called its column-space. The columns of the returned matrix will form a basis of the image (column-space).</dd>
</dl> <dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>originalMatrix</td>
<td>the original matrix, of which *this is the LU decomposition. The reason why it is needed to pass it here, is that this allows a large optimization, as otherwise this method would need to reconstruct it from the LU decomposition.</td>
</tr> </table> </dd> </dl> <dl>
<dt>Note</dt>
<dd>If the image has dimension zero, then the returned matrix is a column-vector filled with zeros.</dd> <dd> This method has to determine which pivots should be considered nonzero. For that, it uses the threshold value that you can control by calling <a href="classeigen_1_1fullpivlu#a414592d82de98f5bd075965caf56d681">setThreshold(const RealScalar&amp;)</a>.</dd>
</dl> <p>Example: </p>
<pre data-language="cpp">Matrix3d m;
m &lt;&lt; 1,1,0,
     1,3,2,
     0,1,1;
cout &lt;&lt; <span>"Here is the matrix m:"</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
cout &lt;&lt; <span>"Notice that the middle column is the sum of the two others, so the "</span>
     &lt;&lt; <span>"columns are linearly dependent."</span> &lt;&lt; endl;
cout &lt;&lt; <span>"Here is a matrix whose columns have the same span but are linearly independent:"</span>
     &lt;&lt; endl &lt;&lt; m.fullPivLu().image(m) &lt;&lt; endl;
</pre>
<p> Output: </p>
<pre>Here is the matrix m:
1 1 0
1 3 2
0 1 1
Notice that the middle column is the sum of the two others, so the columns are linearly dependent.
Here is a matrix whose columns have the same span but are linearly independent:
1 1
3 1
1 0
</pre>
<dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1fullpivlu#a70f52eeb2cd07dfbf790fce106fb4015">kernel()</a> </dd>
</dl> </div> </div> <a id="ae6f4bb55f859f6353f99cf15ecff4b25"></a> <h2>inverse()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="classeigen_1_1inverse">Inverse</a>&lt;<a href="classeigen_1_1fullpivlu">FullPivLU</a>&gt; <a href="classeigen_1_1fullpivlu">Eigen::FullPivLU</a>&lt; _MatrixType &gt;::inverse </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>the inverse of the matrix of which *this is the LU decomposition.</dd>
</dl> <dl>
<dt>Note</dt>
<dd>If this matrix is not invertible, the returned matrix has undefined coefficients. Use <a href="classeigen_1_1fullpivlu#afdf2579c93473650f2ef2a47a376c4a0">isInvertible()</a> to first determine whether this matrix is invertible.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1matrixbase#a7712eb69e8ea3c8f7b8da1c44dbdeebf">MatrixBase::inverse()</a> </dd>
</dl> </div> </div> <a id="ab13992c852aa593461d9b81790b56667"></a> <h2>isInjective()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>bool <a href="classeigen_1_1fullpivlu">Eigen::FullPivLU</a>&lt; _MatrixType &gt;::isInjective </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>true if the matrix of which *this is the LU decomposition represents an injective linear map, i.e. has trivial kernel; false otherwise.</dd>
</dl> <dl>
<dt>Note</dt>
<dd>This method has to determine which pivots should be considered nonzero. For that, it uses the threshold value that you can control by calling <a href="classeigen_1_1fullpivlu#a414592d82de98f5bd075965caf56d681">setThreshold(const RealScalar&amp;)</a>. </dd>
</dl> </div> </div> <a id="afdf2579c93473650f2ef2a47a376c4a0"></a> <h2>isInvertible()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>bool <a href="classeigen_1_1fullpivlu">Eigen::FullPivLU</a>&lt; _MatrixType &gt;::isInvertible </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>true if the matrix of which *this is the LU decomposition is invertible.</dd>
</dl> <dl>
<dt>Note</dt>
<dd>This method has to determine which pivots should be considered nonzero. For that, it uses the threshold value that you can control by calling <a href="classeigen_1_1fullpivlu#a414592d82de98f5bd075965caf56d681">setThreshold(const RealScalar&amp;)</a>. </dd>
</dl> </div> </div> <a id="a1f6222875fc3a181ee1544b9b36dfda5"></a> <h2>isSurjective()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>bool <a href="classeigen_1_1fullpivlu">Eigen::FullPivLU</a>&lt; _MatrixType &gt;::isSurjective </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>true if the matrix of which *this is the LU decomposition represents a surjective linear map; false otherwise.</dd>
</dl> <dl>
<dt>Note</dt>
<dd>This method has to determine which pivots should be considered nonzero. For that, it uses the threshold value that you can control by calling <a href="classeigen_1_1fullpivlu#a414592d82de98f5bd075965caf56d681">setThreshold(const RealScalar&amp;)</a>. </dd>
</dl> </div> </div> <a id="a70f52eeb2cd07dfbf790fce106fb4015"></a> <h2>kernel()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>const internal::kernel_retval&lt;<a href="classeigen_1_1fullpivlu">FullPivLU</a>&gt; <a href="classeigen_1_1fullpivlu">Eigen::FullPivLU</a>&lt; _MatrixType &gt;::kernel </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>the kernel of the matrix, also called its null-space. The columns of the returned matrix will form a basis of the kernel.</dd>
</dl> <dl>
<dt>Note</dt>
<dd>If the kernel has dimension zero, then the returned matrix is a column-vector filled with zeros.</dd> <dd> This method has to determine which pivots should be considered nonzero. For that, it uses the threshold value that you can control by calling <a href="classeigen_1_1fullpivlu#a414592d82de98f5bd075965caf56d681">setThreshold(const RealScalar&amp;)</a>.</dd>
</dl> <p>Example: </p>
<pre data-language="cpp">MatrixXf m = <a href="classeigen_1_1densebase#ae814abb451b48ed872819192dc188c19">MatrixXf::Random</a>(3,5);
cout &lt;&lt; <span>"Here is the matrix m:"</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
MatrixXf ker = m.fullPivLu().kernel();
cout &lt;&lt; <span>"Here is a matrix whose columns form a basis of the kernel of m:"</span>
     &lt;&lt; endl &lt;&lt; ker &lt;&lt; endl;
cout &lt;&lt; <span>"By definition of the kernel, m*ker is zero:"</span>
     &lt;&lt; endl &lt;&lt; m*ker &lt;&lt; endl;</pre>
<p> Output: </p>
<pre>Here is the matrix m:
   0.68   0.597   -0.33   0.108   -0.27
 -0.211   0.823   0.536 -0.0452  0.0268
  0.566  -0.605  -0.444   0.258   0.904
Here is a matrix whose columns form a basis of the kernel of m:
 -0.219   0.763
0.00335  -0.447
      0       1
      1       0
 -0.145  -0.285
By definition of the kernel, m*ker is zero:
 7.45e-09  1.49e-08
-1.86e-09 -4.05e-08
        0 -2.98e-08
</pre>
<dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1fullpivlu#a0893985d2dab367baa6e57c6fd0c4956">image()</a> </dd>
</dl> </div> </div> <a id="afea0b8fc707a9097d46fe358cb18bbff"></a> <h2>matrixLU()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>const MatrixType&amp; <a href="classeigen_1_1fullpivlu">Eigen::FullPivLU</a>&lt; _MatrixType &gt;::matrixLU </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>the LU decomposition matrix: the upper-triangular part is U, the unit-lower-triangular part is L (at least for square matrices; in the non-square case, special care is needed, see the documentation of class <a href="classeigen_1_1fullpivlu" title="LU decomposition of a matrix with complete pivoting, and related features.">FullPivLU</a>).</dd>
</dl> <dl>
<dt>See also</dt>
<dd>matrixL(), matrixU() </dd>
</dl> </div> </div> <a id="abced9f280f5fc49c2e62605c782b237b"></a> <h2>maxPivot()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>RealScalar <a href="classeigen_1_1fullpivlu">Eigen::FullPivLU</a>&lt; _MatrixType &gt;::maxPivot </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>the absolute value of the biggest pivot, i.e. the biggest diagonal coefficient of U. </dd>
</dl> </div> </div> <a id="aa71132a751ad3c78178e33d6b2987400"></a> <h2>nonzeroPivots()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="structeigen_1_1eigenbase#a554f30542cc2316add4b1ea0a492ff02">Index</a> <a href="classeigen_1_1fullpivlu">Eigen::FullPivLU</a>&lt; _MatrixType &gt;::nonzeroPivots </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>the number of nonzero pivots in the LU decomposition. Here nonzero is meant in the exact sense, not in a fuzzy sense. So that notion isn't really intrinsically interesting, but it is still useful when implementing algorithms.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1fullpivlu#a67a870aa69e699e058d04802ba0bdad9">rank()</a> </dd>
</dl> </div> </div> <a id="ad8f1d7266a434c524d3e0dbcc7a0f588"></a> <h2>permutationP()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="classeigen_1_1permutationmatrix">PermutationPType</a>&amp; <a href="classeigen_1_1fullpivlu">Eigen::FullPivLU</a>&lt; _MatrixType &gt;::permutationP </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>the permutation matrix P</dd>
</dl> <dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1fullpivlu#a8d18190c7618de271cba7293f0493a36">permutationQ()</a> </dd>
</dl> </div> </div> <a id="a8d18190c7618de271cba7293f0493a36"></a> <h2>permutationQ()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="classeigen_1_1permutationmatrix">PermutationQType</a>&amp; <a href="classeigen_1_1fullpivlu">Eigen::FullPivLU</a>&lt; _MatrixType &gt;::permutationQ </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>the permutation matrix Q</dd>
</dl> <dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1fullpivlu#ad8f1d7266a434c524d3e0dbcc7a0f588">permutationP()</a> </dd>
</dl> </div> </div> <a id="a67a870aa69e699e058d04802ba0bdad9"></a> <h2>rank()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="structeigen_1_1eigenbase#a554f30542cc2316add4b1ea0a492ff02">Index</a> <a href="classeigen_1_1fullpivlu">Eigen::FullPivLU</a>&lt; _MatrixType &gt;::rank </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>the rank of the matrix of which *this is the LU decomposition.</dd>
</dl> <dl>
<dt>Note</dt>
<dd>This method has to determine which pivots should be considered nonzero. For that, it uses the threshold value that you can control by calling <a href="classeigen_1_1fullpivlu#a414592d82de98f5bd075965caf56d681">setThreshold(const RealScalar&amp;)</a>. </dd>
</dl> </div> </div> <a id="a0bc63f910960dc3e35acecc8442025b6"></a> <h2>rcond()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>RealScalar <a href="classeigen_1_1fullpivlu">Eigen::FullPivLU</a>&lt; _MatrixType &gt;::rcond </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>an estimate of the reciprocal condition number of the matrix of which <code>*this</code> is the LU decomposition. </dd>
</dl> </div> </div> <a id="a191a4f598b0c192a83ab48984e87ee51"></a> <h2>reconstructedMatrix()</h2> <div> <div> <div> template&lt;typename MatrixType &gt; </div> <table> <tr> <td>MatrixType <a href="classeigen_1_1fullpivlu">Eigen::FullPivLU</a>&lt; MatrixType &gt;::reconstructedMatrix</td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>the matrix represented by the decomposition, i.e., it returns the product: \( P^{-1} L U Q^{-1} \). This function is provided for debug purposes. </dd>
</dl> </div> </div> <a id="a414592d82de98f5bd075965caf56d681"></a> <h2>setThreshold() <span>[1/2]</span>
</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1fullpivlu">FullPivLU</a>&amp; <a href="classeigen_1_1fullpivlu">Eigen::FullPivLU</a>&lt; _MatrixType &gt;::setThreshold </td> <td>(</td> <td>const RealScalar &amp; </td> <td><em>threshold</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Allows to prescribe a threshold to be used by certain methods, such as <a href="classeigen_1_1fullpivlu#a67a870aa69e699e058d04802ba0bdad9">rank()</a>, who need to determine when pivots are to be considered nonzero. This is not used for the LU decomposition itself.</p> <p>When it needs to get the threshold value, <a href="namespaceeigen" title="Namespace containing all symbols from the Eigen library.">Eigen</a> calls <a href="classeigen_1_1fullpivlu#ad77539203694f2d85ff7d11616e5a0a5">threshold()</a>. By default, this uses a formula to automatically determine a reasonable threshold. Once you have called the present method <a href="classeigen_1_1fullpivlu#a414592d82de98f5bd075965caf56d681">setThreshold(const RealScalar&amp;)</a>, your value is used instead.</p> <dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>threshold</td>
<td>The new value to use as the threshold.</td>
</tr> </table> </dd> </dl> <p>A pivot will be considered nonzero if its absolute value is strictly greater than \( \vert pivot \vert \leqslant threshold \times \vert maxpivot \vert \) where maxpivot is the biggest pivot.</p> <p>If you want to come back to the default behavior, call <a href="classeigen_1_1fullpivlu#a1b5e30add3dfb6625da1213d68418f44">setThreshold(Default_t)</a> </p> </div> </div> <a id="a1b5e30add3dfb6625da1213d68418f44"></a> <h2>setThreshold() <span>[2/2]</span>
</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1fullpivlu">FullPivLU</a>&amp; <a href="classeigen_1_1fullpivlu">Eigen::FullPivLU</a>&lt; _MatrixType &gt;::setThreshold </td> <td>(</td> <td>Default_t </td> <td></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Allows to come back to the default behavior, letting <a href="namespaceeigen" title="Namespace containing all symbols from the Eigen library.">Eigen</a> use its default formula for determining the threshold.</p> <p>You should pass the special object Eigen::Default as parameter here. </p>
<pre data-language="cpp">lu.setThreshold(Eigen::Default); 
</pre>
<p>See the documentation of <a href="classeigen_1_1fullpivlu#a414592d82de98f5bd075965caf56d681">setThreshold(const RealScalar&amp;)</a>. </p> </div> </div> <a id="af563471f6f3283fd10779ef02dd0b748"></a> <h2>solve()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <div> template&lt;typename Rhs &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="classeigen_1_1solve">Solve</a>&lt;<a href="classeigen_1_1fullpivlu">FullPivLU</a>, Rhs&gt; <a href="classeigen_1_1fullpivlu">Eigen::FullPivLU</a>&lt; _MatrixType &gt;::solve </td> <td>(</td> <td>const <a href="classeigen_1_1matrixbase">MatrixBase</a>&lt; Rhs &gt; &amp; </td> <td><em>b</em></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>a solution x to the equation Ax=b, where A is the matrix of which *this is the LU decomposition.</dd>
</dl> <dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>b</td>
<td>the right-hand-side of the equation to solve. Can be a vector or a matrix, the only requirement in order for the equation to make sense is that b.rows()==A.rows(), where A is the matrix of which *this is the LU decomposition.</td>
</tr> </table> </dd> </dl> <dl>
<dt>Returns</dt>
<dd>a solution.</dd>
</dl> <p>This method just tries to find as good a solution as possible. If you want to check whether a solution exists or if it is accurate, just call this function to get a result and then compute the error of this result, or use <a href="classeigen_1_1densebase#ae8443357b808cd393be1b51974213f9c">MatrixBase::isApprox()</a> directly, for instance like this:</p>
<pre data-language="cpp"><span>bool</span> a_solution_exists = (A*result).isApprox(b, precision); 
</pre>
<p> This method avoids dividing by zero, so that the non-existence of a solution doesn't by itself mean that you'll get <code>inf</code> or <code>nan</code> values.</p> <p>If there exists more than one solution, this method will arbitrarily choose one. If you need a complete analysis of the space of solutions, take the one solution obtained by this method and add to it elements of the kernel, as determined by <a href="classeigen_1_1fullpivlu#a70f52eeb2cd07dfbf790fce106fb4015">kernel()</a>.</p> <p>Example: </p>
<pre data-language="cpp">Matrix&lt;float,2,3&gt; m = <a href="classeigen_1_1densebase#ae814abb451b48ed872819192dc188c19">Matrix&lt;float,2,3&gt;::Random</a>();
Matrix2f y = <a href="classeigen_1_1densebase#ae814abb451b48ed872819192dc188c19">Matrix2f::Random</a>();
cout &lt;&lt; <span>"Here is the matrix m:"</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
cout &lt;&lt; <span>"Here is the matrix y:"</span> &lt;&lt; endl &lt;&lt; y &lt;&lt; endl;
Matrix&lt;float,3,2&gt; x = m.fullPivLu().solve(y);
<span>if</span>((m*x).isApprox(y))
{
  cout &lt;&lt; <span>"Here is a solution x to the equation mx=y:"</span> &lt;&lt; endl &lt;&lt; x &lt;&lt; endl;
}
<span>else</span>
  cout &lt;&lt; <span>"The equation mx=y does not have any solution."</span> &lt;&lt; endl;
</pre>
<p> Output: </p>
<pre>Here is the matrix m:
  0.68  0.566  0.823
-0.211  0.597 -0.605
Here is the matrix y:
 -0.33 -0.444
 0.536  0.108
Here is a solution x to the equation mx=y:
     0      0
 0.291 -0.216
  -0.6 -0.391
</pre>
<dl>
<dt>See also</dt>
<dd>TriangularView::solve(), <a href="classeigen_1_1fullpivlu#a70f52eeb2cd07dfbf790fce106fb4015">kernel()</a>, <a href="classeigen_1_1fullpivlu#ae6f4bb55f859f6353f99cf15ecff4b25">inverse()</a> </dd>
</dl> </div> </div> <a id="ad77539203694f2d85ff7d11616e5a0a5"></a> <h2>threshold()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>RealScalar <a href="classeigen_1_1fullpivlu">Eigen::FullPivLU</a>&lt; _MatrixType &gt;::threshold </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Returns the threshold that will be used by certain methods such as <a href="classeigen_1_1fullpivlu#a67a870aa69e699e058d04802ba0bdad9">rank()</a>.</p> <p>See the documentation of <a href="classeigen_1_1fullpivlu#a414592d82de98f5bd075965caf56d681">setThreshold(const RealScalar&amp;)</a>. </p> </div> </div> <hr>The documentation for this class was generated from the following file:<ul> <li><a href="https://eigen.tuxfamily.org/dox/FullPivLU_8h_source.html">FullPivLU.h</a></li> </ul> </div> <div class="_attribution">
  <p class="_attribution-p">
     Eigen.<br>Licensed under the MPL2 License.<br>
    <a href="https://eigen.tuxfamily.org/dox/classEigen_1_1FullPivLU.html" class="_attribution-link">https://eigen.tuxfamily.org/dox/classEigen_1_1FullPivLU.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
