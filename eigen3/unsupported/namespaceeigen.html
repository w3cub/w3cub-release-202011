
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Eigen - Eigen3 - W3cubDocs</title>
  
  <meta name="description" content=" Namespace containing all symbols from the Eigen library. More... ">
  <meta name="keywords" content="eigen, eigen3">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/eigen3/unsupported/namespaceeigen.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-f16eecbe420d8b2925d31ffbb21d05646497ecbd9515f08ffe69e9bba7332f5657accc7003c7f6c72cb4a132171acf171b359ae3bae4ae5660ddfb1718f88c67.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/eigen3.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/eigen3/" class="_nav-link" title="" style="margin-left:0;">Eigen3</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _eigen3">
				
				
<h1>Eigen</h1>      <div> <p>Namespace containing all symbols from the Eigen library. <a href="namespaceeigen#details">More...</a></p> <table> <tr><td colspan="2"></td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1aligned__allocator">aligned_allocator</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1alignedbox">AlignedBox</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1alignedvector3">AlignedVector3</a></td>
</tr> <tr>
<td> </td>
<td>A vectorization friendly 3D vector. <a href="classeigen_1_1alignedvector3#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1amdordering">AMDOrdering</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1angleaxis">AngleAxis</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1arithmeticsequence">ArithmeticSequence</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1array">Array</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1arraybase">ArrayBase</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1arraywrapper">ArrayWrapper</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">struct </td>
<td valign="bottom"><a href="../structeigen_1_1arrayxpr">ArrayXpr</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1autodiffscalar">AutoDiffScalar</a></td>
</tr> <tr>
<td> </td>
<td>A scalar type replacement with automatic differentiation capability. <a href="classeigen_1_1autodiffscalar#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1bdcsvd">BDCSVD</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1bicgstab">BiCGSTAB</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1block">Block</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1blockimpl_3_01xprtype_00_01blockrows_00_01blockcols_00_01innerpanel_00_01sparse_01_4">BlockImpl&lt; XprType, BlockRows, BlockCols, InnerPanel, Sparse &gt;</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1blocksparsematrix">BlockSparseMatrix</a></td>
</tr> <tr>
<td> </td>
<td>A versatile sparse matrix representation where each element is a block. <a href="classeigen_1_1blocksparsematrix#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1cholmodbase">CholmodBase</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1cholmoddecomposition">CholmodDecomposition</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1cholmodsimplicialldlt">CholmodSimplicialLDLT</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1cholmodsimplicialllt">CholmodSimplicialLLT</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1cholmodsupernodalllt">CholmodSupernodalLLT</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1colamdordering">COLAMDOrdering</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1colpivhouseholderqr">ColPivHouseholderQR</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../structeigen_1_1commainitializer">CommaInitializer</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1completeorthogonaldecomposition">CompleteOrthogonalDecomposition</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1complexeigensolver">ComplexEigenSolver</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1complexschur">ComplexSchur</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1conjugategradient">ConjugateGradient</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1cwisebinaryop">CwiseBinaryOp</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1cwisenullaryop">CwiseNullaryOp</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1cwiseternaryop">CwiseTernaryOp</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1cwiseunaryop">CwiseUnaryOp</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1cwiseunaryview">CwiseUnaryView</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">struct </td>
<td valign="bottom"><a href="../structeigen_1_1dense">Dense</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1densebase">DenseBase</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1densecoeffsbase_3_01derived_00_01directaccessors_01_4">DenseCoeffsBase&lt; Derived, DirectAccessors &gt;</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1densecoeffsbase_3_01derived_00_01directwriteaccessors_01_4">DenseCoeffsBase&lt; Derived, DirectWriteAccessors &gt;</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1densecoeffsbase_3_01derived_00_01readonlyaccessors_01_4">DenseCoeffsBase&lt; Derived, ReadOnlyAccessors &gt;</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1densecoeffsbase_3_01derived_00_01writeaccessors_01_4">DenseCoeffsBase&lt; Derived, WriteAccessors &gt;</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1dgmres">DGMRES</a></td>
</tr> <tr>
<td> </td>
<td>A Restarted <a href="classeigen_1_1gmres" title="A GMRES solver for sparse square problems.">GMRES</a> with deflation. This class implements a modification of the <a href="classeigen_1_1gmres" title="A GMRES solver for sparse square problems.">GMRES</a> solver for sparse linear systems. The basis is built with modified Gram-Schmidt. At each restart, a few approximated eigenvectors corresponding to the smallest eigenvalues are used to build a preconditioner for the next cycle. This preconditioner for deflation can be combined with any other preconditioner, the <a href="../classeigen_1_1incompletelut">IncompleteLUT</a> for instance. The preconditioner is applied at right of the matrix and the combination is multiplicative. <a href="classeigen_1_1dgmres#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1diagonal">Diagonal</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1diagonalmatrix">DiagonalMatrix</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1diagonalpreconditioner">DiagonalPreconditioner</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1diagonalwrapper">DiagonalWrapper</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1dynamicsgroup">DynamicSGroup</a></td>
</tr> <tr>
<td> </td>
<td>Dynamic symmetry group. <a href="classeigen_1_1dynamicsgroup#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1dynamicsparsematrix">DynamicSparseMatrix</a></td>
</tr> <tr>
<td> </td>
<td>A sparse matrix class designed for matrix assembly purpose. <a href="classeigen_1_1dynamicsparsematrix#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../structeigen_1_1eigenbase">EigenBase</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1eigensolver">EigenSolver</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1eulerangles">EulerAngles</a></td>
</tr> <tr>
<td> </td>
<td>Represents a rotation in a 3 dimensional space as three Euler angles. <a href="classeigen_1_1eulerangles#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1eulersystem">EulerSystem</a></td>
</tr> <tr>
<td> </td>
<td>Represents a fixed Euler rotation system. <a href="classeigen_1_1eulersystem#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1forcealignedaccess">ForceAlignedAccess</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1fullpivhouseholderqr">FullPivHouseholderQR</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1fullpivlu">FullPivLU</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1generalizedeigensolver">GeneralizedEigenSolver</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1generalizedselfadjointeigensolver">GeneralizedSelfAdjointEigenSolver</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1gmres">GMRES</a></td>
</tr> <tr>
<td> </td>
<td>A <a href="classeigen_1_1gmres" title="A GMRES solver for sparse square problems.">GMRES</a> solver for sparse square problems. <a href="classeigen_1_1gmres#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1hessenbergdecomposition">HessenbergDecomposition</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1homogeneous">Homogeneous</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1householderqr">HouseholderQR</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1householdersequence">HouseholderSequence</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1hybridnonlinearsolver">HybridNonLinearSolver</a></td>
</tr> <tr>
<td> </td>
<td>Finds a zero of a system of n nonlinear functions in n variables by a modification of the Powell hybrid method ("dogleg"). <a href="classeigen_1_1hybridnonlinearsolver#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1hyperplane">Hyperplane</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1identitypreconditioner">IdentityPreconditioner</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1idrs">IDRS</a></td>
</tr> <tr>
<td> </td>
<td>The Induced Dimension Reduction method (IDR(s)) is a short-recurrences Krylov method for sparse square problems. <a href="classeigen_1_1idrs#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1incompletecholesky">IncompleteCholesky</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1incompletelut">IncompleteLUT</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1indexedview">IndexedView</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1innerstride">InnerStride</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1inverse">Inverse</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../structeigen_1_1ioformat">IOFormat</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1iterationcontroller">IterationController</a></td>
</tr> <tr>
<td> </td>
<td>Controls the iterations of the iterative solvers. <a href="classeigen_1_1iterationcontroller#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1iterativesolverbase">IterativeSolverBase</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1iterscaling">IterScaling</a></td>
</tr> <tr>
<td> </td>
<td>iterative scaling algorithm to equilibrate rows and column norms in matrices <a href="classeigen_1_1iterscaling#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1jacobirotation">JacobiRotation</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1jacobisvd">JacobiSVD</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1kdbvh">KdBVH</a></td>
</tr> <tr>
<td> </td>
<td>A simple bounding volume hierarchy based on <a href="../classeigen_1_1alignedbox">AlignedBox</a>. <a href="classeigen_1_1kdbvh#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1kroneckerproduct">KroneckerProduct</a></td>
</tr> <tr>
<td> </td>
<td>Kronecker tensor product helper class for dense matrices. <a href="classeigen_1_1kroneckerproduct#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1kroneckerproductbase">KroneckerProductBase</a></td>
</tr> <tr>
<td> </td>
<td>The base class of dense and sparse Kronecker product. <a href="classeigen_1_1kroneckerproductbase#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1kroneckerproductsparse">KroneckerProductSparse</a></td>
</tr> <tr>
<td> </td>
<td>Kronecker tensor product helper class for sparse matrices. <a href="classeigen_1_1kroneckerproductsparse#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1ldlt">LDLT</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1leastsquarediagonalpreconditioner">LeastSquareDiagonalPreconditioner</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1leastsquaresconjugategradient">LeastSquaresConjugateGradient</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1levenbergmarquardt">LevenbergMarquardt</a></td>
</tr> <tr>
<td> </td>
<td>Performs non linear optimization over a non-linear function, using a variant of the Levenberg Marquardt algorithm. <a href="classeigen_1_1levenbergmarquardt#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1llt">LLT</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1map">Map</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1map_3_01const_01quaternion_3_01__scalar_01_4_00_01__options_01_4">Map&lt; const Quaternion&lt; _Scalar &gt;, _Options &gt;</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1map_3_01quaternion_3_01__scalar_01_4_00_01__options_01_4">Map&lt; Quaternion&lt; _Scalar &gt;, _Options &gt;</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1map_3_01sparsematrixtype_01_4">Map&lt; SparseMatrixType &gt;</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1mapbase_3_01derived_00_01readonlyaccessors_01_4">MapBase&lt; Derived, ReadOnlyAccessors &gt;</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1mapbase_3_01derived_00_01writeaccessors_01_4">MapBase&lt; Derived, WriteAccessors &gt;</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1mappedsparsematrix">MappedSparseMatrix</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1matrix">Matrix</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1matrixbase">MatrixBase</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1matrixcomplexpowerreturnvalue">MatrixComplexPowerReturnValue</a></td>
</tr> <tr>
<td> </td>
<td>Proxy for the matrix power of some matrix (expression). <a href="classeigen_1_1matrixcomplexpowerreturnvalue#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">struct </td>
<td valign="bottom"><a href="structeigen_1_1matrixexponentialreturnvalue">MatrixExponentialReturnValue</a></td>
</tr> <tr>
<td> </td>
<td>Proxy for the matrix exponential of some matrix (expression). <a href="structeigen_1_1matrixexponentialreturnvalue#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1matrixfunctionreturnvalue">MatrixFunctionReturnValue</a></td>
</tr> <tr>
<td> </td>
<td>Proxy for the matrix function of some matrix (expression). <a href="classeigen_1_1matrixfunctionreturnvalue#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1matrixlogarithmreturnvalue">MatrixLogarithmReturnValue</a></td>
</tr> <tr>
<td> </td>
<td>Proxy for the matrix logarithm of some matrix (expression). <a href="classeigen_1_1matrixlogarithmreturnvalue#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1matrixmarketiterator">MatrixMarketIterator</a></td>
</tr> <tr>
<td> </td>
<td>Iterator to browse matrices from a specified folder. <a href="classeigen_1_1matrixmarketiterator#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1matrixpower">MatrixPower</a></td>
</tr> <tr>
<td> </td>
<td>Class for computing matrix powers. <a href="classeigen_1_1matrixpower#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1matrixpoweratomic">MatrixPowerAtomic</a></td>
</tr> <tr>
<td> </td>
<td>Class for computing matrix powers. <a href="classeigen_1_1matrixpoweratomic#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1matrixpowerparenthesesreturnvalue">MatrixPowerParenthesesReturnValue</a></td>
</tr> <tr>
<td> </td>
<td>Proxy for the matrix power of some matrix. <a href="classeigen_1_1matrixpowerparenthesesreturnvalue#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1matrixpowerreturnvalue">MatrixPowerReturnValue</a></td>
</tr> <tr>
<td> </td>
<td>Proxy for the matrix power of some matrix (expression). <a href="classeigen_1_1matrixpowerreturnvalue#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1matrixsquarerootreturnvalue">MatrixSquareRootReturnValue</a></td>
</tr> <tr>
<td> </td>
<td>Proxy for the matrix square root of some matrix (expression). <a href="classeigen_1_1matrixsquarerootreturnvalue#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1matrixwrapper">MatrixWrapper</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">struct </td>
<td valign="bottom"><a href="../structeigen_1_1matrixxpr">MatrixXpr</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1maxsizevector">MaxSizeVector</a></td>
</tr> <tr>
<td> </td>
<td>The <a href="classeigen_1_1maxsizevector" title="The MaxSizeVector class.">MaxSizeVector</a> class. <a href="classeigen_1_1maxsizevector#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1metisordering">MetisOrdering</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1minres">MINRES</a></td>
</tr> <tr>
<td> </td>
<td>A minimal residual solver for sparse symmetric problems. <a href="classeigen_1_1minres#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1naturalordering">NaturalOrdering</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1nestbyvalue">NestByValue</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1noalias">NoAlias</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1numericaldiff">NumericalDiff</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../structeigen_1_1numtraits">NumTraits</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">struct </td>
<td valign="bottom"><a href="structeigen_1_1numtraits_3_01mpfr_1_1mpreal_01_4">NumTraits&lt; mpfr::mpreal &gt;</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1outerstride">OuterStride</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1parametrizedline">ParametrizedLine</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1pardisoldlt">PardisoLDLT</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1pardisollt">PardisoLLT</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1pardisolu">PardisoLU</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1partialpivlu">PartialPivLU</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1partialreduxexpr">PartialReduxExpr</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1pastixldlt">PastixLDLT</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1pastixllt">PastixLLT</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1pastixlu">PastixLU</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1permutationbase">PermutationBase</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1permutationmatrix">PermutationMatrix</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">struct </td>
<td valign="bottom"><a href="../structeigen_1_1permutationstorage">PermutationStorage</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1permutationwrapper">PermutationWrapper</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1plainobjectbase">PlainObjectBase</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1polynomialsolver">PolynomialSolver</a></td>
</tr> <tr>
<td> </td>
<td>A polynomial solver. <a href="classeigen_1_1polynomialsolver#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1polynomialsolverbase">PolynomialSolverBase</a></td>
</tr> <tr>
<td> </td>
<td>Defined to be inherited by polynomial solvers: it provides convenient methods such as. <a href="classeigen_1_1polynomialsolverbase#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1product">Product</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1quaternion">Quaternion</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1quaternionbase">QuaternionBase</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1randomsetter">RandomSetter</a></td>
</tr> <tr>
<td> </td>
<td>The <a href="classeigen_1_1randomsetter" title="The RandomSetter is a wrapper object allowing to set/update a sparse matrix with random access.">RandomSetter</a> is a wrapper object allowing to set/update a sparse matrix with random access. <a href="classeigen_1_1randomsetter#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1realqz">RealQZ</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1realschur">RealSchur</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1ref">Ref</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1ref_3_01sparsematrixtype_00_01options_01_4">Ref&lt; SparseMatrixType, Options &gt;</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1ref_3_01sparsevectortype_01_4">Ref&lt; SparseVectorType &gt;</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1replicate">Replicate</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1reshaped">Reshaped</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1reverse">Reverse</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1rotation2d">Rotation2D</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1rotationbase">RotationBase</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../structeigen_1_1scalarbinaryoptraits">ScalarBinaryOpTraits</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1select">Select</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1selfadjointeigensolver">SelfAdjointEigenSolver</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1selfadjointview">SelfAdjointView</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1sgroup">SGroup</a></td>
</tr> <tr>
<td> </td>
<td>Symmetry group, initialized from template arguments. <a href="classeigen_1_1sgroup#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1simplicialcholesky">SimplicialCholesky</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1simplicialcholeskybase">SimplicialCholeskyBase</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1simplicialldlt">SimplicialLDLT</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1simplicialllt">SimplicialLLT</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1skylineinplacelu">SkylineInplaceLU</a></td>
</tr> <tr>
<td> </td>
<td>Inplace LU decomposition of a skyline matrix and associated features. <a href="classeigen_1_1skylineinplacelu#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1skylinematrix">SkylineMatrix</a></td>
</tr> <tr>
<td> </td>
<td>The main skyline matrix class. <a href="classeigen_1_1skylinematrix#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1skylinematrixbase">SkylineMatrixBase</a></td>
</tr> <tr>
<td> </td>
<td>Base class of any skyline matrices or skyline expressions. <a href="classeigen_1_1skylinematrixbase#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1skylinestorage">SkylineStorage</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1solve">Solve</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1solverbase">SolverBase</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">struct </td>
<td valign="bottom"><a href="../structeigen_1_1solverstorage">SolverStorage</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1solvewithguess">SolveWithGuess</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">struct </td>
<td valign="bottom"><a href="../structeigen_1_1sparse">Sparse</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1sparsecompressedbase">SparseCompressedBase</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1sparselu">SparseLU</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1sparsemapbase_3_01derived_00_01readonlyaccessors_01_4">SparseMapBase&lt; Derived, ReadOnlyAccessors &gt;</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1sparsemapbase_3_01derived_00_01writeaccessors_01_4">SparseMapBase&lt; Derived, WriteAccessors &gt;</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1sparsematrix">SparseMatrix</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1sparsematrixbase">SparseMatrixBase</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1sparseqr">SparseQR</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1sparseselfadjointview">SparseSelfAdjointView</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1sparsesolverbase">SparseSolverBase</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1sparsevector">SparseVector</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1sparseview">SparseView</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1spline">Spline</a></td>
</tr> <tr>
<td> </td>
<td>A class representing multi-dimensional spline curves. <a href="classeigen_1_1spline#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">struct </td>
<td valign="bottom"><a href="structeigen_1_1splinefitting">SplineFitting</a></td>
</tr> <tr>
<td> </td>
<td>
<a href="classeigen_1_1spline" title="A class representing multi-dimensional spline curves.">Spline</a> fitting methods. <a href="structeigen_1_1splinefitting#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">struct </td>
<td valign="bottom"><a href="structeigen_1_1splinetraits_3_01spline_3_01__scalar_00_01__dim_00_01__degree_01_4_00_01__derivativeorder_01_4">SplineTraits&lt; Spline&lt; _Scalar, _Dim, _Degree &gt;, _DerivativeOrder &gt;</a></td>
</tr> <tr>
<td> </td>
<td>Compile-time attributes of the <a href="classeigen_1_1spline" title="A class representing multi-dimensional spline curves.">Spline</a> class for fixed degree. <a href="structeigen_1_1splinetraits_3_01spline_3_01__scalar_00_01__dim_00_01__degree_01_4_00_01__derivativeorder_01_4#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">struct </td>
<td valign="bottom"><a href="structeigen_1_1splinetraits_3_01spline_3_01__scalar_00_01__dim_00_01__degree_01_4_00_01dynamic_01_4">SplineTraits&lt; Spline&lt; _Scalar, _Dim, _Degree &gt;, Dynamic &gt;</a></td>
</tr> <tr>
<td> </td>
<td>Compile-time attributes of the <a href="classeigen_1_1spline" title="A class representing multi-dimensional spline curves.">Spline</a> class for Dynamic degree. <a href="structeigen_1_1splinetraits_3_01spline_3_01__scalar_00_01__dim_00_01__degree_01_4_00_01dynamic_01_4#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1spqr">SPQR</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1staticsgroup">StaticSGroup</a></td>
</tr> <tr>
<td> </td>
<td>Static symmetry group. <a href="classeigen_1_1staticsgroup#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">struct </td>
<td valign="bottom"><a href="structeigen_1_1stdmaptraits">StdMapTraits</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1stride">Stride</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1superilu">SuperILU</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1superlu">SuperLU</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1superlubase">SuperLUBase</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1svdbase">SVDBase</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensor">Tensor</a></td>
</tr> <tr>
<td> </td>
<td>The tensor class. <a href="classeigen_1_1tensor#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensorasyncdevice">TensorAsyncDevice</a></td>
</tr> <tr>
<td> </td>
<td>Pseudo expression providing an operator = that will evaluate its argument asynchronously on the specified device. Currently only ThreadPoolDevice implements proper asynchronous execution, while the default and GPU devices just run the expression synchronously and call m_done() on completion.. <a href="classeigen_1_1tensorasyncdevice#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensorbase">TensorBase</a></td>
</tr> <tr>
<td> </td>
<td>The tensor base class. <a href="classeigen_1_1tensorbase#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensorconcatenationop">TensorConcatenationOp</a></td>
</tr> <tr>
<td> </td>
<td>
<a href="classeigen_1_1tensor" title="The tensor class.">Tensor</a> concatenation class. <a href="classeigen_1_1tensorconcatenationop#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensorconversionop">TensorConversionOp</a></td>
</tr> <tr>
<td> </td>
<td>
<a href="classeigen_1_1tensor" title="The tensor class.">Tensor</a> conversion class. This class makes it possible to vectorize type casting operations when the number of scalars per packet in the source and the destination type differ. <a href="classeigen_1_1tensorconversionop#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensorcustombinaryop">TensorCustomBinaryOp</a></td>
</tr> <tr>
<td> </td>
<td>
<a href="classeigen_1_1tensor" title="The tensor class.">Tensor</a> custom class. <a href="classeigen_1_1tensorcustombinaryop#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensorcustomunaryop">TensorCustomUnaryOp</a></td>
</tr> <tr>
<td> </td>
<td>
<a href="classeigen_1_1tensor" title="The tensor class.">Tensor</a> custom class. <a href="classeigen_1_1tensorcustomunaryop#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensordevice">TensorDevice</a></td>
</tr> <tr>
<td> </td>
<td>Pseudo expression providing an operator = that will evaluate its argument on the specified computing 'device' (GPU, thread pool, ...) <a href="classeigen_1_1tensordevice#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="structeigen_1_1tensorevaluator">TensorEvaluator</a></td>
</tr> <tr>
<td> </td>
<td>A cost model used to limit the number of threads used for evaluating tensor expression. <a href="structeigen_1_1tensorevaluator#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensorfixedsize">TensorFixedSize</a></td>
</tr> <tr>
<td> </td>
<td>The fixed sized version of the tensor class. <a href="classeigen_1_1tensorfixedsize#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensorgeneratorop">TensorGeneratorOp</a></td>
</tr> <tr>
<td> </td>
<td>
<a href="classeigen_1_1tensor" title="The tensor class.">Tensor</a> generator class. <a href="classeigen_1_1tensorgeneratorop#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensormap">TensorMap</a></td>
</tr> <tr>
<td> </td>
<td>A tensor expression mapping an existing array of data. <a href="classeigen_1_1tensormap#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensorref">TensorRef</a></td>
</tr> <tr>
<td> </td>
<td>A reference to a tensor expression The expression will be evaluated lazily (as much as possible). <a href="classeigen_1_1tensorref#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1transform">Transform</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1translation">Translation</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1transpose">Transpose</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1transpositions">Transpositions</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">struct </td>
<td valign="bottom"><a href="../structeigen_1_1transpositionsstorage">TranspositionsStorage</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1triangularbase">TriangularBase</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1triangularview">TriangularView</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1triangularviewimpl_3_01__matrixtype_00_01__mode_00_01dense_01_4">TriangularViewImpl&lt; _MatrixType, _Mode, Dense &gt;</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1triangularviewimpl_3_01matrixtype_00_01mode_00_01sparse_01_4">TriangularViewImpl&lt; MatrixType, Mode, Sparse &gt;</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1tridiagonalization">Tridiagonalization</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1triplet">Triplet</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1umfpacklu">UmfPackLU</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1uniformscaling">UniformScaling</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1vectorblock">VectorBlock</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1vectorwiseop">VectorwiseOp</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1withformat">WithFormat</a></td>
</tr> <tr><td colspan="2"> </td></tr> </table>
<table> <tr><td colspan="2"></td></tr> <tr>
<td align="right" valign="top">
<a id="aa04df76fa4fc7d93538c28bbbd838507"></a> typedef <a href="classeigen_1_1spline">Spline</a>&lt; double, 2 &gt; </td>
<td valign="bottom"><a href="namespaceeigen#aa04df76fa4fc7d93538c28bbbd838507">Spline2d</a></td>
</tr> <tr>
<td> </td>
<td>2D double B-spline with dynamic degree. <br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a id="a1709ceddcb1e899317ac4bdb9682807f"></a> typedef <a href="classeigen_1_1spline">Spline</a>&lt; float, 2 &gt; </td>
<td valign="bottom"><a href="namespaceeigen#a1709ceddcb1e899317ac4bdb9682807f">Spline2f</a></td>
</tr> <tr>
<td> </td>
<td>2D float B-spline with dynamic degree. <br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a id="a34dfede40d5b8f3b2443ff20d891f455"></a> typedef <a href="classeigen_1_1spline">Spline</a>&lt; double, 3 &gt; </td>
<td valign="bottom"><a href="namespaceeigen#a34dfede40d5b8f3b2443ff20d891f455">Spline3d</a></td>
</tr> <tr>
<td> </td>
<td>3D double B-spline with dynamic degree. <br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a id="a612e989f65acc6abc1593909f901e455"></a> typedef <a href="classeigen_1_1spline">Spline</a>&lt; float, 3 &gt; </td>
<td valign="bottom"><a href="namespaceeigen#a612e989f65acc6abc1593909f901e455">Spline3f</a></td>
</tr> <tr>
<td> </td>
<td>3D float B-spline with dynamic degree. <br>
</td>
</tr> <tr><td colspan="2"> </td></tr> </table>
<table> <tr><td colspan="2"></td></tr> <tr>
<td align="right" valign="top">enum </td>
<td valign="bottom">
<a href="group__eulerangles__module#gae614aa7cdd687fb5c421a54f2ce5c361">EulerAxis</a> { <br> <a href="group__eulerangles__module#ggae614aa7cdd687fb5c421a54f2ce5c361a11e1ea88cbe04a6fc077475d515d0b38">EULER_X</a> , <br> <a href="group__eulerangles__module#ggae614aa7cdd687fb5c421a54f2ce5c361aee756a2b63043248f3d83541386c266b">EULER_Y</a> , <br> <a href="group__eulerangles__module#ggae614aa7cdd687fb5c421a54f2ce5c361a95187b9943820cca5edc4bc96b3c08be">EULER_Z</a> <br> }</td>
</tr> <tr>
<td> </td>
<td>Representation of a fixed signed rotation axis for EulerSystem. <a href="group__eulerangles__module#gae614aa7cdd687fb5c421a54f2ce5c361">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> </table>
<table> <tr><td colspan="2"></td></tr> <tr><td colspan="2">template&lt;typename Derived &gt; </td></tr> <tr>
<td align="right" valign="top">const <a href="../classeigen_1_1cwiseunaryop">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_i0_op&lt; typename Derived::Scalar &gt;, const Derived &gt; </td>
<td valign="bottom">
<a href="namespaceeigen#ab0c429bb38ce58964b561fb9d6c9377a">bessel_i0</a> (const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename Derived &gt; </td></tr> <tr>
<td align="right" valign="top">const <a href="../classeigen_1_1cwiseunaryop">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_i0e_op&lt; typename Derived::Scalar &gt;, const Derived &gt; </td>
<td valign="bottom">
<a href="namespaceeigen#aef13ab56dea757bfb7bd3e220ac478d5">bessel_i0e</a> (const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename Derived &gt; </td></tr> <tr>
<td align="right" valign="top">const <a href="../classeigen_1_1cwiseunaryop">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_i1_op&lt; typename Derived::Scalar &gt;, const Derived &gt; </td>
<td valign="bottom">
<a href="namespaceeigen#ae35e1cabdc81f3783219186a7e658a2b">bessel_i1</a> (const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename Derived &gt; </td></tr> <tr>
<td align="right" valign="top">const <a href="../classeigen_1_1cwiseunaryop">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_i1e_op&lt; typename Derived::Scalar &gt;, const Derived &gt; </td>
<td valign="bottom">
<a href="namespaceeigen#ae52c524c4108c6265e9543468da42e28">bessel_i1e</a> (const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename Derived &gt; </td></tr> <tr>
<td align="right" valign="top">const <a href="../classeigen_1_1cwiseunaryop">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_j0_op&lt; typename Derived::Scalar &gt;, const Derived &gt; </td>
<td valign="bottom">
<a href="namespaceeigen#a65acfc33a2b6140a09af67e45928e037">bessel_j0</a> (const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename Derived &gt; </td></tr> <tr>
<td align="right" valign="top">const <a href="../classeigen_1_1cwiseunaryop">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_j1_op&lt; typename Derived::Scalar &gt;, const Derived &gt; </td>
<td valign="bottom">
<a href="namespaceeigen#a4079ddbfe44e3a865cdb600353f371ab">bessel_j1</a> (const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename Derived &gt; </td></tr> <tr>
<td align="right" valign="top">const <a href="../classeigen_1_1cwiseunaryop">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_k0_op&lt; typename Derived::Scalar &gt;, const Derived &gt; </td>
<td valign="bottom">
<a href="namespaceeigen#a4664123a5ae23d981410d7dc5cd86970">bessel_k0</a> (const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename Derived &gt; </td></tr> <tr>
<td align="right" valign="top">const <a href="../classeigen_1_1cwiseunaryop">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_k0e_op&lt; typename Derived::Scalar &gt;, const Derived &gt; </td>
<td valign="bottom">
<a href="namespaceeigen#a9cc57448af6eda4fa72f34be7cc72da5">bessel_k0e</a> (const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename Derived &gt; </td></tr> <tr>
<td align="right" valign="top">const <a href="../classeigen_1_1cwiseunaryop">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_k1_op&lt; typename Derived::Scalar &gt;, const Derived &gt; </td>
<td valign="bottom">
<a href="namespaceeigen#a76e76fa84ed24785bf32665a48157bf1">bessel_k1</a> (const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename Derived &gt; </td></tr> <tr>
<td align="right" valign="top">const <a href="../classeigen_1_1cwiseunaryop">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_k1e_op&lt; typename Derived::Scalar &gt;, const Derived &gt; </td>
<td valign="bottom">
<a href="namespaceeigen#af9e044c2baa913adea597c4d497a3315">bessel_k1e</a> (const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename Derived &gt; </td></tr> <tr>
<td align="right" valign="top">const <a href="../classeigen_1_1cwiseunaryop">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_y0_op&lt; typename Derived::Scalar &gt;, const Derived &gt; </td>
<td valign="bottom">
<a href="namespaceeigen#aad0c42bfd8d5b4169a542206b460b2d0">bessel_y0</a> (const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename Derived &gt; </td></tr> <tr>
<td align="right" valign="top">const <a href="../classeigen_1_1cwiseunaryop">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_y1_op&lt; typename Derived::Scalar &gt;, const Derived &gt; </td>
<td valign="bottom">
<a href="namespaceeigen#a60d76185793d52703fa01d83d5b46615">bessel_y1</a> (const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename ADerived , typename BDerived , typename XDerived &gt; </td></tr> <tr>
<td align="right" valign="top">const TensorCwiseTernaryOp&lt; internal::scalar_betainc_op&lt; typename XDerived::Scalar &gt;, const ADerived, const BDerived, const XDerived &gt; </td>
<td valign="bottom">
<a href="namespaceeigen#a6d7e9b581a1fc3ca3c8aff6a0a69f523">betainc</a> (const ADerived &amp;a, const BDerived &amp;b, const XDerived &amp;x)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename ArgADerived , typename ArgBDerived , typename ArgXDerived &gt; </td></tr> <tr>
<td align="right" valign="top">const <a href="../classeigen_1_1cwiseternaryop">Eigen::CwiseTernaryOp</a>&lt; Eigen::internal::scalar_betainc_op&lt; typename ArgXDerived::Scalar &gt;, const ArgADerived, const ArgBDerived, const ArgXDerived &gt; </td>
<td valign="bottom">
<a href="namespaceeigen#ac58db11132cd34e57ad819f3e77ff60c">betainc</a> (const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; ArgADerived &gt; &amp;a, const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; ArgBDerived &gt; &amp;b, const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; ArgXDerived &gt; &amp;x)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename BVH , typename Intersector &gt; </td></tr> <tr>
<td align="right" valign="top">void </td>
<td valign="bottom">
<a href="namespaceeigen#a07d8e283f082c972338f3fc4f644b2a9">BVIntersect</a> (const BVH &amp;tree, Intersector &amp;intersector)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename BVH1 , typename BVH2 , typename Intersector &gt; </td></tr> <tr>
<td align="right" valign="top">void </td>
<td valign="bottom">
<a href="namespaceeigen#ac3b8047a3ee05b5e6fec4668197a9a43">BVIntersect</a> (const BVH1 &amp;tree1, const BVH2 &amp;tree2, Intersector &amp;intersector)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename BVH , typename Minimizer &gt; </td></tr> <tr>
<td align="right" valign="top">Minimizer::Scalar </td>
<td valign="bottom">
<a href="namespaceeigen#adcbe73ac1482eacab0e18ee32c25508e">BVMinimize</a> (const BVH &amp;tree, Minimizer &amp;minimizer)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename BVH1 , typename BVH2 , typename Minimizer &gt; </td></tr> <tr>
<td align="right" valign="top">Minimizer::Scalar </td>
<td valign="bottom">
<a href="namespaceeigen#a915f6adc8b195c94a83c35de6a842556">BVMinimize</a> (const BVH1 &amp;tree1, const BVH2 &amp;tree2, Minimizer &amp;minimizer)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename Polynomial &gt; </td></tr> <tr>
<td align="right" valign="top">
<a href="../structeigen_1_1numtraits">NumTraits</a>&lt; typename Polynomial::Scalar &gt;::Real </td>
<td valign="bottom">
<a href="group__polynomials__module#ga375e3ea1f370fb76dfe0f43a89b95926">cauchy_max_bound</a> (const Polynomial &amp;poly)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename Polynomial &gt; </td></tr> <tr>
<td align="right" valign="top">
<a href="../structeigen_1_1numtraits">NumTraits</a>&lt; typename Polynomial::Scalar &gt;::Real </td>
<td valign="bottom">
<a href="group__polynomials__module#gab076afbdba0e9298a541cc4e8cc7506b">cauchy_min_bound</a> (const Polynomial &amp;poly)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename PointArrayType , typename KnotVectorType &gt; </td></tr> <tr>
<td align="right" valign="top">void </td>
<td valign="bottom">
<a href="group__splines__module#ga1b4cbde5d98411405871accf877552d2">ChordLengths</a> (const PointArrayType &amp;pts, KnotVectorType &amp;chord_lengths)</td>
</tr> <tr>
<td> </td>
<td>Computes chord length parameters which are required for spline interpolation. <a href="group__splines__module#ga1b4cbde5d98411405871accf877552d2">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename AlphaDerived , typename SampleDerived &gt; </td></tr> <tr>
<td align="right" valign="top">const <a href="../classeigen_1_1cwisebinaryop">Eigen::CwiseBinaryOp</a>&lt; Eigen::internal::scalar_gamma_sample_der_alpha_op&lt; typename AlphaDerived::Scalar &gt;, const AlphaDerived, const SampleDerived &gt; </td>
<td valign="bottom">
<a href="namespaceeigen#afd81653604859fe8e5b09552a7a800c9">gamma_sample_der_alpha</a> (const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; AlphaDerived &gt; &amp;alpha, const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; SampleDerived &gt; &amp;sample)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename Derived , typename ExponentDerived &gt; </td></tr> <tr>
<td align="right" valign="top">const <a href="../classeigen_1_1cwisebinaryop">Eigen::CwiseBinaryOp</a>&lt; Eigen::internal::scalar_igamma_op&lt; typename Derived::Scalar &gt;, const Derived, const ExponentDerived &gt; </td>
<td valign="bottom">
<a href="namespaceeigen#a6e89509c5ff1af076baea462520f231c">igamma</a> (const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;a, const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; ExponentDerived &gt; &amp;x)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename Derived , typename ExponentDerived &gt; </td></tr> <tr>
<td align="right" valign="top">const <a href="../classeigen_1_1cwisebinaryop">Eigen::CwiseBinaryOp</a>&lt; Eigen::internal::scalar_igamma_der_a_op&lt; typename Derived::Scalar &gt;, const Derived, const ExponentDerived &gt; </td>
<td valign="bottom">
<a href="namespaceeigen#ad0b09518c9ef2376690af1b346f77ff1">igamma_der_a</a> (const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;a, const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; ExponentDerived &gt; &amp;x)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename Derived , typename ExponentDerived &gt; </td></tr> <tr>
<td align="right" valign="top">const <a href="../classeigen_1_1cwisebinaryop">Eigen::CwiseBinaryOp</a>&lt; Eigen::internal::scalar_igammac_op&lt; typename Derived::Scalar &gt;, const Derived, const ExponentDerived &gt; </td>
<td valign="bottom">
<a href="namespaceeigen#a2b1593c0c3f9d1673ae5980ae03e75f1">igammac</a> (const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;a, const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; ExponentDerived &gt; &amp;x)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename KnotVectorType &gt; </td></tr> <tr>
<td align="right" valign="top">void </td>
<td valign="bottom">
<a href="group__splines__module#ga9474da5ed68bbd9a6788a999330416d6">KnotAveraging</a> (const KnotVectorType &amp;parameters, DenseIndex degree, KnotVectorType &amp;knots)</td>
</tr> <tr>
<td> </td>
<td>Computes knot averages. <a href="group__splines__module#ga9474da5ed68bbd9a6788a999330416d6">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename KnotVectorType , typename ParameterVectorType , typename IndexArray &gt; </td></tr> <tr>
<td align="right" valign="top">void </td>
<td valign="bottom">
<a href="group__splines__module#gae10a6f9b6ab7fb400a2526b6382c533b">KnotAveragingWithDerivatives</a> (const ParameterVectorType &amp;parameters, const unsigned int degree, const IndexArray &amp;derivativeIndices, KnotVectorType &amp;knots)</td>
</tr> <tr>
<td> </td>
<td>Computes knot averages when derivative constraints are present. Note that this is a technical interpretation of the referenced article since the algorithm contained therein is incorrect as written. <a href="group__splines__module#gae10a6f9b6ab7fb400a2526b6382c533b">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename A , typename B &gt; </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1kroneckerproductsparse">KroneckerProductSparse</a>&lt; A, B &gt; </td>
<td valign="bottom">
<a href="group__kroneckerproduct__module#gaca497f43cc92bcbf6eaff64984a266cc">kroneckerProduct</a> (const <a href="../structeigen_1_1eigenbase">EigenBase</a>&lt; A &gt; &amp;a, const <a href="../structeigen_1_1eigenbase">EigenBase</a>&lt; B &gt; &amp;b)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename A , typename B &gt; </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1kroneckerproduct">KroneckerProduct</a>&lt; A, B &gt; </td>
<td valign="bottom">
<a href="group__kroneckerproduct__module#gaa8924dffc6cee7aa1e908dc395a7a167">kroneckerProduct</a> (const <a href="../classeigen_1_1matrixbase">MatrixBase</a>&lt; A &gt; &amp;a, const <a href="../classeigen_1_1matrixbase">MatrixBase</a>&lt; B &gt; &amp;b)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename MatrixType , typename ResultType &gt; </td></tr> <tr>
<td align="right" valign="top">void </td>
<td valign="bottom">
<a href="group__matrixfunctions__module#ga2f490197e16df831683018e383e29346">matrix_sqrt_quasi_triangular</a> (const MatrixType &amp;<a href="../namespaceeigen#aa539408a09481d35961e11ee78793db1">arg</a>, ResultType &amp;result)</td>
</tr> <tr>
<td> </td>
<td>Compute matrix square root of quasi-triangular matrix. <a href="group__matrixfunctions__module#ga2f490197e16df831683018e383e29346">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename MatrixType , typename ResultType &gt; </td></tr> <tr>
<td align="right" valign="top">void </td>
<td valign="bottom">
<a href="group__matrixfunctions__module#gae51c91f920f6ea4a7f6f72caa1e8249f">matrix_sqrt_triangular</a> (const MatrixType &amp;<a href="../namespaceeigen#aa539408a09481d35961e11ee78793db1">arg</a>, ResultType &amp;result)</td>
</tr> <tr>
<td> </td>
<td>Compute matrix square root of triangular matrix. <a href="group__matrixfunctions__module#gae51c91f920f6ea4a7f6f72caa1e8249f">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename Polynomials , typename T &gt; </td></tr> <tr>
<td align="right" valign="top">T </td>
<td valign="bottom">
<a href="group__polynomials__module#gadb64ffddaa9e83634e3ab0e3fd3664f5">poly_eval</a> (const Polynomials &amp;poly, const T &amp;x)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename Polynomials , typename T &gt; </td></tr> <tr>
<td align="right" valign="top">T </td>
<td valign="bottom">
<a href="group__polynomials__module#gaadbf059bc28ce1cf94c57c1454633d40">poly_eval_horner</a> (const Polynomials &amp;poly, const T &amp;x)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename DerivedN , typename DerivedX &gt; </td></tr> <tr>
<td align="right" valign="top">const <a href="../classeigen_1_1cwisebinaryop">Eigen::CwiseBinaryOp</a>&lt; Eigen::internal::scalar_polygamma_op&lt; typename DerivedX::Scalar &gt;, const DerivedN, const DerivedX &gt; </td>
<td valign="bottom">
<a href="namespaceeigen#a7ec2455c3a3bb4b0c1401b25a8480361">polygamma</a> (const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; DerivedN &gt; &amp;n, const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; DerivedX &gt; &amp;x)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename RootVector , typename Polynomial &gt; </td></tr> <tr>
<td align="right" valign="top">void </td>
<td valign="bottom">
<a href="group__polynomials__module#gafbc3648f7ef67db3d5d04454fc1257fd">roots_to_monicPolynomial</a> (const RootVector &amp;rv, Polynomial &amp;poly)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename DerivedX , typename DerivedQ &gt; </td></tr> <tr>
<td align="right" valign="top">const <a href="../classeigen_1_1cwisebinaryop">Eigen::CwiseBinaryOp</a>&lt; Eigen::internal::scalar_zeta_op&lt; typename DerivedX::Scalar &gt;, const DerivedX, const DerivedQ &gt; </td>
<td valign="bottom">
<a href="namespaceeigen#ade7c45ba55113cf0c89e33972f3da434">zeta</a> (const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; DerivedX &gt; &amp;x, const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; DerivedQ &gt; &amp;q)</td>
</tr> <tr><td colspan="2"> </td></tr> </table>  <div>
<p>Namespace containing all symbols from the Eigen library. </p> </div> <a id="ab0c429bb38ce58964b561fb9d6c9377a"></a> <h2>bessel_i0()</h2> <div> <div> <div> template&lt;typename Derived &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="../classeigen_1_1cwiseunaryop">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_i0_op&lt;typename Derived::Scalar&gt;, const Derived&gt; Eigen::bessel_i0 </td> <td>(</td> <td>const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; Derived &gt; &amp; </td> <td><em>x</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>an expression of the coefficient-wise i0(<em>x</em>) to the given arrays.</dd>
</dl> <p>It returns the modified Bessel function of the first kind of order zero.</p> <dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>x</td>
<td>is the argument</td>
</tr> </table> </dd> </dl> <dl>
<dt>Note</dt>
<dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of i0(T) for any scalar type T to be supported.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>ArrayBase::bessel_i0() </dd>
</dl> </div> </div> <a id="aef13ab56dea757bfb7bd3e220ac478d5"></a> <h2>bessel_i0e()</h2> <div> <div> <div> template&lt;typename Derived &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="../classeigen_1_1cwiseunaryop">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_i0e_op&lt;typename Derived::Scalar&gt;, const Derived&gt; Eigen::bessel_i0e </td> <td>(</td> <td>const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; Derived &gt; &amp; </td> <td><em>x</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>an expression of the coefficient-wise i0e(<em>x</em>) to the given arrays.</dd>
</dl> <p>It returns the exponentially scaled modified Bessel function of the first kind of order zero.</p> <dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>x</td>
<td>is the argument</td>
</tr> </table> </dd> </dl> <dl>
<dt>Note</dt>
<dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of i0e(T) for any scalar type T to be supported.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>ArrayBase::bessel_i0e() </dd>
</dl> </div> </div> <a id="ae35e1cabdc81f3783219186a7e658a2b"></a> <h2>bessel_i1()</h2> <div> <div> <div> template&lt;typename Derived &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="../classeigen_1_1cwiseunaryop">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_i1_op&lt;typename Derived::Scalar&gt;, const Derived&gt; Eigen::bessel_i1 </td> <td>(</td> <td>const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; Derived &gt; &amp; </td> <td><em>x</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>an expression of the coefficient-wise i1(<em>x</em>) to the given arrays.</dd>
</dl> <p>It returns the modified Bessel function of the first kind of order one.</p> <dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>x</td>
<td>is the argument</td>
</tr> </table> </dd> </dl> <dl>
<dt>Note</dt>
<dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of i1(T) for any scalar type T to be supported.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>ArrayBase::bessel_i1() </dd>
</dl> </div> </div> <a id="ae52c524c4108c6265e9543468da42e28"></a> <h2>bessel_i1e()</h2> <div> <div> <div> template&lt;typename Derived &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="../classeigen_1_1cwiseunaryop">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_i1e_op&lt;typename Derived::Scalar&gt;, const Derived&gt; Eigen::bessel_i1e </td> <td>(</td> <td>const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; Derived &gt; &amp; </td> <td><em>x</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>an expression of the coefficient-wise i1e(<em>x</em>) to the given arrays.</dd>
</dl> <p>It returns the exponentially scaled modified Bessel function of the first kind of order one.</p> <dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>x</td>
<td>is the argument</td>
</tr> </table> </dd> </dl> <dl>
<dt>Note</dt>
<dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of i1e(T) for any scalar type T to be supported.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>ArrayBase::bessel_i1e() </dd>
</dl> </div> </div> <a id="a65acfc33a2b6140a09af67e45928e037"></a> <h2>bessel_j0()</h2> <div> <div> <div> template&lt;typename Derived &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="../classeigen_1_1cwiseunaryop">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_j0_op&lt;typename Derived::Scalar&gt;, const Derived&gt; Eigen::bessel_j0 </td> <td>(</td> <td>const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; Derived &gt; &amp; </td> <td><em>x</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>an expression of the coefficient-wise j0(<em>x</em>) to the given arrays.</dd>
</dl> <p>It returns the Bessel function of the first kind of order zero.</p> <dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>x</td>
<td>is the argument</td>
</tr> </table> </dd> </dl> <dl>
<dt>Note</dt>
<dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of j0(T) for any scalar type T to be supported.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>ArrayBase::bessel_j0() </dd>
</dl> </div> </div> <a id="a4079ddbfe44e3a865cdb600353f371ab"></a> <h2>bessel_j1()</h2> <div> <div> <div> template&lt;typename Derived &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="../classeigen_1_1cwiseunaryop">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_j1_op&lt;typename Derived::Scalar&gt;, const Derived&gt; Eigen::bessel_j1 </td> <td>(</td> <td>const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; Derived &gt; &amp; </td> <td><em>x</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>an expression of the coefficient-wise j1(<em>x</em>) to the given arrays.</dd>
</dl> <p>It returns the modified Bessel function of the first kind of order one.</p> <dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>x</td>
<td>is the argument</td>
</tr> </table> </dd> </dl> <dl>
<dt>Note</dt>
<dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of j1(T) for any scalar type T to be supported.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>ArrayBase::bessel_j1() </dd>
</dl> </div> </div> <a id="a4664123a5ae23d981410d7dc5cd86970"></a> <h2>bessel_k0()</h2> <div> <div> <div> template&lt;typename Derived &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="../classeigen_1_1cwiseunaryop">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_k0_op&lt;typename Derived::Scalar&gt;, const Derived&gt; Eigen::bessel_k0 </td> <td>(</td> <td>const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; Derived &gt; &amp; </td> <td><em>x</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>an expression of the coefficient-wise k0(<em>x</em>) to the given arrays.</dd>
</dl> <p>It returns the modified Bessel function of the second kind of order zero.</p> <dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>x</td>
<td>is the argument</td>
</tr> </table> </dd> </dl> <dl>
<dt>Note</dt>
<dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of k0(T) for any scalar type T to be supported.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>ArrayBase::bessel_k0() </dd>
</dl> </div> </div> <a id="a9cc57448af6eda4fa72f34be7cc72da5"></a> <h2>bessel_k0e()</h2> <div> <div> <div> template&lt;typename Derived &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="../classeigen_1_1cwiseunaryop">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_k0e_op&lt;typename Derived::Scalar&gt;, const Derived&gt; Eigen::bessel_k0e </td> <td>(</td> <td>const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; Derived &gt; &amp; </td> <td><em>x</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>an expression of the coefficient-wise k0e(<em>x</em>) to the given arrays.</dd>
</dl> <p>It returns the exponentially scaled modified Bessel function of the second kind of order zero.</p> <dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>x</td>
<td>is the argument</td>
</tr> </table> </dd> </dl> <dl>
<dt>Note</dt>
<dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of k0e(T) for any scalar type T to be supported.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>ArrayBase::bessel_k0e() </dd>
</dl> </div> </div> <a id="a76e76fa84ed24785bf32665a48157bf1"></a> <h2>bessel_k1()</h2> <div> <div> <div> template&lt;typename Derived &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="../classeigen_1_1cwiseunaryop">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_k1_op&lt;typename Derived::Scalar&gt;, const Derived&gt; Eigen::bessel_k1 </td> <td>(</td> <td>const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; Derived &gt; &amp; </td> <td><em>x</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>an expression of the coefficient-wise k1(<em>x</em>) to the given arrays.</dd>
</dl> <p>It returns the modified Bessel function of the second kind of order one.</p> <dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>x</td>
<td>is the argument</td>
</tr> </table> </dd> </dl> <dl>
<dt>Note</dt>
<dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of k1(T) for any scalar type T to be supported.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>ArrayBase::bessel_k1() </dd>
</dl> </div> </div> <a id="af9e044c2baa913adea597c4d497a3315"></a> <h2>bessel_k1e()</h2> <div> <div> <div> template&lt;typename Derived &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="../classeigen_1_1cwiseunaryop">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_k1e_op&lt;typename Derived::Scalar&gt;, const Derived&gt; Eigen::bessel_k1e </td> <td>(</td> <td>const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; Derived &gt; &amp; </td> <td><em>x</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>an expression of the coefficient-wise k1e(<em>x</em>) to the given arrays.</dd>
</dl> <p>It returns the exponentially scaled modified Bessel function of the second kind of order one.</p> <dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>x</td>
<td>is the argument</td>
</tr> </table> </dd> </dl> <dl>
<dt>Note</dt>
<dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of k1e(T) for any scalar type T to be supported.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>ArrayBase::bessel_k1e() </dd>
</dl> </div> </div> <a id="aad0c42bfd8d5b4169a542206b460b2d0"></a> <h2>bessel_y0()</h2> <div> <div> <div> template&lt;typename Derived &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="../classeigen_1_1cwiseunaryop">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_y0_op&lt;typename Derived::Scalar&gt;, const Derived&gt; Eigen::bessel_y0 </td> <td>(</td> <td>const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; Derived &gt; &amp; </td> <td><em>x</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>an expression of the coefficient-wise y0(<em>x</em>) to the given arrays.</dd>
</dl> <p>It returns the Bessel function of the second kind of order zero.</p> <dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>x</td>
<td>is the argument</td>
</tr> </table> </dd> </dl> <dl>
<dt>Note</dt>
<dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of y0(T) for any scalar type T to be supported.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>ArrayBase::bessel_y0() </dd>
</dl> </div> </div> <a id="a60d76185793d52703fa01d83d5b46615"></a> <h2>bessel_y1()</h2> <div> <div> <div> template&lt;typename Derived &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="../classeigen_1_1cwiseunaryop">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_y1_op&lt;typename Derived::Scalar&gt;, const Derived&gt; Eigen::bessel_y1 </td> <td>(</td> <td>const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; Derived &gt; &amp; </td> <td><em>x</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>an expression of the coefficient-wise y1(<em>x</em>) to the given arrays.</dd>
</dl> <p>It returns the Bessel function of the second kind of order one.</p> <dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>x</td>
<td>is the argument</td>
</tr> </table> </dd> </dl> <dl>
<dt>Note</dt>
<dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of y1(T) for any scalar type T to be supported.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>ArrayBase::bessel_y1() </dd>
</dl> </div> </div> <a id="a6d7e9b581a1fc3ca3c8aff6a0a69f523"></a> <h2>betainc() <span>[1/2]</span>
</h2> <div> <div> <div> template&lt;typename ADerived , typename BDerived , typename XDerived &gt; </div> <table> <tr> <td> <table> <tr> <td>const TensorCwiseTernaryOp&lt;internal::scalar_betainc_op&lt;typename XDerived::Scalar&gt;, const ADerived, const BDerived, const XDerived&gt; Eigen::betainc </td> <td>(</td> <td>const ADerived &amp; </td> <td>
<em>a</em>, </td> </tr> <tr> <td></td> <td></td> <td>const BDerived &amp; </td> <td>
<em>b</em>, </td> </tr> <tr> <td></td> <td></td> <td>const XDerived &amp; </td> <td>
<em>x</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p><span>[c++11]</span> </p>
<dl>
<dt>Returns</dt>
<dd>an expression of the coefficient-wise betainc(<em>x</em>, <em>a</em>, <em>b</em>) to the given tensors.</dd>
</dl> <p>This function computes the regularized incomplete beta function (integral). </p> </div> </div> <a id="ac58db11132cd34e57ad819f3e77ff60c"></a> <h2>betainc() <span>[2/2]</span>
</h2> <div> <div> <div> template&lt;typename ArgADerived , typename ArgBDerived , typename ArgXDerived &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="../classeigen_1_1cwiseternaryop">Eigen::CwiseTernaryOp</a>&lt;Eigen::internal::scalar_betainc_op&lt;typename ArgXDerived::Scalar&gt;, const ArgADerived, const ArgBDerived, const ArgXDerived&gt; Eigen::betainc </td> <td>(</td> <td>const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; ArgADerived &gt; &amp; </td> <td>
<em>a</em>, </td> </tr> <tr> <td></td> <td></td> <td>const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; ArgBDerived &gt; &amp; </td> <td>
<em>b</em>, </td> </tr> <tr> <td></td> <td></td> <td>const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; ArgXDerived &gt; &amp; </td> <td>
<em>x</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p><span>[c++11]</span> </p>
<dl>
<dt>Returns</dt>
<dd>an expression of the coefficient-wise betainc(<em>x</em>, <em>a</em>, <em>b</em>) to the given arrays.</dd>
</dl> <p>This function computes the regularized incomplete beta function (integral).</p> <dl>
<dt>Note</dt>
<dd>This function supports only float and double scalar types in c++11 mode. To support other scalar types, or float/double in non c++11 mode, the user has to provide implementations of betainc(T,T,T) for any scalar type T to be supported.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>
<a href="namespaceeigen#a6d7e9b581a1fc3ca3c8aff6a0a69f523">Eigen::betainc()</a>, <a href="../namespaceeigen#ac2e6331628bb1989b7be6d7e42827649">Eigen::lgamma()</a> </dd>
</dl> </div> </div> <a id="a07d8e283f082c972338f3fc4f644b2a9"></a> <h2>BVIntersect() <span>[1/2]</span>
</h2> <div> <div> <div> template&lt;typename BVH , typename Intersector &gt; </div> <table> <tr> <td>void Eigen::BVIntersect </td> <td>(</td> <td>const BVH &amp; </td> <td>
<em>tree</em>, </td> </tr> <tr> <td></td> <td></td> <td>Intersector &amp; </td> <td>
<em>intersector</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </div>
<div> <p>Given a BVH, runs the query encapsulated by <em>intersector</em>. The Intersector type must provide the following members:</p>
<pre data-language="cpp"><span>bool</span> intersectVolume(<span>const</span> BVH::Volume &amp;volume) <span>//returns true if volume intersects the query</span>
<span>bool</span> intersectObject(<span>const</span> BVH::Object &amp;<span>object</span>) <span>//returns true if the search should terminate immediately</span>
</pre> </div> </div> <a id="ac3b8047a3ee05b5e6fec4668197a9a43"></a> <h2>BVIntersect() <span>[2/2]</span>
</h2> <div> <div> <div> template&lt;typename BVH1 , typename BVH2 , typename Intersector &gt; </div> <table> <tr> <td>void Eigen::BVIntersect </td> <td>(</td> <td>const BVH1 &amp; </td> <td>
<em>tree1</em>, </td> </tr> <tr> <td></td> <td></td> <td>const BVH2 &amp; </td> <td>
<em>tree2</em>, </td> </tr> <tr> <td></td> <td></td> <td>Intersector &amp; </td> <td>
<em>intersector</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </div>
<div> <p>Given two BVH's, runs the query on their Cartesian product encapsulated by <em>intersector</em>. The Intersector type must provide the following members:</p>
<pre data-language="cpp"><span>bool</span> intersectVolumeVolume(<span>const</span> BVH1::Volume &amp;v1, <span>const</span> BVH2::Volume &amp;v2) <span>//returns true if product of volumes intersects the query</span>
<span>bool</span> intersectVolumeObject(<span>const</span> BVH1::Volume &amp;v1, <span>const</span> BVH2::Object &amp;o2) <span>//returns true if the volume-object product intersects the query</span>
<span>bool</span> intersectObjectVolume(<span>const</span> BVH1::Object &amp;o1, <span>const</span> BVH2::Volume &amp;v2) <span>//returns true if the volume-object product intersects the query</span>
<span>bool</span> intersectObjectObject(<span>const</span> BVH1::Object &amp;o1, <span>const</span> BVH2::Object &amp;o2) <span>//returns true if the search should terminate immediately</span>
</pre> </div> </div> <a id="adcbe73ac1482eacab0e18ee32c25508e"></a> <h2>BVMinimize() <span>[1/2]</span>
</h2> <div> <div> <div> template&lt;typename BVH , typename Minimizer &gt; </div> <table> <tr> <td>Minimizer::Scalar Eigen::BVMinimize </td> <td>(</td> <td>const BVH &amp; </td> <td>
<em>tree</em>, </td> </tr> <tr> <td></td> <td></td> <td>Minimizer &amp; </td> <td>
<em>minimizer</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </div>
<div> <p>Given a BVH, runs the query encapsulated by <em>minimizer</em>. </p>
<dl>
<dt>Returns</dt>
<dd>the minimum value. The Minimizer type must provide the following members:<pre data-language="cpp"><span>typedef</span> Scalar <span>//the numeric type of what is being minimized--not necessarily the Scalar type of the BVH (if it has one)</span>
Scalar minimumOnVolume(<span>const</span> BVH::Volume &amp;volume)
Scalar minimumOnObject(<span>const</span> BVH::Object &amp;<span>object</span>)
</pre> </dd>
</dl> </div> </div> <a id="a915f6adc8b195c94a83c35de6a842556"></a> <h2>BVMinimize() <span>[2/2]</span>
</h2> <div> <div> <div> template&lt;typename BVH1 , typename BVH2 , typename Minimizer &gt; </div> <table> <tr> <td>Minimizer::Scalar Eigen::BVMinimize </td> <td>(</td> <td>const BVH1 &amp; </td> <td>
<em>tree1</em>, </td> </tr> <tr> <td></td> <td></td> <td>const BVH2 &amp; </td> <td>
<em>tree2</em>, </td> </tr> <tr> <td></td> <td></td> <td>Minimizer &amp; </td> <td>
<em>minimizer</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </div>
<div> <p>Given two BVH's, runs the query on their cartesian product encapsulated by <em>minimizer</em>. </p>
<dl>
<dt>Returns</dt>
<dd>the minimum value. The Minimizer type must provide the following members:<pre data-language="cpp"><span>typedef</span> Scalar <span>//the numeric type of what is being minimized--not necessarily the Scalar type of the BVH (if it has one)</span>
Scalar minimumOnVolumeVolume(<span>const</span> BVH1::Volume &amp;v1, <span>const</span> BVH2::Volume &amp;v2)
Scalar minimumOnVolumeObject(<span>const</span> BVH1::Volume &amp;v1, <span>const</span> BVH2::Object &amp;o2)
Scalar minimumOnObjectVolume(<span>const</span> BVH1::Object &amp;o1, <span>const</span> BVH2::Volume &amp;v2)
Scalar minimumOnObjectObject(<span>const</span> BVH1::Object &amp;o1, <span>const</span> BVH2::Object &amp;o2)
</pre> </dd>
</dl> </div> </div> <a id="afd81653604859fe8e5b09552a7a800c9"></a> <h2>gamma_sample_der_alpha()</h2> <div> <div> <div> template&lt;typename AlphaDerived , typename SampleDerived &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="../classeigen_1_1cwisebinaryop">Eigen::CwiseBinaryOp</a>&lt;Eigen::internal::scalar_gamma_sample_der_alpha_op&lt;typename AlphaDerived::Scalar&gt;, const AlphaDerived, const SampleDerived&gt; Eigen::gamma_sample_der_alpha </td> <td>(</td> <td>const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; AlphaDerived &gt; &amp; </td> <td>
<em>alpha</em>, </td> </tr> <tr> <td></td> <td></td> <td>const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; SampleDerived &gt; &amp; </td> <td>
<em>sample</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p><span>[c++11]</span> </p>
<dl>
<dt>Returns</dt>
<dd>an expression of the coefficient-wise gamma_sample_der_alpha(<em>alpha</em>, <em>sample</em>) to the given arrays.</dd>
</dl> <p>This function computes the coefficient-wise derivative of the sample of a Gamma(alpha, 1) random variable with respect to the parameter alpha.</p> <dl>
<dt>Note</dt>
<dd>This function supports only float and double scalar types in c++11 mode. To support other scalar types, or float/double in non c++11 mode, the user has to provide implementations of gamma_sample_der_alpha(T,T) for any scalar type T to be supported.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>
<a href="namespaceeigen#a6e89509c5ff1af076baea462520f231c">Eigen::igamma()</a>, <a href="../namespaceeigen#ac2e6331628bb1989b7be6d7e42827649">Eigen::lgamma()</a> </dd>
</dl> </div> </div> <a id="a6e89509c5ff1af076baea462520f231c"></a> <h2>igamma()</h2> <div> <div> <div> template&lt;typename Derived , typename ExponentDerived &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="../classeigen_1_1cwisebinaryop">Eigen::CwiseBinaryOp</a>&lt;Eigen::internal::scalar_igamma_op&lt;typename Derived::Scalar&gt;, const Derived, const ExponentDerived&gt; Eigen::igamma </td> <td>(</td> <td>const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; Derived &gt; &amp; </td> <td>
<em>a</em>, </td> </tr> <tr> <td></td> <td></td> <td>const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; ExponentDerived &gt; &amp; </td> <td>
<em>x</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p><span>[c++11]</span> </p>
<dl>
<dt>Returns</dt>
<dd>an expression of the coefficient-wise igamma(<em>a</em>, <em>x</em>) to the given arrays.</dd>
</dl> <p>This function computes the coefficient-wise incomplete gamma function.</p> <dl>
<dt>Note</dt>
<dd>This function supports only float and double scalar types in c++11 mode. To support other scalar types, or float/double in non c++11 mode, the user has to provide implementations of igammac(T,T) for any scalar type T to be supported.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>
<a href="namespaceeigen#a2b1593c0c3f9d1673ae5980ae03e75f1">Eigen::igammac()</a>, <a href="../namespaceeigen#ac2e6331628bb1989b7be6d7e42827649">Eigen::lgamma()</a> </dd>
</dl> </div> </div> <a id="ad0b09518c9ef2376690af1b346f77ff1"></a> <h2>igamma_der_a()</h2> <div> <div> <div> template&lt;typename Derived , typename ExponentDerived &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="../classeigen_1_1cwisebinaryop">Eigen::CwiseBinaryOp</a>&lt;Eigen::internal::scalar_igamma_der_a_op&lt;typename Derived::Scalar&gt;, const Derived, const ExponentDerived&gt; Eigen::igamma_der_a </td> <td>(</td> <td>const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; Derived &gt; &amp; </td> <td>
<em>a</em>, </td> </tr> <tr> <td></td> <td></td> <td>const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; ExponentDerived &gt; &amp; </td> <td>
<em>x</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p><span>[c++11]</span> </p>
<dl>
<dt>Returns</dt>
<dd>an expression of the coefficient-wise igamma_der_a(<em>a</em>, <em>x</em>) to the given arrays.</dd>
</dl> <p>This function computes the coefficient-wise derivative of the incomplete gamma function with respect to the parameter a.</p> <dl>
<dt>Note</dt>
<dd>This function supports only float and double scalar types in c++11 mode. To support other scalar types, or float/double in non c++11 mode, the user has to provide implementations of igamma_der_a(T,T) for any scalar type T to be supported.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>
<a href="namespaceeigen#a6e89509c5ff1af076baea462520f231c">Eigen::igamma()</a>, <a href="../namespaceeigen#ac2e6331628bb1989b7be6d7e42827649">Eigen::lgamma()</a> </dd>
</dl> </div> </div> <a id="a2b1593c0c3f9d1673ae5980ae03e75f1"></a> <h2>igammac()</h2> <div> <div> <div> template&lt;typename Derived , typename ExponentDerived &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="../classeigen_1_1cwisebinaryop">Eigen::CwiseBinaryOp</a>&lt;Eigen::internal::scalar_igammac_op&lt;typename Derived::Scalar&gt;, const Derived, const ExponentDerived&gt; Eigen::igammac </td> <td>(</td> <td>const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; Derived &gt; &amp; </td> <td>
<em>a</em>, </td> </tr> <tr> <td></td> <td></td> <td>const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; ExponentDerived &gt; &amp; </td> <td>
<em>x</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p><span>[c++11]</span> </p>
<dl>
<dt>Returns</dt>
<dd>an expression of the coefficient-wise igammac(<em>a</em>, <em>x</em>) to the given arrays.</dd>
</dl> <p>This function computes the coefficient-wise complementary incomplete gamma function.</p> <dl>
<dt>Note</dt>
<dd>This function supports only float and double scalar types in c++11 mode. To support other scalar types, or float/double in non c++11 mode, the user has to provide implementations of igammac(T,T) for any scalar type T to be supported.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>
<a href="namespaceeigen#a6e89509c5ff1af076baea462520f231c">Eigen::igamma()</a>, <a href="../namespaceeigen#ac2e6331628bb1989b7be6d7e42827649">Eigen::lgamma()</a> </dd>
</dl> </div> </div> <a id="a7ec2455c3a3bb4b0c1401b25a8480361"></a> <h2>polygamma()</h2> <div> <div> <div> template&lt;typename DerivedN , typename DerivedX &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="../classeigen_1_1cwisebinaryop">Eigen::CwiseBinaryOp</a>&lt;Eigen::internal::scalar_polygamma_op&lt;typename DerivedX::Scalar&gt;, const DerivedN, const DerivedX&gt; Eigen::polygamma </td> <td>(</td> <td>const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; DerivedN &gt; &amp; </td> <td>
<em>n</em>, </td> </tr> <tr> <td></td> <td></td> <td>const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; DerivedX &gt; &amp; </td> <td>
<em>x</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p><span>[c++11]</span> </p>
<dl>
<dt>Returns</dt>
<dd>an expression of the coefficient-wise polygamma(<em>n</em>, <em>x</em>) to the given arrays.</dd>
</dl> <p>It returns the <em>n</em> -th derivative of the digamma(psi) evaluated at <code>x</code>.</p> <dl>
<dt>Note</dt>
<dd>This function supports only float and double scalar types in c++11 mode. To support other scalar types, or float/double in non c++11 mode, the user has to provide implementations of polygamma(T,T) for any scalar type T to be supported.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>
<a href="../namespaceeigen#af40db84b3db19fe25fe2f77c429420e5">Eigen::digamma()</a> </dd>
</dl> </div> </div> <a id="ade7c45ba55113cf0c89e33972f3da434"></a> <h2>zeta()</h2> <div> <div> <div> template&lt;typename DerivedX , typename DerivedQ &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="../classeigen_1_1cwisebinaryop">Eigen::CwiseBinaryOp</a>&lt;Eigen::internal::scalar_zeta_op&lt;typename DerivedX::Scalar&gt;, const DerivedX, const DerivedQ&gt; Eigen::zeta </td> <td>(</td> <td>const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; DerivedX &gt; &amp; </td> <td>
<em>x</em>, </td> </tr> <tr> <td></td> <td></td> <td>const <a href="../classeigen_1_1arraybase">Eigen::ArrayBase</a>&lt; DerivedQ &gt; &amp; </td> <td>
<em>q</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>an expression of the coefficient-wise zeta(<em>x</em>, <em>q</em>) to the given arrays.</dd>
</dl> <p>It returns the Riemann zeta function of two arguments <em>x</em> and <em>q:</em> </p> <dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>x</td>
<td>is the exponent, it must be &gt; 1 </td>
</tr> <tr>
<td>q</td>
<td>is the shift, it must be &gt; 0</td>
</tr> </table> </dd> </dl> <dl>
<dt>Note</dt>
<dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of zeta(T,T) for any scalar type T to be supported.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>ArrayBase::zeta() </dd>
</dl> </div> </div> </div> <div class="_attribution">
  <p class="_attribution-p">
     Eigen.<br>Licensed under the MPL2 License.<br>
    <a href="https://eigen.tuxfamily.org/dox/unsupported/namespaceEigen.html" class="_attribution-link">https://eigen.tuxfamily.org/dox/unsupported/namespaceEigen.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
