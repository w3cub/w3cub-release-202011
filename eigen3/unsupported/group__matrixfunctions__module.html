
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Matrix Functions Module - Eigen3 - W3cubDocs</title>
  
  <meta name="description" content=" This module aims to provide various methods for the computation of matrix functions. ">
  <meta name="keywords" content="matrix, functions, module, matrixbase, methods, defined, matrixfunctions, eigen, eigen3">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/eigen3/unsupported/group__matrixfunctions__module.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-f16eecbe420d8b2925d31ffbb21d05646497ecbd9515f08ffe69e9bba7332f5657accc7003c7f6c72cb4a132171acf171b359ae3bae4ae5660ddfb1718f88c67.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/eigen3.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/eigen3/" class="_nav-link" title="" style="margin-left:0;">Eigen3</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _eigen3">
				
				
<h1>Matrix functions module</h1>      <div>  <p>This module aims to provide various methods for the computation of matrix functions. </p> <p>To use this module, add </p>
<pre data-language="cpp"><span>#include &lt;unsupported/Eigen/MatrixFunctions&gt;</span>
</pre>
<p> at the start of your source file.</p> <p>This module defines the following MatrixBase methods.</p>
<ul> <li>
<a href="group__matrixfunctions__module#matrixbase_cos">MatrixBase::cos()</a>, for computing the matrix cosine</li> <li>
<a href="group__matrixfunctions__module#matrixbase_cosh">MatrixBase::cosh()</a>, for computing the matrix hyperbolic cosine</li> <li>
<a href="group__matrixfunctions__module#matrixbase_exp">MatrixBase::exp()</a>, for computing the matrix exponential</li> <li>
<a href="group__matrixfunctions__module#matrixbase_log">MatrixBase::log()</a>, for computing the matrix logarithm</li> <li>
<a href="group__matrixfunctions__module#matrixbase_pow">MatrixBase::pow()</a>, for computing the matrix power</li> <li>
<a href="group__matrixfunctions__module#matrixbase_matrixfunction">MatrixBase::matrixFunction()</a>, for computing general matrix functions</li> <li>
<a href="group__matrixfunctions__module#matrixbase_sin">MatrixBase::sin()</a>, for computing the matrix sine</li> <li>
<a href="group__matrixfunctions__module#matrixbase_sinh">MatrixBase::sinh()</a>, for computing the matrix hyperbolic sine</li> <li>
<a href="group__matrixfunctions__module#matrixbase_sqrt">MatrixBase::sqrt()</a>, for computing the matrix square root</li> </ul> <p>These methods are the main entry points to this module.</p> <p>Matrix functions are defined as follows. Suppose that \( f \) is an entire function (that is, a function on the complex plane that is everywhere complex differentiable). Then its Taylor series </p>
<p> \[ f(0) + f'(0) x + \frac{f''(0)}{2} x^2 + \frac{f'''(0)}{3!} x^3 + \cdots \] </p> <p> converges to \( f(x) \). In this case, we can define the matrix function by the same series: </p>
<p> \[ f(M) = f(0) + f'(0) M + \frac{f''(0)}{2} M^2 + \frac{f'''(0)}{3!} M^3 + \cdots \] </p> <table> <tr><td colspan="2"></td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1matrixcomplexpowerreturnvalue">Eigen::MatrixComplexPowerReturnValue&lt; Derived &gt;</a></td>
</tr> <tr>
<td> </td>
<td>Proxy for the matrix power of some matrix (expression). <a href="classeigen_1_1matrixcomplexpowerreturnvalue#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">struct </td>
<td valign="bottom"><a href="structeigen_1_1matrixexponentialreturnvalue">Eigen::MatrixExponentialReturnValue&lt; Derived &gt;</a></td>
</tr> <tr>
<td> </td>
<td>Proxy for the matrix exponential of some matrix (expression). <a href="structeigen_1_1matrixexponentialreturnvalue#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1matrixfunctionreturnvalue">Eigen::MatrixFunctionReturnValue&lt; Derived &gt;</a></td>
</tr> <tr>
<td> </td>
<td>Proxy for the matrix function of some matrix (expression). <a href="classeigen_1_1matrixfunctionreturnvalue#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1matrixlogarithmreturnvalue">Eigen::MatrixLogarithmReturnValue&lt; Derived &gt;</a></td>
</tr> <tr>
<td> </td>
<td>Proxy for the matrix logarithm of some matrix (expression). <a href="classeigen_1_1matrixlogarithmreturnvalue#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1matrixpower">Eigen::MatrixPower&lt; MatrixType &gt;</a></td>
</tr> <tr>
<td> </td>
<td>Class for computing matrix powers. <a href="classeigen_1_1matrixpower#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1matrixpoweratomic">Eigen::MatrixPowerAtomic&lt; MatrixType &gt;</a></td>
</tr> <tr>
<td> </td>
<td>Class for computing matrix powers. <a href="classeigen_1_1matrixpoweratomic#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1matrixpowerparenthesesreturnvalue">Eigen::MatrixPowerParenthesesReturnValue&lt; MatrixType &gt;</a></td>
</tr> <tr>
<td> </td>
<td>Proxy for the matrix power of some matrix. <a href="classeigen_1_1matrixpowerparenthesesreturnvalue#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1matrixpowerreturnvalue">Eigen::MatrixPowerReturnValue&lt; Derived &gt;</a></td>
</tr> <tr>
<td> </td>
<td>Proxy for the matrix power of some matrix (expression). <a href="classeigen_1_1matrixpowerreturnvalue#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1matrixsquarerootreturnvalue">Eigen::MatrixSquareRootReturnValue&lt; Derived &gt;</a></td>
</tr> <tr>
<td> </td>
<td>Proxy for the matrix square root of some matrix (expression). <a href="classeigen_1_1matrixsquarerootreturnvalue#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> </table>
<table> <tr><td colspan="2"></td></tr> <tr><td colspan="2">template&lt;typename MatrixType , typename ResultType &gt; </td></tr> <tr>
<td align="right" valign="top">void </td>
<td valign="bottom">
<a href="group__matrixfunctions__module#ga2f490197e16df831683018e383e29346">Eigen::matrix_sqrt_quasi_triangular</a> (const MatrixType &amp;<a href="../namespaceeigen#aa539408a09481d35961e11ee78793db1">arg</a>, ResultType &amp;result)</td>
</tr> <tr>
<td> </td>
<td>Compute matrix square root of quasi-triangular matrix. <a href="group__matrixfunctions__module#ga2f490197e16df831683018e383e29346">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename MatrixType , typename ResultType &gt; </td></tr> <tr>
<td align="right" valign="top">void </td>
<td valign="bottom">
<a href="group__matrixfunctions__module#gae51c91f920f6ea4a7f6f72caa1e8249f">Eigen::matrix_sqrt_triangular</a> (const MatrixType &amp;<a href="../namespaceeigen#aa539408a09481d35961e11ee78793db1">arg</a>, ResultType &amp;result)</td>
</tr> <tr>
<td> </td>
<td>Compute matrix square root of triangular matrix. <a href="group__matrixfunctions__module#gae51c91f920f6ea4a7f6f72caa1e8249f">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> </table> <div>
<h1>
<a id="matrixbaseextra"></a> MatrixBase methods defined in the MatrixFunctions module</h1> <p>The remainder of the page documents the following MatrixBase methods which are defined in the MatrixFunctions module.</p> <h2>
<a id="matrixbase_cos"></a> MatrixBase::cos()</h2> <p>Compute the matrix cosine.</p> <pre data-language="cpp"><span>const</span> MatrixFunctionReturnValue&lt;Derived&gt; MatrixBase&lt;Derived&gt;::cos() const
</pre>
<dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>[in]</td>
<td>M</td>
<td>a square matrix. </td>
</tr> </table> </dd> </dl> <dl>
<dt>Returns</dt>
<dd>expression representing \( \cos(M) \).</dd>
</dl> <p>This function computes the matrix cosine. Use ArrayBase::cos() for computing the entry-wise cosine.</p> <p>The implementation calls <a href="group__matrixfunctions__module#matrixbase_matrixfunction">matrixFunction()</a> with StdStemFunctions::cos().</p> <dl>
<dt>See also</dt>
<dd>
<a href="group__matrixfunctions__module#matrixbase_sin">sin()</a> for an example.</dd>
</dl> <h2>
<a id="matrixbase_cosh"></a> MatrixBase::cosh()</h2> <p>Compute the matrix hyberbolic cosine.</p> <pre data-language="cpp"><span>const</span> MatrixFunctionReturnValue&lt;Derived&gt; MatrixBase&lt;Derived&gt;::cosh() const
</pre>
<dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>[in]</td>
<td>M</td>
<td>a square matrix. </td>
</tr> </table> </dd> </dl> <dl>
<dt>Returns</dt>
<dd>expression representing \( \cosh(M) \)</dd>
</dl> <p>This function calls <a href="group__matrixfunctions__module#matrixbase_matrixfunction">matrixFunction()</a> with StdStemFunctions::cosh().</p> <dl>
<dt>See also</dt>
<dd>
<a href="group__matrixfunctions__module#matrixbase_sinh">sinh()</a> for an example.</dd>
</dl> <h2>
<a id="matrixbase_exp"></a> MatrixBase::exp()</h2> <p>Compute the matrix exponential.</p> <pre data-language="cpp"><span>const</span> MatrixExponentialReturnValue&lt;Derived&gt; MatrixBase&lt;Derived&gt;::exp() const
</pre>
<dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>[in]</td>
<td>M</td>
<td>matrix whose exponential is to be computed. </td>
</tr> </table> </dd> </dl> <dl>
<dt>Returns</dt>
<dd>expression representing the matrix exponential of <code>M</code>.</dd>
</dl> <p>The matrix exponential of \( M \) is defined by </p>
<p> \[ \exp(M) = \sum_{k=0}^\infty \frac{M^k}{k!}. \] </p> <p> The matrix exponential can be used to solve linear ordinary differential equations: the solution of \( y' = My \) with the initial condition \( y(0) = y_0 \) is given by \( y(t) = \exp(M) y_0 \).</p> <p>The matrix exponential is different from applying the exp function to all the entries in the matrix. Use ArrayBase::exp() if you want to do the latter.</p> <p>The cost of the computation is approximately \( 20 n^3 \) for matrices of size \( n \). The number 20 depends weakly on the norm of the matrix.</p> <p>The matrix exponential is computed using the scaling-and-squaring method combined with Padé approximation. The matrix is first rescaled, then the exponential of the reduced matrix is computed approximant, and then the rescaling is undone by repeated squaring. The degree of the Padé approximant is chosen such that the approximation error is less than the round-off error. However, errors may accumulate during the squaring phase.</p> <p>Details of the algorithm can be found in: Nicholas J. Higham, "The scaling and squaring method for the matrix exponential revisited," <em>SIAM J. Matrix Anal. Applic.</em>, <b>26</b>:1179–1193, 2005.</p> <p>Example: The following program checks that </p>
<p> \[ \exp \left[ \begin{array}{ccc} 0 &amp; \frac14\pi &amp; 0 \\ -\frac14\pi &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 \end{array} \right] = \left[ \begin{array}{ccc} \frac12\sqrt2 &amp; -\frac12\sqrt2 &amp; 0 \\ \frac12\sqrt2 &amp; \frac12\sqrt2 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{array} \right]. \] </p> <p> This corresponds to a rotation of \( \frac14\pi \) radians around the z-axis.</p> <pre data-language="cpp"><span>#include &lt;unsupported/Eigen/MatrixFunctions&gt;</span>
<span>#include &lt;iostream&gt;</span>
 
<span>using namespace </span><a href="namespaceeigen">Eigen</a>;
 
<span>int</span> main()
{
  <span>const</span> <span>double</span> pi = std::acos(-1.0);
 
  MatrixXd A(3,3);
  A &lt;&lt; 0,    -pi/4, 0,
       pi/4, 0,     0,
       0,    0,     0;
  std::cout &lt;&lt; <span>"The matrix A is:\n"</span> &lt;&lt; A &lt;&lt; <span>"\n\n"</span>;
  std::cout &lt;&lt; <span>"The matrix exponential of A is:\n"</span> &lt;&lt; A.exp() &lt;&lt; <span>"\n\n"</span>;
}</pre>
<p> Output: </p>
<pre>The matrix A is:
        0 -0.785398         0
 0.785398         0         0
        0         0         0

The matrix exponential of A is:
 0.707107 -0.707107         0
 0.707107  0.707107         0
        0         0         1

</pre>
<dl>
<dt>Note</dt>
<dd>
<code>M</code> has to be a matrix of <code>float</code>, <code>double</code>, <code>long double</code> <code>complex&lt;float&gt;</code>, <code>complex&lt;double&gt;</code>, or <code>complex&lt;long double&gt;</code> .</dd>
</dl> <h2>
<a id="matrixbase_log"></a> MatrixBase::log()</h2> <p>Compute the matrix logarithm.</p> <pre data-language="cpp"><span>const</span> MatrixLogarithmReturnValue&lt;Derived&gt; MatrixBase&lt;Derived&gt;::log() const
</pre>
<dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>[in]</td>
<td>M</td>
<td>invertible matrix whose logarithm is to be computed. </td>
</tr> </table> </dd> </dl> <dl>
<dt>Returns</dt>
<dd>expression representing the matrix logarithm root of <code>M</code>.</dd>
</dl> <p>The matrix logarithm of \( M \) is a matrix \( X \) such that \( \exp(X) = M \) where exp denotes the matrix exponential. As for the scalar logarithm, the equation \( \exp(X) = M \) may have multiple solutions; this function returns a matrix whose eigenvalues have imaginary part in the interval \( (-\pi,\pi] \).</p> <p>The matrix logarithm is different from applying the log function to all the entries in the matrix. Use ArrayBase::log() if you want to do the latter.</p> <p>In the real case, the matrix \( M \) should be invertible and it should have no eigenvalues which are real and negative (pairs of complex conjugate eigenvalues are allowed). In the complex case, it only needs to be invertible.</p> <p>This function computes the matrix logarithm using the Schur-Parlett algorithm as implemented by MatrixBase::matrixFunction(). The logarithm of an atomic block is computed by MatrixLogarithmAtomic, which uses direct computation for 1-by-1 and 2-by-2 blocks and an inverse scaling-and-squaring algorithm for bigger blocks, with the square roots computed by MatrixBase::sqrt().</p> <p>Details of the algorithm can be found in Section 11.6.2 of: Nicholas J. Higham, <em>Functions of Matrices: Theory and Computation</em>, SIAM 2008. ISBN 978-0-898716-46-7.</p> <p>Example: The following program checks that </p>
<p> \[ \log \left[ \begin{array}{ccc} \frac12\sqrt2 &amp; -\frac12\sqrt2 &amp; 0 \\ \frac12\sqrt2 &amp; \frac12\sqrt2 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{array} \right] = \left[ \begin{array}{ccc} 0 &amp; \frac14\pi &amp; 0 \\ -\frac14\pi &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 \end{array} \right]. \] </p> <p> This corresponds to a rotation of \( \frac14\pi \) radians around the z-axis. This is the inverse of the example used in the documentation of <a href="group__matrixfunctions__module#matrixbase_exp">exp()</a>.</p> <pre data-language="cpp"><span>#include &lt;unsupported/Eigen/MatrixFunctions&gt;</span>
<span>#include &lt;iostream&gt;</span>
 
<span>using namespace </span><a href="namespaceeigen">Eigen</a>;
 
<span>int</span> main()
{
  <span>using</span> std::sqrt;
  MatrixXd A(3,3);
  A &lt;&lt; 0.5*<a href="../namespaceeigen#af4f536e8ea56702e63088efb3706d1f0">sqrt</a>(2), -0.5*<a href="../namespaceeigen#af4f536e8ea56702e63088efb3706d1f0">sqrt</a>(2), 0,
       0.5*<a href="../namespaceeigen#af4f536e8ea56702e63088efb3706d1f0">sqrt</a>(2),  0.5*<a href="../namespaceeigen#af4f536e8ea56702e63088efb3706d1f0">sqrt</a>(2), 0,
       0,            0,           1;
  std::cout &lt;&lt; <span>"The matrix A is:\n"</span> &lt;&lt; A &lt;&lt; <span>"\n\n"</span>;
  std::cout &lt;&lt; <span>"The matrix logarithm of A is:\n"</span> &lt;&lt; A.log() &lt;&lt; <span>"\n"</span>;
}</pre>
<p> Output: </p>
<pre>The matrix A is:
 0.707107 -0.707107         0
 0.707107  0.707107         0
        0         0         1

The matrix logarithm of A is:
-8.86512e-17    -0.785398            0
    0.785398 -8.86512e-17            0
           0            0            0
</pre>
<dl>
<dt>Note</dt>
<dd>
<code>M</code> has to be a matrix of <code>float</code>, <code>double</code>, <code>long double</code>, <code>complex&lt;float&gt;</code>, <code>complex&lt;double&gt;</code>, or <code>complex&lt;long double&gt;</code>.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>MatrixBase::exp(), MatrixBase::matrixFunction(), class MatrixLogarithmAtomic, MatrixBase::sqrt().</dd>
</dl> <h2>
<a id="matrixbase_pow"></a> MatrixBase::pow()</h2> <p>Compute the matrix raised to arbitrary real power.</p> <pre data-language="cpp"><span>const</span> MatrixPowerReturnValue&lt;Derived&gt; MatrixBase&lt;Derived&gt;::pow(RealScalar p) <span>const</span>
</pre>
<dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>[in]</td>
<td>M</td>
<td>base of the matrix power, should be a square matrix. </td>
</tr> <tr>
<td>[in]</td>
<td>p</td>
<td>exponent of the matrix power.</td>
</tr> </table> </dd> </dl> <p>The matrix power \( M^p \) is defined as \( \exp(p \log(M)) \), where exp denotes the matrix exponential, and log denotes the matrix logarithm. This is different from raising all the entries in the matrix to the p-th power. Use ArrayBase::pow() if you want to do the latter.</p> <p>If <code>p</code> is complex, the scalar type of <code>M</code> should be the type of <code>p</code> . \( M^p \) simply evaluates into \( \exp(p \log(M)) \). Therefore, the matrix \( M \) should meet the conditions to be an argument of matrix logarithm.</p> <p>If <code>p</code> is real, it is casted into the real scalar type of <code>M</code>. Then this function computes the matrix power using the Schur-Padé algorithm as implemented by class MatrixPower. The exponent is split into integral part and fractional part, where the fractional part is in the interval \( (-1, 1) \). The main diagonal and the first super-diagonal is directly computed.</p> <p>If <code>M</code> is singular with a semisimple zero eigenvalue and <code>p</code> is positive, the Schur factor \( T \) is reordered with Givens rotations, i.e.</p> <p> \[ T = \left[ \begin{array}{cc} T_1 &amp; T_2 \\ 0 &amp; 0 \end{array} \right] \] </p> <p>where \( T_1 \) is invertible. Then \( T^p \) is given by</p> <p> \[ T^p = \left[ \begin{array}{cc} T_1^p &amp; T_1^{-1} T_1^p T_2 \\ 0 &amp; 0 \end{array}. \right] \] </p> <dl>
<dt>Warning</dt>
<dd>Fractional power of a matrix with a non-semisimple zero eigenvalue is not well-defined. We introduce an assertion failure against inaccurate result, e.g.<pre data-language="cpp"><span>#include &lt;unsupported/Eigen/MatrixFunctions&gt;</span>
<span>#include &lt;iostream&gt;</span>
 
<span>int</span> main()
{
  Eigen::Matrix4d A;
  A &lt;&lt; 0, 0, 2, 3,
       0, 0, 4, 5,
       0, 0, 6, 7,
       0, 0, 8, 9;
  std::cout &lt;&lt; A.pow(0.37) &lt;&lt; std::endl;
  
  <span>// The 1 makes eigenvalue 0 non-semisimple.</span>
  A.coeffRef(0, 1) = 1;
 
  <span>// This fails if EIGEN_NO_DEBUG is undefined.</span>
  std::cout &lt;&lt; A.pow(0.37) &lt;&lt; std::endl;
 
  <span>return</span> 0;
}
</pre>
</dd>
</dl> <p>Details of the algorithm can be found in: Nicholas J. Higham and Lijing Lin, "A Schur-Pad&amp;eacute; algorithm for fractional powers of a matrix," <em>SIAM J. Matrix Anal. Applic.</em>, <b>32(3)</b>:1056–1078, 2011.</p> <p>Example: The following program checks that </p>
<p> \[ \left[ \begin{array}{ccc} \cos1 &amp; -\sin1 &amp; 0 \\ \sin1 &amp; \cos1 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{array} \right]^{\frac14\pi} = \left[ \begin{array}{ccc} \frac12\sqrt2 &amp; -\frac12\sqrt2 &amp; 0 \\ \frac12\sqrt2 &amp; \frac12\sqrt2 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{array} \right]. \] </p> <p> This corresponds to \( \frac14\pi \) rotations of 1 radian around the z-axis.</p> <pre data-language="cpp"><span>#include &lt;unsupported/Eigen/MatrixFunctions&gt;</span>
<span>#include &lt;iostream&gt;</span>
 
<span>using namespace </span><a href="namespaceeigen">Eigen</a>;
 
<span>int</span> main()
{
  <span>const</span> <span>double</span> pi = std::acos(-1.0);
  Matrix3d A;
  A &lt;&lt; <a href="../namespaceeigen#ad01d50a42869218f1d54af13f71517a6">cos</a>(1), -<a href="../namespaceeigen#ae6e8ad270ff41c088d7651567594f796">sin</a>(1), 0,
       <a href="../namespaceeigen#ae6e8ad270ff41c088d7651567594f796">sin</a>(1),  <a href="../namespaceeigen#ad01d50a42869218f1d54af13f71517a6">cos</a>(1), 0,
           0 ,      0 , 1;
  std::cout &lt;&lt; <span>"The matrix A is:\n"</span> &lt;&lt; A &lt;&lt; <span>"\n\n"</span>
               <span>"The matrix power A^(pi/4) is:\n"</span> &lt;&lt; A.pow(pi/4) &lt;&lt; std::endl;
  <span>return</span> 0;
}</pre>
<p> Output: </p>
<pre>The matrix A is:
 0.540302 -0.841471         0
 0.841471  0.540302         0
        0         0         1

The matrix power A^(pi/4) is:
 0.707107 -0.707107         0
 0.707107  0.707107         0
        0         0         1
</pre>
<p>MatrixBase::pow() is user-friendly. However, there are some circumstances under which you should use class MatrixPower directly. MatrixPower can save the result of Schur decomposition, so it's better for computing various powers for the same matrix.</p> <p>Example: </p>
<pre data-language="cpp"><span>#include &lt;unsupported/Eigen/MatrixFunctions&gt;</span>
<span>#include &lt;iostream&gt;</span>
 
<span>using namespace </span><a href="namespaceeigen">Eigen</a>;
 
<span>int</span> main()
{
  Matrix4cd A = Matrix4cd::Random();
  MatrixPower&lt;Matrix4cd&gt; Apow(A);
 
  std::cout &lt;&lt; <span>"The matrix A is:\n"</span> &lt;&lt; A &lt;&lt; <span>"\n\n"</span>
               <span>"A^3.1 is:\n"</span> &lt;&lt; Apow(3.1) &lt;&lt; <span>"\n\n"</span>
               <span>"A^3.3 is:\n"</span> &lt;&lt; Apow(3.3) &lt;&lt; <span>"\n\n"</span>
               <span>"A^3.7 is:\n"</span> &lt;&lt; Apow(3.7) &lt;&lt; <span>"\n\n"</span>
               <span>"A^3.9 is:\n"</span> &lt;&lt; Apow(3.9) &lt;&lt; std::endl;
  <span>return</span> 0;
}
</pre>
<p> Output: </p>
<pre>The matrix A is:
 (-0.211234,0.680375)   (0.10794,-0.444451)   (0.434594,0.271423) (-0.198111,-0.686642)
   (0.59688,0.566198) (0.257742,-0.0452059)  (0.213938,-0.716795) (-0.782382,-0.740419)
 (-0.604897,0.823295) (0.0268018,-0.270431) (-0.514226,-0.967399)  (-0.563486,0.997849)
 (0.536459,-0.329554)    (0.83239,0.904459)  (0.608354,-0.725537)  (0.678224,0.0258648)

A^3.1 is:
   (2.80575,-0.607662) (-1.16847,-0.00660555)    (-0.760385,1.01461)   (-0.38073,-0.106512)
     (1.4041,-3.61891)     (1.00481,0.186263)   (-0.163888,0.449419)   (-0.388981,-1.22629)
   (-2.07957,-1.58136)     (0.825866,2.25962)     (5.09383,0.155736)    (0.394308,-1.63034)
  (-0.818997,0.671026)  (2.11069,-0.00768024)    (-1.37876,0.140165)    (2.50512,-0.854429)

A^3.3 is:
  (2.83571,-0.238717) (-1.48174,-0.0615217)  (-0.0544396,1.68092) (-0.292699,-0.621726)
    (2.0521,-3.58316)    (0.87894,0.400548)  (0.738072,-0.121242)   (-1.07957,-1.63492)
  (-3.00106,-1.10558)     (1.52205,1.92407)    (5.29759,-1.83562)  (-0.532038,-1.50253)
  (-0.491353,-0.4145)     (2.5761,0.481286)  (-1.21994,0.0367069)    (2.67112,-1.06331)

A^3.7 is:
     (1.42126,0.33362)   (-1.39486,-0.560486)      (1.44968,2.47066)   (-0.324079,-1.75879)
    (2.65301,-1.82427)   (0.357333,-0.192429)      (2.01017,-1.4791)    (-2.71518,-2.35892)
   (-3.98544,0.964861)     (2.26033,0.554254)     (3.18211,-5.94352)    (-2.22888,0.128951)
   (0.944969,-2.14683)      (3.31345,1.66075) (-0.0623743,-0.848324)        (2.3897,-1.863)

A^3.9 is:
 (0.0720766,0.378685) (-0.931961,-0.978624)      (1.9855,2.34105)  (-0.530547,-2.17664)
  (2.40934,-0.265286)  (0.0299975,-1.08827)    (1.98974,-2.05886)   (-3.45767,-2.50235)
    (-3.71666,2.3874)        (2.054,-0.303)   (0.844348,-7.29588)    (-2.59136,1.57689)
   (1.87645,-2.38798)     (3.52111,2.10508)    (0.799055,-1.6122)    (1.93452,-2.44408)
</pre>
<dl>
<dt>Note</dt>
<dd>
<code>M</code> has to be a matrix of <code>float</code>, <code>double</code>, <code>long double</code>, <code>complex&lt;float&gt;</code>, <code>complex&lt;double&gt;</code>, or <code>complex&lt;long double&gt;</code> .</dd>
</dl> <dl>
<dt>See also</dt>
<dd>MatrixBase::exp(), MatrixBase::log(), class MatrixPower.</dd>
</dl> <h2>
<a id="matrixbase_matrixfunction"></a> MatrixBase::matrixFunction()</h2> <p>Compute a matrix function.</p> <pre data-language="cpp"><span>const</span> MatrixFunctionReturnValue&lt;Derived&gt; MatrixBase&lt;Derived&gt;::matrixFunction(<span>typename</span> internal::stem_function&lt;<span>typename</span> internal::traits&lt;Derived&gt;::Scalar&gt;::type f) <span>const</span>
</pre>
<dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>[in]</td>
<td>M</td>
<td>argument of matrix function, should be a square matrix. </td>
</tr> <tr>
<td>[in]</td>
<td>f</td>
<td>an entire function; <code>f(x,n)</code> should compute the n-th derivative of f at x. </td>
</tr> </table> </dd> </dl> <dl>
<dt>Returns</dt>
<dd>expression representing <code>f</code> applied to <code>M</code>.</dd>
</dl> <p>Suppose that <code>M</code> is a matrix whose entries have type <code>Scalar</code>. Then, the second argument, <code>f</code>, should be a function with prototype </p>
<pre data-language="cpp">ComplexScalar f(ComplexScalar, <span>int</span>) 
</pre>
<p> where <code>ComplexScalar</code> = <code>std::complex&lt;Scalar&gt;</code> if <code>Scalar</code> is real (e.g., <code>float</code> or <code>double</code>) and <code>ComplexScalar</code> = <code>Scalar</code> if <code>Scalar</code> is complex. The return value of <code>f(x,n)</code> should be \( f^{(n)}(x) \), the n-th derivative of f at x.</p> <p>This routine uses the algorithm described in: Philip Davies and Nicholas J. Higham, "A Schur-Parlett algorithm for computing matrix functions", <em>SIAM J. Matrix Anal. Applic.</em>, <b>25</b>:464–485, 2003.</p> <p>The actual work is done by the MatrixFunction class.</p> <p>Example: The following program checks that </p>
<p> \[ \exp \left[ \begin{array}{ccc} 0 &amp; \frac14\pi &amp; 0 \\ -\frac14\pi &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 \end{array} \right] = \left[ \begin{array}{ccc} \frac12\sqrt2 &amp; -\frac12\sqrt2 &amp; 0 \\ \frac12\sqrt2 &amp; \frac12\sqrt2 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{array} \right]. \] </p> <p> This corresponds to a rotation of \( \frac14\pi \) radians around the z-axis. This is the same example as used in the documentation of <a href="group__matrixfunctions__module#matrixbase_exp">exp()</a>.</p> <pre data-language="cpp"><span>#include &lt;unsupported/Eigen/MatrixFunctions&gt;</span>
<span>#include &lt;iostream&gt;</span>
 
<span>using namespace </span><a href="namespaceeigen">Eigen</a>;
 
std::complex&lt;double&gt; expfn(std::complex&lt;double&gt; x, <span>int</span>)
{
  <span>return</span> std::exp(x);
}
 
<span>int</span> main()
{
  <span>const</span> <span>double</span> pi = std::acos(-1.0);
 
  MatrixXd A(3,3);
  A &lt;&lt; 0,    -pi/4, 0,
       pi/4, 0,     0,
       0,    0,     0;
 
  std::cout &lt;&lt; <span>"The matrix A is:\n"</span> &lt;&lt; A &lt;&lt; <span>"\n\n"</span>;
  std::cout &lt;&lt; <span>"The matrix exponential of A is:\n"</span> 
            &lt;&lt; A.matrixFunction(expfn) &lt;&lt; <span>"\n\n"</span>;
}
</pre>
<p> Output: </p>
<pre>The matrix A is:
        0 -0.785398         0
 0.785398         0         0
        0         0         0

The matrix exponential of A is:
 0.707107 -0.707107         0
 0.707107  0.707107         0
        0         0         1

</pre>
<p>Note that the function <code>expfn</code> is defined for complex numbers <code>x</code>, even though the matrix <code>A</code> is over the reals. Instead of <code>expfn</code>, we could also have used StdStemFunctions::exp: </p>
<pre data-language="cpp">A.matrixFunction(StdStemFunctions&lt;std::complex&lt;double&gt; &gt;::exp, &amp;B);
</pre>
<h2>
<a id="matrixbase_sin"></a> MatrixBase::sin()</h2> <p>Compute the matrix sine.</p> <pre data-language="cpp"><span>const</span> MatrixFunctionReturnValue&lt;Derived&gt; MatrixBase&lt;Derived&gt;::sin() const
</pre>
<dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>[in]</td>
<td>M</td>
<td>a square matrix. </td>
</tr> </table> </dd> </dl> <dl>
<dt>Returns</dt>
<dd>expression representing \( \sin(M) \).</dd>
</dl> <p>This function computes the matrix sine. Use ArrayBase::sin() for computing the entry-wise sine.</p> <p>The implementation calls <a href="group__matrixfunctions__module#matrixbase_matrixfunction">matrixFunction()</a> with StdStemFunctions::sin().</p> <p>Example: </p>
<pre data-language="cpp"><span>#include &lt;unsupported/Eigen/MatrixFunctions&gt;</span>
<span>#include &lt;iostream&gt;</span>
 
<span>using namespace </span><a href="namespaceeigen">Eigen</a>;
 
<span>int</span> main()
{
  MatrixXd A = MatrixXd::Random(3,3);
  std::cout &lt;&lt; <span>"A = \n"</span> &lt;&lt; A &lt;&lt; <span>"\n\n"</span>;
 
  MatrixXd sinA = A.sin();
  std::cout &lt;&lt; <span>"sin(A) = \n"</span> &lt;&lt; sinA &lt;&lt; <span>"\n\n"</span>;
 
  MatrixXd cosA = A.cos();
  std::cout &lt;&lt; <span>"cos(A) = \n"</span> &lt;&lt; cosA &lt;&lt; <span>"\n\n"</span>;
  
  <span>// The matrix functions satisfy sin^2(A) + cos^2(A) = I, </span>
  <span>// like the scalar functions.</span>
  std::cout &lt;&lt; <span>"sin^2(A) + cos^2(A) = \n"</span> &lt;&lt; sinA*sinA + cosA*cosA &lt;&lt; <span>"\n\n"</span>;
}
</pre>
<p> Output: </p>
<pre>A = 
 0.680375   0.59688 -0.329554
-0.211234  0.823295  0.536459
 0.566198 -0.604897 -0.444451

sin(A) = 
 0.679919    0.4579 -0.400612
-0.227278  0.821913    0.5358
 0.570141 -0.676728 -0.462398

cos(A) = 
  0.927728  -0.530361  -0.110482
0.00969246   0.889022  -0.137604
 -0.132574   -0.04289    1.16475

sin^2(A) + cos^2(A) = 
           1 -7.77156e-16  4.71845e-16
-5.55112e-17            1  2.77556e-16
 1.66533e-16 -2.08167e-16            1

</pre>
<h2>
<a id="matrixbase_sinh"></a> MatrixBase::sinh()</h2> <p>Compute the matrix hyperbolic sine.</p> <pre data-language="cpp">MatrixFunctionReturnValue&lt;Derived&gt; MatrixBase&lt;Derived&gt;::sinh() const
</pre>
<dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>[in]</td>
<td>M</td>
<td>a square matrix. </td>
</tr> </table> </dd> </dl> <dl>
<dt>Returns</dt>
<dd>expression representing \( \sinh(M) \)</dd>
</dl> <p>This function calls <a href="group__matrixfunctions__module#matrixbase_matrixfunction">matrixFunction()</a> with StdStemFunctions::sinh().</p> <p>Example: </p>
<pre data-language="cpp"><span>#include &lt;unsupported/Eigen/MatrixFunctions&gt;</span>
<span>#include &lt;iostream&gt;</span>
 
<span>using namespace </span><a href="namespaceeigen">Eigen</a>;
 
<span>int</span> main()
{
  MatrixXf A = MatrixXf::Random(3,3);
  std::cout &lt;&lt; <span>"A = \n"</span> &lt;&lt; A &lt;&lt; <span>"\n\n"</span>;
 
  MatrixXf sinhA = A.sinh();
  std::cout &lt;&lt; <span>"sinh(A) = \n"</span> &lt;&lt; sinhA &lt;&lt; <span>"\n\n"</span>;
 
  MatrixXf coshA = A.cosh();
  std::cout &lt;&lt; <span>"cosh(A) = \n"</span> &lt;&lt; coshA &lt;&lt; <span>"\n\n"</span>;
  
  <span>// The matrix functions satisfy cosh^2(A) - sinh^2(A) = I, </span>
  <span>// like the scalar functions.</span>
  std::cout &lt;&lt; <span>"cosh^2(A) - sinh^2(A) = \n"</span> &lt;&lt; coshA*coshA - sinhA*sinhA &lt;&lt; <span>"\n\n"</span>;
}
</pre>
<p> Output: </p>
<pre>A = 
 0.680375   0.59688 -0.329554
-0.211234  0.823295  0.536459
 0.566198 -0.604897 -0.444451

sinh(A) = 
 0.682534  0.739988 -0.256871
-0.194928  0.826512  0.537546
 0.562584  -0.53163 -0.425199

cosh(A) = 
  1.07817  0.567068  0.132125
-0.004186   1.11649  0.135361
 0.128891  0.065999  0.851201

cosh^2(A) - sinh^2(A) = 
          1 1.19209e-07           0
2.10479e-07           1 1.78814e-07
1.19209e-07 2.38419e-07           1

</pre>
<h2>
<a id="matrixbase_sqrt"></a> MatrixBase::sqrt()</h2> <p>Compute the matrix square root.</p> <pre data-language="cpp"><span>const</span> MatrixSquareRootReturnValue&lt;Derived&gt; MatrixBase&lt;Derived&gt;::sqrt() const
</pre>
<dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>[in]</td>
<td>M</td>
<td>invertible matrix whose square root is to be computed. </td>
</tr> </table> </dd> </dl> <dl>
<dt>Returns</dt>
<dd>expression representing the matrix square root of <code>M</code>.</dd>
</dl> <p>The matrix square root of \( M \) is the matrix \( M^{1/2} \) whose square is the original matrix; so if \( S = M^{1/2} \) then \( S^2 = M \). This is different from taking the square root of all the entries in the matrix; use ArrayBase::sqrt() if you want to do the latter.</p> <p>In the <b>real case</b>, the matrix \( M \) should be invertible and it should have no eigenvalues which are real and negative (pairs of complex conjugate eigenvalues are allowed). In that case, the matrix has a square root which is also real, and this is the square root computed by this function.</p> <p>The matrix square root is computed by first reducing the matrix to quasi-triangular form with the real Schur decomposition. The square root of the quasi-triangular matrix can then be computed directly. The cost is approximately \( 25 n^3 \) real flops for the real Schur decomposition and \( 3\frac13 n^3 \) real flops for the remainder (though the computation time in practice is likely more than this indicates).</p> <p>Details of the algorithm can be found in: Nicholas J. Highan, "Computing real square roots of a real matrix", <em>Linear Algebra Appl.</em>, 88/89:405–430, 1987.</p> <p>If the matrix is <b>positive-definite symmetric</b>, then the square root is also positive-definite symmetric. In this case, it is best to use SelfAdjointEigenSolver::operatorSqrt() to compute it.</p> <p>In the <b>complex case</b>, the matrix \( M \) should be invertible; this is a restriction of the algorithm. The square root computed by this algorithm is the one whose eigenvalues have an argument in the interval \( (-\frac12\pi, \frac12\pi] \). This is the usual branch cut.</p> <p>The computation is the same as in the real case, except that the complex Schur decomposition is used to reduce the matrix to a triangular matrix. The theoretical cost is the same. Details are in: Åke Björck and Sven Hammarling, "A Schur method for the square root of a matrix", <em>Linear Algebra Appl.</em>, 52/53:127–140, 1983.</p> <p>Example: The following program checks that the square root of </p>
<p> \[ \left[ \begin{array}{cc} \cos(\frac13\pi) &amp; -\sin(\frac13\pi) \\ \sin(\frac13\pi) &amp; \cos(\frac13\pi) \end{array} \right], \] </p> <p> corresponding to a rotation over 60 degrees, is a rotation over 30 degrees: </p>
<p> \[ \left[ \begin{array}{cc} \cos(\frac16\pi) &amp; -\sin(\frac16\pi) \\ \sin(\frac16\pi) &amp; \cos(\frac16\pi) \end{array} \right]. \] </p> <pre data-language="cpp"><span>#include &lt;unsupported/Eigen/MatrixFunctions&gt;</span>
<span>#include &lt;iostream&gt;</span>
 
<span>using namespace </span><a href="namespaceeigen">Eigen</a>;
 
<span>int</span> main()
{
  <span>const</span> <span>double</span> pi = std::acos(-1.0);
 
  MatrixXd A(2,2);
  A &lt;&lt; <a href="../namespaceeigen#ad01d50a42869218f1d54af13f71517a6">cos</a>(pi/3), -<a href="../namespaceeigen#ae6e8ad270ff41c088d7651567594f796">sin</a>(pi/3), 
       <a href="../namespaceeigen#ae6e8ad270ff41c088d7651567594f796">sin</a>(pi/3),  <a href="../namespaceeigen#ad01d50a42869218f1d54af13f71517a6">cos</a>(pi/3);
  std::cout &lt;&lt; <span>"The matrix A is:\n"</span> &lt;&lt; A &lt;&lt; <span>"\n\n"</span>;
  std::cout &lt;&lt; <span>"The matrix square root of A is:\n"</span> &lt;&lt; A.sqrt() &lt;&lt; <span>"\n\n"</span>;
  std::cout &lt;&lt; <span>"The square of the last matrix is:\n"</span> &lt;&lt; A.sqrt() * A.sqrt() &lt;&lt; <span>"\n"</span>;
}
</pre>
<p> Output: </p>
<pre>The matrix A is:
      0.5 -0.866025
 0.866025       0.5

The matrix square root of A is:
0.866025     -0.5
     0.5 0.866025

The square of the last matrix is:
      0.5 -0.866025
 0.866025       0.5
</pre>
<dl>
<dt>See also</dt>
<dd>class RealSchur, class ComplexSchur, class MatrixSquareRoot, SelfAdjointEigenSolver::operatorSqrt(). </dd>
</dl> </div> <a id="ga2f490197e16df831683018e383e29346"></a> <h2>matrix_sqrt_quasi_triangular()</h2> <div> <div> <div> template&lt;typename MatrixType , typename ResultType &gt; </div> <table> <tr> <td>void Eigen::matrix_sqrt_quasi_triangular </td> <td>(</td> <td>const MatrixType &amp; </td> <td>
<em>arg</em>, </td> </tr> <tr> <td></td> <td></td> <td>ResultType &amp; </td> <td>
<em>result</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </div>
<div> <p>Compute matrix square root of quasi-triangular matrix. </p> <dl>
<dt>Template Parameters</dt>
<dd> <table> <tr>
<td>MatrixType</td>
<td>type of <code>arg</code>, the argument of matrix square root, expected to be an instantiation of the <a href="../classeigen_1_1matrix">Matrix</a> class template. </td>
</tr> <tr>
<td>ResultType</td>
<td>type of <code>result</code>, where result is to be stored. </td>
</tr> </table> </dd> </dl> <dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>[in]</td>
<td>arg</td>
<td>argument of matrix square root. </td>
</tr> <tr>
<td>[out]</td>
<td>result</td>
<td>matrix square root of upper Hessenberg part of <code>arg</code>.</td>
</tr> </table> </dd> </dl> <p>This function computes the square root of the upper quasi-triangular matrix stored in the upper Hessenberg part of <code>arg</code>. Only the upper Hessenberg part of <code>result</code> is updated, the rest is not touched. See <a href="../classeigen_1_1matrixbase#ad873dca860bd47baeeede8663e161b83">MatrixBase::sqrt()</a> for details on how this computation is implemented.</p> <dl>
<dt>See also</dt>
<dd>MatrixSquareRoot, MatrixSquareRootQuasiTriangular </dd>
</dl> </div> </div> <a id="gae51c91f920f6ea4a7f6f72caa1e8249f"></a> <h2>matrix_sqrt_triangular()</h2> <div> <div> <div> template&lt;typename MatrixType , typename ResultType &gt; </div> <table> <tr> <td>void Eigen::matrix_sqrt_triangular </td> <td>(</td> <td>const MatrixType &amp; </td> <td>
<em>arg</em>, </td> </tr> <tr> <td></td> <td></td> <td>ResultType &amp; </td> <td>
<em>result</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </div>
<div> <p>Compute matrix square root of triangular matrix. </p> <dl>
<dt>Template Parameters</dt>
<dd> <table> <tr>
<td>MatrixType</td>
<td>type of <code>arg</code>, the argument of matrix square root, expected to be an instantiation of the <a href="../classeigen_1_1matrix">Matrix</a> class template. </td>
</tr> <tr>
<td>ResultType</td>
<td>type of <code>result</code>, where result is to be stored. </td>
</tr> </table> </dd> </dl> <dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>[in]</td>
<td>arg</td>
<td>argument of matrix square root. </td>
</tr> <tr>
<td>[out]</td>
<td>result</td>
<td>matrix square root of upper triangular part of <code>arg</code>.</td>
</tr> </table> </dd> </dl> <p>Only the upper triangular part (including the diagonal) of <code>result</code> is updated, the rest is not touched. See <a href="../classeigen_1_1matrixbase#ad873dca860bd47baeeede8663e161b83">MatrixBase::sqrt()</a> for details on how this computation is implemented.</p> <dl>
<dt>See also</dt>
<dd>MatrixSquareRoot, MatrixSquareRootQuasiTriangular </dd>
</dl> </div> </div> </div> <div class="_attribution">
  <p class="_attribution-p">
    © Eigen.<br>Licensed under the MPL2 License.<br>
    <a href="https://eigen.tuxfamily.org/dox/unsupported/group__MatrixFunctions__Module.html" class="_attribution-link">https://eigen.tuxfamily.org/dox/unsupported/group__MatrixFunctions__Module.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
