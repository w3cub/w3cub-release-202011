
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Eigen&#58;&#58;SelfAdjointEigenSolver - Eigen3 - W3cubDocs</title>
  
  <meta name="description" content=" Computes eigenvalues and eigenvectors of selfadjoint matrices. ">
  <meta name="keywords" content="eigen, selfadjointeigensolver, eigen3">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/eigen3/classeigen_1_1selfadjointeigensolver.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-f16eecbe420d8b2925d31ffbb21d05646497ecbd9515f08ffe69e9bba7332f5657accc7003c7f6c72cb4a132171acf171b359ae3bae4ae5660ddfb1718f88c67.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/eigen3.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/eigen3/" class="_nav-link" title="" style="margin-left:0;">Eigen3</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _eigen3">
				
				
<h1>Eigen::SelfAdjointEigenSolver</h1>      <div>  <div>
<h3>template&lt;typename _MatrixType&gt;<br> class Eigen::SelfAdjointEigenSolver&lt; _MatrixType &gt;</h3> <p>Computes eigenvalues and eigenvectors of selfadjoint matrices. </p> <p>This is defined in the Eigenvalues module.</p>
<pre data-language="cpp"><span>#include &lt;Eigen/Eigenvalues&gt;</span> 
</pre>
<dl>
<dt>Template Parameters</dt>
<dd> <table> <tr>
<td>_MatrixType</td>
<td>the type of the matrix of which we are computing the eigendecomposition; this is expected to be an instantiation of the <a href="classeigen_1_1matrix" title="The matrix class, also used for vectors and row-vectors.">Matrix</a> class template.</td>
</tr> </table> </dd> </dl> <p>A matrix \( A \) is selfadjoint if it equals its adjoint. For real matrices, this means that the matrix is symmetric: it equals its transpose. This class computes the eigenvalues and eigenvectors of a selfadjoint matrix. These are the scalars \( \lambda \) and vectors \( v \) such that \( Av = \lambda v \). The eigenvalues of a selfadjoint matrix are always real. If \( D \) is a diagonal matrix with the eigenvalues on the diagonal, and \( V \) is a matrix with the eigenvectors as its columns, then \( A = V D V^{-1} \). This is called the eigendecomposition.</p> <p>For a selfadjoint matrix, \( V \) is unitary, meaning its inverse is equal to its adjoint, \( V^{-1} = V^{\dagger} \). If \( A \) is real, then \( V \) is also real and therefore orthogonal, meaning its inverse is equal to its transpose, \( V^{-1} = V^T \).</p> <p>The algorithm exploits the fact that the matrix is selfadjoint, making it faster and more accurate than the general purpose eigenvalue algorithms implemented in <a href="classeigen_1_1eigensolver" title="Computes eigenvalues and eigenvectors of general matrices.">EigenSolver</a> and <a href="classeigen_1_1complexeigensolver" title="Computes eigenvalues and eigenvectors of general complex matrices.">ComplexEigenSolver</a>.</p> <p>Only the <b>lower</b> <b>triangular</b> <b>part</b> of the input matrix is referenced.</p> <p>Call the function <a href="classeigen_1_1selfadjointeigensolver#adf397f6bce9f93c4b0139a47e261fc24" title="Computes eigendecomposition of given matrix.">compute()</a> to compute the eigenvalues and eigenvectors of a given matrix. Alternatively, you can use the SelfAdjointEigenSolver(const MatrixType&amp;, int) constructor which computes the eigenvalues and eigenvectors at construction time. Once the eigenvalue and eigenvectors are computed, they can be retrieved with the <a href="classeigen_1_1selfadjointeigensolver#a3df8721abcc71132f7f02bf9dfe78e41" title="Returns the eigenvalues of given matrix.">eigenvalues()</a> and <a href="classeigen_1_1selfadjointeigensolver#a229c4c26d87c5d2663cd3cc8a4c68266" title="Returns the eigenvectors of given matrix.">eigenvectors()</a> functions.</p> <p>The documentation for SelfAdjointEigenSolver(const MatrixType&amp;, int) contains an example of the typical use of this class.</p> <p>To solve the <em>generalized</em> eigenvalue problem \( Av = \lambda Bv \) and the likes, see the class <a href="classeigen_1_1generalizedselfadjointeigensolver" title="Computes eigenvalues and eigenvectors of the generalized selfadjoint eigen problem.">GeneralizedSelfAdjointEigenSolver</a>.</p> <dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1matrixbase#a30430fa3d5b4e74d312fd4f502ac984d" title="Computes the eigenvalues of a matrix.">MatrixBase::eigenvalues()</a>, class <a href="classeigen_1_1eigensolver" title="Computes eigenvalues and eigenvectors of general matrices.">EigenSolver</a>, class <a href="classeigen_1_1complexeigensolver" title="Computes eigenvalues and eigenvectors of general complex matrices.">ComplexEigenSolver</a> </dd>
</dl> </div> <div id="dynsection-0-summary" style="display:block;"> </div> <div id="dynsection-0-content" style="display:none;"> <div><img src="data:image/png;base64,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" border="0" usemap="#aEigen_1_1SelfAdjointEigenSolver_3_01__MatrixType_01_4_inherit__map" alt="Inheritance graph"></div> <map name="aEigen_1_1SelfAdjointEigenSolver_3_01__MatrixType_01_4_inherit__map" id="aEigen_1_1SelfAdjointEigenSolver_3_01__MatrixType_01_4_inherit__map"> <area shape="rect" title="Computes eigenvalues and eigenvectors of selfadjoint matrices." alt="" coords="5,5,211,376"> <area shape="rect" href="classEigen_1_1GeneralizedSelfAdjointEigenSolver.html" title="Computes eigenvalues and eigenvectors of the generalized selfadjoint eigen problem." alt="" coords="9,424,207,604"> </map> </div> <table> <tr><td colspan="2"></td></tr> <tr>
<td align="right" valign="top">typedef <a href="namespaceeigen#a62e77e0933482dafde8fe197d9a2cfde">Eigen::Index</a> </td>
<td valign="bottom"><a href="classeigen_1_1selfadjointeigensolver#a8a59ab7734b6eae2754fd78bc7c3a360">Index</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">typedef <a href="structeigen_1_1numtraits">NumTraits</a>&lt; <a href="classeigen_1_1selfadjointeigensolver#a0bfcedf4245b6846007ca4f01e4feb1f">Scalar</a> &gt;::Real </td>
<td valign="bottom"><a href="classeigen_1_1selfadjointeigensolver#a5dae5f422a3c71060e6bd31332bf64fd">RealScalar</a></td>
</tr> <tr>
<td> </td>
<td>Real scalar type for <code>_MatrixType</code>. <a href="classeigen_1_1selfadjointeigensolver#a5dae5f422a3c71060e6bd31332bf64fd">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">typedef internal::plain_col_type&lt; MatrixType, <a href="classeigen_1_1selfadjointeigensolver#a5dae5f422a3c71060e6bd31332bf64fd">RealScalar</a> &gt;::type </td>
<td valign="bottom"><a href="classeigen_1_1selfadjointeigensolver#acd090d5fdfc3cc017a13b6d8daa92287">RealVectorType</a></td>
</tr> <tr>
<td> </td>
<td>Type for vector of eigenvalues as returned by <a href="classeigen_1_1selfadjointeigensolver#a3df8721abcc71132f7f02bf9dfe78e41" title="Returns the eigenvalues of given matrix.">eigenvalues()</a>. <a href="classeigen_1_1selfadjointeigensolver#acd090d5fdfc3cc017a13b6d8daa92287">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a id="a0bfcedf4245b6846007ca4f01e4feb1f"></a> typedef MatrixType::Scalar </td>
<td valign="bottom"><a href="classeigen_1_1selfadjointeigensolver#a0bfcedf4245b6846007ca4f01e4feb1f">Scalar</a></td>
</tr> <tr>
<td> </td>
<td>Scalar type for matrices of type <code>_MatrixType</code>. <br>
</td>
</tr> <tr><td colspan="2"> </td></tr> </table>
<table> <tr><td colspan="2"></td></tr> <tr><td colspan="2">template&lt;typename InputType &gt; </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1selfadjointeigensolver">SelfAdjointEigenSolver</a> &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1selfadjointeigensolver#adf397f6bce9f93c4b0139a47e261fc24">compute</a> (const <a href="structeigen_1_1eigenbase">EigenBase</a>&lt; InputType &gt; &amp;matrix, int options=<a href="group__enums#ggae3e239fb70022eb8747994cf5d68b4a9a7f7d17fba3c9bb92158e346d5979d0f4">ComputeEigenvectors</a>)</td>
</tr> <tr>
<td> </td>
<td>Computes eigendecomposition of given matrix. <a href="classeigen_1_1selfadjointeigensolver#adf397f6bce9f93c4b0139a47e261fc24">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1selfadjointeigensolver">SelfAdjointEigenSolver</a> &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1selfadjointeigensolver#afe520161701f5f585bcc4cedb8657bd1">computeDirect</a> (const MatrixType &amp;matrix, int options=<a href="group__enums#ggae3e239fb70022eb8747994cf5d68b4a9a7f7d17fba3c9bb92158e346d5979d0f4">ComputeEigenvectors</a>)</td>
</tr> <tr>
<td> </td>
<td>Computes eigendecomposition of given matrix using a closed-form algorithm. <a href="classeigen_1_1selfadjointeigensolver#afe520161701f5f585bcc4cedb8657bd1">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1selfadjointeigensolver">SelfAdjointEigenSolver</a> &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1selfadjointeigensolver#a297893df7098c43278d385e4d4e23fe4">computeFromTridiagonal</a> (const <a href="classeigen_1_1selfadjointeigensolver#acd090d5fdfc3cc017a13b6d8daa92287">RealVectorType</a> &amp;diag, const <a href="classeigen_1_1matrix">SubDiagonalType</a> &amp;subdiag, int options=<a href="group__enums#ggae3e239fb70022eb8747994cf5d68b4a9a7f7d17fba3c9bb92158e346d5979d0f4">ComputeEigenvectors</a>)</td>
</tr> <tr>
<td> </td>
<td>Computes the eigen decomposition from a tridiagonal symmetric matrix. <a href="classeigen_1_1selfadjointeigensolver#a297893df7098c43278d385e4d4e23fe4">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const <a href="classeigen_1_1selfadjointeigensolver#acd090d5fdfc3cc017a13b6d8daa92287">RealVectorType</a> &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1selfadjointeigensolver#a3df8721abcc71132f7f02bf9dfe78e41">eigenvalues</a> () const</td>
</tr> <tr>
<td> </td>
<td>Returns the eigenvalues of given matrix. <a href="classeigen_1_1selfadjointeigensolver#a3df8721abcc71132f7f02bf9dfe78e41">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const <a href="classeigen_1_1matrix">EigenvectorsType</a> &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1selfadjointeigensolver#a229c4c26d87c5d2663cd3cc8a4c68266">eigenvectors</a> () const</td>
</tr> <tr>
<td> </td>
<td>Returns the eigenvectors of given matrix. <a href="classeigen_1_1selfadjointeigensolver#a229c4c26d87c5d2663cd3cc8a4c68266">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="group__enums#ga85fad7b87587764e5cf6b513a9e0ee5e">ComputationInfo</a> </td>
<td valign="bottom">
<a href="classeigen_1_1selfadjointeigensolver#a31e8a509231e57e684c53799693607ae">info</a> () const</td>
</tr> <tr>
<td> </td>
<td>Reports whether previous computation was successful. <a href="classeigen_1_1selfadjointeigensolver#a31e8a509231e57e684c53799693607ae">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">MatrixType </td>
<td valign="bottom">
<a href="classeigen_1_1selfadjointeigensolver#ae4b13fe4ce22faf74e50d346fc51a66e">operatorInverseSqrt</a> () const</td>
</tr> <tr>
<td> </td>
<td>Computes the inverse square root of the matrix. <a href="classeigen_1_1selfadjointeigensolver#ae4b13fe4ce22faf74e50d346fc51a66e">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">MatrixType </td>
<td valign="bottom">
<a href="classeigen_1_1selfadjointeigensolver#aeeedb2ae618f21a4eb59465746c1cee5">operatorSqrt</a> () const</td>
</tr> <tr>
<td> </td>
<td>Computes the positive-definite square root of the matrix. <a href="classeigen_1_1selfadjointeigensolver#aeeedb2ae618f21a4eb59465746c1cee5">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top"> </td>
<td valign="bottom">
<a href="classeigen_1_1selfadjointeigensolver#a8f3dde67faa971dd97e8141617762326">SelfAdjointEigenSolver</a> ()</td>
</tr> <tr>
<td> </td>
<td>Default constructor for fixed-size matrices. <a href="classeigen_1_1selfadjointeigensolver#a8f3dde67faa971dd97e8141617762326">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename InputType &gt; </td></tr> <tr>
<td align="right" valign="top"> </td>
<td valign="bottom">
<a href="classeigen_1_1selfadjointeigensolver#a7d8cba55cce60cb3931148208cc5bd0e">SelfAdjointEigenSolver</a> (const <a href="structeigen_1_1eigenbase">EigenBase</a>&lt; InputType &gt; &amp;matrix, int options=<a href="group__enums#ggae3e239fb70022eb8747994cf5d68b4a9a7f7d17fba3c9bb92158e346d5979d0f4">ComputeEigenvectors</a>)</td>
</tr> <tr>
<td> </td>
<td>Constructor; computes eigendecomposition of given matrix. <a href="classeigen_1_1selfadjointeigensolver#a7d8cba55cce60cb3931148208cc5bd0e">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top"> </td>
<td valign="bottom">
<a href="classeigen_1_1selfadjointeigensolver#a825919ee41153a19910c72d1bff31c8e">SelfAdjointEigenSolver</a> (<a href="classeigen_1_1selfadjointeigensolver#a8a59ab7734b6eae2754fd78bc7c3a360">Index</a> size)</td>
</tr> <tr>
<td> </td>
<td>Constructor, pre-allocates memory for dynamic-size matrices. <a href="classeigen_1_1selfadjointeigensolver#a825919ee41153a19910c72d1bff31c8e">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> </table>
<table> <tr><td colspan="2"></td></tr> <tr>
<td align="right" valign="top">static const int </td>
<td valign="bottom"><a href="classeigen_1_1selfadjointeigensolver#a9ba10b83f095b18dbea345db7304acfa">m_maxIterations</a></td>
</tr> <tr>
<td> </td>
<td>Maximum number of iterations. <a href="classeigen_1_1selfadjointeigensolver#a9ba10b83f095b18dbea345db7304acfa">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> </table>  <a id="a8a59ab7734b6eae2754fd78bc7c3a360"></a> <h2>Index</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td>typedef <a href="namespaceeigen#a62e77e0933482dafde8fe197d9a2cfde">Eigen::Index</a> <a href="classeigen_1_1selfadjointeigensolver">Eigen::SelfAdjointEigenSolver</a>&lt; _MatrixType &gt;::<a href="classeigen_1_1selfadjointeigensolver#a8a59ab7734b6eae2754fd78bc7c3a360">Index</a>
</td> </tr> </table> </div>
<div> <dl>
<dt><b><a href="deprecated#_deprecated000019">Deprecated:</a></b></dt>
<dd>since <a href="namespaceeigen" title="Namespace containing all symbols from the Eigen library.">Eigen</a> 3.3 </dd>
</dl> </div> </div> <a id="a5dae5f422a3c71060e6bd31332bf64fd"></a> <h2>RealScalar</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td>typedef <a href="structeigen_1_1numtraits">NumTraits</a>&lt;<a href="classeigen_1_1selfadjointeigensolver#a0bfcedf4245b6846007ca4f01e4feb1f">Scalar</a>&gt;::Real <a href="classeigen_1_1selfadjointeigensolver">Eigen::SelfAdjointEigenSolver</a>&lt; _MatrixType &gt;::<a href="classeigen_1_1selfadjointeigensolver#a5dae5f422a3c71060e6bd31332bf64fd">RealScalar</a>
</td> </tr> </table> </div>
<div> <p>Real scalar type for <code>_MatrixType</code>. </p> <p>This is just <code>Scalar</code> if <a href="classeigen_1_1selfadjointeigensolver#a0bfcedf4245b6846007ca4f01e4feb1f" title="Scalar type for matrices of type _MatrixType.">Scalar</a> is real (e.g., <code>float</code> or <code>double</code>), and the type of the real part of <code>Scalar</code> if <a href="classeigen_1_1selfadjointeigensolver#a0bfcedf4245b6846007ca4f01e4feb1f" title="Scalar type for matrices of type _MatrixType.">Scalar</a> is complex. </p> </div> </div> <a id="acd090d5fdfc3cc017a13b6d8daa92287"></a> <h2>RealVectorType</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td>typedef internal::plain_col_type&lt;MatrixType, <a href="classeigen_1_1selfadjointeigensolver#a5dae5f422a3c71060e6bd31332bf64fd">RealScalar</a>&gt;::type <a href="classeigen_1_1selfadjointeigensolver">Eigen::SelfAdjointEigenSolver</a>&lt; _MatrixType &gt;::<a href="classeigen_1_1selfadjointeigensolver#acd090d5fdfc3cc017a13b6d8daa92287">RealVectorType</a>
</td> </tr> </table> </div>
<div> <p>Type for vector of eigenvalues as returned by <a href="classeigen_1_1selfadjointeigensolver#a3df8721abcc71132f7f02bf9dfe78e41" title="Returns the eigenvalues of given matrix.">eigenvalues()</a>. </p> <p>This is a column vector with entries of type <a href="classeigen_1_1selfadjointeigensolver#a5dae5f422a3c71060e6bd31332bf64fd" title="Real scalar type for _MatrixType.">RealScalar</a>. The length of the vector is the size of <code>_MatrixType</code>. </p> </div> </div>  <a id="a8f3dde67faa971dd97e8141617762326"></a> <h2>SelfAdjointEigenSolver() <span>[1/3]</span>
</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1selfadjointeigensolver">Eigen::SelfAdjointEigenSolver</a>&lt; _MatrixType &gt;::<a href="classeigen_1_1selfadjointeigensolver">SelfAdjointEigenSolver</a> </td> <td>(</td> <td></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Default constructor for fixed-size matrices. </p> <p>The default constructor is useful in cases in which the user intends to perform decompositions via <a href="classeigen_1_1selfadjointeigensolver#adf397f6bce9f93c4b0139a47e261fc24" title="Computes eigendecomposition of given matrix.">compute()</a>. This constructor can only be used if <code>_MatrixType</code> is a fixed-size matrix; use <a href="classeigen_1_1selfadjointeigensolver#a825919ee41153a19910c72d1bff31c8e" title="Constructor, pre-allocates memory for dynamic-size matrices.">SelfAdjointEigenSolver(Index)</a> for dynamic-size matrices.</p> <p>Example: </p>
<pre data-language="cpp">SelfAdjointEigenSolver&lt;Matrix4f&gt; es;
Matrix4f X = <a href="classeigen_1_1densebase#ae814abb451b48ed872819192dc188c19">Matrix4f::Random</a>(4,4);
Matrix4f A = X + X.transpose();
es.compute(A);
cout &lt;&lt; <span>"The eigenvalues of A are: "</span> &lt;&lt; es.eigenvalues().transpose() &lt;&lt; endl;
es.compute(A + <a href="classeigen_1_1matrixbase#a98bb9a0f705c6dfde85b0bfff31bf88f">Matrix4f::Identity</a>(4,4)); <span>// re-use es to compute eigenvalues of A+I</span>
cout &lt;&lt; <span>"The eigenvalues of A+I are: "</span> &lt;&lt; es.eigenvalues().transpose() &lt;&lt; endl;</pre>
<p> Output: </p>
<pre>The eigenvalues of A are:  -1.58 -0.473   1.32   2.46
The eigenvalues of A+I are: -0.581  0.527   2.32   3.46
</pre> </div> </div> <a id="a825919ee41153a19910c72d1bff31c8e"></a> <h2>SelfAdjointEigenSolver() <span>[2/3]</span>
</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1selfadjointeigensolver">Eigen::SelfAdjointEigenSolver</a>&lt; _MatrixType &gt;::<a href="classeigen_1_1selfadjointeigensolver">SelfAdjointEigenSolver</a> </td> <td>(</td> <td>
<a href="classeigen_1_1selfadjointeigensolver#a8a59ab7734b6eae2754fd78bc7c3a360">Index</a> </td> <td><em>size</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span><span>explicit</span></span> </td> </tr> </table> </div>
<div> <p>Constructor, pre-allocates memory for dynamic-size matrices. </p> <dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>[in]</td>
<td>size</td>
<td>Positive integer, size of the matrix whose eigenvalues and eigenvectors will be computed.</td>
</tr> </table> </dd> </dl> <p>This constructor is useful for dynamic-size matrices, when the user intends to perform decompositions via <a href="classeigen_1_1selfadjointeigensolver#adf397f6bce9f93c4b0139a47e261fc24" title="Computes eigendecomposition of given matrix.">compute()</a>. The <code>size</code> parameter is only used as a hint. It is not an error to give a wrong <code>size</code>, but it may impair performance.</p> <dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1selfadjointeigensolver#adf397f6bce9f93c4b0139a47e261fc24" title="Computes eigendecomposition of given matrix.">compute()</a> for an example </dd>
</dl> </div> </div> <a id="a7d8cba55cce60cb3931148208cc5bd0e"></a> <h2>SelfAdjointEigenSolver() <span>[3/3]</span>
</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <div> template&lt;typename InputType &gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1selfadjointeigensolver">Eigen::SelfAdjointEigenSolver</a>&lt; _MatrixType &gt;::<a href="classeigen_1_1selfadjointeigensolver">SelfAdjointEigenSolver</a> </td> <td>(</td> <td>const <a href="structeigen_1_1eigenbase">EigenBase</a>&lt; InputType &gt; &amp; </td> <td>
<em>matrix</em>, </td> </tr> <tr> <td></td> <td></td> <td>int </td> <td>
<em>options</em> = <code><a href="group__enums#ggae3e239fb70022eb8747994cf5d68b4a9a7f7d17fba3c9bb92158e346d5979d0f4">ComputeEigenvectors</a></code> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </td> <td> <span><span>inline</span><span>explicit</span></span> </td> </tr> </table> </div>
<div> <p>Constructor; computes eigendecomposition of given matrix. </p> <dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>[in]</td>
<td>matrix</td>
<td>Selfadjoint matrix whose eigendecomposition is to be computed. Only the lower triangular part of the matrix is referenced. </td>
</tr> <tr>
<td>[in]</td>
<td>options</td>
<td>Can be <a href="group__enums#ggae3e239fb70022eb8747994cf5d68b4a9a7f7d17fba3c9bb92158e346d5979d0f4">ComputeEigenvectors</a> (default) or <a href="group__enums#ggae3e239fb70022eb8747994cf5d68b4a9afd06633f270207c373875fd7ca03e906">EigenvaluesOnly</a>.</td>
</tr> </table> </dd> </dl> <p>This constructor calls compute(const MatrixType&amp;, int) to compute the eigenvalues of the matrix <code>matrix</code>. The eigenvectors are computed if <code>options</code> equals <a href="group__enums#ggae3e239fb70022eb8747994cf5d68b4a9a7f7d17fba3c9bb92158e346d5979d0f4">ComputeEigenvectors</a>.</p> <p>Example: </p>
<pre data-language="cpp">MatrixXd X = <a href="classeigen_1_1densebase#ae814abb451b48ed872819192dc188c19">MatrixXd::Random</a>(5,5);
MatrixXd A = X + X.transpose();
cout &lt;&lt; <span>"Here is a random symmetric 5x5 matrix, A:"</span> &lt;&lt; endl &lt;&lt; A &lt;&lt; endl &lt;&lt; endl;
 
SelfAdjointEigenSolver&lt;MatrixXd&gt; es(A);
cout &lt;&lt; <span>"The eigenvalues of A are:"</span> &lt;&lt; endl &lt;&lt; es.eigenvalues() &lt;&lt; endl;
cout &lt;&lt; <span>"The matrix of eigenvectors, V, is:"</span> &lt;&lt; endl &lt;&lt; es.eigenvectors() &lt;&lt; endl &lt;&lt; endl;
 
<span>double</span> lambda = es.eigenvalues()[0];
cout &lt;&lt; <span>"Consider the first eigenvalue, lambda = "</span> &lt;&lt; lambda &lt;&lt; endl;
VectorXd v = es.eigenvectors().col(0);
cout &lt;&lt; <span>"If v is the corresponding eigenvector, then lambda * v = "</span> &lt;&lt; endl &lt;&lt; lambda * v &lt;&lt; endl;
cout &lt;&lt; <span>"... and A * v = "</span> &lt;&lt; endl &lt;&lt; A * v &lt;&lt; endl &lt;&lt; endl;
 
MatrixXd D = es.eigenvalues().asDiagonal();
MatrixXd V = es.eigenvectors();
cout &lt;&lt; <span>"Finally, V * D * V^(-1) = "</span> &lt;&lt; endl &lt;&lt; V * D * V.inverse() &lt;&lt; endl;
</pre>
<p> Output: </p>
<pre>Here is a random symmetric 5x5 matrix, A:
  1.36 -0.816  0.521   1.43 -0.144
-0.816 -0.659  0.794 -0.173 -0.406
 0.521  0.794 -0.541  0.461  0.179
  1.43 -0.173  0.461  -1.43  0.822
-0.144 -0.406  0.179  0.822  -1.37

The eigenvalues of A are:
 -2.65
 -1.77
-0.745
 0.227
  2.29
The matrix of eigenvectors, V, is:
 -0.326 -0.0984   0.347 -0.0109   0.874
 -0.207  -0.642   0.228   0.662  -0.232
 0.0495   0.629  -0.164    0.74   0.164
  0.721  -0.397  -0.402   0.115   0.385
 -0.573  -0.156  -0.799 -0.0256  0.0858

Consider the first eigenvalue, lambda = -2.65
If v is the corresponding eigenvector, then lambda * v = 
 0.865
  0.55
-0.131
 -1.91
  1.52
... and A * v = 
 0.865
  0.55
-0.131
 -1.91
  1.52

Finally, V * D * V^(-1) = 
  1.36 -0.816  0.521   1.43 -0.144
-0.816 -0.659  0.794 -0.173 -0.406
 0.521  0.794 -0.541  0.461  0.179
  1.43 -0.173  0.461  -1.43  0.822
-0.144 -0.406  0.179  0.822  -1.37
</pre>
<dl>
<dt>See also</dt>
<dd>compute(const MatrixType&amp;, int) </dd>
</dl> </div> </div>  <a id="adf397f6bce9f93c4b0139a47e261fc24"></a> <h2>compute()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <div> template&lt;typename InputType &gt; </div> <table> <tr> <td>
<a href="classeigen_1_1selfadjointeigensolver">SelfAdjointEigenSolver</a>&amp; <a href="classeigen_1_1selfadjointeigensolver">Eigen::SelfAdjointEigenSolver</a>&lt; _MatrixType &gt;::compute </td> <td>(</td> <td>const <a href="structeigen_1_1eigenbase">EigenBase</a>&lt; InputType &gt; &amp; </td> <td>
<em>matrix</em>, </td> </tr> <tr> <td></td> <td></td> <td>int </td> <td>
<em>options</em> = <code><a href="group__enums#ggae3e239fb70022eb8747994cf5d68b4a9a7f7d17fba3c9bb92158e346d5979d0f4">ComputeEigenvectors</a></code> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </div>
<div> <p>Computes eigendecomposition of given matrix. </p> <dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>[in]</td>
<td>matrix</td>
<td>Selfadjoint matrix whose eigendecomposition is to be computed. Only the lower triangular part of the matrix is referenced. </td>
</tr> <tr>
<td>[in]</td>
<td>options</td>
<td>Can be <a href="group__enums#ggae3e239fb70022eb8747994cf5d68b4a9a7f7d17fba3c9bb92158e346d5979d0f4">ComputeEigenvectors</a> (default) or <a href="group__enums#ggae3e239fb70022eb8747994cf5d68b4a9afd06633f270207c373875fd7ca03e906">EigenvaluesOnly</a>. </td>
</tr> </table> </dd> </dl> <dl>
<dt>Returns</dt>
<dd>Reference to <code>*this</code> </dd>
</dl> <p>This function computes the eigenvalues of <code>matrix</code>. The <a href="classeigen_1_1selfadjointeigensolver#a3df8721abcc71132f7f02bf9dfe78e41" title="Returns the eigenvalues of given matrix.">eigenvalues()</a> function can be used to retrieve them. If <code>options</code> equals <a href="group__enums#ggae3e239fb70022eb8747994cf5d68b4a9a7f7d17fba3c9bb92158e346d5979d0f4">ComputeEigenvectors</a>, then the eigenvectors are also computed and can be retrieved by calling <a href="classeigen_1_1selfadjointeigensolver#a229c4c26d87c5d2663cd3cc8a4c68266" title="Returns the eigenvectors of given matrix.">eigenvectors()</a>.</p> <p>This implementation uses a symmetric QR algorithm. The matrix is first reduced to tridiagonal form using the <a href="classeigen_1_1tridiagonalization" title="Tridiagonal decomposition of a selfadjoint matrix.">Tridiagonalization</a> class. The tridiagonal matrix is then brought to diagonal form with implicit symmetric QR steps with Wilkinson shift. Details can be found in Section 8.3 of Golub &amp; Van Loan, <em>Matrix Computations</em>.</p> <p>The cost of the computation is about \( 9n^3 \) if the eigenvectors are required and \( 4n^3/3 \) if they are not required.</p> <p>This method reuses the memory in the <a href="classeigen_1_1selfadjointeigensolver" title="Computes eigenvalues and eigenvectors of selfadjoint matrices.">SelfAdjointEigenSolver</a> object that was allocated when the object was constructed, if the size of the matrix does not change.</p> <p>Example: </p>
<pre data-language="cpp">SelfAdjointEigenSolver&lt;MatrixXf&gt; es(4);
MatrixXf X = <a href="classeigen_1_1densebase#ae814abb451b48ed872819192dc188c19">MatrixXf::Random</a>(4,4);
MatrixXf A = X + X.transpose();
es.compute(A);
cout &lt;&lt; <span>"The eigenvalues of A are: "</span> &lt;&lt; es.eigenvalues().transpose() &lt;&lt; endl;
es.compute(A + <a href="classeigen_1_1matrixbase#a98bb9a0f705c6dfde85b0bfff31bf88f">MatrixXf::Identity</a>(4,4)); <span>// re-use es to compute eigenvalues of A+I</span>
cout &lt;&lt; <span>"The eigenvalues of A+I are: "</span> &lt;&lt; es.eigenvalues().transpose() &lt;&lt; endl;
</pre>
<p> Output: </p>
<pre>The eigenvalues of A are:  -1.58 -0.473   1.32   2.46
The eigenvalues of A+I are: -0.581  0.527   2.32   3.46
</pre>
<dl>
<dt>See also</dt>
<dd>SelfAdjointEigenSolver(const MatrixType&amp;, int) </dd>
</dl> </div> </div> <a id="afe520161701f5f585bcc4cedb8657bd1"></a> <h2>computeDirect()</h2> <div> <div> <div> template&lt;typename MatrixType &gt; </div> <table> <tr> <td>
<a href="classeigen_1_1selfadjointeigensolver">SelfAdjointEigenSolver</a>&lt; MatrixType &gt; &amp; <a href="classeigen_1_1selfadjointeigensolver">Eigen::SelfAdjointEigenSolver</a>&lt; MatrixType &gt;::computeDirect </td> <td>(</td> <td>const MatrixType &amp; </td> <td>
<em>matrix</em>, </td> </tr> <tr> <td></td> <td></td> <td>int </td> <td>
<em>options</em> = <code><a href="group__enums#ggae3e239fb70022eb8747994cf5d68b4a9a7f7d17fba3c9bb92158e346d5979d0f4">ComputeEigenvectors</a></code> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </div>
<div> <p>Computes eigendecomposition of given matrix using a closed-form algorithm. </p> <p>This is a variant of compute(const MatrixType&amp;, int options) which directly solves the underlying polynomial equation.</p> <p>Currently only 2x2 and 3x3 matrices for which the sizes are known at compile time are supported (e.g., Matrix3d).</p> <p>This method is usually significantly faster than the QR iterative algorithm but it might also be less accurate. It is also worth noting that for 3x3 matrices it involves trigonometric operations which are not necessarily available for all scalar types.</p> <p>For the 3x3 case, we observed the following worst case relative error regarding the eigenvalues:</p>
<ul> <li>double: 1e-8</li> <li>float: 1e-3</li> </ul> <dl>
<dt>See also</dt>
<dd>compute(const MatrixType&amp;, int options) </dd>
</dl> </div> </div> <a id="a297893df7098c43278d385e4d4e23fe4"></a> <h2>computeFromTridiagonal()</h2> <div> <div> <div> template&lt;typename MatrixType &gt; </div> <table> <tr> <td>
<a href="classeigen_1_1selfadjointeigensolver">SelfAdjointEigenSolver</a>&lt; MatrixType &gt; &amp; <a href="classeigen_1_1selfadjointeigensolver">Eigen::SelfAdjointEigenSolver</a>&lt; MatrixType &gt;::computeFromTridiagonal </td> <td>(</td> <td>const <a href="classeigen_1_1selfadjointeigensolver#acd090d5fdfc3cc017a13b6d8daa92287">RealVectorType</a> &amp; </td> <td>
<em>diag</em>, </td> </tr> <tr> <td></td> <td></td> <td>const <a href="classeigen_1_1matrix">SubDiagonalType</a> &amp; </td> <td>
<em>subdiag</em>, </td> </tr> <tr> <td></td> <td></td> <td>int </td> <td>
<em>options</em> = <code><a href="group__enums#ggae3e239fb70022eb8747994cf5d68b4a9a7f7d17fba3c9bb92158e346d5979d0f4">ComputeEigenvectors</a></code> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </div>
<div> <p>Computes the eigen decomposition from a tridiagonal symmetric matrix. </p> <dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>[in]</td>
<td>diag</td>
<td>The vector containing the diagonal of the matrix. </td>
</tr> <tr>
<td>[in]</td>
<td>subdiag</td>
<td>The subdiagonal of the matrix. </td>
</tr> <tr>
<td>[in]</td>
<td>options</td>
<td>Can be <a href="group__enums#ggae3e239fb70022eb8747994cf5d68b4a9a7f7d17fba3c9bb92158e346d5979d0f4">ComputeEigenvectors</a> (default) or <a href="group__enums#ggae3e239fb70022eb8747994cf5d68b4a9afd06633f270207c373875fd7ca03e906">EigenvaluesOnly</a>. </td>
</tr> </table> </dd> </dl> <dl>
<dt>Returns</dt>
<dd>Reference to <code>*this</code> </dd>
</dl> <p>This function assumes that the matrix has been reduced to tridiagonal form.</p> <dl>
<dt>See also</dt>
<dd>compute(const MatrixType&amp;, int) for more information </dd>
</dl> </div> </div> <a id="a3df8721abcc71132f7f02bf9dfe78e41"></a> <h2>eigenvalues()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="classeigen_1_1selfadjointeigensolver#acd090d5fdfc3cc017a13b6d8daa92287">RealVectorType</a>&amp; <a href="classeigen_1_1selfadjointeigensolver">Eigen::SelfAdjointEigenSolver</a>&lt; _MatrixType &gt;::eigenvalues </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Returns the eigenvalues of given matrix. </p> <dl>
<dt>Returns</dt>
<dd>A const reference to the column vector containing the eigenvalues.</dd>
</dl> <dl>
<dt>Precondition</dt>
<dd>The eigenvalues have been computed before.</dd>
</dl> <p>The eigenvalues are repeated according to their algebraic multiplicity, so there are as many eigenvalues as rows in the matrix. The eigenvalues are sorted in increasing order.</p> <p>Example: </p>
<pre data-language="cpp">MatrixXd ones = <a href="classeigen_1_1densebase#a2755cb4023f7376880523626a8e05101">MatrixXd::Ones</a>(3,3);
SelfAdjointEigenSolver&lt;MatrixXd&gt; es(ones);
cout &lt;&lt; <span>"The eigenvalues of the 3x3 matrix of ones are:"</span> 
     &lt;&lt; endl &lt;&lt; es.eigenvalues() &lt;&lt; endl;</pre>
<p> Output: </p>
<pre>The eigenvalues of the 3x3 matrix of ones are:
-3.09e-16
        0
        3
</pre>
<dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1selfadjointeigensolver#a229c4c26d87c5d2663cd3cc8a4c68266" title="Returns the eigenvectors of given matrix.">eigenvectors()</a>, <a href="classeigen_1_1matrixbase#a30430fa3d5b4e74d312fd4f502ac984d" title="Computes the eigenvalues of a matrix.">MatrixBase::eigenvalues()</a> </dd>
</dl> </div> </div> <a id="a229c4c26d87c5d2663cd3cc8a4c68266"></a> <h2>eigenvectors()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="classeigen_1_1matrix">EigenvectorsType</a>&amp; <a href="classeigen_1_1selfadjointeigensolver">Eigen::SelfAdjointEigenSolver</a>&lt; _MatrixType &gt;::eigenvectors </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Returns the eigenvectors of given matrix. </p> <dl>
<dt>Returns</dt>
<dd>A const reference to the matrix whose columns are the eigenvectors.</dd>
</dl> <dl>
<dt>Precondition</dt>
<dd>The eigenvectors have been computed before.</dd>
</dl> <p>Column \( k \) of the returned matrix is an eigenvector corresponding to eigenvalue number \( k \) as returned by <a href="classeigen_1_1selfadjointeigensolver#a3df8721abcc71132f7f02bf9dfe78e41" title="Returns the eigenvalues of given matrix.">eigenvalues()</a>. The eigenvectors are normalized to have (Euclidean) norm equal to one. If this object was used to solve the eigenproblem for the selfadjoint matrix \( A \), then the matrix returned by this function is the matrix \( V \) in the eigendecomposition \( A = V D V^{-1} \).</p> <p>For a selfadjoint matrix, \( V \) is unitary, meaning its inverse is equal to its adjoint, \( V^{-1} = V^{\dagger} \). If \( A \) is real, then \( V \) is also real and therefore orthogonal, meaning its inverse is equal to its transpose, \( V^{-1} = V^T \).</p> <p>Example: </p>
<pre data-language="cpp">MatrixXd ones = <a href="classeigen_1_1densebase#a2755cb4023f7376880523626a8e05101">MatrixXd::Ones</a>(3,3);
SelfAdjointEigenSolver&lt;MatrixXd&gt; es(ones);
cout &lt;&lt; <span>"The first eigenvector of the 3x3 matrix of ones is:"</span> 
     &lt;&lt; endl &lt;&lt; es.eigenvectors().col(0) &lt;&lt; endl;
</pre>
<p> Output: </p>
<pre>The first eigenvector of the 3x3 matrix of ones is:
-0.816
 0.408
 0.408
</pre>
<dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1selfadjointeigensolver#a3df8721abcc71132f7f02bf9dfe78e41" title="Returns the eigenvalues of given matrix.">eigenvalues()</a> </dd>
</dl> </div> </div> <a id="a31e8a509231e57e684c53799693607ae"></a> <h2>info()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="group__enums#ga85fad7b87587764e5cf6b513a9e0ee5e">ComputationInfo</a> <a href="classeigen_1_1selfadjointeigensolver">Eigen::SelfAdjointEigenSolver</a>&lt; _MatrixType &gt;::info </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Reports whether previous computation was successful. </p> <dl>
<dt>Returns</dt>
<dd>
<code>Success</code> if computation was successful, <code>NoConvergence</code> otherwise. </dd>
</dl> </div> </div> <a id="ae4b13fe4ce22faf74e50d346fc51a66e"></a> <h2>operatorInverseSqrt()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>MatrixType <a href="classeigen_1_1selfadjointeigensolver">Eigen::SelfAdjointEigenSolver</a>&lt; _MatrixType &gt;::operatorInverseSqrt </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Computes the inverse square root of the matrix. </p> <dl>
<dt>Returns</dt>
<dd>the inverse positive-definite square root of the matrix</dd>
</dl> <dl>
<dt>Precondition</dt>
<dd>The eigenvalues and eigenvectors of a positive-definite matrix have been computed before.</dd>
</dl> <p>This function uses the eigendecomposition \( A = V D V^{-1} \) to compute the inverse square root as \( V D^{-1/2} V^{-1} \). This is cheaper than first computing the square root with <a href="classeigen_1_1selfadjointeigensolver#aeeedb2ae618f21a4eb59465746c1cee5" title="Computes the positive-definite square root of the matrix.">operatorSqrt()</a> and then its inverse with <a href="classeigen_1_1matrixbase#a7712eb69e8ea3c8f7b8da1c44dbdeebf">MatrixBase::inverse()</a>.</p> <p>Example: </p>
<pre data-language="cpp">MatrixXd X = <a href="classeigen_1_1densebase#ae814abb451b48ed872819192dc188c19">MatrixXd::Random</a>(4,4);
MatrixXd A = X * X.transpose();
cout &lt;&lt; <span>"Here is a random positive-definite matrix, A:"</span> &lt;&lt; endl &lt;&lt; A &lt;&lt; endl &lt;&lt; endl;
 
SelfAdjointEigenSolver&lt;MatrixXd&gt; es(A);
cout &lt;&lt; <span>"The inverse square root of A is: "</span> &lt;&lt; endl;
cout &lt;&lt; es.operatorInverseSqrt() &lt;&lt; endl;
cout &lt;&lt; <span>"We can also compute it with operatorSqrt() and inverse(). That yields: "</span> &lt;&lt; endl;
cout &lt;&lt; es.operatorSqrt().inverse() &lt;&lt; endl;
</pre>
<p> Output: </p>
<pre>Here is a random positive-definite matrix, A:
  1.41 -0.697 -0.111  0.508
-0.697  0.423 0.0991   -0.4
-0.111 0.0991   1.25  0.902
 0.508   -0.4  0.902    1.4

The inverse square root of A is: 
  1.88   2.78 -0.546  0.605
  2.78   8.61   -2.3   2.74
-0.546   -2.3   1.92  -1.36
 0.605   2.74  -1.36   2.18
We can also compute it with operatorSqrt() and inverse(). That yields: 
  1.88   2.78 -0.546  0.605
  2.78   8.61   -2.3   2.74
-0.546   -2.3   1.92  -1.36
 0.605   2.74  -1.36   2.18
</pre>
<dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1selfadjointeigensolver#aeeedb2ae618f21a4eb59465746c1cee5" title="Computes the positive-definite square root of the matrix.">operatorSqrt()</a>, <a href="classeigen_1_1matrixbase#a7712eb69e8ea3c8f7b8da1c44dbdeebf">MatrixBase::inverse()</a>, <a href="unsupported/group__matrixfunctions__module">MatrixFunctions Module</a> </dd>
</dl> </div> </div> <a id="aeeedb2ae618f21a4eb59465746c1cee5"></a> <h2>operatorSqrt()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>MatrixType <a href="classeigen_1_1selfadjointeigensolver">Eigen::SelfAdjointEigenSolver</a>&lt; _MatrixType &gt;::operatorSqrt </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Computes the positive-definite square root of the matrix. </p> <dl>
<dt>Returns</dt>
<dd>the positive-definite square root of the matrix</dd>
</dl> <dl>
<dt>Precondition</dt>
<dd>The eigenvalues and eigenvectors of a positive-definite matrix have been computed before.</dd>
</dl> <p>The square root of a positive-definite matrix \( A \) is the positive-definite matrix whose square equals \( A \). This function uses the eigendecomposition \( A = V D V^{-1} \) to compute the square root as \( A^{1/2} = V D^{1/2} V^{-1} \).</p> <p>Example: </p>
<pre data-language="cpp">MatrixXd X = <a href="classeigen_1_1densebase#ae814abb451b48ed872819192dc188c19">MatrixXd::Random</a>(4,4);
MatrixXd A = X * X.transpose();
cout &lt;&lt; <span>"Here is a random positive-definite matrix, A:"</span> &lt;&lt; endl &lt;&lt; A &lt;&lt; endl &lt;&lt; endl;
 
SelfAdjointEigenSolver&lt;MatrixXd&gt; es(A);
MatrixXd sqrtA = es.operatorSqrt();
cout &lt;&lt; <span>"The square root of A is: "</span> &lt;&lt; endl &lt;&lt; sqrtA &lt;&lt; endl;
cout &lt;&lt; <span>"If we square this, we get: "</span> &lt;&lt; endl &lt;&lt; sqrtA*sqrtA &lt;&lt; endl;
</pre>
<p> Output: </p>
<pre>Here is a random positive-definite matrix, A:
  1.41 -0.697 -0.111  0.508
-0.697  0.423 0.0991   -0.4
-0.111 0.0991   1.25  0.902
 0.508   -0.4  0.902    1.4

The square root of A is: 
   1.09  -0.432 -0.0685     0.2
 -0.432   0.379   0.141  -0.269
-0.0685   0.141       1   0.468
    0.2  -0.269   0.468    1.04
If we square this, we get: 
  1.41 -0.697 -0.111  0.508
-0.697  0.423 0.0991   -0.4
-0.111 0.0991   1.25  0.902
 0.508   -0.4  0.902    1.4
</pre>
<dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1selfadjointeigensolver#ae4b13fe4ce22faf74e50d346fc51a66e" title="Computes the inverse square root of the matrix.">operatorInverseSqrt()</a>, <a href="unsupported/group__matrixfunctions__module">MatrixFunctions Module</a> </dd>
</dl> </div> </div>  <a id="a9ba10b83f095b18dbea345db7304acfa"></a> <h2>m_maxIterations</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>const int <a href="classeigen_1_1selfadjointeigensolver">Eigen::SelfAdjointEigenSolver</a>&lt; _MatrixType &gt;::m_maxIterations</td> </tr> </table> </td> <td> <span><span>static</span></span> </td> </tr> </table> </div>
<div> <p>Maximum number of iterations. </p> <p>The algorithm terminates if it does not converge within m_maxIterations * n iterations, where n denotes the size of the matrix. This value is currently set to 30 (copied from LAPACK). </p> </div> </div> <hr>The documentation for this class was generated from the following file:<ul> <li><a href="https://eigen.tuxfamily.org/dox/SelfAdjointEigenSolver_8h_source.html">SelfAdjointEigenSolver.h</a></li> </ul> </div> <div class="_attribution">
  <p class="_attribution-p">
     Eigen.<br>Licensed under the MPL2 License.<br>
    <a href="https://eigen.tuxfamily.org/dox/classEigen_1_1SelfAdjointEigenSolver.html" class="_attribution-link">https://eigen.tuxfamily.org/dox/classEigen_1_1SelfAdjointEigenSolver.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
