
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Quick Reference Guide - Eigen3 - W3cubDocs</title>
  
  <meta name="description" content=" ">
  <meta name="keywords" content="quick, reference, guide, modules, and, header, files, array, matrix, vector, types, arithmetic, operators, coefficient-wise, &#38;, reductions, sub-matrices, miscellaneous, operations, diagonal, triangular, self-adjoint, matrices, eigen, eigen3">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/eigen3/group__quickrefpage.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-f16eecbe420d8b2925d31ffbb21d05646497ecbd9515f08ffe69e9bba7332f5657accc7003c7f6c72cb4a132171acf171b359ae3bae4ae5660ddfb1718f88c67.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/eigen3.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/eigen3/" class="_nav-link" title="" style="margin-left:0;">Eigen3</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _eigen3">
				
				
<h1>Quick reference guide</h1>      <div> <hr> <p> </p> <h1>
<a id="QuickRef_Headers"></a> Modules and Header files</h1> <p>The <a href="namespaceeigen" title="Namespace containing all symbols from the Eigen library.">Eigen</a> library is divided in a Core module and several additional modules. Each module has a corresponding header file which has to be included in order to use the module. The <code>Dense</code> and <code><a href="namespaceeigen" title="Namespace containing all symbols from the Eigen library.">Eigen</a></code> header files are provided to conveniently gain access to several modules at once.</p> <table> <tr> <th>Module</th>
<th>Header file</th>
<th>Contents </th>
</tr> <tr> <td><a href="group__core__module">Core </a></td>
<td><pre data-language="cpp"><span>#include &lt;Eigen/Core&gt;</span>
</pre></td>
<td>
<a href="classeigen_1_1matrix" title="The matrix class, also used for vectors and row-vectors.">Matrix</a> and <a href="classeigen_1_1array" title="General-purpose arrays with easy API for coefficient-wise operations.">Array</a> classes, basic linear algebra (including triangular and selfadjoint products), array manipulation </td>
</tr> <tr> <td><a href="group__geometry__module">Geometry </a></td>
<td><pre data-language="cpp"><span>#include &lt;Eigen/Geometry&gt;</span>
</pre></td>
<td>
<a href="classeigen_1_1transform" title="Represents an homogeneous transformation in a N dimensional space.">Transform</a>, <a href="classeigen_1_1translation" title="Represents a translation transformation.">Translation</a>, Scaling, <a href="classeigen_1_1rotation2d" title="Represents a rotation/orientation in a 2 dimensional space.">Rotation2D</a> and 3D rotations (<a href="classeigen_1_1quaternion" title="The quaternion class used to represent 3D orientations and rotations.">Quaternion</a>, <a href="classeigen_1_1angleaxis" title="Represents a 3D rotation as a rotation angle around an arbitrary 3D axis.">AngleAxis</a>) </td>
</tr> <tr> <td><a href="group__lu__module">LU </a></td>
<td><pre data-language="cpp"><span>#include &lt;Eigen/LU&gt;</span>
</pre></td>
<td>
<a href="classeigen_1_1inverse" title="Expression of the inverse of another expression.">Inverse</a>, determinant, LU decompositions with solver (<a href="classeigen_1_1fullpivlu" title="LU decomposition of a matrix with complete pivoting, and related features.">FullPivLU</a>, <a href="classeigen_1_1partialpivlu" title="LU decomposition of a matrix with partial pivoting, and related features.">PartialPivLU</a>) </td>
</tr> <tr> <td><a href="group__cholesky__module">Cholesky </a></td>
<td><pre data-language="cpp"><span>#include &lt;Eigen/Cholesky&gt;</span>
</pre></td>
<td>
<a href="classeigen_1_1llt" title="Standard Cholesky decomposition (LL^T) of a matrix and associated features.">LLT</a> and <a href="classeigen_1_1ldlt" title="Robust Cholesky decomposition of a matrix with pivoting.">LDLT</a> Cholesky factorization with solver </td>
</tr> <tr> <td><a href="group__householder__module">Householder </a></td>
<td><pre data-language="cpp"><span>#include &lt;Eigen/Householder&gt;</span>
</pre></td>
<td>Householder transformations; this module is used by several linear algebra modules </td>
</tr> <tr> <td><a href="group__svd__module">SVD </a></td>
<td><pre data-language="cpp"><span>#include &lt;Eigen/SVD&gt;</span>
</pre></td>
<td>SVD decompositions with least-squares solver (<a href="classeigen_1_1jacobisvd" title="Two-sided Jacobi SVD decomposition of a rectangular matrix.">JacobiSVD</a>, <a href="classeigen_1_1bdcsvd" title="class Bidiagonal Divide and Conquer SVD">BDCSVD</a>) </td>
</tr> <tr> <td><a href="group__qr__module">QR </a></td>
<td><pre data-language="cpp"><span>#include &lt;Eigen/QR&gt;</span>
</pre></td>
<td>QR decomposition with solver (<a href="classeigen_1_1householderqr" title="Householder QR decomposition of a matrix.">HouseholderQR</a>, <a href="classeigen_1_1colpivhouseholderqr" title="Householder rank-revealing QR decomposition of a matrix with column-pivoting.">ColPivHouseholderQR</a>, <a href="classeigen_1_1fullpivhouseholderqr" title="Householder rank-revealing QR decomposition of a matrix with full pivoting.">FullPivHouseholderQR</a>) </td>
</tr> <tr> <td><a href="group__eigenvalues__module">Eigenvalues </a></td>
<td><pre data-language="cpp"><span>#include &lt;Eigen/Eigenvalues&gt;</span>
</pre></td>
<td>Eigenvalue, eigenvector decompositions (<a href="classeigen_1_1eigensolver" title="Computes eigenvalues and eigenvectors of general matrices.">EigenSolver</a>, <a href="classeigen_1_1selfadjointeigensolver" title="Computes eigenvalues and eigenvectors of selfadjoint matrices.">SelfAdjointEigenSolver</a>, <a href="classeigen_1_1complexeigensolver" title="Computes eigenvalues and eigenvectors of general complex matrices.">ComplexEigenSolver</a>) </td>
</tr> <tr> <td><a href="group__sparse__module">Sparse </a></td>
<td><pre data-language="cpp"><span>#include &lt;Eigen/Sparse&gt;</span>
</pre></td>
<td>Sparse matrix storage and related basic linear algebra (<a href="classeigen_1_1sparsematrix" title="A versatible sparse matrix representation.">SparseMatrix</a>, <a href="classeigen_1_1sparsevector" title="a sparse vector class">SparseVector</a>) <br> (see <a href="group__sparsequickrefpage">Quick reference guide for sparse matrices</a> for details on sparse modules) </td>
</tr> <tr> <td></td>
<td><pre data-language="cpp"><span>#include &lt;Eigen/Dense&gt;</span>
</pre></td>
<td>Includes Core, Geometry, LU, Cholesky, SVD, QR, and Eigenvalues header files </td>
</tr> <tr> <td></td>
<td><pre data-language="cpp"><span>#include &lt;Eigen/Eigen&gt;</span>
</pre></td>
<td>Includes Dense and Sparse header files (the whole <a href="namespaceeigen" title="Namespace containing all symbols from the Eigen library.">Eigen</a> library) </td>
</tr> </table> <p> </p> <h1>
<a id="QuickRef_Types"></a> Array, matrix and vector types</h1> <p><b>Recall:</b> <a href="namespaceeigen" title="Namespace containing all symbols from the Eigen library.">Eigen</a> provides two kinds of dense objects: mathematical matrices and vectors which are both represented by the template class <a href="classeigen_1_1matrix" title="The matrix class, also used for vectors and row-vectors.">Matrix</a>, and general 1D and 2D arrays represented by the template class <a href="classeigen_1_1array" title="General-purpose arrays with easy API for coefficient-wise operations.">Array</a>: </p>
<pre data-language="cpp"><span>typedef</span> Matrix&lt;Scalar, RowsAtCompileTime, ColsAtCompileTime, Options&gt; MyMatrixType;
<span>typedef</span> Array&lt;Scalar, RowsAtCompileTime, ColsAtCompileTime, Options&gt; MyArrayType;
</pre>
<ul> <li>
<code>Scalar</code> is the scalar type of the coefficients (e.g., <code>float</code>, <code>double</code>, <code>bool</code>, <code>int</code>, etc.). </li> <li>
<code>RowsAtCompileTime</code> and <code>ColsAtCompileTime</code> are the number of rows and columns of the matrix as known at compile-time or <code>Dynamic</code>. </li> <li>
<code>Options</code> can be <code>ColMajor</code> or <code>RowMajor</code>, default is <code>ColMajor</code>. (see class <a href="classeigen_1_1matrix" title="The matrix class, also used for vectors and row-vectors.">Matrix</a> for more options)</li> </ul> <p>All combinations are allowed: you can have a matrix with a fixed number of rows and a dynamic number of columns, etc. The following are all valid: </p>
<pre data-language="cpp">Matrix&lt;double, 6, Dynamic&gt;                  <span>// Dynamic number of columns (heap allocation)</span>
Matrix&lt;double, Dynamic, 2&gt;                  <span>// Dynamic number of rows (heap allocation)</span>
Matrix&lt;double, Dynamic, Dynamic, RowMajor&gt;  <span>// Fully dynamic, row major (heap allocation)</span>
Matrix&lt;double, 13, 3&gt;                       <span>// Fully fixed (usually allocated on stack)</span>
</pre>
<p>In most cases, you can simply use one of the convenience typedefs for <a href="group__matrixtypedefs">matrices</a> and <a href="group__arraytypedefs">arrays</a>. Some examples: </p>
<table> <tr> <th>Matrices</th>
<th>Arrays </th>
</tr> <tr> <td><pre data-language="cpp">Matrix&lt;float,Dynamic,Dynamic&gt;   &lt;=&gt;   MatrixXf
Matrix&lt;double,Dynamic,1&gt;        &lt;=&gt;   VectorXd
Matrix&lt;int,1,Dynamic&gt;           &lt;=&gt;   RowVectorXi
Matrix&lt;float,3,3&gt;               &lt;=&gt;   Matrix3f
Matrix&lt;float,4,1&gt;               &lt;=&gt;   Vector4f
</pre></td>
<td>
<pre data-language="cpp">Array&lt;float,Dynamic,Dynamic&gt;    &lt;=&gt;   ArrayXXf
Array&lt;double,Dynamic,1&gt;         &lt;=&gt;   ArrayXd
Array&lt;int,1,Dynamic&gt;            &lt;=&gt;   RowArrayXi
Array&lt;float,3,3&gt;                &lt;=&gt;   Array33f
Array&lt;float,4,1&gt;                &lt;=&gt;   Array4f
</pre> </td>
</tr> </table> <p>Conversion between the matrix and array worlds: </p>
<pre data-language="cpp">Array44f a1, a2;
Matrix4f m1, m2;
m1 = a1 * a2;                     <span>// coeffwise product, implicit conversion from array to matrix.</span>
a1 = m1 * m2;                     <span>// matrix product, implicit conversion from matrix to array.</span>
a2 = a1 + m1.array();             <span>// mixing array and matrix is forbidden</span>
m2 = a1.matrix() + m1;            <span>// and explicit conversion is required.</span>
ArrayWrapper&lt;Matrix4f&gt; m1a(m1);   <span>// m1a is an alias for m1.array(), they share the same coefficients</span>
MatrixWrapper&lt;Array44f&gt; a1m(a1);
</pre>
<p>In the rest of this document we will use the following symbols to emphasize the features which are specifics to a given kind of object: </p>
<ul> <li>
<a id="matrixonly"></a><a href="#matrixonly" style="color:green;text-decoration: none;">*</a> linear algebra matrix and vector only </li> <li>
<a id="arrayonly"></a><a href="#arrayonly" style="color:blue;text-decoration: none;">*</a> array objects only</li> </ul> <h2>
<a id="QuickRef_Basics"></a> Basic matrix manipulation</h2> <table> <tr> <th></th>
<th>1D objects</th>
<th>2D objects</th>
<th>Notes </th>
</tr> <tr> <td>Constructors </td>
<td><pre data-language="cpp">Vector4d  v4;
Vector2f  v1(x, y);
Array3i   v2(x, y, z);
Vector4d  v3(x, y, z, w);
 
VectorXf  v5; <span>// empty object</span>
ArrayXf   v6(size);
</pre></td>
<td><pre data-language="cpp">Matrix4f  m1;
 
 
 
 
MatrixXf  m5; <span>// empty object</span>
MatrixXf  m6(nb_rows, nb_columns);
</pre></td>
<td>By default, the coefficients <br> are left uninitialized </td>
</tr> <tr> <td>Comma initializer </td>
<td><pre data-language="cpp">Vector3f  v1;     v1 &lt;&lt; x, y, z;
ArrayXf   v2(4);  v2 &lt;&lt; 1, 2, 3, 4;
</pre></td>
<td><pre data-language="cpp">Matrix3f  m1;   m1 &lt;&lt; 1, 2, 3,
                      4, 5, 6,
                      7, 8, 9;
</pre></td>
<td>
<p></p> <p></p> </td>
</tr> <tr> <td>Comma initializer (bis) </td>
<td colspan="2">
<pre data-language="cpp"><span>int</span> rows=5, cols=5;
MatrixXf m(rows,cols);
m &lt;&lt; (Matrix3f() &lt;&lt; 1, 2, 3, 4, 5, 6, 7, 8, 9).finished(),
     <a href="classeigen_1_1densebase#a422ddeef58bedc7bddb1d4357688d761">MatrixXf::Zero</a>(3,cols-3),
     <a href="classeigen_1_1densebase#a422ddeef58bedc7bddb1d4357688d761">MatrixXf::Zero</a>(rows-3,3),
     <a href="classeigen_1_1matrixbase#a98bb9a0f705c6dfde85b0bfff31bf88f">MatrixXf::Identity</a>(rows-3,cols-3);
cout &lt;&lt; m;</pre> </td>
<td>
<p>output: </p>
<pre>1 2 3 0 0
4 5 6 0 0
7 8 9 0 0
0 0 0 1 0
0 0 0 0 1</pre> <p></p> </td>
</tr> <tr> <td>Runtime info </td>
<td><pre data-language="cpp">vector.size();
 
vector.innerStride();
vector.data();
</pre></td>
<td><pre data-language="cpp">matrix.rows();          matrix.cols();
matrix.innerSize();     matrix.outerSize();
matrix.innerStride();   matrix.outerStride();
matrix.data();
</pre></td>
<td>Inner/Outer* are storage order dependent </td>
</tr> <tr> <td>Compile-time info </td>
<td colspan="2"><pre data-language="cpp">ObjectType::Scalar              ObjectType::RowsAtCompileTime
ObjectType::RealScalar          ObjectType::ColsAtCompileTime
ObjectType::Index               ObjectType::SizeAtCompileTime
</pre></td>
<td></td>
</tr> <tr> <td>Resizing </td>
<td><pre data-language="cpp">vector.resize(size);
 
 
vector.resizeLike(other_vector);
vector.conservativeResize(size);
</pre></td>
<td><pre data-language="cpp">matrix.resize(nb_rows, nb_cols);
matrix.resize(Eigen::NoChange, nb_cols);
matrix.resize(nb_rows, Eigen::NoChange);
matrix.resizeLike(other_matrix);
matrix.conservativeResize(nb_rows, nb_cols);
</pre></td>
<td>
<p>no-op if the new sizes match,<br> otherwise data are lost<br> <br> resizing with data preservation</p> <p></p> </td>
</tr> <tr> <td>Coeff access with <br> range checking </td>
<td><pre data-language="cpp">vector(i)     vector.x()
vector[i]     vector.y()
              vector.z()
              vector.w()
</pre></td>
<td><pre data-language="cpp">matrix(i,j)
</pre></td>
<td>
<p>Range checking is disabled if <br> NDEBUG or EIGEN_NO_DEBUG is defined</p> <p></p> </td>
</tr> <tr> <td>Coeff access without <br> range checking </td>
<td><pre data-language="cpp">vector.coeff(i)
vector.coeffRef(i)
</pre></td>
<td><pre data-language="cpp">matrix.coeff(i,j)
matrix.coeffRef(i,j)
</pre></td>
<td>
<p></p> <p></p> </td>
</tr> <tr> <td>Assignment/copy </td>
<td colspan="2"><pre data-language="cpp"><span>object</span> = expression;
object_of_float = expression_of_double.cast&lt;<span>float</span>&gt;();
</pre></td>
<td>
<p>the destination is automatically resized (if possible)</p> <p></p> </td>
</tr> </table> <h2>
<a id="QuickRef_PredefMat"></a> Predefined Matrices</h2> <table> <tr> <th>Fixed-size matrix or vector </th>
<th>Dynamic-size matrix </th>
<th>Dynamic-size vector </th>
</tr> <tr style="border-bottom-style: none;"> <td>
<pre data-language="cpp"><span>typedef</span> {Matrix3f|Array33f} FixedXD;
FixedXD x;
 
x = FixedXD::Zero();
x = FixedXD::Ones();
x = FixedXD::Constant(value);
x = FixedXD::Random();
x = FixedXD::LinSpaced(size, low, high);
 
x.setZero();
x.setOnes();
x.setConstant(value);
x.setRandom();
x.setLinSpaced(size, low, high);
</pre> </td>
<td>
<pre data-language="cpp"><span>typedef</span> {MatrixXf|ArrayXXf} Dynamic2D;
Dynamic2D x;
 
x = Dynamic2D::Zero(rows, cols);
x = Dynamic2D::Ones(rows, cols);
x = Dynamic2D::Constant(rows, cols, value);
x = Dynamic2D::Random(rows, cols);
N/A
 
x.setZero(rows, cols);
x.setOnes(rows, cols);
x.setConstant(rows, cols, value);
x.setRandom(rows, cols);
N/A
</pre> </td>
<td>
<pre data-language="cpp"><span>typedef</span> {VectorXf|ArrayXf} Dynamic1D;
Dynamic1D x;
 
x = Dynamic1D::Zero(size);
x = Dynamic1D::Ones(size);
x = Dynamic1D::Constant(size, value);
x = Dynamic1D::Random(size);
x = Dynamic1D::LinSpaced(size, low, high);
 
x.setZero(size);
x.setOnes(size);
x.setConstant(size, value);
x.setRandom(size);
x.setLinSpaced(size, low, high);
</pre> <p></p> </td>
</tr> <tr> <td colspan="3">Identity and <a href="classeigen_1_1matrixbase#ac7a03a61014f37ddd2fe61ebac0c9539">basis vectors </a> <a href="#matrixonly" style="color:green;text-decoration: none;">*</a> </td>
</tr> <tr style="border-bottom-style: none;"> <td>
<pre data-language="cpp">x = FixedXD::Identity();
x.setIdentity();
 
<a href="classeigen_1_1matrixbase#a8a555b7cf626cced54670b98668c4e6d">Vector3f::UnitX</a>() <span>// 1 0 0</span>
Vector3f::UnitY() <span>// 0 1 0</span>
Vector3f::UnitZ() <span>// 0 0 1</span>
Vector4f::Unit(i)
x.setUnit(i);</pre> </td>
<td>
<pre data-language="cpp">x = Dynamic2D::Identity(rows, cols);
x.setIdentity(rows, cols);
 
 
 
N/A
</pre> </td>
<td>
<pre data-language="cpp">N/A
 
 
<a href="classeigen_1_1matrixbase#ac7a03a61014f37ddd2fe61ebac0c9539">VectorXf::Unit</a>(size,i)
x.setUnit(size,i);
<a href="classeigen_1_1matrixbase#ac7a03a61014f37ddd2fe61ebac0c9539">VectorXf::Unit</a>(4,1) == Vector4f(0,1,0,0)
                    == <a href="classeigen_1_1matrixbase#a00850083489e20249b1d05b394fc5efc">Vector4f::UnitY</a>()</pre> </td>
</tr> </table> <p>Note that it is allowed to call any of the <code>set*</code> functions to a dynamic-sized vector or matrix without passing new sizes. For instance: </p>
<pre data-language="cpp">MatrixXi M(3,3);
M.setIdentity();
</pre>
<h2>
<a id="QuickRef_Map"></a> Mapping external arrays</h2> <table> <tr> <td>Contiguous <br> memory </td>
<td>
<pre data-language="cpp"><span>float</span> data[] = {1,2,3,4};
Map&lt;Vector3f&gt; v1(data);       <span>// uses v1 as a Vector3f object</span>
Map&lt;ArrayXf&gt;  v2(data,3);     <span>// uses v2 as a ArrayXf object</span>
Map&lt;Array22f&gt; m1(data);       <span>// uses m1 as a Array22f object</span>
Map&lt;MatrixXf&gt; m2(data,2,2);   <span>// uses m2 as a MatrixXf object</span>
</pre> </td>
</tr> <tr> <td>Typical usage <br> of strides </td>
<td>
<pre data-language="cpp"><span>float</span> data[] = {1,2,3,4,5,6,7,8,9};
Map&lt;VectorXf,0,InnerStride&lt;2&gt; &gt;  v1(data,3);                      <span>// = [1,3,5]</span>
Map&lt;VectorXf,0,InnerStride&lt;&gt; &gt;   v2(data,3,InnerStride&lt;&gt;(3));     <span>// = [1,4,7]</span>
Map&lt;MatrixXf,0,OuterStride&lt;3&gt; &gt;  m2(data,2,3);                    <span>// both lines     |1,4,7|</span>
Map&lt;MatrixXf,0,OuterStride&lt;&gt; &gt;   m1(data,2,3,OuterStride&lt;&gt;(3));   <span>// are equal to:  |2,5,8|</span>
</pre> </td>
</tr> </table> <p> </p> <h1>
<a id="QuickRef_ArithmeticOperators"></a> Arithmetic Operators</h1> <table> <tr> <td>add <br> subtract</td>
<td>
<pre data-language="cpp">mat3 = mat1 + mat2;           mat3 += mat1;
mat3 = mat1 - mat2;           mat3 -= mat1;
</pre> </td>
</tr> <tr> <td>scalar product</td>
<td>
<pre data-language="cpp">mat3 = mat1 * s1;             mat3 *= s1;           mat3 = s1 * mat1;
mat3 = mat1 / s1;             mat3 /= s1;
</pre> </td>
</tr> <tr> <td>matrix/vector <br> products <a href="#matrixonly" style="color:green;text-decoration: none;">*</a>
</td>
<td>
<pre data-language="cpp">col2 = mat1 * col1;
row2 = row1 * mat1;           row1 *= mat1;
mat3 = mat1 * mat2;           mat3 *= mat1; 
</pre> </td>
</tr> <tr> <td>transposition <br> adjoint <a href="#matrixonly" style="color:green;text-decoration: none;">*</a>
</td>
<td>
<pre data-language="cpp">mat1 = mat2.transpose();      mat1.transposeInPlace();
mat1 = mat2.adjoint();        mat1.adjointInPlace();
</pre> </td>
</tr> <tr> <td>
<a href="classeigen_1_1matrixbase#adfd32bf5fcf6ee603c924dde9bf7bc39">dot </a> product <br> inner product <a href="#matrixonly" style="color:green;text-decoration: none;">*</a>
</td>
<td>
<pre data-language="cpp">scalar = vec1.dot(vec2);
scalar = col1.adjoint() * col2;
scalar = (col1.adjoint() * col2).value();
</pre> </td>
</tr> <tr> <td>outer product <a href="#matrixonly" style="color:green;text-decoration: none;">*</a>
</td>
<td>
<pre data-language="cpp">mat = col1 * col2.transpose();
</pre> <p></p> </td>
</tr> <tr> <td>
<a href="classeigen_1_1matrixbase#a196c4ec3c8ffdf5bda45d0f617154975">norm </a> <br> <a href="classeigen_1_1matrixbase#a5cf2fd4c57e59604fd4116158fd34308">normalization </a> <a href="#matrixonly" style="color:green;text-decoration: none;">*</a>
</td>
<td>
<pre data-language="cpp">scalar = vec1.norm();         scalar = vec1.squaredNorm()
vec2 = vec1.normalized();     vec1.normalize(); <span>// inplace </span>
</pre> <p></p> </td>
</tr> <tr> <td>
<a href="group__geometry__module#ga0024b44eca99cb7135887c2aaf319d28">cross product </a> <a href="#matrixonly" style="color:green;text-decoration: none;">*</a>
</td>
<td>
<pre data-language="cpp"><span>#include &lt;Eigen/Geometry&gt;</span>
vec3 = vec1.cross(vec2);
</pre> </td>
</tr> </table> <p> </p> <h1>
<a id="QuickRef_Coeffwise"></a> Coefficient-wise &amp; Array operators</h1> <p>In addition to the aforementioned operators, <a href="namespaceeigen" title="Namespace containing all symbols from the Eigen library.">Eigen</a> supports numerous coefficient-wise operator and functions. Most of them unambiguously makes sense in array-world<a href="#arrayonly" style="color:blue;text-decoration: none;">*</a>. The following operators are readily available for arrays, or available through .array() for vectors and matrices:</p> <table> <tr> <td>Arithmetic operators</td>
<td>
<pre data-language="cpp">array1 * array2     array1 / array2     array1 *= array2    array1 /= array2
array1 + scalar     array1 - scalar     array1 += scalar    array1 -= scalar
</pre> </td>
</tr> <tr> <td>Comparisons</td>
<td>
<pre data-language="cpp">array1 &lt; array2     array1 &gt; array2     array1 &lt; scalar     array1 &gt; scalar
array1 &lt;= array2    array1 &gt;= array2    array1 &lt;= scalar    array1 &gt;= scalar
array1 == array2    array1 != array2    array1 == scalar    array1 != scalar
array1.min(array2)  array1.max(array2)  array1.min(scalar)  array1.max(scalar)
</pre> </td>
</tr> <tr> <td>Trigo, power, and <br> misc functions <br> and the STL-like variants</td>
<td>
<pre data-language="cpp">array1.abs2()
array1.abs()                  <a href="namespaceeigen#ae27242789e7e62a8c42579b79be59b1a">abs</a>(array1)
array1.sqrt()                 <a href="namespaceeigen#af4f536e8ea56702e63088efb3706d1f0">sqrt</a>(array1)
array1.log()                  <a href="namespaceeigen#ae8bb75ba4f5f30a7571146dbfa653c6d">log</a>(array1)
array1.log10()                <a href="namespaceeigen#a25256faeec3ffd0f3615a0e1e45dfb14">log10</a>(array1)
array1.exp()                  <a href="namespaceeigen#ae491aecf7dab66ac7e11008c5766694d">exp</a>(array1)
array1.pow(array2)            pow(array1,array2)
array1.pow(scalar)            pow(array1,scalar)
                              pow(scalar,array2)
array1.square()
array1.cube()
array1.inverse()
 
array1.sin()                  <a href="namespaceeigen#ae6e8ad270ff41c088d7651567594f796">sin</a>(array1)
array1.cos()                  <a href="namespaceeigen#ad01d50a42869218f1d54af13f71517a6">cos</a>(array1)
array1.tan()                  <a href="namespaceeigen#a3bc116a6243f38c22f851581aa7b521a">tan</a>(array1)
array1.asin()                 <a href="namespaceeigen#a6c5c246b877ac331495d21e7a5d51616">asin</a>(array1)
array1.acos()                 <a href="namespaceeigen#a3fe3a136370fefae062591304c6a7ebd">acos</a>(array1)
array1.atan()                 <a href="namespaceeigen#a230744e17147d12e8ef3f2fc3796f64f">atan</a>(array1)
array1.sinh()                 <a href="namespaceeigen#af284ce359b6efd4b594a9f8a1f5e5d96">sinh</a>(array1)
array1.cosh()                 <a href="namespaceeigen#a34b99a26a2a1e7ff985a5ace16eedfcb">cosh</a>(array1)
array1.tanh()                 <a href="namespaceeigen#a0110c233d357169fd58fdf5656992a98">tanh</a>(array1)
array1.arg()                  <a href="namespaceeigen#aa539408a09481d35961e11ee78793db1">arg</a>(array1)
 
array1.floor()                <a href="namespaceeigen#abf03d773a87830bc7fde51bcd94c89a0">floor</a>(array1)
array1.ceil()                 <a href="namespaceeigen#aa73e38be0689a463ae14141b9cf89c35">ceil</a>(array1)
array1.round()                <a href="namespaceeigen#ad9eaa98e8016ef17024a18a2f3e5bef3">round</a>(aray1)
 
array1.isFinite()             <a href="namespaceeigen#aba24ec81dec745a00b7f33adead89811">isfinite</a>(array1)
array1.isInf()                <a href="namespaceeigen#a1f1103712e337c4c96a05f949637a4c8">isinf</a>(array1)
array1.isNaN()                <a href="namespaceeigen#a99adfc5178f3fd5488304284388b2a10">isnan</a>(array1)</pre> </td>
</tr> </table> <p>The following coefficient-wise operators are available for all kind of expressions (matrices, vectors, and arrays), and for both real or complex scalar types:</p> <table> <tr> <th>
<a href="namespaceeigen" title="Namespace containing all symbols from the Eigen library.">Eigen</a>'s API</th>
<th>STL-like APIs<a href="#arrayonly" style="color:blue;text-decoration: none;">*</a> </th>
<th>Comments </th>
</tr> <tr> <td>
<pre data-language="cpp">mat1.real()
mat1.imag()
mat1.conjugate()
</pre> </td>
<td>
<pre data-language="cpp"><a href="namespaceeigen#ac74dc920119b1eba45e9218d9f402afc">real</a>(array1)
<a href="namespaceeigen#a04d60a3c8a266f63c08e03615c1985c9">imag</a>(array1)
<a href="namespaceeigen#ab84f39a06a18e1ebb23f8be80345b79d">conj</a>(array1)</pre> </td>
<td>
<pre data-language="cpp"><span>// read-write, no-op for real expressions</span>
<span>// read-only for real, read-write for complexes</span>
<span>// no-op for real expressions</span>
</pre> </td>
</tr> </table> <p>Some coefficient-wise operators are readily available for for matrices and vectors through the following cwise* methods: </p>
<table> <tr> <th>
<a href="classeigen_1_1matrix" title="The matrix class, also used for vectors and row-vectors.">Matrix</a> API <a href="#matrixonly" style="color:green;text-decoration: none;">*</a>
</th>
<th>Via <a href="classeigen_1_1array" title="General-purpose arrays with easy API for coefficient-wise operations.">Array</a> conversions </th>
</tr> <tr> <td>
<pre data-language="cpp">mat1.cwiseMin(mat2)         mat1.cwiseMin(scalar)
mat1.cwiseMax(mat2)         mat1.cwiseMax(scalar)
mat1.cwiseAbs2()
mat1.cwiseAbs()
mat1.cwiseSqrt()
mat1.cwiseInverse()
mat1.cwiseProduct(mat2)
mat1.cwiseQuotient(mat2)
mat1.cwiseEqual(mat2)       mat1.cwiseEqual(scalar)
mat1.cwiseNotEqual(mat2)
</pre> </td>
<td>
<pre data-language="cpp">mat1.array().min(mat2.array())    mat1.array().min(scalar)
mat1.array().max(mat2.array())    mat1.array().max(scalar)
mat1.array().abs2()
mat1.array().abs()
mat1.array().sqrt()
mat1.array().inverse()
mat1.array() * mat2.array()
mat1.array() / mat2.array()
mat1.array() == mat2.array()      mat1.array() == scalar
mat1.array() != mat2.array()
</pre> </td>
</tr> </table> <p>The main difference between the two API is that the one based on cwise* methods returns an expression in the matrix world, while the second one (based on .array()) returns an array expression. Recall that .array() has no cost, it only changes the available API and interpretation of the data.</p> <p>It is also very simple to apply any user defined function <code>foo</code> using DenseBase::unaryExpr together with <a href="http://en.cppreference.com/w/cpp/utility/functional/ptr_fun">std::ptr_fun</a> (c++03, deprecated or removed in newer C++ versions), <a href="http://en.cppreference.com/w/cpp/utility/functional/ref">std::ref</a> (c++11), or <a href="http://en.cppreference.com/w/cpp/language/lambda">lambdas</a> (c++11): </p>
<pre data-language="cpp">mat1.unaryExpr(std::ptr_fun(foo));
mat1.unaryExpr(std::ref(foo));
mat1.unaryExpr([](<span>double</span> x) { <span>return</span> foo(x); });
</pre>
<p>Please note that it's not possible to pass a raw function pointer to <code>unaryExpr</code>, so please warp it as shown above.</p> <p> </p> <h1>
<a id="QuickRef_Reductions"></a> Reductions</h1> <p><a href="namespaceeigen" title="Namespace containing all symbols from the Eigen library.">Eigen</a> provides several reduction methods such as: <a href="classeigen_1_1densebase#a0739f9c868c331031c7810e21838dcb2">minCoeff() </a>, <a href="classeigen_1_1densebase#a7e6987d106f1cca3ac6ab36d288cc8e1">maxCoeff() </a>, <a href="classeigen_1_1densebase#addd7080d5c202795820e361768d0140c">sum() </a>, <a href="classeigen_1_1densebase#af119d9a4efe5a15cd83c1ccdf01b3a4f">prod() </a>, <a href="classeigen_1_1matrixbase#a544b609f65eb2bd3e368b3fc2d79479e">trace() </a> <a href="#matrixonly" style="color:green;text-decoration: none;">*</a>, <a href="classeigen_1_1matrixbase#a196c4ec3c8ffdf5bda45d0f617154975">norm() </a> <a href="#matrixonly" style="color:green;text-decoration: none;">*</a>, <a href="classeigen_1_1matrixbase#ac8da566526419f9742a6c471bbd87e0a">squaredNorm() </a> <a href="#matrixonly" style="color:green;text-decoration: none;">*</a>, <a href="classeigen_1_1densebase#ae42ab60296c120e9f45ce3b44e1761a4">all() </a>, and <a href="classeigen_1_1densebase#abfbf4cb72dd577e62fbe035b1c53e695">any() </a>. All reduction operations can be done matrix-wise, <a href="classeigen_1_1densebase#a1c0e1b6067ec1de6cb8799da55aa7d30">column-wise </a> or <a href="classeigen_1_1densebase#a6daa3a3156ca0e0722bf78638e1c7f28">row-wise </a>. Usage example: </p>
<table> <tr> <td rowspan="3" style="border-right-style:dashed;vertical-align:middle">
<pre data-language="cpp">      5 3 1
mat = 2 7 8
      9 4 6 
</pre> </td>
<td><pre data-language="cpp">mat.minCoeff(); 
</pre></td>
<td>
<pre data-language="cpp">1 
</pre> </td>
</tr> <tr> <td><pre data-language="cpp">mat.colwise().minCoeff(); 
</pre></td>
<td>
<pre data-language="cpp">2 3 1 
</pre> </td>
</tr> <tr style="vertical-align:middle"> <td><pre data-language="cpp">mat.rowwise().minCoeff(); 
</pre></td>
<td>
<pre data-language="cpp">1
2
4
</pre> </td>
</tr> </table> <p>Special versions of <a href="classeigen_1_1densebase#aa28152ba4a42b2d112e5fec5469ec4c1">minCoeff </a> and <a href="classeigen_1_1densebase#a3780b7a9cd184d0b4f3ea797eba9e2b3">maxCoeff </a>: </p>
<pre data-language="cpp"><span>int</span> i, j;
s = vector.minCoeff(&amp;i);        <span>// s == vector[i]</span>
s = matrix.maxCoeff(&amp;i, &amp;j);    <span>// s == matrix(i,j)</span>
</pre>
<p> Typical use cases of <a href="group__core__module#ga790ab6c4226ef5f678b9eb532a3eab14">all()</a> and any(): </p>
<pre data-language="cpp"><span>if</span>((array1 &gt; 0).<a href="group__core__module#ga790ab6c4226ef5f678b9eb532a3eab14">all</a>()) ...      <span>// if all coefficients of array1 are greater than 0 ...</span>
<span>if</span>((array1 &lt; array2).any()) ... <span>// if there exist a pair i,j such that array1(i,j) &lt; array2(i,j) ...</span></pre>
<p></p> <h1>
<a id="QuickRef_Blocks"></a> Sub-matrices</h1> <div> <b>PLEASE HELP US IMPROVING THIS SECTION.</b> Eigen 3.4 supports a much improved API for sub-matrices, including, slicing and indexing from arrays: <a href="group__tutorialslicingindexing">Slicing and Indexing</a> </div>
<p>Read-write access to a <a href="group__quickrefpage">column </a> or a <a href="group__quickrefpage">row </a> of a matrix (or array): </p>
<pre data-language="cpp">mat1.row(i) = mat2.col(j);
mat1.col(j1).swap(mat1.col(j2));
</pre>
<p>Read-write access to sub-vectors: </p>
<table> <tr> <th>Default versions </th>
<th>Optimized versions when the size <br> is known at compile time </th>
<th>
<p></p> <p></p> </th>
</tr> <tr> <td><pre data-language="cpp">vec1.head(n)
</pre></td>
<td><pre data-language="cpp">vec1.head&lt;n&gt;()
</pre></td>
<td>the first <code>n</code> coeffs </td>
</tr> <tr> <td><pre data-language="cpp">vec1.tail(n)
</pre></td>
<td><pre data-language="cpp">vec1.tail&lt;n&gt;()
</pre></td>
<td>the last <code>n</code> coeffs </td>
</tr> <tr> <td><pre data-language="cpp">vec1.segment(pos,n)
</pre></td>
<td>
<pre data-language="cpp">vec1.segment&lt;n&gt;(pos)
</pre> </td>
<td>the <code>n</code> coeffs in the <br> range [<code>pos</code> : <code>pos</code> + <code>n</code> - 1] </td>
</tr> <tr> <td colspan="3">
<p></p> <p>Read-write access to sub-matrices: </p> </td>
</tr> <tr> <td>
<pre data-language="cpp">mat1.block(i,j,rows,cols)
</pre> <a href="group__quickrefpage">(more) </a> </td>
<td>
<pre data-language="cpp">mat1.block&lt;rows,cols&gt;(i,j)
</pre> <a href="group__quickrefpage">(more) </a> </td>
<td>the <code>rows</code> x <code>cols</code> sub-matrix <br> starting from position (<code>i</code>,<code>j</code>) </td>
</tr> <tr> <td>
<pre data-language="cpp">mat1.topLeftCorner(rows,cols)
mat1.topRightCorner(rows,cols)
mat1.bottomLeftCorner(rows,cols)
mat1.bottomRightCorner(rows,cols)
</pre> </td>
<td>
<pre data-language="cpp">mat1.topLeftCorner&lt;rows,cols&gt;()
mat1.topRightCorner&lt;rows,cols&gt;()
mat1.bottomLeftCorner&lt;rows,cols&gt;()
mat1.bottomRightCorner&lt;rows,cols&gt;()
</pre> </td>
<td>the <code>rows</code> x <code>cols</code> sub-matrix <br> taken in one of the four corners </td>
</tr> <tr> <td>
<pre data-language="cpp">mat1.topRows(rows)
mat1.bottomRows(rows)
mat1.leftCols(cols)
mat1.rightCols(cols)
</pre> </td>
<td>
<pre data-language="cpp">mat1.topRows&lt;rows&gt;()
mat1.bottomRows&lt;rows&gt;()
mat1.leftCols&lt;cols&gt;()
mat1.rightCols&lt;cols&gt;()
</pre> </td>
<td>specialized versions of block() <br> when the block fit two corners </td>
</tr> </table> <p></p> <h1>
<a id="QuickRef_Misc"></a> Miscellaneous operations</h1> <div> <b>PLEASE HELP US IMPROVING THIS SECTION.</b> Eigen 3.4 supports a new API for reshaping: <a href="group__tutorialreshape">Reshape</a> </div>
<h2>
<a id="QuickRef_Reverse"></a> Reverse</h2> <p>Vectors, rows, and/or columns of a matrix can be reversed (see <a href="classeigen_1_1densebase#a38ea394036d8b096abf322469c80198f">DenseBase::reverse()</a>, <a href="classeigen_1_1densebase#adb8045155ea45f7961fc2a5170e1d921">DenseBase::reverseInPlace()</a>, <a href="classeigen_1_1vectorwiseop#ab8caf5367e2bd636536c8a0e0c89fe15">VectorwiseOp::reverse()</a>). </p>
<pre data-language="cpp">vec.reverse()           mat.colwise().reverse()   mat.rowwise().reverse()
vec.reverseInPlace()
</pre>
<h2>
<a id="QuickRef_Replicate"></a> Replicate</h2> <p>Vectors, matrices, rows, and/or columns can be replicated in any direction (see <a href="classeigen_1_1densebase#a60dadfe80b813d808e91e4521c722a8e">DenseBase::replicate()</a>, <a href="classeigen_1_1vectorwiseop#a5f0c8dc9e9c4aeaa2057f15800f5c18c">VectorwiseOp::replicate()</a>) </p>
<pre data-language="cpp">vec.replicate(times)                                          vec.replicate&lt;Times&gt;
mat.replicate(vertical_times, horizontal_times)               mat.replicate&lt;VerticalTimes, HorizontalTimes&gt;()
mat.colwise().replicate(vertical_times, horizontal_times)     mat.colwise().replicate&lt;VerticalTimes, HorizontalTimes&gt;()
mat.rowwise().replicate(vertical_times, horizontal_times)     mat.rowwise().replicate&lt;VerticalTimes, HorizontalTimes&gt;()
</pre>
<p></p> <h1>
<a id="QuickRef_DiagTriSymm"></a> Diagonal, Triangular, and Self-adjoint matrices</h1> <p>(matrix world <a href="#matrixonly" style="color:green;text-decoration: none;">*</a>)</p> <h2>
<a id="QuickRef_Diagonal"></a> Diagonal matrices</h2> <table> <tr> <th>Operation</th>
<th>Code </th>
</tr> <tr> <td>view a vector <a href="classeigen_1_1matrixbase#a14235b62c90f93fe910070b4743782d0">as a diagonal matrix </a> <br> </td>
<td>
<pre data-language="cpp">mat1 = vec1.asDiagonal();
</pre> </td>
</tr> <tr> <td>Declare a diagonal matrix</td>
<td>
<pre data-language="cpp">DiagonalMatrix&lt;Scalar,SizeAtCompileTime&gt; diag1(size);
diag1.diagonal() = vector;
</pre> </td>
</tr> <tr> <td>Access the <a href="classeigen_1_1matrixbase#ab5768147536273eb2dbdfa389cfd26a3">diagonal </a> and <a href="classeigen_1_1matrixbase#a8a13d4b8efbd7797ee8efd3dd988a7f7">super/sub diagonals </a> of a matrix as a vector (read/write) </td>
<td>
<pre data-language="cpp">vec1 = mat1.diagonal();        mat1.diagonal() = vec1;      <span>// main diagonal</span>
vec1 = mat1.diagonal(+n);      mat1.diagonal(+n) = vec1;    <span>// n-th super diagonal</span>
vec1 = mat1.diagonal(-n);      mat1.diagonal(-n) = vec1;    <span>// n-th sub diagonal</span>
vec1 = mat1.diagonal&lt;1&gt;();     mat1.diagonal&lt;1&gt;() = vec1;   <span>// first super diagonal</span>
vec1 = mat1.diagonal&lt;-2&gt;();    mat1.diagonal&lt;-2&gt;() = vec1;  <span>// second sub diagonal</span>
</pre> <p></p> </td>
</tr> <tr> <td>Optimized products and inverse </td>
<td>
<pre data-language="cpp">mat3  = scalar * diag1 * mat1;
mat3 += scalar * mat1 * vec1.asDiagonal();
mat3 = vec1.asDiagonal().inverse() * mat1
mat3 = mat1 * diag1.inverse()
</pre> <p></p> </td>
</tr> </table> <h2>
<a id="QuickRef_TriangularView"></a> Triangular views</h2> <p><a href="classeigen_1_1triangularview" title="Expression of a triangular part in a matrix.">TriangularView</a> gives a view on a triangular part of a dense matrix and allows to perform optimized operations on it. The opposite triangular part is never referenced and can be used to store other information.</p> <dl>
<dt>Note</dt>
<dd>The .triangularView() template member function requires the <code>template</code> keyword if it is used on an object of a type that depends on a template parameter; see <a href="topictemplatekeyword">The template and typename keywords in C++</a> for details.</dd>
</dl> <table> <tr> <th>Operation</th>
<th>Code </th>
</tr> <tr> <td>Reference to a triangular with optional <br> unit or null diagonal (read/write): </td>
<td>
<pre data-language="cpp">m.triangularView&lt;Xxx&gt;()
</pre> <br> <code>Xxx</code> = <a href="group__enums#gga39e3366ff5554d731e7dc8bb642f83cdafca2ccebb604f171656deb53e8c083c1">Upper</a>, <a href="group__enums#gga39e3366ff5554d731e7dc8bb642f83cdaf581029282d421eee5aae14238c6f749">Lower</a>, <a href="group__enums#gga39e3366ff5554d731e7dc8bb642f83cda7b37877e0b9b0df28c9c2b669a633265">StrictlyUpper</a>, <a href="group__enums#gga39e3366ff5554d731e7dc8bb642f83cda2424988b6fca98be70b595632753ba81">StrictlyLower</a>, <a href="group__enums#gga39e3366ff5554d731e7dc8bb642f83cdadd28224d7ea92689930be73c1b50b0ad">UnitUpper</a>, <a href="group__enums#gga39e3366ff5554d731e7dc8bb642f83cda8f40b928c10a71ba03e5f75ad2a72fda">UnitLower</a> </td>
</tr> <tr> <td>Writing to a specific triangular part:<br> (only the referenced triangular part is evaluated) </td>
<td>
<pre data-language="cpp">m1.triangularView&lt;<a href="group__enums#gga39e3366ff5554d731e7dc8bb642f83cdaf581029282d421eee5aae14238c6f749">Eigen::Lower</a>&gt;() = m2 + m3 </pre> </td>
</tr> <tr> <td>Conversion to a dense matrix setting the opposite triangular part to zero: </td>
<td>
<pre data-language="cpp">m2 = m1.triangularView&lt;<a href="group__enums#gga39e3366ff5554d731e7dc8bb642f83cdadd28224d7ea92689930be73c1b50b0ad">Eigen::UnitUpper</a>&gt;()</pre> </td>
</tr> <tr> <td>Products: </td>
<td>
<pre data-language="cpp">m3 += s1 * m1.adjoint().triangularView&lt;<a href="group__enums#gga39e3366ff5554d731e7dc8bb642f83cdadd28224d7ea92689930be73c1b50b0ad">Eigen::UnitUpper</a>&gt;() * m2
m3 -= s1 * m2.conjugate() * m1.adjoint().triangularView&lt;<a href="group__enums#gga39e3366ff5554d731e7dc8bb642f83cdaf581029282d421eee5aae14238c6f749">Eigen::Lower</a>&gt;() 
</pre> </td>
</tr> <tr> <td>Solving linear equations:<br> \( M_2 := L_1^{-1} M_2 \) <br> \( M_3 := {L_1^*}^{-1} M_3 \) <br> \( M_4 := M_4 U_1^{-1} \) </td>
<td>
<br> <pre data-language="cpp">L1.triangularView&lt;<a href="group__enums#gga39e3366ff5554d731e7dc8bb642f83cda8f40b928c10a71ba03e5f75ad2a72fda">Eigen::UnitLower</a>&gt;().solveInPlace(M2)
L1.triangularView&lt;<a href="group__enums#gga39e3366ff5554d731e7dc8bb642f83cdaf581029282d421eee5aae14238c6f749">Eigen::Lower</a>&gt;().adjoint().solveInPlace(M3)
U1.triangularView&lt;<a href="group__enums#gga39e3366ff5554d731e7dc8bb642f83cdafca2ccebb604f171656deb53e8c083c1">Eigen::Upper</a>&gt;().solveInPlace&lt;OnTheRight&gt;(M4)</pre> </td>
</tr> </table> <h2>
<a id="QuickRef_SelfadjointMatrix"></a> Symmetric/selfadjoint views</h2> <p>Just as for triangular matrix, you can reference any triangular part of a square matrix to see it as a selfadjoint matrix and perform special and optimized operations. Again the opposite triangular part is never referenced and can be used to store other information.</p> <dl>
<dt>Note</dt>
<dd>The .selfadjointView() template member function requires the <code>template</code> keyword if it is used on an object of a type that depends on a template parameter; see <a href="topictemplatekeyword">The template and typename keywords in C++</a> for details.</dd>
</dl> <table> <tr> <th>Operation</th>
<th>Code </th>
</tr> <tr> <td>Conversion to a dense matrix: </td>
<td>
<pre data-language="cpp">m2 = m.selfadjointView&lt;<a href="group__enums#gga39e3366ff5554d731e7dc8bb642f83cdaf581029282d421eee5aae14238c6f749">Eigen::Lower</a>&gt;();
</pre> </td>
</tr> <tr> <td>
<a href="classeigen_1_1product" title="Expression of the product of two arbitrary matrices or vectors.">Product</a> with another general matrix or vector: </td>
<td>
<pre data-language="cpp">m3  = s1 * m1.conjugate().selfadjointView&lt;<a href="group__enums#gga39e3366ff5554d731e7dc8bb642f83cdafca2ccebb604f171656deb53e8c083c1">Eigen::Upper</a>&gt;() * m3;
m3 -= s1 * m3.adjoint() * m1.selfadjointView&lt;<a href="group__enums#gga39e3366ff5554d731e7dc8bb642f83cdaf581029282d421eee5aae14238c6f749">Eigen::Lower</a>&gt;();
</pre> </td>
</tr> <tr> <td>Rank 1 and rank K update: <br> \( upper(M_1) \mathrel{{+}{=}} s_1 M_2 M_2^* \) <br> \( lower(M_1) \mathbin{{-}{=}} M_2^* M_2 \) </td>
<td>
<br> <pre data-language="cpp">M1.selfadjointView&lt;<a href="group__enums#gga39e3366ff5554d731e7dc8bb642f83cdafca2ccebb604f171656deb53e8c083c1">Eigen::Upper</a>&gt;().rankUpdate(M2,s1);
M1.selfadjointView&lt;<a href="group__enums#gga39e3366ff5554d731e7dc8bb642f83cdaf581029282d421eee5aae14238c6f749">Eigen::Lower</a>&gt;().rankUpdate(M2.adjoint(),-1); 
</pre> </td>
</tr> <tr> <td>Rank 2 update: ( \( M \mathrel{{+}{=}} s u v^* + s v u^* \)) </td>
<td>
<pre data-language="cpp">M.selfadjointView&lt;<a href="group__enums#gga39e3366ff5554d731e7dc8bb642f83cdafca2ccebb604f171656deb53e8c083c1">Eigen::Upper</a>&gt;().rankUpdate(u,v,s);
</pre> </td>
</tr> <tr> <td>Solving linear equations:<br> ( \( M_2 := M_1^{-1} M_2 \)) </td>
<td>
<pre data-language="cpp"><span>// via a standard Cholesky factorization</span>
m2 = m1.selfadjointView&lt;<a href="group__enums#gga39e3366ff5554d731e7dc8bb642f83cdafca2ccebb604f171656deb53e8c083c1">Eigen::Upper</a>&gt;().llt().solve(m2);
<span>// via a Cholesky factorization with pivoting</span>
m2 = m1.selfadjointView&lt;<a href="group__enums#gga39e3366ff5554d731e7dc8bb642f83cdaf581029282d421eee5aae14238c6f749">Eigen::Lower</a>&gt;().ldlt().solve(m2);
</pre> </td>
</tr> </table> </div> <div class="_attribution">
  <p class="_attribution-p">
    Â© Eigen.<br>Licensed under the MPL2 License.<br>
    <a href="https://eigen.tuxfamily.org/dox/group__QuickRefPage.html" class="_attribution-link">https://eigen.tuxfamily.org/dox/group__QuickRefPage.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
