
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Testing Utility APIs - Angular - W3cubDocs</title>
  
  <meta name="description" content=" This page describes the most useful Angular testing features. ">
  <meta name="keywords" content="testing, utility, apis, angular">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/angular/guide/testing-utility-apis.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-9c7b0d969c0ce639a6c01c2badcdd81667c7c66206aa3d0fccc5cb0585fb1b912dab72ea882101d18010680927514b4b77b107282db8f756fbf63301fe9c88b0.css">
  <script type="text/javascript" src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js"></script>
  <script src="/json/angular.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/angular/" class="_nav-link" title="" style="margin-left:0;">Angular</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _angular">
				
				
<h1 id="testing-utility-apis">Testing Utility APIs</h1> <p>This page describes the most useful Angular testing features.</p> <p>The Angular testing utilities include the <code><a href="../api/core/testing/testbed" class="code-anchor">TestBed</a></code>, the <code><a href="../api/core/testing/componentfixture" class="code-anchor">ComponentFixture</a></code>, and a handful of functions that control the test environment. The <a href="testing-utility-apis#testbed-api-summary"><code>TestBed</code></a> and <a href="testing-utility-apis#component-fixture-api-summary"><code>ComponentFixture</code></a> classes are covered separately.</p> <p>Here's a summary of the stand-alone functions, in order of likely utility:</p> <table> <thead> <tr> <th align="left">Function</th> <th align="left">Details</th> </tr> </thead> <tbody> <tr> <td align="left"><code><a href="../api/core/testing/waitforasync" class="code-anchor">waitForAsync</a></code></td> <td align="left">Runs the body of a test (<code>it</code>) or setup (<code>beforeEach</code>) function within a special <em>async test zone</em>. See <a href="testing-components-scenarios#waitForAsync">waitForAsync</a>.</td> </tr> <tr> <td align="left"><code><a href="../api/core/testing/fakeasync" class="code-anchor">fakeAsync</a></code></td> <td align="left">Runs the body of a test (<code>it</code>) within a special <em>fakeAsync test zone</em>, enabling a linear control flow coding style. See <a href="testing-components-scenarios#fake-async">fakeAsync</a>.</td> </tr> <tr> <td align="left"><code><a href="../api/core/testing/tick" class="code-anchor">tick</a></code></td> <td align="left">Simulates the passage of time and the completion of pending asynchronous activities by flushing both <em>timer</em> and <em>micro-task</em> queues within the <em>fakeAsync test zone</em>. <blockquote class="alert is-helpful"> The curious, dedicated reader might enjoy this lengthy blog post, <a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules">"<em>Tasks, microtasks, queues and schedules</em>"</a>. </blockquote> Accepts an optional argument that moves the virtual clock forward by the specified number of milliseconds, clearing asynchronous activities scheduled within that timeframe. See <a href="testing-components-scenarios#tick">tick</a>.</td> </tr> <tr> <td align="left"><code>inject</code></td> <td align="left">Injects one or more services from the current <code><a href="../api/core/testing/testbed" class="code-anchor">TestBed</a></code> injector into a test function. It cannot inject a service provided by the component itself. See discussion of the <a href="testing-components-scenarios#get-injected-services">debugElement.injector</a>.</td> </tr> <tr> <td align="left"><code><a href="../api/core/testing/discardperiodictasks" class="code-anchor">discardPeriodicTasks</a></code></td> <td align="left">When a <code><a href="../api/core/testing/fakeasync" class="code-anchor">fakeAsync</a>()</code> test ends with pending timer event <em>tasks</em> (queued <code>setTimeOut</code> and <code>setInterval</code> callbacks), the test fails with a clear error message.  In general, a test should end with no queued tasks. When pending timer tasks are expected, call <code><a href="../api/core/testing/discardperiodictasks" class="code-anchor">discardPeriodicTasks</a></code> to flush the <em>task</em> queue and avoid the error.</td> </tr> <tr> <td align="left"><code><a href="../api/core/testing/flushmicrotasks" class="code-anchor">flushMicrotasks</a></code></td> <td align="left">When a <code><a href="../api/core/testing/fakeasync" class="code-anchor">fakeAsync</a>()</code> test ends with pending <em>micro-tasks</em> such as unresolved promises, the test fails with a clear error message.  In general, a test should wait for micro-tasks to finish. When pending microtasks are expected, call <code><a href="../api/core/testing/flushmicrotasks" class="code-anchor">flushMicrotasks</a></code> to flush the <em>micro-task</em> queue and avoid the error.</td> </tr> <tr> <td align="left"><code><a href="../api/core/testing/componentfixtureautodetect" class="code-anchor">ComponentFixtureAutoDetect</a></code></td> <td align="left">A provider token for a service that turns on <a href="testing-components-scenarios#automatic-change-detection">automatic change detection</a>.</td> </tr> <tr> <td align="left"><code><a href="../api/core/testing/gettestbed" class="code-anchor">getTestBed</a></code></td> <td align="left">Gets the current instance of the <code><a href="../api/core/testing/testbed" class="code-anchor">TestBed</a></code>. Usually unnecessary because the static class methods of the <code><a href="../api/core/testing/testbed" class="code-anchor">TestBed</a></code> class are typically sufficient. The <code><a href="../api/core/testing/testbed" class="code-anchor">TestBed</a></code> instance exposes a few rarely used members that are not available as static methods.</td> </tr> </tbody> </table>  <h2 id="testbed-class-summary">
<code><a href="../api/core/testing/testbed" class="code-anchor">TestBed</a></code> class summary</h2> <p>The <code><a href="../api/core/testing/testbed" class="code-anchor">TestBed</a></code> class is one of the principal Angular testing utilities. Its API is quite large and can be overwhelming until you've explored it, a little at a time. Read the early part of this guide first to get the basics before trying to absorb the full API.</p> <p>The module definition passed to <code>configureTestingModule</code> is a subset of the <code>@<a href="../api/core/ngmodule" class="code-anchor">NgModule</a></code> metadata properties.</p> <pre format="javascript" data-language="javascript">type TestModuleMetadata = {
  providers?: any[];
  declarations?: any[];
  imports?: any[];
  schemas?: Array&lt;SchemaMetadata | any[]&gt;;
};</pre>  <p>Each override method takes a <code><a href="../api/core/testing/metadataoverride" class="code-anchor">MetadataOverride</a>&lt;T&gt;</code> where <code>T</code> is the kind of metadata appropriate to the method, that is, the parameter of an <code>@<a href="../api/core/ngmodule" class="code-anchor">NgModule</a></code>, <code>@<a href="../api/core/component" class="code-anchor">Component</a></code>, <code>@<a href="../api/core/directive" class="code-anchor">Directive</a></code>, or <code>@<a href="../api/core/pipe" class="code-anchor">Pipe</a></code>.</p> <pre format="javascript" data-language="javascript">type MetadataOverride&lt;T&gt; = {
  add?: Partial&lt;T&gt;;
  remove?: Partial&lt;T&gt;;
  set?: Partial&lt;T&gt;;
};</pre>  <p>The <code><a href="../api/core/testing/testbed" class="code-anchor">TestBed</a></code> API consists of static class methods that either update or reference a <em>global</em> instance of the <code><a href="../api/core/testing/testbed" class="code-anchor">TestBed</a></code>.</p> <p>Internally, all static methods cover methods of the current runtime <code><a href="../api/core/testing/testbed" class="code-anchor">TestBed</a></code> instance, which is also returned by the <code><a href="../api/core/testing/gettestbed" class="code-anchor">getTestBed</a>()</code> function.</p> <p>Call <code><a href="../api/core/testing/testbed" class="code-anchor">TestBed</a></code> methods <em>within</em> a <code>beforeEach()</code> to ensure a fresh start before each individual test.</p> <p>Here are the most important static methods, in order of likely utility.</p> <table> <thead> <tr> <th align="left">Methods</th> <th align="left">Details</th> </tr> </thead> <tbody> <tr> <td align="left"><code>configureTestingModule</code></td> <td align="left">The testing shims (<code>karma-test-shim</code>, <code>browser-test-shim</code>) establish the <a href="testing">initial test environment</a> and a default testing module. The default testing module is configured with basic declaratives and some Angular service substitutes that every tester needs.  Call <code>configureTestingModule</code> to refine the testing module configuration for a particular set of tests by adding and removing imports, declarations (of components, directives, and pipes), and providers.</td> </tr> <tr> <td align="left"><code>compileComponents</code></td> <td align="left">Compile the testing module asynchronously after you've finished configuring it. You <strong>must</strong> call this method if <em>any</em> of the testing module components have a <code>templateUrl</code> or <code>styleUrls</code> because fetching component template and style files is necessarily asynchronous. See <a href="testing-components-scenarios#compile-components">compileComponents</a>.  After calling <code>compileComponents</code>, the <code><a href="../api/core/testing/testbed" class="code-anchor">TestBed</a></code> configuration is frozen for the duration of the current spec.</td> </tr> <tr> <td align="left"><code><a href="../api/core/createcomponent" class="code-anchor">createComponent</a>&lt;T&gt;</code></td> <td align="left">Create an instance of a component of type <code>T</code> based on the current <code><a href="../api/core/testing/testbed" class="code-anchor">TestBed</a></code> configuration. After calling <code><a href="../api/core/createcomponent" class="code-anchor">createComponent</a></code>, the <code><a href="../api/core/testing/testbed" class="code-anchor">TestBed</a></code> configuration is frozen for the duration of the current spec.</td> </tr> <tr> <td align="left"><code>overrideModule</code></td> <td align="left">Replace metadata for the given <code><a href="../api/core/ngmodule" class="code-anchor">NgModule</a></code>. Recall that modules can import other modules. The <code>overrideModule</code> method can reach deeply into the current testing module to modify one of these inner modules.</td> </tr> <tr> <td align="left"><code>overrideComponent</code></td> <td align="left">Replace metadata for the given component class, which could be nested deeply within an inner module.</td> </tr> <tr> <td align="left"><code>overrideDirective</code></td> <td align="left">Replace metadata for the given directive class, which could be nested deeply within an inner module.</td> </tr> <tr> <td align="left"><code>overridePipe</code></td> <td align="left">Replace metadata for the given pipe class, which could be nested deeply within an inner module.</td> </tr> </tbody> </table> <p>|  <code>inject</code> | Retrieve a service from the current <code><a href="../api/core/testing/testbed" class="code-anchor">TestBed</a></code> injector. The <code>inject</code> function is often adequate for this purpose. But <code>inject</code> throws an error if it can't provide the service.  What if the service is optional?  The <code>TestBed.inject()</code> method takes an optional second parameter, the object to return if Angular can't find the provider (<code>null</code> in this example): </p>
<pre header="app/demo/demo.testbed.spec.ts" data-language="typescript">expect(TestBed.inject(NotProvided, null)).toBeNull();</pre> After calling <code>TestBed.inject</code>, the <code><a href="../api/core/testing/testbed" class="code-anchor">TestBed</a></code> configuration is frozen for the duration of the current spec. | |  <code>initTestEnvironment</code> | Initialize the testing environment for the entire test run.  The testing shims (<code>karma-test-shim</code>, <code>browser-test-shim</code>) call it for you so there is rarely a reason for you to call it yourself.  Call this method <em>exactly once</em>. To change this default in the middle of a test run, call <code>resetTestEnvironment</code> first.  Specify the Angular compiler factory, a <code><a href="../api/core/platformref" class="code-anchor">PlatformRef</a></code>, and a default Angular testing module. Alternatives for non-browser platforms are available in the general form <code>@angular/platform-&lt;platform_name&gt;/testing/&lt;platform_name&gt;</code>. | | <code>resetTestEnvironment</code> | Reset the initial test environment, including the default testing module. | <p>A few of the <code><a href="../api/core/testing/testbed" class="code-anchor">TestBed</a></code> instance methods are not covered by static <code><a href="../api/core/testing/testbed" class="code-anchor">TestBed</a></code> <em>class</em> methods. These are rarely needed.</p>  <h2 id="the-componentfixture">The <code><a href="../api/core/testing/componentfixture" class="code-anchor">ComponentFixture</a></code>
</h2> <p>The <code>TestBed.createComponent&lt;T&gt;</code> creates an instance of the component <code>T</code> and returns a strongly typed <code><a href="../api/core/testing/componentfixture" class="code-anchor">ComponentFixture</a></code> for that component.</p> <p>The <code><a href="../api/core/testing/componentfixture" class="code-anchor">ComponentFixture</a></code> properties and methods provide access to the component, its DOM representation, and aspects of its Angular environment.</p>  <h3 id="componentfixture-properties">
<code><a href="../api/core/testing/componentfixture" class="code-anchor">ComponentFixture</a></code> properties</h3> <p>Here are the most important properties for testers, in order of likely utility.</p> <table> <thead> <tr> <th align="left">Properties</th> <th align="left">Details</th> </tr> </thead> <tbody> <tr> <td align="left"><code>componentInstance</code></td> <td align="left">The instance of the component class created by <code>TestBed.createComponent</code>.</td> </tr> <tr> <td align="left"><code>debugElement</code></td> <td align="left">The <code><a href="../api/core/debugelement" class="code-anchor">DebugElement</a></code> associated with the root element of the component.  The <code>debugElement</code> provides insight into the component and its DOM element during test and debugging. It's a critical property for testers. The most interesting members are covered <a href="testing-utility-apis#debug-element-details">below</a>.</td> </tr> <tr> <td align="left"><code>nativeElement</code></td> <td align="left">The native DOM element at the root of the component.</td> </tr> <tr> <td align="left"><code>changeDetectorRef</code></td> <td align="left">The <code><a href="../api/core/changedetectorref" class="code-anchor">ChangeDetectorRef</a></code> for the component.  The <code><a href="../api/core/changedetectorref" class="code-anchor">ChangeDetectorRef</a></code> is most valuable when testing a component that has the <code><a href="../api/core/changedetectionstrategy#OnPush" class="code-anchor">ChangeDetectionStrategy.OnPush</a></code> method or the component's change detection is under your programmatic control.</td> </tr> </tbody> </table>  <h3 id="componentfixture-methods">
<code><a href="../api/core/testing/componentfixture" class="code-anchor">ComponentFixture</a></code> methods</h3> <p>The <em>fixture</em> methods cause Angular to perform certain tasks on the component tree. Call these method to trigger Angular behavior in response to simulated user action.</p> <p>Here are the most useful methods for testers.</p> <table> <thead> <tr> <th align="left">Methods</th> <th align="left">Details</th> </tr> </thead> <tbody> <tr> <td align="left"><code>detectChanges</code></td> <td align="left">Trigger a change detection cycle for the component.  Call it to initialize the component (it calls <code>ngOnInit</code>) and after your test code, change the component's data bound property values. Angular can't see that you've changed <code>personComponent.name</code> and won't update the <code>name</code> binding until you call <code>detectChanges</code>.  Runs <code>checkNoChanges</code> afterwards to confirm that there are no circular updates unless called as <code>detectChanges(false)</code>;</td> </tr> <tr> <td align="left"><code>autoDetectChanges</code></td> <td align="left">Set this to <code>true</code> when you want the fixture to detect changes automatically.  When autodetect is <code>true</code>, the test fixture calls <code>detectChanges</code> immediately after creating the component. Then it listens for pertinent zone events and calls <code>detectChanges</code> accordingly. When your test code modifies component property values directly, you probably still have to call <code>fixture.detectChanges</code> to trigger data binding updates.  The default is <code>false</code>. Testers who prefer fine control over test behavior tend to keep it <code>false</code>.</td> </tr> <tr> <td align="left"><code>checkNoChanges</code></td> <td align="left">Do a change detection run to make sure there are no pending changes. Throws an exceptions if there are.</td> </tr> <tr> <td align="left"><code>isStable</code></td> <td align="left">If the fixture is currently <em>stable</em>, returns <code>true</code>. If there are async tasks that have not completed, returns <code>false</code>.</td> </tr> <tr> <td align="left"><code>whenStable</code></td> <td align="left">Returns a promise that resolves when the fixture is stable.  To resume testing after completion of asynchronous activity or asynchronous change detection, hook that promise. See <a href="testing-components-scenarios#when-stable">whenStable</a>.</td> </tr> <tr> <td align="left"><code>destroy</code></td> <td align="left">Trigger component destruction.</td> </tr> </tbody> </table>  <h4 id="debugelement"><code><a href="../api/core/debugelement" class="code-anchor">DebugElement</a></code></h4> <p>The <code><a href="../api/core/debugelement" class="code-anchor">DebugElement</a></code> provides crucial insights into the component's DOM representation.</p> <p>From the test root component's <code><a href="../api/core/debugelement" class="code-anchor">DebugElement</a></code> returned by <code>fixture.debugElement</code>, you can walk (and query) the fixture's entire element and component subtrees.</p> <p>Here are the most useful <code><a href="../api/core/debugelement" class="code-anchor">DebugElement</a></code> members for testers, in approximate order of utility:</p> <table> <thead> <tr> <th align="left">Members</th> <th align="left">Details</th> </tr> </thead> <tbody> <tr> <td align="left"><code>nativeElement</code></td> <td align="left">The corresponding DOM element in the browser</td> </tr> <tr> <td align="left"><code><a href="../api/animations/query" class="code-anchor">query</a></code></td> <td align="left">Calling <code><a href="../api/animations/query" class="code-anchor">query</a>(predicate: <a href="../api/core/predicate" class="code-anchor">Predicate</a>&lt;<a href="../api/core/debugelement" class="code-anchor">DebugElement</a>&gt;)</code> returns the first <code><a href="../api/core/debugelement" class="code-anchor">DebugElement</a></code> that matches the <a href="testing-utility-apis#query-predicate">predicate</a> at any depth in the subtree.</td> </tr> <tr> <td align="left"><code>queryAll</code></td> <td align="left">Calling <code>queryAll(predicate: <a href="../api/core/predicate" class="code-anchor">Predicate</a>&lt;<a href="../api/core/debugelement" class="code-anchor">DebugElement</a>&gt;)</code> returns all <code>DebugElements</code> that matches the <a href="testing-utility-apis#query-predicate">predicate</a> at any depth in subtree.</td> </tr> <tr> <td align="left"><code>injector</code></td> <td align="left">The host dependency injector. For example, the root element's component instance injector.</td> </tr> <tr> <td align="left"><code>componentInstance</code></td> <td align="left">The element's own component instance, if it has one.</td> </tr> <tr> <td align="left"><code>context</code></td> <td align="left">An object that provides parent context for this element. Often an ancestor component instance that governs this element.  When an element is repeated within <code>*<a href="../api/common/ngfor" class="code-anchor">ngFor</a></code>, the context is an <code><a href="../api/common/ngforof" class="code-anchor">NgForOf</a></code> whose <code>$implicit</code> property is the value of the row instance value. For example, the <code>hero</code> in <code>*<a href="../api/common/ngfor" class="code-anchor">ngFor</a>="let hero of heroes"</code>.</td> </tr> <tr> <td align="left"><code>children</code></td> <td align="left">The immediate <code><a href="../api/core/debugelement" class="code-anchor">DebugElement</a></code> children. Walk the tree by descending through <code>children</code>. <blockquote class="alert is-helpful"> <code><a href="../api/core/debugelement" class="code-anchor">DebugElement</a></code> also has <code>childNodes</code>, a list of <code><a href="../api/core/debugnode" class="code-anchor">DebugNode</a></code> objects. <code><a href="../api/core/debugelement" class="code-anchor">DebugElement</a></code> derives from <code><a href="../api/core/debugnode" class="code-anchor">DebugNode</a></code> objects and there are often more nodes than elements. Testers can usually ignore plain nodes. </blockquote>
</td> </tr> <tr> <td align="left"><code>parent</code></td> <td align="left">The <code><a href="../api/core/debugelement" class="code-anchor">DebugElement</a></code> parent. Null if this is the root element.</td> </tr> <tr> <td align="left"><code>name</code></td> <td align="left">The element tag name, if it is an element.</td> </tr> <tr> <td align="left"><code>triggerEventHandler</code></td> <td align="left">Triggers the event by its name if there is a corresponding listener in the element's <code>listeners</code> collection. The second parameter is the <em>event object</em> expected by the handler. See <a href="testing-components-scenarios#trigger-event-handler">triggerEventHandler</a>.  If the event lacks a listener or there's some other problem, consider calling <code>nativeElement.dispatchEvent(eventObject)</code>.</td> </tr> <tr> <td align="left"><code>listeners</code></td> <td align="left">The callbacks attached to the component's <code>@<a href="../api/core/output" class="code-anchor">Output</a></code> properties and/or the element's event properties.</td> </tr> <tr> <td align="left"><code>providerTokens</code></td> <td align="left">This component's injector lookup tokens. Includes the component itself plus the tokens that the component lists in its <code>providers</code> metadata.</td> </tr> <tr> <td align="left"><code>source</code></td> <td align="left">Where to find this element in the source component template.</td> </tr> <tr> <td align="left"><code>references</code></td> <td align="left">Dictionary of objects associated with template local variables (for example, <code>#foo</code>), keyed by the local variable name.</td> </tr> </tbody> </table>  <p>The <code>DebugElement.query(predicate)</code> and <code>DebugElement.queryAll(predicate)</code> methods take a predicate that filters the source element's subtree for matching <code><a href="../api/core/debugelement" class="code-anchor">DebugElement</a></code>.</p> <p>The predicate is any method that takes a <code><a href="../api/core/debugelement" class="code-anchor">DebugElement</a></code> and returns a <em>truthy</em> value. The following example finds all <code>DebugElements</code> with a reference to a template local variable named "content":</p> <pre header="app/demo/demo.testbed.spec.ts" data-language="typescript">// Filter for DebugElements with a #content reference
const contentRefs = el.queryAll( de =&gt; de.references['content']);</pre> <p>The Angular <code><a href="../api/platform-browser/by" class="code-anchor">By</a></code> class has three static methods for common predicates:</p> <table> <thead> <tr> <th align="left">Static method</th> <th align="left">Details</th> </tr> </thead> <tbody> <tr> <td align="left"><code>By.all</code></td> <td align="left">Return all elements</td> </tr> <tr> <td align="left"><code>By.css(selector)</code></td> <td align="left">Return elements with matching CSS selectors</td> </tr> <tr> <td align="left"><code>By.directive(directive)</code></td> <td align="left">Return elements that Angular matched to an instance of the directive class</td> </tr> </tbody> </table> <pre header="app/hero/hero-list.component.spec.ts" data-language="typescript">// Can find DebugElement either by css selector or by directive
const h2 = fixture.debugElement.query(By.css('h2'));
const directive = fixture.debugElement.query(By.directive(HighlightDirective));</pre>    <div class="reviewed">Last reviewed on Mon Feb 28 2022</div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2010–2023 Google, Inc.<br>Licensed under the Creative Commons Attribution License 4.0.<br>
    <a href="https://angular.io/guide/testing-utility-apis" class="_attribution-link">https://angular.io/guide/testing-utility-apis</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
