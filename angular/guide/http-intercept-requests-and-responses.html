
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>HTTP - Intercept Requests and Responses - Angular - W3cubDocs</title>
  
  <meta name="description" content="With interception, you declare interceptors that inspect and transform HTTP requests from your application to a server. The same interceptors can &hellip;">
  <meta name="keywords" content="http, intercept, requests, and, responses, angular">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/angular/guide/http-intercept-requests-and-responses.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-9c7b0d969c0ce639a6c01c2badcdd81667c7c66206aa3d0fccc5cb0585fb1b912dab72ea882101d18010680927514b4b77b107282db8f756fbf63301fe9c88b0.css">
  <script type="text/javascript" src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js"></script>
  <script src="/json/angular.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/angular/" class="_nav-link" title="" style="margin-left:0;">Angular</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _angular">
				
				
<h1 id="http---intercept-requests-and-responses">HTTP - Intercept requests and responses</h1> <p>With interception, you declare <em>interceptors</em> that inspect and transform HTTP requests from your application to a server. The same interceptors can also inspect and transform a server's responses on their way back to the application. Multiple interceptors form a <em>forward-and-backward</em> chain of request/response handlers.</p> <p>Interceptors can perform a variety of <em>implicit</em> tasks, from authentication to logging, in a routine, standard way, for every HTTP request/response.</p> <p>Without interception, developers would have to implement these tasks <em>explicitly</em> for each <code><a href="../api/common/http/httpclient" class="code-anchor">HttpClient</a></code> method call.</p> <h2 id="write-an-interceptor">Write an interceptor</h2> <p>To implement an interceptor, declare a class that implements the <code>intercept()</code> method of the <code><a href="../api/common/http/httpinterceptor" class="code-anchor">HttpInterceptor</a></code> interface.</p> <p>Here is a do-nothing <code>noop</code> interceptor that passes the request through without touching it:</p> <pre header="app/http-interceptors/noop-interceptor.ts" data-language="typescript">import { Injectable } from '@angular/core';
import {
  HttpEvent, HttpInterceptor, HttpHandler, HttpRequest
} from '@angular/common/http';

import { Observable } from 'rxjs';

/** Pass untouched request through to the next request handler. */
@Injectable()
export class NoopInterceptor implements HttpInterceptor {

  intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler):
    Observable&lt;HttpEvent&lt;any&gt;&gt; {
    return next.handle(req);
  }
}</pre> <p>The <code>intercept</code> method transforms a request into an <code>Observable</code> that eventually returns the HTTP response. In this sense, each interceptor is fully capable of handling the request entirely by itself.</p> <p>Most interceptors inspect the request on the way in and forward the potentially altered request to the <code>handle()</code> method of the <code>next</code> object which implements the <a href="../api/common/http/httphandler"><code>HttpHandler</code></a> interface.</p> <pre format="javascript" data-language="javascript">export abstract class HttpHandler {
  abstract handle(req: HttpRequest&lt;any&gt;): Observable&lt;HttpEvent&lt;any&gt;&gt;;
}</pre> <p>Like <code>intercept()</code>, the <code>handle()</code> method transforms an HTTP request into an <code>Observable</code> of <a href="http-intercept-requests-and-responses#interceptor-events"><code>HttpEvents</code></a> which ultimately include the server's response. The <code>intercept()</code> method could inspect that observable and alter it before returning it to the caller.</p> <p>This <code>no-op</code> interceptor calls <code>next.handle()</code> with the original request and returns the observable without doing a thing.</p> <h2 id="the-next-object">The <code>next</code> object</h2> <p>The <code>next</code> object represents the next interceptor in the chain of interceptors. The final <code>next</code> in the chain is the <code><a href="../api/common/http/httpclient" class="code-anchor">HttpClient</a></code> backend handler that sends the request to the server and receives the server's response.</p> <p>Most interceptors call <code>next.handle()</code> so that the request flows through to the next interceptor and, eventually, the backend handler. An interceptor <em>could</em> skip calling <code>next.handle()</code>, short-circuit the chain, and <a href="http-interceptor-use-cases#caching">return its own <code>Observable</code></a> with an artificial server response.</p> <p>This is a common middleware pattern found in frameworks such as Express.js.</p> <h2 id="provide-the-interceptor">Provide the interceptor</h2> <p>The <code>NoopInterceptor</code> is a service managed by Angular's <a href="dependency-injection">dependency injection (DI)</a> system. Like other services, you must provide the interceptor class before the app can use it.</p> <p>Because interceptors are optional dependencies of the <code><a href="../api/common/http/httpclient" class="code-anchor">HttpClient</a></code> service, you must provide them in the same injector or a parent of the injector that provides <code><a href="../api/common/http/httpclient" class="code-anchor">HttpClient</a></code>. Interceptors provided <em>after</em> DI creates the <code><a href="../api/common/http/httpclient" class="code-anchor">HttpClient</a></code> are ignored.</p> <p>This app provides <code><a href="../api/common/http/httpclient" class="code-anchor">HttpClient</a></code> in the app's root injector, as a side-effect of importing the <code><a href="../api/common/http/httpclientmodule" class="code-anchor">HttpClientModule</a></code> in <code>AppModule</code>. You should provide interceptors in <code>AppModule</code> as well.</p> <p>After importing the <code><a href="../api/common/http/http_interceptors" class="code-anchor">HTTP_INTERCEPTORS</a></code> injection token from <code>@angular/common/<a href="../api/common/http" class="code-anchor">http</a></code>, write the <code>NoopInterceptor</code> provider like this:</p> <pre data-language="typescript">{ provide: HTTP_INTERCEPTORS, useClass: NoopInterceptor, multi: true },</pre> <p>Notice the <code>multi: true</code> option. This required setting tells Angular that <code><a href="../api/common/http/http_interceptors" class="code-anchor">HTTP_INTERCEPTORS</a></code> is a token for a <em>multiprovider</em> that injects an array of values, rather than a single value.</p> <p>You <em>could</em> add this provider directly to the providers array of the <code>AppModule</code>. However, it's rather verbose and there's a good chance that you'll create more interceptors and provide them in the same way. You must also pay <a href="http-intercept-requests-and-responses#interceptor-order">close attention to the order</a> in which you provide these interceptors.</p> <p>Consider creating a "barrel" file that gathers all the interceptor providers into an <code>httpInterceptorProviders</code> array, starting with this first one, the <code>NoopInterceptor</code>.</p> <pre header="app/http-interceptors/index.ts" data-language="typescript">/* "Barrel" of Http Interceptors */
import { HTTP_INTERCEPTORS } from '@angular/common/http';

import { NoopInterceptor } from './noop-interceptor';

/** Http interceptor providers in outside-in order */
export const httpInterceptorProviders = [
  { provide: HTTP_INTERCEPTORS, useClass: NoopInterceptor, multi: true },
];</pre> <p>Then import and add it to the <code>AppModule</code> <code>providers array</code> like this:</p> <pre header="app/app.module.ts (interceptor providers)" data-language="typescript">providers: [
  httpInterceptorProviders
],</pre> <p>As you create new interceptors, add them to the <code>httpInterceptorProviders</code> array and you won't have to revisit the <code>AppModule</code>.</p> <blockquote class="alert is-helpful"> <p>There are many more interceptors in the complete sample code.</p> </blockquote> <h2 id="interceptor-order">Interceptor order</h2> <p>Angular applies interceptors in the order that you provide them. For example, consider a situation in which you want to handle the authentication of your HTTP requests and log them before sending them to a server. To accomplish this task, you could provide an <code>AuthInterceptor</code> service and then a <code>LoggingInterceptor</code> service. Outgoing requests would flow from the <code>AuthInterceptor</code> to the <code>LoggingInterceptor</code>. Responses from these requests would flow in the other direction, from <code>LoggingInterceptor</code> back to <code>AuthInterceptor</code>. The following is a visual representation of the process:</p> <div class="lightbox"> <img alt="Interceptor in order of HttpClient, AuthInterceptor, AuthInterceptor, HttpBackend, Server, and back in opposite order to show the two-way flow" src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDU0IDk0IiB3aWR0aD0iMzAwIj4KICA8c3R5bGU+CiAgICAjaW50ZXJjZXB0b3ItZXhlYy1vcmRlciB7CiAgICAgIGZpbGw6IG5vbmU7CiAgICAgIHN0cm9rZTogYmxhY2s7CiAgICAgIHN0cm9rZS13aWR0aDogLjM7CiAgICB9CiAgICAjaW50ZXJjZXB0b3ItZXhlYy1vcmRlciA+IHRleHQgewogICAgICBkb21pbmFudC1iYXNlbGluZTogY2VudHJhbDsKICAgICAgZmlsbDogYmxhY2s7CiAgICAgIGZvbnQtc2l6ZTogNHB4OwogICAgICBmb250LXdlaWdodDogbGlnaHRlcjsKICAgICAgbGV0dGVyLXNwYWNpbmc6IC4ycHg7CiAgICAgIHRleHQtYW5jaG9yOiBtaWRkbGU7CiAgICB9CiAgICAjaW50ZXJjZXB0b3ItZXhlYy1vcmRlciA+IC5kYXNoZWQgewogICAgICBzdHJva2UtZGFzaGFycmF5OiAyIDE7CiAgICB9CiAgPC9zdHlsZT4KCiAgPGRlZnM+CiAgICA8cmVjdCBpZD0idGV4dGJveCIgeD0iMiIgd2lkdGg9IjUwIiBoZWlnaHQ9IjEwIiByeD0iMiIgLz4KICAgIDxwYXRoIGlkPSJhcnJvdyIgZD0iTTEyLDAgdjEwIGwtMiwtNCBtMiw0IGwyLC00IiAvPgogICAgPGcgaWQ9ImFycm93cyI+CiAgICAgIDx1c2UgaHJlZj0iI2Fycm93IiAvPgogICAgICA8dXNlIGhyZWY9IiNhcnJvdyIgc3R5bGU9InRyYW5zZm9ybTogcm90YXRlWigxODBkZWcpOyB0cmFuc2Zvcm0tb3JpZ2luOiAyN3B4IDVweDsiIC8+CiAgICA8L2c+CiAgPC9kZWZzPgoKICA8ZyBpZD0iaW50ZXJjZXB0b3ItZXhlYy1vcmRlciI+CiAgICA8dGV4dCB4PSIyNyIgeT0iNyI+SHR0cENsaWVudDwvdGV4dD4KICAgIDx1c2UgaHJlZj0iI3RleHRib3giIHk9IjAyIiBjbGFzcz0iZGFzaGVkIiAvPgogICAgPHVzZSBocmVmPSIjYXJyb3dzIiAgeT0iMTIiIGNsYXNzPSJkYXNoZWQiIC8+CgogICAgPHRleHQgeD0iMjciIHk9IjI3Ij5BdXRoSW50ZXJjZXB0b3I8L3RleHQ+CiAgICA8dXNlIGhyZWY9IiN0ZXh0Ym94IiB5PSIyMiIgLz4KICAgIDx1c2UgaHJlZj0iI2Fycm93cyIgIHk9IjMyIiAvPgoKICAgIDx0ZXh0IHg9IjI3IiB5PSI0NyI+TG9nZ2luZ0ludGVyY2VwdG9yPC90ZXh0PgogICAgPHVzZSBocmVmPSIjdGV4dGJveCIgeT0iNDIiIC8+CiAgICA8dXNlIGhyZWY9IiNhcnJvd3MiICB5PSI1MiIgLz4KCiAgICA8dGV4dCB4PSIyNyIgeT0iNjciPkh0dHBCYWNrZW5kPC90ZXh0PgogICAgPHVzZSBocmVmPSIjdGV4dGJveCIgeT0iNjIiIC8+CiAgICA8dXNlIGhyZWY9IiNhcnJvd3MiICB5PSI3MiIgY2xhc3M9ImRhc2hlZCIgLz4KCiAgICA8dGV4dCB4PSIyNyIgeT0iODciPlNlcnZlcjwvdGV4dD4KICAgIDx1c2UgaHJlZj0iI3RleHRib3giIHk9IjgyIiBjbGFzcz0iZGFzaGVkIiAvPgogIDwvZz4KPC9zdmc+Cg==" width="300" height="522"> </div> <blockquote class="alert is-helpful"> <p>The last interceptor in the process is always the <code><a href="../api/common/http/httpbackend" class="code-anchor">HttpBackend</a></code> that handles communication with the server.</p> </blockquote> <p>You cannot change the order or remove interceptors later. If you need to enable and disable an interceptor dynamically, you'll have to build that capability into the interceptor itself.</p>  <h2 id="handle-interceptor-events">Handle interceptor events</h2> <p>Most <code><a href="../api/common/http/httpclient" class="code-anchor">HttpClient</a></code> methods return observables of <code><a href="../api/common/http/httpresponse" class="code-anchor">HttpResponse</a>&lt;any&gt;</code>. The <code><a href="../api/common/http/httpresponse" class="code-anchor">HttpResponse</a></code> class itself is actually an event, whose type is <code><a href="../api/common/http/httpeventtype#Response" class="code-anchor">HttpEventType.Response</a></code>. A single HTTP request can, however, generate multiple events of other types, including upload and download progress events. The methods <code>HttpInterceptor.intercept()</code> and <code>HttpHandler.handle()</code> return observables of <code><a href="../api/common/http/httpevent" class="code-anchor">HttpEvent</a>&lt;any&gt;</code>.</p> <p>Many interceptors are only concerned with the outgoing request and return the event stream from <code>next.handle()</code> without modifying it. Some interceptors, however, need to examine and modify the response from <code>next.handle()</code>; these operations can see all of these events in the stream.</p>  <p>Although interceptors are capable of modifying requests and responses, the <code><a href="../api/common/http/httprequest" class="code-anchor">HttpRequest</a></code> and <code><a href="../api/common/http/httpresponse" class="code-anchor">HttpResponse</a></code> instance properties are <code>readonly</code>, rendering them largely immutable. They are immutable for a good reason: An app might retry a request several times before it succeeds, which means that the interceptor chain can re-process the same request multiple times. If an interceptor could modify the original request object, the re-tried operation would start from the modified request rather than the original. Immutability ensures that interceptors see the same request for each try.</p> <blockquote class="alert is-helpful"> <p>Your interceptor should return every event without modification unless it has a compelling reason to do otherwise.</p> </blockquote> <p>TypeScript prevents you from setting <code><a href="../api/common/http/httprequest" class="code-anchor">HttpRequest</a></code> read-only properties.</p> <pre format="javascript" data-language="javascript">// Typescript disallows the following assignment because req.url is readonly
req.url = req.url.replace('http://', 'https://');</pre> <p>If you must alter a request, clone it first and modify the clone before passing it to <code>next.handle()</code>. You can clone and modify the request in a single step, as shown in the following example.</p> <pre header="app/http-interceptors/ensure-https-interceptor.ts (excerpt)" data-language="typescript">// clone request and replace 'http://' with 'https://' at the same time
const secureReq = req.clone({
  url: req.url.replace('http://', 'https://')
});
// send the cloned, "secure" request to the next handler.
return next.handle(secureReq);</pre> <p>The <code>clone()</code> method's hash argument lets you mutate specific properties of the request while copying the others.</p> <h3 id="modify-a-request-body">Modify a request body</h3> <p>The <code>readonly</code> assignment guard can't prevent deep updates and, in particular, it can't prevent you from modifying a property of a request body object.</p> <pre format="javascript" data-language="javascript">req.body.name = req.body.name.trim(); // bad idea!</pre> <p>If you must modify the request body, follow these steps.</p> <ol> <li>Copy the body and make your change in the copy.</li> <li>Clone the request object, using its <code>clone()</code> method.</li> <li>Replace the clone's body with the modified copy.</li> </ol> <pre header="app/http-interceptors/trim-name-interceptor.ts (excerpt)" data-language="typescript">// copy the body and trim whitespace from the name property
const newBody = { ...body, name: body.name.trim() };
// clone request and set its body
const newReq = req.clone({ body: newBody });
// send the cloned request to the next handler.
return next.handle(newReq);</pre> <h3 id="clear-the-request-body-in-a-clone">Clear the request body in a clone</h3> <p>Sometimes you need to clear the request body rather than replace it. To do this, set the cloned request body to <code>null</code>.</p> <blockquote class="alert is-helpful"> <p><strong>TIP</strong>:  If you set the cloned request body to <code>undefined</code>, Angular assumes you intend to leave the body as is.</p> </blockquote> <pre format="javascript" data-language="javascript">newReq = req.clone({ … }); // body not mentioned =&gt; preserve original body
newReq = req.clone({ body: undefined }); // preserve original body
newReq = req.clone({ body: null }); // clear the body</pre> <div class="reviewed">Last reviewed on Thu Mar 16 2023</div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2010–2023 Google, Inc.<br>Licensed under the Creative Commons Attribution License 4.0.<br>
    <a href="https://angular.io/guide/http-intercept-requests-and-responses" class="_attribution-link">https://angular.io/guide/http-intercept-requests-and-responses</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
