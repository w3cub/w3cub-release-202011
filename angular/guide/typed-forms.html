
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Typed Forms - Angular - W3cubDocs</title>
  
  <meta name="description" content=" As of Angular 14, reactive forms are strictly typed by default. ">
  <meta name="keywords" content="typed, forms, angular">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/angular/guide/typed-forms.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-9c7b0d969c0ce639a6c01c2badcdd81667c7c66206aa3d0fccc5cb0585fb1b912dab72ea882101d18010680927514b4b77b107282db8f756fbf63301fe9c88b0.css">
  <script type="text/javascript" src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js"></script>
  <script src="/json/angular.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/angular/" class="_nav-link" title="" style="margin-left:0;">Angular</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _angular">
				
				
<h1 id="typed-forms">Typed Forms</h1> <p>As of Angular 14, reactive forms are strictly typed by default.</p>  <h2 id="prerequisites">Prerequisites</h2> <p>As background for this guide, you should already be familiar with <a href="reactive-forms" title="Reactive Forms">Angular Reactive Forms</a>.</p>  <h2 id="overview-of-typed-forms">Overview of Typed Forms</h2> <iframe width="560" height="315" src="https://www.youtube.com/embed/L-odCf4MfJc" title="YouTube video player" frameborder="0" allow="accelerometer; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe> <p>With Angular reactive forms, you explicitly specify a <em>form model</em>. As a simple example, consider this basic user login form:</p> <pre data-language="typescript">const login = new FormGroup({
    email: new FormControl(''),
    password: new FormControl(''),
});</pre> <p>Angular provides many APIs for interacting with this <code><a href="../api/forms/formgroup" class="code-anchor">FormGroup</a></code>. For example, you may call <code>login.value</code>, <code>login.controls</code>, <code>login.patchValue</code>, etc. (For a full API reference, see the <a href="../api/forms/formgroup">API documentation</a>.)</p> <p>In previous Angular versions, most of these APIs included <code>any</code> somewhere in their types, and interacting with the structure of the controls, or the values themselves, was not type-safe. For example: you could write the following invalid code:</p> <pre data-language="typescript">const emailDomain = login.value.email.domain;</pre> <p>With strictly typed reactive forms, the above code does not compile, because there is no <code>domain</code> property on <code><a href="../api/forms/emailvalidator" class="code-anchor">email</a></code>.</p> <p>In addition to the added safety, the types enable a variety of other improvements, such as better autocomplete in IDEs, and an explicit way to specify form structure.</p> <p>These improvements currently apply only to <em>reactive</em> forms (not <a href="forms" title="Forms Guide"><em>template-driven</em> forms</a>).</p>  <h2 id="automated-untyped-forms-migration">Automated Untyped Forms Migration</h2> <p>When upgrading to Angular 14, an included migration will automatically replace all the forms classes in your code with corresponding untyped versions. For example, the snippet from above would become:</p> <pre data-language="typescript">const login = new UntypedFormGroup({
    email: new UntypedFormControl(''),
    password: new UntypedFormControl(''),
});</pre> <p>Each <code>Untyped</code> symbol has exactly the same semantics as in previous Angular versions, so your application should continue to compile as before. By removing the <code>Untyped</code> prefixes, you can incrementally enable the types.</p>  <h2 id="formcontrol-getting-started">
<code><a href="../api/forms/formcontrol" class="code-anchor">FormControl</a></code>: Getting Started</h2> <p>The simplest possible form consists of a single control:</p> <pre data-language="typescript">const email = new FormControl('angularrox@gmail.com');</pre> <p>This control will be automatically inferred to have the type <code><a href="../api/forms/formcontrol" class="code-anchor">FormControl</a>&lt;string|null&gt;</code>. TypeScript will automatically enforce this type throughout the <a href="../api/forms/formcontrol"><code>FormControl</code> API</a>, such as <code>email.value</code>, <code>email.valueChanges</code>, <code>email.setValue(...)</code>, etc.</p> <h3 id="nullability">Nullability</h3> <p>You might wonder: why does the type of this control include <code>null</code>? This is because the control can become <code>null</code> at any time, by calling reset:</p> <pre data-language="typescript">const email = new FormControl('angularrox@gmail.com');
email.reset();
console.log(email.value); // null</pre> <p>TypeScript will enforce that you always handle the possibility that the control has become <code>null</code>. If you want to make this control non-nullable, you may use the <code>nonNullable</code> option. This will cause the control to reset to its initial value, instead of <code>null</code>:</p> <pre data-language="typescript">const email = new FormControl('angularrox@gmail.com', {nonNullable: true});
email.reset();
console.log(email.value); // angularrox@gmail.com</pre> <p>To reiterate, this option affects the runtime behavior of your form when <code>.reset()</code> is called, and should be flipped with care.</p> <h3 id="specifying-an-explicit-type">Specifying an Explicit Type</h3> <p>It is possible to specify the type, instead of relying on inference. Consider a control that is initialized to <code>null</code>. Because the initial value is <code>null</code>, TypeScript will infer <code><a href="../api/forms/formcontrol" class="code-anchor">FormControl</a>&lt;null&gt;</code>, which is narrower than we want.</p> <pre data-language="typescript">const email = new FormControl(null);
email.setValue('angularrox@gmail.com'); // Error!</pre> <p>To prevent this, we explicitly specify the type as <code>string|null</code>:</p> <pre data-language="typescript">const email = new FormControl&lt;string|null&gt;(null);
email.setValue('angularrox@gmail.com');</pre>  <h2 id="formarray-dynamic-homogenous-collections">
<code><a href="../api/forms/formarray" class="code-anchor">FormArray</a></code>: Dynamic, Homogenous Collections</h2> <p>A <code><a href="../api/forms/formarray" class="code-anchor">FormArray</a></code> contains an open-ended list of controls. The type parameter corresponds to the type of each inner control:</p> <pre data-language="typescript">const names = new FormArray([new FormControl('Alex')]);
names.push(new FormControl('Jess'));</pre> <p>This <code><a href="../api/forms/formarray" class="code-anchor">FormArray</a></code> will have the inner controls type <code><a href="../api/forms/formcontrol" class="code-anchor">FormControl</a>&lt;string|null&gt;</code>.</p> <p>If you want to have multiple different element types inside the array, you must use <code><a href="../api/forms/untypedformarray" class="code-anchor">UntypedFormArray</a></code>, because TypeScript cannot infer which element type will occur at which position.</p>  <h2 id="formgroup-and-formrecord">
<code><a href="../api/forms/formgroup" class="code-anchor">FormGroup</a></code> and <code><a href="../api/forms/formrecord" class="code-anchor">FormRecord</a></code>
</h2> <p>Angular provides the <code><a href="../api/forms/formgroup" class="code-anchor">FormGroup</a></code> type for forms with an enumerated set of keys, and a type called <code><a href="../api/forms/formrecord" class="code-anchor">FormRecord</a></code>, for open-ended or dynamic groups.</p> <h3 id="partial-values">Partial Values</h3> <p>Consider again a login form:</p> <pre data-language="typescript">const login = new FormGroup({
    email: new FormControl('', {nonNullable: true}),
    password: new FormControl('', {nonNullable: true}),
});</pre> <p>On any <code><a href="../api/forms/formgroup" class="code-anchor">FormGroup</a></code>, it is <a href="../api/forms/formgroup">possible to disable controls</a>. Any disabled control will not appear in the group's value.</p> <p>As a consequence, the type of <code>login.value</code> is <code>Partial&lt;{<a href="../api/forms/emailvalidator" class="code-anchor">email</a>: string, password: string}&gt;</code>. The <code>Partial</code> in this type means that each member might be undefined.</p> <p>More specifically, the type of <code>login.value.email</code> is <code>string|undefined</code>, and TypeScript will enforce that you handle the possibly <code>undefined</code> value (if you have <code>strictNullChecks</code> enabled).</p> <p>If you want to access the value <em>including</em> disabled controls, and thus bypass possible <code>undefined</code> fields, you can use <code>login.getRawValue()</code>.</p> <h3 id="optional-controls-and-dynamic-groups">Optional Controls and Dynamic Groups</h3> <p>Some forms have controls that may or may not be present, which can be added and removed at runtime. You can represent these controls using <em>optional fields</em>:</p> <pre data-language="typescript">interface LoginForm {
    email: FormControl&lt;string&gt;;
    password?: FormControl&lt;string&gt;;
}

const login = new FormGroup&lt;LoginForm&gt;({
    email: new FormControl('', {nonNullable: true}),
    password: new FormControl('', {nonNullable: true}),
});

login.removeControl('password');</pre> <p>In this form, we explicitly specify the type, which allows us to make the <code>password</code> control optional. TypeScript will enforce that only optional controls can be added or removed.</p> <h3 id="formrecord"><code><a href="../api/forms/formrecord" class="code-anchor">FormRecord</a></code></h3> <p>Some <code><a href="../api/forms/formgroup" class="code-anchor">FormGroup</a></code> usages do not fit the above pattern because the keys are not known ahead of time. The <code><a href="../api/forms/formrecord" class="code-anchor">FormRecord</a></code> class is designed for that case:</p> <pre data-language="typescript">const addresses = new FormRecord&lt;FormControl&lt;string|null&gt;&gt;({});
addresses.addControl('Andrew', new FormControl('2340 Folsom St'));</pre> <p>Any control of type <code>string|null</code> can be added to this <code><a href="../api/forms/formrecord" class="code-anchor">FormRecord</a></code>.</p> <p>If you need a <code><a href="../api/forms/formgroup" class="code-anchor">FormGroup</a></code> that is both dynamic (open-ended) and heterogeneous (the controls are different types), no improved type safety is possible, and you should use <code><a href="../api/forms/untypedformgroup" class="code-anchor">UntypedFormGroup</a></code>.</p> <p>A <code><a href="../api/forms/formrecord" class="code-anchor">FormRecord</a></code> can also be built with the <code><a href="../api/forms/formbuilder" class="code-anchor">FormBuilder</a></code>:</p> <pre data-language="typescript">const addresses = fb.record({'Andrew': '2340 Folsom St'});</pre> <h2 id="formbuilder-and-nonnullableformbuilder">
<code><a href="../api/forms/formbuilder" class="code-anchor">FormBuilder</a></code> and <code><a href="../api/forms/nonnullableformbuilder" class="code-anchor">NonNullableFormBuilder</a></code>
</h2> <p>The <code><a href="../api/forms/formbuilder" class="code-anchor">FormBuilder</a></code> class has been upgraded to support the new types as well, in the same manner as the above examples.</p> <p>Additionally, an additional builder is available: <code><a href="../api/forms/nonnullableformbuilder" class="code-anchor">NonNullableFormBuilder</a></code>. This type is shorthand for specifying <code>{nonNullable: true}</code> on every control, and can eliminate significant boilerplate from large non-nullable forms. You can access it using the <code>nonNullable</code> property on a <code><a href="../api/forms/formbuilder" class="code-anchor">FormBuilder</a></code>:</p> <pre data-language="typescript">const fb = new FormBuilder();
const login = fb.nonNullable.group({
    email: '',
    password: '',
});</pre> <p>On the above example, both inner controls will be non-nullable (i.e. <code>nonNullable</code> will be set).</p> <p>You can also inject it using the name <code><a href="../api/forms/nonnullableformbuilder" class="code-anchor">NonNullableFormBuilder</a></code>.</p>    <div class="reviewed">Last reviewed on Tue May 10 2022</div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2010–2023 Google, Inc.<br>Licensed under the Creative Commons Attribution License 4.0.<br>
    <a href="https://angular.io/guide/typed-forms" class="_attribution-link">https://angular.io/guide/typed-forms</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
