
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>6. Get Data From a Server - Angular - W3cubDocs</title>
  
  <meta name="description" content=" This tutorial adds the following data persistence features with help from Angular&#39;s HttpClient. ">
  <meta name="keywords" content="get, data, from, server, angular">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/angular/tutorial/tour-of-heroes/toh-pt6.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-9c7b0d969c0ce639a6c01c2badcdd81667c7c66206aa3d0fccc5cb0585fb1b912dab72ea882101d18010680927514b4b77b107282db8f756fbf63301fe9c88b0.css">
  <script type="text/javascript" src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js"></script>
  <script src="/json/angular.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/angular/" class="_nav-link" title="" style="margin-left:0;">Angular</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _angular">
				
				
<h1 id="get-data-from-a-server">Get data from a server</h1> <p>This tutorial adds the following data persistence features with help from Angular's <code><a href="../../api/common/http/httpclient" class="code-anchor">HttpClient</a></code>.</p> <ul> <li>The <code>HeroService</code> gets hero data with HTTP requests</li> <li>Users can add, edit, and delete heroes and save these changes over HTTP</li> <li>Users can search for heroes by name</li> </ul> <blockquote class="alert is-helpful"> <p>For the sample application that this page describes, see the live example.</p> </blockquote> <h2 id="enable-http-services">Enable HTTP services</h2> <p><code><a href="../../api/common/http/httpclient" class="code-anchor">HttpClient</a></code> is Angular's mechanism for communicating with a remote server over HTTP.</p> <p>Make <code><a href="../../api/common/http/httpclient" class="code-anchor">HttpClient</a></code> available everywhere in the application in two steps. First, add it to the root <code>AppModule</code> by importing it:</p> <pre header="src/app/app.module.ts (HttpClientModule import)" data-language="typescript">import { HttpClientModule } from '@angular/common/http';</pre> <p>Next, still in the <code>AppModule</code>, add <code><a href="../../api/common/http/httpclientmodule" class="code-anchor">HttpClientModule</a></code> to the <code>imports</code> array:</p> <pre header="src/app/app.module.ts (imports array excerpt)" data-language="typescript">@NgModule({
  imports: [
    HttpClientModule,
  ],
})</pre> <h2 id="simulate-a-data-server">Simulate a data server</h2> <p>This tutorial sample mimics communication with a remote data server by using the <a href="https://github.com/angular/angular/tree/main/packages/misc/angular-in-memory-web-api" title="In-memory Web API">In-memory Web API</a> module.</p> <p>After installing the module, the application makes requests to and receive responses from the <code><a href="../../api/common/http/httpclient" class="code-anchor">HttpClient</a></code>. The application doesn't know that the <em>In-memory Web API</em> is intercepting those requests, applying them to an in-memory data store, and returning simulated responses.</p> <p>By using the In-memory Web API, you won't have to set up a server to learn about <code><a href="../../api/common/http/httpclient" class="code-anchor">HttpClient</a></code>.</p> <blockquote class="alert is-important"> <p><strong>IMPORTANT</strong>:  The In-memory Web API module has nothing to do with HTTP in Angular.</p> <p>If you're reading this tutorial to learn about <code><a href="../../api/common/http/httpclient" class="code-anchor">HttpClient</a></code>, you can <a href="toh-pt6#import-heroes">skip over</a> this step. If you're coding along with this tutorial, stay here and add the In-memory Web API now.</p> </blockquote> <p>Install the In-memory Web API package from npm with the following command:</p> <pre format="shell" data-language="shell">npm install angular-in-memory-web-api --save</pre> <p>Generate the class <code>src/app/in-memory-data.service.ts</code> with the following command:</p> <pre format="shell" data-language="shell">ng generate service InMemoryData</pre> <p>Replace the default contents of <code>in-memory-data.service.ts</code> with the following:</p> <pre header="src/app/in-memory-data.service.ts" data-language="typescript">import { Injectable } from '@angular/core';
import { InMemoryDbService } from 'angular-in-memory-web-api';
import { Hero } from './hero';

@Injectable({
  providedIn: 'root',
})
export class InMemoryDataService implements InMemoryDbService {
  createDb() {
    const heroes = [
      { id: 12, name: 'Dr. Nice' },
      { id: 13, name: 'Bombasto' },
      { id: 14, name: 'Celeritas' },
      { id: 15, name: 'Magneta' },
      { id: 16, name: 'RubberMan' },
      { id: 17, name: 'Dynama' },
      { id: 18, name: 'Dr. IQ' },
      { id: 19, name: 'Magma' },
      { id: 20, name: 'Tornado' }
    ];
    return {heroes};
  }

  // Overrides the genId method to ensure that a hero always has an id.
  // If the heroes array is empty,
  // the method below returns the initial number (11).
  // if the heroes array is not empty, the method below returns the highest
  // hero id + 1.
  genId(heroes: Hero[]): number {
    return heroes.length &gt; 0 ? Math.max(...heroes.map(hero =&gt; hero.id)) + 1 : 11;
  }
}</pre> <p>In the <code>AppModule</code>, import the <code>HttpClientInMemoryWebApiModule</code> and the <code>InMemoryDataService</code> class, which you create next.</p> <pre header="src/app/app.module.ts (In-memory Web API imports)" data-language="typescript">import { HttpClientInMemoryWebApiModule } from 'angular-in-memory-web-api';
import { InMemoryDataService } from './in-memory-data.service';</pre> <p>After the <code><a href="../../api/common/http/httpclientmodule" class="code-anchor">HttpClientModule</a></code>, add the <code>HttpClientInMemoryWebApiModule</code> to the <code>AppModule</code> <code>imports</code> array and configure it with the <code>InMemoryDataService</code>.</p> <pre header="src/app/app.module.ts (imports array excerpt)" data-language="typescript">HttpClientModule,

// The HttpClientInMemoryWebApiModule module intercepts HTTP requests
// and returns simulated server responses.
// Remove it when a real server is ready to receive requests.
HttpClientInMemoryWebApiModule.forRoot(
  InMemoryDataService, { dataEncapsulation: false }
)</pre> <p>The <code>forRoot()</code> configuration method takes an <code>InMemoryDataService</code> class that primes the in-memory database.</p> <p>The <code>in-memory-data.service.ts</code> file takes over the function of <code>mock-heroes.ts</code>. Don't delete <code>mock-heroes.ts</code> yet. You still need it for a few more steps of this tutorial.</p> <p>After the server is ready, detach the In-memory Web API so the application's requests can go through to the server.</p>  <h2 id="heroes-and-http">Heroes and HTTP</h2> <p>In the <code>HeroService</code>, import <code><a href="../../api/common/http/httpclient" class="code-anchor">HttpClient</a></code> and <code><a href="../../api/common/http/httpheaders" class="code-anchor">HttpHeaders</a></code>:</p> <pre header="src/app/hero.service.ts (import HTTP symbols)" data-language="typescript">import { HttpClient, HttpHeaders } from '@angular/common/http';</pre> <p>Still in the <code>HeroService</code>, inject <code><a href="../../api/common/http/httpclient" class="code-anchor">HttpClient</a></code> into the constructor in a private property called <code><a href="../../api/common/http" class="code-anchor">http</a></code>.</p> <pre header="src/app/hero.service.ts" data-language="typescript">constructor(
  private http: HttpClient,
  private messageService: MessageService) { }</pre> <p>Notice that you keep injecting the <code>MessageService</code> but since your application calls it so frequently, wrap it in a private <code>log()</code> method:</p> <pre header="src/app/hero.service.ts" data-language="typescript">/** Log a HeroService message with the MessageService */
private log(message: string) {
  this.messageService.add(`HeroService: ${message}`);
}</pre> <p>Define the <code>heroesUrl</code> of the form <code>:base/:collectionName</code> with the address of the heroes resource on the server. Here <code>base</code> is the resource to which requests are made, and <code>collectionName</code> is the heroes data object in the <code>in-memory-data-service.ts</code>.</p> <pre header="src/app/hero.service.ts" data-language="typescript">private heroesUrl = 'api/heroes';  // URL to web api</pre> <h3 id="get-heroes-with-httpclient">Get heroes with <code><a href="../../api/common/http/httpclient" class="code-anchor">HttpClient</a></code>
</h3> <p>The current <code>HeroService.getHeroes()</code> uses the RxJS <code>of()</code> function to return an array of mock heroes as an <code>Observable&lt;Hero[]&gt;</code>.</p> <pre header="src/app/hero.service.ts (getHeroes with RxJs 'of()')" data-language="typescript">getHeroes(): Observable&lt;Hero[]&gt; {
  const heroes = of(HEROES);
  return heroes;
}</pre> <p>Convert that method to use <code><a href="../../api/common/http/httpclient" class="code-anchor">HttpClient</a></code> as follows:</p> <pre header="src/app/hero.service.ts" data-language="typescript">/** GET heroes from the server */
getHeroes(): Observable&lt;Hero[]&gt; {
  return this.http.get&lt;Hero[]&gt;(this.heroesUrl)
}</pre> <p>Refresh the browser. The hero data should successfully load from the mock server.</p> <p>You've swapped <code>of()</code> for <code>http.get()</code> and the application keeps working without any other changes because both functions return an <code>Observable&lt;Hero[]&gt;</code>.</p> <h3 id="httpclient-methods-return-one-value">
<code><a href="../../api/common/http/httpclient" class="code-anchor">HttpClient</a></code> methods return one value</h3> <p>All <code><a href="../../api/common/http/httpclient" class="code-anchor">HttpClient</a></code> methods return an RxJS <code>Observable</code> of something.</p> <p>HTTP is a request/response protocol. You make a request, it returns a single response.</p> <p>In general, an observable <em>can</em> return more than one value over time. An observable from <code><a href="../../api/common/http/httpclient" class="code-anchor">HttpClient</a></code> always emits a single value and then completes, never to emit again.</p> <p>This particular call to <code><a href="../../api/common/http/httpclient#get" class="code-anchor">HttpClient.get()</a></code> returns an <code>Observable&lt;Hero[]&gt;</code>, which is <em>an observable of hero arrays</em>. In practice, it only returns a single hero array.</p> <h3 id="httpclientget-returns-response-data">
<code><a href="../../api/common/http/httpclient#get" class="code-anchor">HttpClient.get()</a></code> returns response data</h3> <p><code><a href="../../api/common/http/httpclient#get" class="code-anchor">HttpClient.get()</a></code> returns the body of the response as an untyped JSON object by default. Applying the optional type specifier, <code>&lt;Hero[]&gt;</code> , adds TypeScript capabilities, which reduce errors during compile time.</p> <p>The server's data API determines the shape of the JSON data. The <em>Tour of Heroes</em> data API returns the hero data as an array.</p> <blockquote class="alert is-helpful"> <p>Other APIs may bury the data that you want within an object. You might have to dig that data out by processing the <code>Observable</code> result with the RxJS <code>map()</code> operator.</p> <p>Although not discussed here, there's an example of <code>map()</code> in the <code>getHeroNo404()</code> method included in the sample source code.</p> </blockquote> <h3 id="error-handling">Error handling</h3> <p>Things go wrong, especially when you're getting data from a remote server. The <code>HeroService.getHeroes()</code> method should catch errors and do something appropriate.</p> <p>To catch errors, you <strong>"pipe" the observable</strong> result from <code>http.get()</code> through an RxJS <code>catchError()</code> operator.</p> <p>Import the <code>catchError</code> symbol from <code>rxjs/operators</code>, along with some other operators to use later.</p> <pre header="src/app/hero.service.ts" data-language="typescript">import { catchError, map, tap } from 'rxjs/operators';</pre> <p>Now extend the observable result with the <code>pipe()</code> method and give it a <code>catchError()</code> operator.</p> <pre header="src/app/hero.service.ts" data-language="typescript">getHeroes(): Observable&lt;Hero[]&gt; {
  return this.http.get&lt;Hero[]&gt;(this.heroesUrl)
    .pipe(
      catchError(this.handleError&lt;Hero[]&gt;('getHeroes', []))
    );
}</pre> <p>The <code>catchError()</code> operator intercepts an <strong><code>Observable</code> that failed</strong>. The operator then passes the error to the error handling function.</p> <p>The following <code>handleError()</code> method reports the error and then returns an innocuous result so that the application keeps working.</p> <h4 id="handleerror"><code>handleError</code></h4> <p>The following <code>handleError()</code> can be shared by many <code>HeroService</code> methods so it's generalized to meet their different needs.</p> <p>Instead of handling the error directly, it returns an error handler function to <code>catchError</code>. This function is configured with both the name of the operation that failed and a safe return value.</p> <pre header="src/app/hero.service.ts" data-language="typescript">/**
 * Handle Http operation that failed.
 * Let the app continue.
 *
 * @param operation - name of the operation that failed
 * @param result - optional value to return as the observable result
 */
private handleError&lt;T&gt;(operation = 'operation', result?: T) {
  return (error: any): Observable&lt;T&gt; =&gt; {

    // TODO: send the error to remote logging infrastructure
    console.error(error); // log to console instead

    // TODO: better job of transforming error for user consumption
    this.log(`${operation} failed: ${error.message}`);

    // Let the app keep running by returning an empty result.
    return of(result as T);
  };
}</pre> <p>After reporting the error to the console, the handler constructs a friendly message and returns a safe value so the application can keep working.</p> <p>Because each service method returns a different kind of <code>Observable</code> result, <code>handleError()</code> takes a type parameter to return the safe value as the type that the application expects.</p> <h3 id="tap-into-the-observable">Tap into the Observable</h3> <p>The <code>getHeros()</code> method taps into the flow of observable values and sends a message, using the <code>log()</code> method, to the message area at the bottom of the page.</p> <p>The RxJS <code>tap()</code> operator enables this ability by looking at the observable values, doing something with those values, and passing them along. The <code>tap()</code> callback doesn't access the values themselves.</p> <p>Here is the final version of <code>getHeroes()</code> with the <code>tap()</code> that logs the operation.</p> <pre header="src/app/hero.service.ts" data-language="typescript">/** GET heroes from the server */
getHeroes(): Observable&lt;Hero[]&gt; {
  return this.http.get&lt;Hero[]&gt;(this.heroesUrl)
    .pipe(
      tap(_ =&gt; this.log('fetched heroes')),
      catchError(this.handleError&lt;Hero[]&gt;('getHeroes', []))
    );
}</pre> <h3 id="get-hero-by-id">Get hero by id</h3> <p>Most web APIs support a <em>get by id</em> request in the form <code>:baseURL/:id</code>.</p> <p>Here, the <em>base URL</em> is the <code>heroesURL</code> defined in the <a href="toh-pt6#heroes-and-http">Heroes and HTTP</a> section in <code>api/heroes</code> and <em>id</em> is the number of the hero that you want to retrieve. For example, <code>api/heroes/11</code>.</p> <p>Update the <code>HeroService</code> <code>getHero()</code> method with the following to make that request:</p> <pre header="src/app/hero.service.ts" data-language="typescript">/** GET hero by id. Will 404 if id not found */
getHero(id: number): Observable&lt;Hero&gt; {
  const url = `${this.heroesUrl}/${id}`;
  return this.http.get&lt;Hero&gt;(url).pipe(
    tap(_ =&gt; this.log(`fetched hero id=${id}`)),
    catchError(this.handleError&lt;Hero&gt;(`getHero id=${id}`))
  );
}</pre> <p><code>getHero()</code> has three significant differences from <code>getHeroes()</code>:</p> <ul> <li>
<code>getHero()</code> constructs a request URL with the desired hero's id</li> <li>The server should respond with a single hero rather than an array of heroes</li> <li>
<code>getHero()</code> returns an <code>Observable&lt;Hero&gt;</code>, which is an observable of <code>Hero</code> <em>objects</em> rather than an observable of <code>Hero</code> <em>arrays</em>.</li> </ul> <h2 id="update-heroes">Update heroes</h2>  <p>Edit a hero's name in the hero detail view. As you type, the hero name updates the heading at the top of the page, yet when you click <strong>Go back</strong>, your changes are lost.</p> <p>If you want changes to persist, you must write them back to the server.</p> <p>At the end of the hero detail template, add a save button with a <code>click</code> event binding that invokes a new component method named <code>save()</code>.</p> <pre header="src/app/hero-detail/hero-detail.component.html (save)" data-language="html">&lt;button type="button" (click)="save()"&gt;save&lt;/button&gt;</pre> <p>In the <code>HeroDetail</code> component class, add the following <code>save()</code> method, which persists hero name changes using the hero service <code>updateHero()</code> method and then navigates back to the previous view.</p> <pre header="src/app/hero-detail/hero-detail.component.ts (save)" data-language="typescript">save(): void {
  if (this.hero) {
    this.heroService.updateHero(this.hero)
      .subscribe(() =&gt; this.goBack());
  }
}</pre> <h4 id="add-heroserviceupdatehero">Add <code>HeroService.updateHero()</code>
</h4> <p>The structure of the <code>updateHero()</code> method is like that of <code>getHeroes()</code>, but it uses <code>http.put()</code> to persist the changed hero on the server. Add the following to the <code>HeroService</code>.</p> <pre header="src/app/hero.service.ts (update)" data-language="typescript">/** PUT: update the hero on the server */
updateHero(hero: Hero): Observable&lt;any&gt; {
  return this.http.put(this.heroesUrl, hero, this.httpOptions).pipe(
    tap(_ =&gt; this.log(`updated hero id=${hero.id}`)),
    catchError(this.handleError&lt;any&gt;('updateHero'))
  );
}</pre> <p>The <code><a href="../../api/common/http/httpclient#put" class="code-anchor">HttpClient.put()</a></code> method takes three parameters:</p> <ul> <li>The URL</li> <li>The data to update, which is the modified hero in this case</li> <li>Options</li> </ul> <p>The URL is unchanged. The heroes web API knows which hero to update by looking at the hero's <code>id</code>.</p> <p>The heroes web API expects a special header in HTTP save requests. That header is in the <code>httpOptions</code> constant defined in the <code>HeroService</code>. Add the following to the <code>HeroService</code> class.</p> <pre header="src/app/hero.service.ts" data-language="typescript">httpOptions = {
  headers: new HttpHeaders({ 'Content-Type': 'application/json' })
};</pre> <p>Refresh the browser, change a hero name and save your change. The <code>save()</code> method in <code>HeroDetailComponent</code> navigates to the previous view. The hero now appears in the list with the changed name.</p> <h2 id="add-a-new-hero">Add a new hero</h2> <p>To add a hero, this application only needs the hero's name. You can use an <code>&lt;input&gt;</code> element paired with an add button.</p> <p>Insert the following into the <code>HeroesComponent</code> template, after the heading:</p> <pre header="src/app/heroes/heroes.component.html (add)" data-language="html">&lt;div&gt;
  &lt;label for="new-hero"&gt;Hero name: &lt;/label&gt;
  &lt;input id="new-hero" #heroName /&gt;

  &lt;!-- (click) passes input value to add() and then clears the input --&gt;
  &lt;button type="button" class="add-button" (click)="add(heroName.value); heroName.value=''"&gt;
    Add hero
  &lt;/button&gt;
&lt;/div&gt;</pre> <p>In response to a click event, call the component's click handler, <code>add()</code>, and then clear the input field so that it's ready for another name. Add the following to the <code>HeroesComponent</code> class:</p> <pre header="src/app/heroes/heroes.component.ts (add)" data-language="typescript">add(name: string): void {
  name = name.trim();
  if (!name) { return; }
  this.heroService.addHero({ name } as Hero)
    .subscribe(hero =&gt; {
      this.heroes.push(hero);
    });
}</pre> <p>When the given name isn't blank, the handler creates an object based on the hero's name. The handler passes the object name to the service's <code>addHero()</code> method.</p> <p>When <code>addHero()</code> creates a new object, the <code>subscribe()</code> callback receives the new hero and pushes it into to the <code>heroes</code> list for display.</p> <p>Add the following <code>addHero()</code> method to the <code>HeroService</code> class.</p> <pre header="src/app/hero.service.ts (addHero)" data-language="typescript">/** POST: add a new hero to the server */
addHero(hero: Hero): Observable&lt;Hero&gt; {
  return this.http.post&lt;Hero&gt;(this.heroesUrl, hero, this.httpOptions).pipe(
    tap((newHero: Hero) =&gt; this.log(`added hero w/ id=${newHero.id}`)),
    catchError(this.handleError&lt;Hero&gt;('addHero'))
  );
}</pre> <p><code>addHero()</code> differs from <code>updateHero()</code> in two ways:</p> <ul> <li>It calls <code><a href="../../api/common/http/httpclient#post" class="code-anchor">HttpClient.post()</a></code> instead of <code>put()</code>
</li> <li>It expects the server to create an id for the new hero, which it returns in the <code>Observable&lt;Hero&gt;</code> to the caller</li> </ul> <p>Refresh the browser and add some heroes.</p> <h2 id="delete-a-hero">Delete a hero</h2> <p>Each hero in the heroes list should have a delete button.</p> <p>Add the following button element to the <code>HeroesComponent</code> template, after the hero name in the repeated <code>&lt;li&gt;</code> element.</p> <pre header="src/app/heroes/heroes.component.html" data-language="html">&lt;button type="button" class="delete" title="delete hero"
  (click)="delete(hero)"&gt;x&lt;/button&gt;</pre> <p>The HTML for the list of heroes should look like this:</p> <pre header="src/app/heroes/heroes.component.html (list of heroes)" data-language="html">&lt;ul class="heroes"&gt;
  &lt;li *ngFor="let hero of heroes"&gt;
    &lt;a routerLink="/detail/{{hero.id}}"&gt;
      &lt;span class="badge"&gt;{{hero.id}}&lt;/span&gt; {{hero.name}}
    &lt;/a&gt;
    &lt;button type="button" class="delete" title="delete hero"
      (click)="delete(hero)"&gt;x&lt;/button&gt;
  &lt;/li&gt;
&lt;/ul&gt;</pre> <p>To position the delete button at the far right of the hero entry, add some CSS from the <a href="toh-pt6#heroescomponent">final review code</a> to the <code>heroes.component.css</code>.</p> <p>Add the <code>delete()</code> handler to the component class.</p> <pre header="src/app/heroes/heroes.component.ts (delete)" data-language="typescript">delete(hero: Hero): void {
  this.heroes = this.heroes.filter(h =&gt; h !== hero);
  this.heroService.deleteHero(hero.id).subscribe();
}</pre> <p>Although the component delegates hero deletion to the <code>HeroService</code>, it remains responsible for updating its own list of heroes. The component's <code>delete()</code> method immediately removes the <em>hero-to-delete</em> from that list, anticipating that the <code>HeroService</code> succeeds on the server.</p> <p>There's really nothing for the component to do with the <code>Observable</code> returned by <code>heroService.deleteHero()</code> <strong>but it must subscribe anyway</strong>.</p> <p>Next, add a <code>deleteHero()</code> method to <code>HeroService</code> like this.</p> <pre header="src/app/hero.service.ts (delete)" data-language="typescript">/** DELETE: delete the hero from the server */
deleteHero(id: number): Observable&lt;Hero&gt; {
  const url = `${this.heroesUrl}/${id}`;

  return this.http.delete&lt;Hero&gt;(url, this.httpOptions).pipe(
    tap(_ =&gt; this.log(`deleted hero id=${id}`)),
    catchError(this.handleError&lt;Hero&gt;('deleteHero'))
  );
}</pre> <p>Notice the following key points:</p> <ul> <li>
<code>deleteHero()</code> calls <code><a href="../../api/common/http/httpclient#delete" class="code-anchor">HttpClient.delete()</a></code>
</li> <li>The URL is the heroes resource URL plus the <code>id</code> of the hero to delete</li> <li>You don't send data as you did with <code>put()</code> and <code>post()</code>
</li> <li>You still send the <code>httpOptions</code>
</li> </ul> <p>Refresh the browser and try the new delete capability.</p> <blockquote class="alert is-important"> <p>If you neglect to <code>subscribe()</code>, the service can't send the delete request to the server. As a rule, an <code>Observable</code> <em>does nothing</em> until something subscribes.</p> <p>Confirm this for yourself by temporarily removing the <code>subscribe()</code>, clicking <strong>Dashboard</strong>, then clicking <strong>Heroes</strong>. This shows the full list of heroes again.</p> </blockquote> <h2 id="search-by-name">Search by name</h2> <p>In this last exercise, you learn to chain <code>Observable</code> operators together so you can reduce the number of similar HTTP requests to consume network bandwidth economically.</p> <h3 id="add-a-heroes-search-feature-to-the-dashboard">Add a heroes search feature to the Dashboard</h3> <p>As the user types a name into a search box, your application makes repeated HTTP requests for heroes filtered by that name. Your goal is to issue only as many requests as necessary.</p> <h4 id="heroservicesearchheroes"><code>HeroService.searchHeroes()</code></h4> <p>Start by adding a <code>searchHeroes()</code> method to the <code>HeroService</code>.</p> <pre header="src/app/hero.service.ts" data-language="typescript">/* GET heroes whose name contains search term */
searchHeroes(term: string): Observable&lt;Hero[]&gt; {
  if (!term.trim()) {
    // if not search term, return empty hero array.
    return of([]);
  }
  return this.http.get&lt;Hero[]&gt;(`${this.heroesUrl}/?name=${term}`).pipe(
    tap(x =&gt; x.length ?
       this.log(`found heroes matching "${term}"`) :
       this.log(`no heroes matching "${term}"`)),
    catchError(this.handleError&lt;Hero[]&gt;('searchHeroes', []))
  );
}</pre> <p>The method returns immediately with an empty array if there is no search term. The rest of it closely resembles <code>getHeroes()</code>, the only significant difference being the URL, which includes a query string with the search term.</p> <h3 id="add-search-to-the-dashboard">Add search to the dashboard</h3> <p>Open the <code>DashboardComponent</code> template and add the hero search element, <code>&lt;app-hero-search&gt;</code>, to the bottom of the markup.</p> <pre header="src/app/dashboard/dashboard.component.html" data-language="html">&lt;h2&gt;Top Heroes&lt;/h2&gt;
&lt;div class="heroes-menu"&gt;
  &lt;a *ngFor="let hero of heroes"
      routerLink="/detail/{{hero.id}}"&gt;
      {{hero.name}}
  &lt;/a&gt;
&lt;/div&gt;

&lt;app-hero-search&gt;&lt;/app-hero-search&gt;</pre> <p>This template looks a lot like the <code>*<a href="../../api/common/ngfor" class="code-anchor">ngFor</a></code> repeater in the <code>HeroesComponent</code> template.</p> <p>For this to work, the next step is to add a component with a selector that matches <code>&lt;app-hero-search&gt;</code>.</p> <h3 id="create-herosearchcomponent">Create <code>HeroSearchComponent</code>
</h3> <p>Run <code>ng generate</code> to create a <code>HeroSearchComponent</code>.</p> <pre format="shell" data-language="shell">ng generate component hero-search</pre> <p><code>ng generate</code> creates the three <code>HeroSearchComponent</code> files and adds the component to the <code>AppModule</code> declarations.</p> <p>Replace the <code>HeroSearchComponent</code> template with an <code>&lt;input&gt;</code> and a list of matching search results, as follows.</p> <pre header="src/app/hero-search/hero-search.component.html" data-language="html">&lt;div id="search-component"&gt;
  &lt;label for="search-box"&gt;Hero Search&lt;/label&gt;
  &lt;input #searchBox id="search-box" (input)="search(searchBox.value)" /&gt;

  &lt;ul class="search-result"&gt;
    &lt;li *ngFor="let hero of heroes$ | async" &gt;
      &lt;a routerLink="/detail/{{hero.id}}"&gt;
        {{hero.name}}
      &lt;/a&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;</pre> <p>Add private CSS styles to <code>hero-search.component.css</code> as listed in the <a href="toh-pt6#herosearchcomponent">final code review</a> below.</p> <p>As the user types in the search box, an input event binding calls the component's <code>search()</code> method with the new search box value.</p>  <h3 id="asyncpipe"><code><a href="../../api/common/asyncpipe" class="code-anchor">AsyncPipe</a></code></h3> <p>The <code>*<a href="../../api/common/ngfor" class="code-anchor">ngFor</a></code> repeats hero objects. Notice that the <code>*<a href="../../api/common/ngfor" class="code-anchor">ngFor</a></code> iterates over a list called <code>heroes$</code>, not <code>heroes</code>. The <code>$</code> is a convention that indicates <code>heroes$</code> is an <code>Observable</code>, not an array.</p> <pre header="src/app/hero-search/hero-search.component.html" data-language="html">&lt;li *ngFor="let hero of heroes$ | async" &gt;</pre> <p>Since <code>*<a href="../../api/common/ngfor" class="code-anchor">ngFor</a></code> can't do anything with an <code>Observable</code>, use the pipe <code>|</code> character followed by <code><a href="../../api/common/asyncpipe" class="code-anchor">async</a></code>. This identifies Angular's <code><a href="../../api/common/asyncpipe" class="code-anchor">AsyncPipe</a></code> and subscribes to an <code>Observable</code> automatically so you won't have to do so in the component class.</p> <h3 id="edit-the-herosearchcomponent-class">Edit the <code>HeroSearchComponent</code> class</h3> <p>Replace the <code>HeroSearchComponent</code> class and metadata as follows.</p> <pre header="src/app/hero-search/hero-search.component.ts" data-language="typescript">import { Component, OnInit } from '@angular/core';

import { Observable, Subject } from 'rxjs';

import {
   debounceTime, distinctUntilChanged, switchMap
 } from 'rxjs/operators';

import { Hero } from '../hero';
import { HeroService } from '../hero.service';

@Component({
  selector: 'app-hero-search',
  templateUrl: './hero-search.component.html',
  styleUrls: [ './hero-search.component.css' ]
})
export class HeroSearchComponent implements OnInit {
  heroes$!: Observable&lt;Hero[]&gt;;
  private searchTerms = new Subject&lt;string&gt;();

  constructor(private heroService: HeroService) {}

  // Push a search term into the observable stream.
  search(term: string): void {
    this.searchTerms.next(term);
  }

  ngOnInit(): void {
    this.heroes$ = this.searchTerms.pipe(
      // wait 300ms after each keystroke before considering the term
      debounceTime(300),

      // ignore new term if same as previous term
      distinctUntilChanged(),

      // switch to new search observable each time the term changes
      switchMap((term: string) =&gt; this.heroService.searchHeroes(term)),
    );
  }
}</pre> <p>Notice the declaration of <code>heroes$</code> as an <code>Observable</code>:</p> <pre header="src/app/hero-search/hero-search.component.ts" data-language="typescript">heroes$!: Observable&lt;Hero[]&gt;;</pre> <p>Set this in <a href="toh-pt6#search-pipe"><code>ngOnInit()</code></a>. Before you do, focus on the definition of <code>searchTerms</code>.</p> <h3 id="the-searchterms-rxjs-subject">The <code>searchTerms</code> RxJS subject</h3> <p>The <code>searchTerms</code> property is an RxJS <code>Subject</code>.</p> <pre header="src/app/hero-search/hero-search.component.ts" data-language="typescript">private searchTerms = new Subject&lt;string&gt;();

// Push a search term into the observable stream.
search(term: string): void {
  this.searchTerms.next(term);
}</pre> <p>A <code>Subject</code> is both a source of observable values and an <code>Observable</code> itself. You can subscribe to a <code>Subject</code> as you would any <code>Observable</code>.</p> <p>You can also push values into that <code>Observable</code> by calling its <code>next(value)</code> method as the <code>search()</code> method does.</p> <p>The event binding to the text box's <code>input</code> event calls the <code>search()</code> method.</p> <pre header="src/app/hero-search/hero-search.component.html" data-language="html">&lt;input #searchBox id="search-box" (input)="search(searchBox.value)" /&gt;</pre> <p>Every time the user types in the text box, the binding calls <code>search()</code> with the text box value as a <em>search term</em>. The <code>searchTerms</code> becomes an <code>Observable</code> emitting a steady stream of search terms.</p>  <h3 id="chaining-rxjs-operators">Chaining RxJS operators</h3> <p>Passing a new search term directly to the <code>searchHeroes()</code> after every user keystroke creates excessive HTTP requests, which taxes server resources and burns through data plans.</p> <p>Instead, the <code>ngOnInit()</code> method pipes the <code>searchTerms</code> observable through a sequence of RxJS operators that reduce the number of calls to the <code>searchHeroes()</code>. Ultimately, this returns an observable of timely hero search results where each one is a <code>Hero[]</code>.</p> <p>Here's a closer look at the code.</p> <pre header="src/app/hero-search/hero-search.component.ts" data-language="typescript">this.heroes$ = this.searchTerms.pipe(
  // wait 300ms after each keystroke before considering the term
  debounceTime(300),

  // ignore new term if same as previous term
  distinctUntilChanged(),

  // switch to new search observable each time the term changes
  switchMap((term: string) =&gt; this.heroService.searchHeroes(term)),
);</pre> <p>Each operator works as follows:</p> <ul> <li> <p><code>debounceTime(300)</code> waits until the flow of new string events pauses for 300 milliseconds before passing along the latest string. Requests aren't likely to happen more frequently than 300 ms.</p> </li> <li> <p><code>distinctUntilChanged()</code> ensures that a request is sent only if the filter text changed.</p> </li> <li> <p><code>switchMap()</code> calls the search service for each search term that makes it through <code>debounce()</code> and <code>distinctUntilChanged()</code>. It cancels and discards previous search observables, returning only the latest search service observable.</p> </li> </ul> <blockquote class="alert is-helpful"> <p>With the <a href="https://www.learnrxjs.io/learn-rxjs/operators/transformation/switchmap"><code>switchMap</code> operator</a>, every qualifying key event can trigger an <code><a href="../../api/common/http/httpclient#get" class="code-anchor">HttpClient.get()</a></code> method call. Even with a 300 ms pause between requests, you could have many HTTP requests in flight and they may not return in the order sent.</p> <p><code>switchMap()</code> preserves the original request order while returning only the observable from the most recent HTTP method call. Results from prior calls are canceled and discarded.</p> <blockquote class="alert is-helpful"> <p>Canceling a previous <code>searchHeroes()</code> Observable doesn't actually cancel a pending HTTP request. Unwanted results are discarded before they reach your application code.</p> </blockquote> </blockquote> <p>Remember that the component <em>class</em> doesn't subscribe to the <code>heroes$</code> <em>observable</em>. That's the job of the <a href="toh-pt6#asyncpipe"><code>AsyncPipe</code></a> in the template.</p> <h4 id="try-it">Try it</h4> <p>Run the application again. In the <em>Dashboard</em>, enter some text in the search box. Enter characters that match any existing hero names, and look for something like this.</p> <div class="lightbox"> <img alt="Hero Search field with the letters 'm' and 'a' along with four search results that match the query displayed in a list beneath the search input" src="data:image/gif;base64,R0lGODlhkAErAfeaAFdXV9XV1Xl5eYqKisTExEBAQJmZmdnZ2Xx8fPHx8Z2dnbm5uT09PVhYWEBwny0tLeTk5FRUVOHh4ampqcjIyGFhYcDAwFtbW/39/YSEhDg4OOLp8LCwsDAwME1NTSsrKzU1Nc3NzVFRUUFxoN3d3TprnK2trUJCQkdHR29vb1xcXJqamnp6el9fXz4+PnV1dby8vPT09K/D18/b59Dc55CsyMHR4GlpaYaGhp+fn66urnFxccvLyxcXFwkJCW1tbRUVFdHR0XZ2dqWlpbfJ26urq9rj7GWMs9zl7TZomkhISCYmJigoKLKysnJycjMzM2dnZ46OjmNjY7S0tOfn55WVlWRkZPb29kRERM7Ozuzs7PPz81JSUqampkpKSqCgoLu7u4yMjOHo8MLCwqK50Ka80n9/f9LS0j5vnzNmmTs7Ozc3N7+/v+jo6IODg1mDrIiIiNfX1y4uLhAQEAAAAB0dHRoaGv///+/v7/v7+woKCqOjowQEBJOTkyEhId/f3w0NDSQkJAMDAwYGBhISEg4ODvv8/cfHx5eXl6S70f3+/pCQkEJxoOPj4+/z9+rq6ra2tk5OTtvb24CAgPX4+hgYGGpqaiMjIx8fH/j4+AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAUAAJoALAAAAACQASsBAAj/AO8IHEiwoMGDCBMqXMiwocOHECNKnEixosWLGDNq3Mixo8ePIEOKHEmypMmTKFOqXMmypcuXMGPKnEmzps2bOHPq3Mmzp8+fQIMKHUq0qNGjSJMqXcq0qdOnUF0qyrQlj6KoWLM6JSCgq4GrBAN0FYCoZgIFLlyoYQAADh6wOCEg6ApJq927Ayc82dsCrkALe58U8OvSkAE1TzoE3qvGjVWcZ9bsdYO3cla9iSsQBrx3sMwcexUHVqxYSCbIkp9Qtszaqd4OHSpgKMhZMGGWijyQBjFJAQ7Eogmgnty6+NIJpGXTDuwZ5h/YT1okUES9kQjYHb7ejEzcuPeiipBn/55NsHZzgZkIwIlQYZEE8gIlFTHRJAGFHypWZAKbKYsbFVy8AEMMtxGkyBikIQCXImBo4OAPfm3BRgZcVGBAG/AJpEgMTSCgggg34BBHHgRxMN8YZ4mQAg9gGXLAHj9wIcAE0w3EnWp58PCCCAjAcNp3QOoUXnIZ3mEeXEFEMNoTarwQg4ZDwMbACyAERgB1bIiw2F4eTKCQIgmQpoYABwyUiSQkSKAFWAdGsqUGk/woECQoJLYYCJYkoGFiHUTAhZ0RnPZIClVi18EJCtiYmhNQbAkACQUGKalU4vXJw6WYGsAcWEEsZugTQlilSJRbPoHFFQdqUCppTSykpGhPcP+xyBgS5IEBBtQJFIQasC6WwUBauGBnqQpcpciwfD7BgiJ4KBFaqSZcdSOfhsZG4qTYwjTksKSV6gJYKQQmQghTqAobJLiS6ukNhkCwBnYguLEIFmJKoBAbyNq5hgpnEGSIB3bukMUUiO31xx2KOJEcAQEIgZ0Hsx0rmmK88nDHIsMiwoYK2HEhbWodqIEIDwgsFkC2KLe07afVwvbtHX9U+UQFj0kC3AvpwkoABlSQcAcigaEgAXWP3GAnHAph0AQWz3argRuo3gGJnSpcgSsM0FlyBwYcLPIDFFsIpEXBTxhrZwdOaJFHFoYoggJsasShodFPKEGFItwp1sRVV2j/uRcMKQee0sogMKDG4QwwoGpnV+kQWhVbRL5FBYl5PKpoOxTU6F4UEEQCr7F+iUECfXDBwNmhfXHVItBBEnkMW4TGwBUI5xoDFWcsUugTp0n8BAgH5HpHDIFlPlAQbKxJ3RmFnoArwpNgN4Xg1Je08gWNZK+9CYG9bIadBXggvgfmqkGdul0YeF0HDPiVgBeBhc1QJhCMYQZwiamBKgt2YjE+wBS729YIcINInGA0iuld/9pAEB4E5lcaEp5AmJcYJxAEY3tpVfU2CJKVVaAgimADdl52AdR5SjFtUxfgBpIb2CjBQFfQjWJ8ZhBDkCALbODAY6iTgByY6wkW+4EJ/0MDmzX8AUw7WBLIniAqPikBDyUKDNISQsEOTIKFfcCOBjnIxY14EIQiVMzLBEA1BJiRBWhE437U1TkWAoBiC2pWaNZkkLGFJghsUkTfRDMFRZBRMT84IxrNOIlH5MFNjDEDD2JwOti0zXce0NPxAoMAguQhBpkwxAQLtRqBVCEwfeyiKDHyRQOF8Qkv2wN0yjKQOLSBTeoKgYEsQRoOECQL5lJC20BoCADYyQwFwcPbYDMGDMDBTgsYSB6CQEeYLc4LDLxDAvC3J8VEQn7oCQwA4PIFLETACq2qYifv8MkMFmmU6HxIKVmILzFShwTm4gIdSSCZE1DmcnuRJUEUYP8nDWRhNpJ4Y2L6kBATQCc7f0gAHs4ghMCs4W4LgA4KHiGQiHYACwLIRBVVcK0F7E6TvovEkzSEgUhgZwi0e0QDEgO8O4iTIOXsQBPOmc6afqlSHyxIO1EJFiFSzABuWNwTFnE+0egTWKDrwBpQoATJKEYDjUCIInpJLRA4qFCw+dVU3QQbLCgAAal5whAw0IgfuuEPVXDqXqYT0pEOZA+jUYMK8HcBaXESpnzam033ypB1DmSnL7tDCJJaLRW8Ep9POKqGeNDIE2JBOArJQliXpBgRCPAOjC1VYqBglUxYwoSkgQ2L2lqQK0ChW0QEwSFm89KBfFIxoeSrbA+iiCL/kEYKBgGMOwcSgAhMVg1QeAvCuhAYxQ7kDy0gm1K5EASaFqQRVuDVp04ghC1IcAwyxI4arCDJO2SCcnzSwA7AEJgwUCcwHnCrhjIxCWENKwKrtWtixvnaJ8x0tvg1UALiIIkDQMAgMZAEfyXBQkVsIQ5F6EMVFkCCTDxPmnGIwwFod5BMNAIGK+iDDkiAqkgVJA+N4EERwtCHLvCgDdfSbxxMUAUFwKARmiRIJoJQhCqw4Q+ZyMMBIkyF2ZBAwn8oEnV4loUh9AESAbAuf/oriWiKTcAHSIBz81vTIUvQQIrA1W2y/GAsezgjWTaEmG91ZRCWucDGIjOaqfNlK2vZ/0C3evOaz0zlOtv5znjOs573zOc++/nPgA60oAdN6EIb+tCITrSiF83oRjv60ZCOtKQnTelKW/rSmM60pjfN6U57+iAbkAEZRk3qUpv61KhOtapXzepWu/rVsI61rGdN61rb+ta4zrWud83qMswgJDRAQxqGTexiG/vYyE62spfN7GY7+9nQjra0p03talv72tjOtra3/ewafGQDwua2uMdN7nKb+9zoTre61/1sG7D53fCGd0NkMGwiiPne+M63vvfN7377+98AD7jAB07wghv84AhPuMIXzvCGOxzgYhhBGt4Q74qzuSGKSMSw8zBmQ2DA4yD/uMhDTvKRm7zkKP8/ucpTzvKVu7zlMH+5zGNO85nbvOY4v7nOc87znfu850DfuSLekIYSWPzoC7mKxtNgq9k4fWtQf7rUo071qVu96li/utazzvWte73rYP+62MNO9rGbvexoP7va0872tbu97VsbehrQcPG65+rdSVf6xm8F97f7ve+A/7vgA0/4wRu+8Ig/vOLZfhWiG712xro73j1srDssvemJz/ziN6/5znP+854PPehHX3W5oyFiGkp95Okcwdpdnu+kj73oZy/72tP+9rbPPdUbX3TUy7vitIW85feu++Lj/vjGTz7yl698XDn+zX6xuEHurqHXN5/52L++9rPP/e1fnfclUPP/giR4cQMh7Px6Zzrsu89+77f//e6Pf+LlHv6451F45S+w8Kljffj7X/4A+H8CGICo93wCEWdatnrnx0L7lyv9R4ADGIEQOIESKHr053QIyIDol0cLyCbDp34UGIIVKIIkOIJgB34YiIAJiHfot4EX94AmWIIyGIM0GIIXuDUqKFUNaH4wOIM+WINA+IO6h4I4qIJGOHnS14NBuIRCyIROGHs3aIRGCHWpx4BsooRNmIVPuIVaOHZEKIVgCHmTd35YyIVm2IVnmIZSF4VgOIUe6IIfiHlXZwArkAcG4AJCQGBBYDRh8GYYMAQVIAcoUARXgYaGqIaIKHtf2IY5uHpj/1iGsyEHc9ABdGAHlYgDPgAEdEAHXEAif8AEdPABT+ADdAAFiXiKh5iKnseGjBhntTN9rkd8XCcHlSgJGCAAdMAHBIUHfgAEeiIEdIADWXYAekAHVoOKyKiKygh3i9iKZHZ0DiiLV0eLbCAQV0AHgbAFuOIBgqAFUgM158cAdNAIy1iOyXiOYseKzohlC1h90oh1tAhSikAHcsBlAEAHa4IBf6AALNACT7CJ74GOAmmOBAl1zbiOqteO6SeH8DgIBEEHHYCDDUAHUEQAPiAIekAIBaCJAVmQHjmQyaiOrdh6+BeLIDiLDjkQEBlnE4kHmUAIdKAACaUIH0AHkAKSH/+Zk4h4kCPpiPIGiXcgBykpECs5Gy0pCXQwBx2WBaQoN7mik1CJk08okoz4isEHlEL5kB3Ady0ZA5t4A5KwAjBJB4dQeVF5llIpgjzJiNAYjSc5jUN5B0V5By2pCDBQB5s4CFagAKVYiGn5l2hJglTZhuxYkkBZIK7IQnkQByGwH+wYmIAZmQG4loSpevEWh+s3dbcRhrT1brjymVkWmqA5mqJZmqR5mqaZmqi5mqrZmqz5mq4Zm7A5m7JZm7R5m7aZm7i5m7rZm7x5KwbojIlJfSB0mAUhnMiZnMq5nMzZnM75nNAZndI5ndRZndbJnMGJnC1IGAuZmbtHENcZnuL/OZ7kWZ7meZ7omZ7OmJ3CuX/saJwHqJ7yOZ/0WZ/2eZ/4KYXs6YzUtyBk+I6aGZ/5OaAEWqAGeqAFSnSnl4Ij+YocyH8AmnUIOqEUWqEWeqHK+XzJmZCV94IR6nRchqEiOqIkWqL3qaFF2JOSV3kIA5Qm+qIwGqMyCp2OF3XCuaLbiZlWF6Iz2qM++qMzqqHaWYUKCKFvWXVAmqRKuqQUup8q+ntuyZCfyaRUWqVWOp9C2p7tqIHdaXVX+qVgGqbTiaLayZ14VwbDRgmwx6Ni2qZu+qZSmAdZipDRh2VEMGxkwHGiCad82qdtagQOkAZHYCspWpXjN3mOwAjstqiM/9qojvqokBqp6JYEEuBxhUqYb9ihV7EBRCepnvqpoBqqojqq1cYIMmAVG+qCkocwMYABV7ABSBCrsjqrtFqrtnqruJqrurqrvNqrvvqrwBqswjqsxFqsxnqsyJqsuypl0bShVzZ5h7AHbYMBeVCt1nqt2Jqt2rqt3Nqt3vqt4Bqu4jqu5Fqu5nqu6Jqu6rqu7Nqu3ooBZ4ADyimG+Wcsh4AD5+en+rqvYXqv82p+FXevbMqvBFuwMhp1/vqvDrp/93qpBvuwEEuiCZuqmip5DRuxGJuxGDqxZeqTd3exGhuyIkugHNueHvtuIDuyKruy6lmy68iCDIuvLDuzNDueLv/biixYdwiTsjXbsz7rnDdrqMLngjz7s0Z7tIwYtJh6f3VXtEj7tFCrtGAobwDrtFB7tT8rtVJoZtAqs1j7tUartVO4ZqpntWB7tiMrtjkYQRZntnEGA35yAXgghYvABVwwAQa6TGi7t+GpthlIr/LmtrcSBZsoCDujglfwAJt4RQSqBR7QA3wbudTpt654mfBGAPLaioS7uDkoCYOwuA5Ln2NAB4UguaYLnZT7jCwauJnLiIQrCHRwCU0XZz9AB7DLuAM6uqV7ury7nKkLHx4rEIKLAYSrBptYTHGmBZ+LAnSAuxgwBm7gAeGTAw6GgBbQAgWwAxTwBwPAAbcyBnD/EAAQsAgewAVV8CQIiAdVAAAngAA8EGccAAW2CwdVEGdnEAYAUAAn0AfV27v++7skaWbq4YyEGwH3aAUY2AR00AAX0Lxb0wYXALubuIko0HR5cAMTvIkRQAcAcCsIQAcpgAkZzADaeCsLIMITrAc40KpckMF0kAdX4AR84MIf8F/+27sA3KHsOMChO7h0EAEBQI+ncSu1ywENzLibOwGZgAe4SAc5cCthsIlmoAUEYIkcfCtmsImAMARiAboYkAlzAJGSkAAssImJAgFDQAc+cABlcgiwuwiwgwifW0k3zLuY+686m5A87Lo/nAlLMAhBRq114AMScMRbQ4nFciuZ/+ACdCACGNAGxRgqbSMJYdzBGJDFZKnIDQwE1eoFdLAGbPUzghAI35uUYMG8P0AQTkAHGtDDdfy1v9ufAbzHbUi4XGAIG4wzGAAJrIwBhjw6WRA2GIAHJNDCWPC8glAI+wEWH2zJWXwCA/GHpJsJWlCMCoAH2LxQn+szussfQUBRoyMBZfwArvzKV3vHeKzDlUfLYFjAdzAFdDAI2ngCdCAchrw1efAFEXAJdhDGdOA8HEAHT1AQE3DFl1yKOPjOdAAIV3AApEgIlRDRldADm2hLozsHhXgrTdACTGAHhAC7H2DOppvDcHhx7CyF7pwJlUAHYNAGleAHW/PLkICXm//oB15Aic5T0GugggHtzHSgyxq90FcQBJ/7AQ9w1EgtB2PVzVsTALS4iXaABQUQiiItuQM8r1C6znDAoEZYwLcCjAJgAXQgBbdiyHmgiYHQBEqmAnRQAHfABoJQBylYBQadxUCtNEJNAqR4ACrYvxd9FXkgwpUwBOAcxSFd1Xw7vCpIfh14FSfd1T88G3AtBw3svb7swIegxlmQK5mguK3s0HQwPbeSB//o03etwAydAMWIM1D3B2tBAc9LB3pwFXFQ0U9ZAbGL2InttUM6hlrN1Sro1RhQzZs4B8JsyJk9CGXpXZMA0tS6wZhAAFsAAcBY1z+NgKhtNVlMCGBwKwn/YAl0AARWQwGb+AdXUNt0MATo8QWkCLm6jbZX7az4p4CPHdyRLRAtsIksgINmbcU7IAXFuInK/MWBULgZbNrYLdSzQYkQKQKaSAdlgQEHMMGCgAdLsImW8ANjuYm0895gi87J6dvUV98IKNwYgJQ+8E+z0cC/8rz/uImE8AJBEM/9QlZJNAhWhAN0gMAHfdcLMM23AgE7QIqbuAQ5YMFwEOABQALMu4l6IAWZTQet4uFfG98dm8e5QuIZmJiuyHcCqo9sQAIZ8sVZQAKEKhC4aEFdvuVdbggBsACBrIIHpidBzgYBcOblTOU9q9gI6NstqOUj2ZxUMAeFMOUYoNcx/5nniQmeeo7YVk6nJZ3lW63o1JkJGkAHdVAFHLAClDgH79HooI6cOYyEv03p1HkFTCDBtusHchPqrt6KII6cjM2BgD6eeMAGVYAAi7AAGPLqvg6GACyGOVrr5Gmjv37sKhjrJjvfwkfs4WnqyA7qsayzOuvs0X7t5qnsLzuGr2jt2P7t4fno/Entfz7p4H7u6qntPRnpjm3u6P7u5SnuT4qj7Q7c8H7v06nubOmftO7u+P7v+b7V6SzL9Q7tAH/wUqjvS/ugkm7vCP/wzijv+96fI+7vEH/xEd+6V06cDW/wGH/wEt+Gfr7Ok7AIUXDyKJ/yKr/yLN/yLv/yMB/zMv8/8zRf8zZ/8zif8zq/8zzf8z7/8zMPB7xtsux+B4fgBjDABkm/9Erf9Ez/9E4f9VA/9VJf9VR/9Vaf9Vi/9Vrf9Vz/9V4f9mA/9mJf9mR/9maf9mi/9mof9Xsw9Ntud5GHuUPW5ZJ595CZk9NuhVV4CEhj9wcYzYIf+IRPhYYPH4g/+Iev+Ilf+I2/+I7P+JIf+ZQP+Zb/+Jg/+Zev+Zlf+Z2/+Z7P+aIf+qQP+qb/+ag/+lsT7CJOHQL78bDPiCEfhuXH8Xwe+w9/+6qrzrXz+rj/+3Gm+xFD6mzm9x4P/O8++1JI6gby+seP/N+u8LTfgvQqsBkN/R+v/G5I8Sj/C/fYf/HCz/3w5vvf//HCz7YwqwjGX/6wr/2NiP7jL4wOz/73Lv1bS/xgYf3PT/++DhAE4GAgWNDgQYKKFC5keEfhITh3EB4kIMLiRREVhOh4NNHjFSsNrnhMYJGER5QpMSiw+MIjAotgVM6kWdPmTZw5de7k2dPnz54EcOB0eMfo0aKK7hzCoUhlETpRpU6tQ0LizC119CS4evBR1CBAC1qJKmgLQiqCouboKtbtW7hx5c6l61YgUYZ5HSpi2nYi1CULBC+AlKPFIDoA/HrMCijBxDtawL6FItUNwglSvyyu29nzZ9ChRWMQijOvUqV7+TZ9SgcE0qMsonbEqpXr/8SvdMK6reyDDqCRBqXQUZtjYp7RyZUvZ7787k3VSVWv5mwQ6mvYd2BE5YFBQoZFB/sM0IKhcYIuEbCQL5g7hAIPKMI0QgjmhRoAK/J0jYIDwqQCdtCiMhUAGSQEgzIBYhA/6DCuIArcEEENDxAJDoMFMjhDAhywEGGFTJoTcUQSSzSor5sUSuq01ZxK6brs7ogiKiowGCOqEAvSShLz6hhEhKkKWYCg3NSYyg9ICtIihano+ICCguagw8ioLKjshgboCK+gLuhQggEHCbpiuCY1oA+DHehoQUqpsLiiOhPjlHPOn56r6aiGVuQrotZAOM2EqNQg6EY6ciSoDkB4zP8qKg+oIOEJOnx4LDc6NKDigEro6KFGDCqjI4orAuiAjkqQw4DNQU645Iorc6BjjYLyeICOLMB8cAU6+FAgjysyiEoAgtKkYw4d4nAiqgnoVHZZZnFiCi889WoRAzih8uEJbJ/ooEE6CsmCWkINxWDHOxZlYAuJqACEjhQwyM0L5MqdNQx3CRkEEhUfqYMOYE91baSRyLrhj6gCIAgCID7Iw1YMYpg1A+SU+iGxYOkgxCoM8vCADhea9fhjkEkbCLo88XSIKRVRgkoQQArxLSpMbnjEKBtxNAhRHmOoQxAer+qD4zxym8Ig2RjA0Mk28NBC6RlPQE5KJ7q68o4C6BD/gqAm6LAkDyMfjCGITCRKQBIE6BChYhW6woEOJuAM+W24R0PRpoZYpK61DiCgAoIF9p0jAJprLvTmRHsk5CyC7siCjgeukIyOkwoagjgM3KBjECCAICTzdTsIUUoDuhL4jhvXCBEFOhbgOkyJMtmjgTqAAESts+9I06WCfg7E7bh7910uO2kyisVoUW7tidQU37cDxAUXd8eGMbED3YIIZsJxGgu6g4Oo8hgOkA/k6EB88SP5nA4dDLqyYa3aIIEOO65Y/UEClpCqDiW8MJvaNCcx6OdL/E6AA6TLs1JkNxXtiXcwwhMB+FCp4BAqBgaZQ6LuEANMzOE2BIHElIIW/5UDaK8KjLvDIuhQgDwoBAOKyEO8/MUB9dHhBnfIg/4WYcKhzA8DeMAE/CaAhxWOMBIS6Z/2AEhAJCaxTiOzyV6mk8BpVcs1sMkDWeiwB4IcIioQKEgAfpOzfbGhKyfwkiEepwDtAYAOFcCAFqeHlCo8QQpPowMMC7I+DEyOEFjQA+AywbA4+EAQEFjIHYDkASLSwX+JO6ISHfnImsztTqg5TVFQphSVTRE2MbBfDyTgnai8IERn2FfhMEiHOhgMA3sgDhsw8LgPnCQPOtCDD7rDSTpcgApGOYRvbkAQKdmRIOsrF5sCcRYdHkCQWTBKHtZGBxRUbJHUaiQkrXnNE//hgHcHmQ5sFgKRBWoSNjqIChb2kyXi9EAqFjxlVArwgahAgUhTwQI8T1gQV9FBD5HAQlTqcJY7BDOGvyTIDUJJkD+GCQ8NEoQVLPHAqICAf4o0Ih0CiE2MWjN4NCmZdJbCmpRwDzuwyQQXItUdKrQAokxYAAoAcZIr+KEOQ1DnsOAAUDxEZQVAiIoP4PCmgsBgVFEZhBSsIhEpDe2OMiwIJNTyyYwZaQgEyULVogKIHxAACIO0HUUThwjGZVSsjpSk8ChZt5NpUyUxihG1CLKFMUigK21RhCHOEIT9SESvDsFAEBCUmsQZBQ8E4AEeAJs4brrVIH7xSyPYcIDk7ZX/sYoda2UFuNG1OhE1w/smSHuiV+2Fti1I8Uh0AsdN0soltZZl7TUxq5JCJrAoad3maLLTWtzm1jOlgQ5nY7sX4+lWuMMdqwGb+MQngpO4y2XuI1+bkieqCE/Gq21zrXtdOfGWbgjsbMqw+13wKuu5KNGs3coaXvSmtznnXetZWRRc9cZXvqFhL3RLljwFzle/+53LeD2SJ/dGkb8DJjBPtDvJ6Er3ktUtcIML7F/ISNe3wOWTgy184YnUFyXEkw58MfxhC2u4tCar291AfOIGQxgh0ZqtajyMYhjPV8SQkU5qGDLjGOf4ujjmJhSjewgzhEHIQyZykY18ZCQnWclL/2Zyk538ZChHWcpTpnKVrXxlLGdZy0/GwVBI1s2zHsINY7BAmc18ZjSnWc1rZnOb3fxmOMdZznOmc53tfGc851nPe+Zzn+O8By/fKcGxpa6ODR1eFR+Ew0lZ8KEdfd0Dm7XEN1broy3NXOPWxG7F8+ylPZ3bRC82RoSu8KdNzVoei9qbUCz0qV2d0VAHdtWybfSrba1RJgo6WjZ+SKlv/Wslplp7u/boi4F97N8JW9ax3ayJkf1s38U6sGiltIugfe23KZtahdTs8LSNbXCvt9Ka/m2zpxVudC9L2tue9Dd9nW54l0jbk0aKgD1yAATkO99uQAQkLhRvgItF2sPzaP9eaj2RLzRJKnP4QfMC/vCdrDs6AXa2R1hZCBWo4AKReEKm6PCEx0Bc5M4aN0fNfRpjH4SVasCTu2TzKQaPXOQD9+19lZuSlcOGIGoEwhYyAYMx/BsDFGDDFrQAgzNkIgR7QMQCaFOQGFCgCItAxBRC/koYHOAKMEAEImAwkqNXYQ9nOEgeQsCBKvRBB1yU+X4zbdaaG5w1cMr5UYIalSQRgg5jSJAPCkECMJhNAFNhwtUDsK+p6GE3gY/AxKTygi0wQSqDgEFBIDCrqfggSW2fr8TbnZqDIyThLD/tDn+FATVGoCu+8lzgH+iFMFhCD3SQg6lmtQZEDGESeo8mBgL/zyg4XEAQPmACIASAg0DAD3FKoMMSFtGFAdih+ULnPKIDTe5N95p3dUcIYtIGFTqcaQvr2sx2crntGfmAR9uxQxuuMgW1UOv3EUDOFpLPhzFIhABROcMdQsCdo4CAdSmP6lOvt5uJFqs3S+q0ici5iciUs8kE39iSQ+ADINgP8zuJZrocssMDNoCEwIkDxHiT35MEFdmYOYiVqICBCzqEZLmKK4AnCIi5AsStSENABAKukmvAKTkOxEAAalkbLyCIwbMEiXA9U6EWA/kWo4CACXADK1CCmoqBOwi8QaAWh2gBOhjCglhBmsEDDoCDG/CAHqKDGaxB9Fq3SuK1c0OJ/5WbCAmIij0wigOopRhQkNQhiMDrgbYohEH4FgyAA6kQhDnwOCrcQyy8gwo4v8SJCpnAgAmAKEEoBDtAjDNBQ/DStonTk4rjQUHBDP6TiCuQvDAgJx8AKEQ0CD/8FkR4IBHoAh74gxBAjEPUFCxUBC28AO1xxDtoAt/QgBw4BEloA8mDKkz8rnk7ObmzNovrwYNIACPxgq4YoTowqQFIjVQsiFXMg0ugA3NKDTZQCyBCxKNYRF1sRDqQiQugA0zgCsHSu8g5RuySuG7Sk5tzw0ppIX0kgUwRBBaMlXXpFnf0PVtUxT+8gkKgAydQkRiQg9moQlscnlzcxXTMA9TxgP+CyASrUiV53LEdbK9dI7S5w0dAUAMNWAMQWIIHEoQ+CJsYApqryEaCWEUMyBJAQIAJcALMo4MQgMgeSERzpEiZeKYbKAIz0ACpUKqOtC5N7ChGawpM8oiEa5JCqAM1SBaEmIKoQITAkclTGYSwSKj7EYAe+gGfvMWgREeZyAQPUIuoAIKN80YaXEqMukHYYjaU+8iDuAIq6Eu/XBpx0R4KiBQqzEgqaIOD2Jt4uYI46II9IIHHwAMqmJlM6MvkSQAqAKKC6EuXzAQSMIEVCAAg2oLDnEu6dK1ckzS94KyU44k7GLwdoCzEWjHZ/K/IKr3QGrYVSp7TbC67TAnuQo3/e/QJSYABExoEHhit2lzOEbut48LN3hQuz6M4HXQK0zwIA5CKFkjC6MS23yQvitus0NuJEIiESBiA2ezOa5tOCfOt4fQJ0LpO9XS0ZGzPzfooZpzP6GzK6HpK+dRPiJvOgusuAFXP+uw2G/u2Ah05TYy7FWnNBcVEepSWG3u3CJXHpqyk6RrJC+3IgQvOh4DK/+xQcBNQBFJQEo03/uQuCE3RtstQCcOv93TRAlRDbgswMRsMHd1RHu1RH/1RIA1SIR1SIi1SIz1SJE1SJV1SJm1SJ31SKEXSL9BL8Bw0XpqEPki7PthSLu1SL/1SMA1TMR1TMi1TMz1TNE1TNV1T/zZtUzd9UziNUzmd0zINAyotLftkNahkThqdudScCQ4TT6iMyj7lvAYluBIbz0Jl0DulsW7zLYFYiEWtvgkd0BAl1EmVuQwtr2qzzkyVOZpzL3sc1BH9VFc7wPbKwRbBVFMNOBtdzadk1VYFOBiFok6dVZGrT1i91FLF1U+jx+wQSVn1VXQ71HrT02ElVnAz1ppbwGRV1vX808wiNhdrCrdpBB3QgSYITKrK1jiA1kP7zubcRNCz1pSYkcv51rJzgaiYhF4FV0STVuiaMNlqEbdB1yvyiwTQO0V6V3hFxkZdMTCbjkiFExmRCoxUOalw13+NMRjlrNmyV/KakW6kA/9O0RFU6tdYuQLS9DmEyIQY0IIYaKEryJFMyIQWioFH8FgMANk2GNmy41gqSADqa9jfEdeJoLYHNdfSmpFIsB96KYjFeYB1ZFgMaAI1sIOVZILQaao1mD0gUIMc8AMjxIAwwIQiaIGEFIQHOINGKAC9mwMA0Mw2KgA/8A0+8INJ4E6bjTZ5Bc/Pk9iepQMuYCUXSMIBoIMwKFqJ0Eo66AAvQIFu5ANJkIg4kJIlQAE1QIzEkIiymQM+eAAX4KkOmAMgYIAnQIw+IAhJeCAm8AIvsCdEaNsBwlmEoLcNfdaD5YIEmIPDKYgCOBC+rUmtyZFHaJAKuIMrUCc5KI9MwBX/isEAM4iKH5AfHkAMHziDPMiERewAgljED7iNK2BXpyHdm31bPLVUXp1Yul0drPwDQeiBGOBbGbkBjsQAFYAmDDiDQRCE3SAI/QEAghjeQAgOLdgX3MEA7uGDjMkBS+jJggAUNWBb6w0Z0+2xel1Gg50RLlCEvFUYDHgBvb0D8iUILZAEHlCAC/CNE8AArVyCg1CA4B3e3KWWBGgQmZAINogKxdICWRyCG5ASDSDgAv4YG+XEaltgOlC9NiiYLVgCPXiT2cWDFtCKJungLvnEguAe+RVeOohNgjhh3SiIFaYDTGIBPwhIqVADbq1hj2nQRZNbyJgR1buDSKCDKggA/z1AAYmY3Qi4HBSAgkUggEXs4A76AMpipSYe3vyV4vetYqc4limRggGAAUDRgC72Ymbhz0ET4xUjY6PoEhHI2zBo436lAuJogr2qGqM53kHAg65Ikz2mgz5ukD+OCkWIKTTeKxMyHUV+G/YMMF7i2THeYaOQBB/wAXWKHL5dgEiJxxBISIlKgB6KgBwhAN8Y5VKeYoIA5ATQAz7Qgqs4AHUCgUR+ZTrR1TV0ZG6CZBqyH7mkFr6lAsTYgTPIgiHg15/EABiYPRFQADfgV2UuCD+mYlS+gm7kghAIAA6AFMapWWzO5oDtsVFzVh0u4zsAlDwU537tqstBXl/RgzNR6P+rqowWmF9SpmdTtmcrPtjLeRkcIAQ9AOWA9pgDXixV5ebF4oEw0ORmCoNF0Mw7gIQwoIDWaYIXUAEnQIQ/sNoo2CWC+IMm6AMOoIIw0Br9GwALuIpMUIABeDoJEDKasQAWaIEfWATl/YIwAOqSZpZX/S3VKFiiWKHeugMIeAIV6AiFyIR+qjTQys3mTER/7eq6OGntKbfpQBkatLuciIF1MR+JGDw6WOrSomtrQlXgVMYcFo0v8A070IAeGoQfoGHDxqYJvdFqfda5OAQgzuVAcOnKtiy7Thz8kha9tq0dkoBHoOzQtmzsjTBuI7HTbm1LG+3dtFUFpm1LQ2y43VX/ldbtGPtq4vlt4EaxTd3m2S5uHVvRNcTPuVbu74rlWUtu6IYxXVXActXs6nYw5qY26t5uEDPRiF0IsQZv4x5og2C2gvtu876wQ5UW4MoAv5xv+q5v+75v/M5v/d5v/u5v//5vAA9wAR9wAi9wAz9wBE/wAF8A9B42Cv0mM4hwCZ9wCq9wC79wDM9wDd9wDu9wD/9wEA9xER9xEi9xEz9xFE9xEL8+BEywY+W29j6xmAPRs3ruGB8u6LSv8NQLt7LxG2etHLevRi6kH8ewINfxGA2wxeLTIg+vI09s6VJsH2/yynpyIY9bWX1rKndy+XSiuGuILecvK79LCu2mwp7yGjD3nTGfVjAD8zSXrzWf1ubW7h5/cxzv1YAAADs=" width="400" height="299"> </div> <h2 id="final-code-review">Final code review</h2> <p>Here are the code files discussed on this page. They're found in the <code>src/app/</code> directory.</p>   <h3 id="heroservice-inmemorydataservice-appmodule">
<code>HeroService</code>, <code>InMemoryDataService</code>, <code>AppModule</code>
</h3> <code-tabs> <pre header="hero.service.ts" data-language="typescript">import { Injectable } from '@angular/core';
import { HttpClient, HttpHeaders } from '@angular/common/http';

import { Observable, of } from 'rxjs';
import { catchError, map, tap } from 'rxjs/operators';

import { Hero } from './hero';
import { MessageService } from './message.service';


@Injectable({ providedIn: 'root' })
export class HeroService {

  private heroesUrl = 'api/heroes';  // URL to web api

  httpOptions = {
    headers: new HttpHeaders({ 'Content-Type': 'application/json' })
  };

  constructor(
    private http: HttpClient,
    private messageService: MessageService) { }

  /** GET heroes from the server */
  getHeroes(): Observable&lt;Hero[]&gt; {
    return this.http.get&lt;Hero[]&gt;(this.heroesUrl)
      .pipe(
        tap(_ =&gt; this.log('fetched heroes')),
        catchError(this.handleError&lt;Hero[]&gt;('getHeroes', []))
      );
  }

  /** GET hero by id. Return `undefined` when id not found */
  getHeroNo404&lt;Data&gt;(id: number): Observable&lt;Hero&gt; {
    const url = `${this.heroesUrl}/?id=${id}`;
    return this.http.get&lt;Hero[]&gt;(url)
      .pipe(
        map(heroes =&gt; heroes[0]), // returns a {0|1} element array
        tap(h =&gt; {
          const outcome = h ? 'fetched' : 'did not find';
          this.log(`${outcome} hero id=${id}`);
        }),
        catchError(this.handleError&lt;Hero&gt;(`getHero id=${id}`))
      );
  }

  /** GET hero by id. Will 404 if id not found */
  getHero(id: number): Observable&lt;Hero&gt; {
    const url = `${this.heroesUrl}/${id}`;
    return this.http.get&lt;Hero&gt;(url).pipe(
      tap(_ =&gt; this.log(`fetched hero id=${id}`)),
      catchError(this.handleError&lt;Hero&gt;(`getHero id=${id}`))
    );
  }

  /* GET heroes whose name contains search term */
  searchHeroes(term: string): Observable&lt;Hero[]&gt; {
    if (!term.trim()) {
      // if not search term, return empty hero array.
      return of([]);
    }
    return this.http.get&lt;Hero[]&gt;(`${this.heroesUrl}/?name=${term}`).pipe(
      tap(x =&gt; x.length ?
         this.log(`found heroes matching "${term}"`) :
         this.log(`no heroes matching "${term}"`)),
      catchError(this.handleError&lt;Hero[]&gt;('searchHeroes', []))
    );
  }

  //////// Save methods //////////

  /** POST: add a new hero to the server */
  addHero(hero: Hero): Observable&lt;Hero&gt; {
    return this.http.post&lt;Hero&gt;(this.heroesUrl, hero, this.httpOptions).pipe(
      tap((newHero: Hero) =&gt; this.log(`added hero w/ id=${newHero.id}`)),
      catchError(this.handleError&lt;Hero&gt;('addHero'))
    );
  }

  /** DELETE: delete the hero from the server */
  deleteHero(id: number): Observable&lt;Hero&gt; {
    const url = `${this.heroesUrl}/${id}`;

    return this.http.delete&lt;Hero&gt;(url, this.httpOptions).pipe(
      tap(_ =&gt; this.log(`deleted hero id=${id}`)),
      catchError(this.handleError&lt;Hero&gt;('deleteHero'))
    );
  }

  /** PUT: update the hero on the server */
  updateHero(hero: Hero): Observable&lt;any&gt; {
    return this.http.put(this.heroesUrl, hero, this.httpOptions).pipe(
      tap(_ =&gt; this.log(`updated hero id=${hero.id}`)),
      catchError(this.handleError&lt;any&gt;('updateHero'))
    );
  }

  /**
   * Handle Http operation that failed.
   * Let the app continue.
   *
   * @param operation - name of the operation that failed
   * @param result - optional value to return as the observable result
   */
  private handleError&lt;T&gt;(operation = 'operation', result?: T) {
    return (error: any): Observable&lt;T&gt; =&gt; {

      // TODO: send the error to remote logging infrastructure
      console.error(error); // log to console instead

      // TODO: better job of transforming error for user consumption
      this.log(`${operation} failed: ${error.message}`);

      // Let the app keep running by returning an empty result.
      return of(result as T);
    };
  }

  /** Log a HeroService message with the MessageService */
  private log(message: string) {
    this.messageService.add(`HeroService: ${message}`);
  }
}</pre> <pre header="in-memory-data.service.ts" data-language="typescript">import { Injectable } from '@angular/core';
import { InMemoryDbService } from 'angular-in-memory-web-api';
import { Hero } from './hero';

@Injectable({
  providedIn: 'root',
})
export class InMemoryDataService implements InMemoryDbService {
  createDb() {
    const heroes = [
      { id: 12, name: 'Dr. Nice' },
      { id: 13, name: 'Bombasto' },
      { id: 14, name: 'Celeritas' },
      { id: 15, name: 'Magneta' },
      { id: 16, name: 'RubberMan' },
      { id: 17, name: 'Dynama' },
      { id: 18, name: 'Dr. IQ' },
      { id: 19, name: 'Magma' },
      { id: 20, name: 'Tornado' }
    ];
    return {heroes};
  }

  // Overrides the genId method to ensure that a hero always has an id.
  // If the heroes array is empty,
  // the method below returns the initial number (11).
  // if the heroes array is not empty, the method below returns the highest
  // hero id + 1.
  genId(heroes: Hero[]): number {
    return heroes.length &gt; 0 ? Math.max(...heroes.map(hero =&gt; hero.id)) + 1 : 11;
  }
}</pre> <pre header="app.module.ts" data-language="typescript">import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { FormsModule } from '@angular/forms';
import { HttpClientModule } from '@angular/common/http';

import { HttpClientInMemoryWebApiModule } from 'angular-in-memory-web-api';
import { InMemoryDataService } from './in-memory-data.service';

import { AppRoutingModule } from './app-routing.module';

import { AppComponent } from './app.component';
import { DashboardComponent } from './dashboard/dashboard.component';
import { HeroDetailComponent } from './hero-detail/hero-detail.component';
import { HeroesComponent } from './heroes/heroes.component';
import { HeroSearchComponent } from './hero-search/hero-search.component';
import { MessagesComponent } from './messages/messages.component';

@NgModule({
  imports: [
    BrowserModule,
    FormsModule,
    AppRoutingModule,
    HttpClientModule,

    // The HttpClientInMemoryWebApiModule module intercepts HTTP requests
    // and returns simulated server responses.
    // Remove it when a real server is ready to receive requests.
    HttpClientInMemoryWebApiModule.forRoot(
      InMemoryDataService, { dataEncapsulation: false }
    )
  ],
  declarations: [
    AppComponent,
    DashboardComponent,
    HeroesComponent,
    HeroDetailComponent,
    MessagesComponent,
    HeroSearchComponent
  ],
  bootstrap: [ AppComponent ]
})
export class AppModule { }</pre> </code-tabs>  <h3 id="heroescomponent"><code>HeroesComponent</code></h3> <code-tabs> <pre header="heroes/heroes.component.html" data-language="html">&lt;h2&gt;My Heroes&lt;/h2&gt;

&lt;div&gt;
  &lt;label for="new-hero"&gt;Hero name: &lt;/label&gt;
  &lt;input id="new-hero" #heroName /&gt;

  &lt;!-- (click) passes input value to add() and then clears the input --&gt;
  &lt;button type="button" class="add-button" (click)="add(heroName.value); heroName.value=''"&gt;
    Add hero
  &lt;/button&gt;
&lt;/div&gt;

&lt;ul class="heroes"&gt;
  &lt;li *ngFor="let hero of heroes"&gt;
    &lt;a routerLink="/detail/{{hero.id}}"&gt;
      &lt;span class="badge"&gt;{{hero.id}}&lt;/span&gt; {{hero.name}}
    &lt;/a&gt;
    &lt;button type="button" class="delete" title="delete hero"
      (click)="delete(hero)"&gt;x&lt;/button&gt;
  &lt;/li&gt;
&lt;/ul&gt;</pre> <pre header="heroes/heroes.component.ts" data-language="typescript">import { Component, OnInit } from '@angular/core';

import { Hero } from '../hero';
import { HeroService } from '../hero.service';

@Component({
  selector: 'app-heroes',
  templateUrl: './heroes.component.html',
  styleUrls: ['./heroes.component.css']
})
export class HeroesComponent implements OnInit {
  heroes: Hero[] = [];

  constructor(private heroService: HeroService) { }

  ngOnInit(): void {
    this.getHeroes();
  }

  getHeroes(): void {
    this.heroService.getHeroes()
    .subscribe(heroes =&gt; this.heroes = heroes);
  }

  add(name: string): void {
    name = name.trim();
    if (!name) { return; }
    this.heroService.addHero({ name } as Hero)
      .subscribe(hero =&gt; {
        this.heroes.push(hero);
      });
  }

  delete(hero: Hero): void {
    this.heroes = this.heroes.filter(h =&gt; h !== hero);
    this.heroService.deleteHero(hero.id).subscribe();
  }

}</pre> <pre header="heroes/heroes.component.css" data-language="css">/* HeroesComponent's private CSS styles */
.heroes {
  margin: 0 0 2em 0;
  list-style-type: none;
  padding: 0;
  width: 15em;
}

input {
  display: block;
  width: 100%;
  padding: .5rem;
  margin: 1rem 0;
  box-sizing: border-box;
}

.heroes li {
  position: relative;
  cursor: pointer;
}

.heroes li:hover {
  left: .1em;
}

.heroes a {
  color: #333;
  text-decoration: none;
  background-color: #EEE;
  margin: .5em;
  padding: .3em 0;
  height: 1.6em;
  border-radius: 4px;
  display: block;
  width: 100%;
}

.heroes a:hover {
  color: #2c3a41;
  background-color: #e6e6e6;
}

.heroes a:active {
  background-color: #525252;
  color: #fafafa;
}

.heroes .badge {
  display: inline-block;
  font-size: small;
  color: white;
  padding: 0.8em 0.7em 0 0.7em;
  background-color: #405061;
  line-height: 1em;
  position: relative;
  left: -1px;
  top: -4px;
  height: 1.8em;
  min-width: 16px;
  text-align: right;
  margin-right: .8em;
  border-radius: 4px 0 0 4px;
}

.add-button {
 padding: .5rem 1.5rem;
 font-size: 1rem;
 margin-bottom: 2rem;
}

.add-button:hover {
  color: white;
  background-color: #42545C;
}

button.delete {
  position: absolute;
  left: 210px;
  top: 5px;
  background-color: white;
  color:  #525252;
  font-size: 1.1rem;
  margin: 0;
  padding: 1px 10px 3px 10px;
}

button.delete:hover {
  background-color: #525252;
  color: white;
}</pre> </code-tabs>  <h3 id="herodetailcomponent"><code>HeroDetailComponent</code></h3> <code-tabs> <pre header="hero-detail/hero-detail.component.html" data-language="html">&lt;div *ngIf="hero"&gt;
  &lt;h2&gt;{{hero.name | uppercase}} Details&lt;/h2&gt;
  &lt;div&gt;&lt;span&gt;id: &lt;/span&gt;{{hero.id}}&lt;/div&gt;
  &lt;div&gt;
    &lt;label for="hero-name"&gt;Hero name: &lt;/label&gt;
    &lt;input id="hero-name" [(ngModel)]="hero.name" placeholder="Hero name"/&gt;
  &lt;/div&gt;
  &lt;button type="button" (click)="goBack()"&gt;go back&lt;/button&gt;
  &lt;button type="button" (click)="save()"&gt;save&lt;/button&gt;
&lt;/div&gt;</pre> <pre header="hero-detail/hero-detail.component.ts" data-language="typescript">import { Component, OnInit } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
import { Location } from '@angular/common';

import { Hero } from '../hero';
import { HeroService } from '../hero.service';

@Component({
  selector: 'app-hero-detail',
  templateUrl: './hero-detail.component.html',
  styleUrls: [ './hero-detail.component.css' ]
})
export class HeroDetailComponent implements OnInit {
  hero: Hero | undefined;

  constructor(
    private route: ActivatedRoute,
    private heroService: HeroService,
    private location: Location
  ) {}

  ngOnInit(): void {
    this.getHero();
  }

  getHero(): void {
    const id = parseInt(this.route.snapshot.paramMap.get('id')!, 10);
    this.heroService.getHero(id)
      .subscribe(hero =&gt; this.hero = hero);
  }

  goBack(): void {
    this.location.back();
  }

  save(): void {
    if (this.hero) {
      this.heroService.updateHero(this.hero)
        .subscribe(() =&gt; this.goBack());
    }
  }
}</pre> <pre header="hero-detail/hero-detail.component.css" data-language="css">/* HeroDetailComponent's private CSS styles */
label {
  color: #435960;
  font-weight: bold;
}
input {
  font-size: 1em;
  padding: .5rem;
}
button {
  margin-top: 20px;
  margin-right: .5rem;
  background-color: #eee;
  padding: 1rem;
  border-radius: 4px;
  font-size: 1rem;
}
button:hover {
  background-color: #cfd8dc;
}
button:disabled {
  background-color: #eee;
  color: #ccc;
  cursor: auto;
}</pre> </code-tabs>  <h3 id="dashboardcomponent"><code>DashboardComponent</code></h3> <code-tabs> <pre header="dashboard/dashboard.component.html" data-language="html">&lt;h2&gt;Top Heroes&lt;/h2&gt;
&lt;div class="heroes-menu"&gt;
  &lt;a *ngFor="let hero of heroes"
      routerLink="/detail/{{hero.id}}"&gt;
      {{hero.name}}
  &lt;/a&gt;
&lt;/div&gt;

&lt;app-hero-search&gt;&lt;/app-hero-search&gt;</pre> <pre header="dashboard/dashboard.component.ts" data-language="typescript">import { Component, OnInit } from '@angular/core';
import { Hero } from '../hero';
import { HeroService } from '../hero.service';

@Component({
  selector: 'app-dashboard',
  templateUrl: './dashboard.component.html',
  styleUrls: [ './dashboard.component.css' ]
})
export class DashboardComponent implements OnInit {
  heroes: Hero[] = [];

  constructor(private heroService: HeroService) { }

  ngOnInit(): void {
    this.getHeroes();
  }

  getHeroes(): void {
    this.heroService.getHeroes()
      .subscribe(heroes =&gt; this.heroes = heroes.slice(1, 5));
  }
}</pre> <pre header="dashboard/dashboard.component.css" data-language="css">/* DashboardComponent's private CSS styles */

h2 {
  text-align: center;
}

.heroes-menu {
  padding: 0;
  margin: auto;
  max-width: 1000px;

  /* flexbox */
  display: -webkit-box;
  display: -moz-box;
  display: -ms-flexbox;
  display: -webkit-flex;
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
  justify-content: space-around;
  align-content: flex-start;
  align-items: flex-start;
}

a {
  background-color: #3f525c;
  border-radius: 2px;
  padding: 1rem;
  font-size: 1.2rem;
  text-decoration: none;
  display: inline-block;
  color: #fff;
  text-align: center;
  width: 100%;
  min-width: 70px;
  margin: .5rem auto;
  box-sizing: border-box;

  /* flexbox */
  order: 0;
  flex: 0 1 auto;
  align-self: auto;
}

@media (min-width: 600px) {
  a {
    width: 18%;
    box-sizing: content-box;
  }
}

a:hover {
  background-color: black;
}</pre> </code-tabs>  <h3 id="herosearchcomponent"><code>HeroSearchComponent</code></h3> <code-tabs> <pre header="hero-search/hero-search.component.html" data-language="html">&lt;div id="search-component"&gt;
  &lt;label for="search-box"&gt;Hero Search&lt;/label&gt;
  &lt;input #searchBox id="search-box" (input)="search(searchBox.value)" /&gt;

  &lt;ul class="search-result"&gt;
    &lt;li *ngFor="let hero of heroes$ | async" &gt;
      &lt;a routerLink="/detail/{{hero.id}}"&gt;
        {{hero.name}}
      &lt;/a&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;</pre> <pre header="hero-search/hero-search.component.ts" data-language="typescript">import { Component, OnInit } from '@angular/core';

import { Observable, Subject } from 'rxjs';

import {
   debounceTime, distinctUntilChanged, switchMap
 } from 'rxjs/operators';

import { Hero } from '../hero';
import { HeroService } from '../hero.service';

@Component({
  selector: 'app-hero-search',
  templateUrl: './hero-search.component.html',
  styleUrls: [ './hero-search.component.css' ]
})
export class HeroSearchComponent implements OnInit {
  heroes$!: Observable&lt;Hero[]&gt;;
  private searchTerms = new Subject&lt;string&gt;();

  constructor(private heroService: HeroService) {}

  // Push a search term into the observable stream.
  search(term: string): void {
    this.searchTerms.next(term);
  }

  ngOnInit(): void {
    this.heroes$ = this.searchTerms.pipe(
      // wait 300ms after each keystroke before considering the term
      debounceTime(300),

      // ignore new term if same as previous term
      distinctUntilChanged(),

      // switch to new search observable each time the term changes
      switchMap((term: string) =&gt; this.heroService.searchHeroes(term)),
    );
  }
}</pre> <pre header="hero-search/hero-search.component.css" data-language="css">/* HeroSearch private styles */

label {
  display: block;
  font-weight: bold;
  font-size: 1.2rem;
  margin-top: 1rem;
  margin-bottom: .5rem;

}
input {
  padding: .5rem;
  width: 100%;
  max-width: 600px;
  box-sizing: border-box;
  display: block;
}

input:focus {
  outline: #336699 auto 1px;
}

li {
  list-style-type: none;
}
.search-result li a {
  border-bottom: 1px solid gray;
  border-left: 1px solid gray;
  border-right: 1px solid gray;
  display: inline-block;
  width: 100%;
  max-width: 600px;
  padding: .5rem;
  box-sizing: border-box;
  text-decoration: none;
  color: black;
}

.search-result li a:hover {
  background-color: #435A60;
  color: white;
}

ul.search-result {
  margin-top: 0;
  padding-left: 0;
}</pre> </code-tabs> <h2 id="summary">Summary</h2> <p>You're at the end of your journey, and you've accomplished a lot.</p> <ul> <li>You added the necessary dependencies to use HTTP in the application</li> <li>You refactored <code>HeroService</code> to load heroes from a web API</li> <li>You extended <code>HeroService</code> to support <code>post()</code>, <code>put()</code>, and <code>delete()</code> methods</li> <li>You updated the components to allow adding, editing, and deleting of heroes</li> <li>You configured an in-memory web API</li> <li>You learned how to use observables</li> </ul> <p>This concludes the "Tour of Heroes" tutorial. You're ready to learn more about Angular development in the fundamentals section, starting with the <a href="../../guide/architecture" title="Architecture">Architecture</a> guide.</p> <div class="reviewed">Last reviewed on Mon Feb 28 2022</div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2010–2023 Google, Inc.<br>Licensed under the Creative Commons Attribution License 4.0.<br>
    <a href="https://angular.io/tutorial/tour-of-heroes/toh-pt6" class="_attribution-link">https://angular.io/tutorial/tour-of-heroes/toh-pt6</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
