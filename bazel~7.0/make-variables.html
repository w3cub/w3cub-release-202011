
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Make Variables - Bazel 7.0 - W3cubDocs</title>
  
  <meta name="description" content="&#34;Make&#34; variables are a special class of expandable string variables available to attributes marked as &#34;Subject to &#39;Make variable&#39 &hellip;">
  <meta name="keywords" content="make, variables, bazel, bazel~7.0">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/bazel~7.0/make-variables.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-c8f743fc70bb84079c3cf4b71f5f99835529659c30689b2fd6193651a680f383ef1d96896f8966c7ca8a0160ffd557685bb8ad12820ec6002d60143812238086.css">
  <script type="text/javascript" src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js"></script>
  <script src="/json/bazel~7.0.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/bazel~7.0/" class="_nav-link" title="" style="margin-left:0;">Bazel 7.0</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _bazel">
				
				
<article class="devsite-article">  <h1 class="devsite-page-title" tabindex="-1">Make Variables</h1> <div class="devsite-page-title-meta"><devsite-view-release-notes></devsite-view-release-notes></div>  <div class="devsite-article-body clearfix
  ">      <ul> <li><a href="#use">Use</a></li> <li><a href="#predefined_variables">Predefined variables</a></li> <li><a href="#predefined_genrule_variables">Predefined genrule variables</a></li> <li><a href="#predefined_label_variables">Predefined source/output path variables</a></li> <li><a href="#custom_variables">Custom variables</a></li> </ul> <p> "Make" variables are a special class of expandable string variables available to attributes marked as <i>"Subject to 'Make variable' substitution"</i>. </p> <p> These can be used, for example, to inject specific toolchain paths into user-constructed build actions. </p> <p> Bazel provides both <i>predefined</i> variables, which are available to all targets, and <i>custom</i> variables, which are defined in dependency targets and only available to targets that depend on them. </p> <p> The reason for the term "Make" is historical: the syntax and semantics of these variables were originally intended to match <a href="https://www.gnu.org/software/make/manual/html_node/Using-Variables.html">GNU Make</a>. </p> <h2 id="use" data-text="Use" tabindex="-1">Use</h2> <p> Attributes marked as <i>"Subject to 'Make variable' substitution"</i> can reference the "Make" variable <code translate="no" dir="ltr">FOO</code> as follows: </p> <p> <code translate="no" dir="ltr">my_attr = "prefix $(FOO) suffix"</code> </p> <p> In other words, any substring matching <code translate="no" dir="ltr">$(FOO)</code> gets expanded to <code translate="no" dir="ltr">FOO</code>'s value. If that value is <code translate="no" dir="ltr">"bar"</code>, the final string becomes: </p> <p> <code translate="no" dir="ltr">my_attr = "prefix bar suffix"</code> </p> <p> If <code translate="no" dir="ltr">FOO</code> doesn't correspond to a variable known to the consuming target, Bazel fails with an error. </p> <p> "Make" variables whose names are non-letter symbols, such as <code translate="no" dir="ltr">@</code>, can also be referenced using only a dollar sign, without the parentheses. For example: </p> <p> <code translate="no" dir="ltr">my_attr = "prefix $@ suffix"</code> </p> <p> To write <code translate="no" dir="ltr">$</code> as a string literal (i.e. to prevent variable expansion), write <code translate="no" dir="ltr">$$</code>. </p> <h2 id="predefined_variables" data-text="Predefined variables" tabindex="-1">Predefined variables</h2> <p> Predefined "Make" variables can be referenced by any attribute marked as <i>"Subject to 'Make variable' substitution"</i> on any target. </p> <p> To see the list of these variables and their values for a given set of build options, run </p> <p><code translate="no" dir="ltr">bazel info --show_make_env [build options]</code></p> <p> and look at the top output lines with capital letters. </p> <p><a href="https://github.com/bazelbuild/examples/tree/main/make-variables#predefined-variables"> See an example of predefined variables</a>.</p> <p><strong>Toolchain option variables</strong></p> <ul> <li>
<code translate="no" dir="ltr">COMPILATION_MODE</code>: <code translate="no" dir="ltr">fastbuild</code>, <code translate="no" dir="ltr">dbg</code>, or <code translate="no" dir="ltr">opt</code>. (<a href="https://bazel.build/versions/7.0.0/docs/user-manual#flag--compilation_mode">more details</a>) </li> </ul> <p><strong>Path variables</strong></p> <ul> <li> <p> <code translate="no" dir="ltr">BINDIR</code>: The base of the generated binary tree for the target architecture. </p> <p> Note that a different tree may be used for programs that run during the build on the host architecture, to support cross-compiling. </p> <p> If you want to run a tool from within a <code translate="no" dir="ltr">genrule</code>, the recommended way to get its path is <code translate="no" dir="ltr">$(<a href="#predefined_label_variables">execpath</a> toolname)</code>, where <i>toolname</i> must be listed in the <code translate="no" dir="ltr">genrule</code>'s <code translate="no" dir="ltr"><a href="general#genrule.tools">tools</a></code> attribute. </p> </li> <li>
<code translate="no" dir="ltr">GENDIR</code>: The base of the generated code tree for the target architecture. </li> </ul> <p><strong>Machine architecture variables</strong></p> <ul> <li> <code translate="no" dir="ltr">TARGET_CPU</code>: The target architecture's CPU, e.g. <code translate="no" dir="ltr">k8</code>. </li> </ul> <h2 id="predefined_genrule_variables" data-text="Predefined genrule variables" tabindex="-1">Predefined genrule variables</h2> <p> The following are specially available to <code translate="no" dir="ltr">genrule</code>'s <code translate="no" dir="ltr"><a href="general#genrule.cmd">cmd</a></code> attribute and are generally important for making that attribute work. </p> <p><a href="https://github.com/bazelbuild/examples/tree/main/make-variables#predefined-genrule-variables"> See an example of predefined genrule variables</a>.</p> <ul> <li>
<code translate="no" dir="ltr">OUTS</code>: The <code translate="no" dir="ltr">genrule</code>'s <code translate="no" dir="ltr"><a href="general#genrule.outs">outs</a></code> list. If you have only one output file, you can also use <code translate="no" dir="ltr">$@</code>.</li> <li> <code translate="no" dir="ltr">SRCS</code>: The <code translate="no" dir="ltr">genrule</code>'s <code translate="no" dir="ltr"><a href="general#genrule.srcs">srcs</a></code> list (or more precisely: the path names of the files corresponding to labels in the <code translate="no" dir="ltr"><a href="general#genrule.srcs">srcs</a></code> list). If you have only one source file, you can also use <code translate="no" dir="ltr">$&lt;</code>. </li> <li> <code translate="no" dir="ltr">&lt;</code>: <code translate="no" dir="ltr">SRCS</code>, if it is a single file. Else triggers a build error. </li> <li> <code translate="no" dir="ltr">@</code>: <code translate="no" dir="ltr">OUTS</code>, if it is a single file. Else triggers a build error. </li> <li> <p> <code translate="no" dir="ltr">RULEDIR</code>: The output directory of the target, that is, the directory corresponding to the name of the package containing the target under the <code translate="no" dir="ltr">genfiles</code> or <code translate="no" dir="ltr">bin</code> tree. For <code translate="no" dir="ltr">//my/pkg:my_genrule</code> this always ends in <code translate="no" dir="ltr">my/pkg</code>, even if <code translate="no" dir="ltr">//my/pkg:my_genrule</code>'s outputs are in subdirectories. </p> </li> <li> <p> <code translate="no" dir="ltr">@D</code>: The output directory. If <a href="general#genrule.outs">outs</a> has one entry, this expands to the directory containing that file. If it has multiple entries, this expands to the package's root directory in the <code translate="no" dir="ltr">genfiles</code> tree, <i>even if all output files are in the same subdirectory</i>!  </p> <p> <b>Note:</b> Use <code translate="no" dir="ltr">RULEDIR</code> over <code translate="no" dir="ltr">@D</code> because <code translate="no" dir="ltr">RULEDIR</code> has simpler semantics and behaves the same way regardless of the number of output files. </p> <p> If the genrule needs to generate temporary intermediate files (perhaps as a result of using some other tool like a compiler), it should attempt to write them to <code translate="no" dir="ltr">@D</code> (although <code translate="no" dir="ltr">/tmp</code> will also be writable) and remove them before finishing. </p> <p> Especially avoid writing to directories containing inputs. They may be on read-only filesystems. Even if not, doing so would trash the source tree. </p> </li> </ul> <h2 id="predefined_label_variables" data-text="Predefined source/output path variables" tabindex="-1">Predefined source/output path variables</h2> <p> The predefined variables <code translate="no" dir="ltr">execpath</code>, <code translate="no" dir="ltr">execpaths</code>, <code translate="no" dir="ltr">rootpath</code>, <code translate="no" dir="ltr">rootpaths</code>, <code translate="no" dir="ltr">location</code>, and <code translate="no" dir="ltr">locations</code> take label parameters (e.g. <code translate="no" dir="ltr">$(execpath
  //foo:bar)</code>) and substitute the file paths denoted by that label. </p> <p> For source files, this is the path relative to your workspace root. For files that are outputs of rules, this is the file's <i>output path</i> (see the explanation of <i>output files</i> below). </p> <p><a href="https://github.com/bazelbuild/examples/tree/main/make-variables#predefined-path-variables"> See an example of predefined path variables</a>.</p> <ul> <li> <p> <code translate="no" dir="ltr">execpath</code>: Denotes the path beneath the <a href="https://bazel.build/versions/7.0.0/docs/output_directories">execroot</a> where Bazel runs build actions. </p> <p> In the above example, Bazel runs all build actions in the directory linked by the <code translate="no" dir="ltr">bazel-myproject</code> symlink in your workspace root. The source file <code translate="no" dir="ltr">empty.source</code> is linked at the path <code translate="no" dir="ltr">bazel-myproject/testapp/empty.source</code>. So its exec path (which is the subpath below the root) is <code translate="no" dir="ltr">testapp/empty.source</code>. This is the path build actions can use to find the file. </p> <p> Output files are staged similarly, but are also prefixed with the subpath <code translate="no" dir="ltr">bazel-out/cpu-compilation_mode/bin</code> (or for the outputs of tools: <code translate="no" dir="ltr">bazel-out/cpu-opt-exec-hash/bin</code>). In the above example, <code translate="no" dir="ltr">//testapp:app</code> is a tool because it appears in <code translate="no" dir="ltr">show_app_output</code>'s <code translate="no" dir="ltr"><a href="general#genrule.tools">tools</a></code> attribute. So its output file <code translate="no" dir="ltr">app</code> is written to <code translate="no" dir="ltr">bazel-myproject/bazel-out/cpu-opt-exec-hash/bin/testapp/app</code>. The exec path is thus <code translate="no" dir="ltr">
      bazel-out/cpu-opt-exec-hash/bin/testapp/app</code>. This extra prefix makes it possible to build the same target for, say, two different CPUs in the same build without the results clobbering each other. </p> <p> The label passed to this variable must represent exactly one file. For labels representing source files, this is automatically true. For labels representing rules, the rule must generate exactly one output. If this is false or the label is malformed, the build fails with an error. </p> </li> <li> <p> <code translate="no" dir="ltr">rootpath</code>: Denotes the path that a built binary can use to find a dependency at runtime relative to the subdirectory of its runfiles directory corresponding to the main repository. <strong>Note:</strong> This only works if <a href="https://bazel.build/versions/7.0.0/reference/command-line-reference#flag--enable_runfiles"> <code translate="no" dir="ltr">--enable_runfiles</code></a> is enabled, which is not the case on Windows by default. Use <code translate="no" dir="ltr">rlocationpath</code> instead for cross-platform support. </p>
<p> This is similar to <code translate="no" dir="ltr">execpath</code> but strips the configuration prefixes described above. In the example from above this means both <code translate="no" dir="ltr">empty.source</code> and <code translate="no" dir="ltr">app</code> use pure workspace-relative paths: <code translate="no" dir="ltr">testapp/empty.source</code> and <code translate="no" dir="ltr">testapp/app</code>. </p> <p> The <code translate="no" dir="ltr">rootpath</code> of a file in an external repository <code translate="no" dir="ltr">repo</code> will start with <code translate="no" dir="ltr">../repo/</code>, followed by the repository-relative path. </p> <p> This has the same "one output only" requirements as <code translate="no" dir="ltr">execpath</code>. </p> </li> <li> <p> <code translate="no" dir="ltr">rlocationpath</code>: The path a built binary can pass to the <code translate="no" dir="ltr">
      Rlocation</code> function of a runfiles library to find a dependency at runtime, either in the runfiles directory (if available) or using the runfiles manifest. </p> <p> This is similar to <code translate="no" dir="ltr">rootpath</code> in that it does not contain configuration prefixes, but differs in that it always starts with the name of the repository. In the example from above this means that <code translate="no" dir="ltr">
      empty.source</code> and <code translate="no" dir="ltr">app</code> result in the following paths: <code translate="no" dir="ltr">myproject/testapp/empty.source</code> and <code translate="no" dir="ltr">
      myproject/testapp/app</code>. </p> <p> The <code translate="no" dir="ltr">rlocationpath</code> of a file in an external repository <code translate="no" dir="ltr">repo</code> will start with <code translate="no" dir="ltr">repo/</code>, followed by the repository-relative path. </p> <p> Passing this path to a binary and resolving it to a file system path using the runfiles libraries is the preferred approach to find dependencies at runtime. Compared to <code translate="no" dir="ltr">rootpath</code>, it has the advantage that it works on all platforms and even if the runfiles directory is not available. </p> <p> This has the same "one output only" requirements as <code translate="no" dir="ltr">execpath</code>. </p> </li> <li> <code translate="no" dir="ltr">location</code>: A synonym for either <code translate="no" dir="ltr">execpath</code> or <code translate="no" dir="ltr">rootpath</code>, depending on the attribute being expanded. This is legacy pre-Starlark behavior and not recommended unless you really know what it does for a particular rule. See <a href="https://github.com/bazelbuild/bazel/issues/2475#issuecomment-339318016">#2475</a> for details. </li> </ul> <p> <code translate="no" dir="ltr">execpaths</code>, <code translate="no" dir="ltr">rootpaths</code>, <code translate="no" dir="ltr">rlocationpaths</code>, and <code translate="no" dir="ltr">locations</code> are the plural variations of <code translate="no" dir="ltr">execpath</code>, <code translate="no" dir="ltr">rootpath</code>, <code translate="no" dir="ltr">rlocationpaths</code>, and<code translate="no" dir="ltr">location</code>, respectively. They support labels producing multiple outputs, in which case each output is listed separated by a space. Zero-output rules and malformed labels produce build errors. </p> <p> All referenced labels must appear in the consuming target's <code translate="no" dir="ltr">srcs</code>, output files, or <code translate="no" dir="ltr">deps</code>. Otherwise the build fails. C++ targets can also reference labels in <code translate="no" dir="ltr"><a href="c-cpp#cc_binary.data">data</a></code>. </p> <p> Labels don't have to be in canonical form: <code translate="no" dir="ltr">foo</code>, <code translate="no" dir="ltr">:foo</code> and <code translate="no" dir="ltr">//somepkg:foo</code> are all fine. </p> <h2 id="custom_variables" data-text="Custom variables" tabindex="-1">Custom variables</h2> <p> Custom "Make" variables can be referenced by any attribute marked as <i>"Subject to 'Make variable' substitution"</i>, but only on targets that depend on other targets that <i>define</i> these variables. </p> <p> As best practice all variables should be custom unless there's a really good reason to bake them into core Bazel. This saves Bazel from having to load potentially expensive dependencies to supply variables consuming tarets may not care about. </p> <p><strong>C++ toolchain variables</strong></p> <p> The following are defined in C++ toolchain rules and available to any rule that sets <code translate="no" dir="ltr">toolchains =
  ["@bazel_tools//tools/cpp:current_cc_toolchain"]</code> Some rules, like <code translate="no" dir="ltr"><a href="java#java_binary">java_binary</a></code>, implicitly include the C++ toolchain in their rule definition. They inherit these variables automatically. </p> <p> The built-in C++ rules are much more sophisticated than "run the compiler on it". In order to support compilation modes as diverse as *SAN, ThinLTO, with/without modules, and carefully optimized binaries at the same time as fast running tests on multiple platforms, the built-in rules go to great lengths to ensure the correct inputs, outputs, and command-line flags are set on each of potentially multiple internally generated actions. </p> <p> These variables are a fallback mechanism to be used by language experts in rare cases. If you are tempted to use them, please <a href="https://bazel.build/versions/7.0.0/help">contact the Bazel devs</a> first. </p> <ul> <li>
<code translate="no" dir="ltr">ABI</code>: The C++ ABI version. </li> <li> <code translate="no" dir="ltr">AR</code>: The "ar" command from crosstool. </li> <li class="harmful"> <code translate="no" dir="ltr">C_COMPILER</code>: The C/C++ compiler identifier, e.g. <code translate="no" dir="ltr">llvm</code>. </li> <li class="harmful"> <p><code translate="no" dir="ltr">CC</code>: The C and C++ compiler command.</p> <p> We strongly recommended always using <code translate="no" dir="ltr">CC_FLAGS</code> in combination with <code translate="no" dir="ltr">CC</code>. Fail to do so at your own risk. </p> </li> <li class="harmful">
<code translate="no" dir="ltr">CC_FLAGS</code>: A minimal set of flags for the C/C++ compiler to be usable by genrules. In particular, this contains flags to select the correct architecture if <code translate="no" dir="ltr">CC</code> supports multiple architectures. </li> <li> <code translate="no" dir="ltr">NM</code>: The "nm" command from crosstool. </li> <li> <code translate="no" dir="ltr">OBJCOPY</code>: The objcopy command from the same suite as the C/C++ compiler. </li> <li> <code translate="no" dir="ltr">STRIP</code>: The strip command from the same suite as the C/C++ compiler.</li> </ul> <p><strong>Java toolchain variables</strong></p> <p> The following are defined in Java toolchain rules and available to any rule that sets <code translate="no" dir="ltr">toolchains =
["@bazel_tools//tools/jdk:current_java_runtime"]</code> (or <code translate="no" dir="ltr">"@bazel_tools//tools/jdk:current_host_java_runtime"</code> for the host toolchain equivalent). </p> <p> Most of the tools in the JDK should not be used directly. The built-in Java rules use much more sophisticated approaches to Java compilation and packaging than upstream tools can express, such as interface Jars, header interface Jars, and highly optimized Jar packaging and merging implementations. </p> <p> These variables are a fallback mechanism to be used by language experts in rare cases. If you are tempted to use them, please <a href="https://bazel.build/versions/7.0.0/help">contact the Bazel devs</a> first. </p> <ul> <li class="harmful"> <code translate="no" dir="ltr">JAVA</code>: The "java" command (a Java virtual machine). Avoid this, and use a <code translate="no" dir="ltr"><a href="java#java_binary">java_binary</a></code> rule instead where possible. May be a relative path. If you must change directories before invoking <code translate="no" dir="ltr">java</code>, you need to capture the working directory before changing it. </li> <li class="harmful">
<code translate="no" dir="ltr">JAVABASE</code>: The base directory containing the Java utilities. May be a relative path. It will have a "bin" subdirectory. </li> </ul> <p><strong>Starlark-defined variables</strong></p> <p> Rule and <a href="https://bazel.build/versions/7.0.0/docs/toolchains">toolchain</a> writers can define completely custom variables by returning a <a href="https://bazel.build/versions/7.0.0/rules/lib/TemplateVariableInfo">TemplateVariableInfo</a> provider. Any rules depending on these through the <code translate="no" dir="ltr">toolchains</code> attribute can then read their values: </p> <p><a href="https://github.com/bazelbuild/examples/tree/main/make-variables#custom-starlark-defined-variables"> See an example of Starlark-defined variables</a>.</p>  </div>  </article> <devsite-content-footer class="nocontent"> <p>Except as otherwise noted, the content of this page is licensed under the <a href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 License</a>, and code samples are licensed under the <a href="https://www.apache.org/licenses/LICENSE-2.0">Apache 2.0 License</a>. For details, see the <a href="https://developers.google.com/site-policies">Google Developers Site Policies</a>. Java is a registered trademark of Oracle and/or its affiliates.</p> <p>Last updated 2023-12-11 UTC.</p> </devsite-content-footer> <devsite-notification> </devsite-notification> <div class="devsite-content-data"> <template class="devsite-thumb-rating-down-categories"> [{ "type": "thumb-down", "id": "missingTheInformationINeed", "label":"Missing the information I need" },{ "type": "thumb-down", "id": "tooComplicatedTooManySteps", "label":"Too complicated / too many steps" },{ "type": "thumb-down", "id": "outOfDate", "label":"Out of date" },{ "type": "thumb-down", "id": "samplesCodeIssue", "label":"Samples / code issue" },{ "type": "thumb-down", "id": "otherDown", "label":"Other" }] </template> <template class="devsite-thumb-rating-up-categories"> [{ "type": "thumb-up", "id": "easyToUnderstand", "label":"Easy to understand" },{ "type": "thumb-up", "id": "solvedMyProblem", "label":"Solved my problem" },{ "type": "thumb-up", "id": "otherUp", "label":"Other" }] </template> </div>
<div class="_attribution">
  <p class="_attribution-p">
    Licensed under the Creative Commons Attribution 4.0 License, and code samples are licensed under the Apache 2.0 License.<br>
    <a href="https://bazel.build/versions/7.0.0/reference/be/make-variables" class="_attribution-link">https://bazel.build/versions/7.0.0/reference/be/make-variables</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
