
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>ActionDispatch&#58;&#58;Routing&#58;&#58;Mapper&#58;&#58;Resources - Ruby on Rails 7.0 - W3cubDocs</title>
  
  <meta name="description" content="Resource routing allows you to quickly declare all of the common routes for a given resourceful controller. Instead of declaring separate routes for &hellip;">
  <meta name="keywords" content="module, actiondispatch, routing, mapper, resources, ruby, on, rails, rails~7.0">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/rails~7.0/actiondispatch/routing/mapper/resources.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-60a6449bb52e9968d95c133a29f066ffcb8dbe4f077d4022e51c991ce30bf256c8e19c508207a4193c414ffd0414826564317669b0f27f9f85c1cb21b84e097e.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/rails~7.0.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/rails~7.0/" class="_nav-link" title="" style="margin-left:0;">Ruby on Rails 7.0</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _rdoc">
				
				
<h1 id="module-ActionDispatch::Routing::Mapper::Resources" class="module"> module ActionDispatch::Routing::Mapper::Resources </h1> <section class="description"> <p>Resource routing allows you to quickly declare all of the common routes for a given resourceful controller. Instead of declaring separate routes for your <code>index</code>, <code>show</code>, <code>new</code>, <code>edit</code>, <code>create</code>, <code>update</code> and <code>destroy</code> actions, a resourceful route declares them in a single line of code:</p> <pre class="ruby" data-language="ruby">resources :photos
</pre> <p>Sometimes, you have a resource that clients always look up without referencing an ID. A common example, /profile always shows the profile of the currently logged in user. In this case, you can use a singular resource to map /profile (rather than /profile/:id) to the show action.</p> <pre class="ruby" data-language="ruby">resource :profile
</pre> <p>It's common to have resources that are logically children of other resources:</p> <pre class="ruby" data-language="ruby">resources :magazines do
  resources :ads
end
</pre> <p>You may wish to organize groups of controllers under a namespace. Most commonly, you might group a number of administrative controllers under an <code>admin</code> namespace. You would place these controllers under the <code>app/controllers/admin</code> directory, and you can group them together in your router:</p> <pre class="ruby" data-language="ruby">namespace "admin" do
  resources :posts, :comments
end
</pre> <p>By default the <code>:id</code> parameter doesn't accept dots. If you need to use dots as part of the <code>:id</code> parameter add a constraint which overrides this restriction, e.g:</p> <pre class="ruby" data-language="ruby">resources :articles, id: /[^\/]+/
</pre> <p>This allows any character other than a slash as part of your <code>:id</code>.</p> </section> <section id="5Buntitled-5D" class="documentation-section"> <section class="constants-list"> <header> <h3>Constants</h3> </header> <dl> <dt id="CANONICAL_ACTIONS">CANONICAL_ACTIONS </dt>

<dt id="RESOURCE_OPTIONS">RESOURCE_OPTIONS </dt>

<dt id="VALID_ON_OPTIONS">VALID_ON_OPTIONS </dt>
<dd>
<p><a href="resources#CANONICAL_ACTIONS"><code>CANONICAL_ACTIONS</code></a> holds all actions that does not need a prefix or a path appended since they fit properly in their scope level.</p> </dd>
</dl> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-collection"> <span class="method-name">collection</span><span class="method-args">(&amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="collection-source"> <pre class="ruby" data-language="ruby"># File actionpack/lib/action_dispatch/routing/mapper.rb, line 1500
def collection(&amp;block)
  unless resource_scope?
    raise ArgumentError, "can't use collection outside resource(s) scope"
  end

  with_scope_level(:collection) do
    path_scope(parent_resource.collection_scope, &amp;block)
  end
end</pre> </div> <p>To add a route to the collection:</p> <pre class="ruby" data-language="ruby">resources :photos do
  collection do
    get 'search'
  end
end
</pre> <p>This will enable Rails to recognize paths such as <code>/photos/search</code> with GET, and route to the search action of <code>PhotosController</code>. It will also create the <code>search_photos_url</code> and <code>search_photos_path</code> route helpers.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-draw"> <span class="method-name">draw</span><span class="method-args">(name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="draw-source"> <pre class="ruby" data-language="ruby"># File actionpack/lib/action_dispatch/routing/mapper.rb, line 1587
def draw(name)
  path = @draw_paths.find do |_path|
    File.exist? "#{_path}/#{name}.rb"
  end

  unless path
    msg  = "Your router tried to #draw the external file #{name}.rb,\n" \
           "but the file was not found in:\n\n"
    msg += @draw_paths.map { |_path| " * #{_path}" }.join("\n")
    raise ArgumentError, msg
  end

  route_path = "#{path}/#{name}.rb"
  instance_eval(File.read(route_path), route_path.to_s)
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-match"> <span class="method-name">match</span><span class="method-args">(path, *rest, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="match-source"> <pre class="ruby" data-language="ruby"># File actionpack/lib/action_dispatch/routing/mapper.rb, line 1609
def match(path, *rest, &amp;block)
  if rest.empty? &amp;&amp; Hash === path
    options  = path
    path, to = options.find { |name, _value| name.is_a?(String) }

    raise ArgumentError, "Route path not specified" if path.nil?

    case to
    when Symbol
      options[:action] = to
    when String
      if /#/.match?(to)
        options[:to] = to
      else
        options[:controller] = to
      end
    else
      options[:to] = to
    end

    options.delete(path)
    paths = [path]
  else
    options = rest.pop || {}
    paths = [path] + rest
  end

  if options.key?(:defaults)
    defaults(options.delete(:defaults)) { map_match(paths, options, &amp;block) }
  else
    map_match(paths, options, &amp;block)
  end
end</pre> </div> <p>Matches a URL pattern to one or more routes. For more information, see <a href="base#method-i-match">match</a>.</p> <pre class="ruby" data-language="ruby">match 'path' =&gt; 'controller#action', via: :patch
match 'path', to: 'controller#action', via: :post
match 'path', 'otherpath', on: :member, via: :get
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-member"> <span class="method-name">member</span><span class="method-args">(&amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="member-source"> <pre class="ruby" data-language="ruby"># File actionpack/lib/action_dispatch/routing/mapper.rb, line 1521
def member(&amp;block)
  unless resource_scope?
    raise ArgumentError, "can't use member outside resource(s) scope"
  end

  with_scope_level(:member) do
    if shallow?
      shallow_scope {
        path_scope(parent_resource.member_scope, &amp;block)
      }
    else
      path_scope(parent_resource.member_scope, &amp;block)
    end
  end
end</pre> </div> <p>To add a member route, add a member block into the resource block:</p> <pre class="ruby" data-language="ruby">resources :photos do
  member do
    get 'preview'
  end
end
</pre> <p>This will recognize <code>/photos/1/preview</code> with GET, and route to the preview action of <code>PhotosController</code>. It will also create the <code>preview_photo_url</code> and <code>preview_photo_path</code> helpers.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-namespace"> <span class="method-name">namespace</span><span class="method-args">(path, options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="namespace-source"> <pre class="ruby" data-language="ruby"># File actionpack/lib/action_dispatch/routing/mapper.rb, line 1568
def namespace(path, options = {})
  if resource_scope?
    nested { super }
  else
    super
  end
end</pre> </div> <p>See <a href="scoping#method-i-namespace"><code>ActionDispatch::Routing::Mapper::Scoping#namespace</code></a>.</p> <div class="method-calls-super"> Calls superclass method </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-nested"> <span class="method-name">nested</span><span class="method-args">(&amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="nested-source"> <pre class="ruby" data-language="ruby"># File actionpack/lib/action_dispatch/routing/mapper.rb, line 1547
def nested(&amp;block)
  unless resource_scope?
    raise ArgumentError, "can't use nested outside resource(s) scope"
  end

  with_scope_level(:nested) do
    if shallow? &amp;&amp; shallow_nesting_depth &gt;= 1
      shallow_scope do
        path_scope(parent_resource.nested_scope) do
          scope(nested_options, &amp;block)
        end
      end
    else
      path_scope(parent_resource.nested_scope) do
        scope(nested_options, &amp;block)
      end
    end
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-new"> <span class="method-name">new</span><span class="method-args">(&amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="ruby" data-language="ruby"># File actionpack/lib/action_dispatch/routing/mapper.rb, line 1537
def new(&amp;block)
  unless resource_scope?
    raise ArgumentError, "can't use new outside resource(s) scope"
  end

  with_scope_level(:new) do
    path_scope(parent_resource.new_scope(action_path(:new)), &amp;block)
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-resource"> <span class="method-name">resource</span><span class="method-args">(*resources) { || ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="resource-source"> <pre class="ruby" data-language="ruby"># File actionpack/lib/action_dispatch/routing/mapper.rb, line 1292
def resource(*resources, &amp;block)
  options = resources.extract_options!.dup

  if apply_common_behavior_for(:resource, resources, options, &amp;block)
    return self
  end

  with_scope_level(:resource) do
    options = apply_action_options options
    resource_scope(SingletonResource.new(resources.pop, api_only?, @scope[:shallow], options)) do
      yield if block_given?

      concerns(options[:concerns]) if options[:concerns]

      new do
        get :new
      end if parent_resource.actions.include?(:new)

      set_member_mappings_for_resource

      collection do
        post :create
      end if parent_resource.actions.include?(:create)
    end
  end

  self
end</pre> </div> <p>Sometimes, you have a resource that clients always look up without referencing an ID. A common example, /profile always shows the profile of the currently logged in user. In this case, you can use a singular resource to map /profile (rather than /profile/:id) to the show action:</p> <pre class="ruby" data-language="ruby">resource :profile
</pre> <p>This creates six different routes in your application, all mapping to the <code>Profiles</code> controller (note that the controller is named after the plural):</p> <pre>GET       /profile/new
GET       /profile
GET       /profile/edit
PATCH/PUT /profile
DELETE    /profile
POST      /profile</pre> <p>If you want instances of a model to work with this resource via record identification (e.g. in <code>form_with</code> or <code>redirect_to</code>), you will need to call <a href="customurls#method-i-resolve">resolve</a>:</p> <pre class="ruby" data-language="ruby">resource :profile
resolve('Profile') { [:profile] }

# Enables this to work with singular routes:
form_with(model: @profile) {}
</pre> <h3 id="method-i-resource-label-Options">Options</h3> <p>Takes same options as <a href="resources#method-i-resources">resources</a></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-resources"> <span class="method-name">resources</span><span class="method-args">(*resources) { || ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="resources-source"> <pre class="ruby" data-language="ruby"># File actionpack/lib/action_dispatch/routing/mapper.rb, line 1458
def resources(*resources, &amp;block)
  options = resources.extract_options!.dup

  if apply_common_behavior_for(:resources, resources, options, &amp;block)
    return self
  end

  with_scope_level(:resources) do
    options = apply_action_options options
    resource_scope(Resource.new(resources.pop, api_only?, @scope[:shallow], options)) do
      yield if block_given?

      concerns(options[:concerns]) if options[:concerns]

      collection do
        get  :index if parent_resource.actions.include?(:index)
        post :create if parent_resource.actions.include?(:create)
      end

      new do
        get :new
      end if parent_resource.actions.include?(:new)

      set_member_mappings_for_resource
    end
  end

  self
end</pre> </div> <p>In Rails, a resourceful route provides a mapping between HTTP verbs and URLs and controller actions. By convention, each action also maps to particular CRUD operations in a database. A single entry in the routing file, such as</p> <pre class="ruby" data-language="ruby">resources :photos
</pre> <p>creates seven different routes in your application, all mapping to the <code>Photos</code> controller:</p> <pre>GET       /photos
GET       /photos/new
POST      /photos
GET       /photos/:id
GET       /photos/:id/edit
PATCH/PUT /photos/:id
DELETE    /photos/:id</pre> <p><a href="resources"><code>Resources</code></a> can also be nested infinitely by using this block syntax:</p> <pre class="ruby" data-language="ruby">resources :photos do
  resources :comments
end
</pre> <p>This generates the following comments routes:</p> <pre>GET       /photos/:photo_id/comments
GET       /photos/:photo_id/comments/new
POST      /photos/:photo_id/comments
GET       /photos/:photo_id/comments/:id
GET       /photos/:photo_id/comments/:id/edit
PATCH/PUT /photos/:photo_id/comments/:id
DELETE    /photos/:photo_id/comments/:id</pre> <h3 id="method-i-resources-label-Options">Options</h3> <p>Takes same options as <a href="base#method-i-match">match</a> as well as:</p> <dl class="rdoc-list label-list">
<dt>:path_names </dt>
<dd> <p>Allows you to change the segment component of the <code>edit</code> and <code>new</code> actions. Actions not specified are not changed.</p> <pre class="ruby" data-language="ruby">resources :posts, path_names: { new: "brand_new" }
</pre> <p>The above example will now change /posts/new to /posts/brand_new.</p> </dd>
<dt>:path </dt>
<dd> <p>Allows you to change the path prefix for the resource.</p> <pre class="ruby" data-language="ruby">resources :posts, path: 'postings'
</pre> <p>The resource and all segments will now route to /postings instead of /posts.</p> </dd>
<dt>:only </dt>
<dd> <p>Only generate routes for the given actions.</p> <pre class="ruby" data-language="ruby">resources :cows, only: :show
resources :cows, only: [:show, :index]
</pre> </dd>
<dt>:except </dt>
<dd> <p>Generate all routes except for the given actions.</p> <pre class="ruby" data-language="ruby">resources :cows, except: :show
resources :cows, except: [:show, :index]
</pre> </dd>
<dt>:shallow </dt>
<dd> <p>Generates shallow routes for nested resource(s). When placed on a parent resource, generates shallow routes for all nested resources.</p> <pre class="ruby" data-language="ruby">resources :posts, shallow: true do
  resources :comments
end
</pre> <p>Is the same as:</p> <pre class="ruby" data-language="ruby">resources :posts do
  resources :comments, except: [:show, :edit, :update, :destroy]
end
resources :comments, only: [:show, :edit, :update, :destroy]
</pre> <p>This allows URLs for resources that otherwise would be deeply nested such as a comment on a blog post like <code>/posts/a-long-permalink/comments/1234</code> to be shortened to just <code>/comments/1234</code>.</p> <p>Set <code>shallow: false</code> on a child resource to ignore a parent's shallow parameter.</p> </dd>
<dt>:shallow_path </dt>
<dd> <p>Prefixes nested shallow routes with the specified path.</p> <pre class="ruby" data-language="ruby">scope shallow_path: "sekret" do
  resources :posts do
    resources :comments, shallow: true
  end
end
</pre> <p>The <code>comments</code> resource here will have the following routes generated for it:</p> <pre>post_comments    GET       /posts/:post_id/comments(.:format)
post_comments    POST      /posts/:post_id/comments(.:format)
new_post_comment GET       /posts/:post_id/comments/new(.:format)
edit_comment     GET       /sekret/comments/:id/edit(.:format)
comment          GET       /sekret/comments/:id(.:format)
comment          PATCH/PUT /sekret/comments/:id(.:format)
comment          DELETE    /sekret/comments/:id(.:format)</pre> </dd>
<dt>:shallow_prefix </dt>
<dd> <p>Prefixes nested shallow route names with specified prefix.</p> <pre class="ruby" data-language="ruby">scope shallow_prefix: "sekret" do
  resources :posts do
    resources :comments, shallow: true
  end
end
</pre> <p>The <code>comments</code> resource here will have the following routes generated for it:</p> <pre>post_comments           GET       /posts/:post_id/comments(.:format)
post_comments           POST      /posts/:post_id/comments(.:format)
new_post_comment        GET       /posts/:post_id/comments/new(.:format)
edit_sekret_comment     GET       /comments/:id/edit(.:format)
sekret_comment          GET       /comments/:id(.:format)
sekret_comment          PATCH/PUT /comments/:id(.:format)
sekret_comment          DELETE    /comments/:id(.:format)</pre> </dd>
<dt>:format </dt>
<dd> <p>Allows you to specify the default value for optional <code>format</code> segment or disable it by supplying <code>false</code>.</p> </dd>
<dt>:param </dt>
<dd> <p>Allows you to override the default param name of <code>:id</code> in the URL.</p> </dd>
</dl> <h3 id="method-i-resources-label-Examples">Examples</h3> <pre class="ruby" data-language="ruby"># routes call &lt;tt&gt;Admin::PostsController&lt;/tt&gt;
resources :posts, module: "admin"

# resource actions are at /admin/posts.
resources :posts, path: "admin/posts"
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-resources_path_names"> <span class="method-name">resources_path_names</span><span class="method-args">(options)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="resources_path_names-source"> <pre class="ruby" data-language="ruby"># File actionpack/lib/action_dispatch/routing/mapper.rb, line 1257
def resources_path_names(options)
  @scope[:path_names].merge!(options)
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-root"> <span class="method-name">root</span><span class="method-args">(path, options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="root-source"> <pre class="ruby" data-language="ruby"># File actionpack/lib/action_dispatch/routing/mapper.rb, line 1656
def root(path, options = {})
  if path.is_a?(String)
    options[:to] = path
  elsif path.is_a?(Hash) &amp;&amp; options.empty?
    options = path
  else
    raise ArgumentError, "must be called with a path and/or options"
  end

  if @scope.resources?
    with_scope_level(:root) do
      path_scope(parent_resource.path) do
        match_root_route(options)
      end
    end
  else
    match_root_route(options)
  end
end</pre> </div> <p>You can specify what Rails should route “/” to with the root method:</p> <pre class="ruby" data-language="ruby">root to: 'pages#main'
</pre> <p>For options, see <code>match</code>, as <code>root</code> uses it internally.</p> <p>You can also pass a string which will expand</p> <pre class="ruby" data-language="ruby">root 'pages#main'
</pre> <p>You should put the root route at the top of <code>config/routes.rb</code>, because this means it will be matched first. As this is the most popular route of most Rails applications, this is beneficial.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-shallow"> <span class="method-name">shallow</span><span class="method-args">() { || ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="shallow-source"> <pre class="ruby" data-language="ruby"># File actionpack/lib/action_dispatch/routing/mapper.rb, line 1576
def shallow
  @scope = @scope.new(shallow: true)
  yield
ensure
  @scope = @scope.parent
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-shallow-3F"> <span class="method-name">shallow?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="shallow-3F-source"> <pre class="ruby" data-language="ruby"># File actionpack/lib/action_dispatch/routing/mapper.rb, line 1583
def shallow?
  !parent_resource.singleton? &amp;&amp; @scope[:shallow]
end</pre> </div>  </div> </div> </section> <section id="private-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Private Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-api_only-3F"> <span class="method-name">api_only?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="api_only-3F-source"> <pre class="ruby" data-language="ruby"># File actionpack/lib/action_dispatch/routing/mapper.rb, line 1856
def api_only? # :doc:
  @set.api_only?
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-set_member_mappings_for_resource"> <span class="method-name">set_member_mappings_for_resource</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="set_member_mappings_for_resource-source"> <pre class="ruby" data-language="ruby"># File actionpack/lib/action_dispatch/routing/mapper.rb, line 1844
def set_member_mappings_for_resource # :doc:
  member do
    get :edit if parent_resource.actions.include?(:edit)
    get :show if parent_resource.actions.include?(:show)
    if parent_resource.actions.include?(:update)
      patch :update
      put   :update
    end
    delete :destroy if parent_resource.actions.include?(:destroy)
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-with_scope_level"> <span class="method-name">with_scope_level</span><span class="method-args">(kind) { || ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="with_scope_level-source"> <pre class="ruby" data-language="ruby"># File actionpack/lib/action_dispatch/routing/mapper.rb, line 1740
def with_scope_level(kind) # :doc:
  @scope = @scope.new_level(kind)
  yield
ensure
  @scope = @scope.parent
end</pre> </div>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    © 2004–2021 David Heinemeier Hansson<br>Licensed under the MIT License.<br>
    
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
