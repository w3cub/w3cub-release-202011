
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>ActiveRecord&#58;&#58;ConnectionAdapters&#58;&#58;SchemaStatements - Ruby on Rails 7.0 - W3cubDocs</title>
  
  <meta name="description" content=" Adds a new check constraint to the table. expression is a String representation of verifiable boolean condition. ">
  <meta name="keywords" content="module, activerecord, connectionadapters, schemastatements, ruby, on, rails, rails~7.0">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/rails~7.0/activerecord/connectionadapters/schemastatements.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/rails~7.0.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/rails~7.0/" class="_nav-link" title="" style="margin-left:0;">Ruby on Rails 7.0</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _rdoc">
				
				
<h1 id="module-ActiveRecord::ConnectionAdapters::SchemaStatements" class="module"> module ActiveRecord::ConnectionAdapters::SchemaStatements </h1>  <section id="5Buntitled-5D" class="documentation-section"> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-add_belongs_to"> <span class="method-name">add_belongs_to</span><span class="method-args">(table_name, ref_name, **options)</span> </div>  <div class="aliases"> Alias for: <a href="schemastatements#method-i-add_reference">add_reference</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-add_check_constraint"> <span class="method-name">add_check_constraint</span><span class="method-args">(table_name, expression, **options)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="add_check_constraint-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 1185
def add_check_constraint(table_name, expression, **options)
  return unless supports_check_constraints?

  options = check_constraint_options(table_name, expression, options)
  at = create_alter_table(table_name)
  at.add_check_constraint(expression, options)

  execute schema_creation.accept(at)
end</pre> </div> <p>Adds a new check constraint to the table. <code>expression</code> is a <a href="../../string"><code>String</code></a> representation of verifiable boolean condition.</p> <pre class="ruby" data-language="ruby">add_check_constraint :products, "price &gt; 0", name: "price_check"
</pre> <p>generates:</p> <pre>ALTER TABLE "products" ADD CONSTRAINT price_check CHECK (price &gt; 0)</pre> <p>The <code>options</code> hash can include the following keys:</p> <dl class="rdoc-list label-list">
<dt>
<code>:name</code> </dt>
<dd> <p>The constraint name. Defaults to <code>chk_rails_&lt;identifier&gt;</code>.</p> </dd>
<dt>
<code>:validate</code> </dt>
<dd> <p>(PostgreSQL only) Specify whether or not the constraint should be validated. Defaults to <code>true</code>.</p> </dd>
</dl>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-add_column"> <span class="method-name">add_column</span><span class="method-args">(table_name, column_name, type, **options)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="add_column-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 616
def add_column(table_name, column_name, type, **options)
  return if options[:if_not_exists] == true &amp;&amp; column_exists?(table_name, column_name)

  if supports_datetime_with_precision?
    if type == :datetime &amp;&amp; !options.key?(:precision)
      options[:precision] = 6
    end
  end

  at = create_alter_table table_name
  at.add_column(column_name, type, **options)
  execute schema_creation.accept at
end</pre> </div> <p>Add a new <code>type</code> column named <code>column_name</code> to <code>table_name</code>.</p> <p>See <a href="tabledefinition#method-i-column">ActiveRecord::ConnectionAdapters::TableDefinition.column</a>.</p> <p>The <code>type</code> parameter is normally one of the migrations native types, which is one of the following: <code>:primary_key</code>, <code>:string</code>, <code>:text</code>, <code>:integer</code>, <code>:bigint</code>, <code>:float</code>, <code>:decimal</code>, <code>:numeric</code>, <code>:datetime</code>, <code>:time</code>, <code>:date</code>, <code>:binary</code>, <code>:blob</code>, <code>:boolean</code>.</p> <p>You may use a type not in this list as long as it is supported by your database (for example, “polygon” in <span><code>MySQL</code></span>), but this will not be database agnostic and should usually be avoided.</p> <p>Available options are (none of these exists by default):</p> <ul>
<li> <p><code>:comment</code> - Specifies the comment for the column. This option is ignored by some backends.</p> </li>
<li> <p><code>:collation</code> - Specifies the collation for a <code>:string</code> or <code>:text</code> column. If not specified, the column will have the same collation as the table.</p> </li>
<li> <p><code>:default</code> - The column's default value. Use <code>nil</code> for <code>NULL</code>.</p> </li>
<li> <p><code>:limit</code> - Requests a maximum column length. This is the number of characters for a <code>:string</code> column and number of bytes for <code>:text</code>, <code>:binary</code>, <code>:blob</code>, and <code>:integer</code> columns. This option is ignored by some backends.</p> </li>
<li> <p><code>:null</code> - Allows or disallows <code>NULL</code> values in the column.</p> </li>
<li> <p><code>:precision</code> - Specifies the precision for the <code>:decimal</code>, <code>:numeric</code>, <code>:datetime</code>, and <code>:time</code> columns.</p> </li>
<li> <p><code>:scale</code> - Specifies the scale for the <code>:decimal</code> and <code>:numeric</code> columns.</p> </li>
<li> <p><code>:collation</code> - Specifies the collation for a <code>:string</code> or <code>:text</code> column. If not specified, the column will have the same collation as the table.</p> </li>
<li> <p><code>:comment</code> - Specifies the comment for the column. This option is ignored by some backends.</p> </li>
<li> <p><code>:if_not_exists</code> - Specifies if the column already exists to not try to re-add it. This will avoid duplicate column errors.</p> </li>
</ul> <p>Note: The precision is the total number of significant digits, and the scale is the number of digits that can be stored following the decimal point. For example, the number 123.45 has a precision of 5 and a scale of 2. A decimal with a precision of 5 and a scale of 2 can range from -999.99 to 999.99.</p> <p>Please be aware of different RDBMS implementations behavior with <code>:decimal</code> columns:</p> <ul>
<li> <p>The SQL standard says the default scale should be 0, <code>:scale</code> &lt;= <code>:precision</code>, and makes no comments about the requirements of <code>:precision</code>.</p> </li>
<li> <p>MySQL: <code>:precision</code> [1..63], <code>:scale</code> [0..30]. Default is (10,0).</p> </li>
<li> <p>PostgreSQL: <code>:precision</code> [1..infinity], <code>:scale</code> [0..infinity]. No default.</p> </li>
<li> <p>SQLite3: No restrictions on <code>:precision</code> and <code>:scale</code>, but the maximum supported <code>:precision</code> is 16. No default.</p> </li>
<li> <p>Oracle: <code>:precision</code> [1..38], <code>:scale</code> [-84..127]. Default is (38,0).</p> </li>
<li> <p>SqlServer: <code>:precision</code> [1..38], <code>:scale</code> [0..38]. Default (38,0).</p> </li>
</ul> <h2 id="method-i-add_column-label-Examples">Examples</h2> <pre class="ruby" data-language="ruby">add_column(:users, :picture, :binary, limit: 2.megabytes)
# ALTER TABLE "users" ADD "picture" blob(2097152)

add_column(:articles, :status, :string, limit: 20, default: 'draft', null: false)
# ALTER TABLE "articles" ADD "status" varchar(20) DEFAULT 'draft' NOT NULL

add_column(:answers, :bill_gates_money, :decimal, precision: 15, scale: 2)
# ALTER TABLE "answers" ADD "bill_gates_money" decimal(15,2)

add_column(:measurements, :sensor_reading, :decimal, precision: 30, scale: 20)
# ALTER TABLE "measurements" ADD "sensor_reading" decimal(30,20)

# While :scale defaults to zero on most databases, it
# probably wouldn't hurt to include it.
add_column(:measurements, :huge_integer, :decimal, precision: 30)
# ALTER TABLE "measurements" ADD "huge_integer" decimal(30)

# Defines a column that stores an array of a type.
add_column(:users, :skills, :text, array: true)
# ALTER TABLE "users" ADD "skills" text[]

# Defines a column with a database-specific type.
add_column(:shapes, :triangle, 'polygon')
# ALTER TABLE "shapes" ADD "triangle" polygon

# Ignores the method call if the column exists
add_column(:shapes, :triangle, 'polygon', if_not_exists: true)
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-add_foreign_key"> <span class="method-name">add_foreign_key</span><span class="method-args">(from_table, to_table, **options)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="add_foreign_key-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 1085
def add_foreign_key(from_table, to_table, **options)
  return unless supports_foreign_keys?
  return if options[:if_not_exists] == true &amp;&amp; foreign_key_exists?(from_table, to_table)

  options = foreign_key_options(from_table, to_table, options)
  at = create_alter_table from_table
  at.add_foreign_key to_table, options

  execute schema_creation.accept(at)
end</pre> </div> <p>Adds a new foreign key. <code>from_table</code> is the table with the key column, <code>to_table</code> contains the referenced primary key.</p> <p>The foreign key will be named after the following pattern: <code>fk_rails_&lt;identifier&gt;</code>. <code>identifier</code> is a 10 character long string which is deterministically generated from the <code>from_table</code> and <code>column</code>. A custom name can be specified with the <code>:name</code> option.</p> <h6 id="method-i-add_foreign_key-label-Creating+a+simple+foreign+key">Creating a simple foreign key</h6> <pre class="ruby" data-language="ruby">add_foreign_key :articles, :authors
</pre> <p>generates:</p> <pre>ALTER TABLE "articles" ADD CONSTRAINT fk_rails_e74ce85cbc FOREIGN KEY ("author_id") REFERENCES "authors" ("id")</pre> <h6 id="method-i-add_foreign_key-label-Creating+a+foreign+key-2C+ignoring+method+call+if+the+foreign+key+exists">Creating a foreign key, ignoring method call if the foreign key exists</h6> <pre class="ruby" data-language="ruby">add_foreign_key(:articles, :authors, if_not_exists: true)
</pre> <h6 id="method-i-add_foreign_key-label-Creating+a+foreign+key+on+a+specific+column">Creating a foreign key on a specific column</h6> <pre class="ruby" data-language="ruby">add_foreign_key :articles, :users, column: :author_id, primary_key: "lng_id"
</pre> <p>generates:</p> <pre>ALTER TABLE "articles" ADD CONSTRAINT fk_rails_58ca3d3a82 FOREIGN KEY ("author_id") REFERENCES "users" ("lng_id")</pre> <h6 id="method-i-add_foreign_key-label-Creating+a+cascading+foreign+key">Creating a cascading foreign key</h6> <pre class="ruby" data-language="ruby">add_foreign_key :articles, :authors, on_delete: :cascade
</pre> <p>generates:</p> <pre>ALTER TABLE "articles" ADD CONSTRAINT fk_rails_e74ce85cbc FOREIGN KEY ("author_id") REFERENCES "authors" ("id") ON DELETE CASCADE</pre> <p>The <code>options</code> hash can include the following keys:</p> <dl class="rdoc-list label-list">
<dt>
<code>:column</code> </dt>
<dd> <p>The foreign key column name on <code>from_table</code>. Defaults to <code>to_table.singularize + "_id"</code></p> </dd>
<dt>
<code>:primary_key</code> </dt>
<dd> <p>The primary key column name on <code>to_table</code>. Defaults to <code>id</code>.</p> </dd>
<dt>
<code>:name</code> </dt>
<dd> <p>The constraint name. Defaults to <code>fk_rails_&lt;identifier&gt;</code>.</p> </dd>
<dt>
<code>:on_delete</code> </dt>
<dd> <p>Action that happens <code>ON DELETE</code>. Valid values are <code>:nullify</code>, <code>:cascade</code> and <code>:restrict</code></p> </dd>
<dt>
<code>:on_update</code> </dt>
<dd> <p>Action that happens <code>ON UPDATE</code>. Valid values are <code>:nullify</code>, <code>:cascade</code> and <code>:restrict</code></p> </dd>
<dt>
<code>:if_not_exists</code> </dt>
<dd> <p>Specifies if the foreign key already exists to not try to re-add it. This will avoid duplicate column errors.</p> </dd>
<dt>
<code>:validate</code> </dt>
<dd> <p>(PostgreSQL only) Specify whether or not the constraint should be validated. Defaults to <code>true</code>.</p> </dd>
<dt>
<code>:deferrable</code> </dt>
<dd> <p>(PostgreSQL only) Specify whether or not the foreign key should be deferrable. Valid values are booleans or <code>:deferred</code> or <code>:immediate</code> to specify the default behavior. Defaults to <code>false</code>.</p> </dd>
</dl>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-add_index"> <span class="method-name">add_index</span><span class="method-args">(table_name, column_name, **options)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="add_index-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 851
def add_index(table_name, column_name, **options)
  index, algorithm, if_not_exists = add_index_options(table_name, column_name, **options)

  create_index = CreateIndexDefinition.new(index, algorithm, if_not_exists)
  execute schema_creation.accept(create_index)
end</pre> </div> <p>Adds a new index to the table. <code>column_name</code> can be a single <span><code>Symbol</code></span>, or an <a href="../../array"><code>Array</code></a> of Symbols.</p> <p>The index will be named after the table and the column name(s), unless you pass <code>:name</code> as an option.</p> <h6 id="method-i-add_index-label-Creating+a+simple+index">Creating a simple index</h6> <pre class="ruby" data-language="ruby">add_index(:suppliers, :name)
</pre> <p>generates:</p> <pre class="ruby" data-language="ruby">CREATE INDEX index_suppliers_on_name ON suppliers(name)
</pre> <h6 id="method-i-add_index-label-Creating+a+index+which+already+exists">Creating a index which already exists</h6> <pre class="ruby" data-language="ruby">add_index(:suppliers, :name, if_not_exists: true)
</pre> <p>generates:</p> <pre class="ruby" data-language="ruby">CREATE INDEX IF NOT EXISTS index_suppliers_on_name ON suppliers(name)
</pre> <p>Note: Not supported by <span><code>MySQL</code></span>.</p> <h6 id="method-i-add_index-label-Creating+a+unique+index">Creating a unique index</h6> <pre class="ruby" data-language="ruby">add_index(:accounts, [:branch_id, :party_id], unique: true)
</pre> <p>generates:</p> <pre class="ruby" data-language="ruby">CREATE UNIQUE INDEX index_accounts_on_branch_id_and_party_id ON accounts(branch_id, party_id)
</pre> <h6 id="method-i-add_index-label-Creating+a+named+index">Creating a named index</h6> <pre class="ruby" data-language="ruby">add_index(:accounts, [:branch_id, :party_id], unique: true, name: 'by_branch_party')
</pre> <p>generates:</p> <pre class="ruby" data-language="ruby">CREATE UNIQUE INDEX by_branch_party ON accounts(branch_id, party_id)
</pre> <h6 id="method-i-add_index-label-Creating+an+index+with+specific+key+length">Creating an index with specific key length</h6> <pre class="ruby" data-language="ruby">add_index(:accounts, :name, name: 'by_name', length: 10)
</pre> <p>generates:</p> <pre class="ruby" data-language="ruby">CREATE INDEX by_name ON accounts(name(10))
</pre> <h6 id="method-i-add_index-label-Creating+an+index+with+specific+key+lengths+for+multiple+keys">Creating an index with specific key lengths for multiple keys</h6> <pre class="ruby" data-language="ruby">add_index(:accounts, [:name, :surname], name: 'by_name_surname', length: {name: 10, surname: 15})
</pre> <p>generates:</p> <pre class="ruby" data-language="ruby">CREATE INDEX by_name_surname ON accounts(name(10), surname(15))
</pre> <p>Note: only supported by <span><code>MySQL</code></span></p> <h6 id="method-i-add_index-label-Creating+an+index+with+a+sort+order+-28desc+or+asc-2C+asc+is+the+default-29">Creating an index with a sort order (desc or asc, asc is the default)</h6> <pre class="ruby" data-language="ruby">add_index(:accounts, [:branch_id, :party_id, :surname], name: 'by_branch_desc_party', order: {branch_id: :desc, party_id: :asc})
</pre> <p>generates:</p> <pre>CREATE INDEX by_branch_desc_party ON accounts(branch_id DESC, party_id ASC, surname)</pre> <p>Note: <span><code>MySQL</code></span> only supports index order from 8.0.1 onwards (earlier versions accepted the syntax but ignored it).</p> <h6 id="method-i-add_index-label-Creating+a+partial+index">Creating a partial index</h6> <pre class="ruby" data-language="ruby">add_index(:accounts, [:branch_id, :party_id], unique: true, where: "active")
</pre> <p>generates:</p> <pre>CREATE UNIQUE INDEX index_accounts_on_branch_id_and_party_id ON accounts(branch_id, party_id) WHERE active</pre> <p>Note: Partial indexes are only supported for PostgreSQL and SQLite.</p> <h6 id="method-i-add_index-label-Creating+an+index+with+a+specific+method">Creating an index with a specific method</h6> <pre class="ruby" data-language="ruby">add_index(:developers, :name, using: 'btree')
</pre> <p>generates:</p> <pre class="ruby" data-language="ruby">CREATE INDEX index_developers_on_name ON developers USING btree (name) -- PostgreSQL
CREATE INDEX index_developers_on_name USING btree ON developers (name) -- MySQL
</pre> <p>Note: only supported by PostgreSQL and <span><code>MySQL</code></span></p> <h6 id="method-i-add_index-label-Creating+an+index+with+a+specific+operator+class">Creating an index with a specific operator class</h6> <pre class="ruby" data-language="ruby">add_index(:developers, :name, using: 'gist', opclass: :gist_trgm_ops)
# CREATE INDEX developers_on_name ON developers USING gist (name gist_trgm_ops) -- PostgreSQL

add_index(:developers, [:name, :city], using: 'gist', opclass: { city: :gist_trgm_ops })
# CREATE INDEX developers_on_name_and_city ON developers USING gist (name, city gist_trgm_ops) -- PostgreSQL

add_index(:developers, [:name, :city], using: 'gist', opclass: :gist_trgm_ops)
# CREATE INDEX developers_on_name_and_city ON developers USING gist (name gist_trgm_ops, city gist_trgm_ops) -- PostgreSQL
</pre> <p>Note: only supported by PostgreSQL</p> <h6 id="method-i-add_index-label-Creating+an+index+with+a+specific+type">Creating an index with a specific type</h6> <pre class="ruby" data-language="ruby">add_index(:developers, :name, type: :fulltext)
</pre> <p>generates:</p> <pre class="ruby" data-language="ruby">CREATE FULLTEXT INDEX index_developers_on_name ON developers (name) -- MySQL
</pre> <p>Note: only supported by <span><code>MySQL</code></span>.</p> <h6 id="method-i-add_index-label-Creating+an+index+with+a+specific+algorithm">Creating an index with a specific algorithm</h6> <pre class="ruby" data-language="ruby">add_index(:developers, :name, algorithm: :concurrently)
# CREATE INDEX CONCURRENTLY developers_on_name on developers (name)
</pre> <p>Note: only supported by PostgreSQL.</p> <p>Concurrently adding an index is not supported in a transaction.</p> <p>For more information see the <a href="../migration">“Transactional Migrations” section</a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-add_reference"> <span class="method-name">add_reference</span><span class="method-args">(table_name, ref_name, **options)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="add_reference-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 988
def add_reference(table_name, ref_name, **options)
  ReferenceDefinition.new(ref_name, **options).add_to(update_table_definition(table_name, self))
end</pre> </div> <p>Adds a reference. The reference column is a bigint by default, the <code>:type</code> option can be used to specify a different type. Optionally adds a <code>_type</code> column, if <code>:polymorphic</code> option is provided. <a href="schemastatements#method-i-add_reference"><code>add_reference</code></a> and <a href="schemastatements#method-i-add_belongs_to"><code>add_belongs_to</code></a> are acceptable.</p> <p>The <code>options</code> hash can include the following keys:</p> <dl class="rdoc-list label-list">
<dt>
<code>:type</code> </dt>
<dd> <p>The reference column type. Defaults to <code>:bigint</code>.</p> </dd>
<dt>
<code>:index</code> </dt>
<dd> <p>Add an appropriate index. Defaults to true. See <a href="schemastatements#method-i-add_index"><code>add_index</code></a> for usage of this option.</p> </dd>
<dt>
<code>:foreign_key</code> </dt>
<dd> <p>Add an appropriate foreign key constraint. Defaults to false, pass true to add. In case the join table can't be inferred from the association pass <code>:to_table</code> with the appropriate table name.</p> </dd>
<dt>
<code>:polymorphic</code> </dt>
<dd> <p>Whether an additional <code>_type</code> column should be added. Defaults to false.</p> </dd>
<dt>
<code>:null</code> </dt>
<dd> <p>Whether the column allows nulls. Defaults to true.</p> </dd>
</dl> <h6 id="method-i-add_reference-label-Create+a+user_id+bigint+column+without+an+index">Create a user_id bigint column without an index</h6> <pre class="ruby" data-language="ruby">add_reference(:products, :user, index: false)
</pre> <h6 id="method-i-add_reference-label-Create+a+user_id+string+column">Create a user_id string column</h6> <pre class="ruby" data-language="ruby">add_reference(:products, :user, type: :string)
</pre> <h6 id="method-i-add_reference-label-Create+supplier_id-2C+supplier_type+columns">Create supplier_id, supplier_type columns</h6> <pre class="ruby" data-language="ruby">add_reference(:products, :supplier, polymorphic: true)
</pre> <h6 id="method-i-add_reference-label-Create+a+supplier_id+column+with+a+unique+index">Create a supplier_id column with a unique index</h6> <pre class="ruby" data-language="ruby">add_reference(:products, :supplier, index: { unique: true })
</pre> <h6 id="method-i-add_reference-label-Create+a+supplier_id+column+with+a+named+index">Create a supplier_id column with a named index</h6> <pre class="ruby" data-language="ruby">add_reference(:products, :supplier, index: { name: "my_supplier_index" })
</pre> <h6 id="method-i-add_reference-label-Create+a+supplier_id+column+and+appropriate+foreign+key">Create a supplier_id column and appropriate foreign key</h6> <pre class="ruby" data-language="ruby">add_reference(:products, :supplier, foreign_key: true)
</pre> <h6 id="method-i-add_reference-label-Create+a+supplier_id+column+and+a+foreign+key+to+the+firms+table">Create a supplier_id column and a foreign key to the firms table</h6> <pre class="ruby" data-language="ruby">add_reference(:products, :supplier, foreign_key: { to_table: :firms })
</pre>  </div> <div class="aliases"> Also aliased as: <a href="schemastatements#method-i-add_belongs_to">add_belongs_to</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-add_timestamps"> <span class="method-name">add_timestamps</span><span class="method-args">(table_name, **options)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="add_timestamps-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 1316
def add_timestamps(table_name, **options)
  options[:null] = false if options[:null].nil?

  if !options.key?(:precision) &amp;&amp; supports_datetime_with_precision?
    options[:precision] = 6
  end

  add_column table_name, :created_at, :datetime, **options
  add_column table_name, :updated_at, :datetime, **options
end</pre> </div> <p>Adds timestamps (<code>created_at</code> and <code>updated_at</code>) columns to <code>table_name</code>. Additional options (like <code>:null</code>) are forwarded to <a href="schemastatements#method-i-add_column"><code>add_column</code></a>.</p> <pre class="ruby" data-language="ruby">add_timestamps(:suppliers, null: true)
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-assume_migrated_upto_version"> <span class="method-name">assume_migrated_upto_version</span><span class="method-args">(version)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="assume_migrated_upto_version-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 1228
def assume_migrated_upto_version(version)
  version = version.to_i
  sm_table = quote_table_name(schema_migration.table_name)

  migrated = migration_context.get_all_versions
  versions = migration_context.migrations.map(&amp;:version)

  unless migrated.include?(version)
    execute "INSERT INTO #{sm_table} (version) VALUES (#{quote(version)})"
  end

  inserting = (versions - migrated).select { |v| v &lt; version }
  if inserting.any?
    if (duplicate = inserting.detect { |v| inserting.count(v) &gt; 1 })
      raise "Duplicate migration #{duplicate}. Please renumber your migrations to resolve the conflict."
    end
    execute insert_versions_sql(inserting)
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-change_column"> <span class="method-name">change_column</span><span class="method-args">(table_name, column_name, type, **options)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="change_column-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 679
def change_column(table_name, column_name, type, **options)
  raise NotImplementedError, "change_column is not implemented"
end</pre> </div> <p>Changes the column's definition according to the new options. See <a href="tabledefinition#method-i-column"><code>TableDefinition#column</code></a> for details of the options you can use.</p> <pre class="ruby" data-language="ruby">change_column(:suppliers, :name, :string, limit: 80)
change_column(:accounts, :description, :text)
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-change_column_comment"> <span class="method-name">change_column_comment</span><span class="method-args">(table_name, column_name, comment_or_changes)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="change_column_comment-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 1398
def change_column_comment(table_name, column_name, comment_or_changes)
  raise NotImplementedError, "#{self.class} does not support changing column comments"
end</pre> </div> <p>Changes the comment for a column or removes it if <code>nil</code>.</p> <p>Passing a hash containing <code>:from</code> and <code>:to</code> will make this change reversible in migration:</p> <pre class="ruby" data-language="ruby">change_column_comment(:posts, :state, from: "old_comment", to: "new_comment")
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-change_column_default"> <span class="method-name">change_column_default</span><span class="method-args">(table_name, column_name, default_or_changes)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="change_column_default-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 697
def change_column_default(table_name, column_name, default_or_changes)
  raise NotImplementedError, "change_column_default is not implemented"
end</pre> </div> <p>Sets a new default value for a column:</p> <pre class="ruby" data-language="ruby">change_column_default(:suppliers, :qualification, 'new')
change_column_default(:accounts, :authorized, 1)
</pre> <p>Setting the default to <code>nil</code> effectively drops the default:</p> <pre class="ruby" data-language="ruby">change_column_default(:users, :email, nil)
</pre> <p>Passing a hash containing <code>:from</code> and <code>:to</code> will make this change reversible in migration:</p> <pre class="ruby" data-language="ruby">change_column_default(:posts, :state, from: nil, to: "draft")
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-change_column_null"> <span class="method-name">change_column_null</span><span class="method-args">(table_name, column_name, null, default = nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="change_column_null-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 717
def change_column_null(table_name, column_name, null, default = nil)
  raise NotImplementedError, "change_column_null is not implemented"
end</pre> </div> <p>Sets or removes a <code>NOT NULL</code> constraint on a column. The <code>null</code> flag indicates whether the value can be <code>NULL</code>. For example</p> <pre class="ruby" data-language="ruby">change_column_null(:users, :nickname, false)
</pre> <p>says nicknames cannot be <code>NULL</code> (adds the constraint), whereas</p> <pre class="ruby" data-language="ruby">change_column_null(:users, :nickname, true)
</pre> <p>allows them to be <code>NULL</code> (drops the constraint).</p> <p>The method accepts an optional fourth argument to replace existing <code>NULL</code>s with some other value. Use that one when enabling the constraint if needed, since otherwise those rows would not be valid.</p> <p>Please note the fourth argument does not set a column's default.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-change_table"> <span class="method-name">change_table</span><span class="method-args">(table_name, **options) { |update_table_definition(table_name, recorder)| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="change_table-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 487
def change_table(table_name, **options)
  if supports_bulk_alter? &amp;&amp; options[:bulk]
    recorder = ActiveRecord::Migration::CommandRecorder.new(self)
    yield update_table_definition(table_name, recorder)
    bulk_change_table(table_name, recorder.commands)
  else
    yield update_table_definition(table_name, self)
  end
end</pre> </div> <p>A block for changing columns in <code>table</code>.</p> <pre class="ruby" data-language="ruby"># change_table() yields a Table instance
change_table(:suppliers) do |t|
  t.column :name, :string, limit: 60
  # Other column alterations here
end
</pre> <p>The <code>options</code> hash can include the following keys:</p> <dl class="rdoc-list label-list">
<dt>
<code>:bulk</code> </dt>
<dd> <p>Set this to true to make this a bulk alter query, such as</p> <pre>ALTER TABLE `users` ADD COLUMN age INT, ADD COLUMN birthdate DATETIME ...</pre> <p>Defaults to false.</p> <p>Only supported on the <span><code>MySQL</code></span> and PostgreSQL adapter, ignored elsewhere.</p> </dd>
</dl> <h6 id="method-i-change_table-label-Add+a+column">Add a column</h6> <pre class="ruby" data-language="ruby">change_table(:suppliers) do |t|
  t.column :name, :string, limit: 60
end
</pre> <h6 id="method-i-change_table-label-Change+type+of+a+column">Change type of a column</h6> <pre class="ruby" data-language="ruby">change_table(:suppliers) do |t|
  t.change :metadata, :json
end
</pre> <h6 id="method-i-change_table-label-Add+2+integer+columns">Add 2 integer columns</h6> <pre class="ruby" data-language="ruby">change_table(:suppliers) do |t|
  t.integer :width, :height, null: false, default: 0
end
</pre> <h6 id="method-i-change_table-label-Add+created_at-2Fupdated_at+columns">Add created_at/updated_at columns</h6> <pre class="ruby" data-language="ruby">change_table(:suppliers) do |t|
  t.timestamps
end
</pre> <h6 id="method-i-change_table-label-Add+a+foreign+key+column">Add a foreign key column</h6> <pre class="ruby" data-language="ruby">change_table(:suppliers) do |t|
  t.references :company
end
</pre> <p>Creates a <code>company_id(bigint)</code> column.</p> <h6 id="method-i-change_table-label-Add+a+polymorphic+foreign+key+column">Add a polymorphic foreign key column</h6> <pre class="ruby" data-language="ruby">change_table(:suppliers) do |t|
  t.belongs_to :company, polymorphic: true
end
</pre> <p>Creates <code>company_type(varchar)</code> and <code>company_id(bigint)</code> columns.</p> <h6 id="method-i-change_table-label-Remove+a+column">Remove a column</h6> <pre class="ruby" data-language="ruby">change_table(:suppliers) do |t|
  t.remove :company
end
</pre> <h6 id="method-i-change_table-label-Remove+several+columns">Remove several columns</h6> <pre class="ruby" data-language="ruby">change_table(:suppliers) do |t|
  t.remove :company_id
  t.remove :width, :height
end
</pre> <h6 id="method-i-change_table-label-Remove+an+index">Remove an index</h6> <pre class="ruby" data-language="ruby">change_table(:suppliers) do |t|
  t.remove_index :company_id
end
</pre> <p>See also <a href="table"><code>Table</code></a> for details on all of the various column transformations.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-change_table_comment"> <span class="method-name">change_table_comment</span><span class="method-args">(table_name, comment_or_changes)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="change_table_comment-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 1388
def change_table_comment(table_name, comment_or_changes)
  raise NotImplementedError, "#{self.class} does not support changing table comments"
end</pre> </div> <p>Changes the comment for a table or removes it if <code>nil</code>.</p> <p>Passing a hash containing <code>:from</code> and <code>:to</code> will make this change reversible in migration:</p> <pre class="ruby" data-language="ruby">change_table_comment(:posts, from: "old_comment", to: "new_comment")
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-check_constraints"> <span class="method-name">check_constraints</span><span class="method-args">(table_name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="check_constraints-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 1167
def check_constraints(table_name)
  raise NotImplementedError
end</pre> </div> <p>Returns an array of check constraints for the given table. The check constraints are represented as CheckConstraintDefinition objects.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-column_exists-3F"> <span class="method-name">column_exists?</span><span class="method-args">(table_name, column_name, type = nil, **options)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="column_exists-3F-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 138
def column_exists?(table_name, column_name, type = nil, **options)
  column_name = column_name.to_s
  checks = []
  checks &lt;&lt; lambda { |c| c.name == column_name }
  checks &lt;&lt; lambda { |c| c.type == type.to_sym rescue nil } if type
  column_options_keys.each do |attr|
    checks &lt;&lt; lambda { |c| c.send(attr) == options[attr] } if options.key?(attr)
  end

  columns(table_name).any? { |c| checks.all? { |check| check[c] } }
end</pre> </div> <p>Checks to see if a column exists in a given table.</p> <pre class="ruby" data-language="ruby"># Check a column exists
column_exists?(:suppliers, :name)

# Check a column exists of a particular type
#
# This works for standard non-casted types (eg. string) but is unreliable
# for types that may get cast to something else (eg. char, bigint).
column_exists?(:suppliers, :name, :string)

# Check a column exists with a specific definition
column_exists?(:suppliers, :name, :string, limit: 100)
column_exists?(:suppliers, :name, :string, default: 'default')
column_exists?(:suppliers, :name, :string, null: false)
column_exists?(:suppliers, :tax, :decimal, precision: 8, scale: 2)
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-columns"> <span class="method-name">columns</span><span class="method-args">(table_name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="columns-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 114
def columns(table_name)
  table_name = table_name.to_s
  column_definitions(table_name).map do |field|
    new_column_from_field(table_name, field)
  end
end</pre> </div> <p>Returns an array of <code>Column</code> objects for the table specified by <code>table_name</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-create_join_table"> <span class="method-name">create_join_table</span><span class="method-args">(table_1, table_2, column_options: {}, **options) { |td| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="create_join_table-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 384
def create_join_table(table_1, table_2, column_options: {}, **options)
  join_table_name = find_join_table_name(table_1, table_2, options)

  column_options.reverse_merge!(null: false, index: false)

  t1_ref, t2_ref = [table_1, table_2].map { |t| t.to_s.singularize }

  create_table(join_table_name, **options.merge!(id: false)) do |td|
    td.references t1_ref, **column_options
    td.references t2_ref, **column_options
    yield td if block_given?
  end
end</pre> </div> <p>Creates a new join table with the name created using the lexical order of the first two arguments. These arguments can be a <a href="../../string"><code>String</code></a> or a <span><code>Symbol</code></span>.</p> <pre class="ruby" data-language="ruby"># Creates a table called 'assemblies_parts' with no id.
create_join_table(:assemblies, :parts)
</pre> <p>You can pass an <code>options</code> hash which can include the following keys:</p> <dl class="rdoc-list label-list">
<dt>
<code>:table_name</code> </dt>
<dd> <p>Sets the table name, overriding the default.</p> </dd>
<dt>
<code>:column_options</code> </dt>
<dd> <p>Any extra options you want appended to the columns definition.</p> </dd>
<dt>
<code>:options</code> </dt>
<dd> <p>Any extra options you want appended to the table definition.</p> </dd>
<dt>
<code>:temporary</code> </dt>
<dd> <p>Make a temporary table.</p> </dd>
<dt>
<code>:force</code> </dt>
<dd> <p>Set to true to drop the table before creating it. Defaults to false.</p> </dd>
</dl> <p>Note that <a href="schemastatements#method-i-create_join_table"><code>create_join_table</code></a> does not create any indices by default; you can use its block form to do so yourself:</p> <pre class="ruby" data-language="ruby">create_join_table :products, :categories do |t|
  t.index :product_id
  t.index :category_id
end
</pre> <h6 id="method-i-create_join_table-label-Add+a+backend+specific+option+to+the+generated+SQL+-28MySQL-29">Add a backend specific option to the generated SQL ()</h6> <pre class="ruby" data-language="ruby">create_join_table(:assemblies, :parts, options: 'ENGINE=InnoDB DEFAULT CHARSET=utf8')
</pre> <p>generates:</p> <pre>CREATE TABLE assemblies_parts (
  assembly_id bigint NOT NULL,
  part_id bigint NOT NULL,
) ENGINE=InnoDB DEFAULT CHARSET=utf8</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-create_table"> <span class="method-name">create_table</span><span class="method-args">(table_name, id: :primary_key, primary_key: nil, force: nil, **options) { |td| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="create_table-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 299
def create_table(table_name, id: :primary_key, primary_key: nil, force: nil, **options)
  td = create_table_definition(table_name, **extract_table_options!(options))

  if id &amp;&amp; !td.as
    pk = primary_key || Base.get_primary_key(table_name.to_s.singularize)

    if id.is_a?(Hash)
      options.merge!(id.except(:type))
      id = id.fetch(:type, :primary_key)
    end

    if pk.is_a?(Array)
      td.primary_keys pk
    else
      td.primary_key pk, id, **options
    end
  end

  yield td if block_given?

  if force
    drop_table(table_name, force: force, if_exists: true)
  else
    schema_cache.clear_data_source_cache!(table_name.to_s)
  end

  result = execute schema_creation.accept td

  unless supports_indexes_in_create?
    td.indexes.each do |column_name, index_options|
      add_index(table_name, column_name, **index_options, if_not_exists: td.if_not_exists)
    end
  end

  if supports_comments? &amp;&amp; !supports_comments_in_create?
    if table_comment = td.comment.presence
      change_table_comment(table_name, table_comment)
    end

    td.columns.each do |column|
      change_column_comment(table_name, column.name, column.comment) if column.comment.present?
    end
  end

  result
end</pre> </div> <p>Creates a new table with the name <code>table_name</code>. <code>table_name</code> may either be a <a href="../../string"><code>String</code></a> or a <span><code>Symbol</code></span>.</p> <p>There are two ways to work with <a href="schemastatements#method-i-create_table"><code>create_table</code></a>. You can use the block form or the regular form, like this:</p> <h3 id="method-i-create_table-label-Block+form">Block form</h3> <pre class="ruby" data-language="ruby"># create_table() passes a TableDefinition object to the block.
# This form will not only create the table, but also columns for the
# table.

create_table(:suppliers) do |t|
  t.column :name, :string, limit: 60
  # Other fields here
end
</pre> <h3 id="method-i-create_table-label-Block+form-2C+with+shorthand">Block form, with shorthand</h3> <pre class="ruby" data-language="ruby"># You can also use the column types as method calls, rather than calling the column method.
create_table(:suppliers) do |t|
  t.string :name, limit: 60
  # Other fields here
end
</pre> <h3 id="method-i-create_table-label-Regular+form">Regular form</h3> <pre class="ruby" data-language="ruby"># Creates a table called 'suppliers' with no columns.
create_table(:suppliers)
# Add a column to 'suppliers'.
add_column(:suppliers, :name, :string, {limit: 60})
</pre> <p>The <code>options</code> hash can include the following keys:</p> <dl class="rdoc-list label-list">
<dt>
<code>:id</code> </dt>
<dd> <p>Whether to automatically add a primary key column. Defaults to true. Join tables for <a href="../associations/classmethods#method-i-has_and_belongs_to_many">ActiveRecord::Base.has_and_belongs_to_many</a> should set it to false.</p> <p>A <span><code>Symbol</code></span> can be used to specify the type of the generated primary key column.</p> </dd>
<dt>
<code>:primary_key</code> </dt>
<dd> <p>The name of the primary key, if one is to be added automatically. Defaults to <code>id</code>. If <code>:id</code> is false, then this option is ignored.</p> <p>If an array is passed, a composite primary key will be created.</p> <p>Note that Active Record models will automatically detect their primary key. This can be avoided by using <a href="../attributemethods/primarykey/classmethods#method-i-primary_key-3D">self.primary_key=</a> on the model to define the key explicitly.</p> </dd>
<dt>
<code>:options</code> </dt>
<dd> <p>Any extra options you want appended to the table definition.</p> </dd>
<dt>
<code>:temporary</code> </dt>
<dd> <p>Make a temporary table.</p> </dd>
<dt>
<code>:force</code> </dt>
<dd> <p>Set to true to drop the table before creating it. Set to <code>:cascade</code> to drop dependent objects as well. Defaults to false.</p> </dd>
<dt>
<code>:if_not_exists</code> </dt>
<dd> <p>Set to true to avoid raising an error when the table already exists. Defaults to false.</p> </dd>
<dt>
<code>:as</code> </dt>
<dd> <p>SQL to use to generate the table. When this option is used, the block is ignored, as are the <code>:id</code> and <code>:primary_key</code> options.</p> </dd>
</dl> <h6 id="method-i-create_table-label-Add+a+backend+specific+option+to+the+generated+SQL+-28MySQL-29">Add a backend specific option to the generated SQL ()</h6> <pre class="ruby" data-language="ruby">create_table(:suppliers, options: 'ENGINE=InnoDB DEFAULT CHARSET=utf8mb4')
</pre> <p>generates:</p> <pre>CREATE TABLE suppliers (
  id bigint auto_increment PRIMARY KEY
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4</pre> <h6 id="method-i-create_table-label-Rename+the+primary+key+column">Rename the primary key column</h6> <pre class="ruby" data-language="ruby">create_table(:objects, primary_key: 'guid') do |t|
  t.column :name, :string, limit: 80
end
</pre> <p>generates:</p> <pre>CREATE TABLE objects (
  guid bigint auto_increment PRIMARY KEY,
  name varchar(80)
)</pre> <h6 id="method-i-create_table-label-Change+the+primary+key+column+type">Change the primary key column type</h6> <pre class="ruby" data-language="ruby">create_table(:tags, id: :string) do |t|
  t.column :label, :string
end
</pre> <p>generates:</p> <pre>CREATE TABLE tags (
  id varchar PRIMARY KEY,
  label varchar
)</pre> <h6 id="method-i-create_table-label-Create+a+composite+primary+key">Create a composite primary key</h6> <pre class="ruby" data-language="ruby">create_table(:orders, primary_key: [:product_id, :client_id]) do |t|
  t.belongs_to :product
  t.belongs_to :client
end
</pre> <p>generates:</p> <pre>CREATE TABLE order (
    product_id bigint NOT NULL,
    client_id bigint NOT NULL
);

ALTER TABLE ONLY "orders"
  ADD CONSTRAINT orders_pkey PRIMARY KEY (product_id, client_id);</pre> <h6 id="method-i-create_table-label-Do+not+add+a+primary+key+column">Do not add a primary key column</h6> <pre class="ruby" data-language="ruby">create_table(:categories_suppliers, id: false) do |t|
  t.column :category_id, :bigint
  t.column :supplier_id, :bigint
end
</pre> <p>generates:</p> <pre>CREATE TABLE categories_suppliers (
  category_id bigint,
  supplier_id bigint
)</pre> <h6 id="method-i-create_table-label-Create+a+temporary+table+based+on+a+query">Create a temporary table based on a query</h6> <pre class="ruby" data-language="ruby">create_table(:long_query, temporary: true,
  as: "SELECT * FROM orders INNER JOIN line_items ON order_id=orders.id")
</pre> <p>generates:</p> <pre>CREATE TEMPORARY TABLE long_query AS
  SELECT * FROM orders INNER JOIN line_items ON order_id=orders.id</pre> <p>See also <a href="tabledefinition#method-i-column"><code>TableDefinition#column</code></a> for details on how to create columns.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-data_source_exists-3F"> <span class="method-name">data_source_exists?</span><span class="method-args">(name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="data_source_exists-3F-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 44
def data_source_exists?(name)
  query_values(data_source_sql(name), "SCHEMA").any? if name.present?
rescue NotImplementedError
  data_sources.include?(name.to_s)
end</pre> </div> <p>Checks to see if the data source <code>name</code> exists on the database.</p> <pre class="ruby" data-language="ruby">data_source_exists?(:ebooks)
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-data_sources"> <span class="method-name">data_sources</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="data_sources-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 34
def data_sources
  query_values(data_source_sql, "SCHEMA")
rescue NotImplementedError
  tables | views
end</pre> </div> <p>Returns the relation names usable to back Active Record models. For most adapters this means all <a href="schemastatements#method-i-tables"><code>tables</code></a> and <a href="schemastatements#method-i-views"><code>views</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-drop_join_table"> <span class="method-name">drop_join_table</span><span class="method-args">(table_1, table_2, **options)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="drop_join_table-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 404
def drop_join_table(table_1, table_2, **options)
  join_table_name = find_join_table_name(table_1, table_2, options)
  drop_table(join_table_name)
end</pre> </div> <p>Drops the join table specified by the given arguments. See <a href="schemastatements#method-i-create_join_table"><code>create_join_table</code></a> for details.</p> <p>Although this command ignores the block if one is given, it can be helpful to provide one in a migration's <code>change</code> method so it can be reverted. In that case, the block will be used by <a href="schemastatements#method-i-create_join_table"><code>create_join_table</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-drop_table"> <span class="method-name">drop_table</span><span class="method-args">(table_name, **options)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="drop_table-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 517
def drop_table(table_name, **options)
  schema_cache.clear_data_source_cache!(table_name.to_s)
  execute "DROP TABLE#{' IF EXISTS' if options[:if_exists]} #{quote_table_name(table_name)}"
end</pre> </div> <p>Drops a table from the database.</p> <dl class="rdoc-list label-list">
<dt>
<code>:force</code> </dt>
<dd> <p>Set to <code>:cascade</code> to drop dependent objects as well. Defaults to false.</p> </dd>
<dt>
<code>:if_exists</code> </dt>
<dd> <p>Set to <code>true</code> to only drop the table if it exists. Defaults to false.</p> </dd>
</dl> <p>Although this command ignores most <code>options</code> and the block if one is given, it can be helpful to provide these in a migration's <code>change</code> method so it can be reverted. In that case, <code>options</code> and the block will be used by <a href="schemastatements#method-i-create_table"><code>create_table</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-foreign_key_exists-3F"> <span class="method-name">foreign_key_exists?</span><span class="method-args">(from_table, to_table = nil, **options)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="foreign_key_exists-3F-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 1149
def foreign_key_exists?(from_table, to_table = nil, **options)
  foreign_key_for(from_table, to_table: to_table, **options).present?
end</pre> </div> <p>Checks to see if a foreign key exists on a table for a given foreign key definition.</p> <pre class="ruby" data-language="ruby"># Checks to see if a foreign key exists.
foreign_key_exists?(:accounts, :branches)

# Checks to see if a foreign key on a specified column exists.
foreign_key_exists?(:accounts, column: :owner_id)

# Checks to see if a foreign key with a custom name exists.
foreign_key_exists?(:accounts, name: "special_fk_name")
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-foreign_keys"> <span class="method-name">foreign_keys</span><span class="method-args">(table_name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="foreign_keys-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 1027
def foreign_keys(table_name)
  raise NotImplementedError, "foreign_keys is not implemented"
end</pre> </div> <p>Returns an array of foreign keys for the given table. The foreign keys are represented as ForeignKeyDefinition objects.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-index_exists-3F"> <span class="method-name">index_exists?</span><span class="method-args">(table_name, column_name, **options)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="index_exists-3F-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 99
def index_exists?(table_name, column_name, **options)
  checks = []

  if column_name.present?
    column_names = Array(column_name).map(&amp;:to_s)
    checks &lt;&lt; lambda { |i| Array(i.columns) == column_names }
  end

  checks &lt;&lt; lambda { |i| i.unique } if options[:unique]
  checks &lt;&lt; lambda { |i| i.name == options[:name].to_s } if options[:name]

  indexes(table_name).any? { |i| checks.all? { |check| check[i] } }
end</pre> </div> <p>Checks to see if an index exists on a table for a given index definition.</p> <pre class="ruby" data-language="ruby"># Check an index exists
index_exists?(:suppliers, :company_id)

# Check an index on multiple columns exists
index_exists?(:suppliers, [:company_id, :company_type])

# Check a unique index exists
index_exists?(:suppliers, :company_id, unique: true)

# Check an index with a custom name exists
index_exists?(:suppliers, :company_id, name: "idx_company_id")
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-index_name_exists-3F"> <span class="method-name">index_name_exists?</span><span class="method-args">(table_name, index_name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="index_name_exists-3F-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 935
def index_name_exists?(table_name, index_name)
  index_name = index_name.to_s
  indexes(table_name).detect { |i| i.name == index_name }
end</pre> </div> <p>Verifies the existence of an index with a given name.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-indexes"> <span class="method-name">indexes</span><span class="method-args">(table_name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="indexes-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 81
def indexes(table_name)
  raise NotImplementedError, "#indexes is not implemented"
end</pre> </div> <p>Returns an array of indexes for the given table.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-native_database_types"> <span class="method-name">native_database_types</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="native_database_types-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 14
def native_database_types
  {}
end</pre> </div> <p>Returns a hash of mappings from the abstract data types to the native database types. See <a href="tabledefinition#method-i-column"><code>TableDefinition#column</code></a> for details on the recognized abstract data types.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-options_include_default-3F"> <span class="method-name">options_include_default?</span><span class="method-args">(options)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="options_include_default-3F-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 1378
def options_include_default?(options)
  options.include?(:default) &amp;&amp; !(options[:null] == false &amp;&amp; options[:default].nil?)
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-primary_key"> <span class="method-name">primary_key</span><span class="method-args">(table_name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="primary_key-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 151
def primary_key(table_name)
  pk = primary_keys(table_name)
  pk = pk.first unless pk.size &gt; 1
  pk
end</pre> </div> <p>Returns just a table's primary key</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-remove_belongs_to"> <span class="method-name">remove_belongs_to</span><span class="method-args">(table_name, ref_name, foreign_key: false, polymorphic: false, **options)</span> </div>  <div class="aliases"> Alias for: <a href="schemastatements#method-i-remove_reference">remove_reference</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-remove_check_constraint"> <span class="method-name">remove_check_constraint</span><span class="method-args">(table_name, expression = nil, **options)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="remove_check_constraint-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 1208
def remove_check_constraint(table_name, expression = nil, **options)
  return unless supports_check_constraints?

  chk_name_to_delete = check_constraint_for!(table_name, expression: expression, **options).name

  at = create_alter_table(table_name)
  at.drop_check_constraint(chk_name_to_delete)

  execute schema_creation.accept(at)
end</pre> </div> <p>Removes the given check constraint from the table.</p> <pre class="ruby" data-language="ruby">remove_check_constraint :products, name: "price_check"
</pre> <p>The <code>expression</code> parameter will be ignored if present. It can be helpful to provide this in a migration's <code>change</code> method so it can be reverted. In that case, <code>expression</code> will be used by <a href="schemastatements#method-i-add_check_constraint"><code>add_check_constraint</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-remove_column"> <span class="method-name">remove_column</span><span class="method-args">(table_name, column_name, type = nil, **options)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="remove_column-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 667
def remove_column(table_name, column_name, type = nil, **options)
  return if options[:if_exists] == true &amp;&amp; !column_exists?(table_name, column_name)

  execute "ALTER TABLE #{quote_table_name(table_name)} #{remove_column_for_alter(table_name, column_name, type, **options)}"
end</pre> </div> <p>Removes the column from the table definition.</p> <pre class="ruby" data-language="ruby">remove_column(:suppliers, :qualification)
</pre> <p>The <code>type</code> and <code>options</code> parameters will be ignored if present. It can be helpful to provide these in a migration's <code>change</code> method so it can be reverted. In that case, <code>type</code> and <code>options</code> will be used by <a href="schemastatements#method-i-add_column"><code>add_column</code></a>. Depending on the database you're using, indexes using this column may be automatically removed or modified to remove this column from the index.</p> <p>If the options provided include an <code>if_exists</code> key, it will be used to check if the column does not exist. This will silently ignore the migration rather than raising if the column was already used.</p> <pre class="ruby" data-language="ruby">remove_column(:suppliers, :qualification, if_exists: true)
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-remove_columns"> <span class="method-name">remove_columns</span><span class="method-args">(table_name, *column_names, type: nil, **options)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="remove_columns-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 643
def remove_columns(table_name, *column_names, type: nil, **options)
  if column_names.empty?
    raise ArgumentError.new("You must specify at least one column name. Example: remove_columns(:people, :first_name)")
  end

  remove_column_fragments = remove_columns_for_alter(table_name, *column_names, type: type, **options)
  execute "ALTER TABLE #{quote_table_name(table_name)} #{remove_column_fragments.join(', ')}"
end</pre> </div> <p>Removes the given columns from the table definition.</p> <pre class="ruby" data-language="ruby">remove_columns(:suppliers, :qualification, :experience)
</pre> <p><code>type</code> and other column options can be passed to make migration reversible.</p> <pre class="ruby" data-language="ruby">remove_columns(:suppliers, :qualification, :experience, type: :string, null: false)
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-remove_foreign_key"> <span class="method-name">remove_foreign_key</span><span class="method-args">(from_table, to_table = nil, **options)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="remove_foreign_key-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 1126
def remove_foreign_key(from_table, to_table = nil, **options)
  return unless supports_foreign_keys?
  return if options[:if_exists] == true &amp;&amp; !foreign_key_exists?(from_table, to_table)

  fk_name_to_delete = foreign_key_for!(from_table, to_table: to_table, **options).name

  at = create_alter_table from_table
  at.drop_foreign_key fk_name_to_delete

  execute schema_creation.accept(at)
end</pre> </div> <p>Removes the given foreign key from the table. Any option parameters provided will be used to re-add the foreign key in case of a migration rollback. It is recommended that you provide any options used when creating the foreign key so that the migration can be reverted properly.</p> <p>Removes the foreign key on <code>accounts.branch_id</code>.</p> <pre class="ruby" data-language="ruby">remove_foreign_key :accounts, :branches
</pre> <p>Removes the foreign key on <code>accounts.owner_id</code>.</p> <pre class="ruby" data-language="ruby">remove_foreign_key :accounts, column: :owner_id
</pre> <p>Removes the foreign key on <code>accounts.owner_id</code>.</p> <pre class="ruby" data-language="ruby">remove_foreign_key :accounts, to_table: :owners
</pre> <p>Removes the foreign key named <code>special_fk_name</code> on the <code>accounts</code> table.</p> <pre class="ruby" data-language="ruby">remove_foreign_key :accounts, name: :special_fk_name
</pre> <p>Checks if the foreign key exists before trying to remove it. Will silently ignore indexes that don't exist.</p> <pre class="ruby" data-language="ruby">remove_foreign_key :accounts, :branches, if_exists: true
</pre> <p>The <code>options</code> hash accepts the same keys as <a href="schemastatements#method-i-add_foreign_key"><code>SchemaStatements#add_foreign_key</code></a> with an addition of</p> <dl class="rdoc-list label-list">
<dt>
<code>:to_table</code> </dt>
<dd> <p>The name of the table that contains the referenced primary key.</p> </dd>
</dl>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-remove_index"> <span class="method-name">remove_index</span><span class="method-args">(table_name, column_name = nil, **options)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="remove_index-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 894
def remove_index(table_name, column_name = nil, **options)
  return if options[:if_exists] &amp;&amp; !index_exists?(table_name, column_name, **options)

  index_name = index_name_for_remove(table_name, column_name, options)

  execute "DROP INDEX #{quote_column_name(index_name)} ON #{quote_table_name(table_name)}"
end</pre> </div> <p>Removes the given index from the table.</p> <p>Removes the index on <code>branch_id</code> in the <code>accounts</code> table if exactly one such index exists.</p> <pre class="ruby" data-language="ruby">remove_index :accounts, :branch_id
</pre> <p>Removes the index on <code>branch_id</code> in the <code>accounts</code> table if exactly one such index exists.</p> <pre class="ruby" data-language="ruby">remove_index :accounts, column: :branch_id
</pre> <p>Removes the index on <code>branch_id</code> and <code>party_id</code> in the <code>accounts</code> table if exactly one such index exists.</p> <pre class="ruby" data-language="ruby">remove_index :accounts, column: [:branch_id, :party_id]
</pre> <p>Removes the index named <code>by_branch_party</code> in the <code>accounts</code> table.</p> <pre class="ruby" data-language="ruby">remove_index :accounts, name: :by_branch_party
</pre> <p>Removes the index on <code>branch_id</code> named <code>by_branch_party</code> in the <code>accounts</code> table.</p> <pre class="ruby" data-language="ruby">remove_index :accounts, :branch_id, name: :by_branch_party
</pre> <p>Checks if the index exists before trying to remove it. Will silently ignore indexes that don't exist.</p> <pre class="ruby" data-language="ruby">remove_index :accounts, if_exists: true
</pre> <p>Removes the index named <code>by_branch_party</code> in the <code>accounts</code> table <code>concurrently</code>.</p> <pre class="ruby" data-language="ruby">remove_index :accounts, name: :by_branch_party, algorithm: :concurrently
</pre> <p>Note: only supported by PostgreSQL.</p> <p>Concurrently removing an index is not supported in a transaction.</p> <p>For more information see the <a href="../migration">“Transactional Migrations” section</a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-remove_reference"> <span class="method-name">remove_reference</span><span class="method-args">(table_name, ref_name, foreign_key: false, polymorphic: false, **options)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="remove_reference-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 1008
def remove_reference(table_name, ref_name, foreign_key: false, polymorphic: false, **options)
  if foreign_key
    reference_name = Base.pluralize_table_names ? ref_name.to_s.pluralize : ref_name
    if foreign_key.is_a?(Hash)
      foreign_key_options = foreign_key
    else
      foreign_key_options = { to_table: reference_name }
    end
    foreign_key_options[:column] ||= "#{ref_name}_id"
    remove_foreign_key(table_name, **foreign_key_options)
  end

  remove_column(table_name, "#{ref_name}_id")
  remove_column(table_name, "#{ref_name}_type") if polymorphic
end</pre> </div> <p>Removes the reference(s). Also removes a <code>type</code> column if one exists. <a href="schemastatements#method-i-remove_reference"><code>remove_reference</code></a> and <a href="schemastatements#method-i-remove_belongs_to"><code>remove_belongs_to</code></a> are acceptable.</p> <h6 id="method-i-remove_reference-label-Remove+the+reference">Remove the reference</h6> <pre class="ruby" data-language="ruby">remove_reference(:products, :user, index: false)
</pre> <h6 id="method-i-remove_reference-label-Remove+polymorphic+reference">Remove polymorphic reference</h6> <pre class="ruby" data-language="ruby">remove_reference(:products, :supplier, polymorphic: true)
</pre> <h6 id="method-i-remove_reference-label-Remove+the+reference+with+a+foreign+key">Remove the reference with a foreign key</h6> <pre class="ruby" data-language="ruby">remove_reference(:products, :user, foreign_key: true)
</pre>  </div> <div class="aliases"> Also aliased as: <a href="schemastatements#method-i-remove_belongs_to">remove_belongs_to</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-remove_timestamps"> <span class="method-name">remove_timestamps</span><span class="method-args">(table_name, **options)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="remove_timestamps-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 1331
def remove_timestamps(table_name, **options)
  remove_columns table_name, :updated_at, :created_at
end</pre> </div> <p>Removes the timestamp columns (<code>created_at</code> and <code>updated_at</code>) from the table definition.</p> <pre class="ruby" data-language="ruby">remove_timestamps(:suppliers)
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-rename_column"> <span class="method-name">rename_column</span><span class="method-args">(table_name, column_name, new_column_name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="rename_column-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 725
def rename_column(table_name, column_name, new_column_name)
  raise NotImplementedError, "rename_column is not implemented"
end</pre> </div> <p>Renames a column.</p> <pre class="ruby" data-language="ruby">rename_column(:suppliers, :description, :name)
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-rename_index"> <span class="method-name">rename_index</span><span class="method-args">(table_name, old_name, new_name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="rename_index-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 908
def rename_index(table_name, old_name, new_name)
  old_name = old_name.to_s
  new_name = new_name.to_s
  validate_index_length!(table_name, new_name)

  # this is a naive implementation; some DBs may support this more efficiently (PostgreSQL, for instance)
  old_index_def = indexes(table_name).detect { |i| i.name == old_name }
  return unless old_index_def
  add_index(table_name, old_index_def.columns, name: new_name, unique: old_index_def.unique)
  remove_index(table_name, name: old_name)
end</pre> </div> <p>Renames an index.</p> <p>Rename the <code>index_people_on_last_name</code> index to <code>index_users_on_last_name</code>:</p> <pre class="ruby" data-language="ruby">rename_index :people, 'index_people_on_last_name', 'index_users_on_last_name'
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-rename_table"> <span class="method-name">rename_table</span><span class="method-args">(table_name, new_name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="rename_table-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 501
def rename_table(table_name, new_name)
  raise NotImplementedError, "rename_table is not implemented"
end</pre> </div> <p>Renames a table.</p> <pre class="ruby" data-language="ruby">rename_table('octopuses', 'octopi')
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-table_alias_for"> <span class="method-name">table_alias_for</span><span class="method-args">(table_name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="table_alias_for-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 28
def table_alias_for(table_name)
  table_name[0...table_alias_length].tr(".", "_")
end</pre> </div> <p>Truncates a table alias according to the limits of the current adapter.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-table_comment"> <span class="method-name">table_comment</span><span class="method-args">(table_name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="table_comment-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 23
def table_comment(table_name)
  nil
end</pre> </div> <p>Returns the table comment that's stored in database metadata.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-table_exists-3F"> <span class="method-name">table_exists?</span><span class="method-args">(table_name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="table_exists-3F-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 59
def table_exists?(table_name)
  query_values(data_source_sql(table_name, type: "BASE TABLE"), "SCHEMA").any? if table_name.present?
rescue NotImplementedError
  tables.include?(table_name.to_s)
end</pre> </div> <p>Checks to see if the table <code>table_name</code> exists on the database.</p> <pre class="ruby" data-language="ruby">table_exists?(:developers)
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-table_options"> <span class="method-name">table_options</span><span class="method-args">(table_name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="table_options-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 18
def table_options(table_name)
  nil
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-tables"> <span class="method-name">tables</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="tables-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 51
def tables
  query_values(data_source_sql(type: "BASE TABLE"), "SCHEMA")
end</pre> </div> <p>Returns an array of table names defined in the database.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-view_exists-3F"> <span class="method-name">view_exists?</span><span class="method-args">(view_name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="view_exists-3F-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 74
def view_exists?(view_name)
  query_values(data_source_sql(view_name, type: "VIEW"), "SCHEMA").any? if view_name.present?
rescue NotImplementedError
  views.include?(view_name.to_s)
end</pre> </div> <p>Checks to see if the view <code>view_name</code> exists on the database.</p> <pre class="ruby" data-language="ruby">view_exists?(:ebooks)
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-views"> <span class="method-name">views</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="views-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 66
def views
  query_values(data_source_sql(type: "VIEW"), "SCHEMA")
end</pre> </div> <p>Returns an array of view names defined in the database.</p>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    © 2004–2021 David Heinemeier Hansson<br>Licensed under the MIT License.<br>
    
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
